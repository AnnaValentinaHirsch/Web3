*GitHub Repository "GaloisField2718/DAO4SocialAccount"*

'''--- .github/workflows/build.yml ---
name: Build
on:
  # (you may add filters for when running the workflow)
  push:
    branches:
      - main
  pull_request:
env:
  # better visualization
  CARGO_TERM_COLOR: always
jobs:
  # the first job is used to acquire some tag-naming information
  #
  # this snippet was based on:
  # https://raw.githubusercontent.com/BurntSushi/ripgrep/master/.github/workflows/release.yml
  # in case a tag was set, a binary release will be made
  create-release-on-tags:
    name: Create a new release on tags
    runs-on: ubuntu-latest
    # env:
      # Set to force version number, e.g., when no tag exists.
      # RG_VERSION: TEST-0.0.0
    outputs:
      rg_version: ${{ env.RG_VERSION }}
    steps:
      - name: Get the release version from the tag
        shell: bash
        if: env.RG_VERSION == ''
        run: |
          # Apparently, this is the right way to get a tag name. Really?
          #
          # See: https://github.community/t5/GitHub-Actions/How-to-get-just-the-tag-name/m-p/32167/highlight/true#M1027
          echo "RG_VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
          echo "version is: ${{ env.RG_VERSION }}"

  # this second job builds and tests the contracts
  # if it's a tag release, it also creates their release file
  build:
    # in case this is a binary release, we make sure to wait
    # for any requirement to be ready
    needs: ['create-release-on-tags']
    runs-on: ubuntu-latest
    steps:
      # rust compiler for running tests
      - uses: actions/checkout@v2
      - name: Install latest stable (for linux-gnu)
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: x86_64-unknown-linux-gnu
          components: rustfmt, clippy
      # rust compiler for creating binaries
      - name: Install latest stable (for wasm)
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
          components: rustfmt, clippy
      # caching (cargo registry)
      - name: Cache cargo registry
        uses: actions/cache@v1
        with:
          path: ~/.cargo/registry
          key: ubuntu-latest-stable-cargo-registry-${{ hashFiles('**/Cargo.toml') }}
      # caching (cargo index)
      - name: Cache cargo index
        uses: actions/cache@v1
        with:
          path: ~/.cargo/git
          key: ubuntu-latest-stable-cargo-index-${{ hashFiles('**/Cargo.toml') }}
      # caching (cargo wasm artifacts)
      - name: Cache cargo wasm build (including docs)
        uses: actions/cache@v1
        with:
          path: target/wasm32-unknown-unknown
          key: ubuntu-latest-stable-cargo-release-target-${{ hashFiles('**/Cargo.toml') }}
      # caching (cargo testing artifacts)
      - name: Cache cargo linux-gnu build (for testing)
        uses: actions/cache@v1
        with:
          path: target/x86_64-unknown-linux-gnu
          key: ubuntu-latest-stable-cargo-release-target-${{ hashFiles('**/Cargo.toml') }}
      # downloads/installs any extra requirements
      #
      # binaryen, which is used to reduce the contract's size.
      # based on:
      # https://github.com/rustwasm/walrus/blob/9d6c9de432d6a97478dc76ebdf18aed51584c3af/.github/workflows/main.yml#L56
      - name: Install binaryen
        run: |
          set -e
          curl -L https://github.com/WebAssembly/binaryen/releases/download/version_105/binaryen-version_105-x86_64-linux.tar.gz | tar xzf -
          echo "`pwd`/binaryen-version_105/bin" >> $GITHUB_PATH
      # triggers all build.rs steps
      - name: Trigger build.rs steps
        run: |
          find . \
            -maxdepth 2 \
            -name build.rs  \
            -prune \
            -exec touch -c {} \;
      # Builds the wasm binaries
      - name: Build wasm binaries
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release --target wasm32-unknown-unknown
      # Copies the wasm binaries to res/ and strips them 
      # (reducing their's sizes)
      - name: Wasm copy and strip
        run: |
          find target/wasm32-unknown-unknown/release \
            -maxdepth 1 \
            -name \*.wasm \
            -prune \
            -exec cp {} res \;
          for f in res/*.wasm
          do
            wasm-opt -Oz -o "$f" "$f"
          done
      - name: Show the wasm files and their sizes
        run: |
          ls -lah res/*.wasm | awk '{print $5 " " $9}'
      # run the tests (which depend on the binaries from res/)
      - name: Run native tests
        uses: actions-rs/cargo@v1
        with:
          command: test
          # the jobs is optional, to reduce RAM usage
          # the --nocapture prints the tests' stdout
          args: --target=x86_64-unknown-linux-gnu --jobs=2 -- --nocapture
      # for tagged runs, create an archive releaseruns
      #
      # based on:
      # https://raw.githubusercontent.com/BurntSushi/ripgrep/master/.github/workflows/release.yml
      - name: Build archive
        if: startsWith(github.ref, 'refs/tags')
        shell: bash
        run: |
          staging="contracts-${{ needs.create-release-on-tags.outputs.rg_version }}"
          mkdir -p "$staging/info"
          # copy all markdown files
          find . -name \*.md -not -path "./target/*" -prune -not -path "./$staging/*" -prune -exec cp --parents {} "$staging/info/" \;
          # copy all wasm files
          cp res/*.wasm "$staging/"
          # save the tag name and git sha to the VERSION file
          echo ${{ needs.create-release-on-tags.outputs.rg_version }} >> "$staging/info/VERSION"
          git rev-parse HEAD >> "$staging/info/VERSION"
          tar czf "$staging.tar.gz" "$staging"
          echo "ASSET=$staging.tar.gz" >> $GITHUB_ENV
      - name: Upload release archive
        if: startsWith(github.ref, 'refs/tags')
        uses: softprops/action-gh-release@v1
        with:
          files: |
            ${{ env.ASSET }}

'''
'''--- .github/workflows/tests.yml ---
name: Tests
on:
  push:
    branches:
      - main
  pull_request:
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Build
        env:
          IS_GITHUB_ACTION: true
        run: cargo +stable build --workspace --target wasm32-unknown-unknown --release
      - name: Run Cargo tests
        env:
          IS_GITHUB_ACTION: true
        run: cargo test --workspace -- --nocapture
      - name: Run Ava tests
        env:
          IS_GITHUB_ACTION: true
        run: cd sputnikdao2 && sh test.sh
'''
'''--- Cargo.toml ---
[workspace]
# include a member for each contract
members = [
  "sputnik-staking",
  "sputnikdao2",
  "sputnikdao2-gasfix",
  "sputnikdao-factory2",
  "test-token"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = true
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- README.md ---
Submission to : Governance

Topics related : Web2 to Web3, Technical content, Future of work

## Inspiration
Problematic of Social Media management.

**Solve problem for a community to organise their social network accounts by themselves.**

Many associations and human organisations have to own a social network page. For necessities, for facilities or for many other reasons, an association can need to have a social network page. 
And in some cases, the association can want to use an horizontal way to manage theses accounts. 

So from this problem we can about three solutions. 

Level 1 : To use actual tools offer by a DAO (proposal, bounty and rights permissions) to make it. The DAO by its rules decide an action to make on social network account through vote kind proposal. After, the community always through the DAO decides an IP address will made the action. If he doesn't made it, he isn't rewarded and apply some restrictions in accordance to the rules of the community. 

Level 2 :  To link DAO with an API social account (like twitter or reddit) and automate publication through Function Call option in the DAO. 
Each member can vote depends on his rights in the DAO, determined by the association. 

Level 3 : To link a DAO with a Web3 social account as myriad on octopus network.
This can be easier because apparently everything are on-chain

## What it does

Level 1 : We are providing a documentation for association wants to onboard with DAOs. It is doing on AstroDAO. The goal is really accessibility for not crypto users. 
We want that people don't think about Blockchain. Don't think about 'what is it ?', 'what is mean blockchain?'. 
Just use IF IT'S USEFUL FOR YOU. 
For example in a little association, it can be hard to control who did something with the social accounts that are often shared to allow more reactivity.

Level 2 (Detailing our Proof of Concept) :  An association could put a proposal with type `post` and `content` of its, as : 
```bash
near call $MY_DAO add_proposal '{
  "proposal" : {
             "kind" : {
                      "post" : {
                                       "content" : "I want to make this, post on twitter account of the association. I WILL SUCCESSSSS !!!"
                                      }
                             }
                         }
}' --accountId my-account.near 
```
We have the idea to use a python code to check if a certain transaction happen on the contract and so act on the web by the way of the contract tell. 
We need to do something like that : 
```python
if proposal_approved == true : 
      text_posted = proposal_description
      make : post_with_api(text_posted)
else
     do_nothing
```
With a such code we can link the dao wallet and API social account in the python code, make run the python code by a crontab job and proposals on dao should act as wanted. 

Level 3 : If there exists a contract of a social web3 app (compatible with near) we can just make a call from FunctionCall proposal kind. When proposal is approved, DAO will make the request automatically (for example make a post on this app).  

## How we built it

Level 1 : A doc as easy as possible, with most informations on 'how to onboard' possible.

Level 2 : We made a schema for the Proof of Concept with core idea of the API use. 

Level 3 : We made abstract contract to show attempted interactions. 
 
## Challenges we ran into

Level 1 : Difficulty to be exhaustive in this time range. 

Level 2 : Impossibility to find a contract to make an API call for us. We didn't success to develop one by themselves.

Level 3 : Difficulties with near integrations on some appchains (use myriad contract from a _near call_). It's an ecosystem which exponentially growth and as Illia told in his Keynote : "We still need to find combinations with Web3 primitives". 

## Accomplishments that we're proud of

Level 1 : As the doc is not complete. It's really one of our main goal to onboard new people who has truly need of the blockchain without know it before. Maybe we can find totally new use never mind before (as in Open Forest Protocol, we can see people who use it to prove the ownership of a Forest (in Brazil). This is a not thinking use case before but it's a useful way to prove ownership and existants of the Forest in an open-source and verifiable 

Level 3 : This integration can allow a true network effect across communities. It can onboard near-user in new Social Web3 App in providing DAO content related. 

## What we learned

We learned a lot through the different challenges we ran into, especially on how to interact with the different dapps in the near ecosystem.
We also learned how to create a bridge between the web2 world and the near ecosystem.

## What's next for DAO4SocialAccount

Level 3 : This can enhance the content available in web3 Social media like Myriad or Social08. If the submission of posts aren’t made by an individual, it’s easy to publish them on a lot of platforms at the same time (for instance on twitter and myriad). This would bring a lot of contents to those emerging platforms, and help users transition into them without losing the content they are used to see.

Another step is to find organisations willing to try our solution and give us feedbacks. We know some little associations, such as local food banks, that would be interested.

If we can even give them some near for their DAO creation, that would be huge. Once they're onboarded onto our decentralized social media product, they would be just one small step to fully transfert into a DAO format for all their other needs.

## LINKS
**Youtube** : https://www.youtube.com/watch?v=bjp4fmTr-k8
**Slides** : https://docs.google.com/presentation/d/1W53uEVnVQTWjG7pexAofirLmDdcpLB_d4pzt98f_3NU/edit?usp=sharing

'''
'''--- build.sh ---
#!/bin/bash
set -e

cargo +stable build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/sputnik_staking.wasm ./sputnik-staking/res/
cp target/wasm32-unknown-unknown/release/sputnikdao2.wasm ./sputnikdao2/res/
cp target/wasm32-unknown-unknown/release/sputnikdao2_gasfix.wasm ./sputnikdao2-gasfix/res/
cp target/wasm32-unknown-unknown/release/sputnikdao_factory2.wasm ./sputnikdao-factory2/res/
cp target/wasm32-unknown-unknown/release/test_token.wasm ./test-token/res/
'''
'''--- scripts/deploy_factory_gasfix_testnet.sh ---
#!/bin/bash
set -e

# TODO: Change to the official approved commit:
# COMMIT_V3=596f27a649c5df3310e945a37a41a957492c0322
COMMIT_V3=TBD_SEE_COMMIT_ONCE_LIVE
# git checkout $COMMIT_V3

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnikv2.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

# export FACTORY_ACCOUNT_ID=daofactory.$NEAR_ACCT
export FACTORY_ACCOUNT_ID=$NEAR_ACCT
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
export GAS_220_TGAS=220000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000
COMMIT_V2=
V2_CODE_HASH=8RMeZ5cXDap6TENxaJKtigRYf3n139iHmTRe8ZUNey6N
COMMIT_V2A=UNOFFICIAL_SCRIPT_DATA
V2A_CODE_HASH=8LN56HLNjvwtiNb6pRVNSTMtPgJYqGjAgkVSHRiK5Wfv
COMMIT_V3=640495ba572345ca356376989738fbd5462e1ff8
V3_CODE_HASH=783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

# NOTE: Only needed if deploying NEW factory
# #### --------------------------------------------
# #### Account & Data management for setup
# #### --------------------------------------------
# # near call $FACTORY_ACCOUNT_ID delete_contract '{"code_hash":"6SQymHtmezR3u9zAtLBQdb8RWCXxwxnigqSH2mRTxecB"}' --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS
# # near delete $FACTORY_ACCOUNT_ID $NEAR_ACCT
# near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 80
# #### --------------------------------------------

# # NOTE: Only needed if deploying NEW factory
# #### --------------------------------------------
# #### Grab the factory v2 code data
# #### --------------------------------------------
# http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
# params:='{"request_type":"view_code","finality":"final","account_id":"'sputnikv2.$FACTORY'"}' \
# | jq -r .result.code_base64 \
# | base64 --decode > sputnikdao_factory2_original.wasm

# # Deploy the previous version to allow accurate testing
# near deploy --wasmFile sputnikdao_factory2_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
# #### --------------------------------------------

#### --------------------------------------------
#### Upgrade the factory
#### NOTE: Make sure you've built on the right commit!
#### --------------------------------------------
near deploy --wasmFile sputnikdao-factory2/res/sputnikdao_factory2.wasm --accountId $FACTORY_ACCOUNT_ID --force
#### --------------------------------------------

#### --------------------------------------------
#### Grab the DAO v2 code data & store it in factory
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"genesis.sputnikv2.testnet"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao2_original.wasm

# Store the code data
V2_BYTES='cat sputnikdao2_original.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2_CODE_HASH=$(eval "tail -1 v2_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2 CODE HASH: $V2_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2_CODE_HASH'", "metadata": {"version": [2,0], "commit_id": "c2cf1553b070d04eed8f659571440b27d398c588"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v2a code data & store it in factory
#### Keep this around for gas-fixes version
#### NOTE: This doesnt really fix the upgrade path post neard 1.26.0 - those v2 DAOs will be stuck
#### --------------------------------------------
# Store the code data
V2A_BYTES='cat sputnikdao2-gasfix/res/sputnikdao2_gasfix.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2A_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2a_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2A_CODE_HASH=$(eval "tail -1 v2a_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2A CODE HASH: $V2A_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2A_CODE_HASH'", "metadata": {"version": [2,1], "commit_id": "'$COMMIT_V2A'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v3 code data & store it in factory
#### --------------------------------------------
# Store the code data
V3_BYTES='cat sputnikdao2/res/sputnikdao2.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V3_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v3_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V3_CODE_HASH'", "metadata": {"version": [3,0], "commit_id": "'$COMMIT_V3'"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

# #### --------------------------------------------
# #### Sanity check the new metadata
# #### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
# #### --------------------------------------------

#### --------------------------------------------
#### Deploy a v2 gasfix DAO & Some proposals
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=sputnik-v2-gasfix-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "Sputnik GasFix v2 DAO '$TIMESTAMP'", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 14
DAO_ACCOUNT_ID=$DAO_NAME.$FACTORY_ACCOUNT_ID

# some sample payouts
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "13370000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "10000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "20000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DAO_ACCOUNT_ID act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
near call $DAO_ACCOUNT_ID act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
near view $DAO_ACCOUNT_ID get_proposal '{"id": 2}'
#### --------------------------------------------

#### --------------------------------------------
#### Quick sanity check on getters
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Proposal
#### --------------------------------------------
# 783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

UPGRADE_PROPOSAL_ARGS=`echo '{"code_hash":"783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5"}' | base64`
# propose UpgradeSelf using the code_hash from store_blob
near call $DAO_ACCOUNT_ID add_proposal '{
  "proposal": {
    "description": "Upgrade to v3 DAO code using upgrade contract via factory",
    "kind": {
      "FunctionCall": {
        "receiver_id": "'$FACTORY_ACCOUNT_ID'",
        "actions": [
          {
            "method_name": "store_contract_self",
            "args": "'$UPGRADE_PROPOSAL_ARGS'",
            "deposit": "'$BYTE_STORAGE_COST'",
            "gas": "'$GAS_220_TGAS'"
          }
        ]
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $DAO_ACCOUNT_ID act_proposal '{"id": 3, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 3}'
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade a v2a DAO to v3
#### --------------------------------------------
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "Upgrade V3 CODE HASH: $V3_CODE_HASH"
# some sample payouts
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Upgrade to v3", "kind": { "UpgradeSelf": { "hash": "'$V3_CODE_HASH'" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DAO_ACCOUNT_ID act_proposal '{"id": 4, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 4}'
#### --------------------------------------------

#### --------------------------------------------
#### Remove cached blob DAO Proposal
#### --------------------------------------------
# 783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

REMOVE_PROPOSAL_ARGS=`echo '{"code_hash":"783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5"}' | base64`
# propose UpgradeSelf using the code_hash from store_blob
near call $DAO_ACCOUNT_ID add_proposal '{
  "proposal": {
    "description": "Remove DAO upgrade contract local code blob via factory",
    "kind": {
      "FunctionCall": {
        "receiver_id": "'$FACTORY_ACCOUNT_ID'",
        "actions": [
          {
            "method_name": "remove_contract_self",
            "args": "'$REMOVE_PROPOSAL_ARGS'",
            "deposit": "0",
            "gas": "'$GAS_220_TGAS'"
          }
        ]
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $DAO_ACCOUNT_ID act_proposal '{"id": 5, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 5}'
#### --------------------------------------------

#### --------------------------------------------
#### Deploy a v3 DAO & Some proposals
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=sputnikdao-dev-v3-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "Sputnik Dev v3 DAO '$TIMESTAMP'", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 12
DEMO_DAO_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID

# Quick check for v3 DAO
near view $DEMO_DAO_ACCOUNT get_available_amount

# some sample payouts
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "1000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "2000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "3000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DEMO_DAO_ACCOUNT act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
near call $DEMO_DAO_ACCOUNT act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DEMO_DAO_ACCOUNT get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check v3 dao all worked
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm sputnikdao2_original.wasm
rm sputnikdao_factory2_original.wasm
rm v2_code_hash_result.txt
rm v2a_code_hash_result.txt
rm v3_code_hash_result.txt

echo "Dev Factory Deploy & Test Complete"
'''
'''--- scripts/deploy_factory_mainnet.sh ---
#!/bin/bash
set -e

# build the things
./build.sh

export NEAR_ENV=mainnet
export FACTORY=near

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=daofactory.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=$NEAR_ACCT
# export FACTORY_ACCOUNT_ID=subfactory.$NEAR_ACCT
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
export GAS_220_TGAS=220000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000
COMMIT_V2=c2cf1553b070d04eed8f659571440b27d398c588
V2_CODE_HASH=8RMeZ5cXDap6TENxaJKtigRYf3n139iHmTRe8ZUNey6N
COMMIT_V2A=UNOFFICIAL_SCRIPT_DATA
V2A_CODE_HASH=8LN56HLNjvwtiNb6pRVNSTMtPgJYqGjAgkVSHRiK5Wfv
COMMIT_V3=640495ba572345ca356376989738fbd5462e1ff8
V3_CODE_HASH=783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

# #### --------------------------------------------
# #### Account & Data management for setup
# #### --------------------------------------------
# near call $FACTORY_ACCOUNT_ID delete_contract '{"code_hash":"'$V3_CODE_HASH'"}' --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS
# near delete $FACTORY_ACCOUNT_ID $NEAR_ACCT
# near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 62
# #### --------------------------------------------

#### --------------------------------------------
#### Grab the factory v2 code data
#### --------------------------------------------
http --json post https://rpc.mainnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'sputnik-dao.$FACTORY'"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao_factory2_original.wasm

# Deploy the previous version to allow accurate testing
near deploy --wasmFile sputnikdao_factory2_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
#### --------------------------------------------

#### --------------------------------------------
#### Deploy a v2 DAO & Some proposals
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=sputnikdao-v2-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "Upgrade V2 DAO '$TIMESTAMP'", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 12
DAO_ACCOUNT_ID=$DAO_NAME.$FACTORY_ACCOUNT_ID

# some sample payouts
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "13370000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "10000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "20000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DAO_ACCOUNT_ID act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
near call $DAO_ACCOUNT_ID act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Quick sanity check on getters
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade the factory
#### NOTE: Make sure you've built on the right commit!
#### --------------------------------------------
near deploy --wasmFile sputnikdao-factory2/res/sputnikdao_factory2.wasm --accountId $FACTORY_ACCOUNT_ID --force
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v2a code data & store it in factory
#### Keep this around for gas-fixes version
#### NOTE: This doesnt really fix the upgrade path post neard 1.26.0 - those v2 DAOs will be stuck
#### --------------------------------------------
# Store the code data
V2A_BYTES='cat sputnikdao2-gasfix/res/sputnikdao2_gasfix.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2A_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2a_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2A_CODE_HASH=$(eval "tail -1 v2a_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2A CODE HASH: $V2A_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2A_CODE_HASH'", "metadata": {"version": [2,1], "commit_id": "'$COMMIT_V2A'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v3 code data & store it in factory
#### --------------------------------------------
# Store the code data
V3_BYTES='cat sputnikdao2/res/sputnikdao2.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V3_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 6 > v3_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V3_CODE_HASH'", "metadata": {"version": [3,0], "commit_id": "'$COMMIT_V3'"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata & DAO
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
#### --------------------------------------------

#### --------------------------------------------
#### Deploy a v2a DAO & Some proposals
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=sputnikdao-v2a-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "Upgrade Gasfix DAO '$TIMESTAMP'", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 12
GASDAO_ACCOUNT_ID=$DAO_NAME.$FACTORY_ACCOUNT_ID

# some sample payouts
near call $GASDAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "13370000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $GASDAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "10000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $GASDAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "20000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $GASDAO_ACCOUNT_ID act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
near call $GASDAO_ACCOUNT_ID act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $GASDAO_ACCOUNT_ID get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Quick sanity check on getters
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm sputnikdao2_original.wasm
rm sputnikdao_factory2_original.wasm
rm v2_code_hash_result.txt
rm v2a_code_hash_result.txt
rm v3_code_hash_result.txt

echo "Mainnet Factory Deploy & Test Complete"

'''
'''--- scripts/deploy_factory_testnet.sh ---
#!/bin/bash
set -e

# TODO: Change to the official approved commit:
# COMMIT_V3=596f27a649c5df3310e945a37a41a957492c0322
COMMIT_V3=TBD_SEE_COMMIT_ONCE_LIVE
# git checkout $COMMIT_V3

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnikv2.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=sputnikv2.$NEAR_ACCT
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000
COMMIT_V2=c2cf1553b070d04eed8f659571440b27d398c588
V2_CODE_HASH=8RMeZ5cXDap6TENxaJKtigRYf3n139iHmTRe8ZUNey6N
COMMIT_V2A=UNOFFICIAL_SCRIPT_DATA
V2A_CODE_HASH=8LN56HLNjvwtiNb6pRVNSTMtPgJYqGjAgkVSHRiK5Wfv
COMMIT_V3=640495ba572345ca356376989738fbd5462e1ff8
V3_CODE_HASH=783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

# NOTE: Only needed if deploying NEW factory
# #### --------------------------------------------
# #### Account & Data management for setup
# #### --------------------------------------------
# # near call $FACTORY_ACCOUNT_ID delete_contract '{"code_hash":"6SQymHtmezR3u9zAtLBQdb8RWCXxwxnigqSH2mRTxecB"}' --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS
# # near delete $FACTORY_ACCOUNT_ID $NEAR_ACCT
# near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 80
# #### --------------------------------------------

# NOTE: Only needed if deploying NEW factory
# #### --------------------------------------------
# #### Grab the factory v2 code data
# #### --------------------------------------------
# http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
# params:='{"request_type":"view_code","finality":"final","account_id":"'sputnikv2.$FACTORY'"}' \
# | jq -r .result.code_base64 \
# | base64 --decode > sputnikdao_factory2_original.wasm

# # Deploy the previous version to allow accurate testing
# near deploy --wasmFile sputnikdao_factory2_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
# #### --------------------------------------------

#### --------------------------------------------
#### Deploy a v2 DAO & Some proposals
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=sputnikdao-dev-v2-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "Sputnik Dev v2 DAO '$TIMESTAMP'", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 10
DAO_ACCOUNT_ID=$DAO_NAME.$FACTORY_ACCOUNT_ID

# some sample payouts
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "1337000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "1000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "2000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DAO_ACCOUNT_ID act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
near call $DAO_ACCOUNT_ID act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Quick sanity check on getters
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade the factory
#### NOTE: Make sure you've built on the right commit!
#### --------------------------------------------
near deploy --wasmFile sputnikdao-factory2/res/sputnikdao_factory2.wasm --accountId $FACTORY_ACCOUNT_ID --force
#### --------------------------------------------

#### --------------------------------------------
#### Grab the DAO v2 code data & store it in factory
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'$DAO_ACCOUNT_ID'"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao2_original.wasm

# Store the code data
V2_BYTES='cat sputnikdao2_original.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2_CODE_HASH=$(eval "tail -1 v2_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2 CODE HASH: $V2_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2_CODE_HASH'", "metadata": {"version": [2,0], "commit_id": "c2cf1553b070d04eed8f659571440b27d398c588"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v2a code data & store it in factory
#### Keep this around for gas-fixes version
#### NOTE: This doesnt really fix the upgrade path post neard 1.26.0 - those v2 DAOs will be stuck
#### --------------------------------------------
# Store the code data
V2A_BYTES='cat sputnikdao2-gasfix/res/sputnikdao2-gasfix.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2A_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2a_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2A_CODE_HASH=$(eval "tail -1 v2a_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2A CODE HASH: $V2A_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2A_CODE_HASH'", "metadata": {"version": [2,1], "commit_id": "'$COMMIT_V2A'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v3 code data & store it in factory
#### --------------------------------------------
# Store the code data
V3_BYTES='cat sputnikdao2/res/sputnikdao2.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V3_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v3_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V3_CODE_HASH'", "metadata": {"version": [3,0], "commit_id": "'$COMMIT_V3'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata & DAO
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
# Check a v2 DAO
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
near view $DAO_ACCOUNT_ID get_proposal '{"id": 2}'
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade a v2 DAO to v2a
#### --------------------------------------------
V2A_CODE_HASH=$(eval "tail -1 v2a_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "Upgrade V2A CODE HASH: $V2A_CODE_HASH"
# some sample payouts
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Upgrade to v2a", "kind": { "UpgradeSelf": { "hash": "'$V2A_CODE_HASH'" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DAO_ACCOUNT_ID act_proposal '{"id": 3, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
near view $DAO_ACCOUNT_ID get_proposal '{"id": 3}'
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata & DAO
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
# Check a v2 DAO
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
near view $DAO_ACCOUNT_ID get_proposal '{"id": 2}'
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade a v2a DAO to v3
#### --------------------------------------------
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "Upgrade V3 CODE HASH: $V3_CODE_HASH"
# some sample payouts
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Upgrade to v3", "kind": { "UpgradeSelf": { "hash": "'$V3_CODE_HASH'" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DAO_ACCOUNT_ID act_proposal '{"id": 4, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
near view $DAO_ACCOUNT_ID get_proposal '{"id": 4}'
#### --------------------------------------------

#### --------------------------------------------
#### Deploy a v3 DAO & Some proposals
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=sputnikdao-dev-v3-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "Sputnik Dev v3 DAO '$TIMESTAMP'", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 12
DEMO_DAO_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID

# Quick check for v3 DAO
near view $DEMO_DAO_ACCOUNT get_available_amount

# some sample payouts
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "1000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "2000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "3000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DEMO_DAO_ACCOUNT act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
near call $DEMO_DAO_ACCOUNT act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DEMO_DAO_ACCOUNT get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check v3 dao all worked
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm sputnikdao2_original.wasm
rm sputnikdao_factory2_original.wasm
rm v2_code_hash_result.txt
rm v3_code_hash_result.txt

echo "Dev Factory Deploy & Test Complete"
'''
'''--- scripts/token_staking_v2_testnet.sh ---
#!/bin/bash
set -e

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  # export NEAR_ACCT=sputnikv2.$FACTORY
  export NEAR_ACCT=sputnikpm.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

# export FACTORY_ACCOUNT_ID=sputnikv2.$FACTORY
export FACTORY_ACCOUNT_ID=factory_v2.$NEAR_ACCT
export STAKING_ACCOUNT_ID=staking_contract_v1.$NEAR_ACCT
export TOKEN_ACCOUNT_ID=sample_ft.$NEAR_ACCT
# export DAO_ACCOUNT_ID=samples-1651616675.$FACTORY_ACCOUNT_ID
export DAO_ACCOUNT_ID=THIS_WILL_GET_SET_UPON_DEPLOY_BELOW
export USER_ACCOUNT_ID=$NEAR_ACCT
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000

#### --------------------------------------------
#### New Factory for entire test
#### --------------------------------------------
near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 80
near create-account $STAKING_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 10
near create-account $TOKEN_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 10
#### --------------------------------------------

# Deploy new FT
near deploy --wasmFile test-token/res/fungible_token.wasm --accountId $TOKEN_ACCOUNT_ID
near call $TOKEN_ACCOUNT_ID new '{"owner_id": "'$TOKEN_ACCOUNT_ID'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Sample Token Name", "symbol": "SMPL", "decimals": 8 }}' --accountId $TOKEN_ACCOUNT_ID

# Send some tokens to some accounts
near call $TOKEN_ACCOUNT_ID storage_deposit '' --accountId $USER_ACCOUNT_ID --amount 0.00125
near call $TOKEN_ACCOUNT_ID storage_deposit '' --accountId $STAKING_ACCOUNT_ID --amount 0.00125
near view $TOKEN_ACCOUNT_ID ft_balance_of '{"account_id": "'$TOKEN_ACCOUNT_ID'"}'
near view $TOKEN_ACCOUNT_ID ft_balance_of '{"account_id": "'$USER_ACCOUNT_ID'"}'
near call $TOKEN_ACCOUNT_ID ft_transfer '{"receiver_id": "'$USER_ACCOUNT_ID'", "amount": "10000000000000"}' --accountId $TOKEN_ACCOUNT_ID --amount 0.000000000000000000000001
near view $TOKEN_ACCOUNT_ID ft_balance_of '{"account_id": "'$USER_ACCOUNT_ID'"}'

#### --------------------------------------------
#### Grab the factory v2 code data
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'sputnikv2.$FACTORY'"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao_factory2_original.wasm

# Deploy the previous version to allow accurate testing
near deploy --wasmFile sputnikdao_factory2_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
#### --------------------------------------------

#### --------------------------------------------
#### Deploy SampleDAO
#### --------------------------------------------
COUNCIL='["'$USER_ACCOUNT_ID'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=samples-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "A DAO that governs samples - Best way to vote for new samples at your local store", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 8
DAO_ACCOUNT_ID=$DAO_NAME.$FACTORY_ACCOUNT_ID
#### --------------------------------------------

# Deploy staking contract (OWNER MUST BE THE DAO!!!!!!)
near deploy $STAKING_ACCOUNT_ID --wasmFile=sputnik-staking/res/sputnik_staking.wasm --accountId $STAKING_ACCOUNT_ID --initFunction new --initArgs '{"owner_id": "'$DAO_ACCOUNT_ID'","token_id": "'$TOKEN_ACCOUNT_ID'","unstake_period": "3600"}' --force
# near deploy $STAKING_ACCOUNT_ID --wasmFile=sputnik-staking/res/sputnik_staking.wasm --accountId $STAKING_ACCOUNT_ID --force

# Change DAO to use a staking contract
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "", "kind": { "SetStakingContract": { "staking_id": "'$STAKING_ACCOUNT_ID'" } } } }' --accountId $USER_ACCOUNT_ID --amount 1
near call $DAO_ACCOUNT_ID act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $USER_ACCOUNT_ID  --gas $MAX_GAS
near view $DAO_ACCOUNT_ID get_staking_contract

# # Storage Costs
# near call $STAKING_ACCOUNT_ID storage_unregister '' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS --depositYocto 1
near call $STAKING_ACCOUNT_ID storage_deposit '' --accountId $USER_ACCOUNT_ID --amount 0.01

# NOTE: This assumes you have some FT, and are ready to deposit into the newly deployed staking contract, if you need to create your own FT: https://github.com/near-examples/FT
# Send tokens to the staking contract
near call $TOKEN_ACCOUNT_ID ft_transfer_call '{"receiver_id": "'$STAKING_ACCOUNT_ID'", "amount": "123456789", "msg": ""}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS --depositYocto 1

# Delegation
near call $STAKING_ACCOUNT_ID delegate '{"account_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Check user info
near view $STAKING_ACCOUNT_ID get_user '{"account_id": "'$USER_ACCOUNT_ID'"}'

# Make a transfer proposal happen, so we can test token weighting works
PAYOUT_AMT=1000000000000000000000000
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Payout", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$USER_ACCOUNT_ID'", "amount": "'$PAYOUT_AMT'" } } } }' --accountId $USER_ACCOUNT_ID --amount 1
near call $DAO_ACCOUNT_ID act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $USER_ACCOUNT_ID  --gas $MAX_GAS

# Undelegation
near call $STAKING_ACCOUNT_ID undelegate '{"account_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Withdraw tokens from staking contract
near call $STAKING_ACCOUNT_ID withdraw '{"amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Check final user info
near view $STAKING_ACCOUNT_ID get_user '{"account_id": "'$USER_ACCOUNT_ID'"}'
near view $TOKEN_ACCOUNT_ID ft_balance_of '{"account_id": "'$USER_ACCOUNT_ID'"}'

echo "Token Staking Test Complete"
'''
'''--- scripts/token_staking_v3_testnet.sh ---
#!/bin/bash
set -e

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  # export NEAR_ACCT=sputnikv2.$FACTORY
  export NEAR_ACCT=sputnikpm.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

# export FACTORY_ACCOUNT_ID=sputnikv2.$FACTORY
export FACTORY_ACCOUNT_ID=factory_v3_001.$NEAR_ACCT
export STAKING_ACCOUNT_ID=staking_contract_v1_001.$NEAR_ACCT
export TOKEN_ACCOUNT_ID=sample_ft_v3_001.$NEAR_ACCT
# export DAO_ACCOUNT_ID=samples-1651616675.$FACTORY_ACCOUNT_ID
export DAO_ACCOUNT_ID=THIS_WILL_GET_SET_UPON_DEPLOY_BELOW
export USER_ACCOUNT_ID=$NEAR_ACCT
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000

#### --------------------------------------------
#### New Factory for entire test
#### --------------------------------------------
near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 80
near create-account $STAKING_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 10
near create-account $TOKEN_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 10
#### --------------------------------------------

# Deploy new FT
near deploy --wasmFile test-token/res/fungible_token.wasm --accountId $TOKEN_ACCOUNT_ID
near call $TOKEN_ACCOUNT_ID new '{"owner_id": "'$TOKEN_ACCOUNT_ID'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Sample Token Name", "symbol": "SMPL", "decimals": 8 }}' --accountId $TOKEN_ACCOUNT_ID

# Send some tokens to some accounts
near call $TOKEN_ACCOUNT_ID storage_deposit '' --accountId $USER_ACCOUNT_ID --amount 0.00125
near call $TOKEN_ACCOUNT_ID storage_deposit '' --accountId $STAKING_ACCOUNT_ID --amount 0.00125
near view $TOKEN_ACCOUNT_ID ft_balance_of '{"account_id": "'$TOKEN_ACCOUNT_ID'"}'
near view $TOKEN_ACCOUNT_ID ft_balance_of '{"account_id": "'$USER_ACCOUNT_ID'"}'
near call $TOKEN_ACCOUNT_ID ft_transfer '{"receiver_id": "'$USER_ACCOUNT_ID'", "amount": "10000000000000"}' --accountId $TOKEN_ACCOUNT_ID --amount 0.000000000000000000000001
near view $TOKEN_ACCOUNT_ID ft_balance_of '{"account_id": "'$USER_ACCOUNT_ID'"}'

#### --------------------------------------------
#### Deploy factory v3 code data
#### --------------------------------------------
near deploy --wasmFile sputnikdao-factory2/res/sputnikdao_factory2.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
#### --------------------------------------------

#### --------------------------------------------
#### Deploy SampleDAO
#### --------------------------------------------
COUNCIL='["'$USER_ACCOUNT_ID'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=samples-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "A DAO that governs samples - Best way to vote for new samples at your local store", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 8
DAO_ACCOUNT_ID=$DAO_NAME.$FACTORY_ACCOUNT_ID
#### --------------------------------------------

# Deploy staking contract (OWNER MUST BE THE DAO!!!!!!)
near deploy $STAKING_ACCOUNT_ID --wasmFile=sputnik-staking/res/sputnik_staking.wasm --accountId $STAKING_ACCOUNT_ID --initFunction new --initArgs '{"owner_id": "'$DAO_ACCOUNT_ID'","token_id": "'$TOKEN_ACCOUNT_ID'","unstake_period": "3600"}' --force
# near deploy $STAKING_ACCOUNT_ID --wasmFile=sputnik-staking/res/sputnik_staking.wasm --accountId $STAKING_ACCOUNT_ID --force

# Change DAO to use a staking contract
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "", "kind": { "SetStakingContract": { "staking_id": "'$STAKING_ACCOUNT_ID'" } } } }' --accountId $USER_ACCOUNT_ID --amount 1
near call $DAO_ACCOUNT_ID act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $USER_ACCOUNT_ID  --gas $MAX_GAS
near view $DAO_ACCOUNT_ID get_staking_contract

# # Storage Costs
# near call $STAKING_ACCOUNT_ID storage_unregister '' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS --depositYocto 1
near call $STAKING_ACCOUNT_ID storage_deposit '' --accountId $USER_ACCOUNT_ID --amount 0.01

# NOTE: This assumes you have some FT, and are ready to deposit into the newly deployed staking contract, if you need to create your own FT: https://github.com/near-examples/FT
# Send tokens to the staking contract
near call $TOKEN_ACCOUNT_ID ft_transfer_call '{"receiver_id": "'$STAKING_ACCOUNT_ID'", "amount": "123456789", "msg": ""}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS --depositYocto 1

# Delegation
near call $STAKING_ACCOUNT_ID delegate '{"account_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Check user info
near view $STAKING_ACCOUNT_ID get_user '{"account_id": "'$USER_ACCOUNT_ID'"}'

# Make a transfer proposal happen, so we can test token weighting works
PAYOUT_AMT=1000000000000000000000000
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Payout", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$USER_ACCOUNT_ID'", "amount": "'$PAYOUT_AMT'" } } } }' --accountId $USER_ACCOUNT_ID --amount 1
near call $DAO_ACCOUNT_ID act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $USER_ACCOUNT_ID  --gas $MAX_GAS

# Undelegation
near call $STAKING_ACCOUNT_ID undelegate '{"account_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Withdraw tokens from staking contract
near call $STAKING_ACCOUNT_ID withdraw '{"amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Check final user info
near view $STAKING_ACCOUNT_ID get_user '{"account_id": "'$USER_ACCOUNT_ID'"}'
near view $TOKEN_ACCOUNT_ID ft_balance_of '{"account_id": "'$USER_ACCOUNT_ID'"}'

echo "Token Staking Test Complete"
'''
'''--- scripts/upgrade_dao_direct_testnet.sh ---
#!/bin/bash
#### --------------------------------------------
#### NOTE: The following flows are supported in this file, for testing!
# - Create an Upgradeable DAO via sputnikv2.testnet, for testing v2-v3 upgrade
# - Upgradeable DAO store_blob
# - Upgradeable DAO proposal UpgradeSelf with hash from UpgradeDAO store_blob
# - Check code_hash on Upgradeable DAO
#### --------------------------------------------
set -e

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnikv2.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=sputnikv2.$FACTORY
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000

# #### --------------------------------------------
# #### New Factory for entire test
# #### --------------------------------------------
near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 80
# #### --------------------------------------------

#### --------------------------------------------
#### Grab the factory v2 code data
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'sputnikv2.$FACTORY'"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao_factory2_original.wasm

# Deploy the previous version to allow accurate testing
near deploy --wasmFile sputnikdao_factory2_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
#### --------------------------------------------

#### --------------------------------------------
#### Deploy UpgradeDAO
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=upgradadora-1-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "A DAO to propose upgrade bytes to other DAOs", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 50
UPGRADEDAO_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Deploy Upgradeable DAO
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=upgrademe-1-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "A v2 dao that gets upgraded by self from remote submitted bytes", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 10
UPGRDADEME_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Store blob
#### --------------------------------------------
# propose function call on UpgradeDAO to store_blob on Upgradeable DAO
V3_BYTES='cat sputnikdao2/res/sputnikdao2.wasm | base64'

near call $UPGRDADEME_ACCOUNT store_blob $(eval "$V3_BYTES") --base64 --accountId $NEAR_ACCT --depositYocto $BYTE_STORAGE_COST --gas $MAX_GAS > v3_code_hash_result.txt

V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Proposal
#### --------------------------------------------
# propose UpgradeSelf using the code_hash from store_blob
near call $UPGRDADEME_ACCOUNT add_proposal '{
  "proposal": {
    "description": "Upgrade to v3 DAO code using code_hash '$CODE_HASH'",
    "kind": {
      "UpgradeSelf": {
        "hash": "'$V3_CODE_HASH'"
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $UPGRDADEME_ACCOUNT act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $UPGRDADEME_ACCOUNT get_proposal '{"id": 0}'
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm sputnikdao_factory2_original.wasm
rm v3_code_hash_result.txt

echo "Dev: Go to https://explorer.testnet.near.org/accounts/$UPGRDADEME_ACCOUNT and check the code_hash matches $CODE_HASH"
'''
'''--- scripts/upgrade_dao_proposal_mainnet.sh ---
#!/bin/bash
set -e

# build the things
./build.sh

export NEAR_ENV=mainnet
export FACTORY=near

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnik-dao.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=sputnik-dao.$FACTORY
# export FACTORY_ACCOUNT_ID=subfactory.$NEAR_ACCT
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
export GAS_220_TGAS=220000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000
COMMIT_V3=640495ba572345ca356376989738fbd5462e1ff8
V3_CODE_HASH=783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

# IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Change this to YOUR dao
DAO_ACCOUNT_ID=sputnikdao-.$FACTORY_ACCOUNT_ID
# ALSO!!!!!!!!!!!!
# CHANGE ALL THE proposal IDs!!!!! Your DAO could have other proposals, you need to change to use the next ID

#### --------------------------------------------
#### Sanity check the new metadata & DAO
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Proposal
#### --------------------------------------------
# 783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

UPGRADE_PROPOSAL_ARGS=`echo '{"code_hash":"783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5"}' | base64`
# propose UpgradeSelf using the code_hash from store_blob
near call $DAO_ACCOUNT_ID add_proposal '{
  "proposal": {
    "description": "Upgrade to v3 DAO code using upgrade contract via factory",
    "kind": {
      "FunctionCall": {
        "receiver_id": "'$FACTORY_ACCOUNT_ID'",
        "actions": [
          {
            "method_name": "store_contract_self",
            "args": "'$UPGRADE_PROPOSAL_ARGS'",
            "deposit": "'$BYTE_STORAGE_COST'",
            "gas": "'$GAS_220_TGAS'"
          }
        ]
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $DAO_ACCOUNT_ID act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 1}'
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade a v2 DAO to v3
#### --------------------------------------------
# 783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5
echo "Upgrade V3 CODE HASH: $V3_CODE_HASH"
# some sample payouts
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Upgrade to v3", "kind": { "UpgradeSelf": { "hash": "'$V3_CODE_HASH'" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DAO_ACCOUNT_ID act_proposal '{"id": 2, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 2}'
#### --------------------------------------------

#### --------------------------------------------
#### Remove cached blob DAO Proposal
#### --------------------------------------------
# 783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

REMOVE_PROPOSAL_ARGS=`echo '{"code_hash":"783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5"}' | base64`
# propose UpgradeSelf using the code_hash from store_blob
near call $DAO_ACCOUNT_ID add_proposal '{
  "proposal": {
    "description": "Remove DAO upgrade contract local code blob via factory",
    "kind": {
      "FunctionCall": {
        "receiver_id": "'$FACTORY_ACCOUNT_ID'",
        "actions": [
          {
            "method_name": "remove_contract_self",
            "args": "'$REMOVE_PROPOSAL_ARGS'",
            "deposit": "0",
            "gas": "'$GAS_220_TGAS'"
          }
        ]
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $DAO_ACCOUNT_ID act_proposal '{"id": 3, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 3}'
#### --------------------------------------------

echo "Mainnet DAO Upgrade Complete"

'''
'''--- scripts/upgrade_dao_proposal_testnet.sh ---
#!/bin/bash
#### --------------------------------------------
#### NOTE: The following flows are supported in this file, for testing!
# - Create an UpgradeDAO via sputnikv2.testnet, funded with enough for 10 upgrades
# - Create an Upgradeable DAO via sputnikv2.testnet, for testing v2-v3 upgrade
# - UpgradeDAO proposal to store_blob on Upgradeable DAO
# - Upgradeable DAO proposal UpgradeSelf with hash from UpgradeDAO store_blob
# - Check code_hash on Upgradeable DAO
#### --------------------------------------------
set -e

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnikv2.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=sputnikv2.$FACTORY
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
export GAS_220_TGAS=220000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000
COMMIT_V2=c2cf1553b070d04eed8f659571440b27d398c588
V2_CODE_HASH=8RMeZ5cXDap6TENxaJKtigRYf3n139iHmTRe8ZUNey6N
COMMIT_V2A=UNOFFICIAL_SCRIPT_DATA
V2A_CODE_HASH=8LN56HLNjvwtiNb6pRVNSTMtPgJYqGjAgkVSHRiK5Wfv
COMMIT_V3=640495ba572345ca356376989738fbd5462e1ff8
V3_CODE_HASH=783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

# #### --------------------------------------------
# #### New Factory for entire test
# #### --------------------------------------------
near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 80
# #### --------------------------------------------

#### --------------------------------------------
#### Grab the factory v2 code data
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'sputnikv2.$FACTORY'"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao_factory2_original.wasm

# Deploy the previous version to allow accurate testing
near deploy --wasmFile sputnikdao_factory2_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
#### --------------------------------------------

#### --------------------------------------------
#### Deploy Upgradeable DAO
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=upgrademe-1-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "A v2 dao that gets upgraded by self from remote submitted bytes", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 12
UPGRDADEME_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Quick sanity check on getters
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade the factory
#### NOTE: Make sure you've built on the right commit!
#### --------------------------------------------
near deploy --wasmFile sputnikdao-factory2/res/sputnikdao_factory2.wasm --accountId $FACTORY_ACCOUNT_ID --force
#### --------------------------------------------

#### --------------------------------------------
#### Grab the DAO v2 code data & store it in factory
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'$DAO_ACCOUNT_ID'"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao2_original.wasm

# Store the code data
V2_BYTES='cat sputnikdao2_original.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS --amount 10 > v2_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2_CODE_HASH=$(eval "tail -1 v2_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2 CODE HASH: $V2_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2_CODE_HASH'", "metadata": {"version": [2,0], "commit_id": "c2cf1553b070d04eed8f659571440b27d398c588"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v3 code data & store it in factory
#### --------------------------------------------
# Store the code data
V3_BYTES='cat sputnikdao2/res/sputnikdao2.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V3_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS --amount 10 > v3_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V3_CODE_HASH'", "metadata": {"version": [3,0], "commit_id": "'$COMMIT_V3'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Proposal
#### --------------------------------------------
# 783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

UPGRADE_PROPOSAL_ARGS=`echo '{"code_hash":"783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5"}' | base64`
# propose UpgradeSelf using the code_hash from store_blob
near call $UPGRDADEME_ACCOUNT add_proposal '{
  "proposal": {
    "description": "Upgrade to v3 DAO code using upgrade contract via factory",
    "kind": {
      "FunctionCall": {
        "receiver_id": "'$FACTORY_ACCOUNT_ID'",
        "actions": [
          {
            "method_name": "store_contract_self",
            "args": "'$UPGRADE_PROPOSAL_ARGS'",
            "deposit": "'$BYTE_STORAGE_COST'",
            "gas": "'$GAS_220_TGAS'"
          }
        ]
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $UPGRDADEME_ACCOUNT act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $UPGRDADEME_ACCOUNT get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Proposal
#### --------------------------------------------
V3_CODE_HASH=783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5
# propose UpgradeSelf using the code_hash from store_blob
near call $UPGRDADEME_ACCOUNT add_proposal '{
  "proposal": {
    "description": "Upgrade to v3 DAO code using local stored code",
    "kind": {
      "UpgradeSelf": {
        "hash": "'$V3_CODE_HASH'"
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $UPGRDADEME_ACCOUNT act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $UPGRDADEME_ACCOUNT get_proposal '{"id": 1}'
#### --------------------------------------------

#### --------------------------------------------
#### Remove cached blob DAO Proposal
#### --------------------------------------------
# 783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

REMOVE_PROPOSAL_ARGS=`echo '{"code_hash":"783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5"}' | base64`
# propose UpgradeSelf using the code_hash from store_blob
near call $UPGRDADEME_ACCOUNT add_proposal '{
  "proposal": {
    "description": "Remove DAO upgrade contract local code blob via factory",
    "kind": {
      "FunctionCall": {
        "receiver_id": "'$FACTORY_ACCOUNT_ID'",
        "actions": [
          {
            "method_name": "remove_contract_self",
            "args": "'$REMOVE_PROPOSAL_ARGS'",
            "deposit": "0",
            "gas": "'$GAS_220_TGAS'"
          }
        ]
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $UPGRDADEME_ACCOUNT act_proposal '{"id": 2, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $UPGRDADEME_ACCOUNT get_proposal '{"id": 2}'
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm sputnikdao2_original.wasm
rm sputnikdao_factory2_original.wasm
rm v2_code_hash_result.txt
rm v3_code_hash_result.txt

echo "Dev: Go to https://explorer.testnet.near.org/accounts/$UPGRDADEME_ACCOUNT and check the code_hash matches $CODE_HASH"
'''
'''--- scripts/upgrade_fa_dao_direct_mainnet.sh ---
#!/bin/bash
set -e

# build the things
./build.sh

export NEAR_ENV=mainnet
export FACTORY=near

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnik-dao.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=sputnik-dao.$FACTORY
export MAX_GAS=300000000000000

# Create a backup of signer key just so we can be paranoid and careful
cp ~/.near-credentials/$NEAR_ENV/$NEAR_ACCT.json ~/.near-credentials/$NEAR_ENV/$NEAR_ACCT-backup.json 

# Loop All accounts and deploy v2 gas fixes
# NOTE: If this fails, the full access key could be wrong.
# NOTE: If this fails, the account might not have enough funds for new code storage.
accounts=("collabs" "wiki" "openshards" "codame" "pixeltoken" "curators" "multicall" "marmaj" "hype" "mochi" "news" "famjam" "genesis" "hak" "peter" "nearweek" "thekindao" "shrm" "skyward" "metapool" "prod_dev" "pulse" "stardust" "city-nodes" "audit" "simplegames" "auctionhouse" "wyosky" "grain-lang" "jascha" "swarming" "roketo" "rarity" "information" "millionaire-raccoons-dao" "aurora" "mindful" "maximum-viable-potential" "raritydao" "pulse-markets" "nearprotocoltamil" "terrans" "now-fund-this" "rucommunity" "cpgtest" "nyc-sports" "learnnear" "lisboa-node" "jinn" "transform" "art" "nearsighted" "kindessgrocerycoop" "devco" "hfq" "catalygraphy" "nftbuzz" "yaway" "localmakermart" "nihilism_fulltime" "flymoon" "blackvirtualmap" "abra" "nft")
for (( e=0; e<=${#accounts[@]} - 1; e++ ))
do
  DAO_ACCOUNT_ID="${accounts[e]}.${FACTORY_ACCOUNT_ID}"
  echo "Upgrading: ${DAO_ACCOUNT_ID}"

  # Copy the signing key temporarily so near-cli can get tricked into the right signer
  cp ~/.near-credentials/$NEAR_ENV/$NEAR_ACCT.json ~/.near-credentials/$NEAR_ENV/$DAO_ACCOUNT_ID.json 

  # FOR DEPLOYING v2 with the gas fix
  near deploy --wasmFile sputnikdao2-gasfix/res/sputnikdao2_gasfix.wasm --accountId $DAO_ACCOUNT_ID --initGas $MAX_GAS --force
  # # FOR DEPLOYING v3 directly (SHOULD BE AVOIDED IF POSSIBLE!)
  # near deploy --wasmFile sputnikdao2/res/sputnikdao2.wasm --accountId $FACTORY_ACCOUNT_ID --initGas $MAX_GAS --force

  echo "Deployed ${DAO_ACCOUNT_ID}: Go to https://explorer.near.org/accounts/${DAO_ACCOUNT_ID} and check the code_hash"

  # Remove the dao account fake signer key
  rm ~/.near-credentials/$NEAR_ENV/$DAO_ACCOUNT_ID.json 
done

'''
'''--- scripts/upgrade_fa_dao_direct_testnet.sh ---
#!/bin/bash
set -e

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnikv2.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=sputnikv2.$FACTORY
export MAX_GAS=300000000000000

# Create a backup of signer key just so we can be paranoid and careful
cp ~/.near-credentials/$NEAR_ENV/$NEAR_ACCT.json ~/.near-credentials/$NEAR_ENV/$NEAR_ACCT-backup.json 

# Loop All accounts and deploy v2 gas fixes
# NOTE: If this fails, the full access key could be wrong.
# NOTE: If this fails, the account might not have enough funds for new code storage.
accounts=("nearnear" "dodo")
for (( e=0; e<=${#accounts[@]} - 1; e++ ))
do
  DAO_ACCOUNT_ID="${accounts[e]}.${FACTORY_ACCOUNT_ID}"
  echo "Upgrading: ${DAO_ACCOUNT_ID}"

  # Copy the signing key temporarily so near-cli can get tricked into the right signer
  cp ~/.near-credentials/$NEAR_ENV/$NEAR_ACCT.json ~/.near-credentials/$NEAR_ENV/$DAO_ACCOUNT_ID.json 

  # FOR DEPLOYING v2 with the gas fix
  near deploy --wasmFile sputnikdao2-gasfix/res/sputnikdao2_gasfix.wasm --accountId $DAO_ACCOUNT_ID --initGas $MAX_GAS --force
  # # FOR DEPLOYING v3 directly (SHOULD BE AVOIDED IF POSSIBLE!)
  # near deploy --wasmFile sputnikdao2/res/sputnikdao2.wasm --accountId $FACTORY_ACCOUNT_ID --initGas $MAX_GAS --force

  echo "Deployed ${DAO_ACCOUNT_ID}: Go to https://explorer.testnet.near.org/accounts/${DAO_ACCOUNT_ID} and check the code_hash"

  # Remove the dao account fake signer key
  rm ~/.near-credentials/$NEAR_ENV/$DAO_ACCOUNT_ID.json 
done

'''
'''--- scripts/upgrade_factory_mainnet.sh ---
#!/bin/bash
set -e

# build the things
./build.sh

export NEAR_ENV=mainnet
export FACTORY=near

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnik-dao.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=sputnik-dao.$NEAR_ACCT
export DAO_ACCOUNT_ID=genesis.$FACTORY_ACCOUNT_ID
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000
COMMIT_V2=c2cf1553b070d04eed8f659571440b27d398c588
V2_CODE_HASH=8RMeZ5cXDap6TENxaJKtigRYf3n139iHmTRe8ZUNey6N
COMMIT_V2A=UNOFFICIAL_SCRIPT_DATA
V2A_CODE_HASH=8LN56HLNjvwtiNb6pRVNSTMtPgJYqGjAgkVSHRiK5Wfv
COMMIT_V3=640495ba572345ca356376989738fbd5462e1ff8
V3_CODE_HASH=783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

#### --------------------------------------------
#### Grab the DAO v2 code data
#### --------------------------------------------
http --json post https://rpc.mainnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'$DAO_ACCOUNT_ID'"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao2_original.wasm
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade the factory
#### NOTE: Make sure you've built on the right commit!
#### --------------------------------------------
near deploy --wasmFile sputnikdao-factory2/res/sputnikdao_factory2.wasm --accountId $FACTORY_ACCOUNT_ID --force
#### --------------------------------------------

#### --------------------------------------------
#### DAO v2 code data, store it in factory
#### --------------------------------------------
# Store the code data
V2_BYTES='cat sputnikdao2_original.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2_CODE_HASH=$(eval "tail -1 v2_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2 CODE HASH: $V2_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2_CODE_HASH'", "metadata": {"version": [2,0], "commit_id": "'$COMMIT_V2'"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v2a code data & store it in factory
#### Keep this around for gas-fixes version
#### NOTE: This doesnt really fix the upgrade path post neard 1.26.0 - those v2 DAOs will be stuck
#### --------------------------------------------
# Store the code data
V2A_BYTES='cat sputnikdao2-gasfix/res/sputnikdao2_gasfix.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2A_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2a_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2A_CODE_HASH=$(eval "tail -1 v2a_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2A CODE HASH: $V2A_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2A_CODE_HASH'", "metadata": {"version": [2,1], "commit_id": "'$COMMIT_V2A'"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v3 code data & store it in factory
#### --------------------------------------------
# Store the code data
V3_BYTES='cat sputnikdao2/res/sputnikdao2.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V3_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v3_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V3_CODE_HASH'", "metadata": {"version": [3,0], "commit_id": "'$COMMIT_V3'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm sputnikdao2_original.wasm
rm sputnikdao_factory2_original.wasm
rm v2_code_hash_result.txt
rm v2a_code_hash_result.txt
rm v3_code_hash_result.txt

echo "MAINNET: Factory Upgrade Complete"
'''
'''--- scripts/upgrade_factory_testnet.sh ---
#!/bin/bash
set -e

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  export NEAR_ACCT=sputnikv2.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=sputnikv2.$NEAR_ACCT
export DAO_ACCOUNT_ID=genesis.$FACTORY_ACCOUNT_ID
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000
COMMIT_V2=c2cf1553b070d04eed8f659571440b27d398c588
V2_CODE_HASH=8RMeZ5cXDap6TENxaJKtigRYf3n139iHmTRe8ZUNey6N
COMMIT_V2A=UNOFFICIAL_SCRIPT_DATA
V2A_CODE_HASH=8LN56HLNjvwtiNb6pRVNSTMtPgJYqGjAgkVSHRiK5Wfv
COMMIT_V3=640495ba572345ca356376989738fbd5462e1ff8
V3_CODE_HASH=783vth3Fg8MBBGGFmRqrytQCWBpYzUcmHoCq4Mo8QqF5

#### --------------------------------------------
#### Grab the DAO v2 code data & store it in factory
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'$DAO_ACCOUNT_ID'"}' \
| jq -r .result.code_base64 \
| base64 --decode > sputnikdao2_original.wasm
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade the factory
#### NOTE: Make sure you've built on the right commit!
#### --------------------------------------------
near deploy --wasmFile sputnikdao-factory2/res/sputnikdao_factory2.wasm --accountId $FACTORY_ACCOUNT_ID --force
#### --------------------------------------------

#### --------------------------------------------
#### Grab the DAO v2 code data & store it in factory
#### --------------------------------------------
# Store the code data
V2_BYTES='cat sputnikdao2_original.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2_CODE_HASH=$(eval "tail -1 v2_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2 CODE HASH: $V2_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2_CODE_HASH'", "metadata": {"version": [2,0], "commit_id": "'$COMMIT_V2'"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v2a code data & store it in factory
#### Keep this around for gas-fixes version
#### NOTE: This doesnt really fix the upgrade path post neard 1.26.0 - those v2 DAOs will be stuck
#### --------------------------------------------
# Store the code data
V2A_BYTES='cat sputnikdao2-gasfix/res/sputnikdao2-gasfix.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2A_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v2a_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2A_CODE_HASH=$(eval "tail -1 v2a_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2A CODE HASH: $V2A_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2A_CODE_HASH'", "metadata": {"version": [2,1], "commit_id": "'$COMMIT_V2A'"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v3 code data & store it in factory
#### --------------------------------------------
# Store the code data
V3_BYTES='cat sputnikdao2/res/sputnikdao2.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V3_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $MAX_GAS --amount 10 > v3_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V3_CODE_HASH'", "metadata": {"version": [3,0], "commit_id": "'$COMMIT_V3'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm sputnikdao2_original.wasm
rm sputnikdao_factory2_original.wasm
rm v2_code_hash_result.txt
rm v2a_code_hash_result.txt
rm v3_code_hash_result.txt

echo "TESTNET: Factory Upgrade Complete"
'''
'''--- sputnik-staking/Cargo.toml ---
[package]
name = "sputnik-staking"
version = "1.0.0"
authors = ["Sputnik Devs <near-daos@protonmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.4"
near-contract-standards = "4.0.0-pre.4"
hex = "0.4.2"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.4"
test-token = { path = "../test-token" }

'''
'''--- sputnik-staking/README.md ---
# Sputnik Staking

This is staking contract for Sputnik DAO.

The default version just allows to stake the tokens by users and convert them into "weight" in the Sputnik itself.
Further modifications can be done to allow to leverage the staked token for other functions (providing liquidity for example).

### Token voting

> DAO votes to select some token to become voting token (only can be done once, can't change later).

User flow to vote with selected token:

- Users deposit the desired amount of the token to the separate staking contract defined by the DAO.
- They can then choose who to delegate these tokens. It can be to themselves or to other users to increase their vote weight.
- When users vote for proposals, their vote is weighted by all the delegations to them.
- Undelegating will block delegating / withdrawing until one voting period passes.
- Undelegated tokens can be withdrawn by the user.

## Scripted Flow

NOTE: This is not 100% working, help finalize :)

```bash
export STAKING_ACCOUNT_ID=YOUR_STAKING_CONTRACT.testnet
export DAO_ACCOUNT_ID=YOUR_DAO.sputnikv2.testnet
export TOKEN_ACCOUNT_ID=YOUR_TOKEN_ID.testnet
export USER_ACCOUNT_ID=YOU.testnet
export MAX_GAS=300000000000000

# Deploy staking contract
near deploy $STAKING_ACCOUNT_ID --wasmFile=sputnik-staking/res/sputnik_staking.wasm --accountId $STAKING_ACCOUNT_ID --initFunction new --initArgs '{"owner_id": "'$DAO_ACCOUNT_ID'","token_id": "'$TOKEN_ACCOUNT_ID'","unstake_period": "604800000"}'

# Change DAO to use a staking contract
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "", "kind": { "SetStakingContract": { "staking_id": "'$STAKING_ACCOUNT_ID'" } } } }' --accountId $USER_ACCOUNT_ID --amount 1
near call $DAO_ACCOUNT_ID act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $USER_ACCOUNT_ID  --gas $MAX_GAS
near view $DAO_ACCOUNT_ID get_staking_contract

# Storage Costs
near call $STAKING_ACCOUNT_ID storage_deposit '{"registration_only": true}' --accountId $STAKER_ACCOUNT_ID --amount 0.01

# NOTE: This assumes you have some FT, and are ready to deposit into the newly deployed staking contract, if you need to create your own FT: https://github.com/near-examples/FT
# Send tokens to the staking contract
near call $TOKEN_ACCOUNT_ID ft_transfer_call '{"sender_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Delegation
near call $STAKING_ACCOUNT_ID delegate '{"account_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Check user info
near view $STAKING_ACCOUNT_ID get_user '{"account_id": "'$USER_ACCOUNT_ID'"}'

# Undelegation
near call $STAKING_ACCOUNT_ID undelegate '{"account_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Withdraw tokens from staking contract
near call $STAKING_ACCOUNT_ID withdraw '{"amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS
```

## ABIs

### Staking Contract :: V1
```
{
  "viewMethods": [
    "ft_total_supply",
    "ft_balance_of",
    "get_user",
    "storage_balance_of"
  ],
  "changeMethods": [
    "new",
    "delegate",
    "undelegate",
    "withdraw",
    "storage_deposit",
    "storage_withdraw",
    "storage_unregister"
  ],
}
```

'''
'''--- sputnik-staking/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/sputnik_staking.wasm ./res/

'''
'''--- sputnik-staking/src/lib.rs ---
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, Duration, Gas,
    PanicOnDefault, Promise, PromiseOrValue, PromiseResult,
};

pub use user::{User, VersionedUser};

mod storage_impl;
mod user;

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKeys {
    Users,
}

/// Amount of gas for fungible token transfers.
pub const GAS_FOR_FT_TRANSFER: Gas = Gas(10_000_000_000_000);

/// Amount of gas for delegate action.
pub const GAS_FOR_DELEGATE: Gas = Gas(10_000_000_000_000);

/// Amount of gas for register action.
pub const GAS_FOR_REGISTER: Gas = Gas(10_000_000_000_000);

/// Amount of gas for undelegate action.
pub const GAS_FOR_UNDELEGATE: Gas = Gas(10_000_000_000_000);

#[ext_contract(ext_sputnik)]
pub trait Sputnik {
    fn register_delegation(&mut self, account_id: AccountId);
    fn delegate(&mut self, account_id: AccountId, amount: U128);
    fn undelegate(&mut self, account_id: AccountId, amount: U128);
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    /// DAO owner of this staking contract.
    owner_id: AccountId,
    /// Vote token account.
    vote_token_id: AccountId,
    /// Recording user deposits.
    users: LookupMap<AccountId, VersionedUser>,
    /// Total token amount deposited.
    total_amount: Balance,
    /// Duration of unstaking. Should be over the possible voting periods.
    unstake_period: Duration,
}

#[ext_contract(ext_self)]
pub trait Contract {
    fn exchange_callback_post_withdraw(&mut self, sender_id: AccountId, amount: U128);
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId, token_id: AccountId, unstake_period: U64) -> Self {
        Self {
            owner_id: owner_id.into(),
            vote_token_id: token_id,
            users: LookupMap::new(StorageKeys::Users),
            total_amount: 0,
            unstake_period: unstake_period.0,
        }
    }

    /// Total number of tokens staked in this contract.
    pub fn ft_total_supply(&self) -> U128 {
        U128(self.total_amount)
    }

    /// Total number of tokens staked by given user.
    pub fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.internal_get_user(&account_id).vote_amount.0)
    }

    /// Returns user information.
    pub fn get_user(&self, account_id: AccountId) -> User {
        self.internal_get_user(&account_id)
    }

    /// Delegate give amount of votes to given account.
    /// If enough tokens and storage, forwards this to owner account.
    pub fn delegate(&mut self, account_id: AccountId, amount: U128) -> Promise {
        let sender_id = env::predecessor_account_id();
        self.internal_delegate(sender_id, account_id.clone().into(), amount.0);
        ext_sputnik::delegate(
            account_id.into(),
            amount,
            self.owner_id.clone(),
            0,
            GAS_FOR_DELEGATE,
        )
    }

    /// Remove given amount of delegation.
    pub fn undelegate(&mut self, account_id: AccountId, amount: U128) -> Promise {
        let sender_id = env::predecessor_account_id();
        self.internal_undelegate(sender_id, account_id.clone().into(), amount.0);
        ext_sputnik::undelegate(
            account_id.into(),
            amount,
            self.owner_id.clone(),
            0,
            GAS_FOR_UNDELEGATE,
        )
    }

    /// Withdraw non delegated tokens back to the user's account.
    /// If user's account is not registered, will keep funds here.
    pub fn withdraw(&mut self, amount: U128) -> Promise {
        let sender_id = env::predecessor_account_id();
        self.internal_withdraw(&sender_id, amount.0);
        ext_fungible_token::ft_transfer(
            sender_id.clone(),
            amount,
            None,
            self.vote_token_id.clone(),
            1,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::exchange_callback_post_withdraw(
            sender_id,
            amount,
            env::current_account_id(),
            0,
            GAS_FOR_FT_TRANSFER,
        ))
    }

    #[private]
    pub fn exchange_callback_post_withdraw(&mut self, sender_id: AccountId, amount: U128) {
        assert_eq!(
            env::promise_results_count(),
            1,
            "ERR_CALLBACK_POST_WITHDRAW_INVALID",
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => {}
            PromiseResult::Failed => {
                // This reverts the changes from withdraw function.
                self.internal_deposit(&sender_id, amount.0);
            }
        };
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            self.vote_token_id,
            env::predecessor_account_id(),
            "ERR_INVALID_TOKEN"
        );
        assert!(msg.is_empty(), "ERR_INVALID_MESSAGE");
        self.internal_deposit(&sender_id, amount.0);
        PromiseOrValue::Value(U128(0))
    }
}

#[cfg(test)]
mod tests {
    use near_contract_standards::storage_management::StorageManagement;
    use near_sdk::json_types::U64;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use near_sdk_sim::to_yocto;

    use super::*;

    #[test]
    fn test_basics() {
        const UNSTAKE_PERIOD: u64 = 1000;
        let contract_owner: AccountId = accounts(0);
        let voting_token: AccountId = accounts(1);
        let delegate_from_user: AccountId = accounts(2);
        let delegate_to_user: AccountId = accounts(3);

        let mut context = VMContextBuilder::new();

        testing_env!(context
            .predecessor_account_id(contract_owner.clone())
            .build());
        let mut contract = Contract::new(contract_owner, voting_token.clone(), U64(UNSTAKE_PERIOD));

        testing_env!(context.attached_deposit(to_yocto("1")).build());
        contract.storage_deposit(Some(delegate_from_user.clone()), None);

        testing_env!(context.predecessor_account_id(voting_token.clone()).build());
        contract.ft_on_transfer(
            delegate_from_user.clone(),
            U128(to_yocto("100")),
            "".to_string(),
        );
        assert_eq!(contract.ft_total_supply().0, to_yocto("100"));
        assert_eq!(
            contract.ft_balance_of(delegate_from_user.clone()).0,
            to_yocto("100")
        );

        testing_env!(context
            .predecessor_account_id(delegate_from_user.clone())
            .build());
        contract.withdraw(U128(to_yocto("50")));
        assert_eq!(contract.ft_total_supply().0, to_yocto("50"));
        assert_eq!(
            contract.ft_balance_of(delegate_from_user.clone()).0,
            to_yocto("50")
        );

        testing_env!(context.attached_deposit(to_yocto("1")).build());
        contract.storage_deposit(Some(delegate_to_user.clone()), None);

        contract.delegate(delegate_to_user.clone(), U128(to_yocto("10")));
        let user = contract.get_user(delegate_from_user.clone());
        assert_eq!(user.delegated_amount(), to_yocto("10"));

        contract.undelegate(delegate_to_user, U128(to_yocto("10")));
        let user = contract.get_user(delegate_from_user);
        assert_eq!(user.delegated_amount(), 0);
        assert_eq!(user.next_action_timestamp, U64(UNSTAKE_PERIOD));
    }
}

'''
'''--- sputnik-staking/src/storage_impl.rs ---
use std::convert::TryInto;

use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::{assert_one_yocto, log};

use crate::*;

/// Implements users storage management for the pool.
#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let deposit_amount = env::attached_deposit();
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);

        if self.users.contains_key(&account_id) {
            log!("ERR_ACC_REGISTERED");
            if deposit_amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(deposit_amount);
            }
        } else {
            let min_balance = User::min_storage() as Balance * env::storage_byte_cost();
            if deposit_amount < min_balance {
                env::panic_str("ERR_DEPOSIT_LESS_THAN_MIN_STORAGE");
            }

            let registration_only = registration_only.unwrap_or(false);
            if registration_only {
                self.internal_register_user(&account_id, min_balance);
                let refund = deposit_amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
            } else {
                self.internal_register_user(&account_id, deposit_amount);
            }
        }
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let user = self.internal_get_user(&account_id);
        let available = user.storage_available();
        let amount = amount.map(|a| a.0).unwrap_or(available);
        assert!(amount <= available, "ERR_STORAGE_WITHDRAW_TOO_MUCH");
        Promise::new(account_id.clone()).transfer(amount);
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(user) = self.internal_get_user_opt(&account_id) {
            // TODO: figure out force option logic.
            assert!(user.vote_amount.0 > 0, "ERR_STORAGE_UNREGISTER_NOT_EMPTY");
            self.users.remove(&account_id);
            Promise::new(account_id.clone()).transfer(user.near_amount.0);
            true
        } else {
            false
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(User::min_storage() as Balance * env::storage_byte_cost()),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        self.internal_get_user_opt(&account_id)
            .map(|user| StorageBalance {
                total: user.near_amount,
                available: U128(user.storage_available()),
            })
    }
}

'''
'''--- sputnik-staking/src/user.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance, Duration, StorageUsage};

use crate::*;

const U64_LEN: StorageUsage = 8;
const U128_LEN: StorageUsage = 16;
const ACCOUNT_MAX_LENGTH: StorageUsage = 64;

/// User data.
/// Recording deposited voting tokens, storage used and delegations for voting.
/// Once delegated - the tokens are used in the votes. It records for each delegate when was the last vote.
/// When undelegating - the new delegations or withdrawal are only available after cooldown period from last vote of the delegate.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct User {
    /// Total amount of storage used by this user struct.
    pub storage_used: StorageUsage,
    /// Amount of $NEAR to cover storage.
    pub near_amount: U128,
    /// Amount of staked token deposited.
    pub vote_amount: U128,
    /// Withdrawal or next delegation available timestamp.
    pub next_action_timestamp: U64,
    /// List of delegations to other accounts.
    pub delegated_amounts: Vec<(AccountId, U128)>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VersionedUser {
    Default(User),
}

impl User {
    pub fn new(near_amount: Balance) -> Self {
        Self {
            storage_used: Self::min_storage(),
            near_amount: U128(near_amount),
            vote_amount: U128(0),
            delegated_amounts: vec![],
            next_action_timestamp: 0.into(),
        }
    }

    /// Minimum storage with empty delegations in bytes.
    /// This includes u128 stored in DAO for delegations to this user.
    /// They are deposited on internal_register and removed on internal_unregister.
    pub fn min_storage() -> StorageUsage {
        ACCOUNT_MAX_LENGTH + 2 * U64_LEN + 4 * U128_LEN
    }

    fn assert_storage(&self) {
        assert!(
            (self.storage_used as Balance) * env::storage_byte_cost() <= self.near_amount.0,
            "ERR_NOT_ENOUGH_STORAGE"
        );
    }

    pub(crate) fn delegated_amount(&self) -> Balance {
        self.delegated_amounts
            .iter()
            .fold(0, |total, (_, amount)| total + amount.0)
    }

    /// Record delegation from this account to another account.
    /// Fails if not enough available balance to delegate.
    pub fn delegate(&mut self, delegate_id: AccountId, amount: Balance) {
        assert!(
            self.delegated_amount() + amount <= self.vote_amount.0,
            "ERR_NOT_ENOUGH_AMOUNT"
        );
        assert!(
            env::block_timestamp() >= self.next_action_timestamp.0,
            "ERR_NOT_ENOUGH_TIME_PASSED"
        );
        self.storage_used += delegate_id.as_bytes().len() as StorageUsage + U128_LEN;
        self.delegated_amounts.push((delegate_id, U128(amount)));
        self.assert_storage();
    }

    /// Remove given amount from delegates. Updates timestamp when next action can be called.
    /// Fails if delegate not found or not enough amount delegated.
    pub fn undelegate(
        &mut self,
        delegate_id: &AccountId,
        amount: Balance,
        undelegation_period: Duration,
    ) {
        let f = self
            .delegated_amounts
            .iter()
            .enumerate()
            .find(|(_, (account_id, _))| account_id == delegate_id)
            .expect("ERR_NO_DELEGATE");
        let element = (f.0, ((f.1).1).0);
        assert!(element.1 >= amount, "ERR_NOT_ENOUGH_AMOUNT");
        if element.1 == amount {
            self.delegated_amounts.remove(element.0);
            self.storage_used -= delegate_id.as_bytes().len() as StorageUsage + U128_LEN;
        } else {
            (self.delegated_amounts[element.0].1).0 -= amount;
        }
        self.next_action_timestamp = (env::block_timestamp() + undelegation_period).into();
    }

    /// Withdraw the amount.
    /// Fails if there is not enough available balance.
    pub fn withdraw(&mut self, amount: Balance) {
        assert!(
            self.delegated_amount() + amount <= self.vote_amount.0,
            "ERR_NOT_ENOUGH_AVAILABLE_AMOUNT"
        );
        assert!(
            env::block_timestamp() >= self.next_action_timestamp.0,
            "ERR_NOT_ENOUGH_TIME_PASSED"
        );
        self.vote_amount.0 -= amount;
    }

    /// Deposit given amount of vote tokens.
    pub fn deposit(&mut self, amount: Balance) {
        self.vote_amount.0 += amount;
    }

    /// Returns amount in NEAR that is available for storage.
    pub fn storage_available(&self) -> Balance {
        self.near_amount.0 - self.storage_used as Balance * env::storage_byte_cost()
    }
}

impl Contract {
    pub fn internal_get_user(&self, account_id: &AccountId) -> User {
        self.internal_get_user_opt(account_id).expect("NO_USER")
    }

    pub fn internal_get_user_opt(&self, account_id: &AccountId) -> Option<User> {
        self.users
            .get(account_id)
            .map(|versioned_user| match versioned_user {
                VersionedUser::Default(user) => user,
            })
    }

    pub fn save_user(&mut self, account_id: &AccountId, user: User) {
        self.users.insert(account_id, &VersionedUser::Default(user));
    }

    /// Internal register new user.
    pub fn internal_register_user(&mut self, sender_id: &AccountId, near_amount: Balance) {
        let user = User::new(near_amount);
        self.save_user(sender_id, user);
        ext_sputnik::register_delegation(
            sender_id.clone(),
            self.owner_id.clone(),
            (U128_LEN as Balance) * env::storage_byte_cost(),
            GAS_FOR_REGISTER,
        );
    }

    /// Deposit voting token.
    pub fn internal_deposit(&mut self, sender_id: &AccountId, amount: Balance) {
        let mut sender = self.internal_get_user(&sender_id);
        sender.deposit(amount);
        self.save_user(&sender_id, sender);
        self.total_amount += amount;
    }

    /// Withdraw voting token.
    pub fn internal_withdraw(&mut self, sender_id: &AccountId, amount: Balance) {
        let mut sender = self.internal_get_user(&sender_id);
        sender.withdraw(amount);
        self.save_user(&sender_id, sender);
        assert!(self.total_amount >= amount, "ERR_INTERNAL");
        self.total_amount -= amount;
    }

    /// Given user delegates given amount of votes to another user.
    /// The other user must be registered.
    pub fn internal_delegate(
        &mut self,
        sender_id: AccountId,
        delegate_id: AccountId,
        amount: Balance,
    ) {
        let mut sender = self.internal_get_user(&sender_id);
        assert!(self.users.contains_key(&delegate_id), "ERR_NOT_REGISTERED");
        sender.delegate(delegate_id.clone(), amount);
        self.save_user(&sender_id, sender);
    }

    /// Undelegate votes from given delegate.
    pub fn internal_undelegate(
        &mut self,
        sender_id: AccountId,
        delegate_id: AccountId,
        amount: Balance,
    ) {
        let mut sender = self.internal_get_user(&sender_id);
        sender.undelegate(&delegate_id, amount, self.unstake_period);
        self.save_user(&sender_id, sender);
    }
}

'''
'''--- sputnikdao-factory2/Cargo.toml ---
[package]
name = "sputnikdao-factory2"
version = "0.2.0"
authors = ["Illia Polosukhin <illia.polosukhin@gmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { version = "4.0.0-pre.4", features = ["unstable"]  }

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.4"

'''
'''--- sputnikdao-factory2/README.md ---
# Sputnik Factory

# Deployment & Usage

## TestNet

```
near dev-deploy --wasmFile=res/sputnikdao_factory2.wasm

# bash
CONTRACT_ID="dev-1608694678554-8567049"
# fish
set CONTRACT_ID "dev-1608694678554-8567049"

# Initialize the factory.
near call $CONTRACT_ID new '{}' --accountId $CONTRACT_ID 

# bash
ARGS=`echo '{"purpose": "test", "council": ["testmewell.testnet", "illia"], "bond": "1000000000000000000000000", "vote_period": "1800000000000", "grace_period": "1800000000000"}' | base64`
# fish
set ARGS (echo '{"purpose": "test", "council": ["testmewell.testnet", "illia"], "bond": "1000000000000000000000000", "vote_period": "1800000000000", "grace_period": "1800000000000"}' | base64)

# Create a new DAO with the given parameters.
near call $CONTRACT_ID create "{\"name\": \"test\", \"public_key\": null, \"args\": \"$ARGS\"}"  --accountId $CONTRACT_ID --amount 30 --gas 100000000000000

# Create a new DAO with the given parameters while having Full Access Key to the account (trusted, but useful in case of testing or upgrades)
near call $CONTRACT_ID create "{\"name\": \"test\", \"public_key\": \"<base58 of public key>\", \"args\": \"$ARGS\"}"  --accountId $CONTRACT_ID --amount 30 --gas 100000000000000

# List all created DAOs.
near view $CONTRACT_ID get_dao_list
```

# ABIs

V1 is archived in a different repo. :)

### Sputnik Factory :: v3
```
{
  "viewMethods": [
    "get_dao_list",
    "get_number_daos",
    "get_daos",
    "get_owner",
    "get_default_code_hash",
    "get_default_version",
    "get_code",
    "get_contracts_metadata"
  ],
  "changeMethods": [
    "new",
    "create",
    "set_owner",
    "set_default_code_hash",
    "delete_contract",
    "update",
    "store_contract_metadata",
    "delete_contract_metadata",
    "store"
  ],
}
```

### Sputnik DAO :: v2
```
{
  "viewMethods": [
    "get_dao_list"
  ],
  "changeMethods": [
    "new",
    "create"
  ],
}
```
'''
'''--- sputnikdao-factory2/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/sputnikdao_factory2.wasm ./res/

'''
'''--- sputnikdao-factory2/src/factory_manager.rs ---
//! Module for standard generic contract factory manager.
//! TODO: move to near-sdk standards library.

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base58CryptoHash;
use near_sdk::serde_json;
use near_sdk::{env, AccountId, Balance, CryptoHash, Gas};

/// Gas spent on the call & account creation.
const CREATE_CALL_GAS: Gas = Gas(40_000_000_000_000);

/// Gas allocated on the callback.
const ON_CREATE_CALL_GAS: Gas = Gas(10_000_000_000_000);

/// Leftover gas after creating promise and calling update.
const GAS_UPDATE_LEFTOVER: Gas = Gas(10_000_000_000_000);

const NO_DEPOSIT: Balance = 0;

/// Factory manager that allows to store/load contracts by hash directly in the storage.
/// Uses directly underlying host functions to not load any of the data into WASM memory.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct FactoryManager {}

impl FactoryManager {
    /// Store contract from input.
    pub fn store_contract(&self) {
        let input = env::input().expect("ERR_NO_INPUT");
        let sha256_hash = env::sha256(&input);
        assert!(!env::storage_has_key(&sha256_hash), "ERR_ALREADY_EXISTS");
        env::storage_write(&sha256_hash, &input);

        let mut blob_hash = [0u8; 32];
        blob_hash.copy_from_slice(&sha256_hash);
        let blob_hash_str = serde_json::to_string(&Base58CryptoHash::from(blob_hash))
            .unwrap()
            .into_bytes();
        env::value_return(&blob_hash_str);
    }

    /// Delete code from the contract.
    pub fn delete_contract(&self, code_hash: Base58CryptoHash) {
        let code_hash: CryptoHash = code_hash.into();
        env::storage_remove(&code_hash);
    }

    /// Get code for given hash.
    pub fn get_code(&self, code_hash: Base58CryptoHash) {
        let code_hash: CryptoHash = code_hash.into();
        // Check that such contract exists.
        assert!(env::storage_has_key(&code_hash), "Contract doesn't exist");
        // Load the hash from storage.
        let code = env::storage_read(&code_hash).unwrap();
        // Return as value.
        env::value_return(&code);
    }

    /// Forces update on the given contract.
    /// Contract must support update by factory for this via permission check.
    pub fn update_contract(
        &self,
        account_id: AccountId,
        code_hash: Base58CryptoHash,
        method_name: &str,
    ) {
        let code_hash: CryptoHash = code_hash.into();
        // Check that such contract exists.
        assert!(env::storage_has_key(&code_hash), "Contract doesn't exist");
        // Load the hash from storage.
        let code = env::storage_read(&code_hash).expect("ERR_NO_HASH");
        // Create a promise toward given account.
        let promise_id = env::promise_batch_create(&account_id);
        // Call `update` method, which should also handle migrations.
        env::promise_batch_action_function_call(
            promise_id,
            method_name,
            &code,
            NO_DEPOSIT,
            env::prepaid_gas() - env::used_gas() - GAS_UPDATE_LEFTOVER,
        );
        env::promise_return(promise_id);
    }

    /// Create given contract with args and callback factory.
    pub fn create_contract(
        &self,
        code_hash: Base58CryptoHash,
        account_id: AccountId,
        new_method: &str,
        args: &[u8],
        callback_method: &str,
        callback_args: &[u8],
    ) {
        let code_hash: CryptoHash = code_hash.into();
        let attached_deposit = env::attached_deposit();
        let factory_account_id = env::current_account_id();
        // Check that such contract exists.
        assert!(env::storage_has_key(&code_hash), "Contract doesn't exist");
        // Load input (wasm code).
        let code = env::storage_read(&code_hash).expect("ERR_NO_HASH");
        // Compute storage cost.
        let code_len = code.len();
        let storage_cost = ((code_len + 32) as Balance) * env::storage_byte_cost();
        assert!(
            attached_deposit >= storage_cost,
            "ERR_NOT_ENOUGH_DEPOSIT:{}",
            storage_cost
        );
        // Schedule a Promise tx to account_id.
        let promise_id = env::promise_batch_create(&account_id);
        // Create account first.
        env::promise_batch_action_create_account(promise_id);
        // Transfer attached deposit.
        env::promise_batch_action_transfer(promise_id, attached_deposit);
        // Deploy contract.
        env::promise_batch_action_deploy_contract(promise_id, &code);
        // call `new` with given arguments.
        env::promise_batch_action_function_call(
            promise_id,
            new_method,
            args,
            NO_DEPOSIT,
            CREATE_CALL_GAS,
        );
        // attach callback to the factory.
        let _ = env::promise_then(
            promise_id,
            factory_account_id,
            callback_method,
            callback_args,
            NO_DEPOSIT,
            ON_CREATE_CALL_GAS,
        );
        env::promise_return(promise_id);
    }
}

'''
'''--- sputnikdao-factory2/src/lib.rs ---
mod factory_manager;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base58CryptoHash, Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{self, json};
use near_sdk::{env, near_bindgen, AccountId, Balance, CryptoHash, Gas, PanicOnDefault, Promise};

use factory_manager::FactoryManager;

type Version = [u8; 2];

// The keys used for writing data to storage via `env::storage_write`.
const DEFAULT_CODE_HASH_KEY: &[u8; 4] = b"CODE";
const FACTORY_OWNER_KEY: &[u8; 5] = b"OWNER";
const CODE_METADATA_KEY: &[u8; 8] = b"METADATA";

// The values used when writing initial data to the storage.
const DAO_CONTRACT_INITIAL_CODE: &[u8] = include_bytes!("../../sputnikdao2/res/sputnikdao2.wasm");
const DAO_CONTRACT_INITIAL_VERSION: Version = [3, 0];
const DAO_CONTRACT_NO_DATA: &str = "no data";

// Gas & Costs for blob storage
const GAS_STORE_CONTRACT_LEFTOVER: Gas = Gas(20_000_000_000_000);
const ON_REMOVE_CONTRACT_GAS: Gas = Gas(10_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct DaoContractMetadata {
    // version of the DAO contract code (e.g. [2, 0] -> 2.0, [3, 1] -> 3.1, [4, 0] -> 4.0)
    pub version: Version,
    // commit id of https://github.com/near-daos/sputnik-dao-contract
    // representing a snapshot of the code that generated the wasm
    pub commit_id: String,
    // if available, url to the changelog to see the changes introduced in this version
    pub changelog_url: Option<String>,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct SputnikDAOFactory {
    factory_manager: FactoryManager,
    daos: UnorderedSet<AccountId>,
}

#[near_bindgen]
impl SputnikDAOFactory {
    #[init]
    pub fn new() -> Self {
        let this = Self {
            factory_manager: FactoryManager {},
            daos: UnorderedSet::new(b"d".to_vec()),
        };
        this.internal_store_initial_contract();
        this
    }

    fn internal_store_initial_contract(&self) {
        self.assert_owner();
        let code = DAO_CONTRACT_INITIAL_CODE.to_vec();
        let sha256_hash = env::sha256(&code);
        env::storage_write(&sha256_hash, &code);

        self.store_contract_metadata(
            slice_to_hash(&sha256_hash),
            DaoContractMetadata {
                version: DAO_CONTRACT_INITIAL_VERSION,
                commit_id: String::from(DAO_CONTRACT_NO_DATA),
                changelog_url: None,
            },
            true,
        );
    }

    pub fn set_owner(&self, owner_id: AccountId) {
        self.assert_owner();
        env::storage_write(FACTORY_OWNER_KEY, owner_id.as_bytes());
    }

    pub fn set_default_code_hash(&self, code_hash: Base58CryptoHash) {
        self.assert_owner();
        let code_hash: CryptoHash = code_hash.into();
        assert!(
            env::storage_has_key(&code_hash),
            "Code not found for the given code hash. Please store the code first."
        );
        env::storage_write(DEFAULT_CODE_HASH_KEY, &code_hash);
    }

    pub fn delete_contract(&self, code_hash: Base58CryptoHash) {
        self.assert_owner();
        self.factory_manager.delete_contract(code_hash);
        self.delete_contract_metadata(code_hash);
    }

    #[payable]
    pub fn create(&mut self, name: AccountId, args: Base64VecU8) {
        let account_id: AccountId = format!("{}.{}", name, env::current_account_id())
            .parse()
            .unwrap();
        let callback_args = serde_json::to_vec(&json!({
            "account_id": account_id,
            "attached_deposit": U128(env::attached_deposit()),
            "predecessor_account_id": env::predecessor_account_id()
        }))
        .expect("Failed to serialize");
        self.factory_manager.create_contract(
            self.get_default_code_hash(),
            account_id,
            "new",
            &args.0,
            "on_create",
            &callback_args,
        );
    }

    #[private]
    pub fn on_create(
        &mut self,
        account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> bool {
        if near_sdk::is_promise_success() {
            self.daos.insert(&account_id);
            true
        } else {
            Promise::new(predecessor_account_id).transfer(attached_deposit.0);
            false
        }
    }

    /// Tries to update given account created by this factory to the specified code.
    pub fn update(&self, account_id: AccountId, code_hash: Base58CryptoHash) {
        let caller_id = env::predecessor_account_id();
        assert!(
            caller_id == self.get_owner() || caller_id == account_id,
            "Must be updated by the factory owner or the DAO itself"
        );
        assert!(
            self.daos.contains(&account_id),
            "Must be contract created by factory"
        );
        self.factory_manager
            .update_contract(account_id, code_hash, "update");
    }

    /// Allows a DAO to store the official factory version as a blob, funded by the DAO wanting to upgrade
    /// Required to successfully upgrade a DAO via proposals (proposal to store blob, proposal to upgrade from local blob)
    /// Only intended for sputnik v2 DAO's created by sputnik factory
    /// Payment is needed to cover storage costs for code blob size, paid by the DAO and returned upon blob removal
    #[payable]
    pub fn store_contract_self(&mut self, code_hash: Base58CryptoHash) {
        let account_id = env::predecessor_account_id();
        let method_name = "store_blob";

        let hash: CryptoHash = code_hash.into();
        assert!(
            env::storage_has_key(&hash),
            "Code not found for the given code hash. Please store the code first."
        );

        // Lock down contract upgrades to this factory:
        let dao_id = env::predecessor_account_id().to_string();
        let idx = dao_id.find('.').expect("INTERNAL_FAIL");
        // ex: sputnik-dao.near
        let factory_id = &dao_id[idx + 1..];

        assert_eq!(
            factory_id,
            env::current_account_id().as_str(),
            "Wrong factory"
        );

        let dao_contract_code = env::storage_read(&hash).expect("CODE_HASH_NONEXIST");

        // Compute and use the correct amount needed for storage
        let blob_len = dao_contract_code.len();
        let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();

        // Confirm payment before proceeding
        assert!(
            storage_cost <= env::attached_deposit(),
            "Must at least deposit {} to store",
            storage_cost
        );

        // refund the extra cost
        let extra_attached_deposit = env::attached_deposit() - storage_cost;
        Promise::new(account_id.clone()).transfer(extra_attached_deposit);

        // Create a promise toward given account.
        let promise_id = env::promise_batch_create(&account_id);
        env::promise_batch_action_function_call(
            promise_id,
            method_name,
            &dao_contract_code,
            storage_cost,
            env::prepaid_gas() - env::used_gas() - GAS_STORE_CONTRACT_LEFTOVER,
        );
        env::promise_return(promise_id);
    }

    /// Allows a DAO to remove the blob stored in its DAO storage, and reclaim the storage cost
    pub fn remove_contract_self(&mut self, code_hash: Base58CryptoHash) {
        let account_id = env::predecessor_account_id();
        let factory_id = env::current_account_id();
        let method_name = "remove_blob";

        // NOTE: Not verifing the hash, in case factory removes a hash before DAO does
        let method_args = &json!({ "hash": &code_hash }).to_string().into_bytes();
        let callback_method = "on_remove_contract_self";
        let callback_args = &json!({ "account_id": &account_id, "code_hash": &code_hash })
            .to_string()
            .into_bytes();

        // Create a promise toward given account.
        let promise_id = env::promise_batch_create(&account_id);
        env::promise_batch_action_function_call(
            promise_id,
            method_name,
            method_args,
            NO_DEPOSIT,
            GAS_STORE_CONTRACT_LEFTOVER,
        );
        // attach callback to the factory.
        let _ = env::promise_then(
            promise_id,
            factory_id,
            callback_method,
            callback_args,
            NO_DEPOSIT,
            ON_REMOVE_CONTRACT_GAS,
        );
        env::promise_return(promise_id);
    }

    /// Upon blob remove, compute the balance (if any) that got paid to the factory,
    /// since it was the "owner" of the blob stored on the DAO.
    /// Send this balance back to the DAO, since it was the original funder
    #[private]
    pub fn on_remove_contract_self(
        &mut self,
        account_id: AccountId,
        code_hash: Base58CryptoHash,
    ) -> bool {
        if near_sdk::is_promise_success() {
            // Compute the actual storage cost for an accurate refund
            let hash: CryptoHash = code_hash.into();
            let dao_contract_code = env::storage_read(&hash).expect("CODE_HASH_NONEXIST");
            let blob_len = dao_contract_code.len();
            let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
            Promise::new(account_id).transfer(storage_cost);
            true
        } else {
            false
        }
    }

    pub fn get_dao_list(&self) -> Vec<AccountId> {
        self.daos.to_vec()
    }

    /// Get number of created DAOs.
    pub fn get_number_daos(&self) -> u64 {
        self.daos.len()
    }

    /// Get daos in paginated view.
    pub fn get_daos(&self, from_index: u64, limit: u64) -> Vec<AccountId> {
        let elements = self.daos.as_vector();
        (from_index..std::cmp::min(from_index + limit, elements.len()))
            .filter_map(|index| elements.get(index))
            .collect()
    }

    pub fn get_owner(&self) -> AccountId {
        AccountId::new_unchecked(
            String::from_utf8(
                env::storage_read(FACTORY_OWNER_KEY)
                    .unwrap_or(env::current_account_id().as_bytes().to_vec()),
            )
            .expect("INTERNAL_FAIL"),
        )
    }

    pub fn get_default_code_hash(&self) -> Base58CryptoHash {
        slice_to_hash(&env::storage_read(DEFAULT_CODE_HASH_KEY).expect("Must have code hash"))
    }

    pub fn get_default_version(&self) -> Version {
        let storage_metadata = env::storage_read(CODE_METADATA_KEY).expect("INTERNAL_FAIL");
        let deserialized_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
            BorshDeserialize::try_from_slice(&storage_metadata).expect("INTERNAL_FAIL");
        let default_metadata = deserialized_metadata
            .get(&self.get_default_code_hash())
            .expect("INTERNAL_FAIL");
        default_metadata.version
    }

    /// Returns non serialized code by given code hash.
    pub fn get_code(&self, code_hash: Base58CryptoHash) {
        self.factory_manager.get_code(code_hash);
    }

    pub fn store_contract_metadata(
        &self,
        code_hash: Base58CryptoHash,
        metadata: DaoContractMetadata,
        set_default: bool,
    ) {
        self.assert_owner();
        let hash: CryptoHash = code_hash.into();
        assert!(
            env::storage_has_key(&hash),
            "Code not found for the given code hash. Please store the code first."
        );

        let storage_metadata = env::storage_read(CODE_METADATA_KEY);
        if storage_metadata.is_none() {
            let mut storage_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
                UnorderedMap::new(b"m".to_vec());
            storage_metadata.insert(&code_hash, &metadata);
            let serialized_metadata =
                BorshSerialize::try_to_vec(&storage_metadata).expect("INTERNAL_FAIL");
            env::storage_write(CODE_METADATA_KEY, &serialized_metadata);
        } else {
            let storage_metadata = storage_metadata.expect("INTERNAL_FAIL");
            let mut deserialized_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
                BorshDeserialize::try_from_slice(&storage_metadata).expect("INTERNAL_FAIL");
            deserialized_metadata.insert(&code_hash, &metadata);
            let serialized_metadata =
                BorshSerialize::try_to_vec(&deserialized_metadata).expect("INTERNAL_FAIL");
            env::storage_write(CODE_METADATA_KEY, &serialized_metadata);
        }

        if set_default {
            env::storage_write(DEFAULT_CODE_HASH_KEY, &hash);
        }
    }

    pub fn delete_contract_metadata(&self, code_hash: Base58CryptoHash) {
        self.assert_owner();
        let storage_metadata = env::storage_read(CODE_METADATA_KEY).expect("INTERNAL_FAIL");
        let mut deserialized_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
            BorshDeserialize::try_from_slice(&storage_metadata).expect("INTERNAL_FAIL");
        deserialized_metadata.remove(&code_hash);
        let serialized_metadata =
            BorshSerialize::try_to_vec(&deserialized_metadata).expect("INTERNAL_FAIL");
        env::storage_write(CODE_METADATA_KEY, &serialized_metadata);
    }

    pub fn get_contracts_metadata(&self) -> Vec<(Base58CryptoHash, DaoContractMetadata)> {
        let storage_metadata = env::storage_read(CODE_METADATA_KEY).expect("INTERNAL_FAIL");
        let deserialized_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
            BorshDeserialize::try_from_slice(&storage_metadata).expect("INTERNAL_FAIL");
        return deserialized_metadata.to_vec();
    }

    fn assert_owner(&self) {
        assert_eq!(
            self.get_owner(),
            env::predecessor_account_id(),
            "Must be owner"
        );
    }
}

pub fn slice_to_hash(hash: &[u8]) -> Base58CryptoHash {
    let mut result: CryptoHash = [0; 32];
    result.copy_from_slice(&hash);
    Base58CryptoHash::from(result)
}

/// Store new contract. Non serialized argument is the contract.
/// Returns base58 of the hash of the contract.
#[no_mangle]
pub extern "C" fn store() {
    env::setup_panic_hook();
    let contract: SputnikDAOFactory = env::state_read().expect("Contract is not initialized");
    contract.assert_owner();
    let prev_storage = env::storage_usage();
    contract.factory_manager.store_contract();
    let storage_cost = (env::storage_usage() - prev_storage) as u128 * env::storage_byte_cost();
    assert!(
        storage_cost <= env::attached_deposit(),
        "Must at least deposit {} to store",
        storage_cost
    );
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, PromiseResult};

    use near_sdk_sim::to_yocto;

    use super::*;

    #[test]
    #[should_panic(expected = "ERR_NOT_ENOUGH_DEPOSIT")]
    fn test_create_error() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .build());
        let mut factory = SputnikDAOFactory::new();

        testing_env!(context.attached_deposit(to_yocto("5")).build());
        factory.create("test".parse().unwrap(), "{}".as_bytes().to_vec().into());
    }

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .build());
        let mut factory = SputnikDAOFactory::new();

        testing_env!(context.attached_deposit(to_yocto("6")).build());
        factory.create("test".parse().unwrap(), "{}".as_bytes().to_vec().into());

        testing_env!(
            context.predecessor_account_id(accounts(0)).build(),
            near_sdk::VMConfig::test(),
            near_sdk::RuntimeFeesConfig::test(),
            Default::default(),
            vec![PromiseResult::Successful(vec![])],
        );
        factory.on_create(
            format!("test.{}", accounts(0)).parse().unwrap(),
            U128(to_yocto("6")),
            accounts(0),
        );
        assert_eq!(
            factory.get_dao_list(),
            vec![format!("test.{}", accounts(0)).parse().unwrap()]
        );
        assert_eq!(
            factory.get_daos(0, 100),
            vec![format!("test.{}", accounts(0)).parse().unwrap()]
        );
    }

    //              #################################              //
    //              #    Factory ownership tests    #              //
    //              #################################              //

    #[test]
    fn test_factory_can_get_current_owner() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(alice())
            .predecessor_account_id(alice())
            .attached_deposit(to_yocto("5"))
            .build());
        let factory = SputnikDAOFactory::new();

        assert_eq!(factory.get_owner(), alice());
    }

    #[test]
    #[should_panic]
    fn test_factory_fails_setting_owner_from_not_owner_account() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(alice())
            .predecessor_account_id(carol())
            .attached_deposit(to_yocto("5"))
            .build());
        let factory = SputnikDAOFactory::new();

        factory.set_owner(bob());
    }

    #[test]
    fn test_owner_can_be_a_dao_account() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(bob())
            .predecessor_account_id(bob())
            .attached_deposit(to_yocto("6"))
            .build());
        let mut factory = SputnikDAOFactory::new();

        factory.create(bob(), "{}".as_bytes().to_vec().into());

        factory.set_owner(AccountId::new_unchecked("bob.sputnik-dao.near".to_string()));

        assert_eq!(
            factory.get_owner(),
            AccountId::new_unchecked("bob.sputnik-dao.near".to_string())
        )
    }

    #[test]
    fn test_owner_gets_succesfully_updated() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .attached_deposit(to_yocto("5"))
            .build());
        let factory = SputnikDAOFactory::new();

        assert_ne!(factory.get_owner(), bob());

        factory.set_owner(bob());

        assert_eq!(factory.get_owner(), bob())
    }
}

'''
'''--- sputnikdao2-gasfix/Cargo.toml ---
[package]
name = "sputnikdao2-gasfix"
version = "2.0.0"
authors = ["Sputnik Devs <near-daos@protonmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
hex = "0.4.2"

[dev-dependencies]
near-sdk-sim = "3.1.0"
test-token = { path = "../test-token" }
sputnik-staking = { path = "../sputnik-staking" }
'''
'''--- sputnikdao2-gasfix/README.md ---
# Sputnik DAO v2 with GAS FIXES for v1.26.0

'''
'''--- sputnikdao2-gasfix/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/sputnikdao2_gasfix.wasm ./res/

'''
'''--- sputnikdao2-gasfix/src/bounties.rs ---
use std::convert::TryFrom;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{WrappedDuration, WrappedTimestamp, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseOrValue};

use crate::*;

/// Information recorded about claim of the bounty by given user.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BountyClaim {
    /// Bounty id that was claimed.
    bounty_id: u64,
    /// Start time of the claim.
    start_time: WrappedTimestamp,
    /// Deadline specified by claimer.
    deadline: WrappedDuration,
    /// Completed?
    completed: bool,
}

/// Bounty information.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Bounty {
    /// Description of the bounty.
    pub description: String,
    /// Token the bounty will be paid out.
    pub token: AccountId,
    /// Amount to be paid out.
    pub amount: U128,
    /// How many times this bounty can be done.
    pub times: u32,
    /// Max deadline from claim that can be spend on this bounty.
    pub max_deadline: WrappedDuration,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum VersionedBounty {
    Default(Bounty),
}

impl From<VersionedBounty> for Bounty {
    fn from(v: VersionedBounty) -> Self {
        match v {
            VersionedBounty::Default(b) => b,
        }
    }
}

impl Contract {
    /// Adds bounty to the storage and returns it's id.
    /// Must not fail.
    pub(crate) fn internal_add_bounty(&mut self, bounty: &Bounty) -> u64 {
        let id = self.last_bounty_id;
        self.bounties
            .insert(&id, &VersionedBounty::Default(bounty.clone()));
        self.last_bounty_id += 1;
        id
    }

    /// This must be called when proposal to payout bounty has been voted either successfully or not.
    pub(crate) fn internal_execute_bounty_payout(
        &mut self,
        id: u64,
        receiver_id: &AccountId,
        success: bool,
    ) -> PromiseOrValue<()> {
        let mut bounty: Bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY").into();
        let (claims, claim_idx) = self.internal_get_claims(id, &receiver_id);
        self.internal_remove_claim(id, claims, claim_idx);
        if success {
            let res = self.internal_payout(
                &bounty.token,
                receiver_id,
                bounty.amount.0,
                format!("Bounty {} payout", id),
                None,
            );
            if bounty.times == 0 {
                self.bounties.remove(&id);
            } else {
                bounty.times -= 1;
                self.bounties.insert(&id, &VersionedBounty::Default(bounty));
            }
            res
        } else {
            PromiseOrValue::Value(())
        }
    }

    fn internal_find_claim(&self, bounty_id: u64, claims: &[BountyClaim]) -> Option<usize> {
        for i in 0..claims.len() {
            if claims[i].bounty_id == bounty_id {
                return Some(i);
            }
        }
        None
    }
}

#[near_bindgen]
impl Contract {
    /// Claim given bounty by caller with given expected duration to execute.
    /// Bond must be attached to the claim.
    /// Fails if already claimed `times` times.
    #[payable]
    pub fn bounty_claim(&mut self, id: u64, deadline: WrappedDuration) {
        let bounty: Bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY").into();
        let policy = self.policy.get().unwrap().to_policy();
        assert_eq!(
            env::attached_deposit(),
            policy.bounty_bond.0,
            "ERR_BOUNTY_WRONG_BOND"
        );
        let claims_count = self.bounty_claims_count.get(&id).unwrap_or_default();
        assert!(claims_count < bounty.times, "ERR_BOUNTY_ALL_CLAIMED");
        assert!(
            deadline.0 <= bounty.max_deadline.0,
            "ERR_BOUNTY_WRONG_DEADLINE"
        );
        self.bounty_claims_count.insert(&id, &(claims_count + 1));
        let mut claims = self
            .bounty_claimers
            .get(&env::predecessor_account_id())
            .unwrap_or_default();
        claims.push(BountyClaim {
            bounty_id: id,
            start_time: WrappedTimestamp::from(env::block_timestamp()),
            deadline,
            completed: false,
        });
        self.bounty_claimers
            .insert(&env::predecessor_account_id(), &claims);
    }

    /// Removes given claims from this bounty and user's claims.
    fn internal_remove_claim(&mut self, id: u64, mut claims: Vec<BountyClaim>, claim_idx: usize) {
        claims.remove(claim_idx);
        if claims.len() == 0 {
            self.bounty_claimers.remove(&env::predecessor_account_id());
        } else {
            self.bounty_claimers
                .insert(&env::predecessor_account_id(), &claims);
        }
        let count = self.bounty_claims_count.get(&id).unwrap() - 1;
        self.bounty_claims_count.insert(&id, &count);
    }

    fn internal_get_claims(&mut self, id: u64, sender_id: &AccountId) -> (Vec<BountyClaim>, usize) {
        let claims = self
            .bounty_claimers
            .get(&sender_id)
            .expect("ERR_NO_BOUNTY_CLAIMS");
        let claim_idx = self
            .internal_find_claim(id, &claims)
            .expect("ERR_NO_BOUNTY_CLAIM");
        (claims, claim_idx)
    }

    /// Report that bounty is done. Creates a proposal to vote for paying out the bounty.
    /// Only creator of the claim can call `done` on bounty that is still in progress.
    /// On expired, anyone can call it to free up the claim slot.
    pub fn bounty_done(&mut self, id: u64, account_id: Option<AccountId>, description: String) {
        let sender_id = account_id.unwrap_or_else(|| env::predecessor_account_id());
        let (mut claims, claim_idx) = self.internal_get_claims(id, &sender_id);
        assert!(!claims[claim_idx].completed, "ERR_BOUNTY_CLAIM_COMPLETED");
        if env::block_timestamp() > claims[claim_idx].start_time.0 + claims[claim_idx].deadline.0 {
            // Expired. Nothing to do.
            self.internal_remove_claim(id, claims, claim_idx);
        } else {
            // Still under deadline. Only the user themself can call this.
            assert_eq!(
                sender_id,
                env::predecessor_account_id(),
                "ERR_BOUNTY_DONE_MUST_BE_SELF"
            );
            self.add_proposal(ProposalInput {
                description,
                kind: ProposalKind::BountyDone {
                    bounty_id: id,
                    receiver_id: ValidAccountId::try_from(sender_id.clone()).unwrap(),
                },
            });
            claims[claim_idx].completed = true;
            self.bounty_claimers.insert(&sender_id, &claims);
        }
    }

    /// Give up working on the bounty.
    pub fn bounty_giveup(&mut self, id: u64) -> PromiseOrValue<()> {
        let policy = self.policy.get().unwrap().to_policy();
        let (claims, claim_idx) = self.internal_get_claims(id, &env::predecessor_account_id());
        let result = if env::block_timestamp() - claims[claim_idx].start_time.0
            > policy.bounty_forgiveness_period.0
        {
            // If user over the forgiveness period.
            PromiseOrValue::Value(())
        } else {
            // Within forgiveness period.
            Promise::new(env::predecessor_account_id())
                .transfer(policy.bounty_bond.0)
                .into()
        };
        self.internal_remove_claim(id, claims, claim_idx);
        result
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};
    use near_sdk_sim::to_yocto;

    use crate::proposals::{ProposalInput, ProposalKind};
    use crate::types::BASE_TOKEN;
    use crate::{Action, Config};

    use super::*;

    fn add_bounty(context: &mut VMContextBuilder, contract: &mut Contract, times: u32) -> u64 {
        testing_env!(context.attached_deposit(to_yocto("1")).build());
        let id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddBounty {
                bounty: Bounty {
                    description: "test bounty".to_string(),
                    token: BASE_TOKEN.to_string(),
                    amount: U128(to_yocto("10")),
                    times,
                    max_deadline: WrappedDuration::from(1_000),
                },
            },
        });
        assert_eq!(contract.get_last_bounty_id(), id);
        contract.act_proposal(id, Action::VoteApprove, None);
        id
    }

    /// Adds a bounty, and tests it's full lifecycle.
    #[test]
    fn test_bounty_lifecycle() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        add_bounty(&mut context, &mut contract, 2);

        assert_eq!(contract.get_last_bounty_id(), 1);
        assert_eq!(contract.get_bounty(0).bounty.times, 2);

        contract.bounty_claim(0, WrappedDuration::from(500));
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 1);
        assert_eq!(contract.get_bounty_number_of_claims(0), 1);

        contract.bounty_giveup(0);
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 0);
        assert_eq!(contract.get_bounty_number_of_claims(0), 0);

        contract.bounty_claim(0, WrappedDuration::from(500));
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 1);
        assert_eq!(contract.get_bounty_number_of_claims(0), 1);

        contract.bounty_done(0, None, "Bounty is done".to_string());
        assert!(contract.get_bounty_claims(accounts(1))[0].completed);

        assert_eq!(contract.get_last_proposal_id(), 2);
        assert_eq!(
            contract.get_proposal(1).proposal.kind.to_policy_label(),
            "bounty_done"
        );

        contract.act_proposal(1, Action::VoteApprove, None);

        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 0);
        assert_eq!(contract.get_bounty(0).bounty.times, 1);

        contract.bounty_claim(0, WrappedDuration::from(500));
        contract.bounty_done(0, None, "Bounty is done 2".to_string());
        contract.act_proposal(2, Action::VoteApprove, None);

        assert_eq!(contract.get_bounty(0).bounty.times, 0);
    }

    #[test]
    #[should_panic(expected = "ERR_BOUNTY_ALL_CLAIMED")]
    fn test_bounty_claim_not_allowed() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        let id = add_bounty(&mut context, &mut contract, 1);
        contract.bounty_claim(id, WrappedDuration::from(500));
        contract.bounty_done(id, None, "Bounty is done 2".to_string());
        contract.bounty_claim(id, WrappedDuration::from(500));
    }
}

'''
'''--- sputnikdao2-gasfix/src/delegation.rs ---
use crate::*;

impl Contract {
    pub fn get_user_weight(&self, account_id: &AccountId) -> Balance {
        self.delegations.get(account_id).unwrap_or_default()
    }
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn register_delegation(&mut self, account_id: &AccountId) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        assert_eq!(env::attached_deposit(), 16 * env::storage_byte_cost());
        self.delegations.insert(account_id, &0);
    }

    pub fn delegate(&mut self, account_id: &AccountId, amount: U128) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        let prev_amount = self
            .delegations
            .get(account_id)
            .expect("ERR_NOT_REGISTERED");
        self.delegations
            .insert(account_id, &(prev_amount + amount.0));
        self.total_delegation_amount += amount.0;
    }

    pub fn undelegate(&mut self, account_id: &AccountId, amount: U128) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        let prev_amount = self.delegations.get(account_id).unwrap_or_default();
        assert!(prev_amount >= amount.0, "ERR_INVALID_STAKING_CONTRACT");
        self.delegations
            .insert(account_id, &(prev_amount - amount.0));
        self.total_delegation_amount -= amount.0;
    }
}

'''
'''--- sputnikdao2-gasfix/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
#[cfg(target_arch = "wasm32")]
use near_sdk::env::BLOCKCHAIN_INTERFACE;
use near_sdk::json_types::{Base58CryptoHash, ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, BorshStorageKey, CryptoHash, PanicOnDefault, Promise,
};

use crate::bounties::{Bounty, BountyClaim, VersionedBounty};
pub use crate::policy::{Policy, RoleKind, RolePermission, VersionedPolicy, VotePolicy};
use crate::proposals::VersionedProposal;
pub use crate::proposals::{Proposal, ProposalInput, ProposalKind, ProposalStatus};
pub use crate::types::{Action, Config};

mod bounties;
mod delegation;
mod policy;
mod proposals;
mod types;
pub mod views;

near_sdk::setup_alloc!();

#[cfg(target_arch = "wasm32")]
const BLOCKCHAIN_INTERFACE_NOT_SET_ERR: &str = "Blockchain interface not set.";

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    Config,
    Policy,
    Delegations,
    Proposals,
    Bounties,
    BountyClaimers,
    BountyClaimCounts,
    Blobs,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    /// DAO configuration.
    pub config: LazyOption<Config>,
    /// Voting and permissions policy.
    pub policy: LazyOption<VersionedPolicy>,

    /// Amount of $NEAR locked for storage / bonds.
    pub locked_amount: Balance,

    /// Vote staking contract id. That contract must have this account as owner.
    pub staking_id: Option<AccountId>,
    /// Delegated  token total amount.
    pub total_delegation_amount: Balance,
    /// Delegations per user.
    pub delegations: LookupMap<AccountId, Balance>,

    /// Last available id for the proposals.
    pub last_proposal_id: u64,
    /// Proposal map from ID to proposal information.
    pub proposals: LookupMap<u64, VersionedProposal>,

    /// Last available id for the bounty.
    pub last_bounty_id: u64,
    /// Bounties map from ID to bounty information.
    pub bounties: LookupMap<u64, VersionedBounty>,
    /// Bounty claimers map per user. Allows quickly to query for each users their claims.
    pub bounty_claimers: LookupMap<AccountId, Vec<BountyClaim>>,
    /// Count of claims per bounty.
    pub bounty_claims_count: LookupMap<u64, u32>,

    /// Large blob storage.
    pub blobs: LookupMap<CryptoHash, AccountId>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(config: Config, policy: VersionedPolicy) -> Self {
        Self {
            config: LazyOption::new(StorageKeys::Config, Some(&config)),
            policy: LazyOption::new(StorageKeys::Policy, Some(&policy.upgrade())),
            staking_id: None,
            total_delegation_amount: 0,
            delegations: LookupMap::new(StorageKeys::Delegations),
            last_proposal_id: 0,
            proposals: LookupMap::new(StorageKeys::Proposals),
            last_bounty_id: 0,
            bounties: LookupMap::new(StorageKeys::Bounties),
            bounty_claimers: LookupMap::new(StorageKeys::BountyClaimers),
            bounty_claims_count: LookupMap::new(StorageKeys::BountyClaimCounts),
            blobs: LookupMap::new(StorageKeys::Blobs),
            // TODO: only accounts for contract but not for this state object. Can just add fixed size of it.
            locked_amount: env::storage_byte_cost() * (env::storage_usage() as u128),
        }
    }

    /// Should only be called by this contract on migration.
    /// This is NOOP implementation. KEEP IT if you haven't changed contract state.
    /// If you have changed state, you need to implement migration from old state (keep the old struct with different name to deserialize it first).
    /// After migrate goes live on MainNet, return this implementation for next updates.
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "ERR_NOT_ALLOWED"
        );
        let this: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        this
    }

    /// Remove blob from contract storage and pay back to original storer.
    /// Only original storer can call this.
    pub fn remove_blob(&mut self, hash: Base58CryptoHash) -> Promise {
        let hash: CryptoHash = hash.into();
        let account_id = self.blobs.remove(&hash).expect("ERR_NO_BLOB");
        assert_eq!(
            env::predecessor_account_id(),
            account_id,
            "ERR_INVALID_CALLER"
        );
        env::storage_remove(&hash);
        let blob_len = env::register_len(u64::MAX - 1).unwrap();
        let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
        self.locked_amount -= storage_cost;
        Promise::new(account_id).transfer(storage_cost)
    }
}

/// Stores attached data into blob store and returns hash of it.
/// Implemented to avoid loading the data into WASM for optimal gas usage.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn store_blob() {
    env::setup_panic_hook();
    env::set_blockchain_interface(Box::new(near_blockchain::NearBlockchain {}));
    let mut contract: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
    unsafe {
        BLOCKCHAIN_INTERFACE.with(|b| {
            // Load input into register 0.
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .input(0);
            // Compute sha256 hash of register 0 and store in 1.
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .sha256(u64::MAX as _, 0 as _, 1);
            // Check if such blob already stored.
            assert_eq!(
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .storage_has_key(u64::MAX as _, 1 as _),
                0,
                "ERR_ALREADY_EXISTS"
            );
            // Get length of the input argument and check that enough $NEAR has been attached.
            let blob_len = b
                .borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .register_len(0);
            let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
            assert!(
                env::attached_deposit() >= storage_cost,
                "ERR_NOT_ENOUGH_DEPOSIT:{}",
                storage_cost
            );
            contract.locked_amount += storage_cost;
            // Store value of register 0 into key = register 1.
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .storage_write(u64::MAX as _, 1 as _, u64::MAX as _, 0 as _, 2);
            // Load register 1 into blob_hash and save into LookupMap.
            let blob_hash = [0u8; 32];
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .read_register(1, blob_hash.as_ptr() as _);
            contract
                .blobs
                .insert(&blob_hash, &env::predecessor_account_id());
            // Return from function value of register 1.
            let blob_hash_str = near_sdk::serde_json::to_string(&Base58CryptoHash::from(blob_hash))
                .unwrap()
                .into_bytes();
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .value_return(blob_hash_str.len() as _, blob_hash_str.as_ptr() as _);
        });
    }
    env::state_write(&contract);
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};
    use near_sdk_sim::to_yocto;

    use crate::proposals::ProposalStatus;
    use crate::types::BASE_TOKEN;

    use super::*;

    fn create_proposal(context: &mut VMContextBuilder, contract: &mut Contract) -> u64 {
        testing_env!(context.attached_deposit(to_yocto("1")).build());
        contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::Transfer {
                token_id: BASE_TOKEN.to_string(),
                receiver_id: accounts(2).into(),
                amount: U128(to_yocto("100")),
                msg: None,
            },
        })
    }

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        assert_eq!(contract.get_proposals(0, 10).len(), 1);

        let id = create_proposal(&mut context, &mut contract);
        contract.act_proposal(id, Action::VoteApprove, None);
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Approved
        );

        let id = create_proposal(&mut context, &mut contract);
        // proposal expired, finalize.
        testing_env!(context
            .block_timestamp(1_000_000_000 * 24 * 60 * 60 * 8)
            .build());
        contract.act_proposal(id, Action::Finalize, None);
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Expired
        );

        // non council adding proposal per default policy.
        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(to_yocto("1"))
            .build());
        let _id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: accounts(2).into(),
                role: "council".to_string(),
            },
        });
    }

    #[test]
    #[should_panic(expected = "ERR_PERMISSION_DENIED")]
    fn test_remove_proposal_denied() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        contract.act_proposal(id, Action::RemoveProposal, None);
    }

    #[test]
    fn test_remove_proposal_allowed() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut policy = VersionedPolicy::Default(vec![accounts(1).into()]).upgrade();
        policy.to_policy_mut().roles[1]
            .permissions
            .insert("*:RemoveProposal".to_string());
        let mut contract = Contract::new(Config::test_config(), policy);
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        contract.act_proposal(id, Action::RemoveProposal, None);
        assert_eq!(contract.get_proposals(0, 10).len(), 0);
    }

    #[test]
    fn test_vote_expired_proposal() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        let id = create_proposal(&mut context, &mut contract);
        testing_env!(context
            .block_timestamp(1_000_000_000 * 24 * 60 * 60 * 8)
            .build());
        contract.act_proposal(id, Action::VoteApprove, None);
    }

    #[test]
    #[should_panic(expected = "ERR_ALREADY_VOTED")]
    fn test_vote_twice() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into(), accounts(2).into()]),
        );
        let id = create_proposal(&mut context, &mut contract);
        contract.act_proposal(id, Action::VoteApprove, None);
        contract.act_proposal(id, Action::VoteApprove, None);
    }
}

'''
'''--- sputnikdao2-gasfix/src/policy.rs ---
use std::cmp::min;
use std::collections::{HashMap, HashSet};

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{WrappedDuration, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance};

use crate::proposals::{Proposal, ProposalKind, ProposalStatus, Vote};
use crate::types::Action;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub enum RoleKind {
    /// Matches everyone, who is not matched by other roles.
    Everyone,
    /// Member greater or equal than given balance. Can use `1` as non-zero balance.
    Member(Balance),
    /// Set of accounts.
    Group(HashSet<AccountId>),
}

impl RoleKind {
    /// Checks if user matches given role.
    pub fn match_user(&self, user: &UserInfo) -> bool {
        match self {
            RoleKind::Everyone => true,
            RoleKind::Member(amount) => user.amount >= *amount,
            RoleKind::Group(accounts) => accounts.contains(&user.account_id),
        }
    }

    /// Returns the number of people in the this role or None if not supported role kind.
    pub fn get_role_size(&self) -> Option<usize> {
        match self {
            RoleKind::Group(accounts) => Some(accounts.len()),
            _ => None,
        }
    }

    pub fn add_member_to_group(&mut self, member_id: &AccountId) -> Result<(), ()> {
        match self {
            RoleKind::Group(accounts) => {
                accounts.insert(member_id.clone());
                Ok(())
            }
            _ => Err(()),
        }
    }

    pub fn remove_member_from_group(&mut self, member_id: &AccountId) -> Result<(), ()> {
        match self {
            RoleKind::Group(accounts) => {
                accounts.remove(member_id);
                Ok(())
            }
            _ => Err(()),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct RolePermission {
    /// Name of the role to display to the user.
    pub name: String,
    /// Kind of the role: defines which users this permissions apply.
    pub kind: RoleKind,
    /// Set of actions on which proposals that this role is allowed to execute.
    /// <proposal_kind>:<action>
    pub permissions: HashSet<String>,
    /// For each proposal kind, defines voting policy.
    pub vote_policy: HashMap<String, VotePolicy>,
}

pub struct UserInfo {
    pub account_id: AccountId,
    pub amount: Balance,
}

/// Direct weight or ratio to total weight, used for the voting policy.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum WeightOrRatio {
    Weight(U128),
    Ratio(u64, u64),
}

impl WeightOrRatio {
    /// Convert weight or ratio to specific weight given total weight.
    pub fn to_weight(&self, total_weight: Balance) -> Balance {
        match self {
            WeightOrRatio::Weight(weight) => min(weight.0, total_weight),
            WeightOrRatio::Ratio(num, denom) => min(
                (*num as u128 * total_weight) / *denom as u128 + 1,
                total_weight,
            ),
        }
    }
}

/// How the voting policy votes get weigthed.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub enum WeightKind {
    /// Using token amounts and total delegated at the moment.
    TokenWeight,
    /// Weight of the group role. Roles that don't have scoped group are not supported.
    RoleWeight,
}

/// Defines configuration of the vote.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct VotePolicy {
    /// Kind of weight to use for votes.
    pub weight_kind: WeightKind,
    /// Minimum number required for vote to finalize.
    /// If weight kind is TokenWeight - this is minimum number of tokens required.
    ///     This allows to avoid situation where the number of staked tokens from total supply is too small.
    /// If RoleWeight - this is minimum umber of votes.
    ///     This allows to avoid situation where the role is got too small but policy kept at 1/2, for example.
    pub quorum: U128,
    /// How many votes to pass this vote.
    pub threshold: WeightOrRatio,
}

impl Default for VotePolicy {
    fn default() -> Self {
        VotePolicy {
            weight_kind: WeightKind::RoleWeight,
            quorum: U128(0),
            threshold: WeightOrRatio::Ratio(1, 2),
        }
    }
}

/// Defines voting / decision making policy of this DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct Policy {
    /// List of roles and permissions for them in the current policy.
    pub roles: Vec<RolePermission>,
    /// Default vote policy. Used when given proposal kind doesn't have special policy.
    pub default_vote_policy: VotePolicy,
    /// Proposal bond.
    pub proposal_bond: U128,
    /// Expiration period for proposals.
    pub proposal_period: WrappedDuration,
    /// Bond for claiming a bounty.
    pub bounty_bond: U128,
    /// Period in which giving up on bounty is not punished.
    pub bounty_forgiveness_period: WrappedDuration,
}

/// Versioned policy.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum VersionedPolicy {
    /// Default policy with given accounts as council.
    Default(Vec<AccountId>),
    Current(Policy),
}

/// Defines default policy:
///     - everyone can add proposals
///     - group consisting of the call can do all actions, consists of caller.
///     - non token weighted voting, requires 1/2 of the group to vote
///     - proposal & bounty bond is 1N
///     - proposal & bounty forgiveness period is 1 day
fn default_policy(council: Vec<AccountId>) -> Policy {
    Policy {
        roles: vec![
            RolePermission {
                name: "all".to_string(),
                kind: RoleKind::Everyone,
                permissions: vec!["*:AddProposal".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "council".to_string(),
                kind: RoleKind::Group(council.into_iter().collect()),
                // All actions except RemoveProposal are allowed by council.
                permissions: vec![
                    "*:AddProposal".to_string(),
                    "*:VoteApprove".to_string(),
                    "*:VoteReject".to_string(),
                    "*:VoteRemove".to_string(),
                    "*:Finalize".to_string(),
                ]
                .into_iter()
                .collect(),
                vote_policy: HashMap::default(),
            },
        ],
        default_vote_policy: VotePolicy::default(),
        proposal_bond: U128(10u128.pow(24)),
        proposal_period: WrappedDuration::from(1_000_000_000 * 60 * 60 * 24 * 7),
        bounty_bond: U128(10u128.pow(24)),
        bounty_forgiveness_period: WrappedDuration::from(1_000_000_000 * 60 * 60 * 24),
    }
}

impl VersionedPolicy {
    /// Upgrades either version of policy into the latest.
    pub fn upgrade(self) -> Self {
        match self {
            VersionedPolicy::Default(accounts) => {
                VersionedPolicy::Current(default_policy(accounts))
            }
            VersionedPolicy::Current(policy) => VersionedPolicy::Current(policy),
        }
    }

    /// Return recent version of policy.
    pub fn to_policy(self) -> Policy {
        match self {
            VersionedPolicy::Current(policy) => policy,
            _ => unimplemented!(),
        }
    }

    pub fn to_policy_mut(&mut self) -> &mut Policy {
        match self {
            VersionedPolicy::Current(policy) => policy,
            _ => unimplemented!(),
        }
    }
}

impl Policy {
    ///
    /// Doesn't fail, because will be used on the finalization of the proposal.
    pub fn add_member_to_role(&mut self, role: &String, member_id: &AccountId) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == role {
                self.roles[i]
                    .kind
                    .add_member_to_group(member_id)
                    .unwrap_or_else(|()| {
                        env::log(&format!("ERR_ROLE_WRONG_KIND:{}", role).into_bytes());
                    });
                return;
            }
        }
        env::log(&format!("ERR_ROLE_NOT_FOUND:{}", role).into_bytes());
    }

    pub fn remove_member_from_role(&mut self, role: &String, member_id: &AccountId) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == role {
                self.roles[i]
                    .kind
                    .remove_member_from_group(member_id)
                    .unwrap_or_else(|()| {
                        env::log(&format!("ERR_ROLE_WRONG_KIND:{}", role).into_bytes());
                    });
                return;
            }
        }
        env::log(&format!("ERR_ROLE_NOT_FOUND:{}", role).into_bytes());
    }

    /// Returns set of roles that this user is memeber of permissions for given user across all the roles it's member of.
    fn get_user_roles(&self, user: UserInfo) -> HashMap<String, &HashSet<String>> {
        let mut roles = HashMap::default();
        for role in self.roles.iter() {
            if role.kind.match_user(&user) {
                roles.insert(role.name.clone(), &role.permissions);
            }
        }
        roles
    }

    /// Can given user execute given action on this proposal.
    /// Returns all roles that allow this action.
    pub fn can_execute_action(
        &self,
        user: UserInfo,
        proposal_kind: &ProposalKind,
        action: &Action,
    ) -> (Vec<String>, bool) {
        let roles = self.get_user_roles(user);
        let mut allowed = false;
        let allowed_roles = roles
            .into_iter()
            .filter_map(|(role, permissions)| {
                let allowed_role = permissions.contains(&format!(
                    "{}:{}",
                    proposal_kind.to_policy_label(),
                    action.to_policy_label()
                )) || permissions
                    .contains(&format!("{}:*", proposal_kind.to_policy_label()))
                    || permissions.contains(&format!("*:{}", action.to_policy_label()))
                    || permissions.contains("*:*");
                allowed = allowed || allowed_role;
                if allowed_role {
                    Some(role)
                } else {
                    None
                }
            })
            .collect();
        (allowed_roles, allowed)
    }

    /// Returns if given proposal kind is token weighted.
    pub fn is_token_weighted(&self, role: &String, proposal_kind_label: &String) -> bool {
        let role_info = self.internal_get_role(role).expect("ERR_ROLE_NOT_FOUND");
        match role_info
            .vote_policy
            .get(proposal_kind_label)
            .unwrap_or(&self.default_vote_policy)
            .weight_kind
        {
            WeightKind::TokenWeight => true,
            _ => false,
        }
    }

    fn internal_get_role(&self, name: &String) -> Option<&RolePermission> {
        for role in self.roles.iter() {
            if role.name == *name {
                return Some(role);
            }
        }
        None
    }

    /// Get proposal status for given proposal.
    /// Usually is called after changing it's state.
    pub fn proposal_status(
        &self,
        proposal: &Proposal,
        roles: Vec<String>,
        total_supply: Balance,
    ) -> ProposalStatus {
        assert_eq!(
            proposal.status,
            ProposalStatus::InProgress,
            "ERR_PROPOSAL_NOT_IN_PROGRESS"
        );
        if proposal.submission_time.0 + self.proposal_period.0 < env::block_timestamp() {
            // Proposal expired.
            return ProposalStatus::Expired;
        };
        for role in roles {
            let role_info = self.internal_get_role(&role).expect("ERR_MISSING_ROLE");
            let vote_policy = role_info
                .vote_policy
                .get(&proposal.kind.to_policy_label().to_string())
                .unwrap_or(&self.default_vote_policy);
            let threshold = std::cmp::max(
                vote_policy.quorum.0,
                match &vote_policy.weight_kind {
                    WeightKind::TokenWeight => vote_policy.threshold.to_weight(total_supply),
                    WeightKind::RoleWeight => vote_policy.threshold.to_weight(
                        role_info
                            .kind
                            .get_role_size()
                            .expect("ERR_UNSUPPORTED_ROLE") as Balance,
                    ),
                },
            );
            // Check if there is anything voted above the threshold specified by policy for given role.
            let vote_counts = proposal.vote_counts.get(&role).expect("ERR_MISSING_ROLE");
            if vote_counts[Vote::Approve as usize] >= threshold {
                return ProposalStatus::Approved;
            } else if vote_counts[Vote::Reject as usize] >= threshold {
                return ProposalStatus::Rejected;
            } else if vote_counts[Vote::Remove as usize] >= threshold {
                return ProposalStatus::Removed;
            } else {
                // continue to next role.
            }
        }
        proposal.status.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vote_policy() {
        let r1 = WeightOrRatio::Weight(U128(100));
        assert_eq!(r1.to_weight(1_000_000), 100);
        let r2 = WeightOrRatio::Ratio(1, 2);
        assert_eq!(r2.to_weight(2), 2);
        let r2 = WeightOrRatio::Ratio(1, 2);
        assert_eq!(r2.to_weight(5), 3);
        let r2 = WeightOrRatio::Ratio(1, 1);
        assert_eq!(r2.to_weight(5), 5);
    }
}

'''
'''--- sputnikdao2-gasfix/src/proposals.rs ---
use std::collections::HashMap;
use std::convert::TryFrom;

use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, WrappedTimestamp, U64};
use near_sdk::{log, AccountId, Balance, PromiseOrValue};

use crate::policy::UserInfo;
use crate::types::{
    upgrade_remote, upgrade_self, Action, Config, BASE_TOKEN, GAS_FOR_FT_TRANSFER, ONE_YOCTO_NEAR,
};
use crate::*;

/// Status of a proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalStatus {
    InProgress,
    /// If quorum voted yes, this proposal is successfully approved.
    Approved,
    /// If quorum voted no, this proposal is rejected. Bond is returned.
    Rejected,
    /// If quorum voted to remove (e.g. spam), this proposal is rejected and bond is not returned.
    /// Interfaces shouldn't show removed proposals.
    Removed,
    /// Expired after period of time.
    Expired,
    /// If proposal was moved to Hub or somewhere else.
    Moved,
}

/// Function call arguments.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct ActionCall {
    method_name: String,
    args: Base64VecU8,
    deposit: U128,
    gas: U64,
}

/// Kinds of proposals, doing different action.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalKind {
    /// Change the DAO config.
    ChangeConfig { config: Config },
    /// Change the full policy.
    ChangePolicy { policy: VersionedPolicy },
    /// Add member to given role in the policy. This is short cut to updating the whole policy.
    AddMemberToRole {
        member_id: ValidAccountId,
        role: String,
    },
    /// Remove member to given role in the policy. This is short cut to updating the whole policy.
    RemoveMemberFromRole {
        member_id: ValidAccountId,
        role: String,
    },
    /// Calls `receiver_id` with list of method names in a single promise.
    /// Allows this contract to execute any arbitrary set of actions in other contracts.
    FunctionCall {
        receiver_id: ValidAccountId,
        actions: Vec<ActionCall>,
    },
    /// Upgrade this contract with given hash from blob store.
    UpgradeSelf { hash: Base58CryptoHash },
    /// Upgrade another contract, by calling method with the code from given hash from blob store.
    UpgradeRemote {
        receiver_id: ValidAccountId,
        method_name: String,
        hash: Base58CryptoHash,
    },
    /// Transfers given amount of `token_id` from this DAO to `receiver_id`.
    /// If `msg` is not None, calls `ft_transfer_call` with given `msg`. Fails if this base token.
    /// For `ft_transfer` and `ft_transfer_call` `memo` is the `description` of the proposal.
    Transfer {
        /// Can be "" for $NEAR or a valid account id.
        token_id: AccountId,
        receiver_id: ValidAccountId,
        amount: U128,
        msg: Option<String>,
    },
    /// Sets staking contract. Can only be proposed if staking contract is not set yet.
    SetStakingContract { staking_id: ValidAccountId },
    /// Add new bounty.
    AddBounty { bounty: Bounty },
    /// Indicates that given bounty is done by given user.
    BountyDone {
        bounty_id: u64,
        receiver_id: ValidAccountId,
    },
    /// Just a signaling vote, with no execution.
    Vote,
}

impl ProposalKind {
    /// Returns label of policy for given type of proposal.
    pub fn to_policy_label(&self) -> &str {
        match self {
            ProposalKind::ChangeConfig { .. } => "config",
            ProposalKind::ChangePolicy { .. } => "policy",
            ProposalKind::AddMemberToRole { .. } => "add_member_to_role",
            ProposalKind::RemoveMemberFromRole { .. } => "remove_member_from_role",
            ProposalKind::FunctionCall { .. } => "call",
            ProposalKind::UpgradeSelf { .. } => "upgrade_self",
            ProposalKind::UpgradeRemote { .. } => "upgrade_remote",
            ProposalKind::Transfer { .. } => "transfer",
            ProposalKind::SetStakingContract { .. } => "set_vote_token",
            ProposalKind::AddBounty { .. } => "add_bounty",
            ProposalKind::BountyDone { .. } => "bounty_done",
            ProposalKind::Vote => "vote",
        }
    }
}

/// Votes recorded in the proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Vote {
    Approve = 0x0,
    Reject = 0x1,
    Remove = 0x2,
}

impl From<Action> for Vote {
    fn from(action: Action) -> Self {
        match action {
            Action::VoteApprove => Vote::Approve,
            Action::VoteReject => Vote::Reject,
            Action::VoteRemove => Vote::Remove,
            _ => unreachable!(),
        }
    }
}

/// Proposal that are sent to this DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Proposal {
    /// Original proposer.
    pub proposer: AccountId,
    /// Description of this proposal.
    pub description: String,
    /// Kind of proposal with relevant information.
    pub kind: ProposalKind,
    /// Current status of the proposal.
    pub status: ProposalStatus,
    /// Count of votes per role per decision: yes / no / spam.
    pub vote_counts: HashMap<String, [Balance; 3]>,
    /// Map of who voted and how.
    pub votes: HashMap<AccountId, Vote>,
    /// Submission time (for voting period).
    pub submission_time: WrappedTimestamp,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum VersionedProposal {
    Default(Proposal),
}

impl From<VersionedProposal> for Proposal {
    fn from(v: VersionedProposal) -> Self {
        match v {
            VersionedProposal::Default(p) => p,
        }
    }
}

impl Proposal {
    /// Adds vote of the given user with given `amount` of weight. If user already voted, fails.
    pub fn update_votes(
        &mut self,
        account_id: &AccountId,
        roles: &[String],
        vote: Vote,
        policy: &Policy,
        user_weight: Balance,
    ) {
        for role in roles {
            let amount = if policy.is_token_weighted(role, &self.kind.to_policy_label().to_string())
            {
                user_weight
            } else {
                1
            };
            self.vote_counts.entry(role.clone()).or_insert([0u128; 3])[vote.clone() as usize] +=
                amount;
        }
        assert!(
            self.votes.insert(account_id.clone(), vote).is_none(),
            "ERR_ALREADY_VOTED"
        );
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalInput {
    /// Description of this proposal.
    pub description: String,
    /// Kind of proposal with relevant information.
    pub kind: ProposalKind,
}

impl From<ProposalInput> for Proposal {
    fn from(input: ProposalInput) -> Self {
        Self {
            proposer: env::predecessor_account_id(),
            description: input.description,
            kind: input.kind,
            status: ProposalStatus::InProgress,
            vote_counts: HashMap::default(),
            votes: HashMap::default(),
            submission_time: WrappedTimestamp::from(env::block_timestamp()),
        }
    }
}

impl Contract {
    /// Execute payout of given token to given user.
    pub(crate) fn internal_payout(
        &mut self,
        token_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: String,
        msg: Option<String>,
    ) -> PromiseOrValue<()> {
        if token_id == BASE_TOKEN {
            Promise::new(receiver_id.clone()).transfer(amount).into()
        } else {
            if let Some(msg) = msg {
                ext_fungible_token::ft_transfer_call(
                    receiver_id.clone(),
                    U128(amount),
                    Some(memo),
                    msg,
                    &token_id,
                    ONE_YOCTO_NEAR,
                    GAS_FOR_FT_TRANSFER,
                )
                .into()
            } else {
                ext_fungible_token::ft_transfer(
                    receiver_id.clone(),
                    U128(amount),
                    Some(memo),
                    &token_id,
                    ONE_YOCTO_NEAR,
                    GAS_FOR_FT_TRANSFER,
                )
                .into()
            }
        }
    }

    /// Executes given proposal and updates the contract's state.
    fn internal_execute_proposal(
        &mut self,
        policy: &Policy,
        proposal: &Proposal,
    ) -> PromiseOrValue<()> {
        // Return the proposal bond.
        Promise::new(proposal.proposer.clone()).transfer(policy.proposal_bond.0);
        match &proposal.kind {
            ProposalKind::ChangeConfig { config } => {
                self.config.set(config);
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicy { policy } => {
                self.policy.set(policy);
                PromiseOrValue::Value(())
            }
            ProposalKind::AddMemberToRole { member_id, role } => {
                let mut new_policy = policy.clone();
                new_policy.add_member_to_role(role, &member_id.clone().into());
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::RemoveMemberFromRole { member_id, role } => {
                let mut new_policy = policy.clone();
                new_policy.remove_member_from_role(role, &member_id.clone().into());
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::FunctionCall {
                receiver_id,
                actions,
            } => {
                let mut promise = Promise::new(receiver_id.clone().into());
                for action in actions {
                    promise = promise.function_call(
                        action.method_name.clone().into_bytes(),
                        action.args.clone().into(),
                        action.deposit.0,
                        action.gas.0,
                    )
                }
                promise.into()
            }
            ProposalKind::UpgradeSelf { hash } => {
                upgrade_self(&CryptoHash::from(hash.clone()));
                PromiseOrValue::Value(())
            }
            ProposalKind::UpgradeRemote {
                receiver_id,
                method_name,
                hash,
            } => {
                upgrade_remote(
                    &receiver_id.clone().into(),
                    method_name,
                    &CryptoHash::from(hash.clone()),
                );
                PromiseOrValue::Value(())
            }
            ProposalKind::Transfer {
                token_id,
                receiver_id,
                amount,
                msg,
            } => self.internal_payout(
                token_id,
                &receiver_id.clone().into(),
                amount.0,
                proposal.description.clone(),
                msg.clone(),
            ),
            ProposalKind::SetStakingContract { staking_id } => {
                assert!(self.staking_id.is_none(), "ERR_INVALID_STAKING_CHANGE");
                self.staking_id = Some(staking_id.clone().into());
                PromiseOrValue::Value(())
            }
            ProposalKind::AddBounty { bounty } => {
                self.internal_add_bounty(bounty);
                PromiseOrValue::Value(())
            }
            ProposalKind::BountyDone {
                bounty_id,
                receiver_id,
            } => self.internal_execute_bounty_payout(*bounty_id, &receiver_id.clone().into(), true),
            ProposalKind::Vote => PromiseOrValue::Value(()),
        }
    }

    /// Process rejecting proposal.
    fn internal_reject_proposal(
        &mut self,
        policy: &Policy,
        proposal: &Proposal,
        return_bond: bool,
    ) -> PromiseOrValue<()> {
        if return_bond {
            // Return bond to the proposer.
            Promise::new(proposal.proposer.clone()).transfer(policy.proposal_bond.0);
        }
        match &proposal.kind {
            ProposalKind::BountyDone {
                bounty_id,
                receiver_id,
            } => {
                self.internal_execute_bounty_payout(*bounty_id, &receiver_id.clone().into(), false)
            }
            _ => PromiseOrValue::Value(()),
        }
    }

    pub(crate) fn internal_user_info(&self) -> UserInfo {
        let account_id = env::predecessor_account_id();
        UserInfo {
            amount: self.get_user_weight(&account_id),
            account_id,
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Add proposal to this DAO.
    #[payable]
    pub fn add_proposal(&mut self, proposal: ProposalInput) -> u64 {
        // 0. validate bond attached.
        // TODO: consider bond in the token of this DAO.
        let policy = self.policy.get().unwrap().to_policy();
        assert!(
            env::attached_deposit() >= policy.proposal_bond.0,
            "ERR_MIN_BOND"
        );

        // 1. Validate proposal.
        match &proposal.kind {
            ProposalKind::Transfer { token_id, msg, .. } => {
                assert!(
                    !(token_id == BASE_TOKEN) || msg.is_none(),
                    "ERR_BASE_TOKEN_NO_MSG"
                );
                if token_id != BASE_TOKEN {
                    assert!(
                        ValidAccountId::try_from(token_id.clone()).is_ok(),
                        "ERR_TOKEN_ID_INVALID"
                    );
                }
            }
            ProposalKind::SetStakingContract { .. } => assert!(
                self.staking_id.is_none(),
                "ERR_STAKING_CONTRACT_CANT_CHANGE"
            ),
            // TODO: add more verifications.
            _ => {}
        };

        // 2. Check permission of caller to add this type of proposal.
        assert!(
            policy
                .can_execute_action(
                    self.internal_user_info(),
                    &proposal.kind,
                    &Action::AddProposal
                )
                .1,
            "ERR_PERMISSION_DENIED"
        );

        // 3. Actually add proposal to the current list of proposals.
        let id = self.last_proposal_id;
        self.proposals
            .insert(&id, &VersionedProposal::Default(proposal.into()));
        self.last_proposal_id += 1;
        id
    }

    /// Act on given proposal by id, if permissions allow.
    /// Memo is logged but not stored in the state. Can be used to leave notes or explain the action.
    pub fn act_proposal(&mut self, id: u64, action: Action, memo: Option<String>) {
        let mut proposal: Proposal = self.proposals.get(&id).expect("ERR_NO_PROPOSAL").into();
        let policy = self.policy.get().unwrap().to_policy();
        // Check permissions for the given action.
        let (roles, allowed) =
            policy.can_execute_action(self.internal_user_info(), &proposal.kind, &action);
        assert!(allowed, "ERR_PERMISSION_DENIED");
        let sender_id = env::predecessor_account_id();
        // Update proposal given action. Returns true if should be updated in storage.
        let update = match action {
            Action::AddProposal => env::panic(b"ERR_WRONG_ACTION"),
            Action::RemoveProposal => {
                self.proposals.remove(&id);
                false
            }
            Action::VoteApprove | Action::VoteReject | Action::VoteRemove => {
                assert_eq!(
                    proposal.status,
                    ProposalStatus::InProgress,
                    "ERR_PROPOSAL_NOT_IN_PROGRESS"
                );
                proposal.update_votes(
                    &sender_id,
                    &roles,
                    Vote::from(action),
                    &policy,
                    self.get_user_weight(&sender_id),
                );
                // Updates proposal status with new votes using the policy.
                proposal.status =
                    policy.proposal_status(&proposal, roles, self.total_delegation_amount);
                if proposal.status == ProposalStatus::Approved {
                    self.internal_execute_proposal(&policy, &proposal);
                    true
                } else if proposal.status == ProposalStatus::Removed {
                    self.internal_reject_proposal(&policy, &proposal, false);
                    self.proposals.remove(&id);
                    false
                } else if proposal.status == ProposalStatus::Rejected {
                    self.internal_reject_proposal(&policy, &proposal, true);
                    true
                } else {
                    // Still in progress or expired.
                    true
                }
            }
            Action::Finalize => {
                proposal.status = policy.proposal_status(
                    &proposal,
                    policy.roles.iter().map(|r| r.name.clone()).collect(),
                    self.total_delegation_amount,
                );
                assert_eq!(
                    proposal.status,
                    ProposalStatus::Expired,
                    "ERR_PROPOSAL_NOT_EXPIRED"
                );
                self.internal_reject_proposal(&policy, &proposal, true);
                true
            }
            Action::MoveToHub => false,
        };
        if update {
            self.proposals
                .insert(&id, &VersionedProposal::Default(proposal));
        }
        if let Some(memo) = memo {
            log!("Memo: {}", memo);
        }
    }
}

'''
'''--- sputnikdao2-gasfix/src/types.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::env::BLOCKCHAIN_INTERFACE;
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance, Gas};

const BLOCKCHAIN_INTERFACE_NOT_SET_ERR: &str = "Blockchain interface not set.";

/// Account ID used for $NEAR.
pub const BASE_TOKEN: &str = "";

/// 1 yN to prevent access key fraud.
pub const ONE_YOCTO_NEAR: Balance = 1;

/// Gas for single ft_transfer call.
pub const GAS_FOR_FT_TRANSFER: Gas = 10_000_000_000_000;

/// Gas for upgrading this contract on promise creation + deploying new contract.
// pub const GAS_FOR_UPGRADE_SELF_DEPLOY: Gas = 30_000_000_000_000;
pub const GAS_FOR_UPGRADE_SELF_DEPLOY: Gas = 200_000_000_000_000;

// pub const GAS_FOR_UPGRADE_REMOTE_DEPLOY: Gas = 10_000_000_000_000;
pub const GAS_FOR_UPGRADE_REMOTE_DEPLOY: Gas = 200_000_000_000_000;

/// Configuration of the DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// Name of the DAO.
    pub name: String,
    /// Purpose of this DAO.
    pub purpose: String,
    /// Generic metadata. Can be used by specific UI to store additional data.
    /// This is not used by anything in the contract.
    pub metadata: Base64VecU8,
}

#[cfg(test)]
impl Config {
    pub fn test_config() -> Self {
        Self {
            name: "Test".to_string(),
            purpose: "to test".to_string(),
            metadata: Base64VecU8(vec![]),
        }
    }
}

/// Set of possible action to take.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    /// Action to add proposal. Used internally.
    AddProposal,
    /// Action to remove given proposal. Used for immediate deletion in special cases.
    RemoveProposal,
    /// Vote to approve given proposal or bounty.
    VoteApprove,
    /// Vote to reject given proposal or bounty.
    VoteReject,
    /// Vote to remove given proposal or bounty (because it's spam).
    VoteRemove,
    /// Finalize proposal, called when it's expired to return the funds
    /// (or in the future can be used for early proposal closure).
    Finalize,
    /// Move a proposal to the hub to shift into another DAO.
    MoveToHub,
}

impl Action {
    pub fn to_policy_label(&self) -> String {
        format!("{:?}", self)
    }
}

/// Self upgrade, optimizes gas by not loading into memory the code.
pub(crate) fn upgrade_self(hash: &[u8]) {
    let current_id = env::current_account_id().into_bytes();
    let method_name = "migrate".as_bytes().to_vec();
    let attached_gas = env::prepaid_gas() - env::used_gas() - GAS_FOR_UPGRADE_SELF_DEPLOY;
    unsafe {
        BLOCKCHAIN_INTERFACE.with(|b| {
            // Load input (wasm code) into register 0.
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .storage_read(hash.len() as _, hash.as_ptr() as _, 0);
            // schedule a Promise tx to this same contract
            let promise_id = b
                .borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);
            // 1st item in the Tx: "deploy contract" (code is taken from register 0)
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);
            // 2nd item in the Tx: call this_contract.migrate() with remaining gas
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .promise_batch_action_function_call(
                    promise_id,
                    method_name.len() as _,
                    method_name.as_ptr() as _,
                    0 as _,
                    0 as _,
                    0 as _,
                    attached_gas,
                );
        });
    }
}

pub(crate) fn upgrade_remote(receiver_id: &AccountId, method_name: &str, hash: &[u8]) {
    unsafe {
        BLOCKCHAIN_INTERFACE.with(|b| {
            // Load input into register 0.
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .storage_read(hash.len() as _, hash.as_ptr() as _, 0);
            let promise_id = b
                .borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .promise_batch_create(receiver_id.len() as _, receiver_id.as_ptr() as _);
            let attached_gas = env::prepaid_gas() - env::used_gas() - GAS_FOR_UPGRADE_REMOTE_DEPLOY;
            b.borrow()
                .as_ref()
                .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                .promise_batch_action_function_call(
                    promise_id,
                    method_name.len() as _,
                    method_name.as_ptr() as _,
                    u64::MAX as _,
                    0 as _,
                    0 as _,
                    attached_gas,
                );
        });
    }
}

'''
'''--- sputnikdao2-gasfix/src/views.rs ---
use std::cmp::min;

use crate::*;

/// This is format of output via JSON for the proposal.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalOutput {
    /// Id of the proposal.
    pub id: u64,
    #[serde(flatten)]
    pub proposal: Proposal,
}

/// This is format of output via JSON for the bounty.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BountyOutput {
    /// Id of the bounty.
    pub id: u64,
    #[serde(flatten)]
    pub bounty: Bounty,
}

#[near_bindgen]
impl Contract {
    /// Returns semver of this contract.
    pub fn version(&self) -> String {
        env!("CARGO_PKG_VERSION").to_string()
    }

    /// Returns config of this contract.
    pub fn get_config(&self) -> Config {
        self.config.get().unwrap().clone()
    }

    /// Returns policy of this contract.
    pub fn get_policy(&self) -> Policy {
        self.policy.get().unwrap().to_policy().clone()
    }

    /// Returns staking contract if available. Otherwise returns empty.
    pub fn get_staking_contract(&self) -> AccountId {
        self.staking_id.clone().unwrap_or_default()
    }

    /// Returns if blob with given hash is stored.
    pub fn has_blob(&self, hash: Base58CryptoHash) -> bool {
        env::storage_read(&CryptoHash::from(hash)).is_some()
    }

    /// Returns available amount of NEAR that can be spent (outside of amount for storage and bonds).
    pub fn get_available_amount(&self) -> U128 {
        U128(env::account_balance() - self.locked_amount)
    }

    /// Returns total delegated stake.
    pub fn delegation_total_supply(&self) -> U128 {
        U128(self.total_delegation_amount)
    }

    /// Returns delegated stake to given account.
    pub fn delegation_balance_of(&self, account_id: ValidAccountId) -> U128 {
        U128(
            self.delegations
                .get(account_id.as_ref())
                .unwrap_or_default(),
        )
    }

    /// Last proposal's id.
    pub fn get_last_proposal_id(&self) -> u64 {
        self.last_proposal_id
    }

    /// Get proposals in paginated view.
    pub fn get_proposals(&self, from_index: u64, limit: u64) -> Vec<ProposalOutput> {
        (from_index..min(self.last_proposal_id, from_index + limit))
            .filter_map(|id| {
                self.proposals.get(&id).map(|proposal| ProposalOutput {
                    id,
                    proposal: proposal.into(),
                })
            })
            .collect()
    }

    /// Get specific proposal.
    pub fn get_proposal(&self, id: u64) -> ProposalOutput {
        let proposal = self.proposals.get(&id).expect("ERR_NO_PROPOSAL");
        ProposalOutput {
            id,
            proposal: proposal.into(),
        }
    }

    /// Get given bounty by id.
    pub fn get_bounty(&self, id: u64) -> BountyOutput {
        let bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY");
        BountyOutput {
            id,
            bounty: bounty.into(),
        }
    }

    /// Get number of bounties.
    pub fn get_last_bounty_id(&self) -> u64 {
        self.last_bounty_id
    }

    /// Get `limit` of bounties from given index.
    pub fn get_bounties(&self, from_index: u64, limit: u64) -> Vec<BountyOutput> {
        (from_index..std::cmp::min(from_index + limit, self.last_bounty_id))
            .filter_map(|id| {
                self.bounties.get(&id).map(|bounty| BountyOutput {
                    id,
                    bounty: bounty.into(),
                })
            })
            .collect()
    }

    /// Get bounty claims for given user.
    pub fn get_bounty_claims(&self, account_id: ValidAccountId) -> Vec<BountyClaim> {
        self.bounty_claimers
            .get(account_id.as_ref())
            .unwrap_or_default()
    }

    /// Returns number of claims per given bounty.
    pub fn get_bounty_number_of_claims(&self, id: u64) -> u32 {
        self.bounty_claims_count.get(&id).unwrap_or_default()
    }
}

'''
'''--- sputnikdao2-gasfix/tests/test_general.rs ---
use std::collections::HashMap;

use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk_sim::{call, to_yocto, view};

use sputnik_staking::User;
use sputnikdao2::{
    Action, Policy, Proposal, ProposalInput, ProposalKind, ProposalStatus, RoleKind,
    RolePermission, VersionedPolicy, VotePolicy,
};

use crate::utils::*;

mod utils;

fn user(id: u32) -> String {
    format!("user{}", id)
}

#[test]
fn test_multi_council() {
    let (root, dao) = setup_dao();
    let user1 = root.create_user(user(1), to_yocto("1000"));
    let user2 = root.create_user(user(2), to_yocto("1000"));
    let user3 = root.create_user(user(3), to_yocto("1000"));
    let new_policy = Policy {
        roles: vec![
            RolePermission {
                name: "all".to_string(),
                kind: RoleKind::Everyone,
                permissions: vec!["*:AddProposal".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "council".to_string(),
                kind: RoleKind::Group(vec![user(1), user(2)].into_iter().collect()),
                permissions: vec!["*:*".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "community".to_string(),
                kind: RoleKind::Group(vec![user(1), user(3), user(4)].into_iter().collect()),
                permissions: vec!["*:*".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
        ],
        default_vote_policy: VotePolicy::default(),
        proposal_bond: U128(10u128.pow(24)),
        proposal_period: WrappedDuration::from(1_000_000_000 * 60 * 60 * 24 * 7),
        bounty_bond: U128(10u128.pow(24)),
        bounty_forgiveness_period: WrappedDuration::from(1_000_000_000 * 60 * 60 * 24),
    };
    add_proposal(
        &root,
        &dao,
        ProposalInput {
            description: "new policy".to_string(),
            kind: ProposalKind::ChangePolicy {
                policy: VersionedPolicy::Current(new_policy.clone()),
            },
        },
    )
    .assert_success();
    vote(vec![&root], &dao, 0);
    assert_eq!(view!(dao.get_policy()).unwrap_json::<Policy>(), new_policy);
    add_transfer_proposal(&root, &dao, base_token(), user(1), 1_000_000, None).assert_success();
    vote(vec![&user2], &dao, 1);
    vote(vec![&user3], &dao, 1);
    let proposal = view!(dao.get_proposal(1)).unwrap_json::<Proposal>();
    // Votes from members in different councils.
    assert_eq!(proposal.status, ProposalStatus::InProgress);
    // Finish with vote that is in both councils, which approves the proposal.
    vote(vec![&user1], &dao, 1);
    let proposal = view!(dao.get_proposal(1)).unwrap_json::<Proposal>();
    assert_eq!(proposal.status, ProposalStatus::Approved);
}

#[test]
fn test_create_dao_and_use_token() {
    let (root, dao) = setup_dao();
    let user2 = root.create_user(user(2), to_yocto("1000"));
    let user3 = root.create_user(user(3), to_yocto("1000"));
    let test_token = setup_test_token(&root);
    let staking = setup_staking(&root);

    assert!(view!(dao.get_staking_contract())
        .unwrap_json::<AccountId>()
        .is_empty());
    add_member_proposal(&root, &dao, user2.account_id.clone()).assert_success();
    assert_eq!(view!(dao.get_last_proposal_id()).unwrap_json::<u64>(), 1);
    // Voting by user who is not member should fail.
    should_fail(call!(user2, dao.act_proposal(0, Action::VoteApprove, None)));
    call!(root, dao.act_proposal(0, Action::VoteApprove, None)).assert_success();
    // voting second time should fail.
    should_fail(call!(root, dao.act_proposal(0, Action::VoteApprove, None)));
    // Add 3rd member.
    add_member_proposal(&user2, &dao, user3.account_id.clone()).assert_success();
    vote(vec![&root, &user2], &dao, 1);
    let policy = view!(dao.get_policy()).unwrap_json::<Policy>();
    assert_eq!(policy.roles.len(), 2);
    assert_eq!(
        policy.roles[1].kind,
        RoleKind::Group(
            vec![
                root.account_id.clone(),
                user2.account_id.clone(),
                user3.account_id.clone()
            ]
            .into_iter()
            .collect()
        )
    );
    add_proposal(
        &user2,
        &dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::SetStakingContract {
                staking_id: to_va("staking".to_string()),
            },
        },
    )
    .assert_success();
    vote(vec![&user3, &user2], &dao, 2);
    assert!(!view!(dao.get_staking_contract())
        .unwrap_json::<AccountId>()
        .is_empty());
    assert_eq!(
        view!(dao.get_proposal(2)).unwrap_json::<Proposal>().status,
        ProposalStatus::Approved
    );
    assert_eq!(
        view!(staking.ft_total_supply()).unwrap_json::<U128>().0,
        to_yocto("0")
    );
    call!(
        user2,
        test_token.mint(to_va(user2.account_id.clone()), U128(to_yocto("100")))
    )
    .assert_success();
    call!(
        user2,
        test_token.storage_deposit(Some(to_va(staking.account_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        user2,
        staking.storage_deposit(None, None),
        deposit = to_yocto("1")
    );
    call!(
        user2,
        test_token.ft_transfer_call(
            to_va(staking.account_id()),
            U128(to_yocto("10")),
            None,
            "".to_string()
        ),
        deposit = 1
    )
    .assert_success();
    assert_eq!(
        view!(staking.ft_total_supply()).unwrap_json::<U128>().0,
        to_yocto("10")
    );
    let user2_id = to_va(user2.account_id.clone());
    assert_eq!(
        view!(staking.ft_balance_of(user2_id.clone()))
            .unwrap_json::<U128>()
            .0,
        to_yocto("10")
    );
    assert_eq!(
        view!(test_token.ft_balance_of(user2_id.clone()))
            .unwrap_json::<U128>()
            .0,
        to_yocto("90")
    );
    call!(user2, staking.withdraw(U128(to_yocto("5")))).assert_success();
    assert_eq!(
        view!(staking.ft_total_supply()).unwrap_json::<U128>().0,
        to_yocto("5")
    );
    assert_eq!(
        view!(test_token.ft_balance_of(user2_id.clone()))
            .unwrap_json::<U128>()
            .0,
        to_yocto("95")
    );
    call!(
        user2,
        staking.delegate(user2_id.clone(), U128(to_yocto("5")))
    )
    .assert_success();
    call!(
        user2,
        staking.undelegate(user2_id.clone(), U128(to_yocto("1")))
    )
    .assert_success();
    // should fail right after undelegation as need to wait for voting period before can delegate again.
    should_fail(call!(
        user2,
        staking.delegate(user2_id.clone(), U128(to_yocto("1")))
    ));
    let user = view!(staking.get_user(user2_id.clone())).unwrap_json::<User>();
    assert_eq!(
        user.delegated_amounts,
        vec![(user2_id.to_string(), U128(to_yocto("4")))]
    );
    assert_eq!(
        view!(dao.delegation_total_supply()).unwrap_json::<U128>().0,
        to_yocto("4")
    );
    assert_eq!(
        view!(dao.delegation_balance_of(user2_id))
            .unwrap_json::<U128>()
            .0,
        to_yocto("4")
    );
}

/// Test various cases that must fail.
#[test]
fn test_failures() {
    let (root, dao) = setup_dao();
    should_fail(add_transfer_proposal(
        &root,
        &dao,
        base_token(),
        user(1),
        1_000_000,
        Some("some".to_string()),
    ));
    should_fail(add_transfer_proposal(
        &root,
        &dao,
        "not:a^valid.token@".to_string(),
        user(1),
        1_000_000,
        None,
    ));
}

'''
'''--- sputnikdao2-gasfix/tests/test_upgrade.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base58CryptoHash, ValidAccountId};
use near_sdk::serde_json::json;
use near_sdk_sim::{call, to_yocto, view, DEFAULT_GAS};
use sputnikdao2::{Action, ProposalInput, ProposalKind};

mod utils;
use crate::utils::*;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    DAO_WASM_BYTES => "res/sputnikdao2.wasm",
    OTHER_WASM_BYTES => "res/ref_exchange_release.wasm"
}

#[test]
fn test_upgrade() {
    let (root, dao) = setup_dao();
    let hash = root
        .call(
            dao.user_account.account_id.clone(),
            "store_blob",
            &DAO_WASM_BYTES,
            near_sdk_sim::DEFAULT_GAS,
            to_yocto("200"),
        )
        .unwrap_json::<Base58CryptoHash>();
    call!(
        root,
        dao.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::UpgradeSelf { hash }
        }),
        deposit = to_yocto("1")
    )
    .assert_success();
    assert_eq!(view!(dao.get_last_proposal_id()).unwrap_json::<u64>(), 1);
    call!(root, dao.act_proposal(0, Action::VoteApprove, None)).assert_success();
    assert_eq!(view!(dao.version()).unwrap_json::<String>(), "2.0.0");
    call!(root, dao.remove_blob(hash)).assert_success();
    should_fail(call!(root, dao.remove_blob(hash)));
}

#[derive(BorshSerialize, BorshDeserialize)]
struct NewArgs {
    owner_id: ValidAccountId,
    exchange_fee: u32,
    referral_fee: u32,
}

/// Test that Sputnik can upgrade another contract.
#[test]
fn test_upgrade_other() {
    let (root, dao) = setup_dao();
    let ref_account_id = "ref-finance".to_string();
    let _ = root.deploy_and_init(
        &OTHER_WASM_BYTES,
        ref_account_id.clone(),
        "new",
        &json!({
            "owner_id": to_va(dao.account_id()),
            "exchange_fee": 1,
            "referral_fee": 1,
        })
        .to_string()
        .into_bytes(),
        to_yocto("1000"),
        DEFAULT_GAS,
    );
    let hash = root
        .call(
            dao.user_account.account_id.clone(),
            "store_blob",
            &OTHER_WASM_BYTES,
            near_sdk_sim::DEFAULT_GAS,
            to_yocto("200"),
        )
        .unwrap_json::<Base58CryptoHash>();
    add_proposal(
        &root,
        &dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::UpgradeRemote {
                receiver_id: to_va(ref_account_id.clone()),
                method_name: "upgrade".to_string(),
                hash,
            },
        },
    )
    .assert_success();
    call!(root, dao.act_proposal(0, Action::VoteApprove, None)).assert_success();
}

'''
'''--- sputnikdao2-gasfix/tests/utils/mod.rs ---
#![allow(dead_code)]
use std::convert::TryFrom;

pub use near_sdk::json_types::{Base64VecU8, ValidAccountId, WrappedDuration, U64};
use near_sdk::{AccountId, Balance};
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, ContractAccount, ExecutionResult, UserAccount,
};

use near_sdk::json_types::U128;
use sputnik_staking::ContractContract as StakingContract;
use sputnikdao2::{
    Action, Config, ContractContract as DAOContract, ProposalInput, ProposalKind, VersionedPolicy,
};
use test_token::ContractContract as TestTokenContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    DAO_WASM_BYTES => "res/sputnikdao2.wasm",
    TEST_TOKEN_WASM_BYTES => "../test-token/res/test_token.wasm",
    STAKING_WASM_BYTES => "../sputnik-staking/res/sputnik_staking.wasm",
}

type Contract = ContractAccount<DAOContract>;

pub fn base_token() -> String {
    "".to_string()
}

pub fn should_fail(r: ExecutionResult) {
    match r.status() {
        ExecutionStatus::Failure(_) => {}
        _ => panic!("Should fail"),
    }
}

pub fn setup_dao() -> (UserAccount, Contract) {
    let root = init_simulator(None);
    let config = Config {
        name: "test".to_string(),
        purpose: "to test".to_string(),
        metadata: Base64VecU8(vec![]),
    };
    let dao = deploy!(
        contract: DAOContract,
        contract_id: "dao".to_string(),
        bytes: &DAO_WASM_BYTES,
        signer_account: root,
        deposit: to_yocto("200"),
        init_method: new(config, VersionedPolicy::Default(vec![root.account_id.clone()]))
    );
    (root, dao)
}

pub fn setup_test_token(root: &UserAccount) -> ContractAccount<TestTokenContract> {
    deploy!(
        contract: TestTokenContract,
        contract_id: "test_token".to_string(),
        bytes: &TEST_TOKEN_WASM_BYTES,
        signer_account: root,
        deposit: to_yocto("200"),
        init_method: new()
    )
}

pub fn setup_staking(root: &UserAccount) -> ContractAccount<StakingContract> {
    deploy!(
        contract: StakingContract,
        contract_id: "staking".to_string(),
        bytes: &STAKING_WASM_BYTES,
        signer_account: root,
        deposit: to_yocto("100"),
        init_method: new(to_va("dao".to_string()), to_va("test_token".to_string()), U64(100_000_000_000))
    )
}

pub fn add_proposal(
    root: &UserAccount,
    dao: &Contract,
    proposal: ProposalInput,
) -> ExecutionResult {
    call!(root, dao.add_proposal(proposal), deposit = to_yocto("1"))
}

pub fn add_member_proposal(
    root: &UserAccount,
    dao: &Contract,
    member_id: AccountId,
) -> ExecutionResult {
    add_proposal(
        root,
        dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: to_va(member_id),
                role: "council".to_string(),
            },
        },
    )
}

pub fn add_transfer_proposal(
    root: &UserAccount,
    dao: &Contract,
    token_id: AccountId,
    receiver_id: AccountId,
    amount: Balance,
    msg: Option<String>,
) -> ExecutionResult {
    add_proposal(
        root,
        dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::Transfer {
                token_id,
                receiver_id: to_va(receiver_id),
                amount: U128(amount),
                msg,
            },
        },
    )
}

pub fn vote(users: Vec<&UserAccount>, dao: &Contract, proposal_id: u64) {
    for user in users.into_iter() {
        call!(
            user,
            dao.act_proposal(proposal_id, Action::VoteApprove, None)
        )
        .assert_success();
    }
}

pub fn to_va(a: AccountId) -> ValidAccountId {
    ValidAccountId::try_from(a).unwrap()
}

'''
'''--- sputnikdao2/ABI.md ---
# Sputnik DAO Contract ABIs

V1 is archived in a different repo. :)

## Sputnik DAO :: v2
```
{
  "viewMethods": [
    "version",
    "get_config",
    "get_policy",
    "get_staking_contract",
    "has_blob",
    "get_available_amount",
    "delegation_total_supply",
    "delegation_balance_of",
    "get_last_proposal_id",
    "get_proposals",
    "get_proposal",
    "get_bounty",
    "get_last_bounty_id",
    "get_bounties",
    "get_bounty_claims",
    "get_bounty_number_of_claims"
  ],
  "changeMethods": [
    "new",
    "migrate",
    "store_blob",
    "remove_blob",
    "add_proposal",
    "act_proposal",
    "bounty_claim",
    "bounty_done",
    "bounty_giveup",
    "register_delegation",
    "delegate",
    "undelegate"
  ],
}
```

## Sputnik DAO :: v3
```
{
  "viewMethods": [
    "version",
    "get_config",
    "get_policy",
    "get_staking_contract",
    "has_blob",
    "get_locked_storage_amount",
    "get_available_amount",
    "delegation_total_supply",
    "delegation_balance_of",
    "delegation_balance_ratio",
    "get_last_proposal_id",
    "get_proposals",
    "get_proposal",
    "get_bounty",
    "get_last_bounty_id",
    "get_bounties",
    "get_bounty_claims",
    "get_bounty_number_of_claims",
    "get_factory_info"
  ],
  "changeMethods": [
    "new",
    "migrate",
    "store_blob",
    "remove_blob",
    "add_proposal",
    "act_proposal",
    "bounty_claim",
    "bounty_done",
    "bounty_giveup",
    "register_delegation",
    "delegate",
    "undelegate"
  ],
}
```
'''
'''--- sputnikdao2/Cargo.toml ---
[package]
name = "sputnikdao2"
version = "2.0.0"
authors = ["Sputnik Devs <near-daos@protonmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = {version = "4.0.0-pre.4", features = ["unstable"]}
near-contract-standards = "4.0.0-pre.4"
hex = "0.4.2"

[dependencies.serde_with]
version = "1.4.0"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.4"
test-token = { path = "../test-token" }
sputnik-staking = { path = "../sputnik-staking" }
sputnikdao-factory2 = { path = "../sputnikdao-factory2" }

'''
'''--- sputnikdao2/TestPlan.md ---
# Sputnik Test Planning

The following is coverage checklists & notes about context tests needed to check the security of the Sputnik DAO contracts. These tests are aimed at 100% of the latest version, and best coverage of older versions.

# Sputnik Factory

## Init & Default
### new
- [ ] Can instantiate a new factory with default struct, including DAOs set.
- [ ] Stores the latest compiled version of Sputnik DAO contract in storage
- [ ] Creates metadata for the latest compiled version of Sputnik DAO
- [ ] Does not allow re-init
- [ ] Does not allow anyone but owner to call "new"

## DAOs
### Creation
- [ ] Allows any account to call create method
- [ ] Created DAO becomes a sub-account of the factory. Example for new DAO: "awesome.sputnik.near"
- [ ] Creates a new DAO & instantiates with the correct default Sputnik DAO contract from storage - see metadata
- [ ] Returns the payment amount, if the creation failed for any reason
- [ ] DAO Balance is equal to payment amount
- [ ] DAO exists in the list of DAOs upon successful creation
- [ ] Fails if the DAO name exists
- [ ] Fails if the DAO name is not a valid account ID
### Upgrades
- [ ] DAO Can update to a specific code_hash version of Sputnik DAO Code
- [ ] Fails if DAO is not within the list of supported DAOs
- [ ] Fails if DAO tries a code_hash that doesnt exist
- [ ] Fails if predecessor is not the DAO getting upgraded (DAO proposal must trigger upgrade)

## Ownership
### Changing Owner
- [ ] Can get current owner
- [ ] Fails if trying to set owner from non-owner account
- [ ] Owner can be a DAO account
- [ ] Owner gets successfully updated
### Adding Code Version
- [ ] Can store code as blob in factory
- [ ] Can set a default code_hash
- [ ] Fails if not owner of factory
- [ ] Fails if no code is attached when storing a code blob
- [ ] Fails if code blob is too small to be a legit contract
- [ ] Fails if attached payment doesnt support the storage cost
### Adding Code Metadata
- [ ] Can add metadata for an existing set of Sputnik DAO Code (code_hash is available only upon storage of contract inside factory)
- [ ] Can set the code_hash as default
- [ ] Metadata version and other params meet types & spec standards
- [ ] Fails to add code metadata if code_hash doesn't exist
- [ ] Can remove code metadata if called by owner
- [ ] Fails to remove code metadata if metadata by code_hash doesn't exist
### Removing Code Version
- [ ] Can delete a code blob by code_hash
- [ ] Can delete any/all associated code metadata for the same code_hash
- [ ] Confirm storage is empty after deletion success
- [ ] Fails if non-owner attempting to delete code blob
- [ ] Fails if no code blob exists

## views
### get_dao_list
- [ ] Returns empty array for new factory
- [ ] Returns full list of DAOs
- [ ] NOTE: This method will fail when list gets too long for gas to return on RPC
### get_number_daos
- [ ] Returns an integer representing the total amount of DAOs known to factory
### get_daos
- [ ] (Needs Impl) Returns default list of DAOs with a max length of 100 & offset of 0.
- [ ] Returns a list of DAOs matching the specified `from_index` and `limit`.
- [ ] Capable of returning non-zero indexed list, so pagination can be verified
### get_owner
- [ ] Returns a string representing the account that owns the factory
- [ ] Fails if storage is corrupted or no owner
### get_default_code_hash
- [ ] Returns the default code_hash for a new DAO
- [ ] Returns the default code_hash that has been updated after new code blob in factory
### get_default_version
- [ ] Returns the default metadata version for a new DAO, this will be a simplified semver. Example: [2,0] for V 2.0
### get_code
- [ ] Returns an entire code blob based on given code_hash
- [ ] Returns no value if code_hash doesn't exist
### get_contracts_metadata
- [ ] Returns the supported list of all factory code_hash + metadata, indicating the supported versions available for DAOs to upgrade

# Sputnik DAO

## Dao Policy Configurations
These tests are purely for checking support of certain policy configurations, no simulations.

You can check a DAO's policy by doing: 

```bash
near view DAO_NAME.sputnik-dao.near get_policy
```

### Default
**Goal:**
Confirm the default policy acts as it should.

**TESTS:**
- [ ] TODO: 

**Default Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {}
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Threshold
**Goal:**
Each 

**TESTS:**
- [ ] TODO: 

**Threshold Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Role Weighted
**Goal:**
Each 

**TESTS:**
- [ ] TODO: 

**Threshold Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Token Weighted
**Goal:**
Each 

**TESTS:**
- [ ] TODO: 

**Threshold Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Groups Weighted
**Goal:**
Each 

**TESTS:**
- [ ] TODO: 

**Threshold Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Groups Varying Policy
**Goal:**
Each group council can have different threshold criteria for consensus. Confirm that a group can be assessed based on their individual definitions versus the default policy config.

**TESTS:**
- [ ] TODO: 

**Varying Policy Config:**

```json
{
  "roles": [
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    },
    {
      "name": "admins",
      "kind": {
        "Group": [
          "admin_1.testnet",
          "admin_2.testnet",
          "admin_3.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "60",
          "threshold": []
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

## Staking Token
### None
- [ ] Confirming other policies means non token-staking works fine
### New Staking Contract
- [ ] Can deploy a new staking contract, configured to the right DAO owner, token & stake period
- [ ] DAO Can propose and accept the staking contract proposal
- [ ] Users can pre-pay storage & register to delegate tokens
- [ ] Users can deposit tokens using FT transfers
- [ ] Users can delegate to themselves within the staking contract
- [ ] Users can delegate to a different user within the staking contract
- [ ] Can check the amounts held within the staking contract
- [ ] Users can undelegate tokens from a delegation
- [ ] Users can withdraw any available tokens that aren't delegated in the staking contract

## bounties

### Happy path
Creates an end-to-end check of happy path completion
- [x] Setup test token
- [x] propose a bounty
- [x] Vote on the bounty
- [x] Claim the bounty
- [x] Check bounty has claims
- [x] Make bounty done
- [x] Check bounty has claims
- [x] Finalize bounty proposal
- [x] Check bounty proposal approved

### bounty_claim
Claims given bounty by caller with given expected duration to execute.
- [x] The method could panic if the bounty with given id doesn't exist
- [x] Should panic if `attached_deposit` is not equal to the corresponding `bounty_bond`
- [x] Should panic in case of wrong deadline
- [x] Should panic if all bounties are claimed
- [x] Should increase number of claims
- [x] Should add this claim to the list of claims, done by this account
### bounty_done
Reports that bounty is done. Creates a proposal to vote for paying out the bounty.
- [x] Should panic if the caller is not in the list of claimers
- [x] Should panic if the list of claims for the caller of the method doesn't contain the claim with given ID
- [x] Should panic if the bounty claim is completed
- [x] If claim is not expired, the `bounty_done` can only be called by the claimer
- [x] If not expired, proposal should be added, claim is marked as completed
### bounty_giveup
Gives up working on the bounty.
- [x] Should panic if the caller is not in the list of claimers
- [x] Should panic if the list of claims for the caller of the method doesn't contain the claim with given ID
- [x] If within forgiveness period, `bounty_bond` should be returned
- [x] If within forgiveness period, claim should be removed from the list of claims, done by this account

## delegation

### register_delegation
Inserts a caller to the `delegations` LookupMap with zero balance.
- [x] Check that delegation appears in `delegations` LookupMap.
- [x] Can only be called by the `staking_id`
- [x] Attached deposit is handled correctly
### delegate
Adds given amount to given account as delegated weight.
- [x] Should panic if `staking_id` is `None`
- [x] Check that amount is added correctly
- [x] Check that a user can't delegate more than it has
- [x] Check that it can only be called by the `staking_id`
- [x] Can't be called without previos registration
### undelegate
Removes given amount from given account's delegations.
- [x] Should panic if `staking_id` is `None`
- [x] Check that it can only be called by the `staking_id`
- [x] Check that amount is subtracted correctly
- [x] Check that a user can't remove more than it delegated
- [x] Can't be called without previous registration

## lib

_NOTE: This covers v2 functionality for upgrades only_

### store_blob
Stores attached data into blob store and returns the hash of it.
- [x] Should panic if contract is not initialized
- [x] Should panic if the blob already exists
- [x] Should panic if the amount of the attached deposit is not enough
- [x] Should save the blob to the LookupMap
### remove_blob
Removes blob from contract storage and pays back to the original storer.
- [x] Should panic if `hash` is wrong
- [x] Should return hash of stored data
- [x] Can only be called by the original storer
- [x] Blob should be removed
- [x] The payback should be computed correctly

## Policy

_TODO: Policy is missing a lot of coverage:_

### TokenWeight
Happy path for token-weighted policy
- [x] Can create new DAO
- [x] Can set staking contract
- [x] Can change policy to TokenWeight
- [x] Can register & delegate tokens
- [x] Can use TokenWeight policy to vote & approve a proposal
### TokenWeight Self-Lock
- [x] Can create new DAO, with TokenWeight set without staking contract id
- [x] Attempt a proposal, fail to move status because voting is locked

## proposals

### add_proposal
Adds proposal to this DAO.
- [x] Check that the method fails in case of insufficient deposit 
- [x] Check that different kinds of `proposal` are validated correctly
- [x] Check that only those with a permission can add the proposal
- [x] Check that the proposal is added to the list of proposals
### act_proposal
Act on given proposal by id, if permissions allow.
- [??] Check that only those with a permission can act on the the proposal
- [x] Check that the method works correctly on any possible `action`
- [x] If the number of votes in the group has changed (new members has been added) the proposal can lose it's approved state. In this case new proposal needs to be made, this one should expire
### on_proposal_callback
Receiving callback after the proposal has been finalized.
- [??] If successful, should return bond money to the proposal originator
- [??] If the proposal execution failed (funds didn't transfer or function call failure), should move the proposal to the "Failed" state

_NOTE: Appears views are currently just helper methods and dont have test coverage_

## views
### version
- [ ] Returns the version of this contract.
### get_config
- [ ] Returns the config of this contract.
### get_policy
- [ ] Returns policy of this contract.
### get_staking_contract
- [ ] Returns the staking contract if available. Otherwise returns `None`.
### has_blob
- [ ] Returns whether the blob with given hash is stored.
### get_locked_storage_amount
- [ ] Returns the locked amount of NEAR that is used for the storage.
### get_available_amount
- [ ] Returns the available amount of NEAR that can be spent (outside of the amount for the storage and bonds).
### delegation_total_supply
- [ ] Returns the total delegated stake.
### delegation_balance_of
- [ ] Returns the delegated stake of the given account.
### delegation_balance_ratio
- [ ] Combines the balance and the total amount for calling from external contracts.
### get_last_proposal_id
- [ ] Returns the last proposal's id.
### get_proposals
- [ ] Returns a vector of the proposals.
### get_proposal
- [ ] Returns the specific proposal by id.
  - [ ] Should panic if the proposal with the given id doesn't exist
### get_bounty
- [ ] Returns the specific bounty by id.
  - [ ] Should panic if the bounty with the given id doesn't exist
### get_last_bounty_id
- [ ] Returns number of the bounties.
### get_bounties
- [ ] Returns the bounties.
### get_bounty_claims
- [ ] Returns bounty claims for given user.
### get_bounty_number_of_claims
- [ ] Returns the number of claims per given bounty.

'''
'''--- sputnikdao2/bounty-test.sh ---
#!/bin/sh
set -e
# Change these to your account ids
./build.sh
export CONTRACT_ID=sputnikdao2.md4ire.testnet
export CONTRACT_PARENT=md4ire.testnet

# Redo account (if contract already exists)
set +e
near delete $CONTRACT_ID $CONTRACT_PARENT 2> /dev/null # Ignore errors
set -e
near create-account $CONTRACT_ID --masterAccount $CONTRACT_PARENT

# Set up
near deploy $CONTRACT_ID --wasmFile res/sputnikdao2.wasm
export COUNCIL='["'$CONTRACT_ID'"]'
near call $CONTRACT_ID new '{"config": {"name": "genesis2", "purpose": "test", "metadata": ""}, "policy": '$COUNCIL'}' --accountId $CONTRACT_ID

# Add proposal for a Transfer kind that pays out 19 NEAR
near call $CONTRACT_ID add_proposal '{"proposal": {"description": "test bounty", "kind": {"AddBounty": {"bounty": {"description": "do the thing", "amount": "19000000000000000000000000", "times": 3, "max_deadline": "1925376849430593581"}}}}}' --accountId $CONTRACT_PARENT --amount 1

# Show error when a user tries to vote along with log
near call $CONTRACT_ID act_proposal '{"id": 0, "action": "VoteApprove"}' --accountId $CONTRACT_ID

# Someone claims bounty
near call $CONTRACT_ID bounty_claim '{"id": 0, "deadline": "1925376849430593581"}' --accountId $CONTRACT_PARENT --amount 1

# Show bounty claims
near view $CONTRACT_ID get_bounty_claims '{"account_id": "'$CONTRACT_PARENT'"}'

# Call bounty_done
near call $CONTRACT_ID bounty_done '{"id": 0, "description": "was not even hard. ez"}'  --accountId $CONTRACT_PARENT --amount 1
# Add BountyDone proposal done
# bounty_done adds proposal BountyDone itself
# near call $CONTRACT_ID add_proposal '{"proposal": {"description": "test bounty done", "kind": {"BountyDone": {"bounty_id": 0, "receiver_id": "'$CONTRACT_PARENT'"}}}}' --accountId $CONTRACT_PARENT --amount 1

# Vote it in
near call $CONTRACT_ID act_proposal '{"id": 1, "action": "VoteApprove"}' --accountId $CONTRACT_ID

# See how many now.
near view $CONTRACT_ID get_bounty_claims '{"account_id": "'$CONTRACT_PARENT'"}'
'''
'''--- sputnikdao2/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/sputnikdao2.wasm ./res/

'''
'''--- sputnikdao2/src/bounties.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseOrValue};

use crate::types::{convert_old_to_new_token, OldAccountId};
use crate::*;

/// Information recorded about claim of the bounty by given user.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BountyClaim {
    /// Bounty id that was claimed.
    bounty_id: u64,
    /// Start time of the claim.
    start_time: U64,
    /// Deadline specified by claimer.
    deadline: U64,
    /// Completed?
    completed: bool,
}

/// Bounty information.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Bounty {
    /// Description of the bounty.
    pub description: String,
    /// Token the bounty will be paid out.
    /// Can be "" for $NEAR or a valid account id.
    pub token: OldAccountId,
    /// Amount to be paid out.
    pub amount: U128,
    /// How many times this bounty can be done.
    pub times: u32,
    /// Max deadline from claim that can be spend on this bounty.
    pub max_deadline: U64,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum VersionedBounty {
    Default(Bounty),
}

impl From<VersionedBounty> for Bounty {
    fn from(v: VersionedBounty) -> Self {
        match v {
            VersionedBounty::Default(b) => b,
        }
    }
}

impl Contract {
    /// Adds bounty to the storage and returns it's id.
    /// Must not fail.
    pub(crate) fn internal_add_bounty(&mut self, bounty: &Bounty) -> u64 {
        let id = self.last_bounty_id;
        self.bounties
            .insert(&id, &VersionedBounty::Default(bounty.clone()));
        self.last_bounty_id += 1;
        id
    }

    /// This must be called when proposal to payout bounty has been voted either successfully or not.
    pub(crate) fn internal_execute_bounty_payout(
        &mut self,
        id: u64,
        receiver_id: &AccountId,
        success: bool,
    ) -> PromiseOrValue<()> {
        let bounty: Bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY").into();
        self.internal_remove_claim(id, receiver_id);
        if success {
            self.internal_payout(
                &convert_old_to_new_token(&bounty.token),
                receiver_id,
                bounty.amount.0,
                format!("Bounty {} payout", id),
                None,
            )
        } else {
            PromiseOrValue::Value(())
        }
    }

    fn internal_find_claim(&self, bounty_id: u64, claims: &[BountyClaim]) -> Option<usize> {
        for i in 0..claims.len() {
            if claims[i].bounty_id == bounty_id {
                return Some(i);
            }
        }
        None
    }
}

#[near_bindgen]
impl Contract {
    /// Claim given bounty by caller with given expected duration to execute.
    /// Bond must be attached to the claim.
    /// Fails if already claimed `times` times.
    #[payable]
    pub fn bounty_claim(&mut self, id: u64, deadline: U64) {
        let bounty: Bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY").into();
        let policy = self.policy.get().unwrap().to_policy();
        assert_eq!(
            env::attached_deposit(),
            policy.bounty_bond.0,
            "ERR_BOUNTY_WRONG_BOND"
        );
        let claims_count = self.bounty_claims_count.get(&id).unwrap_or_default();
        assert!(claims_count < bounty.times, "ERR_BOUNTY_ALL_CLAIMED");
        assert!(
            deadline.0 <= bounty.max_deadline.0,
            "ERR_BOUNTY_WRONG_DEADLINE"
        );
        self.bounty_claims_count.insert(&id, &(claims_count + 1));
        let mut claims = self
            .bounty_claimers
            .get(&env::predecessor_account_id())
            .unwrap_or_default();
        claims.push(BountyClaim {
            bounty_id: id,
            start_time: U64::from(env::block_timestamp()),
            deadline,
            completed: false,
        });
        self.bounty_claimers
            .insert(&env::predecessor_account_id(), &claims);
        self.locked_amount += env::attached_deposit();
    }

    /// Remove the claim of `claimer_id` from this bounty.
    fn internal_remove_claim(&mut self, bounty_id: u64, claimer_id: &AccountId) {
        let (mut claims, claim_idx) = self.internal_get_claims(bounty_id, claimer_id);
        claims.remove(claim_idx);
        if claims.len() == 0 {
            self.bounty_claimers.remove(claimer_id);
        } else {
            self.bounty_claimers.insert(claimer_id, &claims);
        }
        let count = self.bounty_claims_count.get(&bounty_id).unwrap() - 1;
        self.bounty_claims_count.insert(&bounty_id, &count);
    }

    fn internal_get_claims(&mut self, id: u64, sender_id: &AccountId) -> (Vec<BountyClaim>, usize) {
        let claims = self
            .bounty_claimers
            .get(&sender_id)
            .expect("ERR_NO_BOUNTY_CLAIMS");
        let claim_idx = self
            .internal_find_claim(id, &claims)
            .expect("ERR_NO_BOUNTY_CLAIM");
        (claims, claim_idx)
    }

    /// Report that bounty is done. Creates a proposal to vote for paying out the bounty.
    /// Only creator of the claim can call `done` on bounty that is still in progress.
    /// On expired, anyone can call it to free up the claim slot.
    #[payable]
    pub fn bounty_done(&mut self, id: u64, account_id: Option<AccountId>, description: String) {
        let sender_id = account_id.unwrap_or_else(|| env::predecessor_account_id());
        let (mut claims, claim_idx) = self.internal_get_claims(id, &sender_id);
        assert!(!claims[claim_idx].completed, "ERR_BOUNTY_CLAIM_COMPLETED");
        if env::block_timestamp() > claims[claim_idx].start_time.0 + claims[claim_idx].deadline.0 {
            // Expired. Nothing to do.
            self.internal_remove_claim(id, &sender_id);
        } else {
            // Still under deadline. Only the user themself can call this.
            assert_eq!(
                sender_id,
                env::predecessor_account_id(),
                "ERR_BOUNTY_DONE_MUST_BE_SELF"
            );
            self.add_proposal(ProposalInput {
                description,
                kind: ProposalKind::BountyDone {
                    bounty_id: id,
                    receiver_id: sender_id.clone(),
                },
            });
            claims[claim_idx].completed = true;
            self.bounty_claimers.insert(&sender_id, &claims);
        }
    }

    /// Give up working on the bounty.
    pub fn bounty_giveup(&mut self, id: u64) -> PromiseOrValue<()> {
        let policy = self.policy.get().unwrap().to_policy();
        let (claims, claim_idx) = self.internal_get_claims(id, &env::predecessor_account_id());
        let result = if env::block_timestamp() - claims[claim_idx].start_time.0
            > policy.bounty_forgiveness_period.0
        {
            // If user over the forgiveness period.
            PromiseOrValue::Value(())
        } else {
            // Within forgiveness period. Return bond.
            self.locked_amount -= policy.bounty_bond.0;
            Promise::new(env::predecessor_account_id())
                .transfer(policy.bounty_bond.0)
                .into()
        };
        self.internal_remove_claim(id, &env::predecessor_account_id());
        result
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use near_sdk_sim::to_yocto;

    use crate::proposals::{ProposalInput, ProposalKind};
    use crate::{Action, Config};

    use super::*;

    fn add_bounty(context: &mut VMContextBuilder, contract: &mut Contract, times: u32) -> u64 {
        testing_env!(context.attached_deposit(to_yocto("1")).build());
        let id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddBounty {
                bounty: Bounty {
                    description: "test bounty".to_string(),
                    token: String::from(OLD_BASE_TOKEN),
                    amount: U128(to_yocto("10")),
                    times,
                    max_deadline: U64::from(1_000),
                },
            },
        });
        assert_eq!(contract.get_last_bounty_id(), id);
        contract.act_proposal(id, Action::VoteApprove, None);
        id
    }

    /// Adds a bounty, and tests it's full lifecycle.
    #[test]
    fn test_bounty_lifecycle() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        add_bounty(&mut context, &mut contract, 2);

        assert_eq!(contract.get_last_bounty_id(), 1);
        assert_eq!(contract.get_bounty(0).bounty.times, 2);

        contract.bounty_claim(0, U64::from(500));
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 1);
        assert_eq!(contract.get_bounty_number_of_claims(0), 1);

        contract.bounty_giveup(0);
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 0);
        assert_eq!(contract.get_bounty_number_of_claims(0), 0);

        contract.bounty_claim(0, U64::from(500));
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 1);
        assert_eq!(contract.get_bounty_number_of_claims(0), 1);

        contract.bounty_done(0, None, "Bounty is done".to_string());
        assert!(contract.get_bounty_claims(accounts(1))[0].completed);

        assert_eq!(contract.get_last_proposal_id(), 2);
        assert_eq!(
            contract.get_proposal(1).proposal.kind.to_policy_label(),
            "bounty_done"
        );

        contract.act_proposal(1, Action::VoteApprove, None);
        testing_env!(
            context.build(),
            near_sdk::VMConfig::test(),
            near_sdk::RuntimeFeesConfig::test(),
            Default::default(),
            vec![PromiseResult::Successful(vec![])],
        );
        contract.on_proposal_callback(1);

        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 0);
        assert_eq!(contract.get_bounty(0).bounty.times, 1);

        contract.bounty_claim(0, U64::from(500));
        contract.bounty_done(0, None, "Bounty is done 2".to_string());
        contract.act_proposal(2, Action::VoteApprove, None);
        testing_env!(
            context.build(),
            near_sdk::VMConfig::test(),
            near_sdk::RuntimeFeesConfig::test(),
            Default::default(),
            vec![PromiseResult::Successful(vec![])],
        );
        contract.on_proposal_callback(2);

        assert_eq!(contract.get_bounty(0).bounty.times, 0);
    }

    #[test]
    #[should_panic(expected = "ERR_BOUNTY_ALL_CLAIMED")]
    fn test_bounty_claim_not_allowed() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        let id = add_bounty(&mut context, &mut contract, 1);
        contract.bounty_claim(id, U64::from(500));
        contract.bounty_done(id, None, "Bounty is done 2".to_string());
        contract.bounty_claim(id, U64::from(500));
    }
}

'''
'''--- sputnikdao2/src/delegation.rs ---
use crate::*;

impl Contract {
    pub fn get_user_weight(&self, account_id: &AccountId) -> Balance {
        self.delegations.get(account_id).unwrap_or_default()
    }
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn register_delegation(&mut self, account_id: &AccountId) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        assert_eq!(env::attached_deposit(), 16 * env::storage_byte_cost());
        self.delegations.insert(account_id, &0);
    }

    /// Adds given amount to given account as delegated weight.
    /// Returns previous amount, new amount and total delegated amount.
    pub fn delegate(&mut self, account_id: &AccountId, amount: U128) -> (U128, U128, U128) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        let prev_amount = self
            .delegations
            .get(account_id)
            .expect("ERR_NOT_REGISTERED");
        let new_amount = prev_amount + amount.0;
        self.delegations.insert(account_id, &new_amount);
        self.total_delegation_amount += amount.0;
        (
            U128(prev_amount),
            U128(new_amount),
            self.delegation_total_supply(),
        )
    }

    /// Removes given amount from given account's delegations.
    /// Returns previous, new amount of this account and total delegated amount.
    pub fn undelegate(&mut self, account_id: &AccountId, amount: U128) -> (U128, U128, U128) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        let prev_amount = self.delegations.get(account_id).unwrap_or_default();
        assert!(prev_amount >= amount.0, "ERR_INVALID_STAKING_CONTRACT");
        let new_amount = prev_amount - amount.0;
        self.delegations.insert(account_id, &new_amount);
        self.total_delegation_amount -= amount.0;
        (
            U128(prev_amount),
            U128(new_amount),
            self.delegation_total_supply(),
        )
    }
}

'''
'''--- sputnikdao2/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::{Base58CryptoHash, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, CryptoHash,
    PanicOnDefault, Promise, PromiseResult,
};

pub use crate::bounties::{Bounty, BountyClaim, VersionedBounty};
pub use crate::policy::{
    default_policy, Policy, RoleKind, RolePermission, VersionedPolicy, VotePolicy,
};
use crate::proposals::VersionedProposal;
pub use crate::proposals::{Proposal, ProposalInput, ProposalKind, ProposalStatus};
pub use crate::types::{Action, Config, OldAccountId, OLD_BASE_TOKEN};
use crate::upgrade::{internal_get_factory_info, internal_set_factory_info, FactoryInfo};
pub use crate::views::{BountyOutput, ProposalOutput};

mod bounties;
mod delegation;
mod policy;
mod proposals;
mod types;
mod upgrade;
pub mod views;

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    Config,
    Policy,
    Delegations,
    Proposals,
    Bounties,
    BountyClaimers,
    BountyClaimCounts,
    Blobs,
}

/// After payouts, allows a callback
#[ext_contract(ext_self)]
pub trait ExtSelf {
    /// Callback after proposal execution.
    fn on_proposal_callback(&mut self, proposal_id: u64) -> PromiseOrValue<()>;
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    /// DAO configuration.
    pub config: LazyOption<Config>,
    /// Voting and permissions policy.
    pub policy: LazyOption<VersionedPolicy>,

    /// Amount of $NEAR locked for bonds.
    pub locked_amount: Balance,

    /// Vote staking contract id. That contract must have this account as owner.
    pub staking_id: Option<AccountId>,
    /// Delegated  token total amount.
    pub total_delegation_amount: Balance,
    /// Delegations per user.
    pub delegations: LookupMap<AccountId, Balance>,

    /// Last available id for the proposals.
    pub last_proposal_id: u64,
    /// Proposal map from ID to proposal information.
    pub proposals: LookupMap<u64, VersionedProposal>,

    /// Last available id for the bounty.
    pub last_bounty_id: u64,
    /// Bounties map from ID to bounty information.
    pub bounties: LookupMap<u64, VersionedBounty>,
    /// Bounty claimers map per user. Allows quickly to query for each users their claims.
    pub bounty_claimers: LookupMap<AccountId, Vec<BountyClaim>>,
    /// Count of claims per bounty.
    pub bounty_claims_count: LookupMap<u64, u32>,

    /// Large blob storage.
    pub blobs: LookupMap<CryptoHash, AccountId>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(config: Config, policy: VersionedPolicy) -> Self {
        let this = Self {
            config: LazyOption::new(StorageKeys::Config, Some(&config)),
            policy: LazyOption::new(StorageKeys::Policy, Some(&policy.upgrade())),
            staking_id: None,
            total_delegation_amount: 0,
            delegations: LookupMap::new(StorageKeys::Delegations),
            last_proposal_id: 0,
            proposals: LookupMap::new(StorageKeys::Proposals),
            last_bounty_id: 0,
            bounties: LookupMap::new(StorageKeys::Bounties),
            bounty_claimers: LookupMap::new(StorageKeys::BountyClaimers),
            bounty_claims_count: LookupMap::new(StorageKeys::BountyClaimCounts),
            blobs: LookupMap::new(StorageKeys::Blobs),
            locked_amount: 0,
        };
        internal_set_factory_info(&FactoryInfo {
            factory_id: env::predecessor_account_id(),
            auto_update: true,
        });
        this
    }

    /// Should only be called by this contract on migration.
    /// This is NOOP implementation. KEEP IT if you haven't changed contract state.
    /// If you have changed state, you need to implement migration from old state (keep the old struct with different name to deserialize it first).
    /// After migrate goes live on MainNet, return this implementation for next updates.
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let this: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        this
    }

    /// Remove blob from contract storage and pay back to original storer.
    /// Only original storer can call this.
    pub fn remove_blob(&mut self, hash: Base58CryptoHash) -> Promise {
        let hash: CryptoHash = hash.into();
        let account_id = self.blobs.remove(&hash).expect("ERR_NO_BLOB");
        assert_eq!(
            env::predecessor_account_id(),
            account_id,
            "ERR_INVALID_CALLER"
        );
        env::storage_remove(&hash);
        let blob_len = env::register_len(u64::MAX - 1).unwrap();
        let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
        Promise::new(account_id).transfer(storage_cost)
    }

    /// Returns factory information, including if auto update is allowed.
    pub fn get_factory_info(&self) -> FactoryInfo {
        internal_get_factory_info()
    }
}

/// Stores attached data into blob store and returns hash of it.
/// Implemented to avoid loading the data into WASM for optimal gas usage.
#[no_mangle]
pub extern "C" fn store_blob() {
    env::setup_panic_hook();
    let mut contract: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
    let input = env::input().expect("ERR_NO_INPUT");
    let sha256_hash = env::sha256(&input);
    assert!(!env::storage_has_key(&sha256_hash), "ERR_ALREADY_EXISTS");

    let blob_len = input.len();
    let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
    assert!(
        env::attached_deposit() >= storage_cost,
        "ERR_NOT_ENOUGH_DEPOSIT:{}",
        storage_cost
    );

    env::storage_write(&sha256_hash, &input);
    let mut blob_hash = [0u8; 32];
    blob_hash.copy_from_slice(&sha256_hash);
    contract
        .blobs
        .insert(&blob_hash, &env::predecessor_account_id());
    let blob_hash_str = near_sdk::serde_json::to_string(&Base58CryptoHash::from(blob_hash))
        .unwrap()
        .into_bytes();

    env::value_return(&blob_hash_str);
    env::state_write(&contract);
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use near_sdk_sim::to_yocto;

    use crate::proposals::ProposalStatus;

    use super::*;

    fn create_proposal(context: &mut VMContextBuilder, contract: &mut Contract) -> u64 {
        testing_env!(context.attached_deposit(to_yocto("1")).build());
        contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::Transfer {
                token_id: String::from(OLD_BASE_TOKEN),
                receiver_id: accounts(2).into(),
                amount: U128(to_yocto("100")),
                msg: None,
            },
        })
    }

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        assert_eq!(contract.get_proposals(0, 10).len(), 1);

        let id = create_proposal(&mut context, &mut contract);
        contract.act_proposal(id, Action::VoteApprove, None);
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Approved
        );

        let id = create_proposal(&mut context, &mut contract);
        // proposal expired, finalize.
        testing_env!(context
            .block_timestamp(1_000_000_000 * 24 * 60 * 60 * 8)
            .build());
        contract.act_proposal(id, Action::Finalize, None);
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Expired
        );

        // non council adding proposal per default policy.
        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(to_yocto("1"))
            .build());
        let _id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: accounts(2).into(),
                role: "council".to_string(),
            },
        });
    }

    #[test]
    #[should_panic(expected = "ERR_PERMISSION_DENIED")]
    fn test_remove_proposal_denied() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        contract.act_proposal(id, Action::RemoveProposal, None);
    }

    #[test]
    fn test_remove_proposal_allowed() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut policy = VersionedPolicy::Default(vec![accounts(1).into()]).upgrade();
        policy.to_policy_mut().roles[1]
            .permissions
            .insert("*:RemoveProposal".to_string());
        let mut contract = Contract::new(Config::test_config(), policy);
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        contract.act_proposal(id, Action::RemoveProposal, None);
        assert_eq!(contract.get_proposals(0, 10).len(), 0);
    }

    #[test]
    fn test_vote_expired_proposal() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        let id = create_proposal(&mut context, &mut contract);
        testing_env!(context
            .block_timestamp(1_000_000_000 * 24 * 60 * 60 * 8)
            .build());
        contract.act_proposal(id, Action::VoteApprove, None);
    }

    #[test]
    #[should_panic(expected = "ERR_ALREADY_VOTED")]
    fn test_vote_twice() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into(), accounts(2).into()]),
        );
        let id = create_proposal(&mut context, &mut contract);
        contract.act_proposal(id, Action::VoteApprove, None);
        contract.act_proposal(id, Action::VoteApprove, None);
    }

    #[test]
    fn test_add_to_missing_role() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        testing_env!(context.attached_deposit(to_yocto("1")).build());
        let id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: accounts(2).into(),
                role: "missing".to_string(),
            },
        });
        contract.act_proposal(id, Action::VoteApprove, None);
        let x = contract.get_policy();
        // still 2 roles: all and council.
        assert_eq!(x.roles.len(), 2);
    }

    #[test]
    #[should_panic(expected = "ERR_INVALID_POLICY")]
    fn test_fails_adding_invalid_policy() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1).into()]),
        );
        testing_env!(context.attached_deposit(to_yocto("1")).build());
        let _id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::ChangePolicy {
                policy: VersionedPolicy::Default(vec![]),
            },
        });
    }
}

'''
'''--- sputnikdao2/src/policy.rs ---
use std::cmp::min;
use std::collections::{HashMap, HashSet};

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance};

use crate::proposals::{PolicyParameters, Proposal, ProposalKind, ProposalStatus, Vote};
use crate::types::Action;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub enum RoleKind {
    /// Matches everyone, who is not matched by other roles.
    Everyone,
    /// Member greater or equal than given balance. Can use `1` as non-zero balance.
    Member(U128),
    /// Set of accounts.
    Group(HashSet<AccountId>),
}

impl RoleKind {
    /// Checks if user matches given role.
    pub fn match_user(&self, user: &UserInfo) -> bool {
        match self {
            RoleKind::Everyone => true,
            RoleKind::Member(amount) => user.amount >= amount.0,
            RoleKind::Group(accounts) => accounts.contains(&user.account_id),
        }
    }

    /// Returns the number of people in the this role or None if not supported role kind.
    pub fn get_role_size(&self) -> Option<usize> {
        match self {
            RoleKind::Group(accounts) => Some(accounts.len()),
            _ => None,
        }
    }

    pub fn add_member_to_group(&mut self, member_id: &AccountId) -> Result<(), ()> {
        match self {
            RoleKind::Group(accounts) => {
                accounts.insert(member_id.clone());
                Ok(())
            }
            _ => Err(()),
        }
    }

    pub fn remove_member_from_group(&mut self, member_id: &AccountId) -> Result<(), ()> {
        match self {
            RoleKind::Group(accounts) => {
                accounts.remove(member_id);
                Ok(())
            }
            _ => Err(()),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct RolePermission {
    /// Name of the role to display to the user.
    pub name: String,
    /// Kind of the role: defines which users this permissions apply.
    pub kind: RoleKind,
    /// Set of actions on which proposals that this role is allowed to execute.
    /// <proposal_kind>:<action>
    pub permissions: HashSet<String>,
    /// For each proposal kind, defines voting policy.
    pub vote_policy: HashMap<String, VotePolicy>,
}

pub struct UserInfo {
    pub account_id: AccountId,
    pub amount: Balance,
}

/// Direct weight or ratio to total weight, used for the voting policy.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum WeightOrRatio {
    Weight(U128),
    Ratio(u64, u64),
}

impl WeightOrRatio {
    /// Convert weight or ratio to specific weight given total weight.
    pub fn to_weight(&self, total_weight: Balance) -> Balance {
        match self {
            WeightOrRatio::Weight(weight) => min(weight.0, total_weight),
            WeightOrRatio::Ratio(num, denom) => min(
                (*num as u128 * total_weight) / *denom as u128 + 1,
                total_weight,
            ),
        }
    }
}

/// How the voting policy votes get weigthed.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum WeightKind {
    /// Using token amounts and total delegated at the moment.
    TokenWeight,
    /// Weight of the group role. Roles that don't have scoped group are not supported.
    RoleWeight,
}

/// Defines configuration of the vote.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct VotePolicy {
    /// Kind of weight to use for votes.
    pub weight_kind: WeightKind,
    /// Minimum number required for vote to finalize.
    /// If weight kind is TokenWeight - this is minimum number of tokens required.
    ///     This allows to avoid situation where the number of staked tokens from total supply is too small.
    /// If RoleWeight - this is minimum number of votes.
    ///     This allows to avoid situation where the role is got too small but policy kept at 1/2, for example.
    pub quorum: U128,
    /// How many votes to pass this vote.
    pub threshold: WeightOrRatio,
}

impl Default for VotePolicy {
    fn default() -> Self {
        VotePolicy {
            weight_kind: WeightKind::RoleWeight,
            quorum: U128(0),
            threshold: WeightOrRatio::Ratio(1, 2),
        }
    }
}

/// Defines voting / decision making policy of this DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct Policy {
    /// List of roles and permissions for them in the current policy.
    pub roles: Vec<RolePermission>,
    /// Default vote policy. Used when given proposal kind doesn't have special policy.
    pub default_vote_policy: VotePolicy,
    /// Proposal bond.
    pub proposal_bond: U128,
    /// Expiration period for proposals.
    pub proposal_period: U64,
    /// Bond for claiming a bounty.
    pub bounty_bond: U128,
    /// Period in which giving up on bounty is not punished.
    pub bounty_forgiveness_period: U64,
}

/// Versioned policy.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum VersionedPolicy {
    /// Default policy with given accounts as council.
    Default(Vec<AccountId>),
    Current(Policy),
}

/// Defines default policy:
///     - everyone can add proposals
///     - group consisting of the call can do all actions, consists of caller.
///     - non token weighted voting, requires 1/2 of the group to vote
///     - proposal & bounty bond is 1N
///     - proposal & bounty forgiveness period is 1 day
pub fn default_policy(council: Vec<AccountId>) -> Policy {
    Policy {
        roles: vec![
            RolePermission {
                name: "all".to_string(),
                kind: RoleKind::Everyone,
                permissions: vec!["*:AddProposal".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "council".to_string(),
                kind: RoleKind::Group(council.into_iter().collect()),
                // All actions except RemoveProposal are allowed by council.
                permissions: vec![
                    "*:AddProposal".to_string(),
                    "*:VoteApprove".to_string(),
                    "*:VoteReject".to_string(),
                    "*:VoteRemove".to_string(),
                    "*:Finalize".to_string(),
                ]
                .into_iter()
                .collect(),
                vote_policy: HashMap::default(),
            },
        ],
        default_vote_policy: VotePolicy::default(),
        proposal_bond: U128(10u128.pow(24)),
        proposal_period: U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
        bounty_bond: U128(10u128.pow(24)),
        bounty_forgiveness_period: U64::from(1_000_000_000 * 60 * 60 * 24),
    }
}

impl VersionedPolicy {
    /// Upgrades either version of policy into the latest.
    pub fn upgrade(self) -> Self {
        match self {
            VersionedPolicy::Default(accounts) => {
                VersionedPolicy::Current(default_policy(accounts))
            }
            VersionedPolicy::Current(policy) => VersionedPolicy::Current(policy),
        }
    }

    /// Return recent version of policy.
    pub fn to_policy(self) -> Policy {
        match self {
            VersionedPolicy::Current(policy) => policy,
            _ => unimplemented!(),
        }
    }

    pub fn to_policy_mut(&mut self) -> &mut Policy {
        match self {
            VersionedPolicy::Current(policy) => policy,
            _ => unimplemented!(),
        }
    }
}

impl Policy {
    pub fn add_or_update_role(&mut self, role: &RolePermission) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == &role.name {
                env::log_str(&format!(
                    "Updating existing role in the policy:{}",
                    &role.name
                ));
                let _ = std::mem::replace(&mut self.roles[i], role.clone());
                return;
            }
        }
        env::log_str(&format!("Adding new role to the policy:{}", &role.name));
        self.roles.push(role.clone());
    }

    pub fn remove_role(&mut self, role: &String) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == role {
                self.roles.remove(i);
                return;
            }
        }
        env::log_str(&format!("ERR_ROLE_NOT_FOUND:{}", role));
    }

    pub fn update_default_vote_policy(&mut self, vote_policy: &VotePolicy) {
        self.default_vote_policy = vote_policy.clone();
        env::log_str("Successfully updated the default vote policy.");
    }

    pub fn update_parameters(&mut self, parameters: &PolicyParameters) {
        if parameters.proposal_bond.is_some() {
            self.proposal_bond = parameters.proposal_bond.unwrap();
        }
        if parameters.proposal_period.is_some() {
            self.proposal_period = parameters.proposal_period.unwrap();
        }
        if parameters.bounty_bond.is_some() {
            self.bounty_bond = parameters.bounty_bond.unwrap();
        }
        if parameters.bounty_forgiveness_period.is_some() {
            self.bounty_forgiveness_period = parameters.bounty_forgiveness_period.unwrap();
        }
        env::log_str("Successfully updated the policy parameters.");
    }

    pub fn add_member_to_role(&mut self, role: &String, member_id: &AccountId) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == role {
                self.roles[i]
                    .kind
                    .add_member_to_group(member_id)
                    .unwrap_or_else(|()| {
                        env::log_str(&format!("ERR_ROLE_WRONG_KIND:{}", role));
                    });
                return;
            }
        }
        env::log_str(&format!("ERR_ROLE_NOT_FOUND:{}", role));
    }

    pub fn remove_member_from_role(&mut self, role: &String, member_id: &AccountId) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == role {
                self.roles[i]
                    .kind
                    .remove_member_from_group(member_id)
                    .unwrap_or_else(|()| {
                        env::log_str(&format!("ERR_ROLE_WRONG_KIND:{}", role));
                    });
                return;
            }
        }
        env::log_str(&format!("ERR_ROLE_NOT_FOUND:{}", role));
    }

    /// Returns set of roles that this user is member of permissions for given user across all the roles it's member of.
    fn get_user_roles(&self, user: UserInfo) -> HashMap<String, &HashSet<String>> {
        let mut roles = HashMap::default();
        for role in self.roles.iter() {
            if role.kind.match_user(&user) {
                roles.insert(role.name.clone(), &role.permissions);
            }
        }
        roles
    }

    /// Can given user execute given action on this proposal.
    /// Returns all roles that allow this action.
    pub fn can_execute_action(
        &self,
        user: UserInfo,
        proposal_kind: &ProposalKind,
        action: &Action,
    ) -> (Vec<String>, bool) {
        let roles = self.get_user_roles(user);
        let mut allowed = false;
        let allowed_roles = roles
            .into_iter()
            .filter_map(|(role, permissions)| {
                let allowed_role = permissions.contains(&format!(
                    "{}:{}",
                    proposal_kind.to_policy_label(),
                    action.to_policy_label()
                )) || permissions
                    .contains(&format!("{}:*", proposal_kind.to_policy_label()))
                    || permissions.contains(&format!("*:{}", action.to_policy_label()))
                    || permissions.contains("*:*");
                allowed = allowed || allowed_role;
                if allowed_role {
                    Some(role)
                } else {
                    None
                }
            })
            .collect();
        (allowed_roles, allowed)
    }

    /// Returns if given proposal kind is token weighted.
    pub fn is_token_weighted(&self, role: &String, proposal_kind_label: &String) -> bool {
        let role_info = self.internal_get_role(role).expect("ERR_ROLE_NOT_FOUND");
        match role_info
            .vote_policy
            .get(proposal_kind_label)
            .unwrap_or(&self.default_vote_policy)
            .weight_kind
        {
            WeightKind::TokenWeight => true,
            _ => false,
        }
    }

    fn internal_get_role(&self, name: &String) -> Option<&RolePermission> {
        for role in self.roles.iter() {
            if role.name == *name {
                return Some(role);
            }
        }
        None
    }

    /// Get proposal status for given proposal.
    /// Usually is called after changing it's state.
    pub fn proposal_status(
        &self,
        proposal: &Proposal,
        roles: Vec<String>,
        total_supply: Balance,
    ) -> ProposalStatus {
        assert!(
            matches!(
                proposal.status,
                ProposalStatus::InProgress | ProposalStatus::Failed
            ),
            "ERR_PROPOSAL_NOT_IN_PROGRESS"
        );
        if proposal.submission_time.0 + self.proposal_period.0 < env::block_timestamp() {
            // Proposal expired.
            return ProposalStatus::Expired;
        };
        for role in roles {
            let role_info = self.internal_get_role(&role).expect("ERR_MISSING_ROLE");
            let vote_policy = role_info
                .vote_policy
                .get(&proposal.kind.to_policy_label().to_string())
                .unwrap_or(&self.default_vote_policy);
            let total_weight = match &role_info.kind {
                // Skip role that covers everyone as it doesn't provide a total size.
                RoleKind::Everyone => continue,
                RoleKind::Group(group) => {
                    if vote_policy.weight_kind == WeightKind::RoleWeight {
                        group.len() as Balance
                    } else {
                        total_supply
                    }
                }
                RoleKind::Member(_) => total_supply,
            };
            let threshold = std::cmp::max(
                vote_policy.quorum.0,
                vote_policy.threshold.to_weight(total_weight),
            );
            // Check if there is anything voted above the threshold specified by policy for given role.
            let vote_counts = proposal.vote_counts.get(&role).unwrap_or(&[0u128; 3]);
            if vote_counts[Vote::Approve as usize] >= threshold {
                return ProposalStatus::Approved;
            } else if vote_counts[Vote::Reject as usize] >= threshold {
                return ProposalStatus::Rejected;
            } else if vote_counts[Vote::Remove as usize] >= threshold {
                return ProposalStatus::Removed;
            } else {
                // continue to next role.
            }
        }
        proposal.status.clone()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::accounts;

    use super::*;

    #[test]
    fn test_vote_policy() {
        let r1 = WeightOrRatio::Weight(U128(100));
        assert_eq!(r1.to_weight(1_000_000), 100);
        let r2 = WeightOrRatio::Ratio(1, 2);
        assert_eq!(r2.to_weight(2), 2);
        let r2 = WeightOrRatio::Ratio(1, 2);
        assert_eq!(r2.to_weight(5), 3);
        let r2 = WeightOrRatio::Ratio(1, 1);
        assert_eq!(r2.to_weight(5), 5);
    }

    #[test]
    fn test_add_role() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        let community_role = policy.internal_get_role(&String::from("community"));
        assert!(community_role.is_none());

        let name: String = "community".to_string();
        let kind: RoleKind = RoleKind::Group(vec![accounts(2), accounts(3)].into_iter().collect());
        let permissions: HashSet<String> = vec!["*:*".to_string()].into_iter().collect();
        let vote_policy: HashMap<String, VotePolicy> = HashMap::default();
        let new_role = RolePermission {
            name: name.clone(),
            kind: kind.clone(),
            permissions: permissions.clone(),
            vote_policy: vote_policy.clone(),
        };
        assert_eq!(2, policy.roles.len());
        policy.add_or_update_role(&new_role);
        assert_eq!(3, policy.roles.len());

        let community_role = policy.internal_get_role(&String::from("community"));
        assert!(community_role.is_some());

        let community_role = community_role.unwrap();
        assert_eq!(name, community_role.name);
        assert_eq!(kind, community_role.kind);
        assert_eq!(permissions, community_role.permissions);
        assert_eq!(vote_policy, community_role.vote_policy);
    }

    #[test]
    fn test_update_role() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        let name: String = "council".to_string();
        let kind: RoleKind = RoleKind::Group(vec![accounts(0), accounts(1)].into_iter().collect());
        let permissions: HashSet<String> = vec![
            "*:AddProposal".to_string(),
            "*:VoteApprove".to_string(),
            "*:VoteReject".to_string(),
            "*:VoteRemove".to_string(),
            "*:Finalize".to_string(),
        ]
        .into_iter()
        .collect();
        let vote_policy: HashMap<String, VotePolicy> = HashMap::default();

        let council_role = policy.internal_get_role(&String::from("council"));
        assert!(council_role.is_some());

        let council_role = council_role.unwrap();
        assert_eq!(name, council_role.name);
        assert_eq!(kind, council_role.kind);
        assert_eq!(permissions, council_role.permissions);
        assert_eq!(vote_policy, council_role.vote_policy);

        let kind: RoleKind = RoleKind::Group(vec![accounts(2), accounts(3)].into_iter().collect());
        let permissions: HashSet<String> = vec!["*:*".to_string()].into_iter().collect();
        let updated_role = RolePermission {
            name: name.clone(),
            kind: kind.clone(),
            permissions: permissions.clone(),
            vote_policy: vote_policy.clone(),
        };
        assert_eq!(2, policy.roles.len());
        policy.add_or_update_role(&updated_role);
        assert_eq!(2, policy.roles.len());

        let council_role = policy.internal_get_role(&String::from("council"));
        assert!(council_role.is_some());

        let council_role = council_role.unwrap();
        assert_eq!(name, council_role.name);
        assert_eq!(kind, council_role.kind);
        assert_eq!(permissions, council_role.permissions);
        assert_eq!(vote_policy, council_role.vote_policy);
    }

    #[test]
    fn test_remove_role() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        let council_role = policy.internal_get_role(&String::from("council"));
        assert!(council_role.is_some());
        assert_eq!(2, policy.roles.len());

        policy.remove_role(&String::from("council"));

        let council_role = policy.internal_get_role(&String::from("council"));
        assert!(council_role.is_none());
        assert_eq!(1, policy.roles.len());
    }

    #[test]
    fn test_update_default_vote_policy() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        assert_eq!(
            WeightKind::RoleWeight,
            policy.default_vote_policy.weight_kind
        );
        assert_eq!(U128(0), policy.default_vote_policy.quorum);
        assert_eq!(
            WeightOrRatio::Ratio(1, 2),
            policy.default_vote_policy.threshold
        );

        let new_default_vote_policy = VotePolicy {
            weight_kind: WeightKind::TokenWeight,
            quorum: U128(100),
            threshold: WeightOrRatio::Ratio(1, 4),
        };
        policy.update_default_vote_policy(&new_default_vote_policy);
        assert_eq!(
            new_default_vote_policy.weight_kind,
            policy.default_vote_policy.weight_kind
        );
        assert_eq!(
            new_default_vote_policy.quorum,
            policy.default_vote_policy.quorum
        );
        assert_eq!(
            new_default_vote_policy.threshold,
            policy.default_vote_policy.threshold
        );
    }

    #[test]
    fn test_update_parameters() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        assert_eq!(U128(10u128.pow(24)), policy.proposal_bond);
        assert_eq!(
            U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
            policy.proposal_period
        );
        assert_eq!(U128(10u128.pow(24)), policy.bounty_bond);
        assert_eq!(
            U64::from(1_000_000_000 * 60 * 60 * 24),
            policy.bounty_forgiveness_period
        );

        let new_parameters = PolicyParameters {
            proposal_bond: Some(U128(10u128.pow(26))),
            proposal_period: None,
            bounty_bond: None,
            bounty_forgiveness_period: Some(U64::from(1_000_000_000 * 60 * 60 * 24 * 5)),
        };
        policy.update_parameters(&new_parameters);
        assert_eq!(U128(10u128.pow(26)), policy.proposal_bond);
        assert_eq!(
            U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
            policy.proposal_period
        );
        assert_eq!(U128(10u128.pow(24)), policy.bounty_bond);
        assert_eq!(
            U64::from(1_000_000_000 * 60 * 60 * 24 * 5),
            policy.bounty_forgiveness_period
        );
    }
}

'''
'''--- sputnikdao2/src/proposals.rs ---
use std::collections::HashMap;

use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::{log, AccountId, Balance, Gas, PromiseOrValue};

use crate::policy::UserInfo;
use crate::types::{
    convert_old_to_new_token, Action, Config, OldAccountId, GAS_FOR_FT_TRANSFER, OLD_BASE_TOKEN,
    ONE_YOCTO_NEAR,
};
use crate::upgrade::{upgrade_remote, upgrade_using_factory};
use crate::*;

/// Status of a proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalStatus {
    InProgress,
    /// If quorum voted yes, this proposal is successfully approved.
    Approved,
    /// If quorum voted no, this proposal is rejected. Bond is returned.
    Rejected,
    /// If quorum voted to remove (e.g. spam), this proposal is rejected and bond is not returned.
    /// Interfaces shouldn't show removed proposals.
    Removed,
    /// Expired after period of time.
    Expired,
    /// If proposal was moved to Hub or somewhere else.
    Moved,
    /// If proposal has failed when finalizing. Allowed to re-finalize again to either expire or approved.
    Failed,
}

/// Function call arguments.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct ActionCall {
    method_name: String,
    args: Base64VecU8,
    deposit: U128,
    gas: U64,
}

/// Function call arguments.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct PolicyParameters {
    pub proposal_bond: Option<U128>,
    pub proposal_period: Option<U64>,
    pub bounty_bond: Option<U128>,
    pub bounty_forgiveness_period: Option<U64>,
}

/// Kinds of proposals, doing different action.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalKind {
    /// Change the DAO config.
    ChangeConfig { config: Config },
    /// Change the full policy.
    ChangePolicy { policy: VersionedPolicy },
    /// Add member to given role in the policy. This is short cut to updating the whole policy.
    AddMemberToRole { member_id: AccountId, role: String },
    /// Remove member to given role in the policy. This is short cut to updating the whole policy.
    RemoveMemberFromRole { member_id: AccountId, role: String },
    /// Calls `receiver_id` with list of method names in a single promise.
    /// Allows this contract to execute any arbitrary set of actions in other contracts.
    FunctionCall {
        receiver_id: AccountId,
        actions: Vec<ActionCall>,
    },
    /// Upgrade this contract with given hash from blob store.
    UpgradeSelf { hash: Base58CryptoHash },
    /// Upgrade another contract, by calling method with the code from given hash from blob store.
    UpgradeRemote {
        receiver_id: AccountId,
        method_name: String,
        hash: Base58CryptoHash,
    },
    /// Transfers given amount of `token_id` from this DAO to `receiver_id`.
    /// If `msg` is not None, calls `ft_transfer_call` with given `msg`. Fails if this base token.
    /// For `ft_transfer` and `ft_transfer_call` `memo` is the `description` of the proposal.
    Transfer {
        /// Can be "" for $NEAR or a valid account id.
        token_id: OldAccountId,
        receiver_id: AccountId,
        amount: U128,
        msg: Option<String>,
    },
    /// Sets staking contract. Can only be proposed if staking contract is not set yet.
    SetStakingContract { staking_id: AccountId },
    /// Add new bounty.
    AddBounty { bounty: Bounty },
    /// Indicates that given bounty is done by given user.
    BountyDone {
        bounty_id: u64,
        receiver_id: AccountId,
    },
    /// Just a signaling vote, with no execution.
    Vote,
    /// Change information about factory and auto update.
    FactoryInfoUpdate { factory_info: FactoryInfo },
    /// Add new role to the policy. If the role already exists, update it. This is short cut to updating the whole policy.
    ChangePolicyAddOrUpdateRole { role: RolePermission },
    /// Remove role from the policy. This is short cut to updating the whole policy.
    ChangePolicyRemoveRole { role: String },
    /// Update the default vote policy from the policy. This is short cut to updating the whole policy.
    ChangePolicyUpdateDefaultVotePolicy { vote_policy: VotePolicy },
    /// Update the parameters from the policy. This is short cut to updating the whole policy.
    ChangePolicyUpdateParameters { parameters: PolicyParameters },
}

impl ProposalKind {
    /// Returns label of policy for given type of proposal.
    pub fn to_policy_label(&self) -> &str {
        match self {
            ProposalKind::ChangeConfig { .. } => "config",
            ProposalKind::ChangePolicy { .. } => "policy",
            ProposalKind::AddMemberToRole { .. } => "add_member_to_role",
            ProposalKind::RemoveMemberFromRole { .. } => "remove_member_from_role",
            ProposalKind::FunctionCall { .. } => "call",
            ProposalKind::UpgradeSelf { .. } => "upgrade_self",
            ProposalKind::UpgradeRemote { .. } => "upgrade_remote",
            ProposalKind::Transfer { .. } => "transfer",
            ProposalKind::SetStakingContract { .. } => "set_vote_token",
            ProposalKind::AddBounty { .. } => "add_bounty",
            ProposalKind::BountyDone { .. } => "bounty_done",
            ProposalKind::Vote => "vote",
            ProposalKind::FactoryInfoUpdate { .. } => "factory_info_update",
            ProposalKind::ChangePolicyAddOrUpdateRole { .. } => "policy_add_or_update_role",
            ProposalKind::ChangePolicyRemoveRole { .. } => "policy_remove_role",
            ProposalKind::ChangePolicyUpdateDefaultVotePolicy { .. } => {
                "policy_update_default_vote_policy"
            }
            ProposalKind::ChangePolicyUpdateParameters { .. } => "policy_update_parameters",
        }
    }
}

/// Votes recorded in the proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Vote {
    Approve = 0x0,
    Reject = 0x1,
    Remove = 0x2,
}

impl From<Action> for Vote {
    fn from(action: Action) -> Self {
        match action {
            Action::VoteApprove => Vote::Approve,
            Action::VoteReject => Vote::Reject,
            Action::VoteRemove => Vote::Remove,
            _ => unreachable!(),
        }
    }
}

/// Proposal that are sent to this DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Proposal {
    /// Original proposer.
    pub proposer: AccountId,
    /// Description of this proposal.
    pub description: String,
    /// Kind of proposal with relevant information.
    pub kind: ProposalKind,
    /// Current status of the proposal.
    pub status: ProposalStatus,
    /// Count of votes per role per decision: yes / no / spam.
    pub vote_counts: HashMap<String, [Balance; 3]>,
    /// Map of who voted and how.
    pub votes: HashMap<AccountId, Vote>,
    /// Submission time (for voting period).
    pub submission_time: U64,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum VersionedProposal {
    Default(Proposal),
}

impl From<VersionedProposal> for Proposal {
    fn from(v: VersionedProposal) -> Self {
        match v {
            VersionedProposal::Default(p) => p,
        }
    }
}

impl Proposal {
    /// Adds vote of the given user with given `amount` of weight. If user already voted, fails.
    pub fn update_votes(
        &mut self,
        account_id: &AccountId,
        roles: &[String],
        vote: Vote,
        policy: &Policy,
        user_weight: Balance,
    ) {
        for role in roles {
            let amount = if policy.is_token_weighted(role, &self.kind.to_policy_label().to_string())
            {
                user_weight
            } else {
                1
            };
            self.vote_counts.entry(role.clone()).or_insert([0u128; 3])[vote.clone() as usize] +=
                amount;
        }
        assert!(
            self.votes.insert(account_id.clone(), vote).is_none(),
            "ERR_ALREADY_VOTED"
        );
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalInput {
    /// Description of this proposal.
    pub description: String,
    /// Kind of proposal with relevant information.
    pub kind: ProposalKind,
}

impl From<ProposalInput> for Proposal {
    fn from(input: ProposalInput) -> Self {
        Self {
            proposer: env::predecessor_account_id(),
            description: input.description,
            kind: input.kind,
            status: ProposalStatus::InProgress,
            vote_counts: HashMap::default(),
            votes: HashMap::default(),
            submission_time: U64::from(env::block_timestamp()),
        }
    }
}

impl Contract {
    /// Execute payout of given token to given user.
    pub(crate) fn internal_payout(
        &mut self,
        token_id: &Option<AccountId>,
        receiver_id: &AccountId,
        amount: Balance,
        memo: String,
        msg: Option<String>,
    ) -> PromiseOrValue<()> {
        if token_id.is_none() {
            Promise::new(receiver_id.clone()).transfer(amount).into()
        } else {
            if let Some(msg) = msg {
                ext_fungible_token::ft_transfer_call(
                    receiver_id.clone(),
                    U128(amount),
                    Some(memo),
                    msg,
                    token_id.as_ref().unwrap().clone(),
                    ONE_YOCTO_NEAR,
                    GAS_FOR_FT_TRANSFER,
                )
            } else {
                ext_fungible_token::ft_transfer(
                    receiver_id.clone(),
                    U128(amount),
                    Some(memo),
                    token_id.as_ref().unwrap().clone(),
                    ONE_YOCTO_NEAR,
                    GAS_FOR_FT_TRANSFER,
                )
            }
            .into()
        }
    }

    fn internal_return_bonds(&mut self, policy: &Policy, proposal: &Proposal) -> Promise {
        match &proposal.kind {
            ProposalKind::BountyDone { .. } => {
                self.locked_amount -= policy.bounty_bond.0;
                Promise::new(proposal.proposer.clone()).transfer(policy.bounty_bond.0);
            }
            _ => {}
        }

        self.locked_amount -= policy.proposal_bond.0;
        Promise::new(proposal.proposer.clone()).transfer(policy.proposal_bond.0)
    }

    /// Executes given proposal and updates the contract's state.
    fn internal_execute_proposal(
        &mut self,
        policy: &Policy,
        proposal: &Proposal,
        proposal_id: u64,
    ) -> PromiseOrValue<()> {
        let result = match &proposal.kind {
            ProposalKind::ChangeConfig { config } => {
                self.config.set(config);
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicy { policy } => {
                self.policy.set(policy);
                PromiseOrValue::Value(())
            }
            ProposalKind::AddMemberToRole { member_id, role } => {
                let mut new_policy = policy.clone();
                new_policy.add_member_to_role(role, &member_id.clone().into());
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::RemoveMemberFromRole { member_id, role } => {
                let mut new_policy = policy.clone();
                new_policy.remove_member_from_role(role, &member_id.clone().into());
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::FunctionCall {
                receiver_id,
                actions,
            } => {
                let mut promise = Promise::new(receiver_id.clone().into());
                for action in actions {
                    promise = promise.function_call(
                        action.method_name.clone().into(),
                        action.args.clone().into(),
                        action.deposit.0,
                        Gas(action.gas.0),
                    )
                }
                promise.into()
            }
            ProposalKind::UpgradeSelf { hash } => {
                upgrade_using_factory(hash.clone());
                PromiseOrValue::Value(())
            }
            ProposalKind::UpgradeRemote {
                receiver_id,
                method_name,
                hash,
            } => {
                upgrade_remote(&receiver_id, method_name, &CryptoHash::from(hash.clone()));
                PromiseOrValue::Value(())
            }
            ProposalKind::Transfer {
                token_id,
                receiver_id,
                amount,
                msg,
            } => self.internal_payout(
                &convert_old_to_new_token(token_id),
                &receiver_id,
                amount.0,
                proposal.description.clone(),
                msg.clone(),
            ),
            ProposalKind::SetStakingContract { staking_id } => {
                assert!(self.staking_id.is_none(), "ERR_INVALID_STAKING_CHANGE");
                self.staking_id = Some(staking_id.clone().into());
                PromiseOrValue::Value(())
            }
            ProposalKind::AddBounty { bounty } => {
                self.internal_add_bounty(bounty);
                PromiseOrValue::Value(())
            }
            ProposalKind::BountyDone {
                bounty_id,
                receiver_id,
            } => self.internal_execute_bounty_payout(*bounty_id, &receiver_id.clone().into(), true),
            ProposalKind::Vote => PromiseOrValue::Value(()),
            ProposalKind::FactoryInfoUpdate { factory_info } => {
                internal_set_factory_info(factory_info);
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicyAddOrUpdateRole { role } => {
                let mut new_policy = policy.clone();
                new_policy.add_or_update_role(role);
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicyRemoveRole { role } => {
                let mut new_policy = policy.clone();
                new_policy.remove_role(role);
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicyUpdateDefaultVotePolicy { vote_policy } => {
                let mut new_policy = policy.clone();
                new_policy.update_default_vote_policy(vote_policy);
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicyUpdateParameters { parameters } => {
                let mut new_policy = policy.clone();
                new_policy.update_parameters(parameters);
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
        };
        match result {
            PromiseOrValue::Promise(promise) => promise
                .then(ext_self::on_proposal_callback(
                    proposal_id,
                    env::current_account_id(),
                    0,
                    GAS_FOR_FT_TRANSFER,
                ))
                .into(),
            PromiseOrValue::Value(()) => self.internal_return_bonds(&policy, &proposal).into(),
        }
    }

    pub(crate) fn internal_callback_proposal_success(
        &mut self,
        proposal: &mut Proposal,
    ) -> PromiseOrValue<()> {
        let policy = self.policy.get().unwrap().to_policy();
        if let ProposalKind::BountyDone { bounty_id, .. } = proposal.kind {
            let mut bounty: Bounty = self.bounties.get(&bounty_id).expect("ERR_NO_BOUNTY").into();
            if bounty.times == 0 {
                self.bounties.remove(&bounty_id);
            } else {
                bounty.times -= 1;
                self.bounties
                    .insert(&bounty_id, &VersionedBounty::Default(bounty));
            }
        }
        proposal.status = ProposalStatus::Approved;
        self.internal_return_bonds(&policy, &proposal).into()
    }

    pub(crate) fn internal_callback_proposal_fail(
        &mut self,
        proposal: &mut Proposal,
    ) -> PromiseOrValue<()> {
        proposal.status = ProposalStatus::Failed;
        PromiseOrValue::Value(())
    }

    /// Process rejecting proposal.
    fn internal_reject_proposal(
        &mut self,
        policy: &Policy,
        proposal: &Proposal,
        return_bonds: bool,
    ) -> PromiseOrValue<()> {
        if return_bonds {
            // Return bond to the proposer.
            self.internal_return_bonds(policy, proposal);
        }
        match &proposal.kind {
            ProposalKind::BountyDone {
                bounty_id,
                receiver_id,
            } => {
                self.internal_execute_bounty_payout(*bounty_id, &receiver_id.clone().into(), false)
            }
            _ => PromiseOrValue::Value(()),
        }
    }

    pub(crate) fn internal_user_info(&self) -> UserInfo {
        let account_id = env::predecessor_account_id();
        UserInfo {
            amount: self.get_user_weight(&account_id),
            account_id,
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Add proposal to this DAO.
    #[payable]
    pub fn add_proposal(&mut self, proposal: ProposalInput) -> u64 {
        // 0. validate bond attached.
        // TODO: consider bond in the token of this DAO.
        let policy = self.policy.get().unwrap().to_policy();

        assert_eq!(
            env::attached_deposit(),
            policy.proposal_bond.0,
            "ERR_MIN_BOND"
        );

        // 1. Validate proposal.
        match &proposal.kind {
            ProposalKind::ChangePolicy { policy } => match policy {
                VersionedPolicy::Current(_) => {}
                _ => panic!("ERR_INVALID_POLICY"),
            },
            ProposalKind::Transfer { token_id, msg, .. } => {
                assert!(
                    !(token_id == OLD_BASE_TOKEN) || msg.is_none(),
                    "ERR_BASE_TOKEN_NO_MSG"
                );
            }
            ProposalKind::SetStakingContract { .. } => assert!(
                self.staking_id.is_none(),
                "ERR_STAKING_CONTRACT_CANT_CHANGE"
            ),
            // TODO: add more verifications.
            _ => {}
        };

        // 2. Check permission of caller to add this type of proposal.
        assert!(
            policy
                .can_execute_action(
                    self.internal_user_info(),
                    &proposal.kind,
                    &Action::AddProposal
                )
                .1,
            "ERR_PERMISSION_DENIED"
        );

        // 3. Actually add proposal to the current list of proposals.
        let id = self.last_proposal_id;
        self.proposals
            .insert(&id, &VersionedProposal::Default(proposal.into()));
        self.last_proposal_id += 1;
        self.locked_amount += env::attached_deposit();
        id
    }

    /// Act on given proposal by id, if permissions allow.
    /// Memo is logged but not stored in the state. Can be used to leave notes or explain the action.
    pub fn act_proposal(&mut self, id: u64, action: Action, memo: Option<String>) {
        let mut proposal: Proposal = self.proposals.get(&id).expect("ERR_NO_PROPOSAL").into();
        let policy = self.policy.get().unwrap().to_policy();
        // Check permissions for the given action.
        let (roles, allowed) =
            policy.can_execute_action(self.internal_user_info(), &proposal.kind, &action);
        assert!(allowed, "ERR_PERMISSION_DENIED");
        let sender_id = env::predecessor_account_id();
        // Update proposal given action. Returns true if should be updated in storage.
        let update = match action {
            Action::AddProposal => env::panic_str("ERR_WRONG_ACTION"),
            Action::RemoveProposal => {
                self.proposals.remove(&id);
                false
            }
            Action::VoteApprove | Action::VoteReject | Action::VoteRemove => {
                assert!(
                    matches!(proposal.status, ProposalStatus::InProgress),
                    "ERR_PROPOSAL_NOT_READY_FOR_VOTE"
                );
                proposal.update_votes(
                    &sender_id,
                    &roles,
                    Vote::from(action),
                    &policy,
                    self.get_user_weight(&sender_id),
                );
                // Updates proposal status with new votes using the policy.
                proposal.status =
                    policy.proposal_status(&proposal, roles, self.total_delegation_amount);
                if proposal.status == ProposalStatus::Approved {
                    self.internal_execute_proposal(&policy, &proposal, id);
                    true
                } else if proposal.status == ProposalStatus::Removed {
                    self.internal_reject_proposal(&policy, &proposal, false);
                    self.proposals.remove(&id);
                    false
                } else if proposal.status == ProposalStatus::Rejected {
                    self.internal_reject_proposal(&policy, &proposal, true);
                    true
                } else {
                    // Still in progress or expired.
                    true
                }
            }
            // There are two cases when proposal must be finalized manually: expired or failed.
            // In case of failed, we just recompute the status and if it still approved, we re-execute the proposal.
            // In case of expired, we reject the proposal and return the bond.
            // Corner cases:
            //  - if proposal expired during the failed state - it will be marked as expired.
            //  - if the number of votes in the group has changed (new members has been added) -
            //      the proposal can loose it's approved state. In this case new proposal needs to be made, this one can only expire.
            Action::Finalize => {
                proposal.status = policy.proposal_status(
                    &proposal,
                    policy.roles.iter().map(|r| r.name.clone()).collect(),
                    self.total_delegation_amount,
                );
                match proposal.status {
                    ProposalStatus::Approved => {
                        self.internal_execute_proposal(&policy, &proposal, id);
                    }
                    ProposalStatus::Expired => {
                        self.internal_reject_proposal(&policy, &proposal, true);
                    }
                    _ => {
                        env::panic_str("ERR_PROPOSAL_NOT_EXPIRED_OR_FAILED");
                    }
                }
                true
            }
            Action::MoveToHub => false,
        };
        if update {
            self.proposals
                .insert(&id, &VersionedProposal::Default(proposal));
        }
        if let Some(memo) = memo {
            log!("Memo: {}", memo);
        }
    }

    /// Receiving callback after the proposal has been finalized.
    /// If successful, returns bond money to the proposal originator.
    /// If the proposal execution failed (funds didn't transfer or function call failure),
    /// move proposal to "Failed" state.
    #[private]
    pub fn on_proposal_callback(&mut self, proposal_id: u64) -> PromiseOrValue<()> {
        let mut proposal: Proposal = self
            .proposals
            .get(&proposal_id)
            .expect("ERR_NO_PROPOSAL")
            .into();
        assert_eq!(
            env::promise_results_count(),
            1,
            "ERR_UNEXPECTED_CALLBACK_PROMISES"
        );
        let result = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => self.internal_callback_proposal_success(&mut proposal),
            PromiseResult::Failed => self.internal_callback_proposal_fail(&mut proposal),
        };
        self.proposals
            .insert(&proposal_id, &VersionedProposal::Default(proposal.into()));
        result
    }
}

'''
'''--- sputnikdao2/src/types.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, Gas};

/// Account ID used for $NEAR in near-sdk v3.
/// Need to keep it around for backward compatibility.
pub const OLD_BASE_TOKEN: &str = "";

/// Account ID that represents a token in near-sdk v3.
/// Need to keep it around for backward compatibility.
pub type OldAccountId = String;

/// 1 yN to prevent access key fraud.
pub const ONE_YOCTO_NEAR: Balance = 1;

/// Gas for single ft_transfer call.
pub const GAS_FOR_FT_TRANSFER: Gas = Gas(10_000_000_000_000);

/// Configuration of the DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// Name of the DAO.
    pub name: String,
    /// Purpose of this DAO.
    pub purpose: String,
    /// Generic metadata. Can be used by specific UI to store additional data.
    /// This is not used by anything in the contract.
    pub metadata: Base64VecU8,
}

#[cfg(test)]
impl Config {
    pub fn test_config() -> Self {
        Self {
            name: "Test".to_string(),
            purpose: "to test".to_string(),
            metadata: Base64VecU8(vec![]),
        }
    }
}

/// Set of possible action to take.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    /// Action to add proposal. Used internally.
    AddProposal,
    /// Action to remove given proposal. Used for immediate deletion in special cases.
    RemoveProposal,
    /// Vote to approve given proposal or bounty.
    VoteApprove,
    /// Vote to reject given proposal or bounty.
    VoteReject,
    /// Vote to remove given proposal or bounty (because it's spam).
    VoteRemove,
    /// Finalize proposal, called when it's expired to return the funds
    /// (or in the future can be used for early proposal closure).
    Finalize,
    /// Move a proposal to the hub to shift into another DAO.
    MoveToHub,
}

impl Action {
    pub fn to_policy_label(&self) -> String {
        format!("{:?}", self)
    }
}

/// In near-sdk v3, the token was represented by a String, with no other restrictions.
/// That being said, Sputnik used "" (empty String) as a convention to represent the $NEAR token.
/// In near-sdk v4, the token representation was replaced by AccountId (which is in fact a wrapper
/// over a String), with the restriction that the token must be between 2 and 64 chars.
/// Sputnik had to adapt since "" was not allowed anymore and we chose to represent the token as a
/// Option<AccountId> with the convention that None represents the $NEAR token.
/// This function is required to help with the transition and keep the backward compatibility.
pub fn convert_old_to_new_token(old_account_id: &OldAccountId) -> Option<AccountId> {
    if old_account_id == OLD_BASE_TOKEN {
        return None;
    }
    Some(AccountId::new_unchecked(old_account_id.clone()))
}

'''
'''--- sputnikdao2/src/upgrade.rs ---
//! Logic to upgrade Sputnik contracts.

use near_sdk::serde_json::json;
use near_sdk::Gas;

use crate::*;

const FACTORY_KEY: &[u8; 7] = b"FACTORY";
const ERR_MUST_BE_SELF_OR_FACTORY: &str = "ERR_MUST_BE_SELF_OR_FACTORY";
const UPDATE_GAS_LEFTOVER: Gas = Gas(10_000_000_000_000);
const FACTORY_UPDATE_GAS_LEFTOVER: Gas = Gas(15_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

pub const GAS_FOR_UPGRADE_SELF_DEPLOY: Gas = Gas(15_000_000_000_000);
pub const GAS_FOR_UPGRADE_REMOTE_DEPLOY: Gas = Gas(15_000_000_000_000);

/// Info about factory that deployed this contract and if auto-update is allowed.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct FactoryInfo {
    pub factory_id: AccountId,
    pub auto_update: bool,
}

pub fn get_default_factory_id() -> AccountId {
    // ex: mydao.sputnik-dao.near
    let dao_id = env::current_account_id().to_string();
    let idx = dao_id.find('.').expect("INTERNAL_FAIL");
    // ex: sputnik-dao.near
    let factory_id = &dao_id[idx + 1..];

    AccountId::new_unchecked(String::from(factory_id))
}

/// Fetches factory info from the storage.
/// By design not using contract STATE to allow for upgrade of stuck contracts from factory.
pub(crate) fn internal_get_factory_info() -> FactoryInfo {
    env::storage_read(FACTORY_KEY)
        .map(|value| FactoryInfo::try_from_slice(&value).expect("INTERNAL_FAIL"))
        .unwrap_or_else(|| FactoryInfo {
            factory_id: get_default_factory_id(),
            auto_update: true,
        })
}

pub(crate) fn internal_set_factory_info(factory_info: &FactoryInfo) {
    env::storage_write(
        FACTORY_KEY,
        &factory_info.try_to_vec().expect("INTERNAL_FAIL"),
    );
}

/// Function that receives new contract, updates and calls migration.
/// Two options who call it:
///  - current account, in case of fetching contract code from factory;
///  - factory, if this contract allows to factory-update;
#[no_mangle]
pub fn update() {
    env::setup_panic_hook();

    let factory_info = internal_get_factory_info();
    let current_id = env::current_account_id();
    assert!(
        env::predecessor_account_id() == current_id
            || (env::predecessor_account_id() == factory_info.factory_id
                && factory_info.auto_update),
        "{}",
        ERR_MUST_BE_SELF_OR_FACTORY
    );

    let is_callback = env::predecessor_account_id() == current_id;
    let input;
    if is_callback {
        input = match env::promise_result(0) {
            PromiseResult::Successful(data) => data,
            _ => env::panic_str("ERR_NO_RESULT"),
        };
    } else {
        input = env::input().expect("ERR_NO_INPUT");
    };

    let promise_id = env::promise_batch_create(&current_id);
    // Deploy the contract code.
    env::promise_batch_action_deploy_contract(promise_id, &input);
    // Call promise to migrate the state.
    // Batched together to fail upgrade if migration fails.
    env::promise_batch_action_function_call(
        promise_id,
        "migrate",
        &[],
        NO_DEPOSIT,
        env::prepaid_gas() - env::used_gas() - UPDATE_GAS_LEFTOVER,
    );
    env::promise_return(promise_id);
}

pub(crate) fn upgrade_using_factory(code_hash: Base58CryptoHash) {
    let account_id = get_default_factory_id();
    // Create a promise toward the factory.
    let promise_id = env::promise_batch_create(&account_id);
    // Call `update` method from the factory which calls `update` method on this account.
    env::promise_batch_action_function_call(
        promise_id,
        "update",
        &json!({ "account_id": env::current_account_id(), "code_hash": code_hash })
            .to_string()
            .into_bytes(),
        NO_DEPOSIT,
        env::prepaid_gas() - env::used_gas() - FACTORY_UPDATE_GAS_LEFTOVER,
    );
    env::promise_return(promise_id);
}

#[allow(dead_code)]
pub(crate) fn upgrade_self(hash: &[u8]) {
    let current_id = env::current_account_id();
    let input = env::storage_read(hash).expect("ERR_NO_HASH");
    let promise_id = env::promise_batch_create(&current_id);
    env::promise_batch_action_deploy_contract(promise_id, &input);
    env::promise_batch_action_function_call(
        promise_id,
        "migrate",
        &[],
        NO_DEPOSIT,
        env::prepaid_gas() - env::used_gas() - GAS_FOR_UPGRADE_SELF_DEPLOY,
    );
}

pub(crate) fn upgrade_remote(receiver_id: &AccountId, method_name: &str, hash: &[u8]) {
    let input = env::storage_read(hash).expect("ERR_NO_HASH");
    let promise_id = env::promise_batch_create(receiver_id);
    env::promise_batch_action_function_call(
        promise_id,
        method_name,
        &input,
        NO_DEPOSIT,
        env::prepaid_gas() - env::used_gas() - GAS_FOR_UPGRADE_REMOTE_DEPLOY,
    );
}

'''
'''--- sputnikdao2/src/views.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use std::cmp::min;

use crate::*;

/// This is format of output via JSON for the proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalOutput {
    /// Id of the proposal.
    pub id: u64,
    #[serde(flatten)]
    pub proposal: Proposal,
}

/// This is format of output via JSON for the bounty.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BountyOutput {
    /// Id of the bounty.
    pub id: u64,
    #[serde(flatten)]
    pub bounty: Bounty,
}

#[near_bindgen]
impl Contract {
    /// Returns semver of this contract.
    pub fn version(&self) -> String {
        env!("CARGO_PKG_VERSION").to_string()
    }

    /// Returns config of this contract.
    pub fn get_config(&self) -> Config {
        self.config.get().unwrap().clone()
    }

    /// Returns policy of this contract.
    pub fn get_policy(&self) -> Policy {
        self.policy.get().unwrap().to_policy().clone()
    }

    /// Returns staking contract if available. Otherwise returns empty.
    pub fn get_staking_contract(self) -> String {
        self.staking_id.map(String::from).unwrap_or_default()
    }

    /// Returns if blob with given hash is stored.
    pub fn has_blob(&self, hash: Base58CryptoHash) -> bool {
        env::storage_has_key(&CryptoHash::from(hash))
    }

    /// Returns locked amount of NEAR that is used for storage.
    pub fn get_locked_storage_amount(&self) -> U128 {
        let locked_storage_amount = env::storage_byte_cost() * (env::storage_usage() as u128);
        U128(locked_storage_amount)
    }

    /// Returns available amount of NEAR that can be spent (outside of amount for storage and bonds).
    pub fn get_available_amount(&self) -> U128 {
        U128(env::account_balance() - self.get_locked_storage_amount().0 - self.locked_amount)
    }

    /// Returns total delegated stake.
    pub fn delegation_total_supply(&self) -> U128 {
        U128(self.total_delegation_amount)
    }

    /// Returns delegated stake to given account.
    pub fn delegation_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.delegations.get(&account_id).unwrap_or_default())
    }

    /// Combines balance and total amount for calling from external contracts.
    pub fn delegation_balance_ratio(&self, account_id: AccountId) -> (U128, U128) {
        (
            self.delegation_balance_of(account_id),
            self.delegation_total_supply(),
        )
    }

    /// Last proposal's id.
    pub fn get_last_proposal_id(&self) -> u64 {
        self.last_proposal_id
    }

    /// Get proposals in paginated view.
    pub fn get_proposals(&self, from_index: u64, limit: u64) -> Vec<ProposalOutput> {
        (from_index..min(self.last_proposal_id, from_index + limit))
            .filter_map(|id| {
                self.proposals.get(&id).map(|proposal| ProposalOutput {
                    id,
                    proposal: proposal.into(),
                })
            })
            .collect()
    }

    /// Get specific proposal.
    pub fn get_proposal(&self, id: u64) -> ProposalOutput {
        let proposal = self.proposals.get(&id).expect("ERR_NO_PROPOSAL");
        ProposalOutput {
            id,
            proposal: proposal.into(),
        }
    }

    /// Get given bounty by id.
    pub fn get_bounty(&self, id: u64) -> BountyOutput {
        let bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY");
        BountyOutput {
            id,
            bounty: bounty.into(),
        }
    }

    /// Get number of bounties.
    pub fn get_last_bounty_id(&self) -> u64 {
        self.last_bounty_id
    }

    /// Get `limit` of bounties from given index.
    pub fn get_bounties(&self, from_index: u64, limit: u64) -> Vec<BountyOutput> {
        (from_index..std::cmp::min(from_index + limit, self.last_bounty_id))
            .filter_map(|id| {
                self.bounties.get(&id).map(|bounty| BountyOutput {
                    id,
                    bounty: bounty.into(),
                })
            })
            .collect()
    }

    /// Get bounty claims for given user.
    pub fn get_bounty_claims(&self, account_id: AccountId) -> Vec<BountyClaim> {
        self.bounty_claimers.get(&account_id).unwrap_or_default()
    }

    /// Returns number of claims per given bounty.
    pub fn get_bounty_number_of_claims(&self, id: u64) -> u32 {
        self.bounty_claims_count.get(&id).unwrap_or_default()
    }
}

'''
'''--- sputnikdao2/test.bat ---
:: This script is for Windows.
:: It was auto-generated by near-workspaces-ava,
:: and only runs the tests in the `near-workspaces` folder.
cd tests-ava
npm install
npm run test -- %*
'''
'''--- sputnikdao2/test.sh ---
#!/bin/bash

# This script is for use with Linux/macOS/Unix.
# It was auto-generated by near-workspaces-ava,
# and only runs the tests in the `near-workspaces` folder.
sh build.sh # to make sure last version is tested
cd tests-ava
npm install
npm run test -- $@ # pass along any CLI flags, such as `--verbose`
'''
'''--- sputnikdao2/tests-ava/README.md ---
These tests use [near-workspaces-ava](https://github.com/near/workspaces-js/tree/main/packages/ava): delightful, deterministic local testing for NEAR smart contracts.

You will need to install [NodeJS](https://nodejs.dev/). Then you can use the `scripts` defined in [package.json](./package.json):

    npm run test

If you want to run `near-workspaces-ava` or `ava` directly, you can use [npx](https://nodejs.dev/learn/the-npx-nodejs-package-runner):

    npx near-workspaces-ava --help
    npx ava --help

To run only one test file:

    npm run test "**/main*"         # matches test files starting with "main"
    npm run test "**/whatever/**/*" # matches test files in the "whatever" directory

To run only one test:

    npm run test -- -m "root sets*" # matches tests with titles starting with "root sets"
    yarn test -m "root sets*"       # same thing using yarn instead of npm, see https://yarnpkg.com/

If debugging:

    NEAR_WORKSPACES_DEBUG=true npm run test

'''
'''--- sputnikdao2/tests-ava/__tests__/bounties.ava.ts ---
import {
    Workspace,
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
    ONE_NEAR,
    NEAR,
} from 'near-workspaces-ava';
import {
    workspace,
    initStaking,
    initTestToken,
    STORAGE_PER_BYTE,
} from './utils';
import {
    DEADLINE,
    BOND,
    proposeBounty,
    proposeBountyWithNear,
    voteOnBounty,
    claimBounty,
    doneBounty,
    giveupBounty,
    giveupBountyRaw,
    voteApprove,
} from './utils';

workspace.test('Bounty workflow', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    const proposalId = await proposeBounty(alice, dao, testToken);
    await voteOnBounty(root, dao, proposalId);
    await claimBounty(alice, dao, proposalId);
    const proposal = await dao.view('get_bounty_claims', { account_id: alice });
    test.log('Claims before bounty_done:');
    test.log(await dao.view('get_bounty_claims', { account_id: alice }));
    await doneBounty(alice, alice, dao, proposalId);
    test.log('Claims after bounty_done:');
    test.log(await dao.view('get_bounty_claims', { account_id: alice }));
    test.log('The proposal before act_proposal, voting on the bounty:');
    test.log(await dao.view('get_proposal', { id: proposalId + 1 }));
    await voteOnBounty(root, dao, proposalId + 1);
    test.log('The proposal after act_proposal, voting on the bounty:');
    test.log(await dao.view('get_proposal', { id: proposalId + 1 }));
});

workspace.test('Bounty claim', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    const proposalId = await proposeBounty(alice, dao, testToken);

    //The method could panic if the bounty with given id doesn't exist
    let errorString1 = await captureError(
        async () => await claimBounty(alice, dao, proposalId),
    );
    test.regex(errorString1, /ERR_NO_BOUNTY/);

    await voteOnBounty(root, dao, proposalId);

    //Should panic if `attached_deposit`
    //is not equal to the corresponding `bounty_bond`
    //If we attach more than needed:
    let errorString2_1 = await captureError(
        async () =>
            await alice.call(
                dao,
                'bounty_claim',
                {
                    id: proposalId,
                    deadline: DEADLINE,
                },
                {
                    attachedDeposit: new BN(BOND).addn(1),
                },
            ),
    );
    test.regex(errorString2_1, /ERR_BOUNTY_WRONG_BOND/);
    //If we attach less than needed:
    let errorString2_2 = await captureError(
        async () =>
            await alice.call(
                dao,
                'bounty_claim',
                {
                    id: proposalId,
                    deadline: DEADLINE,
                },
                {
                    attachedDeposit: new BN(BOND).subn(1),
                },
            ),
    );
    test.regex(errorString2_2, /ERR_BOUNTY_WRONG_BOND/);

    //Should panic in case of wrong deadline
    let errorString3 = await captureError(
        async () =>
            await alice.call(
                dao,
                'bounty_claim',
                {
                    id: proposalId,
                    deadline: '1925376849430593582',
                },
                {
                    attachedDeposit: BOND,
                },
            ),
    );
    test.regex(errorString3, /ERR_BOUNTY_WRONG_DEADLINE/);

    await claimBounty(alice, dao, proposalId);

    //Should increase number of claims
    test.is(
        await dao.view('get_bounty_number_of_claims', { id: proposalId }),
        1,
    );

    //Should add this claim to the list of claims, done by this account
    let bounty: any = await dao.view('get_bounty_claims', {
        account_id: alice,
    });
    test.is(bounty[0].bounty_id, 0);
    test.is(bounty[0].deadline, DEADLINE);
    test.is(bounty[0].completed, false);

    await claimBounty(alice, dao, proposalId);
    test.is(
        await dao.view('get_bounty_number_of_claims', { id: proposalId }),
        2,
    );

    let bounty2: any = await dao.view('get_bounty_claims', {
        account_id: alice,
    });
    test.is(bounty2[1].bounty_id, 0);
    test.is(bounty2[1].deadline, DEADLINE);
    test.is(bounty2[1].completed, false);

    await claimBounty(alice, dao, proposalId);
    test.is(
        await dao.view('get_bounty_number_of_claims', { id: proposalId }),
        3,
    );

    //Should panic if all bounties are claimed
    let errorString4 = await captureError(
        async () =>
            await alice.call(
                dao,
                'bounty_claim',
                {
                    id: proposalId,
                    deadline: DEADLINE,
                },
                {
                    attachedDeposit: BOND,
                },
            ),
    );
    test.regex(errorString4, /ERR_BOUNTY_ALL_CLAIMED/);
});

workspace.test(
    'Bounty done with NEAR token',
    async (test, { alice, root, dao }) => {
        const proposalId = await proposeBountyWithNear(alice, dao);

        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);

        const bob = await root.createAccount('bob');
        //Should panic if the caller is not in the list of claimers
        let errorString1 = await captureError(
            async () => await doneBounty(alice, bob, dao, proposalId),
        );
        test.regex(errorString1, /ERR_NO_BOUNTY_CLAIMS/);

        await claimBounty(bob, dao, proposalId);

        //Should panic if the list of claims for the caller of the method
        //doesn't contain the claim with given ID
        let errorString2 = await captureError(
            async () => await doneBounty(alice, alice, dao, proposalId + 10),
        );
        test.regex(errorString2, /ERR_NO_BOUNTY_CLAIM/);

        //`bounty_done` can only be called by the claimer
        let errorString3 = await captureError(
            async () => await doneBounty(alice, bob, dao, proposalId),
        );
        test.regex(errorString3, /ERR_BOUNTY_DONE_MUST_BE_SELF/);

        let bounty: any = await dao.view('get_bounty_claims', {
            account_id: alice,
        });
        test.is(bounty[0].completed, false);

        await doneBounty(alice, alice, dao, proposalId);

        //claim is marked as completed
        bounty = await dao.view('get_bounty_claims', { account_id: alice });
        test.is(bounty[0].completed, true);

        let proposal: any = await dao.view('get_proposal', {
            id: proposalId + 1,
        });
        test.is(proposal.status, 'InProgress');

        await voteOnBounty(root, dao, proposalId + 1);

        //proposal is approved
        proposal = await dao.view('get_proposal', { id: proposalId + 1 });
        test.is(proposal.status, 'Approved');

        //Should panic if the bounty claim is completed
        let errorString4 = await captureError(
            async () => await doneBounty(alice, alice, dao, proposalId),
        );
        test.regex(errorString4, /ERR_NO_BOUNTY_CLAIMS/);
    },
);

workspace.test('Bounty giveup', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    const proposalId = await proposeBounty(alice, dao, testToken);
    await voteOnBounty(root, dao, proposalId);
    await claimBounty(alice, dao, proposalId);

    //Should panic if the caller is not in the list of claimers
    const bob = await root.createAccount('bob');
    let errorString = await captureError(
        async () => await giveupBounty(bob, dao, proposalId),
    );
    test.regex(errorString, /ERR_NO_BOUNTY_CLAIMS/);

    //Should panic if the list of claims for the caller of the method
    //doesn't contain the claim with given ID
    errorString = await captureError(
        async () => await giveupBounty(alice, dao, proposalId + 10),
    );
    test.regex(errorString, /ERR_NO_BOUNTY_CLAIM/);

    //If within forgiveness period, `bounty_bond` should be returned ???
    const balance1: NEAR = (await alice.balance()).total;
    const result = await giveupBountyRaw(alice, dao, proposalId);
    const balance2: NEAR = (await alice.balance()).total;
    test.is(
        Number(balance2.add(result.gas_burnt).toHuman().slice(0, -1)).toFixed(
            1,
        ),
        Number(balance1.add(ONE_NEAR).toHuman().slice(0, -1)).toFixed(1),
    );
    test.not(balance2, balance1);

    //If within forgiveness period,
    //claim should be removed from the list of claims, done by this account
    test.deepEqual(
        await dao.view('get_bounty_claims', { account_id: alice }),
        [],
    );
});

workspace.test('Bounty ft done', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    await dao.call(
        testToken,
        'mint',
        {
            account_id: dao,
            amount: '1000000000',
        },
        {
            gas: tGas(50),
        },
    );
    await alice.call(
        testToken,
        'storage_deposit',
        {
            account_id: alice.accountId,
            registration_only: true,
        },
        {
            attachedDeposit: toYocto('90'),
        },
    );
    const bounty = {
        description: 'test_bounties',
        token: testToken.accountId,
        amount: '10',
        times: 3,
        max_deadline: DEADLINE,
    };
    let proposalId: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'add_new_bounty',
                kind: {
                    AddBounty: {
                        bounty,
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    await voteApprove(root, dao, proposalId);
    let { status } = await dao.view('get_proposal', { id: proposalId });
    test.is(status, 'Approved');
    const bountyId = 0; // first bounty
    await claimBounty(alice, dao, bountyId);
    await alice.call(
        dao,
        'bounty_done',
        {
            id: bountyId,
            account_id: alice.accountId,
            description: 'This bounty is done',
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );

    await voteApprove(root, dao, proposalId + 1);
    ({ status } = await dao.view('get_proposal', { id: proposalId }));
    test.is(status, 'Approved');
});

workspace.test(
    'Callback for BountyDone with NEAR token',
    async (test, { alice, root, dao }) => {
        //During the callback the number bounty_claims_count should decrease
        const proposalId = await proposeBountyWithNear(alice, dao);
        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);
        await doneBounty(alice, alice, dao, proposalId);
        //Before the bounty is done there is 1 claim
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        const balanceBefore: NEAR = (await alice.balance()).total;
        //During the callback this number is decreased
        await voteOnBounty(root, dao, proposalId + 1);
        const balanceAfter: NEAR = (await alice.balance()).total;
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 0);
        test.assert(balanceBefore.lt(balanceAfter));
    },
);

workspace.test(
    'Callback for BountyDone ft token fail',
    async (test, { alice, root, dao }) => {
        //Test the callback with Failed proposal status
        const testTokenFail = await initTestToken(root);
        const proposalIdFail = await proposeBounty(alice, dao, testTokenFail);
        await dao.call(
            testTokenFail,
            'mint',
            {
                account_id: dao,
                amount: '1000000000',
            },
            {
                gas: tGas(50),
            },
        );
        await alice.call(
            testTokenFail,
            'storage_deposit',
            {
                account_id: alice.accountId,
                registration_only: true,
            },
            {
                attachedDeposit: toYocto('90'),
            },
        );
        await voteOnBounty(root, dao, proposalIdFail);
        await claimBounty(alice, dao, proposalIdFail);
        await doneBounty(alice, alice, dao, proposalIdFail);
        await voteOnBounty(root, dao, proposalIdFail + 1);
        //Proposal should be Failed
        let { status } = await dao.view('get_proposal', {
            id: proposalIdFail + 1,
        });
        test.is(status, 'Failed');
    },
);

workspace.test(
    'Callback for BountyDone ft token',
    async (test, { alice, root, dao }) => {
        //Test correct callback
        const testToken = await initTestToken(root);
        await dao.call(
            testToken,
            'mint',
            {
                account_id: dao,
                amount: '1000000000',
            },
            {
                gas: tGas(50),
            },
        );
        await alice.call(
            testToken,
            'storage_deposit',
            {
                account_id: alice.accountId,
                registration_only: true,
            },
            {
                attachedDeposit: toYocto('90'),
            },
        );
        const bounty = {
            description: 'test_bounties',
            token: testToken.accountId,
            amount: '10',
            times: 3,
            max_deadline: DEADLINE,
        };
        let proposalId: number = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'add_new_bounty',
                    kind: {
                        AddBounty: {
                            bounty,
                        },
                    },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);
        await doneBounty(alice, alice, dao, proposalId);
        //Before the bounty is done there is 1 claim
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        const balanceBefore: NEAR = (await alice.balance()).total;
        //During the callback this number is decreased
        await voteOnBounty(root, dao, proposalId + 1);

        //Proposal should be approved
        let { status } = await dao.view('get_proposal', { id: proposalId + 1 });
        test.is(status, 'Approved');

        //During the callback the number bounty_claims_count should decrease
        const balanceAfter: NEAR = (await alice.balance()).total;
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 0);
        test.assert(balanceBefore.lt(balanceAfter));
    },
);

'''
'''--- sputnikdao2/tests-ava/__tests__/delegation.ava.ts ---
import {
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
} from 'near-workspaces-ava';
import {
    workspace,
    initStaking,
    initTestToken,
    STORAGE_PER_BYTE,
    setStakingId,
    registerAndDelegate,
    regCost,
} from './utils';

workspace.test('Register delegation', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);

    // set staking
    await setStakingId(root, dao, staking);

    await registerAndDelegate(dao, staking, alice, new BN(1));

    // Check that delegation appears in `delegations` LookupMap.
    let bal: BN = new BN(
        await dao.view('delegation_balance_of', { account_id: alice }),
    );
    test.deepEqual(bal, new BN(1));
    const total: BN = new BN(await dao.view('delegation_total_supply'));
    test.deepEqual(total, new BN(1));
});

workspace.test(
    'Register delegation fail',
    async (test, { root, dao, alice }) => {
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);

        // Staking id not set
        let errorString = await captureError(async () =>
            staking.call(
                dao,
                'register_delegation',
                { account_id: alice },
                { attachedDeposit: regCost },
            ),
        );
        test.regex(errorString, /ERR_NO_STAKING/);

        await setStakingId(root, dao, staking);
        // Can only be called by the `staking_id`
        errorString = await captureError(async () =>
            root.call(
                dao,
                'register_delegation',
                { account_id: alice },
                { attachedDeposit: regCost },
            ),
        );
        test.regex(errorString, /ERR_INVALID_CALLER/);

        // Attached deposit is handled correctly
        await captureError(async () =>
            root.call(
                dao,
                'register_delegation',
                { account_id: alice },
                { attachedDeposit: regCost.add(new BN(1)) },
            ),
        );
        await captureError(async () =>
            root.call(
                dao,
                'register_delegation',
                { account_id: alice },
                { attachedDeposit: regCost.sub(new BN(1)) },
            ),
        );
    },
);

workspace.test('Delegation', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);
    const randomAmount = new BN('10087687667869');
    const bob = await root.createAccount('bob');

    // set staking
    await setStakingId(root, dao, staking);

    let result = await registerAndDelegate(dao, staking, alice, randomAmount);
    test.deepEqual(
        [new BN(result[0]), new BN(result[1]), new BN(result[2])],
        [new BN('0'), randomAmount, randomAmount],
    );
    result = await registerAndDelegate(dao, staking, bob, randomAmount.muln(2));
    test.deepEqual(
        [new BN(result[0]), new BN(result[1]), new BN(result[2])],
        [new BN('0'), randomAmount.muln(2), randomAmount.muln(3)],
    );
    test.deepEqual(
        new BN(await dao.view('delegation_balance_of', { account_id: alice })),
        randomAmount,
    );
    test.deepEqual(
        new BN(await dao.view('delegation_balance_of', { account_id: bob })),
        randomAmount.muln(2),
    );
    test.deepEqual(
        new BN(await dao.view('delegation_total_supply')),
        randomAmount.muln(3),
    );
});

workspace.test('Delegation fail', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);
    const randomAmount = new BN('10087687667869');

    // Should panic if `staking_id` is `None`
    let errorString = await captureError(async () =>
        staking.call(dao, 'delegate', {
            account_id: alice,
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_NO_STAKING/);

    // set staking
    await setStakingId(root, dao, staking);

    // Check that it can only be called by the `staking_id`
    errorString = await captureError(async () =>
        root.call(dao, 'delegate', {
            account_id: alice,
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_INVALID_CALLER/);

    // Can't be called without previos registration
    errorString = await captureError(async () =>
        staking.call(dao, 'delegate', {
            account_id: 'not-registered-account.bob',
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_NOT_REGISTERED/);
});

workspace.test('Undelegate', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);
    const randomAmount = new BN('44887687667868');

    // set staking
    await setStakingId(root, dao, staking);

    await registerAndDelegate(dao, staking, alice, randomAmount);

    // Check that amount is subtracted correctly
    const result: string[3] = await staking.call(dao, 'undelegate', {
        account_id: alice,
        amount: randomAmount.divn(2).toString(),
    });
    test.deepEqual(
        [new BN(result[0]), new BN(result[1]), new BN(result[2])],
        [randomAmount, randomAmount.divn(2), randomAmount.divn(2)],
    );
});

workspace.test('Undelegate fail', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);
    const randomAmount = new BN('44887687667868');

    // Should panic if `staking_id` is `None`
    let errorString = await captureError(async () =>
        staking.call(dao, 'undelegate', {
            account_id: alice,
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_NO_STAKING/);

    // Set staking
    await setStakingId(root, dao, staking);

    // Check that it can only be called by the `staking_id`
    errorString = await captureError(async () =>
        root.call(dao, 'undelegate', {
            account_id: alice,
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_INVALID_CALLER/);

    await registerAndDelegate(dao, staking, alice, randomAmount);
    // Check that a user can't remove more than it delegated
    errorString = await captureError(async () =>
        staking.call(dao, 'undelegate', {
            account_id: alice,
            amount: randomAmount.addn(1).toString(),
        }),
    );
    test.regex(errorString, /ERR_INVALID_STAKING_CONTRACT/);
});

'''
'''--- sputnikdao2/tests-ava/__tests__/lib.ava.ts ---
import {
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
    DEFAULT_FUNCTION_CALL_GAS,
    Gas,
    NEAR,
} from 'near-workspaces-ava';
import {
    workspace,
    initStaking,
    initTestToken,
    STORAGE_PER_BYTE,
    workspaceWithoutInit,
    workspaceWithFactory,
} from './utils';
import { voteApprove } from './utils';
import {
    DEADLINE,
    BOND,
    proposeBounty,
    proposeBountyWithNear,
    voteOnBounty,
    claimBounty,
    doneBounty,
} from './utils';
import * as fs from 'fs';

const DAO_WASM_BYTES: Uint8Array = fs.readFileSync('../res/sputnikdao2.wasm');

workspaceWithFactory.test(
    'Upgrade self using factory',
    async (test, { root, factory }) => {
        const config = {
            name: 'testdao',
            purpose: 'to test',
            metadata: '',
        };
        const policy = [root.accountId];
        const params = {
            config,
            policy,
        };

        await root.call(
            factory,
            'create',
            {
                name: 'testdao',
                args: Buffer.from(JSON.stringify(params)).toString('base64'),
            },
            {
                attachedDeposit: toYocto('10'),
                gas: tGas(300),
            },
        );

        test.deepEqual(await factory.view('get_dao_list', {}), [
            'testdao.factory.test.near',
        ]);
        const hash = await factory.view('get_default_code_hash', {});

        const proposalId: number = await root.call(
            'testdao.factory.test.near',
            'add_proposal',
            {
                proposal: {
                    description: 'proposal to test',
                    kind: {
                        UpgradeSelf: {
                            hash: hash,
                        },
                    },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        test.is(proposalId, 0);

        await root.call(
            'testdao.factory.test.near',
            'act_proposal',
            {
                id: proposalId,
                action: 'VoteApprove',
            },
            {
                gas: tGas(300),
            },
        );
    },
);

workspaceWithoutInit.test(
    'Upgrade self negative',
    async (test, { root, dao }) => {
        const config = { name: 'sputnik', purpose: 'testing', metadata: '' };

        // NOT INITIALIZED
        let err = await captureError(async () =>
            root.call(dao, 'store_blob', DAO_WASM_BYTES, {
                attachedDeposit: toYocto('200'),
                gas: tGas(300),
            }),
        );
        test.regex(err, /ERR_CONTRACT_IS_NOT_INITIALIZED/);

        // Initializing contract
        await root.call(dao, 'new', { config, policy: [root.accountId] });

        // not enough deposit
        err = await captureError(async () =>
            root.call(dao, 'store_blob', DAO_WASM_BYTES, {
                attachedDeposit: toYocto('1'),
                gas: tGas(300),
            }),
        );
        test.regex(err, /ERR_NOT_ENOUGH_DEPOSIT/);

        await root.call(dao, 'store_blob', DAO_WASM_BYTES, {
            attachedDeposit: toYocto('200'),
            gas: tGas(300),
        });

        // Already exists
        err = await captureError(async () =>
            root.call(dao, 'store_blob', DAO_WASM_BYTES, {
                attachedDeposit: toYocto('200'),
                gas: tGas(300),
            }),
        );
        test.regex(err, /ERR_ALREADY_EXISTS/);
    },
);

workspace.test('Remove blob', async (test, { root, dao, alice }) => {
    const hash: String = await root.call(dao, 'store_blob', DAO_WASM_BYTES, {
        attachedDeposit: toYocto('200'),
        gas: tGas(300),
    });

    // fails if hash is wrong
    let err = await captureError(async () =>
        root.call(dao, 'remove_blob', {
            hash: 'HLBiX51txizmQzZJMrHMCq4u7iEEqNbaJppZ84yW7628', // some_random hash
        }),
    );
    test.regex(err, /ERR_NO_BLOB/);

    // Can only be called by the original storer
    err = await captureError(async () =>
        alice.call(dao, 'remove_blob', {
            hash: hash,
        }),
    );
    test.regex(err, /ERR_INVALID_CALLER/);

    // blob is removed with payback
    const rootAmountBeforeRemove = (await root.balance()).total;
    await root.call(dao, 'remove_blob', {
        hash: hash,
    });
    const rootAmountAfterRemove = (await root.balance()).total;
    test.false(await dao.view('has_blob', { hash: hash }));
    test.assert(rootAmountAfterRemove.gt(rootAmountBeforeRemove));
});

workspace.test(
    'Callback for BountyDone with NEAR token',
    async (test, { alice, root, dao }) => {
        //During the callback the number bounty_claims_count should decrease
        const proposalId = await proposeBountyWithNear(alice, dao);
        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);
        await doneBounty(alice, alice, dao, proposalId);
        //Before the bounty is done there is 1 claim
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        const balanceBefore: NEAR = (await alice.balance()).total;
        //During the callback this number is decreased
        await voteOnBounty(root, dao, proposalId + 1);
        const balanceAfter: NEAR = (await alice.balance()).total;
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 0);
        test.assert(balanceBefore.lt(balanceAfter));
    },
);

workspace.test(
    'Callback for BountyDone ft token fail',
    async (test, { alice, root, dao }) => {
        //Test the callback with Failed proposal status
        const testTokenFail = await initTestToken(root);
        const proposalIdFail = await proposeBounty(alice, dao, testTokenFail);
        await dao.call(
            testTokenFail,
            'mint',
            {
                account_id: dao,
                amount: '1000000000',
            },
            {
                gas: tGas(50),
            },
        );
        await alice.call(
            testTokenFail,
            'storage_deposit',
            {
                account_id: alice.accountId,
                registration_only: true,
            },
            {
                attachedDeposit: toYocto('90'),
            },
        );
        await voteOnBounty(root, dao, proposalIdFail);
        await claimBounty(alice, dao, proposalIdFail);
        await doneBounty(alice, alice, dao, proposalIdFail);
        await voteOnBounty(root, dao, proposalIdFail + 1);
        //Proposal should be Failed
        let { status } = await dao.view('get_proposal', {
            id: proposalIdFail + 1,
        });
        test.is(status, 'Failed');
    },
);

workspace.test(
    'Callback for BountyDone ft token',
    async (test, { alice, root, dao }) => {
        //Test correct callback
        const testToken = await initTestToken(root);
        await dao.call(
            testToken,
            'mint',
            {
                account_id: dao,
                amount: '1000000000',
            },
            {
                gas: tGas(50),
            },
        );
        await alice.call(
            testToken,
            'storage_deposit',
            {
                account_id: alice.accountId,
                registration_only: true,
            },
            {
                attachedDeposit: toYocto('90'),
            },
        );
        const bounty = {
            description: 'test_bounties',
            token: testToken.accountId,
            amount: '10',
            times: 3,
            max_deadline: DEADLINE,
        };
        let proposalId: number = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'add_new_bounty',
                    kind: {
                        AddBounty: {
                            bounty,
                        },
                    },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);
        await doneBounty(alice, alice, dao, proposalId);
        //Before the bounty is done there is 1 claim
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        const balanceBefore: NEAR = (await alice.balance()).total;
        //During the callback this number is decreased
        await voteOnBounty(root, dao, proposalId + 1);

        //Proposal should be approved
        let { status } = await dao.view('get_proposal', { id: proposalId + 1 });
        test.is(status, 'Approved');

        //During the callback the number bounty_claims_count should decrease
        const balanceAfter: NEAR = (await alice.balance()).total;
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 0);
        test.assert(balanceBefore.lt(balanceAfter));
    },
);

workspace.test('Callback transfer', async (test, { alice, root, dao }) => {
    const user1 = await root.createAccount('user1');
    // Fail transfer by transfering to non-existent accountId
    let transferId: number = await user1.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: 'broken_id',
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    let user1Balance = (await user1.balance()).total;
    await voteApprove(root, dao, transferId);
    let { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Failed');
    test.assert((await user1.balance()).total.eq(user1Balance)); // no bond returns on fail

    // now we transfer to real accountId
    transferId = await user1.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: alice.accountId, // valid id this time
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    user1Balance = (await user1.balance()).total;
    await voteApprove(root, dao, transferId);
    ({ status } = await dao.view('get_proposal', { id: transferId }));
    test.is(status, 'Approved');
    test.assert((await user1.balance()).total.gt(user1Balance)); // returns bond
});

workspace.test('Callback function call', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    let transferId: number = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    FunctionCall: {
                        receiver_id: testToken.accountId,
                        actions: [
                            {
                                method_name: 'fail',
                                args: Buffer.from('bad args').toString(
                                    'base64',
                                ),
                                deposit: toYocto('1'),
                                gas: tGas(10),
                            },
                        ],
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    await root.call(
        dao,
        'act_proposal',
        {
            id: transferId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(200),
        },
    );
    let { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Failed');

    transferId = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    FunctionCall: {
                        receiver_id: testToken.accountId,
                        actions: [
                            {
                                method_name: 'mint',
                                args: Buffer.from(
                                    '{"account_id": "' +
                                        alice.accountId +
                                        '", "amount": "10"}',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(10),
                            },
                            {
                                method_name: 'burn',
                                args: Buffer.from(
                                    '{"account_id": "' +
                                        alice.accountId +
                                        '", "amount": "10"}',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(10),
                            },
                        ],
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    await root.call(
        dao,
        'act_proposal',
        {
            id: transferId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(200),
        },
    );
    ({ status } = await dao.view('get_proposal', { id: transferId }));
    test.is(status, 'Approved');
});

'''
'''--- sputnikdao2/tests-ava/__tests__/policy.ava.ts ---
import {
    Workspace,
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
    DEFAULT_FUNCTION_CALL_GAS,
} from 'near-workspaces-ava';
import {
    initStaking,
    initTestToken,
    STORAGE_PER_BYTE,
    registerAndDelegate,
    setStakingId,
    workspaceWithoutInit as workspace,
} from './utils';

workspace.test(
    'Testing policy TokenWeight',
    async (test, { alice, root, dao }) => {
        const config = { name: 'sputnik', purpose: 'testing', metadata: '' };
        const bob = await root.createAccount('bob');
        const period = new BN('1000000000')
            .muln(60)
            .muln(60)
            .muln(24)
            .muln(7)
            .toString();
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);
        await root.call(dao, 'new', { config, policy: [root.accountId] });
        await setStakingId(root, dao, staking);

        const policy = {
            roles: [
                {
                    name: 'all',
                    kind: { Group: [alice.accountId, bob.accountId] }, // fails with kind: "Everyone" need to investigate
                    permissions: ['*:AddProposal', '*:VoteApprove'],
                    vote_policy: {},
                },
            ],
            default_vote_policy: {
                weight_kind: 'TokenWeight',
                quorum: new BN('1').toString(),
                threshold: '5',
            },
            proposal_bond: toYocto('1'),
            proposal_period: period,
            bounty_bond: toYocto('1'),
            bounty_forgiveness_period: period,
        };

        let proposalId: number = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'test',
                    kind: { ChangePolicy: { policy } },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        await root.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteApprove',
        });

        // Setting up a new config
        const new_config = {
            name: 'new dao wohoo',
            purpose: 'testing',
            metadata: '',
        };
        await registerAndDelegate(dao, staking, alice, new BN('1'));
        await registerAndDelegate(dao, staking, bob, new BN('4'));
        proposalId = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'test',
                    kind: {
                        ChangeConfig: {
                            config: new_config,
                        },
                    },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        await alice.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteApprove',
        });
        await bob.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteApprove',
        });
        test.deepEqual(await dao.view('get_config'), new_config);
    },
);

workspace.test('Policy self-lock', async (test, { alice, root, dao }) => {
    const config = { name: 'sputnik', purpose: 'testing', metadata: '' };
    const period = new BN('1000000000')
        .muln(60)
        .muln(60)
        .muln(24)
        .muln(7)
        .toString();
    const policy = {
        roles: [
            {
                name: 'all',
                kind: { Group: [alice.accountId] },
                permissions: ['*:AddProposal', '*:VoteApprove'],
                vote_policy: {},
            },
        ],
        default_vote_policy: {
            weight_kind: 'TokenWeight',
            quorum: new BN('1').toString(),
            threshold: '5',
        },
        proposal_bond: toYocto('1'),
        proposal_period: period,
        bounty_bond: toYocto('1'),
        bounty_forgiveness_period: period,
    };
    // 'staking_id' is not set, we can't delegate, so this contract got locked
    await root.call(dao, 'new', { config, policy });
    const proposalId = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'test',
                kind: {
                    ChangePolicy: {
                        policy,
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    await alice.call(dao, 'act_proposal', {
        id: proposalId,
        action: 'VoteApprove',
    });
    let { status } = await dao.view('get_proposal', { id: proposalId });
    test.is(status, 'InProgress');
});

'''
'''--- sputnikdao2/tests-ava/__tests__/proposals.ava.ts ---
import {
    toYocto,
    NearAccount,
    captureError,
    BN,
    NEAR,
    ONE_NEAR,
    tGas,
} from 'near-workspaces-ava';

import {
    workspace,
    initTestToken,
    initStaking,
    setStakingId,
    workspaceWithoutInit,
    voteApprove,
} from './utils';

workspace.test('basic', async (test, { alice, root, dao }) => {
    test.true(await alice.exists());
    test.true(await root.exists());
    test.true(await dao.exists());
    test.log(await dao.view('get_config'));
});

workspace.test(
    'add_proposal fails in case of insufficient deposit',
    async (test, { alice, root, dao }) => {
        test.is(await dao.view('get_last_proposal_id'), 0);
        const config = {
            name: 'sputnikdao',
            purpose: 'testing',
            metadata: '',
        };
        //Try adding a proposal with 0.999... near
        let err = await captureError(
            async () =>
                await alice.call(
                    dao,
                    'add_proposal',
                    {
                        proposal: {
                            description: 'rename the dao',
                            kind: {
                                ChangeConfig: {
                                    config,
                                },
                            },
                        },
                    },
                    { attachedDeposit: new BN(toYocto('1')).subn(1) },
                ),
        );

        test.log(err.toString());
        test.true(err.includes('ERR_MIN_BOND'));
        //the proposal did not count
        test.is(await dao.view('get_last_proposal_id'), 0);

        //Checks that the same proposal doesn't fail
        //if the deposit is at least 1 near
        await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );
        test.is(await dao.view('get_last_proposal_id'), 1);

        let new_proposal: any = await dao.view('get_proposal', { id: 0 });

        test.log(new_proposal);
        test.is(new_proposal.description, 'rename the dao');
        test.is(new_proposal.proposer, 'alice.test.near');
        test.is(new_proposal.status, 'InProgress');

        test.truthy(new_proposal.kind.ChangeConfig);
        test.is(new_proposal.kind.ChangeConfig.config.name, 'sputnikdao');
        //same config as we did not execute that proposal
        test.deepEqual(await dao.view('get_config'), {
            name: 'sputnik',
            purpose: 'testing',
            metadata: '',
        });
    },
);

workspace.test(
    'Bob can not add proposals',
    async (test, { alice, root, dao }) => {
        const bob = await root.createAccount('bob');

        //First we change a policy so that Bob can't add proposals
        const period = new BN('1000000000')
            .muln(60)
            .muln(60)
            .muln(24)
            .muln(7)
            .toString();
        const newPolicy = {
            roles: [
                {
                    name: 'all',
                    kind: {
                        Group: [root.accountId, alice.accountId],
                    },
                    permissions: ['*:VoteApprove', '*:AddProposal'],
                    vote_policy: {},
                },
            ],
            default_vote_policy: {
                weight_kind: 'TokenWeight',
                quorum: new BN('1').toString(),
                threshold: '5',
            },
            proposal_bond: toYocto('1'),
            proposal_period: period,
            bounty_bond: toYocto('1'),
            bounty_forgiveness_period: period,
        };
        let id: number = await bob.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description:
                        'change to a new policy, so that bob can not add a proposal',
                    kind: {
                        ChangePolicy: {
                            policy: newPolicy,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );
        await voteApprove(root, dao, id);

        //Chrck that only those with a permission can add the proposal
        let errorString = await captureError(
            async () =>
                await bob.call(
                    dao,
                    'add_proposal',
                    {
                        proposal: {
                            description: 'change to a new policy',
                            kind: {
                                ChangePolicy: {
                                    policy: newPolicy,
                                },
                            },
                        },
                    },
                    { attachedDeposit: toYocto('1') },
                ),
        );
        test.regex(errorString, /ERR_PERMISSION_DENIED/);
    },
);

workspace.test('Proposal ChangePolicy', async (test, { alice, root, dao }) => {
    test.deepEqual(
        await dao.view('get_proposals', { from_index: 0, limit: 10 }),
        [],
    );

    //Check that we can't change policy to a policy unless it's VersionedPolicy::Current
    let policy = [root.accountId];
    let errorString = await captureError(
        async () =>
            await alice.call(
                dao,
                'add_proposal',
                {
                    proposal: {
                        description: 'change the policy',
                        kind: {
                            ChangePolicy: {
                                policy,
                            },
                        },
                    },
                },
                { attachedDeposit: toYocto('1') },
            ),
    );
    test.regex(errorString, /ERR_INVALID_POLICY/);

    //Check that we can change to a correct policy
    const period = new BN('1000000000')
        .muln(60)
        .muln(60)
        .muln(24)
        .muln(7)
        .toString();
    const correctPolicy = {
        roles: [
            {
                name: 'all',
                kind: {
                    Group: [root.accountId, alice.accountId],
                },
                permissions: ['*:VoteApprove', '*:AddProposal'],
                vote_policy: {},
            },
        ],
        default_vote_policy: {
            weight_kind: 'TokenWeight',
            quorum: new BN('1').toString(),
            threshold: '5',
        },
        proposal_bond: toYocto('1'),
        proposal_period: period,
        bounty_bond: toYocto('1'),
        bounty_forgiveness_period: period,
    };
    let id: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'change to a new correct policy',
                kind: {
                    ChangePolicy: {
                        policy: correctPolicy,
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );

    //Number of proposals = 1
    test.is(await dao.view('get_last_proposal_id'), 1);
    //Check that the proposal is added to the list of proposals
    let proposals = await dao.view('get_proposals', {
        from_index: 0,
        limit: 10,
    });
    let realProposal = {
        id: 0,
        proposer: alice.accountId,
        description: 'change to a new correct policy',
        kind: { ChangePolicy: { policy: correctPolicy } },
        status: 'InProgress',
        vote_counts: {},
        votes: {},
    };
    test.is(proposals[0].id, realProposal.id);
    test.is(proposals[0].proposer, realProposal.proposer);
    test.is(proposals[0].description, realProposal.description);
    test.is(proposals[0].status, realProposal.status);
    test.deepEqual(proposals[0].vote_counts, realProposal.vote_counts);
    test.deepEqual(proposals[0].votes, realProposal.votes);
    test.deepEqual(proposals[0].kind, realProposal.kind);

    //After voting on the proposal it is Approved
    await voteApprove(root, dao, id);

    test.deepEqual(
        (await dao.view('get_proposals', { from_index: 0, limit: 10 }))[0]
            .vote_counts,
        { council: [1, 0, 0] },
    );
    test.is(
        (await dao.view('get_proposals', { from_index: 0, limit: 10 }))[0]
            .status,
        'Approved',
    );

    //Check that the policy is changed
    test.deepEqual(await dao.view('get_policy'), correctPolicy);
});

workspace.test('Proposal Transfer', async (test, { alice, root, dao }) => {
    let errorString = await captureError(
        async () =>
            await root.call(
                dao,
                'add_proposal',
                {
                    proposal: {
                        description:
                            'can not use transfer without wrong token_id and msg',
                        kind: {
                            Transfer: {
                                token_id: '',
                                receiver_id: alice.accountId,
                                amount: toYocto('1'),
                                msg: 'some msg',
                            },
                        },
                    },
                },
                {
                    attachedDeposit: toYocto('1'),
                },
            ),
    );
    test.regex(errorString, /ERR_BASE_TOKEN_NO_MSG/);

    const transferId: number = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'transfer 1 yocto',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: alice,
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    const initBalance: NEAR = (await alice.balance()).total;
    await voteApprove(root, dao, transferId);
    const balance: NEAR = (await alice.balance()).total;
    test.deepEqual(balance, initBalance.add(ONE_NEAR));
});

workspace.test(
    'Proposal SetStakingContract',
    async (test, { alice, root, dao }) => {
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);
        await setStakingId(root, dao, staking);

        test.is(await dao.view('get_staking_contract'), staking.accountId);

        let errorString = await captureError(
            async () => await setStakingId(root, dao, staking),
        );
        test.regex(errorString, /ERR_STAKING_CONTRACT_CANT_CHANGE/);
    },
);

workspace.test(
    'Voting is only allowed for councils',
    async (test, { alice, root, dao }) => {
        const config = {
            name: 'sputnikdao',
            purpose: 'testing',
            metadata: '',
        };
        //add_proposal returns new proposal id
        const id: number = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        //Check that voting is not allowed for non councils
        //Here alice tries to vote for her proposal but she is not a council and has no permission to vote.
        const err = await captureError(
            async () => await voteApprove(alice, dao, id),
        );
        test.log(err);
        test.true(err.includes('ERR_PERMISSION_DENIED'));

        let proposal: any = await dao.view('get_proposal', { id });
        test.log(proposal);
        test.is(proposal.status, 'InProgress');

        //Check that voting is allowed for councils
        //council (root) votes on alice's promise
        const res = await voteApprove(root, dao, id);
        proposal = await dao.view('get_proposal', { id });
        test.log(res);
        test.log(proposal);
        test.is(proposal.status, 'Approved');

        // proposal approved so now the config is equal to what alice did propose
        test.deepEqual(await dao.view('get_config'), config);
    },
);

// If the number of votes in the group has changed (new members has been added)
//  the proposal can lose it's approved state.
//  In this case new proposal needs to be made, this one should expire
workspace.test(
    'Proposal group changed during voting',
    async (test, { alice, root, dao }) => {
        const transferId: number = await root.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'give me tokens',
                    kind: {
                        Transfer: {
                            token_id: '',
                            receiver_id: alice,
                            amount: toYocto('1'),
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        const addMemberToRoleId: number = await root.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'add alice',
                    kind: {
                        AddMemberToRole: {
                            member_id: alice,
                            role: 'council',
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );
        await voteApprove(root, dao, addMemberToRoleId);
        await voteApprove(root, dao, transferId);
        const { status } = await dao.view('get_proposal', { id: transferId });
        test.is(status, 'InProgress');
    },
);

workspaceWithoutInit.test(
    'Proposal action types',
    async (test, { alice, root, dao }) => {
        const user1 = await root.createAccount('user1');
        const user2 = await root.createAccount('user2');
        const user3 = await root.createAccount('user3');
        const period = new BN('1000000000')
            .muln(60)
            .muln(60)
            .muln(24)
            .muln(7)
            .toString();
        const policy = {
            roles: [
                {
                    name: 'council',
                    kind: {
                        Group: [
                            alice.accountId,
                            user1.accountId,
                            user2.accountId,
                            user3.accountId,
                        ],
                    },
                    permissions: ['*:*'],
                    vote_policy: {},
                },
            ],
            default_vote_policy: {
                weight_kind: 'RoleWeight',
                quorum: new BN('0').toString(),
                threshold: [1, 2],
            },
            proposal_bond: toYocto('1'),
            proposal_period: period,
            bounty_bond: toYocto('1'),
            bounty_forgiveness_period: period,
        };

        let config = { name: 'sputnik', purpose: 'testing', metadata: '' };

        await root.call(dao, 'new', { config, policy });

        let proposalId = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        // Remove proposal works
        await alice.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'RemoveProposal',
        });
        let err = await captureError(async () =>
            dao.view('get_proposal', { id: proposalId }),
        );
        test.regex(err, /ERR_NO_PROPOSAL/);

        err = await captureError(async () =>
            alice.call(dao, 'act_proposal', {
                id: proposalId,
                action: 'VoteApprove',
            }),
        );
        test.regex(err, /ERR_NO_PROPOSAL/);

        proposalId = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        err = await captureError(async () =>
            alice.call(dao, 'act_proposal', {
                id: proposalId,
                action: 'AddProposal',
            }),
        );
        test.regex(err, /ERR_WRONG_ACTION/);

        // Check if every vote counts
        await user1.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteApprove',
        });
        await user2.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteReject',
        });
        await alice.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteRemove',
        });
        {
            const { vote_counts, votes } = await dao.view('get_proposal', {
                id: proposalId,
            });
            test.deepEqual(vote_counts.council, [1, 1, 1]);
            test.deepEqual(votes, {
                [alice.accountId]: 'Remove',
                [user1.accountId]: 'Approve',
                [user2.accountId]: 'Reject',
            });
        }

        // Finalize proposal will panic if not exired or failed
        err = await captureError(async () =>
            alice.call(dao, 'act_proposal', {
                id: proposalId,
                action: 'Finalize',
            }),
        );
        test.regex(err, /ERR_PROPOSAL_NOT_EXPIRED_OR_FAILED/);
    },
);

workspace.test('Proposal transfer ft', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    await dao.call(
        testToken,
        'mint',
        {
            account_id: dao,
            amount: '1000000000',
        },
        {
            gas: tGas(50),
        },
    );
    await alice.call(
        testToken,
        'storage_deposit',
        {
            account_id: alice.accountId,
            registration_only: true,
        },
        {
            attachedDeposit: toYocto('90'),
        },
    );
    const transferId: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'transfer tokens to me',
                kind: {
                    Transfer: {
                        token_id: testToken.accountId,
                        receiver_id: alice.accountId,
                        amount: '10',
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    await voteApprove(root, dao, transferId);
    const { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Approved');
});

workspace.test('Callback transfer', async (test, { alice, root, dao }) => {
    const user1 = await root.createAccount('user1');
    // Fail transfer by transfering to non-existent accountId
    let transferId: number = await user1.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: 'broken_id',
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    let user1Balance = (await user1.balance()).total;
    await voteApprove(root, dao, transferId);
    let { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Failed');
    test.assert((await user1.balance()).total.eq(user1Balance)); // no bond returns on fail

    // now we transfer to real accountId
    transferId = await user1.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: alice.accountId, // valid id this time
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    user1Balance = (await user1.balance()).total;
    await voteApprove(root, dao, transferId);
    ({ status } = await dao.view('get_proposal', { id: transferId }));
    test.is(status, 'Approved');
    test.assert((await user1.balance()).total.gt(user1Balance)); // returns bond
});

workspace.test('Callback function call', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    let transferId: number = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    FunctionCall: {
                        receiver_id: testToken.accountId,
                        actions: [
                            {
                                method_name: 'fail',
                                args: Buffer.from('bad args').toString(
                                    'base64',
                                ),
                                deposit: toYocto('1'),
                                gas: tGas(10),
                            },
                        ],
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    await root.call(
        dao,
        'act_proposal',
        {
            id: transferId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(200),
        },
    );
    let { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Failed');

    transferId = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    FunctionCall: {
                        receiver_id: testToken.accountId,
                        actions: [
                            {
                                method_name: 'mint',
                                args: Buffer.from(
                                    '{"account_id": "' +
                                        alice.accountId +
                                        '", "amount": "10"}',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(10),
                            },
                            {
                                method_name: 'burn',
                                args: Buffer.from(
                                    '{"account_id": "' +
                                        alice.accountId +
                                        '", "amount": "10"}',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(10),
                            },
                        ],
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    await root.call(
        dao,
        'act_proposal',
        {
            id: transferId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(200),
        },
    );
    ({ status } = await dao.view('get_proposal', { id: transferId }));
    test.is(status, 'Approved');
});

'''
'''--- sputnikdao2/tests-ava/__tests__/upgrade.ava.ts ---
import { toYocto, tGas } from 'near-workspaces-ava';

import { workspaceWithFactory } from './utils';

// DAO v2 Upgrade flow:
// 1. add proposal for store_contract_self(get it approved)
// 2. add proposal for UpgradeSelf with hash of blob from #1(get it approved)
// 3. add proposal for remove_contract_self(get it approved)
// 4. Confirm DAO contract code_hash and returned balance

workspaceWithFactory.test('basic', async (test, { root, factory }) => {
    test.true(await root.exists());
    test.true(await factory.exists());
});

workspaceWithFactory.test(
    'Store DAO upgrade code in DAO via factory',
    async (test, { root, factory }) => {
        const config = {
            name: 'upgradedao',
            purpose: 'to test',
            metadata: '',
        };
        const policy = [root.accountId];
        const params = {
            config,
            policy,
        };

        await root.call(
            factory,
            'create',
            {
                name: 'upgradedao',
                args: Buffer.from(JSON.stringify(params)).toString('base64'),
            },
            {
                attachedDeposit: toYocto('20'),
                gas: tGas(300),
            },
        );

        test.deepEqual(await factory.view('get_dao_list', {}), [
            'upgradedao.factory.test.near',
        ]);

        // 1. add proposal for store_contract_self(get it approved)
        // --------------------------------------------------------------------
        const six_near = toYocto('6');
        const default_code_hash = await factory.view('get_default_code_hash');

        let proposalId: number = await root.call(
            'upgradedao.factory.test.near',
            'get_last_proposal_id',
            {},
            { gas: tGas(300) },
        );
        test.is(proposalId, 0);

        const args = Buffer.from(
            `{ "code_hash": "${default_code_hash}" }`,
            'binary',
        ).toString('base64');

        const proposal = {
            proposal: {
                description: 'Store DAO upgrade contract code blob',
                kind: {
                    FunctionCall: {
                        receiver_id: `${factory.accountId}`,
                        actions: [
                            {
                                method_name: 'store_contract_self',
                                args: args,
                                deposit: six_near,
                                gas: tGas(220),
                            },
                        ],
                    },
                },
            },
        };

        await root.call(
            'upgradedao.factory.test.near',
            'add_proposal',
            proposal,
            {
                attachedDeposit: toYocto('1'),
                gas: tGas(300),
            },
        );

        proposalId = await root.call(
            'upgradedao.factory.test.near',
            'get_last_proposal_id',
            {},
            { gas: tGas(300) },
        );
        test.is(proposalId, 1);

        let new_proposal: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 0 },
            { gas: tGas(300) },
        );

        test.log(new_proposal);
        test.is(
            new_proposal.description,
            'Store DAO upgrade contract code blob',
        );
        test.is(new_proposal.proposer, 'test.near');
        test.is(new_proposal.status, 'InProgress');
        test.truthy(new_proposal.kind.FunctionCall);
        test.is(
            new_proposal.kind.FunctionCall.receiver_id,
            `${factory.accountId}`,
        );

        await root.call(
            'upgradedao.factory.test.near',
            'act_proposal',
            { id: 0, action: 'VoteApprove' },
            { gas: tGas(300) },
        );

        let passed_proposal_0: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 0 },
            { gas: tGas(300) },
        );
        test.log(passed_proposal_0);
        test.is(passed_proposal_0.status, 'Approved');

        // 2. add proposal for UpgradeSelf with hash of blob from #1(get it approved)
        // --------------------------------------------------------------------
        const proposalUpgradeSelf = {
            proposal: {
                description: 'Upgrade DAO contract using local code blob',
                kind: {
                    UpgradeSelf: {
                        hash: `${default_code_hash}`,
                    },
                },
            },
        };
        await root.call(
            'upgradedao.factory.test.near',
            'add_proposal',
            proposalUpgradeSelf,
            {
                attachedDeposit: toYocto('1'),
                gas: tGas(300),
            },
        );

        let new_proposal_1: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 1 },
            { gas: tGas(300) },
        );

        test.log(new_proposal_1);
        test.is(
            new_proposal_1.description,
            'Upgrade DAO contract using local code blob',
        );
        test.is(new_proposal_1.proposer, 'test.near');
        test.is(new_proposal_1.status, 'InProgress');
        test.truthy(new_proposal_1.kind.UpgradeSelf);

        await root.call(
            'upgradedao.factory.test.near',
            'act_proposal',
            { id: 1, action: 'VoteApprove' },
            { gas: tGas(300) },
        );

        let passed_proposal_1: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 1 },
            { gas: tGas(300) },
        );

        test.log(passed_proposal_1);
        test.is(passed_proposal_1.status, 'Approved');

        // 3. add proposal for remove_contract_self(get it approved)
        // --------------------------------------------------------------------
        const proposalRemoveContractBlob = {
            proposal: {
                description:
                    'Remove DAO upgrade contract local code blob via factory',
                kind: {
                    FunctionCall: {
                        receiver_id: `${factory.accountId}`,
                        actions: [
                            {
                                method_name: 'remove_contract_self',
                                args: Buffer.from(
                                    `{ "code_hash": "${default_code_hash}" }`,
                                    'binary',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(220),
                            },
                        ],
                    },
                },
            },
        };
        // console.log(
        //     'proposalRemoveContractBlob',
        //     JSON.stringify(proposalRemoveContractBlob)
        // );

        await root.call(
            'upgradedao.factory.test.near',
            'add_proposal',
            proposalRemoveContractBlob,
            {
                attachedDeposit: toYocto('1'),
                gas: tGas(300),
            },
        );

        let new_proposal_2: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 2 },
            { gas: tGas(300) },
        );

        test.log(new_proposal_2);
        test.is(
            new_proposal_2.description,
            'Remove DAO upgrade contract local code blob via factory',
        );
        test.is(new_proposal_2.proposer, 'test.near');
        test.is(new_proposal_2.status, 'InProgress');
        test.truthy(new_proposal_2.kind.FunctionCall);
        test.is(
            new_proposal_2.kind.FunctionCall.receiver_id,
            `${factory.accountId}`,
        );

        await root.call(
            'upgradedao.factory.test.near',
            'act_proposal',
            { id: 2, action: 'VoteApprove' },
            { gas: tGas(300) },
        );

        let passed_proposal_2: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 2 },
            { gas: tGas(300) },
        );

        test.log(passed_proposal_2);
        test.is(passed_proposal_2.status, 'Approved');

        // 4. Confirm DAO contract code_hash and returned balance
        // --------------------------------------------------------------------
        // TODO: Check if balance increased by 6 NEAR for refund
    },
);

'''
'''--- sputnikdao2/tests-ava/__tests__/utils.ts ---
import { Workspace, NearAccount, BN, toYocto, tGas } from 'near-workspaces-ava';

async function initWorkspace(root: NearAccount) {
    const alice = await root.createAccount('alice');
    // console.log('alice\'s balance is: ' + (await alice.balance()).total) //100N

    const config = { name: 'sputnik', purpose: 'testing', metadata: '' };
    const policy = [root.accountId];

    //for short let's call it just dao
    const dao = await root.createAndDeploy('dao', '../res/sputnikdao2.wasm', {
        method: 'new',
        args: { config, policy },
        initialBalance: toYocto('200'),
    });

    // console.log('dao\'s balance is: ' + (await dao.balance()).total) //~200N

    return { alice, dao };
}

export const STORAGE_PER_BYTE = new BN('10000000000000000000');

export const workspace = Workspace.init(async ({ root }) => {
    return initWorkspace(root);
});

export const workspaceWithoutInit = Workspace.init(async ({ root }) => {
    const alice = await root.createAccount('alice');

    //for short let's call it just dao
    const dao = await root.createAndDeploy('dao', '../res/sputnikdao2.wasm', {
        initialBalance: toYocto('200'),
    });
    return { alice, dao };
});

export const workspaceWithFactory = Workspace.init(async ({ root }) => {
    const factory = await root.createAndDeploy(
        'factory',
        '../../sputnikdao-factory2/res/sputnikdao_factory2.wasm',
        {
            initialBalance: toYocto('500'),
        },
    );
    await factory.call(factory.accountId, 'new', {}, { gas: tGas(300) });
    return { factory };
});

export async function initTestToken(root: NearAccount) {
    const testToken = await root.createAndDeploy(
        'test-token',
        '../../test-token/res/test_token.wasm',
        {
            method: 'new',
            initialBalance: toYocto('200'),
        },
    );
    return testToken;
}

export async function initStaking(
    root: NearAccount,
    dao: NearAccount,
    testToken: NearAccount,
) {
    const staking = await root.createAndDeploy(
        'staking',
        '../../sputnik-staking/res/sputnik_staking.wasm',
        {
            method: 'new',
            args: {
                owner_id: dao,
                token_id: testToken,
                unstake_period: '100000000000',
            },
            initialBalance: toYocto('100'),
        },
    );
    return staking;
}

export async function setStakingId(
    root: NearAccount,
    dao: NearAccount,
    staking: NearAccount,
) {
    // Setting staking id
    const proposalId = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'test',
                kind: { SetStakingContract: { staking_id: staking.accountId } },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    await root.call(dao, 'act_proposal', {
        id: proposalId,
        action: 'VoteApprove',
    });
}

export const regCost = STORAGE_PER_BYTE.mul(new BN(16));

export async function registerAndDelegate(
    dao: NearAccount,
    staking: NearAccount,
    account: NearAccount,
    amount: BN,
) {
    await staking.call(
        dao,
        'register_delegation',
        { account_id: account },
        { attachedDeposit: regCost },
    );
    const res: string[3] = await staking.call(dao, 'delegate', {
        account_id: account,
        amount: amount.toString(),
    });
    return res;
}

export const DEADLINE = '1925376849430593581';
export const BOND = toYocto('1');

export async function proposeBounty(
    alice: NearAccount,
    dao: NearAccount,
    token: NearAccount,
) {
    const bounty = {
        description: 'test_bounties',
        token: token.accountId,
        amount: '19000000000000000000000000',
        times: 3,
        max_deadline: DEADLINE,
    };
    const proposalId: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'add_new_bounty',
                kind: {
                    AddBounty: {
                        bounty,
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    return proposalId;
}

export async function proposeBountyWithNear(
    alice: NearAccount,
    dao: NearAccount,
) {
    const bounty = {
        description: 'test_bounties_with_near_token',
        token: '',
        amount: '19000000000000000000000000',
        times: 3,
        max_deadline: DEADLINE,
    };
    const proposalId: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'add_new_bounty',
                kind: {
                    AddBounty: {
                        bounty,
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    return proposalId;
}

export async function voteOnBounty(
    root: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    await root.call(
        dao,
        'act_proposal',
        {
            id: proposalId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(50),
        },
    );
}

export async function claimBounty(
    alice: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    await alice.call(
        dao,
        'bounty_claim',
        {
            id: proposalId,
            deadline: DEADLINE,
        },
        {
            attachedDeposit: BOND,
        },
    );
}

export async function doneBounty(
    alice: NearAccount,
    bob: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    await alice.call(
        dao,
        'bounty_done',
        {
            id: proposalId,
            account_id: bob,
            description: 'This bounty is done',
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
}

export async function giveupBounty(
    alice: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    return await alice.call(dao, 'bounty_giveup', { id: proposalId });
}

export async function giveupBountyRaw(
    alice: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    return await alice.call_raw(dao, 'bounty_giveup', { id: proposalId });
}

export async function voteApprove(
    root: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    await root.call(
        dao,
        'act_proposal',
        {
            id: proposalId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(100),
        },
    );
}

'''
'''--- sputnikdao2/tests-ava/__tests__/views.ava.ts ---
import {
    Workspace,
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
    ONE_NEAR,
} from 'near-workspaces-ava';
import {
    workspace,
    initStaking,
    initTestToken,
    setStakingId,
    registerAndDelegate,
    STORAGE_PER_BYTE,
} from './utils';
import {
    DEADLINE,
    BOND,
    proposeBounty,
    voteOnBounty,
    claimBounty,
} from './utils';
import * as fs from 'fs';

workspace.test('View method version', async (test, { alice, root, dao }) => {
    test.log('Version:');
    test.log(await dao.view('version'));
    test.is(await dao.view('version'), '2.0.0');
});

workspace.test('View method get_config', async (test, { root }) => {
    const config = {
        name: 'sputnikda2',
        purpose: 'testing get_config',
        metadata: '',
    };
    const policy = [root.accountId];

    const bob = await root.createAndDeploy('bob', '../res/sputnikdao2.wasm', {
        method: 'new',
        args: { config, policy },
        initialBalance: toYocto('200'),
    });
    test.deepEqual(await bob.view('get_config'), config);
});

workspace.test('View method get_policy', async (test, { root }) => {
    const config = {
        name: 'sputnikda2',
        purpose: 'testing get_policy',
        metadata: '',
    };
    const versionedPolicy = [root.accountId];

    const bob = await root.createAndDeploy('bob', '../res/sputnikdao2.wasm', {
        method: 'new',
        args: { config, policy: versionedPolicy },
        initialBalance: toYocto('200'),
    });
    const policy = {
        roles: [
            {
                name: 'all',
                kind: 'Everyone',
                permissions: ['*:AddProposal'],
                vote_policy: {},
            },
            {
                name: 'council',
                kind: {
                    Group: [root.accountId],
                },
                permissions: [
                    '*:Finalize',
                    '*:AddProposal',
                    '*:VoteApprove',
                    '*:VoteReject',
                    '*:VoteRemove',
                ],
                vote_policy: {},
            },
        ],
        default_vote_policy: {
            weight_kind: 'RoleWeight',
            quorum: '0',
            threshold: [1, 2],
        },
        proposal_bond: '1000000000000000000000000',
        proposal_period: '604800000000000',
        bounty_bond: '1000000000000000000000000',
        bounty_forgiveness_period: '86400000000000',
    };
    test.deepEqual(await bob.view('get_policy'), policy);
});

workspace.test(
    'View method get_staking_contract',
    async (test, { alice, root, dao }) => {
        test.is(await dao.view('get_staking_contract'), '');

        //To set the staking_id
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);
        await setStakingId(root, dao, staking);

        test.is(await dao.view('get_staking_contract'), staking.accountId);
    },
);

workspace.test('View has_blob', async (test, { alice, root, dao }) => {
    const DAO_WASM_BYTES: Uint8Array = fs.readFileSync(
        '../res/sputnikdao2.wasm',
    );
    const hash: String = await root.call(dao, 'store_blob', DAO_WASM_BYTES, {
        attachedDeposit: toYocto('200'),
        gas: tGas(300),
    });

    test.true(await dao.view('has_blob', { hash: hash }));
    await root.call(dao, 'remove_blob', {
        hash: hash,
    });
    test.false(await dao.view('has_blob', { hash: hash }));
});

workspace.test(
    'View get_locked_storage_amount',
    async (test, { alice, root, dao }) => {
        const beforeProposal = new BN(
            await dao.view('get_locked_storage_amount'),
        );
        test.log('Locked amount: ' + beforeProposal);
        await root.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'adding some bytes',
                    kind: 'Vote',
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        const afterProposal = new BN(
            await dao.view('get_locked_storage_amount'),
        );
        test.assert(beforeProposal.lt(afterProposal));
    },
);

workspace.test(
    'View get_available_amount',
    async (test, { alice, root, dao }) => {
        const beforeProposal = new BN(await dao.view('get_available_amount'));
        test.log('Available amount: ' + beforeProposal);
        await root.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'adding some bytes',
                    kind: 'Vote',
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        const afterProposal = new BN(await dao.view('get_available_amount'));
        test.assert(beforeProposal.gt(afterProposal));
    },
);

workspace.test(
    'View methods for delegation',
    async (test, { alice, root, dao }) => {
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);
        const randomAmount = new BN('10087687667869');
        const bob = await root.createAccount('bob');

        await setStakingId(root, dao, staking);

        let result = await registerAndDelegate(
            dao,
            staking,
            alice,
            randomAmount,
        );
        result = await registerAndDelegate(
            dao,
            staking,
            bob,
            randomAmount.muln(2),
        );

        //Test delegation_balance_of
        test.deepEqual(
            new BN(
                await dao.view('delegation_balance_of', { account_id: alice }),
            ),
            randomAmount,
        );
        test.deepEqual(
            new BN(
                await dao.view('delegation_balance_of', { account_id: bob }),
            ),
            randomAmount.muln(2),
        );

        //Test delegation_total_supply
        test.deepEqual(
            new BN(await dao.view('delegation_total_supply')),
            randomAmount.muln(3),
        );

        //Test delegation_balance_ratio
        test.deepEqual(
            await dao.view('delegation_balance_ratio', { account_id: alice }),
            [
                await dao.view('delegation_balance_of', { account_id: alice }),
                await dao.view('delegation_total_supply'),
            ],
        );
    },
);

workspace.test(
    'View methods for proposals',
    async (test, { alice, root, dao }) => {
        //Test get_last_proposal_id
        test.is(await dao.view('get_last_proposal_id'), 0);

        //Test get_proposals
        test.deepEqual(
            await dao.view('get_proposals', { from_index: 0, limit: 100 }),
            [],
        );

        const config = {
            name: 'sputnikdao2',
            purpose: 'testing_view_methods',
            metadata: '',
        };
        await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        const realProposalAlice = {
            id: 0,
            proposer: alice.accountId,
            description: 'rename the dao',
            kind: { ChangeConfig: { config } },
            status: 'InProgress',
            vote_counts: {},
            votes: {},
        };

        const proposalAlice: any = await dao.view('get_proposal', { id: 0 });

        //Test get_proposal
        test.is(proposalAlice.proposer, realProposalAlice.proposer);
        test.is(proposalAlice.description, realProposalAlice.description);
        test.is(proposalAlice.status, realProposalAlice.status);
        test.deepEqual(
            proposalAlice.vote_counts,
            realProposalAlice.vote_counts,
        );
        test.deepEqual(proposalAlice.votes, realProposalAlice.votes);
        test.deepEqual(proposalAlice.kind, realProposalAlice.kind);

        //Test get_last_proposal_id
        test.deepEqual(await dao.view('get_last_proposal_id'), 1);

        //Test get_proposals
        const proposals: any = await dao.view('get_proposals', {
            from_index: 0,
            limit: 100,
        });
        test.is(proposals[0].proposer, realProposalAlice.proposer);
        test.is(proposals[0].description, realProposalAlice.description);
        test.is(proposals[0].status, realProposalAlice.status);
        test.deepEqual(proposals[0].vote_counts, realProposalAlice.vote_counts);
        test.deepEqual(proposals[0].votes, realProposalAlice.votes);
        test.deepEqual(proposals[0].kind, realProposalAlice.kind);

        //Should panic if the proposal with the given id doesn't exist
        const errorString = await captureError(
            async () => await dao.view('get_proposal', { id: 10 }),
        );
        test.regex(errorString, /ERR_NO_PROPOSAL/);
    },
);

workspace.test(
    'View methods for bounties',
    async (test, { alice, root, dao }) => {
        //Test get_last_bounty_id
        test.is(await dao.view('get_last_bounty_id'), 0);
        //Test get_bounties
        test.deepEqual(
            await dao.view('get_bounties', { from_index: 0, limit: 100 }),
            [],
        );

        const testToken = await initTestToken(root);
        const proposalId = await proposeBounty(alice, dao, testToken);
        const bounty = {
            id: 0,
            description: 'test_bounties',
            token: testToken.accountId,
            amount: '19000000000000000000000000',
            times: 3,
            max_deadline: DEADLINE,
        };
        await voteOnBounty(root, dao, proposalId);

        //Test get_last_bounty_id
        test.is(await dao.view('get_last_bounty_id'), 1);
        //Test get_bounties
        test.deepEqual(
            await dao.view('get_bounties', { from_index: 0, limit: 100 }),
            [bounty],
        );
        //Test get_bounty
        test.deepEqual(await dao.view('get_bounty', { id: 0 }), bounty);

        await claimBounty(alice, dao, proposalId);

        //Test get_bounty_number_of_claims
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        //Test get_bounty_claims
        const realClaim = {
            bounty_id: 0,
            deadline: DEADLINE,
            completed: false,
        };
        const claims: any = await dao.view('get_bounty_claims', {
            account_id: alice.accountId,
        });
        test.is(claims[0].bounty_id, realClaim.bounty_id);
        test.is(claims[0].deadline, realClaim.deadline);
        test.is(claims[0].completed, realClaim.completed);

        //Should panic if the bounty with the given id doesn't exist
        const errorString = await captureError(
            async () => await dao.view('get_bounty', { id: 10 }),
        );
        test.regex(errorString, /ERR_NO_BOUNTY/);
    },
);

'''
'''--- sputnikdao2/tests-ava/package.json ---
{
  "private": true,
  "scripts": {
    "format": "prettier --write \"__tests__/*.{js,jsx,ts,tsx}\" --tab-width=4 --single-quote --trailing-comma all",
    "test": "near-workspaces-ava",
    "test:testnet": "near-workspaces-ava --config ./ava.testnet.config.cjs"
  },
  "devDependencies": {
    "near-workspaces-ava": "^1.1.0",
    "prettier": "^2.5.1"
  }
}

'''
'''--- sputnikdao2/tests-ava/tsconfig.json ---
{
  "extends": "near-workspaces-ava/tsconfig.ava.json"
}
'''
'''--- sputnikdao2/tests/test_general.rs ---
use std::collections::HashMap;

use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::{env, AccountId};
use near_sdk_sim::{call, init_simulator, to_yocto, view};

use crate::utils::*;
use sputnik_staking::User;
use sputnikdao2::{
    default_policy, Action, BountyClaim, BountyOutput, Config, Policy, Proposal, ProposalInput,
    ProposalKind, ProposalOutput, ProposalStatus, RoleKind, RolePermission, VersionedPolicy,
    VotePolicy,
};

mod utils;

fn user(id: u32) -> AccountId {
    format!("user{}", id).parse().unwrap()
}

#[test]
fn test_large_policy() {
    let root = init_simulator(None);
    let factory = setup_factory(&root);
    factory
        .user_account
        .call(
            factory.user_account.account_id.clone(),
            "new",
            &[],
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .assert_success();

    let config = Config {
        name: "testdao".to_string(),
        purpose: "to test".to_string(),
        metadata: Base64VecU8(vec![]),
    };
    let mut policy = default_policy(vec![root.account_id()]);
    const NO_OF_COUNCILS: u32 = 10;
    const USERS_PER_COUNCIL: u32 = 100;
    for council_no in 0..NO_OF_COUNCILS {
        let mut council = vec![];
        let user_id_start = council_no * USERS_PER_COUNCIL;
        let user_id_end = user_id_start + USERS_PER_COUNCIL;
        for user_id in user_id_start..user_id_end {
            council.push(user(user_id));
        }

        let role = RolePermission {
            name: format!("council{}", council_no),
            kind: RoleKind::Group(council.into_iter().collect()),
            permissions: vec![
                "*:AddProposal".to_string(),
                "*:VoteApprove".to_string(),
                "*:VoteReject".to_string(),
                "*:VoteRemove".to_string(),
                "*:Finalize".to_string(),
            ]
            .into_iter()
            .collect(),
            vote_policy: HashMap::default(),
        };
        policy.add_or_update_role(&role);
    }

    let params = json!({ "config": config, "policy": policy })
        .to_string()
        .into_bytes();

    call!(
        root,
        factory.create(
            AccountId::new_unchecked("testdao".to_string()),
            Base64VecU8(params)
        ),
        deposit = to_yocto("10")
    )
    .assert_success();

    let dao_account_id = AccountId::new_unchecked("testdao.factory".to_string());
    let dao_list = factory
        .user_account
        .view(factory.user_account.account_id.clone(), "get_dao_list", &[])
        .unwrap_json::<Vec<AccountId>>();
    assert_eq!(dao_list, vec![dao_account_id.clone()]);
}

#[test]
fn test_multi_council() {
    let (root, dao) = setup_dao();
    let user1 = root.create_user(user(1), to_yocto("1000"));
    let user2 = root.create_user(user(2), to_yocto("1000"));
    let user3 = root.create_user(user(3), to_yocto("1000"));
    let new_policy = Policy {
        roles: vec![
            RolePermission {
                name: "all".to_string(),
                kind: RoleKind::Everyone,
                permissions: vec!["*:AddProposal".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "council".to_string(),
                kind: RoleKind::Group(vec![user(1), user(2)].into_iter().collect()),
                permissions: vec!["*:*".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "community".to_string(),
                kind: RoleKind::Group(vec![user(1), user(3), user(4)].into_iter().collect()),
                permissions: vec!["*:*".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
        ],
        default_vote_policy: VotePolicy::default(),
        proposal_bond: U128(10u128.pow(24)),
        proposal_period: U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
        bounty_bond: U128(10u128.pow(24)),
        bounty_forgiveness_period: U64::from(1_000_000_000 * 60 * 60 * 24),
    };
    add_proposal(
        &root,
        &dao,
        ProposalInput {
            description: "new policy".to_string(),
            kind: ProposalKind::ChangePolicy {
                policy: VersionedPolicy::Current(new_policy.clone()),
            },
        },
    )
    .assert_success();
    vote(vec![&root], &dao, 0);
    assert_eq!(view!(dao.get_policy()).unwrap_json::<Policy>(), new_policy);
    add_transfer_proposal(&root, &dao, base_token(), user(1), 1_000_000, None).assert_success();
    vote(vec![&user2], &dao, 1);
    vote(vec![&user3], &dao, 1);
    let proposal = view!(dao.get_proposal(1)).unwrap_json::<Proposal>();
    // Votes from members in different councils.
    assert_eq!(proposal.status, ProposalStatus::InProgress);
    // Finish with vote that is in both councils, which approves the proposal.
    vote(vec![&user1], &dao, 1);
    let proposal = view!(dao.get_proposal(1)).unwrap_json::<Proposal>();
    assert_eq!(proposal.status, ProposalStatus::Approved);
}

#[test]
fn test_bounty_workflow() {
    let (root, dao) = setup_dao();
    let user1 = root.create_user(user(1), to_yocto("1000"));
    let user2 = root.create_user(user(2), to_yocto("1000"));

    let mut proposal_id = add_bounty_proposal(&root, &dao).unwrap_json::<u64>();
    assert_eq!(proposal_id, 0);
    call!(
        root,
        dao.act_proposal(proposal_id, Action::VoteApprove, None)
    )
    .assert_success();

    let bounty_id = view!(dao.get_last_bounty_id()).unwrap_json::<u64>() - 1;
    assert_eq!(bounty_id, 0);
    assert_eq!(
        view!(dao.get_bounty(bounty_id))
            .unwrap_json::<BountyOutput>()
            .bounty
            .times,
        3
    );

    assert_eq!(to_yocto("1000"), user1.account().unwrap().amount);
    call!(
        user1,
        dao.bounty_claim(bounty_id, U64::from(0)),
        deposit = to_yocto("1")
    )
    .assert_success();
    assert!(user1.account().unwrap().amount < to_yocto("999"));
    assert_eq!(
        view!(dao.get_bounty_claims(user1.account_id()))
            .unwrap_json::<Vec<BountyClaim>>()
            .len(),
        1
    );
    assert_eq!(
        view!(dao.get_bounty_number_of_claims(bounty_id)).unwrap_json::<u64>(),
        1
    );

    call!(user1, dao.bounty_giveup(bounty_id)).assert_success();
    assert!(user1.account().unwrap().amount > to_yocto("999"));
    assert_eq!(
        view!(dao.get_bounty_claims(user1.account_id()))
            .unwrap_json::<Vec<BountyClaim>>()
            .len(),
        0
    );
    assert_eq!(
        view!(dao.get_bounty_number_of_claims(bounty_id)).unwrap_json::<u64>(),
        0
    );

    assert_eq!(to_yocto("1000"), user2.account().unwrap().amount);
    call!(
        user2,
        dao.bounty_claim(bounty_id, U64(env::block_timestamp() + 5_000_000_000)),
        deposit = to_yocto("1")
    )
    .assert_success();
    assert!(user2.account().unwrap().amount < to_yocto("999"));
    assert_eq!(
        view!(dao.get_bounty_claims(user2.account_id()))
            .unwrap_json::<Vec<BountyClaim>>()
            .len(),
        1
    );
    assert_eq!(
        view!(dao.get_bounty_number_of_claims(bounty_id)).unwrap_json::<u64>(),
        1
    );

    call!(
        user2,
        dao.bounty_done(bounty_id, None, "Bounty is done".to_string()),
        deposit = to_yocto("1")
    )
    .assert_success();
    assert!(user2.account().unwrap().amount < to_yocto("998"));
    proposal_id = view!(dao.get_last_proposal_id()).unwrap_json::<u64>() - 1;
    assert_eq!(proposal_id, 1);
    assert_eq!(
        view!(dao.get_proposal(proposal_id))
            .unwrap_json::<ProposalOutput>()
            .proposal
            .kind
            .to_policy_label(),
        "bounty_done"
    );

    call!(
        root,
        dao.act_proposal(proposal_id, Action::VoteApprove, None)
    )
    .assert_success();
    assert!(user2.account().unwrap().amount > to_yocto("999"));
    assert_eq!(
        view!(dao.get_bounty_claims(user2.account_id()))
            .unwrap_json::<Vec<BountyClaim>>()
            .len(),
        0
    );
    assert_eq!(
        view!(dao.get_bounty_number_of_claims(bounty_id)).unwrap_json::<u64>(),
        0
    );
    assert_eq!(
        view!(dao.get_bounty(bounty_id))
            .unwrap_json::<BountyOutput>()
            .bounty
            .times,
        2
    );
}

#[test]
fn test_create_dao_and_use_token() {
    let (root, dao) = setup_dao();
    let user2 = root.create_user(user(2), to_yocto("1000"));
    let user3 = root.create_user(user(3), to_yocto("1000"));
    let test_token = setup_test_token(&root);
    let staking = setup_staking(&root);

    assert!(view!(dao.get_staking_contract())
        .unwrap_json::<String>()
        .is_empty());
    add_member_proposal(&root, &dao, user2.account_id.clone()).assert_success();
    assert_eq!(view!(dao.get_last_proposal_id()).unwrap_json::<u64>(), 1);
    // Voting by user who is not member should fail.
    should_fail(call!(user2, dao.act_proposal(0, Action::VoteApprove, None)));
    call!(root, dao.act_proposal(0, Action::VoteApprove, None)).assert_success();
    // voting second time should fail.
    should_fail(call!(root, dao.act_proposal(0, Action::VoteApprove, None)));
    // Add 3rd member.
    add_member_proposal(&user2, &dao, user3.account_id.clone()).assert_success();
    vote(vec![&root, &user2], &dao, 1);
    let policy = view!(dao.get_policy()).unwrap_json::<Policy>();
    assert_eq!(policy.roles.len(), 2);
    assert_eq!(
        policy.roles[1].kind,
        RoleKind::Group(
            vec![
                root.account_id.clone(),
                user2.account_id.clone(),
                user3.account_id.clone()
            ]
            .into_iter()
            .collect()
        )
    );
    add_proposal(
        &user2,
        &dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::SetStakingContract {
                staking_id: "staking".parse().unwrap(),
            },
        },
    )
    .assert_success();
    vote(vec![&user3, &user2], &dao, 2);
    assert!(!view!(dao.get_staking_contract())
        .unwrap_json::<String>()
        .is_empty());
    assert_eq!(
        view!(dao.get_proposal(2)).unwrap_json::<Proposal>().status,
        ProposalStatus::Approved
    );

    staking
        .user_account
        .view_method_call(staking.contract.ft_total_supply());
    assert_eq!(
        view!(staking.ft_total_supply()).unwrap_json::<U128>().0,
        to_yocto("0")
    );
    call!(
        user2,
        test_token.mint(user2.account_id.clone(), U128(to_yocto("100")))
    )
    .assert_success();
    call!(
        user2,
        test_token.storage_deposit(Some(staking.account_id()), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        user2,
        staking.storage_deposit(None, None),
        deposit = to_yocto("1")
    );
    call!(
        user2,
        test_token.ft_transfer_call(
            staking.account_id(),
            U128(to_yocto("10")),
            None,
            "".to_string()
        ),
        deposit = 1
    )
    .assert_success();
    assert_eq!(
        view!(staking.ft_total_supply()).unwrap_json::<U128>().0,
        to_yocto("10")
    );
    let user2_id = user2.account_id.clone();
    assert_eq!(
        view!(staking.ft_balance_of(user2_id.clone()))
            .unwrap_json::<U128>()
            .0,
        to_yocto("10")
    );
    assert_eq!(
        view!(test_token.ft_balance_of(user2_id.clone()))
            .unwrap_json::<U128>()
            .0,
        to_yocto("90")
    );
    call!(user2, staking.withdraw(U128(to_yocto("5")))).assert_success();
    assert_eq!(
        view!(staking.ft_total_supply()).unwrap_json::<U128>().0,
        to_yocto("5")
    );
    assert_eq!(
        view!(test_token.ft_balance_of(user2_id.clone()))
            .unwrap_json::<U128>()
            .0,
        to_yocto("95")
    );
    call!(
        user2,
        staking.delegate(user2_id.clone(), U128(to_yocto("5")))
    )
    .assert_success();
    call!(
        user2,
        staking.undelegate(user2_id.clone(), U128(to_yocto("1")))
    )
    .assert_success();
    // should fail right after undelegation as need to wait for voting period before can delegate again.
    should_fail(call!(
        user2,
        staking.delegate(user2_id.clone(), U128(to_yocto("1")))
    ));
    let user = view!(staking.get_user(user2_id.clone())).unwrap_json::<User>();
    assert_eq!(
        user.delegated_amounts,
        vec![(user2_id.clone(), U128(to_yocto("4")))]
    );
    assert_eq!(
        view!(dao.delegation_total_supply()).unwrap_json::<U128>().0,
        to_yocto("4")
    );
    assert_eq!(
        view!(dao.delegation_balance_of(user2_id.clone()))
            .unwrap_json::<U128>()
            .0,
        to_yocto("4")
    );
}

/// Test various cases that must fail.
#[test]
fn test_failures() {
    let (root, dao) = setup_dao();
    should_fail(add_transfer_proposal(
        &root,
        &dao,
        base_token(),
        user(1),
        1_000_000,
        Some("some".to_string()),
    ));
}

/// Test payments that fail
#[test]
fn test_payment_failures() {
    let (root, dao) = setup_dao();
    let user1 = root.create_user(user(1), to_yocto("1000"));
    let whale = root.create_user(user(2), to_yocto("1000"));

    // Add user1
    add_member_proposal(&root, &dao, user1.account_id.clone()).assert_success();
    vote(vec![&root], &dao, 0);

    // Set up fungible tokens and give 5 to the dao
    let test_token = setup_test_token(&root);
    call!(
        dao.user_account,
        test_token.mint(dao.user_account.account_id.clone(), U128(5))
    )
    .assert_success();
    call!(
        user1,
        test_token.storage_deposit(Some(user1.account_id.clone()), Some(true)),
        deposit = to_yocto("125")
    )
    .assert_success();

    // Attempt to transfer more than it has
    add_transfer_proposal(
        &root,
        &dao,
        Some(test_token.account_id()),
        user(1),
        10,
        None,
    )
    .assert_success();

    // Vote in the transfer
    vote(vec![&root, &user1], &dao, 1);
    let mut proposal = view!(dao.get_proposal(1)).unwrap_json::<Proposal>();
    assert_eq!(proposal.status, ProposalStatus::Failed);

    // Set up benefactor whale who will donate the needed tokens
    call!(
        whale,
        test_token.mint(whale.account_id.clone(), U128(6_000_000_000))
    )
    .assert_success();
    call!(
        whale,
        test_token.ft_transfer(
            dao.account_id(),
            U128::from(1000),
            Some("Heard you're in a pinch, let me help.".to_string())
        ),
        deposit = 1
    )
    .assert_success();

    // Council member retries payment via an action
    call!(
        root,
        dao.act_proposal(
            1,
            Action::Finalize,
            Some("Sorry! We topped up our tokens. Thanks.".to_string())
        )
    )
    .assert_success();

    proposal = view!(dao.get_proposal(1)).unwrap_json::<Proposal>();
    assert_eq!(
        proposal.status,
        ProposalStatus::Approved,
        "Did not return to approved status."
    );
}

'''
'''--- sputnikdao2/tests/test_upgrade.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base58CryptoHash;
use near_sdk::serde_json::json;
use near_sdk::AccountId;

use near_sdk_sim::{call, init_simulator, to_yocto, DEFAULT_GAS};
use sputnikdao2::{Action, Config, ProposalInput, ProposalKind, VersionedPolicy};

mod utils;
use crate::utils::*;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    DAO_WASM_BYTES => "res/sputnikdao2.wasm",
    OTHER_WASM_BYTES => "res/ref_exchange_release.wasm"
}

#[test]
fn test_upgrade_using_factory() {
    let root = init_simulator(None);
    let factory = setup_factory(&root);
    factory
        .user_account
        .call(
            factory.user_account.account_id.clone(),
            "new",
            &[],
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .assert_success();

    let config = Config {
        name: "testdao".to_string(),
        purpose: "to test".to_string(),
        metadata: Base64VecU8(vec![]),
    };
    let policy = VersionedPolicy::Default(vec![root.account_id()]);
    let params = json!({ "config": config, "policy": policy })
        .to_string()
        .into_bytes();

    call!(
        root,
        factory.create(
            AccountId::new_unchecked("testdao".to_string()),
            Base64VecU8(params)
        ),
        deposit = to_yocto("10")
    )
    .assert_success();

    let dao_account_id = AccountId::new_unchecked("testdao.factory".to_string());
    let dao_list = factory
        .user_account
        .view(factory.user_account.account_id.clone(), "get_dao_list", &[])
        .unwrap_json::<Vec<AccountId>>();
    assert_eq!(dao_list, vec![dao_account_id.clone()]);

    let hash = factory
        .user_account
        .view(
            factory.user_account.account_id.clone(),
            "get_default_code_hash",
            &[],
        )
        .unwrap_json::<Base58CryptoHash>();

    let proposal_id = root
        .call(
            dao_account_id.clone(),
            "add_proposal",
            &json!({ "proposal": ProposalInput {
                description: "proposal to test".to_string(),
                kind: ProposalKind::UpgradeSelf { hash }
            }})
            .to_string()
            .into_bytes(),
            near_sdk_sim::DEFAULT_GAS,
            to_yocto("1"),
        )
        .unwrap_json::<u64>();
    assert_eq!(0, proposal_id);

    root.call(
        dao_account_id.clone(),
        "act_proposal",
        &json!({ "id": 0, "action": Action::VoteApprove})
            .to_string()
            .into_bytes(),
        near_sdk_sim::DEFAULT_GAS,
        0,
    )
    .assert_success();
}

#[derive(BorshSerialize, BorshDeserialize)]
struct NewArgs {
    owner_id: AccountId,
    exchange_fee: u32,
    referral_fee: u32,
}

/// Test that Sputnik can upgrade another contract.
#[test]
fn test_upgrade_other() {
    let (root, dao) = setup_dao();
    let ref_account_id: AccountId = "ref-finance".parse().unwrap();
    let _ = root.deploy_and_init(
        &OTHER_WASM_BYTES,
        ref_account_id.clone(),
        "new",
        &json!({
            "owner_id": dao.account_id(),
            "exchange_fee": 1,
            "referral_fee": 1,
        })
        .to_string()
        .into_bytes(),
        to_yocto("1000"),
        DEFAULT_GAS,
    );
    let hash = root
        .call(
            dao.user_account.account_id.clone(),
            "store_blob",
            &OTHER_WASM_BYTES,
            near_sdk_sim::DEFAULT_GAS,
            to_yocto("200"),
        )
        .unwrap_json::<Base58CryptoHash>();
    add_proposal(
        &root,
        &dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::UpgradeRemote {
                receiver_id: ref_account_id.clone(),
                method_name: "upgrade".to_string(),
                hash,
            },
        },
    )
    .assert_success();
    call!(root, dao.act_proposal(0, Action::VoteApprove, None)).assert_success();
}

'''
'''--- sputnikdao2/tests/utils/mod.rs ---
#![allow(dead_code)]
pub use near_sdk::json_types::{Base64VecU8, U64};
use near_sdk::{env, AccountId, Balance};
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, ContractAccount, ExecutionResult, UserAccount,
};

use near_sdk::json_types::U128;
use sputnik_staking::ContractContract as StakingContract;
use sputnikdao2::{
    Action, Bounty, Config, ContractContract as DAOContract, OldAccountId, ProposalInput,
    ProposalKind, VersionedPolicy, OLD_BASE_TOKEN,
};
use sputnikdao_factory2::SputnikDAOFactoryContract as FactoryContract;
use test_token::ContractContract as TestTokenContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    FACTORY_WASM_BYTES => "../sputnikdao-factory2/res/sputnikdao_factory2.wasm",
    DAO_WASM_BYTES => "res/sputnikdao2.wasm",
    TEST_TOKEN_WASM_BYTES => "../test-token/res/test_token.wasm",
    STAKING_WASM_BYTES => "../sputnik-staking/res/sputnik_staking.wasm",
}

type Contract = ContractAccount<DAOContract>;

pub fn base_token() -> Option<AccountId> {
    None
}

pub fn should_fail(r: ExecutionResult) {
    match r.status() {
        ExecutionStatus::Failure(_) => {}
        _ => panic!("Should fail"),
    }
}

pub fn setup_factory(root: &UserAccount) -> ContractAccount<FactoryContract> {
    deploy!(
        contract: FactoryContract,
        contract_id: "factory".to_string(),
        bytes: &FACTORY_WASM_BYTES,
        signer_account: root,
        deposit: to_yocto("500"),
    )
}

pub fn setup_dao() -> (UserAccount, Contract) {
    let root = init_simulator(None);
    let config = Config {
        name: "test".to_string(),
        purpose: "to test".to_string(),
        metadata: Base64VecU8(vec![]),
    };
    let dao = deploy!(
        contract: DAOContract,
        contract_id: "dao".to_string(),
        bytes: &DAO_WASM_BYTES,
        signer_account: root,
        deposit: to_yocto("200"),
        init_method: new(config, VersionedPolicy::Default(vec![root.account_id.clone()]))
    );
    (root, dao)
}

pub fn setup_test_token(root: &UserAccount) -> ContractAccount<TestTokenContract> {
    deploy!(
        contract: TestTokenContract,
        contract_id: "test_token".to_string(),
        bytes: &TEST_TOKEN_WASM_BYTES,
        signer_account: root,
        deposit: to_yocto("200"),
        init_method: new()
    )
}

pub fn setup_staking(root: &UserAccount) -> ContractAccount<StakingContract> {
    deploy!(
        contract: StakingContract,
        contract_id: "staking".to_string(),
        bytes: &STAKING_WASM_BYTES,
        signer_account: root,
        deposit: to_yocto("100"),
        init_method: new("dao".parse().unwrap(), "test_token".parse::<AccountId>().unwrap(), U64(100_000_000_000))
    )
}

pub fn add_proposal(
    root: &UserAccount,
    dao: &Contract,
    proposal: ProposalInput,
) -> ExecutionResult {
    call!(root, dao.add_proposal(proposal), deposit = to_yocto("1"))
}

pub fn add_member_proposal(
    root: &UserAccount,
    dao: &Contract,
    member_id: AccountId,
) -> ExecutionResult {
    add_proposal(
        root,
        dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: member_id,
                role: "council".to_string(),
            },
        },
    )
}

pub fn add_transfer_proposal(
    root: &UserAccount,
    dao: &Contract,
    token_id: Option<AccountId>,
    receiver_id: AccountId,
    amount: Balance,
    msg: Option<String>,
) -> ExecutionResult {
    add_proposal(
        root,
        dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::Transfer {
                token_id: convert_new_to_old_token(token_id),
                receiver_id,
                amount: U128(amount),
                msg,
            },
        },
    )
}

pub fn add_bounty_proposal(root: &UserAccount, dao: &Contract) -> ExecutionResult {
    add_proposal(
        root,
        dao,
        ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddBounty {
                bounty: Bounty {
                    description: "test bounty".to_string(),
                    token: String::from(OLD_BASE_TOKEN),
                    amount: U128(to_yocto("10")),
                    times: 3,
                    max_deadline: U64(env::block_timestamp() + 10_000_000_000),
                },
            },
        },
    )
}

pub fn vote(users: Vec<&UserAccount>, dao: &Contract, proposal_id: u64) {
    for user in users.into_iter() {
        call!(
            user,
            dao.act_proposal(proposal_id, Action::VoteApprove, None)
        )
        .assert_success();
    }
}

pub fn convert_new_to_old_token(new_account_id: Option<AccountId>) -> OldAccountId {
    if new_account_id.is_none() {
        return String::from(OLD_BASE_TOKEN);
    }
    new_account_id.unwrap().to_string()
}

'''
'''--- test-token/Cargo.toml ---
[package]
name = "test-token"
version = "0.1.0"
authors = ["Illia Polosukhin <illia.polosukhin@gmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.4"
near-contract-standards = "4.0.0-pre.4"

'''
'''--- test-token/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/test_token.wasm res/

'''
'''--- test-token/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{near_bindgen, AccountId, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            token: FungibleToken::new(b"t".to_vec()),
        }
    }

    pub fn mint(&mut self, account_id: AccountId, amount: U128) {
        self.token.internal_register_account(&account_id);
        self.token.internal_deposit(&account_id, amount.into());
    }

    pub fn burn(&mut self, account_id: AccountId, amount: U128) {
        self.token.internal_withdraw(&account_id, amount.into());
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        unimplemented!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{env, testing_env};

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = Contract::new();
        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.mint(accounts(0), 1_000_000.into());
        assert_eq!(contract.ft_balance_of(accounts(0)), 1_000_000.into());

        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.storage_deposit(Some(accounts(1)), None);
        testing_env!(context
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.ft_transfer(accounts(1), 1_000.into(), None);
        assert_eq!(contract.ft_balance_of(accounts(1)), 1_000.into());

        contract.burn(accounts(1), 500.into());
        assert_eq!(contract.ft_balance_of(accounts(1)), 500.into());
    }
}

'''