*GitHub Repository "nearvndev/simple-amm-contract"*

'''--- Cargo.toml ---
[package]
name = "simple-pool-contract"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "3.1.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p out
cp target/wasm32-unknown-unknown/release/*.wasm out/simple-pool.wasm
'''
'''--- src/account.rs ---
use std::collections::HashMap;

use near_sdk::collections::UnorderedMap;

use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    pub near_amount: Balance,
    pub tokens: UnorderedMap<AccountId, Balance>,
    pub share: Balance
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountJson {
    pub tokens: HashMap<AccountId, Balance>,
    pub share: U128,
    pub account_id: AccountId
}

#[derive(BorshDeserialize, BorshSerialize)]
pub enum VersionedAccount {
    Current(Account)
}

impl From<VersionedAccount> for Account {
    fn from(v_account: VersionedAccount) -> Self {
        match v_account {
            VersionedAccount::Current(account) => account
        }
    }
}

impl From<Account> for VersionedAccount {
    fn from(account: Account) -> Self {
        VersionedAccount::Current(account)
    }
}

#[near_bindgen]
impl SimplePool {

    #[payable]
    pub fn register_account(&mut self, account_id: Option<AccountId>) {
        assert_at_least_one_yocto();
        let account_id_unwrap = account_id.unwrap_or_else(|| env::predecessor_account_id());
        let v_account = self.accounts.get(&account_id_unwrap);
        assert!(v_account.is_none(), "ERR_ACCOUNT_REGISTED");

        let before_storage_usage = env::storage_usage();

        let account = Account {
            near_amount: 0,
            tokens: UnorderedMap::new(StorageKey::AccountTokenKey { account_id: account_id_unwrap.clone() }),
            share: 0
        };

        self.accounts.insert(&account_id_unwrap, &VersionedAccount::from(account));

        let after_storage_usage = env::storage_usage();

        refund_deposit(after_storage_usage - before_storage_usage);
    }

    pub fn get_account_info(&self, account_id: AccountId) -> AccountJson {
        let v_account = self.accounts.get(&account_id).unwrap();
        let account = Account::from(v_account);

        AccountJson { tokens: HashMap::from_iter(account.tokens.to_vec()), share: U128(account.share), account_id }
    }

    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        let v_account = self.accounts.get(&account_id);

        if v_account.is_some() {
            U128(1)
        } else {
            U128(0)
        }
    }

    pub(crate) fn internal_deposit(&mut self, account_id: AccountId, token_id: AccountId, amount: u128) {
        let v_account = self.accounts.get(&account_id).unwrap();
        let mut account = Account::from(v_account);

        let token_amount = account.tokens.get(&token_id).unwrap_or_else( || 0);
        account.tokens.insert(&token_id, &(token_amount + amount));

        self.accounts.insert(&account_id, &VersionedAccount::from(account));
    }

    pub(crate) fn internal_withdraw(&mut self, account_id: AccountId, token_id: AccountId, amount: u128) {
        let v_account = self.accounts.get(&account_id).unwrap();
        let mut account = Account::from(v_account);

        let token_amount = account.tokens.get(&token_id).unwrap_or_else( || 0);

        assert!(token_amount >= amount, "ERR_INVALID_AMOUNT");
        
        account.tokens.insert(&token_id, &(token_amount - amount));

        self.accounts.insert(&account_id, &VersionedAccount::from(account));
    }
}
'''
'''--- src/core_impl.rs ---
use near_sdk::PromiseOrValue;

use crate::*;
use std::{cmp::min, collections::HashMap, hash::Hash};

pub const FT_TRANSFER_GAS: Gas = 10_000_000_000_000;
pub const WITHDRAW_CALLBACK_GAS: Gas = 10_000_000_000_000;

#[ext_contract(ext_ft_contract)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[ext_contract(ext_self)]
pub trait ExtStakingContract {
    fn ft_withdraw_callback(&mut self, account_id: AccountId, token_id: AccountId, amount: U128);
}

#[near_bindgen]
impl SimplePool {
    pub fn get_tokens(&self) -> Vec<AccountId> {
        self.token_ids.to_vec()
    }

    pub fn get_fee(&self) -> U128 {
        U128(self.exchange_fee)
    }

    pub fn get_volumes(&self) -> Vec<SwapVolume> {
        self.volumes.values().into_iter().collect()
    }

    pub fn get_return(&self, token_in: AccountId, amount_in: U128, token_out: AccountId) -> U128 {
        U128(self.internal_get_return(token_in, amount_in.0, token_out))
    }

    #[payable]
    pub fn swap(&mut self, token_in: AccountId, amount_in: U128, token_out: AccountId, min_amount_out: U128) -> Balance {
        assert_one_yocto();
        let in_reserve = self.token_reserves.get(&token_in).unwrap();
        let out_reserve = self.token_reserves.get(&token_out).unwrap();

        let amount_out = self.internal_get_return(token_in.clone(), amount_in.0, token_out.clone());
        assert!(amount_out >= min_amount_out.0, "ERR_MIN_AMOUNT");
        log!("Swapped from {} {} for {} {} ", token_in.clone(), amount_in.clone().0.to_string(), token_out.clone(), amount_out.clone().to_string());

        self.token_reserves.insert(&token_in, &(in_reserve + amount_in.0));
        self.token_reserves.insert(&token_out, &(&out_reserve - amount_out));

        // Deposit amount out for user
        self.internal_deposit(env::predecessor_account_id(), token_out.clone(), amount_out.clone());

        // Wihdraw amount in
        self.internal_withdraw(env::predecessor_account_id(), token_in.clone(), amount_in.clone().0);

        // Add volume
        let mut volume = self.volumes.get(&token_in).unwrap_or_else( || SwapVolume::default());
        volume.input += amount_in.0;
        volume.output += amount_out;

        self.volumes.insert(&token_in, &volume);

        amount_out
    }

    /**
         * calculate share
         * How much dx, dy to add?
         * xy = k
         * (x + dx)(y + dy) = k'
         * 
         * No price change, before and after adding liquidity
         * x / y = (x + dx) / (y + dy)
         * x(y + dy) = y(x + dx)
         * x * dy = y * dx
         * x / y = dx / dy
         * dy = y / x * dx
    */

    #[payable]
    pub fn add_liquidity(&mut self, token_in: AccountId, amount_in: U128, token_out: AccountId, amount_out: U128) -> Balance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();

        assert!(token_in != token_out, "ERR_TOKEN_ID");
        assert!(amount_in.0 > 0 && amount_out.0 > 0, "ERR_INVALID_AMOUNT");

        // Withdraw token
        self.internal_withdraw(account_id.clone(), token_in.clone(), amount_in.clone().0);
        self.internal_withdraw(account_id.clone(), token_out.clone(), amount_out.clone().0);

        let in_reserve = self.token_reserves.get(&token_in).unwrap();
        let out_reserve = self.token_reserves.get(&token_out).unwrap();

        let share = if self.total_share_supply > 0 {
            assert!(in_reserve > 0 && out_reserve > 0, "ERR_RESERVE_INVALID");
            assert_eq!(U256::from(in_reserve) * U256::from(amount_out.0), U256::from(out_reserve) * U256::from(amount_in.0), "x / y != dx / dy");

            self.token_reserves.insert(&token_in, &(in_reserve + amount_in.0));
            self.token_reserves.insert(&token_out, &(out_reserve + amount_out.0));

            min(
                U256::from(amount_in.clone().0) * U256::from(self.total_share_supply) / U256::from(in_reserve.clone()),  
                U256::from(amount_out.clone().0) * U256::from(self.total_share_supply) / U256::from(out_reserve.clone())
            )
        } else {
            self.token_reserves.insert(&token_in, &(in_reserve + amount_in.0));
            self.token_reserves.insert(&token_out, &(out_reserve + amount_out.0));
            U256::from(INIT_SHARES_SUPPLY)
        };

        assert!(share.as_u128() > 0, "Share = 0");

        self.mint_share(account_id, share.clone().as_u128());
        share.as_u128()
    }

    #[payable]
    pub fn remove_liquidity(&mut self, amount: U128) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        // Check and burn share
        self.burn_share(account_id.clone(), amount.0);

        let token_1 = self.token_ids.get(0).unwrap();
        let token_2 = self.token_ids.get(1).unwrap();

        let reserve_1 = self.token_reserves.get(&token_1).unwrap();
        let reserve_2 = self.token_reserves.get(&token_2).unwrap();

        let amount_out_1 = U256::from(amount.0) * U256::from(reserve_1) / U256::from(self.total_share_supply);
        let amount_out_2 = U256::from(amount.0) * U256::from(reserve_2) / U256::from(self.total_share_supply);

        self.token_reserves.insert(&token_1, &(reserve_1 - amount_out_1.as_u128()));
        self.token_reserves.insert(&token_2, &(reserve_2 - amount_out_2.as_u128()));

        self.internal_deposit(account_id.clone(), token_1.clone(), amount_out_1.as_u128());
        self.internal_deposit(account_id.clone(), token_2.clone(), amount_out_2.as_u128());
    }

    #[payable]
    pub fn withdraw(&mut self, token_id: AccountId) -> Promise {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let v_account = self.accounts.get(&account_id).unwrap();
        let account = Account::from(v_account);

        let token_balance = account.tokens.get(&token_id).unwrap();
        assert!(token_balance > 0, "ERR_TOKEN_BALANCE_EQUAL_ZERO");

        // Transfer all token balance

        ext_ft_contract::ft_transfer(
            account_id.clone(), 
            U128(token_balance.clone()), 
            Some(String::from("Withdraw from exchange")), 
            &token_id, 
            1, 
            FT_TRANSFER_GAS
        ).then(ext_self::ft_withdraw_callback(
            account_id, 
            token_id, 
            U128(token_balance), 
            &env::current_account_id(), 
            0, 
            WITHDRAW_CALLBACK_GAS
        ))
    }

    #[private]
    pub fn ft_withdraw_callback(&mut self, account_id: AccountId, token_id: AccountId, amount: U128) -> PromiseOrValue<U128> {
        assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULTS");
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_value) => {
                self.internal_withdraw(account_id, token_id, amount.0);
                PromiseOrValue::Value(amount)
            },
            PromiseResult::Failed => env::panic(b"ERR_CALL_FAILED"),
        }
    }
}
'''
'''--- src/ft_receiver.rs ---
use near_sdk::PromiseOrValue;

use crate::*;

pub trait FungibleTokenReceiver {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_ft_contract)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[near_bindgen]
impl FungibleTokenReceiver for SimplePool {
    /**
     * Handle deposit token
     */
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128> {
        let contract_id = env::predecessor_account_id();
        assert!(contract_id == self.token_ids.get(0).unwrap() || contract_id == self.token_ids.get(1).unwrap(), "ERR_FT_CONTRACT_NOT_IN_POOL");
        self.internal_deposit(sender_id, contract_id, amount.0);

        PromiseOrValue::Value(U128(0))
    }
}
'''
'''--- src/internal.rs ---
use crate::*;

#[near_bindgen]
impl SimplePool {
    pub(crate) fn internal_transfer_share(&mut self, account_id: AccountId, receiver_id: AccountId, amount: u128) {
        let v_account = self.accounts.get(&account_id).unwrap();
        let mut account = Account::from(v_account);

        let v_receiver = self.accounts.get(&receiver_id).unwrap();
        let mut receiver = Account::from(v_receiver);

        assert!(account.share >= amount, "ERR_SHARE_AMOUNT_NOT_ENOUGH");

        account.share -= amount;
        receiver.share += amount;

        self.accounts.insert(&account_id, &VersionedAccount::from(account));
        self.accounts.insert(&receiver_id, &VersionedAccount::from(receiver));
    }

    /**
     * x = in_balance
     * y = out_balance
     * dx = amount_in
     * dy = amount_out
     * x*y = k => dy = y*dx / (x + dx)
     */
    pub(crate) fn internal_get_return(&self, token_in: AccountId, amount_in: Balance, token_out: AccountId) -> Balance {
        assert!(token_in != token_out, "ERR_NOT_GET_SAME_TOKEN");
        assert!(amount_in > 0, "ERR_AMOUNT_IN_INVALID");

        let in_balance = self.token_reserves.get(&token_in).unwrap();
        let out_balance = self.token_reserves.get(&token_out).unwrap();

        assert!(in_balance > 0 && out_balance > 0, "ERR_TOKEN_RESERVE_INVALID");

        let amount_out = U256::from(out_balance) * U256::from(amount_in) / U256::from(in_balance + amount_in);
        let amount_out_with_fee = U256::from(FEE_DIVISOR as u128 - self.exchange_fee) * amount_out / U256::from(FEE_DIVISOR);
        amount_out_with_fee.as_u128()
    }
}
'''
'''--- src/lib.rs ---
use near_sdk::{env, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault, Promise, log, ext_contract, Gas, PromiseResult};
use near_sdk::collections::{LookupMap, Vector, UnorderedMap};
use near_sdk::json_types::{U128};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Serialize, Deserialize};
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

use crate::util::*;
use crate::account::*;
mod share;
mod util;
mod internal;
mod core_impl;
mod account;
mod ft_receiver;

/// Fee divisor, allowing to provide fee in bps.
pub const FEE_DIVISOR: u32 = 10_000;

/// Initial shares supply on deposit of liquidity.
pub const INIT_SHARES_SUPPLY: u128 = 1_000_000_000_000_000_000_000_000;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SwapVolume {
    pub input: u128,
    pub output: u128,
}

impl Default for SwapVolume {
    fn default() -> Self {
        Self {
            input: 0,
            output: 0,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    TokenIDKey,
    TokenReserveKey,
    ShareKey,
    VolumeKey,
    AccountKey,
    AccountTokenKey {
        account_id: AccountId
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct SimplePool {
    pub owner_id: AccountId,
    pub token_ids: Vector<AccountId>,
    pub token_reserves: LookupMap<AccountId, Balance>,
    pub total_share_supply: Balance,
    pub exchange_fee: Balance, // ex fee 0.3% => 300/FEE_DIVISOR => exchange_fee = 300
    pub volumes: UnorderedMap<AccountId, SwapVolume>,
    pub accounts: LookupMap<AccountId, VersionedAccount>
}

#[near_bindgen]
impl SimplePool {
    #[init]
    pub fn new(owner_id: AccountId, token_ids: Vec<AccountId>, exchange_fee: U128) -> Self {
        assert_eq!(token_ids.len(), 2, "MUST 2 TOKEN IDS");
        let mut tokens = Vector::new(StorageKey::TokenIDKey);
        tokens.push(&token_ids[0]);
        tokens.push(&token_ids[1]);

        let mut token_reserves = LookupMap::new(StorageKey::TokenReserveKey);
        token_reserves.insert(&token_ids[0], &0);
        token_reserves.insert(&token_ids[1], &0);

        let mut volumes = UnorderedMap::new(StorageKey::VolumeKey);
        volumes.insert(&token_ids[0], &SwapVolume::default());
        volumes.insert(&token_ids[1], &SwapVolume::default());

        SimplePool { 
            owner_id,
            token_ids: tokens, 
            token_reserves,
            total_share_supply: 0, 
            exchange_fee: exchange_fee.0,
            volumes,
            accounts: LookupMap::new(StorageKey::AccountKey)
        }
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}

'''
'''--- src/share.rs ---
use crate::*;

#[near_bindgen]
impl SimplePool {
    pub fn get_share_of(&self, account_id: AccountId) -> U128 {
        let v_account = self.accounts.get(&account_id).unwrap();
        let account = Account::from(v_account);

        U128(account.share)
    }

    #[payable]
    pub fn transfer_share(&mut self, receiver_id: AccountId, amount: U128) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        self.internal_transfer_share(account_id, receiver_id, amount.0);
    }

    pub fn get_total_share_balance(&self) -> U128 {
        U128(self.total_share_supply)
    }

    pub(crate) fn mint_share(&mut self, account_id: AccountId, amount: Balance) {
        let v_account = self.accounts.get(&account_id).unwrap();
        let mut account = Account::from(v_account);
        account.share += amount;

        self.total_share_supply += amount;

        self.accounts.insert(&account_id, &VersionedAccount::from(account));
    }

    pub(crate) fn burn_share(&mut self, account_id: AccountId, amount: Balance) {
        let v_account = self.accounts.get(&account_id).unwrap();
        let mut account = Account::from(v_account);

        assert!(account.share >= amount);
        account.share -= amount;
        self.total_share_supply -= amount;

        self.accounts.insert(&account_id, &VersionedAccount::from(account));
    }
}
'''
'''--- src/util.rs ---
use crate::*;

pub(crate) fn assert_at_least_one_yocto() {
    assert!(env::attached_deposit() >= 1, "Required attached deposit of at least 1 yoctoNEAR")
}

pub(crate) fn assert_one_yocto() {
    assert_eq!(env::attached_deposit(), 1, "Required attached deposit of exactly 1 yoctoNEAR")
}

pub(crate) fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(attached_deposit >= required_cost, "Must attach {} yoctoNear to cover storage", required_cost);

    let refund = attached_deposit - required_cost;

    if refund > 0 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

/// Newton's method of integer square root.
pub fn integer_sqrt(value: U256) -> U256 {
    let mut guess: U256 = (value + U256::one()) >> 1;
    let mut res = value;
    while guess < res {
        res = guess;
        guess = (value / guess + guess) >> 1;
    }
    res
}
'''