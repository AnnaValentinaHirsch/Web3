*GitHub Repository "Minting-Music/near-auth"*

'''--- .gitpod.yml ---
tasks:
  - init: yarn
    command: yarn dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
Meainnet: https://auth.nearspace.info

Testnet: https://testnet.auth.nearspace.info

near-auth
==================

This [React] app was initialized with [create-near-app]

Quick Start
===========

To run this project locally:

1. Prerequisites: Make sure you've installed [Node.js] ≥ 12
2. Install dependencies: `yarn install`
3. Run the local development server: `yarn dev` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Now you'll have a local development environment backed by the NEAR TestNet!

Go ahead and play with the app and the code. As you make code changes, the app will automatically reload.

Exploring The Code
==================

1. The "backend" code lives in the `/contract` folder. See the README there for
   more info.
2. The frontend code lives in the `/src` folder. `/src/index.html` is a great
   place to start exploring. Note that it loads in `/src/index.js`, where you
   can learn how the frontend connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and the smart
   contract. See `contract/README` for info about how it's tested. The frontend
   code gets tested with [jest]. You can run both of these at once with `yarn
   run test`.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `yarn dev`, your smart contract gets deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `yarn install`, but for best ergonomics you may want to install it globally:

    yarn install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `near-auth.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `near-auth.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account near-auth.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: set contract name in code
---------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'near-auth.YOUR-NAME.testnet'

Step 3: deploy!
---------------

One command:

    yarn deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contract to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

  [React]: https://reactjs.org/
  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/docs/concepts/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- contract/Cargo.toml ---
[package]
name = "nearauth"
version = "0.2.0"
authors = ["Vadim Ilin <vadim@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=3.1.0"
sha256 = "1.0.2"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
Near Auth Smart Contract
==================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile it with
   the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard Rust tests using [cargo] with a `--nocapture` flag so that you
   can see any debug info you print to the console.

  [smart contract]: https://docs.near.org/docs/roles/developer/contracts/intro
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://github.com/near/near-sdk-rs#pre-requisites
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')
const path = require('path')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  const linkPath = path.relative(linkDir, outFile)

  sh.ln('-s', linkPath, link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use std::convert::TryFrom;
use near_sdk::wee_alloc;
use near_sdk::{env, near_bindgen, AccountId, Balance, Promise, PanicOnDefault};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::collections::{LookupMap, UnorderedMap};
use std::collections::HashMap;
use sha256::digest;

type SecretKey = String;
type RequestKey = String;
type ContactStringified = String;

/// Price per 1 byte of storage from mainnet config after `0.18` release and protocol version `42`.
/// It's 10 times lower than the genesis price.
pub const STORAGE_PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;
const WHITELIST_STORAGE_COST: u128 = 10_000_000_000_000_000_000_000;
//0.01
const WHITELIST_FEE: u128 = 1_500_000_000_000_000_000_000; //0.0015

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    master_account_id: AccountId,
    accounts: UnorderedMap<AccountId, Vec<Contact>>, // main object, contacts of account
    accounts_for_contacts: UnorderedMap<ContactStringified, AccountId>, // object to find owner of the contact
    requests: UnorderedMap<RequestKey, Request>, // pending requests
    storage_deposits: LookupMap<AccountId, Balance>,
    version: u16,
}

/// Helper structure to for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    AccountsForContacts,
    Requests,
    StorageDeposits,
    Accounts2, // used after migration_1
    Requests2, // used after migration_1
}

#[derive(BorshSerialize, BorshDeserialize, Eq, PartialEq, Debug, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum ContactCategories {
    Email,
    Telegram,
    Twitter,
    Github,
    NearGovForum,
}

#[derive(Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Contact {
    pub category: ContactCategories,
    pub value: String,
    pub account_id: Option<u64>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Contact_v1 {
    pub category: ContactCategories,
    pub value: String,
}

#[derive(Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Request {
    pub contact: Option<Contact>,
    pub account_id: AccountId,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(master_account_id: ValidAccountId) -> Self {
        Self {
            master_account_id: master_account_id.into(),
            accounts: UnorderedMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
            accounts_for_contacts: UnorderedMap::new(StorageKey::AccountsForContacts.try_to_vec().unwrap()),
            requests: UnorderedMap::new(StorageKey::Requests.try_to_vec().unwrap()),
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits.try_to_vec().unwrap()),
            version: 0,
        }
    }

    pub fn whitelist_key(&mut self, account_id: ValidAccountId, request_key: RequestKey) {
        assert!(env::predecessor_account_id() == self.master_account_id, "No access");

        let storage_paid = Contract::storage_paid(self, account_id.clone());

        assert!(
            storage_paid.0 >= WHITELIST_STORAGE_COST,
            "{} requires minimum storage deposit of {}",
            account_id, WHITELIST_STORAGE_COST
        );

        let account_id_string: AccountId = account_id.into();

        match Contract::get_request_key(self, account_id_string.clone()) {
            None => {
                let request = Request {
                    contact: None,
                    account_id: account_id_string.clone(),
                };

                self.requests.insert(&request_key, &request);

                // update storage
                let balance: Balance = storage_paid.0 - WHITELIST_STORAGE_COST;
                self.storage_deposits.insert(&account_id_string, &balance);
            }
            Some(_) => {
                env::panic(b"Request for this account already exist. Please remove it to continue")
            }
        }
    }

    fn prepare_contact(contact: Contact) -> Contact {
        assert!(!contact.value.is_empty(), "Contact value is empty");

        if contact.category == ContactCategories::Telegram {
            assert!(contact.account_id != None, "Telegram account_id is missing");
        }

        if contact.category == ContactCategories::Telegram && contact.value.chars().nth(0).unwrap() == '@' {
            Contact {
                category: ContactCategories::Telegram,
                value: contact.value[1..contact.value.len()].trim().to_string().to_lowercase(),
                account_id: contact.account_id,
            }
        } else {
            Contact {
                category: contact.category,
                value: contact.value.trim().to_string().to_lowercase(),
                account_id: contact.account_id,
            }
        }
    }

    #[payable]
    pub fn start_auth(&mut self, request_key: RequestKey, contact: Contact) {
        assert_one_yocto();

        let account_id: AccountId = env::predecessor_account_id();

        let prepared_contact = Contract::prepare_contact(contact);

        let contact_owner = self.get_account_for_contact(prepared_contact.clone());
        assert!(contact_owner.is_none(), "Contact already registered");

        match self.get_request(request_key.clone()) {
            Some(request) => {
                assert_eq!(
                    request.account_id,
                    account_id,
                    "Key whitelisted for different account"
                );

                match request.contact {
                    None => {
                        self.requests.insert(
                            &request_key,
                            &Request {
                                contact: Some(prepared_contact),
                                account_id,
                            },
                        );
                    }
                    Some(_) =>
                        env::panic(b"Contact already exists for this request")
                }
            }
            None => env::panic(b"Only whitelisted keys allowed")
        }
    }

    pub fn confirm_auth(&mut self, key: SecretKey) {
        let account_id = env::predecessor_account_id();
        let request_key = Contract::get_sha256(key);

        match Contract::get_request(self, request_key.clone()) {
            Some(request) => {
                assert_eq!(
                    account_id,
                    request.account_id,
                    "No access to confirm this request"
                );

                match request.contact {
                    Some(requested_contact) => {
                        self.requests.remove(&request_key).expect("Unexpected request");

                        let initial_storage_usage = env::storage_usage();

                        let mut contacts = self.get_contacts(account_id.clone()).unwrap_or(vec![]);
                        contacts.push(requested_contact.clone());

                        self.insert_accounts_for_contact(account_id.clone(), requested_contact);

                        self.accounts.insert(&account_id, &contacts);

                        // update storage
                        let tokens_per_entry_in_bytes = env::storage_usage() - initial_storage_usage;
                        let tokens_per_entry_storage_price: Balance = Balance::from(tokens_per_entry_in_bytes) * STORAGE_PRICE_PER_BYTE;
                        let storage_paid = Contract::storage_paid(self, ValidAccountId::try_from(account_id.clone()).unwrap());

                        assert!(
                            storage_paid.0 >= tokens_per_entry_storage_price,
                            "{} requires minimum storage of {}", account_id, tokens_per_entry_storage_price
                        );

                        let balance: Balance = storage_paid.0 + WHITELIST_STORAGE_COST - WHITELIST_FEE - tokens_per_entry_storage_price;
                        self.storage_deposits.insert(&account_id, &balance);

                        env::log(format!("@{} spent {} yNEAR for storage", account_id, tokens_per_entry_storage_price).as_bytes());
                    }
                    None =>
                        env::panic(b"Confirm of undefined contact")
                }
            }
            None => {
                env::panic(b"Request not found");
            }
        }
    }

    fn get_sha256(key: SecretKey) -> String {
        digest(key)
    }

    pub(crate) fn are_contacts_equal(contact1: Contact, contact2: Contact) -> bool {
        if contact1.category == ContactCategories::Telegram && contact2.category == ContactCategories::Telegram {
            contact1.account_id == contact2.account_id
        } else {
            contact1.category == contact2.category && contact1.value == contact2.value
        }
    }

    // TODO only first N chars of category to reduce storage?
    fn get_contact_stringified(contact: Contact) -> String {
        if contact.category == ContactCategories::Telegram {
            format!("{:?}:{:?}", contact.category, contact.account_id.unwrap())
        } else {
            format!("{:?}:{}", contact.category, contact.value)
        }
    }

    pub(crate) fn insert_accounts_for_contact(&mut self, account_id: AccountId, contact: Contact) {
        let contact_stringified = Contract::get_contact_stringified(contact);
        self.accounts_for_contacts.insert(&contact_stringified, &account_id);
    }

    pub(crate) fn remove_accounts_for_contact(&mut self, contact: Contact) {
        let contact_stringified = Contract::get_contact_stringified(contact);
        self.accounts_for_contacts.remove(&contact_stringified);
    }

    pub fn get_request(&self, request_key: RequestKey) -> Option<Request> {
        match self.requests.get(&request_key) {
            Some(request) => Some(request),
            None => None
        }
    }

    pub fn get_request_key(&self, account_id: AccountId) -> Option<RequestKey> {
        self.requests
            .iter()
            .find_map(|(key, request)| if request.account_id == account_id { Some(key) } else { None })
    }

    pub fn remove_request(&mut self) {
        let account_id = env::predecessor_account_id();

        match Contract::get_request_key(self, account_id.clone()) {
            Some(request_key) => {
                self.requests.remove(&request_key);

                // update storage
                let storage_paid = Contract::storage_paid(self, ValidAccountId::try_from(account_id.clone()).unwrap());
                let whitelist_storage_cost = WHITELIST_STORAGE_COST - WHITELIST_FEE;
                let balance: Balance = storage_paid.0 + whitelist_storage_cost;
                self.storage_deposits.insert(&account_id, &balance);

                env::log(format!("@{} removed previous request for {} yNEAR", account_id, whitelist_storage_cost).as_bytes());
            }
            None => {
                env::panic(b"Request not found")
            }
        }
    }

    pub fn get_contacts(&self, account_id: AccountId) -> Option<Vec<Contact>> {
        match self.accounts.get(&account_id) {
            Some(contacts) => Some(contacts),
            None => None
        }
    }

    pub fn get_account_for_contact(&self, contact: Contact) -> Option<AccountId> {
        let contact_stringified = Contract::get_contact_stringified(contact);
        self.get_account_for_contact_stringified(contact_stringified)
    }

    pub fn get_account_for_contact_stringified(&self, contact_stringified: ContactStringified) -> Option<AccountId> {
        match self.accounts_for_contacts.get(&contact_stringified) {
            Some(account_id) => Some(account_id),
            None => None
        }
    }

    pub fn get_contacts_by_type(&self, account_id: AccountId, category: ContactCategories) -> Option<Vec<String>> {
        match self.accounts.get(&account_id) {
            Some(contacts) =>
                {
                    let filtered_contacts: Vec<String> = contacts
                        .into_iter()
                        .filter(|contact| contact.category == category)
                        .map(|contact| contact.value)
                        .collect();
                    Some(filtered_contacts)
                }
            None => None
        }
    }

    pub fn has_request_key(&self, account_id: AccountId) -> bool {
        self.get_request_key(account_id) != None
    }

    #[payable]
    pub fn send(&mut self, contact: Contact) -> Promise {
        let tokens: Balance = near_sdk::env::attached_deposit();

        let recipient = self.get_account_for_contact(contact);
        assert!(!recipient.is_none(), "Contact not found");

        let recipient_account_id = recipient.unwrap();

        env::log(format!("Tokens sent to @{}", recipient_account_id).as_bytes());

        Promise::new(recipient_account_id).transfer(tokens)
    }

    pub fn get_all_accounts_for_contacts(&self, from_index: u64, limit: u64) -> HashMap<ContactStringified, AccountId> {
        let keys = self.accounts_for_contacts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| {
                let contact_stringified = keys.get(index).unwrap();
                let account_id = self.get_account_for_contact_stringified(contact_stringified.clone()).unwrap();
                (contact_stringified, account_id)
            })
            .collect()
    }

    pub fn get_all_contacts(&self, from_index: u64, limit: u64) -> HashMap<AccountId, Vec<Contact>> {
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| {
                let account_id = keys.get(index).unwrap();
                let all_contacts = self.get_contacts(account_id.clone()).unwrap();
                (account_id, all_contacts)
            })
            .collect()
    }

    pub fn get_all_contacts_by_type(&self, category: ContactCategories, from_index: u64, limit: u64) -> HashMap<AccountId, Vec<String>> {
        assert!(limit <= 100, "Abort. Limit > 100");

        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| {
                let account_id = keys.get(index).unwrap();
                let all_contacts = self.get_contacts_by_type(account_id.clone(), category.clone()).unwrap();
                (account_id, all_contacts)
            })
            .filter(|(_k, v)| !v.is_empty())
            .map(|(k, v)| (k, v))
            .collect()
    }

    pub fn get_owners(&self, _contact: Contact) -> Vec<String> {
        panic!("Deprecated. Use `get_account_for_contact` instead");
    }

    pub fn is_owner(&self, account_id: AccountId, contact: Contact) -> bool {
        match self.accounts.get(&account_id) {
            Some(contacts) =>
                {
                    contacts.into_iter()
                        .any(|_contact| Contract::are_contacts_equal(_contact, contact.clone()))
                }
            None => false
        }
    }

    // remove contact
    pub fn remove(&mut self, contact: Contact) -> bool {
        let account_id = env::predecessor_account_id();
        let is_owner = Contract::is_owner(self, account_id.clone(), contact.clone());

        assert!(is_owner, "Not an owner of this contact");

        match self.accounts.get(&account_id) {
            Some(contacts) =>
                {
                    let initial_storage_usage = env::storage_usage();

                    let filtered_contacts: Vec<Contact> = contacts
                        .into_iter()
                        .filter(|_contact| !Contract::are_contacts_equal(_contact.clone(), contact.clone()))
                        .collect();
                    self.accounts.insert(&account_id, &filtered_contacts);

                    self.remove_accounts_for_contact(contact);

                    let tokens_per_entry_in_bytes = initial_storage_usage - env::storage_usage();
                    let tokens_per_entry_storage_price: Balance = Balance::from(tokens_per_entry_in_bytes) * STORAGE_PRICE_PER_BYTE;
                    let storage_paid = Contract::storage_paid(self, ValidAccountId::try_from(account_id.clone()).unwrap());
                    let balance: Balance = storage_paid.0 + tokens_per_entry_storage_price;
                    self.storage_deposits.insert(&account_id.clone(), &balance);
                    env::log(format!("@{} unlocked {} yNEAR from storage", account_id, tokens_per_entry_storage_price).as_bytes());

                    true
                }
            None => false
        }
    }

    // remove all contacts
    pub fn remove_all(&mut self) -> bool {
        let account_id = env::predecessor_account_id();

        match self.accounts.get(&account_id) {
            Some(contacts) =>
                {
                    let initial_storage_usage = env::storage_usage();

                    for _contact in contacts.iter() {
                        self.remove_accounts_for_contact(_contact.clone());
                    }

                    self.accounts.insert(&account_id, &vec![]);

                    let tokens_per_entry_in_bytes = initial_storage_usage - env::storage_usage();
                    let tokens_per_entry_storage_price: Balance = Balance::from(tokens_per_entry_in_bytes) * STORAGE_PRICE_PER_BYTE;
                    let storage_paid = Contract::storage_paid(self, ValidAccountId::try_from(account_id.clone()).unwrap());
                    let balance: Balance = storage_paid.0 + tokens_per_entry_storage_price;
                    self.storage_deposits.insert(&account_id, &balance);
                    env::log(format!("@{} unlocked {} yNEAR from storage", account_id, tokens_per_entry_storage_price).as_bytes());

                    true
                }
            None => false
        }
    }

    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<ValidAccountId>) {
        let storage_account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(env::predecessor_account_id);
        let deposit = env::attached_deposit();
        assert!(
            deposit > 0,
            "Requires positive deposit"
        );

        // update storage
        let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
        balance += deposit;
        self.storage_deposits.insert(&storage_account_id, &balance);
    }

    #[payable]
    pub fn storage_withdraw(&mut self) {
        let owner_id = env::predecessor_account_id();
        let amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);
        if amount > 0 {
            Promise::new(owner_id).transfer(amount);
        }
    }

    pub fn storage_amount(&self) -> U128 {
        U128(WHITELIST_STORAGE_COST)
    }

    pub fn storage_paid(&self, account_id: ValidAccountId) -> U128 {
        U128(self.storage_deposits.get(account_id.as_ref()).unwrap_or(0))
    }

    #[init(ignore_state)]
    pub fn migrate_state_1() -> Self {
        let migration_version: u16 = 1;
        assert_eq!(env::predecessor_account_id(), env::current_account_id(), "Private function");

        #[derive(BorshDeserialize)]
        struct OldContract {
            master_account_id: AccountId,
            accounts: UnorderedMap<AccountId, Vec<Contact_v1>>,
            requests: UnorderedMap<RequestKey, Request>,
            storage_deposits: LookupMap<AccountId, Balance>,
        }

        let old_contract: OldContract = env::state_read().expect("Old state doesn't exist");

        let mut new_accounts = UnorderedMap::new(StorageKey::Accounts2.try_to_vec().unwrap());

        let new_requests = UnorderedMap::new(StorageKey::Requests2.try_to_vec().unwrap());
        let mut new_accounts_for_contacts = UnorderedMap::new(StorageKey::AccountsForContacts.try_to_vec().unwrap());

        let data1_account = "example.near".to_string();
        let data1_contact = get_telegram_contact("handler".to_string(), Some(123));
        new_accounts.insert(&data1_account.clone(), &vec![data1_contact.clone()]);
        new_accounts_for_contacts.insert(&Contract::get_contact_stringified(data1_contact), &data1_account);

        Self {
            master_account_id: old_contract.master_account_id,
            accounts: new_accounts,
            accounts_for_contacts: new_accounts_for_contacts,
            requests: new_requests,
            storage_deposits: old_contract.storage_deposits,
            version: migration_version,
        }
    }

    pub fn get_version(&self) -> u16 {
        self.version
    }
}

/* UTILS */
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
}

// for migration
pub(crate) fn get_telegram_contact(value: String, account_id: Option<u64>) -> Contact {
    Contact {
        category: ContactCategories::Telegram,
        value,
        account_id,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn master_account() -> AccountId { "admin.near".to_string() }

    fn master_valid_account() -> ValidAccountId { ValidAccountId::try_from(master_account()).unwrap() }

    fn alice_account() -> AccountId { "alice.near".to_string() }

    fn alice_valid_account() -> ValidAccountId { ValidAccountId::try_from(alice_account()).unwrap() }

    fn bob_account() -> AccountId { "bob.near".to_string() }

    fn bob_valid_account() -> ValidAccountId { ValidAccountId::try_from(bob_account()).unwrap() }

    fn alice_request_key() -> RequestKey { digest(alice_secret_key()).to_string() }

    fn alice_secret_key() -> SecretKey { "be1AcEnEsBVV4UuoZ6qGGHRFK3HDwckDj7pctw83BbkR7JJsQLs7y1gbv78f1o7UkqFAHX45CA82UPT7kDdBaSL".to_string() }

    fn bob_request_key() -> RequestKey { digest(bob_secret_key()).to_string() }

    fn bob_secret_key() -> SecretKey { "WRONG_KEY_be1AcEnEsBVV4UuoZ6qGGHRFK3HDwckDj7pctw83BbkR7JJsQLs7y1gbv78f1o7UkqFAHX45CA82U".to_string() }

    fn alice_contact() -> Contact {
        Contact {
            category: ContactCategories::Telegram,
            value: "account_123".to_string(),
            account_id: 1,
        }
    }

    fn bob_contact() -> Contact {
        Contact {
            category: ContactCategories::Telegram,
            value: "account_456".to_string(),
            account_id: 2,
        }
    }

    pub fn get_context(
        predecessor_account_id: AccountId,
        attached_deposit: u128,
        is_view: bool,
    ) -> VMContext {
        VMContext {
            current_account_id: predecessor_account_id.clone(),
            signer_account_id: predecessor_account_id.clone(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 1,
            block_timestamp: 0,
            epoch_height: 1,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit,
            prepaid_gas: 10u64.pow(15),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
        }
    }

    fn ntoy(near_amount: Balance) -> Balance {
        near_amount * 10u128.pow(24)
    }

    #[test]
    fn test_storage_deposit() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

        assert_eq!(
            ntoy(100),
            contract.storage_paid(alice_valid_account()).0
        );
    }

    #[test]
    fn test_storage_deposit_and_withdraw() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));
        contract.storage_withdraw();

        assert_eq!(
            0,
            contract.storage_paid(alice_valid_account()).0
        );
    }

    #[test]
    fn whitelist_key() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

        let storage_paid_before = contract.storage_paid(alice_valid_account()).0;

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

        let storage_paid_after = contract.storage_paid(alice_valid_account()).0;
        assert!(storage_paid_before == storage_paid_after + WHITELIST_STORAGE_COST,
                "Wrong storage deposit for whitelist {} / {}", storage_paid_before, storage_paid_after);

        let alice_key = contract.get_request_key(alice_account());
        assert_eq!(alice_key, Some(alice_request_key()), "Key wasn't added");

        let bob_key = contract.get_request_key(bob_account());
        assert!(bob_key != Some(bob_request_key()), "Wrong key added");

        let alice_has_key = contract.has_request_key(alice_account());
        assert_eq!(alice_has_key, true, "Key wasn't added");

        let bob_has_key = contract.has_request_key(bob_account());
        assert_eq!(bob_has_key, false, "Wrong key added");

        let request: Request = contract.get_request(alice_request_key()).unwrap();
        assert_eq!(request.account_id, alice_account(), "Key wasn't added");
        assert!(request.account_id != bob_account(), "Wrong key added");
        assert!(request.contact == None, "Contact not empty");
    }

    #[test]
    #[should_panic(expected = "No access")]
    fn whitelist_by_user() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

        contract.whitelist_key(alice_valid_account(), bob_request_key());
    }

    #[test]
    #[should_panic(expected = "Request for this account already exist. Please remove it to continue")]
    fn whitelist_twice() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

        contract.whitelist_key(alice_valid_account(), bob_request_key());
    }

    #[test]
    #[should_panic(expected = "alice.near requires minimum storage deposit of 10000000000000000000000")]
    fn whitelist_without_storage() {
        let context = get_context(alice_account(), ntoy(1) / 1000, false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());
    }

    #[test]
    fn remove_request_after_whitelist() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));
        let storage_paid_before = contract.storage_paid(alice_valid_account()).0;

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 0, false);
        testing_env!(context.clone());

        contract.remove_request();

        let request: Option<Request> = contract.get_request(alice_request_key());
        assert!(request == None, "Request was not removed");

        let storage_paid_after = contract.storage_paid(alice_valid_account()).0;
        assert!(storage_paid_before == storage_paid_after + WHITELIST_FEE,
                "Wrong storage deposit for remove_request {} / {}", storage_paid_before, storage_paid_after);

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

        let alice_has_key = contract.has_request_key(alice_account());
        assert_eq!(alice_has_key, true, "Key wasn't added on a second time");
    }

    #[test]
    fn start_auth() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());

        let request: Request = contract.get_request(alice_request_key()).unwrap();
        assert!(request.contact == Some(alice_contact()), "Contact wasn't properly saved");
    }

    #[test]
    fn remove_request_after_start_auth() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));
        let storage_paid_before = contract.storage_paid(alice_valid_account()).0;

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());

        contract.remove_request();

        let request: Option<Request> = contract.get_request(alice_request_key());
        assert!(request == None, "Request was not removed");

        let storage_paid_after = contract.storage_paid(alice_valid_account()).0;
        assert!(storage_paid_before == storage_paid_after + WHITELIST_FEE,
                "Wrong storage deposit for remove_request {} / {}", storage_paid_before, storage_paid_after);
    }

    #[test]
    fn confirm_auth() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));
        let storage_paid_before = contract.storage_paid(alice_valid_account()).0;

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());

        let secret_key: SecretKey = digest(alice_secret_key());
        assert!(secret_key == "9f763044a36137644ca87a50545c3eff219345d8490d1c1db597105411315a9a", "Wrong secret key generation");
        contract.confirm_auth(alice_secret_key());

        let alice_is_owner = contract.is_owner(alice_account(), alice_contact());
        assert!(alice_is_owner == true, "Contact wasn't created");

        let bob_is_owner = contract.is_owner(bob_account(), alice_contact());
        assert!(bob_is_owner == false, "Wrong contact owner");

        let storage_paid_after = contract.storage_paid(alice_valid_account()).0;
        assert!(storage_paid_before > storage_paid_after,
                "Storage deposit wasn't reduced after adding an item {} / {}", storage_paid_before, storage_paid_after);
    }

    #[test]
    #[should_panic(expected = "Request not found")]
    fn confirm_auth_with_wrong_key() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());

        contract.confirm_auth(bob_secret_key());
    }

    #[test]
    #[should_panic(expected = "No access to confirm this request")]
    fn confirm_auth_with_wrong_user() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());

// switch back to a context with user
        let context = get_context(bob_account(), 1, false);
        testing_env!(context.clone());

        contract.confirm_auth(alice_secret_key());
    }

    #[test]
    #[should_panic(expected = "Contact already registered")]
    fn add_same_contact_twice() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());
        contract.confirm_auth(alice_secret_key());

// switch to bob

        let context = get_context(bob_account(), ntoy(100), false);
        testing_env!(context.clone());
        contract.storage_deposit(Some(bob_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(bob_valid_account(), bob_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());
        contract.confirm_auth(bob_secret_key());
    }

    #[test]
    fn remove_contact() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());
        contract.confirm_auth(alice_secret_key());

        assert!(contract.is_owner(alice_account(), alice_contact()) == true, "Contact wasn't created");

        contract.remove(alice_contact());

        assert!(contract.is_owner(alice_account(), alice_contact()) == false, "Contact wasn't removed");
    }

    #[test]
    #[should_panic(expected = "Contact not found")]
    fn send_to_contact() {
        let context = get_context(alice_account(), ntoy(100), false);
        testing_env!(context.clone());

        let mut contract = Contract::new(master_valid_account());

        contract.storage_deposit(Some(alice_valid_account()));

// switch to a context with master_account
        let context = get_context(master_account(), 0, false);
        testing_env!(context.clone());
        contract.whitelist_key(alice_valid_account(), alice_request_key());

// switch back to a context with user
        let context = get_context(alice_account(), 1, false);
        testing_env!(context.clone());

        contract.start_auth(alice_request_key(), alice_contact());
        contract.confirm_auth(alice_secret_key());

// send from bob

        let context = get_context(bob_account(), ntoy(75), false);
        testing_env!(context.clone());
        contract.send(alice_contact());

        let context = get_context(bob_account(), ntoy(75), false);
        testing_env!(context.clone());
        contract.send(bob_contact());
    }
}

'''
'''--- package.json ---
{
  "name": "near-auth",
  "version": "0.1.0",
  "license": "UNLICENSED",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "node contract/compile.js",
    "build:contract:debug": "node contract/compile.js --debug",
    "build:web": "export NODE_ENV=mainnet && rm -rf mainnet && parcel build src/index.html --public-url ./ && mv dist mainnet && cp src/telegram.php mainnet/telegram.php && cp src/github.php mainnet/github.php",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d dist/",
    "deploy": "npm run build && npm run deploy:contract && npm run deploy:pages",
    "prestart": "npm run build:contract:debug && npm run dev:deploy:contract",
    "start": "export PORT=39106 && echo The app is starting! It will automatically open in your browser when ready && env-cmd -f ./neardev/dev-account.env parcel src/index.html --open",
    "dev": "export NODE_ENV=testnet && export PORT=39106 && nodemon --watch contract/src -e rs --exec \"npm run start\"",
    "test": "npm run build:contract:debug && cd contract && cargo test -- --nocapture && cd .. && jest test --runInBand",
    "build:web:testnet": "export NODE_ENV=testnet && rm -rf testnet && parcel build src/index.html --public-url ./ && mv dist testnet && cp src/telegram.php testnet/telegram.php && cp src/github_testnet.php testnet/github.php",
    "build:contract:testnet": "export NODE_ENV=testnet && node contract/compile.js",
    "deploy:contract:testnet": "export NODE_ENV=testnet && near deploy",
    "build:web:all": "export NODE_ENV=mainnet && rm -rf mainnet && parcel build src/index.html --public-url ./ && mv dist mainnet && export NODE_ENV=testnet && rm -r testnet && parcel build src/index.html --public-url ./ && mv dist testnet",
    "dev:clear": "rm -r neardev"
  },
  "devDependencies": {
    "@babel/core": "~7.12.3",
    "@babel/preset-env": "~7.12.1",
    "@babel/preset-react": "~7.12.5",
    "babel-jest": "~26.6.2",
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~1.4.0",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "react-test-renderer": "~17.0.1",
    "shelljs": "~0.8.4"
  },
  "dependencies": {
    "near-api-js": "^0.36.2",
    "react": "~17.0.1",
    "react-dom": "~17.0.1",
    "react-tooltip": "~4.2.15",
    "md5": "~2.3.0",
    "react-dropdown": "~1.9.2",
    "regenerator-runtime": "~0.13.5",
    "query-string": "~6.14.1",
    "react-github-login": "~1.0.3"
  },
  "jest": {
    "moduleNameMapper": {
      "\\.(jpg|ico|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "<rootDir>/src/__mocks__/fileMock.js",
      "\\.(css|less)$": "<rootDir>/src/__mocks__/fileMock.js"
    },
    "setupFiles": [
      "<rootDir>/src/jest.init.js"
    ],
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/App.js ---
import 'regenerator-runtime/runtime'
import React from 'react'
import GitHubLogin from './GitHubLogin';

const queryString = require('query-string');
const md5 = require('md5');
import {login, logout} from './utils'
import './global.css'
import './app.css'
import * as nearAPI from 'near-api-js'
import {BN} from 'bn.js'
import ReactTooltip from 'react-tooltip';
import Dropdown from 'react-dropdown';
import 'react-dropdown/style.css';
import {useDetectOutsideClick} from "./useDetectOutsideClick";

import getConfig from './config'
import getAppSettings from './app-settings'

const config = getConfig(process.env.NODE_ENV || 'development');
const appSettings = getAppSettings();

const FRAC_DIGITS = 5;
const MIN_STORAGE_DEPOSIT = 0.02;
const REQUIRED_STORAGE_DEPOSIT = 0.015;

function ConvertToYoctoNear(amount) {
    return new BN(Math.round(amount * 100000000)).mul(new BN("10000000000000000")).toString();
}

export default function App() {
    // use React Hooks to store greeting in component state
    const [contactType, setContactType] = React.useState("Telegram");
    const [warning, setWarning] = React.useState("");
    const [complete, setComplete] = React.useState("");
    const [contacts, setContacts] = React.useState([]);
    const [userPicture, setUserPicture] = React.useState("");
    const [whiteListedKeyRemove, setWhiteListedKeyRemove] = React.useState(false)
    const [isInputContactFormAvailable, setIsInputContactFormAvailable] = React.useState(true);
    const [isGithubLoginAvailable, setIsGithubLoginAvailable] = React.useState(false);

    const [showSendForm, setShowSendForm] = React.useState(false);
    const [sendFormNearAmount, setSendFormNearAmount] = React.useState(0);
    const [sendFormType, setSendFormType] = React.useState("");
    const [sendFormContact, setSendFormContact] = React.useState("");
    const [sendFormResult, setSendFormResult] = React.useState("");

    const [showStorageDepositMenuClick, setShowStorageDepositMenuClick] = React.useState(false);
    const [hideStorageDeposit, setHideStorageDeposit] = React.useState(false);
    const [storagePaid, setStoragePaid] = React.useState(0);
    const [inputStorageDeposit, setInputStorageDeposit] = React.useState(MIN_STORAGE_DEPOSIT);
    const [incufficientStorage, setIncufficientStorage] = React.useState(true);

    // when the user has not yet interacted with the form, disable the button
    const [buttonDisabled, setButtonDisabled] = React.useState(true)

    const navDropdownRef = React.useRef(null);
    const [isNavDropdownActive, setIsNaVDropdownActive] = useDetectOutsideClick(navDropdownRef, false);

    // after submitting the form, we want to show Notification
    const [showNotification, setShowNotification] = React.useState(false)

    const Warning = () => {
        return (
            !warning ? null :
                <div className="warning" dangerouslySetInnerHTML={{__html: warning}}/>)
    };

    const Complete = () => {
        return (
            !complete ? null :
                <div className="complete" dangerouslySetInnerHTML={{__html: complete}}/>)
    };

    //const FULL_GAS = 300000000000000;
    const FULL_GAS = 200000000000000;

    const WhiteListedKeyRemove = () => {
        return (
            !whiteListedKeyRemove ? null :
                <div>
                    <button
                        className="abort-previous-button"
                        onClick={async event => {
                            event.preventDefault()
                            try {
                                await window.contract.remove_request({}, FULL_GAS);
                                setWhiteListedKeyRemove(false);
                            } catch (e) {
                                alert(
                                    'Something went wrong! \n' +
                                    'Check your browser console for more info.\n' +
                                    e.toString()
                                )
                                throw e
                            }

                            setShowNotification({method: "call", data: "remove_request"});
                            setTimeout(() => {
                                setShowNotification("")
                            }, 11000)
                        }}
                    >
                        Abort previous auth attempt
                    </button>
                </div>
        )
    };

    function timeout(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function sleep(fn, ...args) {
        await timeout(3000);
        return fn(...args);
    }

    const OnGithubLoginSuccess = async (response) => {
        let goOn = response && response.hasOwnProperty("code");
        if (goOn) {
            setComplete("Github auth request found. Processing... ");

            while (goOn) {
                var [parents] = await Promise.all([
                    await fetch("telegram.php", {
                        method: 'POST',
                        body: JSON.stringify({
                            operation: "start",
                            account_id: window.accountId,
                            contact: response.code,
                            contact_type: contactType,
                            network: config.networkId,
                        }),
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    })
                        .then(response => response.json())
                        .then(async data => {
                            if (data.status) {
                                goOn = false;
                                setComplete(data.text);
                                setWarning("");

                                data.category = contactType.toLowerCase()
                                window.localStorage.setItem('request', data ? JSON.stringify(data) : "[]");

                                try {
                                    await window.contract.start_auth({
                                        request_key: data.request_key,
                                        contact: {category: contactType, value: data.contact},
                                    }, FULL_GAS, 1)
                                } catch (e) {
                                    ContractCallAlert();
                                    throw e
                                }

                            } else {
                                setComplete("");
                                if (data.value === "already_has_key") {
                                    goOn = false;
                                    setWhiteListedKeyRemove(true);
                                    setWarning(data.text);
                                } else if (data.value === "contact_already_exists") {
                                    goOn = false;
                                    setWarning(data.text);
                                } else {
                                    setWarning("Auth failed. Please check console for details.");
                                    console.log(data);
                                }
                            }
                            window.history.replaceState({}, document.title, "/");
                        })
                        .catch(err => console.error("Error:", err)),

                    timeout(500)
                ]);
            }
        }
    }
    const OnGithubLoginFailure = (response) => {
        console.log("Github Login Failure");
        console.error(response);
    }

    const LoginGithub = () => {
        const url = (config.networkId === "testnet") ? appSettings.urlTestnet : appSettings.urlMainnet;
        if (isGithubLoginAvailable && incufficientStorage)
            return <button disabled={true}>Not available</button>;
        else
            return isGithubLoginAvailable
                ? <GitHubLogin clientId="4fe06f510cf9e8f40028"
                               redirectUri={`${url}github.php`}
                               scope='user:email'
                               className="github-login-button"
                               onSuccess={OnGithubLoginSuccess}
                               onFailure={OnGithubLoginFailure}/>
                : null;
    };

    const StoragePaid = () => {
        if (window.walletConnection.isSignedIn()) {
            return <div className="nav user-balance" data-tip="Your Near Auth Storage"
                        onClick={async event => {
                            setShowStorageDepositMenuClick(true)
                        }}>
                {`Storage: ${storagePaid} Ⓝ`}
            </div>;
        } else {
            return null;
        }
    };

    const Header = () => {
        return <div className="nav-container">
            <div className="nav-header">
                <NearLogo/>
                <UserPicture/>
                <div className="nav-item user-name">{window.accountId}</div>
                <StoragePaid/>
                <div className="nav align-right">
                    <NavMenu/>
                    <div className="account-sign-out">
                        <button className="link" style={{float: 'right'}} onClick={logout}>
                            Sign out
                        </button>
                    </div>
                </div>
            </div>
        </div>
    };

    const Footer = () => {
        return <div className="footer">
            <div className="github">
                <div className="build-on-near"><a href="https://nearspace.info">BUILD ON NEAR</a></div>
                <div className="brand">Near {appSettings.appNme} | <a href={appSettings.github}
                                                                      rel="nofollow"
                                                                      target="_blank">Open Source</a></div>
            </div>
            <div className="promo">
                Made by <a href="https://near.zavodil.ru/" rel="nofollow" target="_blank">Zavodil node</a>
            </div>
        </div>
    };

    const UserPicture = () => {
        return userPicture ?
            <div className="user-picture"><img
                src={"http://www.gravatar.com/avatar/" + md5(userPicture) + ".jpg?s=30"}/></div> : null;
    }

    const NearLogo = () => {
        return <div className="logo-container content-desktop">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 414 162" className="near-logo">
                <g id="Layer_1" data-name="Layer 1">
                    <path className="polymorph"
                          d="M207.21,54.75v52.5a.76.76,0,0,1-.75.75H201a7.49,7.49,0,0,1-6.3-3.43l-24.78-38.3.85,19.13v21.85a.76.76,0,0,1-.75.75h-7.22a.76.76,0,0,1-.75-.75V54.75a.76.76,0,0,1,.75-.75h5.43a7.52,7.52,0,0,1,6.3,3.42l24.78,38.24-.77-19.06V54.75a.75.75,0,0,1,.75-.75h7.22A.76.76,0,0,1,207.21,54.75Z"
                    ></path>
                    <path className="polymorph"
                          d="M281,108h-7.64a.75.75,0,0,1-.7-1L292.9,54.72A1.14,1.14,0,0,1,294,54h9.57a1.14,1.14,0,0,1,1.05.72L324.8,107a.75.75,0,0,1-.7,1h-7.64a.76.76,0,0,1-.71-.48l-16.31-43a.75.75,0,0,0-1.41,0l-16.31,43A.76.76,0,0,1,281,108Z"
                    ></path>
                    <path className="polymorph"
                          d="M377.84,106.79,362.66,87.4c8.57-1.62,13.58-7.4,13.58-16.27,0-10.19-6.63-17.13-18.36-17.13H336.71a1.12,1.12,0,0,0-1.12,1.12h0a7.2,7.2,0,0,0,7.2,7.2H357c7.09,0,10.49,3.63,10.49,8.87s-3.32,9-10.49,9H336.71a1.13,1.13,0,0,0-1.12,1.13v26a.75.75,0,0,0,.75.75h7.22a.76.76,0,0,0,.75-.75V87.87h8.33l13.17,17.19a7.51,7.51,0,0,0,6,2.94h5.48A.75.75,0,0,0,377.84,106.79Z"
                    ></path>
                    <path className="polymorph"
                          d="M258.17,54h-33.5a1,1,0,0,0-1,1h0A7.33,7.33,0,0,0,231,62.33h27.17a.74.74,0,0,0,.75-.75V54.75A.75.75,0,0,0,258.17,54Zm0,45.67h-25a.76.76,0,0,1-.75-.75V85.38a.75.75,0,0,1,.75-.75h23.11a.75.75,0,0,0,.75-.75V77a.75.75,0,0,0-.75-.75H224.79a1.13,1.13,0,0,0-1.12,1.13v29.45a1.12,1.12,0,0,0,1.12,1.13h33.38a.75.75,0,0,0,.75-.75v-6.83A.74.74,0,0,0,258.17,99.67Z"
                    ></path>
                    <path className="polymorph"
                          d="M108.24,40.57,89.42,68.5a2,2,0,0,0,3,2.63l18.52-16a.74.74,0,0,1,1.24.56v50.29a.75.75,0,0,1-1.32.48l-56-67A9.59,9.59,0,0,0,47.54,36H45.59A9.59,9.59,0,0,0,36,45.59v70.82A9.59,9.59,0,0,0,45.59,126h0a9.59,9.59,0,0,0,8.17-4.57L72.58,93.5a2,2,0,0,0-3-2.63l-18.52,16a.74.74,0,0,1-1.24-.56V56.07a.75.75,0,0,1,1.32-.48l56,67a9.59,9.59,0,0,0,7.33,3.4h2a9.59,9.59,0,0,0,9.59-9.59V45.59A9.59,9.59,0,0,0,116.41,36h0A9.59,9.59,0,0,0,108.24,40.57Z"
                    ></path>
                </g>
            </svg>
            <div className="app-name">
                <a href="/">Near {appSettings.appNme}</a>
            </div>
        </div>;
    };

    const NavMenu = () => {
        const onClick = () => setIsNaVDropdownActive(!isNavDropdownActive);

        return (
            <div className="nav-menu container">
                <div className="menu-container">
                    <button onClick={onClick} className="menu-trigger">
                        <span className="network-title">{config.networkId}</span>
                        <div className="network-icon"></div>
                    </button>
                    <nav
                        ref={navDropdownRef}
                        className={`menu ${isNavDropdownActive ? "active" : "inactive"}`}
                    >
                        <ul>
                            <li>
                                <a href={appSettings.urlMainnet}>Mainnet</a>
                            </li>
                            <li>
                                <a href={appSettings.urlTestnet}>Testnet</a>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>
        );
    };

    const GetStoragePaid = async () => {
        const storagePaid = await window.contract.storage_paid({
            account_id: window.accountId
        });
        const storagePaidFormatted = storagePaid && Number(storagePaid)
            ? nearAPI.utils.format.formatNearAmount(storagePaid, FRAC_DIGITS).replace(",", "")
            : "0";
        setStoragePaid(storagePaidFormatted);

        setIncufficientStorage(Number(storagePaidFormatted) < 0.0101);

        return storagePaidFormatted;
    };

    React.useEffect(
        async () => {

            // in this case, we only care to query the contract when signed in
            if (window.walletConnection.isSignedIn()) {
                await GetStoragePaid().then((storagePaidFormatted) => {
                    console.log(storagePaidFormatted);
                });

                try {
                    let requestRound = false;

                    if (location.search) {
                        const query = JSON.parse(JSON.stringify(queryString.parse(location.search)));
                        if (query && query.hasOwnProperty("key") && query.hasOwnProperty("contact") && query.hasOwnProperty("type")) {
                            const request_key = await window.contract.get_request_key({
                                account_id: window.accountId
                            });

                            const has_request_key = await window.contract.has_request_key({
                                account_id: window.accountId
                            });

                            if (has_request_key && request_key) {
                                setComplete("Auth request found. Processing... ");

                                await window.contract.confirm_auth({
                                        key: query.key,
                                    }, FULL_GAS
                                )
                                    .then(data => {
                                        if (data.status) {
                                            setComplete(data.text);
                                            setWarning("");
                                        } else {
                                            setComplete("");
                                            setWarning("");
                                            //setWarning("Auth failed. Please check console for details.");
                                            console.log(data.text);
                                        }
                                        GetStoragePaid();
                                        window.history.replaceState({}, document.title, "/");
                                        requestRound = true;
                                    })
                                    .catch(err => console.error("Error:", err));
                            } else {
                                window.localStorage.setItem('request', "[]");
                                window.history.replaceState({}, document.title, "/");
                            }
                        } else if (query && query.hasOwnProperty("action")) {
                            if (query.action === "send" && query.hasOwnProperty("contact") && query.hasOwnProperty("type") && query.hasOwnProperty("amount")) {
                                const type = query.type;
                                console.log(query);
                                console.log(Number(query.amount));
                                if (dropdownOptions.includes(type)) {
                                    setShowSendForm(true);
                                    setSendFormContact(query.contact);
                                    setSendFormType(type);
                                    setSendFormNearAmount(Number(query.amount));
                                }
                            }

                        }
                    }
                    if (!requestRound)
                        await GetRequest();

                    await GetContacts();
                } catch (e) {
                    console.log(e)
                }
                // window.contract is set by initContract in index.js

            }
        },

        // The second argument to useEffect tells React when to re-run the effect
        // Use an empty array to specify "only run on first render"
        // This works because signing into NEAR Wallet reloads the page
        []
    )

    // if not signed in, return early with sign-in prompt
    if (!window.walletConnection.isSignedIn()) {
        return (
            <>
                <Header/>
                <main>
                    <h1>Near {appSettings.appNme}</h1>
                    <p>
                        {appSettings.appDescription}
                    </p>
                    <p>
                        To make use of the NEAR blockchain, you need to sign in. The button
                        below will sign you in using NEAR Wallet.
                    </p>
                    <p style={{textAlign: 'center', marginTop: '2.5em'}}>
                        <button onClick={login}>Sign in</button>
                    </p>
                </main>
                <Footer/>
            </>
        )
    }
    const dropdownOptions = [
        'Telegram', 'Email', 'Github'
    ];

    const Contacts = () => {
        let i = 0;
        return contacts.length ?
            <div className="contacts">
                <div>Your contacts:</div>
                <ul className="accounts">
                    {Object.keys(contacts).map(function (key) {
                        return <li key={contacts[key].value + "-" + i++}>
                            <div className="account">{contacts[key].value}</div>
                            <div className="type">{contacts[key].category}</div>
                            <div className="type"><RemoveContact contact={contacts[key]}/></div>
                        </li>;
                    })}
                </ul>
            </div> :
            null;
    }

    const RemoveContact = (props) => {
        return (
            <button
                type="clear"
                className="remove-contact"
                title="Remove Contact"
                onClick={async event => {
                    event.preventDefault()
                    try {
                        await window.contract.remove({
                                contact: props.contact,
                            },
                            100000000000000, 0).then(() => GetContacts());

                    } catch (e) {
                        alert(
                            'Something went wrong! \n' +
                            'Check your browser console for more info.\n' +
                            e.toString()
                        )
                        throw e
                    }

                }}
            >
                ✗
            </button>
        )
    }

    const GetContacts = async () => {
        try {
            const contacts = await window.contract.get_contacts({
                account_id: window.accountId
            });

            if (contacts) {
                Object.keys(contacts).map(function (key) {
                    if (!userPicture && contacts[key].category === "Email")
                        setUserPicture(contacts[key].value);
                });

                setContacts(contacts);
            }
        } catch (e) {
            console.log(e)
        }
    }

    const GetRequest = async () => {
        try {
            const request_key = await window.contract.get_request_key({
                account_id: window.accountId
            });

            if (request_key) {
                const request = await window.contract.get_request({
                    request_key: request_key
                });

                let queryHasKey = false;
                if (location.search) {
                    const query = JSON.parse(JSON.stringify(queryString.parse(location.search)));
                    queryHasKey = query && query.hasOwnProperty("key");
                }

                if (!queryHasKey && request && request.contact && request.contact.value) {
                    setHideStorageDeposit(true);
                    setComplete("Auth request found. Processing... ");
                    console.log("Request found");
                    const request = JSON.parse(window.localStorage.getItem('request'));
                    if (request.hasOwnProperty("request_key")) {
                        fetch("telegram.php", {
                            method: 'POST',
                            body: JSON.stringify({
                                operation: "send",
                                contact: request.contact,
                                contact_type: request.category || request.contact_type,
                                telegram_id: request.value,
                                request_key: request.request_key,
                                account_id: window.accountId,
                                network: config.networkId,
                                additional_contact: request.additional_contact
                            }),
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (data.status) {
                                    setComplete(data.text);
                                    setWarning("");
                                } else {
                                    setWarning(data.text);
                                    setComplete("");
                                    if (data.text == "Active request found, key already sent") {
                                        setHideStorageDeposit(true);
                                    }
                                }
                            })
                            .catch(err => console.error("Error:", err));
                    }
                }
            } else {
                window.localStorage.setItem('request', "[]");
            }
        } catch (e) {
            console.log(e)
        }
    };

    const ChangeContactType = (value) => {
        setIsInputContactFormAvailable(value !== "Github");
        setIsGithubLoginAvailable(value === "Github");

        setContactType(value)
    }

    return (
        // use React Fragment, <>, to avoid wrapping elements in unnecessary divs
        <>
            <Header/>
            <main>
                <div className="background-img"></div>
                <h1>
                    Near {appSettings.appNme}
                </h1>

                <Warning/>
                <Complete/>
                <WhiteListedKeyRemove/>

                {(showStorageDepositMenuClick || (!hideStorageDeposit && storagePaid < REQUIRED_STORAGE_DEPOSIT)) &&
                <div style={{paddingBottom: "20px"}}>
                    <fieldset id="fieldset-storage-deposit">
                        <label
                            htmlFor="storage-deposit"
                            style={{
                                display: 'block',
                                color: 'var(--gray)',
                                marginBottom: '0.5em'
                            }}
                        >
                            {storagePaid < REQUIRED_STORAGE_DEPOSIT
                                ? `Storage deposit is needed, at least ${REQUIRED_STORAGE_DEPOSIT} NEAR`
                                : "Storage Deposit"
                            }
                            :
                        </label>
                        <div style={{display: 'flex', paddingBottom: "15px"}}>

                            <input
                                autoComplete="off"
                                defaultValue={inputStorageDeposit}
                                id="storage-deposit"
                                onChange={e => setInputStorageDeposit(e.target.value)}
                                placeholder="Enter amount"
                                style={{flex: 1}}
                            />
                            <button
                                style={{borderRadius: '0 5px 5px 0'}}
                                onClick={async event => {
                                    event.preventDefault()
                                    try {
                                        await window.contract.storage_deposit({},
                                            100000000000000, ConvertToYoctoNear(inputStorageDeposit)).then(() => GetStoragePaid());

                                    } catch (e) {
                                        alert(
                                            'Something went wrong! \n' +
                                            'Check your browser console for more info.\n' +
                                            e.toString()
                                        )
                                        throw e
                                    }

                                }}
                            >
                                Deposit
                            </button>
                        </div>
                        {storagePaid > 0 &&
                        <button
                            style={{borderRadius: '5px'}}
                            onClick={async event => {
                                event.preventDefault()
                                try {
                                    await window.contract.storage_withdraw({},
                                        100000000000000, 1).then(() => GetStoragePaid());

                                } catch (e) {
                                    alert(
                                        'Something went wrong! \n' +
                                        'Check your browser console for more info.\n' +
                                        e.toString()
                                    )
                                    throw e
                                }
                            }}
                        >
                            Withdraw {storagePaid} from storage
                        </button>
                        }
                    </fieldset>
                </div>
                }

                <form className="main-form" onSubmit={async event => {
                    event.preventDefault()
                    /* генерим ключи на сервере, сразу сохраняем по account_id
                    когда есть реквест, проверяем ключ из базы, отправляем
                    когда подписываем, удаляем ключ из базы
                     */

                    // get elements from the form using their id attribute
                    const {fieldset, contact} = event.target.elements
                    fieldset.disabled = true;
                    setButtonDisabled(true);

                    const has_request_key = await window.contract.has_request_key({
                        account_id: window.accountId
                    });

                    if (has_request_key) {
                        setWarning("Previous auth attempt was not finished. Please abort previous attempt first.");
                        setWhiteListedKeyRemove(true);
                        return;
                    }

                    try {
                        if (contact && contactType) {

                            await fetch("telegram.php", {
                                method: 'POST',
                                body: JSON.stringify({
                                    operation: "start",
                                    contact: contact.value,
                                    account_id: window.accountId,
                                    contact_type: contactType,
                                    network: config.networkId
                                }),
                                headers: {
                                    'Accept': 'application/json',
                                    'Content-Type': 'application/json'
                                }
                            })
                                .then(response => response.json())
                                .then(async data => {
                                    console.log(data);
                                    if (!data.status) {
                                        setWarning(data.text);
                                        if (data.value === "already_has_key")
                                            setWhiteListedKeyRemove(true);
                                    } else {
                                        setWarning("");
                                        console.log("contact");
                                        console.log(contact);
                                        data.contact = contact.value;
                                        data.contact_type = contactType.toLowerCase()
                                        window.localStorage.setItem('request', data ? JSON.stringify(data) : "[]");

                                        let contactMetadata =
                                            (data.contact_type === "telegram")
                                                ? {
                                                    category: contactType,
                                                    value: contact.value,
                                                    account_id: Number(data.value)
                                                }
                                                : {
                                                    category: contactType,
                                                    value: contact.value
                                                };

                                        try {
                                            await window.contract.start_auth({
                                                request_key: data.request_key,
                                                contact: contactMetadata,
                                            }, FULL_GAS, 1)
                                        } catch (e) {
                                            ContractCallAlert();
                                            throw e
                                        }

                                        /*
                                        console.log("3")
                                        if (!warning)
                                            fetch("telegram.php", {
                                                method: 'POST',
                                                body: JSON.stringify({
                                                    operation: "send",
                                                    telegram_id: data.value,
                                                    key: keypair.secretKey
                                                }),
                                                headers: {
                                                    'Accept': 'application/json',
                                                    'Content-Type': 'application/json'
                                                }
                                            })
                                                .then(response => response.json())
                                                .then(data => {
                                                    if (data.status) {
                                                        setComplete(data.text);
                                                    }
                                                })
                                                .catch(err => console.error("Error:", err));
                                        */
                                    }
                                });
                        }
                    } catch (e) {
                        ContractCallAlert();
                        throw e
                    } finally {
                        // re-enable the form, whether the call succeeded or failed
                        fieldset.disabled = false;
                        setButtonDisabled(false);
                    }

                    // update local `greeting` variable to match persisted value
                    //set_greeting(newGreeting)

                    // show Notification
                    setShowNotification(true)

                    // remove Notification again after css animation completes
                    // this allows it to be shown again next time the form is submitted
                    setTimeout(() => {
                        setShowNotification(false)
                    }, 11000)
                }}>
                    <fieldset id="fieldset">
                        <label
                            htmlFor="contact"
                            style={{
                                display: 'block',
                                color: 'var(--gray)',
                                marginBottom: '0.5em'
                            }}
                        >
                            Auth social account
                        </label>
                        <div style={{display: 'flex'}}>

                            <Dropdown
                                options={dropdownOptions}
                                onChange={e => ChangeContactType(e.value)}
                                value={dropdownOptions[0]}
                                placeholder="Select an option"/>

                            {isInputContactFormAvailable &&
                            <>
                                <input
                                    autoComplete="off"
                                    defaultValue=""
                                    id="contact"
                                    onChange={e => setButtonDisabled(!e.target.value)}
                                    placeholder="Enter account handler"
                                    style={{flex: 1}}
                                />
                                <button
                                    disabled={buttonDisabled || incufficientStorage}
                                    style={{borderRadius: '0 5px 5px 0'}}
                                >
                                    Send
                                </button>
                            </>
                            }

                            <LoginGithub/>

                        </div>
                    </fieldset>
                </form>

                <Contacts/>

                {showSendForm ?
                    <div className="send-form">
                        <fieldset id="fieldset">
                            <label
                                htmlFor="contact"
                                style={{
                                    display: 'block',
                                    color: 'var(--gray)',
                                    marginBottom: '0.5em'
                                }}
                            >
                                Send tokens by social network handler
                            </label>
                            <div style={{display: 'flex'}}>

                                <Dropdown
                                    options={dropdownOptions}
                                    onChange={e => setSendFormType(e.value)}
                                    value={sendFormType}
                                    placeholder="Select an option"/>

                                <input
                                    autoComplete="off"
                                    defaultValue={sendFormContact}
                                    id="send-contact"
                                    className="send-contact"
                                    onChange={e => setSendFormContact(e.target.value)}
                                    placeholder="Enter account handler"
                                    style={{flex: 1}}
                                />

                                <input
                                    autoComplete="off"
                                    defaultValue={sendFormNearAmount}
                                    id="send-amount"
                                    className="send-amount"
                                    onChange={e => setSendFormNearAmount(e.target.value)}
                                    placeholder="Enter amount"
                                />

                                <button
                                    style={{borderRadius: '0 5px 5px 0'}}
                                    onClick={async event => {
                                        event.preventDefault()
                                        try {
                                            let owner = "";
                                            if(sendFormType.toLowerCase() !== "telegram") {
                                                owner = await window.contract.get_account_for_contact({
                                                    "contact":
                                                        {"category": sendFormType, "value": sendFormContact}
                                                });
                                            }

                                            console.log(sendFormContact + " " + owner);

                                            if (owner !== "") {
                                                setSendFormResult("Contact was not found. Abort")
                                            } else {
                                                try {
                                                    await window.contract.send({
                                                        "contact":
                                                            {"category": sendFormType, "value": sendFormContact}
                                                    }, FULL_GAS, ConvertToYoctoNear(sendFormNearAmount))

                                                    setShowNotification({method: "call", data: "send"});
                                                    setTimeout(() => {
                                                        setShowNotification("")
                                                    }, 11000)
                                                } catch (e) {
                                                    ContractCallAlert();
                                                    throw e
                                                }
                                            }

                                        } catch (e) {
                                            alert(
                                                'Something went wrong! \n' +
                                                'Check your browser console for more info.\n' +
                                                e.toString()
                                            )
                                            throw e
                                        }

                                    }}
                                >
                                    Send
                                </button>

                            </div>
                        </fieldset>

                        {sendFormResult ?
                            <div className="warning">{sendFormResult}</div>
                            : null
                        }
                    </div>
                    : null
                }

            </main>
            <Footer/>

            {showNotification && Object.keys(showNotification) &&
            <Notification method={showNotification.method} data={showNotification.data}/>}
            <ReactTooltip/>
        </>
    )
}

function getNearAccountConnection() {
    if (!window.connection) {
        const provider = new nearAPI.providers.JsonRpcProvider(config.nodeUrl);
        window.connection = new nearAPI.Connection(config.nodeUrl, provider, {});
    }
    return window.connection;
}

function Notification(props) {
    const urlPrefix = `https://explorer.${config.networkId}.near.org/accounts`
    if (props.method === "call")
        return (
            <aside>
                <a target="_blank" rel="noreferrer" href={`${urlPrefix}/${window.accountId}`}>
                    {window.accountId}
                </a>
                {' '/* React trims whitespace around tags; insert literal space character when needed */}
                called method: '{props.data}' in contract:
                {' '}
                <a target="_blank" rel="noreferrer" href={`${urlPrefix}/${window.contract.contractId}`}>
                    {window.contract.contractId}
                </a>
                <footer>
                    <div>✔ Succeeded</div>
                    <div>Just now</div>
                </footer>
            </aside>
        )
    else if (props.method === "text")
        return (
            <aside>
                {props.data}
                <footer>
                    <div>✔ Succeeded</div>
                    <div>Just now</div>
                </footer>
            </aside>
        )
    else return (
            <aside/>
        )
}

function ContractCallAlert() {
    alert(
        'Something went wrong! ' +
        'Maybe you need to sign out and back in? ' +
        'Check your browser console for more info.'
    );
}
'''
'''--- src/GitHubLogin.js ---
import React, { Component } from 'react';
import PropTypes from 'prop-types';

import PopupWindow from './PopupWindow';
import { toQuery } from './utils';

class GitHubLogin extends Component {
    static propTypes = {
        buttonText: PropTypes.string,
        children: PropTypes.node,
        className: PropTypes.string,
        clientId: PropTypes.string.isRequired,
        onRequest: PropTypes.func,
        onSuccess: PropTypes.func,
        onFailure: PropTypes.func,
        redirectUri: PropTypes.string,
        scope: PropTypes.string,
    }

    static defaultProps = {
        buttonText: 'Sign in with GitHub',
        redirectUri: '',
        scope: 'user:email',
        onRequest: () => {},
        onSuccess: () => {},
        onFailure: () => {},
    }

    onBtnClick = () => {
        const { clientId, scope, redirectUri } = this.props;
        const search = toQuery({
            client_id: clientId,
            scope,
            redirect_uri: redirectUri,
        });
        const popup = this.popup = PopupWindow.open(
            'github-oauth-authorize',
            `github.php`,
            { height: 1000, width: 600 }
        );

        this.onRequest();
        popup.then(
            data => this.onSuccess(data),
            error => this.onFailure(error)
        );
    }

    onRequest = () => {
        this.props.onRequest();
    }

    onSuccess = (data) => {
        if (!data.code) {
            return this.onFailure(new Error('\'code\' not found'));
        }

        this.props.onSuccess(data);
    }

    onFailure = (error) => {
        this.props.onFailure(error);
    }

    render() {
        const { className, buttonText, children } = this.props;
        const attrs = { onClick: this.onBtnClick };

        if (className) {
            attrs.className = className;
        }

        return <button {...attrs}>{ children || buttonText }</button>;
    }
}

export default GitHubLogin;
'''
'''--- src/PopupWindow.js ---
import { toParams, toQuery } from './utils';

class PopupWindow {
    constructor(id, url, options = {}) {
        this.id = id;
        this.url = url;
        this.options = options;
    }

    open() {
        const { url, id, options } = this;

        this.window = window.open(url, id, toQuery(options, ','));
    }

    close() {
        this.cancel();
        this.window.close();
    }

    poll() {
        this.promise = new Promise((resolve, reject) => {
            this._iid = window.setInterval(() => {
                try {
                    const popup = this.window;

                    if (!popup || popup.closed !== false) {
                        this.close();

                        reject(new Error('The popup was closed'));

                        return;
                    }

                    if (popup.location.href === this.url || popup.location.pathname === 'blank') {
                        return;
                    }

                    const params = toParams(popup.location.search.replace(/^\?/, ''));

                    resolve(params);

                    this.close();
                } catch (error) {
                    /*
                     * Ignore DOMException: Blocked a frame with origin from accessing a
                     * cross-origin frame.
                     */
                }
            }, 500);
        });
    }

    cancel() {
        if (this._iid) {
            window.clearInterval(this._iid);
            this._iid = null;
        }
    }

    then(...args) {
        return this.promise.then(...args);
    }

    catch(...args) {
        return this.promise.then(...args);
    }

    static open(...args) {
        const popup = new this(...args);

        popup.open();
        popup.poll();

        return popup;
    }
}

export default PopupWindow;
'''
'''--- src/app-settings.js ---
function getAppSettings() {
    return {
        urlMainnet: "https://auth.nearspace.info/",
        urlTestnet: "https://testnet.auth.nearspace.info/",
        appNme: "Auth",
        appDescription: "Auth your social network on NEAR",
        github: "https://github.com/zavodil/near-auth"
    };
}

module.exports = getAppSettings
'''
'''--- src/app.css ---
.Dropdown-root{
    width: 150px;
}

.Dropdown-arrow{
    margin-top: 8px;
}

.Dropdown-control{
    background-color: var(--shadow) !important;
}

.send-form{
    padding-top: 30px;
}

.send-contact{
    width: 250px;
}

.send-amount{
    width: 100px
}

.warning{
    border: 1px solid darkred;
    background-color: pink;
    padding: 10px;
    margin-bottom: 10px;
}

.complete{
    border: 1px solid darkgreen;
    background-color: lightgreen;
    padding: 10px;
    margin-bottom: 10px;
}

ul.accounts {
    list-style: inside;
    padding: 0;
    margin: 0;
}

ul.accounts li {
    padding-bottom: 0;
}

ul.accounts li .account {
    font-size: 20px;
}

.contacts {
    padding-top: 20px;
}

ul.accounts .type{
    font-size: 15px;
    padding-left: 10px;
    padding-top: 5px;
    color: var(--gray);
}
ul.accounts div {
    display: inline-block;
    vertical-align: top;
}

.app-name a{
    color: white;
    text-decoration: none;
}

.user-picture{
    padding-left: 10px;
}

.user-picture img{
    border-radius: 5px;
    margin-top: 5px;
}

.main-form{
    padding-top: 10px;
}

.github-login-button{
    margin-left: 10px;
}

.abort-previous-button{
    margin-bottom: 10px;
}

.user-balance{
    cursor: pointer;
}

.remove-contact{
    background-color: initial;
    color: darkred;
    padding: 0;
}
'''
'''--- src/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- src/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'auth.name.near'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: "dev-1625611642901-32969379055293",
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- src/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --secondary: #0072CE;
  --secondary-bg: #0072CE;
  --header-font-color: #efefef;

  --header-primary-color: #FFF;
  --header-secondary-color: #555;
  --header-nav-height: 50px;
  --footer-height: 34px;
  --nav-background-color: rgb(19, 47, 76);

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 0;
  font-family: BwSeidoRound, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
  'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
  sans-serif;
}

.background-img {
  position: absolute;
  right: 0;
  z-index: -1;
  background-image: url(/assets/explorer-bg.svg);
  width: 504px;
  height: 324px;
}

@font-face {
  font-family: BwSeidoRound;
  src: url(./fonts/389947_6_0.eot);
  src: url(./fonts/389947_6_0.eot?#iefix) format("embedded-opentype"), url(./fonts/389947_6_0.woff2) format("woff2"), url(./fonts/389947_6_0.woff) format("woff"), url(./fonts/389947_6_0.ttf) format("truetype");
  font-weight: 500;
  font-style: normal
}

main {
  margin: 0 auto;
  max-width: 25em;
  padding-top: var(--header-nav-height);
  padding-bottom: var(--footer-height);
}

h1 {
  background-image: url(assets/logo.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 3.5em 0 0.5em;
  text-align: center;
}

a,
.link {
  text-decoration: none;
}

a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}

a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}

button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}

button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}

button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}

[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}

[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}

[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}

@keyframes loader {
  0% {
    transform: rotate(0deg)
  }
  100% {
    transform: rotate(360deg)
  }
}

fieldset {
  border: none;
  padding: 0.1em 0 0 0;
}

input {
  background-color: var(--shadow);
  border: none;
  color: inherit;
  padding: 0.25em 1em;
}

input::selection {
  background-color: var(--secondary);
  color: #efefef;
}

input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}

li {
  padding-bottom: 1em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}

aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}

aside footer *:first-child {
  color: var(--success);
}

aside footer *:last-child {
  color: var(--gray);
}

@keyframes notify {
  0% {
    transform: translateY(10em)
  }
  5% {
    transform: translateY(0)
  }
  95% {
    transform: translateY(0)
  }
  100% {
    transform: translateY(10em)
  }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }

  h1 {
    background-image: url(assets/logo-white.svg);
  }

  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

.send-button, .deposit-button, .deposit-send-button {
  border-radius: 5px;
  margin-right: 1em;
}

.action-buttons {
  padding-top: 0.2em;
  font-size: 0.8em
}

.hidden {
  display: none;
}

/* FOOTER */

.footer {
  width: 100%;
  background-color: var(--light-gray);
  color: var(--fg);
  height: 35px;
  position: fixed;
  left: 0;
  bottom: 0;
  display: flex;
}

.footer a {
  color: var(--fg)
}

.footer div {
  display: inline-block;
  font-size: 0.8em;
  padding-bottom: 0.3em;
}

.footer .build-on-near {
  cursor: pointer;
  padding: 0.2em 0.3em 0.1em 0.3em;
  margin: 0 0.3em 0 0.75em;
  background-color: var(--nav-background-color);
  height: var(--footer-height);
}

.footer .build-on-near a {
  color: white
}

.footer .github {
  padding-left: 5px;
}

.footer .github {
  display: flex;
  max-width: 50%;
  width: 50%;
}

.footer .promo, .footer .github {
  margin-top: 5px;
}

.footer .promo {
  text-align: right;
  flex: 1;
}

.footer .github .brand {
  padding-top: 3px;
}

/* HEADER */

.nav-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
}

.nav-header {
  color: white;
  position: relative;
  font-size: 0.8em;
  margin-bottom: 20px;
  padding-left: 15px;
  box-shadow: rgba(0, 0, 0, 0.17) 0px 5px 9px -1px;
  background-color: var(--nav-background-color);
  height: var(--header-nav-height);
  -webkit-box-align: center;
  align-items: center;
  display: flex;
  cursor: default;
}

.nav-header .user-name {
  white-space: nowrap;
  margin-left: 5px;
}

.nav-header .user-balance {
  margin-left: 10px;
  white-space: nowrap;
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
  background-color: black;
  padding: 2px 10px;
  border-radius: 40px;
  font-size: 14px;
  color: rgb(143, 214, 189);
}

.nav-header .nav-item {
  display: flex;
}

.nav-header .near-logo {
  width: 100px;
  height: 50px;
  fill: var(--header-primary-color);
}

.nav-header .logo-container {
  border-right: 2px solid rgb(93, 95, 96);
  color: var(--header-primary-color);
  align-items: center;
  justify-content: center;
  display: flex;
}

.nav-header .logo-container .app-name {
  padding-right: 10px;
  color: var(--header-primary-color);
}

.nav-header .align-right {
  display: flex;
  margin-left: auto;
  order: 2;
  align-items: center;
  justify-content: center;
}

.footer .promo {
  padding-right: 5px;
  float: right;
  vertical-align: top;
  height: 100%;
}

/* NAV MENU */

.nav-menu .network-icon {
  background-image: url(/assets/icon-network-right.svg);
  border-radius: 0;
  width: 15px;
  height: 15px;
}

.nav-menu .network-title {
  text-transform: capitalize;
  color: var(--header-secondary-color);
}

.menu-container {
  position: relative;
}

.menu {
  background: #ffffff;
  border-radius: 8px;
  position: absolute;
  top: 30px;
  right: 0;
  width: 95px;
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.3);
  opacity: 0;
  visibility: hidden;
  transform: translateY(-20px);
  transition: opacity 0.4s ease, transform 0.4s ease, visibility 0.4s;
}

.menu.active {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

.menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.menu li {
  padding-left: 10px;
  border-bottom: 1px solid #dddddd;
  padding-bottom: 0;
}

.menu li a {
  text-decoration: none;
  color: #333333;
  padding: 5px;
  display: block;
  font-size: 0.6em;
}

.menu-trigger {
  background: #ffffff;
  border-radius: 90px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 6px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  border: none;
  vertical-align: middle;
  transition: box-shadow 0.4s ease;
}

.menu-trigger:hover {
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.3);
}

.menu-trigger span {
  font-weight: 700;
  vertical-align: middle;
  font-size: 14px;
  margin: 0 10px;
}

.menu-trigger img {
  border-radius: 90px;
}

/* MOBILE */

.content-desktop {
  display: block;
}

.content-mobile {
  display: none;
}

@media screen and (max-width: 768px) {
  .content-desktop {
    display: none !important;
  }

  .content-mobile {
    display: block !important;
  }
}
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./assets/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="apple-touch-icon" href="./assets/favicon.ico" />
    <title>Welcome to NEAR with React</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import { initContract } from './utils'

window.nearInitPromise = initContract()
  .then(() => {
    ReactDOM.render(
      <App />,
      document.querySelector('#root')
    )
  })
  .catch(console.error)

'''
'''--- src/jest.init.js ---
import 'regenerator-runtime/runtime'

'''
'''--- src/main.test.js ---
beforeAll(async function () {
  // NOTE: nearlib and nearConfig are made available by near-cli/test_environment
  const near = await nearlib.connect(nearConfig)
  window.accountId = nearConfig.contractName
  window.contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['get_greeting'],
    changeMethods: [],
    sender: window.accountId
  })

  window.walletConnection = {
    requestSignIn() {
    },
    signOut() {
    },
    isSignedIn() {
      return true
    },
    getAccountId() {
      return window.accountId
    }
  }
})

test('get_greeting', async () => {
  const message = await window.contract.get_greeting({ account_id: window.accountId })
  expect(message).toEqual('Hello')
})

'''
'''--- src/useDetectOutsideClick.js ---
import { useState, useEffect } from "react";

/**
 * Hook for handling closing when clicking outside of an element
 * @param {React.node} el
 * @param {boolean} initialState
 */
export const useDetectOutsideClick = (el, initialState) => {
    const [isActive, setIsActive] = useState(initialState);

    useEffect(() => {
        const onClick = e => {
            // If the active element exists and is clicked outside of
            if (el.current !== null && !el.current.contains(e.target)) {
                setIsActive(!isActive);
            }
        };

        // If the item is active (ie open) then listen for clicks outside
        if (isActive) {
            window.addEventListener("click", onClick);
        }

        return () => {
            window.removeEventListener("click", onClick);
        };
    }, [isActive, el]);

    return [isActive, setIsActive];
};
'''
'''--- src/utils.js ---
import { connect, Contract, keyStores, WalletConnection } from 'near-api-js'
import getConfig from './config'

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  const near = await connect(Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig))

  // Initializing Wallet based Account. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(near)

  // Getting the Account ID. If still unauthorized, it's just empty string
  window.accountId = window.walletConnection.getAccountId()

  // Initializing our contract APIs by contract name and configuration
  window.contract = await new Contract(window.walletConnection.account(), nearConfig.contractName, {
    // View methods are read only. They don't modify the state, but usually return some value.
    viewMethods: ['get_request_key', 'get_contacts', 'get_account_for_contact', 'storage_paid', 'has_request_key', 'get_request'],
    // Change methods can modify the state. But you don't receive the returned value when called.
    changeMethods: ['start_auth', 'sign_auth', 'remove_request', 'send', 'storage_deposit', 'storage_withdraw', 'confirm_auth', 'remove'],
  })
}

export function logout() {
  window.walletConnection.signOut()
  // reload page
  window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

export function toParams(query) {
  const q = query.replace(/^\??\//, '');

  return q.split('&').reduce((values, param) => {
    const [key, value] = param.split('=');

    values[key] = value;

    return values;
  }, {});
}

export function toQuery(params, delimiter = '&') {
  const keys = Object.keys(params);

  return keys.reduce((str, key, index) => {
    let query = `${str}${key}=${params[key]}`;

    if (index < (keys.length - 1)) {
      query += delimiter;
    }

    return query;
  }, '');
}

'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>For local account login, Please run the following command in NEAR CLI, then enter account id here.
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''