*GitHub Repository "mamad-1373/nft_escrow_sc_near"*

'''--- Cargo.toml ---
[workspace]
members = [
    "./nft_escrow",
    "./ft_token",
    "./nft_collection",
]

[profile.release]
codegen-units = 1
# s = optimize for binary size ("z" would additionally turn off loop vectorization)
opt-level = "z"
# link time optimization
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- README.md ---
# escrow_sc_near
Escrow smart contract on Near network for Theia protocol

# Required Software

- Rust 1.61 + cargo
- Node.js
- NEAR CLI 3.2

# Usage

## Scripts

### Build

#### 1. Build Fungible Token  
```
$ cd ft_token
$ cargo install
$ ./build.sh
$ cd ..
```
Compiles "Fungible Token" smart contract to a WebAssembly binary. The binary path is `./target/wasm32-unknown-unknown/release/ft_token.wasm`.

#### 2. Build Non Fungible Token  
```
$ cd nft_collection
$ cargo install
$ ./build.sh
$ cd ..
```
Compiles "Non Fungible Token" smart contract to a WebAssembly binary. The binary path is `./target/wasm32-unknown-unknown/release/nft_collection.wasm`.

#### 3. Build Escrow Smart Contract  
```
$ cd nft_escrow
$ cargo install
$ ./build.sh
$ cd ..
```
Compiles "Escrow" smart contract to a WebAssembly binary. The binary path is `./target/wasm32-unknown-unknown/release/nft_escrow_sc.wasm`.

### Test
Integration testing of escrow contract.  
All 13 test features
```
$ cd nft_escrow
$ ./test.sh
```

### Deploy
#### deploy smart contract on mainnet

```
$ cd nft_escrow
$ ./deploy.sh <account-id>
```
Deploys the most recently built WASM binary to `<account-id>` on mainnet, and calls the `new` function with arguments generated by `init-args.js`.

#### deploy smart contract on testnet

```
$ cd nft_escrow
$ dev-deploy.sh [--force]
```

Deploys the most recently built WASM binary to the dev account in `neardev/`, or to a new dev account if `neardev/` is not found or `--force` is set. Calls the `new` function with arguments generated by `init-args.js`.

#### active project
- active ft project  
    Calls `active_ft_project` function with arguments generated by `active-ft-args.js`.

    ```
    $ cd ft_escrow
    $ ./active_ft_project.sh
    ```

- active nft project  
    Calls `active_nft_project` function with arguments generated by `active-nft-args.js`.

    ```
    $ cd nft_escrow
    $ ./active_nft_project.sh
    ```
#### other view functions in [here](./nft_escrow/commands.md)

'''
'''--- ft_token/Cargo.toml ---
[package]
name = "ft_token"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
near-contract-tools = "0.5.0"

[dev-dependencies]
workspaces = "0.4.1"
anyhow = "1.0.62"
near-units = "0.2.0"
tokio = "1.20.1"

[lib]
crate-type = ["cdylib"]
'''
'''--- ft_token/build.sh ---
#!/usr/bin/env bash

export WASM_NAME=ft_token.wasm
cargo build --target wasm32-unknown-unknown --release
wasm-opt -Os -o ../target/wasm32-unknown-unknown/release/$WASM_NAME ../target/wasm32-unknown-unknown/release/$WASM_NAME
'''
'''--- ft_token/commands.txt ---
1. register account

near call dev-1662102511052-26947222593947 storage_deposit '{"account_id":"dev-1662193217534-19046783282878"}' --deposit 0.01 --accountId theia_owner.testnet

2. token mint

near call dev-1662102511052-26947222593947 ft_mint '{"receiver_id":"hosokawa.testnet", "amount":"1000000000000000000000000000000"}' --accountId hosokawa.testnet

3. Balance

near view dev-1662102511052-26947222593947 ft_balance_of '{"account_id":"dev-1662211928903-24924279464718"}'
'''
'''--- ft_token/deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- ft_token/dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="../target/wasm32-unknown-unknown/release/ft_token.wasm"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- ft_token/init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

// Fungible token
const owner_id = "theia_owner.testnet";
const name = "USD Tether";
const symbol = "USDT";
const decimals = "24";

console.log(JSON.stringify({owner_id, name, symbol, decimals}));
'''
'''--- ft_token/src/lib.rs ---
mod owner;

use near_contract_standards::fungible_token::events::{FtBurn, FtMint};
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{
    env, log, near_bindgen, require, AccountId, Balance, BorshStorageKey, PanicOnDefault,
    PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
    owner_id: AccountId,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    FungibleToken,
    Metadata,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner_id: AccountId, name: String, symbol: String, decimals: u8) -> Self {
        require!(!env::state_exists(), "Already initialized");

        let metadata = FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name,
            symbol,
            icon: None,
            reference: None,
            reference_hash: None,
            decimals,
        };
        metadata.assert_valid();

        Self {
            token: FungibleToken::new(StorageKey::FungibleToken),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            owner_id: owner_id.clone(),
        }
    }

    pub fn ft_mint(&mut self, receiver_id: AccountId, amount: U128) {
        require!(env::predecessor_account_id() == self.owner_id, "UnAuthorized");

        self.token.internal_deposit(&receiver_id, amount.0);
        FtMint {
            owner_id: &(receiver_id),
            amount: &amount,
            memo: None
        }.emit();
    }

    pub fn ft_burn(&mut self, from_id: AccountId, amount: U128) {
        require!(env::predecessor_account_id() == self.owner_id, "UnAuthorized");

        self.token.internal_withdraw(&from_id, amount.0);
        FtBurn {
            owner_id: &(from_id),
            amount: &amount,
            memo: None
        }.emit();
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[allow(dead_code, unused)]
#[cfg(test)]
mod tests {
    use near_sdk::{test_utils::*, testing_env, AccountId, ONE_NEAR};
    use super::*;

    fn contract_account() -> AccountId {
        "contract".parse::<AccountId>().unwrap()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(contract_account())
            .account_balance(15 * ONE_NEAR)
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test() {
        let owner_id = accounts(0);
        let alice_id = accounts(1);

        // deploy
        testing_env!(get_context(owner_id.clone()).build());
        let mut contract = Contract::new(owner_id.clone(), String::from("Test FT"), String::from("TFT"));

        // mint
        testing_env!(
            get_context(owner_id.clone())
                .attached_deposit(125 * env::storage_byte_cost())
                .build()
        );
        contract.storage_deposit(Some(accounts(0)), None);
        contract.ft_mint(accounts(0), 1_000_000u128.into());
        assert_eq!(contract.ft_balance_of(accounts(0)), 1_000_000u128.into());

        // transfer
        testing_env!(
            get_context(owner_id.clone())
                .attached_deposit(125 * env::storage_byte_cost())
                .build()
        );
        contract.storage_deposit(Some(alice_id.clone()), None);
        testing_env!(
             get_context(owner_id.clone())
                .attached_deposit(1)
                .build());
        contract.ft_transfer(alice_id.clone(), 1_000u128.into(), None);
        assert_eq!(contract.ft_balance_of(accounts(1)), 1_000u128.into());

        // burn
        contract.ft_burn(alice_id.clone(), 500u128.into());
        assert_eq!(contract.ft_balance_of(accounts(1)), 500u128.into());
    }
}

'''
'''--- ft_token/src/owner.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn get_owner(&self) -> AccountId {
        self.owner_id.clone()
    }

    pub fn set_owner(&mut self, owner_id: AccountId) {
        self.assert_owner();
        self.owner_id = owner_id.into();
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "No permission to invoke this"
        );
    }
}

'''
'''--- nft_collection/Cargo.toml ---
[package]
name = "nft_collection"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
near-contract-tools = "0.5.0"

[lib]
crate-type = ["cdylib"]
'''
'''--- nft_collection/build.sh ---
#!/usr/bin/env bash

export WASM_NAME=nft_collection.wasm
cargo build --target wasm32-unknown-unknown --release
wasm-opt -Os -o ../target/wasm32-unknown-unknown/release/$WASM_NAME ../target/wasm32-unknown-unknown/release/$WASM_NAME
'''
'''--- nft_collection/deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- nft_collection/dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="../target/wasm32-unknown-unknown/release/nft_collection*.wasm"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- nft_collection/init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

// Nft collection
const owner_id = "hosokawa.testnet";
const name = "NFT Collection 1";
const symbol = "NCC";
const base_uri = "https://gateway.pinata.cloud/ipfs/QmatVxVUBWiM2vJp5z5m9aWeyP4hpphjHTRArSgEjomseE";
const max_supply = 30;

console.log(JSON.stringify({owner_id, name, symbol, base_uri, max_supply}));
'''
'''--- nft_collection/src/lib.rs ---
mod owner;

use std::collections::HashMap;
use near_contract_standards::non_fungible_token::events::{NftMint, NftTransfer};
use near_contract_standards::non_fungible_token::metadata::{NFTContractMetadata, TokenMetadata, NFT_METADATA_SPEC, NonFungibleTokenMetadataProvider};
use near_contract_standards::non_fungible_token::{Token, TokenId, refund_deposit_to_account};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedSet};
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue, CryptoHash, assert_one_yocto, require};
use near_sdk::json_types::U128;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    current_index: u128,
    max_supply: u128
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub enum NonFungibleTokenStorageKey {
    TokensPerOwner { account_hash: Vec<u8> },
    TokenPerOwnerInner { account_id_hash: CryptoHash },
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with nft metadata
    #[init]
    pub fn new(owner_id: AccountId, name: String, symbol: String, base_uri: String, max_supply: U128) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let metadata = NFTContractMetadata {
            spec: NFT_METADATA_SPEC.to_string(),
            name,
            symbol,
            icon: None,
            base_uri: Some(base_uri),
            reference: None,
            reference_hash: None,
        };

        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            current_index: 0u128,
            max_supply: max_supply.0
        }
    }

    /// Mint nft tokens with amount belonging to `receiver_id`.
    /// caller should be owner
    #[payable]
    pub fn nft_mint(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
    ) -> Vec<Token> {
        assert!(amount.0 > 0, "Invalid amount");
        assert!(self.current_index.checked_add(amount.0).unwrap() < self.max_supply, "OverMaxSupply");
        assert_eq!(env::predecessor_account_id(), self.tokens.owner_id, "Unauthorized");

        let mut tokens: Vec<Token> = vec![];
        let mut i = 0;
        let mut all_token_ids: Vec<TokenId> = vec![];

        // Remember current storage usage if refund_id is Some
        let initial_storage_usage = env::storage_usage();

        while i < amount.0 {
            let title = Some(format!("{} #{}", self.metadata.get().unwrap().name, i.to_string()));
            let media = Some(i.to_string());
            let reference = Some(format!("{}.json", i.to_string()));

            let token_id: TokenId = (self.current_index + i).to_string();
            let token_metadata = Some(TokenMetadata {
                title,
                description: None,
                media,
                media_hash: None,
                copies: Some(1u64),
                issued_at: Some(env::block_timestamp().to_string()),
                expires_at: None,
                starts_at: None,
                updated_at: None,
                extra: None,
                reference,
                reference_hash: None
            });
            
            //let token: Token = self.tokens.internal_mint(token_id.to_string(), receiver_id.clone(), token_metadata);
                
            if self.tokens.owner_by_id.get(&token_id).is_some() {
                env::panic_str("token_id must be unique");
            }

            let owner_id: AccountId = receiver_id.clone();

            // Core behavior: every token must have an owner
            self.tokens.owner_by_id.insert(&token_id, &owner_id);

            // Metadata extension: Save metadata, keep variable around to return later.
            // Note that check above already panicked if metadata extension in use but no metadata
            // provided to call.
            self.tokens.token_metadata_by_id
                .as_mut()
                .and_then(|by_id| by_id.insert(&token_id, token_metadata.as_ref().unwrap()));

            // Enumeration extension: Record tokens_per_owner for use with enumeration view methods.
            if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
                let mut token_ids = tokens_per_owner.get(&owner_id).unwrap_or_else(|| {
                    UnorderedSet::new(NonFungibleTokenStorageKey::TokensPerOwner {
                        account_hash: env::sha256(&owner_id.as_bytes()),
                    })
                });
                token_ids.insert(&token_id);
                tokens_per_owner.insert(&owner_id, &token_ids);
            }

            // Approval Management extension: return empty HashMap as part of Token
            let approved_account_ids =
                if self.tokens.approvals_by_id.is_some() { Some(HashMap::new()) } else { None };

            all_token_ids.push(owner_id.to_string());

            let token = Token { token_id, owner_id: owner_id.clone(), metadata: token_metadata, approved_account_ids };
            
            tokens.push(token.clone());
            i += 1;
        }
        
        self.current_index += amount.0;

        let str_token_ids: Vec<&str> = all_token_ids.iter().map(AsRef::as_ref).collect();
        NftMint { owner_id: &receiver_id, token_ids: &str_token_ids, memo: None }.emit();

        // Return any extra attached deposit not used for storage
        refund_deposit_to_account(env::storage_usage() - initial_storage_usage, receiver_id);

        tokens
    }

    pub fn nft_batch_transfer(&mut self, to: AccountId, token_ids: Vec<TokenId>, memo: Option<String>) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();

        for token_id in &token_ids {
            let owner_id =
                self.tokens.owner_by_id.get(&token_id).unwrap_or_else(|| env::panic_str("Token not found"));
            require!(&owner_id == &sender_id, "Only owner can do batch-transfer");
            require!(&owner_id != &to, "Current and next owner must differ");

            self.tokens.internal_transfer_unguarded(&token_id, &owner_id, &to);
        }

        let str_token_ids: Vec<_> = token_ids.iter().map(String::as_str).collect();
        NftTransfer {
            old_owner_id: &sender_id,
            new_owner_id: &to,
            token_ids: &str_token_ids,
            authorized_id: None,
            memo: memo.as_deref(),
        }.emit();
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[allow(dead_code, unused)]
#[cfg(test)]
mod tests {
    use near_sdk::{test_utils::*, testing_env, AccountId, ONE_NEAR};
    use super::*;

    fn contract_account() -> AccountId {
        "contract".parse::<AccountId>().unwrap()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(contract_account())
            .account_balance(15 * ONE_NEAR)
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test() {
        let owner_id = accounts(0);
        let alice_id = accounts(1);

        // deploy
        testing_env!(get_context(owner_id.clone()).build());
        let mut contract = Contract::new(
            owner_id.clone(),
            String::from("Test FT"),
            String::from("TFT"),
            String::from("https://ipfs.io/ipfs/QmXa5nrfaqrvvcYFeEvs8E9W7AAeCZeUAuN6jophN9y8Ds/"),
            U128::from(100)
        );

        // mint
        testing_env!(
            get_context(owner_id.clone())
                .attached_deposit(553 * env::storage_byte_cost())
                .build()
        );
        contract.nft_mint(accounts(0), 1u128.into());
        assert_eq!(contract.nft_supply_for_owner(accounts(0)), 1u128.into());

        // transfer
        testing_env!(
             get_context(owner_id.clone())
                .attached_deposit(1)
                .build());
        contract.nft_transfer(alice_id.clone(), "0".to_string(), None, None);
        assert_eq!(contract.nft_supply_for_owner(accounts(0)), 0u128.into());
        assert_eq!(contract.nft_supply_for_owner(accounts(1)), 1u128.into());
        assert_eq!(contract.nft_total_supply(), 1u128.into());
    }
}
'''
'''--- nft_collection/src/owner.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn get_owner(&self) -> AccountId {
        self.tokens.owner_id.clone()
    }

    pub fn set_owner(&mut self, owner_id: AccountId) {
        self.assert_owner();
        self.tokens.owner_id = owner_id.into();
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.tokens.owner_id,
            "No permission to invoke this"
        );
    }
}

'''
'''--- nft_escrow/Cargo.toml ---
[package]
name = "nft_escrow_sc"
version = "0.1.0"
edition = "2021"
authors = ["hosokawa"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
near-contract-tools = "0.5.0"
serde = "1"
serde_json = "1"
near-units = "0.2.0"
uint='0.9.3'

[dev-dependencies]
anyhow = "1.0.62"
tokio = "1.20.1"
workspaces = "0.4.1"
tracing = "0.1.36"
tracing-subscriber = "0.3.15"

[lib]
crate-type = ["cdylib"]

'''
'''--- nft_escrow/active-ft-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

// Activate FT Project
const name = "Theia Collection 1";
const symbol = "TCN";
const blank_media_uri = "https://ipfs.io/ipfs/QmZRBnIklexQCvEmQxZ1CDqczgXcy7hatu9eZXW5FZUznj";
const max_supply = "100";
const finder_id = "hosokawa_test1.testnet";
const pre_mint_amount = "10";
const fund_threshold = (ONE_NEAR * 15n).toString();     // 15 USDT
const buffer_period = 0;
const conversion_period = 1800 * 1_000_000_000; // 30 min

console.log(JSON.stringify({name, symbol, blank_media_uri, max_supply, finder_id, pre_mint_amount, fund_threshold, buffer_period, conversion_period}));

'''
'''--- nft_escrow/active-nft-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

// Activate NFT Project
const name = "Theia Collection 1";
const symbol = "TCN";
const base_uri = "https://ipfs.io/ipfs/QmUDqczgXxZ7exQ9znjZRB1CCvEmQ5FZchatueZXWnIkly/";
const blank_media_uri = "https://ipfs.io/ipfs/QmZRBnIklexQCvEmQxZ1CDqczgXcy7hatu9eZXW5FZUznj";
const max_supply = "1000";
const finder_id = "hosokawa_test1.testnet";
const pre_mint_amount = "10";
const fund_threshold = (ONE_NEAR * 15n).toString();     // 200 NEAR
const buffer_period = 0;
const conversion_period = 1800 * 1_000_000_000; // 30 min

console.log(JSON.stringify({name, symbol, base_uri, blank_media_uri, max_supply, finder_id, pre_mint_amount, fund_threshold, buffer_period, conversion_period}));

'''
'''--- nft_escrow/active_ft_project.sh ---
near call "$(<./neardev/dev-account)" active_ft_project "$(node ./active-ft-args.js)" \
  --accountId "theia_owner.testnet" --gas 300000000000000

'''
'''--- nft_escrow/active_nft_project.sh ---
near call "$(<./neardev/dev-account)" active_nft_project "$(node ./active-nft-args.js)" \
  --accountId "theia_owner.testnet" --gas 300000000000000

'''
'''--- nft_escrow/build.sh ---
#!/usr/bin/env bash

export WASM_NAME=nft_escrow_sc.wasm
cargo build --target wasm32-unknown-unknown --release
wasm-opt -Os -o ../target/wasm32-unknown-unknown/release/$WASM_NAME ../target/wasm32-unknown-unknown/release/$WASM_NAME
'''
'''--- nft_escrow/commands.md ---

## Call Functions  
- 1. buy

    ```
    near call <stable-coin-id> ft_transfer_call '{"receiver_id":"<escrow-contract-id>","amount":"30000000000000000000000000","memo":"","msg":"buy:10"}' --accountId <user-account-id> --deposit 0.000000000000000000000001 --gas 300000000000000
    ```

- 2. sell

    ```
    near call <escrow-contract-id> sell '{"token_ids":["15","16","17","18","19"]}' --accountId <user-account-id> --gas 300000000000000
    ```

- 3. convert (register user account to project token)

    ```
    near call <escrow-contract-id> convert '{"token_ids":["25","26","27","28","29","30","31","32","33","34"]}' --accountId <user-account-id> --gas 300000000000000
    ```

- 4. claim fund (register project owner to stable coin)

    ```
    near call <escrow-contract-id> claim_fund '{"to":"<owner-account-id>","amount":"41880000000000000000000020"}' --accountId <owner-account-id> --gas 300000000000000
    ```

- 5. close project (register project owner and contract to project token)

    ```
    near call <escrow-contract-id> close_project '{}' --accountId <owner-account-id> --gas 300000000000000
    ```

## View Functions

- 1. get proxy token
    ```
    near view <escrow-contract-id> get_proxy_token_id
    ```

- 2. get project token
    ```
    near view <escrow-contract-id> get_project_token_id
    ```

- 3. calculate for buying proxy token
    ```
    near view <escrow-contract-id> calculate_buy_proxy_token '{"amount":"10"}'
    ```
    
- 4. calculate for selling proxy token
    ```
    near view <escrow-contract-id> calculate_sell_proxy_token '{"token_ids":["11","12","13","14","15"]}'
    ```

- 5. get proxy token Balance
    ```
    near view ptheiacollection1.<escrow-contract-id> mt_balance_of '{"owner":"<user-account-id>","id":["15","16","17","18","19"]}'
    ```

- 6. register account to project token (fungible token)
    ```
    near call theiacollection1.<escrow-contract-id> storage_deposit '{"account_id":"<user-account-id>"}' --deposit 0.01 --accountId <user-account-id>
    ```

- 7.  get total fund amount
    ```
    near view <escrow-contract-id> get_total_fund_amount
    ```

- 8.  get pre-mint amount
    ```
    near view <escrow-contract-id> get_pre_mint_amount
    ```

- 9.  get start timestamp
    ```
    near view <escrow-contract-id> get_start_timestamp
    ```

- 10.  get tp timestamp
    ```
    near view <escrow-contract-id> get_tp_timestamp
    ```

- 11.  get buffer period
    ```
    near view <escrow-contract-id> get_buffer_period
    ```

- 12.  get conversion period
    ```
    near view <escrow-contract-id> get_conversion_period
    ```

- 13.  get get_stable_coin_id
    ```
    near view <escrow-contract-id> get_stable_coin_id
    ```

- 14.  get running state
    ```
    near view <escrow-contract-id> get_running_state
    ```

- 15.  get `is_closed` flag
    ```
    near view <escrow-contract-id> get_is_closed
    ```

- 16.  get total converted amount
    ```
    near view <escrow-contract-id> get_converted_amount
    ```

- 17.  get current circulating supply amount
    ```
    near view <escrow-contract-id> get_circulating_supply
    ```

'''
'''--- nft_escrow/contract.sh ---
#!/usr/bin/env sh

command="$1"
shift
near "$command" "$(<./neardev/dev-account)" "$@"

'''
'''--- nft_escrow/deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- nft_escrow/dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ../target/wasm32-unknown-unknown/release/nft_escrow_sc.wasm)"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- nft_escrow/init-args.js ---
const CURVE_TYPE_HORIZONTAL = 'Horizontal';
const CURVE_TYPE_LINEAR = 'Linear';
const CURVE_TYPE_SIGMOIDAL = 'Sigmoidal';

// initialize
const owner_id = "theia_owner.testnet";
const stable_coin_id = "dev-1662102511052-26947222593947";
const stable_coin_decimals = 24;
const curve_type = CURVE_TYPE_LINEAR;
const curve_args = {
    arg_a: 3,
    arg_b: 3
};
// const curve_args = {
//     arg_a: 50,
//     arg_b: 10,
//     arg_c: 100,
//     arg_d: 100
// };
const treasury_id = "theia_owner.testnet";

console.log(JSON.stringify({owner_id, stable_coin_id, stable_coin_decimals, curve_type, curve_args, treasury_id}));
'''
'''--- nft_escrow/rustfmt.toml ---
tab_spaces = 4

'''
'''--- nft_escrow/src/curves.rs ---
use near_contract_standards::non_fungible_token::TokenId;
use crate::*;
use crate::utils::{FEE_DIVISOR, integer_sqrt};

#[near_bindgen]
impl Contract {
    #[private]
    pub fn get_sum_price(&self, to_token_id: u128) -> u128 {
        let one_coin = 10u128.pow(self.stable_coin_decimals as u32);
        let mut price;
        match &self.curve_type {
            CurveType::Horizontal => {
                // p = A * x
                price = (&self).curve_args.arg_a
                    .unwrap()
                    .checked_mul(to_token_id)
                    .unwrap()
                    .checked_mul(one_coin)
                    .unwrap();
            },
            CurveType::Linear=> {
                // p = (A * x^2 + 2 * B * x) / 2
                price = (&self).curve_args.arg_a
                    .unwrap()
                    .checked_mul(to_token_id * to_token_id)
                    .unwrap();
                price = price
                    .checked_add((&self).curve_args.arg_b
                        .unwrap()
                        .checked_mul(to_token_id).unwrap()
                        .checked_mul(2).unwrap())
                        .unwrap();
                price = price
                    .checked_mul(one_coin)
                    .unwrap()
                    .checked_div(2)
                    .unwrap();
            },
            CurveType::Sigmoidal => {
                // p = A * sqr(C + (x + B)^2) + x * (D + A)
                let aa = integer_sqrt(
                    U256::from(
                        (&self).curve_args.arg_c.unwrap() + (to_token_id + (&self).curve_args.arg_b.unwrap()).pow(2)
                    )
                    * U256::from(one_coin)
                    * U256::from(one_coin)
                );
                price = (&self).curve_args.arg_a
                    .unwrap()
                    .checked_mul(aa.as_u128())
                    .unwrap();
                price = price
                    .checked_add(
                    to_token_id.checked_mul(
                        (&self).curve_args.arg_d.unwrap() + (&self).curve_args.arg_a.unwrap()
                        )
                        .unwrap()
                        * one_coin
                    )
                    .unwrap();
            }
        }
        price
    }

    pub fn get_curve_type(&self) -> CurveType { self.curve_type.clone() }

    pub fn get_curve_args(&self) -> CurveArgs { self.curve_args.clone() }

    pub fn get_token_price(&self, token_id: U128) -> u128 {
        if token_id.0 < self.pre_mint_amount {
            return 0u128;
        }
        let token_index = token_id.0 - self.pre_mint_amount;
        self.get_sum_price(token_index + 1)
            .checked_sub(self.get_sum_price(token_index))
            .unwrap()
    }

    pub fn calculate_buy_proxy_token(&self, amount: U128) -> u128 {
        self.get_sum_price(self.circulating_supply.checked_add(amount.0).unwrap())
            .checked_sub(self.get_sum_price(self.circulating_supply))
            .unwrap()
    }

    pub fn calculate_sell_proxy_token(&self, token_ids: Vec<TokenId>) -> u128 {
        let mut total_price = 0u128;
        token_ids.iter().enumerate().for_each(|(_, token_id) | {
            total_price = total_price.checked_add(self.get_token_price(U128::from(token_id.parse::<u128>().unwrap()))).unwrap();
        });

        total_price
            .checked_mul(FEE_DIVISOR.checked_sub(self.treasury_fee).unwrap() as u128)
            .unwrap()
            .checked_div(FEE_DIVISOR as u128).unwrap()
    }
}
'''
'''--- nft_escrow/src/errors.rs ---
// Escrow errors.
pub const ERR00_INVALID_NAME: &str = "E00: Invalid name";
pub const ERR01_INVALID_SYMBOL: &str = "E01: Invalid symbol";
pub const ERR02_INVALID_COLLECTION_BASE_URI: &str = "E02: Invalid collection base uri";
pub const ERR03_INVALID_PT_MEDIA_URI: &str = "E03: Invalid blank uri";
pub const ERR04_INVALID_MAX_SUPPLY: &str = "E04: Invalid max supply";
pub const ERR05_INVALID_FUNDING_TARGET: &str = "E05: Invalid funding target";
pub const ERR06_INVALID_CONVERSION_PERIOD: &str = "E06: Invalid conversion period (min: 1 day)";
pub const ERR07_INSUFFICIENT_FUND: &str = "E07: Insufficient fund";
pub const ERR08_ALREADY_INITIALIZED: &str = "E08: Already initialized";
pub const ERR09_INVALID_ACTION: &str = "E09: Invalid action";
pub const ERR010_INVALID_AMOUNT: &str = "E10: Invalid amount";
pub const ERR011_NOT_AVAILABLE_TO_CLOSE: &str = "E11: Invalid amount";
pub const ERR012_ALREADY_CLOSED: &str = "E12: Project was already closed";

// Validate errors
pub const ERR10_NOT_ACTIVATED: &str = "E10: Escrow is not activated";
pub const ERR11_NOT_ONGOING: &str = "E11: Escrow is not in ongoing state";
pub const ERR12_NOT_OVER_FUNDING_TARGET: &str = "E12: Escrow is not reached to funding threshold";
pub const ERR13_IN_BUFFER_PERIOD: &str = "E13: Escrow is in buffer period";
pub const ERR14_NOT_OVER_CONVERSION_PERIOD: &str = "E14: Escrow is not over conversion period";
pub const ERR15_ALREADY_ACTIVATED: &str = "E15: Escrow was already activated";

// Owner errors
pub const ERR20_NOT_ALLOW: &str = "E20: The action is allowed by only owner";

// Pause errors
pub const ERR30_PAUSED: &str = "E20: Escrow was paused";

'''
'''--- nft_escrow/src/lib.rs ---
mod utils;
mod errors;
mod views;
mod curves;
mod owner;
mod validates;
mod pause;
mod token_receiver;
mod pt_metadata;
mod proxy_token;

use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::{env, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault, Promise, Gas, log, is_promise_success, PromiseOrValue};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use crate::pt_metadata::*;
use crate::errors::*;
use crate::utils::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Owner of contract
    owner_id: AccountId,
    /// Project token name
    name: String,
    /// Project token symbol
    symbol: String,
    /// Protocol account
    treasury_id: AccountId,
    /// Protocol fee percent
    treasury_fee: u32,
    /// Finder account
    finder_id: Option<AccountId>,
    /// Finder fee percent
    finder_fee: u32,
    /// Project token type
    project_token_type: ProjectTokenType,
    /// Project token id
    project_token_id: Option<AccountId>,
    /// Funding target amount
    fund_threshold: Balance,
    /// Start timestamp
    start_timestamp: u64,
    /// Threshold timestamp
    tp_timestamp: u64,
    /// Buffer period
    buffer_period: u64,
    /// Conversion period
    conversion_period: u64,
    /// Stable coin
    stable_coin_id: AccountId,
    /// Stable coin decimals
    stable_coin_decimals: u8,
    /// Total fund amount
    total_fund_amount: Balance,
    /// Total claimed fund amount
    claimed_fund_amount: Balance,
    /// Total claimed finder fee amount
    claimed_finder_fee: Balance,
    /// Pre-mint amount
    pre_mint_amount: Balance,
    /// Amount of converted proxy token
    converted_amount: Balance,
    /// Circulating supply of proxy token
    circulating_supply: Balance,
    /// Auction curve type
    curve_type: CurveType,
    /// Auction curve args
    curve_args: CurveArgs,
    /// Running state
    state: RunningState,
    /// Closed
    closed_step: ClosedStep,
    /// Proxy token media uri
    pt_media_uri: String,
    /// Proxy token max supply
    pt_max_supply: u128,
    /// Proxy token all total supply
    pt_all_total_supply: Balance,
    /// Proxy token total supply by token id
    pt_total_supply: LookupMap<TokenId, Balance>,
    /// Proxy token balance by token id and account id
    pt_balances_per_token: UnorderedMap<TokenId, LookupMap<AccountId, Balance>>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    TotalSupply { supply: u128 },
    Balances,
    BalancesInner { token_id: Vec<u8> },
}

const MIN_STORAGE_NON_FUNGIBLE_TOKEN: Balance = 600_000 * STORAGE_PRICE_PER_BYTE;
const MIN_STORAGE_FUNGIBLE_TOKEN: Balance = 600_000 * STORAGE_PRICE_PER_BYTE;
const DEPOSIT_ONE_NFT_MINT: Balance = 638 * STORAGE_PRICE_PER_BYTE;
const DEPOSIT_ONE_PT_MINT: Balance = 415 * STORAGE_PRICE_PER_BYTE;
const NO_DEPOSIT: Balance = 0u128;
const ONE_YOCTO: Balance = 1u128;
const TGAS: u64 = 1_000_000_000_000;
const GAS_FOR_PT_MINT: Gas = Gas(100 * TGAS);

const NFT_COLLECTION_CODE: &[u8] = include_bytes!("../../target/wasm32-unknown-unknown/release/nft_collection.wasm");
const FUNGIBLE_TOKEN_CODE: &[u8] = include_bytes!("../../target/wasm32-unknown-unknown/release/ft_token.wasm");

#[near_bindgen]
impl Contract {
    /// Initialize the contract
    #[init]
    pub fn new(owner_id: AccountId, name: String, symbol: String, pt_media_uri: String, stable_coin_id: AccountId, stable_coin_decimals: u8, curve_type: CurveType, curve_args: CurveArgs, treasury_id: AccountId) -> Self {
        assert!(!env::state_exists(), "{}", ERR08_ALREADY_INITIALIZED);
        assert!(name.len() > 2, "{}", ERR00_INVALID_NAME);
        assert!(symbol.len() < 13 && symbol.len() > 2, "{}", ERR01_INVALID_SYMBOL);
        assert!(pt_media_uri.len() > 0, "{}", ERR03_INVALID_PT_MEDIA_URI);

        Self {
            owner_id,
            name,
            symbol,
            treasury_id,
            treasury_fee: 100,  // 1%
            finder_id: None,
            finder_fee: 100,    // 1%
            project_token_type: ProjectTokenType::NonFungible,
            project_token_id: None,
            fund_threshold: 0,
            start_timestamp: 0,
            tp_timestamp: 0,
            buffer_period: 0,
            conversion_period: 0,
            stable_coin_id,
            stable_coin_decimals,
            total_fund_amount: 0,
            claimed_fund_amount: 0,
            claimed_finder_fee: 0,
            pre_mint_amount: 0,
            converted_amount: 0,
            circulating_supply: 0,
            curve_type,
            curve_args,
            state: RunningState::Running,
            closed_step: ClosedStep::None,
            pt_media_uri,
            pt_total_supply: LookupMap::new(StorageKey::TotalSupply { supply: u128::MAX }),
            pt_balances_per_token: UnorderedMap::new(StorageKey::Balances),
            pt_max_supply: 0,
            pt_all_total_supply: 0
        }
    }

    /// Pre-mint
    #[payable]
    pub fn pre_mint(&mut self, amount: U128) {
        self.assert_owner();
        assert!(amount.0 > 0, "{}", ERR010_INVALID_AMOUNT);
        assert_eq!(self.start_timestamp, 0, "{}", ERR15_ALREADY_ACTIVATED);

        self.pre_mint_amount = self.pre_mint_amount.checked_add(amount.0).unwrap();

        self.pt_mint(self.owner_id.clone(), amount);

        log!("Pre-mint {}", amount.0);
    }

    /// Active NFT project
    pub fn active_nft_project(&mut self, base_uri: String, max_supply: U128, finder_id: AccountId, fund_threshold: U128, buffer_period: u64, conversion_period: u64) -> Promise {
        self.assert_owner();
        assert!(self.closed_step == ClosedStep::None, "{}", ERR012_ALREADY_CLOSED);
        assert!(base_uri.len() > 0, "{}", ERR02_INVALID_COLLECTION_BASE_URI);
        assert!(max_supply.0 > 0 && self.pre_mint_amount < max_supply.0, "{}", ERR04_INVALID_MAX_SUPPLY);
        assert!(fund_threshold.0 > 0, "{}", ERR05_INVALID_FUNDING_TARGET);
        assert!(conversion_period >= 86400, "{}", ERR06_INVALID_CONVERSION_PERIOD);

        self.finder_id = Some(finder_id);
        self.fund_threshold = fund_threshold.0;
        self.buffer_period = buffer_period;
        self.conversion_period = conversion_period;
        self.project_token_type = ProjectTokenType::NonFungible;
        self.pt_max_supply = max_supply.0;

        let mut token_suffix = self.name.clone().to_lowercase();
        token_suffix.retain(|c| !c.is_whitespace());
        let project_token_id = AccountId::new_unchecked(format!("{}.{}", token_suffix, env::current_account_id()));

        // deploy non-fungible token
        let project_token_promise = Promise::new(project_token_id.clone())
            .create_account()
            .transfer(MIN_STORAGE_NON_FUNGIBLE_TOKEN)
            .deploy_contract(NFT_COLLECTION_CODE.to_vec())
            .function_call(
                "new".to_string(),
                json!({
                    "owner_id": env::current_account_id(),
                    "name": self.name.clone(),
                    "symbol": self.symbol.clone(),
                    "base_uri": base_uri,
                    "max_supply": max_supply
                }).to_string().as_bytes().to_vec(),
                NO_DEPOSIT,
                Gas(5 * TGAS)
            );

        project_token_promise
            .then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(Gas(5 * TGAS))
                    .on_activate(project_token_id)
            )
    }

    /// Active FT project
    pub fn active_ft_project(&mut self, max_supply: U128, finder_id: AccountId, fund_threshold: U128, buffer_period: u64, conversion_period: u64) -> Promise {
        self.assert_owner();
        assert!(self.closed_step == ClosedStep::None, "{}", ERR012_ALREADY_CLOSED);
        assert!(max_supply.0 > 0 && self.pre_mint_amount < max_supply.0, "{}", ERR04_INVALID_MAX_SUPPLY);
        assert!(fund_threshold.0 > 0, "{}", ERR05_INVALID_FUNDING_TARGET);
        assert!(conversion_period >= 86400, "{}", ERR06_INVALID_CONVERSION_PERIOD);

        self.finder_id = Some(finder_id);
        self.fund_threshold = fund_threshold.0;
        self.buffer_period = buffer_period;
        self.conversion_period = conversion_period;
        self.project_token_type = ProjectTokenType::Fungible;
        self.pt_max_supply = max_supply.0;

        let mut token_suffix = self.name.clone().to_lowercase();
        token_suffix.retain(|c| !c.is_whitespace());
        let project_token_id = AccountId::new_unchecked(format!("{}.{}", token_suffix, env::current_account_id()));

        // deploy fungible token
        let project_token_promise = Promise::new(project_token_id.clone())
            .create_account()
            .transfer(MIN_STORAGE_FUNGIBLE_TOKEN)
            .deploy_contract(FUNGIBLE_TOKEN_CODE.to_vec())
            .function_call(
                "new".to_string(),
                json!({
                    "owner_id": env::current_account_id(),
                    "name": self.name.clone(),
                    "symbol": self.symbol.clone(),
                    "decimals": 1u8
                }).to_string().as_bytes().to_vec(),
                NO_DEPOSIT,
                Gas(5 * TGAS)
            );

        project_token_promise.then(
            ext_self::ext(env::current_account_id())
                .with_static_gas(Gas(5 * TGAS))
                .on_activate(project_token_id)
        )
    }

    /// Callback after project token was created
    #[private]
    pub fn on_activate(
        &mut self,
        project_token_id: AccountId
    ) -> bool {
        if is_promise_success() {
            self.project_token_id = Some(project_token_id.clone());
            self.start_timestamp = env::block_timestamp();

            log!("Activated {} {}", project_token_id.to_string(), self.start_timestamp);
        } else {
            return false;
        }

        true
    }

    /// buy proxy token
    pub(crate) fn buy(&mut self, from: AccountId, amount: U128, deposit: U128) -> Promise {
        self.assert_not_paused();
        self.assert_is_ongoing();
        assert!(amount.0 > 0, "Invalid amount");
        assert!(self.pt_all_total_supply + amount.0 < self.pt_max_supply, "OverMaxSupply");

        let cal_coin_amount = self.calculate_buy_proxy_token(amount);
        assert!(deposit.0 >= cal_coin_amount, "{}", ERR07_INSUFFICIENT_FUND);

        // Mint proxy token to customer
        let mint_promise = ext_self::ext(env::current_account_id())
            .with_static_gas(GAS_FOR_PT_MINT)
            .with_attached_deposit(amount.0 * DEPOSIT_ONE_PT_MINT)
            .pt_mint(from.clone(), amount);

        mint_promise.then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(Gas(5 * TGAS))
                    .on_buy(from, amount, deposit, U128(cal_coin_amount))
            )
    }

    #[private]
    #[payable]
    pub fn on_buy(&mut self, from: AccountId, amount: U128, deposit: U128, reserve: U128) -> bool {
        if is_promise_success() {
            let treasury_fee_amount = reserve.0
                .checked_mul(self.treasury_fee as u128)
                .unwrap()
                .checked_div(FEE_DIVISOR as u128)
                .unwrap();

            let reserve_fund_amount = reserve.0.checked_sub(treasury_fee_amount).unwrap();

            self.total_fund_amount = self.total_fund_amount
                .checked_add(reserve_fund_amount)
                .unwrap();

            if self.tp_timestamp == 0 && self.total_fund_amount >= self.fund_threshold {
                self.tp_timestamp = env::block_timestamp();
            }
            // update circulating supply
            self.circulating_supply += amount.0;

            // Transfer stable coin to treasury
            ext_fungible_token::ext(self.stable_coin_id.clone())
                .with_static_gas(GAS_FOR_FT_TRANSFER)
                .with_attached_deposit(ONE_YOCTO)
                .ft_transfer(
                    self.treasury_id.clone(),
                    U128::from(treasury_fee_amount),
                    None,
                );

            let remain = deposit.0 - reserve.0;
            if remain > 0 {
                ext_fungible_token::ext(self.stable_coin_id.clone())
                    .with_static_gas(GAS_FOR_FT_TRANSFER)
                    .with_attached_deposit(ONE_YOCTO)
                    .ft_transfer(
                        from.clone(),
                        U128(remain),
                        None,
                    );
            }

            log!("Buy {} {} {}", from, amount.0, reserve.0);
            true
        } else {
            ext_fungible_token::ext(self.stable_coin_id.clone())
                .with_static_gas(GAS_FOR_FT_TRANSFER)
                .with_attached_deposit(ONE_YOCTO)
                .ft_transfer(
                    from.clone(),
                    deposit,
                    None,
                );
            false
        }
    }

    /// sell proxy token
    pub fn sell(&mut self, token_ids: Vec<TokenId>) -> Promise {
        self.assert_not_paused();
        self.assert_is_ongoing();

        let cal_coin_amount = self.calculate_sell_proxy_token(token_ids.clone());
        assert!(cal_coin_amount > 0, "{}", ERR09_INVALID_ACTION);

        // Burn Proxy Token
        self.pt_burn(
            env::predecessor_account_id(),
            token_ids.clone(),
        );

        // Transfer stable coin to customer
        ext_fungible_token::ext(self.stable_coin_id.clone())
            .with_static_gas(GAS_FOR_FT_TRANSFER)
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer(
                env::predecessor_account_id(),
                U128(cal_coin_amount),
                None,
            )
            .then(
                ext_self::ext(env::current_account_id())
                .with_static_gas(Gas(5 * TGAS))
                .on_sell(env::predecessor_account_id(), U128(cal_coin_amount), token_ids)
            )
    }

    #[private]
    pub fn on_sell(&mut self, from: AccountId, refund: U128, token_ids: Vec<TokenId>) -> bool {
        if is_promise_success() {
            self.total_fund_amount = self.total_fund_amount.checked_sub(refund.0).unwrap();
            // update circulating supply
            self.circulating_supply -= token_ids.len() as u128;

            log!("Sell {} [{}] {}", from, token_ids.join(","), refund.0);
            true
        } else {
            self.revert_pt_burn(from, token_ids);

            false
        }
    }

    /// convert proxy token to real token
    pub fn convert(&mut self, token_ids: Vec<TokenId>) -> Promise {
        self.assert_not_paused();
        self.assert_is_after_buffer_period();

        let convert_project_token;
        if self.closed_step >= ClosedStep::RemainProxy {
            convert_project_token = self.internal_convert_transfer(env::predecessor_account_id(), token_ids.len() as u128)
        } else {
            convert_project_token = self.internal_project_token_mint(env::predecessor_account_id(), U128::from(token_ids.len() as u128))
        };

        self.pt_burn(env::predecessor_account_id(), token_ids.clone());

        convert_project_token
            .then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(Gas(5 * TGAS))
                    .on_convert(env::predecessor_account_id(), token_ids)
            )
    }

    #[private]
    pub fn on_convert(&mut self, from: AccountId, token_ids: Vec<TokenId>) -> bool {
        if !is_promise_success() {
            self.revert_pt_burn(from.clone(), token_ids.clone());
            return false;
        }
        
        self.converted_amount = self.converted_amount.checked_add(token_ids.len() as u128).unwrap();

        log!("Convert {} {}", from, token_ids.join(","));
        true
    }

    /// claim fund
    pub fn claim_fund(&mut self, to: AccountId, amount: U128) -> Promise {
        self.assert_owner();
        self.assert_is_after_conversion_period();

        let total_finder_fee = self.total_fund_amount.checked_mul(self.finder_fee as u128).unwrap().checked_div(FEE_DIVISOR as u128).unwrap();
        let total_claimable_fund = self.total_fund_amount.checked_sub(total_finder_fee).unwrap();
        assert!(amount.0 > 0 && (total_claimable_fund - self.claimed_fund_amount) >= amount.0, "{}", ERR010_INVALID_AMOUNT);

        ext_fungible_token::ext(self.stable_coin_id.clone())
            .with_static_gas(Gas(5 * TGAS))
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer(
                to,
                U128::from(amount.0),
                None,
            )
            .then(
                ext_self::ext(env::current_account_id())
                        .with_static_gas(Gas(5 * TGAS))
                        .on_claim_fund(amount)
            )
    }

    #[private]
    pub fn on_claim_fund(&mut self, amount: U128) -> bool {
        if is_promise_success() {
            self.claimed_fund_amount = self.claimed_fund_amount + amount.0;
            return true;
        }

        false
    }

    /// claim finder fee
    pub fn claim_finder_fee(&mut self, amount: U128) -> Promise {
        self.assert_owner();
        self.assert_is_after_conversion_period();

        let total_finder_fee = self.total_fund_amount.checked_mul(self.finder_fee as u128).unwrap().checked_div(FEE_DIVISOR as u128).unwrap();
        assert!(amount.0 > 0 && (total_finder_fee - self.claimed_finder_fee) >= amount.0, "{}", ERR010_INVALID_AMOUNT);

       ext_fungible_token::ext(self.stable_coin_id.clone())
            .with_static_gas(Gas(5 * TGAS))
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer(
                self.finder_id.clone().unwrap(),
                U128::from(amount.0),
                None,
            )
           .then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(Gas(5 * TGAS))
                    .on_claim_finder_fee(amount)
            )
    }

    #[private]
    pub fn on_claim_finder_fee(&mut self, amount: U128) -> bool {
        if is_promise_success() {
            self.claimed_finder_fee = self.claimed_finder_fee + amount.0;
            return true;
        }

        false
    }

    /// close project 1-step pre-mint
    pub fn close_project(&mut self) -> PromiseOrValue<bool> {
        self.assert_owner();
        assert!(
            self.start_timestamp == 0 ||
                (self.tp_timestamp > 0 &&
                    env::block_timestamp() > self.tp_timestamp.checked_add(self.buffer_period).unwrap().checked_add(self.conversion_period).unwrap()),
            "{}",
            ERR011_NOT_AVAILABLE_TO_CLOSE
        );

        let close_promise: Option<Promise> = match self.closed_step {
            ClosedStep::None => {
                if self.pre_mint_amount > 0 {
                    let token_ids = (0..self.pre_mint_amount - 1).enumerate().map(|(_, token_id)| { token_id.to_string() }).collect();
                    self.pt_burn(self.owner_id.clone(), token_ids);

                    Some(self.internal_project_token_mint(self.owner_id.clone(), U128::from(self.pre_mint_amount)))
                } else {
                    None
                }
            }
            ClosedStep::PreMint => {
                let remain_proxys = self.circulating_supply.checked_sub(self.converted_amount).unwrap();
                if remain_proxys > 0 {
                    Some(self.internal_project_token_mint(env::current_account_id(), U128::from(remain_proxys)))
                } else {
                    None
                }
            }
            ClosedStep::RemainProxy => {
                Some(match self.project_token_type {
                        ProjectTokenType::Fungible =>
                            ext_fungible_token::ext(self.project_token_id.clone().unwrap())
                                .with_static_gas(Gas(5 * TGAS))
                                .set_owner(self.owner_id.clone()),
                        ProjectTokenType::NonFungible => ext_nft_collection::ext(self.project_token_id.clone().unwrap())
                            .with_static_gas(Gas(5 * TGAS))
                            .set_owner(self.owner_id.clone())
                })
            }
            ClosedStep::TransferOwnership => {
                env::panic_str(ERR012_ALREADY_CLOSED);
            }
        };

        return if close_promise.is_none() {
            self.closed_step = self.closed_step.increase();
            PromiseOrValue::Value(true)
        } else {
            PromiseOrValue::Promise(
                close_promise.unwrap()
                    .then(
                        ext_self::ext(env::current_account_id())
                            .with_static_gas(Gas(5 * TGAS))
                            .on_close_project()
                    )
            )
        }
    }

    pub fn on_close_project(&mut self) -> bool {
        if is_promise_success() {
            self.closed_step = self.closed_step.increase();
            return true;
        }

        if self.closed_step == ClosedStep::None {
            let token_ids = (0..self.pre_mint_amount - 1).enumerate().map(|(_, token_id)| { token_id.to_string() }).collect();
            self.revert_pt_burn(self.owner_id.clone(), token_ids);
        }

        return false;
    }

    pub fn internal_project_token_mint(&mut self, to: AccountId, amount: U128) -> Promise {
        match self.project_token_type {
            ProjectTokenType::NonFungible => ext_nft_collection::ext(self.project_token_id.clone().unwrap())
                .with_static_gas(Gas(100 * TGAS))
                .with_attached_deposit(DEPOSIT_ONE_NFT_MINT * amount.0)
                .nft_mint(
                    to,
                    amount,
                ),
            ProjectTokenType::Fungible => ext_fungible_token::ext(self.project_token_id.clone().unwrap())
                .with_static_gas(Gas(100 * TGAS))
                .ft_mint(
                    to,
                    amount,
                ),
        }
    }

    pub fn internal_convert_transfer(&mut self, to: AccountId, amount: u128) -> Promise {
        match self.project_token_type {
            ProjectTokenType::NonFungible => {
                let token_ids: Vec<TokenId> = (0..amount-1).enumerate().map(|(_, id)| {
                    return (self.pre_mint_amount + self.converted_amount + id).to_string();
                }).collect();
                ext_nft_collection::ext(self.project_token_id.clone().unwrap())
                    .with_static_gas(Gas(5 * TGAS))
                    .with_attached_deposit(ONE_YOCTO)
                    .nft_batch_transfer(
                        to.clone(),
                        token_ids,
                        Some("".to_string()),
                    )
            }
            ProjectTokenType::Fungible => ext_fungible_token::ext(self.project_token_id.clone().unwrap())
                .with_static_gas(Gas(5 * TGAS))
                .with_attached_deposit(ONE_YOCTO)
                .ft_transfer(
                    to,
                    U128::from(amount),
                    None,
                ),
        }
    }
}

#[allow(dead_code, unused)]
#[cfg(test)]
mod tests {
    use near_sdk::{test_utils::*, testing_env, AccountId, ONE_NEAR};
    use super::*;

    fn contract_account() -> AccountId {
        "contract".parse::<AccountId>().unwrap()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(contract_account())
            .account_balance(15 * ONE_NEAR)
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test() {}
}
'''
'''--- nft_escrow/src/owner.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn get_owner(&self) -> AccountId {
        self.owner_id.clone()
    }

    pub fn set_owner(&mut self, owner_id: AccountId) {
        self.assert_owner();
        self.owner_id = owner_id.into();
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "{}",
            ERR20_NOT_ALLOW
        );
    }
}

'''
'''--- nft_escrow/src/pause.rs ---
use crate::*;
use near_sdk::assert_one_yocto;

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn pause_contract(&mut self) {
        assert_one_yocto();
        self.assert_owner();

        if self.state == RunningState::Running {
            env::log_str(format!("Contract paused by {}", env::predecessor_account_id()).as_str());
            self.state = RunningState::Paused;
        } else {
            env::log_str("Contract state is already in Paused");
        }
    }

    #[payable]
    pub fn resume_contract(&mut self) {
        assert_one_yocto();
        self.assert_owner();

        if self.state == RunningState::Paused {
            env::log_str(format!("Contract resumed by {}", env::predecessor_account_id()).as_str());
            self.state = RunningState::Running;
        } else {
            env::log_str("Contract state is already in Running");
        }
    }

    pub(crate) fn assert_not_paused(&self) {
        assert_eq!(self.state, RunningState::Running, "{}", ERR30_PAUSED);
    }
}
'''
'''--- nft_escrow/src/proxy_token.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// Mint nft tokens with amount belonging to `receiver_id`.
    /// caller should be owner
    #[private]
    #[payable]
    pub fn pt_mint(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
    ) {
        let mut token_ids: Vec<String> = vec![];
        let mut i = 0;

        // Remember current storage usage if refund_id is Some
        let initial_storage_usage = env::storage_usage();

        while i < amount.0 {
            let token_id: TokenId = self.pt_all_total_supply.checked_add(i).unwrap().to_string();

            // Insert new supply
            self.pt_total_supply.insert(
                &token_id,
                &self
                    .pt_total_supply
                    .get(&token_id).unwrap_or(0)
                    .checked_add(1)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow")));

            // Insert new balance
            if self.pt_balances_per_token.get(&token_id).is_none() {
                let mut new_set: LookupMap<AccountId, u128> = LookupMap::new(StorageKey::BalancesInner {
                    token_id: env::sha256(token_id.as_bytes()),
                });
                new_set.insert(&receiver_id, &1u128);
                self.pt_balances_per_token.insert(&token_id, &new_set);
            } else {
                let new = self.pt_balances_per_token.get(&token_id).unwrap().get(&receiver_id).unwrap_or(0).checked_add(1).unwrap();
                let mut balances = self.pt_balances_per_token.get(&token_id).unwrap();
                balances.insert(&receiver_id, &new);
            }

            token_ids.push(token_id);
            i += 1;
        }

        refund_deposit_to_account(env::storage_usage() - initial_storage_usage, env::predecessor_account_id());

        self.pt_all_total_supply = self.pt_all_total_supply.checked_add(amount.0).unwrap();
    }

    /// Burn nft tokens from `from_id`.
    /// caller should be owner
    pub(crate) fn pt_burn(
        &mut self,
        from_id: AccountId,
        token_ids: Vec<TokenId>,
    ) {
        assert!(token_ids.len() > 0, "Invalid param");

        token_ids.iter().enumerate().for_each(|(_, token_id)| {
            let balance = self.internal_unwrap_balance_of(token_id, &from_id);
            if let Some(new) = balance.checked_sub(1) {
                let mut balances = self.pt_balances_per_token.get(token_id).unwrap();
                balances.insert(&from_id, &new);
                self.pt_total_supply.insert(
                    token_id,
                    &self
                        .pt_total_supply
                        .get(token_id)
                        .unwrap()
                        .checked_sub(1)
                        .unwrap_or_else(|| env::panic_str("Total supply overflow")),
                );
            } else {
                env::panic_str("The account doesn't have enough balance");
            }
        });

        self.pt_all_total_supply = self.pt_all_total_supply.checked_sub(token_ids.len().try_into().unwrap()).unwrap();
    }

    // revert burning proxy token
    pub(crate) fn revert_pt_burn(
        &mut self,
        from_id: AccountId,
        token_ids: Vec<TokenId>,
    ) {
        assert!(token_ids.len() > 0, "Invalid param");

        token_ids.iter().enumerate().for_each(|(_, token_id)| {
            let balance = self.internal_unwrap_balance_of(token_id, &from_id);
            let mut balances = self.pt_balances_per_token.get(token_id).unwrap();
            balances.insert(&from_id, &(balance + 1));
            self.pt_total_supply.insert(
                token_id,
                &self
                    .pt_total_supply
                    .get(token_id)
                    .unwrap()
                    .checked_add(1)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow")),
            );
        });

        self.pt_all_total_supply = self.pt_all_total_supply.checked_add(token_ids.len().try_into().unwrap()).unwrap();
    }

    pub fn pt_token(&self, token_id: TokenId) -> Option<Token> {
        let metadata = ProxyTokenMetadata {
            title: Some(token_id.clone()),
            description: None,
            media: Some(self.pt_media_uri.clone()),
            media_hash: None,
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None
        };
        let supply = self.pt_total_supply.get(&token_id)?;

        Some(Token {
            token_id,
            owner_id: None,
            supply,
            metadata
        })
    }

    /// Used to get balance of specified account in specified token
    pub fn internal_unwrap_balance_of(
        &self,
        token_id: &TokenId,
        account_id: &AccountId,
    ) -> Balance {
        match self
            .pt_balances_per_token
            .get(token_id)
            .expect("This token does not exist")
            .get(account_id)
        {
            Some(balance) => balance,
            None => 0u128
        }
    }

    pub fn pt_balance_of(&self, owner: AccountId, ids: Vec<TokenId>) -> Vec<u128> {
        self.pt_balances_per_token
            .iter()
            .filter(|(token_id, _)| ids.contains(token_id))
            .map(|(_, balances)| {
                balances
                    .get(&owner)
                    .unwrap_or_default()
            })
            .collect()
    }

    pub fn pt_metadata(&self) -> PTContractMetadata {
        return PTContractMetadata {
            spec: PT_METADATA_SPEC.to_string(),
            name: self.name.clone(),
            symbol: self.symbol.clone(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        };
    }

    pub fn pt_pt_all_total_supply(&self) -> Balance { self.pt_all_total_supply.clone() }
}
'''
'''--- nft_escrow/src/pt_metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{AccountId, require};
use near_sdk::serde::{Deserialize, Serialize};

/// Version of standard
pub const PT_METADATA_SPEC: &str = "mt-0.0.1";

/// Type alias for convenience
pub type TokenId = String;

/// Metadata that will be permanently set at the contract init
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct PTContractMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub base_uri: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
}

/// Metadata for each token
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct ProxyTokenMetadata {
    pub title: Option<String>,
    /// Free-form description
    pub description: Option<String>,
    /// URL to associated media, preferably to decentralized, content-addressed storage
    pub media: Option<String>,
    /// Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub media_hash: Option<String>,
    /// When token was issued or minted, Unix epoch in milliseconds
    pub issued_at: Option<String>,
    /// When token expires, Unix epoch in milliseconds
    pub expires_at: Option<String>,
    /// When token starts being valid, Unix epoch in milliseconds
    pub starts_at: Option<String>,
    /// When token was last updated, Unix epoch in milliseconds
    pub updated_at: Option<String>,
    /// Anything extra the MT wants to store on-chain. Can be stringified JSON.
    pub extra: Option<String>,
    /// URL to an off-chain JSON file with more info.
    pub reference: Option<String>,
    /// Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    pub reference_hash: Option<String>,
}

/// Info on individual token
#[derive(Debug, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
pub struct Token {
    pub token_id: TokenId,
    pub owner_id: Option<AccountId>,
    /// Total amount generated
    pub supply: u128,
    pub metadata: ProxyTokenMetadata,
}

impl PTContractMetadata {
    pub fn assert_valid(&self) {
        require!(self.spec == PT_METADATA_SPEC, "Spec is not ProxyToken metadata");
        require!(
            self.reference.is_some() == self.reference_hash.is_some(),
            "Reference and reference hash must be present"
        );
        if let Some(reference_hash) = &self.reference_hash {
            require!(reference_hash.len() == 32, "Hash has to be 32 bytes");
        }
    }
}

impl ProxyTokenMetadata {
    pub fn assert_valid(&self) {
        require!(self.media.is_some() == self.media_hash.is_some());
        if let Some(media_hash) = &self.media_hash {
            require!(media_hash.len() == 32, "Media hash has to be 32 bytes");
        }

        require!(self.reference.is_some() == self.reference_hash.is_some());
        if let Some(reference_hash) = &self.reference_hash {
            require!(reference_hash.len() == 32, "Reference hash has to be 32 bytes");
        }
    }
}
'''
'''--- nft_escrow/src/token_receiver.rs ---
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::{AccountId, env, PromiseOrValue};
use near_sdk::json_types::U128;

use crate::*;

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unreachable_code)]
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128> {
        self.assert_not_paused();
        self.assert_is_ongoing();

        let token_in = env::predecessor_account_id();
        let args = msg.split(":").collect::<Vec<&str>>();

        if args.len() == 2 && args[0] == "buy" && token_in == self.stable_coin_id {
            self.buy(sender_id, U128(args[1].parse::<u128>().unwrap()), amount);
        }

        PromiseOrValue::Value(U128(0))
    }
}
'''
'''--- nft_escrow/src/utils.rs ---
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::{ext_contract, AccountId, Gas, Balance, PromiseOrValue, env, require, Promise};
use near_sdk::json_types::{U128};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use uint::construct_uint;

/// Fee divisor, allowing to provide fee in bps.
pub const FEE_DIVISOR: u32 = 10_000;
/// Amount of gas for fungible token transfers.
pub const GAS_FOR_FT_TRANSFER: Gas = Gas::ONE_TERA;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum RunningState {
    Running,
    Paused,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum ProjectTokenType {
    NonFungible,
    Fungible,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum CurveType {
    Horizontal,
    Linear,
    Sigmoidal,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Eq, PartialEq, PartialOrd, Clone, Debug)]
pub enum ClosedStep {
    None = 0,
    PreMint = 1,
    RemainProxy = 2,
    TransferOwnership = 3
}

impl ClosedStep {
    pub fn increase(&self) -> ClosedStep {
        return match self {
            ClosedStep::None => {
                ClosedStep::PreMint
            }
            ClosedStep::PreMint => {
                ClosedStep::RemainProxy
            }
            _ => {
                ClosedStep::TransferOwnership
            }
        }
    }

    pub fn decrease(&self) -> ClosedStep {
        return match self {
            ClosedStep::TransferOwnership => {
                ClosedStep::RemainProxy
            }
            ClosedStep::RemainProxy => {
                ClosedStep::PreMint
            }
            _ => {
                ClosedStep::None
            }
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct CurveArgs {
    pub arg_a: Option<u128>,
    pub arg_b: Option<u128>,
    pub arg_c: Option<u128>,
    pub arg_d: Option<u128>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenArgs {
    pub owner_id: AccountId,
    pub name: String,
    pub symbol: String
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NonFungibleTokenArgs {
    pub owner_id: AccountId,
    pub name: String,
    pub symbol: String,
    pub base_uri: String,
    pub max_supply: U128
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ProxyTokenArgs {
    pub owner_id: AccountId,
    pub name: String,
    pub symbol: String,
    pub blank_media_uri: String,
    pub max_supply: U128
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ProxyTokenMintArgs {
    pub receiver_id: AccountId,
    pub amount: U128
}
#[ext_contract(ext_self)]
pub trait SelfCallbacks {
    fn on_activate(
        &mut self,
        project_token_id: AccountId
    ) -> PromiseOrValue<bool>;
    fn on_buy(&mut self, from: AccountId, amount: U128, deposit: U128, reserve: U128) -> bool;
    fn on_sell(&mut self, from: AccountId, refund: U128, token_ids: Vec<TokenId>) -> bool;
    fn on_convert(&mut self, from: AccountId, token_ids: Vec<TokenId>) -> bool;
    fn on_claim_fund(&mut self, amount: U128);
    fn on_claim_finder_fee(&mut self, amount: U128);
    fn on_close_project(&mut self);
    fn pt_mint(&mut self, receiver_id: AccountId, amount: U128);
}

#[ext_contract(ext_nft_collection)]
pub trait NonFungibleToken {
    fn new(&mut self, name: String, symbol: String, blank_uri: String, max_supply: U128);
    fn nft_mint(&mut self, receiver_id: AccountId, amount: U128);
    fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId, approval_id: Option<u64>, memo: Option<String>);
    fn nft_batch_transfer(&mut self, to: AccountId, token_ids: Vec<TokenId>, memo: Option<String>);
    fn get_owner(&self) -> AccountId;
    fn set_owner(&mut self, owner_id: AccountId);
}

#[ext_contract(ext_fungible_token)]
pub trait FungibleToken {
    fn new(&mut self, name: String, symbol: String);
    fn ft_mint(&mut self, receiver_id: AccountId, amount: U128);
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
    fn get_owner(&self) -> AccountId;
    fn set_owner(&mut self, owner_id: AccountId);
}

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

/// Newton's method of integer square root.
pub fn integer_sqrt(value: U256) -> U256 {
    let mut guess: U256 = (value + 1) >> 1;
    let mut res = value;
    while guess < res {
        res = guess;
        guess = (value / guess + guess) >> 1;
    }
    res
}

pub fn refund_deposit_to_account(storage_used: u64, account_id: AccountId) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    require!(
        required_cost <= attached_deposit,
        format!("Must attach {} yoctoNEAR to cover storage, attached {}", required_cost, attached_deposit)
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(account_id).transfer(refund);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sqrt() {
        assert_eq!(integer_sqrt(U256::from(0u128)), 0u128.into());
        assert_eq!(integer_sqrt(U256::from(4u128)), 2u128.into());
        assert_eq!(
            integer_sqrt(U256::from(1_516_156_330_329u128)),
            1_231_323u128
        );
    }
}
'''
'''--- nft_escrow/src/validates.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub(crate) fn assert_is_ongoing(&self) {
        assert!(self.start_timestamp > 0, "{}", ERR10_NOT_ACTIVATED);
        assert!(
            self.tp_timestamp == 0
                || env::block_timestamp()
                    < self
                        .tp_timestamp
                        .checked_add(self.buffer_period)
                        .unwrap()
                        .checked_add(self.conversion_period)
                        .unwrap(),
            "{}",
            ERR11_NOT_ONGOING
        );
    }

    pub(crate) fn assert_is_after_buffer_period(&self) {
        assert!(self.tp_timestamp > 0, "{}", ERR12_NOT_OVER_FUNDING_TARGET);
        assert!(
            env::block_timestamp() >= self.tp_timestamp.checked_add(self.buffer_period).unwrap(),
            "{}",
            ERR13_IN_BUFFER_PERIOD
        );
    }

    pub(crate) fn assert_is_after_conversion_period(&self) {
        assert!(self.tp_timestamp > 0, "{}", ERR12_NOT_OVER_FUNDING_TARGET);
        assert!(
            env::block_timestamp()
                > self
                    .tp_timestamp
                    .checked_add(self.buffer_period)
                    .unwrap()
                    .checked_add(self.conversion_period)
                    .unwrap(),
            "{}",
            ERR14_NOT_OVER_CONVERSION_PERIOD
        );
    }
}

'''
'''--- nft_escrow/src/views.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn get_project_token_type(&self) -> ProjectTokenType { self.project_token_type.clone() }

    pub fn get_project_token_id(&self) -> AccountId { self.project_token_id.clone().unwrap() }

    pub fn get_finder_fee(&self) -> u32 { self.finder_fee }

    pub fn get_finder_id(&self) -> AccountId { self.finder_id.clone().unwrap() }

    pub fn get_treasury_fee(&self) -> u32 { self.treasury_fee }

    pub fn get_treasury_id(&self) -> AccountId { self.treasury_id.clone() }

    pub fn get_fund_threshold(&self) -> Balance { self.fund_threshold }

    pub fn get_total_fund_amount(&self) -> Balance { self.total_fund_amount }

    pub fn get_pre_mint_amount(&self) -> Balance { self.pre_mint_amount }

    pub fn get_start_timestamp(&self) -> u64 { self.start_timestamp }

    pub fn get_tp_timestamp(&self) -> u64 { self.tp_timestamp }

    pub fn get_buffer_period(&self) -> u64 { self.buffer_period }

    pub fn get_conversion_period(&self) -> u64 { self.conversion_period }

    pub fn get_stable_coin_id(&self) -> AccountId { self.stable_coin_id.clone() }

    pub fn get_running_state(&self) -> RunningState { self.state.clone() }

    pub fn get_closed_step(&self) -> ClosedStep { self.closed_step.clone() }

    pub fn get_converted_amount(&self) -> Balance { self.converted_amount }

    pub fn get_circulating_supply(&self) -> Balance { self.circulating_supply }
}
'''
'''--- nft_escrow/test.sh ---
#!/usr/bin/env bash

bash ./build.sh

cargo test --test escrow-tests -- --nocapture
'''
'''--- nft_escrow/tests/escrow-tests.rs ---
mod helpers;

use near_sdk::json_types::U128;
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{Account, Contract, DevNetwork, Worker, AccountId};
use helpers::*;

const FUNGIBLE_TOKEN_CODE: &[u8] = include_bytes!("../../target/wasm32-unknown-unknown/release/ft_token.wasm");
const NFT_ESCROW_CODE: &[u8] = include_bytes!("../../target/wasm32-unknown-unknown/release/nft_escrow_sc.wasm");
const STORAGE_BYTE_COST: u128 = 10_000_000_000_000_000_000;
const DEPOSIT_ONE_PT_MINT: u128 = 415 * STORAGE_BYTE_COST;

fn parse_unit_with_decimals(amount: u128, decimals: u8) -> u128 {
    return amount * 10u128.pow(decimals as u32)
}

async fn init(
    worker: &Worker<impl DevNetwork>
) -> anyhow::Result<(Contract, Contract, Account, Account, Account, Account, Account, u128)> {
    let owner = worker.dev_create_account().await?;
    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let finder = worker.dev_create_account().await?;
    let treasury = worker.dev_create_account().await?;

    let stable_coin_decimals = 24u8;
    let one_coin = 10u128.pow(stable_coin_decimals as u32);

    // deploy USDT
    let stable_coin_contract = worker.dev_deploy(FUNGIBLE_TOKEN_CODE).await?;
    let res = stable_coin_contract
        .call(&worker, "new")
        .args_json((owner.id(), String::from("USD Tether"), String::from("USDT"), 24u8))?
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // register owner
    stable_coin_contract
        .call(&worker, "storage_deposit")
        .args_json((owner.id(), Option::<bool>::None))?
        .deposit(125 * STORAGE_BYTE_COST)
        .max_gas()
        .transact()
        .await?;
        
    // treansfer 1000 USDT to owner
    owner.call(&worker, stable_coin_contract.id(), "ft_mint")
        .args_json((owner.id(), U128(parse_unit_with_decimals(1000_000_000u128, 24u8))))?
        .max_gas()
        .transact()
        .await?;

    // register alice
    stable_coin_contract
        .call(&worker, "storage_deposit")
        .args_json((alice.id(), Option::<bool>::None))?
        .deposit(125 * STORAGE_BYTE_COST)
        .max_gas()
        .transact()
        .await?;

    // treansfer 1000 USDT to alice
    owner.call(&worker, stable_coin_contract.id(), "ft_mint")
        .args_json((alice.id(), U128(parse_unit_with_decimals(1000_000_000u128, 24u8))))?
        .max_gas()
        .transact()
        .await?;

    // register finder
    stable_coin_contract
        .call(&worker, "storage_deposit")
        .args_json((finder.id(), Option::<bool>::None))?
        .deposit(125 * STORAGE_BYTE_COST)
        .max_gas()
        .transact()
        .await?;

    // register treasury
    stable_coin_contract
        .call(&worker, "storage_deposit")
        .args_json((treasury.id(), Option::<bool>::None))?
        .deposit(125 * STORAGE_BYTE_COST)
        .max_gas()
        .transact()
        .await?;

    // deploy escrow
    let escrow_contract = worker.dev_deploy(NFT_ESCROW_CODE).await?;
    let curve_args = CurveArgs {
        arg_a: Some(100u128),
        arg_b: None,
        arg_c: None,
        arg_d: None,
    };

    // register escrow contract
    let res = escrow_contract
        .call(&worker, "new")
        .args_json((owner.id(), NAME, SYMBOL, NFT_BLANK_URI, stable_coin_contract.id(), stable_coin_decimals, CurveType::Horizontal, curve_args, treasury.id()))?
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    stable_coin_contract
        .call(&worker, "storage_deposit")
        .args_json((escrow_contract.id(), Option::<bool>::None))?
        .deposit(125 * STORAGE_BYTE_COST)
        .max_gas()
        .transact()
        .await?;

    Ok((escrow_contract, stable_coin_contract, owner, alice, bob, finder, treasury, one_coin))
}

#[tokio::test]
async fn test_active_nft_project() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (contract, _, owner, _, _, finder, _, _) = init(&worker).await?;

    let res = owner
        .call(&worker, contract.id(), "active_nft_project".into())
        .args_json((NFT_BASE_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success() && res.failures().is_empty());
    
    Ok(())
}

#[tokio::test]
async fn test_active_ft_project() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (contract, _, owner, _, _, finder, _, _) = init(&worker).await?;

    let res = owner
        .call(&worker, contract.id(), "active_ft_project".into())
        .args_json((FT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success() && res.failures().is_empty());

    Ok(())
}

#[tokio::test]
async fn test_auction_curve_horizontal() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (_, stable_coin_contract, owner, _, _, finder, treasury, one_coin) = init(&worker).await?;

    // deploy
    let escrow_contract = worker.dev_deploy(NFT_ESCROW_CODE).await?;
    const BASE_TOKEN_PRICE: u128 = 100u128;
    let curve_args = CurveArgs {
        arg_a: Some(BASE_TOKEN_PRICE),
        arg_b: None,
        arg_c: None,
        arg_d: None,
    };

    // initialize
    escrow_contract
        .call(&worker, "new")
        .args_json((owner.id(), NAME, SYMBOL, NFT_BLANK_URI, stable_coin_contract.id(), 24u8, CurveType::Horizontal, &curve_args, treasury.id()))?
        .max_gas()
        .transact()
        .await?;

    // active project
    owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BASE_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;

    let curve_type = escrow_contract.call(&worker, "get_curve_type")
        .view()
        .await?
        .json::<CurveType>()?;

    assert_eq!(curve_type, CurveType::Horizontal);

    let _curve_args = escrow_contract.call(&worker, "get_curve_args")
        .view()
        .await?
        .json::<CurveArgs>()?;

    assert_eq!(&_curve_args.arg_a, &curve_args.arg_a);

    for token_id in 1..10 {
        let token_price =
            escrow_contract
                .view(
                    &worker,
                    "get_token_price",
                    json!({
                        "token_id": U128::from(token_id as u128 + PRE_MINT_AMOUNT.0) 
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Token ID: {}, Curve Price: {}", token_id.to_string(), (token_price / one_coin).to_string());
    }

    println!("-- Buy Price --");
    for amount in 0..10 {
        let buy_price =
            escrow_contract
                .view(
                    &worker,
                    "calculate_buy_proxy_token",
                    json!({
                        "amount": U128::from(amount as u128)
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Amount: {}, Buy Price: {}", amount.to_string(), (buy_price as f64 / one_coin as f64).to_string());
    }

    println!("-- Sell Price --");
    for token_id in 0..10 {
        let token_ids: Vec<String> = vec![(token_id + PRE_MINT_AMOUNT.0).to_string()];
        let buy_price =
            escrow_contract
                .view(
                    &worker,
                    "calculate_sell_proxy_token",
                    json!({
                        "token_ids": token_ids
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Token ID: {}, Sell Price: {}", token_id.to_string(), (buy_price as f64 / one_coin as f64).to_string());
    }

    Ok(())
}

#[tokio::test]
async fn test_auction_curve_linear() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (_, stable_coin_contract, owner, _, _, finder, treasury, one_coin) = init(&worker).await?;

    // deploy
    let escrow_contract = worker.dev_deploy(NFT_ESCROW_CODE).await?;
    const CURVE_K: u128 = 2u128;
    const BASE_TOKEN_PRICE: u128 = 100u128;
    let curve_args = CurveArgs {
        arg_a: Some(CURVE_K),
        arg_b: Some(BASE_TOKEN_PRICE),
        arg_c: None,
        arg_d: None,
    };

    // initialize
    escrow_contract
        .call(&worker, "new")
        .args_json((owner.id(), NAME, SYMBOL, NFT_BLANK_URI, stable_coin_contract.id(), 24u8, CurveType::Linear, &curve_args, treasury.id()))?
        .max_gas()
        .transact()
        .await?;

    // active project
    owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BASE_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;

    let curve_type = escrow_contract.call(&worker, "get_curve_type")
        .view()
        .await?
        .json::<CurveType>()?;

    assert_eq!(curve_type, CurveType::Linear);

    let _curve_args = escrow_contract.call(&worker, "get_curve_args")
        .view()
        .await?
        .json::<CurveArgs>()?;

    assert_eq!(&_curve_args.arg_a, &curve_args.arg_a);
    assert_eq!(&_curve_args.arg_b, &curve_args.arg_b);

    println!("-- Token Price --");
    for token_id in 0..10 {
        let token_price =
            escrow_contract
                .view(
                    &worker,
                    "get_token_price",
                    json!({
                        "token_id": U128::from(token_id as u128 + PRE_MINT_AMOUNT.0)
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Token ID: {}, Curve Price: {}", token_id.to_string(), (token_price / one_coin).to_string());
    }

    println!("-- Buy Price --");
    for amount in 0..10 {
        let buy_price =
            escrow_contract
                .view(
                    &worker,
                    "calculate_buy_proxy_token",
                    json!({
                        "amount": U128::from(amount as u128)
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Amount: {}, Buy Price: {}", amount.to_string(), (buy_price as f64 / one_coin as f64).to_string());
    }

    println!("-- Sell Price --");
    for token_id in 0..10 {
        let token_ids: Vec<String> = vec![(token_id + PRE_MINT_AMOUNT.0).to_string()];
        let buy_price =
            escrow_contract
                .view(
                    &worker,
                    "calculate_sell_proxy_token",
                    json!({
                        "token_ids": token_ids
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Token ID: {}, Sell Price: {}", token_id.to_string(), (buy_price as f64 / one_coin as f64).to_string());
    }

    Ok(())
}

#[tokio::test]
async fn test_auction_curve_sigmoidal() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (_, stable_coin_contract, owner, _, _, finder, treasury, one_coin) = init(&worker).await?;

    // deploy
    let escrow_contract = worker.dev_deploy(NFT_ESCROW_CODE).await?;
    const CURVE_K: u128 = 30u128;
    const ARG_B: u128 = 10u128;
    const ARG_C: u128 = 100u128;
    const BASE_TOKEN_PRICE: u128 = 100u128;
    let curve_args = CurveArgs {
        arg_a: Some(CURVE_K),
        arg_b: Some(ARG_B),
        arg_c: Some(ARG_C),
        arg_d: Some(BASE_TOKEN_PRICE),
    };

    // initialize
    escrow_contract
        .call(&worker, "new")
        .args_json((owner.id(), NAME, SYMBOL, NFT_BLANK_URI, stable_coin_contract.id(), 24u8, CurveType::Sigmoidal, &curve_args, treasury.id()))?
        .max_gas()
        .transact()
        .await?;

    // active project
    owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BASE_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;

    let curve_type = escrow_contract.call(&worker, "get_curve_type")
        .view()
        .await?
        .json::<CurveType>()?;

    assert_eq!(curve_type, CurveType::Sigmoidal);

    let _curve_args = escrow_contract.call(&worker, "get_curve_args")
        .view()
        .await?
        .json::<CurveArgs>()?;

    assert_eq!(&_curve_args.arg_a, &curve_args.arg_a);
    assert_eq!(&_curve_args.arg_b, &curve_args.arg_b);
    assert_eq!(&_curve_args.arg_c, &curve_args.arg_c);
    assert_eq!(&_curve_args.arg_d, &curve_args.arg_d);

    println!("-- Token Price --");
    for token_id in 0..10 {
        let token_price =
            escrow_contract
                .view(
                    &worker,
                    "get_token_price",
                    json!({
                        "token_id": U128::from(token_id as u128 + PRE_MINT_AMOUNT.0)
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Token ID: {}, Curve Price: {}", token_id.to_string(), (token_price as f64 / one_coin as f64).to_string());
    }

    println!("-- Buy Price --");
    for amount in 0..10 {
        let buy_price =
            escrow_contract
                .view(
                    &worker,
                    "calculate_buy_proxy_token",
                    json!({
                        "amount": U128::from(amount as u128)
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Amount: {}, Buy Price: {}", amount.to_string(), (buy_price as f64 / one_coin as f64).to_string());
    }

    println!("-- Sell Price --");
    for token_id in 0..10 {
        let token_ids: Vec<String> = vec![(token_id + PRE_MINT_AMOUNT.0).to_string()];
        let buy_price =
            escrow_contract
                .view(
                    &worker,
                    "calculate_sell_proxy_token",
                    json!({
                        "token_ids": token_ids
                    }).to_string().into_bytes(),
                )
                .await?
                .json::<u128>()?;

        println!("Token ID: {}, Sell Price: {}", token_id.to_string(), (buy_price as f64 / one_coin as f64).to_string());
    }

    Ok(())
}

#[tokio::test]
async fn test_revert_nft_buy() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, _, _, finder, treasury, _) = init(&worker).await?;

    // active project
    let _res = owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BASE_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;
    // println!("active: {:?}", _res);

    // calculate stable coin amount for buying proxy token
    let amount = U128::from(300u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    // buy proxy token
    let res = owner
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact()
        .await?;

    println!("buy: {:?}", res);
    assert!(res.is_success() && !res.failures().is_empty());

    let balance = stable_coin_contract
        .view(
            &worker,
            "ft_balance_of",
            json!({
                "account_id": escrow_contract.id()
            }).to_string().into_bytes()
        )
        .await?
        .json::<U128>()?;
    assert_eq!(balance.0, 0);

    let balance = stable_coin_contract
        .view(
            &worker,
            "ft_balance_of",
            json!({
                "account_id": treasury.id()
            }).to_string().into_bytes()
        )
        .await?
        .json::<U128>()?;
    assert_eq!(balance.0, 0);

    Ok(())
}

#[tokio::test]
async fn test_nft_buy() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, _, _, finder, treasury, _) = init(&worker).await?;

    // active project
    let _res = owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BASE_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;
    // println!("active: {:?}", _res);

    // calculate stable coin amount for buying proxy token
    let amount = U128::from(200u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    // buy proxy token
    let res = owner
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact()
        .await?;

    println!("buy: {:?}", res);
    assert!(res.is_success() && res.failures().is_empty());

    let balance = stable_coin_contract
        .view(
            &worker,
            "ft_balance_of",
            json!({
                "account_id": escrow_contract.id()
            }).to_string().into_bytes()
        )
        .await?
        .json::<U128>()?;
    assert_eq!(balance.0, coin_amount * (100u128 - PROTOCOL_FEE as u128)/100u128);

    let balance = stable_coin_contract
        .view(
            &worker,
            "ft_balance_of",
            json!({
                "account_id": treasury.id()
            }).to_string().into_bytes()
        )
        .await?
        .json::<U128>()?;
    assert_eq!(balance.0, coin_amount * (PROTOCOL_FEE as u128)/100u128);

    Ok(())
}

#[tokio::test]
async fn test_ft_buy() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, _, _, finder, treasury, _) = init(&worker).await?;

    // active project
    let _res = owner
        .call(&worker, escrow_contract.id(), "active_ft_project")
        .args_json((FT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;
    // println!("active: {:?}", _res);

    // calculate stable coin amount for buying proxy token
    let amount = U128::from(100u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    // buy proxy token
    let _res = owner
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact()
        .await?;

    assert!(_res.is_success());
    // println!("buy: {:?}", _res);

    let balance = stable_coin_contract
        .view(
            &worker,
            "ft_balance_of",
            json!({
                "account_id": escrow_contract.id()
            }).to_string().into_bytes()
        )
        .await?
        .json::<U128>()?;
    assert_eq!(balance.0, coin_amount * (100u128 - PROTOCOL_FEE as u128)/100u128);

    let balance = stable_coin_contract
        .view(
            &worker,
            "ft_balance_of",
            json!({
                "account_id": treasury.id()
            }).to_string().into_bytes()
        )
        .await?
        .json::<U128>()?;
    assert_eq!(balance.0, coin_amount * (PROTOCOL_FEE as u128)/100u128);

    Ok(())
}

#[tokio::test]
async fn test_sell() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, _, _, finder, _, _) = init(&worker).await?;

    // active project
    let _res = owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BLANK_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;
    
    // buy proxy token
    // calculate stable coin amount for buying proxy token
    let amount = U128::from(200u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    let res = owner
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());
    // println!("buy: {:?}", res);

    assert_eq!(owner
        .call(
            &worker,
            escrow_contract.id(),
            "pt_balance_of",
        )
        .args_json((owner.id(), vec![0.to_string(), 1.to_string()]))?
        .view()
        .await?
        .json::<Vec<u128>>()?, vec![1u128.into(), 1u128.into()]);

    let mut token_ids: Vec<String> = vec![];
    for i in 0..99 {
        token_ids.push(i.to_string());
    }
    // sell proxy token
    let res = owner
        .call(&worker, escrow_contract.id(), "sell".into())
        .args(json!({"token_ids": token_ids}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;

    assert!(res.is_success());
    // println!("sell: {:?}", res);

    assert_eq!(owner
        .call(
            &worker,
            escrow_contract.id(),
            "pt_balance_of",
        )
        .args_json((owner.id(), vec![0.to_string(), 1.to_string()]))?
        .view()
        .await?
        .json::<Vec<u128>>()?, vec![0u128.into(), 0u128.into()]);

    Ok(())
}

#[tokio::test]
async fn test_nft_convert() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, _, _, finder, _, _) = init(&worker).await?;

    // active project
    owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BLANK_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;

    //buy proxy token
    //calculate stable coin amount for buying proxy token
    let amount = U128::from(200u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    owner
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact()
        .await?;

    let mut token_ids: Vec<String> = vec![];
    for i in 0..99 {
        token_ids.push(i.to_string());
    }
    // sell proxy token
    owner
        .call(&worker, escrow_contract.id(), "sell".into())
        .args(json!({"token_ids": token_ids}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;

    worker.fast_forward(300).await?;

    let mut token_ids: Vec<String> = vec![];
    for i in 100..110 {
        token_ids.push(i.to_string());
    }

    // convert
    let res = owner
        .call(&worker, escrow_contract.id(), "convert")
        .args(json!({"token_ids": token_ids}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    assert_eq!(owner
       .call(
           &worker,
           escrow_contract.id(),
           "pt_balance_of",
       )
       .args_json((owner.id(), vec![100.to_string(), 101.to_string()]))?
       .view()
       .await?
       .json::<Vec<u128>>()?, vec![0u128.into(), 0u128.into()]);

    Ok(())
}

#[tokio::test]
async fn test_revert_ft_convert() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, _, _, finder, _, _) = init(&worker).await?;

    let res = owner
        .call(&worker, escrow_contract.id(), "active_ft_project".into())
        .args_json((FT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());
    // println!("active: {:?}", res);

    //buy proxy token
    //calculate stable coin amount for buying proxy token
    let amount = U128::from(100u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    let _res = owner
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact()
        .await?;

    worker.fast_forward(300).await?;

    let mut token_ids: Vec<String> = vec![];
    for i in 0..49 {
        token_ids.push(i.to_string());
    }

    // convert
    let res = owner
        .call(&worker, escrow_contract.id(), "convert")
        .args(json!({"token_ids": token_ids}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());
    println!("convert: {:?}", res);

    // not burned proxy token
    assert_eq!(owner
       .call(&worker, escrow_contract.id(), "pt_balance_of", )
       .args_json((owner.id(), vec![0.to_string(), 1.to_string()]))?
       .view()
       .await?
       .json::<Vec<u128>>()?, vec![1u128.into(), 1u128.into()]);
    Ok(())
}

#[tokio::test]
async fn test_ft_convert() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, _, _, finder, _, _) = init(&worker).await?;

    owner
        .call(&worker, escrow_contract.id(), "active_ft_project".into())
        .args_json((FT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;

    //buy proxy token
    //calculate stable coin amount for buying proxy token
    let amount = U128::from(100u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    let _res = owner
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact()
        .await?;

    worker.fast_forward(300).await?;

    // register account
    let project_token_id = escrow_contract.call(&worker, "get_project_token_id")
        .view()
        .await?
        .json::<AccountId>()?;
    owner
        .call(&worker, &project_token_id, "storage_deposit")
        .args_json((owner.id(), Option::<bool>::None))?
        .deposit(125 * STORAGE_BYTE_COST)
        .max_gas()
        .transact()
        .await?;

    let mut token_ids: Vec<String> = vec![];
    for i in 0..49 {
        token_ids.push(i.to_string());
    }

    // convert
    owner
        .call(&worker, escrow_contract.id(), "convert")
        .args(json!({"token_ids": token_ids}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;

    // burned proxy token
    assert_eq!(owner
       .call(&worker, escrow_contract.id(), "pt_balance_of", )
       .args_json((owner.id(), vec![0.to_string(), 1.to_string()]))?
       .view()
       .await?
       .json::<Vec<u128>>()?, vec![0u128.into(), 0u128.into()]);

    Ok(())
}

#[tokio::test]
async fn test_claim_fund() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, _, _, finder, _, _) = init(&worker).await?;

    owner
        .call(&worker, escrow_contract.id(), "active_ft_project".into())
        .args_json((FT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;

    //buy proxy token
    //calculate stable coin amount for buying proxy token
    let amount = U128::from(3u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    let _res = owner
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact()
        .await?;

    // pass buffer period
    worker.fast_forward(400).await?;
 
    // register account
    let project_token_id = escrow_contract.call(&worker, "get_project_token_id")
        .view()
        .await?
        .json::<AccountId>()?;
    owner
        .call(&worker, &project_token_id, "storage_deposit")
        .args_json((owner.id(), Option::<bool>::None))?
        .deposit(125 * STORAGE_BYTE_COST)
        .max_gas()
        .transact()
        .await?;

    // convert
    let res = owner
        .call(&worker, escrow_contract.id(), "convert")
        .args(json!({"token_ids": vec![2.to_string(), 3.to_string()]}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // pass conversion period
    worker.fast_forward(800).await?;

    let total_fund_amount = 
        escrow_contract.call(&worker, "get_total_fund_amount")
            .view()
            .await?
            .json::<u128>()?;
    let total_finder_fee = total_fund_amount * FINDER_FEE as u128 / 100u128;

    // claim fund
    let res = owner
        .call(&worker, escrow_contract.id(), "claim_fund")
        .args(json!({"to": owner.id(), "amount": U128(total_fund_amount - total_finder_fee)}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // claim fund
    let res = owner
        .call(&worker, escrow_contract.id(), "claim_finder_fee")
        .args(json!({"amount": U128(total_finder_fee)}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    let finder_balance = stable_coin_contract
        .view(
            &worker,
            "ft_balance_of",
            json!({
                "account_id": finder.id()
            }).to_string().into_bytes()
        )
        .await?
        .json::<U128>()?;

    assert_eq!(finder_balance.0, total_finder_fee);

    Ok(())
}

#[tokio::test]
async fn test_close_nft_project() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, alice, _, finder, _, _) = init(&worker).await?;

    // pre-mint
    owner
        .call(&worker, escrow_contract.id(), "pre_mint")
        .args(json!({"amount": PRE_MINT_AMOUNT}).to_string().as_bytes().to_vec())
        .deposit(PRE_MINT_AMOUNT.0 * DEPOSIT_ONE_PT_MINT)
        .max_gas()
        .transact()
        .await?;

    // active project
    owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BASE_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;

    //buy proxy token
    //calculate stable coin amount for buying proxy token
    let amount = U128::from(100u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    alice
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact() 
        .await?;

    worker.fast_forward(400).await?;
    
    // convert
    alice
        .call(&worker, escrow_contract.id(), "convert")
        .args(json!({"token_ids": vec![100.to_string()]}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;

    worker.fast_forward(800).await?;

    // close project - pre-mint
    let res = owner
        .call(&worker, escrow_contract.id(), "close_project")
        .args_json(json!({}).to_string().as_bytes().to_vec())?
        .max_gas()
        .transact()
        .await?;
    println!("closed1: {:?}", res);

    // // close project - mint remaining proxys
    // let res = owner
    //     .call(&worker, escrow_contract.id(), "close_project")
    //     .args_json(json!({}).to_string().as_bytes().to_vec())?
    //     .max_gas()
    //     .transact()
    //     .await?;
    // println!("closed2: {:?}", res);
    //
    // // close project - transfer ownership
    // let res = owner
    //     .call(&worker, escrow_contract.id(), "close_project")
    //     .args_json(json!({}).to_string().as_bytes().to_vec())?
    //     .max_gas()
    //     .transact()
    //     .await?;
    // println!("closed3: {:?}", res);

    // println!("close project: {:?}", res);

    Ok(())
}

#[tokio::test]
async fn test_convert_after_closing_nft_project() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (escrow_contract, stable_coin_contract, owner, alice, _, finder, _, _) = init(&worker).await?;

    // active project
    owner
        .call(&worker, escrow_contract.id(), "active_nft_project")
        .args_json((NFT_BASE_URI, NFT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
        .max_gas()
        .transact()
        .await?;

    //buy proxy token
    //calculate stable coin amount for buying proxy token
    let amount = U128::from(10u128);
    let coin_amount = escrow_contract
        .view(
            &worker,
            "calculate_buy_proxy_token",
            json!({
            "amount": amount
        }).to_string().into_bytes(),
        )
        .await?
        .json::<u128>()?;

    alice
        .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
        .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
        .deposit(1u128)
        .max_gas()
        .transact() 
        .await?;

    worker.fast_forward(400).await?;
    
    // convert
    let res = alice
        .call(&worker, escrow_contract.id(), "convert")
        .args(json!({"token_ids": vec![2.to_string()]}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());
    println!("convert: {:?}", res);

    worker.fast_forward(800).await?;

    // close project
    owner
        .call(&worker, escrow_contract.id(), "close_project")
        .args_json(json!({}).to_string().as_bytes().to_vec())?
        .max_gas()
        .transact()
        .await?;

    owner
        .call(&worker, escrow_contract.id(), "close_project")
        .args_json(json!({}).to_string().as_bytes().to_vec())?
        .max_gas()
        .transact()
        .await?;

    owner
        .call(&worker, escrow_contract.id(), "close_project")
        .args_json(json!({}).to_string().as_bytes().to_vec())?
        .max_gas()
        .transact()
        .await?;

    // println!("close project!");

    let res = alice
        .call(&worker, escrow_contract.id(), "convert")
        .args(json!({"token_ids": vec![3.to_string(),4.to_string(),5.to_string()]}).to_string().as_bytes().to_vec())
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // println!("convert: {:?}", res);

    Ok(())
}

// #[tokio::test]
// async fn test_convert_after_closing_ft_project() -> anyhow::Result<()> {
//     let worker = workspaces::sandbox().await?;
//     let (escrow_contract, stable_coin_contract, owner, alice, _, finder, _, _) = init(&worker).await?;

//     // active project
//     let res = owner
//         .call(&worker, escrow_contract.id(), "active_ft_project".into())
//         .args_json((FT_MAX_SUPPLY, finder.id(), FUND_THRESHOLD, FIVE_MINUTES, TEN_MINUTES))?
//         .max_gas()
//         .transact()
//         .await?;
//     assert!(res.is_success());
//     // println!("active: {:?}", res);

//     //buy proxy token
//     //calculate stable coin amount for buying proxy token
//     let amount = U128::from(3u128);
//     let coin_amount = escrow_contract
//         .view(
//             &worker,
//             "calculate_buy_proxy_token",
//             json!({
//             "amount": amount
//         }).to_string().into_bytes(),
//         )
//         .await?
//         .json::<u128>()?;

//     let _res = owner
//         .call(&worker, stable_coin_contract.id(), "ft_transfer_call".into())
//         .args_json((escrow_contract.id(), U128(coin_amount), Option::<String>::None, format!("buy:{}", amount.0)))?
//         .deposit(1u128)
//         .max_gas()
//         .transact()
//         .await?;

//     worker.fast_forward(300).await?;

//     // register account
//     let project_token_id = escrow_contract.call(&worker, "get_project_token_id")
//         .view()
//         .await?
//         .json::<AccountId>()?;
//     owner
//         .call(&worker, &project_token_id, "storage_deposit")
//         .args_json((owner.id(), Option::<bool>::None))?
//         .deposit(125 * STORAGE_BYTE_COST)
//         .max_gas()
//         .transact()
//         .await?;

//     // convert
//     let res = owner
//         .call(&worker, escrow_contract.id(), "convert")
//         .args(json!({"token_ids": vec![2.to_string(), 3.to_string()]}).to_string().as_bytes().to_vec())
//         .max_gas()
//         .transact()
//         .await?;
//     assert!(res.is_success());

//     worker.fast_forward(800).await?;

//     owner
//         .call(&worker, &project_token_id, "storage_deposit")
//         .args_json((escrow_contract.id(), Option::<bool>::None))?
//         .deposit(125 * STORAGE_BYTE_COST)
//         .max_gas()
//         .transact()
//         .await?;

//     // close project
//     let res = owner
//         .call(&worker, escrow_contract.id(), "close_project")
//         .args_json(json!({}).to_string().as_bytes().to_vec())?
//         .max_gas()
//         .transact()
//         .await?;
//     assert!(res.is_success());

//     // println!("close project!");

//     let res = alice
//         .call(&worker, escrow_contract.id(), "convert")
//         .args(json!({"token_ids": vec![3.to_string(),4.to_string(),5.to_string()]}).to_string().as_bytes().to_vec())
//         .max_gas()
//         .transact()
//         .await?;
//     assert!(res.is_success());

//     println!("convert: {:?}", res);

//     Ok(())
// }

'''
'''--- nft_escrow/tests/helpers.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_units::parse_near;

pub const NAME: &str = "Theia Collection 1";
pub const SYMBOL: &str = "TCN";
pub const NFT_BASE_URI: &str = "https://ipfs.io/ipfs/QmUDqczgXxZ7exQ9znjZRB1CCvEmQ5FZchatueZXWnIkly/";
pub const NFT_BLANK_URI: &str = "https://ipfs.io/ipfs/QmZRBnIklexQCvEmQxZ1CDqczgXcy7hatu9eZXW5FZUznj";
pub const NFT_MAX_SUPPLY: U128 = U128(20_000u128);
pub const FT_MAX_SUPPLY: U128 = U128(1000_000u128);
pub const PRE_MINT_AMOUNT: U128 = U128(100u128);
pub const FUND_THRESHOLD: U128 = U128(parse_near!("200 N"));
pub const PROTOCOL_FEE: u16 = 1u16; // 1%
pub const FINDER_FEE: u16 = 1u16; // 1%

pub const FIVE_MINUTES: u128 = 300u128 * 1_000_000_000;    // 5 min (nanosecond)
pub const TEN_MINUTES: u128 = 600u128 * 1_000_000_000;   // 10 min (nanosecond)

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum CurveType {
    Horizontal,
    Linear,
    Sigmoidal,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct CurveArgs {
    pub arg_a: Option<u128>,
    pub arg_b: Option<u128>,
    pub arg_c: Option<u128>,
    pub arg_d: Option<u128>,
}

'''