*GitHub Repository "nearsend/nearsend-frontend"*

'''--- .eslintrc.js ---
module.exports = {
  env: {
    browser: true,
    es2021: true,
  },
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  plugins: ['react', '@typescript-eslint'],
  rules: {
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    'react/display-name': 'off',
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'react/prop-types': 'off',
    '@typescript-eslint/no-empty-function': 'off',
    '@typescript-eslint/ban-types': 'off',
    'react/react-in-jsx-scope': 'off',
    '@typescript-eslint/ban-ts-comment': 'off',
    '@typescript-eslint/no-var-requires': 'off',
    'react-hooks/exhaustive-deps': 'off',
  },
};

'''
'''--- .lintstagedrc.json ---
{
  "*.{js, tsx, ts, jsx}": "eslint --fix",
  "*.{json,md}": "prettier --write"
}

'''
'''--- .prettierrc.js ---
module.exports = {
  semi: true,
  trailingComma: 'all',
  singleQuote: true,
  printWidth: 120,
  tabWidth: 2,
};

'''
'''--- LICENSE.md ---
Business Source License 1.1

License text copyright (c) 2017 MariaDB Corporation Ab, All Rights Reserved.
"Business Source License" is a trademark of MariaDB Corporation Ab.

-----------------------------------------------------------------------------

Parameters

Licensor:             Invoker Labs

Licensed Work:        Nearsend Frontend
                      The Licensed Work is (c) 2022 Invoker Labs

Change License:       GNU General Public License v2.0 or later

-----------------------------------------------------------------------------

Terms

The Licensor hereby grants you the right to copy, modify, create derivative
works, redistribute, and make non-production use of the Licensed Work. The
Licensor may make an Additional Use Grant, above, permitting limited
production use.

Effective on the Change Date, or the fourth anniversary of the first publicly
available distribution of a specific version of the Licensed Work under this
License, whichever comes first, the Licensor hereby grants you rights under
the terms of the Change License, and the rights granted in the paragraph
above terminate.

If your use of the Licensed Work does not comply with the requirements
currently in effect as described in this License, you must purchase a
commercial license from the Licensor, its affiliated entities, or authorized
resellers, or you must refrain from using the Licensed Work.

All copies of the original and modified Licensed Work, and derivative works
of the Licensed Work, are subject to this License. This License applies
separately for each version of the Licensed Work and the Change Date may vary
for each version of the Licensed Work released by Licensor.

You must conspicuously display this License on each original or modified copy
of the Licensed Work. If you receive the Licensed Work in original or
modified form from a third party, the terms and conditions set forth in this
License apply to your use of that work.

Any use of the Licensed Work in violation of this License will automatically
terminate your rights under this License for the current and all other
versions of the Licensed Work.

This License does not grant you any right in any trademark or logo of
Licensor or its affiliates (provided that you may use a trademark or logo of
Licensor as expressly required by this License).

TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED ON
AN "AS IS" BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS,
EXPRESS OR IMPLIED, INCLUDING (WITHOUT LIMITATION) WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND
TITLE.

MariaDB hereby grants you permission to use this License’s text to license
your works, and to refer to it using the trademark "Business Source License",
as long as you comply with the Covenants of Licensor below.

-----------------------------------------------------------------------------

Covenants of Licensor

In consideration of the right to use this License’s text and the "Business
Source License" name and trademark, Licensor covenants to MariaDB, and to all
other recipients of the licensed work to be provided by Licensor:

1. To specify as the Change License the GPL Version 2.0 or any later version,
   or a license that is compatible with GPL Version 2.0 or a later version,
   where "compatible" means that software provided under the Change License can
   be included in a program with software provided under GPL Version 2.0 or a
   later version. Licensor may specify additional Change Licenses without
   limitation.

2. To either: (a) specify an additional grant of rights to use that does not
   impose any additional restriction on the right granted in this License, as
   the Additional Use Grant; or (b) insert the text "None".

3. To specify a Change Date.

4. Not to modify this License in any other way.

-----------------------------------------------------------------------------

Notice

The Business Source License (this document, or the "License") is not an Open
Source license. However, the Licensed Work will eventually be made available
under an Open Source License, as stated in this License.
'''
'''--- README.md ---
# Nearsend Frontend

Frontend code for [Nearsend]('https://nearsend.io/')

## Getting Started

First, install the dependencies:

```bash
npm i
```

Second, run the development server:

```bash
npm run dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Service Fee

Nearsend Core required a small amount of service fee per address when you make a transaction. The service fee is calculated based on USD, for example, 0.1 equals 10 cents (0.1 USD).

Service fee may be adjusted by updating the ENV variable `VITE_SERVICE_FEE_USD_PER_ACCOUNT`, make sure that it matches the number on our Smart Contract as well
'''
'''--- index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta name="description"
    content="Send NEAR or NEP-141 Tokens to thousands of NEAR addresses in one click. Nearsend allows you to bulksend or multisend Near Protocol tokens in one transaction." />
  <meta name="keywords" content="NEAR, NEP-141, bulksend, multisend, batch, transactions, Near Protocol, tokens" />
  <meta name="author" content="nearsend.io" />
  <meta property="og:title" content="Nearsend | Bulksend NEAR and NEP-141 Tokens" />
  <meta property="og:image" content="/preview.png" />
  <meta property="og:image:alt" content="Batch transacting on Near Protocol, the easy way" />
  <meta property="og:image:width" content="1280" />
  <meta property="og:image:height" content="720" />
  <meta property="og:site_name" content="nearsend.io" />
  <meta property="og:description" content="Send NEAR or NEP-141 Tokens to thousands of NEAR addresses in one click. Nearsend allows you to bulksend or multisend Near Protocol tokens in one transaction." />
  <meta property="og:image:type" content="image/png" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Nearsend | Bulksend NEAR and NEP-141 Tokens" />
  <meta name="twitter:image" content="/preview.png" />

  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WZTMVZC');</script>
  <!-- End Google Tag Manager -->

  <title>Nearsend | Bulksend NEAR and NEP-141 Tokens</title>
</head>

<body>
  <script type="module">
    import {Buffer} from "buffer";
    import process from "process";
    
    window.process = process;
    window.Buffer = Buffer;
  </script>
  <script>
    // Workaround for https://github.com/rollup/plugins/issues/1014
    window.exports = undefined
    window.module = undefined
  </script>
  <script>window.global = window;</script>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>

  <!-- Google Tag Manager (noscript) -->
  <noscript>
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WZTMVZC"
    height="0" width="0" style="display:none;visibility:hidden"></iframe>
  </noscript>
  <!-- End Google Tag Manager (noscript) -->
</body>

</html>
'''
'''--- package.json ---
{
  "name": "nearsend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "dev:test": "vite --mode test",
    "dev:staging": "vite --mode staging",
    "build": "tsc && vite build",
    "build:staging": "tsc && vite build --mode staging",
    "build:test": "tsc && vite build --mode test",
    "preview": "vite preview",
    "lint:fix": "eslint --fix --ext .js,.jsx,.ts,.tsx \"src/**/*.{ts,tsx,js,jsx}\"",
    "lint": "eslint \"src/**/*.{ts,tsx,js,jsx}\" --color",
    "format": "prettier --write .",
    "prepare": "husky install"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "./src/**/*.{js,jsx,ts,tsx}": [
      "yarn lint",
      "yarn format",
      "git add ."
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "dependencies": {
    "@apollo/client": "^3.6.6",
    "@near-wallet-selector/core": "^6.0.0",
    "@near-wallet-selector/ledger": "^6.0.0",
    "@near-wallet-selector/math-wallet": "^6.0.0",
    "@near-wallet-selector/meteor-wallet": "^6.0.0",
    "@near-wallet-selector/modal-ui": "^6.0.0",
    "@near-wallet-selector/my-near-wallet": "^6.0.0",
    "@near-wallet-selector/near-wallet": "^6.0.0",
    "@near-wallet-selector/nightly": "^6.0.0",
    "@near-wallet-selector/nightly-connect": "^6.0.0",
    "@near-wallet-selector/sender": "^6.0.0",
    "@near-wallet-selector/wallet-connect": "^6.0.0",
    "@reduxjs/toolkit": "1.6.1",
    "antd": "^4.22.3",
    "axios": "^0.26.0",
    "bignumber.js": "^9.0.2",
    "broadcast-channel": "^4.13.0",
    "browserify-zlib": "^0.2.0",
    "classnames": "^2.3.1",
    "date-fns": "^2.21.2",
    "ethers": "^5.5.4",
    "exceljs": "^4.3.0",
    "file-saver": "^2.0.5",
    "formik": "^2.2.9",
    "graphql": "^16.5.0",
    "i18next": "^21.9.1",
    "i18next-browser-languagedetector": "^6.1.5",
    "lodash": "^4.17.21",
    "node-sass": "^7.0.1",
    "pino": "^8.4.2",
    "process": "^0.11.10",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-helmet": "^6.1.0",
    "react-i18next": "^11.18.4",
    "react-redux": "7.2.6",
    "react-router-dom": "^6.2.2",
    "redux": "^4.1.2",
    "redux-persist": "^6.0.0",
    "redux-saga": "^1.1.3",
    "sass": "^1.49.9",
    "socket.io-client": "^4.4.1",
    "stream-browserify": "^3.0.0",
    "virtualizedtableforantd4": "^1.1.6",
    "vite-compatible-readable-stream": "3.6.1",
    "web-vitals": "^2.1.4",
    "web3": "^1.7.0",
    "xlsx": "^0.18.5",
    "yup": "^0.32.11",
    "zod": "^3.18.0"
  },
  "devDependencies": {
    "@originjs/vite-plugin-commonjs": "^1.0.3",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.3.0",
    "@testing-library/user-event": "^14.4.3",
    "@types/babel__core": "^7.1.19",
    "@types/file-saver": "^2.0.5",
    "@types/lodash": "^4.14.179",
    "@types/node": "^17.0.21",
    "@types/react": "18.0.14",
    "@types/react-dom": "18.0.5",
    "@types/react-helmet": "^6.1.5",
    "@types/react-lazyload": "^3.2.0",
    "@types/redux-persist": "^4.3.1",
    "@types/styled-components": "^5.1.9",
    "@typescript-eslint/eslint-plugin": "^5.17.0",
    "@typescript-eslint/parser": "^5.17.0",
    "@vitejs/plugin-react": "^1.3.2",
    "eslint": "^7.11.0",
    "eslint-config-airbnb": "^19.0.4",
    "eslint-config-prettier": "^8.2.0",
    "eslint-import-resolver-typescript": "^2.5.0",
    "eslint-plugin-import": "^2.25.3",
    "eslint-plugin-jsx-a11y": "^6.5.1",
    "eslint-plugin-prettier": "^4.0.0",
    "eslint-plugin-react": "7.30.1",
    "eslint-plugin-react-hooks": "4.6.0",
    "husky": "^7.0.4",
    "lint-staged": "^12.3.4",
    "npm": "^8.5.2",
    "prettier": "^2.5.1",
    "react-error-overlay": "6.0.9",
    "typechain": "^7.0.1",
    "typescript": "4.6.3",
    "vite": "^2.9.15"
  }
}

'''
'''--- public/example.near.txt ---
testaddress01.near,0.001
testaddress02.near,1
testaddress03.near,3.45
testaddress04.near,2.1
testaddress05.near,1.5
'''
'''--- public/example.testnet.txt ---
testaddress01.testnet,0.001
testaddress02.testnet,1
testaddress03.testnet,3.45
testaddress04.testnet,2.1
testaddress05.testnet,1.5
'''
'''--- public/favicon.svg ---
<svg width="59" height="59" viewBox="0 0 59 59" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M55.575 0.0189976H38.9077C39.017 0.218549 39.1168 0.427599 39.207 0.631901C39.5562 1.46902 39.7103 2.37464 39.6576 3.28014C39.6049 4.18563 39.3469 5.06726 38.9029 5.85824H52.653V23.6325L51.6172 24.6683L51.1801 25.1197L49.1276 27.1817L47.0608 29.2437L35.7291 40.5564L29.2437 47.056L13.6455 31.4578L11.593 33.5056L9.53094 35.5676L25.1292 51.1658L23.6421 52.653L22.7868 53.5082C22.2414 54.0561 21.9341 54.7971 21.9316 55.5702C21.9302 55.9536 22.0062 56.3334 22.1549 56.6867C22.3751 57.2199 22.7487 57.6757 23.2283 57.9963C23.708 58.3169 24.272 58.4878 24.8489 58.4874H55.5845C55.9677 58.4881 56.3474 58.413 56.7016 58.2667C57.0558 58.1203 57.3776 57.9054 57.6487 57.6344C57.9197 57.3634 58.1345 57.0415 58.2809 56.6873C58.4273 56.3331 58.5023 55.9535 58.5017 55.5702V2.91724C58.4967 2.14519 58.1858 1.40661 57.6372 0.86335C57.0886 0.320093 56.347 0.0164664 55.575 0.0189976V0.0189976ZM34.8739 52.653H31.9139L33.3915 51.1658L51.1896 33.3678L52.672 31.8806V52.653H34.8739Z" fill="#6381C0"/>
<path d="M18.8243 55.5702C18.8256 54.5496 19.0855 53.5459 19.5798 52.653H5.8345V34.8549L6.25735 34.432L7.32163 33.3678L9.38365 31.3058L11.4457 29.2437L29.2437 11.4457L44.8515 27.0534L46.9135 24.9914L48.9755 22.9199L33.6766 7.62095L33.382 7.32637L34.8549 5.83924L35.7101 4.98402C35.9819 4.71367 36.1978 4.39241 36.3453 4.0386C36.4929 3.68478 36.5693 3.30535 36.5701 2.92199C36.57 2.53826 36.4924 2.15849 36.342 1.80546C36.1226 1.27136 35.7493 0.814565 35.2696 0.493094C34.7899 0.171622 34.2255 -7.47579e-06 33.6481 2.44229e-10H2.91725C2.53375 -5.0838e-07 2.15402 0.0756079 1.79977 0.22251C1.44552 0.369413 1.12372 0.584724 0.852766 0.856119C0.581813 1.12751 0.367027 1.44967 0.220702 1.80415C0.074376 2.15864 -0.000620708 2.5385 3.88203e-06 2.92199V55.5702C-0.000621873 55.9535 0.0744086 56.3331 0.220792 56.6873C0.367176 57.0415 0.582033 57.3634 0.853049 57.6344C1.12407 57.9054 1.44591 58.1203 1.80013 58.2667C2.15435 58.413 2.53398 58.4881 2.91725 58.4874H19.5893C19.4728 58.2893 19.3712 58.0829 19.2852 57.8698C18.9814 57.1412 18.8248 56.3596 18.8243 55.5702V55.5702ZM23.6325 5.83449H26.6068L25.1197 7.32162L7.31688 25.1197L5.82975 26.5973V5.83449H23.6325Z" fill="#6381C0"/>
</svg>

'''
'''--- public/near_icon.svg ---
<svg width="26" height="26" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M20.8686 1.31986L15.4339 9.38889C15.3565 9.50509 15.3238 9.6454 15.3418 9.78385C15.3599 9.92231 15.4274 10.0495 15.532 10.142C15.6366 10.2345 15.7712 10.286 15.9108 10.287C16.0504 10.2879 16.1857 10.2383 16.2915 10.1472L21.6414 5.50694C21.6727 5.4789 21.7116 5.46058 21.7532 5.45423C21.7948 5.44789 21.8373 5.45379 21.8756 5.47121C21.9139 5.48863 21.9463 5.51683 21.9688 5.55235C21.9913 5.58787 22.003 5.62919 22.0025 5.67125V20.1987C22.0025 20.2432 21.9888 20.2866 21.9633 20.323C21.9377 20.3595 21.9016 20.3871 21.8598 20.4023C21.818 20.4175 21.7725 20.4195 21.7296 20.4079C21.6866 20.3964 21.6483 20.3719 21.6197 20.3378L5.44917 0.980417C5.18907 0.673283 4.8652 0.426482 4.50007 0.257171C4.13495 0.0878605 3.73733 0.000103087 3.33486 9.56922e-08H2.76972C2.03515 9.56922e-08 1.33066 0.291809 0.811233 0.811233C0.291809 1.33066 0 2.03515 0 2.76972V23.2303C0 23.9649 0.291809 24.6693 0.811233 25.1888C1.33066 25.7082 2.03515 26 2.76972 26C3.24335 26.0001 3.7091 25.8789 4.12254 25.6478C4.53598 25.4168 4.88331 25.0836 5.13139 24.6801L10.5661 16.6111C10.6435 16.4949 10.6762 16.3546 10.6582 16.2161C10.6401 16.0777 10.5726 15.9505 10.468 15.858C10.3634 15.7655 10.2288 15.714 10.0892 15.713C9.94957 15.7121 9.81433 15.7617 9.70847 15.8528L4.35861 20.4931C4.32726 20.5211 4.28842 20.5394 4.24683 20.5458C4.20524 20.5521 4.16271 20.5462 4.12442 20.5288C4.08613 20.5114 4.05373 20.4832 4.0312 20.4477C4.00866 20.4121 3.99695 20.3708 3.9975 20.3287V5.79764C3.99752 5.75316 4.01122 5.70977 4.03675 5.67335C4.06228 5.63693 4.0984 5.60925 4.1402 5.59407C4.182 5.57889 4.22747 5.57694 4.27042 5.58848C4.31337 5.60003 4.35172 5.62451 4.38028 5.65861L20.549 25.0196C20.8091 25.3267 21.133 25.5735 21.4981 25.7428C21.8632 25.9121 22.2609 25.9999 22.6633 26H23.2285C23.5923 26.0002 23.9527 25.9288 24.289 25.7897C24.6252 25.6506 24.9307 25.4466 25.1881 25.1894C25.4455 24.9322 25.6497 24.6268 25.789 24.2906C25.9283 23.9545 26 23.5942 26 23.2303V2.76972C26 2.03515 25.7082 1.33066 25.1888 0.811233C24.6693 0.291809 23.9649 9.56922e-08 23.2303 9.56922e-08C22.7567 -0.000124348 22.2909 0.121129 21.8775 0.352188C21.464 0.583246 21.1167 0.916401 20.8686 1.31986Z" fill="black"/>
</svg>

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- src/components/AppConnectWalletWrapper/hooks/useConnectNear.ts ---
import { useEffect } from 'react';

import { SUPPORTED_NETWORK } from 'connectors/constants';
import { useAppDispatch, useAppSelector } from 'hooks/useStore';
import selectedAddress from 'store/address/selector';
import { loginStart } from 'store/address/slice';
import { isAddressEqual } from 'services/WalletService/utils';
import { useWalletSelector } from 'context/NearWalletSelectorContext';

export const useConnectNear = () => {
  const dispatch = useAppDispatch();

  const { accountId: account, chainId: nearChainId, active } = useWalletSelector();

  const { address, chainId, network } = useAppSelector(selectedAddress.getAddress);

  useEffect(() => {
    if (
      network === SUPPORTED_NETWORK.NEAR &&
      (!isAddressEqual(account, address) || chainId.toString() !== nearChainId?.toString()) &&
      !!active &&
      !!account &&
      !!nearChainId
    ) {
      dispatch(loginStart({ address: account }));
    }
  }, [active, account, chainId, address, nearChainId, network]);
};

'''
'''--- src/components/AppHeader/contants/index.ts ---
import { ROUTE_URLS, PAGE_KEYS } from './../../../constants/routes';

export type NavigationProps = {
  key: string;
  text: string;
  link: string;
  children: NavigationProps[];
};

export const NAVIGATION: NavigationProps[] = [
  {
    key: PAGE_KEYS.TUTORIAL,
    text: 'header.tutorial',
    link: ROUTE_URLS.TUTORIAL,
    children: [],
  },
];

export const DEFAULT_NAVIGATION = {
  key: '',
  text: '',
  link: '',
  children: [],
};

export const DRAWER_WIDTH = 375;

'''
'''--- src/components/NumberFormat/utils.ts ---
//@flow

type FormatInputValueFunction = (inputValue: string) => string;

// basic noop function
export function noop() {}
export function returnTrue() {
  return true;
}

export function charIsNumber(char?: string) {
  return !!(char || '').match(/\d/);
}

export function isNil(val: any) {
  return val === null || val === undefined;
}

export function escapeRegExp(str: string) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
}

export function getThousandsGroupRegex(thousandsGroupStyle: string) {
  switch (thousandsGroupStyle) {
    case 'lakh':
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
    case 'wan':
      return /(\d)(?=(\d{4})+(?!\d))/g;
    case 'thousand':
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g;
  }
}

export function applyThousandSeparator(str: string, thousandSeparator: string, thousandsGroupStyle: string) {
  const thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
  let index = str.search(/[1-9]/);
  index = index === -1 ? str.length : index;
  return (
    str.substring(0, index) + str.substring(index, str.length).replace(thousandsGroupRegex, '$1' + thousandSeparator)
  );
}

//spilt a float number into different parts beforeDecimal, afterDecimal, and negation
export function splitDecimal(numStr: string, allowNegative = true) {
  const hasNagation = numStr[0] === '-';
  const addNegation = hasNagation && allowNegative;
  numStr = numStr.replace('-', '');

  const parts = numStr.split('.');
  const beforeDecimal = parts[0];
  const afterDecimal = parts[1] || '';

  return {
    beforeDecimal,
    afterDecimal,
    hasNagation,
    addNegation,
  };
}

export function fixLeadingZero(numStr?: string) {
  if (!numStr) return numStr;
  const isNegative = numStr[0] === '-';
  if (isNegative) numStr = numStr.substring(1, numStr.length);
  const parts = numStr.split('.');
  const beforeDecimal = parts[0].replace(/^0+/, '') || '0';
  const afterDecimal = parts[1] || '';

  return `${isNegative ? '-' : ''}${beforeDecimal}${afterDecimal ? `.${afterDecimal}` : ''}`;
}

export function fixTrailingZero(numStr?: string) {
  if (!numStr) return numStr;
  const isNegative = numStr[0] === '-';
  if (isNegative) numStr = numStr.substring(1, numStr.length);
  const parts = numStr.split('.');
  const beforeDecimal = parts[0] || '0';
  const afterDecimal = removeTrailingZero(parts[1]) || '';

  return `${isNegative ? '-' : ''}${beforeDecimal}${afterDecimal ? `.${afterDecimal}` : ''}`;
}

export function removeTrailingZero(afterDecimal: string) {
  return afterDecimal.replace(/0+$/, '') || '';
}

/**
 * limit decimal numbers to given scale
 * Not used .fixedTo because that will break with big numbers
 */
export function limitToScale(numStr: string, scale: number, fixedDecimalScale: boolean) {
  let str = '';
  const filler = fixedDecimalScale ? '0' : '';
  for (let i = 0; i <= scale - 1; i++) {
    str += numStr[i] || filler;
  }
  return str;
}

function repeat(str: any, count: any) {
  return Array(count + 1).join(str);
}

export function toNumericString(num: any) {
  num += ''; // typecast number to string

  // store the sign and remove it from the number.
  const sign = num[0] === '-' ? '-' : '';
  if (sign) num = num.substring(1);

  // split the number into cofficient and exponent
  let [coefficient, exponent] = num.split(/[eE]/g);

  // covert exponent to number;
  exponent = Number(exponent);

  // if there is no exponent part or its 0, return the coffiecient with sign
  if (!exponent) return sign + coefficient;

  coefficient = coefficient.replace('.', '');

  /**
   * for scientific notation the current decimal index will be after first number (index 0)
   * So effective decimal index will always be 1 + exponent value
   */
  const decimalIndex = 1 + exponent;

  const coffiecientLn = coefficient.length;

  if (decimalIndex < 0) {
    // if decimal index is less then 0 add preceding 0s
    // add 1 as join will have
    coefficient = '0.' + repeat('0', Math.abs(decimalIndex)) + coefficient;
  } else if (decimalIndex >= coffiecientLn) {
    // if decimal index is less then 0 add leading 0s
    coefficient = coefficient + repeat('0', decimalIndex - coffiecientLn);
  } else {
    // else add decimal point at proper index
    coefficient = (coefficient.substring(0, decimalIndex) || '0') + '.' + coefficient.substring(decimalIndex);
  }

  return sign + coefficient;
}

/**
 * This method is required to round prop value to given scale.
 * Not used .round or .fixedTo because that will break with big numbers
 */
export function roundToPrecision(numStr: string, scale: number, fixedDecimalScale: boolean) {
  //if number is empty don't do anything return empty string
  if (['', '-'].indexOf(numStr) !== -1) return numStr;

  const shoudHaveDecimalSeparator = numStr.indexOf('.') !== -1 && scale;
  const { beforeDecimal, afterDecimal, hasNagation } = splitDecimal(numStr);
  const floatValue = parseFloat(`0.${afterDecimal || '0'}`);
  const floatValueStr = afterDecimal.length <= scale ? toNumericString(floatValue) : floatValue.toFixed(scale);
  const roundedDecimalParts = floatValueStr.split('.');
  const intPart = beforeDecimal
    .split('')
    .reverse()
    .reduce((roundedStr, current, idx) => {
      if (roundedStr.length > idx) {
        return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);
      }
      return current + roundedStr;
    }, roundedDecimalParts[0]);

  const decimalPart = limitToScale(
    roundedDecimalParts[1] || '',
    Math.min(scale, afterDecimal.length),
    fixedDecimalScale,
  );
  const negation = hasNagation ? '-' : '';
  const decimalSeparator = shoudHaveDecimalSeparator ? '.' : '';
  return `${negation}${intPart}${decimalSeparator}${decimalPart}`;
}

export function omit(obj: any, keyMaps: any) {
  const filteredObj = {} as any;
  Object.keys(obj).forEach((key) => {
    if (!keyMaps[key]) filteredObj[key] = obj[key];
  });
  return filteredObj;
}

/** set the caret positon in an input field **/
export function setCaretPosition(el: any, caretPos: number) {
  el.value = el.value;
  // ^ this is used to not only get 'focus', but
  // to make sure we don't have it everything -selected-
  // (it causes an issue in chrome, and having it doesn't hurt any other browser)
  if (el !== null) {
    if (el.createTextRange) {
      const range = el.createTextRange();
      range.move('character', caretPos);
      range.select();
      return true;
    }
    // (el.selectionStart === 0 added for Firefox bug)
    if (el.selectionStart || el.selectionStart === 0) {
      el.focus();
      el.setSelectionRange(caretPos, caretPos);
      return true;
    }

    // fail city, fortunately this never happens (as far as I've tested) :)
    el.focus();
    return false;
  }
}

/**
  Given previous value and newValue it returns the index
  start - end to which values have changed.
  This function makes assumption about only consecutive
  characters are changed which is correct assumption for caret input.
*/
export function findChangedIndex(prevValue: string, newValue: string) {
  let i = 0,
    j = 0;
  const prevLength = prevValue.length;
  const newLength = newValue.length;
  while (prevValue[i] === newValue[i] && i < prevLength) i++;

  //check what has been changed from last
  while (prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i) {
    j++;
  }

  return { start: i, end: prevLength - j };
}

/*
  Returns a number whose value is limited to the given range
*/
export function clamp(num: number, min: number, max: number) {
  return Math.min(Math.max(num, min), max);
}

export function getCurrentCaretPosition(el: any) {
  /*Max of selectionStart and selectionEnd is taken for the patch of pixel and other mobile device caret bug*/
  return Math.max(el.selectionStart, el.selectionEnd);
}

export function addInputMode(format: string | FormatInputValueFunction) {
  return format || !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}

'''
'''--- src/components/Pages/home/components/Prepare/schemas/index.ts ---
import { CHAIN_ID, CONTRACT_ID, NATIVE_TOKEN } from 'connectors/constants';
import ERROR_INPUT_ADDRESS from 'constants/error';
import { trimSpace } from 'utils/string';
import { addMethod, object, string } from 'yup';

export const REGEX_ADDRESS_AMOUNT =
  /^(([a-z\d]+[\-_])*[a-z\d]+\.)*([a-z\d]+[\-_])*[a-z\d]+([\,])(([0-9]+[\,\.])?[0-9]+)$/g;
export const REGEX_ADDRESS = /^(([a-z\d]+[\-_])*[a-z\d]+\.)*([a-z\d]+[\-_])*[a-z\d]+/g;
export const REGEX_AMOUNT = /([\,])(([0-9]+[\,\.])?[0-9]+)$/g;

export const handleValidAddress = (address: string, setCurrentValidToken: any) => {
  if (!!address?.match(REGEX_ADDRESS) || address === NATIVE_TOKEN) {
    if (typeof setCurrentValidToken === 'function') {
      setCurrentValidToken(address);
    }
    return true;
  }
  return false;
};

export const handleAtLeastOneAccounts = (addresses: string) => {
  const { resultString, count } = trimSpace(addresses);
  const arr = resultString.split('\n');
  if (count === 0) {
    return false;
  } else {
    let countValidAddress = 0;
    for (const address of arr) {
      if (countValidAddress === 1) {
        break;
      }
      if (address.match(REGEX_ADDRESS)) {
        countValidAddress++;
      }
    }
    return !!(countValidAddress === 1);
  }
};

export const handleValidRecipients = (
  addresses: string,
  setErrorLines: any,
  decimals: any,
  chainId: string,
  address: string,
) => {
  const { resultString, count } = trimSpace(addresses);
  const arr = resultString.split('\n');
  const net = chainId === CHAIN_ID.NEAR_TEST ? 'NEAR Testnet' : 'NEAR Mainet';

  const newErrorLines = [];
  for (let i = 0; i < count; i++) {
    const amount = arr[i].match(REGEX_AMOUNT)?.[0];
    if (!arr[i].match(REGEX_ADDRESS_AMOUNT)) {
      if (amount) {
        const address = arr[i].split(amount)[0];
        newErrorLines.push({ line: i + 1, error: ERROR_INPUT_ADDRESS.E6(address, net) });
      } else {
        const len = arr[i].length;
        let indexSplit = -1;
        for (let j = 0; j < len; j++) {
          if (arr[i][j].match(/[\,]/g)) {
            indexSplit = j;
            break;
          }
        }
        let address;
        if (indexSplit === -1) {
          address = arr[i];
        } else {
          address = arr[i].slice(0, indexSplit);
        }

        if (address.match(REGEX_ADDRESS) && address.length >= 2 && address.length <= 64) {
          newErrorLines.push({ line: i + 1, error: ERROR_INPUT_ADDRESS.E5 });
        } else {
          newErrorLines.push({ line: i + 1, error: ERROR_INPUT_ADDRESS.E7 });
        }
      }
    } else {
      const exactAmount = amount?.slice(1);
      const exactAddress = arr[i].split(amount as string)[0];

      if (Number(exactAmount) === 0) {
        newErrorLines.push({ line: i + 1, error: ERROR_INPUT_ADDRESS.E5 });
      } else {
        if (decimals.toString()) {
          const amountDecimals = exactAmount?.split(/[\.\,]/g)[1] || '';

          if (amountDecimals?.length > decimals) {
            newErrorLines.push({ line: i + 1, error: ERROR_INPUT_ADDRESS.E8 });
          }
        }
      }

      // const contractId = CONTRACT_ID[chainId] || CONTRACT_ID[CHAIN_ID.NEAR_TEST];
      if (exactAddress === address) {
        newErrorLines.push({ line: i + 1, error: ERROR_INPUT_ADDRESS.E17 });
      }
      // else if (exactAddress === contractId) {
      //   newErrorLines.push({ line: i + 1, error: ERROR_INPUT_ADDRESS.E18 });
      // }

      const lenAddress = exactAddress.length;
      if (lenAddress < 2 || lenAddress > 64) {
        newErrorLines.push({ line: i + 1, error: ERROR_INPUT_ADDRESS.E6(exactAddress, net) });
      }
    }
  }
  setErrorLines(newErrorLines);
  return !newErrorLines.length;
};

export default function createPrepareSchema({
  setErrorLines,
  setCurrentValidToken,
  decimals,
  chainId,
  address,
}: {
  setErrorLines: any;
  setCurrentValidToken: any;
  decimals: any;
  chainId: string;
  address: string;
}) {
  addMethod(string, 'checkValidRecipients', function (errorMessage) {
    return this.test('valid-recipients', errorMessage, function (addresses) {
      const { path, createError } = this;

      return (
        handleValidRecipients(addresses as string, setErrorLines, decimals, chainId, address) ||
        createError({ path, message: errorMessage })
      );
    });
  });

  addMethod(string, 'checkAtLeastOneAccounts', function (errorMessage) {
    return this.test('at-least-2-accs', errorMessage, function (addresses) {
      const { path, createError } = this;

      return handleAtLeastOneAccounts(addresses as string) || createError({ path, message: errorMessage });
    });
  });

  addMethod(string, 'checkValidToken', function (errorMessage) {
    return this.test('check-valid-token', errorMessage, function (address) {
      const { path, createError } = this;
      return (
        handleValidAddress(address as string, setCurrentValidToken) || createError({ path, message: errorMessage })
      );
    });
  });

  return object({
    tokenAddress: string()
      .required(ERROR_INPUT_ADDRESS.E1)
      // @ts-ignore-next-line
      .checkValidToken(ERROR_INPUT_ADDRESS.E2)
      .max(256),
    recipientsAmount: (string() as any).checkAtLeastOneAccounts(ERROR_INPUT_ADDRESS.E3).checkValidRecipients(''),
  });
}

export type PrepareFormValue = {
  tokenAddress: string;
  recipientsAmount: string;
};

'''
'''--- src/components/Pages/home/components/SendToken/constant/index.ts ---
export const COLUMN_KEY = {
  NO: 'no',
  TX_TIME: 'txTime',
  TX_HASH: 'txHash',
  SENDER: 'sender',
  SMART_CONTRACT: 'smartContract',
  RECIPIENT: 'recipient',
  AMOUNT: 'amount',
  TOKEN_TICKER: 'tokenTicker',
  TOKEN_ADDRESS: 'tokenAddress',
  STATUS: 'status',
  GAS_FEE: 'gasFee',
};

export const COLUMN_HEADERS = [
  {
    title: 'report.no',
    key: COLUMN_KEY.NO,
    excelWidth: 8,
  },
  {
    title: 'report.tx_time',
    key: COLUMN_KEY.TX_TIME,
    excelWidth: 15.86,
  },
  {
    title: 'report.tx_hash',
    key: COLUMN_KEY.TX_HASH,
    excelWidth: 17.14,
  },
  {
    title: 'report.sender',
    key: COLUMN_KEY.SENDER,
    excelWidth: 21.57,
  },
  {
    title: 'report.smart_contract',
    key: COLUMN_KEY.SMART_CONTRACT,
    excelWidth: 31.71,
  },
  {
    title: 'report.recipient',
    key: COLUMN_KEY.RECIPIENT,
    excelWidth: 18.86,
  },
  {
    title: 'report.amount',
    key: COLUMN_KEY.AMOUNT,
    excelWidth: 14.43,
  },
  {
    title: 'report.token_ticker',
    key: COLUMN_KEY.TOKEN_TICKER,
    excelWidth: 16.43,
  },
  {
    title: 'report.token_address',
    key: COLUMN_KEY.TOKEN_ADDRESS,
    excelWidth: 16.71,
  },
  {
    title: 'report.status',
    key: COLUMN_KEY.STATUS,
    excelWidth: 18.57,
  },
  {
    title: 'report.gas_fee',
    key: COLUMN_KEY.GAS_FEE,
    excelWidth: 8,
  },
];

'''
'''--- src/connectors/constants.ts ---
import NearIcon from 'resources/svg/near_icon.svg';

export const CHAIN_ID: Record<any, string> = {
  NEAR_TEST: 'testnet',
  NEAR: 'mainnet',
};

export const CONTRACT_ID: Record<any, string> = {
  [CHAIN_ID.NEAR_TEST]: import.meta.env.VITE_CONTRACT_ID_TESTNET,
  [CHAIN_ID.NEAR]: import.meta.env.VITE_CONTRACT_ID_MAINNET,
};

export const WALLET_API: Record<any, string> = {
  [CHAIN_ID.NEAR_TEST]: import.meta.env.VITE_NEAR_WALLET_URL_TESTNET,
  [CHAIN_ID.NEAR]: import.meta.env.VITE_NEAR_WALLET_URL_MAINNET,
};

export const ARCHIVAL_NETWORK: Record<any, string> = {
  [CHAIN_ID.NEAR_TEST]: import.meta.env.VITE_ARCHIVAL_NETWORK_URL_RPC_TESTNET,
  [CHAIN_ID.NEAR]: import.meta.env.VITE_ARCHIVAL_NETWORK_URL_RPC_MAINNET,
};

export const SUPPORTED_NETWORK = {
  NEAR: 'NEAR',
};

export const NATIVE_TOKEN = 'NEAR';
export const NATIVE_TOKEN_DECIMAL_SCALE = 24;

export const SUPPORTED_CHAIN_IDS: (string | number)[] = [CHAIN_ID.NEAR, CHAIN_ID.NEAR_TEST];

export const NEAR_WALLET = 'near-wallet';
export const MY_NEAR_WALLET = 'my-near-wallet';
export const SENDER = 'sender';

export const BROWSER_WALLETS = [NEAR_WALLET, MY_NEAR_WALLET];
export const SUPPORT_CONNECT_TYPE = [NEAR_WALLET, SENDER];

type CHAIN_INFO_TYPE = {
  name: string;
  valueString: string;
  icon: string | null;
  textWarning: string;
  url: string;
  suffixToken: string;
  explorerName: string;
  suffixKey: string;
  shortName: string;
  key: string;
};

export const WALLET_NAME: Record<string, string> = {
  //EVM
  [NEAR_WALLET]: 'common.near_wallet',
  [SENDER]: 'common.sender',
};

export const CHAIN_INFO: Record<string | number, CHAIN_INFO_TYPE> = {
  [CHAIN_ID.NEAR_TEST]: {
    name: 'NEAR Testnet',
    valueString: CHAIN_ID.NEAR_TEST,
    icon: NearIcon,
    textWarning: 'Near - Testnet',
    url: 'https://testnet.nearblocks.io',
    suffixToken: '',
    explorerName: 'Near Explorer',
    suffixKey: '',
    shortName: 'Near',
    key: 'Near',
  },
  [CHAIN_ID.NEAR]: {
    name: 'NEAR Mainnet',
    valueString: CHAIN_ID.NEAR,
    icon: NearIcon,
    textWarning: 'Near - Testnet',
    url: 'https://nearblocks.io',
    suffixToken: '',
    explorerName: 'Near Explorer',
    suffixKey: '',
    shortName: 'Near',
    key: 'Near',
  },
};

'''
'''--- src/constants/error.ts ---
// import { useTranslation } from "react-i18next";
// const {t} = useTranslation()

const ERROR_INPUT_ADDRESS = {
  E1: 'Please input token first',
  E2: 'Invalid token address',
  E3: 'Please provide at least 1 address',
  E4: 'The below transactions cannot be processed',
  E5: 'Wrong amount',
  E6: (wrongAddress: string, chainId: string) => `Given address "${wrongAddress}" is not a valid ${chainId} address`,
  E7: 'Invalid wallet address and wrong amount',
  E8: 'Decimals of amount can not be greater than token decimals',
  E15: 'File format is invalid. Accepted formats : .csv ; .xls ; .txt',
  E17: 'You cannot input your own wallet address',
  E18: 'You cannot input Nearsend smart contract address',
};

export default ERROR_INPUT_ADDRESS;

'''
'''--- src/constants/fileTypes.ts ---
export const ACCEPT_TYPES = ['xlsx', 'csv', 'xls', 'txt'];

'''
'''--- src/constants/httpStatus.ts ---
const HTTP_STATUS_CONTSTANTS = {
  OK: 200,
  ERROR_CODE_401: 401,
};

export default HTTP_STATUS_CONTSTANTS;

'''
'''--- src/constants/index.ts ---
export const PAGE_SIZE_OPTIONS = ['10', '20', '50'];
export const MAX_MOBILE_WIDTH = 576;
export const PAGE_SIZE_DEFAULT = 10;
export const PARAMS_TABLE = {
  limit: 10,
  offset: 0,
};

export const LANGUAGE = {
  EN: 'en',
};

export const LANGUAGE_KEY = {
  [LANGUAGE.EN]: 'en-us',
};

'''
'''--- src/constants/length.ts ---
const LENGTH_CONSTANTS = {
  MAX_LENGTH_INPUT: 256,
};

export default LENGTH_CONSTANTS;

'''
'''--- src/constants/routes.ts ---
import Home from 'pages/home';
import BlockMultiTabs from 'pages/block-multi-tabs';
import TutorialPage from 'pages/tutorial';

import PublicLayout from 'components/Layout/Public';

export const ROUTE_URLS = {
  HOME: '/',
  TUTORIAL: '/tutorial',
  MULTIPLE_TABS: '/block-multi-tabs',
};

export enum PAGE_KEYS {
  HOME = 'HOME',
  TUTORIAL = 'TUTORIAL',
  MULTIPLE_TABS = 'MULTIPLE_TABS',
}

export const PERSIST_DATA_PAGES = [ROUTE_URLS.HOME];

const routes = [
  {
    name: PAGE_KEYS.HOME,
    path: ROUTE_URLS.HOME,
    component: Home,
    layout: PublicLayout,
    isPrivate: false,
    index: true,
  },
  {
    name: PAGE_KEYS.MULTIPLE_TABS,
    path: ROUTE_URLS.MULTIPLE_TABS,
    component: BlockMultiTabs,
    layout: PublicLayout,
    isPrivate: false,
    index: true,
  },
  {
    name: PAGE_KEYS.TUTORIAL,
    path: ROUTE_URLS.TUTORIAL,
    component: TutorialPage,
    layout: PublicLayout,
    isPrivate: false,
    index: true,
  },
];
export default routes;

'''
'''--- src/constants/socketEvent.ts ---
export {};

'''
'''--- src/constants/status.ts ---
export {};

'''
'''--- src/constants/time.ts ---
const TIME_CONSTANTS = {
  DEBOUNCE_SEARCH_TIME: 500,

  TIME_FORMAT: {
    DATE: 'dd-MM-yyyy',
    DATE_ANTD: 'DD-MM-YYYY',
    DATE_FORMAT_REQUEST: 'yyyy/MM/dd',
    TIME: 'HH:mm:ss',
    DATE_TIME: 'DD-MM-yyyy HH:mm:ss',
  },
};

export default TIME_CONSTANTS;

'''
'''--- src/constants/type.ts ---
const TYPE_CONSTANTS = {
  MESSAGE: {
    SUCCESS: 'success',
    ERROR: 'error',
    WARNING: 'warning',
    IMG_DONE: 'done',
  },
  SORT_FORMAT: {
    DESC: -1,
    ASC: 1,
  },
};

export default TYPE_CONSTANTS;

'''
'''--- src/hoc/with-translate-form-errors.ts ---
import { useEffect } from 'react';
import isEmpty from 'lodash/isEmpty';
import { FormikErrors } from 'formik';
import { useTranslation } from 'react-i18next';

const useTranslateFormErrors = (
  errors: FormikErrors<any>,
  validateForm: (values?: any) => Promise<FormikErrors<any>>,
) => {
  const { i18n } = useTranslation();
  useEffect(() => {
    i18n.on('languageChanged', () => {
      if (!isEmpty(errors)) {
        //Hack to change validate message
        setTimeout(async () => {
          await validateForm();
        }, 0);
      }
    });
    return () => {
      i18n.off('languageChanged', () => {});
    };
  }, [errors]);
};

const WithTranslateFormErrors = ({
  errors,
  validateForm,
  children,
}: {
  errors: FormikErrors<any>;
  validateForm: (values?: any) => Promise<FormikErrors<any>>;
  children: any;
}) => {
  useTranslateFormErrors(errors, validateForm);
  return children;
};

export default WithTranslateFormErrors;

'''
'''--- src/hooks/blockchainHook/useBulkSendToken.ts ---
import { useTranslation } from 'react-i18next';
import { useEffect, useState } from 'react';
import get from 'lodash/get';
import { ExecutionOutcomeWithIdView } from 'near-api-js/lib/providers/provider';
import BigNumber from 'bignumber.js';
import { utils } from 'near-api-js';

import { useChainFactory } from 'hooks/walletHook/useChainFactory';
import { CHUNK_SIZE, STEPS, useSendToken } from 'context/SendTokenContext';
import { ExecutionOutcomeWithIdExtended, FinalExecutionOutcomeExtended } from 'types';
import useGetTransactionStatus from './useGetTransactionStatus';
import { addValue, convertPrice } from 'services/WalletService/utils/number';
import { BROWSER_WALLETS, NATIVE_TOKEN, NATIVE_TOKEN_DECIMAL_SCALE } from 'connectors/constants';
import { useAppDispatch, useAppSelector } from './../useStore';
import { setAppLoading, setLoadingTransactions } from 'store/global/slice';
import { META_DATA } from 'services/WalletService/constants';
import selectSendToken from 'store/sendToken/selector';
import { setTransactionHashes } from 'store/sendToken/slice';
import useListAddress from 'hooks/layoutHook/useListAddress';
import selectedConnection from 'store/connection/selector';
import selectGlobalState from 'store/global/selector';
import { getSendFtTokenParamsFromReceipt, getSendNEARAmountFromReceipt } from 'services/WalletService/utils/nearUtils';

export type BulkSendProps = { account_id: string; amount: BigNumber | string };

export enum TRANSACTION_STATUS {
  ALL_FINISHED = 1,
  ALL_FAILED = 2,
  SOME_FAILED = 3,
}

const useBulkSendToken = (navigate: (step: number) => () => void) => {
  const { t } = useTranslation();

  const dispatch = useAppDispatch();

  const { listAddressToSend, tokenInfo, setTokenInfo, setListAddress, setListAddressToSend } = useSendToken();
  const { getConnectedChainInfo, getWallet } = useChainFactory();
  const { getTransactionStatus } = useGetTransactionStatus();
  const { getListAddress, updateListAddress } = useListAddress();

  const [transactionsStatus, setTransactionsStatus] = useState<TRANSACTION_STATUS | null>(null);
  const [failedReceipts, setFailedReceipts] = useState<any>({});
  const [successReceipts, setSuccessReceipts] = useState<any>({});
  const [batchTransactionsResult, setBatchTransactionsResult] = useState<FinalExecutionOutcomeExtended[]>([]);
  const [transactions, setTransactions] = useState<
    [string, Record<'Success' | 'Failure', Record<string, ExecutionOutcomeWithIdView>>][]
  >([]);
  const [receipts, setReceipts] = useState({});

  const transactionHashes = useAppSelector(selectSendToken.getTransactionHashes);
  const connectedWalletType = useAppSelector(selectedConnection.getConnectedWalletTypeByNetwork);
  const hasReport = useAppSelector(selectGlobalState.getIsCurrentScreenHasReport);

  useEffect(() => {
    if (transactionHashes?.length > 0) {
      (async () => await getTransactionsReceipts(transactionHashes))();
      dispatch(setTransactionHashes([]));
    }
  }, [transactionHashes]);

  useEffect(() => {
    const getTokenInfo = async () => {
      let tokenInfo: META_DATA | null = null;

      for (const transaction of batchTransactionsResult) {
        const methodName = get(transaction, ['transaction', 'actions', '0', 'FunctionCall', 'method_name']);

        //Is sending NEAR transactions
        if (['distribute_near'].includes(methodName)) {
          tokenInfo = {
            value: NATIVE_TOKEN,
            token: 'Near',
            symbol: NATIVE_TOKEN,
            address: 'Native token',
            icon: '/src/resources/svg/near_icon.svg',
            decimals: NATIVE_TOKEN_DECIMAL_SCALE,
          };
          break;
        }

        //Is sending FT Token transactions
        if (['ft_transfer_call'].includes(methodName)) {
          const getFtTokenInfo = async (): Promise<META_DATA | null> => {
            try {
              const { library } = getConnectedChainInfo() || {};
              const wallet = getWallet();

              const response = await wallet?.getTokenMetadata({
                library,
                data: { tokens: [batchTransactionsResult[0]?.transaction?.receiver_id], batchLimit: 25 },
              });

              return {
                address: batchTransactionsResult[0]?.transaction?.receiver_id,
                token: response?.[0]?.name,
                symbol: response?.[0]?.symbol,
                icon: response?.[0]?.icon,
                decimals: response?.[0]?.decimals,
                value: batchTransactionsResult[0]?.transaction?.receiver_id,
              };
            } catch (e) {
              return null;
            }
          };
          tokenInfo = await getFtTokenInfo();
          break;
        }
      }

      if (tokenInfo) {
        setTokenInfo(tokenInfo);
        const listAddressId = await getListAddress();
        await updateListAddress(listAddressId, []);

        if (tokenInfo?.value === NATIVE_TOKEN) {
          checkForSendTokenTransactionStatus(batchTransactionsResult);
        } else {
          checkForFtTransferTransactionsStatus(batchTransactionsResult);
        }
      }
    };

    if (batchTransactionsResult?.length > 0) {
      getTokenInfo();
    }
  }, [batchTransactionsResult]);

  const getTransactionsReceipts = async (transactionHashes: string[]) => {
    dispatch(setAppLoading(true));

    try {
      const transactionsStatus: FinalExecutionOutcomeExtended[] = (await getTransactionStatus(transactionHashes)) || [];
      setBatchTransactionsResult(transactionsStatus);
    } catch (e) {
    } finally {
      dispatch(setAppLoading(false));
    }
  };

  const handleSetTransactionStatus = (
    transferEventFailedReceipts: Record<string, any>,
    transferEventSuccessReceipts: Record<string, any>,
    receiptsObject: Record<any, any>,
    transactionReceiptData: Record<
      string,
      Record<'Success' | 'Failure', Record<string, ExecutionOutcomeWithIdExtended>>
    >,
  ) => {
    let transactionsStatus = null;
    //Some transactions finished
    if (Object.keys(transferEventFailedReceipts)?.length > 0 && Object.keys(transferEventSuccessReceipts)?.length > 0) {
      transactionsStatus = TRANSACTION_STATUS.SOME_FAILED;
    }
    //All transactions failed
    else if (
      Object.keys(transferEventFailedReceipts)?.length > 0 &&
      Object.keys(transferEventSuccessReceipts)?.length === 0
    ) {
      transactionsStatus = TRANSACTION_STATUS.ALL_FAILED;
    }
    //Some transaction failed
    else if (
      Object.keys(transferEventFailedReceipts)?.length === 0 &&
      Object.keys(transferEventSuccessReceipts)?.length > 0
    ) {
      transactionsStatus = TRANSACTION_STATUS.ALL_FINISHED;
    } else {
      //All transactions failed
      transactionsStatus = TRANSACTION_STATUS.ALL_FAILED;
    }

    setReceipts(receiptsObject);
    setFailedReceipts(transferEventFailedReceipts);
    setSuccessReceipts(transferEventSuccessReceipts);
    setTransactionsStatus(transactionsStatus);
    setTransactions(Object.entries(transactionReceiptData));
  };

  const checkForSendTokenTransactionStatus = (batchTransactionsResult: FinalExecutionOutcomeExtended[]) => {
    const wallet = getWallet();

    const { transactionReceiptData = {}, receiptsObject = {} } =
      wallet?.readBulkTransferTransactionStatus(batchTransactionsResult || []) || {};

    let failedReceipts: Record<string, ExecutionOutcomeWithIdView> = {},
      successReceipts: Record<string, ExecutionOutcomeWithIdView> = {};

    for (const { Failure, Success } of Object.values(transactionReceiptData)) {
      failedReceipts = { ...failedReceipts, ...Failure };
      successReceipts = { ...successReceipts, ...Success };
    }

    const transferEventFailedReceipts: Record<string, any> = {},
      transferEventSuccessReceipts: Record<string, any> = {},
      refundEventsReceipts: Record<string, any> = {};
    for (const receipt of Object.values(failedReceipts)) {
      if (
        receiptsObject[receipt?.id] &&
        !!get(receiptsObject, [receipt?.id, 'receipt', 'Action', 'actions', '0', 'Transfer'])
      ) {
        transferEventFailedReceipts[receipt?.id] = { ...receiptsObject[receipt?.id] };
      }
    }
    for (const receipt of Object.values(successReceipts)) {
      //If event callback_distribute_near has logs => Refund event => Remove receipts from list success
      if (
        receipt?.outcome?.logs?.length > 0 &&
        receiptsObject[receipt?.id] &&
        !!(
          get(receiptsObject, [receipt?.id, 'receipt', 'Action', 'actions', '0', 'FunctionCall', 'method_name']) ===
          'callback_transfer_near'
        )
      ) {
        for (const receiptId of receipt?.outcome?.receipt_ids) {
          refundEventsReceipts[receiptId] = receiptId;
        }
      }

      //If is Transfer event but refund => Remove receipts from list success
      if (
        receiptsObject[receipt?.id] &&
        !!get(receiptsObject, [receipt?.id, 'receipt', 'Action', 'actions', '0', 'Transfer']) &&
        !refundEventsReceipts[receipt?.id]
      ) {
        transferEventSuccessReceipts[receipt?.id] = { ...receiptsObject[receipt?.id] };
      }
    }

    handleSetTransactionStatus(
      transferEventFailedReceipts,
      transferEventSuccessReceipts,
      receiptsObject,
      transactionReceiptData,
    );
  };

  const checkForFtTransferTransactionsStatus = (batchTransactionsResult: FinalExecutionOutcomeExtended[]) => {
    const wallet = getWallet();

    const { transactionReceiptData = {}, receiptsObject = {} } =
      wallet?.readBulkTransferTransactionStatus(batchTransactionsResult || []) || {};

    let failedReceipts: Record<string, ExecutionOutcomeWithIdView> = {},
      successReceipts: Record<string, ExecutionOutcomeWithIdView> = {};

    for (const { Failure, Success } of Object.values(transactionReceiptData)) {
      failedReceipts = { ...failedReceipts, ...Failure };
      successReceipts = { ...successReceipts, ...Success };
    }

    const transferEventFailedReceipts: Record<string, any> = {},
      transferEventSuccessReceipts: Record<string, any> = {};
    for (const receipt of Object.values(failedReceipts)) {
      if (
        receiptsObject[receipt?.id] &&
        ['ft_on_transfer'].includes(
          get(receiptsObject, [
            receipt?.id,
            'receipt',
            'Action',
            'actions',
            '0',
            'FunctionCall',
            'method_name',
          ]) as string,
        )
      ) {
        transferEventFailedReceipts[receipt?.id] = { ...receiptsObject[receipt?.id] };
      }
    }
    for (const receipt of Object.values(successReceipts)) {
      if (
        receiptsObject[receipt?.id] &&
        ['ft_transfer'].includes(
          get(receiptsObject, [
            receipt?.id,
            'receipt',
            'Action',
            'actions',
            '0',
            'FunctionCall',
            'method_name',
          ]) as string,
        )
      ) {
        transferEventSuccessReceipts[receipt?.id] = { ...receiptsObject[receipt?.id] };
      }
    }

    handleSetTransactionStatus(
      transferEventFailedReceipts,
      transferEventSuccessReceipts,
      receiptsObject,
      transactionReceiptData,
    );
  };

  const bulkSendNear = async ({
    serviceFee,
    totalAccountPayingFor,
  }: {
    serviceFee: number;
    totalAccountPayingFor: number;
  }) => {
    const { account, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    dispatch(setLoadingTransactions(true));

    if (library && account) {
      try {
        const serviceFeeRequest = wallet?.payForServiceFee({
          library,
          account,
          data: { serviceFee, totalAccountPayingFor },
        });

        const bulkSenderAccounts: any[] = listAddressToSend.reduce((acc: BulkSendProps[], cur) => {
          acc.push({ account_id: cur?.address, amount: utils.format.parseNearAmount(cur?.amount.toString()) || '0' });
          return acc;
        }, []);

        const transactions = [];

        if (serviceFee && serviceFee.toString() !== '0' && serviceFeeRequest) {
          transactions.push(serviceFeeRequest);
        }

        const sendNearTransactions = bulkSenderAccounts.reduce((result, value, index, array) => {
          if (index % CHUNK_SIZE.NATIVE_TOKEN === 0) {
            const max_slice = Math.min(index + CHUNK_SIZE.NATIVE_TOKEN, bulkSenderAccounts.length);
            const { receivers, amount, totalAmount } = array.slice(index, max_slice).reduce(
              (acc, cur) =>
                (acc = {
                  receivers: acc.receivers.concat(cur?.account_id),
                  amount: acc.amount.concat(cur?.amount),
                  totalAmount: addValue([acc.totalAmount, cur?.amount]),
                }),
              { receivers: [], amount: [], totalAmount: 0 },
            );

            result.push(
              wallet?.sendNear({
                library,
                account,
                data: {
                  receivers,
                  amount,
                  totalAmount,
                },
              }),
            );
          }
          return result;
        }, []);

        transactions.push(...sendNearTransactions);

        await handleTransactions(transactions);
      } catch (e) {
        console.log(e);
        if (BROWSER_WALLETS.includes(connectedWalletType)) {
          dispatch(setLoadingTransactions(false));
        }
      } finally {
        if (!BROWSER_WALLETS.includes(connectedWalletType)) {
          dispatch(setLoadingTransactions(false));
        }
      }
    }
  };

  const bulkSendFtToken = async () => {
    const { account, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    dispatch(setLoadingTransactions(true));

    if (library && account) {
      try {
        const bulkSenderAccounts: any[] = listAddressToSend.reduce((acc: BulkSendProps[], cur) => {
          acc.push({ account_id: cur?.address, amount: convertPrice(cur?.amount, tokenInfo?.decimals) });
          return acc;
        }, []);

        const transactions = bulkSenderAccounts.reduce((result, value, index, array) => {
          if (index % CHUNK_SIZE.FT_TOKEN === 0) {
            const max_slice = Math.min(index + CHUNK_SIZE.FT_TOKEN, bulkSenderAccounts.length);
            const { msg, amount } = array.slice(index, max_slice).reduce(
              (acc, cur, index) =>
                (acc = {
                  msg: (acc.msg += `${index === 0 ? '' : '#'}${cur?.account_id}:${cur?.amount}`),
                  amount: (acc.amount = addValue([acc.amount, cur?.amount])),
                }),
              { msg: '', amount: 0 },
            );

            result.push(
              wallet?.sendToken({
                library,
                account,
                data: {
                  msg,
                  amount,
                  tokenContract: tokenInfo?.address,
                },
              }),
            );
          }
          return result;
        }, []);

        await handleTransactions(transactions);
      } catch (e) {
        console.log(e);
        if (BROWSER_WALLETS.includes(connectedWalletType)) {
          dispatch(setLoadingTransactions(false));
        }
      } finally {
        if (!BROWSER_WALLETS.includes(connectedWalletType)) {
          dispatch(setLoadingTransactions(false));
        }
      }
    }
  };

  const handleTransactions = async (transactions: any[]) => {
    const { account, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    if (library && account) {
      if (transactions?.length > 0) {
        const batchTransactionsResult = await wallet?.batchTransactions({ library, transactions });

        if (!batchTransactionsResult) {
          return;
        }

        getTransactionsReceipts(batchTransactionsResult.map(({ transaction }) => transaction?.hash));
      }
    }
  };

  const retryTransaction = (stepToGoBack?: number) => () => {
    if (hasReport) {
      const promtGoBack = confirm(t('send_token.confirm_go_back'));

      if (!promtGoBack) {
        return;
      }
    }

    let listAddressToRetry: any = [];

    if (tokenInfo?.value === NATIVE_TOKEN) {
      listAddressToRetry = Object.values(failedReceipts)?.map((receipt: any) => ({
        address: receipt?.receiver_id,
        amount: getSendNEARAmountFromReceipt(receipt),
      }));
    } else {
      listAddressToRetry = Object.values(failedReceipts)?.map((receipt: any) => {
        const { address, amount } = getSendFtTokenParamsFromReceipt(receipt, tokenInfo) || {};

        return {
          address,
          amount,
        };
      });
    }

    setListAddress(listAddressToRetry);
    setListAddressToSend(listAddressToRetry);

    navigate(stepToGoBack || STEPS.SETUP)();
  };

  return {
    bulkSendFtToken,
    bulkSendNear,
    transactionsStatus,
    transactions,
    failedReceipts,
    successReceipts,
    retryTransaction,
    receipts,
    setTransactions,
    setTransactionsStatus,
  };
};

export default useBulkSendToken;

'''
'''--- src/hooks/blockchainHook/useGetBalance.ts ---
import { convertToBigNumber } from 'services/WalletService/utils/number';
import { NATIVE_TOKEN } from 'connectors/constants';
import { BigNumber } from 'bignumber.js';
import { useState } from 'react';

import { setAppToken } from 'store/address/slice';
import { useChainFactory } from '../walletHook/useChainFactory';
import { useAppDispatch } from 'hooks/useStore';
import { setBalance } from 'store/balance/slice';
import showMessage from 'components/Message';
import TYPE_CONSTANTS from 'constants/type';
import { NetworkId, Options } from '@near-wallet-selector/core/lib/options.types';

const useGetBalance = () => {
  const dispatch = useAppDispatch();

  const { getConnectedChainInfo, getWallet } = useChainFactory();

  const [isGettingBalance, setIsGettingBalance] = useState(false);
  const [hasGetBalance, setHasGetBalance] = useState(false);

  const handleSetBalance = (
    chainId: NetworkId | null | string | undefined,
    token: string,
    amount: BigNumber,
  ): Promise<string | number | undefined> => {
    const amountString = amount.toString();

    dispatch(
      setBalance({
        chainId,
        token,
        amount: amountString,
      }),
    );

    return new Promise((resolve) => {
      resolve(amountString);
    });
  };

  const handleErrorMessage = (options: Options | undefined) => {
    const { network } = options || {};

    showMessage(TYPE_CONSTANTS.MESSAGE.ERROR, 'message.E20', {
      interpolation: { escapeValue: false },
      rpc: network?.nodeUrl || 'NEAR RPC',
    });
  };

  const getBalance = async (token: string): Promise<string | number | undefined> => {
    const { chainId, account, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    setIsGettingBalance(true);
    setHasGetBalance(false);

    try {
      if (account && chainId && library && token) {
        const userBalance = await wallet?.getBalance({
          library,
          account,
          data: {
            token,
          },
        });

        if (userBalance) {
          const balance = userBalance || 0;

          dispatch(setAppToken(token));
          return handleSetBalance(chainId, token, balance);
        }
      }
    } catch (e) {
      handleErrorMessage(library?.options);
      return handleSetBalance(chainId, token, convertToBigNumber(0));
    } finally {
      setIsGettingBalance(false);
      setHasGetBalance(true);
    }
  };

  const getNativeTokenBalance = async (): Promise<string | number | undefined> => {
    const { chainId, account, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    setIsGettingBalance(true);
    setHasGetBalance(false);

    try {
      if (account && chainId && library) {
        const userBalance = await wallet?.getBalance({
          library,
          account,
        });

        if (userBalance) {
          const balance = userBalance || 0;

          return handleSetBalance(chainId, NATIVE_TOKEN, balance);
        }
      }
    } catch (e) {
      handleErrorMessage(library?.options);
      return handleSetBalance(chainId, NATIVE_TOKEN, convertToBigNumber(0));
    } finally {
      setIsGettingBalance(false);
      setHasGetBalance(true);
    }
  };

  return {
    getBalance,
    getNativeTokenBalance,
    isGettingBalance,
    hasGetBalance,
  };
};

export default useGetBalance;

'''
'''--- src/hooks/blockchainHook/useGetBlockData.ts ---
import { useAppDispatch } from 'hooks/useStore';
import { useChainFactory } from 'hooks/walletHook/useChainFactory';
import { setAppLoading } from 'store/global/slice';

const useGetBlockData = () => {
  const dispatch = useAppDispatch();

  const { getConnectedChainInfo, getWallet } = useChainFactory();

  const getBlockData = async (blockHashes: string[]) => {
    const { chainId, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    dispatch(setAppLoading(true));

    try {
      if (chainId && library) {
        const blockHashesData = await wallet?.getBlockData({
          library,
          data: {
            blockHashes,
            chainId: chainId as string,
            batchLimit: 25,
          },
        });

        return blockHashesData;
      }
    } catch (e) {
      console.log(e);
    } finally {
      dispatch(setAppLoading(false));
    }
  };
  return { getBlockData };
};

export default useGetBlockData;

'''
'''--- src/hooks/blockchainHook/useGetGasPrice.ts ---
import { CONTRACT_ID } from 'connectors/constants';
import { minusValue } from '../../services/WalletService/utils/number';
import { greaterThan } from 'services/WalletService/utils/number';
import { useAppDispatch } from '../useStore';
import { useChainFactory } from 'hooks/walletHook/useChainFactory';
import { useState } from 'react';
import { setAppLoading } from 'store/global/slice';

const useGetGasPrice = () => {
  const dispatch = useAppDispatch();

  const [isGettingGasPrice, setIsGettingGasPrice] = useState(false);
  const [hasGetGasPrice, setHasGetGasPrice] = useState(false);
  const [currentProgress, setCurrentProgress] = useState(0);

  const { getConnectedChainInfo, getWallet } = useChainFactory();

  const getGasPrice = async () => {
    const { chainId, account, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    setIsGettingGasPrice(true);
    setHasGetGasPrice(false);

    try {
      if (account && chainId && library) {
        const gasPrice = await wallet?.getGasPrice({
          library,
          account,
        });

        return new Promise((resolve) => resolve(gasPrice));
      }
    } catch (e) {
      console.log(e);
    } finally {
      setIsGettingGasPrice(false);
      setHasGetGasPrice(true);
    }
  };

  const getStorageFee = async (listData: any[], tokenContract: string) => {
    const { chainId, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    dispatch(setAppLoading(true));
    setCurrentProgress(0);

    try {
      if (chainId && library) {
        const [storageFee, appContractStorageFee, storageBalanceBound] = await Promise.all([
          wallet?.getStorageFee({
            library,
            data: {
              listData,
              batchLimit: 25,
              tokenContract,
            },
            callback: (current: number): void => {
              setCurrentProgress((current / listData?.length) * 100);
            },
          }),
          wallet?.getStorageFee({
            library,
            data: {
              listData: [{ address: CONTRACT_ID[chainId as string] }],
              batchLimit: 25,
              tokenContract,
            },
          }),
          wallet?.getStorageBalanceBounds({
            library,
            data: {
              tokenContract,
            },
          }),
        ]);
        let storageFeeList: any[] = [];
        let appContractStorageFeeNeed = 0;

        if (!storageBalanceBound?.max) {
          storageFeeList = (storageFee || []).map((data) => {
            const storageFeeNeed = greaterThan(storageBalanceBound?.min, data?.total) ? storageBalanceBound?.min : 0;

            return {
              ...data,
              storageFeeNeed,
            };
          });

          appContractStorageFeeNeed = greaterThan(storageBalanceBound?.min, appContractStorageFee?.[0]?.total)
            ? storageBalanceBound?.min
            : 0;
        } else {
          storageFeeList = (storageFee || []).map((data) => {
            const storageFeeNeed = greaterThan(storageBalanceBound?.min, minusValue([data?.total, data?.available]))
              ? storageBalanceBound?.min
              : 0;

            return {
              ...data,
              storageFeeNeed,
            };
          });

          appContractStorageFeeNeed = greaterThan(
            storageBalanceBound?.min,
            minusValue([appContractStorageFee?.[0]?.total, appContractStorageFee?.[0]?.available]),
          )
            ? storageBalanceBound?.min
            : 0;
        }

        return {
          appContractStorageFeeNeed,
          storageFeeList,
          minStorageFee: storageBalanceBound?.min,
        };
      }
    } catch (e) {
      console.log(e);
    } finally {
      dispatch(setAppLoading(false));
    }
  };

  return {
    getGasPrice,
    isGettingGasPrice,
    getStorageFee,
    currentProgress,
    hasGetGasPrice,
  };
};

export default useGetGasPrice;

'''
'''--- src/hooks/blockchainHook/useGetTokens.ts ---
import { useChainFactory } from 'hooks/walletHook/useChainFactory';
import { useState, useEffect } from 'react';
import axios from 'axios';

import { useAppSelector } from 'hooks/useStore';
import selectedAddress from 'store/address/selector';
import { WALLET_API } from 'connectors/constants';

export const useGetTokens = () => {
  const [ownedTokens, setOwnedTokens] = useState<string[]>([]);
  const [ownedTokensInfo, setOwnedTokensInfo] = useState<any[]>([]);
  const [isLoadingTokens, setIsLoadingTokens] = useState(false);

  const { address, chainId } = useAppSelector(selectedAddress.getAddress);

  const { getConnectedChainInfo, getWallet } = useChainFactory();

  const getOwnedTokens = async () => {
    try {
      const response = await axios.get(`${WALLET_API[chainId]}/account/${address}/likelyTokens`);
      setIsLoadingTokens(true);

      if (response?.status === 200) {
        setOwnedTokens(response?.data);
      }
    } catch (e) {
      setOwnedTokens([]);
    } finally {
      setIsLoadingTokens(false);
    }
  };

  useEffect(() => {
    const getOwnedTokensInfo = async () => {
      try {
        const { library } = getConnectedChainInfo() || {};
        const wallet = getWallet();
        setIsLoadingTokens(true);

        const response = await wallet?.getTokenMetadata({ library, data: { tokens: ownedTokens, batchLimit: 25 } });

        setOwnedTokensInfo(response);
      } catch (e) {
        setOwnedTokensInfo([]);
      } finally {
        setIsLoadingTokens(false);
      }
    };
    if (ownedTokens?.length > 0) {
      getOwnedTokensInfo();
    }
  }, [ownedTokens]);

  return { getOwnedTokens, isLoadingTokens, ownedTokensInfo, ownedTokens };
};

'''
'''--- src/hooks/blockchainHook/useGetTransactionStatus.ts ---
import { useChainFactory } from 'hooks/walletHook/useChainFactory';

// transactionHashes=J4FFyYAMkmr45y7zTGBU7mrGEJvb2kEvVWp1ivNsLDi4%2C8rShdgP4inKps5cM1KF8UNe6b1vgsgDToAVF26xxaePz
// transactionHashes=EpnMB7TuiCqv1WtqQDNSCTKFnZ561RE3XT79rKPTffzx%2CA4n7BdwFJ1XBsoubPWm9CQQSbqkb3R6ZVXWTPBDNKs96

//NEAR
// transactionHashes=EM3o7u25JqksWwd8bnyQjPuBVt24rcft25eMu7zWoMiF
//HKJ2nL3yAxXxJJh5Hsjq1YkVhTW7Jn9y3sxSzivkftJS

const useGetTransactionStatus = () => {
  const { getConnectedChainInfo, getWallet } = useChainFactory();

  const getTransactionStatus = async (txHash: string[]) => {
    const { chainId, account, library } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    try {
      if (account && chainId && library) {
        const transactionStatus = await wallet?.getTransactionStatusReceipts({
          library,
          txHash,
          account,
        });

        return transactionStatus?.map((response) => {
          if (response?.status === 200) {
            return response?.data?.result || {};
          } else {
            return {};
          }
        });
      }
    } catch (e) {
      console.log(e);
    }
  };

  return {
    getTransactionStatus,
  };
};

export default useGetTransactionStatus;

'''
'''--- src/hooks/blockchainHook/useNearWalletQueryParams.ts ---
import { INITIAL_STEP } from './../../context/SendTokenContext';
import { STEPS_LINK } from 'pages/home';
import { useEffect, useState } from 'react';

import { useAppSelector } from 'hooks/useStore';
import { useAppDispatch } from './../useStore';
import { setTransactionHashes, setErrorMessage } from 'store/sendToken/slice';
import navigationService from 'services/navigationService';
import selectGlobalState from 'store/global/selector';
import { setQueryParams } from 'store/global/slice';

const useNearWalletQueryParams = () => {
  const dispatch = useAppDispatch();

  const [hasInit, setHasInit] = useState(false);

  const queryParams = useAppSelector(selectGlobalState.getQueryParams);

  useEffect(() => {
    if (hasInit) {
      return;
    }

    const removeTransactionHashes = async () => {
      const { step, transactionHashes, errorCode } = queryParams || {};
      const navigate = navigationService?.navigation;

      if (errorCode === 'userRejected') {
        dispatch(setErrorMessage('message.E12'));
      } else {
        dispatch(setErrorMessage(''));
      }

      transactionHashes && dispatch(setTransactionHashes(transactionHashes.split(',')));

      navigate(
        {
          search: `?step=${step}`,
        },
        {
          replace: true,
        },
      );
    };

    const redirectToPrepareStep = () => {
      const navigate = navigationService?.navigation;

      navigate({
        search: `?step=${STEPS_LINK[INITIAL_STEP]}`,
      });

      dispatch(setQueryParams({ step: STEPS_LINK[INITIAL_STEP] }));
    };

    if (queryParams?.transactionHashes || queryParams?.errorCode) {
      removeTransactionHashes();
      setHasInit(true);
    } else if (queryParams?.step && queryParams?.step !== STEPS_LINK[INITIAL_STEP]) {
      redirectToPrepareStep();
      setHasInit(true);
    }
  }, [queryParams]);
};

export default useNearWalletQueryParams;

'''
'''--- src/hooks/blockchainHook/useServiceFee.ts ---
import { useState, useEffect } from 'react';
import { useAppDispatch } from '../useStore';
import { useChainFactory } from 'hooks/walletHook/useChainFactory';
import { setAppLoading } from 'store/global/slice';
import { Transaction } from '@near-wallet-selector/core';
import TYPE_CONSTANTS from 'constants/type';
import showMessage from 'components/Message';
import { CONTRACT_ID } from 'connectors/constants';
import { addValue, multiplyValue } from 'services/WalletService/utils/number';

const CHUNK_SIZE = 35;

const useServiceFee = (listAddressToSendLength: number) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [serviceFee, setServiceFee] = useState(0);
  const [totalServiceFee, setTotalServiceFee] = useState(0);
  const [accountPaymentForServiceFee, setAccountPaymentForServiceFee] = useState(0);
  const [totalAccountPayingFor, setTotalAccountPayingFor] = useState(0);

  const dispatch = useAppDispatch();

  const { getConnectedChainInfo, getWallet } = useChainFactory();

  useEffect(() => {
    const totalServiceFeeNeedToPay = calculateServiceFee(
      listAddressToSendLength,
      accountPaymentForServiceFee,
      serviceFee,
    );

    setTotalServiceFee(totalServiceFeeNeedToPay);
  }, [listAddressToSendLength, serviceFee, accountPaymentForServiceFee]);

  const calculateServiceFee = (listAddressLength: number, accountPaymentForServiceFee: number, serviceFee: any) =>
    listAddressLength - accountPaymentForServiceFee > 0
      ? multiplyValue([listAddressLength - accountPaymentForServiceFee, serviceFee])
      : 0;

  const getServiceFee = async () => {
    const { library, account } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    dispatch(setAppLoading(false));
    try {
      if (account && library) {
        //User has pay enough service fee to enable they to send token to accountPaymentForServiceFee accounts
        const [accountPaymentForServiceFee, serviceFee] = await Promise.all([
          wallet?.getAccountPaymentForServiceFee({
            library,
            account,
          }),
          wallet?.getServiceFee({
            library,
          }),
        ]);

        const totalServiceFeeNeedToPay = calculateServiceFee(
          listAddressToSendLength,
          accountPaymentForServiceFee,
          serviceFee,
        );

        setTotalAccountPayingFor(listAddressToSendLength - accountPaymentForServiceFee);
        setAccountPaymentForServiceFee(accountPaymentForServiceFee);
        setServiceFee(serviceFee);

        return {
          serviceFee: totalServiceFeeNeedToPay,
          totalAccountPayingFor: listAddressToSendLength - accountPaymentForServiceFee,
        };
      }
    } catch (e) {
    } finally {
      dispatch(setAppLoading(false));
    }
  };

  const payForServiceFee = async ({
    serviceFee,
    listAddressNeedStorageFee,
    tokenContract,
    retryTransactions,
    appContractStorageFeeNeed,
    totalAccountPayingFor,
  }: {
    serviceFee?: number;
    listAddressNeedStorageFee?: any[];
    tokenContract?: string;
    appContractStorageFeeNeed?: number;
    retryTransactions?: any[];
    totalAccountPayingFor?: number;
  }): Promise<
    | {
        transactionReceiptData?: any[];
        transactionsSuccessStatus?: boolean;
        failedTransactions?: any[];
        errorMessage?: string;
        successTransactions?: any[];
      }
    | undefined
  > => {
    const { library, account, chainId } = getConnectedChainInfo() || {};
    const wallet = getWallet();

    setIsProcessing(true);

    try {
      if (account && library && chainId) {
        let transactions: Transaction[] = [];

        const serviceFeeRequest = wallet?.payForServiceFee({
          library,
          account,
          data: { serviceFee, totalAccountPayingFor },
        });

        if (appContractStorageFeeNeed) {
          const appContractStorageFeeRequest: any =
            [
              wallet?.payForStorageFee({
                library,
                account,
                data: {
                  tokenContract,
                  account_ids: [CONTRACT_ID[chainId as string]],
                  min_fee: appContractStorageFeeNeed,
                  totalFee: appContractStorageFeeNeed,
                },
              }),
            ] || [];

          transactions.push(...appContractStorageFeeRequest);
        }

        const storageFeeRequest = listAddressNeedStorageFee?.reduce((result, value, index, array) => {
          if (index % CHUNK_SIZE === 0) {
            const max_slice = Math.min(index + CHUNK_SIZE, listAddressNeedStorageFee?.length);
            const { account_ids, min_fee, totalFee } = array.slice(index, max_slice).reduce(
              (acc, cur) =>
                (acc = {
                  account_ids: acc.account_ids.concat(cur?.address),
                  min_fee: cur?.storageFeeNeed,
                  totalFee: addValue([acc.totalFee, cur?.storageFeeNeed]),
                }),
              { account_ids: [], min_fee: 0, totalFee: 0 },
            );

            result.push(
              wallet?.payForStorageFee({
                library,
                account,
                data: {
                  tokenContract,
                  account_ids,
                  min_fee,
                  totalFee,
                },
              }),
            );
          }
          return result;
        }, []);

        if (retryTransactions) {
          transactions = retryTransactions;
        } else {
          if (serviceFee && serviceFee.toString() !== '0' && serviceFeeRequest) {
            transactions.push(serviceFeeRequest);
          }

          transactions.push(...(storageFeeRequest || []));
        }

        if (transactions?.length > 0) {
          const batchTransactionsResult = await wallet?.batchTransactions({ library, transactions });

          if (!batchTransactionsResult) {
            return;
          }

          let errorMessage = '';

          const {
            transactionsSuccessStatus,
            failedTransactions = [],
            successTransactions,
          } = wallet?.readTransactionStatus(batchTransactionsResult || [], transactions || []) || {};

          if (failedTransactions?.length === transactions?.length) {
            errorMessage = 'message.E11';
          }

          if (failedTransactions?.length > 0 && failedTransactions?.length < transactions?.length) {
            errorMessage = 'message.E13';
          }

          if (failedTransactions?.length === 0) {
            showMessage(TYPE_CONSTANTS.MESSAGE.SUCCESS, 'message.S2');
          }

          return { transactionsSuccessStatus, errorMessage, failedTransactions, successTransactions };
        } else {
          return { transactionsSuccessStatus: true };
        }
      }
    } catch (e) {
      return { transactionsSuccessStatus: false };
    } finally {
      setIsProcessing(false);
    }
  };

  return {
    getServiceFee,
    payForServiceFee,
    isProcessing,
    serviceFee,
    totalServiceFee,
    totalAccountPayingFor,
  };
};

export default useServiceFee;

'''
'''--- src/hooks/blockchainHook/useSetQueryParams.ts ---
import { useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';

import navigationService from 'services/navigationService';
import { useAppDispatch } from 'hooks/useStore';
import { setQueryParams } from 'store/global/slice';

const useSetQueryParams = () => {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();

  const dispatch = useAppDispatch();

  useEffect(() => {
    const parsedQueryParams = Object.fromEntries([...searchParams]);

    if (!navigationService?.navigation) {
      navigationService.navigation = navigate;
      dispatch(setQueryParams(parsedQueryParams));
    }
  }, []);
};

export default useSetQueryParams;

'''
'''--- src/hooks/useDebounce.ts ---
import { useState, useEffect } from 'react';

// Hook
// T is a generic type for value parameter, our case this will be string
export function useDebounce<T>(value: T, delay: number): T {
  // State and setters for debounced value
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  useEffect(
    () => {
      // Update debounced value after delay
      const handler = setTimeout(() => {
        setDebouncedValue(value);
      }, delay);
      // Cancel the timeout if value changes (also on delay change or unmount)
      // This is how we prevent debounced value from updating if value is changed ...
      // .. within the delay period. Timeout gets cleared and restarted.
      return () => {
        clearTimeout(handler);
      };
    },
    [value, delay], // Only re-call effect if value or delay changes
  );
  return debouncedValue;
}

'''
'''--- src/hooks/useInterval.ts ---
import { MutableRefObject, useEffect, useMemo, useRef } from 'react';

export function useInterval(callback: Function, interval: number | undefined) {
  const intervalId: MutableRefObject<null | number> = useRef(null);
  const handler = useMemo(() => {
    return {
      start(overrideInterval: number | undefined = undefined): void {
        handler.stop();
        intervalId.current = setInterval(callback, overrideInterval === undefined ? interval : overrideInterval);
      },

      stop(): void {
        if (intervalId.current) {
          clearInterval(intervalId.current);
        }
      },

      restart() {
        handler.stop();
        handler.start();
      },
    };
  }, [callback, interval]);

  useEffect(() => {
    return () => {
      handler.stop();
    };
  }, []);

  return handler;
}

'''
'''--- src/hooks/useSocket.ts ---
import { useEffect } from 'react';

import { useAppSelector } from './useStore';
import Socket from 'services/SocketService';
import selectedAddress from 'store/address/selector';

export const useSocket = ({
  event,
  handleEvent,
  dependences,
}: {
  event: string | string[];
  handleEvent: any;
  dependences?: any;
}) => {
  const { address } = useAppSelector(selectedAddress.getAddress);

  useEffect(() => {
    const socketIo = new Socket();
    const socketInstance = socketIo.getInstance();

    if (address) {
      socketInstance.on(event, (data: any) => {
        handleEvent(data);
      });
    }
    return () => {
      socketInstance.close();
      socketIo.removeInstance();
    };
  }, [address, ...(dependences || [])]);
};

'''
'''--- src/hooks/useStore.ts ---
import { shallowEqual, TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import { AppDispatch, RootState } from 'store/configStore';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = (state) => useSelector(state, shallowEqual);

'''
'''--- src/hooks/useTimeout.ts ---
import { MutableRefObject, useEffect, useMemo, useRef } from 'react';

export function useTimeout(callback: Function, timeout = 0): any {
  const timeoutId: MutableRefObject<null | number> = useRef(null);
  const handler = useMemo(() => {
    return {
      start(overrideTimeout: number | undefined = undefined): void {
        handler.stop();
        timeoutId.current = setTimeout(callback, overrideTimeout === undefined ? timeout : overrideTimeout);
      },

      stop(): void {
        if (timeoutId.current) {
          clearTimeout(timeoutId.current);
        }
      },

      restart(): void {
        handler.stop();
        handler.start();
      },
    };
  }, [callback, timeout]);

  useEffect(() => {
    return () => {
      handler.stop();
    };
  }, []);

  return handler;
}

'''
'''--- src/hooks/useWindowSize.ts ---
import { useEffect, useState } from 'react';

const isClient = typeof window === 'object';

function getSize() {
  return {
    width: isClient ? window.innerWidth : undefined,
    height: isClient ? window.innerHeight : undefined,
  };
}

export default function useWindowSize() {
  const [windowSize, setWindowSize] = useState(getSize);

  useEffect(() => {
    function handleResize() {
      setWindowSize(getSize());
    }

    if (isClient) {
      window.addEventListener('resize', handleResize);
      return () => {
        window.removeEventListener('resize', handleResize);
      };
    }
    return undefined;
  }, []);

  return windowSize;
}

'''
'''--- src/hooks/walletHook/useChainFactory.ts ---
import { useEffect, useState } from 'react';

import { useAppSelector } from 'hooks/useStore';
import { CHAIN_ID } from 'connectors/constants';
import selectedAddress from 'store/address/selector';
import { ChainFactory } from 'utils/chains/ChainFactory';
import NearChainService from 'services/WalletService/NearChainService';
import { useWalletSelector } from 'context/NearWalletSelectorContext';

export const useChainFactory = (checkConnectedChainId = false) => {
  const { chainId: appChainId } = useAppSelector(selectedAddress.getAddress);

  const {
    active: isConnectingNear,
    accountId: nearAccount,
    chainId: nearChainId,
    selector: nearLibrary,
  } = useWalletSelector();

  const [connectedChainId, setConnectedChainId] = useState<string | number | null | undefined>(undefined);

  const getConnectedChainInfo = (chainId = '') => {
    if (!chainId && !appChainId) {
      return null;
    }

    switch (chainId?.toString() || appChainId?.toString()) {
      case CHAIN_ID.NEAR_TEST:
      case CHAIN_ID.NEAR:
        return {
          chainId: nearChainId,
          account: nearAccount,
          library: nearLibrary,
          active: isConnectingNear,
        };
    }
  };

  const getConnectedStatus = (chainId: string | number): boolean => {
    if (!chainId) {
      return false;
    }

    switch (chainId?.toString()) {
      case CHAIN_ID.NEAR_TEST:
      case CHAIN_ID.NEAR:
        return isConnectingNear;
    }

    return false;
  };

  const getWallet = (chainId = undefined): NearChainService | undefined => {
    if (!chainId && !appChainId) {
      return undefined;
    }

    return new ChainFactory().getChain(chainId || appChainId)?.getService() as NearChainService;
  };

  useEffect(() => {
    const checkChainId = () => {
      const { chainId } = getConnectedChainInfo() || {};
      setConnectedChainId(chainId as string);
    };

    if (checkConnectedChainId) {
      checkChainId();
    }
  }, [nearAccount, nearChainId]);

  return {
    getConnectedChainInfo,
    getConnectedStatus,
    getWallet,
    connectedChainId,
  };
};

'''
'''--- src/hooks/walletHook/useChangeNetwork.ts ---
import { useEffect } from 'react';

import { useAppDispatch, useAppSelector } from 'hooks/useStore';
import selectedAddress from 'store/address/selector';
import useGetWalletService from './useGetWalletService';

export const useChangeNetwork = () => {
  const dispatch = useAppDispatch();

  const { library } = { library: null };

  const { wallet } = useGetWalletService();

  const { chainId: beforeChangeChainId } = useAppSelector(selectedAddress.getAddress);
  const targetChainId = '';

  const switchNetwork = async () => {
    try {
      const changeNetworkResponse = await wallet?.changeNetwork({
        library,
        data: {
          chainId: targetChainId,
        },
      });

      //Reject metamask => change back to change before
      if (changeNetworkResponse === undefined) {
        // dispatch(handleSetTargetChainId(beforeChangeChainId));
      }

      //Accepted change network => reset state
      if (changeNetworkResponse) {
        // dispatch(handleSetTargetChainId(null));
      }

      return changeNetworkResponse;
    } catch (e: any) {
      console.log(e);
      return false;
    }
  };

  useEffect(() => {
    if (targetChainId) {
      switchNetwork();
    }
  }, [targetChainId]);

  return {
    switchNetwork,
  };
};

'''
'''--- src/hooks/walletHook/useGetWalletService.ts ---
import { useEffect, useState } from 'react';

import { ChainFactory } from 'utils/chains/ChainFactory';
import selectedAddress from 'store/address/selector';
import NearChainService from 'services/WalletService/NearChainService';
import { useAppSelector } from 'hooks/useStore';

const useGetWalletService = () => {
  const [wallet, setWallet] = useState<NearChainService | undefined>(undefined);
  const { chainId } = useAppSelector(selectedAddress.getAddress);

  useEffect(() => {
    const walletService = new ChainFactory().getChain(chainId);

    setWallet(walletService?.getService());
  }, [chainId]);

  return { wallet };
};

export default useGetWalletService;

'''
'''--- src/language/i18n.ts ---
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import detector from 'i18next-browser-languagedetector';

import en from './locales/en/defaults.json';

export const LANGUAGE_RESOURCES = {
  en: {
    translation: en,
  },
};

i18n
  .use(detector)
  .use(initReactI18next)
  .init({
    resources: LANGUAGE_RESOURCES,
    fallbackLng: { default: ['en'] },
    nsSeparator: false,
    detection: {
      order: ['localStorage', 'navigator', 'querystring', 'cookie', 'htmlTag'],
      lookupQuerystring: 'lang',
      lookupCookie: 'i18n',
      lookupLocalStorage: 'i18App',
      caches: ['localStorage', 'cookie'],
    },
  });

export default i18n;

(window as any).i18n = i18n;

'''
'''--- src/language/locales/en/defaults.json ---
{
  "common": {
    "network_notice_title": "Wrong Network",
    "network_notice_desc": "Please change network on {{wallet}} to \n {{network}} to continue.",
    "select_network": "Select Network",
    "select_date": "Select date",
    "all": "All",
    "no_data": "No Data",
    "or": "or",
    "near_wallet": "NEAR Wallet",
    "sender": "Sender",
    "connect_wallet": "Connect Wallet",
    "connected_wallet": "Connected Wallet",
    "next": "Next",
    "back": "Back",
    "address": "Address",
    "amount": "Amount",
    "total_count": "Total count",
    "try_again": "Try again",
    "storage_fee": "Storage Fee",
    "estimated_fee": "Estimated Fee",
    "selected": "selected",
    "failure": "Failure",
    "success": "Success",
    "of": "of",
    "status": "Status",
    "no": "No",
    "total_address": "Total addresses",
    "total_amount": "Total Amount",
    "powered_by": "Powered by",
    "send_transaction": "Send transactions",
    "view_on": "Open in explorer",
    "copy": "Copy"
  },
  "message": {
    "E0": "Internal Server Error",
    "E1": "Please input token first",
    "E2": "Invalid token address",
    "E3": "Please provide at least 2 addresses",
    "E4": "The below transactions cannot be processed [Delete them]",
    "E8": "Insufficient token balance on your account",
    "E9": "Insufficient NEAR balance on your account",
    "E10": "Your transactions are sent. However, some failed. Please retry.",
    "E11": "Transactions failed. Please try again.",
    "E12": "Transaction rejected. Please try again",
    "E13": "Some failed. Please try again",
    "E14": "Connection failed. Please try again",
    "E19": "Please select at least 1 address to continue",
    "E20": "Could not retrieve balance from {{rpc}}",
    "S1": "All your transactions were sent out successfully. You can now download your transaction report.",
    "S2": "Transactions succeeded"
  },
  "header": {
    "disconnect": "Disconnect",
    "disconnect_wallet": "Disconnect Wallet",
    "tutorial": "Tutorial",
    "switch_wallet": "Switch Wallet"
  },
  "home": {
    "title": "Bulk send NEAR and \n NEP-141 tokens in one click",
    "cta": "Fed up of wasting time manually sending out multiple transactions on NEAR Protocol ? Nearsend is for you! Bulk-transacting on NEAR has never been easier.",
    "connect": "Connect your wallet",
    "to_start": "to start a bulk send.",
    "view_tutorial": "View Tutorial"
  },
  "block_multiple_tabs": {
    "title": "Multiple tabs detected",
    "content": "You have been redirected to this page because there are more than one Nearsend.io page opened. It may cause problems with Browser LocalStorage. Please close this page and go to the previous one."
  },
  "send_token": {
    "prepare": "Prepare",
    "confirm": "Confirm",
    "send": "Send",
    "download_report": "Download Report (CSV File)",
    "send_token_notice": "Transactions were sent out. Please wait until all transactions are mined",
    "confirm_transaction": "Transactions are being sent. Please wait until all transactions are sent. ﻿You will be able to download a report once the last transaction is sent.",
    "retry": "Retry all failed transactions",
    "setup_token_accounts": "Setup Storage Deposits",
    "storage_registered": "The address has registered storage for the sending token",
    "storage_unregistered": "The address has NOT registered storage for the sending token",
    "search_address": "Search address",
    "retry_btn": "Retry",
    "allAddress": "All Addresses",
    "unregisteredAddress": "Unregistered Addresses",
    "registeredAddress": "Registered Addresses",
    "storage_registration": "Storage Registration",
    "storage_registration_desc": "This setting is used to filter the addresses that have registered (or not registered) storage for the sending token",
    "notice_storage_fee_need": "NEAR Protocol requires a storage fee for addresses that are yet to interact with the token you are sending. We have compiled a list of those addresses below. Please select and/or deselect recipient addresses to confirm your final list.",
    "notice_no_storage_fee_need": "Please select and/or deselect recipient addresses to confirm your final list.",
    "note_handle_duplicate_address": "NOTE: Duplicate addresses have been merged and amounts are added together.",
    "list_of_recipient": "List of Recipients",
    "double_check": "Please double check the list of addresses before continuing.",
    "check_address": "Checking the addresses",
    "new_transaction": "New Transaction",
    "confirm_go_back": "You will lose the report after leaving this page. Are you sure you want to leave this page?",
    "total_selected_address": "Total selected addresses"
  },
  "summary": {
    "title": "Summary",
    "total_address": "Total number of addresses",
    "total_token": "Total number of tokens to be sent",
    "total_transactions": "Total number of transactions needed",
    "total_balance": "Your token balance",
    "approximate_cost": "Estimated gas fees",
    "your_near_balance": "Your NEAR balance"
  },
  "report": {
    "no": "No.",
    "tx_time": "TX Time",
    "tx_hash": "TX Hash",
    "sender": "Sender",
    "smart_contract": "Nearsend Smart Contract",
    "recipient": "Recipient",
    "amount": "Amount",
    "token_ticker": "Token ticker",
    "token_address": "Token Address",
    "status": "Status",
    "gas_fee": "Gas fee"
  },
  "footer": {
    "title": "Nearsend Contract Address:",
    "commit_version": "Commit {{commit_hash}}. All rights reserved."
  },
  "tooltip": {
    "title": "Example",
    "title_example_file": "Example Files",
    "title_support": "Separated by commas",
    "format": "Format:",
    "address": "address",
    "amount": "amount",
    "instruction": "Separated by commas"
  },
  "prepare": {
    "label_address": "Token address",
    "balance": "Balance:",
    "decimals": "Decimals",
    "label_recipient": "Recipients and Amounts",
    "upload_file": "Upload file",
    "insert_manually": "Insert manually",
    "upload_instruction": "Drop your files here or click to upload",
    "support_format": "Separated by commas",
    "show_example": "Show example",
    "accepted_format": "Accepted formats : .csv ; .xls ; .txt",
    "example_file": "Example files",
    "next": "Next",
    "placeholder_address": "Select token or input token address",
    "placeholder_recipient": "Insert address and amount, separated by commas"
  },
  "button": {
    "delete": "Delete them",
    "process": "Processing..."
  },
  "progress": {
    "check": "Checking the addresses:"
  }
}

'''
'''--- src/reportWebVital.ts ---
const reportWebVitals = (onPerfEntry?: () => void) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- src/resources/svg/near_icon.svg ---
<svg width="26" height="26" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M20.8686 1.31986L15.4339 9.38889C15.3565 9.50509 15.3238 9.6454 15.3418 9.78385C15.3599 9.92231 15.4274 10.0495 15.532 10.142C15.6366 10.2345 15.7712 10.286 15.9108 10.287C16.0504 10.2879 16.1857 10.2383 16.2915 10.1472L21.6414 5.50694C21.6727 5.4789 21.7116 5.46058 21.7532 5.45423C21.7948 5.44789 21.8373 5.45379 21.8756 5.47121C21.9139 5.48863 21.9463 5.51683 21.9688 5.55235C21.9913 5.58787 22.003 5.62919 22.0025 5.67125V20.1987C22.0025 20.2432 21.9888 20.2866 21.9633 20.323C21.9377 20.3595 21.9016 20.3871 21.8598 20.4023C21.818 20.4175 21.7725 20.4195 21.7296 20.4079C21.6866 20.3964 21.6483 20.3719 21.6197 20.3378L5.44917 0.980417C5.18907 0.673283 4.8652 0.426482 4.50007 0.257171C4.13495 0.0878605 3.73733 0.000103087 3.33486 9.56922e-08H2.76972C2.03515 9.56922e-08 1.33066 0.291809 0.811233 0.811233C0.291809 1.33066 0 2.03515 0 2.76972V23.2303C0 23.9649 0.291809 24.6693 0.811233 25.1888C1.33066 25.7082 2.03515 26 2.76972 26C3.24335 26.0001 3.7091 25.8789 4.12254 25.6478C4.53598 25.4168 4.88331 25.0836 5.13139 24.6801L10.5661 16.6111C10.6435 16.4949 10.6762 16.3546 10.6582 16.2161C10.6401 16.0777 10.5726 15.9505 10.468 15.858C10.3634 15.7655 10.2288 15.714 10.0892 15.713C9.94957 15.7121 9.81433 15.7617 9.70847 15.8528L4.35861 20.4931C4.32726 20.5211 4.28842 20.5394 4.24683 20.5458C4.20524 20.5521 4.16271 20.5462 4.12442 20.5288C4.08613 20.5114 4.05373 20.4832 4.0312 20.4477C4.00866 20.4121 3.99695 20.3708 3.9975 20.3287V5.79764C3.99752 5.75316 4.01122 5.70977 4.03675 5.67335C4.06228 5.63693 4.0984 5.60925 4.1402 5.59407C4.182 5.57889 4.22747 5.57694 4.27042 5.58848C4.31337 5.60003 4.35172 5.62451 4.38028 5.65861L20.549 25.0196C20.8091 25.3267 21.133 25.5735 21.4981 25.7428C21.8632 25.9121 22.2609 25.9999 22.6633 26H23.2285C23.5923 26.0002 23.9527 25.9288 24.289 25.7897C24.6252 25.6506 24.9307 25.4466 25.1881 25.1894C25.4455 24.9322 25.6497 24.6268 25.789 24.2906C25.9283 23.9545 26 23.5942 26 23.2303V2.76972C26 2.03515 25.7082 1.33066 25.1888 0.811233C24.6693 0.291809 23.9649 9.56922e-08 23.2303 9.56922e-08C22.7567 -0.000124348 22.2909 0.121129 21.8775 0.352188C21.464 0.583246 21.1167 0.916401 20.8686 1.31986Z" fill="black"/>
</svg>

'''
'''--- src/resources/svg/open_in_new.svg ---
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.6667 12.6667H3.33333V3.33333H8V2H3.33333C2.59333 2 2 2.6 2 3.33333V12.6667C2 13.4 2.59333 14 3.33333 14H12.6667C13.4 14 14 13.4 14 12.6667V8H12.6667V12.6667ZM9.33333 2V3.33333H11.7267L5.17333 9.88667L6.11333 10.8267L12.6667 4.27333V6.66667H14V2H9.33333Z" fill="#BE8F30"/>
</svg>

'''
'''--- src/services/GraphQLService/getTransactionsDetail.ts ---
import { gql } from '@apollo/client';

export const TRANSACTION_DETAIL = gql`
  query ($hash: String) {
    transactions(where: { transaction_hash: { _eq: $hash } }) {
      block_timestamp
      transaction_hash
    }
  }
`;

'''
'''--- src/services/SocketService.ts ---
import io from 'socket.io-client';

let socketIo: any;

export default class Socket {
  getInstance = () => {
    if (socketIo == null) {
      socketIo = io(`${import.meta.env.VITE_SOCKET_URL}`, {
        secure: true,
        reconnection: true,
        rejectUnauthorized: false,
        transports: ['websocket'],
      });

      socketIo.on('connect', () => {
        console.log('connect=', 'connect');
      });
      socketIo.on('disconnect', () => {
        console.log('------------disconnect-socket------------');
      });
    }
    return socketIo;
  };

  removeInstance = () => {
    socketIo = null;
  };
}

'''
'''--- src/services/WalletService/BaseWalletService.ts ---
import { convertToBigNumber } from './utils/number';
import { BigNumber } from 'bignumber.js';
import { ValidationError } from 'yup';

import { INIT_UNIT_256, INIT_UNIT_128 } from './constants/index';

export default class BaseWalletService {
  address: string | null;
  needTobeInitiated: any;
  initUnit256: any;
  initUnit128: any;

  constructor(props: any) {
    this.address = props?.address;
    this.initUnit128 = INIT_UNIT_128;
    this.initUnit256 = INIT_UNIT_256;
  }

  isAddress(address: string): boolean | ValidationError | Promise<boolean | ValidationError> {
    return false;
  }

  getBalance = async ({
    library,
    account,
    data,
  }: {
    library: any;
    account: string;
    data: {
      token: string;
    };
  }): Promise<BigNumber> => {
    return new Promise((resolve) => resolve(convertToBigNumber(0)));
  };

  getStatusCheckCurrency = async ({
    library,
    account,
    data,
  }: {
    library: any;
    account: string;
    data: {
      tokenAddress: string;
      exchangeAddress: string;
      tokenKey: string;
    };
  }): Promise<boolean> => {
    return new Promise((resolve) => resolve(false));
  };

  approveCurrency = async ({
    library,
    account,
    data,
    callback,
  }: {
    library: any;
    account: string;
    data: {
      tokenAddress: string;
      exchangeAddress: string;
      tokenKey: string;
    };
    callback: {
      success: () => void;
      failed: () => void;
    };
  }) => {};

  signMessage = async ({ library, account }: { library: any; account: string }) => {};

  changeNetwork = async ({ library, data }: { library: any; data: { chainId: number | string } }) => {};

  addToken = async ({
    library,
    data,
  }: {
    library: any;
    data: {
      tokenType: string;
      tokenAddress: string;
      tokenSymbol: string;
      tokenDecimals: number;
      tokenImage?: string;
      chainId?: string;
    };
  }) => {};

  getTotalSupply = ({
    library,
    data,
  }: {
    library: any;
    data: {
      tokenInfo: any;
    };
  }): any => {
    return undefined;
  };
}

'''
'''--- src/services/WalletService/NearChainService.ts ---
import { NATIVE_TOKEN_DECIMAL_SCALE } from './../../connectors/constants';
import { setErrorMessage } from 'store/sendToken/slice';
import { NearProvider } from './type/index.d';
import { BigNumber } from 'bignumber.js';
import { ValidationError } from 'yup';
import { providers, utils } from 'near-api-js';
import { ExecutionOutcomeWithIdView } from 'near-api-js/lib/providers/provider';
import { Transaction } from '@near-wallet-selector/core';

import {
  convertToBigNumber,
  minusValue,
  greaterThan,
  convertBalance,
  convertPrice,
  divideNumber,
} from './utils/number';
import BaseWalletService from './BaseWalletService';
import { META_DATA, META_DATA_RESPONSE } from './constants';
import axios from 'axios';
import { ExecutionOutcomeWithIdExtended, FinalExecutionOutcomeExtended } from 'types';
import { ARCHIVAL_NETWORK } from 'connectors/constants';
import { store } from 'store/configStore';
import { formatNearAmount, getContractId } from './utils/nearUtils';
import HTTP_STATUS_CONTSTANTS from 'constants/httpStatus';

let nearServiceInstance: any;

export default class NearChainService extends BaseWalletService {
  private CALL_FUNCTION = 'call_function';
  private VIEW_ACCOUNT = 'view_account';
  private VIEW_ACCESS_KEY_LIST = 'view_access_key_list';
  private FUNCTION_CALL: any = 'FunctionCall';
  private DEFAULT_GAS_PRICE = '100000000';
  private FINAL = 'final';
  private MAX_GAS = '0.0000000003';

  constructor(props?: any) {
    super(props);
  }

  isAddress = (address: string): boolean | ValidationError | Promise<boolean | ValidationError> => {
    if (!address || address?.length < 2 || address?.length > 64) {
      return false;
    }
    const accountRegex = new RegExp('^(([a-zd]+[-_])*[a-zd]+.)*([a-zd]+[-_])*[a-zd]+$');

    if (accountRegex.test(address)) {
      return true;
    }

    return false;
  };

  getInstance() {
    if (nearServiceInstance == null) {
      nearServiceInstance = new NearChainService();
      nearServiceInstance.constructor = null;
    }
    return nearServiceInstance;
  }

  removeInstance() {
    nearServiceInstance = null;
  }

  parseData = (data: any) => {
    return JSON.parse(Buffer.from(data).toString());
  };

  convertToBase64 = (args: any) => {
    const argsJsonStr = args ? JSON.stringify(args) : '';
    const args_base64 = argsJsonStr ? Buffer.from(argsJsonStr).toString('base64') : '';

    return args_base64;
  };

  promiseAllInBatches = async <T>(
    task: (item: any) => any,
    items: any[],
    batchSize: number,
    callback?: (currentItem: number) => void,
  ) => {
    let position = 0;
    let results: T[] = [];

    while (position < items.length) {
      const itemsForBatch = items.slice(position, position + batchSize);
      results = [...results, ...(await Promise.all(itemsForBatch.map((item) => task(item))))];
      position += batchSize;

      if (typeof callback === 'function') {
        callback(results?.length);
      }
    }
    return results;
  };

  checkForReceiptStatus = (
    receipts: ExecutionOutcomeWithIdView[],
    receiptIds: string[],
    receiptsData: Record<string, Record<'Success' | 'Failure', Record<string, ExecutionOutcomeWithIdExtended>>>,
    transactionHash: string,
  ) => {
    receiptIds?.map((receiptId) => {
      const receiptInfo = receipts.find(({ id }) => id === receiptId);

      if (receiptInfo?.id && receiptInfo?.outcome?.receipt_ids && receiptInfo?.outcome?.receipt_ids?.length > 0) {
        if (!receiptsData?.[transactionHash]) {
          receiptsData[transactionHash] = {
            Success: {},
            Failure: {},
          };
        }

        if (receiptInfo?.outcome?.status?.hasOwnProperty('SuccessValue')) {
          receiptsData[transactionHash]['Success'][receiptInfo.id] = { ...receiptInfo, hash: transactionHash };
        } else if (receiptInfo?.outcome?.status?.hasOwnProperty('Failure')) {
          receiptsData[transactionHash]['Failure'][receiptInfo.id] = { ...receiptInfo, hash: transactionHash };
        }
      }

      this.checkForReceiptStatus(receipts, receiptInfo?.outcome?.receipt_ids || [], receiptsData, transactionHash);
    });
  };

  readBulkTransferTransactionStatus = (transactionsResult: FinalExecutionOutcomeExtended[]) => {
    const transactionReceiptData: Record<
      string,
      Record<'Success' | 'Failure', Record<string, ExecutionOutcomeWithIdExtended>>
    > = {};
    const allReceipts = [];
    const receiptsObject: Record<any, any> = {};

    for (const transaction of transactionsResult) {
      const receiptsOutcome = transaction?.receipts_outcome as ExecutionOutcomeWithIdView[];

      allReceipts.push(...transaction?.receipts);

      this.checkForReceiptStatus(
        receiptsOutcome,
        receiptsOutcome?.[0]?.outcome?.receipt_ids || [],
        transactionReceiptData,
        transaction?.transaction?.hash,
      );
    }

    for (const receipt of allReceipts) {
      if (receipt?.receiver_id) {
        receiptsObject[receipt?.receipt_id] = receipt;
      }
    }
    return { transactionReceiptData, receiptsObject };
  };

  readTransactionStatus = (transactionsResult: any[], transactions: any[]) => {
    const transactionReceiptData = [];
    const failedTransactions = [];
    const successTransactions = [];
    let transactionsSuccessStatus = true;

    for (const [i, transaction] of transactionsResult.entries()) {
      const transactionSuccessReceiptId = transaction?.transaction_outcome?.outcome?.status?.SuccessReceiptId;
      const transactionReceipts = transaction?.receipts_outcome;
      const transactionReceipt = transactionReceipts.find(
        ({ id }: { id: string }) => id === transactionSuccessReceiptId,
      );
      const outcome = transactionReceipt?.outcome?.status;

      transactionReceiptData.push(transaction);

      if (outcome?.Failure) {
        failedTransactions.push(transactions[i]);
        transactionsSuccessStatus = false;
      } else {
        successTransactions.push(transactions[i]);
      }
    }

    return { successTransactions, failedTransactions, transactionReceiptData, transactionsSuccessStatus };
  };

  batchTransactions = async ({ library, transactions }: { library: NearProvider; transactions: any[] }) => {
    if (library) {
      try {
        const wallet = await library.wallet();
        const transactionsResult = await wallet.signAndSendTransactions({ transactions });
        return transactionsResult as FinalExecutionOutcomeExtended[];
      } catch (e: any) {
        console.log(e);
        if (e?.message === 'User reject') {
          store.dispatch(setErrorMessage('message.E12'));
        }
      }
    }
  };

  getProvider = (library: NearProvider, rpc?: string): providers.JsonRpcProvider | null => {
    if (library) {
      const { network } = library.options;
      const provider = new providers.JsonRpcProvider({ url: rpc || network.nodeUrl });

      return provider;
    }
    return null;
  };

  async readBlockchainData(
    library: NearProvider,
    account_id: string | undefined,
    method_name: string,
    args?: any,
    request_type = this.CALL_FUNCTION,
    finality = this.FINAL,
  ): Promise<any> {
    if (library && account_id) {
      const provider = this.getProvider(library);
      const args_base64 = this.convertToBase64(args);

      return provider?.query({
        request_type,
        account_id,
        method_name,
        args_base64,
        finality,
      });
    }
  }

  getTokenMetadata = async ({
    library,
    data,
  }: {
    library: NearProvider | undefined | null;
    data: { tokens: string[]; batchLimit: number };
  }): Promise<any> => {
    let results: any[] = [];

    if (library) {
      const provider = this.getProvider(library);
      const { tokens, batchLimit } = data || {};

      if (tokens?.length > 0) {
        results = await this.promiseAllInBatches<{ result: META_DATA }>(
          async (tokenContract: string) => {
            try {
              const response = await provider?.query<META_DATA_RESPONSE>({
                request_type: this.CALL_FUNCTION,
                account_id: tokenContract,
                method_name: 'ft_metadata',
                args_base64: '',
                finality: this.FINAL,
              });

              const parsedResult: META_DATA = response?.result
                ? { ...this.parseData(response?.result), address: tokenContract }
                : {};

              return parsedResult;
            } catch (e) {}
          },
          tokens,
          batchLimit,
        );

        return results.filter(Boolean);
      }
    } else {
      return [];
    }
  };

  getGasPrice = async ({ library }: { library: NearProvider; account: string }): Promise<string> => {
    try {
      const provider = this.getProvider(library);
      const { gas_price = this.DEFAULT_GAS_PRICE } = (await provider?.gasPrice(null)) || {};

      return formatNearAmount(gas_price);
    } catch (e) {
      return '0';
    }
  };

  getBlockData = async ({
    library,
    data,
  }: {
    library: NearProvider;
    data: {
      blockHashes: string[];
      batchLimit: number;
      chainId: string;
    };
  }) => {
    let results: any[] = [];

    if (library) {
      const { blockHashes, batchLimit, chainId } = data || {};

      const provider = this.getProvider(library, ARCHIVAL_NETWORK[chainId]);

      if (blockHashes?.length > 0) {
        results = await this.promiseAllInBatches(
          async (blockHash: any) => {
            try {
              const response = await provider?.block(blockHash);
              return response;
            } catch (e) {}
          },
          blockHashes,
          batchLimit,
        );

        return results.filter(Boolean);
      }
    } else {
      return [];
    }
  };

  getStorageFee = async ({
    library,
    data,
    callback,
  }: {
    library: NearProvider;
    data: {
      listData: any[];
      batchLimit: number;
      tokenContract: string;
    };
    callback?: (current: number) => void;
  }) => {
    let results: any[] = [];

    if (library) {
      const provider = this.getProvider(library);
      const { listData, batchLimit, tokenContract } = data || {};

      if (listData?.length > 0) {
        results = await this.promiseAllInBatches<{ result: META_DATA }>(
          async (item: any) => {
            try {
              const args_base64 = item?.address ? this.convertToBase64({ account_id: item?.address }) : '';

              const response = await provider?.query<any>({
                request_type: this.CALL_FUNCTION,
                account_id: tokenContract,
                method_name: 'storage_balance_of',
                args_base64,
                finality: this.FINAL,
              });
              const parsedResult = response?.result ? this.parseData(response?.result) : {};

              return {
                address: item?.address,
                total: formatNearAmount(parsedResult?.total) || 0,
                available: formatNearAmount(parsedResult?.available) || 0,
              };
            } catch (e) {}
          },
          listData,
          batchLimit,
          callback,
        );

        return results.filter(Boolean);
      }
    } else {
      return [];
    }
  };

  getTransactionStatus = async ({
    library,
    txHash,
    account,
  }: {
    library: NearProvider;
    txHash: string[];
    account: string;
  }) => {
    const { network } = library.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    return Promise.all(txHash.map((hash) => provider.txStatus(hash, account)));
  };

  getTransactionStatusReceipts = async ({
    library,
    txHash,
    account,
  }: {
    library: NearProvider;
    txHash: string[];
    account: string;
  }) => {
    const { network } = library.options;

    return Promise.all(
      txHash.map((hash) =>
        axios.post(network.nodeUrl, {
          id: '',
          jsonrpc: '2.0',
          method: 'EXPERIMENTAL_tx_status',
          params: [hash, account],
        }),
      ),
    );
  };

  getStorageBalanceBounds = async ({
    library,
    data,
  }: {
    library: NearProvider;
    data: {
      tokenContract: string;
    };
  }): Promise<any> => {
    try {
      const { tokenContract } = data || {};

      const storageBalanceBoundsData = await this.readBlockchainData(library, tokenContract, 'storage_balance_bounds');
      const { min, max } = this.parseData(storageBalanceBoundsData?.result);

      return { min: formatNearAmount(min) || 0, max: formatNearAmount(max) || 0 };
    } catch (e) {
      return null;
    }
  };

  getAccountPaymentForServiceFee = async ({
    library,
    account,
  }: {
    library: NearProvider;
    account: string;
  }): Promise<any> => {
    try {
      const serviceFeeCountPromise = await this.readBlockchainData(
        library,
        getContractId(library),
        'get_account_quota',
        {
          account_id: account,
        },
      );
      const serviceFeeCount = this.parseData(serviceFeeCountPromise?.result);

      return serviceFeeCount;
    } catch (e) {
      return null;
    }
  };

  getServiceFee = async ({ library }: { library: NearProvider }): Promise<any> => {
    try {
      // const serviceFeePromise = await this.readBlockchainData(library, getContractId(library), 'service_fee');
      // const serviceFee = this.parseData(serviceFeePromise?.result);
      // const serviceFeeExchangeResponse = await axios.get(
      //  `${import.meta.env.VITE_COIN_GECKO_API}/price?ids=${['near']}&vs_currencies=usd`,
      // );

      return (
        formatNearAmount(
          convertPrice(
            divideNumber(
              convertToBigNumber(import.meta.env.VITE_SERVICE_FEE_USD_PER_ACCOUNT || 0),
              // serviceFeeExchangeResponse.data?.['near']?.usd,
              '1.29' // TEMP HACK
            ),
            NATIVE_TOKEN_DECIMAL_SCALE,
          ).toString(),
        ) || 0
      );
    } catch (e) {
      return null;
    }
  };

  getBalance = async ({
    library,
    account,
    data,
  }: {
    library: NearProvider;
    account: string;
    data?: { token: any };
  }): Promise<BigNumber> => {
    try {
      const { token } = data || {};
      let balance: BigNumber = convertToBigNumber(0);

      if (token) {
        //Fungible token amount
        const data = await this.readBlockchainData(library, token?.address, 'ft_balance_of', { account_id: account });
        const result = this.parseData(data?.result);

        balance = convertBalance(result, token?.decimals);
      } else {
        //NEAR Amount
        const data = await this.readBlockchainData(library, account, '', null, this.VIEW_ACCOUNT);
        const MIN_BALANCE_FOR_GAS = 0.05;
        const availableBalance = minusValue([
          formatNearAmount(data?.amount),
          MIN_BALANCE_FOR_GAS,
          data?.storage_usage / 100000,
        ]);
        balance = convertToBigNumber(greaterThan(0, availableBalance) ? 0 : availableBalance);
      }

      return balance;
    } catch (e) {
      throw e;
    }
  };

  sendNear = ({
    library,
    account,
    data,
  }: {
    library: NearProvider;
    account: string;
    data: { receivers: string[]; amount: string[]; totalAmount: string };
  }): Transaction => {
    const { receivers, amount, totalAmount } = data || {};

    return {
      signerId: account,
      receiverId: getContractId(library),
      actions: [
        {
          type: this.FUNCTION_CALL,
          params: {
            methodName: 'distribute_near',
            args: {
              receivers,
              amount,
            },
            gas: utils.format.parseNearAmount(this.MAX_GAS) as string,
            deposit: totalAmount,
          },
        },
      ],
    };
  };

  sendToken = ({
    library,
    account,
    data,
  }: {
    library: NearProvider;
    account: string;
    data: { msg: string; amount: number; tokenContract: string };
  }): Transaction => {
    const { msg, amount, tokenContract } = data || {};

    return {
      signerId: account,
      receiverId: tokenContract,
      actions: [
        {
          type: this.FUNCTION_CALL,
          params: {
            methodName: 'ft_transfer_call',
            args: {
              msg,
              amount: amount.toString(),
              receiver_id: getContractId(library),
            },
            gas: utils.format.parseNearAmount(this.MAX_GAS) as string,
            deposit: '1',
          },
        },
      ],
    };
  };

  payForServiceFee = ({
    library,
    data,
    account,
  }: {
    library: NearProvider;
    data: { serviceFee?: number; totalAccountPayingFor?: number };
    account: string;
  }): Transaction => {
    const { serviceFee = 0, totalAccountPayingFor = 0 } = data || {};

    const transaction = {
      signerId: account,
      receiverId: getContractId(library),
      actions: [
        {
          type: this.FUNCTION_CALL,
          params: {
            methodName: 'pay_service_fee',
            args: {
              estimated_fee:
                totalAccountPayingFor > 0
                  ? divideNumber(
                      convertToBigNumber(utils.format.parseNearAmount(convertToBigNumber(serviceFee).toString()) || 0),
                      convertToBigNumber(totalAccountPayingFor),
                    )
                  : 0,
            },
            gas: utils.format.parseNearAmount(this.MAX_GAS) as string,
            deposit: utils.format.parseNearAmount(convertToBigNumber(serviceFee).toString()) as string,
          },
        },
      ],
    };

    return transaction;
  };

  payForStorageFee = ({
    library,
    data,
    account,
  }: {
    library: NearProvider;
    data: { account_ids: string[]; tokenContract?: string; min_fee: number; totalFee: number };
    account: string;
  }): Transaction => {
    const { account_ids, tokenContract, min_fee, totalFee } = data || {};

    return {
      signerId: account,
      receiverId: getContractId(library),
      actions: [
        {
          type: this.FUNCTION_CALL,
          params: {
            methodName: 'batch_storage_deposit',
            args: {
              token_id: tokenContract,
              account_ids,
              min_fee: utils.format.parseNearAmount(convertToBigNumber(min_fee).toString()),
            },
            gas: utils.format.parseNearAmount(this.MAX_GAS) as string,
            deposit: utils.format.parseNearAmount(convertToBigNumber(totalFee).toString()) as string,
          },
        },
      ],
    };
  };
}
'''
'''--- src/services/WalletService/constants/index.ts ---
export const INIT_UNIT_128 = '0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF';
export const INIT_UNIT_256 = '0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF';

export const FORMAT_DECIMAL_SCALE = 8;
export const FORMAT_4_DECIMAL = 4;

export const BLOCKCHAIN_TRANSACTION_STATUS = {
  SUCCESS: 1,
};

declare type BlockHash = string;
declare type BlockHeight = number;

export type META_DATA = {
  address?: string;
  decimals?: number;
  icon?: string | null;
  name?: string;
  token?: string;
  reference?: string | null;
  reference_hash?: string | null;
  spec?: string;
  symbol?: string;
  block_height?: BlockHeight;
  block_hash?: BlockHash;
  value?: string;
};

export type META_DATA_RESPONSE = {
  result: Buffer;
  block_height: BlockHeight;
  block_hash: BlockHash;
};

'''
'''--- src/services/WalletService/type/index.d.ts ---
import { WalletSelector } from '@near-wallet-selector/core';

type AppProvider = WalletSelector;
type Extract<T extends AppProvider, A = AppProvider> = A extends T ? A : never;

export type NearProvider = AppProvider;

'''
'''--- src/services/WalletService/utils/index.ts ---
import { CHAIN_INFO } from 'connectors/constants';

export const getBlockExplorerLink = (chainId: number, txId: string) => {
  return `${CHAIN_INFO?.[chainId]?.url}/txns/${txId}`;
};

export const getBlockExplorerAccountLink = (chainId: number, account: string) => {
  return `${CHAIN_INFO?.[chainId]?.url}/address/${account}`;
};

export const getBlockExplorerName = (chainId: number) => {
  return CHAIN_INFO?.[chainId]?.explorerName;
};

export const isAddressEqual = (address1?: string | null, address2?: string | null) => {
  return !!address1 && !!address2 && address1?.toLowerCase() === address2?.toLocaleLowerCase();
};

export const convertBase64ToObj = (args: string): any => {
  if (!!args) {
    let base64ToString = Buffer.from(args, 'base64').toString();
    base64ToString = JSON.parse(base64ToString);

    return base64ToString;
  }
  return {};
};

'''
'''--- src/services/WalletService/utils/nearUtils.ts ---
import get from 'lodash/get';
import { utils } from 'near-api-js';

import { convertBase64ToObj } from '.';
import { NearProvider } from '../type';
import { dividedPrice } from './number';

export const getSendFtTokenParamsFromReceipt = (receipt: any, tokenInfo: any) => {
  const {
    msg = '',
    amount = 0,
    receiver_id = '',
  } = convertBase64ToObj(get(receipt, ['receipt', 'Action', 'actions', '0', 'FunctionCall', 'args'])) || {};

  return {
    address: receiver_id || msg?.split(':')?.[0] || '',
    amount: dividedPrice(amount, tokenInfo?.decimals).toString() || 0,
  };
};

export const formatNearAmount = (amount: string) => {
  return utils.format.formatNearAmount(amount).replace(/,/gi, '');
};

export const getSendNEARAmountFromReceipt = (receipt: any) => {
  const amount = formatNearAmount(get(receipt, ['receipt', 'Action', 'actions', '0', 'Transfer', 'deposit']) || 0);

  return amount;
};

export const getContractId = (library: NearProvider) => library.store.getState().contract?.contractId || '';

'''
'''--- src/services/WalletService/utils/number.ts ---
import BigNumber from 'bignumber.js';

BigNumber.config({
  EXPONENTIAL_AT: 100,
});

export const greaterThanOrEqualTo = (
  number1: string | number | null | undefined,
  number2: string | number | null | undefined,
) => {
  return new BigNumber(number1 || 0).isGreaterThanOrEqualTo(new BigNumber(number2 || 0));
};

export const greaterThan = (number1: string | number, number2: string | number) => {
  return new BigNumber(number1).isGreaterThan(new BigNumber(number2));
};

export const formatNumber = (value: string | number) => {
  return new BigNumber(value).toFormat();
};

export const convertToBigNumber = (value: BigNumber.Value) => {
  return new BigNumber(value);
};

export const convertToDecimal = (value: BigNumber.Value) => {
  return new BigNumber(value, 10).toString();
};

export const convertPrice = (value: BigNumber.Value, decimalScale: number | undefined): BigNumber => {
  return new BigNumber(value).multipliedBy(new BigNumber(Math.pow(10, decimalScale || 0)));
};

export const convertBalance = (value: BigNumber.Value, decimalScale: number | undefined): BigNumber => {
  return new BigNumber(value).multipliedBy(new BigNumber(Math.pow(10, -(decimalScale || 0))));
};

export const dividedPrice = (value: BigNumber.Value, decimalScale?: number): BigNumber => {
  return new BigNumber(value).dividedBy(new BigNumber(Math.pow(10, decimalScale || 0)));
};

export const ceilValue = (value: BigNumber.Value): string =>
  new BigNumber(value).integerValue(BigNumber.ROUND_CEIL).toString();

export const timesValue = (number1: BigNumber.Value, number2: BigNumber.Value): string =>
  new BigNumber(number1 || 0).times(number2 || 0).toString();

export const convertToNumber = (number: BigNumber.Value): number => new BigNumber(number).toNumber();

export const convertToCoinInput = (amount: BigNumber.Value, decimalScale: number): string => {
  const number = new BigNumber(amount ?? 0).div(new BigNumber(10).pow(decimalScale));
  return amount ? number.decimalPlaces(6, BigNumber.ROUND_DOWN).toString() : '0';
};

export const convertDecimal = (amount: BigNumber.Value, decimalScale: number): string => {
  return new BigNumber(amount).decimalPlaces(decimalScale, BigNumber.ROUND_DOWN).toString();
};

export const addValue = (value: any[]) => {
  return value
    .reduce((acc: BigNumber.Value, cur: BigNumber.Value) => {
      return new BigNumber(acc).plus(new BigNumber(cur));
    }, 0)
    .toString();
};

export const minusValue = (value: any[]) => {
  const excludedFirstValueArray = value.splice(1);

  return excludedFirstValueArray
    .reduce((acc: BigNumber.Value, cur: BigNumber.Value) => {
      return new BigNumber(acc).minus(new BigNumber(cur));
    }, value[0])
    .toString();
};

export const multiplyValue = (value: any[]) => {
  return value
    .reduce((acc: BigNumber.Value, cur: BigNumber.Value) => {
      return new BigNumber(acc).multipliedBy(new BigNumber(cur));
    }, 1)
    .toString();
};

export const calculatePercentage = (value: BigNumber.Value, total: BigNumber.Value) => {
  if (!value || !total) {
    return 0;
  }
  return new BigNumber(value).dividedBy(new BigNumber(total)).multipliedBy(100).decimalPlaces(18).toString();
};

export const divideNumber = (value: BigNumber.Value, value2: BigNumber.Value) => {
  return new BigNumber(value).dividedBy(new BigNumber(value2)).toString();
};
'''
'''--- src/services/api.ts ---
import { getI18n } from 'react-i18next';
import throttle from 'lodash/throttle';
import axios from 'axios';

import showMessage from 'components/Message';
import validate from 'utils/validate';
import TYPE_CONSTANTS from 'constants/type';
import HTTP_STATUS_CONTSTANTS from 'constants/httpStatus';

const typeOfMessage = TYPE_CONSTANTS.MESSAGE;

const HEADERS = {
  'Content-Type': 'application/json',
  Accept: 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept',
} as any;

const HEADERS_MULTIPLE_PART = {
  ...HEADERS,
  'Content-Type': 'multipart/form-data; boundary=something',
  Accept: 'application/json',
};

export const getToken = (token: any) => {
  HEADERS['Authorization'] = `Bearer ${token}`;
  HEADERS_MULTIPLE_PART['Authorization'] = `Bearer ${token}`;
};

const getFullUrl = (url: string) => {
  if (!url.startsWith('/')) {
    url = '/' + url;
  }
  return `${import.meta.env.VITE_API_URL}` + url;
};

const resetToLogin = () => {
  const promiseList = [];
  promiseList.push(localStorage.removeItem('persist:root'));
};

const throttledResetToLogin = throttle(resetToLogin, 500, {
  leading: false,
  trailing: true,
}) as any;

const checkErrorNetwork = (err: any) => {
  if (err?.toJSON() && err.toJSON().message === 'Network Error') {
    return showMessage(typeOfMessage.ERROR, getI18n().t(`message.E0`));
  }
  return err;
};

const checkErrorStatus = (response: any) => {
  if (response?.code === '1' || response?.data?.isVerified === false) {
    return response;
  }
  if (response?.meta?.errorCode) {
    // if (response?.meta?.errorCode !== 'E0') {
    //   showMessage(typeOfMessage.ERROR, `message.${response?.meta?.errorCode}`, response?.meta?.extraInfo);
    // } else {
    //   showMessage(typeOfMessage.ERROR, response?.meta?.message);
    // }
    // if (response?.meta?.errorCode === 'E0') {
    //   showMessage(typeOfMessage.ERROR, `message.E0`);
    // }
  }
  showMessage(typeOfMessage.ERROR, `message.E0`);
  return response;
};

const api = {
  post: (endpoint: string, params?: any) => {
    return axios
      .post(getFullUrl(endpoint), params, {
        headers: HEADERS,
        validateStatus: (status: any) => validate.validateStatus(status),
      })
      .then(
        (response: any) => {
          if (
            response?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401 ||
            response?.data?.meta?.extraInfo?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401
          ) {
            throttledResetToLogin(endpoint, params, response);
            return response?.data;
          }
          return checkErrorStatus(response.data);
        },
        (err: any) => {
          return (err?.response?.data && checkErrorStatus(err.response.data)) || checkErrorNetwork(err);
        },
      )
      .catch((response: any) => {
        return response.data;
      });
  },

  postMultiplePart: (endpoint: string, params?: any) => {
    return axios
      .post(getFullUrl(endpoint), params, {
        headers: HEADERS_MULTIPLE_PART,
        validateStatus: (status: any) => validate.validateStatus(status),
      })
      .then(
        (response: any) => {
          if (
            response?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401 ||
            response?.data?.meta?.extraInfo?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401
          ) {
            throttledResetToLogin(endpoint, params, response);
            return response?.data;
          }
          return checkErrorStatus(response.data);
        },
        (err: any) => {
          return (err?.response?.data && checkErrorStatus(err.response.data)) || checkErrorNetwork(err);
        },
      )
      .catch((response: any) => {
        return response.data;
      });
  },

  get: (endpoint: string, params: any = {}) => {
    return axios
      .get(getFullUrl(endpoint), {
        params: params,
        headers: HEADERS,
        validateStatus: (status: any) => validate.validateStatus(status),
      })
      .then(
        (response: any) => {
          if (
            response?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401 ||
            response?.data?.meta?.extraInfo?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401
          ) {
            throttledResetToLogin(endpoint, params, response);
            return checkErrorStatus(response?.data);
          }
          return checkErrorStatus(response?.data);
        },
        (err: any) => {
          return (err?.response?.data && checkErrorStatus(err.response.data)) || checkErrorNetwork(err);
        },
      )
      .catch((response: any) => {
        return response.data;
      });
  },

  put: (endpoint: string, params?: any) => {
    return axios
      .put(getFullUrl(endpoint), params, {
        headers: HEADERS,
        validateStatus: (status: any) => validate.validateStatus(status),
      })
      .then(
        (response: any) => {
          if (
            response?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401 ||
            response?.data?.meta?.extraInfo?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401
          ) {
            throttledResetToLogin(endpoint, params, response);
            return checkErrorStatus(response?.data);
          }
          return checkErrorStatus(response?.data);
        },
        (err: any) => {
          return (err?.response?.data && checkErrorStatus(err.response.data)) || checkErrorNetwork(err);
        },
      )
      .catch((response: any) => {
        return response.data;
      });
  },

  patch: (endpoint: string, params?: any) => {
    return axios
      .patch(getFullUrl(endpoint), params, {
        headers: HEADERS,
        validateStatus: (status: any) => validate.validateStatus(status),
      })
      .then(
        (response: any) => {
          if (
            response?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401 ||
            response?.data?.meta?.extraInfo?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401
          ) {
            throttledResetToLogin(endpoint, params, response);
            return checkErrorStatus(response?.data);
          }
          return checkErrorStatus(response?.data);
        },
        (err: any) => {
          return (err?.response?.data && checkErrorStatus(err.response.data)) || checkErrorNetwork(err);
        },
      )
      .catch((response: any) => {
        return response.data;
      });
  },

  delete: (endpoint: string, params: any) => {
    return axios
      .delete(getFullUrl(endpoint), {
        params: params,
        headers: HEADERS,
        validateStatus: (status: any) => validate.validateStatus(status),
      })
      .then(
        (response: any) => {
          if (
            response?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401 ||
            response?.data?.meta?.extraInfo?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401
          ) {
            throttledResetToLogin(endpoint, params, response);
            return response?.data;
          }
          return checkErrorStatus(response.data);
        },
        (err: any) => {
          return (err?.response?.data && checkErrorStatus(err.response.data)) || checkErrorNetwork(err);
        },
      )
      .catch((response: any) => {
        return response.data;
      });
  },
};

const apiCustom = {
  get: (endpoint: string, params: any = {}) => {
    return axios
      .get(endpoint, {
        params: params,
        headers: HEADERS,
        validateStatus: (status: any) => validate.validateStatus(status),
      })
      .then(
        (response: any) => {
          if (
            response?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401 ||
            response?.data?.meta?.extraInfo?.status === HTTP_STATUS_CONTSTANTS.ERROR_CODE_401
          ) {
            throttledResetToLogin(endpoint, params, response);
            return checkErrorStatus(response?.data);
          }
          return checkErrorStatus(response?.data);
        },
        (err: any) => {
          return (err?.response?.data && checkErrorStatus(err.response.data)) || checkErrorNetwork(err);
        },
      )
      .catch((response: any) => {
        return response.data;
      });
  },
};

export { api, apiCustom };

'''
'''--- src/services/listAddress.ts ---
import { api } from './api';

class ListAddressService {
  private GET_LIST_ADDRESS_URL = '/token-account';

  get getListAddressUrl() {
    return this.GET_LIST_ADDRESS_URL;
  }

  constructor() {}

  getListAddress = (address: string): any => {
    return api.get(`${this.getListAddressUrl}/${address}`);
  };

  createListAddress = (params: any): any => {
    return api.post(this.getListAddressUrl, params);
  };

  updateListAddress = (id: string, params: any): any => {
    return api.put(`${this.getListAddressUrl}/${id}`, params);
  };
}

const listAddressService = new ListAddressService();

export default listAddressService;

'''
'''--- src/services/navigationService.ts ---
class NavigationService {
  private _navigation: any;

  constructor() {
    this._navigation = null;
  }

  set navigation(nav) {
    this._navigation = nav;
  }

  get navigation() {
    return this._navigation;
  }
}

const navigationService = new NavigationService();

export default navigationService;

'''
'''--- src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''
'''--- src/store/address/saga.ts ---
import { setAppNetwork } from 'store/address/slice';
import { put, takeLatest } from 'redux-saga/effects';
import { logout, logoutSuccess } from './slice';
import { handleClearConnectedWalletType } from 'store/connection/slice';

function* logoutSaga() {
  yield put(logoutSuccess());
  yield put(handleClearConnectedWalletType());
  yield put(setAppNetwork(undefined));
}

export function* watchAddress() {
  yield takeLatest(logout, logoutSaga);
}

'''
'''--- src/store/address/selector.ts ---
const selectedAddress = {
  getAddress: (state: any) => state?.AddressSlice,
};

export default selectedAddress;

'''
'''--- src/store/address/slice.ts ---
import { createSlice } from '@reduxjs/toolkit';
import { CHAIN_ID } from 'connectors/constants';
import { ChainFactory } from 'utils/chains/ChainFactory';

export interface Address {
  address: string;
  chainId: string | null;
  tokenInfo: any;
  network: string | undefined;
}

const initialState: Address = {
  address: '',
  chainId: import.meta.env.DEV ? CHAIN_ID.NEAR_TEST : CHAIN_ID.NEAR,
  tokenInfo: null,
  network: undefined,
};

export const AddressSlice = createSlice({
  name: 'address',
  initialState,
  reducers: {
    loginStart: (state: Address, action: any) => {
      const { address } = action.payload;
      return {
        ...state,
        address,
      };
    },
    setAppNetwork: (state: Address, action: any) => ({
      ...state,
      network: action.payload,
    }),
    setAppChainId: (state: Address, action: any) => {
      const networkType = new ChainFactory().getChain(action.payload?.toString())?.getNetworkType();

      return {
        ...state,
        chainId: action.payload?.toString(),
        network: networkType,
      };
    },
    setAppAddress: (state: Address, action: any) => ({
      ...state,
      address: action.payload,
    }),
    setAppToken: (state: Address, action: any) => ({
      ...state,
      tokenInfo: action.payload,
    }),
    logout: (state: Address) => ({
      ...state,
    }),
    logoutSuccess: (state: Address) => ({
      ...state,
      address: '',
    }),
  },
});

export const { loginStart, logout, logoutSuccess, setAppToken, setAppChainId, setAppAddress, setAppNetwork } =
  AddressSlice.actions;

export const namespace = 'AddressSlice';

export default AddressSlice.reducer;

'''
'''--- src/store/balance/selector.ts ---
import isEmpty from 'lodash/isEmpty';
import { ChainFactory } from 'utils/chains/ChainFactory';

const selectBalance = {
  getBalance: (token?: string) => (state: any) => {
    if (isEmpty(state?.BalanceSlice?.balance)) {
      return null;
    }

    const { chainId, tokenInfo } = state?.AddressSlice;
    const chainInstance = new ChainFactory()?.getChain(chainId);

    return chainInstance?.getBalance(state?.BalanceSlice?.balance, chainId, token ? token : tokenInfo) || 0;
  },
};

export default selectBalance;

'''
'''--- src/store/balance/slice.ts ---
import { createSlice } from '@reduxjs/toolkit';

export interface State {
  balance: any;
}

const initialState: State = {
  balance: {},
};

export const BalanceSlice = createSlice({
  name: 'balance',
  initialState,
  reducers: {
    setBalance: (state: State, action: any) => {
      const { chainId, token, amount } = action.payload || {};

      return {
        ...state,
        balance: {
          ...state.balance,
          [chainId]: {
            ...state.balance[chainId],
            [token]: amount,
          },
        },
      };
    },
    clearBalance: (state: State) => {
      return {
        ...state,
        balance: {},
      };
    },
  },
});

export const { setBalance, clearBalance } = BalanceSlice.actions;

export const namespace = 'BalanceSlice';

export default BalanceSlice.reducer;

'''
'''--- src/store/configStore.ts ---
import { configureStore, getDefaultMiddleware } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';
import createSagaMiddleware from 'redux-saga';

import rootReducer from './rootReducer';
import rootSaga from './rootSaga';

import { namespace as AddressNamespace } from './address/slice';
import { namespace as ConnectionNamespace } from './connection/slice';
import { namespace as SendTokenNamespace } from './sendToken/slice';

const persistConfig = {
  key: 'root',
  storage: storage,
  whitelist: [AddressNamespace, ConnectionNamespace, SendTokenNamespace],
  blacklist: [],
};

const root = persistReducer(persistConfig, rootReducer);
export const sagaMiddleware = createSagaMiddleware();

export const store = configureStore({
  reducer: root,
  middleware: [
    ...getDefaultMiddleware({
      thunk: false,
      serializableCheck: false,
    }),
    sagaMiddleware,
  ],
  devTools: import.meta.env.DEV,
});

sagaMiddleware.run(rootSaga);

export const persistor = persistStore(store, {});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof store.getState>;
// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = typeof store.dispatch;

'''
'''--- src/store/connection/selector.ts ---
import { Connection } from './slice';

const selectedConnection = {
  getConnection: (state: any) => state?.ConnectionSlice as Connection,
  getConnectedWalletType: (state: any) => state?.ConnectionSlice?.connectedWalletType,
  getConnectedWalletTypeByNetwork: (state: any) =>
    state?.ConnectionSlice?.connectedWalletType?.[state?.AddressSlice?.network],
};

export default selectedConnection;

'''
'''--- src/store/connection/slice.ts ---
import { createSlice } from '@reduxjs/toolkit';

export interface Connection {
  isConnectingWallet: boolean;
  isWrongNetwork: boolean;
  connectedWalletType: any;
}

const initialState: Connection = {
  isConnectingWallet: false,
  isWrongNetwork: false,
  connectedWalletType: '',
};

export const ConnectionSlice = createSlice({
  name: 'connection',
  initialState,
  reducers: {
    handleSetLoadingMetamask: (state: Connection, action: any) => {
      return {
        ...state,
        isConnectingWallet: action.payload,
      };
    },
    handleSetWrongNetwork: (state: Connection, action: any) => {
      return {
        ...state,
        isWrongNetwork: action.payload,
      };
    },
    handleSetConnectedWalletType: (state: Connection, action: any) => {
      return {
        ...state,
        connectedWalletType: {
          ...state.connectedWalletType,
          ...action.payload,
        },
      };
    },
    handleClearConnectedWalletType: (state: Connection) => {
      return {
        ...state,
        connectedWalletType: {},
      };
    },
  },
});

export const {
  handleSetWrongNetwork,
  handleSetLoadingMetamask,
  handleSetConnectedWalletType,
  handleClearConnectedWalletType,
} = ConnectionSlice.actions;

export const namespace = 'ConnectionSlice';

export default ConnectionSlice.reducer;

'''
'''--- src/store/global/selector.ts ---
const selectGlobalState = {
  getAppLoading: (state: any) => state?.GlobalSlice?.appLoading,
  getLoadingTransactions: (state: any) => state?.GlobalSlice?.loadingTransactions,
  getIsOpeningMultipleTabs: (state: any) => state?.GlobalSlice?.isOpeningMultipleTabs,
  getIsCurrentScreenHasReport: (state: any) => state?.GlobalSlice?.hasReport,
  getQueryParams: (state: any) => state?.GlobalSlice?.queryParams,
};

export default selectGlobalState;

'''
'''--- src/store/global/slice.ts ---
import { createSlice } from '@reduxjs/toolkit';

export interface State {
  appLoading: boolean;
  loadingTransactions: boolean;
  isOpeningMultipleTabs: boolean;
  hasReport: boolean;
  queryParams: any;
}

const initialState: State = {
  appLoading: false,
  loadingTransactions: false,
  isOpeningMultipleTabs: false,
  hasReport: false,
  queryParams: null,
};

export const GlobalSlice = createSlice({
  name: 'global',
  initialState,
  reducers: {
    setAppLoading: (state: State, action: any) => {
      return {
        ...state,
        appLoading: action.payload,
      };
    },
    setLoadingTransactions: (state: State, action: any) => {
      return {
        ...state,
        loadingTransactions: action.payload,
      };
    },
    setIsOpeningMultipleTabs: (state: State, action: any) => {
      return {
        ...state,
        isOpeningMultipleTabs: action.payload,
      };
    },
    setHasReport: (state: State, action: any) => {
      return {
        ...state,
        hasReport: action.payload,
      };
    },
    setQueryParams: (state: State, action: any) => {
      return {
        ...state,
        queryParams: action.payload,
      };
    },
  },
});

export const { setAppLoading, setLoadingTransactions, setIsOpeningMultipleTabs, setHasReport, setQueryParams } =
  GlobalSlice.actions;

export const namespace = 'GlobalSlice';

export default GlobalSlice.reducer;

'''
'''--- src/store/language/selector.ts ---
const selectLanguage = (state: any) => state?.LanguageSlice?.lang;

export default selectLanguage;

'''
'''--- src/store/language/slice.ts ---
import { createSlice } from '@reduxjs/toolkit';
import { LANGUAGE } from 'constants/index';

export interface Language {
  lang: string;
}

const initialState: Language = {
  lang: LANGUAGE.EN,
};

export const LanguageSlice = createSlice({
  name: 'language',
  initialState,
  reducers: {
    setLanguage: (state: Language, action) => ({
      ...state,
      lang: action.payload,
    }),
  },
});

export const { setLanguage } = LanguageSlice.actions;

export const namespace = 'LanguageSlice';

export default LanguageSlice.reducer;

'''
'''--- src/store/rootReducer.ts ---
import { combineReducers } from 'redux';

import AddressSlice, { namespace as AddressNamespace } from './address/slice';
import ConnectionSlice, { namespace as ConnectionNamespace } from './connection/slice';
import BalanceListSlice, { namespace as BalanceListNamespace } from './balance/slice';
import LanguageSlice, { namespace as LanguageNamespace } from './language/slice';
import GlobalSlice, { namespace as GlobalNamespace } from './global/slice';
import SendTokenSlice, { namespace as SendTokenNamespace } from './sendToken/slice';

export default combineReducers({
  [AddressNamespace]: AddressSlice,
  [ConnectionNamespace]: ConnectionSlice,
  [BalanceListNamespace]: BalanceListSlice,
  [LanguageNamespace]: LanguageSlice,
  [GlobalNamespace]: GlobalSlice,
  [SendTokenNamespace]: SendTokenSlice,
});

'''
'''--- src/store/rootSaga.ts ---
import { all } from 'redux-saga/effects';
import { watchAddress } from './address/saga';

function* rootSaga() {
  yield all([watchAddress()]);
}
export default rootSaga;

'''
'''--- src/utils/chains/Chain.ts ---
export class Chain {
  constructor() {}

  getInstance<T>(): T | null {
    return null;
  }

  removeInstance() {}

  getBalance(
    balance: Record<string | number, Record<string, number>>,
    chainId: string | number,
    token: string,
  ): string | number {
    return balance?.[chainId]?.[token];
  }

  getService(): any {
    return null;
  }

  getUtils(): any {
    return null;
  }
}

'''
'''--- src/utils/chains/ChainFactory.ts ---
import { CHAIN_ID, SUPPORTED_NETWORK } from 'connectors/constants';
import { NearChain } from './NearChain';

export class ChainFactory {
  constructor() {}

  getChain(chainId: number | string) {
    if (!chainId) {
      return null;
    }

    switch (chainId) {
      case CHAIN_ID.NEAR:
      case CHAIN_ID.NEAR_TEST:
        return new NearChain().getInstance() as NearChain;
      default:
        return null;
    }
  }

  getNetwork(network: string) {
    if (!network) {
      return null;
    }

    switch (network) {
      case SUPPORTED_NETWORK.NEAR: {
        return new NearChain().getInstance() as NearChain;
      }
      default:
        return null;
    }
  }
}

'''
'''--- src/utils/chains/NearChain.ts ---
import { SUPPORTED_CHAIN_IDS } from '../../connectors/constants';
import { SUPPORTED_NETWORK } from 'connectors/constants';
import NearChainService from 'services/WalletService/NearChainService';
import { Chain } from './Chain';
import { NearUtils } from './utils/NearUtils';

let nearInstance: any = null;

export class NearChain extends Chain {
  constructor() {
    super();
  }

  getInstance<NearChain>(): NearChain | null {
    if (nearInstance == null) {
      nearInstance = new NearChain();
      nearInstance.constructor = () => {};
    }
    return nearInstance as NearChain;
  }

  removeInstance() {
    nearInstance = null;
  }

  getNetworkType() {
    return SUPPORTED_NETWORK.NEAR;
  }

  getDefaultSupportNetwork() {
    return SUPPORTED_CHAIN_IDS[0];
  }

  getService() {
    return new NearChainService().getInstance() as NearChainService;
  }

  getUtils() {
    return new NearUtils().getInstance() as NearUtils;
  }
}

'''
'''--- src/utils/chains/utils/ChainUtils.ts ---
export class ChainUtils {
  constructor() {}

  convertAddressToDisplayValue(address: string, lengthBeforeSlice?: number): string {
    return '';
  }
}

'''
'''--- src/utils/chains/utils/NearUtils.ts ---
import { ChainUtils } from './ChainUtils';

let nearInstance: any = null;

export class NearUtils extends ChainUtils {
  constructor() {
    super();
  }

  getInstance<NearChain>(): NearChain | null {
    if (nearInstance == null) {
      nearInstance = new NearUtils();
      nearInstance.constructor = () => {};
    }
    return nearInstance as NearChain;
  }

  removeInstance() {
    nearInstance = null;
  }

  convertAddressToDisplayValue(address: string, lengthBeforeSlice = 3): string {
    if (!address) {
      return '';
    }

    const [beforeDot, afterDot] = address.split('.');

    if (beforeDot?.length < lengthBeforeSlice + 4) {
      return address;
    }

    return address
      ? afterDot
        ? [
            beforeDot.slice(0, lengthBeforeSlice) + '...' + beforeDot.slice(beforeDot.length - 3, beforeDot.length),
            afterDot,
          ].join('.')
        : beforeDot.slice(0, 6) + '...' + beforeDot.slice(beforeDot.length - 4, beforeDot.length)
      : '';
  }
}

'''
'''--- src/utils/date.ts ---
import TIME_CONSTANTS from 'constants/time';
import moment from 'moment';

export const formatDateRequest = (value: number, format?: string) => {
  if (!value) return null;

  return moment(value).format(format || TIME_CONSTANTS.TIME_FORMAT.DATE_TIME);
};

'''
'''--- src/utils/index.ts ---
import { CHAIN_INFO } from 'connectors/constants';
import TYPE_CONSTANTS from 'constants/type';

export const isExternalLink = (link?: string) => {
  return !!(link?.includes('http') || link?.includes('https'));
};

export const getParamSort = (sorter: any) => {
  const { order, field: sortField } = sorter;
  const sortType = order && order === 'descend' ? TYPE_CONSTANTS.SORT_FORMAT.DESC : TYPE_CONSTANTS.SORT_FORMAT.ASC;

  const sortParams: {
    sortField?: string;
    sortType?: number;
  } = {
    sortField,
    sortType,
  };

  if (!order) {
    delete sortParams.sortField;
    delete sortParams.sortType;
  }

  return sortParams;
};

export const getNetWorkByChainId = (chainId: number | string | null, listToken: any[] = []) => {
  if (!chainId) return {};

  return listToken?.find((item) => item?.chainId === chainId);
};

export const getNetWorkByChainName = (name: string | null, listToken: any[] = []) => {
  if (!name) return {};

  return listToken.find((item) => item?.name === name);
};

export const getTokenInfoByChainId = (configToken: any, chainId: string, token: string): any => {
  return Object.values(configToken?.[chainId])?.find(({ token: currentToken }: any) => currentToken === token) || {};
};

export const delay = (ms: number) => new Promise((res) => setTimeout(res, ms));

export const convertToListNetworkName = (listChainId: (string | number)[], delimiter: string) => {
  return listChainId.map((chainId: string | number) => CHAIN_INFO[chainId]?.name).join(delimiter);
};

'''
'''--- src/utils/string.ts ---
export const trimSpace = (str: string) => {
  if (!str) return { resultString: '', count: 0 };
  const strArr = str
    .replaceAll('"', '')
    .split('\n')
    .filter((item) => item !== '');

  const result = strArr
    .map((line) => {
      return line.replaceAll(/[ ]*[\,][ ]*/g, ',').trim();
    })
    .join('\n');
  return { resultString: result, count: strArr.length };
};

export const trimSpaceStartEnd = (str: string) => {
  if (!str) return { count: 0, str };
  const strArr = str
    .replaceAll('"', '')
    .split('\n')
    .filter((item) => item !== '');
  const count = strArr.length;

  const newStr = strArr.map((line) => line.trim()).join('\n');
  return { count, newStr };
};

'''
'''--- src/utils/validate.ts ---
const validate = {
  passwordStrength(pw: string): number {
    return (
      (/.{8,}/.test(pw) ? 1 : 0) /* at least 8 characters */ *
      ((/[a-z]/.test(pw) ? 1 : 0) /* a lower letter */ +
        (/[A-Z]/.test(pw) ? 1 : 0) /* a upper letter */ +
        (/\d/.test(pw) ? 1 : 0) /* a digit */ +
        (/[^A-Za-z0-9]/.test(pw) ? 1 : 0)) /* a special character */
    );
  },
  validateStatus(status: number): boolean {
    return status === 200 || status === 201 || status === 400 || status === 401 || status === 500;
  },
};

export default validate;

'''
'''--- src/vite-env.d.ts ---
/// <reference types="vite/client" />

interface ImportMetaEnv {
  //API endpoint of Nearsend Application
  readonly VITE_API_URL: string;
  //Contract address of Nearsend Contract on NEAR Testnet
  readonly VITE_CONTRACT_ID_TESTNET: string;
  //Contract address of Nearsend Contract on NEAR Mainnet
  readonly VITE_CONTRACT_ID_MAINNET: string;
  //API endpoint to get list all tokens belong to current user on NEAR Testnet
  readonly VITE_NEAR_WALLET_URL_TESTNET: string;
  //API endpoint to get list all tokens belong to current user on NEAR Mainnet
  readonly VITE_NEAR_WALLET_URL_MAINNET: string;
  //NEAR RPC endpoint on NEAR Testnet to get old data on NEAR Blockchain
  readonly VITE_ARCHIVAL_NETWORK_URL_RPC_TESTNET: string;
  //NEAR RPC endpoint on NEAR Mainnet to get old data on NEAR Blockchain
  readonly VITE_ARCHIVAL_NETWORK_URL_RPC_MAINNET: string;
  //GraphQL endpoint of Nearblocks.io Testnet
  readonly VITE_NEARBLOCKS_GRAPHQL_URL_TESTNET: string;
  //GraphQL endpoint of Nearblocks.io Mainnet
  readonly VITE_NEARBLOCKS_GRAPHQL_URL_MAINNET: string;
  //Coin Gecko API to get Near exchange rate
  readonly VITE_COIN_GECKO_API: string;
  //Service fee USD rate per account (rate is based on 1 USD for example 0.1 = 10 cents)
  readonly VITE_SERVICE_FEE_USD_PER_ACCOUNT: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
'''
'''--- tools/localization/LocalizationGenerator.js ---
const fs = require('fs');
const readline = require('readline');
const async = require('async');
const path = require('path');
const { google } = require('googleapis');
const log4js = require('log4js');
const logger = new log4js.getLogger();
logger.level = 'debug';

// If modifying these scopes, delete token.json.
const SCOPES = ['https://www.googleapis.com/auth/spreadsheets.readonly'];
// The file token.json stores the user's access and refresh tokens, and is
// created automatically when the authorization flow completes for the first
// time.
// make generator-localization-gc
// window:  mingw32-make generator-localization-ekyc
const TOKEN_PATH = path.resolve(__dirname, 'token.json');
const CREDENTIALS_PATH = path.resolve(__dirname, 'credentials.json');
let OUTPUT_LANG_INDEX;
let SPREADSHEET_ID;
let GID_ID;
let OUTPUT_FOLDER;
let PLATFORM;
process.argv.forEach((val, index, array) => {
  const value = val.split('=');
  if (value[0] === 'OUTPUT_LANG_INDEX') {
    OUTPUT_LANG_INDEX = value[1];
  }
  if (value[0] === 'SPREADSHEET_ID') {
    SPREADSHEET_ID = value[1];
  }
  if (value[0] === 'GID_ID') {
    GID_ID = value[1];
  }
  if (value[0] === 'OUTPUT_FOLDER') {
    OUTPUT_FOLDER = value[1];
  }
  if (value[0] === 'PLATFORM') {
    PLATFORM = value[1];
  }
});
// Load client secrets from a local file.
fs.readFile(CREDENTIALS_PATH, (err, content) => {
  if (err) return logger.error(`Error loading client secret file: ${err}`);
  // Authorize a client with credentials, then call the Google Sheets API.
  authorize(JSON.parse(content), listMajors);
});

/**
 * Create an OAuth2 client with the given credentials, and then execute the
 * given callback function.
 * @param {Object} credentials The authorization client credentials.
 * @param {function} callback The callback to call with the authorized client.
 */
function authorize(credentials, callback) {
  const { client_secret, client_id, redirect_uris } = credentials.installed;
  const oAuth2Client = new google.auth.OAuth2(client_id, client_secret, redirect_uris[0]);

  // Check if we have previously stored a token.
  fs.readFile(TOKEN_PATH, (err, token) => {
    if (err) return getNewToken(oAuth2Client, callback);
    oAuth2Client.setCredentials(JSON.parse(token));
    callback(oAuth2Client);
  });
}

/**
 * Get and store new token after prompting for user authorization, and then
 * execute the given callback with the authorized OAuth2 client.
 * @param {google.auth.OAuth2} oAuth2Client The OAuth2 client to get token for.
 * @param {getEventsCallback} callback The callback for the authorized client.
 */
function getNewToken(oAuth2Client, callback) {
  const authUrl = oAuth2Client.generateAuthUrl({
    access_type: 'offline',
    scope: SCOPES,
  });
  logger.info(`Authorize this app by visiting this url: ${authUrl}`);
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  rl.question('Enter the code from that page here: ', (code) => {
    rl.close();
    oAuth2Client.getToken(code, (err, token) => {
      if (err) return logger.error(`Error while trying to retrieve access token: ${err}`);
      oAuth2Client.setCredentials(token);
      // Store the token to disk for later program executions
      fs.writeFile(TOKEN_PATH, JSON.stringify(token), (err) => {
        if (err) return logger.error(err);
        logger.info(`Token stored to: ${TOKEN_PATH}`);
      });
      callback(oAuth2Client);
    });
  });
}

/**
 * Prints the names and majors of students in a sample spreadsheet:
 * @see https://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/edit
 * @param {google.auth.OAuth2} auth The authenticated Google OAuth client.
 */
function listMajors(auth) {
  if (!OUTPUT_LANG_INDEX || !SPREADSHEET_ID || !OUTPUT_FOLDER) {
    logger.error('=======================================================');
    logger.error('Input parameter is not enough!');
    logger.error('=======================================================');

    return;
  }

  let rangeSheet = 'A2:H';
  if (GID_ID) {
    rangeSheet = `${GID_ID}!A2:H`;
  }

  const sheets = google.sheets({ version: 'v4', auth });

  async.waterfall(
    [
      (next) => {
        sheets.spreadsheets.values.get(
          {
            spreadsheetId: SPREADSHEET_ID,
            range: rangeSheet,
          },
          (err, res) => {
            if (err) return logger.error(`The API returned an error: ${err}`);
            const rows = res.data.values;
            if (rows.length) {
              let obj = {};
              let groupBefore = rows[0][0];
              let subGroupBefore = rows[0][1];
              rows.map((row, index) => {
                if (row[0]) {
                  groupBefore = row[0];
                }
                if (row[1]) {
                  subGroupBefore = row[1];
                }

                let groupKey = groupBefore;
                let subGroupKey = subGroupBefore;

                let groups = obj[groupKey];
                if (!groups) {
                  groups = {};
                }

                let key = `${row[2]}`;
                let value = `${row[OUTPUT_LANG_INDEX]}`;
                if (subGroupKey === 'EMPTY') {
                  groups[key] = value;
                } else {
                  let subGroups = groups[subGroupKey];
                  if (!subGroups) {
                    subGroups = {};
                  }
                  subGroups[key] = value;
                  groups[subGroupKey] = subGroups;
                }
                obj[groupKey] = groups;
              });
              return next(null, JSON.stringify(obj, null, 2));
            } else {
              logger.info('No data found.');
            }
          }
        );
      },
      (res, next) => {
        fs.writeFile(OUTPUT_FOLDER, res, next);
      },
    ],
    (err, res) => {
      if (err) {
        logger.error(err);
      }
      logger.info('Generate localization file successful.');
    }
  );
}

'''
'''--- tools/localization/credentials.json ---
{
  "installed": {
    "client_id": "369891029452-71k2b2q8j6ceb97e0oi4its76sibeqlv.apps.googleusercontent.com",
    "project_id": "quickstart-1569473037015",
    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
    "token_uri": "https://oauth2.googleapis.com/token",
    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
    "client_secret": "LivzX9dLGQzUEC3v35CGLma8",
    "redirect_uris": ["urn:ietf:wg:oauth:2.0:oob", "http://localhost"]
  }
}

'''
'''--- tools/package.json ---
{
  "name": "one-card-frontend-tools",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "dependencies": {
    "async": "3.1.0",
    "googleapis": "45.0.0",
    "lodash": "^4.17.20",
    "log4js": "6.1.0"
  },
  "devDependencies": {},
  "scripts": {
    "test": "mocha"
  },
  "author": "",
  "license": "ISC"
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "baseUrl": "src",
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": true,
    "skipLibCheck": false,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "noFallthroughCasesInSwitch": true,
    "useDefineForClassFields": true
  },
  "include": ["src", "types"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

'''
'''--- tsconfig.node.json ---
{
  "compilerOptions": {
    "composite": true,
    "module": "esnext",
    "moduleResolution": "node"
  },
  "include": ["vite.config.ts"]
}

'''
'''--- types/fixes.d.ts ---
// Fixes TS2694
declare global {
  namespace React {
    /** Fixes React 18 compatibility issues with formik: https://github.com/jaredpalmer/formik/issues/3546#issuecomment-1127014775 */
    type StatelessComponent<P> = React.FunctionComponent<P>;
  }

  interface TreeProps {
    icon: any;
  }
}

// Fixes TS2669
export {};

'''
'''--- vite.config.ts ---
// @ts-nocheck
import { esbuildCommonjs, viteCommonjs } from '@originjs/vite-plugin-commonjs';
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import * as path from 'path';
import { dependencies } from './package.json';

const renderChunks = (deps: Record<string, string>) => {
  const chunks: any = {};
  Object.keys(deps).forEach((key) => {
    if (['react', 'react-router-dom', 'react-dom', 'stream-browserify'].includes(key)) return;
    chunks[key] = [key];
  });
  return chunks;
};

// https://vitejs.dev/config/
export default defineConfig({
  exclude: ['@near-wallet-selector/nightly-connect', '@solana/wallet-adapter-base'],
  include: ['@near-wallet-selector/nightly-connect', 'bn.js'],
  esbuildOptions: {
    target: 'es2020',
    plugins: [esbuildCommonjs(['react-flagpack'])],
  },
  resolve: {
    alias: {
      store: path.resolve('./src/store'),
      constants: path.resolve('./src/constants'),
      components: path.resolve('./src/components'),
      hooks: path.resolve('./src/hooks'),
      pages: path.resolve('./src/pages'),
      resources: path.resolve('./src/resources'),
      services: path.resolve('./src/services'),
      utils: path.resolve('./src/utils'),
      connectors: path.resolve('./src/connectors'),
      language: path.resolve('./src/language'),
      hoc: path.resolve('./src/hoc'),
      context: path.resolve('./src/context'),

      process: 'process/browser',
      'readable-stream': 'vite-compatible-readable-stream',
      zlib: 'browserify-zlib',
      util: 'util',
      pino: 'pino',
    },
  },
  plugins: [react(), viteCommonjs()],
  build: {
    manifest: true,
    sourcemap: false,
    outDir: path.join(__dirname, 'dist'),
    target: 'es2020',
    rollupOptions: {
      // output: {
      //   manualChunks: {
      //     vendor: ['react', 'react-router-dom', 'react-dom', 'stream-browserify'],
      //     ...renderChunks(dependencies),
      //   },
      // },
    },
    commonjsOptions: {
      transformMixedEsModules: true,
    },
  },
});

'''