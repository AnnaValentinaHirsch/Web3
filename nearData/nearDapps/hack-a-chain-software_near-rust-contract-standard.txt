*GitHub Repository "hack-a-chain-software/near-rust-contract-standard"*

'''--- readme.md ---
# Code architecture and organization standard for NEAR protocol rust smart contract

### Goals

The goal of this specification is to enforce best practices on designing rust smart contracts for the NEAR protocol for the Hack-a-Chain team and for anyone that aims to build high quality easy to maintain and upgradable smart contract code. 

### Architecture

The architecture of the contract can be found inside the sample_contract folder.  
This spec is not concerned with your entire repo organization and architecture, just with the code that lives inside each rust crate.  
  
The main feature of this architecture is to fully separate the contract logic inside of a Contract struct and its internal method implementations from the blockchain accessible functions, which are implemented inside the actions module.  
  
### Explanation
  
The explanation of the entire architecture can be explored inside the md files in the sample_contract folder. The readme.md in sample_contract explains the overall visualization and architecture goals.  
  
Further md files specific the choices made inside of each rust module that composes the application.

### Contributions
  
Contributions are open to anyone that wants to help to improve the quality of rust smart contracts written for the NEAR protocol. Please raise github issues or post comments for errors and new ideas that you find!
'''
'''--- sample_contract/Cargo.toml ---
[package]
name = "sample_contractmodified-contract-standards"
version = "1.0.0"
authors = ["jack-the-dev <joao@hackachain.io>"]
edition = "2018"
categories = ["wasm"]
description = """
Sample smart contract for the purpose of showing the ideal code organization
in a rust smart contract project on the NEAR protocol.
"""

[profile.release]
codegen-units = 1
# s = optimize for binary size ("z" would additionally turn off loop vectorization)
opt-level = "z"
# link time optimization
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "3.1.0" 
serde = "1"
serde_json = "1"
'''
'''--- sample_contract/readme.md ---
# Standard specification and main concepts

### NEAR protocol smart contract overview
  
Smart contracts in the NEAR protocol are built using a struct with the attribute macro #[near_bindgen] in its definition.  
The public methods of the smart contract (methods that can be called through a blockchain transaction) have to be implemented inside impl sections of the Struct that was decorated with #[near_bindgen]. This impl sections must also use the #[near_bindgen] macro.
  
Example:
  
 ```
 #[near_bindgen]
 #[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
 struct Contract {
 	pub owner: AccountId,
    pub data: u128
 }
 
 /// this methods cannot be called through a blockchain transaction
 impl Contract {
 	pub fn change_data(&mut self, new_data: u128) {
    	self.data = new_data;
    }
 }
 
 /// this methods can be called through blockchain transactions
 #[near_bindgen]
 impl Contract {
 	pub fn blockchain_public_change_data(&mut self, new_data: U128) {
    	self.change_data(new_data.0);
    }
 }
 ```
 
### Code organization
   
Considering this property of NEAR contracts, the code should be organized in a way that allows us to differentiate between the internal logic of the contract and the blockchain calling logic.  

For that to happen we must separate the code in 2 parts: Logic and Actions:

#### Logic
Logic refers to everything in the contract's data structure and all its internal functions, which means: 
(1) the Contract struct and all its methods that are not exposed in the blockchain (lib.rs);
(2) all intenal data structures (enums and structs) and all its methods (each data structure must be created in a separate file);
(3) all interfaces for external contract calls (ext_interface.rs);
(4) documentation of all error messages (errors.rs)
  
### Actions
Actions refers to all functions of the Contract struct that can be called through blockchain transactions.  
We must separate actions per type of user, some actions are meant to be called by any user, some are meant to be called just by the owner and some are meant to be called by the contract itself.  
Depending on the application, there might by many different user categorizations, for better code organization, we must divide the actions in different files, according to the user type that is meant to call them.  
'''
'''--- sample_contract/src/actions/callback_actions.rs ---
/// This file defines callbacks that are performed by the contract to itself
/// More documentation on this process can be found at: https://www.near-sdk.io/cross-contract/callbacks
/// All actions should only handle arguments and call internal functions
/// Actions include both change and view functions
use crate::*;

#[allow(dead_code)]
#[near_bindgen]
impl Contract {
    #[private]
    pub fn callback_function(&mut self, #[callback] val: bool, account: AccountId) {
        if val {
            if let Some(mut old_struct) = self.data_structure_map.get(&account) {
                old_struct.change_data(123);
                self.data_structure_map.insert(&account, &old_struct);
            } else {
                self.data_structure_map.insert(&account, &PersonalizedStruct::new(321, env::signer_account_id()));
            }
        }
    }
}
'''
'''--- sample_contract/src/actions/guardian_actions.rs ---
/// This file defines all functions meant to be called be user of type owner
/// All actions should only handle arguments, perform user validations and call internal functions
/// Actions include both change and view functions
use crate::*;
use near_sdk::utils::{assert_one_yocto};

#[allow(dead_code)]
#[near_bindgen]
impl Contract {
    #[payable]
    pub fn renounce_guardian_privilege(&mut self) {
        self.only_guardians_or_owner();
        assert_one_yocto();
        self.internal_renounce_guardianship(env::predecessor_account_id());
    }  
}
'''
'''--- sample_contract/src/actions/mod.rs ---
/// This file only imports the submodules, no need to define anything in here

pub mod guardian_actions;
pub mod owner_actions;
pub mod user_actions;
pub mod callback_actions;
'''
'''--- sample_contract/src/actions/owner_actions.rs ---
/// This file defines all functions meant to be called be user of type owner
/// All actions should only handle arguments, perform user validations and call internal functions
/// Actions include both change and view functions
use crate::*;
use near_sdk::utils::{assert_one_yocto};

#[allow(dead_code)]
#[near_bindgen]
impl Contract {
    #[payable]
    pub fn owner_private_function(&mut self, new_owner: AccountId) {
        self.only_owner();
        assert_one_yocto();
        self.internal_change_owner(new_owner);
    }  
}
'''
'''--- sample_contract/src/actions/user_actions.rs ---
/// This file defines all functions meant to be called be user of regular type
/// All actions should only handle arguments and call internal functions
/// Actions include both change and view functions
use crate::*;

#[allow(dead_code)]
#[near_bindgen]
impl Contract {
    
    pub fn open_function(&mut self, data: u128, name: String) {
        self.add_personalized_struct(data, name, env::predecessor_account_id());
    }  
}
'''
'''--- sample_contract/src/complex_personalized_struct/internal_data_structure.rs ---
/// This file should create the struct that names it and impl it's methods

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use crate::errors::{ERR_201};

/// This file should create the struct and implement all it's methods
/// It's important that the struct is implemented inside an enum, so that 
/// upgrades to the contract can use the same StorageKey and data structure,
/// which makes migration faster, more secure and easier
#[derive(BorshSerialize, BorshDeserialize)]
pub enum InternalDataStructure {
    V1(InternalDataStructureV1)
}

#[allow(unreachable_patterns)]
impl InternalDataStructure {
    pub fn new(dummy_data: u128) -> Self {
        InternalDataStructure::V1(InternalDataStructureV1::new(dummy_data))
    }

    pub fn change_dummy_data(&mut self, new_dummy_data: u128) {

        match self {
            InternalDataStructure::V1(personalized_struct_v1) => {
                personalized_struct_v1.change_dummy_data(new_dummy_data)
            },
            _ => panic!("{}", ERR_201)
        }

    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct InternalDataStructureV1 {
    pub dummy_data: u128
}

impl InternalDataStructureV1 {
    pub fn new(dummy_data: u128) -> Self {
        Self {
            dummy_data
        }
    }

    pub fn change_dummy_data(&mut self, new_dummy_data: u128) {
        self.dummy_data = new_dummy_data;
    }
}
'''
'''--- sample_contract/src/complex_personalized_struct/mod.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use crate::{AccountId, LookupMap, StorageKey};
use crate::errors::{ERR_101, ERR_102};
use self::internal_data_structure::{InternalDataStructure};

mod internal_data_structure;

/// This file should create the struct and implement all it's methods
/// It's important that the struct is implemented inside an enum, so that 
/// upgrades to the contract can use the same StorageKey and data structure,
/// which makes migration faster, more secure and easier
#[derive(BorshSerialize, BorshDeserialize)]
pub enum ComplexPersonalizedStruct {
    V1(ComplexPersonalizedStructV1)
}

#[allow(unreachable_patterns)]
impl ComplexPersonalizedStruct {
    pub fn new(struct_name: String) -> Self {
        ComplexPersonalizedStruct::V1(ComplexPersonalizedStructV1::new(struct_name))
    }

    pub fn add_to_map(&mut self, account: AccountId, dummy_data: u128) {
        
        match self {
            ComplexPersonalizedStruct::V1(personalized_struct_v1) => {
                personalized_struct_v1.add_to_map(account, dummy_data);
            },
            _ => panic!("{}", ERR_102)
        }

    }

    pub fn change_in_map(&mut self, account: AccountId, new_dummy_data: u128) {

        match self {
            ComplexPersonalizedStruct::V1(personalized_struct_v1) => {
                personalized_struct_v1.add_to_map(account, new_dummy_data);
            },
            _ => panic!("{}", ERR_102)
        }

    }

}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct ComplexPersonalizedStructV1 {
    pub struct_name: String,
    pub account_relationship_map: LookupMap<AccountId, InternalDataStructure>
}

impl ComplexPersonalizedStructV1 {
    pub fn new(struct_name: String) -> Self {
        Self {
            struct_name: struct_name.clone(),
            account_relationship_map: LookupMap::new(StorageKey::InternalDataStructureMap { struct_name })
        }
    }

    pub fn add_to_map(&mut self, account: AccountId, dummy_data: u128) {
        
        let new_internal_data_structure = InternalDataStructure::new(dummy_data);
        self.account_relationship_map.insert(&account, &new_internal_data_structure);
    }

    pub fn change_in_map(&mut self, account: AccountId, new_dummy_data: u128) {

        let mut target_struct = self.account_relationship_map.get(&account).expect(ERR_101);
        target_struct.change_dummy_data(new_dummy_data);
        self.account_relationship_map.insert(&account, &target_struct);
    }

}

'''
'''--- sample_contract/src/errors.rs ---
/// Error should be divided per module.
/// Each module should have its own error code starting number
/// That means a different starting code for error inside contract methods, and inside each of the
/// other structs
/// There's also the need for errors specific to the actions section

/// Error code format is: ERR_{section_number}{error_in_section_number}
/// Error message format is "{smart-contract-name}: {struct or module name}: fn {function_name}: {message_describing_error}"

/// Contract errors - code 0
pub(crate) const ERR_001: &str = "Sample-App: Contract: fn initialize_function: Contract already initialized";
pub(crate) const ERR_002: &str = "Sample-App: Contract: fn only_owner: This function can only be called by the owner";
pub(crate) const ERR_003: &str = "Sample-App: Contract: fn only_guardians_or_owner: This function can only be called by the owner or guardians";
pub(crate) const ERR_004: &str = "Sample-App: Contract: fn add_personalized_struct: This account already created a struct";

/// ComplexPersonalizedStruct (complex_personalized_structs folder) errors - code 1
pub(crate) const ERR_101: &str = "Sample-App: ComplexPersonalizedStruct: fn change_in_map: AccountId not found in account_relationship_map";
pub(crate) const ERR_102: &str = "Sample-App: ComplexPersonalizedStruct: generic: Method not implemented for this enum variant";

/// PersonalizedStructs (personalized_structs.rs) errors - code 2
pub(crate) const ERR_201: &str = "Sample-App: PersonalizedStruct: fn change_data: method not implemented for this enum variant";

'''
'''--- sample_contract/src/events.rs ---
use near_sdk::{log};
use serde_json::{json};

fn log_basic_event_format(standard: &str, version: &str, event_type: &str, data_vec: Vec<&str>) {
    log!("EVENT_JSON:{}", &json!({
        "standard": standard, 
        "version": version, 
        "event": event_type,
        "data": data_vec
    }).to_string())
}
'''
'''--- sample_contract/src/ext_interface.rs ---
use near_sdk::{ext_contract};
use near_sdk::json_types::{U64, U128};

/// This file is used to construct the interfaces for cross contract calls.
/// Documentation on cross contract calls and its interfaces can be found at: https://www.near-sdk.io/cross-contract/callbacks
/// This file should include interfaces to call external contracts and also
/// interfaces to perform callbacks on itself
#[ext_contract(ext_calculator)]
trait Calculator {
    fn mult(&self, a: U64, b: U64) -> U128;

    fn sum(&self, a: U128, b: U128) -> U128;
}

/// The interface to callback the contract should always take the name ext_self
#[ext_contract(ext_self)]
trait Callbacks {
    fn callback_function(#[callback] val: bool, account: AccountId);
}
'''
'''--- sample_contract/src/internal_structs.md ---
# Internal structs
  

### enum wrapping

Because of the way information is stored in the NEAR protocol, it is a best practice to always wrap structs that are directly stored into the state in an enum.  
That is for upgradability purposes, being that in an application V2 we might need to change the data structure and we cannot risk having new and old implementations cohabiting the applications state.  
Wrapping the struct into an enum allows us to handle V1 and V2 data differently, effectively making a smooth contract upgrade.  
  
#### whenever you're storing a struct directly into the trie (that is, as a Contract field or inside a near_sdk collection such LookupMap, Vector, etc.) you should wrap it inside an enum.  
  
### Example
```
#[derive(BorshSerialize, BorshDeserialize)]
pub enum PersonalizedStruct {
    V1(PersonalizedStructV1)
}

#[allow(unreachable_patterns)]
impl PersonalizedStruct {
    pub fn new(data: u128, name: String) -> Self {
        PersonalizedStruct::V1(PersonalizedStructV1::new(data, name))
    }

    pub fn change_data(&mut self, new_data: u128) -> u128 {
        match self {
            PersonalizedStruct::V1(personalized_struct_v1) => {
                personalized_struct_v1.change_data(new_data)
            },
            _ => panic!("{}", ERR_201)
        }
    }

}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct PersonalizedStructV1 {
    pub data: u128,
    pub last_data: Option<u128>,
    pub name: String
}

impl PersonalizedStructV1 {
    pub fn new(data: u128, name: String) -> Self {
        Self {
            data,
            last_data: None,
            name
        }
    }

'''
'''--- sample_contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet, UnorderedMap};
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault
};

use crate::complex_personalized_struct::{ComplexPersonalizedStruct};
use crate::personalized_struct::{PersonalizedStruct};

use crate::errors::{ERR_001, ERR_002, ERR_003, ERR_004};

pub(crate) mod errors;
pub mod ext_interface;
pub mod complex_personalized_struct;
pub mod personalized_struct;
pub mod actions;

/// lib file is used to define the Contract struct, which is the state layer of the smart contract
/// In this file we'll also define the implementations of the methods of the contract struct
/// It is required to always have a initialization function, marked by #[init] ins
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
struct Contract {
    owner: AccountId,
    guardians: UnorderedSet<AccountId>,
    data_structure_map: LookupMap<AccountId, PersonalizedStruct>,
    second_data_structure_map: UnorderedMap<AccountId, ComplexPersonalizedStruct>
}

/// 1. It's a best practice to always use a StorageKey enum to initialize all near_sdk::collections
/// 2. It's important to make the StorageKey enum pub(crate) in case we need to initialize some form
/// of blockchain storage collection in different files.
/// 3. If needed, variants in the enum can also be complex if there's a need to create multiple collections
/// during the execution of the smart contract. That way a parameter can be passed to differentiate between 
/// collections of the same type
#[derive(BorshSerialize, BorshStorageKey)]
pub(crate) enum StorageKey {
    GuardiansSet,
    DataStructureMap,
    SecondDataStructureMap,
    InternalDataStructureMap { struct_name: String },
}

/// 1. There should be no #[near_bindgen] impl sections outside of actions folder,
/// the nly exception is the initialize_contract function, which must be marked with #[init]
/// and is responsible for instantiating the contract into the blockchain's state
/// 2. All other impl sections in this file must be internal to the struct and not exposed to the blockchain,
/// whenever we want to expose a functionality to the end user, it should be declared inside actions
/// 3. #[allow(dead_code)] is used so that rust compiler doesn't throw a unused function warning, this is needed
/// on every #[near_bindgen] impl since the functions are meant to be called on the blockchain and not inside
/// the code itself
#[allow(dead_code)]
#[near_bindgen]
impl Contract {
    #[init]
    pub fn initialize_contract(owner: AccountId) -> Self {
        assert!(!env::state_exists(), "{}", ERR_001);
        Self {
            owner,
            guardians: UnorderedSet::new(StorageKey::GuardiansSet),
            data_structure_map: LookupMap::new(StorageKey::DataStructureMap),
            second_data_structure_map: UnorderedMap::new(StorageKey::SecondDataStructureMap)
        }
    }
}

/// Here all Contract level functions will be defined
impl Contract {
    pub fn internal_change_owner(&mut self, new_owner: AccountId) {
        self.owner = new_owner;
    }

    pub fn internal_renounce_guardianship(&mut self, guardian: AccountId) {
        self.guardians.remove(&guardian);
    }

    pub fn add_personalized_struct(&mut self, data: u128, name: String, user: AccountId) {
        assert!(!self.data_structure_map.contains_key(&user), "{}", ERR_004);
        let new_struct = PersonalizedStruct::new(data, name);
        self.data_structure_map.insert(&user, &new_struct);
    } 
}

/// It is necessary to separate a impl block for helper functions, differen from the block that implements business logic workflows
impl Contract {
    pub fn only_owner(&self) {
        assert_eq!(self.owner, env::predecessor_account_id(), "{}", ERR_002)
    }

    pub fn only_guardians_or_owner(&self) {
        if env::predecessor_account_id() != self.owner {
            assert!(self.guardians.contains(&env::predecessor_account_id()), "{}", ERR_003)
        }
    }
}
'''
'''--- sample_contract/src/personalized_struct.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use crate::errors::{ERR_201};
/// This file should create the struct and implement all it's methods
/// It's important that the struct is implemented inside an enum, so that 
/// upgrades to the contract can use the same StorageKey and data structure,
/// which makes migration faster, more secure and easier
#[derive(BorshSerialize, BorshDeserialize)]
pub enum PersonalizedStruct {
    V1(PersonalizedStructV1)
}

#[allow(unreachable_patterns)]
impl PersonalizedStruct {
    pub fn new(data: u128, name: String) -> Self {
        PersonalizedStruct::V1(PersonalizedStructV1::new(data, name))
    }

    pub fn change_data(&mut self, new_data: u128) -> u128 {
        
        match self {
            PersonalizedStruct::V1(personalized_struct_v1) => {
                personalized_struct_v1.change_data(new_data)
            },
            _ => panic!("{}", ERR_201)
        }
        
    }

}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct PersonalizedStructV1 {
    pub data: u128,
    pub last_data: Option<u128>,
    pub name: String
}

impl PersonalizedStructV1 {
    pub fn new(data: u128, name: String) -> Self {
        Self {
            data,
            last_data: None,
            name
        }
    }

    pub fn change_data(&mut self, new_data: u128) -> u128 {
        
        let old_data = self.data;
        self.last_data = Some(old_data);
        self.data = new_data;
        old_data

    }

}
'''
'''--- sample_contract/src/readme.md ---
# Project structure
  

### Terminology

application -> The entire smart contract application;  
Contract or contract struct -> Struct that implements the #[near_bindgen] attribute macro;  
internal Struct -> Struct defined in the code that is used inside the Contract's variables;

### Folder organization

The organization of folders inside the project should follow the standard:
  
lib.rs -> Contract definition and implementation of Contract method's that are not exposed to the blockchain. Also implements the Contract initialization_function (only blockchain public function outside of actions).  
  
errors.rs -> Lists the different error messages that the application uses as constants of type &str;

ext_interface.rs -> implements the interfaces for the cross contract calls performed by the application;  
  
events.rs -> implements the functions to log events in the application;
  
utils.rs -> implements helper functions (not methods for any struct);
  
internal_struct.rs (must be named after the internal struct being implemented) -> implements an Internal Struct and its methods (note that internal structs should be wrapped in an enum, as explained in internal_structs.md);  
  
internal_struct folder (must be named after the internal struct being implemented) -> implements an Internal Struct and its methods (note that internal structs should be wrapped in an enum, as explained in internal_structs.md).  
The folder approach is to be used when the struct is complex - meaning that it nests other complex data structures inside of it;  
  
actions folder -> implements all the blockchain public methods of the application. Should be divided into submodules for each user type.
'''
'''--- sample_contract/src/utils.rs ---
/// Utilitarina functions not associated with any struct

pub fn create_struct_id(part_1: String, part_2: String) -> String {
    format!(part_1, "@", part_2)
}
'''
'''--- sample_contract/unit_testing_guidelines.md ---
# Unit testing guidelines

Performing unit testing using this architecture is made very simple.  
Unit tests should test all methods defined in all of the files and check that they are performing their correct functionality.  
Each test tests only one method of the application and nothing else. There's a discussion in the testing community regarding tests for private functions, in this spec we mantain that private functions in the Rust sense (that means, functions that cannot be called outside the scope of the impl section in which they're defined) don't need to be tested. However, every method from the Contract and whichever enum or struct you create in the project must be tested, even if it is not exposed on the blockchain.  
  
When testing methods that call other methods, it's only required to test the functionality implemented by the higher level function.  
If all it does is call another function, you should mock the function called with a monkey patch, to remove the actual functionality and only assert that the function has been called, it is not necessary to make any assertions about the functioning of the inner function that has already been tested.  
If a function calls another function somewhere, but also implements logic you should make assertions about the logic that it implements and also assert that the lower level function is being called.  
If you see a function that calls other functions and that apparently cannot be tested without making assertions about the inner state of the lower level functions or that has functionality that won't work if you monkey patch the inner functions that is a sign that you should break the function down into smaller functions that are called separatelly.   
  
### Testing without mocking the blockchain  
  
Unit tests ideally don't need to mock the blockchain features, t

### Differences between unit testing and integration testing in the NEAR protocol  

Building integration tests for the near protocol requires us to actually run a local blockchain in our machine (or use a ci testnet) to deploy a contract and perform operations on it, the same way as the end user would.  
  
That's not the goal for unit testing. Unit tests exist for us to ensure that each function is doing precisely what it is intended to do and nothing else. Most functions are internal to the Contract struct or its internal data structures and might therefore be tested without the need to mock the blockchain environment.
However, in the case of functions that utilize env::predecessor_account_id(), env::attached_deposit() and other blockchain variables, we need to mock the blockchain to be able to unit test them.  
Ideally, the only functionas that should utilise the near_sdk::env variables are the action functions. In some rare cases they might be needed inside internal functions as well. In case the function you're testing requires near_sdk::env variables, you should apply the following context mocking framework:  
  
```
/// This function can actually implement more or less blockchain attributes as variables, depending on the testing needs of the application
pub fn get_context(input: Vec<u8>, is_view: bool, attached_deposit: u128, account_balance: u128, signer_id: AccountId) -> VMContext {
    VMContext {
        current_account_id: CONTRACT_ACCOUNT.to_string(),
        signer_account_id: signer_id.clone(),
        signer_account_pk: vec![0, 1, 2],
        predecessor_account_id: signer_id.clone(),
        input,
        block_index: 0,
        block_timestamp: 0,
        account_balance,
        account_locked_balance: 0,
        storage_usage: 0,
        attached_deposit,
        prepaid_gas: 10u64.pow(18),
        random_seed: vec![0, 1, 2],
        is_view,
        output_data_receivers: vec![],
        epoch_height: 19,
    }
  }

/// to run the test we first setup the blockchain mock and then perform the function call
#[test]
fn test_new() {
  let mut context = get_context(vec!(), false, 0, 0, OWNER_ACCOUNT.to_string()); 
  testing_env!(context);
  
  let contract = Contract::new(OWNER_ACCOUNT.to_string(), TOTAL_SUPPLY.into(), get_test_meta());
  let contract_metadata = contract.metadata.get().unwrap();

  assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
  assert_eq!(contract.ft_balance_of( ValidAccountId::try_from(OWNER_ACCOUNT).unwrap() ).0, TOTAL_SUPPLY);
  assert_eq!(contract_metadata.spec, get_test_meta().spec)
}

```
  
Note that even though we're mocking the blockchain, we're only calling one function of the contract in the test. Unit tests should never call more than one contract function.  
If the function you're testing requires previous setup of the Contract this setup should be done manually and not through the use of different function calls.  
Remember: If you're calling more than one function from your application you're doing an integration test and not a unit test.

'''