*GitHub Repository "philoniare/NearSupplyChain"*

'''--- .idea/modules.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/starter--near-sdk-as.iml" filepath="$PROJECT_DIR$/.idea/starter--near-sdk-as.iml" />
    </modules>
  </component>
</project>
'''
'''--- .idea/vcs.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$" vcs="Git" />
  </component>
</project>
'''
'''--- README.md ---
# Coffee Supply Chain Tracker

This NEAR blockchain project simulates a real-world use case of tracking the supply chain for a product through different actors, such as farmers, distributors, retailers and finally, consumers. 

## Contract

This repository includes a complete project structure for AssemblyScript contract for the supply chain targeting the NEAR platform.

The project is very minimal, but contains the following functionalities:
![State diagram](state_diagram.png)

Contract file:
- **supply_chain** in the `src/simple` folder

## Usage

### Running the tests

Run `yarn test`:

Output:
```
[Describe]: SupplyChainContract

 [Success]: ✔ allows a farmer to harvest coffee
 [Success]: ✔ allows a farmer to process coffee
 [Success]: ✔ allows a farmer to pack coffee
 [Success]: ✔ allows a farmer to mark coffee for sale
 [Success]: ✔ allows a distributor to buy coffee
 [Success]: ✔ allows a retailer to mark coffee received
 [Success]: ✔ allows a retailer to mark coffee received
 [Success]: ✔ allows a consumer to purchase coffee

```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/supply_chain"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

near dev-deploy ./build/debug/supply_chain.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the supply_chain style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/supply_chain/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/supply_chain/__tests__/index.unit.spec.ts ---
import {SupplyChainContract} from "../assembly";
import {u128, VMContext} from "near-sdk-as";
import {ONE_NEAR, AccountId} from '../../utils';
import {ItemState} from "../assembly/model";

const attachProductBalance = (): void => {
  VMContext.setAttached_deposit(ONE_NEAR);
};

const setCurrentAccount = (accountId: AccountId): void => {
  VMContext.setSigner_account_id(accountId);
};

let contract: SupplyChainContract

beforeEach(() => {
  contract = new SupplyChainContract()
});

describe("SupplyChainContract", () => {
  const upc = 1
  const originFarmerID = 'farmer'
  const originFarmName = "John Doe"
  const originFarmInformation = "Yarray Valley"
  const originFarmLatitude = "-38.239770"
  const originFarmLongitude = "144.341490"
  const productNotes = "Best beans for Espresso"
  const distributorID = 'distributor'
  const retailerID = 'retailer'
  const consumerID = 'consumer'

  it("allows a farmer to harvest coffee", () => {
    contract.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude,
        originFarmLongitude, productNotes);
    const product = contract.getProducts().get(upc);;
    expect(product).not.toBeNull();
    expect(product!.itemState).toBe(ItemState.Harvested, 'new product should be in harvested state');
  });

  it("allows a farmer to process coffee", () => {
    contract.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude,
        originFarmLongitude, productNotes);
    contract.processItem(upc);
    const product = contract.getProducts().get(upc);;
    expect(product).not.toBeNull();
    expect(product!.itemState).toBe(ItemState.Processed, 'product state should be processed');
  });

  it("allows a farmer to pack coffee", () => {
    contract.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude,
        originFarmLongitude, productNotes);
    contract.processItem(upc);
    contract.packItem(upc);
    const product = contract.getProducts().get(upc);;
    expect(product).not.toBeNull();
    expect(product!.itemState).toBe(ItemState.Packed, 'product state should be packed');
  });

  it("allows a farmer to mark coffee for sale", () => {
    contract.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude,
        originFarmLongitude, productNotes);
    contract.processItem(upc);
    contract.packItem(upc);
    contract.sellItem(upc, ONE_NEAR);
    const product = contract.getProducts().get(upc);
    expect(product).not.toBeNull();
    expect(product!.itemState).toBe(ItemState.ForSale, 'product state should be for sale');
    expect(product!.productPrice).toBe(ONE_NEAR, 'product price should be one near');
  });

  it("allows a distributor to buy coffee", () => {
    attachProductBalance();
    setCurrentAccount(distributorID);
    contract.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude,
        originFarmLongitude, productNotes);
    contract.processItem(upc);
    contract.packItem(upc);
    contract.sellItem(upc, ONE_NEAR);
    contract.buyItem(upc);
    const product = contract.getProducts().get(upc);
    expect(product).not.toBeNull();
    expect(product!.itemState).toBe(ItemState.Sold, 'product state should be sold');
    expect(product!.distributorID).toBe(distributorID, 'product distributorID should be set correctly');
    expect(product!.ownerID).toBe(distributorID, 'product ownerID should be set correctly');
  });

  it("allows a retailer to mark coffee received", () => {
    attachProductBalance();
    setCurrentAccount(retailerID);
    contract.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude,
        originFarmLongitude, productNotes);
    contract.processItem(upc);
    contract.packItem(upc);
    contract.sellItem(upc, ONE_NEAR);
    contract.buyItem(upc);
    contract.shipItem(upc);
    const product = contract.getProducts().get(upc);
    expect(product).not.toBeNull();
    expect(product!.itemState).toBe(ItemState.Shipped, 'product state should be shipped');
  });

  it("allows a retailer to mark coffee received", () => {
    attachProductBalance();
    setCurrentAccount(retailerID);
    contract.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude,
        originFarmLongitude, productNotes);
    contract.processItem(upc);
    contract.packItem(upc);
    contract.sellItem(upc, ONE_NEAR);
    contract.buyItem(upc);
    contract.shipItem(upc);
    contract.receiveItem(upc);
    const product = contract.getProducts().get(upc);
    expect(product).not.toBeNull();
    expect(product!.itemState).toBe(ItemState.Received, 'product state should be sold');
    expect(product!.retailerID).toBe(retailerID, 'product retailerID should be set correctly');
    expect(product!.ownerID).toBe(retailerID, 'product ownerID should be set correctly');
  });

  it("allows a consumer to purchase coffee", () => {
    attachProductBalance();
    setCurrentAccount(consumerID);
    contract.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude,
        originFarmLongitude, productNotes);
    contract.processItem(upc);
    contract.packItem(upc);
    contract.sellItem(upc, ONE_NEAR);
    contract.buyItem(upc);
    contract.shipItem(upc);
    contract.receiveItem(upc);
    contract.purchaseItem(upc);
    const product = contract.getProducts().get(upc);
    expect(product).not.toBeNull();
    expect(product!.itemState).toBe(ItemState.Purchased, 'product state should be purchased');
    expect(product!.consumerID).toBe(consumerID, 'product consumerID should be set correctly');
    expect(product!.ownerID).toBe(consumerID, 'product ownerID should be set correctly');
  });
});

'''
'''--- src/supply_chain/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/supply_chain/assembly/index.ts ---
import {Context} from "near-sdk-core";
import {ContractPromiseBatch, PersistentMap, u128} from "near-sdk-as";
import {ItemState, Product} from "./model";
import {AccountId, XCC_GAS} from "../../utils";

@nearBindgen
export class SupplyChainContract {
  private skuIndex: i32;
  private upcIndex: i32;
  private products: PersistentMap<i32, Product> = new PersistentMap<i32, Product>("m");

  constructor() {
    this.skuIndex = 1;
    this.upcIndex = 1;
  }

  getProducts(): PersistentMap<i32, Product> {
    return this.products;
  }

  /*
     Allows a farmer to mark an item 'Harvested'
   */
  @mutateState()
  harvestItem(upc: i32, originFarmerID: AccountId, originFarmerName: string, originFarmInformation: string,
              originFarmLatitude: string, originFarmLongitude: string, productNotes: string): void {
    // Create a new product and push to the persistent map
    const product = new Product(
      this.skuIndex,
      upc,
      originFarmerID,
      originFarmerName,
      originFarmInformation,
      originFarmLatitude,
      originFarmLongitude,
      productNotes,
    );
    this.products.set(upc, product);
    this.skuIndex++;
  }

  /*
    Allows a farmer to mark an item 'Processed'
   */
  @mutateState()
  processItem(upc: i32): void {
    let product = this.products.get(upc);
    assert(product !== null, "Product with upc doesn't exist");
    assert(product!.itemState === ItemState.Harvested,
        "Product can only be processed when it's in harvested state");
    assert(this.verifyCaller(product!.originFarmerID), "Only the harvested farmer can process this product");

    product!.itemState = ItemState.Processed;

    this.products.set(upc, product!);
  }

  /*
     Allows a farmer to mark an item 'Packed'
   */
  @mutateState()
  packItem(upc: i32): void {
    let product = this.products.get(upc);
    assert(product !== null, "Product with upc doesn't exist");
    assert(product!.itemState === ItemState.Processed,
        "Product can only be packed when it's in processed state");
    assert(this.verifyCaller(product!.originFarmerID), "Only the harvested farmer can pack this product");

    product!.itemState = ItemState.Packed;

    this.products.set(upc, product!);
  }

  /*
    Allows a farmer to mark an item 'ForSale'
   */
  @mutateState()
  sellItem(upc: i32, price: u128): void {
    let product = this.products.get(upc);
    assert(product !== null, "Product with upc doesn't exist");
    assert(product!.itemState === ItemState.Packed,
        "Product can only be put for sale when it's in packed state");
    assert(this.verifyCaller(product!.originFarmerID), "Only the harvested farmer can sell this product");

    product!.itemState = ItemState.ForSale;
    product!.productPrice = price;

    this.products.set(upc, product!);
  }

  /*
    Allows the distributor to mark an item 'Sold'

   */
  @mutateState()
  buyItem(upc: i32): void {
    let product = this.products.get(upc);
    assert(product !== null, "Product with upc doesn't exist");
    assert(product!.itemState === ItemState.ForSale,
        "Product can only be processed when it's in for sale state");
    assert(Context.attachedDeposit >= product!.productPrice,
        'Attached amount is less than product sale price');
    product!.itemState = ItemState.ForSale;

    // Transfer money to farmer who sold the product
    const to_farmer = ContractPromiseBatch.create(product!.originFarmerID);
    to_farmer.transfer(product!.productPrice);

    // Update product metadata
    product!.itemState = ItemState.Sold;
    product!.ownerID = Context.sender;
    product!.distributorID = Context.sender;
    this.products.set(upc, product!);

    to_farmer.then(Context.sender).function_call("on_payout_complete", "{}", u128.Zero, XCC_GAS);
  }

  /*
    Allows the distributor to mark an item 'Shipped'
   */
  @mutateState()
  shipItem(upc: i32): void {
    let product = this.products.get(upc);
    assert(product !== null, "Product with upc doesn't exist");
    assert(product!.itemState === ItemState.Sold,
        "Product can only be shipped when it's in sold state");
    assert(this.verifyCaller(product!.distributorID), "Only the bought distributor can ship this product");

    product!.itemState = ItemState.Shipped;

    this.products.set(upc, product!);
  }

  /*
    Allows the retailer to mark an item 'Received'
   */
  @mutateState()
  receiveItem(upc: i32): void {
    let product = this.products.get(upc);
    assert(product !== null, "Product with upc doesn't exist");
    assert(product!.itemState === ItemState.Shipped,
        "Product can only be received when it's in shipped state");

    product!.itemState = ItemState.Received;
    product!.retailerID = Context.sender;
    product!.ownerID = Context.sender;

    this.products.set(upc, product!);
  }

  /*
    Allows the consumer to mark an item 'Purchased'
   */
  @mutateState()
  purchaseItem(upc: i32): void {
    let product = this.products.get(upc);
    assert(product !== null, "Product with upc doesn't exist");
    assert(product!.itemState === ItemState.Received,
        "Product can only be purchased when it's in received state");
    assert(this.verifyCaller(product!.retailerID), "Only the received retailer can process this product");

    product!.itemState = ItemState.Purchased;
    product!.consumerID = Context.sender;
    product!.ownerID = Context.sender;

    this.products.set(upc, product!);
  }

  private verifyCaller(callerId: AccountId): boolean {
    return Context.sender !== callerId;
  }
}

'''
'''--- src/supply_chain/assembly/model.ts ---
import { context, u128, PersistentVector } from "near-sdk-as";
import { AccountId, ONE_NEAR, asNEAR, XCC_GAS } from "../../utils";

export enum ItemState {
    Harvested,  // 0
    Processed,  // 1
    Packed,     // 2
    ForSale,    // 3
    Sold,       // 4
    Shipped,    // 5
    Received,   // 6
    Purchased   // 7
}

@nearBindgen
export class Product {
    sku: i32;  // Stock Keeping Unit (SKU)
    upc: i32; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
    ownerID: AccountId;  // address of the current owner as the product moves through 8 stages
    originFarmerID: AccountId; // address of the Farmer
    originFarmName: string; // Farmer Name
    originFarmInformation: string;  // Farmer Information
    originFarmLatitude: string; // Farm Latitude
    originFarmLongitude: string;  // Farm Longitude
    productID: number;  // Product ID potentially a combination of upc + sku
    productNotes: string; // Product Notes
    productPrice: u128; // Product Price
    itemState: ItemState;  // Product State as represented in the enum above
    distributorID: AccountId;  // address of the Distributor
    retailerID: AccountId; // address of the Retailer
    consumerID: AccountId; // address of the Consumer

    constructor(sku: i32, upc: i32, originFarmerID: AccountId, originFarmerName: string, originFarmInformation: string,
                originFarmLatitude: string, originFarmLongitude: string, productNotes: string) {
        this.sku = sku;
        this.upc = upc;
        this.productID = sku + upc;
        this.sku = sku;
        this.productPrice = u128.from('0');
        this.originFarmerID = originFarmerID;
        this.originFarmName = originFarmerName;
        this.originFarmInformation = originFarmInformation;
        this.originFarmLatitude = originFarmLatitude;
        this.originFarmLongitude = originFarmLongitude;
        this.productNotes = productNotes;
        this.ownerID = originFarmerID;
        this.itemState = ItemState.Harvested;
        this.distributorID = 'none';
        this.retailerID = 'none';
        this.consumerID = 'none';
    }

    public toString(): string {
        return `Product ${this.sku}`;
    }
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''