*GitHub Repository "NearDeFi/near-is-aurora"*

'''--- Cargo.toml ---
[package]
name = "near-is-aurora"
version = "0.1.0"
authors = ["Eugene The Dream <ek@proximity.dev>"]
edition = "2018"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "contract",
    "engine-types",
]

'''
'''--- README.md ---
TEST

'''
'''--- build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
pushd "$(dirname $0)"

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
mkdir -p ./res
cp $TARGET/wasm32-unknown-unknown/release/contract.wasm ./res/

popd

'''
'''--- contract/Cargo.toml ---
[package]
name = "contract"
version = "0.1.0"
authors = ["Eugene The Dream <ek@proximity.dev>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
primitive-types = { version = "0.10.0", default-features = false, features = ["rlp"] }
aurora-engine-types = { path = "../engine-types", default-features = false }
hex = { version = "0.4", default-features = false, features = ["alloc"] }

[features]
# default = ["std"]
# std = ["primitive-types/std"]

'''
'''--- contract/src/aurora.rs ---
use near_sdk::{AccountId, Gas};
use primitive_types::H256;

use crate::*;

pub const AURORA: &str = "aurora";
pub const TGAS: Gas = 10u64.pow(12);
pub const VIEW_CALL_GAS: Gas = 100 * TGAS;
pub const CALL_GAS: Gas = 200 * TGAS;
pub const NO_DEPOSIT: Balance = 0;

#[inline]
pub(crate) fn keccak(input: &[u8]) -> H256 {
    H256::from_slice(&env::keccak256(&input))
}

pub(crate) fn near_account_to_evm_address(addr: &AccountId) -> Address {
    Address::from_slice(&keccak(addr.as_bytes())[12..])
}

pub(crate) fn get_selector(str_selector: &str) -> Vec<u8> {
    keccak(str_selector.as_bytes())[..4].to_vec()
}

pub(crate) fn build_input(str_selector: &str, inputs: &[Token]) -> Vec<u8> {
    let sel = get_selector(str_selector);
    let inputs = ethabi::encode(inputs);
    [sel.as_slice(), inputs.as_slice()].concat().to_vec()
}

pub(crate) fn address_to_string(address: &Address) -> String {
    format!("0x{}", hex::encode(&address.0))
}

pub(crate) fn parse_address(address: &str) -> Address {
    assert!(address.starts_with("0x"), "Address should start with 0x");
    let res = hex::decode(&address[2..]).expect("Failed to parse");
    assert_eq!(res.len(), 20, "Not 20 bytes");
    Address::from_slice(&res)
}

#[ext_contract(ext_aurora_internal)]
trait ExtAuroraInternal {
    #[result_serializer(borsh)]
    fn get_balance(&self, #[serializer(borsh)] address: RawAddress);

    #[result_serializer(borsh)]
    fn get_erc20_from_nep141(&self, #[serializer(borsh)] token_id: AccountId);

    #[result_serializer(borsh)]
    fn view(
        &self,
        #[serializer(borsh)] sender: RawAddress,
        #[serializer(borsh)] address: RawAddress,
        #[serializer(borsh)] amount: RawU256,
        #[serializer(borsh)] input: Vec<u8>,
    );

    #[result_serializer(borsh)]
    fn call(&self, #[serializer(borsh)] call_args: CallArgs);
}

/// Borsh-encoded parameters for the engine `call` function.
#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct FunctionCallArgsV2 {
    pub contract: RawAddress,
    /// Wei compatible Borsh-encoded value field to attach an ETH balance to the transaction
    pub value: RawU256,
    pub input: Vec<u8>,
}

/// Deserialized values from bytes to current or legacy Borsh-encoded parameters
/// for passing to the engine `call` function, and to provide backward type compatibility
#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum CallArgs {
    V2(FunctionCallArgsV2),
    LegacyShit,
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub enum TransactionStatus {
    Succeed(Vec<u8>),
    Revert(Vec<u8>),
    OutOfGas,
    OutOfFund,
    OutOfOffset,
    CallTooDeep,
}

pub mod ext_aurora {
    use super::*;

    pub fn get_balance(address: Address) -> Promise {
        ext_aurora_internal::get_balance(address.0, &AURORA.to_string(), NO_DEPOSIT, 5 * TGAS)
    }

    pub fn get_erc20_from_nep141(token_id: &AccountId) -> Promise {
        ext_aurora_internal::get_erc20_from_nep141(
            token_id.clone(),
            &AURORA.to_string(),
            NO_DEPOSIT,
            10 * TGAS,
        )
    }

    fn call(contract: Address, input: Vec<u8>) -> Promise {
        ext_aurora_internal::call(
            CallArgs::V2(FunctionCallArgsV2 {
                contract: contract.0,
                value: RawU256::default(),
                input,
            }),
            &AURORA.to_string(),
            NO_DEPOSIT,
            CALL_GAS,
        )
    }

    pub fn get_erc20_balance(token_address: Address, account_address: Address) -> Promise {
        let input = build_input(
            "balanceOf(address)",
            &[Token::Address(account_address.into())],
        );
        ext_aurora_internal::view(
            account_address.0,
            token_address.0,
            RawU256::default(),
            input,
            &AURORA.to_string(),
            NO_DEPOSIT,
            VIEW_CALL_GAS,
        )
    }

    pub fn erc20_transfer_balance(
        token_address: Address,
        receiver: Address,
        amount: Balance,
    ) -> Promise {
        let input = build_input(
            "transfer(address,uint256)",
            &[
                Token::Address(receiver.into()),
                Token::Uint(U256::from(amount)),
            ],
        );
        call(token_address, input)
    }
}

'''
'''--- contract/src/lib.rs ---
mod aurora;

use aurora_engine_types::ethabi::{self, Token};
use aurora_engine_types::types::{RawAddress, RawU256};
use aurora_engine_types::Address;
use aurora_engine_types::U256;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{ValidAccountId, WrappedBalance};
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault,
    Promise, PromiseOrValue,
};

use crate::aurora::*;

near_sdk::setup_alloc!();

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Erc20ToNep141,
    Nep141ToErc20,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    erc20_to_nep141: LookupMap<RawAddress, AccountId>,
    nep141_to_erc20: LookupMap<AccountId, RawAddress>,
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_balance(&self);
    fn on_near_erc20_token_balance(&self);
    #[result_serializer(borsh)]
    fn on_get_erc20_from_nep141(&self, #[serializer(borsh)] token_id: AccountId);
}

pub trait ExtSelf {
    fn on_balance(&self, balance: RawU256) -> WrappedBalance;
    fn on_near_erc20_token_balance(&self, tx_result: TransactionStatus) -> Option<WrappedBalance>;
    fn on_get_erc20_from_nep141(
        &mut self,
        token_address: RawAddress,
        token_id: AccountId,
    ) -> String;
}

#[near_bindgen]
impl Contract {
    #[init(ignore_state)]
    pub fn new() -> Self {
        Self {
            erc20_to_nep141: LookupMap::new(StorageKey::Erc20ToNep141),
            nep141_to_erc20: LookupMap::new(StorageKey::Nep141ToErc20),
        }
    }

    pub fn near_address(&self) -> String {
        let address = near_account_to_evm_address(&env::current_account_id());
        address_to_string(&address)
    }

    pub fn get_native_balance(&self) -> Promise {
        let address = near_account_to_evm_address(&env::current_account_id());
        ext_aurora::get_balance(address).then(ext_self::on_balance(
            &env::current_account_id(),
            NO_DEPOSIT,
            5 * TGAS,
        ))
    }

    pub fn get_near_erc20_token_balance(&self, token_id: ValidAccountId) -> Promise {
        let address = near_account_to_evm_address(&env::current_account_id());
        let token_address = self.get_erc20_address(token_id.as_ref());
        ext_aurora::get_erc20_balance(token_address, address).then(
            ext_self::on_near_erc20_token_balance(
                &env::current_account_id(),
                NO_DEPOSIT,
                10 * TGAS,
            ),
        )
    }

    pub fn fetch_erc20_token_address(
        &mut self,
        token_id: ValidAccountId,
    ) -> PromiseOrValue<String> {
        if let Some(raw_address) = self.nep141_to_erc20.get(token_id.as_ref()) {
            return PromiseOrValue::Value(address_to_string(&Address(raw_address)));
        }
        ext_aurora::get_erc20_from_nep141(token_id.as_ref())
            .then(ext_self::on_get_erc20_from_nep141(
                token_id.into(),
                &env::current_account_id(),
                NO_DEPOSIT,
                10 * TGAS,
            ))
            .into()
    }

    #[private]
    pub fn erc20_transfer(
        &mut self,
        token_id: ValidAccountId,
        receiver: String,
        amount: WrappedBalance,
    ) -> Promise {
        let token_address = self.get_erc20_address(token_id.as_ref());
        let receiver = parse_address(&receiver);
        log!("Sending {} to {}", amount.0, address_to_string(&receiver));
        ext_aurora::erc20_transfer_balance(token_address, receiver, amount.0)
    }
}

impl Contract {
    fn get_erc20_address(&self, token_id: &AccountId) -> Address {
        let token_address = Address(
            self.nep141_to_erc20
                .get(&token_id)
                .expect("Need to fetch token first."),
        );
        log!("Token Address: {}", address_to_string(&token_address));
        token_address
    }
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn on_balance(
        &self,
        #[callback]
        #[serializer(borsh)]
        balance: RawU256,
    ) -> WrappedBalance {
        let balance = U256::from(balance).as_u128();
        log!("Your balance is {}", balance);
        balance.into()
    }

    #[private]
    fn on_near_erc20_token_balance(
        &self,
        #[callback]
        #[serializer(borsh)]
        tx_result: TransactionStatus,
    ) -> Option<WrappedBalance> {
        match tx_result {
            TransactionStatus::Succeed(res) => {
                let balance = U256::from(res.as_slice()).as_u128();
                log!("Your token balance is {}", balance);
                Some(balance.into())
            }
            _ => {
                log!("Failed to fetch token balance");
                None
            }
        }
    }

    #[private]
    fn on_get_erc20_from_nep141(
        &mut self,
        #[callback]
        #[serializer(borsh)]
        token_address: RawAddress,
        #[serializer(borsh)] token_id: AccountId,
    ) -> String {
        self.erc20_to_nep141.insert(&token_address, &token_id);
        self.nep141_to_erc20.insert(&token_id, &token_address);
        address_to_string(&Address(token_address))
    }
}

'''
'''--- engine-types/Cargo.toml ---
[package]
name = "aurora-engine-types"
version = "1.0.0"
authors = ["NEAR <hello@near.org>"]
edition = "2018"
description = ""
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false
autobenches = false

[dependencies]
borsh = { version = "0.8.2", default-features = false }
ethabi = { git = "https://github.com/darwinia-network/ethabi", branch = "xavier-no-std", default-features = false }
hex = { version = "0.4", default-features = false, features = ["alloc"] }
primitive-types = { version = "0.10.0", default-features = false, features = ["rlp"] }
sha3 = { version = "0.9.1", default-features = false }
# getrandom = { version = "0.2", features = ["js"] }

[features]
# default = ["std"]
# std = ["primitive-types/std"]

'''
'''--- engine-types/src/account_id.rs ---
//! Guarantees all properly constructed AccountId's are valid for the NEAR network.
//!
//! Inpired by: https://github.com/near/nearcore/tree/master/core/account-id

use crate::{fmt, str, str::FromStr, Box, String, TryFrom, Vec};
use borsh::{BorshDeserialize, BorshSerialize};

pub const MIN_ACCOUNT_ID_LEN: usize = 2;
pub const MAX_ACCOUNT_ID_LEN: usize = 64;

/// Account identifier.
///
/// This guarantees all properly constructed AccountId's are valid for the NEAR network.
#[derive(
    BorshSerialize, BorshDeserialize, Default, Eq, Ord, Hash, Clone, Debug, PartialEq, PartialOrd,
)]
pub struct AccountId(Box<str>);

impl AccountId {
    pub fn new(account_id: &str) -> Result<Self, ParseAccountError> {
        Self::validate(account_id)?;
        Ok(Self(account_id.into()))
    }

    pub fn as_bytes(&self) -> &[u8] {
        self.as_ref().as_bytes()
    }

    pub fn validate(account_id: &str) -> Result<(), ParseAccountError> {
        if account_id.len() < MIN_ACCOUNT_ID_LEN {
            Err(ParseAccountError::TooShort)
        } else if account_id.len() > MAX_ACCOUNT_ID_LEN {
            Err(ParseAccountError::TooLong)
        } else {
            // Adapted from https://github.com/near/near-sdk-rs/blob/fd7d4f82d0dfd15f824a1cf110e552e940ea9073/near-sdk/src/environment/env.rs#L819

            // NOTE: We don't want to use Regex here, because it requires extra time to compile it.
            // The valid account ID regex is /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/
            // Instead the implementation is based on the previous character checks.

            // We can safely assume that last char was a separator.
            let mut last_char_is_separator = true;

            for c in account_id.bytes() {
                let current_char_is_separator = match c {
                    b'a'..=b'z' | b'0'..=b'9' => false,
                    b'-' | b'_' | b'.' => true,
                    _ => {
                        return Err(ParseAccountError::Invalid);
                    }
                };
                if current_char_is_separator && last_char_is_separator {
                    return Err(ParseAccountError::Invalid);
                }
                last_char_is_separator = current_char_is_separator;
            }

            (!last_char_is_separator)
                .then(|| ())
                .ok_or(ParseAccountError::Invalid)
        }
    }

    pub fn is_top_level_account_id(&self) -> bool {
        self.0.len() >= MIN_ACCOUNT_ID_LEN
            && self.0.len() <= MAX_ACCOUNT_ID_LEN
            && self.as_ref() != "system"
            && !self.as_ref().contains('.')
    }

    /// Returns true if the signer_id can create a direct sub-account with the given account Id.
    pub fn is_sub_account_of(&self, parent_account_id: &AccountId) -> bool {
        if parent_account_id.0.len() >= self.0.len() {
            return false;
        }
        // Will not panic, since valid account id is utf-8 only and the length is checked above.
        // e.g. when `near` creates `aa.near`, it splits into `aa.` and `near`
        let (prefix, suffix) = self.0.split_at(self.0.len() - parent_account_id.0.len());

        prefix.find('.') == Some(prefix.len() - 1) && suffix == parent_account_id.as_ref()
    }
}

impl TryFrom<String> for AccountId {
    type Error = ParseAccountError;

    fn try_from(account_id: String) -> Result<Self, Self::Error> {
        AccountId::new(&account_id)
    }
}

impl TryFrom<&[u8]> for AccountId {
    type Error = ParseAccountError;

    fn try_from(account_id: &[u8]) -> Result<Self, Self::Error> {
        let account_id = str::from_utf8(account_id).map_err(|_| ParseAccountError::Invalid)?;
        AccountId::new(account_id)
    }
}

impl TryFrom<Vec<u8>> for AccountId {
    type Error = ParseAccountError;

    fn try_from(account_id: Vec<u8>) -> Result<Self, Self::Error> {
        AccountId::try_from(&account_id[..])
    }
}

impl FromStr for AccountId {
    type Err = ParseAccountError;

    fn from_str(account_id: &str) -> Result<Self, Self::Err> {
        Self::validate(account_id)?;
        Ok(Self(account_id.into()))
    }
}

impl From<AccountId> for String {
    fn from(account_id: AccountId) -> Self {
        account_id.0.into_string()
    }
}

impl fmt::Display for AccountId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<AccountId> for Box<str> {
    fn from(value: AccountId) -> Box<str> {
        value.0
    }
}

impl From<AccountId> for Vec<u8> {
    fn from(account_id: AccountId) -> Vec<u8> {
        account_id.as_bytes().to_vec()
    }
}

impl<T: ?Sized> AsRef<T> for AccountId
where
    Box<str>: AsRef<T>,
{
    fn as_ref(&self) -> &T {
        self.0.as_ref()
    }
}

/// A list of errors that occur when parsing an invalid Account ID.
#[derive(Eq, Hash, Clone, Debug, PartialEq)]
pub enum ParseAccountError {
    TooLong,
    TooShort,
    Invalid,
}

impl AsRef<[u8]> for ParseAccountError {
    fn as_ref(&self) -> &[u8] {
        match self {
            ParseAccountError::TooLong => b"ERR_ACCOUNT_ID_TO_LONG",
            ParseAccountError::TooShort => b"ERR_ACCOUNT_ID_TO_SHORT",
            ParseAccountError::Invalid => b"ERR_ACCOUNT_ID_TO_INVALID",
        }
    }
}

impl fmt::Display for ParseAccountError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let msg = String::from_utf8(self.as_ref().to_vec()).unwrap();
        write!(f, "{}", msg)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn is_implicit(account_id: &str) -> bool {
        account_id.len() == 64
            && account_id
                .as_bytes()
                .iter()
                .all(|b| matches!(b, b'a'..=b'f' | b'0'..=b'9'))
    }

    pub const OK_ACCOUNT_IDS: [&str; 24] = [
        "aa",
        "a-a",
        "a-aa",
        "100",
        "0o",
        "com",
        "near",
        "bowen",
        "b-o_w_e-n",
        "b.owen",
        "bro.wen",
        "a.ha",
        "a.b-a.ra",
        "system",
        "over.9000",
        "google.com",
        "illia.cheapaccounts.near",
        "0o0ooo00oo00o",
        "alex-skidanov",
        "10-4.8-2",
        "b-o_w_e-n",
        "no_lols",
        "0123456789012345678901234567890123456789012345678901234567890123",
        // Valid, but can't be created
        "near.a",
    ];

    pub const BAD_ACCOUNT_IDS: [&str; 24] = [
        "a",
        "A",
        "Abc",
        "-near",
        "near-",
        "-near-",
        "near.",
        ".near",
        "near@",
        "@near",
        "неар",
        "@@@@@",
        "0__0",
        "0_-_0",
        "0_-_0",
        "..",
        "a..near",
        "nEar",
        "_bowen",
        "hello world",
        "abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz",
        "01234567890123456789012345678901234567890123456789012345678901234",
        // `@` separators are banned now
        "some-complex-address@gmail.com",
        "sub.buy_d1gitz@atata@b0-rg.c_0_m",
    ];

    #[test]
    fn test_is_valid_account_id() {
        for account_id in OK_ACCOUNT_IDS.iter().cloned() {
            if let Err(err) = AccountId::validate(account_id) {
                panic!("Valid account id {:?} marked invalid: {}", account_id, err);
            }
        }

        for account_id in BAD_ACCOUNT_IDS.iter().cloned() {
            if let Ok(_) = AccountId::validate(account_id) {
                panic!("Valid account id {:?} marked valid", account_id);
            }
        }
    }

    #[test]
    fn test_is_valid_top_level_account_id() {
        let ok_top_level_account_ids = &[
            "aa",
            "a-a",
            "a-aa",
            "100",
            "0o",
            "com",
            "near",
            "bowen",
            "b-o_w_e-n",
            "0o0ooo00oo00o",
            "alex-skidanov",
            "b-o_w_e-n",
            "no_lols",
            "0123456789012345678901234567890123456789012345678901234567890123",
        ];
        for account_id in ok_top_level_account_ids {
            assert!(
                account_id
                    .parse::<AccountId>()
                    .map_or(false, |account_id| account_id.is_top_level_account_id()),
                "Valid top level account id {:?} marked invalid",
                account_id
            );
        }

        let bad_top_level_account_ids = &[
            "near.a",
            "b.owen",
            "bro.wen",
            "a.ha",
            "a.b-a.ra",
            "some-complex-address@gmail.com",
            "sub.buy_d1gitz@atata@b0-rg.c_0_m",
            "over.9000",
            "google.com",
            "illia.cheapaccounts.near",
            "10-4.8-2",
            "a",
            "A",
            "Abc",
            "-near",
            "near-",
            "-near-",
            "near.",
            ".near",
            "near@",
            "@near",
            "неар",
            "@@@@@",
            "0__0",
            "0_-_0",
            "0_-_0",
            "..",
            "a..near",
            "nEar",
            "_bowen",
            "hello world",
            "abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz",
            "01234567890123456789012345678901234567890123456789012345678901234",
            // Valid regex and length, but reserved
            "system",
        ];
        for account_id in bad_top_level_account_ids {
            assert!(
                !account_id
                    .parse::<AccountId>()
                    .map_or(false, |account_id| account_id.is_top_level_account_id()),
                "Invalid top level account id {:?} marked valid",
                account_id
            );
        }
    }

    #[test]
    fn test_is_valid_sub_account_id() {
        let ok_pairs = &[
            ("test", "a.test"),
            ("test-me", "abc.test-me"),
            ("gmail.com", "abc.gmail.com"),
            ("gmail.com", "abc-lol.gmail.com"),
            ("gmail.com", "abc_lol.gmail.com"),
            ("gmail.com", "bro-abc_lol.gmail.com"),
            ("g0", "0g.g0"),
            ("1g", "1g.1g"),
            ("5-3", "4_2.5-3"),
        ];
        for (signer_id, sub_account_id) in ok_pairs {
            assert!(
                matches!(
                    (signer_id.parse::<AccountId>(), sub_account_id.parse::<AccountId>()),
                    (Ok(signer_id), Ok(sub_account_id)) if sub_account_id.is_sub_account_of(&signer_id)
                ),
                "Failed to create sub-account {:?} by account {:?}",
                sub_account_id,
                signer_id
            );
        }

        let bad_pairs = &[
            ("test", ".test"),
            ("test", "test"),
            ("test", "a1.a.test"),
            ("test", "est"),
            ("test", ""),
            ("test", "st"),
            ("test5", "ббб"),
            ("test", "a-test"),
            ("test", "etest"),
            ("test", "a.etest"),
            ("test", "retest"),
            ("test-me", "abc-.test-me"),
            ("test-me", "Abc.test-me"),
            ("test-me", "-abc.test-me"),
            ("test-me", "a--c.test-me"),
            ("test-me", "a_-c.test-me"),
            ("test-me", "a-_c.test-me"),
            ("test-me", "_abc.test-me"),
            ("test-me", "abc_.test-me"),
            ("test-me", "..test-me"),
            ("test-me", "a..test-me"),
            ("gmail.com", "a.abc@gmail.com"),
            ("gmail.com", ".abc@gmail.com"),
            ("gmail.com", ".abc@gmail@com"),
            ("gmail.com", "abc@gmail@com"),
            ("test", "a@test"),
            ("test_me", "abc@test_me"),
            ("gmail.com", "abc@gmail.com"),
            ("gmail@com", "abc.gmail@com"),
            ("gmail.com", "abc-lol@gmail.com"),
            ("gmail@com", "abc_lol.gmail@com"),
            ("gmail@com", "bro-abc_lol.gmail@com"),
            (
                "gmail.com",
                "123456789012345678901234567890123456789012345678901234567890@gmail.com",
            ),
            (
                "123456789012345678901234567890123456789012345678901234567890",
                "1234567890.123456789012345678901234567890123456789012345678901234567890",
            ),
            ("aa", "ъ@aa"),
            ("aa", "ъ.aa"),
        ];
        for (signer_id, sub_account_id) in bad_pairs {
            assert!(
                !matches!(
                    (signer_id.parse::<AccountId>(), sub_account_id.parse::<AccountId>()),
                    (Ok(signer_id), Ok(sub_account_id)) if sub_account_id.is_sub_account_of(&signer_id)
                ),
                "Invalid sub-account {:?} created by account {:?}",
                sub_account_id,
                signer_id
            );
        }
    }

    #[test]
    fn test_is_account_id_64_len_hex() {
        let valid_64_len_hex_account_ids = &[
            "0000000000000000000000000000000000000000000000000000000000000000",
            "6174617461746174617461746174617461746174617461746174617461746174",
            "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
            "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
            "20782e20662e64666420482123494b6b6c677573646b6c66676a646b6c736667",
        ];
        for valid_account_id in valid_64_len_hex_account_ids {
            assert!(
                matches!(
                    valid_account_id.parse::<AccountId>(),
                    Ok(account_id) if is_implicit(account_id.as_ref())
                ),
                "Account ID {} should be valid 64-len hex",
                valid_account_id
            );
            assert!(
                is_implicit(valid_account_id),
                "Account ID {} should be valid 64-len hex",
                valid_account_id
            );
        }

        let invalid_64_len_hex_account_ids = &[
            "000000000000000000000000000000000000000000000000000000000000000",
            "6.74617461746174617461746174617461746174617461746174617461746174",
            "012-456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
            "fffff_ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
            "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
            "00000000000000000000000000000000000000000000000000000000000000",
        ];
        for invalid_account_id in invalid_64_len_hex_account_ids {
            assert!(
                !matches!(
                    invalid_account_id.parse::<AccountId>(),
                    Ok(account_id) if is_implicit(account_id.as_ref())
                ),
                "Account ID {} should be invalid 64-len hex",
                invalid_account_id
            );
            assert!(
                !is_implicit(invalid_account_id),
                "Account ID {} should be invalid 64-len hex",
                invalid_account_id
            );
        }
    }
}

'''
'''--- engine-types/src/lib.rs ---
// #![feature(array_methods)]
#![cfg_attr(not(feature = "std"), no_std)]
// #![cfg_attr(not(feature = "std"), feature(alloc_error_handler))]
// #![cfg_attr(feature = "log", feature(panic_info_message))]

// Reexport
pub use ethabi;

pub mod account_id;
pub mod types;

mod v0 {
    #[cfg(not(feature = "std"))]
    extern crate alloc;
    #[cfg(not(feature = "std"))]
    extern crate core;

    #[cfg(not(feature = "std"))]
    pub use alloc::{
        borrow::ToOwned,
        borrow::{Cow, Cow::*},
        boxed::Box,
        collections::BTreeMap as HashMap,
        collections::BTreeMap,
        fmt, format, str,
        string::String,
        string::ToString,
        vec,
        vec::Vec,
    };
    #[cfg(not(feature = "std"))]
    pub use core::{
        cmp::Ordering, convert::TryFrom, convert::TryInto, fmt::Display, marker::PhantomData, mem,
        ops::Add, ops::Div, ops::Mul, ops::Sub,
    };
    pub use primitive_types::{H160, H256, U256};
    #[cfg(feature = "std")]
    pub use std::{
        borrow::Cow, borrow::Cow::Borrowed, borrow::ToOwned, boxed::Box, cmp::Ordering,
        collections::BTreeMap, collections::HashMap, convert::TryFrom, convert::TryInto,
        error::Error, fmt, fmt::Display, format, marker::PhantomData, mem, ops::Add, ops::Div,
        ops::Mul, ops::Sub, str, string::String, string::ToString, vec, vec::Vec,
    };
}

pub use v0::*;

/// See: https://ethereum-magicians.org/t/increasing-address-size-from-20-to-32-bytes/5485
pub type Address = H160;

#[allow(non_snake_case, dead_code)]
// Gets around the fact that you can't contract pub fields with types.
pub const fn Address(input: [u8; 20]) -> Address {
    H160(input)
}

'''
'''--- engine-types/src/types.rs ---
use crate::{str, vec, Add, Address, Display, Div, Mul, String, Sub, Vec, U256};
use borsh::{BorshDeserialize, BorshSerialize};

use crate::fmt::Formatter;

// TODO: introduce new Balance type for more strict typing
pub type Balance = u128;
pub type RawAddress = [u8; 20];
pub type RawU256 = [u8; 32];
// Big-endian large integer type.
pub type RawH256 = [u8; 32]; // Unformatted binary data of fixed length.

// TODO: introduce new type. Add encode/decode/validation methods
pub type EthAddress = [u8; 20];
pub type StorageUsage = u64;
/// Wei compatible Borsh-encoded raw value to attach an ETH balance to the transaction
pub type WeiU256 = [u8; 32];

#[derive(Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
/// Near gas type which wraps an underlying u64.
pub struct NearGas(u64);

impl Sub<NearGas> for NearGas {
    type Output = NearGas;

    fn sub(self, rhs: NearGas) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Display for NearGas {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl NearGas {
    /// Constructs a new `NearGas` with a given u64 value.
    pub const fn new(gas: u64) -> NearGas {
        Self(gas)
    }

    /// Consumes `NearGas` and returns the underlying type.
    pub fn into_u64(self) -> u64 {
        self.0
    }
}

#[derive(Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
/// Ethereum gas type which wraps an underlying u64.
pub struct EthGas(u64);

impl Display for EthGas {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl EthGas {
    /// Constructs a new `EthGas` with a given u64 value.
    pub const fn new(gas: u64) -> EthGas {
        Self(gas)
    }

    /// Consumes `EthGas` and returns the underlying type.
    pub fn into_u64(self) -> u64 {
        self.0
    }
}

impl Add<EthGas> for EthGas {
    type Output = EthGas;

    fn add(self, rhs: EthGas) -> Self::Output {
        EthGas(self.0 + rhs.0)
    }
}

impl Div<usize> for EthGas {
    type Output = EthGas;

    fn div(self, rhs: usize) -> Self::Output {
        EthGas(self.0 / rhs as u64)
    }
}

impl Mul<EthGas> for u32 {
    type Output = EthGas;

    fn mul(self, rhs: EthGas) -> Self::Output {
        EthGas(self as u64 * rhs.0)
    }
}

impl Mul<u32> for EthGas {
    type Output = EthGas;

    fn mul(self, rhs: u32) -> Self::Output {
        EthGas(self.0 * rhs as u64)
    }
}

impl Mul<usize> for EthGas {
    type Output = EthGas;

    fn mul(self, rhs: usize) -> Self::Output {
        EthGas(self.0 * rhs as u64)
    }
}

impl Mul<EthGas> for u64 {
    type Output = EthGas;

    fn mul(self, rhs: EthGas) -> Self::Output {
        EthGas(self * rhs.0)
    }
}

#[derive(
    Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, BorshSerialize, BorshDeserialize,
)]
/// Engine `fee` type which wraps an underlying u128.
pub struct Fee(u128);

impl Display for Fee {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl Fee {
    /// Constructs a new `Fee` with a given u128 value.
    pub const fn new(fee: u128) -> Fee {
        Self(fee)
    }

    /// Consumes `Fee` and returns the underlying type.
    pub fn into_u128(self) -> u128 {
        self.0
    }
}

impl Add<Fee> for Fee {
    type Output = Fee;

    fn add(self, rhs: Fee) -> Self::Output {
        Fee(self.0 + rhs.0)
    }
}

impl From<u128> for Fee {
    fn from(fee: u128) -> Self {
        Self(fee)
    }
}

/// Selector to call mint function in ERC 20 contract
///
/// keccak("mint(address,uint256)".as_bytes())[..4];
#[allow(dead_code)]
pub const ERC20_MINT_SELECTOR: &[u8] = &[64, 193, 15, 25];

#[derive(Debug)]
pub enum AddressValidationError {
    FailedDecodeHex,
    IncorrectLength,
}

impl AsRef<[u8]> for AddressValidationError {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::FailedDecodeHex => b"FAILED_DECODE_ETH_ADDRESS",
            Self::IncorrectLength => b"ETH_WRONG_ADDRESS_LENGTH",
        }
    }
}

/// Validate Ethereum address from string and return Result data EthAddress or Error data
pub fn validate_eth_address(address: String) -> Result<EthAddress, AddressValidationError> {
    let data = hex::decode(address).map_err(|_| AddressValidationError::FailedDecodeHex)?;
    if data.len() != 20 {
        return Err(AddressValidationError::IncorrectLength);
    }
    let mut result = [0u8; 20];
    result.copy_from_slice(&data);
    Ok(result)
}

/// Newtype to distinguish balances (denominated in Wei) from other U256 types.
#[derive(Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
pub struct Wei(U256);

impl Wei {
    const ETH_TO_WEI: U256 = U256([1_000_000_000_000_000_000, 0, 0, 0]);

    pub const fn zero() -> Self {
        Self(U256([0, 0, 0, 0]))
    }

    pub const fn new(amount: U256) -> Self {
        Self(amount)
    }

    // Purposely not implementing `From<u64>` because I want the call site to always
    // say `Wei::<something>`. If `From` is implemented then the caller might write
    // `amount.into()` without thinking too hard about the units. Explicitly writing
    // `Wei` reminds the developer to think about whether the amount they enter is really
    // in units of `Wei` or not.
    pub const fn new_u64(amount: u64) -> Self {
        Self(U256([amount, 0, 0, 0]))
    }

    pub fn from_eth(amount: U256) -> Option<Self> {
        amount.checked_mul(Self::ETH_TO_WEI).map(Self)
    }

    pub fn to_bytes(self) -> [u8; 32] {
        u256_to_arr(&self.0)
    }

    pub fn is_zero(&self) -> bool {
        self.0.is_zero()
    }

    pub fn raw(self) -> U256 {
        self.0
    }

    pub fn checked_sub(self, rhs: Self) -> Option<Self> {
        self.0.checked_sub(rhs.0).map(Self)
    }

    pub fn checked_add(self, rhs: Self) -> Option<Self> {
        self.0.checked_add(rhs.0).map(Self)
    }

    /// Try convert U256 to u128 with checking overflow.
    /// NOTICE: Error can contain only overflow
    pub fn try_into_u128(self) -> Result<u128, error::BalanceOverflowError> {
        use crate::TryInto;
        self.0.try_into().map_err(|_| error::BalanceOverflowError)
    }
}

impl Display for Wei {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl Add<Self> for Wei {
    type Output = Wei;

    fn add(self, rhs: Self) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub<Self> for Wei {
    type Output = Wei;

    fn sub(self, rhs: Self) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

/// Type casting from Wei compatible Borsh-encoded raw value into the Wei value, to attach an ETH balance to the transaction
impl From<WeiU256> for Wei {
    fn from(value: WeiU256) -> Self {
        Wei(U256::from_big_endian(&value))
    }
}

pub const STORAGE_PRICE_PER_BYTE: u128 = 10_000_000_000_000_000_000;
// 1e19yN, 0.00001N
pub const ERR_FAILED_PARSE: &str = "ERR_FAILED_PARSE";
pub const ERR_INVALID_ETH_ADDRESS: &str = "ERR_INVALID_ETH_ADDRESS";

/// Internal args format for meta call.
#[derive(Debug)]
pub struct InternalMetaCallArgs {
    pub sender: Address,
    pub nonce: U256,
    pub fee_amount: Wei,
    pub fee_address: Address,
    pub contract_address: Address,
    pub value: Wei,
    pub input: Vec<u8>,
}

pub struct StorageBalanceBounds {
    pub min: Balance,
    pub max: Option<Balance>,
}

/// promise results structure
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PromiseResult {
    NotReady,
    Successful(Vec<u8>),
    Failed,
}

/// ft_resolve_transfer result of eth-connector
pub struct FtResolveTransferResult {
    pub amount: Balance,
    pub refund_amount: Balance,
}

/// Internal errors to propagate up and format in the single place.
pub enum ErrorKind {
    ArgumentParseError,
    InvalidMetaTransactionMethodName,
    InvalidMetaTransactionFunctionArg,
    InvalidEcRecoverSignature,
}

#[allow(dead_code)]
pub fn u256_to_arr(value: &U256) -> [u8; 32] {
    let mut result = [0u8; 32];
    value.to_big_endian(&mut result);
    result
}

const HEX_ALPHABET: &[u8; 16] = b"0123456789abcdef";

#[allow(dead_code)]
pub fn bytes_to_hex(v: &[u8]) -> String {
    let mut result = String::new();
    for x in v {
        result.push(HEX_ALPHABET[(x / 16) as usize] as char);
        result.push(HEX_ALPHABET[(x % 16) as usize] as char);
    }
    result
}

#[derive(Default)]
pub struct Stack<T> {
    stack: Vec<T>,
    boundaries: Vec<usize>,
}

impl<T> Stack<T> {
    pub fn new() -> Self {
        Self {
            stack: Vec::new(),
            boundaries: vec![0],
        }
    }

    pub fn enter(&mut self) {
        self.boundaries.push(self.stack.len());
    }

    pub fn commit(&mut self) {
        self.boundaries.pop().unwrap();
    }

    pub fn discard(&mut self) {
        let boundary = self.boundaries.pop().unwrap();
        self.stack.truncate(boundary);
    }

    pub fn push(&mut self, value: T) {
        self.stack.push(value);
    }

    pub fn into_vec(self) -> Vec<T> {
        self.stack
    }
}

pub fn str_from_slice(inp: &[u8]) -> &str {
    str::from_utf8(inp).unwrap()
}

pub mod error {
    use crate::{fmt, String};

    #[derive(Eq, Hash, Clone, Debug, PartialEq)]
    pub struct BalanceOverflowError;

    impl AsRef<[u8]> for BalanceOverflowError {
        fn as_ref(&self) -> &[u8] {
            b"ERR_BALANCE_OVERFLOW"
        }
    }

    impl fmt::Display for BalanceOverflowError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let msg = String::from_utf8(self.as_ref().to_vec()).unwrap();
            write!(f, "{}", msg)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hex() {
        assert_eq!(
            bytes_to_hex(&[0u8, 1u8, 255u8, 16u8]),
            "0001ff10".to_string()
        );
    }

    /// Build view of the stack. Intervals between None values are scopes.
    fn view_stack(stack: &Stack<i32>) -> Vec<Option<i32>> {
        let mut res = vec![];
        let mut pnt = 0;

        for &pos in stack.boundaries.iter() {
            while pnt < pos {
                res.push(Some(stack.stack[pnt]));
                pnt += 1;
            }
            res.push(None);
        }

        while pnt < stack.stack.len() {
            res.push(Some(stack.stack[pnt]));
            pnt += 1;
        }

        res
    }

    fn check_stack(stack: &Stack<i32>, expected: Vec<Option<i32>>) {
        if let Some(&last) = stack.boundaries.last() {
            assert!(last <= stack.stack.len());
        }
        assert_eq!(view_stack(stack), expected);
    }

    #[test]
    fn test_stack() {
        let mut stack = Stack::new(); // [ $ ]
        check_stack(&stack, vec![None]);

        stack.push(1); // [ $, 1]
        check_stack(&stack, vec![None, Some(1)]);
        stack.push(2); // [ $, 1, 2 ]
        check_stack(&stack, vec![None, Some(1), Some(2)]);
        stack.enter(); // [$, 1, 2, $]
        check_stack(&stack, vec![None, Some(1), Some(2), None]);
        stack.push(3); // [$, 1, 2, $, 3]
        check_stack(&stack, vec![None, Some(1), Some(2), None, Some(3)]);
        stack.discard(); // [$, 1, 2]
        check_stack(&stack, vec![None, Some(1), Some(2)]);
        stack.enter();
        check_stack(&stack, vec![None, Some(1), Some(2), None]);
        stack.push(4); // [$, 1, 2, $, 4]
        check_stack(&stack, vec![None, Some(1), Some(2), None, Some(4)]);
        stack.enter(); // [$, 1, 2, $, 4, $]
        check_stack(&stack, vec![None, Some(1), Some(2), None, Some(4), None]);
        stack.push(5); // [$, 1, 2, $, 4, $, 5]
        check_stack(
            &stack,
            vec![None, Some(1), Some(2), None, Some(4), None, Some(5)],
        );
        stack.commit(); // [$, 1, 2, $, 4, 5]
        check_stack(&stack, vec![None, Some(1), Some(2), None, Some(4), Some(5)]);
        stack.discard(); // [$, 1, 2]
        check_stack(&stack, vec![None, Some(1), Some(2)]);
        stack.push(6); // [$, 1, 2, 6]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6)]);
        stack.enter(); // [$, 1, 2, 6, $]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6), None]);
        stack.enter(); // [$, 1, 2, 6, $, $]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6), None, None]);
        stack.enter(); // [$, 1, 2, 6, $, $, $]
        check_stack(
            &stack,
            vec![None, Some(1), Some(2), Some(6), None, None, None],
        );
        stack.commit(); // [$, 1, 2, 6, $, $]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6), None, None]);
        stack.discard(); // [$, 1, 2, 6, $]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6), None]);
        stack.push(7); // [$, 1, 2, 6, $, 7]

        assert_eq!(stack.into_vec(), vec![1, 2, 6, 7]);
    }

    #[test]
    fn test_wei_from_u64() {
        let x: u64 = rand::random();
        assert_eq!(Wei::new_u64(x).raw().as_u64(), x);
    }

    #[test]
    fn test_wei_from_eth() {
        let eth_amount: u64 = rand::random();
        let wei_amount = U256::from(eth_amount) * U256::from(10).pow(18.into());
        assert_eq!(Wei::from_eth(eth_amount.into()), Some(Wei::new(wei_amount)));
    }

    #[test]
    fn test_fee_add() {
        let fee = Fee::new(100);
        assert_eq!(fee + fee, Fee::new(200));
        assert_eq!(fee.add(200.into()), Fee::new(300));
    }

    #[test]
    fn test_fee_from() {
        let fee = Fee::new(100);
        let fee2 = Fee::from(100u128);
        assert_eq!(fee, fee2);
        let res: u128 = fee.into_u128();
        assert_eq!(res, 100);
    }
}

'''
'''--- tests/main.rs ---

'''