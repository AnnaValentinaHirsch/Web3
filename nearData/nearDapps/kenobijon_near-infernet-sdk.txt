*GitHub Repository "kenobijon/near-infernet-sdk"*

'''--- Cargo.toml ---
[package]
name = "near-infernet-sdk"
version = "1.0.0"
authors = ["Near Foundation <ken@near.foundation>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "4.1.1", features = ["unstable"] }
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = ["sandbox-rs"]

'''
'''--- README.md ---
# NEAR Infernet SDK Contract

The smart contract exposes two methods to enable storing and retrieving a greeting in the NEAR network.

```rust
const DEFAULT_GREETING: &str = "Hello";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    greeting: String,
}

impl Default for Contract {
    fn default() -> Self {
        Self { greeting: DEFAULT_GREETING.to_string() }
    }
}

#[near_bindgen]
impl Contract {
    // Public: Returns the stored greeting, defaulting to 'Hello'
    pub fn get_greeting(&self) -> String {
        return self.greeting.clone();
    }

    // Public: Takes a greeting, such as 'howdy', and records it
    pub fn set_greeting(&mut self, greeting: String) {
        // Record a log permanently to the blockchain!
        log!("Saving greeting {}", greeting);
        self.greeting = greeting;
    }
}
```

<br />

# Quickstart

1. Make sure you have installed [rust](https://rust.org/).
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<br />

## 1. Build, Test and Deploy
To build the contract you can execute the `./build.sh` script, which will in turn run:

```bash
rustup target add wasm32-unknown-unknown
cargo build --target wasm32-unknown-unknown --release
```

Then, run the `./deploy.sh` script, which will in turn run:

```bash
near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/hello_near.wasm
```

the command [`near dev-deploy`](https://docs.near.org/tools/near-cli#near-dev-deploy) automatically creates an account in the NEAR testnet, and deploys the compiled contract on it.

Once finished, check the `./neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

<br />

## 2. Retrieve the Greeting

`get_greeting` is a read-only method (aka `view` method).

`View` methods can be called for **free** by anyone, even people **without a NEAR account**!

```bash
# Use near-cli to get the greeting
near view <dev-account> get_greeting
```

<br />

## 3. Store a New Greeting
`set_greeting` changes the contract's state, for which it is a `change` method.

`Change` methods can only be invoked using a NEAR account, since the account needs to pay GAS for the transaction. In this case, we are asking the account we created in step 1 to sign the transaction.

```bash
# Use near-cli to set a new greeting
near call <dev-account> set_greeting '{"greeting":"howdy"}' --accountId <dev-account>
```

**Tip:** If you would like to call `set_greeting` using your own account, first login into NEAR using:

```bash
# Use near-cli to login your NEAR account
near login
```

and then use the logged account to sign the transaction: `--accountId <your-account>`.
'''
'''--- build.sh ---
#!/bin/sh
rustup target add wasm32-unknown-unknown
cargo build --target wasm32-unknown-unknown --release
'''
'''--- deploy.sh ---
#!/bin/sh
near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/near-infernet-sdk.wasm
'''
'''--- rust-toolchain.toml ---
[toolchain]
channel = "1.69"

'''
'''--- sandbox-rs/Cargo.toml ---
[package]
name = "sandbox"
version = "1.0.0"
publish = false
edition = "2021"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.6.0"
pkg-config = "0.3.1"
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types

[[example]]
name = "sandbox"
path = "src/tests.rs"

'''
'''--- sandbox-rs/src/tests.rs ---
use std::{env, fs};
use near_units::parse_near;
use serde_json::json;
use workspaces::{Account, Contract};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let wasm_arg: &str = &(env::args().nth(1).unwrap());
    let wasm_filepath = fs::canonicalize(env::current_dir()?.join(wasm_arg))?;

    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(wasm_filepath)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let account = worker.dev_create_account().await?;
    let alice = account
        .create_subaccount( "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // begin tests
    test_default_message(&alice, &contract).await?;
    test_changes_message(&alice, &contract).await?;
    Ok(())
}

async fn test_default_message(
    user: &Account,
    contract: &Contract,
) -> anyhow::Result<()> {
    let greeting: String = user
        .call( contract.id(), "get_greeting")
        .args_json(json!({}))
        .transact()
        .await?
        .json()?;

    assert_eq!(greeting, "Hello".to_string());
    println!("      Passed ✅ gets default greeting");
    Ok(())
}

async fn test_changes_message(
    user: &Account,
    contract: &Contract,
) -> anyhow::Result<()> {
    user.call(contract.id(), "set_greeting")
        .args_json(json!({"greeting": "Howdy"}))
        .transact()
        .await?
        .into_result()?;

    let greeting: String = user
        .call(contract.id(), "get_greeting")
        .args_json(json!({}))
        .transact()
        .await?
        .json()?;

    assert_eq!(greeting, "Howdy".to_string());
    println!("      Passed ✅ changes greeting");
    Ok(())
}
'''
'''--- src/consumer/base.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::env;
use near_sdk::near_bindgen;

use crate::Coordinator;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct BaseConsumer {
    coordinator: Coordinator,
}

#[near_bindgen]
impl BaseConsumer {
    pub fn new(coordinator: String) -> Self {
        Self {
            coordinator: Coordinator::new(),
        }
    }

    pub fn raw_receive_compute(
        &self,
        subscription_id: u32,
        interval: u32,
        redundancy: u16,
        node: String,
        input: Vec<u8>,
        output: Vec<u8>,
        proof: Vec<u8>,
    ) {
        // Ensure caller is coordinator
        // assert_eq!(
        //     env::predecessor_account_id().to_string(),
        //     self.coordinator,
        //     "NotCoordinator"
        // );

        // Call internal receive function, since caller is validated
        self._receive_compute(
            subscription_id,
            interval,
            redundancy,
            node,
            input,
            output,
            proof,
        );
    }

    #[private]
    fn _receive_compute(
        &self,
        subscription_id: u32,
        interval: u32,
        redundancy: u16,
        node: String,
        input: Vec<u8>,
        output: Vec<u8>,
        proof: Vec<u8>,
    ) {
        // Handle compute response logic here
    }
}

'''
'''--- src/consumer/callback.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::env;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId, Balance, PanicOnDefault, Promise};

use crate::Coordinator;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct CallbackConsumer {
    coordinator: Coordinator,
}

impl CallbackConsumer {
    pub fn new(coordinator: AccountId) -> Self {
        Self {
            coordinator: Coordinator::new(),
        }
    }

    pub fn request_compute(
        &mut self,
        container_id: String,
        inputs: Vec<u8>,
        max_gas_price: U128,
        max_gas_limit: u32,
        redundancy: u16,
    ) -> u32 {
        let period: u32 = 0;
        let frequency: u32 = 1;
        let subscription_id = self.coordinator.create_subscription(
            container_id,
            inputs,
            max_gas_price,
            max_gas_limit,
            frequency,
            period,
            redundancy,
        );

        subscription_id
    }
}

'''
'''--- src/consumer/mod.rs ---
mod base;
mod callback;
mod subscription;

'''
'''--- src/consumer/subscription.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault, Promise};

use crate::consumer::base::BaseConsumer;
use crate::coordinator::Coordinator;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Subscription {
    coordinator: BaseConsumer,
}

#[near_bindgen]
impl Subscription {
    pub fn new(coordinator: String) -> Self {
        Self {
            coordinator: BaseConsumer::new(coordinator),
        }
    }

    // View function to broadcast dynamic container inputs to off-chain Infernet nodes
    pub fn get_container_inputs(
        &self,
        subscription_id: u32,
        interval: u32,
        timestamp: u32,
        caller: AccountId,
    ) -> Vec<u8> {
        // TODO: Implement getContainerInputs logic
        Vec::new()
    }

    #[private]
    fn create_compute_subscription(
        &self,
        container_id: String,
        max_gas_price: U128,
        max_gas_limit: u32,
        frequency: u32,
        period: u32,
        redundancy: u16,
    ) -> u32 {
        // TODO: Implement _createComputeSubscription logic
        0
    }

    #[private]
    fn cancel_compute_subscription(&self, subscription_id: u32) {
        // TODO: Implement _cancelComputeSubscription logic
    }
}

'''
'''--- src/coordinator.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::env;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

use near_sdk::{ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault};

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Subscription {
    active_at: u32,
    owner: AccountId,
    max_gas_price: u128,
    redundancy: u16,
    max_gas_limit: u32,
    frequency: u32,
    period: u32,
    container_id: String,
    inputs: Vec<u8>,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Coordinator {
    id: u32,
    subscriptions: LookupMap<u32, Subscription>,
    redundancy_count: LookupMap<Vec<u8>, u16>,
}

// #[ext_contract]
// pub trait BaseConsumer {
//     fn raw_receive_compute(
//         subscription_id: u32,
//         interval: u32,
//         num_redundant_deliveries: u16,
//         sender: AccountId,
//         input: Vec<u8>,
//         output: Vec<u8>,
//         proof: Vec<u8>,
//     );
// }

#[near_bindgen]
impl Coordinator {
    #[init]
    pub fn new() -> Self {
        Self {
            id: 0,
            subscriptions: LookupMap::new(b"s".to_vec()),
            redundancy_count: LookupMap::new(b"r".to_vec()),
        }
    }

    pub fn create_subscription(
        &mut self,
        container_id: String,
        inputs: Vec<u8>,
        max_gas_price: U128,
        max_gas_limit: u32,
        frequency: u32,
        period: u32,
        redundancy: u16,
    ) -> u32 {
        let subscription_id = self.id;
        self.id += 1;

        let active_at = if period == 0 {
            env::block_timestamp() as u32
        } else {
            env::block_timestamp() as u32 + period
        };

        let owner = env::predecessor_account_id();

        let subscription = Subscription {
            active_at,
            owner,
            max_gas_price: max_gas_price.into(),
            redundancy,
            max_gas_limit,
            frequency,
            period,
            container_id,
            inputs,
        };

        self.subscriptions.insert(&subscription_id, &subscription);

        subscription_id
    }

    pub fn cancel_subscription(&mut self, subscription_id: u32) {
        let subscription = self
            .subscriptions
            .get(&subscription_id)
            .expect("Subscription not found");

        assert_eq!(
            subscription.owner,
            env::predecessor_account_id(),
            "Not subscription owner"
        );

        self.subscriptions.remove(&subscription_id);
    }

    pub fn deliver_compute(
        &mut self,
        subscription_id: u32,
        delivery_interval: u32,
        input: Vec<u8>,
        output: Vec<u8>,
        proof: Vec<u8>,
    ) {
        let subscription = self
            .subscriptions
            .get(&subscription_id)
            .expect("Subscription not found");

        assert_eq!(
            env::predecessor_account_id(),
            subscription.owner,
            "Not subscription owner"
        );

        let interval = self.get_subscription_interval(subscription.active_at, subscription.period);

        let key = self.get_key(subscription_id, interval);
        let num_redundant_deliveries = self.redundancy_count.get(&key).unwrap_or(0);

        assert!(
            num_redundant_deliveries < subscription.redundancy,
            "Interval completed"
        );

        self.redundancy_count
            .insert(&key, &(num_redundant_deliveries + 1));

        let sender = env::predecessor_account_id();

        let starting_gas = env::used_gas();

        // BaseConsumer::raw_receive_compute(
        //     subscription_id,
        //     delivery_interval,
        //     num_redundant_deliveries + 1,
        //     sender,
        //     input,
        //     output,
        //     proof,
        // );

        let ending_gas = env::prepaid_gas() - env::used_gas();

        let execution_cost = starting_gas - ending_gas;
        let overhead_cost = 0; // Add your overhead cost here
    }

    pub fn get_subscription_interval(&self, active_at: u32, period: u32) -> u32 {
        if period == 0 {
            return 1;
        }

        ((env::block_timestamp() as u64) - (active_at as u64) / 1) as u32
    }

    pub fn get_key(&self, subscription_id: u32, interval: u32) -> Vec<u8> {
        let mut key = subscription_id.to_be_bytes().to_vec();
        key.extend_from_slice(&interval.to_be_bytes());
        key
    }

    pub fn get_node_key(&self, node: String, subscription_id: u32, interval: u32) -> Vec<u8> {
        let mut key = node.as_bytes().to_vec();
        key.extend_from_slice(&subscription_id.to_be_bytes());
        key.extend_from_slice(&interval.to_be_bytes());
        key
    }
}

'''
'''--- src/delegator.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId};

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Delegator {
    signer: AccountId,
}

#[near_bindgen]
impl Delegator {
    #[init]
    pub fn new(signer: AccountId) -> Self {
        Self { signer }
    }

    #[private]
    pub fn update_signer(&mut self, new_signer: AccountId) {
        self.signer = new_signer;
    }

    pub fn get_signer(&self) -> AccountId {
        self.signer.clone()
    }
}

'''
'''--- src/lib.rs ---
// lib.rs

// Import NEAR SDK features
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault};

// Import other modules
mod consumer;
mod coordinator;
mod delegator;
mod manager;
mod sign_coordinator;

// Re-export structs and functions from other modules if necessary
pub use consumer::*;
pub use coordinator::*;
pub use delegator::*;
pub use manager::*;
pub use sign_coordinator::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Infernet {
    owner_id: AccountId,
    manager: manager::Manager,
    coordinator: coordinator::Coordinator,
    sign_coordinator: sign_coordinator::SignCoordinator,
}

#[near_bindgen]
impl Infernet {
    // Constructor
    #[init]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner_id: env::predecessor_account_id(),
            manager: manager::Manager::new(3600),
            coordinator: coordinator::Coordinator::new(),
            sign_coordinator: sign_coordinator::SignCoordinator::new(),
        }
    }

    // Public and private methods
    // ...

    // Methods from other modules can be included here,
    // or you can delegate to their implementations
    // in their respective modules.
}

// Include tests for this contract
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::env;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    // Function to create the VMContext
    fn set_context(predecessor: &str, amount: Balance) {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor.parse().unwrap());
        builder.attached_deposit(amount);

        testing_env!(builder.build());
    }
    // Set up the testing context and other necessary test setup
    // ...
    #[test]
    pub fn initialize() {
        let account_id: AccountId = "alice.near".parse().unwrap();

        // Set up the context for a new contract deployment
        let context = VMContextBuilder::new()
            .predecessor_account_id(account_id.clone())
            // You can add more parameters to the context as needed
            .build();

        testing_env!(context);

        // Instantiate the contract
        let contract = Infernet::new();
        assert_eq!(contract.owner_id, account_id);
        assert_eq!(contract.manager.get_cooldown(), 3600);
    }
}

'''
'''--- src/manager.rs ---
// SPDX-License-Identifier: BSD-3-Clause-Clear
// Rust Smart Contract for NEAR Protocol

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::env;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};
use std::collections::HashMap;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum NodeStatus {
    Inactive,
    Registered,
    Active,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct NodeInfo {
    pub status: NodeStatus,
    pub cooldown_start: u32,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize)]
pub struct Manager {
    cooldown: u32,
    node_info: LookupMap<AccountId, NodeInfo>,
}

impl Default for Manager {
    fn default() -> Self {
        Self {
            cooldown: 3600, // 1 hour in seconds
            node_info: LookupMap::new(b"n".to_vec()),
        }
    }
}

#[near_bindgen]
impl Manager {
    #[init]
    pub fn new(cooldown: u32) -> Self {
        Self {
            cooldown,
            node_info: LookupMap::new(b"n".to_vec()),
        }
    }

    pub fn register_node(&mut self, node: AccountId) {
        let account_id = env::predecessor_account_id();
        let mut info = self.node_info.get(&node).unwrap_or_else(|| NodeInfo {
            status: NodeStatus::Inactive,
            cooldown_start: 0,
        });

        if info.status != NodeStatus::Inactive {
            env::panic_str("NodeNotRegisterable");
        }

        info.status = NodeStatus::Registered;
        info.cooldown_start = env::block_timestamp() as u32;

        self.node_info.insert(&node, &info);
        env::log(format!("NodeRegistered: {}", node).as_bytes());
    }

    pub fn activate_node(&mut self) {
        let account_id = env::predecessor_account_id();
        let mut info = self.node_info.get(&account_id).unwrap_or_else(|| {
            env::panic_str("NodeNotActivateable");
        });

        if info.status != NodeStatus::Registered {
            env::panic_str("NodeNotActivateable");
        }

        let cooldown_end = info.cooldown_start + self.cooldown;
        if (env::block_timestamp() as u32) < cooldown_end {
            env::panic_str("CooldownActive");
        }

        info.status = NodeStatus::Active;
        info.cooldown_start = 0;

        self.node_info.insert(&account_id, &info);
        env::log(format!("NodeActivated: {}", account_id).as_bytes());
    }

    pub fn deactivate_node(&mut self) {
        let account_id = env::predecessor_account_id();
        self.node_info.remove(&account_id);
        env::log(format!("NodeDeactivated: {}", account_id).as_bytes());
    }

    pub fn get_cooldown(&self) -> u32 {
        self.cooldown
    }
}

'''
'''--- src/sign_coordinator.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::env;
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{json, to_vec};
use near_sdk::PublicKey;
use near_sdk::{ext_contract, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

use crate::coordinator;
use crate::delegator;

use coordinator::Coordinator;
use delegator::Delegator;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Subscription {
    owner: AccountId,
    active_at: u32,
    period: u32,
    frequency: u32,
    redundancy: u16,
    max_gas_price: U64,
    max_gas_limit: u32,
    container_id: String,
    inputs: Base64VecU8,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct SignCoordinator {
    max_subscriber_nonce: LookupMap<AccountId, u32>,
    delegate_created_ids: LookupMap<Vec<u8>, u32>,
    subscriptions: LookupMap<u32, Subscription>,
}

// impl Delegator for SignCoordinator {
//     fn signer(&self) -> AccountId {
//         env::predecessor_account_id()
//     }
// }

#[near_bindgen]
impl SignCoordinator {
    #[init]
    pub fn new() -> Self {
        Self {
            max_subscriber_nonce: LookupMap::new(b"m".to_vec()),
            delegate_created_ids: LookupMap::new(b"d".to_vec()),
            subscriptions: LookupMap::new(b"s".to_vec()),
        }
    }

    #[payable]
    pub fn create_subscription_delegate(
        &mut self,
        nonce: u32,
        expiry: u32,
        sub: Subscription,
        v: u8,
        r: Vec<u8>,
        s: Vec<u8>,
    ) -> PromiseOrValue<(u32, bool)> {
        // Check if subscription already exists via delegate-created lookup table
        let key = env::sha256(&to_vec(&(sub.owner.clone(), nonce)).unwrap());
        if let Some(subscription_id) = self.delegate_created_ids.get(&key) {
            return PromiseOrValue::Value((subscription_id, true));
        }

        // Else, if subscription does not exist
        // First, verify that signature has not expired
        if env::block_timestamp() >= expiry.into() {
            env::panic_str("SignatureExpired");
        }

        // Generate EIP-712 data
        let digest = env::sha256(
            &to_vec(&json!({
                "nonce": nonce,
                "expiry": expiry,
                "sub": sub,
            }))
            .unwrap(),
        );

        // Get recovered signer from data
        let recovered_signer = env::ecrecover(&digest, &s, v, false).unwrap();
        let key_slice = &recovered_signer[..];
        let recovered_pk = PublicKey::try_from_slice(key_slice).expect("Invalid public key format");

        let delegated_signer = env::signer_account_pk();

        // pub fn ecrecover(hash: &[u8], signature: &[u8], v: u8, malleability_flag: bool) -> Option<[u8; 64]>

        // let delegated_signer = Delegator::get_signer(&self);

        // Verify signatures (recovered_signer should equal delegated_signer)
        if recovered_pk != delegated_signer {
            env::panic_str("SignerMismatch");
        }

        // By this point, the signer is verified and a net-new subscription can be created
        // Assign new subscription id
        // let subscription_id = self.subscriptions.len() as u32;
        let subscription_id = 0;

        // Store provided subscription as-is
        self.subscriptions.insert(&subscription_id, &sub);

        // Update delegate-created ID lookup table
        self.delegate_created_ids.insert(&key, &subscription_id);

        // Emit new subscription
        env::log(format!("SubscriptionCreated: {}", subscription_id).as_bytes());

        // Update max known subscriber nonce (useful for off-chain signing utilities to prevent nonce-collision)
        if nonce > self.max_subscriber_nonce.get(&sub.owner).unwrap_or(0) {
            self.max_subscriber_nonce.insert(&sub.owner, &nonce);
        }

        // Explicitly return subscriptionId
        PromiseOrValue::Value((subscription_id, false))
    }

    pub fn deliver_compute_delegatee(
        &mut self,
        nonce: u32,
        expiry: u32,
        sub: Subscription,
        v: u8,
        r: Vec<u8>,
        s: Vec<u8>,
        delivery_interval: u32,
        input: Base64VecU8,
        output: Base64VecU8,
        proof: Base64VecU8,
    ) {
        // Create subscriptionId via delegatee creation + or collect if subscription already exists
        // let near_sdk::PromiseOrValue::Value(value): PromiseOrValue<(u32, bool)> = self
        //     .create_subscription_delegate(nonce, expiry, sub, v, r, s)
        //     .try_into()
        //     .unwrap();

        // unpack tuple
        // let (subscription_id, cached) = value;
        // Calculate additional gas overhead imposed from delivering container compute response via delegatee function
        // let overhead = if cached {
        //     // Subscription exists, cost to retrieve subscriptionId
        //     600
        // } else {
        //     // Subscription does not exist, cost to create subscription w/ delegatee signature
        //     91_200
        // };

        // Deliver subscription response
        // self.deliver_compute_with_overhead(
        //     subscription_id,
        //     delivery_interval,
        //     input,
        //     output,
        //     proof,
        //     overhead,
        // );
    }
}

'''
'''--- src/utils/ecdsa.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::env;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use near_sdk::BorshStorageKey;
use near_sdk::PanicOnDefault;
use near_sdk::Promise;
use near_sdk::PromiseOrValue;
use near_sdk::PublicKey;
use near_sdk::StorageUsage;
use near_sdk::Gas;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct CheckSignatureTestTemps {
    args_signature: Vec<u8>,
    encoded_calldata_args: Vec<u8>,
    signer: AccountId,
    expected: bool,
    success: [bool; 2],
    result: [Vec<u8>; 2],
    s: [u8; 4],
    recovered: AccountId,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ECDSAContract {
    check_signature_test_temps: Vector<CheckSignatureTestTemps>,
}

#[near_bindgen]
impl ECDSAContract {
    #[init]
    pub fn new() -> Self {
        Self {
            check_signature_test_temps: Vector::new(b"check_signature_test_temps".to_vec()),
        }
    }

    /*
    Below are the functions that are used to test the checkSignature function.
    - hash:  is a fixed-length, unique representation of the data that was signed. 
    - r and s: are the two components of the signature used to sign. Prove access to the private key without revealing it
    - v: is the recovery id of the signature
    */

    pub fn recover(&self, hash: Vec<u8>, signature: Vec<u8>) -> AccountId {
        
    
    }

    // Recover the signer of a message signed by a single account.
    // @param hash The hash of the message.
    // @param signature The signature of the message.
    pub fn recover(&self, hash: Vec<u8>, signature: Vec<u8>) -> AccountId {
        // TODO: Implement the function
    }

    // Recover the signer of a message signed by a single account.
    // @param hash The hash of the message.
    // @param r The r value of the signature.
    // @param vs The vs value of the signature.
    pub fn recover_with_r_vs(&self, hash: Vec<u8>, r: Vec<u8>, vs: Vec<u8>) -> AccountId {
        // TODO: Implement the function
    }

    // Recover the signer of a message signed by a single account with a given v, r, and s.
    pub fn recover_with_v_r_s(&self, hash: Vec<u8>, v: u8, r: Vec<u8>, s: Vec<u8>) -> AccountId {
        // TODO: Implement the function
    }

    // Recover the signer of a message signed by a single account with a given hash and signature.
    pub fn recover_brutalized(&self, hash: Vec<u8>, signature: Vec<u8>) -> AccountId {
        // TODO: Implement the function
    }

    pub fn recover_brutalized_with_r_vs(&self, hash: Vec<u8>, r: Vec<u8>, vs: Vec<u8>) -> AccountId {
        // TODO: Implement the function
    }

    pub fn recover_brutalized_with_v_r_s(
        &self,
        hash: Vec<u8>,
        v: u8,
        r: Vec<u8>,
        s: Vec<u8>,
    ) -> AccountId {
        // TODO: Implement the function
    }

    pub fn test_empty_calldata_helpers(&self) {
        // TODO: Implement the function
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    #[test]
    fn test_example() {
        let context = VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .build();
        testing_env!(context);
        let contract = ECDSAContract::new();
        contract.test_recover_with_v0_signature_with_short_eip2098_format();
        // TODO: Add more test cases
    }
}

'''
'''--- src/utils/events.rs ---
use near_sdk_contract_tools_macros::event;

#[event(
    crate = "crate",
    macros = "crate",
    standard = "infernet-sdk",
    version = "1.0.0"
)]
#[derive(Debug, Clone)]
pub enum InfernetEvent {
    /// Token mint event. Emitted when tokens are created and total_supply is
    /// increased.
    FtMint(Vec<FtMintData>),

    /// Token transfer event. Emitted when tokens are transferred between two
    /// accounts. No change to total_supply.
    FtTransfer(Vec<FtTransferData>),

    /// Token burn event. Emitted when tokens are burned (removed from supply).
    /// Decrease in total_supply.
    FtBurn(Vec<FtBurnData>),
}
use near_sdk::{json_types::U128, serde::Serialize, AccountId};

// TODO
/*
   /// @notice Emitted when a new subscription is created
    /// @param id subscription ID
    event SubscriptionCreated(uint32 indexed id);

    /// @notice Emitted when a subscription is cancelled
    /// @param id subscription ID
    event SubscriptionCancelled(uint32 indexed id);

    /// @notice Emitted when a subscription is fulfilled
    /// @param id subscription ID
    /// @param node address of fulfilling node
    event SubscriptionFulfilled(uint32 indexed id, address indexed node);
*/

'''
'''--- src/utils/mod.rs ---
mod ecdsa;
mod events;

'''
'''--- test.sh ---
#!/bin/sh

# unit testing
cargo test

# sandbox testing
./build.sh
cd sandbox-rs
cargo run --example sandbox "../target/wasm32-unknown-unknown/release/hello_near.wasm"
'''