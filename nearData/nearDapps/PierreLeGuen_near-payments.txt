*GitHub Repository "PierreLeGuen/near-payments"*

'''--- Cargo.toml ---
[workspace]
members = [
    "contract",
    "models",
]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# NEAR payments contract

Multisig wallet with advanced payment options

'''
'''--- build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- contract/Cargo.toml ---
[package]
name = "near-payments"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib"]

[dev-dependencies]
anyhow = "1.0"
maplit = "1.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.7.0"
pkg-config = "0.3.1"

[dependencies]
near-sdk = "4.1.1"
near-units = "0.2.0"
models = { path = "../models" }

'''
'''--- contract/src/common/errors.rs ---
use crate::*;

use near_sdk::{Balance, FunctionError};

#[derive(BorshDeserialize, BorshSerialize, Serialize, PartialEq, Debug)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub enum ContractError {
    InsufficientDeposit {
        expected: Balance,
        received: Balance,
    },
    EscrowTransferNotFound(String),
    NotAuthorized,
    NearTransferFailed,
}

impl FunctionError for ContractError {
    fn panic(&self) -> ! {
        crate::env::panic_str(
            &serde_json::to_string(self).unwrap_or(format!("serde failed: {self:?}")),
        )
    }
}

'''
'''--- contract/src/common/mod.rs ---
pub mod errors;
pub mod primitives;

'''
'''--- contract/src/common/primitives.rs ---
use near_sdk::{env, Balance};

use super::errors::ContractError;

pub fn check_deposit(deposit_needed: Balance) -> Result<(), ContractError> {
    if env::attached_deposit() >= deposit_needed {
        Ok(())
    } else {
        Err(ContractError::InsufficientDeposit {
            expected: deposit_needed,
            received: env::attached_deposit(),
        })
    }
}

'''
'''--- contract/src/escrow/mod.rs ---

pub mod owner;
pub mod receiver;
pub mod view;

'''
'''--- contract/src/escrow/owner.rs ---
use near_sdk::json_types::U128;

use crate::EscrowTransfer;
use crate::*;

///
/// Owner functions
///

impl Contract {
    pub fn create_near_escrow_payment(
        &mut self,
        receiver_id: AccountId,
        amount: u128,
        label: String,
        is_locked: bool,
    ) -> Result<CryptoHash, String> {
        // check near balance is sufficient
        assert!(
            env::account_balance() >= self.near_committed_balance + amount,
            "Not enough NEAR balance"
        );

        // update committed balance
        self.near_committed_balance += amount;

        // create escrow payment
        let mut buf = env::random_seed();
        buf.append(&mut self.request_nonce.to_le_bytes().to_vec());

        let id: CryptoHash = env::sha256(&buf).as_slice().try_into().unwrap();
        let p = EscrowTransfer {
            id,
            receiver_id,
            amount,
            label,
            is_locked,
            token_account: None,
        };

        self.escrow_transfers.insert(&id, &p);

        // return escrow payment id
        Ok(p.id)
    }
}

#[near_bindgen]
impl Contract {
    #[private]
    pub fn callback_create_ft_escrow(
        &mut self,
        receiver_id: AccountId,
        amount: u128,
        label: String,
        is_locked: bool,
        token_account: AccountId,
        #[callback_result] balance: Result<U128, near_sdk::PromiseError>,
    ) -> MultiSigResponse {
        let balance: u128 = match balance {
            Ok(b) => b.into(),
            Err(e) => env::panic_str(&format!("Error from ft_balance_of: {:?}", e)),
        };

        // assert token account is registered
        if self.ft_committed_balance.get(&token_account).is_none() {
            self.ft_committed_balance.insert(&token_account, &0);
        };

        let mut committed_balance = self.ft_committed_balance.get(&token_account).unwrap();

        // check ft balance is sufficient
        assert!(
            balance >= committed_balance + amount,
            "Not enough {} balance, current balance: {}, committed balance: {}",
            token_account,
            balance,
            committed_balance
        );

        // update committed balance
        committed_balance += amount;
        self.ft_committed_balance
            .insert(&token_account, &committed_balance);

        // create escrow payment
        let mut buf = env::random_seed();
        buf.append(&mut self.request_nonce.to_le_bytes().to_vec());

        let id: CryptoHash = env::sha256(&buf).as_slice().try_into().unwrap();
        let p = EscrowTransfer {
            id,
            receiver_id,
            amount,
            label,
            is_locked,
            token_account: Some(token_account),
        };

        self.escrow_transfers.insert(&id, &p);

        // return escrow payment id
        MultiSigResponse::new(0, FuncResponse::EscrowPayment(id.into()))
    }
}

'''
'''--- contract/src/escrow/receiver.rs ---
use near_sdk::{json_types::Base58CryptoHash, near_bindgen, ONE_YOCTO};

use crate::{
    common::{errors::ContractError, primitives::check_deposit},
    *,
};

use near_units::parse_near;

#[near_bindgen]
impl Contract {
    #[handle_result]
    #[payable]
    pub fn claim_payment(
        &mut self,
        payment_id: Base58CryptoHash,
    ) -> Result<Promise, ContractError> {
        check_deposit(ONE_YOCTO)?;

        let p = self
            .escrow_transfers
            .get(&payment_id.into())
            .ok_or_else(|| ContractError::EscrowTransferNotFound("in claim payment".into()))?;

        // assert called by receiver
        if env::predecessor_account_id() != p.receiver_id {
            return Err(ContractError::NotAuthorized);
        }

        if p.token_account.is_some() {
            // update committed balance
            let curr = self
                .ft_committed_balance
                .get(&p.token_account.clone().unwrap())
                .unwrap();
            let new = curr - p.amount;

            self.ft_committed_balance
                .insert(&p.token_account.clone().unwrap(), &new);

            // remove payment from escrow
            self.escrow_transfers.remove(&payment_id.into());

            // transfer FT to receiver
            Ok(ext_nep141_token::ext(p.token_account.clone().unwrap())
                .with_attached_deposit(parse_near!("0.00125"))
                .storage_deposit(p.receiver_id.clone(), Some(true))
                .then(
                    ext_nep141_token::ext(p.token_account.clone().unwrap())
                        .with_attached_deposit(ONE_YOCTO)
                        .ft_transfer(p.receiver_id.clone(), p.amount.into(), None),
                ))
        } else {
            self.near_committed_balance -= p.amount;

            // remove payment from escrow
            self.escrow_transfers.remove(&payment_id.into());

            // transfer NEAR to receiver
            Ok(Promise::new(p.receiver_id).transfer(p.amount))
        }
    }
}

'''
'''--- contract/src/escrow/view.rs ---
use near_sdk::json_types::Base58CryptoHash;

use crate::{
    common::errors::{ContractError},
    *,
};

#[near_bindgen]
impl Contract {
    #[handle_result]
    pub fn get_payments(&self) -> Result<Vec<(CryptoHash, EscrowTransfer)>, String> {
        let mut payments = vec![];
        for (k, v) in self.escrow_transfers.iter() {
            payments.push((k, v));
        }
        Ok(payments)
    }

    #[handle_result]
    pub fn get_payment_by_ud(
        &self,
        payment_id: Base58CryptoHash,
    ) -> Result<EscrowTransfer, ContractError> {
        self.escrow_transfers
            .get(&payment_id.into())
            .ok_or_else(|| ContractError::EscrowTransferNotFound("payment not found".into()))
    }
}

'''
'''--- contract/src/lib.rs ---
use std::collections::HashSet;

use models::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};

use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, serde_json, AccountId, BorshStorageKey, CryptoHash,
    PanicOnDefault, Promise, PromiseOrValue,
};

pub mod common;
pub mod escrow;

/// Unlimited allowance for multisig keys.
const DEFAULT_ALLOWANCE: u128 = 0;

/// Request cooldown period (time before a request can be deleted)
const REQUEST_COOLDOWN: u64 = 900_000_000_000;

/// Default limit of active requests.
const ACTIVE_REQUESTS_LIMIT: u32 = 12;

/// Default set of methods that access key should have.
const MULTISIG_METHOD_NAMES: &str = "add_request,delete_request,confirm,add_and_confirm_request";

#[ext_contract(ext_nep141_token)]
pub trait ExtNep141Token {
    fn ft_balance_of(&mut self, account_id: AccountId) -> Promise;
    fn ft_transfer(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
    ) -> Promise;
    fn storage_deposit(
        &mut self,
        account_id: AccountId,
        registration_only: Option<bool>,
    ) -> Promise;
}

/// An internal request wrapped with the signer_pk and added timestamp to determine num_requests_pk and prevent against malicious key holder gas attacks
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigRequestWithSigner {
    request: MultiSigRequest,
    member: MultisigMember,
    added_timestamp: u64,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    Members,
    Requests,
    Confirmations,
    NumRequestsPk,
    FtCommittedBalances,
    EscrowTransfers,
}
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Members of the multisig.
    members: UnorderedSet<MultisigMember>,
    /// Number of confirmations required.
    num_confirmations: u32,
    /// Latest request nonce.
    request_nonce: RequestId,
    /// All active requests.
    requests: UnorderedMap<RequestId, MultiSigRequestWithSigner>,
    /// All confirmations for active requests.
    confirmations: LookupMap<RequestId, HashSet<String>>,
    /// Number of requests per member.
    num_requests_pk: LookupMap<String, u32>,
    /// Limit number of active requests per member.
    active_requests_limit: u32,

    /// Payments
    ///
    /// Committed balance in escrow transfers.
    near_committed_balance: u128,
    /// Maps FT contracts to committed balance in escrow transfers.
    ft_committed_balance: UnorderedMap<AccountId, u128>,

    /// Pending escrow transfers.
    escrow_transfers: UnorderedMap<CryptoHash, EscrowTransfer>,
}

#[inline]
fn assert(condition: bool, error: &str) {
    if !condition {
        env::panic_str(error);
    }
}

#[near_bindgen]
impl Contract {
    /// Initialize multisig contract.
    /// @params members: list of {"account_id": "name"} or {"public_key": "key"} members.
    /// @params num_confirmations: k of n signatures required to perform operations.
    #[init]
    pub fn new(members: Vec<MultisigMember>, num_confirmations: u32) -> Self {
        assert(
            members.len() >= num_confirmations as usize,
            "Members list must be equal or larger than number of confirmations",
        );
        let mut multisig = Self {
            members: UnorderedSet::new(StorageKeys::Members),
            num_confirmations,
            request_nonce: 0,
            requests: UnorderedMap::new(StorageKeys::Requests),
            confirmations: LookupMap::new(StorageKeys::Confirmations),
            num_requests_pk: LookupMap::new(StorageKeys::NumRequestsPk),
            active_requests_limit: ACTIVE_REQUESTS_LIMIT,
            near_committed_balance: 0,
            ft_committed_balance: UnorderedMap::new(StorageKeys::FtCommittedBalances),
            escrow_transfers: UnorderedMap::new(StorageKeys::EscrowTransfers),
        };
        let mut promise = Promise::new(env::current_account_id());
        for member in members {
            promise = multisig.add_member(promise, member);
        }
        multisig
    }

    /// Add request for multisig.
    pub fn add_request(&mut self, request: MultiSigRequest) -> MultiSigResponse {
        let current_member = self.current_member().unwrap_or_else(|| {
            env::panic_str(
                "Predecessor must be a member or transaction signed with key of given account",
            )
        });
        // track how many requests this key has made
        let num_requests = self
            .num_requests_pk
            .get(&current_member.to_string())
            .unwrap_or(0)
            + 1;
        assert(
            num_requests <= self.active_requests_limit,
            "Account has too many active requests. Confirm or delete some.",
        );
        self.num_requests_pk
            .insert(&current_member.to_string(), &num_requests);
        // add the request
        let request_added = MultiSigRequestWithSigner {
            member: current_member,
            added_timestamp: env::block_timestamp(),
            request,
        };
        self.requests.insert(&self.request_nonce, &request_added);
        let confirmations = HashSet::new();
        self.confirmations
            .insert(&self.request_nonce, &confirmations);
        self.request_nonce += 1;
        MultiSigResponse::new(
            self.request_nonce - 1,
            FuncResponse::AddRequest(self.request_nonce - 1),
        )
    }

    /// Add request for multisig and confirm with the pk that added.
    pub fn add_request_and_confirm(
        &mut self,
        request: MultiSigRequest,
    ) -> PromiseOrValue<MultiSigResponse> {
        let request_id_resp = self.add_request(request);
        self.confirm(request_id_resp.request_id)
    }

    /// Remove given request and associated confirmations.
    pub fn delete_request(&mut self, request_id: RequestId) {
        self.assert_valid_request(request_id);
        let request_with_signer = self
            .requests
            .get(&request_id)
            .unwrap_or_else(|| env::panic_str("No such request"));
        // can't delete requests before 15min
        assert(
            env::block_timestamp() > request_with_signer.added_timestamp + REQUEST_COOLDOWN,
            "Request cannot be deleted immediately after creation.",
        );
        self.remove_request(request_id);
    }

    fn execute_request(&mut self, request: MultiSigRequest) -> PromiseOrValue<FuncResponse> {
        let mut promise = Promise::new(request.receiver_id.clone());
        let receiver_id = request.receiver_id.clone();
        let num_actions = request.actions.len();
        for action in request.actions {
            promise = match action {
                MultiSigRequestAction::CreateAccount => promise.create_account(),
                MultiSigRequestAction::DeployContract { code } => {
                    promise.deploy_contract(code.into())
                }
                MultiSigRequestAction::AddMember { member } => {
                    self.assert_self_request(receiver_id.clone());
                    self.add_member(promise, member)
                }
                MultiSigRequestAction::DeleteMember { member } => {
                    self.assert_self_request(receiver_id.clone());
                    self.delete_member(promise, member)
                }
                MultiSigRequestAction::AddKey {
                    public_key,
                    permission,
                } => {
                    self.assert_self_request(receiver_id.clone());
                    if let Some(permission) = permission {
                        promise.add_access_key(
                            public_key,
                            permission
                                .allowance
                                .map(|x| x.into())
                                .unwrap_or(DEFAULT_ALLOWANCE),
                            permission.receiver_id,
                            permission.method_names.join(","),
                        )
                    } else {
                        // wallet UI should warn user if receiver_id == env::current_account_id(), adding FAK will render multisig useless
                        promise.add_full_access_key(public_key)
                    }
                }
                // the following methods must be a single action
                MultiSigRequestAction::SetNumConfirmations { num_confirmations } => {
                    self.assert_one_action_only(receiver_id, num_actions);
                    self.num_confirmations = num_confirmations;
                    return PromiseOrValue::Value(FuncResponse::Default(true));
                }
                MultiSigRequestAction::SetActiveRequestsLimit {
                    active_requests_limit,
                } => {
                    self.assert_one_action_only(receiver_id, num_actions);
                    self.active_requests_limit = active_requests_limit;
                    return PromiseOrValue::Value(FuncResponse::Default(true));
                }

                // Payments
                MultiSigRequestAction::Transfer { amount } => {
                    // check if there is enough balance accounuting commited balance
                    let available: u128 = env::account_balance() - self.near_committed_balance;

                    assert!(
                        amount.0 <= available,
                        "Not enough balance to transfer. Available: {}, requested: {}",
                        available,
                        amount.0
                    );

                    promise.transfer(amount.into())
                }
                MultiSigRequestAction::NearEscrowTransfer {
                    receiver_id,
                    amount,
                    label,
                    is_cancellable,
                } => {
                    let res = self.create_near_escrow_payment(
                        receiver_id,
                        amount.into(),
                        label,
                        is_cancellable,
                    );
                    let id =
                        res.unwrap_or_else(|_| env::panic_str("Failed to create escrow payment"));
                    return PromiseOrValue::Value(FuncResponse::EscrowPayment(id.into()));
                }
                MultiSigRequestAction::FTEscrowTransfer {
                    receiver_id,
                    amount,
                    token_id,
                    label,
                    is_cancellable,
                } => ext_nep141_token::ext(token_id.clone())
                    .ft_balance_of(env::current_account_id())
                    .then(
                        Self::ext(env::current_account_id()).callback_create_ft_escrow(
                            receiver_id,
                            amount.into(),
                            label,
                            is_cancellable,
                            token_id,
                        ),
                    ),
            };
        }
        promise.into()
    }

    /// Confirm given request with given signing key.
    /// If with this, there has been enough confirmation, a promise with request will be scheduled.
    pub fn confirm(&mut self, request_id: RequestId) -> PromiseOrValue<MultiSigResponse> {
        self.assert_valid_request(request_id);
        let member = self
            .current_member()
            .unwrap_or_else(|| env::panic_str("Must be validated above"));
        let mut confirmations = self.confirmations.get(&request_id).unwrap();
        assert(
            !confirmations.contains(&member.to_string()),
            "Already confirmed this request with this key",
        );
        if confirmations.len() as u32 + 1 >= self.num_confirmations {
            let request = self.remove_request(request_id);
            /********************************
            NOTE: If the tx execution fails for any reason, the request and confirmations are removed already, so the client has to start all over
            ********************************/
            let ret = self.execute_request(request);
            match ret {
                PromiseOrValue::Promise(p) => p.into(),
                PromiseOrValue::Value(v) => {
                    PromiseOrValue::Value(MultiSigResponse::new(request_id, v))
                }
            }
        } else {
            confirmations.insert(member.to_string());
            self.confirmations.insert(&request_id, &confirmations);
            PromiseOrValue::Value(MultiSigResponse::new(
                request_id,
                FuncResponse::Default(true),
            ))
        }
    }

    /********************************
    Helper methods
    ********************************/

    /// Returns current member: either predecessor as account or if it's the same as current account - signer.
    fn current_member(&self) -> Option<MultisigMember> {
        let member = if env::current_account_id() == env::predecessor_account_id() {
            MultisigMember::AccessKey {
                public_key: env::signer_account_pk(),
            }
        } else {
            MultisigMember::Account {
                account_id: env::predecessor_account_id(),
            }
        };
        if self.members.contains(&member) {
            Some(member)
        } else {
            None
        }
    }

    /// Add member to the list. Adds access key if member is key based.
    fn add_member(&mut self, promise: Promise, member: MultisigMember) -> Promise {
        self.members.insert(&member);
        match member {
            MultisigMember::AccessKey { public_key } => promise.add_access_key(
                public_key,
                DEFAULT_ALLOWANCE,
                env::current_account_id(),
                MULTISIG_METHOD_NAMES.to_string(),
            ),
            MultisigMember::Account { account_id: _ } => promise,
        }
    }

    /// Delete member from the list. Removes access key if the member is key based.
    fn delete_member(&mut self, promise: Promise, member: MultisigMember) -> Promise {
        assert(
            self.members.len() > self.num_confirmations as u64,
            "Removing given member will make total number of members below number of confirmations",
        );
        // delete outstanding requests by public_key
        let request_ids: Vec<u32> = self
            .requests
            .iter()
            .filter_map(|(k, r)| if r.member == member { Some(k) } else { None })
            .collect();
        for request_id in request_ids {
            // remove confirmations for this request
            self.confirmations.remove(&request_id);
            self.requests.remove(&request_id);
        }
        // remove num_requests_pk entry for member
        self.num_requests_pk.remove(&member.to_string());
        self.members.remove(&member);
        match member {
            MultisigMember::AccessKey { public_key } => promise.delete_key(public_key),
            MultisigMember::Account { account_id: _ } => promise,
        }
    }

    /// Removes request, removes confirmations and reduces num_requests_pk - used in delete, delete_key, and confirm
    fn remove_request(&mut self, request_id: RequestId) -> MultiSigRequest {
        // remove confirmations for this request
        self.confirmations.remove(&request_id);
        // remove the original request
        let request_with_signer = self
            .requests
            .remove(&request_id)
            .unwrap_or_else(|| env::panic_str("Failed to remove existing element"));
        // decrement num_requests for original request signer
        let original_member = request_with_signer.member;
        let mut num_requests = self
            .num_requests_pk
            .get(&original_member.to_string())
            .unwrap_or(0);
        // safety check for underrun (unlikely since original_signer_pk must have num_requests_pk > 0)
        num_requests = num_requests.saturating_sub(1);
        self.num_requests_pk
            .insert(&original_member.to_string(), &num_requests);
        // return request
        request_with_signer.request
    }

    /// Prevents access to calling requests and make sure request_id is valid - used in delete and confirm
    fn assert_valid_request(&mut self, request_id: RequestId) {
        // request must come from key added to contract account
        assert(
            self.current_member().is_some(),
            "Caller (predecessor or signer) is not a member of this multisig",
        );
        // request must exist
        assert(
            self.requests.get(&request_id).is_some(),
            "No such request: either wrong number or already confirmed",
        );
        // request must have
        assert(
            self.confirmations.get(&request_id).is_some(),
            "Internal error: confirmations mismatch requests",
        );
    }

    /// Prevents request from approving tx on another account
    fn assert_self_request(&mut self, receiver_id: AccountId) {
        assert(
            receiver_id == env::current_account_id(),
            "This method only works when receiver_id is equal to current_account_id",
        );
    }

    /// Prevents a request from being bundled with other actions
    fn assert_one_action_only(&mut self, receiver_id: AccountId, num_actions: usize) {
        self.assert_self_request(receiver_id);
        assert(num_actions == 1, "This method should be a separate request");
    }

    /*******
     * Callback functions
     */

    /********************************
    View methods
    ********************************/

    /// Returns members of the multisig.
    pub fn get_members(&self) -> Vec<MultisigMember> {
        self.members.to_vec()
    }

    pub fn get_request(&self, request_id: RequestId) -> MultiSigRequest {
        (self
            .requests
            .get(&request_id)
            .unwrap_or_else(|| env::panic_str("No such request")))
        .request
    }

    pub fn get_num_requests_per_member(&self, member: MultisigMember) -> u32 {
        self.num_requests_pk.get(&member.to_string()).unwrap_or(0)
    }

    pub fn list_request_ids(&self) -> Vec<RequestId> {
        self.requests.keys().collect()
    }

    pub fn get_confirmations(&self, request_id: RequestId) -> Vec<String> {
        self.confirmations
            .get(&request_id)
            .unwrap_or_else(|| env::panic_str("No such request"))
            .into_iter()
            .collect()
    }

    pub fn get_num_confirmations(&self) -> u32 {
        self.num_confirmations
    }

    pub fn get_request_nonce(&self) -> u32 {
        self.request_nonce
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::Balance;
    use near_sdk::{testing_env, PublicKey};
    use near_sdk::{AccountId, VMContext};
    use std::convert::TryFrom;

    use super::*;

    pub fn alice() -> AccountId {
        AccountId::new_unchecked("alice".to_string())
    }
    pub fn bob() -> AccountId {
        AccountId::new_unchecked("bob".to_string())
    }

    const TEST_KEY: [u8; 33] = [
        0, 247, 230, 176, 93, 224, 175, 33, 211, 72, 124, 12, 163, 219, 7, 137, 3, 37, 162, 199,
        181, 38, 90, 244, 111, 207, 37, 216, 79, 84, 50, 83, 164,
    ];

    fn members() -> Vec<MultisigMember> {
        vec![
            MultisigMember::Account {
                account_id: alice(),
            },
            MultisigMember::Account { account_id: bob() },
            MultisigMember::AccessKey {
                public_key: "ed25519:Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"
                    .parse()
                    .unwrap(),
            },
            MultisigMember::AccessKey {
                public_key: PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            },
        ]
    }

    fn context_with_key(key: PublicKey, amount: Balance) -> VMContext {
        context_with_account_key(alice(), key, amount)
    }

    fn context_with_account(account_id: AccountId, amount: Balance) -> VMContext {
        context_with_account_key(
            account_id,
            PublicKey::try_from(vec![
                0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
                24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
            ])
            .unwrap(),
            amount,
        )
    }

    fn context_with_account_key(
        account_id: AccountId,
        key: PublicKey,
        amount: Balance,
    ) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .predecessor_account_id(account_id.clone())
            .signer_account_id(account_id)
            .signer_account_pk(key)
            .account_balance(amount)
            .build()
    }

    fn context_with_key_future(key: PublicKey, amount: Balance) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .block_timestamp(REQUEST_COOLDOWN + 1)
            .predecessor_account_id(alice())
            .signer_account_id(alice())
            .signer_account_pk(key)
            .account_balance(amount)
            .build()
    }

    #[test]
    fn test_multi_3_of_n() {
        let amount = 1_000;
        testing_env!(context_with_key(
            "Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"
                .parse()
                .unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 3);
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        let request_id = c.add_request(request.clone()).request_id;

        assert_eq!(c.get_request(request_id), request);
        assert_eq!(c.list_request_ids(), vec![request_id]);
        c.confirm(request_id);
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        testing_env!(context_with_key(
            "HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"
                .parse()
                .unwrap(),
            amount
        ));
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 2);
        assert_eq!(c.get_confirmations(request_id).len(), 2);
        testing_env!(context_with_account(bob(), amount));
        c.confirm(request_id);
        // TODO: confirm that funds were transferred out via promise.
        assert_eq!(c.requests.len(), 0);
    }

    #[test]
    fn test_multi_add_request_and_confirm() {
        let amount = 1_000;
        testing_env!(context_with_key(
            "Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"
                .parse()
                .unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 3);
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        let ret = c.add_request_and_confirm(request.clone());
        let request_id = if let PromiseOrValue::Value(v) = ret {
            v.request_id
        } else {
            panic!("Expected value");
        };

        assert_eq!(c.get_request(request_id), request);
        assert_eq!(c.list_request_ids(), vec![request_id]);
        // c.confirm(request_id);
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        testing_env!(context_with_key(
            "HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"
                .parse()
                .unwrap(),
            amount
        ));
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 2);
        assert_eq!(c.get_confirmations(request_id).len(), 2);
        testing_env!(context_with_account(bob(), amount));
        c.confirm(request_id);
        // TODO: confirm that funds were transferred out via promise.
        assert_eq!(c.requests.len(), 0);
    }

    #[test]
    fn add_key_delete_key_storage_cleared() {
        let amount = 1_000;
        testing_env!(context_with_key(
            "ed25519:Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"
                .parse()
                .unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 1);
        let new_key: PublicKey = "HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"
            .parse()
            .unwrap();
        // vm current_account_id is alice, receiver_id must be alice
        let request = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::AddKey {
                public_key: new_key.clone(),
                permission: None,
            }],
        };
        // make request
        c.add_request_and_confirm(request);
        // should be empty now
        assert_eq!(c.requests.len(), 0);
        // switch accounts
        testing_env!(context_with_key(
            "HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"
                .parse()
                .unwrap(),
            amount
        ));
        let request2 = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        // make request but don't confirm
        c.add_request(request2);
        // should have 1 request now
        let new_member = MultisigMember::AccessKey {
            public_key: new_key,
        };
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.get_num_requests_per_member(new_member.clone()), 1);
        // self delete key
        let request3 = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::DeleteMember {
                member: new_member.clone(),
            }],
        };
        // make request and confirm
        c.add_request_and_confirm(request3);
        // should be empty now
        assert_eq!(c.requests.len(), 0);
        assert_eq!(c.get_num_requests_per_member(new_member), 0);
    }

    #[test]
    #[should_panic]
    fn test_panics_add_key_different_account() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(Vec::from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")).unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 1);
        let new_key: PublicKey =
            PublicKey::try_from(Vec::from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")).unwrap();
        // vm current_account_id is alice, receiver_id must be alice
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::AddKey {
                public_key: new_key,
                permission: None,
            }],
        };
        // make request
        c.add_request_and_confirm(request);
    }

    #[test]
    fn test_change_num_confirmations() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 1);
        let request_id = c
            .add_request(MultiSigRequest {
                receiver_id: alice(),
                actions: vec![MultiSigRequestAction::SetNumConfirmations {
                    num_confirmations: 2,
                }],
            })
            .request_id;

        c.confirm(request_id);
        assert_eq!(c.num_confirmations, 2);
    }

    #[test]
    #[should_panic]
    fn test_panics_on_second_confirm() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 3);
        let request_id = c
            .add_request(MultiSigRequest {
                receiver_id: bob(),
                actions: vec![MultiSigRequestAction::Transfer {
                    amount: amount.into(),
                }],
            })
            .request_id;

        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 0);
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        c.confirm(request_id);
    }

    #[test]
    #[should_panic]
    fn test_panics_delete_request() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 3);
        let request_id = c
            .add_request(MultiSigRequest {
                receiver_id: bob(),
                actions: vec![MultiSigRequestAction::Transfer {
                    amount: amount.into(),
                }],
            })
            .request_id;
        c.delete_request(request_id);
    }

    #[test]
    fn test_delete_request_future() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 3);
        let request_id = c
            .add_request(MultiSigRequest {
                receiver_id: bob(),
                actions: vec![MultiSigRequestAction::Transfer {
                    amount: amount.into(),
                }],
            })
            .request_id;

        c.confirm(request_id);
        testing_env!(context_with_key_future(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        c.delete_request(request_id);
        assert_eq!(c.requests.len(), 0);
        assert!(c.confirmations.get(&request_id).is_none());
    }

    #[test]
    #[should_panic]
    fn test_delete_request_panic_wrong_key() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 3);
        let request_id = c
            .add_request(MultiSigRequest {
                receiver_id: bob(),
                actions: vec![MultiSigRequestAction::Transfer {
                    amount: amount.into(),
                }],
            })
            .request_id;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        c.delete_request(request_id);
    }

    #[test]
    #[should_panic]
    fn test_too_many_requests() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = Contract::new(members(), 3);
        for _i in 0..16 {
            c.add_request(MultiSigRequest {
                receiver_id: bob(),
                actions: vec![MultiSigRequestAction::Transfer {
                    amount: amount.into(),
                }],
            });
        }
    }

    #[test]
    #[should_panic]
    fn test_too_many_confirmations() {
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            1_000
        ));
        let _ = Contract::new(members(), 5);
    }
}

'''
'''--- contract/tests/tests.rs ---
#[cfg(test)]
mod tests {
    use anyhow::{Ok, Result};
    use near_sdk::{
        json_types::{Base58CryptoHash, U128},
        AccountId, CryptoHash, Gas, ONE_NEAR, ONE_YOCTO,
    };

    use near_units::parse_near;
    use serde_json::json;
    use std::{fs, sync::Once};
    use tracing::info;
    use workspaces::{Account, Contract};

    pub use models::*;

    pub struct ContractWrapper {
        contract: Contract,
    }

    static log_int: Once = Once::new();

    impl ContractWrapper {
        fn new(contract: Contract) -> Self {
            Self { contract }
        }

        async fn init(&self, members: Vec<MultisigMember>, num_confirmations: u128) -> Result<()> {
            let args = json!({
                "members": members,
                "num_confirmations": num_confirmations,
            });

            self.contract
                .call("new")
                .args_json(args)
                .transact()
                .await?
                .into_result()?;

            let m: Vec<MultisigMember> = self.contract.view("get_members").await?.json()?;

            assert!(m == members);
            Ok(())
        }

        async fn add_request_and_confirm(
            &self,
            from: &Account,
            request: MultiSigRequest,
        ) -> Result<Option<MultiSigResponse>> {
            let ret = from
                .call(self.contract.id(), "add_request_and_confirm")
                .args_json(json!({ "request": request }))
                .gas(300 * Gas::ONE_TERA.0)
                .transact()
                .await?
                .into_result()?;

            let r = if !ret.raw_bytes().unwrap().is_empty() {
                let q: MultiSigResponse = ret.json().unwrap();
                Some(q)
            } else {
                None
            };
            Ok(r)
        }

        async fn get_payments(
            &self,
            caller: &Account,
        ) -> Result<Vec<(CryptoHash, EscrowTransfer)>> {
            let v: Vec<(CryptoHash, EscrowTransfer)> = caller
                .call(self.contract.id(), "get_payments")
                .transact()
                .await?
                .json()?;

            Ok(v)
        }

        async fn claim_payment(
            &self,
            caller: &Account,
            payment_id: Base58CryptoHash,
        ) -> Result<()> {
            caller
                .call(self.contract.id(), "claim_payment")
                .args_json(json!({ "payment_id": payment_id }))
                .gas(300 * Gas::ONE_TERA.0)
                .deposit(ONE_YOCTO)
                .transact()
                .await?
                .into_result()?;

            Ok(())
        }
    }

    async fn init() -> Result<(ContractWrapper, Contract, Account, Account)> {
        log_int.call_once(|| {
            // construct a subscriber that prints formatted traces to stdout
            let subscriber = tracing_subscriber::FmtSubscriber::new();
            // use that subscriber to process traces emitted after this point
            tracing::subscriber::set_global_default(subscriber).unwrap();
        });

        let worker = workspaces::sandbox().await?;

        info!("creating accounts");
        let alice = worker.dev_create_account().await?;
        let bob = worker.dev_create_account().await?;

        info!("deploying contracts");
        let payments_contract = worker
            .dev_deploy(&fs::read(
                "../target/wasm32-unknown-unknown/release/near_payments.wasm",
            )?)
            .await?;
        let ft_contract = worker.dev_deploy(&fs::read("./tests/w_near.wasm")?).await?;
        ft_contract.call("new").transact().await?.unwrap();

        let contract_wrapper = ContractWrapper::new(payments_contract.clone());

        info!("transferring wrap near to multisig wallet");
        alice
            .call(ft_contract.id(), "near_deposit")
            .deposit(50 * ONE_NEAR)
            .transact()
            .await?
            .unwrap();

        alice
            .call(ft_contract.id(), "storage_deposit")
            .args_json(json!({ "account_id": payments_contract.id() }))
            .deposit(parse_near!("0.00125"))
            .transact()
            .await?
            .unwrap();

        alice
            .call(ft_contract.id(), "ft_transfer")
            .args_json(
                json!({ "receiver_id": payments_contract.id(), "amount": (40 * ONE_NEAR).to_string() }),
            )
            .deposit(ONE_YOCTO)
            .transact()
            .await?
            .unwrap();

        info!("initializing contract");
        contract_wrapper
            .init(
                vec![MultisigMember::Account {
                    account_id: workspace_acc_id_to_sdk_id(&alice),
                }],
                1,
            )
            .await?;

        Ok((contract_wrapper, ft_contract, alice, bob))
    }

    #[tokio::test]
    async fn test_transfer() -> Result<()> {
        let (contract_wrapper, _, caller, to) = init().await?;

        let request = MultiSigRequest {
            receiver_id: AccountId::new_unchecked(to.id().to_string()),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: ONE_NEAR.into(),
            }],
        };

        contract_wrapper
            .add_request_and_confirm(&caller, request)
            .await?;

        Ok(())
    }

    #[tokio::test]
    async fn test_escrow_transfer() -> Result<()> {
        let (contract_wrapper, _, caller, to) = init().await?;

        let request = MultiSigRequest {
            receiver_id: AccountId::new_unchecked(to.id().to_string()),
            actions: vec![MultiSigRequestAction::NearEscrowTransfer {
                receiver_id: workspace_acc_id_to_sdk_id(&to),
                amount: ONE_NEAR.into(),
                label: "test".to_string(),
                is_cancellable: true,
            }],
        };

        let ret = contract_wrapper
            .add_request_and_confirm(&caller, request)
            .await?
            .expect("no response");

        let id = match ret.response {
            FuncResponse::EscrowPayment(p) => p,
            _ => panic!("unexpected response"),
        };

        contract_wrapper.claim_payment(&to, id).await?;

        Ok(())
    }

    #[tokio::test]
    #[should_panic = "Not enough NEAR balance"]
    async fn test_escrow_transfer_above_account_balance() {
        let (contract_wrapper, _, caller, to) = init().await.unwrap();

        let request = MultiSigRequest {
            receiver_id: workspace_acc_id_to_sdk_id(&to),
            actions: vec![MultiSigRequestAction::NearEscrowTransfer {
                receiver_id: workspace_acc_id_to_sdk_id(&to),
                amount: (90 * ONE_NEAR).into(),
                label: "test".to_string(),
                is_cancellable: true,
            }],
        };

        let ret = contract_wrapper
            .add_request_and_confirm(&caller, request)
            .await
            .unwrap()
            .expect("no response");

        let _id = match ret.response {
            FuncResponse::EscrowPayment(p) => p,
            _ => panic!("unexpected response"),
        };

        let request = MultiSigRequest {
            receiver_id: workspace_acc_id_to_sdk_id(&to),
            actions: vec![MultiSigRequestAction::NearEscrowTransfer {
                receiver_id: workspace_acc_id_to_sdk_id(&to),
                amount: (90 * ONE_NEAR).into(),
                label: "test".to_string(),
                is_cancellable: true,
            }],
        };

        let ret = contract_wrapper
            .add_request_and_confirm(&caller, request)
            .await
            .unwrap()
            .expect("no response");

        let _id = match ret.response {
            FuncResponse::EscrowPayment(p) => p,
            _ => panic!("unexpected response"),
        };
    }

    #[tokio::test]
    async fn test_ft_escrow_transfer() -> Result<()> {
        let (contract_wrapper, ft_contract, caller, to) = init().await?;

        let request = MultiSigRequest {
            receiver_id: workspace_acc_id_to_sdk_id(&to),
            actions: vec![MultiSigRequestAction::FTEscrowTransfer {
                receiver_id: workspace_acc_id_to_sdk_id(&to),
                amount: (30 * ONE_NEAR).into(),
                label: "test".to_string(),
                is_cancellable: true,
                token_id: workspace_acc_id_to_sdk_id(ft_contract.as_account()),
            }],
        };

        let ret = contract_wrapper
            .add_request_and_confirm(&caller, request)
            .await?
            .expect("no response");

        let payment_id = match ret.response {
            FuncResponse::EscrowPayment(id) => id,
            _ => panic!("unexpected response"),
        };

        // let p = contract.get_payments(caller, id).await?;

        contract_wrapper.claim_payment(&to, payment_id).await?;

        let balance: U128 = to
            .call(ft_contract.id(), "ft_balance_of")
            .args_json(json!({
                "account_id": to.id()
            }))
            .transact()
            .await?
            .unwrap()
            .json()?;

        assert_eq!(balance.0, 30 * ONE_NEAR);

        Ok(())
    }

    #[tokio::test]
    #[should_panic = "Not enough"]
    async fn test_ft_escrow_transfer_above_balance() {
        let (contract_wrapper, ft_contract, caller, to) = init().await.unwrap();

        let request = MultiSigRequest {
            receiver_id: workspace_acc_id_to_sdk_id(&to),
            actions: vec![MultiSigRequestAction::FTEscrowTransfer {
                receiver_id: workspace_acc_id_to_sdk_id(&to),
                amount: (30 * ONE_NEAR).into(),
                label: "test".to_string(),
                is_cancellable: true,
                token_id: workspace_acc_id_to_sdk_id(ft_contract.as_account()),
            }],
        };

        contract_wrapper
            .add_request_and_confirm(&caller, request)
            .await
            .unwrap();

        let request = MultiSigRequest {
            receiver_id: workspace_acc_id_to_sdk_id(&to),
            actions: vec![MultiSigRequestAction::FTEscrowTransfer {
                receiver_id: workspace_acc_id_to_sdk_id(&to),
                amount: (30 * ONE_NEAR).into(),
                label: "test".to_string(),
                is_cancellable: true,
                token_id: workspace_acc_id_to_sdk_id(ft_contract.as_account()),
            }],
        };

        contract_wrapper
            .add_request_and_confirm(&caller, request)
            .await
            .unwrap();
    }

    // Helper function to convert workspaces::AccountId to near_sdk::AccountId
    fn workspace_acc_id_to_sdk_id(acc: &workspaces::Account) -> near_sdk::AccountId {
        near_sdk::AccountId::new_unchecked(acc.id().to_string())
    }
}

'''
'''--- deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract"

near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/near_payments.wasm

'''
'''--- models/Cargo.toml ---
[package]
name = "models"
version = "0.1.0"
edition = "2021"

[dependencies]
near-sdk = "4.1.1"

'''
'''--- models/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base58CryptoHash, Base64VecU8, U128};
use near_sdk::{env, serde_json, CryptoHash};
use near_sdk::{
    serde::{Deserialize, Serialize},
    AccountId, PublicKey,
};

/// Represents member of the multsig: either account or access key to given account.
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone, PartialEq, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum MultisigMember {
    AccessKey { public_key: PublicKey },
    Account { account_id: AccountId },
}

impl ToString for MultisigMember {
    fn to_string(&self) -> String {
        serde_json::to_string(&self).unwrap_or_else(|_| env::panic_str("Failed to serialize"))
    }
}

pub type RequestId = u32;

/// Permissions for function call access key.
#[derive(Debug, PartialEq, Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FunctionCallPermission {
    pub allowance: Option<U128>,
    pub receiver_id: AccountId,
    pub method_names: Vec<String>,
}

/// Lowest level action that can be performed by the multisig contract.
#[derive(Debug, PartialEq, Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(tag = "type", crate = "near_sdk::serde")]
pub enum MultiSigRequestAction {
    /// Create a new account.
    CreateAccount,
    /// Deploys contract to receiver's account. Can upgrade given contract as well.
    DeployContract { code: Base64VecU8 },
    /// Add new member of the multisig.
    AddMember { member: MultisigMember },
    /// Remove existing member of the multisig.
    DeleteMember { member: MultisigMember },
    /// Adds full access key to another account.
    AddKey {
        public_key: PublicKey,
        #[serde(skip_serializing_if = "Option::is_none")]
        permission: Option<FunctionCallPermission>,
    },
    /// Sets number of confirmations required to authorize requests.
    /// Can not be bundled with any other actions or transactions.
    SetNumConfirmations { num_confirmations: u32 },
    /// Sets number of active requests (unconfirmed requests) per access key
    /// Default is 12 unconfirmed requests at a time
    /// The REQUEST_COOLDOWN for requests is 15min
    /// Worst gas attack a malicious keyholder could do is 12 requests every 15min
    SetActiveRequestsLimit { active_requests_limit: u32 },
    /// Payment options
    /// Transfers given amount to receiver.
    Transfer { amount: U128 },
    /// NEAR Escrow transfer
    NearEscrowTransfer {
        receiver_id: AccountId,
        amount: U128,
        label: String,
        is_cancellable: bool,
    },
    /// FT Escrow transfer
    FTEscrowTransfer {
        receiver_id: AccountId,
        amount: U128,
        token_id: AccountId,
        label: String,
        is_cancellable: bool,
    },
}

/// The request the user makes specifying the receiving account and actions they want to execute (1 tx)
#[derive(Debug, PartialEq, Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigRequest {
    pub receiver_id: AccountId,
    pub actions: Vec<MultiSigRequestAction>,
}

#[derive(Debug, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub enum FuncResponse {
    AddRequest(RequestId),
    Default(bool),
    EscrowPayment(Base58CryptoHash),
    Balance(U128),
}

#[derive(Debug, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct EscrowTransfer {
    pub id: CryptoHash,
    pub receiver_id: AccountId,
    pub amount: u128,
    pub label: String,
    pub is_locked: bool,
    pub token_account: Option<AccountId>,
}

#[derive(Debug, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigResponse {
    pub request_id: RequestId,
    pub response: FuncResponse,
}

impl MultiSigResponse {
    pub fn new(request_id: RequestId, response: FuncResponse) -> Self {
        Self {
            request_id,
            response,
        }
    }
}

'''
'''--- test.sh ---
#!/bin/sh

./build.sh

echo ">> Integration tests"

cargo run --example integration-tests "./target/wasm32-unknown-unknown/release/near_payments.wasm" 
'''