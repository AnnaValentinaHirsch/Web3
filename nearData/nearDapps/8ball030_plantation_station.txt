*GitHub Repository "8ball030/plantation_station"*

'''--- .eslintrc.js ---
module.exports = {
    "env": {
        "browser": true,
        "commonjs": true,
        "es2021": true
    },
    "extends": "eslint:recommended",
    "parserOptions": {
        "ecmaVersion": 13
    },
    "ignorePatterns": [
        "artifacts/*",
        "cache/*",
        "node_modules/*",
        "third_party/*"
    ],
    "rules": {
        "camelcase": [
            2, {
                "properties": "always"
            }
        ],
        "indent": [
            "error",
            4
        ],
        "linebreak-style": [
            "error",
            "unix"
        ],
        "quotes": [
            "error",
            "double"
        ],
        "semi": [
            "error",
            "always"
        ],
        "no-unused-vars": "warn"
    }
};

'''
'''--- .solcover.js ---
module.exports = {
    skipFiles: ["test/ReentrancyAttacker.sol"]
};

'''
'''--- hardhat.config.js ---
/*global process*/

require("hardhat-contract-sizer");
require("hardhat-deploy");
require("hardhat-deploy-ethers");
require("hardhat-gas-reporter");
require("hardhat-tracer");
require("@nomicfoundation/hardhat-chai-matchers");
require("@nomiclabs/hardhat-ethers");
require("@nomiclabs/hardhat-etherscan");
require("@nomicfoundation/hardhat-toolbox");

const ALCHEMY_API_KEY_MAINNET = process.env.ALCHEMY_API_KEY_MAINNET;
const ALCHEMY_API_KEY_MATIC = process.env.ALCHEMY_API_KEY_MATIC;
const ALCHEMY_API_KEY_GOERLI = process.env.ALCHEMY_API_KEY_GOERLI;
const ALCHEMY_API_KEY_MUMBAI = process.env.ALCHEMY_API_KEY_MUMBAI;
const GNOSIS_CHAIN_API_KEY = process.env.GNOSIS_CHAIN_API_KEY;
const CHIADO_CHAIN_API_KEY = "10200";
let TESTNET_MNEMONIC = process.env.TESTNET_MNEMONIC;

const accounts = {
    mnemonic: TESTNET_MNEMONIC,
    path: "m/44'/60'/0'/0",
    initialIndex: 0,
    count: 20,
};

if (!TESTNET_MNEMONIC) {
    // Generated with bip39
    accounts.mnemonic = "velvet deliver grief train result fortune travel voice over subject subject staff nominee bone name";
    accounts.accountsBalance = "100000000000000000000000000";
}

const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY;
const POLYGONSCAN_API_KEY = process.env.POLYGONSCAN_API_KEY;

module.exports = {
    networks: {
        local: {
            url: "http://localhost:8545",
        },
        mainnet: {
            url: "https://eth-mainnet.g.alchemy.com/v2/" + ALCHEMY_API_KEY_MAINNET,
            accounts: accounts,
            chainId: 1,
        },
        polygon: {
            url: "https://polygon-mainnet.g.alchemy.com/v2/" + ALCHEMY_API_KEY_MATIC,
            accounts: accounts,
            chainId: 137,
        },
        gnosis: {
            url: "https://rpc.gnosischain.com",
            accounts: accounts,
            chainId: 100,
        },
        goerli: {
            url: "https://eth-goerli.g.alchemy.com/v2/" + ALCHEMY_API_KEY_GOERLI,
            chainId: 5,
            accounts: accounts,
        },
        polygonMumbai: {
            url: "https://polygon-mumbai.g.alchemy.com/v2/" + ALCHEMY_API_KEY_MUMBAI,
            accounts: accounts,
        },
        chiado: {
            url: "https://rpc.chiadochain.net",
            accounts: accounts,
        },
        hardhat: {
            allowUnlimitedContractSize: true
        },
    },
    etherscan: {
        customChains: [
            {
                network: "chiado",
                chainId: 10200,
                urls: {
                    apiURL: "https://blockscout.com/gnosis/chiado/api",
                    browserURL: "https://blockscout.com/gnosis/chiado",
                },
            },
            {
                network: "gnosis",
                chainId: 100,
                urls: {
                    apiURL: "https://api.gnosisscan.io/api",
                    browserURL: "https://gnosisscan.io/"
                },
            },
        ],
        apiKey: {
            mainnet: ETHERSCAN_API_KEY,
            polygon: POLYGONSCAN_API_KEY,
            gnosis: GNOSIS_CHAIN_API_KEY,
            goerli: ETHERSCAN_API_KEY,
            polygonMumbai: POLYGONSCAN_API_KEY,
            chiado: CHIADO_CHAIN_API_KEY,
        }
    },
    solidity: {
        compilers: [
            {
                version: "0.8.19",
                settings: {
                    optimizer: {
                        enabled: true,
                        runs: 1000000,
                    },
                },
            }
        ]
    },
    gasReporter: {
        enabled: true
    }
};

'''
'''--- mas/mints/mapping.txt ---
token_id-"component_id"
# deps
1-"protocol/valory/abci/0.1.0"
2-"protocol/valory/acn/1.1.0"
3-"protocol/valory/contract_api/1.0.0"
4-"protocol/valory/http/1.0.0"
5-"protocol/valory/ledger_api/1.0.0"
6-"protocol/valory/tendermint/0.1.0"
7-"protocol/open_aea/signing/1.0.0"
8-"connection/valory/abci/0.1.0"
9-"connection/valory/http_client/0.23.0"
10-"connection/valory/ledger/0.19.0"
11-"connection/valory/p2p_libp2p_client/0.1.0"
12-"contract/valory/service_registry/0.1.0"
13-"skill/valory/abstract_abci/0.1.0"
14-"skill/valory/abstract_round_abci/0.1.0"
16-"skill/valory/registration_abci/0.1.0"
17-"skill/valory/reset_pause_abci/0.1.0"
18-"contract/valory/gnosis_safe_proxy_factory/0.1.0"
19-"contract/valory/gnosis_safe/0.1.0"
20-"contract/valory/multisend/0.1.0"
22-"skill/valory/transaction_settlement_abci/0.1.0"
39-"protocol/valory/ipfs/0.1.0"
50-"connection/valory/ipfs/0.1.0"
51-"contract/valory/multicall2/0.1.0"
# dev
97-contract/zarathustra/grow_registry:0.1.0
98-skill/zarathustra/plantation_station_abci/0.1.0
99-skill/zarathustra/plantation_abci/0.1.0
12-agent/zarathustra/plantation/0.1.0
8-service/eightballer/plantation_station/0.1.0

'''
'''--- mas/packages/eightballer/__init__.py ---

'''
'''--- mas/packages/eightballer/services/__init__ .py ---

'''
'''--- mas/packages/zarathustra/contracts/__init__.py ---

'''
'''--- mas/packages/zarathustra/contracts/grow_registry/__init__.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the support resources for the scaffold contract."""

'''
'''--- mas/packages/zarathustra/contracts/grow_registry/contract.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the GrowRegistry contract interface."""

import logging
from typing import Any

from aea.common import JSONLike
from aea.configurations.base import PublicId
from aea.contracts.base import Contract
from aea_ledger_ethereum import EthereumApi, LedgerApi
from web3.types import TxParams

PUBLIC_ID = PublicId.from_str("zarathustra/grow_registry:0.1.0")

_logger = logging.getLogger(
    f"aea.packages.{PUBLIC_ID.author}.contracts.{PUBLIC_ID.name}.contract"
)

Address = str

class GrowRegistryContract(Contract):
    """GrowRegistryContract"""

    contract_id = PUBLIC_ID

    @classmethod
    def get_raw_transaction(
        cls, ledger_api: LedgerApi, contract_address: str, **kwargs: Any
    ) -> JSONLike:
        """Get raw transaction."""
        raise NotImplementedError

    @classmethod
    def get_raw_message(
        cls, ledger_api: LedgerApi, contract_address: str, **kwargs: Any
    ) -> bytes:
        """Get raw message."""
        raise NotImplementedError

    @classmethod
    def get_state(
        cls, ledger_api: LedgerApi, contract_address: str, **kwargs: Any
    ) -> JSONLike:
        """Get state."""
        raise NotImplementedError

    @classmethod
    def approve(
        cls,
        ledger_api: LedgerApi,
        contract_address: Address,
        spender: Address,
        id: int,
    ) -> None:

        contract_interface = cls.get_instance(
            ledger_api=ledger_api,
            contract_address=contract_address,
        )

        contract_interface.functions.approve(spender, id).call()

    @classmethod
    def create(
        cls,
        ledger_api: LedgerApi,
        contract_address: Address,
        grow_owner: Address,
        grower: Address,
        grow_hash: bytes,
    ) -> int:

        contract_interface = cls.get_instance(
            ledger_api=ledger_api,
            contract_address=contract_address,
        )

        grow_id = contract_interface.functions.create(
            grow_owner, grower, grow_hash
        ).call()

        return grow_id

    @classmethod
    def propose_to_harvest(
        cls,
        ledger_api: LedgerApi,
        contract_address: Address,
        grow_id: int,
    ) -> None:

        contract_interface = cls.get_instance(
            ledger_api=ledger_api,
            contract_address=contract_address,
        )

        contract_interface.functions.proposeToHarvest(grow_id).call()

    @classmethod
    def harvest(
        cls,
        ledger_api: LedgerApi,
        contract_address: Address,
        grow_id: int,
    ) -> None:

        contract_interface = cls.get_instance(
            ledger_api=ledger_api,
            contract_address=contract_address,
        )

        contract_interface.functions.harvest(grow_id).call()

    @classmethod
    def redeem(
        cls,
        ledger_api: LedgerApi,
        contract_address: Address,
        grow_id: int,
    ) -> None:

        contract_interface = cls.get_instance(
            ledger_api=ledger_api,
            contract_address=contract_address,
        )

        contract_interface.functions.redeem(grow_id).call()

    @classmethod
    def update_hash(
        cls,
        ledger_api: LedgerApi,
        contract_address: Address,
        grow_id: int,
        grow_hash: bytes,
    ) -> JSONLike:
        """
        Get the encoded params for `updateHash`.

        :param ledger_api: ledger API object.
        :param contract_address: address of the NFT
        :param grow_id: grow ID
        :param grow_hash: grow hash
        :param sender_address: The address of the tx sender.
        :param gas: Gas
        :param gas_price: Gas Price
        :param max_fee_per_gas: max
        :param max_priority_fee_per_gas: max
        :return: the raw transaction
        """
        eth_api = cast(EthereumApi, ledger_api)
        contract = cls.get_instance(ledger_api, contract_address)
        tx_parameters = TxParams()

        if gas_price is not None:
            tx_parameters["gasPrice"] = Wei(gas_price)  # pragma: nocover

        if max_fee_per_gas is not None:
            tx_parameters["maxFeePerGas"] = Wei(max_fee_per_gas)  # pragma: nocover

        if max_priority_fee_per_gas is not None:
            tx_parameters["maxPriorityFeePerGas"] = Wei(  # pragma: nocover
                max_priority_fee_per_gas
            )

        if (
            gas_price is None
            and max_fee_per_gas is None
            and max_priority_fee_per_gas is None
        ):
            tx_parameters.update(eth_api.try_get_gas_pricing())

        if gas is not None:
            tx_parameters["gas"] = Wei(gas)

        nonce = eth_api._try_get_transaction_count(  # pylint: disable=protected-access
            sender_address
        )
        tx_parameters["nonce"] = Nonce(nonce)

        if nonce is None:
            raise ValueError("No nonce returned.")  # pragma: nocover

        raw_tx = contract.functions.updateHash(grow_id, grow_hash).buildTransaction(
            tx_params
        )

        return raw_tx

'''
'''--- mas/packages/zarathustra/skills/plantation_abci/__init__.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the implementation of the composite skill."""

from aea.configurations.base import PublicId

PUBLIC_ID = PublicId.from_str("zarathustra/plantation_abci:0.1.0")

'''
'''--- mas/packages/zarathustra/skills/plantation_abci/behaviours.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2021-2023 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the Plantation ABCI behaviour."""

from typing import Set, Type

from packages.valory.skills.abstract_round_abci.behaviours import (
    AbstractRoundBehaviour,
    BaseBehaviour,
)
from packages.valory.skills.registration_abci.behaviours import (
    AgentRegistrationRoundBehaviour,
    RegistrationStartupBehaviour,
)
from packages.valory.skills.reset_pause_abci.behaviours import (
    ResetPauseABCIConsensusBehaviour,
)
from packages.valory.skills.transaction_settlement_abci.behaviours import (
    TransactionSettlementRoundBehaviour,
)
from packages.zarathustra.skills.plantation_abci.composition import PlantationAbciApp
from packages.zarathustra.skills.plantation_station_abci.behaviours import (
    PlantationStationRoundBehaviour,
)

class PlantationAbciAppConsensusBehaviour(AbstractRoundBehaviour):
    """This behaviour manages the consensus stages for the plantation."""

    initial_behaviour_cls = RegistrationStartupBehaviour
    abci_app_cls = PlantationAbciApp  # type: ignore
    behaviours: Set[Type[BaseBehaviour]] = {
        *AgentRegistrationRoundBehaviour.behaviours,
        *PlantationStationRoundBehaviour.behaviours,
        *TransactionSettlementRoundBehaviour.behaviours,
        *ResetPauseABCIConsensusBehaviour.behaviours,
    }

'''
'''--- mas/packages/zarathustra/skills/plantation_abci/composition.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2021-2023 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the Plantation ABCI application."""

from packages.valory.skills.abstract_round_abci.abci_app_chain import (
    AbciAppTransitionMapping,
    chain,
)
from packages.valory.skills.registration_abci.rounds import (
    AgentRegistrationAbciApp,
    FinishedRegistrationRound,
    RegistrationRound,
)
from packages.valory.skills.reset_pause_abci.rounds import (
    FinishedResetAndPauseErrorRound,
    FinishedResetAndPauseRound,
    ResetAndPauseRound,
    ResetPauseAbciApp,
)
from packages.valory.skills.transaction_settlement_abci.rounds import (
    FailedRound,
    FinishedTransactionSubmissionRound,
    RandomnessTransactionSubmissionRound,
    TransactionSubmissionAbciApp,
)
from packages.zarathustra.skills.plantation_station_abci.rounds import (
    ObservationCollectionRound,
    PlantationStationAbciApp,
    ResetPlantationStationRound,
    TransactionSubmissionRound,
)

abci_app_transition_mapping: AbciAppTransitionMapping = {
    FinishedRegistrationRound: ObservationCollectionRound,
    TransactionSubmissionRound: RandomnessTransactionSubmissionRound,
    ResetPlantationStationRound: ResetAndPauseRound,
    FinishedTransactionSubmissionRound: ResetAndPauseRound,
    FailedRound: ResetAndPauseRound,
    FinishedResetAndPauseRound: ObservationCollectionRound,
    FinishedResetAndPauseErrorRound: RegistrationRound,
}

PlantationAbciApp = chain(
    (
        AgentRegistrationAbciApp,
        PlantationStationAbciApp,
        TransactionSubmissionAbciApp,
        ResetPauseAbciApp,
    ),
    abci_app_transition_mapping,
)

'''
'''--- mas/packages/zarathustra/skills/plantation_abci/dialogues.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the dialogues of the PlantationAbciApp."""

from packages.valory.skills.abstract_round_abci.dialogues import (
    AbciDialogue as BaseAbciDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    AbciDialogues as BaseAbciDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    ContractApiDialogue as BaseContractApiDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    ContractApiDialogues as BaseContractApiDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    HttpDialogue as BaseHttpDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    HttpDialogues as BaseHttpDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    IpfsDialogue as BaseIpfsDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    IpfsDialogues as BaseIpfsDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    LedgerApiDialogue as BaseLedgerApiDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    LedgerApiDialogues as BaseLedgerApiDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    SigningDialogue as BaseSigningDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    SigningDialogues as BaseSigningDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    TendermintDialogue as BaseTendermintDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    TendermintDialogues as BaseTendermintDialogues,
)

AbciDialogue = BaseAbciDialogue
AbciDialogues = BaseAbciDialogues

HttpDialogue = BaseHttpDialogue
HttpDialogues = BaseHttpDialogues

SigningDialogue = BaseSigningDialogue
SigningDialogues = BaseSigningDialogues

LedgerApiDialogue = BaseLedgerApiDialogue
LedgerApiDialogues = BaseLedgerApiDialogues

ContractApiDialogue = BaseContractApiDialogue
ContractApiDialogues = BaseContractApiDialogues

TendermintDialogue = BaseTendermintDialogue
TendermintDialogues = BaseTendermintDialogues

IpfsDialogue = BaseIpfsDialogue
IpfsDialogues = BaseIpfsDialogues

'''
'''--- mas/packages/zarathustra/skills/plantation_abci/handlers.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the handlers for the skill of PlantationAbciApp."""

from packages.valory.skills.abstract_round_abci.handlers import (
    ABCIRoundHandler as BaseABCIRoundHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    ContractApiHandler as BaseContractApiHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    HttpHandler as BaseHttpHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    IpfsHandler as BaseIpfsHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    LedgerApiHandler as BaseLedgerApiHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    SigningHandler as BaseSigningHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    TendermintHandler as BaseTendermintHandler,
)

ABCIHandler = BaseABCIRoundHandler
HttpHandler = BaseHttpHandler
SigningHandler = BaseSigningHandler
LedgerApiHandler = BaseLedgerApiHandler
ContractApiHandler = BaseContractApiHandler
TendermintHandler = BaseTendermintHandler
IpfsHandler = BaseIpfsHandler

'''
'''--- mas/packages/zarathustra/skills/plantation_abci/models.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the shared state for the abci skill of PlantationAbciApp."""

from packages.valory.skills.abstract_round_abci.models import BaseParams
from packages.valory.skills.abstract_round_abci.models import (
    BenchmarkTool as BaseBenchmarkTool,
)
from packages.valory.skills.abstract_round_abci.models import Requests as BaseRequests
from packages.valory.skills.abstract_round_abci.models import (
    SharedState as BaseSharedState,
)
from packages.zarathustra.skills.plantation_abci.composition import PlantationAbciApp
from packages.zarathustra.skills.plantation_station_abci.models import (
    RandomnessApi as BaseRandomnessApi,
)

class SharedState(BaseSharedState):
    """Keep the current shared state of the skill."""

    abci_app_cls = PlantationAbciApp

Params = BaseParams
Requests = BaseRequests
BenchmarkTool = BaseBenchmarkTool
RandomnessApi = BaseRandomnessApi

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/__init__.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the implementation of the Plantation Station skill."""

from aea.configurations.base import PublicId

PUBLIC_ID = PublicId.from_str("zarathustra/plantation_station_abci:0.1.0")

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/behaviours.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains round behaviours of PlantationStationAbciApp."""

from abc import ABC
from typing import Generator, Set, Type, cast

from packages.valory.skills.abstract_round_abci.base import AbstractRound
from packages.valory.skills.abstract_round_abci.behaviours import (
    AbstractRoundBehaviour,
    BaseBehaviour,
)

from packages.zarathustra.skills.plantation_station_abci.sensors import Sensors

from packages.zarathustra.skills.plantation_station_abci.models import Params
from packages.zarathustra.skills.plantation_station_abci.rounds import (
    AttestProposalPayload,
    AttestProposalRound,
    CheckHarvestProposalPayload,
    CheckHarvestProposalRound,
    ControlAdjustmentPayload,
    ControlAdjustmentRound,
    FederatedLearningPayload,
    FederatedLearningRound,
    ObservationCollectionPayload,
    ObservationCollectionRound,
    PlantationStationAbciApp,
    PrepareAttestationTransactionPayload,
    PrepareAttestationTransactionRound,
    PrepareObservationTransactionPayload,
    PrepareObservationTransactionRound,
    ReadSensorDataPayload,
    ReadSensorDataRound,
    SynchronizedData,
)

class PlantationStationBaseBehaviour(BaseBehaviour, ABC):
    """Base behaviour for the plantation_station_abci skill."""
    sensors: Sensors

    @property
    def synchronized_data(self) -> SynchronizedData:
        """Return the synchronized data."""
        return cast(SynchronizedData, super().synchronized_data)

    @property
    def params(self) -> Params:
        """Return the params."""
        return cast(Params, super().params)

    def setup(self) -> None:
        """Setup behaviour."""
        super().setup()
        
        self.sensors = Sensors()
        self.context.logger.info("ReadSensorDataBehaviour: setup method called.")

class AttestProposalBehaviour(PlantationStationBaseBehaviour):
    """AttestProposalBehaviour"""

    matching_round: Type[AbstractRound] = AttestProposalRound

    # TODO: implement logic required to set payload content for synchronization
    def async_act(self) -> Generator:
        """Do the act, supporting asynchronous execution."""

        with self.context.benchmark_tool.measure(self.behaviour_id).local():
            sender = self.context.agent_address
            payload = AttestProposalPayload(sender=sender)

        with self.context.benchmark_tool.measure(self.behaviour_id).consensus():
            yield from self.send_a2a_transaction(payload)
            yield from self.wait_until_round_end()

        self.set_done()

class CheckHarvestProposalBehaviour(PlantationStationBaseBehaviour):
    """CheckHarvestProposalBehaviour"""

    matching_round: Type[AbstractRound] = CheckHarvestProposalRound

    # TODO: implement logic required to set payload content for synchronization
    def async_act(self) -> Generator:
        """Do the act, supporting asynchronous execution."""

        with self.context.benchmark_tool.measure(self.behaviour_id).local():
            sender = self.context.agent_address
            payload = CheckHarvestProposalPayload(sender=sender)

        with self.context.benchmark_tool.measure(self.behaviour_id).consensus():
            yield from self.send_a2a_transaction(payload)
            yield from self.wait_until_round_end()

        self.set_done()

class ControlAdjustmentBehaviour(PlantationStationBaseBehaviour):
    """ControlAdjustmentBehaviour"""

    matching_round: Type[AbstractRound] = ControlAdjustmentRound
    sensors: Sensors
    counter: int = 0

    def setup(self) -> None:
        """Setup the behaviour."""
        super().setup()
        self.sensors = Sensors()

    def async_act(self) -> Generator:
        """Do the act, supporting asynchronous execution."""

        self.context.logger.info(f"Adjusting brightness. Counter: {self.counter}")
        self.sensors.set_led_actuator(self.counter % 10 == 0)
        with self.context.benchmark_tool.measure(self.behaviour_id).local():
            sender = self.context.agent_address
            payload = ControlAdjustmentPayload(sender=sender)

        with self.context.benchmark_tool.measure(self.behaviour_id).consensus():
            yield from self.send_a2a_transaction(payload)
            yield from self.wait_until_round_end()
        self.counter += 1

        self.set_done()

class FederatedLearningBehaviour(PlantationStationBaseBehaviour):
    """FederatedLearningBehaviour"""

    matching_round: Type[AbstractRound] = FederatedLearningRound

    # TODO: implement logic required to set payload content for synchronization
    def async_act(self) -> Generator:
        """Do the act, supporting asynchronous execution."""

        with self.context.benchmark_tool.measure(self.behaviour_id).local():
            sender = self.context.agent_address
            payload = FederatedLearningPayload(sender=sender)

        with self.context.benchmark_tool.measure(self.behaviour_id).consensus():
            yield from self.send_a2a_transaction(payload)
            yield from self.wait_until_round_end()

        self.set_done()

class ObservationCollectionBehaviour(PlantationStationBaseBehaviour):
    """ObservationCollectionBehaviour"""

    matching_round: Type[AbstractRound] = ObservationCollectionRound

    # TODO: implement logic required to set payload content for synchronization
    def async_act(self) -> Generator:
        """Do the act, supporting asynchronous execution."""
        breakpoint()

        with self.context.benchmark_tool.measure(self.behaviour_id).local():
            sender = self.context.agent_address
            payload = ObservationCollectionPayload(sender=sender)
            # ipfs_hash = self.ipfs_client.add_json(data)

        with self.context.benchmark_tool.measure(self.behaviour_id).consensus():
            yield from self.send_a2a_transaction(payload)
            yield from self.wait_until_round_end()

        self.set_done()

class PrepareAttestationTransactionBehaviour(PlantationStationBaseBehaviour):
    """PrepareAttestationTransactionBehaviour"""

    matching_round: Type[AbstractRound] = PrepareAttestationTransactionRound

    # TODO: implement logic required to set payload content for synchronization
    def async_act(self) -> Generator:
        """Do the act, supporting asynchronous execution."""

        with self.context.benchmark_tool.measure(self.behaviour_id).local():
            sender = self.context.agent_address
            payload = PrepareAttestationTransactionPayload(sender=sender)

        with self.context.benchmark_tool.measure(self.behaviour_id).consensus():
            yield from self.send_a2a_transaction(payload)
            yield from self.wait_until_round_end()

        self.set_done()

class PrepareObservationTransactionBehaviour(PlantationStationBaseBehaviour):
    """PrepareObservationTransactionBehaviour"""

    matching_round: Type[AbstractRound] = PrepareObservationTransactionRound

    # TODO: implement logic required to set payload content for synchronization
    def async_act(self) -> Generator:
        """Do the act, supporting asynchronous execution."""

        with self.context.benchmark_tool.measure(self.behaviour_id).local():
            sender = self.context.agent_address
            payload = PrepareObservationTransactionPayload(sender=sender)

        with self.context.benchmark_tool.measure(self.behaviour_id).consensus():
            yield from self.send_a2a_transaction(payload)
            yield from self.wait_until_round_end()

        self.set_done()

class ReadSensorDataBehaviour(PlantationStationBaseBehaviour):
    """ReadSensorDataBehaviour"""

    matching_round: Type[AbstractRound] = ReadSensorDataRound

    # TODO: implement logic required to set payload content for synchronization
    def async_act(self) -> Generator:
        """Do the act, supporting asynchronous execution."""

        with self.context.benchmark_tool.measure(self.behaviour_id).local():
            sender = self.context.agent_address
            data = self.sensors.read_sensors()

            payload = ReadSensorDataPayload(
                sender=sender,
                data=data
            )

        with self.context.benchmark_tool.measure(self.behaviour_id).consensus():
            yield from self.send_a2a_transaction(payload)
            yield from self.wait_until_round_end()

        self.set_done()

class PlantationStationRoundBehaviour(AbstractRoundBehaviour):
    """PlantationStationRoundBehaviour"""

    initial_behaviour_cls = ObservationCollectionBehaviour
    abci_app_cls = PlantationStationAbciApp  # type: ignore
    behaviours: Set[Type[BaseBehaviour]] = [
        AttestProposalBehaviour,
        CheckHarvestProposalBehaviour,
        ControlAdjustmentBehaviour,
        FederatedLearningBehaviour,
        ObservationCollectionBehaviour,
        PrepareAttestationTransactionBehaviour,
        PrepareObservationTransactionBehaviour,
        ReadSensorDataBehaviour,
    ]

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/dialogues.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the dialogues of the PlantationStationAbciApp."""

from packages.valory.skills.abstract_round_abci.dialogues import (
    AbciDialogue as BaseAbciDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    AbciDialogues as BaseAbciDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    ContractApiDialogue as BaseContractApiDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    ContractApiDialogues as BaseContractApiDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    HttpDialogue as BaseHttpDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    HttpDialogues as BaseHttpDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    IpfsDialogue as BaseIpfsDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    IpfsDialogues as BaseIpfsDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    LedgerApiDialogue as BaseLedgerApiDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    LedgerApiDialogues as BaseLedgerApiDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    SigningDialogue as BaseSigningDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    SigningDialogues as BaseSigningDialogues,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    TendermintDialogue as BaseTendermintDialogue,
)
from packages.valory.skills.abstract_round_abci.dialogues import (
    TendermintDialogues as BaseTendermintDialogues,
)

AbciDialogue = BaseAbciDialogue
AbciDialogues = BaseAbciDialogues

HttpDialogue = BaseHttpDialogue
HttpDialogues = BaseHttpDialogues

SigningDialogue = BaseSigningDialogue
SigningDialogues = BaseSigningDialogues

LedgerApiDialogue = BaseLedgerApiDialogue
LedgerApiDialogues = BaseLedgerApiDialogues

ContractApiDialogue = BaseContractApiDialogue
ContractApiDialogues = BaseContractApiDialogues

TendermintDialogue = BaseTendermintDialogue
TendermintDialogues = BaseTendermintDialogues

IpfsDialogue = BaseIpfsDialogue
IpfsDialogues = BaseIpfsDialogues

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/handlers.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the handlers for the skill of PlantationStationAbciApp."""

from packages.valory.skills.abstract_round_abci.handlers import (
    ABCIRoundHandler as BaseABCIRoundHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    ContractApiHandler as BaseContractApiHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    HttpHandler as BaseHttpHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    IpfsHandler as BaseIpfsHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    LedgerApiHandler as BaseLedgerApiHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    SigningHandler as BaseSigningHandler,
)
from packages.valory.skills.abstract_round_abci.handlers import (
    TendermintHandler as BaseTendermintHandler,
)

ABCIHandler = BaseABCIRoundHandler
HttpHandler = BaseHttpHandler
SigningHandler = BaseSigningHandler
LedgerApiHandler = BaseLedgerApiHandler
ContractApiHandler = BaseContractApiHandler
TendermintHandler = BaseTendermintHandler
IpfsHandler = BaseIpfsHandler

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/models.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the shared state for the abci skill of PlantationStationAbciApp."""

from packages.valory.skills.abstract_round_abci.models import ApiSpecs, BaseParams
from packages.valory.skills.abstract_round_abci.models import (
    BenchmarkTool as BaseBenchmarkTool,
)
from packages.valory.skills.abstract_round_abci.models import Requests as BaseRequests
from packages.valory.skills.abstract_round_abci.models import (
    SharedState as BaseSharedState,
)
from packages.zarathustra.skills.plantation_station_abci.rounds import (
    PlantationStationAbciApp,
)

class SharedState(BaseSharedState):
    """Keep the current shared state of the skill."""

    abci_app_cls = PlantationStationAbciApp

class RandomnessApi(ApiSpecs):
    """A model for randomness api specifications."""

Params = BaseParams
Requests = BaseRequests
BenchmarkTool = BaseBenchmarkTool

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/payloads.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This module contains the transaction payloads of the PlantationStationAbciApp."""

from dataclasses import dataclass

from packages.valory.skills.abstract_round_abci.base import BaseTxPayload

@dataclass(frozen=True)
class AttestProposalPayload(BaseTxPayload):
    """Represent a transaction payload for the AttestProposalRound."""

    # TODO: define your attributes

@dataclass(frozen=True)
class CheckHarvestProposalPayload(BaseTxPayload):
    """Represent a transaction payload for the CheckHarvestProposalRound."""

    # TODO: define your attributes

@dataclass(frozen=True)
class ControlAdjustmentPayload(BaseTxPayload):
    """Represent a transaction payload for the ControlAdjustmentRound."""

    # TODO: define your attributes

@dataclass(frozen=True)
class FederatedLearningPayload(BaseTxPayload):
    """Represent a transaction payload for the FederatedLearningRound."""

    # TODO: define your attributes

@dataclass(frozen=True)
class ObservationCollectionPayload(BaseTxPayload):
    """Represent a transaction payload for the ObservationCollectionRound."""

    snapshot: str

@dataclass(frozen=True)
class PrepareAttestationTransactionPayload(BaseTxPayload):
    """Represent a transaction payload for the PrepareAttestationTransactionRound."""

    # TODO: define your attributes

@dataclass(frozen=True)
class PrepareObservationTransactionPayload(BaseTxPayload):
    """Represent a transaction payload for the PrepareObservationTransactionRound."""

@dataclass(frozen=True)
class ReadSensorDataPayload(BaseTxPayload):
    """Represent a transaction payload for the ReadSensorDataRound."""

    ipfs_hash: str

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/rounds.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains the rounds of PlantationStationAbciApp."""

from enum import Enum
from typing import Dict, List, Optional, Set, Tuple

from packages.valory.skills.abstract_round_abci.base import (
    AbciApp,
    AbciAppTransitionFunction,
    AbstractRound,
    AppState,
    BaseSynchronizedData,
    DegenerateRound,
    EventToTimeout,
    VotingRound,
    get_name,
)
from packages.zarathustra.skills.plantation_station_abci.payloads import (
    AttestProposalPayload,
    CheckHarvestProposalPayload,
    ControlAdjustmentPayload,
    FederatedLearningPayload,
    ObservationCollectionPayload,
    PrepareAttestationTransactionPayload,
    PrepareObservationTransactionPayload,
    ReadSensorDataPayload,
)

class Event(Enum):
    """PlantationStationAbciApp Events"""

    NO_PROPOSALS = "no_proposals"
    DONE = "done"
    ROUND_TIMEOUT = "round_timeout"
    PROPOSALS = "proposals"
    NO_MAJORITY = "no_majority"

class SynchronizedData(BaseSynchronizedData):
    """
    Class to represent the synchronized data.

    This data is replicated by the tendermint application.
    """

    @property
    def most_voted_tx_hash(self) -> float:
        """Get the most_voted_tx_hash."""
        return cast(float, self.db.get_strict("most_voted_tx_hash"))

class AttestProposalRound(VotingRound):
    """AttestProposalRound"""

    payload_class = AttestProposalPayload
    payload_attribute = ""  # TODO: update
    synchronized_data_class = SynchronizedData

    def end_block(self) -> Optional[Tuple[BaseSynchronizedData, Enum]]:
        """Process the end of the block."""
        synchronized_data = self.synchronized_data
        return synchronized_data, Event.DONE

    def check_payload(self, payload: AttestProposalPayload) -> None:
        """Check payload."""

    def process_payload(self, payload: AttestProposalPayload) -> None:
        """Process payload."""

class CheckHarvestProposalRound(AbstractRound):
    """CheckHarvestProposalRound"""

    payload_class = CheckHarvestProposalPayload
    payload_attribute = ""  # TODO: update
    synchronized_data_class = SynchronizedData

    def end_block(self) -> Optional[Tuple[BaseSynchronizedData, Enum]]:
        """Process the end of the block."""
        synchronized_data = self.synchronized_data
        import random   # TODO
        if random.random() > 0.9:
            return synchronized_data, Event.PROPOSALS
        return synchronized_data, Event.NO_PROPOSALS

    def check_payload(self, payload: CheckHarvestProposalPayload) -> None:
        """Check payload."""

    def process_payload(self, payload: CheckHarvestProposalPayload) -> None:
        """Process payload."""

class ControlAdjustmentRound(AbstractRound):
    """ControlAdjustmentRound"""

    payload_class = ControlAdjustmentPayload
    payload_attribute = ""  # TODO: update
    synchronized_data_class = SynchronizedData

    def end_block(self) -> Optional[Tuple[BaseSynchronizedData, Enum]]:
        """Process the end of the block."""
        synchronized_data = self.synchronized_data
        return synchronized_data, Event.DONE

    def check_payload(self, payload: ControlAdjustmentPayload) -> None:
        """Check payload."""

    def process_payload(self, payload: ControlAdjustmentPayload) -> None:
        """Process payload."""

class FederatedLearningRound(AbstractRound):
    """FederatedLearningRound"""

    payload_class = FederatedLearningPayload
    payload_attribute = ""  # TODO: update
    synchronized_data_class = SynchronizedData

    def end_block(self) -> Optional[Tuple[BaseSynchronizedData, Enum]]:
        """Process the end of the block."""
        synchronized_data = self.synchronized_data
        return synchronized_data, Event.DONE

    def check_payload(self, payload: FederatedLearningPayload) -> None:
        """Check payload."""

    def process_payload(self, payload: FederatedLearningPayload) -> None:
        """Process payload."""

class ObservationCollectionRound(AbstractRound):
    """ObservationCollectionRound"""

    payload_class = ObservationCollectionPayload
    payload_attribute = ""  # TODO: update
    synchronized_data_class = SynchronizedData

    def end_block(self) -> Optional[Tuple[BaseSynchronizedData, Enum]]:
        """Process the end of the block."""
        synchronized_data = self.synchronized_data
        return synchronized_data, Event.DONE

    def check_payload(self, payload: ObservationCollectionPayload) -> None:
        """Check payload."""

    def process_payload(self, payload: ObservationCollectionPayload) -> None:
        """Process payload."""

class PrepareAttestationTransactionRound(AbstractRound):
    """PrepareAttestationTransactionRound"""

    payload_class = PrepareAttestationTransactionPayload
    payload_attribute = ""  # TODO: update
    synchronized_data_class = SynchronizedData

    def end_block(self) -> Optional[Tuple[BaseSynchronizedData, Enum]]:
        """Process the end of the block."""
        synchronized_data = self.synchronized_data
        return synchronized_data, Event.DONE

    def check_payload(self, payload: PrepareAttestationTransactionPayload) -> None:
        """Check payload."""

    def process_payload(self, payload: PrepareAttestationTransactionPayload) -> None:
        """Process payload."""

class PrepareObservationTransactionRound(AbstractRound):
    """PrepareObservationTransactionRound"""

    payload_class = PrepareObservationTransactionPayload
    payload_attribute = ""  # TODO: update
    synchronized_data_class = SynchronizedData

    def end_block(self) -> Optional[Tuple[BaseSynchronizedData, Enum]]:
        """Process the end of the block."""
        synchronized_data = self.synchronized_data
        return synchronized_data, Event.DONE

    def check_payload(self, payload: PrepareObservationTransactionPayload) -> None:
        """Check payload."""

    def process_payload(self, payload: PrepareObservationTransactionPayload) -> None:
        """Process payload."""

class ReadSensorDataRound(AbstractRound):
    """ReadSensorDataRound"""

    payload_class = ReadSensorDataPayload
    payload_attribute = ""  # TODO: update
    synchronized_data_class = SynchronizedData

    def end_block(self) -> Optional[Tuple[BaseSynchronizedData, Enum]]:
        """Process the end of the block."""
        synchronized_data = self.synchronized_data
        return synchronized_data, Event.DONE

    def check_payload(self, payload: ReadSensorDataPayload) -> None:
        """Check payload."""

    def process_payload(self, payload: ReadSensorDataPayload) -> None:
        """Process payload."""

class ResetPlantationStationRound(DegenerateRound):
    """ResetPlantationStationRound"""

class TransactionSubmissionRound(DegenerateRound):
    """TransactionSubmissionRound"""

class PlantationStationAbciApp(AbciApp[Event]):
    """PlantationStationAbciApp"""

    initial_round_cls: AppState = ObservationCollectionRound
    initial_states: Set[AppState] = {ObservationCollectionRound}
    transition_function: AbciAppTransitionFunction = {
        ObservationCollectionRound: {
            Event.DONE: FederatedLearningRound,
            Event.ROUND_TIMEOUT: ResetPlantationStationRound,
            Event.NO_MAJORITY: ResetPlantationStationRound,
        },
        FederatedLearningRound: {
            Event.DONE: CheckHarvestProposalRound,
            Event.ROUND_TIMEOUT: ResetPlantationStationRound,
            Event.NO_MAJORITY: ResetPlantationStationRound,
        },
        CheckHarvestProposalRound: {
            Event.NO_PROPOSALS: ReadSensorDataRound,
            Event.PROPOSALS: AttestProposalRound,
            Event.ROUND_TIMEOUT: ResetPlantationStationRound,
            Event.NO_MAJORITY: ResetPlantationStationRound,
        },
        AttestProposalRound: {
            Event.DONE: PrepareAttestationTransactionRound,
            Event.ROUND_TIMEOUT: ResetPlantationStationRound,
            Event.NO_MAJORITY: ResetPlantationStationRound,
        },
        PrepareAttestationTransactionRound: {
            Event.DONE: TransactionSubmissionRound,
            Event.ROUND_TIMEOUT: ResetPlantationStationRound,
            Event.NO_MAJORITY: ResetPlantationStationRound,
        },
        ReadSensorDataRound: {
            Event.DONE: ControlAdjustmentRound,
            Event.ROUND_TIMEOUT: ResetPlantationStationRound,
            Event.NO_MAJORITY: ResetPlantationStationRound,
        },
        ControlAdjustmentRound: {
            Event.DONE: PrepareObservationTransactionRound,
            Event.ROUND_TIMEOUT: ResetPlantationStationRound,
            Event.NO_MAJORITY: ResetPlantationStationRound,
        },
        PrepareObservationTransactionRound: {
            Event.DONE: TransactionSubmissionRound,
            Event.ROUND_TIMEOUT: ResetPlantationStationRound,
            Event.NO_MAJORITY: ResetPlantationStationRound,
        },
        TransactionSubmissionRound: {},
        ResetPlantationStationRound: {},
    }
    final_states: Set[AppState] = {
        ResetPlantationStationRound,
        TransactionSubmissionRound,
    }
    event_to_timeout: EventToTimeout = {}
    cross_period_persisted_keys: Set[str] = set()
    db_pre_conditions: Dict[AppState, Set[str]] = {
        ObservationCollectionRound: {
            get_name(SynchronizedData.participants),
        },
    }
    db_post_conditions: Dict[AppState, Set[str]] = {
        ResetPlantationStationRound: set(),
        TransactionSubmissionRound: {get_name(SynchronizedData.most_voted_tx_hash)},
    }

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/sensors.py ---
"""
Class to interact with the sensors of the plantation station.
"""

from time import sleep

from typing import Dict, List, Optional, cast

try:
    from gpiozero import LineSensor, PWMLED
except ImportError:
    print("gpiozero not installed. Using mock instead.")
    class LineSensor:
        """Mock class for LineSensor."""
        def __init__(self, *args, **kwargs):
            self.value = 0.0

    class PWMLED:
        """Mock class for PWMLED."""
        def __init__(self, *args, **kwargs):
            self.value = 0.0

LED_ACTUATOR_PIN = 16
MOISTURE_SENSOR_PIN = 18
LOAD_SENSOR_PIN = 1

class Sensors:
    """Class to interact with the sensors of the plantation station."""

    def __init__(self):
        """Initialize the sensors."""
        self.config = {
            "led_actuator": {
                "pin": LED_ACTUATOR_PIN,
                "initial_value": 0,
            },
            "moisture_sensor": {
                "pin": MOISTURE_SENSOR_PIN,
                "queue_len": 1,
                "sample_rate": 1,
            },
            "load_sensor": {
                "pin": LOAD_SENSOR_PIN,
                "queue_len": 1,
                "sample_rate": 1,
            },

        }
        self.sensors: List[LineSensor] = []
        self.actuators: Dict[str, PWMLED] = {}
        self._setup_sensors()
        self._setup_actuators()

    def _setup_sensors(self):
        """Setup the sensors."""
        for sensor_name in self.config:
            if "sensor" in sensor_name:
                sensor = LineSensor(
                    self.config[sensor_name]["pin"],
                    queue_len=self.config[sensor_name]["queue_len"],
                    sample_rate=self.config[sensor_name]["sample_rate"],
                )
                self.sensors.append(sensor)
    
    def _setup_actuators(self):
        """Setup the actuators."""
        for actuator_name in self.config:
            if "actuator" in actuator_name:
                actuator = PWMLED(
                    self.config[actuator_name]["pin"],
                    initial_value=self.config[actuator_name]["initial_value"],
                )
                self.actuators[actuator_name] = actuator

    def read_moisture(self) -> float:
        """Read the moisture."""
        return self.sensors[0].value

    def read_load(self) -> float:
        """Read the load."""
        return self.sensors[1].value

    def set_led_actuator(self, value: float):
        """Set the led actuator."""
        self.actuators["led_actuator"].value = value

    def read_sensors(self) -> Dict[str, float]:
        """Read the sensors."""
        return {
            "moisture": self.read_moisture(),
            "load": self.read_load(),
        }

if __name__ == "__main__":
    sensors = Sensors()
    while True:
        print(sensors.read_sensors())
        sleep(1)

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/tests/__init__.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/tests/test_behaviours.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains round behaviours of PlantationStationAbciApp."""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, Hashable, Optional, Type

import pytest

from packages.valory.skills.abstract_round_abci.base import AbciAppDB
from packages.valory.skills.abstract_round_abci.behaviours import (
    AbstractRoundBehaviour,
    BaseBehaviour,
    make_degenerate_behaviour,
)
from packages.valory.skills.abstract_round_abci.test_tools.base import (
    FSMBehaviourBaseCase,
)
from packages.zarathustra.skills.plantation_station_abci.behaviours import (
    AttestProposalBehaviour,
    CheckHarvestProposalBehaviour,
    ControlAdjustmentBehaviour,
    FederatedLearningBehaviour,
    ObservationCollectionBehaviour,
    PlantationStationBaseBehaviour,
    PlantationStationRoundBehaviour,
    PrepareAttestationTransactionBehaviour,
    PrepareObservationTransactionBehaviour,
    ReadSensorDataBehaviour,
)
from packages.zarathustra.skills.plantation_station_abci.rounds import (
    AttestProposalRound,
    CheckHarvestProposalRound,
    ControlAdjustmentRound,
    DegenerateRound,
    Event,
    FederatedLearningRound,
    ObservationCollectionRound,
    PlantationStationAbciApp,
    PrepareAttestationTransactionRound,
    PrepareObservationTransactionRound,
    ReadSensorDataRound,
    ResetPlantationStationRound,
    SynchronizedData,
    TransactionSubmissionRound,
)

@dataclass
class BehaviourTestCase:
    """BehaviourTestCase"""

    name: str
    initial_data: Dict[str, Hashable]
    event: Event
    kwargs: Dict[str, Any] = field(default_factory=dict)

class BasePlantationStationTest(FSMBehaviourBaseCase):
    """Base test case."""

    path_to_skill = Path(__file__).parent.parent

    behaviour: PlantationStationRoundBehaviour
    behaviour_class: Type[PlantationStationBaseBehaviour]
    next_behaviour_class: Type[PlantationStationBaseBehaviour]
    synchronized_data: SynchronizedData
    done_event = Event.DONE

    @property
    def current_behaviour_id(self) -> str:
        """Current RoundBehaviour's behaviour id"""

        return self.behaviour.current_behaviour.behaviour_id

    def fast_forward(self, data: Optional[Dict[str, Any]] = None) -> None:
        """Fast-forward on initialization"""

        data = data if data is not None else {}
        self.fast_forward_to_behaviour(
            self.behaviour,
            self.behaviour_class.behaviour_id,
            SynchronizedData(AbciAppDB(setup_data=AbciAppDB.data_to_lists(data))),
        )
        assert self.current_behaviour_id == self.behaviour_class.behaviour_id

    def complete(self, event: Event) -> None:
        """Complete test"""

        self.behaviour.act_wrapper()
        self.mock_a2a_transaction()
        self._test_done_flag_set()
        self.end_round(done_event=event)
        assert self.current_behaviour_id == self.next_behaviour_class.behaviour_id

class TestAttestProposalBehaviour(BasePlantationStationTest):
    """Tests AttestProposalBehaviour"""

    # TODO: set next_behaviour_class
    behaviour_class: Type[BaseBehaviour] = AttestProposalBehaviour
    next_behaviour_class: Type[BaseBehaviour] = ...

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: BehaviourTestCase) -> None:
        """Run tests."""

        self.fast_forward(test_case.initial_data)
        # TODO: mock the necessary calls
        # self.mock_ ...
        self.complete(test_case.event)

class TestCheckHarvestProposalBehaviour(BasePlantationStationTest):
    """Tests CheckHarvestProposalBehaviour"""

    # TODO: set next_behaviour_class
    behaviour_class: Type[BaseBehaviour] = CheckHarvestProposalBehaviour
    next_behaviour_class: Type[BaseBehaviour] = ...

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: BehaviourTestCase) -> None:
        """Run tests."""

        self.fast_forward(test_case.initial_data)
        # TODO: mock the necessary calls
        # self.mock_ ...
        self.complete(test_case.event)

class TestControlAdjustmentBehaviour(BasePlantationStationTest):
    """Tests ControlAdjustmentBehaviour"""

    # TODO: set next_behaviour_class
    behaviour_class: Type[BaseBehaviour] = ControlAdjustmentBehaviour
    next_behaviour_class: Type[BaseBehaviour] = ...

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: BehaviourTestCase) -> None:
        """Run tests."""

        self.fast_forward(test_case.initial_data)
        # TODO: mock the necessary calls
        # self.mock_ ...
        self.complete(test_case.event)

class TestFederatedLearningBehaviour(BasePlantationStationTest):
    """Tests FederatedLearningBehaviour"""

    # TODO: set next_behaviour_class
    behaviour_class: Type[BaseBehaviour] = FederatedLearningBehaviour
    next_behaviour_class: Type[BaseBehaviour] = ...

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: BehaviourTestCase) -> None:
        """Run tests."""

        self.fast_forward(test_case.initial_data)
        # TODO: mock the necessary calls
        # self.mock_ ...
        self.complete(test_case.event)

class TestObservationCollectionBehaviour(BasePlantationStationTest):
    """Tests ObservationCollectionBehaviour"""

    # TODO: set next_behaviour_class
    behaviour_class: Type[BaseBehaviour] = ObservationCollectionBehaviour
    next_behaviour_class: Type[BaseBehaviour] = ...

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: BehaviourTestCase) -> None:
        """Run tests."""

        self.fast_forward(test_case.initial_data)
        # TODO: mock the necessary calls
        # self.mock_ ...
        self.complete(test_case.event)

class TestPrepareAttestationTransactionBehaviour(BasePlantationStationTest):
    """Tests PrepareAttestationTransactionBehaviour"""

    # TODO: set next_behaviour_class
    behaviour_class: Type[BaseBehaviour] = PrepareAttestationTransactionBehaviour
    next_behaviour_class: Type[BaseBehaviour] = ...

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: BehaviourTestCase) -> None:
        """Run tests."""

        self.fast_forward(test_case.initial_data)
        # TODO: mock the necessary calls
        # self.mock_ ...
        self.complete(test_case.event)

class TestPrepareObservationTransactionBehaviour(BasePlantationStationTest):
    """Tests PrepareObservationTransactionBehaviour"""

    # TODO: set next_behaviour_class
    behaviour_class: Type[BaseBehaviour] = PrepareObservationTransactionBehaviour
    next_behaviour_class: Type[BaseBehaviour] = ...

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: BehaviourTestCase) -> None:
        """Run tests."""

        self.fast_forward(test_case.initial_data)
        # TODO: mock the necessary calls
        # self.mock_ ...
        self.complete(test_case.event)

class TestReadSensorDataBehaviour(BasePlantationStationTest):
    """Tests ReadSensorDataBehaviour"""

    # TODO: set next_behaviour_class
    behaviour_class: Type[BaseBehaviour] = ReadSensorDataBehaviour
    next_behaviour_class: Type[BaseBehaviour] = ...

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: BehaviourTestCase) -> None:
        """Run tests."""

        self.fast_forward(test_case.initial_data)
        # TODO: mock the necessary calls
        # self.mock_ ...
        self.complete(test_case.event)

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/tests/test_dialogues.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""Test the dialogues.py module of the PlantationStation."""

import packages.zarathustra.skills.plantation_station_abci.dialogues  # noqa

def test_import() -> None:
    """Test that the 'dialogues.py' of the PlantationStation can be imported."""

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/tests/test_handlers.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""Test the handlers.py module of the PlantationStation."""

import packages.zarathustra.skills.plantation_station_abci.handlers  # noqa

def test_import() -> None:
    """Test that the 'handlers.py' of the PlantationStation can be imported."""

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/tests/test_models.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""Test the models.py module of the PlantationStation."""

from packages.valory.skills.abstract_round_abci.test_tools.base import DummyContext
from packages.zarathustra.skills.plantation_station_abci.models import SharedState

class TestSharedState:
    """Test SharedState of PlantationStation."""

    def test_initialization(self) -> None:
        """Test initialization."""
        SharedState(name="", skill_context=DummyContext())

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/tests/test_payloads.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains payload tests for the PlantationStationAbciApp."""

from dataclasses import dataclass
from typing import Hashable, Type

import pytest

from packages.zarathustra.skills.plantation_station_abci.payloads import (
    AttestProposalPayload,
    BaseTxPayload,
    CheckHarvestProposalPayload,
    ControlAdjustmentPayload,
    FederatedLearningPayload,
    ObservationCollectionPayload,
    PrepareAttestationTransactionPayload,
    PrepareObservationTransactionPayload,
    ReadSensorDataPayload,
)

@dataclass
class PayloadTestCase:
    """PayloadTestCase"""

    name: str
    payload_cls: Type[BaseTxPayload]
    content: Hashable

# TODO: provide test cases
@pytest.mark.parametrize("test_case", [])
def test_payloads(test_case: PayloadTestCase) -> None:
    """Tests for PlantationStationAbciApp payloads"""

    payload = test_case.payload_cls(sender="sender", content=test_case.content)
    assert payload.sender == "sender"
    assert payload.from_json(payload.json) == payload

'''
'''--- mas/packages/zarathustra/skills/plantation_station_abci/tests/test_rounds.py ---
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2023 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains the tests for rounds of PlantationStation."""

from dataclasses import dataclass, field
from typing import Any, Callable, Dict, Hashable, List, Mapping, Type

import pytest

from packages.valory.skills.abstract_round_abci.base import BaseTxPayload
from packages.valory.skills.abstract_round_abci.test_tools.rounds import (
    BaseCollectDifferentUntilThresholdRoundTest,
    BaseCollectSameUntilThresholdRoundTest,
    BaseOnlyKeeperSendsRoundTest,
    BaseRoundTestClass,
)
from packages.zarathustra.skills.plantation_station_abci.payloads import (
    AttestProposalPayload,
    CheckHarvestProposalPayload,
    ControlAdjustmentPayload,
    FederatedLearningPayload,
    ObservationCollectionPayload,
    PrepareAttestationTransactionPayload,
    PrepareObservationTransactionPayload,
    ReadSensorDataPayload,
)
from packages.zarathustra.skills.plantation_station_abci.rounds import (
    AbstractRound,
    AttestProposalRound,
    CheckHarvestProposalRound,
    ControlAdjustmentRound,
    Event,
    FederatedLearningRound,
    ObservationCollectionRound,
    PrepareAttestationTransactionRound,
    PrepareObservationTransactionRound,
    ReadSensorDataRound,
    SynchronizedData,
)

@dataclass
class RoundTestCase:
    """RoundTestCase"""

    name: str
    initial_data: Dict[str, Hashable]
    payloads: Mapping[str, BaseTxPayload]
    final_data: Dict[str, Hashable]
    event: Event
    synchronized_data_attr_checks: List[Callable] = field(default_factory=list)
    kwargs: Dict[str, Any] = field(default_factory=dict)

MAX_PARTICIPANTS: int = 4

class BasePlantationStationRoundTest(BaseRoundTestClass):
    """Base test class for PlantationStation rounds."""

    round_cls: Type[AbstractRound]
    synchronized_data: SynchronizedData
    _synchronized_data_class = SynchronizedData
    _event_class = Event

    def run_test(self, test_case: RoundTestCase) -> None:
        """Run the test"""

        self.synchronized_data.update(**test_case.initial_data)

        test_round = self.round_cls(
            synchronized_data=self.synchronized_data,
        )

        self._complete_run(
            self._test_round(
                test_round=test_round,
                round_payloads=test_case.payloads,
                synchronized_data_update_fn=lambda sync_data, _: sync_data.update(
                    **test_case.final_data
                ),
                synchronized_data_attr_checks=test_case.synchronized_data_attr_checks,
                exit_event=test_case.event,
                **test_case.kwargs,  # varies per BaseRoundTestClass child
            )
        )

class TestAttestProposalRound(BasePlantationStationRoundTest):
    """Tests for AttestProposalRound."""

    round_class = AttestProposalRound

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: RoundTestCase) -> None:
        """Run tests."""

        self.run_test(test_case)

class TestCheckHarvestProposalRound(BasePlantationStationRoundTest):
    """Tests for CheckHarvestProposalRound."""

    round_class = CheckHarvestProposalRound

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: RoundTestCase) -> None:
        """Run tests."""

        self.run_test(test_case)

class TestControlAdjustmentRound(BasePlantationStationRoundTest):
    """Tests for ControlAdjustmentRound."""

    round_class = ControlAdjustmentRound

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: RoundTestCase) -> None:
        """Run tests."""

        self.run_test(test_case)

class TestFederatedLearningRound(BasePlantationStationRoundTest):
    """Tests for FederatedLearningRound."""

    round_class = FederatedLearningRound

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: RoundTestCase) -> None:
        """Run tests."""

        self.run_test(test_case)

class TestObservationCollectionRound(BasePlantationStationRoundTest):
    """Tests for ObservationCollectionRound."""

    round_class = ObservationCollectionRound

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: RoundTestCase) -> None:
        """Run tests."""

        self.run_test(test_case)

class TestPrepareAttestationTransactionRound(BasePlantationStationRoundTest):
    """Tests for PrepareAttestationTransactionRound."""

    round_class = PrepareAttestationTransactionRound

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: RoundTestCase) -> None:
        """Run tests."""

        self.run_test(test_case)

class TestPrepareObservationTransactionRound(BasePlantationStationRoundTest):
    """Tests for PrepareObservationTransactionRound."""

    round_class = PrepareObservationTransactionRound

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: RoundTestCase) -> None:
        """Run tests."""

        self.run_test(test_case)

class TestReadSensorDataRound(BasePlantationStationRoundTest):
    """Tests for ReadSensorDataRound."""

    round_class = ReadSensorDataRound

    # TODO: provide test cases
    @pytest.mark.parametrize("test_case", [])
    def test_run(self, test_case: RoundTestCase) -> None:
        """Run tests."""

        self.run_test(test_case)

'''
'''--- scripts/deployment/deploy_01_grow_registry.js ---
/*global process*/

const { ethers } = require("hardhat");

async function main() {
    const fs = require("fs");
    const globalsFile = "globals.json";
    const dataFromJSON = fs.readFileSync(globalsFile, "utf8");
    let parsedData = JSON.parse(dataFromJSON);
    const providerName = parsedData.providerName;
    const gasPriceInGwei = parsedData.gasPriceInGwei;
    const growRegistryName = parsedData.growRegistryName;
    const growRegistrySymbol = parsedData.growRegistrySymbol;
    const baseURI = parsedData.baseURI;

    const signers = await ethers.getSigners();
    const EOA = signers[0];

    // EOA address
    const deployer = await EOA.getAddress();
    console.log("EOA is:", deployer);

    // Transaction signing and execution
    console.log("1. EOA to deploy GrowRegistry");
    const gasPrice = ethers.utils.parseUnits(gasPriceInGwei, "gwei");
    const ServiceRegistry = await ethers.getContractFactory("GrowRegistry");
    console.log("You are signing the following transaction: GrowRegistry.connect(EOA).deploy()");
    const growRegistry = await ServiceRegistry.connect(EOA).deploy(growRegistryName, growRegistrySymbol, baseURI, { gasPrice });
    const result = await growRegistry.deployed();

    // Transaction details
    console.log("Contract deployment: GrowRegistry");
    console.log("Contract address:", growRegistry.address);
    console.log("Transaction:", result.deployTransaction.hash);
    // Wait half a minute for the transaction completion
    await new Promise(r => setTimeout(r, 30000));

    // Writing updated parameters back to the JSON file
    parsedData.growRegistryAddress = growRegistry.address;
    fs.writeFileSync(globalsFile, JSON.stringify(parsedData));

    // Contract verification
    if (parsedData.contractVerification) {
        const execSync = require("child_process").execSync;
        execSync("npx hardhat verify --constructor-args scripts/deployment/verify_01_grow_registry.js --network " + providerName + " " + growRegistry.address, { encoding: "utf-8" });
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

'''
'''--- scripts/deployment/verify_01_grow_registry.js ---
const fs = require("fs");
const globalsFile = "globals.json";
const dataFromJSON = fs.readFileSync(globalsFile, "utf8");
const parsedData = JSON.parse(dataFromJSON);
const growRegistryName = parsedData.growRegistryName;
const growRegistrySymbol = parsedData.growRegistrySymbol;
const baseURI = parsedData.baseURI;

module.exports = [
    growRegistryName,
    growRegistrySymbol,
    baseURI
];
'''
'''--- test/GrowRegistry.js ---
/*global describe, context, beforeEach, it*/

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("GrowRegistry", function () {
    let growRegistry;
    let reentrancyAttacker;
    let signers;
    const growHash = "0x" + "9".repeat(64);
    const growHash1 = "0x" + "1".repeat(64);
    const growHash2 = "0x" + "2".repeat(64);
    const AddressZero = "0x" + "0".repeat(40);
    const ZeroBytes32 = "0x" + "0".repeat(64);
    const growId = 1;
    beforeEach(async function () {
        const GrowRegistry = await ethers.getContractFactory("GrowRegistry");
        growRegistry = await GrowRegistry.deploy("grow", "GROW", "https://localhost/grow/");
        await growRegistry.deployed();

        const ReentrancyAttacker = await ethers.getContractFactory("ReentrancyAttacker");
        reentrancyAttacker = await ReentrancyAttacker.deploy(growRegistry.address);
        await reentrancyAttacker.deployed();

        signers = await ethers.getSigners();
    });

    context("Initialization", async function () {
        it("Checking for arguments passed to the constructor", async function () {
            expect(await growRegistry.name()).to.equal("grow");
            expect(await growRegistry.symbol()).to.equal("GROW");
            expect(await growRegistry.baseURI()).to.equal("https://localhost/grow/");
        });

        it("Should fail when checking for the token id existence", async function () {
            const tokenId = 0;
            expect(await growRegistry.exists(tokenId)).to.equal(false);
        });

        it("Setting the base URI", async function () {
            await growRegistry.setBaseURI("https://localhost2/grow/");
            expect(await growRegistry.baseURI()).to.equal("https://localhost2/grow/");
        });
    });

    context("Grow creation", async function () {
        it("Should fail when creating an grow with a zero owner address", async function () {
            const growFactory = signers[1];
            const user = signers[2];
            
            await expect(
                growRegistry.connect(growFactory).create(AddressZero, AddressZero, growHash)
            ).to.be.revertedWithCustomError(growRegistry, "ZeroAddress");

            await expect(
                growRegistry.connect(growFactory).create(user.address, AddressZero, growHash)
            ).to.be.revertedWithCustomError(growRegistry, "ZeroAddress");
        });

        it("Should fail when creating an grow with a zero owner address", async function () {
            const growFactory = signers[1];
            const user = signers[2];
            
            await expect(
                growRegistry.connect(growFactory).create(user.address, user.address, ZeroBytes32)
            ).to.be.revertedWithCustomError(growRegistry, "ZeroValue");
        });

        it("Token Id=1 after first successful grow creation must exist ", async function () {
            const growFactory = signers[1];
            const user = signers[2];
            const tokenId = 1;
            
            await growRegistry.connect(growFactory).create(user.address, user.address, growHash);
            expect(await growRegistry.balanceOf(user.address)).to.equal(1);
            expect(await growRegistry.exists(tokenId)).to.equal(true);

            // Check the token URI
            const baseURI = "https://localhost/grow/";
            const cidPrefix = "f01701220";
            expect(await growRegistry.tokenURI(1)).to.equal(baseURI + cidPrefix + "9".repeat(64));

            // Try to return a token URI of a non-existent unit Id
            await expect(
                growRegistry.tokenURI(2)
            ).to.be.revertedWithCustomError(growRegistry, "GrowNotFound");
        });

        it("Catching \"Transfer\" event log after successful creation of an grow", async function () {
            const growFactory = signers[1];
            const user = signers[2];
            
            const grow = await growRegistry.connect(growFactory).create(user.address, user.address, growHash);
            const result = await grow.wait();
            expect(result.events[0].event).to.equal("Transfer");
        });
    });

    context("Grow process", async function () {
        it("Should fail when trying to change the wrong grow state", async function () {
            const growOwner = signers[0];
            const grower = signers[1];

            await growRegistry.create(growOwner.address, grower.address, growHash);

            await expect(
                growRegistry.setGrowState(growId, 1)
            ).to.be.revertedWithCustomError(growRegistry, "MultisigOnly");

            await expect(
                growRegistry.connect(grower).harvest(growId)
            ).to.be.revertedWithCustomError(growRegistry, "WrongGrowState");

            await expect(
                growRegistry.connect(grower).redeem(growId)
            ).to.be.revertedWithCustomError(growRegistry, "GrowerOnly");

            await expect(
                growRegistry.connect(growOwner).redeem(growId)
            ).to.be.revertedWithCustomError(growRegistry, "WrongGrowState");
        });

        it("Grow process workflow", async function () {
            const growOwner = signers[0];
            const grower = signers[1];
            const multisig = signers[2];
            // Create the grow
            await growRegistry.create(growOwner.address, grower.address, growHash);
            // Set the multisig
            await growRegistry.setMultisig(multisig.address);
            // Propose to harvest
            await growRegistry.connect(grower).proposeToHarvest(growId);
            // Approve by the agent multisig
            await growRegistry.connect(multisig).setGrowState(growId, true);
            // Harvest the grow
            await growRegistry.connect(grower).harvest(growId);
            // Approve for redeem
            await growRegistry.connect(grower).approveRedeem(growId);
            // Redeem
            await growRegistry.connect(growOwner).redeem(growId);
        });
    });

    context("Updating hashes", async function () {
        it("Should fail when the grow does not belong to the owner or IPFS hash is invalid", async function () {
            const growFactory = signers[1];
            const user = signers[2];
            const user2 = signers[3];
            
            await growRegistry.connect(growFactory).create(user.address, user.address,
                growHash);
            await growRegistry.connect(growFactory).create(user2.address, user2.address, growHash1);
            await expect(
                growRegistry.updateHash(1, growHash2)
            ).to.be.revertedWithCustomError(growRegistry, "GrowerOnly");
            await expect(
                growRegistry.updateHash(2, growHash2)
            ).to.be.revertedWithCustomError(growRegistry, "GrowerOnly");
            await growRegistry.connect(user).updateHash(1, growHash2);
        });

        it("Update hash, get component hashes", async function () {
            const growFactory = signers[1];
            const user = signers[2];
            
            await growRegistry.connect(growFactory).create(user.address, user.address, growHash);

            // Try to update with a zero hash
            await expect(
                growRegistry.connect(user).updateHash(1, ZeroBytes32)
            ).to.be.revertedWithCustomError(growRegistry, "ZeroValue");

            // Update hashes
            await growRegistry.connect(user).updateHash(1, growHash1);
            expect((await growRegistry.mapGrows(1)).hash).to.equal(growHash1);
            await growRegistry.connect(user).updateHash(1, growHash2);
            expect((await growRegistry.mapGrows(1)).hash).to.equal(growHash2);
        });
    });

    context("Reentrancy attack", async function () {
        it("Reentrancy attack by the manager during the service creation", async function () {
            // Simulate the reentrancy attack
            await expect(
                reentrancyAttacker.createBadAgent(reentrancyAttacker.address, reentrancyAttacker.address, growHash)
            ).to.be.revertedWithCustomError(growRegistry, "ReentrancyGuard");
        });
    });
});

'''