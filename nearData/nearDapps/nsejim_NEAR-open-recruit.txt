*GitHub Repository "nsejim/NEAR-open-recruit"*

'''--- README.md ---
# OpenRecruit

OpenRecruit is a multi smart contract DApp to proof the concept of an open and trustless recruitment process running on NEAR Blockchain Protocol. 

## Concept (DONE)

Today's online recruitment services experience different trust-related challenges that natively result from the centralized architecture of their online jobboards. The latters are the user interfaces for posting jobs (recruiter user) and submitting applications (job candidate). 

To name a few of those challenges:
  - a job candidate has to upload its proofs of qualification in each of different jobboards where he/she want to apply for a job
  - once application submiited, the candidate has to trust the online service to effectively transmit its application to the recruiter
  - it is not guaranteed that jobs posted under the same publication package (price) are listed in the pre-defined order (newest on top foe instance) 

With the proposed collaborative smart contracts, we empower both type of users in the following ways:
  1. A candidate can manage his/her open proofs of qualification in an open way
  2. A candidate can verify if the recruiter has effectively consulted his/her application
  3. Recruiters can verify that the positions of their jobs in the listing is as promised 

### Example Story (DONE)

Let's describe a typical end to end user story as a sequence of actions from the following different type of users:
  1. Two recruiters: "NEAR" and "TESLA" 
  2. One candidate "Alice" 

The following actions
  1. Each recruiter registers as Recruiter
  2. Each recruiter posts one or several jobs on the "open recruitment" jobboard. 
  3. Alice upload her open proofs of qualifications in the OpenProofs Dapp.
  4. Alice visits the "open recruitment" jobboard and she opens the "RUST developer" job at "NEAR" for applying. 
  5. On the application form, Alice checks the box authorizing to link its "open proofs" information to the submitted application.
  6. The NEAR recruiter receives the Alice's application and ack its reception

## Repository contents (TODO)

This repository includes:

- Two smart contracts
- [Unit tests](https://docs.near.org/docs/roles/developer/contracts/test-contracts#unit-tests) and [simulation tests](https://docs.near.org/docs/roles/developer/contracts/test-contracts#simulation-tests) for the contract(s)
- Wireframes for the potential dApp UI of each smart contract
- Utilities for building, testing, and deploying contracts (facilitated by the [NEAR CLI](https://docs.near.org/docs/development/near-cli))

### Installation

1. clone this repo
2. run `yarn install` (or `npm install`)
3. run `yarn build` (or `npm run build`)
4. run `yarn test` (or `npm run test`)
5. explore the contents of `src/`

See below for more convenience scripts ...

### Commands (TODO)

**Compile source to WebAssembly**

```sh
yarn build                    # asb --target debug
yarn build:release            # asb
```

**Run unit tests**

```sh
yarn test:unit                # asp --verbose --nologo -f unit.spec
```

**Run simulation tests**

These tests can be run from within VSCode (or any Rust-compatible IDE) or from the command line.

_NOTE: Rust is required_

```sh
yarn test:simulate            # yarn build:release && cargo test -- --nocapture
```

**Run all tests**

```sh
yarn test                     # yarn test:unit && test:simulate
```

## UI Wireframes (TODO)

## File Structure (TODO)

### Factory (TO UNDERSTAND)

## Live DApps on NEAR testnet (DONE)

The 2 smart-contracts have been deployed on NEAR testnet under the following accounts:
- openproofs.ncd.nsejim.testnet
- openboard.ncd.nsejim.testnet

### Future Development (DONE)

Some ideas for future feature development:

- Enable each recruiter to open its own open jobboard

### Key Contributors (DONE)

- [Jimmy NSENGA - @amgando](https://github.com/nsejim)

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/openboard",
    "src/openproofs"
  ]
}

'''
'''--- package.json ---
{
  "name": "open-recruitment",
  "version": "0.0.1",
  "description": "A set of smart contracts to enable open and transparent recruitment process.",
  "license": "UNLICENSED",
  "private": true,
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn test:unit && yarn test:simulate",
    "clean": "rm -rf ./build",
    "test:debug": "node --inspect-brk ./node_modules/.bin/asp"
  },
  "keywords": [],
  "author": "jimmy.nsenga@gmail.com",
  "dependencies": {
    "near-sdk-as": "^3.2.3"
  }
}

'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/openboard/__tests__/application.unit.spec.ts ---
import { Context, VMContext } from "near-sdk-as";
import { Application } from '../assembly/models/application';

describe('Application Model', () => {
    beforeEach(() => {
        VMContext.setSigner_account_id("alice.testnet");
    });

    it('should correctly set the candidate account Id', () => {
        const newApplication = new Application("1", "JOB-1234", "Alice", []);

        expect(newApplication.applicantAccountId).toBe("alice.testnet");
    })

    it('should have createdOn date set', () => {
        const newApplication = new Application("1", "JOB-1234", "Alice", []);

        expect(newApplication.createdOn).toStrictEqual(Context.blockTimestamp);
    })
})

'''
'''--- src/openboard/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/openboard/__tests__/index.unit.spec.ts ---

import { Context, VMContext } from 'near-sdk-as'
import { registerAsEmployer, postJob, updateJob, listJobs, apply, listApplications } from '../assembly';
import { employers, jobs, applications } from '../assembly/states';

describe('openboard Contract', () => {

  beforeEach(() => {
    VMContext.setSigner_account_id("employer.testnet");
    registerAsEmployer({
      name: 'NEAR',
      accountId: ''
    })
  });

  describe('registerAsEmployer method', () => {
    it('should correctly register the sender account as an employer', () => {
            
      const sender = Context.sender;
      expect(employers.contains(sender)).toBe(true);
      expect(employers.getSome(sender).name).toBe("NEAR")
      expect(employers.getSome(sender).accountId).toBe("employer.testnet")
    })
  })
  
  describe('postJob method', () => {
    it('should correctly post a job for a registered user ', () => {

      const jobId = postJob({
        title: "Software Developer",
        deadline: <u64> Date.now()
      })

      expect(jobs.length).toBe(1);
      expect(jobs[0].createdOn).toStrictEqual(Context.blockTimestamp);
      expect(jobs[0].id).toBe(jobId);
    })
  })

  describe('updateJob method', () => {
    it('should update the job correctly', () => {
      const jobId = postJob({
        title: "Software Developer",
        deadline: <u64> Date.now()
      })
      const job = jobs[0];
      job.data.title = "Blockchain Analyst";
      const index = updateJob(jobId, job.data);
      expect(index).toBe(0);
      expect(jobs[index].data.title).toBe("Blockchain Analyst");

    })

    it('should not updated the job if the sender is different from the employer owner', () => {
      const jobId = postJob({
        title: "Software Developer",
        deadline: <u64> Date.now()
      })
      expect(jobs[0].data.title).toStrictEqual("Software Developer");

      VMContext.setSigner_account_id("employer1.testnet");
      const job = jobs[0];
      job.data.title = "Blockchain Analyst";
      const index = updateJob(jobId, job.data);
      expect(index).toBe(0);
      expect(jobs[index].data.title).toBe("Software Developer");

    })
  })

  describe('listJobs method', () => {
    it('should returns empty list when no job has been created yet', () => {

      expect(listJobs().length).toBe(0);
    })

    it('should returns a jobs list containing the created job', () => {
      registerAsEmployer({
  name: 'NEAR',
  accountId: ''
})
      const jobId = postJob({
        title: "Software Developer",
        deadline: <u64> Date.now()
      })

      const data = listJobs();
      expect(data.length).toBe(1);
      expect(data[0].employer.name).toStrictEqual("NEAR");
      expect(data[0].id).toBe(jobId);
    })

    it('should only return the jobs list of the related employer', () => {
      registerAsEmployer({
        name: 'NEAR',
        accountId: ''
      })
      postJob({
        title: "Software Developer",
        deadline: <u64> Date.now()
      })

      VMContext.setSigner_account_id("employer2.testnet");
      registerAsEmployer({
        name: 'AMAZON',
        accountId: ''
      })
      postJob({
        title: "Devops Engineer",
        deadline: <u64> Date.now()
      })

      let data = listJobs();
      expect(data.length).toBe(2);
      expect(data[1].employer.name).toStrictEqual("AMAZON");
      
      VMContext.setSigner_account_id("employer.testnet");
      data = listJobs(true);
      expect(data.length).toBe(1);

    })
  })

  describe('apply method', () => {
    it('should correctly save the application', () => {
      VMContext.setSigner_account_id("employer.testnet");
      registerAsEmployer({
        name: 'NEAR',
        accountId: ''
      })
      const jobId = postJob({
        title: "Devops Engineer",
        deadline: <u64> Date.now()
      })

      VMContext.setSigner_account_id("alice.testnet");
      apply(jobId, "Alice", []);
      const receivedApplications = listApplications(jobId);
      expect(receivedApplications.length).toBe(1);
      expect(receivedApplications[0].applicantAccountId).toBe("alice.testnet");
    })
  })
})

'''
'''--- src/openboard/__tests__/job.unit.spec.ts ---

import { Context } from 'near-sdk-as';
import { VMContext } from 'near-mock-vm';
import { Job } from '../assembly/models/job';

describe('Job Model', () => {

    beforeEach(() => {
        VMContext.setSigner_account_id("employer.testnet");
    });

    it("should have the employer accountId set correctly after job is created", () => {
        const id: string = "1";
        const job = new Job(id, {
            title: "NEAR full stack developer",
            deadline: <u64>Date.fromString("2022/02/28 15:00").getTime()
        });
        
        expect(job.employerAccountId).toStrictEqual("employer.testnet");
    })

    it('should have createdOn date set', () => {
        const id: string = "1";
        const job = new Job(id, {
            title: "NEAR full stack developer",
            deadline: <u64>Date.fromString("2022/02/28 15:00").getTime()
        });

        expect(job.createdOn).toStrictEqual(Context.blockTimestamp);
    })

    it('should id be correctly set', () => {
        const id: string = "1";
        const job = new Job(id, {
            title: "NEAR full stack developer",
            deadline: <u64>Date.fromString("2022/02/28 15:00").getTime()
        });

        expect(job.id).toBe(id);
    })
   
})

'''
'''--- src/openboard/asconfig.json ---
{
    "extends": "near-sdk-as/asconfig.json"
}
'''
'''--- src/openboard/assembly/index.ts ---
import { Context, ContractPromise, logging } from 'near-sdk-as'

import { Job, Employer, JobState, EmployerJobPair }  from "./models/job";
import { jobs, employers, applications } from './states';
import { generateUniqueId } from '../../utils';
import { Application } from './models/application';
import { GetProofArgs } from './models/openProofAPI';

const OPENPROOFS_CONTRACT= "openproofs.ncd.nsejim.test";

// changeMethods
export function registerAsEmployer(employer: Employer): void {
  employer.accountId = Context.sender;
  if(employer.accountId) {
    employers.set(employer.accountId, employer); // add the current sender account as employer
    logging.log(`Employer ${Context.sender} is successfully registered!`)
  } else {
    logging.log(`Failed to create employer.`)
  }

}

export function postJob(job: JobState): string {
  assert(employers.contains(Context.sender), "Employer not registered!");
  const existingJobIds: string[] = listJobs().map<string>(job => job.id);
  const id: string = generateUniqueId("JOB", existingJobIds);
  const newJob = new Job(id, job); // create the new job
  jobs.push(newJob); // add in the jobs set
  logging.log(`The job ${job.title} is posted!`)
  return newJob.id;
}

export function updateJob(id: string, job: JobState): i32 {
  const allJobs: EmployerJobPair[] = listJobs();
  const oldJobIndex: i32 = <i32> listJobs().map<string>(job => job.id).indexOf(id);
  assert(oldJobIndex > -1, "Job to be updated has not been found");
  const jobData: Job = jobs[oldJobIndex];
  if(Context.sender == jobData.employerAccountId) {
    jobData.id = id || generateUniqueId("JOB", allJobs.map<string>(job => job.id));
    jobData.data = job;
    jobData.updatedOn = Context.blockTimestamp;
    jobs.replace(oldJobIndex, jobData);
    logging.log(`The job ${job.title} has been well updated!`)
  } else {
    logging.log(`A job can only be updated by its owner!`)
    
  }
  return <i32>oldJobIndex;
}

export function apply(jobId: string, name: string, proofIds: string[]): string {
  const receivedApplications = listApplications(jobId);
  assert(receivedApplications.findIndex(application => application.applicantAccountId === Context.sender) < 0, "A candidate can only apply once on a given job");
  const existingApplicationIds: string[] = listApplications(jobId).map<string>(application => application.id);
  const id: string = generateUniqueId("APP", existingApplicationIds);
  const newApplication = new Application(id, jobId, name, proofIds);
  applications.push(newApplication);
  return newApplication.id;
}

export function viewProof(jobId: string, applicationId: string, proofId: string): void {
      const application: Application = viewApplication(jobId, applicationId);
      callGetProof(application.applicantAccountId, proofId);
}

function callGetProof(accountId: string, proofId: string): void {
  let args: GetProofArgs = { accountId, proofId };
  let promise = ContractPromise.create(
                        OPENPROOFS_CONTRACT, 
                        "getProof", 
                        args, 
                        100000000000000);
  logging.log("Open Proof Contract called !")
  promise.returnAsResult();
}

// viewMethods
export function listJobs(myJobsOnly: boolean = false): EmployerJobPair[] {
  let allJobs: Array<Job> = [];
  for (let index = 0; index < jobs.length; index++) {
    const element = jobs[index];
    allJobs.push(element);
  } 
  if (myJobsOnly) {  
    allJobs = allJobs.filter(job => job.employerAccountId == Context.sender); // filter only the job for this sender employer
  }
  return allJobs.map<EmployerJobPair>(job => {
    const employer = employers.getSome(job.employerAccountId);
    return {
      id: job.id,
      employer: {
        name: employer.name ,
        accountId: job.employerAccountId
      },
      data: job.data,
      createdOn: job.createdOn, 
      updatedOn: job.updatedOn
    }
  })
}

export function listApplications(jobId: string): Application[] {
  let jobs = listJobs();
  const jobIndex: i32 = <i32> jobs.map<string>(job => job.id).indexOf(jobId);
  let job: EmployerJobPair = jobs[jobIndex];
  let jobApplications: Array<Application> = [];
  if (job) {  
    for (let index = 0; index < applications.length; index++) {
      const application = applications[index];
      if (application.jobId == job.id) {
        jobApplications.push(application);
      }
    } 
  }
  return jobApplications;
}

export function viewApplication(jobId: string, applicationId: string): Application {
  const jobApplications = listApplications(jobId);
  const applicationIdx = jobApplications.map<string>(app => app.id).indexOf(applicationId);
  return jobApplications[applicationIdx];
}
'''
'''--- src/openboard/assembly/models/application.ts ---
import { Context } from "near-sdk-as";

@nearBindgen
export class Application {
    createdOn: u64; 
    applicantAccountId: string; 

    constructor (
        public id: string,
        public jobId: string,
        public name: string, 
        public proofIds: string[]) {
            this.createdOn = <u64>Context.blockTimestamp;
            this.applicantAccountId = Context.sender; // The  job is only created by the sender account
    }
}
'''
'''--- src/openboard/assembly/models/job.ts ---
import { Context } from "near-sdk-as";

@nearBindgen
export class Employer {
    name: string;
    accountId: string;
}

@nearBindgen
export class JobState {
    title: string;
    deadline: u64;
}

@nearBindgen
export class EmployerJobPair {
    id: string;
    employer: Employer;
    data: JobState;
    createdOn: u64; 
    updatedOn: u64;
};

@nearBindgen
export class Job { 
    employerAccountId: string;
    createdOn: u64; 
    updatedOn: u64;
    constructor(public id: string, public data: JobState) {
        this.createdOn = <u64>Context.blockTimestamp;
        this.employerAccountId = Context.sender; // The  job is only created by the sender account
    }
}

'''
'''--- src/openboard/assembly/models/openProofAPI.ts ---

@nearBindgen
export class ListProofsArgs {
    accountId: string;
}

@nearBindgen
export class GetProofArgs {
    accountId: string;
    proofId: string;
}
'''
'''--- src/openboard/assembly/states.ts ---
import { PersistentMap, PersistentVector } from "near-sdk-as";
import { Employer, Job } from "./models/job";
import { Application } from './models/application';

type AccountId = string;
export const employers = new PersistentMap<AccountId, Employer>("employers");
export const jobs = new PersistentVector<Job>("jobs");
export const applications = new PersistentVector<Application>("applications");
'''
'''--- src/openproofs/__tests__/index.unit.spec.ts ---

import { VMContext } from 'near-sdk-as';
import { listProofs, recordProof } from '../assembly';
import { Context } from 'near-sdk-as';
import { Proof, ProofData, PROOF_TYPE } from '../assembly/models/proof';
import { getProof } from '../assembly/index';

const OPENPROOFS_CONTRACT= "openproofs.ncd.nsejim.test";

describe("Openoroofs Contract", () => {
    beforeEach(() => {
        VMContext.setCurrent_account_id("alice.testnet")
    })

    describe("recordProof method", () => {
        it('should add the new proof in the proof list of the sender', () => {
            VMContext.setSigner_account_id("near.testnet");
            const proofData: ProofData =  {
                description: "NCD",
                type: PROOF_TYPE.CERTIFICATE,
                date: Context.blockTimestamp
            }
            recordProof(proofData, "alice.testnet");

            expect(listProofs("alice.testnet").length).toBe(1);
            expect(listProofs("alice.testnet")[0].associatedAccountId).toBe("alice.testnet");
        })
    })

    describe("getProof method", () => {
        it('should get data of requested proofId', () => {
            VMContext.setSigner_account_id("near.testnet");
            const proofData: ProofData =  {
                description: "NCD",
                type: PROOF_TYPE.CERTIFICATE,
                date: Context.blockTimestamp
            }
            const proofId = recordProof(proofData, "alice.testnet");
            VMContext.setSigner_account_id(OPENPROOFS_CONTRACT);
            const requestedProof: Proof = getProof("alice.testnet", proofId);
            expect(requestedProof.data.description).toBe("NCD")
        })
    })
})
'''
'''--- src/openproofs/__tests__/proof.unit.spec.ts ---
import { Context, VMContext } from "near-sdk-as";
import { Proof, ProofData, PROOF_TYPE } from '../assembly/models/proof';

describe('Proof Model', () => {
    beforeEach(() => {
        VMContext.setSigner_account_id("alice.testnet");
    });

    it('should correctly record the proof addedBy and associated Account Ids', () => {
        VMContext.setSigner_account_id("near.testnet");
        const proofData: ProofData =  {
            description: "NCD",
            type: PROOF_TYPE.CERTIFICATE,
            date: Context.blockTimestamp
        }
        const newProof = new Proof("1", proofData, "alice.testnet");

        expect(newProof.addedByAccountId).toBe("near.testnet");
        expect(newProof.associatedAccountId).toBe("alice.testnet");
    })

})

'''
'''--- src/openproofs/asconfig.json ---
{
    "extends": "near-sdk-as/asconfig.json"
}
'''
'''--- src/openproofs/assembly/index.ts ---
import { Proof, ProofData } from "./models/proof";
import { proofs } from './states';
import { Context } from 'near-sdk-as';
import { generateUniqueId } from "../../utils";

const OPENPROOFS_CONTRACT= "openproofs.ncd.nsejim.test";

export function recordProof(proofData: ProofData, associatedAccountId: string = ''): string {
  associatedAccountId = associatedAccountId || Context.sender;
  const accountProofs = listProofs(associatedAccountId) ;
  const existingJProofIds: string[] = accountProofs.map<string>(proof => proof.id);
  
  const id: string = generateUniqueId("PROOF", existingJProofIds);
  const newProof = new Proof(id, proofData, associatedAccountId);
  accountProofs.push(newProof);

  proofs.set(associatedAccountId, accountProofs);
  return newProof.id;
}

// viewMethods
export function listProofs(accountId: string): Proof[]  {
  const result = proofs.get(accountId);
  return  result ? result : [];
}

export function getProof(accountId: string, proofId: string): Proof {
  const allProofs = listProofs(accountId);
  const proofIdx = allProofs.map<string>(proof => proof.id).indexOf(proofId);
  return allProofs[proofIdx];
}

'''
'''--- src/openproofs/assembly/models/proof.ts ---
import { Context } from 'near-sdk-as';

export enum PROOF_TYPE {
    CERTIFICATE,
    DRIVING_LICENCE,
    DEGREE
}

@nearBindgen
export class ProofData {
    description: string;
    type: PROOF_TYPE;
    date: u64;
}

@nearBindgen
export class Proof {
    recordedOn: u64;
    addedByAccountId: string; 

    constructor(
        public id: string,
        public data: ProofData, 
        public associatedAccountId: string = ''
        ) {
        this.addedByAccountId = Context.sender;
        this.recordedOn = Context.blockTimestamp;
    }
}
'''
'''--- src/openproofs/assembly/states.ts ---
import { PersistentMap } from "near-sdk-as";
import { Proof } from './models/proof';

type AccountId = string;
export const proofs = new PersistentMap<AccountId, Proof[]>("proofs");

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { RNG } from "near-sdk-as";

export function generateUniqueId(prefix: string, ids: string[]): string {
    const roll = new RNG<u32>(1, u32.MAX_VALUE);
    const id =  `${prefix}-${roll.next().toString()}`;
    if (ids.includes(id)) {
        return generateUniqueId(prefix, ids);
    }
    return id;
}
'''