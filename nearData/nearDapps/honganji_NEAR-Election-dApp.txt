*GitHub Repository "honganji/NEAR-Election-dApp"*

'''--- .eslintrc.js ---
module.exports = {
  env: {
    browser: false,
    es2021: true,
    mocha: true,
    node: true,
  },
  plugins: ['@typescript-eslint'],
  extends: ['standard', 'prettier', 'plugin:node/recommended'],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 12,
  },
  rules: {
    'node/no-unsupported-features/es-syntax': [
      'error',
      { ignores: ['modules'] },
    ],
    'node/no-unpublished-require': ['warn', { allowModules: ['bn.js'] }],
    'node/no-unpublished-import': ['warn'],
    'node/no-missing-import': ['warn'],
    'no-lone-blocks': ['off'],
    'no-unused-vars': ['warn'],
    camelcase: 'off',
  },
  settings: {
    node: { tryExtensions: ['.js', '.json', '.node', '.ts', '.d.ts'] },
  },
};

'''
'''--- .github/workflows/ci.yml ---
name: CI

on: [push]

jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 16.x
          cache: 'yarn'
      - uses: actions/cache@v3
        id: yarn-cache
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-${{ hashFiles('**/yarn.lock') }}
      - name: Install packages
        if: steps.yarn-cache.outputs.cache-hit != 'true'
        run: yarn install --immutable

  check:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - uses: actions/checkout@v3
      - uses: actions/cache@v3
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-${{ hashFiles('**/yarn.lock') }}
      - name: lint
        run: yarn lint
      - name: format
        run: yarn prettier:check

  contract-test:
    runs-on: ubuntu-latest
    needs: [setup, check]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/cache@v3
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-${{ hashFiles('**/yarn.lock') }}
      - name: integration_test
        run: yarn workspace contract test

'''
'''--- .lintstagedrc.js ---
const path = require('path');

const buildLintCommand = (filenames) =>
  `eslint ${filenames.map((f) => path.relative(process.cwd(), f)).join(' ')}`;

const buildPrettierCommand = (filenames) =>
  `prettier --check ${filenames
    .map((f) => path.relative(process.cwd(), f))
    .join(' ')} `;

module.exports = {
  '**/*.{js,jsx,ts,tsx}': [buildLintCommand],
  '**/*.{js,jsx,ts,tsx}': [buildPrettierCommand],
};

'''
'''--- .parcel-cache/657954f315cdf05c.txt ---
430028193
1686048518341780000
'''
'''--- README.md ---
<p align="center">
  <br />
  <img width="100" src="./assets/near_logo.png" alt="NEAR Logo">
  <br/>
  <br />
  <p align="center">
<img src="https://img.shields.io/badge/Rust-1.69.0-blue?logo=Rust"/>
<img src="https://img.shields.io/badge/cargo-1.69.0-blue"/>
<img src="https://img.shields.io/badge/nodemon-2.0.16-blue?logo=nodemon"/>
<img src="https://img.shields.io/badge/React-18.1.0-blue?logo=react"/>
<img src="https://img.shields.io/badge/-javascript-blue?logo=javascript"/>
</p>

<br/>

[![-----------------------------------------------------](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/colored.png)](#table-of-contents)

<br/>

## • Overview

I made this project and text by myself. The text is located [this URL](https://app.unchain.tech/learn/ETH-dApp/). This is used in the engineer cmmunity `UNCHAIN`.

This is dapp that you can run an election equaly using NEAR blockchain. You can distribute voting ticket and those who have it can vote once. If you are deployer, you can open and close the election whenever you want.

## • Links

[Deployed here](https://near-election.netlify.app)

`*Open in Google Chrome so that images can be seen correctly`

[![Frontend](assets/frontend.png)](https://near-election.netlify.app)

## • Launch

1. run `yarn install` in terminal.

2. make your own NEAR wallet [here](https://wallet.testnet.near.org/)

3. install near-cli and login by implementing command below.

```
near login
```

4. run command below and deploy the contract.

```
yarn contract build
yarn contract deploy
```

5. run command below and start frontend

```
yarn client start
```

'''
'''--- package.json ---
{
  "name": "election-dapp",
  "version": "1.0.0",
  "description": "Election-dApp on NEAR",
  "private": true,
  "devDependencies": {
    "@trivago/prettier-plugin-sort-imports": "^4.0.0",
    "@typescript-eslint/eslint-plugin": "^5.51.0",
    "@typescript-eslint/parser": "^5.51.0",
    "eslint": "^8.33.0",
    "eslint-config-prettier": "^8.6.0",
    "eslint-config-standard": "^17.0.0",
    "eslint-plugin-import": "^2.27.5",
    "eslint-plugin-n": "^15.6.1",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^4.2.1",
    "eslint-plugin-promise": "^6.1.1",
    "lint-staged": "^13.1.0",
    "prettier": "^2.8.3",
    "simple-git-hooks": "^2.8.1"
  },
  "workspaces": {
    "packages": [
      "packages/*"
    ]
  },
  "simple-git-hooks": {
    "pre-commit": "npx lint-staged"
  },
  "scripts": {
    "contract": "yarn workspace contract",
    "client": "yarn workspace client",
    "client:dev": "yarn workspace client dev",
    "prettier": "prettier --ignore-unknown --no-error-on-unmatched-pattern --ignore-path .prettierignore --write .",
    "prettier:check": "prettier --ignore-unknown --no-error-on-unmatched-pattern --ignore-path .prettierignore --check .",
    "lint": "eslint .",
    "lint:fix": "eslint --fix ."
  }
}

'''
'''--- packages/client/.gitpod.yml ---
tasks:
  - init: yarn
    command: yarn dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- packages/client/README.md ---
# near-blank-project

This [React] app was initialized with [create-near-app]

# Quick Start

To run this project locally:

1. Prerequisites: Make sure you've installed [Node.js] ≥ 12
2. Install dependencies: `yarn install`
3. Run the local development server: `yarn dev` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Now you'll have a local development environment backed by the NEAR TestNet!

Go ahead and play with the app and the code. As you make code changes, the app will automatically reload.

# Exploring The Code

1. The "backend" code lives in the `/contract` folder. See the README there for
   more info.
2. The frontend code lives in the `/frontend` folder. `/frontend/index.html` is a great
   place to start exploring. Note that it loads in `/frontend/assets/js/index.js`, where you
   can learn how the frontend connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and the smart
   contract. See `contract/README` for info about how it's tested. The frontend
   code gets tested with [jest]. You can run both of these at once with `yarn
run test`.

# Deploy

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `yarn dev`, your smart contract gets deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

## Step 0: Install near-cli (optional)

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `yarn install`, but for best ergonomics you may want to install it globally:

    yarn install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

## Step 1: Create an account for the contract

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `near-blank-project.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `near-blank-project.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

   near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

   near create-account near-blank-project.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

## Step 2: set contract name in code

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'near-blank-project.YOUR-NAME.testnet'

## Step 3: deploy!

One command:

    yarn deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contract to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

# Troubleshooting

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

[React]: https://reactjs.org/
[create-near-app]: https://github.com/near/create-near-app
[Node.js]: https://nodejs.org/en/download/package-manager/
[jest]: https://jestjs.io/
[NEAR accounts]: https://docs.near.org/docs/concepts/account
[NEAR Wallet]: https://wallet.testnet.near.org/
[near-cli]: https://github.com/near/near-cli
[gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- packages/client/frontend/App.js ---
import React from 'react';
import 'regenerator-runtime/runtime';

import AppRouter from './assets/AppRouter';
import './assets/css/global.css';
import crossLogo from './assets/img/cross.png';
import NEARLogo from './assets/img/logo-black.svg';
import TopImage from './assets/img/top_img.avif';
import UNCHLogo from './assets/img/unchain_logo.png';
import { login, logout } from './assets/js/near/utils';

export default function App() {
  // check if signed in
  if (!window.walletConnection.isSignedIn()) {
    return (
      // sign in screen
      <div className="grid h-3/4 place-items-center">
        <div className="flex items-center">
          <img src={NEARLogo} className="object-cover h-16 w-16" />
          <img src={crossLogo} className="object-cover h-6 w-6" />
          <img src={UNCHLogo} className="object-cover h-12 w-12 mx-2" />
          <span className="self-center text-3xl font-semibold whitespace-nowrap app_title">
            Election Dapp
          </span>
        </div>
        <div className="text-3xl">Have a liberate and fair election!</div>
        <img src={TopImage} className="mb-4 h-5/6 w-1/2" />
        <button
          className="text-white w-2/5 h-12 bg-gradient-to-r from-rose-500 via-rose-600 to-rose-800 hover:bg-gradient-to-br focus:ring-4 focus:outline-none font-medium rounded-lg text-3xl text-center "
          onClick={login}
        >
          Sign In
        </button>
      </div>
    );
  }

  // in case user signed in
  return (
    // home screen
    <div className="bg-white min-h-screen">
      {/* header */}
      <nav className="bg-white pt-2.5">
        <div className="container flex flex-wrap justify-between items-center mx-auto">
          <div className="flex items-center">
            <img src={NEARLogo} className="object-cover h-12 w-12" />
            <img src={crossLogo} className="object-cover h-4 w-4" />
            <img src={UNCHLogo} className="object-cover h-9 w-9 mx-2" />
            <span className="self-center text-3xl font-semibold whitespace-nowrap app_title">
              Election Dapp
            </span>
          </div>
          <div className="md:block md:w-auto pt-1">
            <ul className="flex md:flex-row md:space-x-8 md:text-xl md:font-medium">
              {/* change url as being pushed button */}
              <li>
                <a href="http://localhost:1234/"> Home </a>
              </li>
              <li>
                <a href="http://localhost:1234/candidate"> Add Candidate </a>
              </li>
              <li>
                <a href="http://localhost:1234/voter"> Add Voter </a>
              </li>
              <button
                className="link text-red-500"
                style={{ float: 'right' }}
                onClick={logout}
              >
                Sign out
              </button>
            </ul>
          </div>
        </div>
      </nav>
      {/* body(change depending on url) */}
      <div className="center">
        <AppRouter />
      </div>
    </div>
  );
}

'''
'''--- packages/client/frontend/__mocks__/fileMock.js ---
// NOTE: This is used to mock resource imports in JSX for tests
module.exports = '';

'''
'''--- packages/client/frontend/assets/AppRouter.js ---
import React from 'react';
import { BrowserRouter, Route, Routes } from 'react-router-dom';

import Candidate from './pages/candidate';
import Home from './pages/home';
import Voter from './pages/voter';

// Change with url
const AppRouter = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/candidate" element={<Candidate />} />
        <Route path="/voter" element={<Voter />} />
      </Routes>
    </BrowserRouter>
  );
};

export default AppRouter;

'''
'''--- packages/client/frontend/assets/components/candidate_card.js ---
import React from 'react';
import { IpfsImage } from 'react-ipfs-image';

// template  candidate card template
const CandidateCard = (props) => {
  return (
    <div className="max-w-sm rounded overflow-hidden shadow-lg w-64 h-96">
      <IpfsImage
        className="w-full h-3/5"
        hash={props.CID}
        gatewayUrl="https://gateway.pinata.cloud/ipfs/"
        alt="Sunset in the mountains"
      />
      <div className="px-6 py-4">
        <div className="font-bold text-xl mb-2">{props.name}</div>
        <p className="text-gray-700 text-base">{props.manifest}</p>
      </div>
    </div>
  );
};

export default CandidateCard;

'''
'''--- packages/client/frontend/assets/components/input_form.js ---
import React from 'react';

// template input component
const Input = (props) => {
  return (
    <form
      className="w-3/5"
      onSubmit={(e) => {
        e.preventDefault();
      }}
    >
      <label className="block">
        <span className="block text-3xl font-medium text-slate-700">
          {props.title}
        </span>
        <input
          value={props.input}
          placeholder={props.hint}
          onChange={props.setInput}
          className="mt-1 block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm
                shadow-sm placeholder-slate-400 focus:outline-none focus:border-sky-500 focus:ring-1 focus:ring-sky-500
                disabled:bg-slate-50 disabled:text-slate-500 disabled:border-slate-200 disabled:shadow-none
                invalid:border-pink-500 invalid:text-pink-600 focus:invalid:border-pink-500 focus:invalid:ring-pink-500"
        />
      </label>
    </form>
  );
};

export default Input;

'''
'''--- packages/client/frontend/assets/components/title.js ---
import React from 'react';

// template title component
const Title = (props) => {
  return (
    <span className="box-content h-7 w-1/3 p-4 border-4 m4 center text-4xl items-center">
      {props.name}
    </span>
  );
};

export default Title;

'''
'''--- packages/client/frontend/assets/css/global.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

/* global css */
@layer components {
  .title {
    @apply font-semibold text-black text-transparent text-5xl bg-clip-text bg-gradient-to-b py-3;
  }

  .app_title {
    @apply font-extrabold text-transparent text-8xl bg-clip-text bg-gradient-to-r from-red-500 to-yellow-400;
  }

  .center {
    @apply flex justify-center;
  }
  .button {
    @apply bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 px-4 border-b-4 border-blue-700 hover:border-blue-500 rounded;
  }
  .vote_button {
    @apply h-8 px-3 py-0 my-2 font-sans text-xl font-semibold text-white transition ease-in-out bg-rose-600 border-rose-800 rounded shadow-lg drop-shadow-xl shadow-rose-600/50 hover:border-red-600;
  }

  .close_button {
    @apply h-8 px-3 py-0 mt-2 mb-3 font-sans text-xl font-semibold text-white transition ease-in-out bg-rose-900 border-red-800 rounded shadow-lg shadow-rose-600/50 hover:border-purple-600;
  }
}

html {
  font-size: calc(0.9em + 0.5vw);
}

'''
'''--- packages/client/frontend/assets/img/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- packages/client/frontend/assets/img/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- packages/client/frontend/assets/js/near/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'new-awesome-project';

function getConfig(env) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
        explorerUrl: 'https://explorer.mainnet.near.org',
      };
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        explorerUrl: 'https://explorer.testnet.near.org',
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
        explorerUrl: 'https://explorer.betanet.near.org',
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME,
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near',
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near',
      };
    default:
      throw Error(
        `Unconfigured environment '${env}'. Can be configured in src/config.js.`,
      );
  }
}

module.exports = getConfig;

'''
'''--- packages/client/frontend/assets/js/near/utils.js ---
// 以下のように書き換えてください
import { connect, Contract, keyStores, WalletConnection } from 'near-api-js';

import getConfig from './config';

const BN = require('bn.js');

const nearConfig = getConfig(process.env.NODE_ENV || 'development');

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  const near = await connect(
    Object.assign(
      { deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } },
      nearConfig,
    ),
  );

  // Initializing Wallet based Account. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(near);

  window.accountId = window.walletConnection.getAccountId();

  // Initializing our contract APIs by contract name and configuration
  window.contract = await new Contract(
    window.walletConnection.account(),
    nearConfig.contractName,
    {
      viewMethods: [
        'nft_metadata',
        'nft_tokens_for_kind',
        'nft_return_candidate_likes',
        'check_voter_has_been_added',
        'check_voter_has_voted',
        'if_election_closed',
      ],

      changeMethods: [
        'new_default_meta',
        'nft_mint',
        'nft_transfer',
        'nft_add_likes_to_candidate',
        'voter_voted',
        'close_election',
        'reopen_election',
      ],
    },
  );
}

export function logout() {
  window.walletConnection.signOut();
  // reload page
  window.location.replace(window.location.origin + window.location.pathname);
}

export function login() {
  window.walletConnection.requestSignIn(nearConfig.contractName);
}

export async function new_default_meta() {
  await window.contract.new_default_meta({ owner_id: window.accountId });
}

export async function nft_mint(
  title,
  description,
  media,
  media_CID,
  candidate_name,
  candidate_manifest,
  token_kind,
  receiver_id,
) {
  await window.contract.nft_mint(
    {
      metadata: {
        title: title,
        description: description,
        media: media,
        media_CID: media_CID,
        candidate_name: candidate_name,
        candidate_manifest: candidate_manifest,
        token_kind: token_kind,
      },
      receiver_id: receiver_id,
    },
    300000000000000, // attached GAS (optional)
    new BN('1000000000000000000000000'),
  );
}

export async function nft_transfer(receiver_id, token_id) {
  await window.contract.nft_transfer(
    {
      receiver_id: receiver_id,
      token_id: token_id,
    },
    300000000000000, // attached GAS (optional)
    new BN('1'), // deposit yoctoNEAR
  );
}

export async function nft_add_likes_to_candidate(token_id) {
  await window.contract.nft_add_likes_to_candidate({ token_id: token_id });
}

export async function nft_metadata() {
  const contract_metadata = await window.contract.nft_metadata();
  return contract_metadata;
}

export async function nft_tokens_for_kind(token_kind) {
  const tokens_list = await window.contract.nft_tokens_for_kind({
    token_kind: token_kind,
  });
  return tokens_list;
}

export async function nft_return_candidate_likes(token_id) {
  const num_of_likes = await window.contract.nft_return_candidate_likes({
    token_id: token_id,
  });

  return num_of_likes;
}

export async function check_voter_has_been_added(voter_id) {
  return await window.contract.check_voter_has_been_added({
    voter_id: voter_id,
  });
}

export async function check_voter_has_voted(voter_id) {
  return await window.contract.check_voter_has_voted({ voter_id: voter_id });
}

export async function voter_voted(voter_id) {
  return await window.contract.voter_voted({ voter_id: voter_id });
}

export async function if_election_closed() {
  return await window.contract.if_election_closed();
}

export async function close_election() {
  await window.contract.close_election();
}
export async function reopen_election() {
  await window.contract.reopen_election();
}

'''
'''--- packages/client/frontend/assets/pages/candidate.js ---
import React, { useState } from 'react';

import Input from '../components/input_form';
import Title from '../components/title';
import { nft_mint } from '../js/near/utils';

// add candidate screen
function Candidate() {
  // set input valuable of candidate image CID, candidate name, candidate manifest
  const [inputCID, setInputCID] = useState('');
  const [inputName, setInputName] = useState('');
  const [inputManifest, setInputManifest] = useState('');

  // function that add candidate info to home screen
  const addCandidate = async () => {
    // mint candidate nft
    await nft_mint(
      `${inputName}(candidate)`,
      '',
      `https://gateway.pinata.cloud/ipfs/${inputCID}`,
      inputCID,
      inputName,
      inputManifest,
      'candidate',
      process.env.CONTRACT_NAME,
    );
    setInputCID('');
    setInputName('');
    setInputManifest('');
    window.alert("Candidate's NFT has minted! Let's Check it at Home screen!");
  };

  return (
    <div className="grid place-items-center w-full">
      <Title name="Add Candidate" />
      <div className="my-3 text-2xl text-red-400">
        Add candidate who you think must be a leader!
      </div>
      <Input
        title="Image URI(IPFS Content CID)"
        hint="QmT..."
        className="mb-3"
        input={inputCID}
        setInput={(event) => setInputCID(event.target.value)}
      />
      <div className="mb-6"></div>
      <Input
        title="Name"
        hint="Robert Downey Jr."
        input={inputName}
        setInput={(event) => setInputName(event.target.value)}
      />
      <div className="mb-6"></div>
      <Input
        title="Manifest"
        hint="I'm gonna prosper this city with web3 tech!"
        input={inputManifest}
        setInput={(event) => setInputManifest(event.target.value)}
      />
      <div className="mb-6"></div>
      <button className="button" onClick={async () => addCandidate()}>
        Add
      </button>
    </div>
  );
}
export default Candidate;

'''
'''--- packages/client/frontend/assets/pages/home.js ---
import React, { useEffect, useState } from 'react';

import CandidateCard from '../components/candidate_card';
import LikeIcon from '../img/like_icon.png';
import {
  check_voter_has_been_added,
  check_voter_has_voted,
  close_election,
  if_election_closed,
  nft_add_likes_to_candidate,
  nft_return_candidate_likes,
  nft_tokens_for_kind,
  nft_transfer,
  reopen_election,
  voter_voted,
} from '../js/near/utils';

// Home screen(user can vote here)
const Home = () => {
  // set valuable for candidate NFT info, num of likes for each candidate, state
  const [candidateInfoList, setCandidateInfoList] = useState();
  const [candidateLikesList] = useState([]);
  const [state, setState] = useState('fetching');

  // enum of state
  const State = {
    Fetching: 'fetching',
    Fetched: 'fetched',
    Open: 'open',
    Closed: 'closed',
  };

  // fetch candidate nft info
  useEffect(async () => {
    await nft_tokens_for_kind('candidate').then((value) => {
      setCandidateInfoList(value);
      setState('fetched');
    });
  }, []);

  // vote function
  const vote = (token_id) => {
    // check if user has already voted
    check_voter_has_voted(window.accountId).then((value) => {
      if (value) {
        window.alert('You have already voted!');
        return;
      }

      // check if user has vote ticket
      check_voter_has_been_added(window.accountId).then((value) => {
        const tokenIdOfVoter = parseFloat(value);
        if (tokenIdOfVoter === 0) {
          window.alert(
            "You don't have vote ticket! Please ask deployer to give it to you.",
          );
          return;
        }
        // window.confirm if user really vote to specified candidate(because even if they cancel transaction, contract judge user voted)
        const isSure = window.confirm(
          "Once you vote, you can't change selected candidate. Are you OK?",
        );
        if (!isSure) {
          return;
        }
        // transfer vote ticket from user to contract(get rid of vote ticket)
        nft_transfer(process.env.CONTRACT_NAME, tokenIdOfVoter);
        // add vote to specified candidate
        nft_add_likes_to_candidate(token_id);

        // add user ID to voted-list
        voter_voted(window.accountId);
      });
    });
  };

  // body(in case election is open)
  const cardsInCaseOpen = () => {
    const candidateCardList = [];
    for (let i = 0; i < candidateInfoList.length; i++) {
      // format data for rendering
      candidateCardList.push(
        <div className="items-center">
          <CandidateCard
            CID={candidateInfoList[i].metadata.media_CID}
            name={candidateInfoList[i].metadata.candidate_name}
            manifest={candidateInfoList[i].metadata.candidate_manifest}
          />
          <div className="center text-xl items-center">
            <img src={LikeIcon} className="object-cover h-5 w-5 mr-2" />
            <p className="mr-2">{candidateLikesList[i]}</p>
            <button
              value={candidateInfoList[i].metadata.token_id}
              onClick={(event) => vote(parseInt(event.target.value))}
              className="vote_button hover:skew-1"
            >
              Vote!
            </button>
          </div>
        </div>,
      );
    }
    return candidateCardList;
  };

  // body(in case election is closed)
  const cardsInCaseClosed = () => {
    const candidateCardList = [];
    const mostVotedNum = candidateLikesList.reduce((a, b) => {
      return Math.max(a, b);
    });
    // format data for rendering
    for (let i = 0; i < candidateInfoList.length; i++) {
      if (candidateLikesList[i] === mostVotedNum) {
        // for winner candidate rendering
        candidateCardList.push(
          <div className="items-center">
            <div className="text-2xl shadow-rose-600 center font-semibold text-red-700">
              Won!
            </div>
            <CandidateCard
              CID={candidateInfoList[i].metadata.media_CID}
              name={candidateInfoList[i].metadata.candidate_name}
              manifest={candidateInfoList[i].metadata.candidate_manifest}
            />
            <div className="center text-xl items-center">
              <img src={LikeIcon} className="object-cover h-5 w-5 mr-2" />
              <p className="mr-2">{candidateLikesList[i]}</p>
            </div>
          </div>,
        );
      } else {
        // for other candidate rendering
        candidateCardList.push(
          <div className="items-center opacity-20">
            <div className="pt-7"></div>
            <CandidateCard
              CID={candidateInfoList[i].metadata.media_CID}
              name={candidateInfoList[i].metadata.candidate_name}
              manifest={candidateInfoList[i].metadata.candidate_manifest}
            />
            <div className="center text-xl items-center">
              <img src={LikeIcon} className="object-cover h-5 w-5 mr-2" />
              <p className="mr-2">{candidateLikesList[i]}</p>
            </div>
          </div>,
        );
      }
    }
    return candidateCardList;
  };

  // fetching like method
  const getCandidateLikes = async () => {
    // get num of likes for each candidate
    for (let i = 0; i < candidateInfoList.length; i++) {
      await nft_return_candidate_likes(
        candidateInfoList[i].metadata.token_id,
      ).then((value) => {
        candidateLikesList.push(value);
      });
    }

    // check if election is closed
    const isClosed = await if_election_closed();
    console.log(isClosed);
    if (isClosed) {
      setState('closed');
    } else {
      setState('open');
    }
  };

  // close button function(display to only contract deployer)
  const closeButton = () => {
    // check if user is contract deployer
    if (window.accountId !== process.env.CONTRACT_NAME) {
      return;
    }
    return (
      <button
        className="close_button hover:skew-1 h-10 bg-red-600 mb-3"
        onClick={() => {
          // window.confirm that user really close this election
          const isSureToClose = window.confirm(
            'Are you sure to close this election?',
          );
          if (isSureToClose) {
            // close this election
            close_election();

            // change state to closed
            setState('closed');
          }
        }}
      >
        Close Election
      </button>
    );
  };

  // reopen button function(display to only contract deployer)
  const reopenButton = () => {
    // check if user is contract deployer
    if (window.accountId !== process.env.CONTRACT_NAME) {
      return;
    }
    return (
      <button
        className="close_button hover:skew-1 h-10 bg-red-600 mb-3"
        onClick={() => {
          const isSureToClose = window.confirm(
            'Are you sure to reopen this election?',
          );
          if (isSureToClose) {
            // reopen this election
            reopen_election();

            // change state to open
            setState('open');
          }
        }}
      >
        Reopen Election
      </button>
    );
  };

  // message to wait for fetching data
  const messageToWait = () => {
    return (
      <div className="grid h-screen place-items-center text-3xl">
        Fetching NFTs of candidates...
      </div>
    );
  };

  switch (state) {
    // in case fetching candidate NFTs info
    case State.Fetching:
      return <div>{messageToWait()}</div>;

    // in case fetching number of likes for each candidate
    case State.Fetched:
      getCandidateLikes();
      return <div>{messageToWait()}</div>;

    // in case all data is fetched(election is open)
    case State.Open:
      return (
        <div>
          <div className="center">{closeButton()}</div>
          <div className="grid grid-cols-3 gap-10">{cardsInCaseOpen()}</div>
        </div>
      );

    // in case all data is fetched(election is closed)
    case State.Closed:
      return (
        <div>
          <div className="center">{reopenButton()}</div>
          <div className="grid grid-cols-3 gap-10">{cardsInCaseClosed()}</div>
        </div>
      );
  }
};
export default Home;

'''
'''--- packages/client/frontend/assets/pages/voter.js ---
import React, { useState } from 'react';

import Input from '../components/input_form';
import Title from '../components/title';
import { check_voter_has_been_added, nft_mint } from '../js/near/utils';

// Adding voter screen
const Voter = () => {
  // valuable of input ID for receiving vote ticket
  const [inputId, setInputId] = useState('');

  // mint function
  const mint = async () => {
    // check if user is deployer
    if (window.accountId !== process.env.CONTRACT_NAME) {
      window.alert("You are not contract deployer, so you can't add voter");
      return;
    }

    // check if a ticket minted to user before
    const isMinted = await check_voter_has_been_added(`${inputId}`);
    if (isMinted !== 0) {
      window.alert("You've already got vote ticket or voted and used it!");
      return;
    }

    // mint vote ticket to user
    await nft_mint(
      'Vote Ticket',
      '',
      'https://gateway.pinata.cloud/ipfs/QmUs5K3LwdvbhKA58bH9C6FX5Q7Bhsvvg9GRAhr9aVKLyx',
      'QmUs5K3LwdvbhKA58bH9C6FX5Q7Bhsvvg9GRAhr9aVKLyx',
      'Vote Ticket',
      'You can vote with this ticket! But remember that you can do it just once.',
      'vote',
      `${inputId}`,
    );
    window.alert(`Vote ticket is minted to ${inputId}!`);
    setInputId('');
  };

  return (
    <div className="grid place-items-center w-full">
      <Title name="Add Voter" />
      <div className="text-lg">※Only contract deployer can add voter.</div>
      <div className="mb-24"></div>
      <Input
        title="Wallet ID"
        hint="0x..."
        input={inputId}
        type="text"
        setInput={(event) => setInputId(event.target.value)}
      />
      <div className="mb-24"></div>
      <button className="button" onClick={() => mint()}>
        Add
      </button>
    </div>
  );
};
export default Voter;

'''
'''--- packages/client/frontend/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./assets/img/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="apple-touch-icon" href="./assets/img/favicon.ico" />
    <title>Welcome to NEAR with React</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
    <script src="./index.js" type="module"></script>
  </body>
</html>

'''
'''--- packages/client/frontend/index.js ---
import React from 'react';
import { createRoot } from 'react-dom/client';

import App from './App';
import { initContract } from './assets/js/near/utils';

const container = document.querySelector('#root');
const root = createRoot(container); // createRoot(container!) if you use TypeScript

window.nearInitPromise = initContract()
  .then(() => {
    <App />;
    root.render(<App tab="home" />);
  })
  .catch(console.error);

'''
'''--- packages/client/integration-tests/package.json ---
{
  "name": "ava-testing",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava --verbose"
  },
  "devDependencies": {
    "ava": "^4.2.0",
    "near-api-js": "^0.44.2",
    "typescript": "^4.7.2",
    "ts-node": "^10.8.0",
    "@types/bn.js": "^5.1.0"
  },
  "dependencies": {}
}

'''
'''--- packages/client/integration-tests/src/config.ts ---
import { KeyPair, keyStores } from 'near-api-js';

const fs = require('fs');

const CONTRACT_NAME = fs.readFileSync('../neardev/dev-account', 'utf-8');
const NETWORK_ID = 'testnet';

// Create an InMemoryKeyStore
const keyStore = new keyStores.InMemoryKeyStore();

// Load credentials
const credPath = `${process.env.HOME}/.near-credentials/${NETWORK_ID}/${CONTRACT_NAME}.json`;
let credentials = JSON.parse(fs.readFileSync(credPath));

// Save key in the key store
keyStore.setKey(
  NETWORK_ID,
  CONTRACT_NAME,
  KeyPair.fromString(credentials.private_key),
);

export const nearConfig = {
  networkId: NETWORK_ID,
  nodeUrl: 'https://rpc.testnet.near.org',
  contractName: CONTRACT_NAME,
  walletUrl: 'https://wallet.testnet.near.org',
  helperUrl: 'https://helper.testnet.near.org',
  explorerUrl: 'https://explorer.testnet.near.org',
  headers: {},
  deps: { keyStore },
};

'''
'''--- packages/client/integration-tests/src/main.ava.ts ---
import anyTest, { TestFn } from 'ava';
import { Account, Contract, Near } from 'near-api-js';

import { nearConfig } from './config';

const test = anyTest as TestFn<{
  accounts: Record<string, any>;
}>;

test.beforeEach(async (t) => {
  const near = await new Near(nearConfig);
  const user = await new Account(near.connection, nearConfig.contractName);
  const contract = await new Contract(user, nearConfig.contractName, {
    viewMethods: ['get_greeting'],
    changeMethods: ['set_greeting'],
  });
  t.context.accounts = { contract };
});

test('returns the default greeting', async (t) => {
  const { contract } = t.context.accounts;
  const message: string = await contract.get_greeting({});
  t.is(message, 'Hello');
});

test('changes the message', async (t) => {
  const { contract } = t.context.accounts;
  await contract.set_greeting({ args: { message: 'Howdy' } });
  const message: string = await contract.get_greeting({});
  t.is(message, 'Howdy');
});

'''
'''--- packages/client/netlify.toml ---
[[redirects]]
   from = "/*"
   to = "/"
   status = 200
'''
'''--- packages/client/package.json ---
{
  "name": "client",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "env-cmd -f ./neardev/dev-account.env parcel frontend/index.html --open",
    "dev": "nodemon --watch contract -e ts --exec \"npm run start\"",
    "login":"near login"
  },
  "devDependencies": {
    "@babel/core": "~7.18.2",
    "@babel/preset-env": "~7.18.2",
    "@babel/preset-react": "~7.17.12",
    "autoprefixer": "^10.4.14",
    "ava": "^4.2.0",
    "env-cmd": "~10.1.0",
    "near-cli": "~3.3.0",
    "nodemon": "~2.0.16",
    "parcel": "^2.6.0",
    "postcss": "^8.4.21",
    "process": "^0.11.10",
    "react-test-renderer": "~18.1.0",
    "tailwindcss": "^3.2.7",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2",
    "bn.js":"5.2.1"
  },
  "dependencies": {
    "near-api-js": "~0.44.2",
    "react": "~18.1.0",
    "react-dom": "~18.1.0",
    "react-ipfs-image": "^0.7.0",
    "react-router-dom": "^6.9.0",
    "regenerator-runtime": "~0.13.9"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- packages/client/tailwind.config.js ---
module.exports = {
  content: ['./frontend/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};

'''
'''--- packages/contract/Cargo.toml ---
[package]
name = "near-election-dapp-contract"
version = "0.1.0"
authors = ["Yuji Toshihiro", "YOUR_MAIL_ADDRESS"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0"

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- packages/contract/package.json ---
{
    "name": "contract",
    "version": "1.0.0",
    "description": "contract of Election-dApp",
    "private": true,
    "scripts": {
      "build":"set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release",
      "deploy":"near deploy --wasm-file target/wasm32-unknown-unknown/release/near_election_dapp_contract.wasm --accountId $NFT_CONTRACT_ID",
      "test": "cargo test"
    }
  }
'''
'''--- packages/contract/src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    // get number of tokens
    pub fn nft_total_supply(&self) -> U128 {
        U128(self.token_metadata_by_id.len() as u128)
    }

    // get tokens(caller can select how many tokens to get)
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        let start = u128::from(from_index.unwrap_or(U128(0)));
        self.token_metadata_by_id
            .keys()
            .skip(start as usize)
            .take(limit.unwrap_or(50) as usize)
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }

    // get number of tokens for specified owner
    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        let tokens_for_kind_set = self.tokens_per_owner.get(&account_id);
        if let Some(tokens_for_kind_set) = tokens_for_kind_set {
            U128(tokens_for_kind_set.len() as u128)
        } else {
            U128(0)
        }
    }

    // get token info for specified owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        let tokens = if let Some(tokens_for_kind_set) = tokens_for_owner_set {
            tokens_for_kind_set
        } else {
            return vec![];
        };

        let start = u128::from(from_index.unwrap_or(U128(0)));
        tokens
            .iter()
            .skip(start as usize)
            .take(limit.unwrap_or(50) as usize)
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }

    pub fn nft_tokens_for_kind(
        &self,
        token_kind: TokenKind,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        let tokens_for_kind_set = self.tokens_per_kind.get(&token_kind);
        let tokens = if let Some(tokens_for_kind_set) = tokens_for_kind_set {
            tokens_for_kind_set
        } else {
            return vec![];
        };

        let start = u128::from(from_index.unwrap_or(U128(0)));
        tokens
            .iter()
            .skip(start as usize)
            .take(limit.unwrap_or(50) as usize)
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }
}

'''
'''--- packages/contract/src/internal.rs ---
use crate::*;
use near_sdk::CryptoHash;

// hash account id
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();

    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

// confirm caller attached one yoctoNEAR
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
}

pub(crate) fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNear to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;

    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

impl Contract {
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::TokensPerOwnerInner {
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        tokens_set.insert(token_id);
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    pub(crate) fn internal_add_token_to_kind_map(
        &mut self,
        token_id: &TokenId,
        token_kind: TokenKind,
    ) {
        let token_kind_clone = token_kind.clone();
        let mut tokens_set = self
            .tokens_per_kind
            .get(&token_kind_clone)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::TokensPerKindInner {
                        token_kind: token_kind,
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });

        tokens_set.insert(&token_id);
        self.tokens_per_kind.insert(&token_kind_clone, &tokens_set);
    }

    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            //if there is no set of tokens for the owner, we panic with the following message:
            .expect("Token should be owned by the sender");

        tokens_set.remove(token_id);

        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    // transfer token
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
    ) -> TokenOwner {
        let token = self.tokens_by_id.get(token_id).expect("No token");

        if sender_id != &token.owner_id {
            env::panic_str("Unauthorized");
        }

        assert_ne!(
            &token.owner_id, receiver_id,
            "The token owner and the receiver should be different"
        );

        self.internal_remove_token_from_owner(&token.owner_id, token_id);

        self.internal_add_token_to_owner(receiver_id, token_id);

        let new_token = TokenOwner {
            owner_id: receiver_id.clone(),
        };

        self.tokens_by_id.insert(token_id, &new_token);
        token
    }
}

'''
'''--- packages/contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, CryptoHash, PanicOnDefault, Promise};

mod enumeration;
mod internal;
mod metadata;
mod mint;
mod nft_core;
mod vote;

pub use crate::enumeration::*;
use crate::internal::*;
pub use crate::metadata::*;
pub use crate::mint::*;
pub use crate::nft_core::*;
pub use vote::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    // contract state value
    pub owner_id: AccountId,
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub tokens_per_kind: LookupMap<TokenKind, UnorderedSet<TokenId>>,
    pub tokens_by_id: LookupMap<TokenId, TokenOwner>,
    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
    pub metadata: LazyOption<NFTContractMetadata>,
    pub token_id_counter: u128,
    pub likes_per_candidate: LookupMap<TokenId, Likes>,
    pub added_voter_list: LookupMap<ReceiverId, TokenId>,
    pub voted_voter_list: LookupMap<ReceiverId, u128>,
    pub is_election_closed: bool,
}

#[derive(BorshSerialize)]
pub enum StorageKey {
    TokensPerOwner,
    TokensPerKind,
    TokensPerOwnerInner { account_id_hash: CryptoHash },
    TokensPerKindInner { token_kind: TokenKind },
    TokensById,
    TokenMetadataById,
    TokensPerTypeInner { token_type_hash: CryptoHash },
    NFTContractMetadata,
    LikesPerCandidate,
    AddedVoterList,
    VotedVoterList,
}

#[near_bindgen]
impl Contract {
    // function for initialization(new_default_meta)
    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        let this = Self {
            owner_id,
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_per_kind: LookupMap::new(StorageKey::TokensPerKind.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(
                StorageKey::TokenMetadataById.try_to_vec().unwrap(),
            ),
            metadata: LazyOption::new(
                StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
            token_id_counter: 0,
            likes_per_candidate: LookupMap::new(
                StorageKey::LikesPerCandidate.try_to_vec().unwrap(),
            ),
            added_voter_list: LookupMap::new(StorageKey::AddedVoterList.try_to_vec().unwrap()),
            voted_voter_list: LookupMap::new(StorageKey::VotedVoterList.try_to_vec().unwrap()),
            is_election_closed: false,
        };

        this
    }

    // initialization function
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: "nft-1.0.0".to_string(),
                name: "Near Vote Contract".to_string(),
                reference: "This contract is design for fair election!".to_string(),
            },
        )
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 100000000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn mint_test() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(1))
            .build());

        assert_eq!(contract.owner_id, accounts(1));

        contract.nft_mint(
            TokenMetadata {
                title: None,
                description: None,
                media: "https...".to_string(),
                media_CID: "Qeo...".to_string(),
                candidate_name: None,
                candidate_manifest: None,
                token_kind: "candidate".to_string(),
                token_id: None,
            },
            accounts(1),
        );

        assert_eq!(u128::from(contract.nft_total_supply()), 1);

        let nft_info = contract.nft_tokens(None, None);
        assert_eq!(nft_info[0].metadata.media, "https...".to_string());
        assert_eq!(u128::from(contract.nft_supply_for_owner(accounts(1))), 1);
        assert_eq!(
            nft_info[0].owner_id,
            contract.nft_tokens_for_owner(accounts(1), None, None)[0].owner_id
        );
        assert_eq!(
            nft_info[0].owner_id,
            contract.nft_tokens_for_kind("candidate".to_string(), None, None)[0].owner_id
        );
    }

    #[test]
    fn vote_closed_test() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(1))
            .build());
        assert_eq!(contract.is_election_closed, false);

        contract.close_election();
        assert_eq!(contract.is_election_closed, true);

        contract.reopen_election();
        assert_eq!(contract.is_election_closed, false);
    }

    #[test]
    fn transfer_test() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(1))
            .build());

        contract.nft_mint(
            TokenMetadata {
                title: None,
                description: None,
                media: "https...".to_string(),
                media_CID: "Qeo...".to_string(),
                candidate_name: None,
                candidate_manifest: None,
                token_kind: "candidate".to_string(),
                token_id: None,
            },
            accounts(1),
        );

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(1))
            .build());

        contract.nft_transfer(accounts(2), 0);

        let nft_info = contract.nft_tokens(None, None);
        assert_eq!(nft_info[0].owner_id, accounts(2));
    }
}

'''
'''--- packages/contract/src/metadata.rs ---
use crate::*;
pub type TokenId = u128;
pub type CandidateName = String;
pub type TokenKind = String;
pub type HasVoted = bool;
pub type ReceiverId = AccountId;
pub type Likes = f32;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]

// metadata of contract
pub struct NFTContractMetadata {
    pub spec: String,
    pub name: String,
    pub reference: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>,
    pub description: Option<String>,
    pub media: String,
    pub media_CID: String,
    pub candidate_name: Option<String>,
    pub candidate_manifest: Option<String>,
    pub token_kind: String,
    pub token_id: Option<u128>,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct TokenOwner {
    pub owner_id: AccountId,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]

// metadata of type of Json
pub struct JsonToken {
    pub owner_id: AccountId,
    pub metadata: TokenMetadata,
}

pub trait NFTTokenMetadata {
    fn nft_metadata(&self) -> NFTContractMetadata;
}

// view function for contract info
#[near_bindgen]
impl NFTTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- packages/contract/src/mint.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    #[payable]

    //mint token
    pub fn nft_mint(&mut self, mut metadata: TokenMetadata, receiver_id: AccountId) {
        // set token id
        assert!(
            !(&self.is_election_closed),
            "You can add candidate or voter because this election has been closed!"
        );
        metadata.token_id = Some(self.token_id_counter);
        let initial_storage_usage = env::storage_usage();
        let receiver_id_clone = receiver_id.clone();
        let token = TokenOwner {
            owner_id: receiver_id,
        };
        let token_id = self.token_id_counter;
        let token_kind = metadata.token_kind.clone();

        assert!(
            self.tokens_by_id
                .insert(&self.token_id_counter, &token)
                .is_none(),
            "Token already exists"
        );

        // add info(key: receiver_id, value: token metadata ) to map
        self.token_metadata_by_id
            .insert(&self.token_id_counter, &metadata);

        // add info(key: receiver id, value: token id ) to map
        self.internal_add_token_to_owner(&token.owner_id, &token_id);

        // add info(key: token id, value: token kind ) to map
        self.internal_add_token_to_kind_map(&token_id, token_kind);

        // add data(key: token id, value: number of likes)
        self.likes_per_candidate
            .insert(&self.token_id_counter, &(0 as Likes));

        // add info(key: receiver id, value: token id ) to map(-> this list is for check voter get vote ticket)
        self.added_voter_list
            .insert(&receiver_id_clone, &self.token_id_counter);

        // increment token id counter
        self.token_id_count();

        // calculate storage user used
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        // refund unused payment deposit
        refund_deposit(required_storage_in_bytes);
    }

    // count token id
    pub fn token_id_count(&mut self) {
        self.token_id_counter = self.token_id_counter + 1;
    }

    // get next token id
    pub fn show_token_id_counter(&self) -> u128 {
        self.token_id_counter
    }
}

'''
'''--- packages/contract/src/nft_core.rs ---
use crate::*;
use near_sdk::ext_contract;
pub trait NonFungibleTokenCore {
    fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId);
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
    fn nft_add_likes_to_candidate(&mut self, token_id: TokenId);
}
#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    #[payable]
    // transfer token
    fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId) {
        assert!(
            !(&self.is_election_closed),
            "You can no longer vote because it's been closed!"
        );
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();

        self.internal_transfer(&sender_id, &receiver_id, &token_id);
    }

    // get specified token info
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            let metadata = self.token_metadata_by_id.get(&token_id).unwrap();
            Some(JsonToken {
                owner_id: token.owner_id,
                metadata,
            })
        } else {
            None
        }
    }

    fn nft_add_likes_to_candidate(&mut self, token_id: TokenId) {
        if self.likes_per_candidate.get(&token_id).is_some() {
            let mut likes = self.likes_per_candidate.get(&token_id);
            likes.replace(likes.unwrap() + 1 as Likes);
            self.likes_per_candidate.insert(&token_id, &likes.unwrap());
        }
    }
}

'''
'''--- packages/contract/src/vote.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    // check if election is closed
    pub fn if_election_closed(&self) -> bool {
        self.is_election_closed
    }

    // close election
    pub fn close_election(&mut self) {
        self.is_election_closed = true;
    }

    // reopen election
    pub fn reopen_election(&mut self) {
        self.is_election_closed = false;
    }
    // get number of likes of specified candidate
    pub fn nft_return_candidate_likes(&self, token_id: TokenId) -> Likes {
        if self.tokens_by_id.get(&token_id).is_some() {
            self.likes_per_candidate.get(&token_id).unwrap()
        } else {
            0 as Likes
        }
    }

    // add info(key: receiver id, value: number ) to map(-> this list is for check voter has already voted)
    pub fn voter_voted(&mut self, voter_id: AccountId) {
        self.voted_voter_list.insert(&voter_id, &(0 as u128));
    }

    // check if voter id is in added-list
    pub fn check_voter_has_been_added(&self, voter_id: AccountId) -> TokenId {
        if self.added_voter_list.get(&voter_id).is_some() {
            return self.added_voter_list.get(&voter_id).unwrap();
        } else {
            0
        }
    }

    // check if voter id is in voted-list
    pub fn check_voter_has_voted(&self, voter_id: AccountId) -> bool {
        if self.voted_voter_list.get(&voter_id).is_some() {
            return true;
        } else {
            false
        }
    }
}

'''