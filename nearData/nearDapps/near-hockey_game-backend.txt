*GitHub Repository "near-hockey/game-backend"*

'''--- .env ---
MODE=DEV
DEBUG=1
SECRET_KEY='django-insecure-uo)o#e2*_1!%o72m1_sbagay6)zbnt5t_sen(9r-s(v=)rvbcg'
SQL_ENGINE=django.db.backends.postgresql
SQL_USER=near_game_user
SQL_PASSWORD=kljasdf89uferiUHJasdf9281bvdasA
SQL_DATABASE=near_game
SQL_HOST=localhost
SQL_PORT=5432

CONTRACT=nft-hocke.testnet
NEAR_URL=https://rpc.testnet.near.org

'''
'''--- api_v1/__init__.py ---

'''
'''--- api_v1/admin.py ---
from django.contrib import admin
from .models import MarketplaceData

@admin.register(MarketplaceData)
class MarketplaceDataAdmin(admin.ModelAdmin):
    list_display = 'nft_token', 'user_id', 'price', 'active', 'created'

'''
'''--- api_v1/apps.py ---
from django.apps import AppConfig

class ApiV1Config(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'api_v1'

'''
'''--- api_v1/migrations/0001_initial.py ---
# Generated by Django 4.0 on 2021-12-16 21:48

from django.db import migrations, models

class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MarketplaceData',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nft_token', models.CharField(max_length=256, verbose_name='NFT')),
                ('user_id', models.CharField(max_length=128, verbose_name='User id')),
                ('created', models.DateTimeField(auto_now=True, verbose_name='Date created')),
                ('price', models.FloatField(verbose_name='Price')),
                ('active', models.BooleanField(verbose_name='Is active')),
            ],
        ),
    ]

'''
'''--- api_v1/migrations/__init__.py ---

'''
'''--- api_v1/models.py ---
from django.db import models

class MarketplaceData(models.Model):
    nft_token = models.CharField("NFT", max_length=256)
    user_id = models.CharField("User id", max_length=128)
    created = models.DateTimeField("Date created", auto_now=True)
    price = models.FloatField("Price")
    active = models.BooleanField("Is active", default=True)

'''
'''--- api_v1/permissions.py ---
from rest_framework.permissions import BasePermission
import near_api
from django.conf import settings

class HasNFT(BasePermission):
    def has_permission(self, request, view):
        provider = near_api.providers.JsonProvider(settings.NEAR_URL)
        account = near_api.account.Account(provider, None, request.data.get('user_id'))
        response = account.view_function(settings.CONTRACT, "nft_token", {
            "token_id": request.data.get('nft_token')
        })
        nft_data = response['result']
        if nft_data is None:
            return False
        if nft_data.get('owner_id') == request.data.get('user_id').strip():
            return True
        return False

'''
'''--- api_v1/serializers.py ---
from rest_framework import serializers
from .models import MarketplaceData

class MarketplaceDataSerializer(serializers.ModelSerializer):
    class Meta:
        model = MarketplaceData
        fields = 'nft_token', 'user_id', 'price', 'created'

'''
'''--- api_v1/tests.py ---
from django.test import TestCase

# Create your tests here.

'''
'''--- api_v1/urls.py ---
from django.contrib import admin
from django.urls import path, re_path, include
from .views import *

urlpatterns = [
    re_path(r'test-endpoint/?', Test.as_view(), name="test"),
    re_path(r'nft/marketplace/?$', MarketplaceDataViewSet.as_view({'get': 'list',
                                                                  'post': 'create'}), name="marketplace"),
    re_path(r'nft/marketplace/(?P<nft_token>\d+)', MarketplaceDataViewSet.as_view({
        'get': 'retrieve',
        'delete': 'destroy'
    }), name="single-marketplace"),
    # re_path(r'buy-pack/?', BuyPack.as_view(), name='buy-pack'),
]

'''
'''--- api_v1/views.py ---
from django.shortcuts import render
from rest_framework.views import APIView, Response
from rest_framework.generics import ListAPIView
from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import AllowAny
from .serializers import MarketplaceDataSerializer
from .models import MarketplaceData
from .permissions import HasNFT

class Test(APIView):
    permission_classes = [AllowAny]

    def get(self, request):
        return Response({"success": True})

# class BuyPack(APIView):
#     permission_classes = 0
#     pass

class MarketplaceDataViewSet(ModelViewSet):
    queryset = MarketplaceData.objects.filter(active=True)
    serializer_class = MarketplaceDataSerializer
    lookup_field = 'nft_token'
    permission_classes = [AllowAny]

    def get_permissions(self):
        if not self.request.data:
            permission_classes = [AllowAny]
        elif self.action == 'create' or self.action == 'delete':
            permission_classes = [HasNFT, AllowAny]
        else:
            permission_classes = [AllowAny]
        return [permission() for permission in permission_classes]

'''
'''--- docker-compose.yml ---
version: '3.7'

services:
  db:
    image: postgres:13.3-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    ports:
      - 5432:5432
    env_file:
      - .env.db

volumes:
  postgres_data:

'''
'''--- manage.py ---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys

def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'near_game_backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()

'''
'''--- near_api/__init__.py ---
import logging

import near_api.providers
import near_api.serializer
import near_api.transactions
import near_api.account
import near_api.signer

log = logging.getLogger(__name__)

'''
'''--- near_api/account.py ---
import base58
import json
import itertools

from near_api import transactions

# Amount of gas attached by default 1e14.
DEFAULT_ATTACHED_GAS = 100000000000000

class TransactionError(Exception):
    pass

class ViewFunctionError(Exception):
    pass

class Account(object):

    def __init__(self, provider, signer=None, account_id=None):
        self._provider = provider
        if signer is not None:
            self._signer = signer
        if account_id is not None:
            self._account_id = account_id
            self._account = provider.get_account(account_id)
        if signer is not None:
            self._access_key = provider.get_access_key(account_id, signer._key_pair.encoded_public_key())
        # print(account_id, self._account, self._access_key)

    def _sign_and_submit_tx(self, receiver_id, actions):
        self._access_key["nonce"] += 1
        block_hash = self._provider.get_status()['sync_info']['latest_block_hash']
        block_hash = base58.b58decode(block_hash.encode('utf8'))
        serialzed_tx = transactions.sign_and_serialize_transaction(
            receiver_id, self._access_key["nonce"], actions, block_hash, self._signer)
        result = self._provider.send_tx_and_wait(serialzed_tx, 10)
        for outcome in itertools.chain([result['transaction_outcome']], result['receipts_outcome']):
            for log in outcome['outcome']['logs']:
                print("Log:", log)
        if 'Failure' in result['status']:
            raise TransactionError(result['status']['Failure'])
        return result

    @property
    def account_id(self):
        return self._account_id

    @property
    def signer(self):
        return self._signer

    @property
    def provider(self):
        return self._provider

    @property
    def access_key(self):
        return self._access_key

    @property
    def state(self):
        return self._account

    def fetch_state(self):
        """Fetch state for given account."""
        self._account = self.provider.get_account(self.account_id)

    def send_money(self, account_id, amount):
        """Sends funds to given account_id given amount."""
        return self._sign_and_submit_tx(account_id, [transactions.create_transfer_action(amount)])

    def function_call(self, contract_id, method_name, args, gas=DEFAULT_ATTACHED_GAS, amount=0):
        args = json.dumps(args).encode('utf8')
        return self._sign_and_submit_tx(contract_id, [transactions.create_function_call_action(method_name, args, gas, amount)])

    def create_account(self, account_id, public_key, initial_balance):
        actions = [
            transactions.create_create_account_action(),
            transactions.create_full_access_key_action(public_key),
            transactions.create_transfer_action(initial_balance)]
        return self._sign_and_submit_tx(account_id, actions)

    def deploy_contract(self, contract_code):
        return self._sign_and_submit_tx(self._account_id, [transactions.create_deploy_contract_action(contract_code)])

    def stake(self, public_key, amount):
        return self._sign_and_submit_tx(self._account_id, [transactions.create_staking_action(public_key, amount)])

    def create_and_deploy_contract(self, contract_id, public_key, contract_code, initial_balance):
        actions = [
            transactions.create_create_account_action(),
            transactions.create_transfer_action(initial_balance),
            transactions.create_deploy_contract_action(contract_code)] + \
                  ([transactions.create_full_access_key_action(public_key)] if public_key is not None else [])
        return self._sign_and_submit_tx(contract_id, actions)

    def create_deploy_and_init_contract(self, contract_id, public_key, contract_code, initial_balance, args,
                                        gas=DEFAULT_ATTACHED_GAS, init_method_name="new"):
        args = json.dumps(args).encode('utf8')
        actions = [
          transactions.create_create_account_action(),
          transactions.create_transfer_action(initial_balance),
          transactions.create_deploy_contract_action(contract_code),
          transactions.create_function_call_action(init_method_name, args, gas, 0)] + \
                  ([transactions.create_full_access_key_action(public_key)] if public_key is not None else [])
        return self._sign_and_submit_tx(contract_id, actions)

    def view_function(self, contract_id, method_name, args):
        result = self._provider.view_call(contract_id, method_name, json.dumps(args).encode('utf8'))
        if "error" in result:
            raise ViewFunctionError(result["error"])
        result["result"] = json.loads(''.join([chr(x) for x in result["result"]]))
        return result

'''
'''--- near_api/providers.py ---
import requests
import base64
import json

class JsonProviderError(Exception):
    pass

class JsonProvider(object):

    def __init__(self, rpc_addr):
        if isinstance(rpc_addr, tuple):
            self._rpc_addr = "http://%s:%s" % rpc_addr
        else:
            self._rpc_addr = rpc_addr

    def rpc_addr(self):
        return self._rpc_addr

    def json_rpc(self, method, params, timeout=2):
        j = {
            'method': method,
            'params': params,
            'id': 'dontcare',
            'jsonrpc': '2.0'
        }
        r = requests.post(self.rpc_addr(), json=j, timeout=timeout)
        r.raise_for_status()
        content = json.loads(r.content)
        if "error" in content:
            raise JsonProviderError(content["error"])
        return content["result"]

    def send_tx(self, signed_tx):
        return self.json_rpc('broadcast_tx_async', [base64.b64encode(signed_tx).decode('utf8')])

    def send_tx_and_wait(self, signed_tx, timeout):
        return self.json_rpc('broadcast_tx_commit', [base64.b64encode(signed_tx).decode('utf8')], timeout=timeout)

    def get_status(self):
        r = requests.get("%s/status" % self.rpc_addr(), timeout=2)
        r.raise_for_status()
        return json.loads(r.content)

    def get_validators(self):
        return self.json_rpc('validators', [None])

    def query(self, query_object):
        return self.json_rpc('query', query_object)

    def get_account(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_account", "account_id": account_id, "finality": finality})

    def get_access_key_list(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key_list", "account_id": account_id, "finality": finality})

    def get_access_key(self, account_id, public_key, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key", "account_id": account_id,
                                       "public_key": public_key, "finality": finality})

    def view_call(self, account_id, method_name, args, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "call_function", "account_id": account_id,
                                       "method_name": method_name, "args_base64": base64.b64encode(args).decode('utf8'), "finality": finality})

    def get_block(self, block_id):
        return self.json_rpc('block', [block_id])

    def get_chunk(self, chunk_id):
        return self.json_rpc('chunk', [chunk_id])

    def get_tx(self, tx_hash, tx_recipient_id):
        return self.json_rpc('tx', [tx_hash, tx_recipient_id])

    def get_changes_in_block(self, changes_in_block_request):
        return self.json_rpc('EXPERIMENTAL_changes_in_block', changes_in_block_request)

'''
'''--- near_api/serializer.py ---
class BinarySerializer:
    def __init__(self, schema):
        self.array = bytearray()
        self.schema = schema

    def serialize_num(self, value, n_bytes):
        orig_value = value
        assert value >= 0, "Can't serialize negative numbers %d" % value
        for i in range(n_bytes):
            self.array.append(value & 255)
            value //= 256
        assert value == 0, "Value %d has more than %d bytes" % (orig_value, n_bytes)

    def serialize_field(self, value, fieldType):
        try:
            if type(fieldType) == str:
                if fieldType[0] == 'u':
                    self.serialize_num(value, int(fieldType[1:]) // 8)
                elif fieldType == 'string':
                    b = value.encode('utf8')
                    self.serialize_num(len(b), 4)
                    self.array += b
                else:
                    assert False, fieldType
            elif type(fieldType) == list:
                assert len(fieldType) == 1
                if type(fieldType[0]) == int:
                    assert type(value) == bytes, "type(%s) = %s != bytes" % (value, type(value))
                    assert len(value) == fieldType[0], "len(%s) = %s != %s" % (value, len(value), fieldType[0])
                    self.array += bytearray(value)
                else:
                    self.serialize_num(len(value), 4)
                    for el in value:
                        self.serialize_field(el, fieldType[0])
            elif type(fieldType) == dict:
                assert fieldType['kind'] == 'option'
                if value is None:
                    self.serialize_num(0, 1)
                else:
                    self.serialize_num(1, 1)
                    self.serialize_field(value, fieldType['type'])
            elif type(fieldType) == type:
                assert type(value) == fieldType, "%s != type(%s)" % (fieldType, value)
                self.serialize_struct(value)
            else:
                 assert False, type(fieldType)
        except:
            print("Failed to serialize %s as %s" % (value, fieldType))
            raise

    def serialize_struct(self, obj):
        structSchema = self.schema[type(obj)]
        if structSchema['kind'] == 'struct':
            for fieldName, fieldType in structSchema['fields']:
                self.serialize_field(getattr(obj, fieldName), fieldType)
        elif structSchema['kind'] == 'enum':
            name = getattr(obj, structSchema['field'])
            for idx, (fieldName, fieldType) in enumerate(structSchema['values']):
                if fieldName == name:
                    self.serialize_num(idx, 1)
                    self.serialize_field(getattr(obj, fieldName), fieldType)
                    break
        else:
            assert False, structSchema

    def serialize(self, obj):
        self.serialize_struct(obj)
        return bytes(self.array)

'''
'''--- near_api/signer.py ---
import base58
import ed25519

class KeyPair(object):

    def __init__(self, secret_key):
        secret_key = secret_key.split(
            ':')[1] if ':' in secret_key else secret_key
        self._secret_key = ed25519.SigningKey(base58.b58decode(secret_key))
        self._public_key = self._secret_key.get_verifying_key()

    @property
    def public_key(self):
        return self._public_key.to_bytes()

    def encoded_public_key(self):
        return base58.b58encode(self._public_key.to_bytes()).decode('utf-8')

    def sign(self, message):
        return self._secret_key.sign(message)

class Signer(object):

    def __init__(self, account_id, key_pair):
        self._account_id = account_id
        self._key_pair = key_pair

    @property
    def account_id(self):
        return self._account_id

    @property
    def key_pair(self):
        return self._key_pair

    @property
    def public_key(self):
        return self._key_pair.public_key

    def sign(self, message):
        return self._key_pair.sign(message)

    @classmethod
    def from_json(self, j):
        return Signer(j['account_id'], KeyPair(j['secret_key']))

    @classmethod
    def from_json_file(self, json_file):
        with open(json_file) as f:
            return Signer.from_json(json.loads(f.read()))

'''
'''--- near_api/transactions.py ---
import hashlib
from ed25519 import SigningKey

from near_api.serializer import BinarySerializer

class Signature:
    pass

class SignedTransaction:
    pass

class Transaction:
    pass

class PublicKey:
    pass

class AccessKey:
    pass

class AccessKeyPermission:
    pass

class FunctionCallPermission:
    pass

class FullAccessPermission:
    pass

class Action:
    pass

class CreateAccount:
    pass

class DeployContract:
    pass

class FunctionCall:
    pass

class Transfer:
    pass

class Stake:
    pass

class AddKey:
    pass

class DeleteKey:
    pass

class DeleteAccount:
    pass

tx_schema = dict([[Signature, { 'kind': 'struct', 'fields': [
            ['keyType', 'u8'],
            ['data', [64]]
        ] }],
[SignedTransaction, { 'kind': 'struct', 'fields': [
            ['transaction', Transaction],
            ['signature', Signature]
        ] }],
[Transaction, { 'kind': 'struct', 'fields': [
            ['signerId', 'string'],
            ['publicKey', PublicKey],
            ['nonce', 'u64'],
            ['receiverId', 'string'],
            ['blockHash', [32]],
            ['actions', [Action]]
        ] }],
[PublicKey, { 'kind': 'struct', 'fields': [
            ['keyType', 'u8'],
            ['data', [32]]
        ] }],
[AccessKey, { 'kind': 'struct', 'fields': [
            ['nonce', 'u64'],
            ['permission', AccessKeyPermission],
        ] }],
[AccessKeyPermission, { 'kind': 'enum', 'field': 'enum', 'values': [
            ['functionCall', FunctionCallPermission],
            ['fullAccess', FullAccessPermission],
        ] }],
[FunctionCallPermission, { 'kind': 'struct', 'fields': [
            ['allowance', { 'kind': 'option', type: 'u128' }],
            ['receiverId', 'string'],
            ['methodNames', ['string']],
        ] }],
[FullAccessPermission, { 'kind': 'struct', 'fields': [] }],
[Action, { 'kind': 'enum', 'field': 'enum', 'values': [
            ['createAccount', CreateAccount],
            ['deployContract', DeployContract],
            ['functionCall', FunctionCall],
            ['transfer', Transfer],
            ['stake', Stake],
            ['addKey', AddKey],
            ['deleteKey', DeleteKey],
            ['deleteAccount', DeleteAccount],
        ] }],
[CreateAccount, { 'kind': 'struct', 'fields': [] }],
[DeployContract, { 'kind': 'struct', 'fields': [
            ['code', ['u8']]
        ] }],
[FunctionCall, { 'kind': 'struct', 'fields': [
            ['methodName', 'string'],
            ['args', ['u8']],
            ['gas', 'u64'],
            ['deposit', 'u128']
        ] }],
[Transfer, { 'kind': 'struct', 'fields': [
            ['deposit', 'u128']
        ] }],
[Stake, { 'kind': 'struct', 'fields': [
            ['stake', 'u128'],
            ['publicKey', PublicKey]
        ] }],
[AddKey, { 'kind': 'struct', 'fields': [
            ['publicKey', PublicKey],
            ['accessKey', AccessKey]
        ] }],
[DeleteKey, { 'kind': 'struct', 'fields': [
            ['publicKey', PublicKey]
        ] }],
[DeleteAccount, { 'kind': 'struct', 'fields': [
            ['beneficiaryId', 'string']
        ] }],
])

def sign_and_serialize_transaction(receiverId, nonce, actions, blockHash, signer):
    assert signer.public_key != None
    assert blockHash != None
    tx = Transaction()
    tx.signerId = signer.account_id
    tx.publicKey = PublicKey()
    tx.publicKey.keyType = 0
    tx.publicKey.data = signer.public_key
    tx.nonce = nonce
    tx.receiverId = receiverId
    tx.actions = actions
    tx.blockHash = blockHash

    msg = BinarySerializer(tx_schema).serialize(tx)
    hash_ = hashlib.sha256(msg).digest()

    signature = Signature()
    signature.keyType = 0
    signature.data = signer.sign(hash_)

    signedTx = SignedTransaction()
    signedTx.transaction = tx
    signedTx.signature = signature

    return BinarySerializer(tx_schema).serialize(signedTx)

def create_create_account_action():
    createAccount = CreateAccount()
    action = Action()
    action.enum = 'createAccount'
    action.createAccount = createAccount
    return action

def create_full_access_key_action(pk):
    permission = AccessKeyPermission()
    permission.enum = 'fullAccess'
    permission.fullAccess = FullAccessPermission()
    accessKey = AccessKey()
    accessKey.nonce = 0
    accessKey.permission = permission
    publicKey = PublicKey()
    publicKey.keyType = 0
    publicKey.data = pk
    addKey = AddKey()
    addKey.accessKey = accessKey
    addKey.publicKey = publicKey
    action = Action()
    action.enum = 'addKey'
    action.addKey = addKey
    return action

def create_delete_access_key_action(pk):
    publicKey = PublicKey()
    publicKey.keyType = 0
    publicKey.data = pk
    deleteKey = DeleteKey()
    deleteKey.publicKey = publicKey
    action = Action()
    action.enum = 'deleteKey'
    action.deleteKey = deleteKey
    return action

def create_transfer_action(amount):
    transfer = Transfer()
    transfer.deposit = amount
    action = Action()
    action.enum = 'transfer'
    action.transfer = transfer
    return action

# TODO: deprecate usage of create_payment_action.
create_payment_action = create_transfer_action

def create_staking_action(amount, pk):
    stake = Stake()
    stake.stake = amount
    stake.publicKey = PublicKey()
    stake.publicKey.keyType = 0
    stake.publicKey.data = pk
    action = Action()
    action.enum = 'stake'
    action.stake = stake
    return action

def create_deploy_contract_action(code):
    deployContract = DeployContract()
    deployContract.code = code
    action = Action()
    action.enum = 'deployContract'
    action.deployContract = deployContract
    return action

def create_function_call_action(methodName, args, gas, deposit):
    functionCall = FunctionCall()
    functionCall.methodName = methodName
    functionCall.args = args
    functionCall.gas = gas
    functionCall.deposit = deposit
    action = Action()
    action.enum = 'functionCall'
    action.functionCall = functionCall
    return action

def sign_create_account_tx(creator_signer, new_account_id, nonce, block_hash):
    action = create_create_account_action()
    return sign_and_serialize_transaction(new_account_id, nonce, [action], block_hash, creator_signer)

def sign_create_account_with_full_access_key_and_balance_tx(creator_key, new_account_id, new_key, balance, nonce, block_hash):
    create_account_action = create_create_account_action()
    full_access_key_action = create_full_access_key_action(new_key.decoded_pk())
    payment_action = create_transfer_action(balance)
    actions = [create_account_action, full_access_key_action, payment_action]
    return sign_and_serialize_transaction(new_account_id, nonce, actions, block_hash, creator_key.account_id, creator_key.decoded_pk(), creator_key.decoded_sk())

def sign_delete_access_key_tx(signer_key, target_account_id, key_for_deletion, nonce, block_hash):
    action = create_delete_access_key_action(key_for_deletion.decoded_pk())
    return sign_and_serialize_transaction(target_account_id, nonce, [action], block_hash, signer_key.account_id, signer_key.decoded_pk(), signer_key.decoded_sk())

def sign_payment_tx(key, to, amount, nonce, blockHash):
    action = create_transfer_action(amount)
    return sign_and_serialize_transaction(to, nonce, [action], blockHash, key.account_id, key.decoded_pk(), key.decoded_sk())

def sign_staking_tx(signer_key, validator_key, amount, nonce, blockHash):
    action = create_staking_action(amount, validator_key.decoded_pk())
    return sign_and_serialize_transaction(signer_key.account_id, nonce, [action], blockHash, signer_key.account_id, signer_key.decoded_pk(), signer_key.decoded_sk())

def sign_deploy_contract_tx(signer_key, code, nonce, blockHash):
    action = create_deploy_contract_action(code)
    return sign_and_serialize_transaction(signer_key.account_id, nonce, [action], blockHash, signer_key.account_id, signer_key.decoded_pk(), signer_key.decoded_sk())

def sign_function_call_tx(signer_key, contract_id, methodName, args, gas, deposit, nonce, blockHash):
    action = create_function_call_action(methodName, args, gas, deposit)
    return sign_and_serialize_transaction(contract_id, nonce, [action], blockHash, signer_key.account_id, signer_key.decoded_pk(), signer_key.decoded_sk())

'''
'''--- near_game_backend/__init__.py ---

'''
'''--- near_game_backend/asgi.py ---
"""
ASGI config for near_game_backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'near_game_backend.settings')

application = get_asgi_application()

'''
'''--- near_game_backend/settings.py ---
import os
from pathlib import Path
from dotenv import load_dotenv

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

load_dotenv(BASE_DIR / '.env')

MODE = os.environ.get("MODE")

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.environ.get("DEBUG")

ALLOWED_HOSTS = ["*"]

CONTRACT = os.environ.get('CONTRACT')
NEAR_URL = os.environ.get('NEAR_URL')

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    "corsheaders",

    'rest_framework',

    'api_v1',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    "corsheaders.middleware.CorsMiddleware",
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOW_ALL_ORIGINS = True

ROOT_URLCONF = 'near_game_backend.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates']
        ,
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'near_game_backend.wsgi.application'

# Database
# https://docs.djangoproject.com/en/4.0/ref/settings/#databases
DATABASES = {
    "default": {
        "ENGINE": os.environ.get("SQL_ENGINE", "django.db.backends.sqlite3"),
        "NAME": os.environ.get("SQL_DATABASE", os.path.join(BASE_DIR, "db.sqlite3")),
        "USER": os.environ.get("SQL_USER", "user"),
        "PASSWORD": os.environ.get("SQL_PASSWORD", "password"),
        "HOST": os.environ.get("SQL_HOST", "localhost"),
        "PORT": os.environ.get("SQL_PORT", "5432"),
    }
}

# Password validation
# https://docs.djangoproject.com/en/4.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': (
        # 'rest_framework.permissions.IsAdminUser',
        'rest_framework.permissions.AllowAny',
    ),
    'PAGE_SIZE': 100,
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # 'rest_framework_simplejwt.authentication.JWTAuthentication',
        # 'rest_framework.authentication.TokenAuthentication',
        # 'rest_framework.authentication.BasicAuthentication',
        # 'rest_framework.authentication.SessionAuthentication',
    ),
    # 'EXCEPTION_HANDLER': 'rest_framework_json_api.exceptions.exception_handler',
    'DEFAULT_PAGINATION_CLASS':
        'rest_framework.pagination.PageNumberPagination',
    'DEFAULT_PARSER_CLASSES': (
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser'
    ),
    # 'DEFAULT_METADATA_CLASS': 'rest_framework_json_api.metadata.JSONAPIMetadata',
}

# Internationalization
# https://docs.djangoproject.com/en/4.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.0/howto/static-files/

STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'static'

# Default primary key field type
# https://docs.djangoproject.com/en/4.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

'''
'''--- near_game_backend/urls.py ---
from django.contrib import admin
from django.urls import path, re_path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/v1/', include('api_v1.urls')),
]

'''
'''--- near_game_backend/wsgi.py ---
"""
WSGI config for near_game_backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'near_game_backend.settings')

application = get_wsgi_application()

'''
'''--- requirements.txt ---
asgiref==3.4.1
backports.zoneinfo==0.2.1
base58==2.1.1
certifi==2021.10.8
charset-normalizer==2.0.9
Django==4.0
django-cors-headers==3.10.1
djangorestframework==3.13.1
djangorestframework-simplejwt==5.0.0
ed25519==1.5
idna==3.3
psycopg2==2.9.2
PyJWT==2.3.0
python-dotenv==0.19.2
pytz==2021.3
requests==2.26.0
sqlparse==0.4.2
urllib3==1.26.7

'''