*GitHub Repository "mzhangmzz/event_org"*

'''--- .github/workflows/tests.yml ---
name: Tests
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install modules
        run: yarn
      - name: Run tests
        run: yarn test
'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile

tasks:
  - init: echo "welcome"
    command: npm i && npm run deploy && npm run start

ports:
  - port: 1234
    onOpen: open-browser
'''
'''--- README.md ---
# Guest Book ðŸ“– 
[![](https://img.shields.io/badge/â‹ˆ%20Examples-Basics-green)](https://docs.near.org/tutorials/welcome)
[![](https://img.shields.io/badge/Gitpod-Ready-orange)](https://gitpod.io/#/https://github.com/near-examples/guest-book-rust)
[![](https://img.shields.io/badge/Contract-rust-red)](https://docs.near.org/develop/contracts/anatomy)
[![](https://img.shields.io/badge/Frontend-React-blue)](https://docs.near.org/develop/integrate/frontend)
[![](https://img.shields.io/github/workflow/status/near-examples/guest-book-rust/Tests/main?color=green&label=Tests)](https://github.com/near-examples/guest-book-rust/actions/workflows/tests.yml)

The Guest Book is a simple app that stores messages from users, allowing to pay for a premium message.

![](https://docs.near.org/assets/images/guest-book-b305a87a35cbef2b632ebe289d44f7b2.png)

# What This Example Shows

1. How to receive $NEAR on a contract.
2. How to store and retrieve information from the blockchain.
3. How to use a `Vector`.
4. How to interact with a contract from `React JS`.

<br />

# Quickstart

Clone this repository locally or [**open it in gitpod**](https://gitpod.io/#/github.com/near-examples/guest_book-rust). Then follow these steps:

### 1. Install Dependencies
```bash
npm install
```

### 2. Test the Contract
Deploy your contract in a sandbox and simulate interactions from users.

```bash
npm test
```

### 3. Deploy the Contract
Build the contract and deploy it in a testnet account
```bash
npm run deploy
```

### 4. Start the Frontend
Start the web application to interact with your smart contract 
```bash
npm start
```

---

# Learn More
1. Learn more about the contract through its [README](./contract/README.md).
2. Check [**our documentation**](https://docs.near.org/develop/welcome).
'''
'''--- contract/Cargo.toml ---
[package]
name = "contract"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1.0.150"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
# Guest Book Contract

The smart contract stores messages from users. Messages can be `premium` if the user attaches sufficient money (0.1 $NEAR).

```rust
// Public - Adds a new message.
#[payable]
pub fn add_message(&mut self, text: String) {
  // If the user attaches more than 0.01N the message is premium
  let premium = env::attached_deposit() >= POINT_ONE;
  let sender = env::predecessor_account_id();

  let message = PostedMessage{premium, sender, text};
  self.messages.push(&message);
}

// Returns an array of messages.
pub fn get_messages(&self, from_index:Option<U128>, limit:Option<u64>) -> Vec<PostedMessage>{
  let from = u128::from(from_index.unwrap_or(U128(0)));

  self.messages.iter()
  .skip(from as usize)
  .take(limit.unwrap_or(10) as usize)
  .collect()
}
```

<br />

# Quickstart

1. Make sure you have installed [rust](https://rust.org/).
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<br />

## 1. Build and Deploy the Contract
You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
./deploy.sh
```

Once finished, check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

<br />

## 2. Retrieve the Stored Messages
`get_messages` is a read-only method (`view` method) that returns a slice of the vector `messages`.

`View` methods can be called for **free** by anyone, even people **without a NEAR account**!

```bash
near view <dev-account> get_messages '{"from_index":0, "limit":10}'
```

<br />

## 3. Add a Message
`add_message` adds a message to the vector of `messages` and marks it as premium if the user attached more than `0.1 NEAR`.

`add_message` is a payable method for which can only be invoked using a NEAR account. The account needs to attach money and pay GAS for the transaction.

```bash
# Use near-cli to donate 1 NEAR
near call <dev-account> add_message '{"text": "a message"}' --amount 0.1 --accountId <account>
```

**Tip:** If you would like to add a message using your own account, first login into NEAR using:

```bash
# Use near-cli to login your NEAR account
near login
```

and then use the logged account to sign the transaction: `--accountId <your-account>`.
'''
'''--- contract/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- contract/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract"

near deploy --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm --accountId test1.event_org.testnet

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Serialize, Serializer, Deserialize};
use near_sdk::{env, AccountId, Balance, near_bindgen, Promise, PanicOnDefault, serde_json};
use near_sdk::collections::{LookupMap, UnorderedSet, Vector};
use serde::ser::SerializeStruct;

const NEAR: Balance = 1_000_000_000_000_000_000_000_000;

#[derive(Serialize, Deserialize)]
pub struct EventSpec {
  // Max people that can join this event
  max_num: u64,
  // Min people need to join this event to make it happen
  min_num: u64,
  // In 0.001 * Near
  price: u64,
  // if the number of participants do not meet the target by this time, all funds will be returned
  // Number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
  deadline: u64,
  // If the event raises money successfully, where the money will go to. Usually this will
  // be set as the event owner
  beneficiary: AccountId,
}

type EventId = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Eq, PartialEq)]
enum EventStatus {
  // Deadline is not reached, or no claim has been submitted yet
  WAITING,
  // Deadline has passed and not enough people joined, refund has been issued
  FAILED,
  // Deadline has passed and enough people joined, fund has been sent to beneficiary
  SUCCESS,
}

#[derive(BorshDeserialize, BorshSerialize)]
struct Event {
  // Max people that can join this event
  max_num: u64,
  // Min people need to join this event to make it happen
  min_num: u64,
  cur_participants: Vector<AccountId>,
  // In yoctoNear
  price: Balance,
  // If the number of participants do not meet the target by this time, all funds will be returned
  // Number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
  deadline: u64,
  // Owner of the event
  owner: AccountId,
  // If the event raises money successfully, where the money will go to. Usually this will
  // be set as the event owner
  beneficiary: AccountId,
  status: EventStatus,
}

impl Serialize for Event {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
    let mut state = serializer.serialize_struct("Event", 8)?;
    state.serialize_field("max_num", &self.max_num)?;
    state.serialize_field("min_num", &self.min_num)?;
    state.serialize_field("cur_participants", &self.cur_participants.to_vec())?;
    state.serialize_field("price", &self.price)?;
    state.serialize_field("deadline", &self.deadline)?;
    state.serialize_field("owner", &self.owner)?;
    state.serialize_field("beneficiary", &self.beneficiary)?;
    state.serialize_field("status", &self.status)?;
    state.end()
  }
}

#[derive(Debug)]
struct Error(String);

impl Event {
  fn new(spec: EventSpec, event_id: &String, owner: AccountId) -> Self {
      Self {
        max_num: spec.max_num,
        min_num: spec.min_num,
        cur_participants: Vector::new(event_id.try_to_vec().unwrap()),
        price: spec.price as u128 * 1_000_000_000_000_000_000_000_u128,
        deadline: spec.deadline,
        owner,
        beneficiary: spec.beneficiary,
        status: EventStatus::WAITING,
      }
  }

  fn join(&mut self, deposit: Balance, account_id: &AccountId) -> Result<(), Error> {
    if deposit != self.price {
      return Err(Error(format!("Participant did not attach the right balance, price {} attached: {}", self.price, deposit)));
    }

    for acc in self.cur_participants.iter() {
      if &acc == account_id {
        return Err(Error(format!("{:?} has already joined", account_id)));
      }
    }

    if self.cur_participants.len() >= self.max_num {
      return Err(Error(format!("Event is already full")));
    }

    self.cur_participants.push(account_id);

    Ok(())
  }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
struct Contract {
  event_ids: Vector<EventId>,
  events: LookupMap<EventId, Event>,
  events_by_owner: LookupMap<AccountId, Vector<EventId>>,
  events_by_participants: LookupMap<AccountId, Vector<EventId>>,
}

impl Default for Contract {
  fn default() -> Self {
      Self {
        event_ids: Vector::new(b"a"),
        events: LookupMap::new(b"b"),
        events_by_owner: LookupMap::new(b"c"),
        events_by_participants: LookupMap::new(b"d"),
      }
  }
}

#[near_bindgen]
impl Contract {
  pub fn start_event(&mut self, account_id: AccountId, event_spec: EventSpec) -> EventId {
    env::setup_panic_hook();
    let event_id: EventId = format!("event_{}", self.event_ids.len());
    let event = Event::new(event_spec, &event_id, account_id.clone());

    self.events.insert(&event_id, &event);
    let mut events = self.events_by_owner.get(&account_id).unwrap_or_else(|| Vector::new(format!("o#{}", account_id).as_bytes()));
    events.push(&event_id);
    self.events_by_owner.insert(&account_id, &events);
    self.event_ids.push(&event_id);
    event_id
  }

  #[payable]
  pub fn join(&mut self, event_id: EventId, account_id: AccountId)  {
    env::setup_panic_hook();
    let mut event = self.get_event(&event_id).expect("Event does not exist");
    event.join(env::attached_deposit(), &account_id).unwrap();
    self.events.insert(&event_id, &event);

    let mut events = self.events_by_participants.get(&account_id).unwrap_or_else(|| Vector::new(format!("p#{}", account_id).as_bytes()));
    events.push(&event_id);
    self.events_by_participants.insert(&account_id, &events);
  }

  pub fn claim(&mut self, event_id: EventId) {
    let mut event = self.get_event(&event_id).expect("Event does not exist");

    if event.status == EventStatus::WAITING && env::block_timestamp() >= event.deadline {
      if event.cur_participants.len() < event.min_num {
        event.status = EventStatus::FAILED;
        // If the event doesn't happen, refund everyone
        event.cur_participants.iter().fold(None, |p: Option<Promise>, acc| {
          if let Some(p) = p {
            Some(p.and(Promise::new(acc).transfer(event.price)))
          } else {
            Some(Promise::new(acc).transfer(event.price))
          }
        }).unwrap();
      } else {
        event.status = EventStatus::SUCCESS;
        // Event will happen, send money to beneficiary
        Promise::new(event.beneficiary.clone()).transfer(event.price * (event.cur_participants.len() as u128 ));
      };
    }
    self.events.insert(&event_id, &event);
  }

  pub fn get_all_events(&self) -> Vec<EventId> {
    self.event_ids.to_vec()
  }

  pub fn get_events_by_owner(&self, account_id: AccountId) -> Vec<EventId> {
    self.events_by_owner.get(&account_id).map(|v| v.to_vec()).unwrap_or_default()
  }

  pub fn get_events_by_participants(&self, account_id: AccountId) -> Vec<EventId> {
    self.events_by_participants.get(&account_id).map(|v| v.to_vec()).unwrap_or_default()
  }

  pub fn get_event(&self, event_id: &EventId) -> Option<Event> {
    self.events.get(&event_id)
  }
}

mod tests {
  use near_sdk::serde_json;

  #[test]
  fn test() {
    let string = "1000000000000000000000000000000000";
    let value: u128 = serde_json::from_str(string).unwrap();
    assert_eq!(value, 1000000000000000000000000000000000_u128);
  }
}
'''
'''--- integration-tests/package.json ---
{
  "name": "integration-tests",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "@types/node": "^18.6.2",
    "ava": "^4.2.0",
    "near-workspaces": "^3.2.1",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2"
  },
  "dependencies": {}
}

'''
'''--- integration-tests/src/main.ava.ts ---
import { Worker, NEAR, NearAccount } from 'near-workspaces';
import anyTest, { TestFn } from 'ava';

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // deploy contract
  const root = worker.rootAccount;

  // some test accounts
  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  const contract = await root.createSubAccount("contract", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  // Get wasm file path from package.json test script in folder above
  await contract.deploy(process.argv[2]);

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { root, contract, alice };
});

test.afterEach(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to stop the Sandbox:", error);
  });
});

test("send one message and retrieve it", async (t) => {
  const { root, contract } = t.context.accounts;
  await root.call(contract, "add_message", { text: "aloha" });
  const msgs = await contract.view("get_messages");
  const expectedMessagesResult = [
    { premium: false, sender: root.accountId, text: "aloha" },
  ];
  t.deepEqual(msgs, expectedMessagesResult);
});

test("send two messages and expect two total", async (t) => {
  const { root, contract, alice } = t.context.accounts;
  await root.call(contract, "add_message", { text: "aloha" });
  await alice.call(contract, "add_message", { text: "hola" }, { attachedDeposit: NEAR.parse('1') });
  
  const total_messages = await contract.view("total_messages");
  t.is(total_messages, 2);

  const msgs = await contract.view("get_messages");
  const expected = [
    { premium: false, sender: root.accountId, text: "aloha" },
    { premium: true, sender: alice.accountId, text: "hola" },
  ];

  t.deepEqual(msgs, expected);
});
'''
'''--- package.json ---
{
  "name": "guest-book-rust",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "cd frontend && npm run start",
    "deploy": "cd contract && ./deploy.sh",
    "build": "npm run build:contract && npm run build:web",
    "build:web": "cd frontend && npm run build",
    "build:contract": "cd contract && ./build.sh",
    "test": "npm run build:contract && npm run test:unit && npm run test:integration",
    "test:unit": "cd contract && cargo test",
    "test:integration": "cd integration-tests && npm test -- -- \"./contract/target/wasm32-unknown-unknown/release/contract.wasm\"",
    "postinstall": "cd frontend && npm install && cd .. && cd integration-tests && npm install && cd .. && echo rs contract"
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}
'''