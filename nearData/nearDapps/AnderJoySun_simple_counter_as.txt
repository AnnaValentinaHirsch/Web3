*GitHub Repository "AnderJoySun/simple_counter_as"*

'''--- .travis.yml ---
language: node_js
node_js:
  - "10"
  - "11"
  - "12"

script:
  - yarn test

'''
'''--- README.md ---
# Simple Counter

This example shows how to make a simple NEAR AssemblyScript contract. Normally the sdk
does a lot behind the scenes. When calling a function with arguments it deserializes it for you,
so in this example each exposed function has no arguments. Furthermore, if a function returns
a value the sdk will serialize it for you too, so again these functions do not return anything.

Unfortunately current the serialization must be imported, which adds bloat to the generated binary.
In this example we only use the host imports and the generated optimized binary is only 309 bytes!

The advantage to using AssemblyScript is that you can write code that generates Wasm text that is
readable and close to the code that you wrote. This makes AssemblyScript a great language to learn about
WebAssembly!

# Build it

Running `yarn` under folder or path of this project will auto download missing packages and init the build environment.

Then running `yarn build` will build both a debug and a release version of the binary and a text version.

See `build/debug/simple_counter_as.wat` and `build/release/simple_counter_as.wat` for the generated Wasm in text mode.

Running `yarn test` will run a simple unit test.

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
'''
'''--- asconfig.json ---
{
  "targets": {
    "release": {
      "optimizeLevel": 3,
      "shrinkLevel": 2
    }
  },
  "options": {
    "runtime": "none"
    
  }
}
'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- assembly/__tests__/counter.spec.ts ---
import * as counter from "..";
import { loadCounter } from "../counter";

describe("A simple counter", ()=> {
  it("Should start at 0", () => {
    expect(loadCounter()).toBe(0);
  });

  it("One increment should be 1", () => {
    counter.increment();
    expect(loadCounter()).toBe(1);
  });

  it("One decrement should be -1", () => {
    counter.decrement();
    expect(loadCounter()).toBe(-1);
  });
});
'''
'''--- assembly/counter.ts ---
import { env } from "near-sdk-core";

/**
 * Memory location for key. In Wasm memory starts zero'd.
 * Would be better to ensure that the key is the same value.
 * e.g. `memory.data([42])` returns the memory location where 42 was written.
 * This adds to the data section so that it gets copied when initializing.
 */
export const KEY_PTR = <u64>0;
export const KEY_LEN = <u64>sizeof<u64>();

export const VAL_PTR = KEY_PTR + KEY_LEN;
export const VAL_LEN = <u64>sizeof<u32>();

// Register provided by host, e.i. a hashmap of u64 -> blob of bytes.
export const REG: u64 = <u64>0;

export function setCounter(val: u32): void {
  // Write the value to memory.
  store<u32>(<usize>VAL_PTR, val);
  // Tell the host where the key and value are located and their lengths.
  // If there is an old value it is written to REG.
  env.storage_write(KEY_LEN, KEY_PTR, VAL_LEN, VAL_PTR, REG); 
}

export function loadCounter(): u32 {
  // Check if key is in storage
  if (!env.storage_has_key(KEY_LEN, KEY_PTR)) {
    // Initialize to zero.
    setCounter(0);
  }
  // Read the value into REG
  env.storage_read(KEY_LEN, KEY_PTR, REG);
  // Next write the value to memory.
  // Normally we'd want to use `env.register_len` to allocate the correct space.
  // However, we already know the length of the value
  env.read_register(REG, VAL_PTR);
  // Load the value from memory
  return load<u32>(<usize>VAL_PTR);
}
'''
'''--- assembly/index.ts ---
import { env } from "near-sdk-core";
import { setCounter, loadCounter, VAL_LEN, VAL_PTR } from "./counter";

export function increment(): void {
  setCounter(loadCounter() + 1);
}

export function decrement(): void {
  setCounter(loadCounter() - 1);
}

export function getCounter(): void {
  // Write the value of the counter to memory
  loadCounter();
  // Tell host the length and location of the value
  env.value_return(VAL_LEN, VAL_PTR);
}

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- package.json ---
{
  "name": "simple_counter_as",
  "version": "0.0.1",
  "license": "MIT",
  "types": "assembly/index.ts",
  "scripts": {
    "clean": "rm -rf build/*",
    "rebuild": "yarn clean && yarn build",
    "build": "yarn build:release && yarn build:debug",
    "build:release": "asb --wat",
    "build:debug": "asb --target debug --wat",
    "test": "asp"
  },
  "devDependencies": {
    "@as-pect/cli": "^4.0.0",
    "asbuild": "^0.0.8",
    "assemblyscript": "^0.14.9",
    "near-sdk-as": "^2.0.0"
  }
}

'''