*GitHub Repository "marvinmednick/Exploring-Near-Contracts"*

'''--- README.md ---

# Exploring NEAR Protocol Smart Contracts

## Overview

I created this project to learn the basics of creating, testing and deploying  a smart contracts using NEAR project blockchain. 

This started out as just trying to figure out how to create a simple contract and grew as I understood more and wanted understand how various things work. 

My exploration covered the following areas

* Two Rust smart contract that were created using the near-sdk-rs
	* defining basic contract structure and methods
	* accessing and using data from the NEAR env
	* implements various testing options:
		* Rust unit tests 
		* Rust simulation tests 
		* jest javascript based tests 
	* A contract that NEAR specific data structures that are optimized for accessing data on the blockchain (i.e  Near "Vector" instead the Rust std "Vec") 
	* Using the NEAR U64/U128 JSON types (that workaround JSON 53 bit limitations)
* the basics of using the JS API (Reference) to interact with smart contracts 
* Integrating  with the NEAR wallet:
	- to 'log in' to acquire the signing key for requests 
	- to approving transfers associated with requests that transfer tokens
	- supports multiple wallet logins/signing keys on a single web page
* cross contract calls between two contracts
	- how to develop tests for contracts with cross contract calls
* how to transfer funds between accounts
* scripts/instructions for deploying, initializing

## Functional Overview
From a functional standpoint, this app is a web page that displays information and allows interation with two smart contracts.

A that provide a *very* basic and limited a set of logging functionality;  they allow a user to log some data (a 'log entry') that is stored by the contract.  Entries can later be read back in the order added. 

Each 'log entry' contains some user specified data (a couple of strings) along with some additional metadata ( e.g.  timestamp, AccountId that added the entry ).  

### Block Diagram

![image_info](./images/block_diagram.jpg)

### Key Components 

There are three key components project:
* The **main** contract
* The **proxy** contract
* The Web User Interface

Both contracts are written in Rust using the Near Rust SDK (https://github.com/near/near-sdk-rs )

The web User Interfaces written in javascript and use the NEAR Javascript library  (https://github.com/near/near-api-js)

#### The Main contract
The main contract is the one that does that actual data storage and retrieval of the log entries it support the following methods

| Method       | Description                                                  |
| ------------ | ------------------------------------------------------------ |
| new          | Initializes the log                                          |
| add_entry    | Adds an entry to the log                                     |
| num_entry    | Returns the number of entries that have been added to the log |
| list_entries | provides the full list of all the entries in the log         |
| get_last     | returns only the last entry added to the log                 |
| info         | Returns information about the configuration of the contract  |
| reset_log    | Clears the log                                               |

#### The Proxy Contract

THe proxy contract primary functions is the make cross contact calls the Main contract.

| Method | Description|
|--------|------------|
|new| Initialize the contract which requires AccountId of the account the main logging contract is deployed|
|indirect_add_entry| Calls add_entry on the main contact. |
|indirect_num_entries| Call num_entries on the main contract|
|info|returns the configuration information for the contract (the AccountId of the main contract)|

#### The Web User Interface

HMTL and javascript pages

# Getting Started

Cloning the repo to your local machine.

Identify what account will be used as the Admin account

Install packages

Build the contracts

Run Tests

## Install packages and dependencies.   

    `yarn` 

## Build the contracts

    `yarn build`

## Run Tests

The following will run the unit tests, the Rust Simulation tests and the jest based end-to-end tests in the NEAR shared-test environment.

```
yarn test
```

## Select/Setup Admin Account

Both contracts require initialization with a NEAR account which is considered to be the admin and is allowed to use methods that affect the configuration such as being able to clear the log or for the Proxy contract configure the AccountId of the main contract which it will make the cross contract calls to)

##  Deploy

Contracts are deployed to an account, and each account can only have one contract deployed to it.  
The contract should be deployed to a subaccount or during development to a dev account.
Both methods are described below

### Deploying to Development Accounts

The script 'newdeploydev.sh' is included to deploy and initialize each contracts to two separate development accounts.    The script requires one argument the name of an account which will be the 'admin' for the contracts and will output a file named 'devconfig' which contains bash shell commands to set the necessary environmental variables for of each of the accounts that were created.  

```newdeploydev.sh <admin_acct_id>```

If the admin account set in ADMIN_NAME environmental variable (export ADMIN_NAME=<admin_acct_id>) then the command

```yarn deploy:dev:new``` 

can be used to call the same script.

### Deploying to Specific Named Accounts
The script "deploy.sh" can be used to deploy contracts to specific accounts.  the script requires three parameters the account to deploy the main contract, the account to deploy the proxy contract, and the name of the account to initialize the contracts as the 'admin' account

```
deploy.sh <main_acct_id> <proxy_acct_id> <admin_acct_id>
```

Alternatively the 3 IDs can be provided as environmental variables :
```
export CONTRACT_NAME=<main_acct_id>
export SUBCONTRACT_NAME=<proxy_acct_id>
export ADMIN_NAME=<admin_acct_id>
```

and then simply run as:

```
deploy.sh
```

## Starting the Application Locally

If you have already deployed and initialized the contracts, you start a web local server using parcel which will make the UI web page available  (usual localhost:1234) with the following command

```
yarn restart
```

Alternatively, if you have made some changes that don't impact the on-chain data structures you can rebuild and redeploy the contracts with the start command:

```
yarn start
```

This command will rebuild he contracts and redeploy them to the existing accounts (note that it will redeploy the contracts them even if they haven't changed) and then start the local web server as above.

However if you've made changes to the on chain data structure the new contracts will throw errors as they won't be able to access the existing data properly.  In this case you will need to redeploy the contracts to new accounts and re-initialize them [See section on deploying](#deploy)

## Interacting with the Application

Opening the web pages you will see two column one for the Main contract and one for the Proxy contract. 

![image info](./images/header_example.jpg)

The header section shows the accounts which each contract is deployed on along with the current available balance on that account, and the information at initialization.  

- For the Main account that is the admin account.  
- For the Proxy contract, the admin account and the contract where it will proxy requests to 
  (which should be the Main account) 

The web page allows and requires a separate sign in with the NEAR wallet to interact with the contract. Each side has a separate entry for signing in to interact with that particular contract.   

Note that the information that is displayed in the header (e.g. the admin user) is getting that information via a contract method.  Each contract has a 'info' method that provides the currently configured in that contract.  The UI uses a 'view' (read-only) access  to query the contract to get that information.    (View methods don't need to be signed and there for don't require 'log in' to the NEAR wallet to access signing keys) 

### After Sign-in

After sign in, the options to add a log entry are enabled and an simple entry form (A timestamp, Name and Message) is displayed. 

![image_info](./images/sign_in_example.jpg)

Both contracts have entry forms, but the Proxy version has an additional field allowing Near tokens to be transferred from logged in user to the Main contract.  Transferring is optional.  To not transfer any  tokens leave the amount at 0.  Any amount such as 1,  0.1,  .0001  can be entered either and can represent  NEAR or Million YactoNEAR).

### Viewing Records

#### Last Record 

Once an entry is added to the contract (either), the last record from the log will be displayed in the status window.  This shows the full entry that is logged to the contract in JSON format.

The data in the record is as follows:

```
pub struct LogEntry {
    entry_id:  u64,                  // index of the entry starting from 0
    timestamp: String,            // timestamp as provided by the user
    block_ts: u64,                  // the current block_timestamp as reported by env::block_timestamp
    account: AccountId,         // account which made the request (which could be a user or anothercontract)
    signaccount: AccountId,  // the account tthat signed the request
    name: String,                   // Name -- user provided string
    message: String,              // message -- user provided string
    used_gas: u64,                // used gas as reported by env::gas in this contract
    cc_used_gas: u64,          // when call is made by a another contrct, the amount of gas reported in its env::used_gas
    transfer_amount: u128,  // amount of NEAR transfered (from env::attached_depoist)
 }
```

This view of the the last record uses the get_last method which finds the number of entries and then returns  only the last records

Note on timestamps -- when logging an entry provides a timestamp which  is base on their local machine (e.g. javascript Date() ) and this could vary and can't be considered reliable as comes from the local machine.  As such to ensure that every record is the the contract also logs the current block_timestamp which while may delayed from when the request was made , should be at least consistent and increasing across multiple requests as its maintained and provided by the blockchain.

#### Display Records

At the bottom of the screen there is an option to display all the records.   This interface interacts with get_entries (check name) method which returns ALL the entries in one request.  This is sufficient for this exploration project since the number of entries is small, but for a larger dataset it would be updated to use windowing and only retrieve N records at time, using the similar Vector method as 'get_last' uses to read only the last record. 

<img src="./images/display_list.jpg" alt="image_info" style="zoom:150%;" />    

# References

* [Rust Smart Contract Quick Start](https://docs.near.org/docs/develop/contracts/rust/intro)
* [Rust SDK Book](https://www.near-sdk.io/)

'''
'''--- contracts/.cargo/config.toml ---
[alias]
br ="build  --target wasm32-unknown-unknown --release"

[build]
rustflags = ["-C","link-arg=-s"]

'''
'''--- contracts/Cargo.toml ---
[workspace]
members = [ 
	"explore_near_main",
	"explore_near_proxy"
	]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contracts/explore_near_main/Cargo.toml ---
[package]
name = "explore_near_main"
version = "0.1.0"
authors = ["Marvin Mednick <mmednick@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.5"

[dependencies]
near-sdk = "4.0.0-pre.5"
serde = { version = "1.0", features = ['derive'] }
raw-cpuid = "11.0.0"

'''
'''--- contracts/explore_near_main/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
#cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- contracts/explore_near_main/neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- contracts/explore_near_main/src/lib.rs ---
use near_sdk::{
    AccountId, PanicOnDefault, env, near_bindgen, log, require,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{Vector},
    serde_json::json,
    json_types::U64,
    serde::{Deserialize, Serialize},
};

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]

pub struct MyTimestamp {
	value : u64
}
    

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct LogEntry {
    entry_id:  u64,         // index of the entry starting from 0
    timestamp: String,      // timestamp as provided by the user
    block_ts: u64,          // the current block_timestamp as reported by env::block_timestamp
    account: AccountId,     // account which made the request (which could be a user or another contract)
    signaccount: AccountId, // the account tthat signed the request
    name: String,           // Name -- user provided string
    message: String,        // message -- user provided string
    used_gas: u64,          // used gas as reported by env::gas in this contract
    cc_used_gas: u64,       // when call is made by a another contrct, the amount of gas reported in its env::used_gas
    transfer_amount: u128,  // amount of NEAR transfered (from env::attached_depoist)
 
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize,PanicOnDefault)]
pub struct LogContract {
    owner_id:  AccountId,
    admin: AccountId,
    mylog:  Vector<LogEntry>
}

#[near_bindgen]
impl LogContract {

    #[init]
    pub fn new(admin: String) -> Self {
        log!("Log Contract Init - owner: {}",env::current_account_id());
        Self {
            owner_id: env::current_account_id(),
            admin: admin.try_into().unwrap(),
            mylog: Vector::new(b"c"),        
        }

   }

    #[payable]
    pub fn add_entry (&mut self, timestamp: String, name: String, message: String, cc_used_gas: U64) {
	                                  
        let new_entry = LogEntry {
            entry_id : self.mylog.len()+1,
            timestamp : timestamp, 
            block_ts:   u64::from(env::block_timestamp()),
            account : env::predecessor_account_id(),
            signaccount: env::signer_account_id(), 
            name    : name,
            message   : message,
            used_gas :   u64::from(env::used_gas()),
            cc_used_gas: u64::from(cc_used_gas),
            transfer_amount: env::attached_deposit(),

        };
        self.mylog.push(&new_entry);
        log!("Entry {} Added.  Attached Depost: {}",self.mylog.len(), env::attached_deposit().to_string());
        //env::log_str(&("Entry Added! ".to_owned() + "Deposit: " + &env::attached_deposit().to_string()));
    }
    pub fn num_entries(&self) -> u64 {
       self.mylog.len()
    }

    
    pub fn get_info(&self) -> String {
        let env_used_gas = u64::from(env::used_gas()).to_string();
        let env_prepaid_gas = u64::from(env::prepaid_gas()).to_string();
        let env_time = env::block_timestamp().to_string();
        let curcount = self.mylog.len().to_string();

    	let result = String::new() + &"Block time: " + &env_time + "; used_gas: " + &env_used_gas + "; prepaid_gas: " + &env_prepaid_gas + &"; num_entries: " + &curcount;
    	result
    }
   

	pub fn get_last(&self) -> String {

        let mut result = String::new();
		
        let len = self.mylog.len();
        if len > 0 {
    
		  let entry = self.mylog.get(len-1);
		  let x = match entry {
			Some(x) => { near_sdk::serde_json::to_string(&x).unwrap() }
			None => { String::new() }
		  };    
		   result = x;
        };
		result
	}

    fn  check_for_admin_rights(&self) {
        let request_acct = env::predecessor_account_id().to_string();
        log!("Update of log contract requested by {}",&request_acct);
        let check1 = env::predecessor_account_id() == env::current_account_id();
        let check2 = env::predecessor_account_id() ==  self.admin;
        require!(check1 || check2, "Only contract or admin can update configuration");

    }

    /// Update admin 
    ///
    /// Since initialization is only done one once (unless using 'init(ignore_state)' )
    pub fn update_admin(&mut self, admin: String) {
            
        self.check_for_admin_rights();
        // require!(env::predecessor_account_id() == self.admin_user,"Admin account method");
        self.admin = admin.try_into().unwrap();
    }

    // list_entries 
    pub fn list_entries(&self) -> String {
        let mut count = 0;
        let mut result = String::new();
        
        result += r#"{ "log_entries": ["#;
        for entry in self.mylog.iter() {
            count = count + 1;
            if count > 1 {
                result += ", ";
            }
            //let line = format!("Entry #{} TS: {} NAME: {} ACCT: {} MSG: {}",count, entry.timestamp, entry.name, entry.account, entry.message);
            let serialized = near_sdk::serde_json::to_string(&entry).unwrap();
            result += &serialized;    

        }
        result += r#"] }"#;

        
        result
    }

    /// Return the configured information for this contract
    ///
    /// return JSON structure with the logging account and the admin user
    pub fn info(&self) -> String {
        

        let result = json!({
                "owner_id" : self.owner_id.to_string(),
                "admin"      : self.admin.to_string(),
            }).to_string();
        result
    }
    

    pub fn reset_log (&mut self) -> String {
        let reset_acct = env::predecessor_account_id().to_string();
        log!("Reset log requested by {}",&reset_acct);
        let check1 = env::predecessor_account_id() == self.owner_id;
        let check2 = env::predecessor_account_id() ==  self.admin;
        require!(check1 || check2, "Only contract or admin can reset");
        let result = env::current_account_id().to_string() + " " + &self.admin.to_string() + " " + &reset_acct;
        self.mylog.clear();
        result
        
    }

}

/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-template -- --nocapture
 * Note: 'rust-template' comes from Cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{get_logs, VMContextBuilder};
    use near_sdk::{testing_env, AccountId,serde_json};

    // part of writing unit tests is setting up a mock context
    // provide a `predecessor` here, it'll modify the default context
    fn get_context(predecessor: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }

    fn setup_contract() -> LogContract {
        let account = AccountId::new_unchecked("admin".to_string());
        let context = get_context(account);
        testing_env!(context.build());

        let contract = LogContract::new("admin".to_string());
        contract
     
    }

    #[test]
    fn check_info() {

        #[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug, Clone)]
        #[serde(crate = "near_sdk::serde")]
        struct ContractInfo {
               owner_id:  String,
               admin: String,
        }
    
        let contract = setup_contract();
        let info_json = contract.info();
        println!("Info:  {:?}",info_json);
        let info_data = serde_json::from_str::<ContractInfo>(&info_json).unwrap();
        assert_eq!(info_data.admin,"admin".to_string() );

    }

	#[test]
    fn check_add_entry() {
        let mut contract = setup_contract();
        contract.add_entry("dateAndTime".to_string(),"NameofSam".to_string(),"My Message is".to_string(),U64::from(0));    
        assert_eq!(get_logs(), ["Log Contract Init - owner: alice.near", "Entry 1 Added.  Attached Depost: 0"], "Exec.");

        assert_eq!(contract.num_entries(),1);

        contract.add_entry("dateAndTime1".to_string(),"My Name is".to_string(),"My Message is".to_string(),U64::from(0));
        assert_eq!(contract.num_entries(),2);

    }

	#[test]
    fn check_list() {
        let mut contract = setup_contract();

        let entries_json = contract.list_entries();
		let loglist = serde_json::from_str::<LogList>(&entries_json).unwrap();
        assert_eq!(loglist.log_entries.len(),0);
        println!("entries: {:?}", loglist);

        contract.add_entry("dateAndTime".to_string(),"NameofSam".to_string(),"My Message is".to_string(),U64::from(0));    
        contract.add_entry("dateAndTime1".to_string(),"My Name is".to_string(),"My Message is".to_string(),U64::from(0));
        assert_eq!(contract.num_entries(),2);

		#[derive(Deserialize, Debug, Clone)]
        pub struct LogList {
            pub log_entries: Vec<LogEntry>,
        }

        let entries_json = contract.list_entries();
		let loglist = serde_json::from_str::<LogList>(&entries_json).unwrap();
        println!("entries: {:?}", loglist);

        assert_eq!(loglist.log_entries[0].entry_id,1);
        assert_eq!(loglist.log_entries[1].entry_id,2);
        assert_eq!(loglist.log_entries[0].timestamp,"dateAndTime");
        assert_eq!(loglist.log_entries[1].timestamp,"dateAndTime1");
        assert_eq!(loglist.log_entries.len(),2);
    }

	#[test]
    fn check_reset() {
        let mut contract = setup_contract();
        contract.add_entry("dateAndTime".to_string(),"NameofSam".to_string(),"My Message is".to_string(),U64::from(0));    
        contract.add_entry("dateAndTime".to_string(),"NameofSam".to_string(),"My Message is".to_string(),U64::from(0));    
        assert_eq!(contract.num_entries(),2);
		contract.reset_log();
        assert_eq!(contract.num_entries(),0);
	}

}

'''
'''--- contracts/explore_near_main/tests/sim/first_tests.rs ---
use near_sdk_sim::{view, call, DEFAULT_GAS};
use near_sdk::serde_json::json;
use crate::utils::init;
use near_sdk::json_types::U64;

#[test]
fn simulate_basic_operation() {
	let (root, contract) = init();
	let actual : u64 = view!(contract.num_entries()).unwrap_json();
	assert_eq!(actual, 0);
	call!(root, contract
		.add_entry( "Now".to_string(), "Me".to_string(), "My Message".to_string(), U64::from(0))
		).assert_success();

// Now use the non-macro approach to increment the number.
    root.call(
        contract.account_id(),
        "add_entry",
        &json!({"timestamp": "Now".to_string(), "name": "Me".to_string(), "message": "My Message".to_string(), "cc_used_gas": U64::from(0)})
            .to_string()
            .into_bytes(),
        DEFAULT_GAS,
        0, // attached deposit
    ).assert_success();

	let actual : u64 = view!(contract.num_entries()).unwrap_json();
	assert_eq!(actual, 2);

}

'''
'''--- contracts/explore_near_main/tests/sim/main.rs ---
mod utils;
mod first_tests;

'''
'''--- contracts/explore_near_main/tests/sim/new_main.rs ---
use near_sdk_sim::{view, call, init_simulator, deploy, UserAccount, ContractAccount, DEFAULT_GAS};
use near_sdk::serde_json::json;
use explore_near_main::LogContractContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    CONTRACT_WASM_BYTES => "../target/wasm32-unknown-unknown/release/explore_near_main.wasm",
}

pub fn init() -> (UserAccount, ContractAccount<LogContractContract>) {
    let _root = init_simulator(None);

    let contract : ContractAccount<LogContractContract> = deploy!(
        contract: LogContractContract,
        contract_id: "contract".to_string(),
		bytes: &CONTRACT_WASM_BYTES,
		signer_account:  _root,
    );

    (_root, contract)
}

#[test]
fn simulate_some_view_function() {
	let (root, contract) = init();
	call!(root, contract.new()).assert_success();
	let actual : u64 = view!(contract.num_entries()).unwrap_json();
	assert_eq!(actual, 0);
	call!(root, contract
		.add_entry( "Now".to_string(), "Me".to_string(), "My Message".to_string())
		).assert_success();

// Now use the non-macro approach to increment the number.
    root.call(
        contract.account_id(),
        "add_entry",
        &json!({"timestamp": "Now".to_string(), "name": "Me".to_string(), "message": "My Message".to_string()})
            .to_string()
            .into_bytes(),
        DEFAULT_GAS,
        0, // attached deposit
    ).assert_success();

	let actual : u64 = view!(contract.num_entries()).unwrap_json();
	assert_eq!(actual, 2);

}

'''
'''--- contracts/explore_near_main/tests/sim/utils/mod.rs ---
use near_sdk_sim::{call, init_simulator, deploy, UserAccount, ContractAccount};
//use near_sdk_sim::types::AccountId;
use explore_near_main::LogContractContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    CONTRACT_WASM_BYTES => "../target/wasm32-unknown-unknown/release/explore_near_main.wasm",
}

pub fn init() -> (UserAccount, ContractAccount<LogContractContract>) {
    // Use `None` for default genesis configuration; more info below
    let root = init_simulator(None);

    let contract : ContractAccount<LogContractContract> = deploy!(
        contract: LogContractContract,
        contract_id: "contract".to_string(),
		bytes: &CONTRACT_WASM_BYTES,
		signer_account:  root,
     );
	call!(root, contract.new("admin".to_string())).assert_success();

    (root, contract)
}

'''
'''--- contracts/explore_near_proxy/Cargo.toml ---
[package]
name = "explore_near_proxy"
version = "0.1.0"
authors = ["Marvin Mednick <mmednick@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.5"

[dependencies]
near-sdk = "4.0.0-pre.5"
serde = { version = "1.0", features = ['derive'] }
raw-cpuid = "11.0.0"

'''
'''--- contracts/explore_near_proxy/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
#mkdir -p ./out
#cp target/wasm32-unknown-unknown/release/marvfirst_sub.wasm ./out/main.wasm

'''
'''--- contracts/explore_near_proxy/src/lib.rs ---
use near_sdk::{
    AccountId, PanicOnDefault, near_bindgen, ext_contract,
    Promise, PromiseResult,
    env, Gas, log, require,
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde_json::json,
    json_types::{U64},
    
};

/// External definitions for Cross Contract Calls to Logger
#[ext_contract(ext_logger)]
trait LoggerContract {
    fn add_entry(&self, timestamp: String, name: String, message: String, cc_used_gas: U64);
    fn num_entries();
    fn get_last();
}

/// External definitions for Cross Contract callbacks
#[ext_contract(ext_self)]
pub trait MyContract {
    fn num_entries_callback(&self) -> u64;
    fn get_last_callback(&self) -> String;
}

/// Sub contract data structures
///
/// Contains the configuration for the address the contract that this contract 
/// will call to log data
///
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize,PanicOnDefault)]
struct CallLoggerContract {
    /// AccountId of the contract for Cross contract call for logging
	log_contract_id : AccountId,
    /// Admin account allowed to update logging contract
    admin_user: AccountId
}

/// Sub contract implmentation
#[near_bindgen]
impl CallLoggerContract {
    
    /// Initialization of contract requires address of contract to log to
	#[init]
    pub fn new(log_contract : String, admin : String) -> Self {
        log!("Init Subcongtract -  Log_contract: {} admin = {}", log_contract, admin);
        Self {
          log_contract_id : log_contract.try_into().unwrap(),
          admin_user : admin.try_into().unwrap(),
        } 
    }

    fn  check_for_admin_rights(&self) {
        let request_acct = env::predecessor_account_id().to_string();
        log!("Update of log contract requested by {}",&request_acct);
        let check1 = env::predecessor_account_id() == env::current_account_id();
        let check2 = env::predecessor_account_id() ==  self.admin_user;
        require!(check1 || check2, "Only contract or admin can update configuration");

    }

    /// Update logging contrct 
    ///
    /// Since initialization is only done one once (unless using 'init(ignore_state)' )
    pub fn update_log_contract(&mut self, log_contract: String) {
        self.check_for_admin_rights();
        /* require!(env::predecessor_account_id() == self.admin_user,"Admin account method");
        let request_acct = env::predecessor_account_id().to_string();
        log!("Update of log contract requested by {}",&request_acct);
        let check1 = env:   self.chredecessor_account_id() == self.owner_id;
        let check2 = env::predecessor_account_id() ==  self.admin;
        require!(check1 || check2, "Only contract or admin can update configuration");
        */

        self.log_contract_id = log_contract.try_into().unwrap();
    }

    /// Update admin 
    ///
    /// Since initialization is only done one once (unless using 'init(ignore_state)' )
    pub fn update_admin(&mut self, admin: String) {
        
        self.check_for_admin_rights();
        // require!(env::predecessor_account_id() == self.admin_user,"Admin account method");
        self.admin_user = admin.try_into().unwrap();
    }

    /// non-macro method for a cross contract call to add_entry
    ///
    /// Is payable and transfer amount if provide is transfered to the logging 
	#[payable]
    pub fn indirect_add_entry(&mut self, timestamp: String, name: String, message: String) {
		
        let _cross_contract_call = 
             Promise::new(self.log_contract_id.clone()).function_call(
                "add_entry".to_string(),
                json!({
                    "timestamp" : timestamp,
                    "name"      : name,
                    "message"   : message,
                    "cc_used_gas" : U64::from(u64::from(env::used_gas())),
                }).to_string().into_bytes(),
                env::attached_deposit(), // yocto NEAR to attach, // yocto NEAR to attach
                Gas::from(5_000_000_000_000) // gas to attach
            );
        env::log_str("indirect_entry_add completed");
    }

/*
    /// macro implementat method for a cross contract call to add_entry
    ///
    /// Is payable and transfer amount if provide is transfered to the logging 
	#[payable]
    pub fn indirect_add(&mut self, timestamp: String, name: String, message: String) {

        ext_logger::add_entry(
            timestamp,
            name,
            message,
            U64::from(u64::from(env::used_gas())),
            self.log_contract_id.clone(),
            // take any attached deposit and send it on as to the main contract
            env::attached_deposit(), // yocto NEAR to attach
            Gas::from(5_000_000_000_000) // gas to attach
        );
    }

*/

    /// Read the number of entries via a cross contract call
	pub fn indirect_num_entries(&self) -> Promise {
		ext_logger::num_entries(  
            self.log_contract_id.clone(),
            0, // yocto NEAR to attach
            Gas::from(5_000_000_000_000) // gas to attach
		).then(ext_self::num_entries_callback(
			env::current_account_id(), // this contract's account id
			0, // yocto NEAR to attach to the callback
			Gas::from(5_000_000_000_000) // gas to attach to the callback
			)
		) 
	}

    /// Callback routine for indirect_num_entries promise
    pub fn num_entries_callback(&mut self)  -> u64 {
        
        assert_eq!(
          env::promise_results_count(),
          1,
          "This is a callback method"
        );

      // handle the result from the cross contract call this method is a callback for
      match env::promise_result(0) {
        PromiseResult::NotReady => 0,
        PromiseResult::Failed => { 0 },
        PromiseResult::Successful(result) => {
            let count = near_sdk::serde_json::from_slice::<u64>(&result).unwrap();
            count
        },
      }
    }

    /// Read the last entry via a cross contract call
    pub fn indirect_get_last(&self) -> Promise {
        ext_logger::get_last(  
            self.log_contract_id.clone(),
            0, // yocto NEAR to attach
            Gas::from(5_000_000_000_000) // gas to attach
        ).then(ext_self::get_last_callback(
            env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            Gas::from(5_000_000_000_000) // gas to attach to the callback
            )
        ) 
    }

    /// Callback routine for indirect_get_last promise
    pub fn get_last_callback(&mut self)  -> String {
    
        assert_eq!(
          env::promise_results_count(),
          1,
          "This is a callback method"
        );

      // handle the result from the cross contract call this method is a callback for
      match env::promise_result(0) {
        PromiseResult::NotReady => "Not Ready".to_string(),
        PromiseResult::Failed => { "Failed".to_string() },
        PromiseResult::Successful(result) => {
            let result = near_sdk::serde_json::from_slice::<String>(&result).unwrap();
            result
        },
      }
    }

    /// Return the configured information for this contract
    ///
    /// return JSON structure with the logging account and the admin user
	pub fn info(&self) -> String {
        
        let result = json!({
                "log_contract" : self.log_contract_id.to_string(),
                "admin"      : self.admin_user.to_string(),
            }).to_string();
        result
	}

}
    

/*
 * the rest of this file sets up unit tests
 * to be run as part of cargo test
 * to run these separately, the command will be:
 * cargo test --package <xxx> -- --nocapture
  */

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{get_logs, VMContextBuilder};
    use near_sdk::{testing_env, AccountId};

    // part of writing unit tests is setting up a mock context
    // provide a `predecessor` here, it'll modify the default context
    fn get_context(predecessor: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }

     #[test]
    fn basic_test() {
        let account = AccountId::new_unchecked("andre".to_string());
        let _mainaccount = AccountId::new_unchecked("barbara".to_string());
        let context = get_context(account);
        testing_env!(context.build());

        let mut contract = CallLoggerContract::new("devacct".to_string(),"mmednicktoss.testnet".to_string());
        println!("{:?}",get_logs());
        contract.indirect_add_entry("dateAndTime".to_string(),"NameofSam".to_string(),"My Message is".to_string());
        println!("{:?}",get_logs());
        assert_eq!(get_logs(), ["Init Subcongtract -  Log_contract: devacct admin = mmednicktoss.testnet", "indirect_entry_add completed"], "Exec.");
        let info = contract.info();
        println!("{:?}",info);
        
        }

}

'''
'''--- contracts/explore_near_proxy/tests/sim/explore_near_main.rs ---
use near_sdk::{near_bindgen,
               borsh::{self, BorshDeserialize, BorshSerialize},
               serde::{Deserialize, Serialize},
               };

use near_sdk::json_types::U64;           

use near_sdk::AccountId;
    
#[allow(dead_code)]
#[near_bindgen]
pub struct LogContract {
}

#[near_bindgen]
impl LogContract {

    #[allow(unused_variables, dead_code)]    
    pub fn new(admin : String) {}
    #[allow(unused_variables, dead_code)]   
    pub fn add_entry (&mut self, timestamp: String, name: String, message: String, cc_used_gas: U64) {}
    #[allow(unused_variables, dead_code)]
    pub fn num_entries(&self) -> u64 { 0 }
    #[allow(unused_variables, dead_code)]
    pub fn get_info(&self)  {} 
    #[allow(unused_variables, dead_code)]
   	pub fn get_last(&self)  { } 
    #[allow(unused_variables, dead_code)]
    pub fn list_entries(&self) { } 
    #[allow(unused_variables, dead_code)]
    pub fn reset_log (&mut self)  { }
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct LogEntry {
    pub entry_id:  u64,
    pub timestamp: String,
    block_ts: u64,
    pub account: AccountId,
    signaccount: AccountId,
    pub name: String,
    pub message: String,
    used_gas: u64,
    cc_used_gas: u64,
    transfer_amount: u128
}
'''
'''--- contracts/explore_near_proxy/tests/sim/first_tests.rs ---
use near_sdk_sim::{view, call, DEFAULT_GAS};
use near_sdk::{
	serde_json::{json, from_str},
	serde::{Deserialize, Serialize},
	borsh::{self, BorshDeserialize, BorshSerialize}
};
use crate::utils::init;

use crate::explore_near_main::LogEntry;

#[test]
fn simluate_initial_setup() {

     #[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug, Clone)]
     #[serde(crate = "near_sdk::serde")]
     struct ContractInfo {
               log_contract:  String,
               admin: String,
     }

	println!("Starting");
	let (_root, contract, subcontract) = init();
	
	let actual :u64 = view!(contract.num_entries()).unwrap_json();
	assert_eq!(actual, 0);

	let x_json : String = view!(subcontract.info()).unwrap_json();
	let x = near_sdk::serde_json::from_str::<ContractInfo>(&x_json).unwrap();
	assert_eq!(x.log_contract,contract.account_id().to_string());

}

#[test]
fn simulate_basic_operation() {
	let (root, contract, subcontract) = init();
	
	// use non-macro call to check num entries from subcontract 
	let actual : u64 = root.call(
        subcontract.account_id(),
        "indirect_num_entries",
        &json!({})
            .to_string()
            .into_bytes(),
        DEFAULT_GAS,
        0, // attached deposit
    ).unwrap_json();
	assert_eq!(actual, 0);

	// use the call macro to add a entry
	call!(root, subcontract
		.indirect_add_entry( "Now".to_string(), "Me".to_string(), "My Message".to_string())
	).assert_success();

		// use the call macro to add a entry
	let ret : String = call!(root, contract.get_last()).unwrap_json();
	let deserialized: LogEntry = near_sdk::serde_json::from_str(&ret).unwrap();
	assert_eq!(deserialized.name,"Me");
	assert_eq!(deserialized.message,"My Message");
	assert_eq!(deserialized.timestamp,"Now");
	// Now use the non-macro approach to add an entry 
    root.call(
        subcontract.account_id(),
        "indirect_add_entry",
        &json!({"timestamp": "Now".to_string(), "name": "Me".to_string(), "message": "My Message1".to_string(), "cc_used_gas" : 1})
            .to_string()
            .into_bytes(),
        DEFAULT_GAS,
        0, // attached deposit
    ).assert_success();

    // check the number of entries reported both directly and indirectly
	let actual1 : u64 = view!(contract.num_entries()).unwrap_json();
	
	let actual2 : u64= root.call(
        subcontract.account_id(),
        "indirect_num_entries",
        &json!({})
            .to_string()
            .into_bytes(),
        DEFAULT_GAS,
        0, // attached deposit
    ).unwrap_json();
    
    assert_eq!(actual1, actual2);
    assert_eq!(actual1, 2);

}

'''
'''--- contracts/explore_near_proxy/tests/sim/main.rs ---
mod explore_near_main;
mod utils;
mod first_tests;

'''
'''--- contracts/explore_near_proxy/tests/sim/utils.rs ---
use near_sdk_sim::{call, init_simulator, deploy, UserAccount, ContractAccount};
//use near_sdk_sim::types::AccountId;
use explore_near_proxy::CallLoggerContractContract;

use crate::explore_near_main::LogContractContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    SUBCONTRACT_WASM_BYTES => "../target/wasm32-unknown-unknown/release/explore_near_proxy.wasm",
}
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    CONTRACT_WASM_BYTES => "../target/wasm32-unknown-unknown/release/explore_near_main.wasm",
}

pub fn init() -> (UserAccount, ContractAccount<LogContractContract>, ContractAccount<CallLoggerContractContract>) {
    // Use `None` for default genesis configuration; more info below
    let root = init_simulator(None);

    let contract : ContractAccount<LogContractContract> = deploy!(
        contract: LogContractContract,
        contract_id: "main_contract".to_string(),
		bytes: &CONTRACT_WASM_BYTES,
		signer_account:  root,
     );

    let sub_contract : ContractAccount<CallLoggerContractContract> = deploy!(
        contract: CallLoggerContractContract,
        contract_id: "sub_contract".to_string(),
		bytes: &SUBCONTRACT_WASM_BYTES,
		signer_account:  root,
     );

	call!(root, contract.new("admin".to_string())).assert_success();
	call!(root, sub_contract.new("main_contract".to_string(),"admin".to_string())).assert_success();

//    let alice = root.create_user(
 //       "alice".parse().unwrap(),
  //      to_yocto("100") // initial balance
   // );

    (root, contract, sub_contract)
}

'''
'''--- deploy.sh ---
#!/bin/bash -x

near --version

if [ "$ADMIN_NAME" == "" || "$CONTRACT_NAME" == "" || $SUBCONTRACT_NAM == "" ] && [ $# -lt 3 ]; then 
	echo "Usage:  $0 <main_account> <proxy_account> <admin account>"
	exit 1
fi

if [ $# -ge 3]; then 
CONTRACT_NAME=$1
SUBCONTRACT_NAME=$2
ADMIN_NAME=$3
fi

MAIN_DIR=explore_near_main
MAIN_WASM=explore_near_main.wasm
PROXY_DIR=explore_near_proxy
PROXY_WASM=explore_near_proxy.wasm

# change directories to have separate neardev directory for each contract
near deploy --accountId $CONTRACT_NAME --wasmFile contracts/out/$MAIN_WASM --initFunction new --initArgs "{ \"admin\" : \"$ADMIN_NAME\" }"
near deploy --accountId $SUBCONTRACT_NAME --wasmFile contracts/out/$PROXY_WASM --initFunction new --initArgs "{\"log_contract\" : \"$CONTRACT_NAME\", \"admin\" : \"$ADMIN_NAME\"}"

'''
'''--- neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- newdevdeploy.sh ---
#!/bin/bash -x

near --version

if [ "$ADMIN_NAME" == "" ]  && [ $# -lt 1 ]; then 
	echo "Usage:  $0 <admin account>"
	exit 1
fi

if [ $# -ge 1 ]; then 
ADMIN_NAME=$1
fi

MAIN_DIR=explore_near_main
MAIN_WASM=explore_near_main.wasm
PROXY_DIR=explore_near_proxy
PROXY_WASM=explore_near_proxy.wasm

#Delete neardev files 
rm -f contracts/$MAIN_DIR/neardev/dev*
rm -f contracts/$PROXY_DIR/neardev/dev*

# change directories to have separate neardev directory for each contract
pushd contracts/$MAIN_DIR 
near dev-deploy --wasmFile ../out/$MAIN_WASM --initFunction new --initArgs "{ \"admin\" : \"$ADMIN_NAME\" }"
popd

#!/bin/bash
export CONTRACT_NAME=`cat contracts/$MAIN_DIR/neardev/dev-account` 
echo $CONTRACT_NAME
echo "export CONTRACT_NAME=$CONTRACT_NAME" > devconfig

pushd contracts/$PROXY_DIR 
near dev-deploy --wasmFile ../out/$PROXY_WASM --initFunction new --initArgs "{\"log_contract\" : \"$CONTRACT_NAME\", \"admin\" : \"$ADMIN_NAME\"}"
popd
export SUBCONTRACT_NAME=`cat contracts/$PROXY_DIR/neardev/dev-account` 
echo $SUBCONTRACT_NAME
echo "export SUBCONTRACT_NAME=$SUBCONTRACT_NAME" >> devconfig

echo "exports stored in \"devconfig\" file.  Type \"source devconfig\" to setup environment"

'''
'''--- package.json ---
{
  "name": "marvfirst",
  "description": "A simply logging Smart Contract\n\nThis project contains implementation of a log backed by blockchain, written in Rust.",
  "version": "0.0.1",
  "license": "(MIT AND Apache-2.0)",
  "config": {
    "mainwasm": "explore_near_main.wasm",
    "subwasm": "explore_near_proxy.wasm"
  },
  "scripts": {
    "build": "cd contracts && cargo build --all --target wasm32-unknown-unknown --release",
    "build:dev": "cd contracts && cargo build --all --target wasm32-unknown-unknown",
    "build:c1": "cd contracts && cargo build --package explore_near_main --target wasm32-unknown-unknown --release",
    "build:c2": "cd contracts && cargo build --package explore_near_main --target wasm32-unknown-unknown --release",
    "postbuild:c1": "mkdir -p ./contracts/out && cp ./contracts/target/wasm32-unknown-unknown/release/$npm_package_config_mainwasm ./contracts/out",
    "postbuild:c2": "mkdir -p ./contracts/out && cp ./contracts/target/wasm32-unknown-unknown/release/$npm_package_config_subwasm ./contracts/out",
    "postbuild": "mkdir -p ./contracts/out && cp ./contracts/target/wasm32-unknown-unknown/release/*.wasm ./contracts/out",
    "deploy:contract": "yarn deploy:c1 && yarn deploy:c2",
    "deploy:c1": "near deploy $CONTRACT_NAME ./contracts/out/$npm_package_config_mainwasm",
    "deploy:c2": "near deploy $SUBCONTRACT_NAME ./contracts/out/$npm_package_config_subwasm",
    "deploy:pages": "gh-pages -d src",
    "deploy": "yarn build && yarn deploy:contract",
    "deploy:dev:new": "newdevdeploy.sh",
    "deploy:dev": "yarn build && yarn deploy:dev:c1  && yarn deploy:dev:c2",
    "deploy:dev:c1": "yarn build:c1 && cd contracts/explore_near_main && near dev-deploy ../out/$npm_package_config_mainwasm",
    "deploy:dev:c2": "yarn build:c2 && cd contracts/explore_near_proxy && near dev-deploy ../out/$npm_package_config_subwasm",
    "dev": "yarn deploy:dev && yarn start:dev",
    "clrdev": "yarn clrdev:c1 && yarn clrdev:c2",
    "clrdev:c1": "rm contracts/explore_near_main/neardev/dev*",
    "clrdev:c2": "rm contracts/explore_near_proxy/neardev/dev*",
    "initcontracts": "yarn init:c1 && yarn init:c2",
    "init:c1": "near deploy --accountId $CONTRACT_NAME --wasmFile contracts/out/$npm_package_config_mainwasm --initFunction new --initArgs \"{\\\"admin\\\" : \\\"$ADMIN_NAME\\\"}\"",
    "init:c2": "near deploy --accountId $SUBCONTRACT_NAME --wasmFile contracts/out/$npm_package_config_subwasm --initFunction new --initArgs \"{\\\"log_contract\\\" : \\\"$CONTRACT_NAME\\\", \\\"admin\\\" : \\\"$ADMIN_NAME\\\"}\"",
    "update:c2": "updateSubContractConfig.sh",
    "update:c2a": "near call $SUBCONTRACT_NAME update_log_contract \"{\\\"log_contract\\\" : \\\"$CONTRACT_NAME\\\"}\" --accountId  $SUBCONTRACT_NAME",
    "getinfo": "yarn info:c1 && yarn info:c2",
    "info:c1": "near view $CONTRACT_NAME info",
    "info:c2": "near view $SUBCONTRACT_NAME info",
    "prestart": "yarn build && yarn deploy:contract",
    "start": "parcel src/index.html",
    "start:dev": "env-cmd -f ./neardev/dev-account.env parcel src/index.html",
    "restart": "parcel src/index.html",
    "test:cargo": "cd contracts && cargo test",
    "test:cargo:output": "cd contracts && cargo test -- --nocapture",
    "test": "yarn build && yarn test:cargo && jest",
    "envconfig": "setupdevcfg.sh",
    "jest": "jest"
  },
  "jest": {
    "testEnvironment": "./src/test_environment"
  },
  "devDependencies": {
    "env-cmd": "^10.1.0",
    "near-cli": "^3.1.0",
    "nodemon": "~2.0.14",
    "parcel-bundler": "~1.12.5"
  },
  "dependencies": {
    "big.js": "^6.1.1",
    "jest": "^27.4.5",
    "near-api-js": "^0.43.1",
    "regenerator-runtime": "^0.13.9"
  }
}

'''
'''--- save_main.js ---
import "regenerator-runtime/runtime";
import * as nearAPI from "near-api-js";
import getConfig from "./config";
const nearConfig = getConfig(process.env.NODE_ENV || "development");

window.nearConnections = {
    mainacct:  {near: null, walletConnection: null, contract: null },
    subacct:  {near: null, walletConnection: null, contract: null },
}

console.log(nearConnections);

  // Copied from rust-counter
async function connect(nearConfg, account) {

  let connection = window.nearConnections[account];

  // Connects to NEAR and provides `near`, `walletAccount` and `contract` objects in `window` scope
  // Initializing connection to the NEAR node.
  connection.near = await nearAPI.connect({
    deps: {
      keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore()
    },
    ...nearConfig
  });

    // Needed to access wallet login
  connection.walletConnection = new nearAPI.WalletConnection(connection.near,account);

  // MAIN CONTRACT: Initializing our contract APIs by contract name and configuration.
  connection.contract = await new nearAPI.Contract(connection.walletConnection.account(), nearConfig.contractName, {
    // View methods are read-only – they don't modify the state, but usually return some value
    viewMethods: ['num_entries', 'list_entries', 'get_last'],
    // Change methods can modify the state, but you don't receive the returned value when called
    changeMethods: ['new', 'add_entry', 'reset_log', 'get_info'],
    // Sender is the account ID to initialize transactions.
    // getAccountId() will return empty string if user is still unauthorized
    sender: connection.walletConnection.getAccountId()
  });
  console.log("X",connection.contract);
}

function errorHelper(err) {
  // if there's a cryptic error, provide more helpful feedback and instructions here
  // TODO: as soon as we get the error codes propagating back, use those
  let disp_err = "Error during processing";
  if (err.message.includes('Cannot deserialize the contract state')) {
    disp_err = 'Cannot deserialize the contract state';
    console.warn('NEAR Warning: the contract/account seems to have state that is not (or no longer) compatible.\n' +
        'This may require deleting and recreating the NEAR account as shown here:\n' +
        'https://stackoverflow.com/a/60767144/711863');
  }
  if (err.message.includes('Cannot deserialize the contract state')) {
    disp_err = 'Cannot deserialize the contract state';
    console.warn('NEAR Warning: the contract/account seems to have state that is not (or no longer) compatible.\n' +
        'This may require deleting and recreating the NEAR account as shown here:\n' +
        'https://stackoverflow.com/a/60767144/711863');
  }
  if (err.message.includes('The contract is not initialized')) {
    disp_err = 'Contract is not initialized';
    console.warn('NEAR Warning: the contract/accountis not yet initialized.');
  }
   // err_string = JSON.stringify(error_info,null,2);
   //console.log(error_info, err_string)
  console.error(err);
  document.querySelector('#error_status').innerText = "ERROR: " + disp_err;
  document.querySelector('#error_status').style.setProperty('display', 'block')

}

// Variables used tp size the columns of data and headers in display all entries
let col1_size = 4;
let col2_size = 53;
let col3_size = 35;

function formatLogHdr() {
  let spacer = "  "
  let result = "#".padEnd(col1_size)
            + spacer + "Timestamps".padEnd(col2_size," ")
            + spacer + "Account".padEnd(col3_size," ")
            + spacer + "Message\n"

  return(result);
}

function formatLogEntry (entry) {
  let spacer = "  "
  let block_time = new Date(entry.block_ts / 1e6);
  console.log(block_time,typeof(block_time));
  let block_iso = block_time.toISOString();

  let line1 = entry.entry_id.toString().padEnd(col1_size)
             + spacer + ("User: ".padEnd(7) + entry.timestamp).padEnd(col2_size," ")
             + spacer + entry.account.padEnd(col3_size," ")
             + "   " + entry.message+ '\n';

  let line2 = " ".padEnd(col1_size)
              + spacer + ("Block: ".padStart(7) + block_iso + " (" + entry.block_ts.toString() + ")").padEnd(col2_size," ") + '\n';
  /*
  let result = entry.entry_id.toString().padEnd(4)
             + spacer + entry.timestamp.padEnd(25," ")
             + spacer + (block_iso + " (" + entry.block_ts.toString() + ")").padEnd(50," ")
             + spacer + entry.account.padEnd(35," ")
             + "   " + entry.message+ '\n';
  */

  return(line1 + line2);
}

function update_current_info() {

  let cur_count = 0;
  let update_info = "The log is empty";

  mainContract.num_entries().then(count => {
      cur_count = count;
      document.querySelector('#showcount').innerText = cur_count;
      mainContract.get_last().then(last_info => {
            var lastEntry;
            if (cur_count > 0) {
                lastEntry = JSON.parse(last_info);
                update_info =  JSON.stringify(lastEntry,null,2);
            }
            document.querySelector('#cur_info').innerText = update_info;
      }).catch(err => errorHelper(err));
    }).catch(err => errorHelper(err));
}

function updateUI() {

  document.querySelector('#error_status').style.setProperty('display', 'none');

  document.querySelector('#main_contract_id').innerText = nearConfig.contractName;

  let cur_account = nearConnections.mainacct.walletConnection.getAccountId();
  document.querySelector('#cur_login_id').innerText = cur_account;

  update_current_info();

  console.log(cur_account);
  if (!cur_account) {
    document.querySelector('#cur_login_id').innerText = "";
    document.querySelector('#cur_login_text').innerText = "You are not currently logged in.";
    Array.from(document.querySelectorAll('.sign-in-main')).map(it => it.style = 'display: block;');
    Array.from(document.querySelectorAll('.after-sign-in-main')).map(it => it.style = 'display: none;');
  } else {
    document.querySelector('#cur_login_text').innerText = "You current are logged in as "
    document.querySelector('#cur_login_id').innerText = cur_account;
    Array.from(document.querySelectorAll('.sign-in-main')).map(it => it.style = 'display: none;');
    Array.from(document.querySelectorAll('.after-sign-in-main')).map(it => it.style = 'display: block;');

  }
}

function updateSubAccountUI() {
/*
   document.querySelector('#sub_contract_id').innerText = nearConfig.subcontractName;

  let cur_subaccount = window.walletConnection2.getAccountId();
  console.log(walletConnection2)
  document.querySelector('#cur_login_id').innerText = cur_subaccount;

  update_current_info();

  console.log(cur_subaccount);
  if (!cur_subaccount) {
    document.querySelector('#cur_login_id').innerText = "";
    document.querySelector('#cur_login_text').innerText = "You are not currently logged in.";
    Array.from(document.querySelectorAll('.sign-in-subacct')).map(it => it.style = 'display: block;');
    Array.from(document.querySelectorAll('.after-sign-in-subacct')).map(it => it.style = 'display: none;');
  } else {
    document.querySelector('#subacct_login_text').innerText = "You current are logged in as "
    document.querySelector('#subacct_login_id').innerText = cur_subaccount;
    Array.from(document.querySelectorAll('.sign-in-subacct')).map(it => it.style = 'display: none;');
    Array.from(document.querySelectorAll('.after-sign-in-subacct')).map(it => it.style = 'display: block;');

  }

  */
}

// Log in user using NEAR Wallet on "Sign In" button click
document.querySelector('.sign-in-main .btn').addEventListener('click', () => {
  nearConnections.mainacct.walletConnection.requestSignIn(nearConfig.contractName, 'Marvin First Contract Demo');
});

document.querySelector('.sign-out-main .btn').addEventListener('click', () => {
  nearConnections.mainacct.walletConnection.signOut();
  // TODO: Move redirect to .signOut() ^^^
  window.location.replace(window.location.origin + window.location.pathname);
});

document.querySelector('#refresh').addEventListener('click', () => {
  mainContract.num_entries().then(count => {
      console.log("Count is",count);
      console.log(document.querySelector('#showcount').innerText)
      // document.querySelector('#showcount').classList.replace('loader','number');
      document.querySelector('#showcount').innerText = count === undefined ? 'calculating...' : count;
  }).catch(err => errorHelper(err));
});

function append_entry(value, index, array) {

}

document.querySelector('#display_entries').addEventListener('click', () => {
  document.querySelector('#entry_list_hdr').innerText = formatLogHdr(); //"#".padEnd(4) + "   " + "Timestamp".padEnd(25," ") + "   " + "Account".padEnd(35," ")+ "   " + "Message\n";
  mainContract.list_entries().then(listdata => {
      console.log("retrieved", listdata);
      const obj = JSON.parse(listdata);
      console.log("retrieved", obj);
      let finaldata = "";
      obj.log_entries.forEach(element => finaldata += formatLogEntry(element));
      console.log(finaldata)
      console.log(finaldata.length)
      console.log(document.querySelector('#showlistdata').innerText);
       // document.querySelector('#showcount').classList.replace('loader','number');
      document.querySelector('#showlistdata').innerText = finaldata;
  }).catch(err => errorHelper(err));
});

document.querySelector('#hide_entries').addEventListener('click', () => {
    document.querySelector('#entry_list_hdr').innerText = "";
    document.querySelector('#showlistdata').innerText = "";
});

document.querySelector('.log_reset .btn').addEventListener('click', () => {
  mainContract.reset_log({}).then(listdata => {
      console.log("retrieved", listdata);
  }).catch(err => errorHelper(err));

  console.log("CONTRACT IS:", typeof mainContract);
});

document.querySelector('#add-entry').onsubmit = function() {
   // prevent further default processing from occuring (i.e. don't POST the result/refresh page)
   event.preventDefault();

   // process the form data
   add_new_entry(this);

};

function post_add_entry() {
    $("inprocess_modal").modal("hide")
}

function add_new_entry(form_info) {
   const d = new Date();
   console.log("Date type is",typeof(d),d)

   let args = {
       timestamp: d,
       name: form_info.elements['name'].value,
       message: form_info.elements['msg'].value
   }
   $('inprocess_modal').modal('show');
   $("add_status").style = "display:block;";
  document.querySelector('#add_status').style = "display: block;";
  document.querySelector('#add_entry_form').style = "display: none;";
   mainContract.add_entry(args).then(result => {
       console.log("Add Entry",result);
       form_info.reset();
       document.querySelector('#add_status').style = "display: none;";
       document.querySelector('#add_entry_form').style = "display: block;";
   }).then(updateUI).catch(err => errorHelper(err));

}

function logInfo () {
  console.log("logInfo")
  console.log(mainContract, nearConnections['main'], nearConnections);
   console.log("logInfo End");
   mainContract = nearConnections.mainacct.contract;
}

let mainContract = nearConnections.mainacct.contract;
window.nearInitPromise = connect(nearConfig,'mainacct')
    .then(logInfo)
    .then(updateUI)
    .then(updateSubAccountUI)
    .catch(console.error);

console.log("Reloaded...");

'''
'''--- setupdevcfg.sh ---
#!/bin/bash
MAIN_DEV_ACCT_FILE="contracts/explore_near_main/neardev/dev-account"
PROXY_DEV_ACCT_FILE="contracts/explore_near_proxy/neardev/dev-account"
missing_files=()
if  [ ! -f  $MAIN_DEV_ACCT_FILE ]; then 
    missing_files+=($MAIN_DEV_ACCT_FILE)
fi
if [ ! -f $PROXY_DEV_ACCT_FILE ]; then
    missing_files+=($PROXY_DEV_ACCT_FILE)
fi
if [ ${#missing_files[@]} != 0 ]; then
    echo "The following files must exist before configuring environment; please use dev-deploy to generate new dev accounts"
    for file in ${missing_files[@]}
    do
        echo "  \"$file\""
    done
    exit 1
fi
echo "export CONTRACT_NAME=`cat $MAIN_DEV_ACCT_FILE`" > devconfig
echo "export SUBCONTRACT_NAME=`cat $PROXY_DEV_ACCT_FILE`" >> devconfig
echo "exports stored in \"devconfig\" file.  Type \"source devconfig\" to setup environment"

'''
'''--- src/config.js ---
function getConfig (env) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      }
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      }
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
      }
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        masterAccount: 'test.near'
      }
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        masterAccount: 'test.near'
      }
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- src/contract_names.js ---
export const CONTRACT_NAME = process.env.CONTRACT_NAME || 'asdf.test'; /* TODO: change this to your account */
export const SUBCONTRACT_NAME = process.env.SUBCONTRACT_NAME || 'subasdf.test'; /* TODO: change this to your account */

'''
'''--- src/engineering.js ---
function engineeringNotation(number, precision=3) {

    var intUnitMap = {Y:1e24 , Z:1e21, E: 1e18, P:1e15,T:1e12,G:1e9,M:1e6,k:1e3};
    var bigUnitMap = {Y:BigInt(1e24) , Z:BigInt(1e21), E:BigInt(1e18),
    				  P:BigInt(1e15),T:BigInt(1e12),G:BigInt(1e9),
    				  M:BigInt(1e6),k:BigInt(1e3)
    				};
   // var small_unit_map = {y:1e-24, z:1e-21,a: 1e-18,f:1e-15, p:1e12, n:1e9, u:1e6, m:1e3};
    var space = '&thinsp;';

  //  console.log("eng:",number,typeof(number));
   	absnumber = number;
   	let isneg = false;
   	if (number < 0) {
   		absnumber = -number;
   		isneg = true;

   	}

   	var unitMap = intUnitMap;
   	var factor = 1000;
   	var remainder = 0;

   	if (typeof(number) === 'bigint') {
   		unitMap = bigUnitMap;
   		factor = 1000n
   		remainder = 0n;
   	}

   	var base = absnumber
   	var index = 0;
   	var remainder_factor = factor;

//   	console.log(base, number, base > factor);
   	while (base > factor) {
   			index = index +1;
   			oldbase = base;
   			base = base / factor;
   			new_remainder = oldbase - (base * factor);
   			remainder = (new_remainder * remainder_factor ) + remainder;
   			remainder_factor = remainder_factor * factor; 
   	
   	}
   	
   	let string_remainder = remainder.toString().padEnd(precision,"0").substring(0, precision);
   	var prefix = "";
   	if (isneg) {
   		prefix="-"
   	}
   	result = prefix + base + "." + string_remainder;
   	if (index > 0) { 
   		result += " e"+ (index * 3);
   	}
   	

	return (result);
	
}

module.exports = engineeringNotation
'''
'''--- src/errs.txt ---
Info: Document content looks like HTML5
No warnings or errors were found.

About HTML Tidy: https://github.com/htacg/tidy-html5
Bug reports and comments: https://github.com/htacg/tidy-html5/issues
Official mailing list: https://lists.w3.org/Archives/Public/public-htacg/
Latest HTML specification: http://dev.w3.org/html5/spec-author-view/
Validate your HTML documents: http://validator.w3.org/nu/
Lobby your company to join the W3C: http://www.w3.org/Consortium

Do you speak a language other than English, or a different variant of 
English? Consider helping us to localize HTML Tidy. For details please see 
https://github.com/htacg/tidy-html5/blob/master/README/LOCALIZE.md

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
    <title>NEAR smart contract Exploration</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        h1 {
        margin-top: 3em;
        margin-bottom: 1em;
        }
        ul {
            margin-left:  50px;
        }
        .scene {
        height: 350px;
        }
        .number {
        text-align: center;
        margin:auto;
        width: 66%;
        height: 28%;
        font-size:1.5rem;
        }
        .loader,
        .loader:before,
        .loader:after {
        background: #f56f79;
        -webkit-animation: load1 1s infinite ease-in-out;
        animation: load1 1s infinite ease-in-out;
        width: 0.4rem;
        height: 4em;
        }
        .loader {
        color: #f56f79;
        margin: 2px auto;
        font-size: 0.2rem;
        -webkit-transform: translateZ(0);
        -ms-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-animation-delay: -0.16s;
        animation-delay: -0.16s;
        }
        .loader:before,
        .loader:after {
        position: absolute;
        top: 0;
        content: '';
        }
        .loader:before {
        left: -1.5em;
        -webkit-animation-delay: -0.32s;
        animation-delay: -0.32s;
        }
        .loader:after {
        left: 1.5em;
        }
        @-webkit-keyframes load1 {
        0%,
        80%,
        100% {
        box-shadow: 0 0;
        height: 2em;
        }
        40% {
        box-shadow: 0 -2em  ;
        height: 3em;
        }
        }
        @keyframes load1 {
        0%,
        80%,
        100% {
        box-shadow: 0 0;
        height: 2em;
        }
        40% {
        box-shadow: 0 -2em;
        height: 3em;
        }
        }
        .logintext {
        }
        .loginid {
        }
        .entry_row_even {
            border:  1px;
            margin:  1px;
            padding: 1px;
            background-color: azure;
        }
        .entry_row_odd {
            border:  1px;
            margin:  1px;
            padding: 1px;
            background-color: beige;
        }
        .balance {
            margin-left: 8px;
        }
        .indented {
            margin-left: 30px;   
        }
        </style>
</head>

<body style="background: #eef2fe; font-family: 'Arvo', serif;">
    <div class="container">
        <div class="row">
            <h1>An Exploration of NEAR Protocol smart contracts</h1>
            <br>
            <p>This project explores developing and interfacing to smart contracts on the NEAR protocol blockchain.
            The project is comprised of:
                <ul>
                <li>A <span class=fw-bold>Main</span> contract which is responsible for accepting the storing the data</li>
                <li>A <span class=fw-bold>Proxy</span> contract which takes the requestand then forwards it to the Main contract via cross contract calls</li>
                <li>This web page which provides an interface to both contracts</li>
            </ul>
        </p>

        </div>
        <div class="row">
            <p id="error_status" class="text-danger fs-4 fw-bold" style="display: none;"></p>
        </div> 
        <!-- row -->
    </div>
    <!-- row -->
    <div class="row border border-primary" style="padding: 25px;">
        <div id="mainContract" class="col-6 border border-primary" >
            <div class="row">
                <p class="h3">Main Contract </p>
                <p>Deployed on account <span id=main_contract_id class="fs-5 fw-bolder"></span></p>
                <p class="fw-bolder indented">
                    Available Balance: <span id="main_acct_balance" class="balance fw-normal"></span><br>
                    Balance Change: <span id="main_acct_delta" class="balance fw-normal"></span><br>
                    Admin Acct configured: <span id=main_contract_admin class="balance fw-normal"></span><br>
                    <br>
                </p>
                <p>These requests make calls (or views) directly the main contract
                <br>
                
                </pF>
            </div>
            <br>      
            <!-- main login start -->
            <div class="row border-top border-bottom border-primary" style="padding-top: 20px; padding-bottom: 20px;">
                <p>
                    <span id="main_login_text"></span><span class="fs-5 fw-bolder text-info" id="main_login_id"></span>
                    <p class="indented fw-bolder">
                        Available Balance:<span id="main_login_balance" class="balance fw-normal"></span><br>
                        Balance Change:<span id="main_login_delta" class="balance fw-normal"></span></p>
                    <span id="contract_owner_text"></span><span class="fs-5 fw-bolder text-info" id="contract_owner_id"></span>
                </p>
                <div class="sign-in-main" style="display: none;">
                    <div class="row">
                        <div class=col-2>
                            <button class="btn btn-primary" id="sign-in-main-button" style="background-color: #0072CE;">Sign In</button>
                        </div>
                        <div class=col>
                            <p>You'll need to sign in to be able to see and access the contract methods that use the call methods and modify data</p>
                        </div>
                    </div>
                </div>
                <div class="sign-out-main after-sign-in-main">
                    <button class="btn btn-primary" id="sign-out-main-button" style="background-color: #0072CE;">Sign Out</button>
                </div>
            </div>
            <!-- main login end -->
            <div class="row">
                <div class="viewcommands" style="display: block;">
                    <br>
                    <h4>View Commands</h4>
                    <p>Direct calls to a contract to view are currently available without sigining (and current require no gas fees) so can be issued with  having a signing key (and therefore don't require 'sign-in'</p>
                </div>
            </div>
            <div class="row">
                <div class="col flex">
                    <button id="refresh" class="btn btn-primary" style="background-color: #0072CE;">Refresh</button>
                </div>
                <div class="col flex">
                    <p>The section automatically updates when an action on this page initiates a change, but if updates are made (e.g. via near cli) this will force a request to make new and  refresh the information</p>
                </div>
            </div>
            <div class="row get_entry_count">
                <div class="col-5">Number of entries in the log: <span id="showcount"></span></div>
            </div>
            <div class="row">
                <div class="col"><strong>Lastest Entry</strong></div>
            </div>
            <div class="row get_entry_count">
                <div class="col">
                    <pre id="cur_info"></pre>
                </div>
            </div>
            <br>

            <div class="row after-sign-in-main border-primary border-3 border" style="display: none; padding: 25px;">
                <br>
                <h4>Call Commands</h4>
                <p>Methods that modify contract data, transfer funds must use contract call methods and require signing.  Here we use the wallet to 'sign-in' to get signing keys</p>
                <br>
                <div class="row " >
                    <!-- MAIN Add Entry form START -->
                    <div id="add_entry_form " class="border-top border-primary" style="display: block; padding-left: 10px; padding-right: 25px">
                        <form id="main-add-entry-form" name="main-add-entry-form">
                            <br>
                            <div class="row">
                                <div style="display:flex; flex-direction: row">
                                    <label for="Name" class="form-label" style="width: 75px;">Name</label>
                                    <input type="text" class="form-control" id="name" placeholder="Name?" name="name">
                                </div>
                                <div style="display:flex; flex-direction: row">
                                    <label for="Msg" class="form-label" style="width: 75px;">Message</label>
                                    <input type="text" class="form-control" id="Message" placeholder="Message?" name="msg">
                                </div>
                            </div>
                            <div class="row " style="padding-top: 20px; padding-bottom: 20px;">
                                <div class="col-4">
                                    <button type="submit" name="main_add_entry_btn" class="btn btn-primary" style="background-color: #0072CE;">Add Entry</button>
                                </div>
                                <div class="col">
                                    <span class="fs-5">Add an Entry </span>(Adds an entry to the log.)
                                </div>
                            </div>
                        </form>
                    </div>
                    <div class="bg-info text-white">
                        <h4 id="main-add-status" style="display: none">Adding Entry</h4>
                    </div>
      
                    <!-- MAIN ADD ENTRY FORM END -->
                </div>
                <br>
                <!-- RESET START -->
                <div class="border-top border-primary" style="display: block; padding-left:  10px; padding-top: 25px">
                    <div class="row log_reset">
                        <div class="col-4">
                            <button id="main_reset" class="btn btn-primary" style="background-color: #0072CE;">Reset</button>
                        </div>
                        <div class="col"><span class="fs-5"> Clear the log </span>(Reset the log and remove all entries)
                        </div>
                    </div>
                    <div class="row log_reset">
                        <div class="col-4">
                        </div>
                        <div class="col"><span id=reset_error class="text-danger"></span>
                        </div>    
                </div>
                <!-- RESET END -->
                <br>
            </div>
        </div>
    </div>
        <!---  START OF SUB ACCOUNT CONTRACT I/F -->
        <div id="sub_contract" class="col-6 border border-primary">
            <div class="row">
                <p class="h3">Proxy Contract</p>
                <p>Deployed on account <span id=sub_contract_id class="fs-5 fw-bolder"></span></p>
                <p class="indented fw-bolder">
                    Available Balance: <span id="sub_acct_balance" class="fw-normal balance"></span><br>
                    Balance Change: <span id="sub_acct_delta" class="fw-normal balance"></span><br>
                    Contract to log to: <span id="sub_acct_log_contract" class="fw-normal balance"></span><br>
                    Admin Account: <span id="sub_acct_admin" class="fw-normal balance"></span>
                </p>
                <p>These requests use contract methods on the Proxy Contract which then initiates Cross Contract calls to the main contract. data is returned via callbacks, use gas and require signing and therefore require sign-in via the wallet to get a signing key</p>
            </div>
            <!-- subacct login start -->
            <div class="row border-top border-bottom border-primary" style="padding-top: 20px; padding-bottom: 20px;">
                <p>
                    <span id="subacct_login_text"></span><span class="fs-5 fw-bolder text-info" id="subacct_login_id"></span>
                    <p class="indented fw-bolder">
                        Available Balance:<span id="sub_login_balance" class="balance fw-normal"></span><br>
                        Balance Change:<span id="sub_login_delta" class="balance fw-normal"></span>
                    </p>
                    <span id="subacct_owner_text"></span><span class="fs-5 fw-bolder text-info" id="subacct_owner_id"></span>
                </p>
                <div class="sign-in-subacct" style="display: none;">
                    <div class="row">
                        <div class=col-2>
                            <button class="btn btn-primary" id="sign-in-subacct-button"style="background-color: #0072CE;">Sign In</button>
                        </div>
                        <div class=col>
                            <p>You'll need to sign in to be able to see and access the contract methods that use the call methods and modify data</p>
                        </div>
                    </div>
                </div>
                <div class="sign-out-subacct after-sign-in-subacct">
                    <button class="btn btn-primary" id="sign-out-subacct-button" style="background-color: #0072CE;">Sign Out</button>
                </div>
            </div>
            <!-- subacct login end -->
            <div class="after-sign-in-subacct" style="display: none; padding: 25px;">
            
                <div class="row">

                    <!-- SUBACCT ADD ENTRY START -->
                    <div id="subacct_add_entry_form" style="display: block; padding-left: 10px; padding-right: 25px">
                        <form id="subacct-add-entry-form" name="subacct-add-entry-form">
                            <br>
                            <div class="row">
                                <p><span class="fs-5">Add an Entry </span>(Adds an entry to the log.)</p>
                            </div>
                            <div class="row">
                                <div style="display:flex; flex-direction: row">
                                    <label for="Name" class="form-label" style="width: 75px;">Name</label>
                                    <input type="text" class="form-control" id="name" placeholder="Name?" name="name">
                                </div>
                                <div style="display:flex; flex-direction: row">
                                    <label for="Msg" class="form-label" style="width: 75px;">Message</label>
                                    <input type="text" class="form-control" id="Message" placeholder="Message?" name="msg">
                                </div>
                            </div>
                            <div class=row style="padding-top: 20px; padding-bottom: 20px;">
                                <div class="col-2">
                                    <button type="submit" class="btn btn-primary" style="background-color: #0072CE;">Add Entry</button>
                                </div>
                                <div class="col-2">
                                    <label for="Tip" class="form-label" style="width: 100px;">Transfer Amount</label>
                                </div>
                                <div class="col-3">
                                    <input type="text" class="form-control" id="amount" placeholder="0" name="amount">
                                    <span id="transfer_errmsg" class="fs-6 text-danger" style="display: none">Invalid Entry</span>
                                </div>
                                <div class="col-5">
                                    <select id="denomination" class="form-select fs-6" autocomplete="off" aria-label="Tip range">
                                        <option value="yacto" selected>Million YactoNEAR</option>
                                        <option value="near"> NEAR</option>
                                    </select>
                                </div>  
                            </div>
                        </form>
                    </div>
                    <div class="bg-info text-white">
                        <h4 id="subacct-add-status" style="display: none">Adding Entry</h4>
                    </div>
                </div>
                <!-- SUBACCDT ADD ENTRY END -->
            </div>
        </div>
        <!---  END OF SUB ACCOUNT CONTRACT I/F -->
        <div class="row" style="padding: 25px">
            <!-- row -->
            <div class=row>
                <br>
                <!-- row -->
                <div class="row get_entry_list">
                    <div class="col-2">
                        <button id='display_entries' class="btn btn-primary" style="background-color: #0072CE;">Display Entries</button>
                    </div>
                    <div class="col-2">
                        <button id='hide_entries' class="btn btn-primary" style="background-color: #0072CE;">HideEntries</button>
                    </div>
                </div>
                <!-- row -->
                <div class="row">
                    <p></p>
                    <strong>
                        <pre id="entry_list_hdr"></pre></strong>
                </div>
                <div class="row get_entry_list">
                    <div id="showlistdata"></div>
                </div>
            </div>
        </div>
    </div>
</body>
<script src="./main.js"></script>

</html>

'''
'''--- src/loader.html ---
<head>
    <script>
        window.paceOptions = {
            elements: {
                selectors: ['.never-appears']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/gh/HubSpot/pace@v0.5.3/pace.min.js"></script>
    <link href="https://cdn.jsdelivr.net/gh/HubSpot/pace@v0.5.3/themes/black/pace-theme-center-radar.css" rel="stylesheet" />
</head>
'''
'''--- src/main.js ---
import "regenerator-runtime/runtime";
import * as nearAPI from "near-api-js";
// const { utils } = require("near-api-js");
import getConfig from "./config";
import storedLog from "./storedLog"
import engineeringNotation from "./engineering"
import {CONTRACT_NAME, SUBCONTRACT_NAME}  from "./contract_names"
import Big from 'big.js';
const nearMainConfig = getConfig(process.env.NODE_ENV || "development");
import getSubAcctConfig from "./subacct_config";
const  nearSubAcctConfig = getSubAcctConfig(process.env.NODE_ENV || "development");

var main_contract;
var proxy_contract;

const BOATLOAD_OF_GAS = Big(3).times(10 ** 13).toFixed();
const TOKEN_AMOUNT = Big(1).times(10**24).toFixed();

  
// keep track of the last N URLs that the page was loaded by 
// (for deubgging interaction and transistion from the the wallet)
// if this is redirected from the wallet it will include the account and addition information
 let incomingURL = new URL(window.location.href);
 storedLog(JSON.stringify(incomingURL),"urls");

// Define Object to hold separate connnections and wallets to allow multiple signin accounts
//  However it seems that the local storage for the web page only seems to support once
// account logged in at time...
window.nearConnections = {
    mainacct: { near: null,
                login_account: null,
                contract_name: null,
                contract_account: null,
                walletConnection: null,
                contract: null,
                viewMethods: ['num_entries', 'list_entries', 'get_last', 'info', 'get_info'],
                changeMethods: ['new', 'add_entry', 'reset_log', ],
              },
    subacct:  { near: null,
                login_account: null,
                contract_name: null,
                contract_account: null,
                walletConnection: null,
                contract: null,
                viewMethods: ['indirect_num_entries', 'indirect_get_last', 'info'],
                changeMethods: ['new', 'indirect_add_entry', 'reset_log' ],
              },
}

const localStorage_log_config = {
    maxlen : 50
}

async function getKeyStore(account) {
    let x = await new nearAPI.keyStores.BrowserLocalStorageKeyStore(window.localStorage,account); 
    // console.log(x); 
    return(x);

}

// Copied from rust-counter
async function connect(nearConfig, account, contractName) {
    let connection = window.nearConnections[account];

    // Connects to NEAR and provides `near`, `walletAccount` and `contract` objects in `window` scope
    // Initializing connection to the NEAR node.
    connection.near = await nearAPI.connect({
        deps: {
            keyStore: await getKeyStore(account)
        },
        ...nearConfig
    });
    const currentUrl = new URL(window.location.href);

    // Needed to access wallet loginf
    connection.walletConnection = await new nearAPI.WalletConnection(connection.near, account);

    // Initializing our contract APIs by contract name and configuration.
    connection.contract = await new nearAPI.Contract(connection.walletConnection.account(), contractName, {
        // View methods are read-only – they don't modify the state, but usually return some value
        viewMethods: connection.viewMethods,
        // Change methods can modify the state, but you don't receive the returned value when called
        changeMethods: connection.changeMethods,
        // Sender is the account ID to initialize transactions.
        // getAccountId() will return empty string if user is still unauthorized
        sender: connection.walletConnection.getAccountId()
    });

    connection.login_account = await connection.near.account(connection.walletConnection.getAccountId());
    connection.contract_name = contractName;
    connection.contract_account = await connection.near.account(contractName);
}

function processJSONErrObject(errObject) {

//    console.log("Processing Object")
    var retval = "Error during processing";

    if ('kind' in errObject && 'ExecutionError' in errObject.kind) {
       if (errObject.kind.ExecutionError.includes('Only contract or admin can reset')) {
            console.error("Reset Authorization Error");
            document.querySelector('#reset_error').innerText = "Sorry. Only the admin is allowed to reset the log";
            document.querySelector('#reset_error').style.setProperty('display', 'block');  
            retval = false;
        }
        else {
            retval += " : " + errObject;
        }
    }
    return retval;
}

function processStringErrMessage(message) {

  //  console.log("Processing Message")
    let disp_err = "Error during processing";

    if (message.includes('Cannot deserialize the contract state')) {
        disp_err = 'Cannot deserialize the contract state';
        console.warn('NEAR Warning: the contract/account seems to have state that is not (or no longer) compatible.\n' +
            'This may require deleting and recreating the NEAR account as shown here:\n' +
            'https://stackoverflow.com/a/60767144/711863');
    }
    if (message.includes('Cannot deserialize the contract state')) {
        disp_err = 'Cannot deserialize the contract state';
        console.warn('NEAR Warning: the contract/account seems to have state that is not (or no longer) compatible.\n' +
            'This may require deleting and recreating the NEAR account as shown here:\n' +
            'https://stackoverflow.com/a/60767144/711863');
    }
    if (message.includes('The contract is not initialized')) {
        disp_err = 'Contract is not initialized';
        console.warn('NEAR Warning: the contract/accountis not yet initialized.');
    }

    return disp_err
}

function errorHelper(err) {
    /* if there's a cryptic error, provide more helpful feedback and instructions here
     * as soon as we get the error codes propagating back, use those
    */
    console.log("ERROR INFO",err.message,"TYPE:",typeof(err.message));

    var disp_err;
    var isObject = false;
    var err_detail;

    try {
        err_detail = JSON.parse(err.message);
 
        if (err_detail && typeof(err_detail) === "object") {
            isObject = true;
        }
        console.log("ERR DETAIL:",err_detail,isObject)
    }
    catch (e) {};

    if (isObject) {
         disp_err = processJSONErrObject(err_detail);
    }
    else {
        disp_err = processStringErrMessage(err.message);
    }

   if (disp_err) {
       document.querySelector('#error_status').innerText = "ERROR: " + disp_err;
       document.querySelector('#error_status').style.setProperty('display', 'block');
   }
}

// Variables used tp size the columns of data and headers in display all entries
let col1_size = 4;
let col2_size = 55;
let col3_size = 35;
let col4_size = 5;
let col5_size = 25;
let col6_size = 15;

function formatLogHdr() {
    let spacer = "  "
    let result = "#".padEnd(col1_size)
        + spacer + "Timestamps".padEnd(col2_size, " ")
        + spacer + "Account".padEnd(col3_size, " ")
        + spacer + "CC".padEnd(col4_size)
        + spacer + "Gas used".padEnd(col5_size)
        + spacer + "Name".padEnd(col6_size)
        + spacer + "Message\n"

    return (result);
}

function formatLogEntry(entry) {
    let spacer = "  "
    let block_time = new Date(entry.block_ts / 1e6);
    let block_iso = block_time.toISOString();
    let is_cross_contract = "No".padEnd(col4_size)

    let sign_account_info = "";
    if (entry.signaccount != entry.account) {
        sign_account_info = "(signed by: " + entry.signaccount + ")";
        is_cross_contract = "Yes".padEnd(col4_size);
    }

    var rowtype = "entry_row_odd";
    if (entry.entry_id % 2 == 0) {
        rowtype = "entry_row_even"
    }

    let formatStart = '<div class="'+ rowtype +'"><pre>'
    let line1 = entry.entry_id.toString().padEnd(col1_size)
      + spacer + ("User: ".padEnd(7) + entry.timestamp).padEnd(col2_size, " ")
      + spacer + entry.account.padEnd(col3_size, " ")
      + spacer + is_cross_contract
      + spacer + ("Main: ".padEnd(7) + entry.used_gas).padEnd(col5_size)
      + spacer + entry.name.padEnd(col6_size)
      + spacer + entry.message
      + '\n';

    let line2 = " ".padEnd(col1_size)
        + spacer + ("Block: ".padStart(7) + block_iso
        + spacer + " (" + entry.block_ts.toString()+ ")").padEnd(col2_size, " ")
        + spacer +  sign_account_info.padEnd(col3_size," ")
        + spacer + "".padEnd(col4_size)
        + spacer + ("CC: ".padEnd(7) + entry.cc_used_gas).padEnd(col5_size);
    let formatEnd = '</pre></div>';

    return (formatStart + line1 + line2 + formatEnd);
}

// query the contract to get current info about admin, number of entries and last entry
async function update_current_info(account) {

    let cur_count = 0;
    let update_info = "The log is empty";

    try {
        let main_info = JSON.parse(await main_contract.info({"args" : {}}));
        document.querySelector('#main_contract_admin').innerText = main_info.admin;

        cur_count = await main_contract.num_entries();
        document.querySelector('#showcount').innerText = cur_count;

        if (cur_count > 0) {
            let lastEntry = JSON.parse(await main_contract.get_last());
            update_info = JSON.stringify(lastEntry, null, 2);
        }
        document.querySelector('#cur_info').innerText = update_info;

        let sub_info = JSON.parse(await proxy_contract.info({"args" : {}}));
        document.querySelector('#sub_acct_admin').innerText = sub_info.admin;
        document.querySelector('#sub_acct_log_contract').innerText = sub_info.log_contract;

   } catch (e) {
       errorHelper(e);
   }

}

 // keep storage for current balances
 var curBalances = {
        main_login_balance: { "available" : 0 },
        sub_login_balance:  { "available" : 0 },
        main_acct_balance:  { "available" : 0 },
        sub_acct_balance:   { "available" : 0 },
 };

function updatePrevBalances () {
    /*  NOT CURRENTLY USED
     * This was to keep the copy, but since the page reloads wheen interface with the wallet
     * the variables get reset -- need to move this data to cookies?
     */
    let prevBalanceData = JSON.stringify(curBalances);
    localStorage.prevBalances = prevBalanceData;
    storedLog(curBalances,"balances")
};

function updateLogins() {

};

async function updateCurBalances() {

    curBalances.main_acct_balance = await nearConnections.mainacct.contract_account.getAccountBalance();
    curBalances.sub_acct_balance = await nearConnections.subacct.contract_account.getAccountBalance();

    // retreive last saved prev Balances from 
    let prevBalancesData = localStorage.prevBalances;
    var prevBalances = curBalances 

    if (prevBalancesData != null) {
        prevBalances = JSON.parse(prevBalancesData);
    }

    let is_main_loggedin = false;
    let is_proxy_loggedin = false;
    if (nearConnections.mainacct.walletConnection.isSignedIn()) {
        curBalances.main_login_balance = await nearConnections.mainacct.login_account.getAccountBalance();
        is_main_loggedin = true;

    }

    if (nearConnections.subacct.walletConnection.isSignedIn()) {
        curBalances.sub_login_balance = await  nearConnections.subacct.login_account.getAccountBalance();
        is_proxy_loggedin = true;
    }

    /*
    console.log("BAL: ",typeof curBalances.main_acct_balance.available, curBalances.main_acct_balance.available);
    console.log("BAL: ",typeof prevBalances.main_acct_balance.available, prevBalances.main_acct_balance.available);
    console.log("BAL: ",typeof curBalances.main_login_balance.available, curBalances.main_login_balance.available);
    console.log("BAL: ",typeof prevBalances.main_login_balance.available, prevBalances.main_login_balance.available)
    */

    let delta = {
        main_acct  : BigInt(curBalances.main_acct_balance.available)  - BigInt(prevBalances.main_acct_balance.available),
        sub_acct   : BigInt(curBalances.sub_acct_balance.available)  - BigInt(prevBalances.sub_acct_balance.available),
        main_login : BigInt(curBalances.main_login_balance.available) - BigInt(prevBalances.main_login_balance.available),
        sub_login  : BigInt(curBalances.sub_login_balance.available)  - BigInt(prevBalances.sub_login_balance.available),

    }

    document.querySelector('#main_acct_balance').innerText = curBalances.main_acct_balance.available;
    document.querySelector('#main_acct_delta').innerText = engineeringNotation(delta.main_acct,9);

    document.querySelector('#sub_acct_balance').innerText = curBalances.sub_acct_balance.available ;
    document.querySelector('#sub_acct_delta').innerText = engineeringNotation(delta.sub_acct,9) ;

9

    if (is_main_loggedin) {
           document.querySelector('#main_login_balance').innerText = curBalances.main_login_balance.available;
           document.querySelector('#main_login_delta').innerText =  engineeringNotation(delta.main_login);

    } else {
            document.querySelector('#main_login_balance').innerText = "---";
            document.querySelector('#main_login_delta').innerText =   "---";
    }

    if (is_proxy_loggedin) {
            document.querySelector('#sub_login_balance').innerText =  curBalances.sub_login_balance.available;
            document.querySelector('#sub_login_delta').innerText =    engineeringNotation(delta.sub_login);
    } else {
            document.querySelector('#sub_login_balance').innerText =  "---";
            document.querySelector('#sub_login_delta').innerText =  "---";
    }
            
};

async function updateUI() {

    document.querySelector('#error_status').style.setProperty('display', 'none');   
    document.querySelector('#reset_error').style.setProperty('display', 'none');  

    document.querySelector('#main_contract_id').innerText =
    nearConnections.mainacct.contract_name;
    document.querySelector('#sub_contract_id').innerText =
    nearConnections.subacct.contract_name;

    let cur_account = nearConnections.mainacct.walletConnection.getAccountId();
    document.querySelector('#main_login_id').innerText = cur_account;

    let cur_subaccount = nearConnections.subacct.walletConnection.getAccountId();

    await  updateCurBalances();

    await update_current_info();

    if (!cur_account) {
        document.querySelector('#main_login_id').innerText = "";
        document.querySelector('#main_login_text').innerText = "You are not currently logged in.";
        Array.from(document.querySelectorAll('.sign-in-main')).map(it => it.style = 'display: block;');
        Array.from(document.querySelectorAll('.after-sign-in-main')).map(it => it.style = 'display: none;');
        Array.from(document.querySelectorAll('.sign-in-subacct')).map(it => it.style = 'display: block;');
        Array.from(document.querySelectorAll('.after-sign-in-subacct')).map(it => it.style = 'display: none;');
    } else {
        document.querySelector('#main_login_text').innerText = "You current are logged in as ";
        document.querySelector('#main_login_id').innerText = cur_account;
        Array.from(document.querySelectorAll('.sign-in-main')).map(it => it.style = 'display: none;');
        Array.from(document.querySelectorAll('.after-sign-in-main')).map(it => it.style = 'display: block;');
        Array.from(document.querySelectorAll('.sign-in-subacct')).map(it => it.style = 'display: none;');
        Array.from(document.querySelectorAll('.after-sign-in-subacct')).map(it => it.style = 'display: block;');
     

    }

     if (!cur_subaccount) {
        document.querySelector('#subacct_login_id').innerText = "";
        document.querySelector('#subacct_login_text').innerText = "You are not currently logged in.";
        Array.from(document.querySelectorAll('.sign-in-subacct')).map(it => it.style = 'display: block;');
        Array.from(document.querySelectorAll('.after-sign-in-subacct')).map(it => it.style = 'display: none;');
        
    } else {
        document.querySelector('#subacct_login_text').innerText = "You current are logged in as "
        document.querySelector('#subacct_login_id').innerText = cur_subaccount;
        Array.from(document.querySelectorAll('.sign-in-subacct')).map(it => it.style = 'display: none;');
        Array.from(document.querySelectorAll('.after-sign-in-subacct')).map(it => it.style = 'display: block;');
        

    }

}

// Log in user using NEAR Wallet on "Sign In" button click
document.querySelector('#sign-in-main-button').addEventListener('click', () => {
    nearConnections.mainacct.walletConnection.requestSignIn(
        { "contractId": nearConnections.mainacct.contract_name,
          "successUrl": window.location.origin + '/mainacct' }
    );
});

document.querySelector('#sign-out-main-button').addEventListener('click', () => {
    nearConnections.mainacct.walletConnection.signOut();
     window.location.replace(window.location.origin + window.location.pathname);
});

// Log in user using NEAR Wallet on "Sign In" button click
document.querySelector('#sign-in-subacct-button').addEventListener('click', () => {
    nearConnections.subacct.walletConnection.requestSignIn(
            { "contractId": nearConnections.subacct.contract_name,
              "successUrl": window.location.origin + '/subacct' }
    );
});

document.querySelector('#sign-out-subacct-button').addEventListener('click', () => {
    nearConnections.subacct.walletConnection.signOut();
    window.location.replace(window.location.origin + window.location.pathname);
});

document.querySelector('#refresh').addEventListener('click', () => {
    main_contract.num_entries().then(count => {
        //console.log("Count is", count);
        //console.log(document.querySelector('#showcount').innerText)
        // document.querySelector('#showcount').classList.replace('loader','number');
        document.querySelector('#showcount').innerText = count === undefined ? 'calculating...' : count;
        updatePrevBalances();
    }).then(updateUI)
    .catch(err => errorHelper(err));
});

function append_entry(value, index, array) {

}

document.querySelector('#display_entries').addEventListener('click', () => {
    document.querySelector('#entry_list_hdr').innerText = formatLogHdr(); //"#".padEnd(4) + "   " + "Timestamp".padEnd(25," ") + "   " + "Account".padEnd(35," ")+ "   " + "Message\n";
    main_contract.list_entries().then(listdata => {
        //console.log("retrieved", listdata);
        const obj = JSON.parse(listdata);
        //console.log("retrieved", obj);
        let finaldata = "";
        // obj.log_entries.forEach(element => document.querySelector('#showlistdata').appendChild(formatLogEntry(element));
        obj.log_entries.forEach(element => finaldata += formatLogEntry(element));
        //console.log(finaldata)
        //console.log(finaldata.length)
        //console.log(document.querySelector('#showlistdata').innerText);
        // document.querySelector('#showcount').classList.replace('loader','number');
         document.querySelector('#showlistdata').innerHTML = finaldata;
    }).catch(err => errorHelper(err));
});

document.querySelector('#hide_entries').addEventListener('click', () => {
    document.querySelector('#entry_list_hdr').innerText = "";
    document.querySelector('#showlistdata').innerText = "";
});

document.querySelector('#main_reset').addEventListener('click', () => {
    main_contract.reset_log({})
      .then(listdata => {
          console.log("retrieved", listdata);
      })
      .then(updateUI)
      .catch(err => errorHelper(err));
      updatePrevBalances();
});

document.querySelector('#main-add-entry-form').onsubmit = function() {
    // prevent further default processing from occuring (i.e. don't POST the result/refresh page)
    event.preventDefault();

    // process the form data
    add_new_entry(this, main_contract);

};

document.querySelector('#subacct-add-entry-form').onsubmit = function() {
    // prevent further default processing from occuring (i.e. don't POST the result/refresh page)
    event.preventDefault();

    // process the form data
    indirect_add_new_entry(this,1);

};

/*
function post_add_entry() {
    $("inprocess_modal").modal("hide")
}
*/

function add_new_entry(form_info,contract) {
    const d = new Date();
    console.log("Date type is", typeof(d), d)
    console.log("Log Start Add Entry Main")
    console.log("Form info type: ",typeof(form_info))
    console.log(form_info)
    console.log("Logging Starting new Add Entry Main")

    let args = {
        timestamp: d,
        name: form_info.elements['name'].value,
        message: form_info.elements['msg'].value,
        cc_used_gas: "0",
    }
  //  $('inprocess_modal').modal('show');
    $("main-add_status").style = "display:block;";
    document.querySelector('#main-add-status').style = "display: block;";
    document.querySelector('#main-add-entry-form').style = "display: none;";
        main_contract.add_entry(args,BOATLOAD_OF_GAS,0).then(result => {
        console.log("RESULT: ",result);
        form_info.reset();
        document.querySelector('#main-add-status').style = "display: none;";
        document.querySelector('#main-add-entry-form').style = "display: block;";
    }).then(updateUI).catch(err => errorHelper(err));

    updatePrevBalances();
}

function indirect_add_new_entry(form_info) {
    const d = new Date();
    console.log("Starting new Indirect Add Entry Main")

    var amount_str = "0";
    var transfer_amount = Big(0);

    // remove any commas or _ from input string
    if (form_info['amount'].value)  {
        amount_str = (form_info['amount'].value).replace(/,|_/g,"");
    }

    document.querySelector('#transfer_errmsg').style = "display:none";
    try {
        transfer_amount = Big(amount_str);
    } catch (error) {
        console.error("Bad transfer amount", amount_str);
        document.querySelector('#transfer_errmsg').style = "display:block";
        return(false)
    }

    var nearamt;
    if (form_info.elements['denomination'].value == "near") {
        nearamt = transfer_amount.times(10**24).toFixed();
    } else {
        nearamt = transfer_amount.times(10**6).toFixed();
    }

    let args = {
        timestamp: d,
        name: form_info.elements['name'].value,
        message: form_info.elements['msg'].value,
        transfer_amount: nearamt,
    };

    $("add_status").style = "display:block;";
    document.querySelector('#subacct-add-status').style = "display: block;";
    document.querySelector('#subacct-add-entry-form').style = "display: none;";

    proxy_contract.indirect_add_entry(args, BOATLOAD_OF_GAS, nearamt)
        .then(result => {
            form_info.reset();
            document.querySelector('#subacct-add-status').style = "display: none;";
            document.querySelector('#subacct-add-entry-form').style = "display: block;";
    }).then(updateUI).catch(err => errorHelper(err));

    updatePrevBalances();
}

async function setupConnections() {

  // Save a copy of the incoming URL  --

  //create a URL which is referring to the base page
  // note that is currently assumed to be the the root of the server (e.g. localhost:1234/)
  // (if this were to be deployed at some other offset additional parsing will be needed to
  //  add in the part of the pathname which is considered the root)
  let noParameterURL = new URL(window.location.origin);

  // Initializing the wallet connection analyzes the current URL
  // and if it sees an account ID it then assumes we're logging in
  // so setups up the local storage with the key.
  //
  // In our case, we have two possible logins and we want to control
  // which one is logged in.    This is handled by specifying
  // different URLs   (baseURL/mainacct or baseURL/subacct) for the
  ///'callback' from the NEAR wallet
  // From there the code saves a copy the original incoming URL
  // and also creates a new URL with just the root path of the page
  //
  // Somewhere, after the wallet processing (though I haven't found it) the
  // windows.local.href is updated to remove the addigional informatoin (acccountId/keys, etc)
  // so what is done below, we set the window.location to be the base root of the page
  // initialize the connection for the acct that IS NOT being logged in first
  // then restore the original URL and setup the connection for the one that is being logged in

  // check if this is call back from the wallet for the main account
  if (incomingURL.pathname == "/mainacct") {
      // if so setup the connection without any information from the wallete call back
      window.history.replaceState({}, document.title,  noParameterURL.toString());
      await connect(nearSubAcctConfig,'subacct',SUBCONTRACT_NAME);
      // restore the original URL with the account name and keys, then setup
      // the connection for the main account
      window.history.replaceState({}, document.title, incomingURL.toString());
      await connect(nearMainConfig,'mainacct',CONTRACT_NAME);
  } else {
    // not processing a call back for the main account, so this is either
    // a callback for the subacct OR its not callback at all.
    // Either way the code will process the mainacct first, with no parameters from the wallet
    // and then process the subacct with the original URL (which may or may not  have
    // and account/keys  -- depending on how we got her)
    window.history.replaceState({}, document.title,  noParameterURL.toString());
    await connect(nearMainConfig, 'mainacct',CONTRACT_NAME);

    window.history.replaceState({}, document.title, incomingURL.toString());
    await connect(nearSubAcctConfig,'subacct',SUBCONTRACT_NAME);
  }
  // restore the URL to main page URL removing the path addded by the wallet callback
  window.history.replaceState({}, document.title,  noParameterURL.toString());

  // update global shortcuts for contracts
  main_contract = nearConnections.mainacct.contract;
  proxy_contract = nearConnections.subacct.contract;

}

window.nearInitPromise = setupConnections()
    .then(updateUI)
    .catch(console.error);
console.log("Reloaded...", new Date());

'''
'''--- src/storedLog.js ---

const localStorage_log_config = {
    maxlen : 100
}

function storedLog(value, prefix = null) {
   

    let storage_key = "storageLog";
    if (prefix != null && typeof prefix === 'string') {
        storage_key = prefix + "_" + storage_key;

    }
    var mydata = window.localStorage.getItem(storage_key);
    
    //var mydata = localStorage[storage_key];
    var mylog;
    if (mydata == null) {
        
            mylog = [];
    }
    else {
        
        let newdata = localStorage[storage_key];
         mylog = JSON.parse(mydata);
    }
    const entry = {
        ts : new Date(),
        data : value
   }

   
   // add an entry at the end
   mylog.push(entry)

    // if length has reached the max, then remove the oldest entry
    if (mylog.length > localStorage_log_config.maxlen) {
        mylog.shift();
   }
   
   
   mydata = JSON.stringify(mylog)
   
   localStorage[storage_key] = mydata;

}

module.exports = storedLog

'''
'''--- src/subacct_config.js ---
function getSubAcctConfig (env) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      }
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      }
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
    }
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        masterAccount: 'test.near'
      }
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        masterAccount: 'test.near'
      }
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getSubAcctConfig

'''
'''--- src/test.js ---
describe('Token', function () {
  let near;
  let contract;
  let subcontract;
  let accountId;
  let main_init = false;
  let sub_init = false;

  beforeAll(async function () {
    debugger;
    near = await nearlib.connect(nearConfig);
    admin_user = "admin";

    // base configuration with view and changes methods for the main contract

    var mainContractConfig = {
      viewMethods: ['num_entries', 'info'],
      changeMethods: ['new','add_entry', 'reset_log', 'get_last'],
      sender: testAccounts.main_contract
    };

    var subContractConfig = {
      viewMethods: [],
      changeMethods: ['new', 'indirect_num_entries','indirect_add_entry', 'info'],
      sender: testAccounts.sub_contract
    }

  
    contract = await near.loadContract(testAccounts.main_contract, mainContractConfig);
    subcontract = await near.loadContract(testAccounts.sub_contract, subContractConfig);
   
    var user1Config = Object.assign(mainContractConfig,{sender : testAccounts.user1_acct})
    test1sub =  await near.loadContract(testAccounts.sub_contract, user1Config);

  });

  describe('init', function () {

	var counter;
	var startCounter;

//    console.log("Starting subcontract jest test")
    it('main contract can be initialized', async function() {
      await contract.new({"args" : {"admin" : admin_user }});
      const info_json = await contract.info({"args" : {}});
      const info = JSON.parse(info_json);
      expect(info.admin).toEqual("admin");
      const counter = await contract.num_entries({"args": {}});
      expect(counter).toEqual(0);
    });

    it('subcontract can be initialized', async function() {
      await subcontract.new({"args" : {"log_contract" : testAccounts.main_contract, 'admin' : admin_user}});
      const info = await subcontract.info({"args" : {}});
      expect.stringMatching(".*log_contract.*")
    },10000);
    it('subcontract can be read count', async function() {
      const counter = await subcontract.indirect_num_entries({"args" : {}});
      expect(counter).toEqual(0)
    },10000);

    it('count can be accessed', async function() {
      startCounter = await contract.num_entries({"args": {}});
      expect(startCounter).toEqual(0);
    });
    it('main contract can add entries', async function () {
      await contract.add_entry({"args" : { "timestamp" : "Time1","name" : "My Name","message": "My Message", "cc_used_gas": "0"}});
      counter = await contract.num_entries({"args": {}});
      expect(counter).toEqual(startCounter + 1);
    });
    it('sub account config is can be read', async function() {
      const cfg_contract = JSON.parse(await subcontract.info({"args" : {}} ));
      expect(cfg_contract.log_contract).toEqual(testAccounts.main_contract);
      expect(cfg_contract.admin).toEqual(admin_user);
    });
    it('sub contract can add entries', async function () {
      const startCounter = await contract.num_entries({"args": {}});
     
      await subcontract.indirect_add_entry({"args" : { "timestamp" : "Time2","name" : "Joe","message": "Cool" }});
     
      const endCounter = await subcontract.indirect_num_entries({"args": {}});
     
      expect(endCounter).toEqual(startCounter + 1);
    },15000);
    it('get last data is valid', async function () {
      await subcontract.indirect_add_entry({"args" : { "timestamp" : "Time3","name" : "Luke","message": "Your father" }});
      var last_data = await contract.get_last({"args": {}});
      var last_entry = JSON.parse(last_data);
	  expect(last_entry.name).toEqual("Luke");
	  expect(last_entry.message).toEqual("Your father");

      await contract.add_entry({"args" : { "timestamp" : "Time1","name" : "R2D2","message": "Beep, boop","cc_used_gas": "0"}});
      last_data = await contract.get_last({"args": {}});
      last_entry = JSON.parse(last_data);
	  expect(last_entry.name).toEqual("R2D2");
	  expect(last_entry.message).toEqual("Beep, boop");
    },12000);
    it('can be reset', async function () {
      await contract.reset_log({"args": {}});
      const endCounter = await contract.num_entries({"args": {}});
      expect(endCounter).toEqual(0);
    });
  });
});

'''
'''--- src/test_environment.js ---
const NodeEnvironment = require('jest-environment-node');
const nearAPI = require('near-api-js');
const fs = require('fs');

const { PROJECT_KEY_DIR } = require('near-cli/middleware/key-store');

const INITIAL_BALANCE = '500000000000000000000000000';
const testAccountName = 'test.near';

class LocalTestEnvironment extends NodeEnvironment {
    constructor(config) {
        super(config);
    }

    async setupContract(config,wasmFile='./out/main.asm', id="") {

         const now = Date.now();

        // create random number with at least 7 digits
        const randomNumber = Math.floor(Math.random() * (9999999 - 1000000) + 1000000);
        if (id != "") {
            id = id + "-";
        }
        config = Object.assign(config, {
            // a_contractName: 'test-account-' + id + now + '-' + randomNumber,
            accountId: 'test-account-' + id + now + '-' + randomNumber
        });
        
        delete config.contractName;
        

        const keyStore = new nearAPI.keyStores.UnencryptedFileSystemKeyStore(PROJECT_KEY_DIR);
        config.deps = Object.assign(config.deps || {}, {
            storage:  this.createFakeStorage(),
            keyStore,
        });
        const near = await nearAPI.connect(config);

        const masterAccount = await near.account(testAccountName);
        const randomKey = await nearAPI.KeyPair.fromRandom('ed25519');
        const data = [...fs.readFileSync(wasmFile)];
        await config.deps.keyStore.setKey(config.networkId, config.accountId, randomKey);
        await masterAccount.createAndDeployContract(config.accountId, randomKey.getPublicKey(), data, INITIAL_BALANCE);

        return(config.accountId);
    }

    async setupAccount(config,id) {

        const now = Date.now();

        // create random number with at least 7 digits
        const randomNumber = Math.floor(Math.random() * (9999999 - 1000000) + 1000000);
        if (id != "") {
            id = id + "-";
        }
       
        config = Object.assign(config, {
            // accountId: 'test-account-' + id + now + '-' + randomNumber,
            accountId: 'test-account-' + id + now + '-' + randomNumber
        });
        delete config.contractName;

        const keyStore = new nearAPI.keyStores.UnencryptedFileSystemKeyStore(PROJECT_KEY_DIR);
        config.deps = Object.assign(config.deps || {}, {
            storage:  this.createFakeStorage(),
            keyStore,
        });
        const near = await nearAPI.connect(config);

        const masterAccount = await near.account(testAccountName);
        const randomKey = await nearAPI.KeyPair.fromRandom('ed25519');
        // const data = [...fs.readFileSync(wasmFile)];
        await config.deps.keyStore.setKey(config.networkId, config.accountId, randomKey);
        await masterAccount.createAccount(config.accountId, randomKey.getPublicKey(), INITIAL_BALANCE);

        
        return(config.accountId);

    }

    async setup() {
        
        this.global.nearlib = require('near-api-js');
        this.global.nearAPI = require('near-api-js');
        this.global.window = {};
        let config = require('near-cli/get-config')();

        // check to see if contractName is defined in the config (which is its by default)
        // and go ahead and delete it to avoid any confusion as its not going to be used in this enviorment
        if (config.contractName) {
            delete config.contractName;
        }
        this.global.testSettings = this.global.nearConfig = config;

        let main_contract_id = await this.setupContract(config,'./contracts/out/marvfirst_main.wasm','main');
        let sub_contract_id = await this.setupContract(config,'./contracts/out/marvfirst_sub.wasm','sub');
        let user1_account_id = await this.setupAccount(config,"user1");

        this.global.testAccounts = {
                main_contract :  main_contract_id,
                sub_contract  :  sub_contract_id,
                user_acct1    :  user1_account_id,
        }

        await super.setup();
    }

    async teardown() {
        await super.teardown();
    }

    runScript(script) {
        return super.runScript(script);
    }

    createFakeStorage() {
        let store = {};
        return {
            getItem: function(key) {
                return store[key];
            },
            setItem: function(key, value) {
                store[key] = value.toString();
            },
            clear: function() {
                store = {};
            },
            removeItem: function(key) {
                delete store[key];
            }
        };
    }
}

module.exports = LocalTestEnvironment;

'''
'''--- updateSubContractConfig.sh ---
#!/bin/bash
source devconfig 
echo $SUBCONTRACT_NAME
echo $CONTRACT_NAME
near call $SUBCONTRACT_NAME update_log_contract --accountId  $SUBCONTRACT_NAME --args "{\"log_contract\" : \"$CONTRACT_NAME\"}"

'''