*GitHub Repository "near/near-api-py"*

'''--- near_api/__init__.py ---
import logging

import near_api.providers
import near_api.serializer
import near_api.transactions
import near_api.account
import near_api.signer

log = logging.getLogger(__name__)

'''
'''--- near_api/account.py ---
import itertools
import json
from typing import Optional, List

import base58

import near_api
from near_api import transactions

# Amount of gas attached by default 1e14.
DEFAULT_ATTACHED_GAS = 100_000_000_000_000

class TransactionError(Exception):
    pass

class ViewFunctionError(Exception):
    pass

class Account(object):

    def __init__(
            self,
            provider: 'near_api.providers.JsonProvider',
            signer: 'near_api.signer.Signer',
            account_id: Optional[str] = None
    ):
        self._provider = provider
        self._signer = signer
        self._account_id = account_id or self._signer.account_id
        self._account: dict = provider.get_account(self._account_id)
        self._access_key: dict = provider.get_access_key(self._account_id, self._signer.key_pair.encoded_public_key())
        # print(account_id, self._account, self._access_key)

    def _sign_and_submit_tx(self, receiver_id: str, actions: List['transactions.Action']) -> dict:
        self._access_key['nonce'] += 1
        block_hash = self._provider.get_status()['sync_info']['latest_block_hash']
        block_hash = base58.b58decode(block_hash.encode('utf8'))
        serialized_tx = transactions.sign_and_serialize_transaction(
            receiver_id, self._access_key['nonce'], actions, block_hash, self._signer)
        result: dict = self._provider.send_tx_and_wait(serialized_tx, 10)
        for outcome in itertools.chain([result['transaction_outcome']], result['receipts_outcome']):
            for log in outcome['outcome']['logs']:
                print("Log:", log)
        if 'Failure' in result['status']:
            raise TransactionError(result['status']['Failure'])
        return result

    @property
    def account_id(self) -> str:
        return self._account_id

    @property
    def signer(self) -> 'near_api.signer.Signer':
        return self._signer

    @property
    def provider(self) -> 'near_api.providers.JsonProvider':
        return self._provider

    @property
    def access_key(self) -> dict:
        return self._access_key

    @property
    def state(self) -> dict:
        return self._account

    def fetch_state(self):
        """Fetch state for given account."""
        self._account = self.provider.get_account(self.account_id)

    def send_money(self, account_id: str, amount: int):
        """Sends funds to given account_id given amount."""
        return self._sign_and_submit_tx(account_id, [transactions.create_transfer_action(amount)])

    def function_call(
            self,
            contract_id: str,
            method_name: str,
            args: dict,
            gas: int = DEFAULT_ATTACHED_GAS,
            amount: int = 0
    ) -> dict:
        """NEAR call method."""
        args = json.dumps(args).encode('utf8')
        return self._sign_and_submit_tx(
            contract_id,
            [transactions.create_function_call_action(method_name, args, gas, amount)]
        )

    def create_account(self, account_id: str, public_key: str, initial_balance: int) -> dict:
        actions = [
            transactions.create_create_account_action(),
            transactions.create_full_access_key_action(public_key),
            transactions.create_transfer_action(initial_balance),
        ]
        return self._sign_and_submit_tx(account_id, actions)

    def delete_account(self, beneficiary_id: str) -> dict:
        return self._sign_and_submit_tx(self._account_id, [transactions.create_delete_account_action(beneficiary_id)])

    def deploy_contract(self, contract_code: bytes) -> dict:
        return self._sign_and_submit_tx(self._account_id, [transactions.create_deploy_contract_action(contract_code)])

    def stake(self, public_key: str, amount: int) -> dict:
        return self._sign_and_submit_tx(self._account_id, [transactions.create_staking_action(amount, public_key)])

    def create_and_deploy_contract(
            self,
            contract_id: str,
            public_key: str,
            contract_code: bytes,
            initial_balance: int
    ) -> dict:
        actions = [
                      transactions.create_create_account_action(),
                      transactions.create_transfer_action(initial_balance),
                      transactions.create_deploy_contract_action(contract_code)
                  ] + ([transactions.create_full_access_key_action(public_key)] if public_key is not None else [])
        return self._sign_and_submit_tx(contract_id, actions)

    def create_deploy_and_init_contract(
            self,
            contract_id: str,
            public_key: str,
            contract_code: bytes,
            initial_balance: int,
            args: bytes,
            gas: int = DEFAULT_ATTACHED_GAS,
            init_method_name: str = "new"
    ) -> dict:
        args = json.dumps(args).encode('utf8')
        actions = [
                      transactions.create_create_account_action(),
                      transactions.create_transfer_action(initial_balance),
                      transactions.create_deploy_contract_action(contract_code),
                      transactions.create_function_call_action(init_method_name, args, gas, 0)
                  ] + ([transactions.create_full_access_key_action(public_key)] if public_key is not None else [])
        return self._sign_and_submit_tx(contract_id, actions)

    def view_function(self, contract_id: str, method_name: str, args: Optional[dict] = None) -> dict:
        """NEAR view method."""
        result = self._provider.view_call(contract_id, method_name, json.dumps(args).encode('utf8'))
        if "error" in result:
            raise ViewFunctionError(result['error'])
        result['result'] = json.loads(''.join([chr(x) for x in result['result']]))
        return result

'''
'''--- near_api/providers.py ---
import base64
import json
from typing import Union, Tuple, Any

import requests

TimeoutType = Union[float, Tuple[float, float]]
""" The type used as "timeout" argument when sending requests. Quantities are in seconds.
    As a float, it indicates how long to wait for the server to send data,
    As a (connect timeout, read timeout) tuple, it specifically indicates how long to
    wait for the connection to establish and how long to wait for the sever to respond.
    See https://requests.readthedocs.io/en/latest/api/#requests.request"""

class FinalityTypes:
    FINAL = "final"
    OPTIMISTIC = "optimistic"

class JsonProviderError(Exception):
    pass

class JsonProvider(object):
    def __init__(self, rpc_addr, proxies=None):
        if isinstance(rpc_addr, tuple):
            self._rpc_addr = "http://%s:%s" % rpc_addr
        else:
            self._rpc_addr = rpc_addr
        self.proxies = proxies

    def rpc_addr(self) -> str:
        return self._rpc_addr

    def json_rpc(self, method: str, params: Union[dict, list, str], timeout: 'TimeoutType' = 2.0) -> dict:
        j = {
            'method': method,
            'params': params,
            'id': "dontcare",
            'jsonrpc': "2.0"
        }
        r = requests.post(self.rpc_addr(), json=j, timeout=timeout, proxies=self.proxies)
        r.raise_for_status()
        content = json.loads(r.content)
        if "error" in content:
            raise JsonProviderError(content['error'])
        return content['result']

    def send_tx(self, signed_tx: bytes, timeout: 'TimeoutType' = 2.0) -> dict:
        return self.json_rpc("broadcast_tx_async",
                             [base64.b64encode(signed_tx).decode('utf8')], timeout=timeout)

    def send_tx_and_wait(self, signed_tx: bytes, timeout: 'TimeoutType') -> dict:
        return self.json_rpc("broadcast_tx_commit",
                             [base64.b64encode(signed_tx).decode('utf8')],
                             timeout=timeout)

    def get_status(self, timeout: 'TimeoutType' = 2.0) -> dict:
        r = requests.get("%s/status" % self.rpc_addr(), timeout=timeout)
        r.raise_for_status()
        return json.loads(r.content)

    def get_validators(self, timeout: 'TimeoutType' = 2.0) -> dict:
        return self.json_rpc("validators", [None], timeout=timeout)

    def query(self, query_object: str, timeout: 'TimeoutType' = 2.0) -> dict:
        return self.json_rpc("query", query_object, timeout=timeout)

    def get_account(
            self,
            account_id: str,
            finality: str = FinalityTypes.OPTIMISTIC,
            timeout: 'TimeoutType' = 2.0
    ) -> dict:
        return self.json_rpc(
            "query", {
                'request_type': "view_account",
                'account_id': account_id,
                'finality': finality
            }, timeout=timeout)

    def get_access_key_list(
            self,
            account_id: str,
            finality: str = FinalityTypes.OPTIMISTIC,
            timeout: 'TimeoutType' = 2.0
    ) -> dict:
        return self.json_rpc(
            "query", {
                'request_type': "view_access_key_list",
                'account_id': account_id,
                'finality': finality
            }, timeout=timeout)

    def get_access_key(
            self,
            account_id: str,
            public_key: str,
            finality: str = FinalityTypes.OPTIMISTIC,
            timeout: 'TimeoutType' = 2.0
    ) -> dict:
        return self.json_rpc(
            "query", {
                'request_type': "view_access_key",
                'account_id': account_id,
                'public_key': public_key,
                'finality': finality
            }, timeout=timeout)

    def view_call(
            self,
            account_id: str,
            method_name: str,
            args: bytes,
            finality: str = FinalityTypes.OPTIMISTIC,
            timeout: 'TimeoutType' = 2.0
    ) -> dict:
        return self.json_rpc(
            "query", {
                'request_type': "call_function",
                'account_id': account_id,
                'method_name': method_name,
                'args_base64': base64.b64encode(args).decode('utf8'),
                'finality': finality
            }, timeout=timeout)

    def get_block(self, block_id: str, timeout: 'TimeoutType' = 2.0) -> dict:
        return self.json_rpc("block", [block_id], timeout=timeout)

    def get_chunk(self, chunk_id: str, timeout: 'TimeoutType' = 2.0) -> dict:
        return self.json_rpc("chunk", [chunk_id], timeout=timeout)

    def get_tx(self, tx_hash: str, tx_recipient_id: str, timeout: 'TimeoutType' = 2.0) -> dict:
        return self.json_rpc("tx", [tx_hash, tx_recipient_id], timeout=timeout)

    def get_changes_in_block(
            self,
            block_id: Union[str] = None,
            finality: str = None,
            timeout: 'TimeoutType' = 2.0
    ) -> dict:
        """Use either block_id or finality. Choose finality from "finality_types" class."""
        params = {}
        if block_id:
            params['block_id'] = block_id
        if finality:
            params['finality'] = finality
        return self.json_rpc("EXPERIMENTAL_changes_in_block", params, timeout=timeout)

    def get_validators_ordered(self, block_hash: bytes) -> dict:
        return self.json_rpc("EXPERIMENTAL_validators_ordered", [block_hash])

    def get_light_client_proof(
            self,
            outcome_type: str,
            tx_or_receipt_id: str,
            sender_or_receiver_id: str,
            light_client_head: str
    ) -> dict:
        if outcome_type == "receipt":
            params = {
                'type': "receipt",
                'receipt_id': tx_or_receipt_id,
                'receiver_id': sender_or_receiver_id,
                'light_client_head': light_client_head
            }
        else:
            params = {
                'type': "transaction",
                'transaction_hash': tx_or_receipt_id,
                'sender_id': sender_or_receiver_id,
                'light_client_head': light_client_head
            }
        return self.json_rpc("light_client_proof", params)

    def get_next_light_client_block(self, last_block_hash) -> dict:
        return self.json_rpc("next_light_client_block", [last_block_hash])

    def get_receipt(self, receipt_hash, timeout: 'TimeoutType' = 2.0) -> dict:
        return self.json_rpc("EXPERIMENTAL_receipt", [receipt_hash], timeout=timeout)

'''
'''--- near_api/serializer.py ---
from typing import Union

class BinarySerializer:
    def __init__(self, schema: dict):
        self.array = bytearray()
        self.schema = schema

    def serialize_num(self, value: int, n_bytes: int):
        orig_value = value
        assert value >= 0, "Can't serialize negative numbers %d" % value    # TODO: Need to replace to Exception
        for i in range(n_bytes):
            self.array.append(value & 255)
            value //= 256
        assert value == 0, "Value %d has more than %d bytes" % (orig_value, n_bytes)    # TODO: Need to replace to Exception

    def serialize_field(self, value: Union[str, int], field_type: Union[str, list, dict, type]):
        try:
            if type(field_type) == str:
                if field_type[0] == 'u':
                    self.serialize_num(value, int(field_type[1:]) // 8)
                elif field_type == 'string':
                    b = value.encode('utf8')
                    self.serialize_num(len(b), 4)
                    self.array += b
                else:
                    assert False, field_type        # TODO: Need to replace to Exception
            elif type(field_type) == list:
                assert len(field_type) == 1    # TODO: Need to replace to Exception
                if type(field_type[0]) == int:
                    assert type(value) == bytes, "type(%s) = %s != bytes" % (value, type(value))    # TODO: Need to replace to Exception
                    assert len(value) == field_type[0], "len(%s) = %s != %s" % (value, len(value), field_type[0])    # TODO: Need to replace to Exception
                    self.array += bytearray(value)
                else:
                    self.serialize_num(len(value), 4)
                    for el in value:
                        self.serialize_field(el, field_type[0])
            elif type(field_type) == dict:
                assert field_type['kind'] == "option"    # TODO: Need to replace to Exception
                if value is None:
                    self.serialize_num(0, 1)
                else:
                    self.serialize_num(1, 1)
                    self.serialize_field(value, field_type['type'])
            elif type(field_type) == type:
                assert type(value) == field_type, "%s != type(%s)" % (field_type, value)    # TODO: Need to replace to Exception
                self.serialize_struct(value)
            else:
                assert False, type(field_type)    # TODO: Need to replace to Exception
        except Exception:
            print("Failed to serialize %s as %s" % (value, field_type))
            raise

    def serialize_struct(self, obj):
        struct_schema = self.schema[type(obj)]
        if struct_schema['kind'] == "struct":
            for fieldName, fieldType in struct_schema['fields']:
                self.serialize_field(getattr(obj, fieldName), fieldType)
        elif struct_schema['kind'] == "enum":
            name = getattr(obj, struct_schema['field'])
            for idx, (fieldName, fieldType) in enumerate(struct_schema['values']):
                if fieldName == name:
                    self.serialize_num(idx, 1)
                    self.serialize_field(getattr(obj, fieldName), fieldType)
                    break
        else:
            assert False, struct_schema     # TODO: Need to replace to Exception

    def serialize(self, obj):
        self.serialize_struct(obj)
        return bytes(self.array)

'''
'''--- near_api/signer.py ---
import json
from typing import Union

import base58
from nacl import signing, encoding

class KeyPair(object):

    def __init__(self, secret_key: Union[str, bytes, None] = None):
        """
        If no secret_key, a new one is created.
        secret_key must be a base58-encoded string or
        the byte object returned as "secret_key" property of a KeyPair object."""
        if not secret_key:
            self._secret_key = signing.SigningKey.generate()
        if isinstance(secret_key, bytes):
            self._secret_key = signing.SigningKey(secret_key, encoder=encoding.RawEncoder)
        elif isinstance(secret_key, str):
            secret_key = secret_key.split(':')[-1]
            self._secret_key = signing.SigningKey(base58.b58decode(secret_key)[:32], encoder=encoding.RawEncoder)
        else:
            raise Exception("Unrecognised")
        self._public_key = self._secret_key.verify_key

    @property
    def public_key(self) -> bytes:
        return self._public_key.encode()

    def encoded_public_key(self) -> str:
        return base58.b58encode(self.public_key).decode('utf-8')

    def sign(self, message: bytes) -> bytes:
        return self._secret_key.sign(message).signature

    @property
    def secret_key(self) -> bytes:
        return self._secret_key.encode()

    @property
    def encoded_secret_key(self) -> str:
        return base58.b58encode(self.secret_key).decode('utf-8')

    @property
    def corresponding_account_id(self) -> str:
        return self.public_key.hex()

    @staticmethod
    def encoded_public_key_from_id(account_id) -> str:
        return base58.b58encode(bytes.fromhex(account_id)).decode('utf-8')

class Signer(object):
    def __init__(self, account_id: str, key_pair: 'KeyPair'):
        self._account_id = account_id
        self._key_pair = key_pair

    @property
    def account_id(self) -> str:
        return self._account_id

    @property
    def key_pair(self) -> 'KeyPair':
        return self._key_pair

    @property
    def public_key(self) -> bytes:
        return self._key_pair.public_key

    def sign(self, message: bytes) -> bytes:
        return self._key_pair.sign(message)

    @classmethod
    def from_json(cls, j: dict):
        return cls(j['account_id'], KeyPair(j['secret_key']))

    @classmethod
    def from_json_file(cls, json_file: str):
        with open(json_file) as f:
            return cls.from_json(json.loads(f.read()))

'''
'''--- near_api/transactions.py ---
import hashlib
from typing import List

import near_api
from near_api.serializer import BinarySerializer

class Signature:
    pass

class SignedTransaction:
    pass

class Transaction:
    pass

class PublicKey:
    pass

class AccessKey:
    pass

class AccessKeyPermission:
    pass

class FunctionCallPermission:
    pass

class FullAccessPermission:
    pass

class Action:
    pass

class CreateAccount:
    pass

class DeployContract:
    pass

class FunctionCall:
    pass

class Transfer:
    pass

class Stake:
    pass

class AddKey:
    pass

class DeleteKey:
    pass

class DeleteAccount:
    pass

tx_schema = dict(
    [
        [
            Signature,
            {
                'kind': 'struct',
                'fields': [
                    ['keyType', 'u8'],
                    ['data', [64]],
                ],
            },
        ],
        [
            SignedTransaction,
            {
                'kind': 'struct',
                'fields': [
                    ['transaction', Transaction],
                    ['signature', Signature],
                ],
            },
        ],
        [
            Transaction,
            {
                'kind': 'struct',
                'fields': [
                    ['signerId', 'string'],
                    ['publicKey', PublicKey],
                    ['nonce', 'u64'],
                    ['receiverId', 'string'],
                    ['blockHash', [32]],
                    ['actions', [Action]],
                ],
            },
        ],
        [
            PublicKey,
            {
                'kind': 'struct',
                'fields': [
                    ['keyType', 'u8'],
                    ['data', [32]],
                ],
            },
        ],
        [
            AccessKey,
            {
                'kind': 'struct',
                'fields': [
                    ['nonce', 'u64'],
                    ['permission', AccessKeyPermission],
                ],
            },
        ],
        [
            AccessKeyPermission,
            {
                'kind': 'enum',
                'field': 'enum',
                'values': [
                    ['functionCall', FunctionCallPermission],
                    ['fullAccess', FullAccessPermission],
                ],
            },
        ],
        [
            FunctionCallPermission,
            {
                'kind': 'struct',
                'fields': [
                    ['allowance', {'kind': 'option', type: 'u128'}],
                    ['receiverId', 'string'],
                    ['methodNames', ['string']],
                ],
            },
        ],
        [
            FullAccessPermission,
            {
                'kind': 'struct',
                'fields': []
            },
        ],
        [
            Action,
            {
                'kind': 'enum',
                'field': 'enum',
                'values': [
                    ['createAccount', CreateAccount],
                    ['deployContract', DeployContract],
                    ['functionCall', FunctionCall],
                    ['transfer', Transfer],
                    ['stake', Stake],
                    ['addKey', AddKey],
                    ['deleteKey', DeleteKey],
                    ['deleteAccount', DeleteAccount],
                ],
            },
        ],
        [
            CreateAccount,
            {
                'kind': 'struct',
                'fields': []
            },
        ],
        [
            DeployContract,
            {
                'kind': 'struct',
                'fields': [
                    ['code', ['u8']],
                ],
            },
        ],
        [
            FunctionCall,
            {
                'kind': 'struct',
                'fields': [
                    ['methodName', 'string'],
                    ['args', ['u8']],
                    ['gas', 'u64'],
                    ['deposit', 'u128'],
                ],
            },
        ],
        [
            Transfer,
            {
                'kind': 'struct',
                'fields': [
                    ['deposit', 'u128'],
                ],
            },
        ],
        [
            Stake,
            {
                'kind': 'struct',
                'fields': [
                    ['stake', 'u128'],
                    ['publicKey', PublicKey],
                ],
            },
        ],
        [
            AddKey,
            {
                'kind': 'struct',
                'fields': [
                    ['publicKey', PublicKey],
                    ['accessKey', AccessKey]
                ],
            },
        ],
        [
            DeleteKey,
            {
                'kind': 'struct',
                'fields': [
                    ['publicKey', PublicKey],
                ],
            },
        ],
        [
            DeleteAccount,
            {
                'kind': 'struct',
                'fields': [
                    ['beneficiaryId', 'string'],
                ],
            },
        ],
    ]
)

def sign_and_serialize_transaction(
        receiver_id: str,
        nonce: int,
        actions: List[Action],
        block_hash: bytes,
        signer: 'near_api.signer.Signer'
) -> bytes:
    assert signer.public_key is not None    # TODO: Need to replace to Exception
    assert block_hash is not None    # TODO: Need to replace to Exception
    tx = Transaction()
    tx.signerId = signer.account_id
    tx.publicKey = PublicKey()
    tx.publicKey.keyType = 0
    tx.publicKey.data = signer.public_key
    tx.nonce = nonce
    tx.receiverId = receiver_id
    tx.actions = actions
    tx.blockHash = block_hash

    msg: bytes = BinarySerializer(tx_schema).serialize(tx)
    hash_: bytes = hashlib.sha256(msg).digest()

    signature = Signature()
    signature.keyType = 0
    signature.data = signer.sign(hash_)

    signed_tx = SignedTransaction()
    signed_tx.transaction = tx
    signed_tx.signature = signature

    return BinarySerializer(tx_schema).serialize(signed_tx)

def create_create_account_action() -> 'Action':
    create_account = CreateAccount()
    action = Action()
    action.enum = "createAccount"
    action.createAccount = create_account
    return action

def create_delete_account_action(beneficiary_id: str) -> 'Action':
    delete_account = DeleteAccount()
    delete_account.beneficiaryId = beneficiary_id
    action = Action()
    action.enum = "deleteAccount"
    action.deleteAccount = delete_account
    return action

def create_full_access_key_action(pk: str) -> 'Action':
    permission = AccessKeyPermission()
    permission.enum = "fullAccess"
    permission.fullAccess = FullAccessPermission()
    access_key = AccessKey()
    access_key.nonce = 0
    access_key.permission = permission
    public_key = PublicKey()
    public_key.keyType = 0
    public_key.data = pk
    add_key = AddKey()
    add_key.accessKey = access_key
    add_key.publicKey = public_key
    action = Action()
    action.enum = "addKey"
    action.addKey = add_key
    return action

def create_delete_access_key_action(pk: str) -> 'Action':
    public_key = PublicKey()
    public_key.keyType = 0
    public_key.data = pk
    delete_key = DeleteKey()
    delete_key.publicKey = public_key
    action = Action()
    action.enum = "deleteKey"
    action.deleteKey = delete_key
    return action

def create_transfer_action(amount: int) -> 'Action':
    transfer = Transfer()
    transfer.deposit = amount
    action = Action()
    action.enum = "transfer"
    action.transfer = transfer
    return action

# TODO: deprecate usage of create_payment_action.
create_payment_action = create_transfer_action

def create_staking_action(amount: int, pk: str) -> 'Action':
    stake = Stake()
    stake.stake = amount
    stake.publicKey = PublicKey()
    stake.publicKey.keyType = 0
    stake.publicKey.data = pk
    action = Action()
    action.enum = "stake"
    action.stake = stake
    return action

def create_deploy_contract_action(code: bytes) -> 'Action':
    deploy_contract = DeployContract()
    deploy_contract.code = code
    action = Action()
    action.enum = "deployContract"
    action.deployContract = deploy_contract
    return action

def create_function_call_action(method_name: str, args: bytes, gas: int, deposit: int) -> 'Action':
    function_call = FunctionCall()
    function_call.methodName = method_name
    function_call.args = args
    function_call.gas = gas
    function_call.deposit = deposit
    action = Action()
    action.enum = "functionCall"
    action.functionCall = function_call
    return action

def sign_create_account_tx(
        creator_signer: 'near_api.signer.Signer',
        new_account_id: str,
        nonce: int,
        block_hash: bytes
) -> bytes:
    action = create_create_account_action()
    return sign_and_serialize_transaction(new_account_id, nonce, [action], block_hash, creator_signer)

def sign_create_account_with_full_access_key_and_balance_tx(
        creator_key: 'near_api.signer.Signer',
        new_account_id: str,
        new_key,
        balance: int,
        nonce: int,
        block_hash: bytes
) -> bytes:
    create_account_action = create_create_account_action()
    full_access_key_action = create_full_access_key_action(new_key.decoded_pk())
    payment_action = create_transfer_action(balance)
    actions = [create_account_action, full_access_key_action, payment_action]
    return sign_and_serialize_transaction(new_account_id, nonce, actions, block_hash, creator_key.account_id,
                                          creator_key.decoded_pk(), creator_key.decoded_sk())   # TODO: Last two params is unused

def sign_delete_access_key_tx(
        signer_key: 'near_api.signer.Signer',
        target_account_id: str,
        key_for_deletion,
        nonce: int,
        block_hash: bytes
) -> bytes:
    action = create_delete_access_key_action(key_for_deletion.decoded_pk())
    return sign_and_serialize_transaction(target_account_id, nonce, [action], block_hash, signer_key.account_id,
                                          signer_key.decoded_pk(), signer_key.decoded_sk())   # TODO: Last two params is unused

def sign_payment_tx(
        key: 'near_api.signer.Signer',
        to: str,
        amount: int,
        nonce: int,
        block_hash: bytes
) -> bytes:
    action = create_transfer_action(amount)
    return sign_and_serialize_transaction(to, nonce, [action], block_hash, key.account_id,
                                          key.decoded_pk(), key.decoded_sk())   # TODO: Last two params is unused

def sign_staking_tx(
        signer_key: 'near_api.signer.Signer',
        validator_key,
        amount: int,
        nonce: int,
        block_hash: bytes
) -> bytes:
    action = create_staking_action(amount, validator_key.decoded_pk())
    return sign_and_serialize_transaction(signer_key.account_id, nonce, [action], block_hash, signer_key.account_id,
                                          signer_key.decoded_pk(), signer_key.decoded_sk())   # TODO: Last two params is unused

def sign_deploy_contract_tx(
        signer_key: 'near_api.signer.Signer',
        code: bytes,
        nonce: int,
        block_hash: bytes
) -> bytes:
    action = create_deploy_contract_action(code)
    return sign_and_serialize_transaction(signer_key.account_id, nonce, [action], block_hash, signer_key.account_id,
                                          signer_key.decoded_pk(), signer_key.decoded_sk())   # TODO: Last two params is unused

def sign_function_call_tx(
        signer_key: 'near_api.signer.Signer',
        contract_id: str,
        method_name: str,
        args: bytes,
        gas: int,
        deposit: int,
        nonce: int,
        block_hash: bytes
) -> bytes:
    action = create_function_call_action(method_name, args, gas, deposit)
    return sign_and_serialize_transaction(contract_id, nonce, [action], block_hash, signer_key.account_id,
                                          signer_key.decoded_pk(), signer_key.decoded_sk())   # TODO: Last two params is unused

'''
'''--- setup.py ---
from setuptools import setup, find_packages

META_DATA = dict(
    name="near-api",
    version="0.2.1",
    license="MIT",

    author="NEAR Inc",

    url="https://github.com/near/near-api-py",

    packages=find_packages(),

    install_requires=["requests", "base58", "pynacl"]
)

if __name__ == "__main__":
    setup(**META_DATA)

'''
'''--- test/config.py ---
# TODO: add here environment configuration for local testing.

# mainnet
# https://rpc.mainnet.near.org
# testnet
# https://rpc.testnet.near.org
# betanet (may be unstable)
# https://rpc.betanet.near.org
# localnet
# http://localhost: 3030

# NODE_URL = "https://rpc.testnet.near.org"

NODE_URL = "https://rpc.ci-testnet.near.org"
TEST_ACCOUNT = "test.near"
TEST_KEY_PAIR = "ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"

'''
'''--- test/test_account.py ---
import unittest

import near_api
from config import NODE_URL, TEST_ACCOUNT, TEST_KEY_PAIR
from utils import create_account

class AccountTest(unittest.TestCase):
    def setUp(self):
        self.provider = near_api.providers.JsonProvider(NODE_URL)
        self.signer = near_api.signer.Signer(
            TEST_ACCOUNT,
            near_api.signer.KeyPair(TEST_KEY_PAIR)
        )
        self.master_account = near_api.account.Account(self.provider, self.signer)

    def test_create_account(self):
        amount = 10 ** 24
        account = create_account(self.master_account, amount)
        self.assertEqual(int(account.state["amount"]), amount)

    def test_send_money(self):
        sender = create_account(self.master_account)
        receiver = create_account(self.master_account)
        sender.send_money(receiver.account_id, 1000)
        receiver.fetch_state()
        self.assertEqual(int(receiver.state["amount"]), 10 ** 24 + 1000)

'''
'''--- test/test_provider.py ---
import time
import unittest

import near_api
from config import NODE_URL, TEST_ACCOUNT, TEST_KEY_PAIR
from utils import create_account

class JsonProviderTest(unittest.TestCase):
    def setUp(self):
        self.provider = near_api.providers.JsonProvider(NODE_URL)
        self.signer = near_api.signer.Signer(
            TEST_ACCOUNT,
            near_api.signer.KeyPair(TEST_KEY_PAIR)
        )
        self.master_account = near_api.account.Account(self.provider, self.signer)

    def test_status(self):
        status = self.provider.get_status()
        self.assertIsNotNone(status["chain_id"])

    def test_get_account(self):
        response = self.provider.get_account(TEST_ACCOUNT)
        self.assertEqual(response["code_hash"], "11111111111111111111111111111111")

    def test_get_validators_orders(self):
        status = self.provider.get_status()
        latest_block_hash = status['sync_info']['latest_block_hash']
        self.assertEqual(
            self.provider.get_validators_ordered(latest_block_hash)[0]
            ['account_id'],
            TEST_ACCOUNT
        )

    def test_get_next_light_client_block(self):
        status = self.provider.get_status()
        latest_block_hash = status['sync_info']['latest_block_hash']
        receiver = create_account(self.master_account)
        result = self.master_account.send_money(receiver.account_id, 1000)
        time.sleep(3)
        next_light_client_block = self.provider.get_next_light_client_block(latest_block_hash)
        self.provider.get_light_client_proof(
            'transaction', result['transaction']['hash'],
            result['transaction']['receiver_id'],
            next_light_client_block['prev_block_hash']
        )

'''
'''--- test/utils.py ---
import time

import near_api

def create_account(master_account, amount=10 ** 24):
    account_id = "testtest-%s.test.near" % int(time.time() * 10_000)
    master_account.create_account(account_id, master_account.signer.public_key, amount)
    signer = near_api.signer.Signer(account_id, master_account.signer.key_pair)
    account = near_api.account.Account(master_account.provider, signer)
    return account

'''