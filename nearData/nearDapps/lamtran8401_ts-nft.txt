*GitHub Repository "lamtran8401/ts-nft"*

'''--- .github/workflows/tests.yml ---
name: Tests
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install modules
        run: yarn
      - name: Build contract
        run: yarn build
      - name: Run tests
        run: yarn test

'''
'''--- README.md ---
# NEAR NFT-Tutorial JavaScript Edition

Welcome to NEAR's NFT tutorial, where we will help you parse the details around NEAR's [NEP-171 standard](https://nomicon.io/Standards/NonFungibleToken/Core.html) (Non-Fungible Token Standard), and show you how to build your own NFT smart contract from the ground up, improving your understanding about the NFT standard along the way. 

## Prerequisites

* [Node.js](/develop/prerequisites#nodejs)
* [NEAR Wallet Account](wallet.testnet.near.org)
* [NEAR-CLI](https://docs.near.org/tools/near-cli#setup)
* [yarn](https://classic.yarnpkg.com/en/docs/install#mac-stable)

## Tutorial Stages 

Each branch you will find in this repo corresponds to various stages of this tutorial with a partially completed contract at each stage. You are welcome to start from any stage you want to learn the most about. 

| Branch        | Docs Tutorial                                                                                    | Description |
| ------------- | ------------------------------------------------------------------------------------------------ | ----------- |
| 1.skeleton    | [Contract Architecture](https://docs.near.org/docs/tutorials/contracts/nfts/js/skeleton) | You'll learn the basic architecture of the NFT smart contract.            |
| 2.minting     | [Minting](https://docs.near.org/docs/tutorials/contracts/nfts/js/minting)                |Here you'll flesh out the skeleton so the smart contract can mint a non-fungible token             |
| 3.enumeration | [Enumeration](https://docs.near.org/docs/tutorials/contracts/nfts/js/enumeration)        |    Here you'll find different enumeration methods that can be used to return the smart contract's states.          |
| 4.core        | [Core](https://docs.near.org/docs/tutorials/contracts/nfts/js/core)                      | In this tutorial you'll extend the NFT contract using the core standard, which will allow you to transfer non-fungible tokens.             |
| 5.approval    | [Approval](https://docs.near.org/docs/tutorials/contracts/nfts/js/approvals)             | Here you'll expand the contract allowing other accounts to transfer NFTs on your behalf.            |
| 6.royalty     | [Royalty](https://docs.near.org/docs/tutorials/contracts/nfts/js/royalty)                                                                                        |Here you'll add the ability for non-fungible tokens to have royalties. This will allow people to get a percentage of the purchase price when an NFT is purchased.             |
| 7.events      | -----------                                                                                        |   This allows indexers to know what functions are being called and make it easier and more reliable to keep track of information that can be used to populate the collectibles tab in the wallet for example. (tutorial docs have yet to be implemented )          |
| 8.marketplace | -----------                                                                                      | -----------             |

The tutorial series also contains a very helpful section on [**Upgrading Smart Contracts**](https://docs.near.org/docs/tutorials/contracts/nfts/js/upgrade-contract). Definitely go and check it out as this is a common pain point.

# Quick-Start 

If you want to see the full completed contract go ahead and clone and build this repo using 

```=bash
git clone https://github.com/near-examples/nft-tutorial-js.git 
cd nft-tutorial-js
yarn && yarn build
```

Now that you've cloned and built the contract we can try a few things. 

## Mint An NFT

Once you've created your near wallet go ahead and login to your wallet with your cli and follow the on-screen prompts

```=bash
near login
```

Once your logged in you have to deploy the contract. Make a subaccount with the name of your choosing 

```=bash 
near create-account nft-example.your-account.testnet --masterAccount your-account.testnet --initialBalance 10
```

After you've created your sub account deploy the contract to that sub account, set this variable to your sub account name

```=bash
NFT_CONTRACT_ID=nft-example.your-account.testnet

MAIN_ACCOUNT=your-account.testnet
```

Verify your new variable has the correct value
```=bash
echo $NFT_CONTRACT_ID

echo $MAIN_ACCOUNT
```

### Deploy Your Contract
```=bash
near deploy --accountId $NFT_CONTRACT_ID --wasmFile build/nft.wasm
```

### Initialize Your Contract 

```=bash
near call $NFT_CONTRACT_ID init '{"owner_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID
```

### View Contracts Meta Data

```=bash
near view $NFT_CONTRACT_ID nft_metadata
```
### Minting Token

```bash=
near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$MAIN_ACCOUNT'"}' --accountId $MAIN_ACCOUNT --amount 0.1
```

After you've minted the token go to wallet.testnet.near.org to `your-account.testnet` and look in the collections tab and check out your new sample NFT! 

## View NFT Information

After you've minted your NFT you can make a view call to get a response containing the `token_id` `owner_id` and the `metadata`

```bash=
near view $NFT_CONTRACT_ID nft_token '{"token_id": "token-1"}'
```

## Transfering NFTs

To transfer an NFT go ahead and make another [testnet wallet account](https://wallet.testnet.near.org).

Then run the following
```bash=
MAIN_ACCOUNT_2=your-second-wallet-account.testnet
```

Verify the correct variable names with this

```=bash
echo $NFT_CONTRACT_ID

echo $MAIN_ACCOUNT

echo $MAIN_ACCOUNT_2
```

To initiate the transfer..

```bash=
near call $NFT_CONTRACT_ID nft_transfer '{"receiver_id": "$MAIN_ACCOUNT_2", "token_id": "token-1", "memo": "Go Team :)"}' --accountId $MAIN_ACCOUNT --depositYocto 1
```

In this call you are depositing 1 yoctoNEAR for security and so that the user will be redirected to the NEAR wallet.
'''
'''--- __tests__/test-template.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy the counter contract.
    const counter = await root.createAndDeploy(
        root.getSubAccount('counter').accountId,
        './build/contract.wasm'
    );

    // Init the contract
    await counter.call(counter, 'init', {});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, counter, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Initial count is 0', async t => {
    const { counter } = t.context.accounts;
    const result = await counter.view('getCount', {});
    t.is(result, 0);
});

test('Increase works', async t => {
    const { counter, ali, bob } = t.context.accounts;
    await ali.call(counter, 'increase', {});

    let result = await counter.view('getCount', {});
    t.is(result, 1);

    await bob.call(counter, 'increase', { n: 4 });
    result = await counter.view('getCount', {});
    t.is(result, 5);
});

test('Decrease works', async t => {
    const { counter, ali, bob } = t.context.accounts;
    await ali.call(counter, 'decrease', {});

    let result = await counter.view('getCount', {});
    t.is(result, -1);

    await bob.call(counter, 'decrease', { n: 4 });
    result = await counter.view('getCount', {});
    t.is(result, -5);
});
'''
'''--- babel.config.json ---
{
  "plugins": [
    "near-sdk-js/lib/build-tools/near-bindgen-exporter",
    ["@babel/plugin-proposal-decorators", {"version": "legacy"}]
  ],
  "presets": ["@babel/preset-typescript"]
}
'''
'''--- commands.txt ---
near dev-deploy build/contract.wasm -f && source ./neardev/dev-account.env && near call $CONTRACT_NAME init '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME && near call $CONTRACT_NAME nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME --amount 0.1 

near call $CONTRACT_NAME nft_transfer '{"receiver_id": "benji.fayyr.testnet", "token_id": "token-1"}' --accountId $CONTRACT_NAME --depositYocto 1
'''
'''--- jsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
    },
    "exclude": [
        "node_modules"
    ],
}
'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1659724732366-66506674516641
'''
'''--- package.json ---
{
  "name": "template",
  "version": "1.0.0",
  "description": "Contract template with near-sdk-js",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "build": "yarn build:nft && yarn build:market",
    "build:nft": "near-sdk-js build src/nft-contract/index.ts build/nft.wasm",
    "build:market": "near-sdk-js build src/market-contract/index.ts build/market.wasm",
    "test": "ava"
  },
  "author": "Near Inc <hello@nearprotocol.com>",
  "license": "Apache-2.0",
  "dependencies": {
    "near-sdk-js": "0.4.0-5",
    "lodash-es": "^4.17.21"
  },
  "devDependencies": {
    "typescript": "^4.7.4"
  }
}

'''
'''--- src/market-contract/index.ts ---
import { NearContract, NearBindgen, near, call, view, LookupMap, UnorderedMap, Vector, UnorderedSet, assert } from 'near-sdk-js'
import { assertOneYocto, restoreOwners } from './internal';
import { internalNftOnApprove } from './nft_callbacks';
import { internalOffer, internalRemoveSale, internalResolvePurchase, internalUpdatePrice, Sale } from './sale';
import { internalGetSale, internalSalesByNftContractId, internalSalesByOwnerId, internalSupplyByNftContractId, internalSupplyByOwnerId, internalSupplySales } from './sale_views';

/// This spec can be treated like a version of the standard.
export const NFT_METADATA_SPEC = "nft-1.0.0";

/// This is the name of the NFT standard we're using
export const NFT_STANDARD_NAME = "nep171";

//the minimum storage to have a sale on the contract.
export const STORAGE_PER_SALE: bigint = BigInt(1000) * near.storageByteCost().valueOf();

//every sale will have a unique ID which is `CONTRACT + DELIMITER + TOKEN_ID`
export const DELIMETER = ".";

@NearBindgen
export class Contract extends NearContract {
    //keep track of the owner of the contract
    ownerId: string;
    
    /*
        to keep track of the sales, we map the ContractAndTokenId to a Sale. 
        the ContractAndTokenId is the unique identifier for every sale. It is made
        up of the `contract ID + DELIMITER + token ID`
    */
    sales: UnorderedMap;
    
    //keep track of all the Sale IDs for every account ID
    byOwnerId: LookupMap;

    //keep track of all the token IDs for sale for a given contract
    byNftContractId: LookupMap;

    //keep track of the storage that accounts have payed
    storageDeposits: LookupMap;

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id. 
    */
    constructor({ owner_id }: { owner_id: string }) {
        super()
        this.ownerId = owner_id;
        this.sales = new UnorderedMap("sales");
        this.byOwnerId = new LookupMap("byOwnerId");
        this.byNftContractId = new LookupMap("byNftContractId");
        this.storageDeposits = new LookupMap("storageDeposits");
    }

    default() {
        return new Contract({owner_id: ''})
    }

    /*
        STORAGE
    */
    @call
    //Allows users to deposit storage. This is to cover the cost of storing sale objects on the contract
    //Optional account ID is to users can pay for storage for other people.
    storage_deposit({ account_id }: { account_id?: string }) {
        //get the account ID to pay for storage for
        let storageAccountId = account_id || near.predecessorAccountId();

        //get the deposit value which is how much the user wants to add to their storage
        let deposit = near.attachedDeposit().valueOf();

        //make sure the deposit is greater than or equal to the minimum storage for a sale
        assert(deposit >= STORAGE_PER_SALE, `Requires minimum deposit of ${STORAGE_PER_SALE}`);

        //get the balance of the account (if the account isn't in the map we default to a balance of 0)
        let balance: string = this.storageDeposits.get(storageAccountId) as string || "0";
        //add the deposit to their balance
        let newBalance = BigInt(balance) + deposit;
        //insert the balance back into the map for that account ID
        this.storageDeposits.set(storageAccountId, newBalance.toString());
    }

    @call
    //Allows users to withdraw any excess storage that they're not using. Say Bob pays 0.01N for 1 sale
    //Alice then buys Bob's token. This means bob has paid 0.01N for a sale that's no longer on the marketplace
    //Bob could then withdraw this 0.01N back into his account. 
    storage_withdraw() {
        //make sure the user attaches exactly 1 yoctoNEAR for security purposes.
        //this will redirect them to the NEAR wallet (or requires a full access key). 
        assertOneYocto();

        //the account to withdraw storage to is always the function caller
        let ownerId = near.predecessorAccountId();
        //get the amount that the user has by removing them from the map. If they're not in the map, default to 0
        let amount: string = this.storageDeposits.remove(ownerId) as string || "0";
        
        //how many sales is that user taking up currently. This returns a set
        let sales = restoreOwners(this.byOwnerId.get(ownerId));
        //get the length of that set. 
        let len = 0;
        if (sales != null) {
            len = sales.len();
        }   
        
        //how much NEAR is being used up for all the current sales on the account 
        let diff = BigInt(len) * STORAGE_PER_SALE;
        //the excess to withdraw is the total storage paid - storage being used up.
        let amountLeft = BigInt(amount) - diff;

        //if that excess to withdraw is > 0, we transfer the amount to the user.
        if (amountLeft > 0) {
            const promise = near.promiseBatchCreate(ownerId);
            near.promiseBatchActionTransfer(promise, amountLeft)
        }

        //we need to add back the storage being used up into the map if it's greater than 0.
        //this is so that if the user had 500 sales on the market, we insert that value here so
        //if those sales get taken down, the user can then go and withdraw 500 sales worth of storage.
        if (diff > 0) {
            this.storageDeposits.set(ownerId, diff.toString());
        }
    }

    @view
    //return the minimum storage for 1 sale
    storage_minimum_balance(): string {
        return STORAGE_PER_SALE.toString()
    }

    @view
    //return how much storage an account has paid for
    storage_balance_of({ account_id }: { account_id: string}): string {
        return this.storageDeposits.get(account_id) as string || "0";
    }

    /*
        SALES
    */
    @call
    //removes a sale from the market. 
    remove_sale({nft_contract_id, token_id}:{nft_contract_id: string, token_id: string}) {
        return internalRemoveSale({contract: this, nftContractId: nft_contract_id, tokenId: token_id});
    }

    @call
    //updates the price for a sale on the market
    update_price({nft_contract_id, token_id, price}:{nft_contract_id: string, token_id: string, price: string}) {
        return internalUpdatePrice({contract: this, nftContractId: nft_contract_id, tokenId: token_id, price: price});
    }

    @call
    //place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
    offer({nft_contract_id, token_id}:{nft_contract_id: string, token_id: string}) {
        return internalOffer({contract: this, nftContractId: nft_contract_id, tokenId: token_id});
    }

    @call
    //place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
    resolve_purchase({buyer_id, price}:{buyer_id: string, price: string}) {
        return internalResolvePurchase({buyerId: buyer_id, price: price});
    }

    /*
        SALE VIEWS
    */
    @view
    //returns the number of sales the marketplace has up (as a string)
    get_supply_sales(): string {
        return internalSupplySales({contract: this});
    }

    @view
    //returns the number of sales for a given account (result is a string)
    get_supply_by_owner_id({account_id}:{account_id: string}): string {
        return internalSupplyByOwnerId({contract: this, accountId: account_id});
    }

    @view
    //returns paginated sale objects for a given account. (result is a vector of sales)
    get_sales_by_owner_id({account_id, from_index, limit}:{account_id: string, from_index?: string, limit?: number}): Sale[] {
        return internalSalesByOwnerId({contract: this, accountId: account_id, fromIndex: from_index, limit: limit});
    }

    @view
    //returns paginated sale objects for a given account. (result is a vector of sales)
    get_supply_by_nft_contract_id({nft_contract_id}:{nft_contract_id: string}): string {
        return internalSupplyByNftContractId({contract: this, nftContractId: nft_contract_id});        
    }

    @view
    //returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
    get_sales_by_nft_contract_id({nft_contract_id, from_index, limit}:{nft_contract_id: string, from_index?: string, limit?: number}): Sale[] {
        return internalSalesByNftContractId({contract: this, accountId: nft_contract_id, fromIndex: from_index, limit: limit});
    }

    @view
    //get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
    get_sale({nft_contract_token}:{nft_contract_token: string}): Sale {
        return internalGetSale({contract: this, nftContractToken: nft_contract_token});
    }

    /*
        APPROVALS
    */
    @call
        /// where we add the sale because we know nft owner can only call nft_approve
        nft_on_approve({token_id, owner_id, approval_id, msg}:{token_id: string, owner_id: string, approval_id: number, msg: string}) {
        return internalNftOnApprove({contract: this, tokenId: token_id, ownerId: owner_id, approvalId: approval_id, msg: msg});
    }  

}
'''
'''--- src/market-contract/internal.ts ---
import { assert, near, UnorderedSet } from "near-sdk-js";
import { Contract, DELIMETER } from ".";
import { Sale } from "./sale";

export function restoreOwners(collection) {
    if (collection == null) {
        return null;
    }
    return UnorderedSet.deserialize(collection as UnorderedSet);
}

//used to make sure the user attached exactly 1 yoctoNEAR
export function assertOneYocto() {
    assert(near.attachedDeposit().toString() === "1", "Requires attached deposit of exactly 1 yoctoNEAR");
}

//internal method for removing a sale from the market. This returns the previously removed sale object
export function internallyRemoveSale(contract: Contract, nftContractId: string, tokenId: string): Sale {
    //get the unique sale ID (contract + DELIMITER + token ID)
    let contractAndTokenId = `${nftContractId}${DELIMETER}${tokenId}`;
    //get the sale object by removing the unique sale ID. If there was no sale, panic
    let sale = contract.sales.remove(contractAndTokenId) as Sale;
    if (sale == null) {
        near.panic("no sale");
    }
    
    //get the set of sales for the sale's owner. If there's no sale, panic. 
    let byOwnerId = restoreOwners(contract.byOwnerId.get(sale.owner_id));
    if (byOwnerId == null) {
        near.panic("no sales by owner");
    }
    //remove the unique sale ID from the set of sales
    byOwnerId.remove(contractAndTokenId);

    //if the set of sales is now empty after removing the unique sale ID, we simply remove that owner from the map
    if (byOwnerId.isEmpty()) {
        contract.byOwnerId.remove(sale.owner_id);
    //if the set of sales is not empty after removing, we insert the set back into the map for the owner
    } else {
        contract.byOwnerId.set(sale.owner_id, byOwnerId);
    }

    //get the set of token IDs for sale for the nft contract ID. If there's no sale, panic. 
    let byNftContractId = restoreOwners(contract.byNftContractId.get(nftContractId));
    if (byNftContractId == null) {
        near.panic("no sales by nft contract");
    }
    
    //remove the token ID from the set 
    byNftContractId.remove(tokenId);
    //if the set is now empty after removing the token ID, we remove that nft contract ID from the map
    if (byNftContractId.isEmpty()) {
        contract.byNftContractId.remove(nftContractId);
    //if the set is not empty after removing, we insert the set back into the map for the nft contract ID
    } else {
        contract.byNftContractId.set(nftContractId, byNftContractId);
    }

    //return the sale object
    return sale;
}

'''
'''--- src/market-contract/nft_callbacks.ts ---
import { assert, near, UnorderedSet } from "near-sdk-js";
import { Contract, DELIMETER } from ".";
import { Sale } from "./sale";
import { internalSupplyByOwnerId } from "./sale_views";

/// where we add the sale because we know nft owner can only call nft_approve
export function internalNftOnApprove({
    contract,
    tokenId,
    ownerId,
    approvalId,
    msg
}:{ 
    contract: Contract, 
    tokenId: string, 
    ownerId: string, 
    approvalId: number, 
    msg: string 
}) {
    // get the contract ID which is the predecessor
    let contractId = near.predecessorAccountId();
    //get the signer which is the person who initiated the transaction
    let signerId = near.signerAccountId();
    
    //make sure that the signer isn't the predecessor. This is so that we're sure
    //this was called via a cross-contract call
    assert(signerId != contractId, "this function can only be called via a cross-contract call");
    //make sure the owner ID is the signer. 
    assert(ownerId == signerId, "only the owner of the token can approve it");
    
    //we need to enforce that the user has enough storage for 1 EXTRA sale.  
    let storageAmount = contract.storage_minimum_balance();
    //get the total storage paid by the owner
    let ownerPaidStorage = contract.storageDeposits.get(signerId) || BigInt(0);
    //get the storage required which is simply the storage for the number of sales they have + 1 
    let signerStorageRequired = (BigInt(internalSupplyByOwnerId({contract, accountId: signerId})) + BigInt(1)) * BigInt(storageAmount); 
    
    //make sure that the total paid is >= the required storage
    assert(ownerPaidStorage >= signerStorageRequired, "the owner does not have enough storage to approve this token");
    
    //if all these checks pass we can create the sale conditions object.
    let saleConditions = JSON.parse(msg);
    if (!saleConditions.hasOwnProperty('sale_conditions') || Object.keys(saleConditions).length != 1) {
        near.panic("invalid sale conditions");
    }
    //create the unique sale ID which is the contract + DELIMITER + token ID
    let contractAndTokenId = `${contractId}${DELIMETER}${tokenId}`;
    
    //insert the key value pair into the sales map. Key is the unique ID. value is the sale object
    contract.sales.set(contractAndTokenId, new Sale({
        ownerId: ownerId, //owner of the sale / token
        approvalId: approvalId, //approval ID for that token that was given to the market
        nftContractId: contractId, //NFT contract the token was minted on
        tokenId: tokenId, //the actual token ID
        saleConditions: saleConditions.sale_conditions //the sale conditions 
    }));

    //Extra functionality that populates collections necessary for the view calls 
    //get the sales by owner ID for the given owner. If there are none, we create a new empty set
    let byOwnerId = contract.byOwnerId.get(ownerId) as UnorderedSet || new UnorderedSet(ownerId);
    //insert the unique sale ID into the set
    byOwnerId.set(contractAndTokenId);
    //insert that set back into the collection for the owner
    contract.byOwnerId.set(ownerId, byOwnerId);
    
    //get the token IDs for the given nft contract ID. If there are none, we create a new empty set
    let byNftContractId = contract.byNftContractId.get(contractId) as UnorderedSet || new UnorderedSet(contractId);
    //insert the token ID into the set
    byNftContractId.set(tokenId);
    //insert the set back into the collection for the given nft contract ID
    contract.byNftContractId.set(contractId, byNftContractId);

}
'''
'''--- src/market-contract/sale.ts ---
import { assert, bytes, near } from "near-sdk-js";
import { Contract, DELIMETER } from ".";
import { assertOneYocto, internallyRemoveSale } from "./internal";

//GAS constants to attach to calls
const GAS_FOR_ROYALTIES = 115_000_000_000_000;
const GAS_FOR_NFT_TRANSFER = 15_000_000_000_000;

//struct that holds important information about each sale on the market
export class Sale {
    //owner of the sale
    owner_id: string;
    //market contract's approval ID to transfer the token on behalf of the owner
    approval_id: number;
    //nft contract where the token was minted
    nft_contract_id: string;
    //actual token ID for sale
    token_id: String;
    //sale price in yoctoNEAR that the token is listed for
    sale_conditions: string;
    
    constructor(
        {
            ownerId,
            approvalId,
            nftContractId,
            tokenId,
            saleConditions,
        }:{ 
            ownerId: string,
            approvalId: number,
            nftContractId: string,
            tokenId: String,
            saleConditions: string,
        }) {
        this.owner_id = ownerId;
        this.approval_id = approvalId;
        this.nft_contract_id = nftContractId;
        this.token_id = tokenId;
        this.sale_conditions = saleConditions;
    }
}

//removes a sale from the market. 
export function internalRemoveSale({
    contract,
    nftContractId,
    tokenId
}:{ 
    contract: Contract, 
    nftContractId: string, 
    tokenId: string 
}) {
    //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
    assertOneYocto();
    
    //get the sale object as the return value from removing the sale internally
    let sale = internallyRemoveSale(contract, nftContractId, tokenId);

    //get the predecessor of the call and make sure they're the owner of the sale
    let ownerId = near.predecessorAccountId();

    //assert that the owner of the sale is the same as the caller of the function
    assert(ownerId == sale.owner_id, "only the owner of the sale can remove it");
}

//updates the price for a sale on the market
export function internalUpdatePrice({
    contract,
    nftContractId,
    tokenId,
    price
}:{ 
    contract: Contract, 
    nftContractId: string, 
    tokenId: string, 
    price: string 
}) {
    //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
    assertOneYocto();

    //create the unique sale ID from the nft contract and token
    let contractAndTokenId = `${nftContractId}${DELIMETER}${tokenId}`;

    //get the sale object from the unique sale ID. If there is no token, panic. 
    let sale = contract.sales.get(contractAndTokenId) as Sale;
    if (sale == null) {
        near.panic("no sale");
    }

    assert(near.predecessorAccountId() == sale.owner_id, "only the owner of the sale can update it");
    //set the sale conditions equal to the passed in price
    sale.sale_conditions = price; 
    //insert the sale back into the map for the unique sale ID
    contract.sales.set(contractAndTokenId, sale);
}

//place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
export function internalOffer({
    contract,
    nftContractId,
    tokenId
}:{
    contract: Contract, 
    nftContractId: string, 
    tokenId: string
}) {
    //get the attached deposit and make sure it's greater than 0
    let deposit = near.attachedDeposit().valueOf();
    assert(deposit > 0, "deposit must be greater than 0");
 
    //get the unique sale ID (contract + DELIMITER + token ID)
    let contractAndTokenId = `${nftContractId}${DELIMETER}${tokenId}`;
    //get the sale object from the unique sale ID. If the sale doesn't exist, panic.
    let sale = contract.sales.get(contractAndTokenId) as Sale;
    if (sale == null) {
        near.panic("no sale");
    }

    //get the buyer ID which is the person who called the function and make sure they're not the owner of the sale
    let buyerId = near.predecessorAccountId();
    assert(buyerId != sale.owner_id, "you can't offer on your own sale");

    //get the u128 price of the token (dot 0 converts from U128 to u128)
    let price = BigInt(sale.sale_conditions);
    //make sure the deposit is greater than the price
    assert(deposit >= price, "deposit must be greater than or equal to price");
    
    //process the purchase (which will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties) 
    processPurchase({contract, nftContractId, tokenId, price: deposit.toString(), buyerId});
}

//private function used when a sale is purchased. 
//this will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties
export function processPurchase({
    contract,
    nftContractId,
    tokenId,
    price,
    buyerId
}:{
    contract: Contract, 
    nftContractId: string, 
    tokenId: string, 
    price: string, 
    buyerId: string
}) {
    //get the sale object by removing the sale
    let sale = internallyRemoveSale(contract, nftContractId, tokenId);

    //initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
    //a payout object used for the market to distribute funds to the appropriate accounts.
    const promise = near.promiseBatchCreate(nftContractId);
    near.promiseBatchActionFunctionCall(
        promise, 
        "nft_transfer_payout", 
        bytes(JSON.stringify({ 
                receiver_id: buyerId, //purchaser (person to transfer the NFT to)
                token_id: tokenId, //token ID to transfer
                approval_id: sale.approval_id, //market contract's approval ID in order to transfer the token on behalf of the owner
                memo: "payout from market", //memo (to include some context)
                /*
                    the price that the token was purchased for. This will be used in conjunction with the royalty percentages
                    for the token in order to determine how much money should go to which account. 
                */
                balance: price, 
                max_len_payout : 10 //the maximum amount of accounts the market can payout at once (this is limited by GAS)
        })), 
        1, // 1 yoctoNEAR
        GAS_FOR_NFT_TRANSFER
    );

    //after the transfer payout has been initiated, we resolve the promise by calling our own resolve_purchase function. 
    //resolve purchase will take the payout object returned from the nft_transfer_payout and actually pay the accounts
    near.promiseThen(
        promise, 
        near.currentAccountId(), 
        "resolve_purchase", 
        bytes(JSON.stringify({
            buyer_id: buyerId, //the buyer and price are passed in incase something goes wrong and we need to refund the buyer
            price: price
        })), 
        0, // no deposit 
        GAS_FOR_ROYALTIES
    );
    return near.promiseReturn(promise);
}

/*
    private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and 
    check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
    it will refund the buyer for the price. 
*/
export function internalResolvePurchase({
    buyerId,
    price
}:{
    buyerId: string, 
    price: string
}) {
    assert(near.currentAccountId() === near.predecessorAccountId(), "Only the contract itself can call this method");

    // checking for payout information returned from the nft_transfer_payout method
    let result = near.promiseResult(0);
    let payout = null;
    if (typeof result === 'string') {
        //if we set the payout_option to None, that means something went wrong and we should refund the buyer
        
        try {
            let payoutOption = JSON.parse(result);
            if (Object.keys(payoutOption.payout).length > 10 || Object.keys(payoutOption.payout).length < 1) {
                //we'll check if length of the payout object is > 10 or it's empty. In either case, we return None
                throw "Cannot have more than 10 royalties";
            //if the payout object is the correct length, we move forward
            } else {
                //we'll keep track of how much the nft contract wants us to payout. Starting at the full price payed by the buyer
                let remainder = BigInt(price);
                //loop through the payout and subtract the values from the remainder. 
                Object.entries(payoutOption.payout).forEach(([key, value], index) => {
                    remainder = remainder - BigInt(value as string);
                });

                //Check to see if the NFT contract sent back a faulty payout that requires us to pay more or too little. 
                //The remainder will be 0 if the payout summed to the total price. The remainder will be 1 if the royalties
                //we something like 3333 + 3333 + 3333.
                if (remainder == BigInt(0) || remainder == BigInt(1)) {
                    //set the payout because nothing went wrong
                    payout = payoutOption.payout;
                } else {
                    //if the remainder was anything but 1 or 0, we return None
                    throw "Payout is not correct";
                }
            }
        } catch (e) {
            near.log(`error parsing payout object ${result}`);
            payout = null;
        }
    }
    
    //if the payout was null, we refund the buyer for the price they payed and return
    if (payout == null) {
        const promise = near.promiseBatchCreate(buyerId);
        near.promiseBatchActionTransfer(promise, BigInt(price))
        return price;
    } 
    // NEAR payouts
    for (let [key, value] of Object.entries(payout)) {
        const promise = near.promiseBatchCreate(key);
        near.promiseBatchActionTransfer(promise, BigInt(value as string))
    }

    //return the price payout out
    return price;
}
'''
'''--- src/market-contract/sale_views.ts ---
import { Contract } from ".";
import { restoreOwners } from "./internal";
import { Sale } from "./sale";
    
//returns the number of sales the marketplace has up (as a string)
export function internalSupplySales({
    contract
}:{
    contract: Contract
}): string {
    //returns the sales object length wrapped as a string
    return contract.sales.len().toString();
}

//returns the number of sales for a given account (result is a string)
export function internalSupplyByOwnerId({
    contract,
    accountId
}:{ 
    contract: Contract, 
    accountId: string
}): string {
    //get the set of sales for the given owner Id
    let byOwnerId = restoreOwners(contract.byOwnerId.get(accountId));
    //if there as some set, we return the length but if there wasn't a set, we return 0
    if (byOwnerId == null) {
        return "0"
    }

    return byOwnerId.len().toString();
}

//returns paginated sale objects for a given account. (result is a vector of sales)
export function internalSalesByOwnerId({
    contract,
    accountId,
    fromIndex,
    limit
}:{ 
    contract: Contract, 
    accountId: string, 
    fromIndex?: string, 
    limit?: number
}): Sale[] {
    //get the set of token IDs for sale for the given account ID
    let tokenSet = restoreOwners(contract.byOwnerId.get(accountId));

    //if there was no set, we return an empty array
    if (tokenSet == null) {
        return [];
    }
    
    //where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index
    let start = fromIndex ? parseInt(fromIndex) : 0;
    //take the first "limit" elements in the array. If we didn't specify a limit, use 50
    let max = limit ? limit : 50;

    let keys = tokenSet.toArray();
    let sales: Sale[] = []
    for(let i = start; i < max; i++) {
        if(i >= keys.length) {
            break;
        }
        let sale = contract.sales.get(keys[i]) as Sale; 
        if (sale != null) {
            sales.push(sale);
        }
    }
    return sales;
}

//get the number of sales for an nft contract. (returns a string)
export function internalSupplyByNftContractId({
    contract,
    nftContractId
}:{ 
    contract: Contract, 
    nftContractId: string
}): string {
    //get the set of tokens for associated with the given nft contract
    let byNftContractId = restoreOwners(contract.byNftContractId.get(nftContractId));
    //if there as some set, we return the length but if there wasn't a set, we return 0
    if (byNftContractId == null) {
        return "0"
    }

    return byNftContractId.len().toString();
}

//returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
export function internalSalesByNftContractId({
    contract,
    accountId,
    fromIndex,
    limit
}:{    
    contract: Contract, 
    accountId: string, 
    fromIndex?: string, 
    limit?: number
}): Sale[] {
    //get the set of token IDs for sale for the given contract ID
    let tokenSet = restoreOwners(contract.byNftContractId.get(accountId));

    //if there was no set, we return an empty array
    if (tokenSet == null) {
        return [];
    }
    
    //where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index
    let start = fromIndex ? parseInt(fromIndex) : 0;
    //take the first "limit" elements in the array. If we didn't specify a limit, use 50
    let max = limit ? limit : 50;

    let keys = tokenSet.toArray();
    let sales: Sale[] = []
    for(let i = start; i < max; i++) {
        if(i >= keys.length) {
            break;
        }
        let sale = contract.sales.get(keys[i]) as Sale; 
        if (sale != null) {
            sales.push(sale);
        }
    }
    return sales;
}

//get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
export function internalGetSale({
    contract,
    nftContractToken,
}:{
    contract: Contract, 
    nftContractToken: string
}): Sale {
    //try and get the sale object for the given unique sale ID. Will return an option since
    //we're not guaranteed that the unique sale ID passed in will be valid.n);
    return contract.sales.get(nftContractToken) as Sale;
}

'''
'''--- src/nft-contract/approval.ts ---
// @ts-nocheck
import { assert, bytes, near } from "near-sdk-js";
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from ".";
import { assertAtLeastOneYocto, assertOneYocto, bytesForApprovedAccountId, internalAddTokenToOwner, refundDeposit, refundApprovedAccountIds, refundApprovedAccountIdsIter } from "./internal";
import { Token } from "./metadata";

const GAS_FOR_NFT_ON_APPROVE = 35_000_000_000_000;

//approve an account ID to transfer a token on your behalf
export function internalNftApprove({
    contract,
    tokenId,
    accountId,
    msg
}:{ 
    contract: Contract, 
    tokenId: string, 
    accountId: string, 
    msg: string 
}) {
    /*
        FILL THIS IN
    */
}

//check if the passed in account has access to approve the token ID
export function internalNftIsApproved({
    contract,
    tokenId,
    approvedAccountId,
    approvalId
}:{ 
    contract: Contract, 
    tokenId: string,
    approvedAccountId: string, 
    approvalId: number 
}) {
    /*
        FILL THIS IN
    */
}

//revoke a specific account from transferring the token on your behalf
export function internalNftRevoke({
    contract,
    tokenId,
    accountId
}:{ 
    contract: Contract, 
    tokenId: string, 
    accountId: string 
}) {
    /*
        FILL THIS IN
    */
}

//revoke all accounts from transferring the token on your behalf
export function internalNftRevokeAll({
    contract,
    tokenId
}:{ 
    contract: Contract, 
    tokenId: string 
}) {
    /*
        FILL THIS IN
    */
}
'''
'''--- src/nft-contract/enumeration.ts ---
// @ts-nocheck
import { near, UnorderedSet } from 'near-sdk-js'
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from '.'
import { restoreOwners } from './internal'
import { JsonToken } from './metadata'
import { internalNftToken } from './nft_core'

//Query for the total supply of NFTs on the contract
export function internalTotalSupply({ contract }: { contract: Contract }): number {
	/*
        FILL THIS IN
    */
}

//Query for nft tokens on the contract regardless of the owner using pagination
export function internalNftTokens({
	contract,
	fromIndex,
	limit,
}: {
	contract: Contract
	fromIndex?: string
	limit?: number
}): JsonToken[] {
	/*
        FILL THIS IN
    */
}

//get the total supply of NFTs for a given owner
export function internalSupplyForOwner({
	contract,
	accountId,
}: {
	contract: Contract
	accountId: string
}): number {
	/*
        FILL THIS IN
    */
}

//Query for all the tokens for an owner
export function internalTokensForOwner({
	contract,
	accountId,
	fromIndex,
	limit,
}: {
	contract: Contract
	accountId: string
	fromIndex?: string
	limit?: number
}): JsonToken[] {
	/*
        FILL THIS IN
    */
	//get the set of tokens for the passed in owner
	let tokenSet = restoreOwners(contract.tokensPerOwner.get(accountId))

	//if there isn't a set of tokens for the passed in account ID, we'll return 0
	if (tokenSet == null) {
		return []
	}

	//where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index
	let start = fromIndex ? parseInt(fromIndex) : 0
	//take the first "limit" elements in the array. If we didn't specify a limit, use 50
	let max = limit ? limit : 50

	let keys = tokenSet.toArray()
	let tokens: JsonToken[] = []
	for (let i = start; i < max; i++) {
		if (i >= keys.length) break

		let token = internalNftToken({ contract, tokenId: keys[i] })
		tokens.push(token)
	}
	return tokens
}

'''
'''--- src/nft-contract/index.ts ---
// @ts-nocheck
import {
	NearContract,
	NearBindgen,
	near,
	call,
	view,
	LookupMap,
	UnorderedMap,
	Vector,
	UnorderedSet,
} from 'near-sdk-js'
import {
	NFTContractMetadata,
	Token,
	TokenMetadata,
	internalNftMetadata,
} from './metadata'
import { internalMint } from './mint'
import {
	internalNftTokens,
	internalSupplyForOwner,
	internalTokensForOwner,
	internalTotalSupply,
} from './enumeration'
import {
	internalNftToken,
	internalNftTransfer,
	internalNftTransferCall,
	internalResolveTransfer,
} from './nft_core'
import {
	internalNftApprove,
	internalNftIsApproved,
	internalNftRevoke,
	internalNftRevokeAll,
} from './approval'
import { internalNftPayout, internalNftTransferPayout } from './royalty'

/// This spec can be treated like a version of the standard.
export const NFT_METADATA_SPEC = 'nft-1.0.0'

/// This is the name of the NFT standard we're using
export const NFT_STANDARD_NAME = 'nep171'

@NearBindgen
export class Contract extends NearContract {
	/*
        FILL THIS IN
    */
	owner_id: String
	tokensPerOwner: LookupMap
	tokensById: LookupMap
	tokenMetadataById: UnorderedMap
	metadata: NFTContractMetadata
	//keeps track of all the token IDs for a given account
	// tokensPerOwner: LookupMap<AccountId, UnorderedSet<TokenId>>;

	//keeps track of the token struct for a given token ID
	// tokensById: LookupMap<TokenId, Token>;

	//keeps track of the token metadata for a given token ID
	// tokenMetadataById: UnorderedMap<TokenId, TokenMetadata>;

	/*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id. 
    */
	constructor({
		owner_id,
		metadata = {
			spec: 'nft-1.0.0',
			name: 'NFT Tutorial Contract',
			symbol: 'GOTEAM',
		},
	}) {
		/*
        FILL THIS IN
    */
		super()
		this.owner_id = owner_id
		this.tokensPerOwner = new LookupMap('tokensPerOwner') // accountID -> Set<token_id> that the account owns
		this.tokensById = new LookupMap('tokensById') // token_id -> Token Object
		this.tokenMetadataById = new UnorderedMap('tokenMetadataById') // token_id -> TokenMetadata Object
		this.metadata = metadata
	}

	default() {
		return new Contract({ owner_id: '' })
	}

	/*
        MINT
    */
	@call
	nft_mint({ token_id, metadata, receiver_id, perpetual_royalties }) {
		return internalMint({
			contract: this,
			tokenId: token_id,
			metadata: metadata,
			receiverId: receiver_id,
			perpetualRoyalties: perpetual_royalties,
		})
	}

	/*
        CORE
    */
	@view
	//get the information for a specific token ID
	nft_token({ token_id }) {
		return internalNftToken({ contract: this, tokenId: token_id })
	}

	@call
	//implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver.
	nft_transfer({ receiver_id, token_id, approval_id, memo }) {
		return internalNftTransfer({
			contract: this,
			receiverId: receiver_id,
			tokenId: token_id,
			approvalId: approval_id,
			memo: memo,
		})
	}

	@call
	//implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract
	nft_transfer_call({ receiver_id, token_id, approval_id, memo, msg }) {
		return internalNftTransferCall({
			contract: this,
			receiverId: receiver_id,
			tokenId: token_id,
			approvalId: approval_id,
			memo: memo,
			msg: msg,
		})
	}

	@call
	//resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
	//returns true if the token was successfully transferred to the receiver_id
	nft_resolve_transfer({
		authorized_id,
		owner_id,
		receiver_id,
		token_id,
		approved_account_ids,
		memo,
	}) {
		return internalResolveTransfer({
			contract: this,
			authorizedId: authorized_id,
			ownerId: owner_id,
			receiverId: receiver_id,
			tokenId: token_id,
			approvedAccountIds: approved_account_ids,
			memo: memo,
		})
	}

	/*
        APPROVALS
    */
	@view
	//check if the passed in account has access to approve the token ID
	nft_is_approved({ token_id, approved_account_id, approval_id }) {
		return internalNftIsApproved({
			contract: this,
			tokenId: token_id,
			approvedAccountId: approved_account_id,
			approvalId: approval_id,
		})
	}

	@call
	//approve an account ID to transfer a token on your behalf
	nft_approve({ token_id, account_id, msg }) {
		return internalNftApprove({
			contract: this,
			tokenId: token_id,
			accountId: account_id,
			msg: msg,
		})
	}

	/*
        ROYALTY
    */
	@view
	//calculates the payout for a token given the passed in balance. This is a view method
	nft_payout({ token_id, balance, max_len_payout }) {
		return internalNftPayout({
			contract: this,
			tokenId: token_id,
			balance: balance,
			maxLenPayout: max_len_payout,
		})
	}

	@call
	//transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance.
	nft_transfer_payout({
		receiver_id,
		token_id,
		approval_id,
		memo,
		balance,
		max_len_payout,
	}) {
		return internalNftTransferPayout({
			contract: this,
			receiverId: receiver_id,
			tokenId: token_id,
			approvalId: approval_id,
			memo: memo,
			balance: balance,
			maxLenPayout: max_len_payout,
		})
	}

	@call
	//approve an account ID to transfer a token on your behalf
	nft_revoke({ token_id, account_id }) {
		return internalNftRevoke({ contract: this, tokenId: token_id, accountId: account_id })
	}

	@call
	//approve an account ID to transfer a token on your behalf
	nft_revoke_all({ token_id }) {
		return internalNftRevokeAll({ contract: this, tokenId: token_id })
	}

	/*
        ENUMERATION
    */
	@view
	//Query for the total supply of NFTs on the contract
	nft_total_supply() {
		return internalTotalSupply({ contract: this })
	}

	@view
	//Query for nft tokens on the contract regardless of the owner using pagination
	nft_tokens({ from_index, limit }) {
		return internalNftTokens({ contract: this, fromIndex: from_index, limit: limit })
	}

	@view
	//get the total supply of NFTs for a given owner
	nft_tokens_for_owner({ account_id, from_index, limit }) {
		return internalTokensForOwner({
			contract: this,
			accountId: account_id,
			fromIndex: from_index,
			limit: limit,
		})
	}

	@view
	//Query for all the tokens for an owner
	nft_supply_for_owner({ account_id }) {
		return internalSupplyForOwner({ contract: this, accountId: account_id })
	}

	/*
        METADATA
    */
	@view
	//Query for all the tokens for an owner
	nft_metadata() {
		return internalNftMetadata({ contract: this })
	}
}

'''
'''--- src/nft-contract/internal.ts ---
import { assert, near, UnorderedSet, Vector } from 'near-sdk-js'
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from '.'
import { Token } from './metadata'

// Gets a collection and deserializes it into a set that can be used.
export function restoreOwners(collection) {
	if (collection == null) {
		return null
	}
	return UnorderedSet.deserialize(collection as UnorderedSet)
}

//refund the initial deposit based on the amount of storage that was used up
export function refundDeposit(storageUsed: bigint) {
	//get how much it would cost to store the information
	let requiredCost = storageUsed * near.storageByteCost().valueOf()
	//get the attached deposit
	let attachedDeposit = near.attachedDeposit().valueOf()

	//make sure that the attached deposit is greater than or equal to the required cost
	assert(
		requiredCost <= attachedDeposit,
		`Must attach ${requiredCost} yoctoNEAR to cover storage`
	)

	//get the refund amount from the attached deposit - required cost
	let refund = attachedDeposit - requiredCost
	near.log(`Refunding ${refund} yoctoNEAR`)

	//if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
	if (refund > 1) {
		// Send the money to the beneficiary (TODO: don't use batch actions)
		const promise = near.promiseBatchCreate(near.predecessorAccountId())
		near.promiseBatchActionTransfer(promise, refund)
	}
}

//add a token to the set of tokens an owner has
export function internalAddTokenToOwner(
	contract: Contract,
	accountId: string,
	tokenId: string
) {
	//get the set of tokens for the given account
	let tokenSet = restoreOwners(contract.tokensPerOwner.get(accountId))

	if (tokenSet == null) {
		//if the account doesn't have any tokens, we create a new unordered set
		tokenSet = new UnorderedSet('tokensPerOwner' + accountId.toString())
	}

	//we insert the token ID into the set
	tokenSet.set(tokenId)

	//we insert that set for the given account ID.
	contract.tokensPerOwner.set(accountId, tokenSet)
}

'''
'''--- src/nft-contract/metadata.ts ---
// @ts-nocheck
import { Contract } from '.'

//defines the payout type we'll be returning as a part of the royalty standards.
export class Payout {
	payout: { [accountId: string]: bigint }
	constructor({ payout }: { payout: { [accountId: string]: bigint } }) {
		this.payout = payout
	}
}

export class NFTContractMetadata {
	/*
        FILL THIS IN
    */
	spec: string
	name: string
	symbol: string
	icon?: string
	base_uri?: string
	reference?: string
	reference_hash?: string

	constructor({
		spec,
		name,
		symbol,
		icon,
		baseUri,
		reference,
		referenceHash,
	}: {
		spec: string
		name: string
		symbol: string
		icon?: string
		baseUri?: string
		reference?: string
		referenceHash?: string
	}) {
		this.spec = spec // required, essentially a version like "nft-1.0.0"
		this.name = name // required, ex. "Mosaics"
		this.symbol = symbol // required, ex. "MOSAIC"
		this.icon = icon // Data URL
		this.base_uri = baseUri // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
		this.reference = reference // URL to a JSON file with more info
		this.reference_hash = referenceHash // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
	}
}

export class TokenMetadata {
	/*
        FILL THIS IN
    */
	title?: string
	description?: string
	media?: string
	media_hash?: string
	copies?: number
	issued_at?: string
	expires_at?: string
	starts_at?: string
	updated_at?: string
	extra?: string
	reference?: string
	reference_hash?: string

	constructor({
		title,
		description,
		media,
		mediaHash,
		copies,
		issuedAt,
		expiresAt,
		startsAt,
		updatedAt,
		extra,
		reference,
		referenceHash,
	}: {
		title?: string
		description?: string
		media?: string
		mediaHash?: string
		copies?: number
		issuedAt?: string
		expiresAt?: string
		startsAt?: string
		updatedAt?: string
		extra?: string
		reference?: string
		referenceHash?: string
	}) {
		this.title = title // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
		this.description = description // free-form description
		this.media = media // URL to associated media, preferably to decentralized, content-addressed storage
		this.media_hash = mediaHash // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
		this.copies = copies // number of copies of this set of metadata in existence when token was minted.
		this.issued_at = issuedAt // ISO 8601 datetime when token was issued or minted
		this.expires_at = expiresAt // ISO 8601 datetime when token expires
		this.starts_at = startsAt // ISO 8601 datetime when token starts being valid
		this.updated_at = updatedAt // ISO 8601 datetime when token was last updated
		this.extra = extra // anything extra the NFT wants to store on-chain. Can be stringified JSON.
		this.reference = reference // URL to an off-chain JSON file with more info.
		this.reference_hash = referenceHash // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
	}
}

export class Token {
	/*
        FILL THIS IN
    */
	owner_id: string

	constructor({ ownerId }: { ownerId: string }) {
		//owner of the token
		this.owner_id = ownerId
	}
}

//The Json token is what will be returned from view calls.
export class JsonToken {
	/*
        FILL THIS IN
    */
	token_id: string
	owner_id: string
	metadata: TokenMetadata

	constructor({
		tokenId,
		ownerId,
		metadata,
	}: {
		tokenId: string
		ownerId: string
		metadata: TokenMetadata
	}) {
		//token ID
		this.token_id = tokenId
		//owner of the token
		this.owner_id = ownerId
		//token metadata
		this.metadata = metadata
	}
}

//get the information for a specific token ID
export function internalNftMetadata({
	contract,
}: {
	contract: Contract
}): NFTContractMetadata {
	/*
        FILL THIS IN
    */
	return contract.metadata
}

'''
'''--- src/nft-contract/mint.ts ---
// @ts-nocheck
import { assert, near } from 'near-sdk-js'
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from '.'
import { internalAddTokenToOwner, refundDeposit } from './internal'
import { Token, TokenMetadata } from './metadata'

export function internalMint({
	contract,
	tokenId,
	metadata,
	receiverId,
	perpetualRoyalties,
}: {
	contract: Contract
	tokenId: string
	metadata: TokenMetadata
	receiverId: string
	perpetualRoyalties: { [key: string]: number }
}): void {
	/*
        FILL THIS IN
    */
	//measure the initial storage being used on the contract TODO
	let initialStorageUsage = near.storageUsage()

	//specify the token struct that contains the owner ID
	let token = new Token({
		//set the owner ID equal to the receiver ID passed into the function
		ownerId: receiverId,
	})

	//insert the token ID and token struct and make sure that the token doesn't exist
	assert(!contract.tokensById.containsKey(tokenId), 'Token already exists')
	contract.tokensById.set(tokenId, token)

	//insert the token ID and metadata
	contract.tokenMetadataById.set(tokenId, metadata)

	//call the internal method for adding the token to the owner
	internalAddTokenToOwner(contract, token.owner_id, tokenId)

	//calculate the required storage which was the used - initial TODO
	let requiredStorageInBytes =
		near.storageUsage().valueOf() - initialStorageUsage.valueOf()

	//refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
	refundDeposit(requiredStorageInBytes)
}

'''
'''--- src/nft-contract/nft_core.ts ---
// @ts-nocheck
import { assert, bytes, near } from 'near-sdk-js'
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from '.'
import {
	assertOneYocto,
	internalAddTokenToOwner,
	internalRemoveTokenFromOwner,
	internalTransfer,
	refundDeposit,
	refundApprovedAccountIds,
} from './internal'
import { JsonToken, Token, TokenMetadata } from './metadata'

const GAS_FOR_RESOLVE_TRANSFER = 40_000_000_000_000
const GAS_FOR_NFT_ON_TRANSFER = 35_000_000_000_000

//get the information for a specific token ID
export function internalNftToken({
	contract,
	tokenId,
}: {
	contract: Contract
	tokenId: string
}) {
	/*
        FILL THIS IN
    */
	let token = contract.tokensById.get(tokenId) as Token
	//if there wasn't a token ID in the tokens_by_id collection, we return None
	if (token == null) {
		return null
	}

	//if there is some token ID in the tokens_by_id collection
	//we'll get the metadata for that token
	let metadata = contract.tokenMetadataById.get(tokenId) as TokenMetadata

	//we return the JsonToken
	let jsonToken = new JsonToken({
		tokenId: tokenId,
		ownerId: token.owner_id,
		metadata,
	})
	return jsonToken
}

//implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver.
export function internalNftTransfer({
	contract,
	receiverId,
	tokenId,
	approvalId,
	memo,
}: {
	contract: Contract
	receiverId: string
	tokenId: string
	approvalId: number
	memo: string
}) {
	/*
        FILL THIS IN
    */
}

//implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract
export function internalNftTransferCall({
	contract,
	receiverId,
	tokenId,
	approvalId,
	memo,
	msg,
}: {
	contract: Contract
	receiverId: string
	tokenId: string
	approvalId: number
	memo: string
	msg: string
}) {
	/*
        FILL THIS IN
    */
}

//resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
//returns true if the token was successfully transferred to the receiver_id
export function internalResolveTransfer({
	contract,
	authorizedId,
	ownerId,
	receiverId,
	tokenId,
	approvedAccountIds,
	memo,
}: {
	contract: Contract
	authorizedId: string
	ownerId: string
	receiverId: string
	tokenId: string
	approvedAccountIds: { [key: string]: number }
	memo: string
}) {
	/*
        FILL THIS IN
    */
}

'''
'''--- src/nft-contract/royalty.ts ---
// @ts-nocheck
import { assert, near } from "near-sdk-js";
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from ".";
import { assertAtLeastOneYocto, assertOneYocto, bytesForApprovedAccountId, internalAddTokenToOwner, internalTransfer, refundDeposit, refundApprovedAccountIds, refundApprovedAccountIdsIter, royaltyToPayout } from "./internal";
import { Token } from "./metadata";

//calculates the payout for a token given the passed in balance. This is a view method
export function internalNftPayout({
    contract,
    tokenId,
    balance,
    maxLenPayout
}:{
    contract: Contract, 
    tokenId: string,
    balance: bigint, 
    maxLenPayout: number,
}): { payout: {[key: string]: string }} {
    /*
        FILL THIS IN
    */
}

//transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. 
export function internalNftTransferPayout({
    contract,
    receiverId,
    tokenId,
    approvalId,
    memo,
    balance,
    maxLenPayout
}:{
    contract: Contract, 
    receiverId: string, 
    tokenId: string,
    approvalId: number,
    memo: string,
    balance: bigint,
    maxLenPayout: number,
}): { payout: {[key: string]: string }} {
    /*
        FILL THIS IN
    */
}
'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
        "target": "es5",
        "noEmit": true
    },
    "exclude": [
        "node_modules"
    ],
}
'''