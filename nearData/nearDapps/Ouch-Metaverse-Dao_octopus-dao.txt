*GitHub Repository "Ouch-Metaverse-Dao/octopus-dao"*

'''--- Cargo.toml ---
[package]
name = "octopus-dao"
version = "0.3.0"
authors = ["Octopus Network"]
edition = "2021"

[dev-dependencies]
anyhow = "1.0"
hex-literal = "0.3.1"
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
near-primitives = "0.5.0"
near-units = "0.2.0"
hex = "0.4.2"
num-format = "0.4.0"
secp256k1-test = { package = "secp256k1", version = "0.20.3", features = ["rand-std", "recovery"] }
beefy-light-client = { git = "https://github.com/octopus-network/beefy-light-client.git", branch = "main" }
codec = { package = "parity-scale-codec", version = "3.0.0", default-features = false, features = ["derive"] }
beefy-merkle-tree = { git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v0.9.12", features = ["keccak"], default-features = false }
# remember to include related mock contracts
appchain-anchor = { git = "https://github.com/octopus-network/octopus-appchain-anchor.git", branch = "v2.3.0" }
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.4"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "octopus-council",
]

'''
'''--- README.md ---
# Octopus DAO

The DAO implementation of Octopus Network.

## Octopus Smart Contracts Structure

On NEAR protocol, the Octopus Network infrastructure is consisted of a set of smart contracts. The structure is shown below:

![Smart Contracts Structure](/images/near-contract-accounts.png)

* `octopus-registry.near` - A top-level account on NEAR protocol. The [Octopus Appchain Registry](https://github.com/octopus-network/octopus-appchain-registry) contract lived in this account. This is also the root account of Octopus Network infrastructure.
* `<appchain id>.octopus-registry.near` - A sub-account of octopus appchain registry account. The [Octopus Appchain Anchor](https://github.com/octopus-network/octopus-appchain-anchor) contract lived in this account. Each Octopus Appchain has a corresponding anchor contract, named by its `appchain id`.
* `<appchain id>-token.near` - A top-level account on NEAR protocol. The [Wrapped Appchain Token](https://github.com/octopus-network/wrapped-appchain-token) contract lived in this account. Each Octopus Appchain has a corresponding token contract, named by its `appchain id` plus `-token`.
* `<NFT class name>.<appchain id>.octopus-registry.near` - A sub-account of octopus appchain anchor account. The [Wrapped Appchain NFT](https://github.com/octopus-network/wrapped-appchain-nft) contract lived in this account. This contract is deployed automatically when register a NFT class in `Octopus Appchain Anchor`. Each class of wrapped appchain NFT has a corresponding contract of this template, named by its `class name`.
* `near-receiver.<appchain id>.octopus-registry.near` - A sub-account of octopus appchain anchor account. A contract for receiving native near token for cross-chain transfer lived in this contract. _**(under development)**_
* `wat-faucet.<appchain id>.octopus-registry.near` - A sub-account of octopus appchain anchor account. A contract for automatically issuing wrapped appchain token to new validator of an appchain lived in this account. The source code is [inside of octopus appchain anchor](https://github.com/octopus-network/octopus-appchain-anchor/tree/main/wat-faucet).
* `octopus-dao.sputnik-dao.near` - A sub-account of [sputnik-dao](https://github.com/near-daos/sputnik-dao-contract) account lived in NEAR protocol. This contract includes all basic rules and operations for the operation of Octopus DAO.
* `octopus-council.octopus-registry.near` - A sub-account of octopus registry account. A contract for automatically managing the members of `Octopus Council` will live in this account.

## Octopus Council Contract

The Octopus Council consists of a part of all validators of all appchains lived in Octopus Network.

The top `X` of validators with the most stake in all appchains will automatically become the members of Octopus Council. The number `X` is a setting in Octopus Council contract which can be changed in future by a proposal in Octopus DAO. And the stake of a validator is the total stake of his/her stake (including all of the delegation) in all appchains lived in Octopus Network.

The octopus council contract will sort all validators in descending order based on their total stake in all appchains. The sequence is:

![Sync Validators Stake](/images/sync-validators-stake.png)

This contract has a set of view functions to show the status of octopus council.

## Octopus DAO Contract

The DAO contract implemented using [sputnik-dao](https://github.com/near-daos/sputnik-dao-contract).

The proposal kinds defined in sputnik DAO are as the following:

Proposal Kind | Description
---- | ----
ChangeConfig | Change the DAO config.
ChangePolicy | Change the full policy.
AddMemberToRole | Add member to given role in the policy. This is short cut to updating the whole policy.
RemoveMemberFromRole | Remove member to given role in the policy. This is short cut to updating the whole policy.
FunctionCall | Calls `receiver_id` with list of method names in a single promise. Allows this contract to execute any arbitrary set of actions in other contracts.
UpgradeSelf | Upgrade this contract with given hash from blob store.
UpgradeRemote | Upgrade another contract, by calling method with the code from given hash from blob store.
Transfer | Transfers given amount of `token_id` from this DAO to `receiver_id`. If `msg` is not None, calls `ft_transfer_call` with given `msg`. Fails if this base token. For `ft_transfer` and `ft_transfer_call` `memo` is the `description` of the proposal.
SetStakingContract | Sets staking contract. Can only be proposed if staking contract is not set yet.
AddBounty | Add new bounty.
BountyDone | Indicates that given bounty is done by given user.
Vote | Just a signaling vote, with no execution.
FactoryInfoUpdate | Change information about factory and auto update.
ChangePolicyAddOrUpdateRole | Add new role to the policy. If the role already exists, update it. This is short cut to updating the whole policy.
ChangePolicyRemoveRole | Remove role from the policy. This is short cut to updating the whole policy.
ChangePolicyUpdateDefaultVotePolicy | Update the default vote policy from the policy. This is short cut to updating the whole policy.
ChangePolicyUpdateParameters | Update the parameters from the policy. This is short cut to updating the whole policy.

A initial policy is needed when create the sputnik DAO contract. It is defined as:

Field | Description | Value | Notes
---- | ---- | ---- | ----
roles | List of roles and permissions for them in the current policy. | [`council_permissions`, `council_manager_permissions`] |
default_vote_policy | Default vote policy. Used when given proposal kind doesn't have special policy. | {"weight_kind":"WeightKind::RoleWeight", "quorum":"minimum number of votes", "threshold":"WeightOrRatio::Ratio(1, 2)"} |
proposal_bond | Bond for a proposal. | 0 | 0 NEAR
proposal_period | Expiration period for proposals. | 604800000000000 | 7 days
bounty_bond | Bond for claiming a bounty. | 1000000000000000000000000 | 1 NEAR
bounty_forgiveness_period | Period in which giving up on bounty is not punished. | 86400000000000 | 1 day

The council manager permissions are defined as:

Field | Description | Value | Notes
---- | ---- | ---- | ----
name | Name of the role to display to the user. | council_manager |
kind | Kind of the role: defines which users this permissions apply. | RoleKind::Group({"`account id of Octopus Council contract`"}) |
permissions | Set of actions on which proposals that this role is allowed to execute. | {"ChangePolicyAddOrUpdateRole:\*"} |
vote_policy | For each proposal kind, defines voting policy. | {} |

The council permissions are defined as:

Field | Description | Value | Notes
---- | ---- | ---- | ----
name | Name of the role to display to the user. | council |
kind | Kind of the role: defines which users this permissions apply. | RoleKind::Group({}) | This field is managed by council manager automatically.
permissions | Set of actions on which proposals that this role is allowed to execute. | {"\*:\*"} | Maybe should specify a list of proposal kind and actions.
vote_policy | For each proposal kind, defines voting policy. | {} | Using default vote policy is OK.

'''
'''--- build.sh ---
#!/bin/bash
cargo fmt --all
cargo doc -p octopus-council --no-deps
RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
if [ ! -d "res" ]; then
    mkdir -p "res"
fi
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

if [ "$1" == "test" ]; then
    if [ "$2" == "" ]; then
        RUST_BACKTRACE=1 cargo test --tests -- --nocapture
    else
        RUST_BACKTRACE=1 cargo test $2 -- --nocapture
    fi
fi

'''
'''--- octopus-council/Cargo.toml ---
[package]
name = "octopus-council"
version = "0.3.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

'''
'''--- octopus-council/src/lib.rs ---
mod lookup_array;
mod ranked_lookup_array;
mod storage_migration;
mod sudo_functions;
pub mod types;
mod upgrade;
mod views;

use lookup_array::{IndexedAndClearable, LookupArray};
use near_contract_standards::upgrade::Ownable;
use near_sdk::{
    assert_self,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LookupMap, UnorderedMap, UnorderedSet},
    env, ext_contract,
    json_types::{U128, U64},
    log, near_bindgen,
    serde::{Deserialize, Serialize},
    AccountId, BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseResult,
};
use ranked_lookup_array::{RankValueHolder, RankedLookupArray};
use std::{collections::HashMap, ops::Mul, str::FromStr};
use types::{
    CouncilChangeHistory, CouncilChangeHistoryState, IndexRange, MultiTxsOperationProcessingResult,
    ValidatorStake, ValidatorStakeRecord,
};

const VERSION: &str = "v0.3.0";
/// Constants for gas.
const T_GAS_CAP_FOR_MULTI_TXS_PROCESSING: u64 = 150;
const T_GAS_FOR_ADD_PROPOSAL: u64 = 5;
const T_GAS_FOR_RESOLVE_ADD_PROPOSAL: u64 = 25;
const T_GAS_FOR_ACT_PROPOSAL: u64 = 7;
const T_GAS_FOR_RESOLVE_ACT_PROPOSAL: u64 = 5;

#[ext_contract(ext_self)]
trait ResolverForSelfCallback {
    /// Resolver for adding proposal to DAO contract
    fn resolve_add_proposal(&mut self, change_history: &mut CouncilChangeHistory);
    /// Resolver for acting proposal to DAO contract
    fn resolve_act_proposal(&mut self, change_history: &mut CouncilChangeHistory);
}

/// Storage keys for collections of sub-struct in main contract
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    ValidatorStakes,
    OrderedValidators,
    ValidatorStakeInAppchains(AccountId),
    OctopusCouncilWasm,
    LatestMembers,
    CouncilChangeHistories,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct InternalValidatorStake {
    //
    validator_id: AccountId,
    // key: appchain id, value: total stake in the appchain anchor
    stake_in_appchains: UnorderedMap<String, U128>,
    // total stake in all appchain anchors
    total_stake: U128,
    // the rank of the validator in all validators
    overall_rank: u32,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct OctopusCouncil {
    //
    owner: AccountId,
    //
    appchain_registry_account: AccountId,
    //
    dao_contract_account: AccountId,
    //
    living_appchain_ids: Vec<String>,
    //
    validator_stakes: LookupMap<AccountId, InternalValidatorStake>,
    //
    ranked_validators: RankedLookupArray<AccountId>,
    //
    max_number_of_council_members: u32,
    //
    latest_members: UnorderedSet<AccountId>,
    //
    excluding_validator_accounts: Vec<AccountId>,
    //
    change_histories: LookupArray<CouncilChangeHistory>,
}

#[near_bindgen]
impl OctopusCouncil {
    #[init]
    pub fn new(max_number_of_council_members: u32, dao_contract_account: AccountId) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized.");
        let account_id = String::from(env::current_account_id().as_str());
        let parts = account_id.split(".").collect::<Vec<&str>>();
        assert!(
            parts.len() > 2,
            "This contract must be deployed as a sub-account of octopus appchain registry.",
        );
        let (_first, second) = account_id.split_once(".").unwrap();
        let result = Self {
            owner: env::current_account_id(),
            appchain_registry_account: AccountId::from_str(second).unwrap(),
            dao_contract_account,
            living_appchain_ids: Vec::new(),
            validator_stakes: LookupMap::new(StorageKey::ValidatorStakes),
            ranked_validators: RankedLookupArray::new(StorageKey::OrderedValidators),
            max_number_of_council_members,
            latest_members: UnorderedSet::new(StorageKey::LatestMembers),
            excluding_validator_accounts: Vec::new(),
            change_histories: LookupArray::new(StorageKey::CouncilChangeHistories),
        };
        result
    }
    // Assert that the contract is called by an appchain anchor contract and
    // return the appchain id corresponding to the predecessor account
    fn assert_and_update_living_appchain_ids(&mut self) -> String {
        let account_id = String::from(env::predecessor_account_id().as_str());
        let (first, second) = account_id.split_once(".").expect(
            "This contract can only be called by a sub-account of octopus appchain registry.",
        );
        let appchain_id = first.to_string();
        assert!(
            AccountId::from_str(second)
                .unwrap()
                .eq(&self.appchain_registry_account),
            "This function can only be called by an appchain anchor contract."
        );
        if !self.living_appchain_ids.contains(&appchain_id) {
            self.living_appchain_ids.push(appchain_id.clone());
        }
        appchain_id
    }
    ///
    pub fn sync_validator_stakes_of_anchor(&mut self, stake_records: Vec<ValidatorStakeRecord>) {
        let appchain_id = self.assert_and_update_living_appchain_ids();
        let mut changed = false;
        for stake_record in stake_records {
            let mut validator_stake = self
                .validator_stakes
                .get(&stake_record.validator_id)
                .unwrap_or(InternalValidatorStake::new(&stake_record.validator_id));
            validator_stake.update_stake_record(&appchain_id, &stake_record);
            self.validator_stakes
                .insert(&stake_record.validator_id, &validator_stake);
            changed = self.update_validator_rank_of(&mut validator_stake);
        }
        if changed {
            log!(
                "validators' ranking status has changed: {}",
                near_sdk::serde_json::to_string(&self.ranked_validators.get_slice_of(0, None))
                    .unwrap()
            );
            self.check_and_generate_change_histories();
        } else {
            log!("Validators' ranking status has not changed.")
        }
    }
    // the function will return true if the rank of validator stake has been changed and updated,
    // otherwise return false.
    fn update_validator_rank_of(&mut self, validator_stake: &mut InternalValidatorStake) -> bool {
        let current_index = validator_stake.overall_rank;
        let new_index = match self.ranked_validators.get(current_index) {
            Some(account_id) => {
                assert!(
                    account_id.eq(&validator_stake.validator_id),
                    "Invalid internal state of ordered validators. Account at index '{}' is '{}', but the updating validator is '{}'.",
                    current_index, account_id, validator_stake.validator_id,
                );
                self.ranked_validators.insert(
                    current_index,
                    &validator_stake.validator_id,
                    &mut self.validator_stakes,
                )
            }
            None => self
                .ranked_validators
                .append(&validator_stake.validator_id, &mut self.validator_stakes),
        };
        new_index != current_index
    }
    //
    fn check_and_generate_change_histories(&mut self) {
        let council_members = self
            .ranked_validators
            .get_slice_of(0, Some(self.max_number_of_council_members));
        for account_id in &council_members {
            if !self.latest_members.contains(account_id)
                && !self.excluding_validator_accounts.contains(account_id)
            {
                self.latest_members.insert(account_id);
                let history = self.change_histories.append(&mut CouncilChangeHistory {
                    index: U64::from(0),
                    action: types::CouncilChangeAction::MemberAdded(account_id.clone()),
                    state: CouncilChangeHistoryState::WaitingForApplying,
                    timestamp: U64::from(env::block_timestamp()),
                });
                log!(
                    "Council change history generated: '{}'",
                    near_sdk::serde_json::to_string(&history).unwrap()
                );
            }
        }
        for account_id in &self.latest_members.to_vec() {
            if !council_members.contains(account_id)
                || self.excluding_validator_accounts.contains(account_id)
            {
                self.latest_members.remove(account_id);
                let history = self.change_histories.append(&mut CouncilChangeHistory {
                    index: U64::from(0),
                    action: types::CouncilChangeAction::MemberRemoved(account_id.clone()),
                    state: CouncilChangeHistoryState::WaitingForApplying,
                    timestamp: U64::from(env::block_timestamp()),
                });
                log!(
                    "Council change history generated: '{}'",
                    near_sdk::serde_json::to_string(&history).unwrap()
                );
            }
        }
    }
    ///
    pub fn set_dao_contract_account(&mut self, account_id: AccountId) {
        self.assert_owner();
        self.dao_contract_account = account_id;
    }
    ///
    pub fn apply_change_histories_to_dao_contract(
        &mut self,
        start_index: U64,
    ) -> MultiTxsOperationProcessingResult {
        assert!(
            self.dao_contract_account.to_string().len() > 0,
            "Invalid account id of DAO contract."
        );
        let index_range = self.change_histories.index_range();
        let mut index = start_index.0;
        while index <= index_range.end_index.0
            && env::used_gas() < Gas::ONE_TERA.mul(T_GAS_CAP_FOR_MULTI_TXS_PROCESSING)
        {
            let mut change_history = self.change_histories.get(&index).unwrap();
            match change_history.state {
                CouncilChangeHistoryState::WaitingForApplying => {
                    self.add_proposal_to_dao_contract(&mut change_history)
                }
                CouncilChangeHistoryState::ProposalAdded(_) => {
                    self.act_proposal_on_dao_contract(&mut change_history)
                }
                _ => (),
            }
            index += 1;
        }
        if index > index_range.end_index.0 {
            MultiTxsOperationProcessingResult::Ok
        } else {
            MultiTxsOperationProcessingResult::NeedMoreGas
        }
    }
    //
    fn add_proposal_to_dao_contract(&mut self, change_history: &mut CouncilChangeHistory) {
        #[derive(Serialize, Deserialize, Clone)]
        #[serde(crate = "near_sdk::serde")]
        enum ProposalKind {
            /// Add member to given role in the policy. This is short cut to updating the whole policy.
            AddMemberToRole { member_id: AccountId, role: String },
            /// Remove member to given role in the policy. This is short cut to updating the whole policy.
            RemoveMemberFromRole { member_id: AccountId, role: String },
        }
        #[derive(Serialize, Deserialize, Clone)]
        #[serde(crate = "near_sdk::serde")]
        struct ProposalInput {
            /// Description of this proposal.
            pub description: String,
            /// Kind of proposal with relevant information.
            pub kind: ProposalKind,
        }
        #[derive(Serialize, Deserialize, Clone)]
        #[serde(crate = "near_sdk::serde")]
        struct Input {
            pub proposal: ProposalInput,
        }
        let args = match &change_history.action {
            types::CouncilChangeAction::MemberAdded(account_id) => Input {
                proposal: ProposalInput {
                    description: format!(
                        "Add '{}' to council based on the rule in contract '{}'.",
                        account_id,
                        env::current_account_id()
                    ),
                    kind: ProposalKind::AddMemberToRole {
                        member_id: account_id.clone(),
                        role: "council".to_string(),
                    },
                },
            },
            types::CouncilChangeAction::MemberRemoved(account_id) => Input {
                proposal: ProposalInput {
                    description: format!(
                        "Remove '{}' from council based on the rule in contract '{}'.",
                        account_id,
                        env::current_account_id()
                    ),
                    kind: ProposalKind::RemoveMemberFromRole {
                        member_id: account_id.clone(),
                        role: "council".to_string(),
                    },
                },
            },
        };
        let args = near_sdk::serde_json::to_vec(&args)
            .expect("Failed to serialize the cross contract args using JSON.");
        Promise::new(self.dao_contract_account.clone())
            .function_call(
                "add_proposal".to_string(),
                args,
                0,
                Gas::ONE_TERA.mul(T_GAS_FOR_ADD_PROPOSAL),
            )
            .then(
                ext_self::ext(env::current_account_id())
                    .with_attached_deposit(0)
                    .with_static_gas(Gas::ONE_TERA.mul(T_GAS_FOR_RESOLVE_ADD_PROPOSAL))
                    .with_unused_gas_weight(0)
                    .resolve_add_proposal(change_history),
            );
    }
    //
    fn act_proposal_on_dao_contract(&mut self, change_history: &mut CouncilChangeHistory) {
        #[derive(Serialize, Deserialize, Clone)]
        #[serde(crate = "near_sdk::serde")]
        enum Action {
            /// Vote to approve given proposal or bounty.
            VoteApprove,
        }
        #[derive(Serialize, Deserialize, Clone)]
        #[serde(crate = "near_sdk::serde")]
        struct Input {
            pub id: u64,
            pub action: Action,
            pub memo: Option<String>,
        }
        let args = Input {
            id: match change_history.state {
                CouncilChangeHistoryState::ProposalAdded(proposal_id) => proposal_id,
                _ => panic!(
                    "Invalid state of change history: '{}'",
                    near_sdk::serde_json::to_string(change_history).unwrap()
                ),
            },
            action: Action::VoteApprove,
            memo: Some(format!(
                "Automatically vote approve by '{}'.",
                env::current_account_id()
            )),
        };
        let args = near_sdk::serde_json::to_vec(&args)
            .expect("Failed to serialize the cross contract args using JSON.");
        Promise::new(self.dao_contract_account.clone())
            .function_call(
                "act_proposal".to_string(),
                args,
                0,
                Gas::ONE_TERA.mul(T_GAS_FOR_ACT_PROPOSAL),
            )
            .then(
                ext_self::ext(env::current_account_id())
                    .with_attached_deposit(0)
                    .with_static_gas(Gas::ONE_TERA.mul(T_GAS_FOR_RESOLVE_ACT_PROPOSAL))
                    .with_unused_gas_weight(0)
                    .resolve_act_proposal(change_history),
            );
    }
    ///
    pub fn set_max_number_of_council_members(&mut self, max_number_of_council_members: u32) {
        self.assert_owner();
        assert!(
            self.max_number_of_council_members != max_number_of_council_members,
            "The value is not changed."
        );
        self.max_number_of_council_members = max_number_of_council_members;
        //
        self.check_and_generate_change_histories();
    }
    ///
    pub fn set_excluding_validator_accounts(&mut self, accounts: Vec<AccountId>) {
        self.assert_owner();
        self.excluding_validator_accounts = accounts;
        //
        self.check_and_generate_change_histories();
    }
}

impl Ownable for OctopusCouncil {
    //
    fn get_owner(&self) -> AccountId {
        self.owner.clone()
    }
    //
    fn set_owner(&mut self, owner: AccountId) {
        self.owner = owner;
    }
}

impl InternalValidatorStake {
    //
    pub fn new(validator_id: &AccountId) -> Self {
        Self {
            validator_id: validator_id.clone(),
            stake_in_appchains: UnorderedMap::new(StorageKey::ValidatorStakeInAppchains(
                validator_id.clone(),
            )),
            total_stake: U128(0),
            overall_rank: u32::MAX,
        }
    }
    //
    pub fn update_stake_record(
        &mut self,
        appchain_id: &String,
        stake_record: &ValidatorStakeRecord,
    ) {
        assert_eq!(
            self.validator_id, stake_record.validator_id,
            "Mismatch validator id in `ValidatorStakeRecord`."
        );
        let old_value = self.stake_in_appchains.get(&appchain_id).unwrap_or(U128(0));
        self.stake_in_appchains
            .insert(appchain_id, &stake_record.total_stake);
        self.total_stake.0 = self.total_stake.0 - old_value.0 + stake_record.total_stake.0;
    }
    //
    pub fn to_json_type(&self) -> ValidatorStake {
        let mut stake_in_appchains = HashMap::<String, U128>::new();
        for appchain_id in self.stake_in_appchains.keys() {
            stake_in_appchains.insert(
                appchain_id.clone(),
                self.stake_in_appchains.get(&appchain_id).unwrap(),
            );
        }
        ValidatorStake {
            validator_id: self.validator_id.clone(),
            stake_in_appchains,
            total_stake: self.total_stake.clone(),
            overall_rank: self.overall_rank,
        }
    }
}

impl RankValueHolder<AccountId> for LookupMap<AccountId, InternalValidatorStake> {
    //
    fn get_rank_value_of(&self, member: &AccountId) -> u128 {
        self.get(&member).unwrap().total_stake.0
    }
    //
    fn update_rank_of(&mut self, member: &AccountId, new_rank: u32) {
        let mut validator_stake = self.get(&member).unwrap();
        validator_stake.overall_rank = new_rank;
        self.insert(member, &validator_stake);
    }
}

#[near_bindgen]
impl ResolverForSelfCallback for OctopusCouncil {
    //
    fn resolve_add_proposal(&mut self, change_history: &mut CouncilChangeHistory) {
        assert_self();
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(bytes) => {
                change_history.state = CouncilChangeHistoryState::ProposalAdded(
                    near_sdk::serde_json::from_slice::<u64>(&bytes).unwrap(),
                );
                self.change_histories
                    .insert(&change_history.index.0, change_history);
                //
                self.act_proposal_on_dao_contract(change_history);
            }
            PromiseResult::Failed => {
                log!(
                    "Failed to add proposal for change history: '{}'",
                    near_sdk::serde_json::to_string(&change_history).unwrap()
                );
            }
        }
    }
    //
    fn resolve_act_proposal(&mut self, change_history: &mut CouncilChangeHistory) {
        assert_self();
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => {
                let proposal_id = match change_history.state {
                    CouncilChangeHistoryState::ProposalAdded(id) => id,
                    _ => panic!(
                        "Invalid state of council change history: '{}'",
                        near_sdk::serde_json::to_string(change_history).unwrap()
                    ),
                };
                change_history.state = CouncilChangeHistoryState::ProposalApproved(proposal_id);
                self.change_histories
                    .insert(&change_history.index.0, change_history);
            }
            PromiseResult::Failed => {
                log!(
                    "Failed to act proposal for change history: '{}'",
                    near_sdk::serde_json::to_string(&change_history).unwrap()
                );
            }
        }
    }
}

'''
'''--- octopus-council/src/lookup_array.rs ---
use crate::*;
use near_sdk::json_types::U64;

pub trait IndexedAndClearable {
    ///
    fn set_index(&mut self, index: &u64);
    ///
    fn clear_extra_storage(&mut self) -> MultiTxsOperationProcessingResult;
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct LookupArray<T: BorshDeserialize + BorshSerialize + IndexedAndClearable> {
    /// The anchor event data map.
    pub lookup_map: LookupMap<u64, T>,
    /// The start index of valid anchor event.
    pub start_index: u64,
    /// The end index of valid anchor event.
    pub end_index: u64,
}

impl<T> LookupArray<T>
where
    T: BorshDeserialize + BorshSerialize + IndexedAndClearable,
{
    ///
    pub fn new(storage_key: StorageKey) -> Self {
        Self {
            lookup_map: LookupMap::new(storage_key),
            start_index: 0,
            end_index: 0,
        }
    }
    ///
    pub fn migrate_from(storage_key: StorageKey, start_index: u64, end_index: u64) -> Self {
        Self {
            lookup_map: LookupMap::new(storage_key),
            start_index,
            end_index,
        }
    }
    ///
    pub fn get(&self, index: &u64) -> Option<T> {
        self.lookup_map.get(index)
    }
    ///
    pub fn get_slice_of(&self, start_index: &u64, quantity: Option<u64>) -> Vec<T> {
        let mut results = Vec::<T>::new();
        let start_index = match self.start_index > *start_index {
            true => self.start_index,
            false => *start_index,
        };
        let mut end_index = start_index
            + match quantity {
                Some(quantity) => match quantity > 50 {
                    true => 49,
                    false => quantity - 1,
                },
                None => 49,
            };
        end_index = match end_index < self.end_index {
            true => end_index,
            false => self.end_index,
        };
        for index in start_index..end_index + 1 {
            if let Some(record) = self.get(&index) {
                results.push(record);
            }
        }
        results
    }
    ///
    pub fn contains(&self, index: &u64) -> bool {
        self.lookup_map.contains_key(index)
    }
    ///
    pub fn insert(&mut self, index: &u64, record: &T) {
        self.lookup_map.insert(index, record);
        if *index > self.end_index {
            self.end_index = *index;
        }
    }
    ///
    pub fn index_range(&self) -> IndexRange {
        IndexRange {
            start_index: U64::from(self.start_index),
            end_index: U64::from(self.end_index),
        }
    }
    ///
    pub fn append(&mut self, record: &mut T) -> T {
        let index = match self.lookup_map.contains_key(&0) {
            true => self.end_index + 1,
            false => 0,
        };
        record.set_index(&index);
        self.lookup_map.insert(&index, &record);
        self.end_index = index;
        self.lookup_map.get(&index).unwrap()
    }
    ///
    pub fn remove_before(&mut self, index: &u64) -> MultiTxsOperationProcessingResult {
        if self.start_index >= *index {
            return MultiTxsOperationProcessingResult::Ok;
        }
        for index in self.start_index..*index {
            let result = self.remove_at(&index);
            if !result.is_ok() {
                return result;
            }
        }
        self.start_index = *index;
        MultiTxsOperationProcessingResult::Ok
    }
    ///
    pub fn reset_to(&mut self, index: &u64) -> MultiTxsOperationProcessingResult {
        assert!(
            *index >= self.start_index && *index <= self.end_index,
            "Invalid history data index."
        );
        for index in (*index + 1)..self.end_index + 1 {
            let result = self.remove_at(&index);
            if !result.is_ok() {
                return result;
            }
        }
        self.end_index = *index;
        MultiTxsOperationProcessingResult::Ok
    }
    ///
    pub fn clear(&mut self) -> MultiTxsOperationProcessingResult {
        log!(
            "Index range of lookup array: {} - {}",
            self.start_index,
            self.end_index
        );
        let mut index = self.start_index;
        while index <= self.end_index && self.remove_at(&index).is_ok() {
            index += 1;
        }
        if env::used_gas() > Gas::ONE_TERA.mul(T_GAS_CAP_FOR_MULTI_TXS_PROCESSING) {
            self.start_index = index;
            MultiTxsOperationProcessingResult::NeedMoreGas
        } else {
            self.start_index = 0;
            self.end_index = 0;
            MultiTxsOperationProcessingResult::Ok
        }
    }
    ///
    pub fn remove_at(&mut self, index: &u64) -> MultiTxsOperationProcessingResult {
        if let Some(mut record) = self.lookup_map.get(index) {
            let result = record.clear_extra_storage();
            match result {
                MultiTxsOperationProcessingResult::Ok => {
                    self.lookup_map.remove_raw(&index.try_to_vec().unwrap());
                }
                MultiTxsOperationProcessingResult::NeedMoreGas => {
                    self.lookup_map.insert(index, &record);
                }
                MultiTxsOperationProcessingResult::Error(_) => (),
            }
            return result;
        }
        MultiTxsOperationProcessingResult::Ok
    }
}

'''
'''--- octopus-council/src/ranked_lookup_array.rs ---
use crate::*;

pub trait RankValueHolder<T: BorshDeserialize + BorshSerialize> {
    ///
    fn get_rank_value_of(&self, member: &T) -> u128;
    ///
    fn update_rank_of(&mut self, member: &T, new_rank: u32);
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct RankedLookupArray<T: BorshDeserialize + BorshSerialize> {
    /// The anchor event data map.
    lookup_map: LookupMap<u32, T>,
    /// The length of the array.
    length: u32,
}

impl<T> RankedLookupArray<T>
where
    T: BorshDeserialize + BorshSerialize,
{
    ///
    pub fn new(storage_key: StorageKey) -> Self {
        Self {
            lookup_map: LookupMap::new(storage_key),
            length: 0,
        }
    }
    ///
    pub fn get(&self, index: u32) -> Option<T> {
        self.lookup_map.get(&index)
    }
    ///
    pub fn get_slice_of(&self, start_index: u32, quantity: Option<u32>) -> Vec<T> {
        let mut results = Vec::<T>::new();
        assert!(
            start_index < self.length,
            "Start index is out of bound of the array."
        );
        let end_index = match quantity {
            Some(quantity) => match quantity > self.length - start_index - 1 {
                true => self.length - 1,
                false => start_index + quantity - 1,
            },
            None => self.length - 1,
        };
        for index in start_index..end_index + 1 {
            if let Some(record) = self.get(index) {
                results.push(record);
            }
        }
        results
    }
    ///
    pub fn append<S: RankValueHolder<T>>(&mut self, record: &T, rank_value_holder: &mut S) -> u32 {
        self.lookup_map.insert(&self.length, &record);
        rank_value_holder.update_rank_of(record, self.length);
        self.length += 1;
        //
        self.move_up_by_rank_value(record, self.length - 1, rank_value_holder)
    }
    //
    fn move_up_by_rank_value<S: RankValueHolder<T>>(
        &mut self,
        record: &T,
        index: u32,
        rank_value_holder: &mut S,
    ) -> u32 {
        let mut current_index = index;
        while current_index > 0 {
            let previous_index = current_index - 1;
            let previous_rank_value =
                rank_value_holder.get_rank_value_of(&self.get(previous_index).unwrap());
            let current_rank_value = rank_value_holder.get_rank_value_of(record);
            if current_rank_value <= previous_rank_value {
                break;
            } else {
                self.swap((previous_index, current_index), rank_value_holder);
                current_index = previous_index;
            }
        }
        current_index
    }
    ///
    pub fn insert<S: RankValueHolder<T>>(
        &mut self,
        index: u32,
        record: &T,
        rank_value_holder: &mut S,
    ) -> u32 {
        assert!(index < self.length, "Index is out of bound of the array.");
        self.lookup_map.insert(&index, record);
        //
        let mut new_index = self.move_up_by_rank_value(record, index, rank_value_holder);
        if new_index == index {
            new_index = self.move_down_by_rank_value(record, index, rank_value_holder);
        }
        new_index
    }
    //
    fn move_down_by_rank_value<S: RankValueHolder<T>>(
        &mut self,
        record: &T,
        index: u32,
        rank_value_holder: &mut S,
    ) -> u32 {
        let mut current_index = index;
        if self.length > 1 {
            while current_index < self.length - 1 {
                let next_index = current_index + 1;
                let next_rank_value =
                    rank_value_holder.get_rank_value_of(&self.get(next_index).unwrap());
                let current_rank_value = rank_value_holder.get_rank_value_of(record);
                if current_rank_value >= next_rank_value {
                    break;
                } else {
                    self.swap((next_index, current_index), rank_value_holder);
                    current_index = next_index;
                }
            }
        }
        current_index
    }
    ///
    pub fn len(&self) -> u32 {
        self.length
    }
    ///
    pub fn clear(&mut self) -> MultiTxsOperationProcessingResult {
        while self.length > 0
            && env::used_gas() <= Gas::ONE_TERA.mul(T_GAS_CAP_FOR_MULTI_TXS_PROCESSING)
        {
            self.lookup_map.remove(&(self.length - 1));
            self.length -= 1
        }
        if self.length > 0
            && env::used_gas() > Gas::ONE_TERA.mul(T_GAS_CAP_FOR_MULTI_TXS_PROCESSING)
        {
            MultiTxsOperationProcessingResult::NeedMoreGas
        } else {
            MultiTxsOperationProcessingResult::Ok
        }
    }
    ///
    fn swap<S: RankValueHolder<T>>(&mut self, index_pair: (u32, u32), rank_value_holder: &mut S) {
        assert!(
            index_pair.0 < self.length
                && index_pair.1 < self.length
                && index_pair.0 != index_pair.1,
            "Invalid index pair to swap."
        );
        let t0 = self.lookup_map.get(&index_pair.0).unwrap();
        let t1 = self.lookup_map.get(&index_pair.1).unwrap();
        self.lookup_map.insert(&index_pair.0, &t1);
        rank_value_holder.update_rank_of(&t1, index_pair.0);
        self.lookup_map.insert(&index_pair.1, &t0);
        rank_value_holder.update_rank_of(&t0, index_pair.1);
    }
}

'''
'''--- octopus-council/src/storage_migration.rs ---
use crate::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::{env, near_bindgen, AccountId};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct OldOctopusCouncil {
    //
    owner: AccountId,
    //
    appchain_registry_account: AccountId,
    //
    dao_contract_account: AccountId,
    //
    living_appchain_ids: Vec<String>,
    //
    validator_stakes: LookupMap<AccountId, InternalValidatorStake>,
    //
    ranked_validators: RankedLookupArray<AccountId>,
    //
    max_number_of_council_members: u32,
    //
    latest_members: UnorderedSet<AccountId>,
    //
    change_histories: LookupArray<CouncilChangeHistory>,
}

#[near_bindgen]
impl OctopusCouncil {
    #[init(ignore_state)]
    pub fn migrate_state() -> Self {
        // Deserialize the state using the old contract structure.
        let old_contract: OldOctopusCouncil = env::state_read().expect("Old state doesn't exist");
        //
        near_sdk::assert_self();
        //
        // Create the new contract using the data from the old contract.
        let new_contract = OctopusCouncil {
            owner: old_contract.owner,
            appchain_registry_account: old_contract.appchain_registry_account,
            dao_contract_account: old_contract.dao_contract_account,
            living_appchain_ids: old_contract.living_appchain_ids,
            validator_stakes: old_contract.validator_stakes,
            ranked_validators: old_contract.ranked_validators,
            max_number_of_council_members: old_contract.max_number_of_council_members,
            latest_members: old_contract.latest_members,
            excluding_validator_accounts: Vec::new(),
            change_histories: old_contract.change_histories,
        };
        //
        //
        new_contract
    }
}

'''
'''--- octopus-council/src/sudo_functions.rs ---
use crate::*;

#[near_bindgen]
impl OctopusCouncil {
    ///
    pub fn clear_council_members_and_regenerate_change_histories(&mut self) {
        self.assert_owner();
        //
        self.latest_members.clear();
        //
        // self.change_histories.clear();
        let change_history_index_range = self.change_histories.index_range();
        for index in
            change_history_index_range.start_index.0..change_history_index_range.end_index.0 + 1
        {
            env::storage_remove(&get_storage_key_in_lookup_array(
                &StorageKey::CouncilChangeHistories,
                &index,
            ));
        }
        //
        self.check_and_generate_change_histories();
    }
}

fn get_storage_key_in_lookup_array<T: BorshSerialize>(prefix: &StorageKey, index: &T) -> Vec<u8> {
    [prefix.try_to_vec().unwrap(), index.try_to_vec().unwrap()].concat()
}

'''
'''--- octopus-council/src/types.rs ---
use crate::*;
use near_sdk::{
    json_types::U64,
    serde::{Deserialize, Serialize},
};
use std::collections::HashMap;

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct IndexRange {
    pub start_index: U64,
    pub end_index: U64,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum MultiTxsOperationProcessingResult {
    NeedMoreGas,
    Ok,
    Error(String),
}

impl MultiTxsOperationProcessingResult {
    ///
    pub fn is_ok(&self) -> bool {
        match self {
            MultiTxsOperationProcessingResult::Ok => true,
            _ => false,
        }
    }
    ///
    pub fn is_need_more_gas(&self) -> bool {
        match self {
            MultiTxsOperationProcessingResult::NeedMoreGas => true,
            _ => false,
        }
    }
    ///
    pub fn is_error(&self) -> bool {
        match self {
            MultiTxsOperationProcessingResult::Error(_) => true,
            _ => false,
        }
    }
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ValidatorStakeRecord {
    pub validator_id: AccountId,
    pub total_stake: U128,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ValidatorStake {
    //
    pub validator_id: AccountId,
    // key: appchain id, value: total stake in the appchain anchor
    pub stake_in_appchains: HashMap<String, U128>,
    // total stake in all appchain anchors
    pub total_stake: U128,
    // the rank of the validator in all validators
    pub overall_rank: u32,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum CouncilChangeAction {
    MemberAdded(AccountId),
    MemberRemoved(AccountId),
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum CouncilChangeHistoryState {
    NoNeedToApply,
    WaitingForApplying,
    ProposalAdded(u64),
    ProposalApproved(u64),
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CouncilChangeHistory {
    pub index: U64,
    pub action: CouncilChangeAction,
    pub state: CouncilChangeHistoryState,
    pub timestamp: U64,
}

impl IndexedAndClearable for CouncilChangeHistory {
    //
    fn set_index(&mut self, index: &u64) {
        self.index = U64::from(*index);
    }
    //
    fn clear_extra_storage(&mut self) -> MultiTxsOperationProcessingResult {
        MultiTxsOperationProcessingResult::Ok
    }
}

'''
'''--- octopus-council/src/upgrade.rs ---
use crate::*;
use near_sdk::json_types::Base58CryptoHash;
use near_sdk::{env, IntoStorageKey};

const GAS_FOR_UPGRADE_SELF_DEPLOY: Gas = Gas(15_000_000_000_000);

/// Stores attached data into blob store and returns hash of it.
/// Implemented to avoid loading the data into WASM for optimal gas usage.
#[no_mangle]
pub extern "C" fn store_wasm_of_self() {
    env::setup_panic_hook();
    let contract: OctopusCouncil = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
    contract.assert_owner();
    let input = env::input().expect("ERR_NO_INPUT");
    let sha256_hash = env::sha256(&input);

    let blob_len = input.len();
    let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
    assert!(
        env::attached_deposit() >= storage_cost,
        "ERR_NOT_ENOUGH_DEPOSIT:{}",
        storage_cost
    );

    env::storage_write(&StorageKey::OctopusCouncilWasm.into_storage_key(), &input);
    let mut blob_hash = [0u8; 32];
    blob_hash.copy_from_slice(&sha256_hash);
    let blob_hash_str = near_sdk::serde_json::to_string(&Base58CryptoHash::from(blob_hash))
        .unwrap()
        .into_bytes();

    env::value_return(&blob_hash_str);
}

#[no_mangle]
pub fn update_self() {
    env::setup_panic_hook();
    let contract: OctopusCouncil = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
    contract.assert_owner();
    let current_id = env::current_account_id();
    let input = env::storage_read(&StorageKey::OctopusCouncilWasm.into_storage_key())
        .expect("Wasm file for deployment is not staged yet.");
    let promise_id = env::promise_batch_create(&current_id);
    env::promise_batch_action_deploy_contract(promise_id, &input);
    env::promise_batch_action_function_call(
        promise_id,
        "migrate_state",
        &[],
        0,
        env::prepaid_gas() - env::used_gas() - GAS_FOR_UPGRADE_SELF_DEPLOY,
    );
}

'''
'''--- octopus-council/src/views.rs ---
use crate::*;

#[near_bindgen]
impl OctopusCouncil {
    ///
    pub fn version(&self) -> String {
        String::from(VERSION)
    }
    ///
    pub fn get_living_appchain_ids(&self) -> Vec<String> {
        self.living_appchain_ids.clone()
    }
    ///
    pub fn get_max_number_of_council_members(&self) -> u32 {
        self.max_number_of_council_members
    }
    ///
    pub fn get_excluding_validator_accounts(&self) -> Vec<AccountId> {
        self.excluding_validator_accounts.clone()
    }
    //
    pub fn get_validator_stake_of(&self, account_id: AccountId) -> ValidatorStake {
        self.validator_stakes
            .get(&account_id)
            .expect("Invalid validator id.")
            .to_json_type()
    }
    //
    pub fn get_ranked_validator_stakes(
        &self,
        start_index: u32,
        quantity: Option<u32>,
    ) -> Vec<ValidatorStake> {
        let all_members = match self.ranked_validators.len() > 0 {
            true => self.ranked_validators.get_slice_of(start_index, quantity),
            false => Vec::new(),
        };
        all_members
            .iter()
            .map(|account_id| {
                self.validator_stakes
                    .get(account_id)
                    .unwrap()
                    .to_json_type()
            })
            .collect()
    }
    //
    pub fn get_council_members(&self) -> Vec<AccountId> {
        self.latest_members.to_vec()
    }
    //
    pub fn get_council_change_histories(
        &self,
        start_index: U64,
        quantity: Option<U64>,
    ) -> Vec<CouncilChangeHistory> {
        self.change_histories
            .get_slice_of(&start_index.0, quantity.map(|q| q.0))
    }
}

'''
'''--- scripts/testnet_cli.sh ---
#!/bin/bash
set -e
#
# export NEAR_CLI_TESTNET_RPC_SERVER_URL=https://near-testnet.infura.io/v3/4f80a04e6eb2437a9ed20cb874e10d55
# export NEAR_CLI_TESTNET_RPC_SERVER_URL=https://public-rpc.blockpi.io/http/near-testnet
export NEAR_ENV=testnet
export REGISTRY_ACCOUNT_ID=registry.test_oct.testnet
export COUNCIL_ACCOUNT_ID=octopus-council.$REGISTRY_ACCOUNT_ID
#
#
#
# near deploy --accountId $COUNCIL_ACCOUNT_ID --wasmFile res/octopus_council.wasm
#
# near call $COUNCIL_ACCOUNT_ID migrate_state '' --accountId $COUNCIL_ACCOUNT_ID --gas 200000000000000
#
# WASM_BYTES='cat res/octopus_council.wasm | base64'
# near call $COUNCIL_ACCOUNT_ID store_wasm_of_self $(eval "$WASM_BYTES") --base64 --accountId $COUNCIL_ACCOUNT_ID --deposit 3 --gas 200000000000000
#
# near call $COUNCIL_ACCOUNT_ID update_self '' --accountId $COUNCIL_ACCOUNT_ID --gas 200000000000000
#
# near call $COUNCIL_ACCOUNT_ID set_dao_contract_account '{"account_id":"octopus-dao.sputnikv2.testnet"}' --accountId $COUNCIL_ACCOUNT_ID --gas 200000000000000
#
# near call $COUNCIL_ACCOUNT_ID apply_change_histories_to_dao_contract '{"start_index":"0"}' --accountId $COUNCIL_ACCOUNT_ID --gas 200000000000000
#
# near call $COUNCIL_ACCOUNT_ID set_max_number_of_council_members '{"max_number_of_council_members":10}' --accountId $COUNCIL_ACCOUNT_ID --gas 200000000000000
#
# near call $COUNCIL_ACCOUNT_ID clear_council_members_and_regenerate_change_histories '' --accountId $COUNCIL_ACCOUNT_ID --gas 200000000000000
#
# near call $COUNCIL_ACCOUNT_ID set_excluding_validator_accounts '{"accounts":["alice-octopus.testnet","bob-octopus.testnet","charlie-octopus.testnet","dave-octopus.testnet"]}' --accountId $COUNCIL_ACCOUNT_ID --gas 200000000000000

'''
'''--- scripts/testnet_init.sh ---
#!/bin/bash
set -e
#
# export NEAR_CLI_TESTNET_RPC_SERVER_URL=https://near-testnet.infura.io/v3/4f80a04e6eb2437a9ed20cb874e10d55
# export NEAR_CLI_TESTNET_RPC_SERVER_URL=https://public-rpc.blockpi.io/http/near-testnet
export NEAR_ENV=testnet
export REGISTRY_ACCOUNT_ID=registry.test_oct.testnet
export COUNCIL_ACCOUNT_ID=octopus-council.$REGISTRY_ACCOUNT_ID
#
#
#
cp ~/.near-credentials/testnet/$REGISTRY_ACCOUNT_ID.json ~/.near-credentials/testnet/$COUNCIL_ACCOUNT_ID.json
sed -i '' "s/$REGISTRY_ACCOUNT_ID/$COUNCIL_ACCOUNT_ID/" ~/.near-credentials/testnet/$COUNCIL_ACCOUNT_ID.json
#
near create-account $COUNCIL_ACCOUNT_ID --masterAccount $REGISTRY_ACCOUNT_ID --publicKey ed25519:5xprFQ2PvGLs5TAFieQzdgLHMHcsHSJnQj8FD6KuXq13 --initialBalance 2
near deploy --accountId $COUNCIL_ACCOUNT_ID --wasmFile res/octopus_council.wasm
near call $COUNCIL_ACCOUNT_ID new '{"max_number_of_council_members":5}' --accountId $COUNCIL_ACCOUNT_ID --gas 200000000000000

'''
'''--- scripts/testnet_view_cli.sh ---
#!/bin/bash
set -e
#
# export NEAR_CLI_TESTNET_RPC_SERVER_URL=https://near-testnet.infura.io/v3/4f80a04e6eb2437a9ed20cb874e10d55
# export NEAR_CLI_TESTNET_RPC_SERVER_URL=https://public-rpc.blockpi.io/http/near-testnet
export NEAR_ENV=testnet
export REGISTRY_ACCOUNT_ID=registry.test_oct.testnet
export COUNCIL_ACCOUNT_ID=octopus-council.$REGISTRY_ACCOUNT_ID
#
#
#
near view $COUNCIL_ACCOUNT_ID version
#
near view $COUNCIL_ACCOUNT_ID get_living_appchain_ids
#
near view $COUNCIL_ACCOUNT_ID get_max_number_of_council_members
#
near view $COUNCIL_ACCOUNT_ID get_excluding_validator_accounts
#
near view $COUNCIL_ACCOUNT_ID get_council_members
#
near view $COUNCIL_ACCOUNT_ID get_ranked_validator_stakes '{"start_index":0,"quantity":null}'
#
near view $COUNCIL_ACCOUNT_ID get_council_change_histories '{"start_index":"0","quantity":null}'

'''
'''--- tests/workspaces/main.rs ---

'''