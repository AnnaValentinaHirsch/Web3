*GitHub Repository "evgenykuzyakov/nft-viewer"*

'''--- Cargo.toml ---
[package]
name = "nftview"
version = "0.1.0"
authors = ["Eugene The Dream"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "=4.0.0-pre.6"
near-contract-standards = "4.0.0-pre.6"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- build.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)"

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./res
cp target/wasm32-unknown-unknown/release/nftview.wasm ./res/

'''
'''--- res/index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>%URL_TITLE%</title>

    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="og:title" content="%URL_TITLE%" />
    <meta name="og:description" content="%DESCRIPTION%" />
    <meta name="og:image" content="%IMAGE%" />
    <meta name="og:url" content="%URL%" />

    <link href="https://fonts.googleapis.com/css?family=Outfit:100,200,300,regular,500,600,700,800,900" rel="stylesheet" />

   <style>
       :root {
           --oxford-blue:       hsl(217, 54%, 11%);
           --light-oxford-blue: hsl(216, 50%, 16%);
           --indigo-dye:        hsl(215, 32%, 27%);
           --blue-yonder:       hsl(216, 30%, 55%);
           --aqua:              hsl(178, 100%, 50%);
           --white:             hsl(0, 0%, 100%);
       }

       * {
           margin:  0;
           padding: 0;
           box-sizing: border-box;
       }

       html { font-family: "Outfit", sans-serif; }

       a { text-decoration: none; }

       body {
           background: var(--oxford-blue);
           min-height: 100vh;
           padding: 25px;
           display:         flex;
           justify-content: center;
           align-items:     center;
       }

       .card {
           background: var(--light-oxford-blue);
           max-width: 350px;
           padding: 24px;
           border-radius: 15px;
           box-shadow: 0 20px 25px 15px rgba(0, 0, 0, 0.05),
           0 40px 30px 15px rgba(0, 0, 0, 0.1);
       }

       .card__product-img {
           position: relative;
           border-radius: 8px;
           overflow: hidden;
           cursor: pointer;
       }

       .card__product-img::after {
           --aqua: hsla(178, 100%, 50%, 0.5);
           position: absolute;
           inset: 0;
           display:         flex;
           justify-content: center;
           align-items:     center;
           opacity: 0;
           transition: all 0.25s ease;
       }

       .card__product-img:hover::after { opacity: 1; }

       .card__product-img img {
           width: 100%;
           display: block;
           min-width: 100px;
           min-height: 100px;
       }

       .card__body {
           padding: 23px 0;
       }

       .card__title {
           color: var(--white);
           font-size: 22px;
           font-weight: 500;
           margin-bottom: 15px;
       }

       .card__title:hover { color: var(--aqua); }

       .card__text {
           color: var(--blue-yonder);
           font-size: 18px;
           line-height: 1.5;
           margin-bottom: 23px;
           border-bottom: 1px solid var(--indigo-dye);
           padding-bottom: 5px;
       }

       .card__body .wrapper {
           display:         flex;
           justify-content: space-between;
           align-items:     center;
       }

       .card__owner,
       .card__contract {
           display:     flex;
           align-items: center;
           font-weight: 500;
       }

       .card__owner { color: var(--aqua); }

       .card__contract { color: var(--blue-yonder); }

       .card__author-name a {
           color: var(--white);
           font-weight: 400;
       }

       .card__author-name a:hover { color: var(--aqua); }
   </style>
</head>

<body>

<div class="card">

    <div class="card__head">
        <a href="%IMAGE%">
            <div class="card__product-img">
                <img src="%IMAGE%" alt="%TITLE%">
            </div>
        </a>
    </div>

    <div class="card__body">
        <h3 class="card__title">%TITLE%</h3>

        <p class="card__text">%DESCRIPTION%</p>

        <div class="wrapper">
            <div class="card__owner">
                <span>%OWNER_ID%</span>
            </div>

            <div class="card__contract">
                <span>%CONTRACT_ID%</span>
            </div>
        </div>

    </div>

    <div>
        <a href="https://twitter.com/share" class="twitter-share-button" data-text="Look at my NFT on NEAR: %URL_TITLE%" data-hashtags="NearNFT" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    </div>
</div>
</body>
</html>

'''
'''--- src/lib.rs ---
mod web4;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {}

'''
'''--- src/web4.rs ---
use crate::*;
use near_contract_standards::non_fungible_token::metadata::{NFTContractMetadata, TokenMetadata};
use near_sdk::json_types::Base64VecU8;
use near_sdk::{env, serde_json};
use std::collections::HashMap;
use std::str::FromStr;

const INDEX_BODY: &str = include_str!("../res/index.html");
const IPFS_PREFIX: &str = "https://cloudflare-ipfs.com/ipfs";

#[allow(dead_code)]
#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Web4Request {
    #[serde(rename = "accountId")]
    account_id: Option<AccountId>,
    path: String,
    params: Option<HashMap<String, String>>,
    query: Option<HashMap<String, Vec<String>>>,
    preloads: Option<HashMap<String, Web4Response>>,
}

#[derive(Serialize, Deserialize, Default)]
#[serde(crate = "near_sdk::serde")]
pub struct Web4Response {
    #[serde(rename = "contentType")]
    content_type: Option<String>,
    status: Option<u32>,
    body: Option<Base64VecU8>,
    #[serde(rename = "bodyUrl")]
    body_url: Option<String>,
    #[serde(rename = "preloadUrls")]
    preload_urls: Option<Vec<String>>,
}

#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
    pub owner_id: AccountId,
    pub metadata: Option<TokenMetadata>,
}

impl Web4Response {
    pub fn html_response(text: String) -> Self {
        Self {
            content_type: Some(String::from("text/html; charset=UTF-8")),
            body: Some(text.into_bytes().into()),
            ..Default::default()
        }
    }

    pub fn plain_response(text: String) -> Self {
        Self {
            content_type: Some(String::from("text/plain; charset=UTF-8")),
            body: Some(text.into_bytes().into()),
            ..Default::default()
        }
    }

    pub fn preload_urls(urls: Vec<String>) -> Self {
        Self {
            preload_urls: Some(urls),
            ..Default::default()
        }
    }

    pub fn body_url(url: String) -> Self {
        Self {
            body_url: Some(url),
            ..Default::default()
        }
    }

    pub fn status(status: u32) -> Self {
        Self {
            status: Some(status),
            ..Default::default()
        }
    }
}

fn filter_string(s: String) -> String {
    s.chars()
        .into_iter()
        .filter_map(|c| match c {
            '\n' => Some(' '),
            ' ' | '_' | '.' | '-' | ',' | '!' | '(' | ')' | '/' | '=' | ':' | '+' | '?' | '#'
            | '%' | '|' => Some(c),
            _ if c.is_alphanumeric() => Some(c),
            _ => None,
        })
        .collect()
}

#[near_bindgen]
impl Contract {
    #[allow(unused_variables)]
    pub fn web4_get(&self, request: Web4Request) -> Web4Response {
        let path = request.path;

        if path == "/robots.txt" {
            return Web4Response::plain_response("User-agent: *\nDisallow:".to_string());
        }

        let (nft_account_id, token_id) = path[1..].split_once('/').expect("Token ID is missing");
        let nft_account_id = AccountId::from_str(nft_account_id).expect("Invalid NFT account ID");
        let nft_metadata_url =
            format!("/web4/contract/{}/nft_metadata", nft_account_id.to_string());
        let token_url = format!(
            "/web4/contract/{}/nft_token?token_id={}",
            nft_account_id.to_string(),
            token_id
        );

        if let Some(preloads) = request.preloads {
            let token: Token = serde_json::from_slice(
                &preloads
                    .get(&token_url)
                    .unwrap()
                    .body
                    .as_ref()
                    .expect("Token not found")
                    .0,
            )
            .expect("Failed to parse token");
            let nft_metadata: NFTContractMetadata = serde_json::from_slice(
                &preloads
                    .get(&nft_metadata_url)
                    .unwrap()
                    .body
                    .as_ref()
                    .expect("NFT Metadata doesn't exist")
                    .0,
            )
            .expect("Failed to parse NFT Metadata");
            let token_metadata = token.metadata.expect("Token metadata is missing");
            let token_media = token_metadata.media.unwrap_or_default();

            let image_url = if token_media.starts_with("https://")
                || token_media.starts_with("http://")
                || token_media.starts_with("data:image")
            {
                token_media
            } else if let Some(base_uri) = &nft_metadata.base_uri {
                format!("{}/{}", base_uri, token_media)
            } else if token_media.starts_with("Qm") {
                format!("{}/{}", IPFS_PREFIX, token_media)
            } else {
                token_media
            };

            let token_title = filter_string(token_metadata.title.unwrap_or_default());

            Web4Response::html_response(
                INDEX_BODY
                    .replace("%IMAGE%", &filter_string(image_url))
                    .replace("%TITLE%", &token_title)
                    .replace(
                        "%URL_TITLE%",
                        &filter_string(format!("{} | {}", token_title, nft_metadata.name)),
                    )
                    .replace(
                        "%DESCRIPTION%",
                        &filter_string(
                            token_metadata
                                .description
                                .unwrap_or_else(|| nft_metadata.name),
                        ),
                    )
                    .replace("%OWNER_ID%", &token.owner_id.to_string())
                    .replace("%CONTRACT_ID%", &nft_account_id.to_string())
                    .replace(
                        "%URL%",
                        &format!("{}.page{}", env::current_account_id().to_string(), path),
                    ),
            )
        } else {
            Web4Response::preload_urls(vec![nft_metadata_url, token_url])
        }
        //
        // let path = request.path.expect("Path expected");
        // if path.starts_with("/static/") || path == "/favicon.png" || path == "/manifest.json" {
        //     return Web4Response::body_url(
        //         String::from("ipfs://bafybeigifbsj3nnbufxa3non7xas23r3yqjlfx3v3k27qgdgch2mmqdeue")
        //             + &path,
        //     );
        // }
        //
        // if path == "/robots.txt" {
        //     return Web4Response::plain_response("User-agent: *\nDisallow:".to_string());
        // }
        //
        // let article_id = path
        //     .rfind('/')
        //     .map(|p| path[(p + 1)..].to_string())
        //     .unwrap_or_default();
        //
        // let escaped_article_id = filter_string(article_id.clone());
        //
        // let title = if path.starts_with(PREFIX_HISTORY) {
        //     format!("Edit history of {} | wiki", escaped_article_id)
        // } else {
        //     format!("{} | wiki", escaped_article_id)
        // };
        //
        // let article = self.internal_get_article(&article_id);
        //
        // let description = article
        //     .map(|article| filter_string(article.body))
        //     .unwrap_or_else(|| "the wiki built on NEAR".to_string());
        //
        // Web4Response::html_response(
        //     INDEX_BODY
        //         .replace("The wiki", &title)
        //         .replace("the wiki built on NEAR", &description),
        // )
    }
}

'''