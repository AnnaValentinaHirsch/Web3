*GitHub Repository "21Horza/social-artist-app"*

'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder â€“
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contract/target/debug/build/wee_alloc-e2cb34bd00ad2611/out/wee_alloc_static_array_backend_size_bytes.txt ---
33554432
'''
'''--- contract/target/rls/debug/build/wee_alloc-e2cb34bd00ad2611/out/wee_alloc_static_array_backend_size_bytes.txt ---
33554432
'''
'''--- contract/target/wasm32-unknown-unknown/debug/build/wee_alloc-96614ccff1c83e60/out/wee_alloc_static_array_backend_size_bytes.txt ---
33554432
'''
'''--- contract/target/wasm32-unknown-unknown/release/build/wee_alloc-eee7ea5cef997a34/out/wee_alloc_static_array_backend_size_bytes.txt ---
33554432
'''
'''--- server/controllers/likesController.js ---
const likesService = require('../service/likesService')

class LikesController {
    async increment(req, res) {
      try {
        const likesLength = await likesService.increment(req);
        return res.json(likesLength);
      } catch (e) {
        return res.status(500).json({ error: true, message: e.message });
      }
    }
    async decrement(req, res) {
      try {
        const likesLength = await likesService.decrement(req);
        return res.json(likesLength);
      } catch (e) {
        return res.status(500).json({ error: true, message: e.message });
      }
    }
  }
  
module.exports = new LikesController();
'''
'''--- server/controllers/postController.js ---
const postService = require('../service/postService')

class PostController {
    
    async createPost(req, res) {
        try {
            const created = await postService.create(req.body)
            return res.json(created)
        } catch(e) {
            return res.status(500).json({error: true, message: e.message})
        }
    }

    async updatePost(req, res) {
        try {
            const updatedPost = await postService.update(req.body)
                return res.json(updatedPost)
        } catch(e) {
            return res.status(500).json({error: true, message: e.message})
        }
    }

    async getAllPosts(req, res) {
        try {
            const posts = await postService.getAll()
            return res.json(posts)
        } catch(e) {
            return res.status(500).json({error: true, message: e.message})
        }
    }

    async getOnePost(req, res) {
        try {
            const post = await postService.getOne(req.params.id)
            return res.json(post)
        }
        catch(e) {
            return res.status(500).json({error: true, message: e.message})
        }
    }

    async deletePost(req, res) {
        try {
            const deletedPost = await postService.delete(req.params.id)
            return res.json(deletedPost)
        } catch(e) {
            return res.status(500).json({error: true, message: e.message})
        }
    }
}

module.exports = new PostController()
'''
'''--- server/controllers/userController.js ---
const userService = require("../service/userService");

class UserController {
  async registerUser(req, res) { // create user with "USER" or "ARTIST" roles
    try {
      const createdUser = await userService.registration(req, res);
      return res.json(createdUser);
    } catch (e) {
      return res.status(500).json({ error: true, message: e.message });
    }
  }
  async loginUser(req, res) {
    try {
      const user = await userService.login(req);
      return res.json(user);
    } catch (e) {
      return res.status(500).json({ error: true, message: e.message });
    }
  } 

  // that's for test

  // async getUsers(req, res) {
  //   try {
  //     const data = await userService.getUsers(req);
  //     return res.json(data)
  //   } catch(e) {
  //     return res.status(400).json({message: 'Smth went wrong'})
  //   }
  // }
}

module.exports = new UserController();
'''
'''--- server/index.js ---
require('dotenv').config()
const cors = require('cors')
const express = require('express')
const mongoose = require('mongoose')
const postRouter = require('./routers/postRouter')
const userRouter = require('./routers/userRouter')
const fileUpload = require('express-fileupload')
const likesRouter = require('./routers/likesRouter')

const PORT = process.env.PORT || 7000

const app = express()
app.use(cors())
app.use(express.json())
app.use(fileUpload({}))

app.use('/api', postRouter)
app.use('/user', userRouter)
app.use('/api', likesRouter)

async function startApp() {
    try {
        await mongoose.connect(process.env.DB_URL)
        app.listen(PORT, () => console.log(`Server started on ${PORT} port`))
    } catch(e) {
        console.log(e)
    }
}

startApp()
'''
'''--- server/middlewares/verifyRole.js ---
const jwt = require('jsonwebtoken')

module.exports = function (roles) {
    return function (req, res, next) {
        if (req.method === 'OPTIONS') {
            next()
        }
    
        try {
            const token = req.headers.authorization.split(' ')[1]
            if (!token) {
                return res.status(403).json({message: "USER is not authorized"})
            }
            const {roles: userRoles} = jwt.verify(token, process.env.SECRET_KEY)
            let hasRole = false
            userRoles.forEach(role => {
                if (roles.includes(role)) {
                    hasRole = true
                }
            })
            if (!hasRole) {
                return res.status(403).json({message: 'You do not have acccess'})
            }
            next()
        } catch(e) {
            console.log(e)
            return res.status(403).json({message: 'User isn\'t authorized'})
        }
    }
}
'''
'''--- server/models/Post.js ---
const {Schema, model} = require('mongoose');

const Post = new Schema({
  username: {
    type: String,
    required: true,
  },
  title: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  near_wallet: {
    type: String,
    required: true,
  },
  img: {
    type: String,
    required: true,
  },
  nft_link: {
    type: String,
  },
  likes: {
    type: Array,
  },
});

module.exports = model("Post", Post);
'''
'''--- server/models/Role.js ---
const { Schema, model } = require("mongoose");

const Role = new Schema({
  value: {type: String, unique: true, default: 'USER'}
});

module.exports = model("Role", Role);
'''
'''--- server/models/User.js ---
const { Schema, model } = require("mongoose");

const User = new Schema({
  username: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true,
  },
  wallet: {
    type: String,
    unique: true
  },
  roles: 
    [{type: String, ref: 'Role'}]
});

module.exports = model("User", User);
'''
'''--- server/routers/likesRouter.js ---
const likesController = require('../controllers/likesController')
const verifyRole = require('../middlewares/verifyRole')

const Router = require('express').Router
const likesRouter = new Router()

likesRouter.post('/likes/:postId', verifyRole(["USER"]), likesController.increment)
likesRouter.delete('/likes/:postId', verifyRole(["USER"]),  likesController.decrement)

module.exports = likesRouter
'''
'''--- server/routers/postRouter.js ---
const postController = require('../controllers/postController')
const verifyRole = require('../middlewares/verifyRole')

const Router = require('express').Router
const postRouter = new Router()

postRouter.get('/post', postController.getAllPosts)
postRouter.get('/post/:id', postController.getOnePost)
postRouter.post('/post', verifyRole(['ARTIST']), postController.createPost)
postRouter.put('/post', verifyRole(['ARTIST']), postController.updatePost)
postRouter.delete('/post/:id', verifyRole(['ARTIST']), postController.deletePost)

module.exports = postRouter
'''
'''--- server/routers/userRouter.js ---
const userRouter = require("express").Router();
const userController = require("../controllers/userController");
const {check} = require('express-validator')

userRouter.post("/registration", 
[
    check('username', 'Username can not be empty').notEmpty(),
    check('password', "Password can not be less than 6 and less than 12 characters").isLength({min: 6, max: 12})
],
userController.registerUser);
userRouter.post("/login", userController.loginUser);

module.exports = userRouter;
'''
'''--- server/service/likesService.js ---
const User = require("../models/User")
const Post = require('../models/Post')
const jwt = require('jsonwebtoken')

class LikesService {
    async increment(req, res) {

        const token = req.headers.authorization.split(' ')[1]
        req.decoded = jwt.verify(token, process.env.SECRET_KEY)

        const post = await Post.findById(req.params.postId)
        
        if(!post) {
            throw new Error('Post not found')
        }

        const user = await User.findById(req.decoded.id)
        console.log(user)
        console.log('items', post)
        const foundUser = post.likes.find((item) => item === user.wallet);

        if (!foundUser) {
            post.likes.push(user.wallet);
            await post.save();
            return post.likes.length;
        } else {
            throw new Error('You already liked the post')
        }
    }

    async decrement(req) {
        
        const token = req.headers.authorization.split(' ')[1]
        req.decoded = jwt.verify(token, process.env.SECRET_KEY)

        const post = await Post.findById(req.params.postId);

        if(!post) {
            throw new Error('Post not found')
        }

        const user = await User.findById(req.decoded.id);
        const foundUser = post.likes.find((item) => item === user.wallet);
        
        if (foundUser) {
            post.likes.splice(post.likes.indexOf(user.wallet), 1);
            await post.save();
            return post.likes.length;
        } else {
            throw new Error('You already disliked the post')
        }
    }
}

module.exports = new LikesService()
'''
'''--- server/service/postService.js ---
const Post = require('../models/Post')

class PostService {
    async create(post) {
        const createdPost = await Post.create(post)
        return createdPost
    }

    async getAll() {
        const posts = await Post.find()
        return posts
    }

    async getOne(postId) {
        if (!postId) {
            throw new Error('Post ID is not defined')
        }
        const post = await Post.findById(postId)
        if (!post) {
            throw new Error('Post not found')
        }
        return post
    }

    async update(post) {
        if (!post._id) {
            throw new Error('Post ID is not defined')
        }
        const updatedPost = await Post.findByIdAndUpdate(post._id, post, {new: true})
        if (!updatedPost) {
            throw new Error('Post not found')
        }
        return updatedPost
    }

    async delete(postId) {
        if(!postId) {
            throw new Error('Post ID is not defined')
        }
        const deletedPost = Post.findByIdAndDelete(postId)
        if(!deletedPost) {
            throw new Error('Post not found')
        }
        return deletedPost
    }
}

module.exports = new PostService()
'''
'''--- server/service/userService.js ---
const User = require("../models/User");
const Role = require("../models/Role");
const bcrypt = require("bcrypt");
const jwt = require('jsonwebtoken')
const {validationResult} = require('express-validator')

const generateJwt = (id, wallet, roles) => {
    return jwt.sign(
        {id, wallet, roles}, // payload
        process.env.SECRET_KEY, // secret key
        {expiresIn: '2h'} // time
        )
}

class UserService {
  async registration(req, res) { // registration with "USER" or "ARTIST" role

    const errors = validationResult(req)
      if (!errors.isEmpty()) {
          return res.status(400).json({message: 'Password or username is invalid', errors})
      }

    const {username, password, wallet, is_artist} = req.body

    const candidate = await User.findOne({wallet, username});

    if (candidate) {
      throw new Error("The user already exists");
    }

    const hashedPassword = await bcrypt.hash(password, 5)
    
    if(is_artist === 'false') {
      const userRole = await Role.findOne({value: 'USER'})
      const user = new User({username, password: hashedPassword, wallet, roles: [userRole.value]})
      await user.save()
      
      return user
    }

    if(is_artist === 'true') {
      const userRole = await Role.findOne({value: 'ARTIST'})
      const user = new User({username, password: hashedPassword, wallet, roles: [userRole.value, 'USER']})
      await user.save()

      return user
    }
  }

  async login(req, res) {
    const {wallet, password} = req.body
    console.log('wallet', wallet)
    const user = await User.findOne({wallet});
    if (!user) throw new Error("Wallet or password is invalid");

    const isValid = bcrypt.compareSync(password, user.password);
    if (!isValid) throw new Error("Password is invalid");

    const token = generateJwt(user._id, wallet, user.roles)
    return {token: token};
  }

  //   async getUsers(req, res) {
      
  //     const users = await User.find()
  //     return users
      
  // }

  // async getUsers (req, res) {
  //   const userRole = new Role()
  //   const artistRole = new Role({value: "ARTIST"})
  //   userRole.save()
  //   artistRole.save()
  //   return {userRole, artistRole}
  // }
}

module.exports = new UserService();
'''
'''--- src/App.js ---
import 'regenerator-runtime/runtime'
import React, {useEffect, useContext} from 'react'
import './styles/App.css'
import getConfig from './config'
import { BrowserRouter } from 'react-router-dom'
import Navbar from './components/Navbar'
import AppRouter from './routes/AppRouter'
import { observer } from 'mobx-react-lite'
import { Context } from '.'
const { networkId } = getConfig(process.env.NODE_ENV || 'development')

const App = observer(() => {
  const {user} = useContext(Context)

  useEffect(() => {
      user.setIsArtist(true)
      user.setIsAuth(true)
      user.setUser(true)
}, [])

  return (
    <div >
      <BrowserRouter>
        <Navbar />
        <AppRouter />
      </BrowserRouter>
    </div>
  )
})

export default App
'''
'''--- src/components/hooks/useFetching.js ---
import { useState } from "react"

export const useFetching = (callback) => {
    const [isLdng, setIsLdng] = useState(false)
    const [showSuccess, setShowSuccess] = useState(false)
    const [err, setErr] = useState('')

    const fetch = async () => {
        try {
            setIsLdng(true)
            await callback()
            setShowSuccess(true)
        } catch (e) {
            setErr(e.message)
        } finally {
            setIsLdng(false)
        }
    }

    return [fetch, isLdng, err, showSuccess]
}

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME ||'art.heyhey23.testnet'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- src/consts/consts.js ---
export const POSTS_ROUTE = '/'
export const INFO_ROUTE = '/info'
export const UPDATE_POST_ROUTE = '/update'
export const CREATE_POST_ROUTE = '/create'

export const IMG_DB = 'https://api.cloudinary.com/v1_1/de0yikcb3/image/upload'

export const DEFAULT_IMG = 'https://i-shop.link/assets/images/no-image.png'
'''
'''--- src/handlers/sendTipsHandler.js ---

'''
'''--- src/http/index.js ---
import axios from "axios";

const $host = axios.create({
    baseURL: process.env.REACT_APP_API_URL
})

const $authHost = axios.create({
    baseURL: process.env.REACT_APP_API_URL
})

const authInterceptor = config => {
    config.headers.authorization = `Bearer ${localStorage.getItem('token')}`
    return config
}

$authHost.interceptors.request.use(authInterceptor)

export {
    $host,
    $authHost
}
'''
'''--- src/http/likesApi.js ---
import { $authHost } from "./index";

export const sendLike = async (postId) => {
  const data = await $authHost.post(`api/likes/${postId}`);
  console.log('data',data)
  return data;
};

export const sendDislike = async (postId) => {
  const data = await $authHost.delete(`api/likes/${postId}`);
  console.log('data dis',data)
  return data;
};
'''
'''--- src/http/postApi.js ---
import {$authHost, $host} from "./index";

export const createPost = async (formData) => {
    const {data} = await $authHost.post('api/post', formData)
    return data
}
export const updatePost = async (formData) => {
    for (var pair of formData.entries()) {
        console.log(pair[0]+ ', ' + pair[1]);
      }
    const {data} = await $authHost.put('api/post', formData)
    return data
}
export const deletePost = async (postId) => {
    const {data} = await $authHost.delete(`api/post/${postId}`)
    window.location.reload()
    return data
}

export const getOnePost = async (id) => {
    const {data} = await $host.get(`api/post/${id}`)
    return data;
}
export const getAllPosts = async () => {
    const {data} = await $host.get('api/post')
    return data
}

'''
'''--- src/http/userApi.js ---
import {$authHost, $host} from "./index";

export const registration = async (formData) => {
    const data = await $host.post('user/registration', formData)
    return data
}

export const loginUser = async (wallet, password ) => {
    const {data} = await $host.post('user/login', {wallet, password })
    localStorage.setItem('token', data.token)
    window.location.reload()
    return data
}

// export const checkToken = async (token) => {
//     const {data} = await $authHost.get('api/auth', {headers: {'Authorization': `Bearer ${token}`}})
//     localStorage.setItem('token', data.token)
//     return data 
// }
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./assets/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="apple-touch-icon" href="./assets/favicon.ico" />
    <title>Welcome to NEAR with React</title>
  </head>
  <body style="background-color: #121212;">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React, {createContext} from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import { initContract } from './utils'
import userStore from './store/userStore'

export const Context = createContext(null)

window.nearInitPromise = initContract()
  .then(() => {
    ReactDOM.render(
      <Context.Provider value={{
        user: new userStore()
    }}>
      <App />,
    </Context.Provider>,
      document.querySelector('#root')
    )
  })
  .catch(console.error)

'''
'''--- src/jest.init.js ---
import 'regenerator-runtime/runtime'

'''
'''--- src/routes/routes.js ---
import { CREATE_POST_ROUTE, INFO_ROUTE, POSTS_ROUTE } from "../consts/consts";
import PostCreate from "../components/PostCreate";
import PostsList from "../components/PostsList";
import React from 'react';
import PostInfo from "../components/PostInfo";

export const artistRoutes = [
    {
        path: CREATE_POST_ROUTE,
        element: <PostCreate />
    }
]

export const publicRoutes = [
    {
        path: INFO_ROUTE + '/:id',
        element: <PostInfo />
    },
    {
        path: POSTS_ROUTE,
        element: <PostsList/>
    }
]
'''
'''--- src/store/userStore.js ---
import {makeAutoObservable} from 'mobx'

export default class UserStore {
    constructor() {
        this._isAuth = false
        this._isArtist = false
        this._user = {}
        makeAutoObservable(this)
    }

    setIsAuth(bool) {
        this._isAuth = bool
    }

    setIsArtist(bool) {
        this._isArtist = bool
    }

    setUser(user) {
        this._user = user
    }

    get isAuth() {
        return this._isAuth
    }

    get user() {
        return this._user
    }

    get isArtist() {
        return this._isArtist
    }
}
'''
'''--- src/utils.js ---
import { connect, Contract, keyStores, WalletConnection } from 'near-api-js'
import getConfig from './config'

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

export async function initContract() {

  const near = await connect(Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig))

  window.walletConnection = new WalletConnection(near)

  window.accountId = window.walletConnection.getAccountId()

  window.contract = await new Contract(window.walletConnection.account(), nearConfig.contractName, {
    changeMethods: ['send_tips'],
  })
}

export function logout() {
  window.walletConnection.signOut()
}

export function login() {
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>For local account login, Please run the following command in NEAR CLI, then enter account id here.
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''