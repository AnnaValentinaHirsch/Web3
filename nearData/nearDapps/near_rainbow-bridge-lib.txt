*GitHub Repository "near/rainbow-bridge-lib"*

'''--- .buildkite/pipeline.yml ---
steps:
  - trigger: "rainbow-bridge"
    label: "rainbow bridge cli tests"
    build:
      env:
        PATCH_RAINBOW_BRIDGE_LIB: "${BUILDKITE_COMMIT}"
'''
'''--- CHANGELOG.md ---
# 3.0.0
* `rainbow-bridge-sol` was updated to `2.0.0`. This library now expects NearOnEthClient constructor to accept one additional argument: `replaceDuration_`. This library can also resubmit header on top of header that has not passed challenge period. Under certain conditions.

'''
'''--- README.md ---
Ethereum to Near trustless, fully decentralized, bidirectional bridge

See https://github.com/near/rainbow-bridge for Installation, Usage, Documentation and Examples.
'''
'''--- config/index.js ---
const Configstore = require('configstore')
const path = require('path')
const homedir = require('os').homedir()
const changeCase = require('change-case')

class RainbowConfig {
  // Remembers the description of the parameter.
  static declareOption(name, description, defaultValue = '', noConfig = false) {
    this.paramDeclarations[name] = {
      description: description,
      defaultValue: defaultValue,
      noConfig: noConfig,
    }
  }

  // Adds a list of options to the given commander action.
  // options is a list of string representing parameter name.
  static addOptions(action, options) {
    let prev = action
    for (const option of options) {
      const declaration = this.paramDeclarations[option]
      const paramCase = changeCase.paramCase(option)
      const snakeCase = changeCase.snakeCase(option)
      if (declaration.defaultValue) {
        prev = prev.option(
          `--${paramCase} <${snakeCase}>`,
          declaration.description,
          (value, previous) => {
            this._processArg(option, value, previous)
          }
        )
      } else {
        prev = prev.option(
          `--${paramCase} <${snakeCase}>`,
          declaration.description,
          (value, previous) => {
            this._processArg(option, value, previous)
          },
          declaration.defaultValue
        )
      }
    }
  }

  // This function is called when argument is processed by the commander.
  static _processArg(name, value, previous) {
    const constantCase = changeCase.constantCase(name)
    const camelCase = changeCase.camelCase(name)
    if (this.paramValues[name]) {
      console.error(`Argument ${name} is specified more than once.`)
      process.exit(1)
    }
    if (process.env[constantCase]) {
      this.paramValues[name] = {
        value: process.env[constantCase],
        paramType: 'env',
      }
    } else if (value) {
      this.paramValues[name] = { value: value, paramType: 'arg' }
    } else if (this.configFile.has(camelCase)) {
      this.paramValues[name] = {
        value: this.configFile.get(camelCase),
        paramType: 'config',
      }
    } else if (previous) {
      this.paramValues[name] = { value: previous, paramType: 'default' }
    } else {
      console.error('Unreachable code')
      process.exit(1)
    }
  }

  // This function should be used to retrieve the actual value of the argument.
  static getParam(name) {
    const res = this.maybeGetParam(name)
    if (res === null) {
      throw new Error(`Parameter ${name} must be specified.`)
    }
    return res
  }

  static maybeGetParam(name) {
    if (typeof this.paramValues[name] === 'undefined') {
      const camelCase = changeCase.camelCase(name)
      if (this.configFile.has(camelCase)) {
        return this.configFile.get(camelCase)
      } else {
        const decl = this.paramDeclarations[name]
        if (
          typeof decl !== 'undefined' &&
          typeof decl.defaultValue !== 'undefined'
        ) {
          return decl.defaultValue
        } else {
          return null
        }
      }
    } else {
      return this.paramValues[name].value
    }
  }

  static setParam(name, value) {
    this.paramValues[name] = { value: value, paramType: 'config' }
  }

  // Get all args, but without daemon as array of strings.
  static getArgsNoDaemon() {
    const result = []
    for (const name in this.paramValues) {
      const value = this.paramValues[name]
      if (value.paramType === 'arg' && name !== 'daemon') {
        result.push(`--${name}`)
        result.push(`${value.value}`)
      }
    }
    result.push('--daemon')
    result.push('false')
    return result
  }

  // Iterates over the params and writes them into config if they were set through arguments
  // or default values.
  static saveConfig() {
    for (const name in this.paramValues) {
      const value = this.paramValues[name]
      /*if (
        typeof this.paramDeclarations[name] === 'undefined' ||
        this.paramDeclarations[name].noConfig
      ) {
        continue
      }
      if (
        value.paramType === 'arg' ||
        value.paramType === 'default' ||
        value.paramType === 'config'
      ) {*/
      const camelCase = changeCase.camelCase(name)
      this.configFile.set(camelCase, value.value)
      //}
    }
  }
}

// Stores key values 'my-param-name' => { value: 'value', paramType: ...}
// where paramType is one of 'env', 'arg', 'config', 'default' representing where the
// value is coming from.
RainbowConfig.paramValues = {}

// Stores key values 'my-param-name' => { description: 'my description', defaultValue: 'default value', noConfig: false}
// where default value might not be provided.
// noConfig indicates whether the param should not be written into config.
RainbowConfig.paramDeclarations = {}

// File that stores config.
RainbowConfig.configFile = new Configstore(
  '',
  {},
  {
    configPath: path.join(homedir, '.rainbow', 'config.json'),
  }
)

exports.RainbowConfig = RainbowConfig

'''
'''--- eth-on-near-client/dag_merkle_roots.json ---
{
  "dag_merkle_roots": [
    "0x55b891e842e58f58956a847cbbf67821",
    "0xfba03a3d1902b9256ebe9177d03242fe",
    "0x2b186dc65b93be71780e5194fd44fc70",
    "0x94c0532d49523cd9309057a847ef0dbd",
    "0xf61d6da773315bdd4c79418186ebaa4a",
    "0x28e89dd2e1e5e09ee3e4cf412af58a0e",
    "0x54a0171c74e7336634f5b6b61f2b302c",
    "0x3be685b693d9ddfc342406fcc8d98512",
    "0x1887acc39d0818a7c6d47e33904a150a",
    "0xe1434e68f6a9f30252e2f31be8db9658",
    "0xa5e981ffaa1f770de8a1d21550f49755",
    "0xf4a55238db60864330a300e1d05dba16",
    "0xf4b2032ab23f95f9c9516db6d43372ce",
    "0x5fa11b8f22bd56e5bbb4cb0f843b6730",
    "0xad4e75d7abf04b5798d8d0c832bf6833",
    "0x7df3208dec48fb446e0f89da95843d8a",
    "0x250e4cae8e10486589190b68608af301",
    "0xa55b182e12b1433a4935514bb729d2b2",
    "0x99456d6b4f8886afbbafa6a758830a92",
    "0xcfd122fe8a0b3c8984e1a603e97bae53",
    "0x0d05ebdd6eae46efa4b0c7694e6db158",
    "0x7e59bb58278cbd8f9470fe8636c4edee",
    "0xc48e2800c2442220eb1d0a9d9d08b437",
    "0x185f8beff965e31b7859b9b63fc79f97",
    "0x6e6c22abdb238266d3fa0f2902f85d7c",
    "0x7345950e2b649e10596ae6be11782110",
    "0x0cc51bae63bfb29add017e4a0f89f97a",
    "0x0a5a13ee1aea57228395fc64b8a1852e",
    "0xecb847d99f761b457747886f4e0c81d7",
    "0x9eaf4241ffab9b2d693b96420dbd0356",
    "0x93f46416f3ef2d5ea57fe1a25c89cfea",
    "0xec1ba1810cafc7c0fe76e7bf50809bb2",
    "0x5ce691721774a58d63e53da2b80f0dbc",
    "0xf570455f0bfca4359608d92ba076c0cc",
    "0x1cdc79438ea2129bc739fc9497f53c14",
    "0x52bfc78f0fc5839e04f1c729c73a1469",
    "0xd711787384841b856ff7f4d53e5e42df",
    "0x63dd408ecfdd6e71d45cddfd45aff23b",
    "0xb0b09781e2c5249c9c248e0062a681ea",
    "0x0d9d5d09f198c9637b510bbac6f33f34",
    "0xb572f9b06f63d012d848174bd1191588",
    "0xd7ab790f4a80e62b38d3a8ae4d170832",
    "0x9184028922c8de7accdd9d72106aed6b",
    "0x9d52e83fb1ccb288a8bbd7094ea25221",
    "0xcb56adf452205662e1f83e51c0c496b5",
    "0x761eb4593abc7603cf0b5ea95d3661bd",
    "0x35ca47a1892c4524442a83fdc5231d3d",
    "0x289f4c7339489b0d07c8716fbf169c74",
    "0x75ec671be4712c1ce838fff26ef1122d",
    "0xab650e5529ec2ce4147efe135a061eb1",
    "0xe0e637747620e8c1c0ef440b99eb9ce7",
    "0x94c0e63214f027f2ddd3ea463e44beb8",
    "0x8548626524a60410aee37ee400d237fc",
    "0xd80eb32a857a1f84b23801f6e4242459",
    "0x4853cb0907651c681f1dfbab0646a828",
    "0xecd1edccd4844736d8a8e01d4ab21e59",
    "0xfb58a3ad252f9d576dcd1cfb23d32b89",
    "0x583b5070f416adbbf796976b2ca27066",
    "0x259d6fdcd7c3e46dd1a57ae64abda536",
    "0xd0c6caf2ce368aa85881e8c3bca18192",
    "0x7d54a3c9d517fba4ffb88cace0276c43",
    "0x630201121608bdec230db5d012bacfb4",
    "0x0da36e18ac524cab0cbd44ed0e70bf0e",
    "0x864cf4a44dfa1f5419a85613e03340b3",
    "0xd0369950eb82302e887caaca083d31b7",
    "0x2993e04f04c9b8476e92871886d88d7a",
    "0xdd49abb10a5bfaff4503b3a31874ac65",
    "0x96f5bb80bb703cd6b940b0fab926195a",
    "0x10e2c9baae90477c9be2f10365c29130",
    "0x696469c514035c0cdf657865a76c8b05",
    "0xe988c9b6348ae392d81e9d224c608247",
    "0x81a816b9971534a48e6ec21994b78c81",
    "0x5498cb9019ba94f896e2c04140cd036a",
    "0x17fa73eaa092e4bce97e3ba4b770a0b8",
    "0xe8c7b08816fc5215dfbe44cd46b47dec",
    "0xc30789092db881251b0c5f7373e0c6f0",
    "0xf397a1ac039c5e8bc374d1fd03568042",
    "0x33ec1f25215eae69085a3fbf7a6b27fa",
    "0xf6fdd17ce7427518d0631e269924f45b",
    "0x036c902bf005559ba3082e5f2201e614",
    "0x1fc45e655afc624fb90a7e0795b20b86",
    "0xbc94ffd5e4f606a12f0c0425d7bf1013",
    "0x21abfc7ec366c0b93e047d0d9d9df4bf",
    "0xb8a9f1c0b2d0601e00bb6fa35f3970e2",
    "0xd67fcb43ff2287a0cf8cf1f0a78ebc85",
    "0xade2d8bdd4c48bd437b41d2a36424ef1",
    "0xd5550bdc493b35a3480c7a5f5d93e939",
    "0xb069c39e1059a068f9aa767b5a2c39d1",
    "0xe151a181c34b360acc4ae8f41f0eb923",
    "0xfa407454a0690b03f714c08ec72b3247",
    "0x10ffffcebaf525fbadcbe4aa46104680",
    "0x25569aef3173e2e81bd94a5e7904fc1b",
    "0x28681502310381ebc0ae31947c3cb188",
    "0x5db958abc1654596872a50938a0c9b24",
    "0x7c744e082a52a74767b70a72ec4489a9",
    "0x5b18ccdaa7efd9b3aff6bad60d547c81",
    "0x86322eab36c65090a3b7fdb5d7bc091c",
    "0x8423baac6908031fd9d08157f686b2dc",
    "0x08a1ade53581b4c029e1c002e51ceaf3",
    "0xf1ed7d196dff54c3421321acf939e08e",
    "0x2752d9c907207388e62373ed510c4e88",
    "0xc3c06fa841383ac60ccb91e4e05580d5",
    "0xa4c95f5a9ed58116110e43e663425608",
    "0x2c5bd140dff9063bba7ec0a206a3a4a0",
    "0xa5848a52ea19a2e85afeb598ce50eb47",
    "0xff6279dc1306e5169f95f0b060e34b39",
    "0xda33c34ef46e9dd360b8dbe6531901b4",
    "0x83b7e0dbe63ffc49ffc59bae4b7b683e",
    "0x5c051f94fa62a73c11cfee276461fdb0",
    "0x798e3ba76c500e8177f392003ed1872b",
    "0x583d7265ee7126131854bbcb0de1f310",
    "0x90e4980b35640a8b3bb682ef2606e476",
    "0x6d431024b5bffd1270c0d041a05b815f",
    "0x496322b442254a79d1dd0dfdd6f51def",
    "0x92182683f38300b23bc0412e4138ac05",
    "0x212df134572585d10dd251f536025085",
    "0x63e2dbdb3937238a5d08cdf2b578b4e1",
    "0x96b819206e1d15573307e27b6ad290db",
    "0x0c54a577923b77c5a4ee726412c43be2",
    "0x155b53faed668b73ad702c93296a3e01",
    "0x896d7317a2f611e7363d93db93bcb72a",
    "0xa39c09d3a4ba25f3ce6691b85b390f3d",
    "0x7148171957df73a82553216488e35859",
    "0xca049d60e60b7b69047e42f0b436ff67",
    "0x6f402a4a8208e9e49d4bf06f6ce7e11e",
    "0x95773e0c271ded0e10d2b47221c91e0e",
    "0x80fd5388433e89d3e74da2637216e3d8",
    "0xe35fe60581edd06fe880059a63952380",
    "0x24a5b87aba928ac920362a8bb3a853c1",
    "0x5a82f1cd0c0c58f0fbebb02c062dd029",
    "0xd8a989f4d05f65c07cd4f78d4c83d6de",
    "0x7e100ed69fa83cb97318cf268e063802",
    "0x5f7d7cb3363d1c4b41736787c8fa3a36",
    "0x03292bdeef76208a33368b1dd89c5f4f",
    "0x6b619e4bfd91e47efc4c6a18d6d2ddd4",
    "0x49e98cfac5039df5711f7bc82ca704fc",
    "0xbd17f87c484f37449d0cb26bee85352d",
    "0xb29204f91eeec3a61cf80f78d341e981",
    "0x0e2806dac2236f555aa1b60d44e6bb94",
    "0x84762739d031e5c2809951560a9aeaa2",
    "0xdf1404d9feadf66ce9b6106bd730323f",
    "0xbf36c772e3f353b177dd77ff0af7f658",
    "0xc01a75724444ea62092d205d4f1faff8",
    "0x0eb6c4edf01055c26f19606f80660a82",
    "0xc5475e77e5b769f6e97f0aee53bb2927",
    "0x3a2a5f7f0ca0c8270800aa61bf75a256",
    "0xe2fbc1e07d14ac6e3a96cc9055750013",
    "0x226e5bbb1137417f87d4d0a638739739",
    "0x745c89d0db4461d9cf03e483f9ed2d66",
    "0x70ab39feaf98c852e8fac994ca8cc297",
    "0xcd9d7ebd5e7484375ec35bda9ebfad9b",
    "0x080de890fd9263b983b58e52f6dee214",
    "0xf67c8e857d379a60f7bf47b13ec08dc8",
    "0xb0b8ce46fdfa7f8b0091182cd9e52c19",
    "0x3fe2d70b44670254ddeaed4e46ba2d6a",
    "0x1e0f257e0107db4a3be7208c3490f3e8",
    "0xd0eb4a9ff0dc08a9149b275e3a64e93d",
    "0xeeab095cfa3a4dc8de4daf9c3e5affbe",
    "0xbee906bac51d709fa6c8d852834506fb",
    "0x85cd74d6633623e3e09d3b2ea0e8eebd",
    "0xf296dfe85523c5ab10cda4edaa513a52",
    "0x7d8ced87ed7fd15b2e4bbc0264e76f99",
    "0xae69988dd1df0ff853e6ee66a5fe3210",
    "0x4469c4d95255369c6461be2862b915b4",
    "0x5709b43c1560bff7d265cfd850627680",
    "0xdeb4f8617f931348359a3811076a30eb",
    "0xf881b9bdedd6f655e33220d24e1cc2eb",
    "0xad903ea64fc18d570cd9a50e86bf033c",
    "0x4b3ac2630be5f8aab921697d1d1404bd",
    "0x07d5dd8bb48e7a72880b329cff744c4a",
    "0x84567d5b5e74e94c2373574d42ade1be",
    "0x63cf6b1ebbb29334730d8b9321cd264d",
    "0x83094b1464a6bbf92363619af081e20e",
    "0x7a93ae31b228b723301bf96ab9b0a09f",
    "0x16873ac9aead7c99286cce23dd91b4ee",
    "0xbf293be8af1eb38d7080957c7e1f8aeb",
    "0x967668d49545810fcf18632a5a3431e9",
    "0x475d5bbd6272a2695f66d2056da42bd9",
    "0xafc7e6ef08b5b8dc7a2bb1027160cd9c",
    "0xaa694f10ce796540ed77418cd9b35c86",
    "0x8be1f7a470d0c1edbbec6728fb0ff366",
    "0x7444078510fe6d9b3cf94188059a1366",
    "0x3739215eb46221b4040eea02c7757573",
    "0xa71b11286fff39e65eb3c8b3ac9a7219",
    "0x4b48bc59af9ddec38279e60178263779",
    "0x6076a0b6743690958cf040bfaefac391",
    "0xbead81dbb9227ba51a02f827f8dee2c5",
    "0x89508f9f01576f81853e8b92ba917838",
    "0xd075a5b5dcf20971f2e70e816bbcbb7e",
    "0x009554c550589a814909c9805279c743",
    "0xb470cf622846d536ad7b288b9074d667",
    "0xb87704373978613853240a3ec9368e8b",
    "0x7127b8d0e757abd6830b787afd829201",
    "0xf0cab8ea67e0a38ad606ab83ba6bc67e",
    "0xa408633718e44f4817c329af0395aabb",
    "0x4607a3ecef00a24da74521f22a6f8bee",
    "0x917cb60d42ccc40442e48be457f51dea",
    "0x90222d408a76f7f55fbb18282bef90da",
    "0x481d56afbd0ba6978e0ab2ada7b3506c",
    "0x604d874175bd36f8a02ce56b31ca827c",
    "0x6dc7717dfba128a330ea277dca94141d",
    "0x86226285351eba0c6e818826b1c562fb",
    "0xae7280a5b84931846adff138820f221c",
    "0xbe628492637e26e6489375f3a2938180",
    "0x7559678bfebb6f78e5c8026b17eadca3",
    "0xf38e7a19c004dd22688cf0079680bb1c",
    "0xc3b0e6a2b106f925aa2f92aac6213f8c",
    "0xeec733087a807a87a0c346de11513e12",
    "0x4c6d1ee77b414dc3bc448ecc0769a376",
    "0x303db177352ecf1920f09ba9fc8c6514",
    "0x8e38c47ebaf4ce8dc05178f3c5a9e86b",
    "0x104570237e9cbf0f4836ec8c4ff42f65",
    "0x4776ebe704f27086bcb98059906e8e3a",
    "0xc5aa722b23a6deef1d15a95f32dc4797",
    "0xc6188b4ee8720e1efa99aebeb02c7a67",
    "0x32701ac4e10f922048e0a7368e1f0452",
    "0xe5988223410c1d4f4260994faaf952b3",
    "0x2a92d9428c88e74bf47e545ea2025857",
    "0x04ca250a42e1f227955846abb768a035",
    "0x05b4a77d503468b71c0e730753fc1a56",
    "0xd7caf66b03181401cda1369c123d19f6",
    "0x6d3e29cb829b58d3fe90129c20dc9abb",
    "0x41b4f0817f11f8016023d74dea3eec97",
    "0xaeaa60d08ac92150b54908f7f8a92857",
    "0xc9453b8e185fb93ea0e1282e8803eff0",
    "0xe87f027df74563c88e700dfe057432ee",
    "0xaf377ff39afc683033823eeb3ed0f10b",
    "0xf56a0b076a6bfc3eea7b1804b946d947",
    "0x69ba2470b6623fa3b9d68124e329513e",
    "0x575aee5f222f5ae9cca0973be3ad572f",
    "0xda97a6cd52c728a6f3bca987ebfa8cad",
    "0x4b5536ec8aad2250a2e38f6bfcdf58f4",
    "0x8fd3b4c5ad2c5743a6aae9f8219a60c6",
    "0x145b1a9812d684da23e74fead96c8552",
    "0x7617defe6ad9c021bc9bd7c809675624",
    "0xd9a2e97eaf84cce6294581acce315ed7",
    "0x3199b22620f39d534cd96fa8a032998b",
    "0xb1ca9b7eb944ea1f16364a1222b9afcd",
    "0xecd0e506f3792f650fe5a00694afc356",
    "0x3b96f1eb7ad3124a51372cbe56f5c5e4",
    "0x962a5ed01d20d1202172cae5c4b1c7ed",
    "0xb5e9dc0e5c554931dba835dc88102421",
    "0x4596b31e8bf6c1f24b122de58efc7e1b",
    "0x224536fd41573a41daf7e131be8bdb09",
    "0xef9661b2ac61737aa4bbba6fcad9f860",
    "0x26c9661a65164390de94c2d38c1f568a",
    "0xcc0b4699871953942cea3d167e8c9956",
    "0x575617f32549dc68ceb014b2f69d3b80",
    "0x932544c41c0e2d7af28189e513fb7ec5",
    "0x4b8e46de3ce76638280b9a699dfdb620",
    "0x53406aff68e56538b48fb98364e1a5a5",
    "0x928ae8d7116355d36b946a8182fc9923",
    "0xe30282bce7cdf44def0f840b6321e335",
    "0xbeed3d40f310c0c6d0e18443f3304a60",
    "0xe2725bfdbac45fa18dabf0eb892f03d9",
    "0x07b43c42513772bc09aac4e471d67b16",
    "0x8609ba6e215f939caae8770e47d25f8a",
    "0x4287aec47a1da79aa2351f31cbd4ed0c",
    "0xb033cc4424fc38cbf7992491211c84c5",
    "0xcce1d898301da9cddb02d7f36181f8c2",
    "0x79e12de9d9e677ac2322705cc8a922b1",
    "0xc448a85e856037d8e88f672979a551eb",
    "0x467403ae25f597deb3c1094a2d33d413",
    "0xd7e03948dfccb6abb773409bd4a3c930",
    "0x674a8c75924d08965e7039c2e41f7940",
    "0x9220bbcb1742381fd5936662dee7210f",
    "0x505e4a4e5a49243957ee68bcf2ddb9e4",
    "0x85952e0b3c1032f7cad908bbd3a2b8a3",
    "0xf6e25da02626214f2dca471706a057d0",
    "0xdc7efbb16d990fb6db9e68efbc7fe740",
    "0xa3231a207b1daf19693a1a5ad18c6ac4",
    "0x90c5a0bbbc65a3fe44f2be3f860c5f0e",
    "0x3d8f53b6024c3b33b9097cc678de9a28",
    "0x1ad8cb3b8d1d4e04bb25330acd10b3e7",
    "0xc4830b15a969f30d1592527eda63bf82",
    "0x9d51b6f0c5be845ef775b6b900f0c993",
    "0xabdb6ff729edfa1fdf81725236fe166c",
    "0xf92a2b3fb5ebe93ee6fdac51e55f58d0",
    "0xbad463d68b2067ee099b35bc976d4262",
    "0x8a326abf1bf139fd19a9931aad716e2b",
    "0x21a32ae99babd87319e21b115291fa93",
    "0xaed51baf66ff4910f3b84c6dddd277d0",
    "0x65c3bbb3015925ae57d939a67bb3e1a2",
    "0x97bc9538e14c7d221d3fba271fe1a9a3",
    "0x6394e2557149a2acf674610e834f02a7",
    "0x280dcfe6935188046eefb81a77e043db",
    "0x313d0d27a7b82f6e85b32037b3458025",
    "0xaf7416b95834809dc8619c24d9f70575",
    "0x9e14b1882ac75f1b7ac8735e89bd1dcf",
    "0xf770f4047a86f36727fcde69c0cb8b68",
    "0x004610125634efd77979c429a95f16e9",
    "0x9fb78c563cc2617353fb943c5c6029d9",
    "0xaddc6c96bafb15254e0e2c2a21f6eca0",
    "0xb2e1d71c4419cf35d2ccb202727e9006",
    "0x22c2cf6192e5f767d518ba32d2628f27",
    "0xd4a9a8dedeaa916c20451f72d868e54c",
    "0xe15c7e3a6935f188aab577be046518f8",
    "0xd00f06b2b19fb192d885586001624318",
    "0x3c1133d7e7085944fa800c1365d4b4f3",
    "0x3963a16de74721a202e7f10d66278fe4",
    "0x2f886a0a39058911d72b46e15bc34672",
    "0xbf8c454a96a689eb71c30d9639aaecee",
    "0x761b3e46118bc24bc62987107f3d12c6",
    "0x891583dc69ff4a5e64070d942aaa435f",
    "0xd8b34532a52763f1afd495aa3e36b2ef",
    "0x2f9e4d03913cd937e09c451b3ed20dcb",
    "0x93d22323cd8c06ec945733ee811d8ac8",
    "0x2a9d9c385dc260a178c9dd5902499f7e",
    "0x45e79066792ee537ae6106b3c897d44c",
    "0x4e00df4f849deba8f05284dba1a8daf6",
    "0x9ed2f8a53f69dee1e9b2d4a332ac80d5",
    "0xb0cb763b4c0e4bddbdeab130195681bb",
    "0xc25c64f479521ed7a68cb75637498e67",
    "0xa66e88f5a0279ebbfc9063d5d7fc9681",
    "0x97f23e83e5a2c1e6209a1e0baa4c9048",
    "0x08efb5ef7d86b52c486f88ea92865e2e",
    "0x750b98718c4d7f9b63a0fe4135a00143",
    "0xbd71d4d32938661a8e4e8e198f6e3c71",
    "0xdac6dce2e49f253706ee5ea4549abb67",
    "0x1dfa7fc8cff2108f4de96a6f6404321b",
    "0x58fa94796612dacc2f2a60fbac5f85d6",
    "0xaf4a599a7afc59244662fb56a32f38cb",
    "0x7b2920aac8c076c5fccfdf3325fc8455",
    "0xb3328f0b1057958da28bab59330133a7",
    "0xad4e0add9ad103421f47d88eeb5c711f",
    "0x4825b9d42589e834f61e6ef705641713",
    "0x3da44d4f1d8bb790537ec42ba2af168c",
    "0x87db7dab6b1aa2857fcf861273b9a58d",
    "0xc32c902e1389ebda24a09ae882575370",
    "0xcf17c3f198e852d5123942c402918656",
    "0x9f1cf97072ee00922c301340a19c91b7",
    "0xb3e163f4cbeac4437a962c84a85a1e5b",
    "0xa70314ea9655ebf03ee78a4a320d1ecc",
    "0x2ab485395195fd37e0fd5b2336f0a00a",
    "0x9f77060b503e1fbccf8b682215821b07",
    "0xa4fd17b615f2794b3fbb98ac81e0c5e7",
    "0x3e7faa44b3e919bf089ce8962a41596b",
    "0xf1cb06f527cfdb2bfb3e3341c878101d",
    "0xfe8cedf87702d7b090a0f07571607d86",
    "0xf569a8f30771d73544ad99fb1610b174",
    "0x1e332a7f9b33fc91369ba33503353023",
    "0xe04c52de8e81749474a0a3ef746c4c9d",
    "0xe961634b1721573ccbaf4c195ece7bd4",
    "0xc50b42bd793d49f0505df93353c4acde",
    "0xf8a9ea7fd860ad32e03ed50aebeb92f2",
    "0xf6a622025cb1659a5bce3c4cc7ed0680",
    "0xb6a78250c0253c2a8a985beb3ed16309",
    "0xd2ba47f421049058107969e08458e7bc",
    "0x66809b4880f156c8f539441829d11b90",
    "0x980b88f3b17ad1bf46ddc89356df550c",
    "0x083177d975088d3b3acb85c5e767948f",
    "0x07a3e31da3988ccc22a48cb61890ed83",
    "0x12c4f7a7402ada8fac7c2ddc784ca2cb",
    "0xa7bd8cdd867b4b3812f3066b3db3c006",
    "0xaa098d01c41cc948c138f864a8a62481",
    "0x18457233e28062083f7d23b2e481189d",
    "0x1702cda0b76772ba09cea0edc5e5746e",
    "0xdb200270afe9e05cba79d94ff6d2da8c",
    "0xb93ce415bb6beb51157141149e34bd0e",
    "0x6266741ef0b85a2fd5ac4a1fb816835b",
    "0x8dba28245cf055574881b05fef9953a6",
    "0xe4af90f7979c2c631633131d642dd8bd",
    "0x97f98f4275be120a445cd0275e2cd73a",
    "0x150a9c0526b11752453a23d8b18a8f3b",
    "0x010bbf6895ade2375c8478a0c3151ce5",
    "0x355796530fdacf6d87bcc370f17fc71e",
    "0x9a404317c26f415ed025f32dfabe8598",
    "0x15d2eb783afced72c733f6ce90bf7349",
    "0xfb9f445a7acf24b91e6cbe8f9489a7c2",
    "0x6f03e5d4ef52a7c05a5a5fd28b159b5b",
    "0x2466fb6d4eb8aa1c700e728fded218df",
    "0x676cfafe2fbcffd070ddb236d2bb0021",
    "0x91e33a111622283750412eea13c83f35",
    "0x88b1f25057c3bac8ee1eeca2ff2209a3",
    "0xc10d6e9c953ebdc8ece36c5cd6223387",
    "0x1fb01164b818aa63387a0ec14be5e3e7",
    "0xaca8367a8bfd04541cc836e293255b77",
    "0x8b74b13c0d49da16c37a8de608c18e7e",
    "0x79e4197b401889e0756cedda74f46812",
    "0xfdfc1643dbd6ad08bd6a4eba37a0e3c3",
    "0x3c4b6a74dd034b4e72bc84652a09a3ff",
    "0x2f31fab52ef05919d280c2abcf422fab",
    "0x4a2f98048e8605e4d439ff8554ab6e63",
    "0x3b7e760d63c75a4c368dd53425084427",
    "0xdbd55facc2eed4edae760a2ba92b4f39",
    "0xf0e079daee7e4fae706c60345eaed7c6",
    "0x00cd47758ac9dfe055865748f9f15b3a",
    "0x5bb13e4d95fd1a1d551a0a8bbb724fbb",
    "0x2ab38207d22885d80753f77eb8f11188",
    "0x77af57a3e73852729f602770889d41f6",
    "0x4e76a9575455c544259f6fa4dc28ec73",
    "0xdced4535167e2f1ff0075e1fbca1f32b",
    "0x94ac1540daf6ee75412dfedf521ac26b",
    "0xa5f4edb22058795428c0e3f0984c4e42",
    "0xc21b458e1b2973ad8d1a42865476e420",
    "0xb8edf8bfd4fa0dcd9d68ca62de7f8163",
    "0x8ca26ec2b20aaa2a003f4732b133d55e",
    "0x518a1c489f3d366a6175a6c27caedb6d",
    "0x11aa2bd74ac3e01a7ee5d413d3607681",
    "0x3f2e4621aff23efdbe33e8c828c4d45a",
    "0xff373231626f5dbcb6f1e0216aaec0ba",
    "0xd400fa2884977ede9fb3667d23d984db",
    "0x3ec403699e9f2e18d23f8e777cafa676",
    "0xb6d0a777a0ce6e68f7bdeb79f37ae378",
    "0x9e20d21eaa17f971543fe70ac15df078",
    "0x8566b7226d025a7fcd4d61a7cb76edef",
    "0x86d6b187f841cb3fcc92a27060e8f9ea",
    "0xbf8d2e422a91c28cc445cb08a87bc401",
    "0x0d64d2fbbad9c1b0530052ea47d4539b",
    "0x0d5279a8100c0a044cf13882942f3c5e",
    "0x4d914c7455896b6aeafbfaf5bbb7c69f",
    "0x34859258bb4bac5923fb3c73c8e95fbb",
    "0xcb2409f400cef34f88c7f29b731d7d59",
    "0x7e9bc66a6bc2a5c5692306db1b6c474f",
    "0x9b125466b31b3e4275b9c3f477ad9bb4",
    "0x0682605f164269183277a0bfa1a7aa86",
    "0xfdf029dca743acf24f4cbebbc846e990",
    "0x4e5fa1902e699e059e6ac657585525f3",
    "0xc70fced2684c45f39a227f1b0e6a2639",
    "0x2e8ca3caf417021d3209da66f0d125b8",
    "0x18a51613c5ae13e32c5bcf4965b78583",
    "0x402ece445768d17f2790dc0cdbf7f9fa",
    "0x7ef9cfe23a9f2d9b5fa10cc91e601f1c",
    "0xba2dd4d240fbd92f1d46cd90a63cb301",
    "0x29cff10b881311ce6292a765b9086853",
    "0x9a016ffcb23883d0328d0183e035ed18",
    "0xffcbd9d2ef2912e64d811c45700fcaec",
    "0x0ce6dccd903d0e4809ad3e300da7a455",
    "0x846bc24d47b884f73346f81788688374",
    "0xbb5094794e59876aa8301adb7126a2c3",
    "0xb8f55aa699f64d44a2c944246686298a",
    "0xb824a33ef385a5293d2570326a7227c3",
    "0xa9d724a77e1f87aaec95df4050649b1b",
    "0xc0a76950b77ced186bdd52e1dc3ba8b7",
    "0x38c28c14bfa88693bf306588e08ae09f",
    "0x04f9280b95c9812a51299359c770b913",
    "0x94f78ea30bbbc5024bc05c06fc80a3a3",
    "0x57e2ff4bcecff754849ea5c15684df75",
    "0x9064b534593c012115617b850814974e",
    "0x96b84b73c9bd4fe4686b9c5e47057279",
    "0x79422e6008157852225f4960b952ce94",
    "0x16e6b48564c7f62bb0d6a5d8562f71e1",
    "0x9ba574947f637db0922b5a3411b39073",
    "0x9c0ea3342b493673eb6ba7c0f3e33001",
    "0x13219cddbc960a443b68f73348bdabb7",
    "0x9612e953f80bcec6fd9c11e80642e07c",
    "0x7e1a63fe5d68d66440f69212f0d06a7d",
    "0x29388bc27f370d522dc179cfddcefcf0",
    "0x22d098169c99d823adbc0279467cdd55",
    "0x8cb0763f7a0ec5aa0761bfbb049fe2c1",
    "0xccd344c4e3b6b028253a724d7014b831",
    "0x8a409beab35999899ae65a0b4519e081",
    "0x472da5358a5c51cbe55d4beadfa8d2ef",
    "0xaf3eb432bc504607d20dd9b93fdf0382",
    "0x15652ee8ba674184c53238346e7c2818",
    "0x1038ca6c9eca2e2240ae40dcee168d7f",
    "0x8f99e10b2925562e1061f7ad3a7f591e",
    "0xec7875f6e017ec743ce364f257c79a70",
    "0xdf953a9008d4f96c63da1993439a81c6",
    "0xc44353ffa531580a5bbbbb8faa0855cd",
    "0x4d2020a9a71a5351f415552099e2760a",
    "0x39c14bb1c059f585fd4ba723dc1c66ca",
    "0x4fbbf8b5795d2a8b7a83b3768869b5e1",
    "0x8210215bfb4ace609e0fb0973ac511de",
    "0x16fba09f0e8ecd584d0524a4c5723a8b",
    "0x8619f37f7511cec0777ab7efe07ae451",
    "0xa4ff22443285056f6e6be1bba3a886e8",
    "0xa13fb0480ab2fb0cdb3a1373694323f9",
    "0xc9b9c6a82b04c72d8970ec3e015c2607",
    "0x064449044bd883c413684d6d29eef904",
    "0xb1896f87a9ae66ec233de69dd5b5fc50",
    "0x4d39896b61686334603e8accbb0288ff",
    "0xe0687ca2fc99a162a61e83da0f54dfea",
    "0xe12c1c535fc6f6498de80b0da9094c80",
    "0x4731d5e4b9421510c3ddf73d87a9c4a3",
    "0x247a38f6f0fcc658fc35057787bd9054",
    "0x8974ef985b8dc87bbf14f16657f3bd30",
    "0x89073a016fd5c618095291915c5912e1",
    "0x86f16e07d569b7570af0031fb6c36af4",
    "0x12d5be9063d155f9df791be6c35f1865",
    "0x8962f4ccba3d7cb61f0a501d474f9906",
    "0xefee4030b687d7ae3eb2d27673f65343",
    "0x2464c007ea23451f778ed2bf0c017b7b",
    "0x6dbe36b12f350e01689f6295d686b8b9",
    "0x025cafd23d97228050066bf4128a4fa3",
    "0xde0bb757deba77755678381d08a12bf1",
    "0x1c542ed68bb6f818c4bee47703298d08",
    "0x8178b368306f2ae1abd7e68583d67dad",
    "0xcb4d956080d6f8bb617a2d51e5ac1296",
    "0x06dc4c3c0f4d7c5f4784f3e865433730",
    "0x7134fde96ed353c8d6ac24ec7efccaf9",
    "0x1466a522411631d6c9c5c706558985c1",
    "0x95e26e89a1c7b9df6a7c2c56223292b5",
    "0x6555486abac007b7fadaf6e04f896239",
    "0x472a1d76a9734964c42b92b36993ed49",
    "0xcea176b441e44750555739f29e045e74",
    "0xfeb06e244cdbf8e8cb1d5fab49c6e583",
    "0x499c5a7fc475c7ab9e888a9f8aeb5765",
    "0xd3b05f45181c0b1b4a0354ffe3d95c9a",
    "0xb768bcc1492f03e1819620dfa2e130d5",
    "0xa38c13579500a7c7a90c80153ab22f4f",
    "0xadb73d387c59a6ba8eff18a6b0320ca4",
    "0x09c8e0bdd1ba73602063d89d11ff5210",
    "0xecab8f890f1f3d6ff564eebab034ebb3",
    "0x9823e2e8911c5a0fb2ff6feb52be2c0f",
    "0x4fa03dbaabcf99e71903f3177444bfaa",
    "0xa4c9667d00998d262c47f6d2c79f43c2",
    "0xb3e65ee26384d25bc7750b3f37e72883",
    "0x7dea46d1a183f3070760eee0bf5fce3c",
    "0xecb2963c22a757569fe659635f4b0243",
    "0x9ed968203144981e6e697db052910c27",
    "0x4aa6ca6ebef942d8766065b2e590fd32"
  ]
}

'''
'''--- eth-on-near-client/index.js ---
const { web3BlockToRlp } = require('../eth2near-relay')

const Web3 = require('web3')
const BN = require('bn.js')
const { BorshContract, hexToBuffer, readerToHex } = require('../rainbow/borsh')
const roots = require('./dag_merkle_roots.json')

const borshSchema = {
  bool: {
    kind: 'function',
    // @ts-ignore
    ser: (b) => Buffer.from(Web3.utils.hexToBytes(b ? '0x01' : '0x00')),
    deser: (z) => readerToHex(1)(z) === '0x01',
  },
  initInput: {
    kind: 'struct',
    fields: [
      ['validate_ethash', 'bool'],
      ['dags_start_epoch', 'u64'],
      ['dags_merkle_roots', ['H128']],
      ['first_header', ['u8']],
      ['hashes_gc_threshold', 'u64'],
      ['finalized_gc_threshold', 'u64'],
      ['num_confirmations', 'u64'],
      ['trusted_signer', '?AccountId']
    ],
  },
  dagMerkleRootInput: {
    kind: 'struct',
    fields: [['epoch', 'u64']],
  },
  addBlockHeaderInput: {
    kind: 'struct',
    fields: [
      ['block_header', ['u8']],
      ['dag_nodes', ['DoubleNodeWithMerkleProof']],
    ],
  },
  DoubleNodeWithMerkleProof: {
    kind: 'struct',
    fields: [
      ['dag_nodes', ['H512']],
      ['proof', ['H128']],
    ],
  },
  H128: {
    kind: 'function',
    ser: hexToBuffer,
    deser: readerToHex(16),
  },
  H256: {
    kind: 'function',
    ser: hexToBuffer,
    deser: readerToHex(32),
  },
  H512: {
    kind: 'function',
    ser: hexToBuffer,
    deser: readerToHex(64),
  },
  '?H256': {
    kind: 'option',
    type: 'H256',
  },
  '?AccountId': {
    kind: 'option',
    type: 'string',
  }
}

class EthOnNearClientContract extends BorshContract {
  constructor(account, contractId) {
    super(borshSchema, account, contractId, {
      viewMethods: [
        {
          methodName: 'initialized',
          inputFieldType: null,
          outputFieldType: 'bool',
        },
        {
          methodName: 'dag_merkle_root',
          inputFieldType: 'dagMerkleRootInput',
          outputFieldType: 'H128',
        },
        {
          methodName: 'last_block_number',
          inputFieldType: null,
          outputFieldType: 'u64',
        },
        {
          methodName: 'block_hash',
          inputFieldType: 'u64',
          outputFieldType: '?H256',
        },
        {
          methodName: 'known_hashes',
          inputFieldType: 'u64',
          outputFieldType: ['H256'],
        },
        {
          methodName: 'block_hash_safe',
          inputFieldType: 'u64',
          outputFieldType: '?H256',
        },
      ],

      changeMethods: [
        {
          methodName: 'init',
          inputFieldType: 'initInput',
          outputFieldType: null,
        },
        {
          methodName: 'add_block_header',
          inputFieldType: 'addBlockHeaderInput',
          outputFieldType: null,
        },
      ],
    })
  }

  // Call initialization methods on the contract.
  // If validate_ethash is true will do ethash validation otherwise it won't.
  async maybeInitialize(validate_ethash, trusted_signer, robustWeb3) {
    await this.accessKeyInit()
    let initialized = false
    try {
      // @ts-ignore
      initialized = await this.initialized()
    } catch (e) { }
    if (!initialized) {
      console.log('EthOnNearClient is not initialized, initializing...')
      const last_block_number = await robustWeb3.getBlockNumber()
      const blockRlp = web3BlockToRlp(
        await robustWeb3.getBlock(last_block_number)
      )
      // @ts-ignore
      await this.init(
        {
          validate_ethash: validate_ethash,
          dags_start_epoch: 0,
          dags_merkle_roots: roots.dag_merkle_roots,
          first_header: blockRlp,
          hashes_gc_threshold: 40000,
          finalized_gc_threshold: 500,
          num_confirmations: 10,
          trusted_signer,
        },
        new BN('300000000000000')
      )
      console.log('EthOnNearClient initialized')
    }

    console.log('Checking EthOnNearClient initialization.')
    // @ts-ignore
    const first_root = await this.dag_merkle_root({
      epoch: 0,
    })
    // @ts-ignore
    const last_root = await this.dag_merkle_root({
      epoch: 511,
    })
    if (
      !(
        first_root === '0x55b891e842e58f58956a847cbbf67821' &&
        last_root === '0x4aa6ca6ebef942d8766065b2e590fd32'
      )
    ) {
      console.log(
        `EthOnNearClient initialization error! The first and last roots are ${first_root} and ${last_root}`
      )
      process.exit(1)
    }
  }
}

exports.EthOnNearClientContract = EthOnNearClientContract

'''
'''--- eth-on-near-prover/index.js ---
const { BorshContract, hexToBuffer, readerToHex } = require('../rainbow/borsh')

const borshSchema = {
  initInput: {
    kind: 'struct',
    fields: [['bridge_smart_contract', 'string']],
  },
  assertEthbridgeHashInput: {
    kind: 'struct',
    fields: [
      ['block_number', 'u64'],
      ['expected_block_hash', 'H256'],
    ],
  },
  H256: {
    kind: 'function',
    ser: hexToBuffer,
    deser: readerToHex(32),
  },
  verifyLogEntry: {
    kind: 'struct',
    fields: [
      ['log_index', 'u64'],
      ['log_entry_data', ['u8']],
      ['receipt_index', 'u64'],
      ['receipt_data', ['u8']],
      ['header_data', ['u8']],
      ['proof', [['u8']]],
      ['skip_bridge_call', 'bool'],
    ],
  },
}

class EthOnNearProverContract extends BorshContract {
  constructor(account, contractId) {
    super(borshSchema, account, contractId, {
      viewMethods: [],
      changeMethods: [
        {
          methodName: 'verify_log_entry',
          inputFieldType: 'verifyLogEntry',
          outputFieldType: 'bool',
        },
        {
          methodName: 'init',
          inputFieldType: 'initInput',
          outputFieldType: null,
        },
        {
          methodName: 'assert_ethbridge_hash',
          inputFieldType: 'assertEthbridgeHashInput',
          outputFieldType: 'bool',
        },
      ],
    })
  }

  async maybeInitialize(ethClientAccId) {
    await this.accessKeyInit()

    try {
      // @ts-ignore
      await this.init({
        bridge_smart_contract: ethClientAccId,
      })
      console.log('ETH2NEARProver initialized')
    } catch (e) {
      if (
        e.message &&
        e.message.includes('The contract is already initialized')
      ) {
        console.log('Contract is already initialized')
      } else {
        throw e
      }
    }
  }
}

exports.EthOnNearProverContract = EthOnNearProverContract
// For debugging;
exports.borshSchema = borshSchema

'''
'''--- eth-proof-extractor/index.js ---
const Tree = require('merkle-patricia-tree')
const { Header, Proof, Receipt, Log } = require('eth-object')
const { encode } = require('eth-util-lite')
const { promisfy } = require('promisfy')
const { RobustWeb3 } = require('../rainbow/robust')

function receiptFromWeb3(result) {
  return Receipt.fromWeb3(result)
}

function logFromWeb3(result) {
  return Log.fromWeb3(result)
}

class EthProofExtractor {
  initialize(ethNodeURL) {
    // @ts-ignore
    this.robustWeb3 = new RobustWeb3(ethNodeURL)
    this.web3 = this.robustWeb3.web3
  }

  async extractReceipt(txHash) {
    return await this.robustWeb3.getTransactionReceipt(txHash)
  }

  async extractBlock(blockNumber) {
    return await this.robustWeb3.getBlock(blockNumber)
  }

  async buildTrie(block) {
    const blockReceipts = await Promise.all(
      block.transactions.map((t) => this.robustWeb3.getTransactionReceipt(t))
    )
    // Build a Patricia Merkle Trie
    const tree = new Tree()
    await Promise.all(
      blockReceipts.map((receipt) => {
        const path = encode(receipt.transactionIndex)
        const serializedReceipt = receiptFromWeb3(receipt).serialize()
        return promisfy(tree.put, tree)(path, serializedReceipt)
      })
    )
    return tree
  }

  async extractProof(web3, block, tree, transactionIndex) {
    const [, , stack] = await promisfy(
      tree.findPath,
      tree
    )(encode(transactionIndex))

    const blockData = await web3.eth.getBlock(block.number)
    // Correctly compose and encode the header.
    const header = Header.fromWeb3(blockData)
    return {
      header_rlp: header.serialize(),
      receiptProof: Proof.fromStack(stack),
      txIndex: transactionIndex,
    }
  }

  destroy() {
    if (this.web3.currentProvider.connection.close) {
      // Only WebSocket provider has close, HTTPS don't
      this.web3.currentProvider.connection.close()
    }
  }
}

EthProofExtractor.fromWeb3 = (web3) => {
    let extractor = new EthProofExtractor();
    extractor.robustWeb3 = new RobustWeb3(web3.currentProvider.host);
    extractor.web3 = web3;
    return extractor;
}

exports.EthProofExtractor = EthProofExtractor
exports.receiptFromWeb3 = receiptFromWeb3
exports.logFromWeb3 = logFromWeb3

'''
'''--- eth2near-relay/index.js ---
const path = require('path')
const os = require('os')
const exec = require('child_process').exec
const utils = require('ethereumjs-util')
const BN = require('bn.js')
const blockFromRpc = require('ethereumjs-block/from-rpc')
const { RobustWeb3, sleep } = require('../rainbow/robust')
const { txnStatus } = require('../rainbow/borsh')
const MAX_SUBMIT_BLOCK = 10
const BRIDGE_SRC_DIR = path.join(__dirname, '..')

function execute(command, _callback) {
  return new Promise((resolve) =>
    exec(command, (error, stdout, _stderr) => {
      if (error) {
        console.log(error)
      }
      resolve(stdout)
    })
  )
}

function web3BlockToRlp(blockData) {
  // difficulty is only used and make sense in PoW network
  blockData.difficulty = parseInt(blockData.difficulty || '0', 10)
  blockData.totalDifficulty = parseInt(blockData.totalDifficulty, 10)
  blockData.uncleHash = blockData.sha3Uncles
  blockData.coinbase = blockData.miner
  blockData.transactionTrie = blockData.transactionsRoot
  blockData.receiptTrie = blockData.receiptsRoot
  blockData.bloom = blockData.logsBloom
  const blockHeader = blockFromRpc(blockData)
  return utils.rlp.encode(blockHeader.header.raw)
}

// TODO #297: get rid of vendors and enable Eth2NearRelay

/*class Eth2NearRelay {
  initialize(ethClientContract, ethNodeURL) {
    this.ethClientContract = ethClientContract
    // @ts-ignore
    this.robustWeb3 = new RobustWeb3(ethNodeURL)
    this.web3 = this.robustWeb3.web3
  }

  async run() {
    const robustWeb3 = this.robustWeb3
    while (true) {
      let clientBlockNumber
      let chainBlockNumber
      try {
        // Even retry 10 times ethClientContract.last_block_number could still fail
        // Return back to loop to avoid crash eth2near-relay.
        clientBlockNumber = (
          await this.ethClientContract.last_block_number()
        ).toNumber()
        console.log('Client block number is ' + clientBlockNumber)
        chainBlockNumber = await robustWeb3.getBlockNumber()
        console.log('Chain block number is ' + chainBlockNumber)
      } catch (e) {
        console.log(e)
        continue
      }

      // Backtrack if chain switched the fork.
      while (true) {
        try {
          const chainBlock = await robustWeb3.getBlock(clientBlockNumber)
          const chainBlockHash = chainBlock.hash
          const clientHashes = await this.ethClientContract.known_hashes(
            clientBlockNumber
          )
          if (clientHashes.find((x) => x === chainBlockHash)) {
            break
          } else {
            console.log(
              `Block ${chainBlockHash} height: ${clientBlockNumber} is not known to the client. Backtracking.`
            )
            clientBlockNumber -= 1
          }
        } catch (e) {
          console.log(e)
          continue
        }
      }

      if (clientBlockNumber < chainBlockNumber) {
        try {
          // Submit add_block txns
          let blockPromises = []
          let endBlock = Math.min(
            clientBlockNumber + MAX_SUBMIT_BLOCK,
            chainBlockNumber
          )
          if (clientBlockNumber < 5) {
            // Initially, do not add block concurrently
            endBlock = clientBlockNumber + 1
          }
          for (let i = clientBlockNumber + 1; i <= endBlock; i++) {
            blockPromises.push(this.getParseBlock(i))
          }
          let blocks = await Promise.all(blockPromises)
          console.log(
            `Got and parsed block ${clientBlockNumber + 1} to block ${endBlock}`
          )

          let txHashes = []
          for (let i = clientBlockNumber + 1, j = 0; i <= endBlock; i++, j++) {
            txHashes.push(await this.submitBlock(blocks[j], i))
          }

          console.log(
            `Submit txn to add block ${
              clientBlockNumber + 1
            } to block ${endBlock}`
          )

          // Wait add_block txns commit
          await Promise.all(
            txHashes.map((txHash) =>
              txnStatus(this.ethClientContract.account, txHash, 10, 2000)
            )
          )
          console.log(
            `Success added block ${clientBlockNumber + 1} to block ${endBlock}`
          )
        } catch (e) {
          console.log(e)
        }
      } else {
        await sleep(10000)
      }
    }
  }

  async getParseBlock(blockNumber) {
    try {
      const blockRlp = this.web3.utils.bytesToHex(
        web3BlockToRlp(await this.robustWeb3.getBlock(blockNumber))
      )
      const unparsedBlock = await execute(
        `${BRIDGE_SRC_DIR}/vendor/ethashproof/cmd/relayer/relayer ${blockRlp} | sed -e '1,/Json output/d'`
      )
      console.log('---')
      console.log(unparsedBlock)
      return JSON.parse(unparsedBlock)
    } catch (e) {
      console.log(`Failed to get or parse block ${blockNumber}: ${e}`)
    }
  }

  async submitBlock(block, blockNumber) {
    const h512s = block.elements
      .filter((_, index) => index % 2 === 0)
      .map((element, index) => {
        return (
          this.web3.utils.padLeft(element, 64) +
          this.web3.utils.padLeft(block.elements[index * 2 + 1], 64).substr(2)
        )
      })

    const args = {
      block_header: this.web3.utils.hexToBytes(block.header_rlp),
      dag_nodes: h512s
        .filter((_, index) => index % 2 === 0)
        .map((element, index) => {
          return {
            dag_nodes: [element, h512s[index * 2 + 1]],
            proof: block.merkle_proofs
              .slice(
                index * block.proof_length,
                (index + 1) * block.proof_length
              )
              .map((leaf) => this.web3.utils.padLeft(leaf, 32)),
          }
        }),
    }

    console.log(`Submitting block ${blockNumber} to EthClient`)
    return await this.ethClientContract.add_block_header_async(
      args,
      new BN('300000000000000')
    )
  }
}

exports.Eth2NearRelay = Eth2NearRelay*/
exports.web3BlockToRlp = web3BlockToRlp
exports.execute = execute

'''
'''--- index.js ---
const nearAPI = require('near-api-js')

const getConfig = require('./src/get-config')
const utils = require('./src/utils')

// Re-export to make sure subsequent libraries use the same version.
// Without this, ppl would use different version of PublicKey class and the transactions won't serialize.
exports.nearlib = nearAPI
exports.nearAPI = nearAPI
exports.getConfig = getConfig
exports.utils = utils

'''
'''--- init/eth-contracts.js ---
const Web3 = require('web3')
const BN = require('bn.js')
const fs = require('fs')
const { RainbowConfig } = require('../config')
const { normalizeEthKey } = require('../rainbow/robust')

class EthContractInitializer {
  async execute(contractName, args, gas) {
    const address = 'eth-' + contractName + '-address'
    const abiPath = RainbowConfig.getParam('eth-' + contractName + '-abi-path')
    const binPath = RainbowConfig.getParam('eth-' + contractName + '-bin-path')
    if (!abiPath || !binPath) {
      return false
    }

    try {
      const web3 = new Web3(RainbowConfig.getParam('eth-node-url'))
      let ethMasterAccount = web3.eth.accounts.privateKeyToAccount(
        normalizeEthKey(RainbowConfig.getParam('eth-master-sk'))
      )
      web3.eth.accounts.wallet.add(ethMasterAccount)
      web3.eth.defaultAccount = ethMasterAccount.address
      ethMasterAccount = ethMasterAccount.address

      console.log('Deploying ETH contract', contractName)
      const tokenContract = new web3.eth.Contract(
        JSON.parse(fs.readFileSync(abiPath))
      )
      const txContract = await tokenContract
        .deploy({
          data: '0x' + fs.readFileSync(binPath),
          arguments: args,
        })
        .send({
          from: ethMasterAccount,
          gas: gas,
          gasPrice: new BN(await web3.eth.getGasPrice()).mul(
            new BN(RainbowConfig.getParam('eth-gas-multiplier'))
          ),
        })
      console.log(
        'Deployed ETH contract',
        contractName,
        'to',
        `${txContract.options.address}`
      )
      RainbowConfig.setParam(
        address,
        normalizeEthKey(txContract.options.address)
      )
      RainbowConfig.saveConfig()
      try {
        // Only WebSocket provider can close.
        web3.currentProvider.connection.close()
      } catch (e) {}
    } catch (e) {
      console.log(e)
      return false
    }
    return true
  }
}

class InitEthEd25519 {
  static async execute() {
    const ethContractInitializer = new EthContractInitializer()
    const contractName = 'ed25519'
    const success = await ethContractInitializer.execute(
      contractName,
      [],
      5000000
    )
    if (!success) {
      console.log("Can't deploy", contractName)
      throw 1
    }
  }
}

class InitEthErc20 {
  static async execute() {
    const ethContractInitializer = new EthContractInitializer()
    const contractName = 'erc20'
    const success = await ethContractInitializer.execute(
      contractName,
      [],
      3000000
    )
    if (!success) {
      console.log("Can't deploy", contractName)
      throw 1
    }
  }
}

class InitEthLocker {
  static async execute() {
    const ethContractInitializer = new EthContractInitializer()
    const contractName = 'locker'
    const success = await ethContractInitializer.execute(
      contractName,
      [
        Buffer.from(
          RainbowConfig.getParam('near-token-factory-account'),
          'utf8'
        ),
        RainbowConfig.getParam('eth-prover-address'),
      ],
      5000000
    )
    if (!success) {
      console.log("Can't deploy", contractName)
      throw 1
    }
  }
}

class InitEthClient {
  static async execute() {
    const ethContractInitializer = new EthContractInitializer()
    const contractName = 'client'
    const web3 = new Web3(RainbowConfig.getParam('eth-node-url'))
    const lockEthAmount = web3.utils.toBN(
      RainbowConfig.getParam('eth-client-lock-eth-amount')
    )
    const lockDuration = web3.utils.toBN(
      RainbowConfig.getParam('eth-client-lock-duration')
    )
    const replaceDuration = web3.utils.toBN(
      RainbowConfig.getParam('eth-client-replace-duration')
    ).mul(new web3.utils.BN(1e9))
    try {
      // Only WebSocket provider can close.
      web3.currentProvider.connection.close()
    } catch (e) {}
    const success = await ethContractInitializer.execute(
      contractName,
      [
        RainbowConfig.getParam('eth-ed25519-address'),
        lockEthAmount,
        lockDuration,
        replaceDuration,
      ],
      5000000
    )
    if (!success) {
      console.log("Can't deploy", contractName)
      throw 1
    }
  }
}

class InitEthProver {
  static async execute() {
    const ethContractInitializer = new EthContractInitializer()
    const contractName = 'prover'
    const success = await ethContractInitializer.execute(
      contractName,
      [RainbowConfig.getParam('eth-client-address')],
      3000000
    )
    if (!success) {
      console.log("Can't deploy", contractName)
      throw 1
    }
  }
}

exports.InitEthEd25519 = InitEthEd25519
exports.InitEthErc20 = InitEthErc20
exports.InitEthLocker = InitEthLocker
exports.InitEthClient = InitEthClient
exports.InitEthProver = InitEthProver
'''
'''--- init/index.js ---
const {
  InitEthClient,
  InitEthEd25519,
  InitEthErc20,
  InitEthLocker,
  InitEthProver,
} = require('./eth-contracts')
const { InitNearContracts } = require('./near-contracts')
const { InitNearTokenFactory } = require('./near-token-factory')

exports.InitEthEd25519 = InitEthEd25519
exports.InitEthErc20 = InitEthErc20
exports.InitEthLocker = InitEthLocker
exports.InitEthClient = InitEthClient
exports.InitEthProver = InitEthProver
exports.InitNearContracts = InitNearContracts
exports.InitNearTokenFactory = InitNearTokenFactory

'''
'''--- init/near-contracts.js ---
const Web3 = require('web3')
const nearlib = require('near-api-js')
const { maybeCreateAccount, verifyAccount } = require('../rainbow/helpers')
const { EthOnNearClientContract } = require('../eth-on-near-client')
const { EthOnNearProverContract } = require('../eth-on-near-prover')
const { RobustWeb3 } = require('../rainbow/robust')
const { RainbowConfig } = require('../config')

class InitNearContracts {
  static async execute() {
    const masterAccount = RainbowConfig.getParam('near-master-account')
    const masterSk = RainbowConfig.getParam('near-master-sk')
    const clientAccount = RainbowConfig.getParam('near-client-account')
    let clientSk = RainbowConfig.maybeGetParam('near-client-sk')
    if (!clientSk) {
      console.log(
        'Key to call Near Client contract is not specified. Reusing master key.'
      )
      clientSk = masterSk
      RainbowConfig.setParam('near-client-sk', masterSk)
    }
    const clientContractPath = RainbowConfig.getParam(
      'near-client-contract-path'
    )
    const clientInitBalance = RainbowConfig.getParam('near-client-init-balance')

    const proverAccount = RainbowConfig.getParam('near-prover-account')
    let proverSk = RainbowConfig.maybeGetParam('near-prover-sk')
    if (!proverSk) {
      console.log(
        'Key to call Near Prover contract is not specified. Reusing master key.'
      )
      proverSk = masterSk
      RainbowConfig.setParam('near-prover-sk', masterSk)
    }
    const proverContractPath = RainbowConfig.getParam(
      'near-prover-contract-path'
    )
    const proverInitBalance = RainbowConfig.getParam('near-prover-init-balance')

    const nearNodeUrl = RainbowConfig.getParam('near-node-url')
    const nearNetworkId = RainbowConfig.getParam('near-network-id')
    const validateEthash = RainbowConfig.getParam('near-client-validate-ethash')
    const trustedSigner = RainbowConfig.getParam('near-client-trusted-signer')

    const clientPk = nearlib.KeyPair.fromString(clientSk).getPublicKey()
    const proverPk = nearlib.KeyPair.fromString(proverSk).getPublicKey()

    const keyStore = new nearlib.keyStores.InMemoryKeyStore()
    await keyStore.setKey(
      nearNetworkId,
      masterAccount,
      nearlib.KeyPair.fromString(masterSk)
    )
    await keyStore.setKey(
      nearNetworkId,
      clientAccount,
      nearlib.KeyPair.fromString(clientSk)
    )
    await keyStore.setKey(
      nearNetworkId,
      proverAccount,
      nearlib.KeyPair.fromString(proverSk)
    )
    const near = await nearlib.connect({
      nodeUrl: nearNodeUrl,
      networkId: nearNetworkId,
      masterAccount: masterAccount,
      deps: {
        keyStore: keyStore,
      },
    })

    console.log('Creating accounts and deploying the contracts.')
    await verifyAccount(near, masterAccount)
    await maybeCreateAccount(
      near,
      masterAccount,
      clientAccount,
      clientPk,
      clientInitBalance,
      clientContractPath
    )
    await verifyAccount(near, clientAccount)
    await maybeCreateAccount(
      near,
      masterAccount,
      proverAccount,
      proverPk,
      proverInitBalance,
      proverContractPath
    )
    await verifyAccount(near, proverAccount)

    console.log('Initializing client and prover contracts.')
    const clientContract = new EthOnNearClientContract(
      new nearlib.Account(near.connection, clientAccount),
      clientAccount
    )
    const robustWeb3 = new RobustWeb3(RainbowConfig.getParam('eth-node-url'))
    await clientContract.maybeInitialize(validateEthash === 'true', trustedSigner || null, robustWeb3)
    const proverContract = new EthOnNearProverContract(
      new nearlib.Account(near.connection, proverAccount),
      proverAccount
    )
    await proverContract.maybeInitialize(clientAccount)
    RainbowConfig.saveConfig()
    process.exit(0)
  }
}

exports.InitNearContracts = InitNearContracts

'''
'''--- init/near-token-factory.js ---
const nearlib = require('near-api-js')
const { maybeCreateAccount, verifyAccount } = require('../rainbow/helpers')
const { RainbowConfig } = require('../config')
const { BN } = require('ethereumjs-util')
const { DeployToken } = require('../transfer-eth-erc20/deploy-token')

class InitNearTokenFactory {
  static async execute() {
    const masterAccount = RainbowConfig.getParam('near-master-account')
    const masterSk = RainbowConfig.getParam('near-master-sk')
    const tokenFactoryAccount = RainbowConfig.getParam(
      'near-token-factory-account'
    )
    let tokenSk = RainbowConfig.maybeGetParam('near-token-factory-sk')
    if (!tokenSk) {
      console.log(
        'Secret key for fungible token is not specified. Reusing master secret key.'
      )
      tokenSk = masterSk
      RainbowConfig.setParam('near-token-factory-sk', tokenSk)
    }
    const tokenContractPath = RainbowConfig.getParam(
      'near-token-factory-contract-path'
    )
    const tokenInitBalance = RainbowConfig.getParam(
      'near-token-factory-init-balance'
    )
    const proverAccount = RainbowConfig.getParam('near-prover-account')

    const nearNodeUrl = RainbowConfig.getParam('near-node-url')
    const nearNetworkId = RainbowConfig.getParam('near-network-id')

    const tokenPk = nearlib.KeyPair.fromString(tokenSk).getPublicKey()

    const keyStore = new nearlib.keyStores.InMemoryKeyStore()
    await keyStore.setKey(
      nearNetworkId,
      masterAccount,
      nearlib.KeyPair.fromString(masterSk)
    )
    await keyStore.setKey(
      nearNetworkId,
      tokenFactoryAccount,
      nearlib.KeyPair.fromString(tokenSk)
    )
    const near = await nearlib.connect({
      nodeUrl: nearNodeUrl,
      networkId: nearNetworkId,
      masterAccount: masterAccount,
      deps: { keyStore: keyStore },
    })

    await verifyAccount(near, masterAccount)
    console.log('Deploying token contract.')
    await maybeCreateAccount(
      near,
      masterAccount,
      tokenFactoryAccount,
      tokenPk,
      tokenInitBalance,
      tokenContractPath
    )
    const tokenFactoryContract = new nearlib.Contract(
      new nearlib.Account(near.connection, tokenFactoryAccount),
      tokenFactoryAccount,
      {
        changeMethods: ['new', 'deploy_bridge_token'],
        viewMethods: ['get_bridge_token_account_id'],
      }
    )
    const lockerAddress = RainbowConfig.getParam('eth-locker-address')
    try {
      // Try initializing the factory.
      await tokenFactoryContract.new(
        {
          prover_account: proverAccount,
          locker_address: lockerAddress.startsWith('0x')
            ? lockerAddress.substr(2)
            : lockerAddress,
        },
        new BN('300000000000000')
      )
    } catch (err) {
      console.log(`Failed to initialize the token factory ${err}`)
      process.exit(1)
    }

    DeployToken.execute('erc20', RainbowConfig.getParam('eth-erc20-address'))
  }
}

exports.InitNearTokenFactory = InitNearTokenFactory

'''
'''--- near-mintable-token/index.js ---
const Web3 = require('web3')
const { BorshContract, readerToHex } = require('../rainbow/borsh')

const borshSchema = {
  bool: {
    kind: 'function',
    // @ts-ignore
    ser: (b) => Buffer.from(Web3.utils.hexToBytes(b ? '0x01' : '0x00')),
    deser: (z) => readerToHex(1)(z) === '0x01',
  },
  Proof: {
    kind: 'struct',
    fields: [
      ['log_index', 'u64'],
      ['log_entry_data', ['u8']],
      ['receipt_index', 'u64'],
      ['receipt_data', ['u8']],
      ['header_data', ['u8']],
      ['proof', [['u8']]],
    ],
  },
}

class NearMintableToken extends BorshContract {
  constructor(account, contractId) {
    super(borshSchema, account, contractId, {
      viewMethods: [],
      changeMethods: [
        {
          methodName: 'deposit',
          inputFieldType: 'Proof',
          outputFieldType: null,
        },
      ],
    })
  }
}

exports.NearMintableToken = NearMintableToken

'''
'''--- near2eth-relay/index.js ---
const nearlib = require('near-api-js')
const fs = require('fs')
// @ts-ignore
const bs58 = require('bs58')
// @ts-ignore
const { toBuffer } = require('eth-util-lite')
const { BN } = require('ethereumjs-util')
const { RainbowConfig } = require('../config')
const { sleep, RobustWeb3, normalizeEthKey } = require('../rainbow/robust')
const { borshify, borshifyInitialValidators } = require('../rainbow/borsh')

/// Maximum number of retries a Web3 method call will perform.
const MAX_WEB3_RETRIES = 1000

class Near2EthRelay {
  async initialize() {
    // @ts-ignore
    this.robustWeb3 = new RobustWeb3(RainbowConfig.getParam('eth-node-url'))
    this.web3 = this.robustWeb3.web3
    this.ethMasterAccount = this.web3.eth.accounts.privateKeyToAccount(
      normalizeEthKey(RainbowConfig.getParam('eth-master-sk'))
    )
    this.web3.eth.accounts.wallet.add(this.ethMasterAccount)
    this.web3.eth.defaultAccount = this.ethMasterAccount.address
    this.ethMasterAccount = this.ethMasterAccount.address

    const keyStore = new nearlib.keyStores.InMemoryKeyStore()
    this.near = await nearlib.connect({
      nodeUrl: RainbowConfig.getParam('near-node-url'),
      networkId: RainbowConfig.getParam('near-network-id'),
      deps: {
        keyStore: keyStore,
      },
    })

    // Declare Near2EthClient contract.
    this.clientContract = new this.web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(RainbowConfig.getParam('eth-client-abi-path'))
      ),
      RainbowConfig.getParam('eth-client-address'),
      {
        from: this.ethMasterAccount,
        handleRevert: true,
      }
    )

    // Check if initialization is needed.
    try {
      console.log('Checking whether client is initialized.')
      const isInitialized = await this.clientContract.methods
        .initialized()
        .call()
      if (!isInitialized) {
        console.log('Client is not initialized. Initializing.')
        // Get most recent block from Near blockchain.
        const status = await this.near.connection.provider.status()
        // Get the block two blocks before that, to make sure it is final.
        const headBlock = await this.near.connection.provider.block({
          blockId: status.sync_info.latest_block_height,
        })
        // @ts-ignore
        const lastFinalBlockHash = headBlock.header.last_final_block
        // The finalized block is not immediately available so we wait for it to become available.
        let lightClientBlock = null
        let currentValidators = null
        while (!lightClientBlock) {
          // @ts-ignore
          currentValidators = await this.near.connection.provider.sendJsonRpc(
            'EXPERIMENTAL_validators_ordered',
            [lastFinalBlockHash]
          )
          if (!currentValidators) {
            await sleep(300)
            continue
          }
          lightClientBlock = await this.near.connection.provider.sendJsonRpc(
            'next_light_client_block',
            [lastFinalBlockHash]
          )
          if (!lightClientBlock) {
            await sleep(300)
            continue
          }
        }
        console.log('Initializing with validators')
        console.log(`${JSON.stringify(currentValidators)}`)
        const borshInitialValidators = borshifyInitialValidators(
          currentValidators
        )
        // @ts-ignore
        let gasPrice = new BN(await this.web3.eth.getGasPrice()).mul(
          new BN(RainbowConfig.getParam('eth-gas-multiplier'))
        )
        let err
        for (let i = 0; i < 10; i++) {
          try {
            await this.clientContract.methods
              .initWithValidators(borshInitialValidators)
              .send({
                from: this.ethMasterAccount,
                gas: 4000000,
                handleRevert: true,
                gasPrice,
              })
          } catch (e) {
            if (e.message.includes('replacement transaction underpriced')) {
              gasPrice = gasPrice.mul(new BN(11)).div(new BN(10))
              continue
            }
            err = e
          }
          break
        }
        if (err) {
          console.log('Failure')
          console.log(err)
          process.exit(1)
        }

        console.log('Initializing with block')
        console.log(`${JSON.stringify(lightClientBlock)}`)
        const borshBlock = borshify(lightClientBlock)
        for (let i = 0; i < 10; i++) {
          try {
            await this.clientContract.methods.initWithBlock(borshBlock).send({
              from: this.ethMasterAccount,
              gas: 4000000,
              handleRevert: true,
              gasPrice: new BN(await this.web3.eth.getGasPrice()).mul(
                new BN(RainbowConfig.getParam('eth-gas-multiplier'))
              ),
            })
          } catch (e) {
            if (e.message.includes('replacement transaction underpriced')) {
              gasPrice = gasPrice.mul(new BN(11)).div(new BN(10))
              continue
            }
            err = e
          }
          break
        }
        if (err) {
          console.log('Failure')
          console.log(err)
          process.exit(1)
        }
      }
      console.log('Client is initialized.')
    } catch (txRevertMessage) {
      console.log('Failure.')
      console.log(txRevertMessage.toString())
      process.exit(1)
    }
  }

  async runInternal(submitInvalidBlock) {
    const clientContract = this.clientContract
    const robustWeb3 = this.robustWeb3
    const near = this.near
    const ethMasterAccount = this.ethMasterAccount
    const web3 = this.web3

    const minDelay = Number(RainbowConfig.getParam('near2eth-relay-min-delay'))
    const maxDelay = Number(RainbowConfig.getParam('near2eth-relay-max-delay'))
    const errorDelay = Number(RainbowConfig.getParam('near2eth-relay-error-delay'))

    while (true) {
      try {
        // Determine the next action: sleep or attempt an update.
        let bridgeState = await clientContract.methods.bridgeState().call()
        let currentBlockHash = toBuffer(await clientContract.methods.blockHashes(bridgeState.currentHeight).call())
        let lastBlock = await near.connection.provider.sendJsonRpc('next_light_client_block', [bs58.encode(currentBlockHash)])
        let replaceDuration = web3.utils.toBN(await clientContract.methods.replaceDuration().call())
        let nextValidAt = web3.utils.toBN(bridgeState.nextValidAt)
        let replaceDelay
        if (!nextValidAt.isZero()) {
          replaceDelay = web3.utils.toBN(bridgeState.nextTimestamp).add(replaceDuration).sub(web3.utils.toBN(lastBlock.inner_lite.timestamp))
        }
        // console.log({bridgeState, currentBlockHash, lastBlock, replaceDuration}) // DEBUG
        if (bridgeState.currentHeight < lastBlock.inner_lite.height) {
          if (nextValidAt.isZero() || replaceDelay.cmpn(0) <= 0) {
            console.log(`Trying to submit new block at height ${lastBlock.inner_lite.height}.`)

            // Check whether master account has enough balance at stake.
            let lockEthAmount = await clientContract.methods.lockEthAmount().call()
            let balance = await clientContract.methods.balanceOf(ethMasterAccount).call()
            if (balance === '0') {
              console.log(`The sender account does not have enough stake. Transferring ${lockEthAmount} wei.`)
              await clientContract.methods.deposit().send({
                from: ethMasterAccount,
                gas: 1000000,
                handleRevert: true,
                value: new BN(lockEthAmount),
                gasPrice: new BN(await web3.eth.getGasPrice()).mul(
                  new BN(RainbowConfig.getParam('eth-gas-multiplier'))
                ),
              })
              console.log('Transferred.')
            }

            let borshBlock = borshify(lastBlock)
            if (submitInvalidBlock) {
              console.log('Mutate block by one byte')
              console.log(borshBlock)
              borshBlock[Math.floor(borshBlock.length * Math.random())] += 1
            }
            await clientContract.methods.addLightClientBlock(borshBlock).send({
              from: ethMasterAccount,
              gas: 4000000,
              handleRevert: true,
              gasPrice: new BN(await web3.eth.getGasPrice()).mul(
                new BN(RainbowConfig.getParam('eth-gas-multiplier'))
              ),
            })

            if (submitInvalidBlock) {
              console.log('Successfully submit invalid block')
              return process.exit(0)
            }
            console.log('Submitted.')
            continue
          }
        }
        // Going to sleep, compute the delay.
        let delay = maxDelay
        if (!nextValidAt.isZero()) {
          let latestBlock = await robustWeb3.getBlock('latest')
          delay = Math.min(delay, nextValidAt.toNumber() - latestBlock.timestamp)
          delay = Math.min(delay, replaceDelay.div(new web3.utils.BN(1e9)).toNumber())
        }
        delay = Math.max(delay, minDelay)
        console.log(`Client height is ${bridgeState.currentHeight}, chain height is ${lastBlock.inner_lite.height}. Sleeping for ${delay} seconds.`)
        await sleep(1000 * delay)
      } catch (e) {
        console.log("Error", e)
        await sleep(1000 * errorDelay)
      }
    }
  }

  DANGER_submitInvalidNearBlock() {
    return this.runInternal(true)
  }

  run() {
    return this.runInternal(false)
  }
}

exports.Near2EthRelay = Near2EthRelay
exports.borshify = borshify

'''
'''--- package.json ---
{
  "name": "rainbow-bridge-lib",
  "version": "3.0.0",
  "description": "Rainbow Bridge Lib",
  "author": "Near Inc.",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/near/rainbow-bridge-lib.git"
  },
  "license": "MIT",
  "keywords": [
    "nearprotocol",
    "decentralized",
    "blockchain",
    "ethereum",
    "bridge"
  ],
  "dependencies": {
    "bn.js": "^5.1.3",
    "bs58": "^4.0.1",
    "bsert": "^0.0.10",
    "change-case": "^4.1.1",
    "configstore": "^5.0.1",
    "eth-object": "near/eth-object#54e03b8aac8208cf724e206d49ffb8bdd30451d7",
    "eth-util-lite": "near/eth-util-lite#master",
    "ethereumjs-block": "^2.2.2",
    "ethereumjs-tx": "^2.1.2",
    "ethereumjs-util": "^6.2.0",
    "lodash": "^4.17.20",
    "merkle-patricia-tree": "^3.0.0",
    "near-api-js": "^0.26.0",
    "node-fetch": "^2.6.0",
    "promisfy": "^1.2.0",
    "tweetnacl": "^1.0.3",
    "web3": "=1.2.6"
  },
  "devDependencies": {
    "eslint": "^6.8.0",
    "eslint-plugin-import": "^2.20.2",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-promise": "^4.0.1",
    "eslint-plugin-standard": "^4.0.0",
    "typescript": "^3.9.5"
  },
  "scripts": {
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "check": "tsc"
  },
  "prettier": {
    "trailingComma": "es5",
    "tabWidth": 2,
    "semi": false,
    "singleQuote": true
  }
}

'''
'''--- rainbow/borsh.js ---
const Web3 = require('web3')
const nearlib = require('near-api-js')
const bs58 = require('bs58')

const BN = require('bn.js')
const { TextDecoder } = require('util')
const { borshifyOutcomeProof } = require('./borshify-proof')
const { sleep, backoff, signAndSendTransaction } = require('./robust')

class BorshError extends Error {
  constructor(message) {
    super(message)

    this.name = this.constructor.name
  }
}

function serializeField(schema, value, fieldType, writer) {
  if (fieldType === 'u8') {
    writer.write_u8(value)
  } else if (fieldType === 'u64') {
    writer.write_u64(value)
  } else if (fieldType === 'u128') {
    writer.write_u128(value)
  } else if (fieldType === 'bool') {
    return writer.write_u8(value ? 1 : 0)
  } else if (fieldType === 'string') {
    return writer.write_string(value)
  } else if (fieldType instanceof Array) {
    if (typeof fieldType[0] === 'number') {
      if (value.length !== fieldType[0]) {
        throw new Error(
          `Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`
        )
      }
      writer.write_fixed_array(value)
    } else {
      writer.write_array(value, (item) => {
        serializeField(schema, item, fieldType[0], writer)
      })
    }
  } else {
    const structSchema = schema[fieldType]
    if (!structSchema) {
      throw new Error(`Schema type ${fieldType} is missing in schema`)
    }
    if (structSchema.kind === 'option') {
      if (value === null) {
        writer.write_u8(0)
      } else {
        writer.write_u8(1)
        serializeField(schema, value, structSchema.type, writer)
      }
    } else if (structSchema.kind === 'struct') {
      structSchema.fields.map(([fieldName, fieldType]) => {
        serializeField(schema, value[fieldName], fieldType, writer)
      })
    } else if (structSchema.kind === 'function') {
      writer.write_buffer(structSchema.ser(value))
    } else {
      throw new Error(
        `Unexpected schema kind: ${structSchema.kind} for ${fieldType}`
      )
    }
  }
}

function deserializeField(schema, fieldType, reader) {
  if (fieldType === 'u8') {
    return reader.read_u8()
  } else if (fieldType === 'u64') {
    return reader.read_u64()
  } else if (fieldType === 'u128') {
    return reader.read_u128()
  } else if (fieldType === 'bool') {
    return !!reader.read_u8()
  } else if (fieldType === 'string') {
    return reader.read_string()
  } else if (fieldType instanceof Array) {
    if (typeof fieldType[0] === 'number') {
      return reader.read_fixed_array(fieldType[0])
    } else {
      return reader.read_array(() =>
        deserializeField(schema, fieldType[0], reader)
      )
    }
  } else {
    const structSchema = schema[fieldType]
    if (!structSchema) {
      throw new Error(`Schema type ${fieldType} is missing in schema`)
    }
    if (structSchema.kind === 'option') {
      const optionRes = reader.read_u8()
      if (optionRes === 0) {
        return null
      } else if (optionRes === 1) {
        return deserializeField(schema, structSchema.type, reader)
      } else {
        throw new Error(`Unexpected option flag: ${optionRes}`)
      }
    } else if (structSchema.kind === 'struct') {
      const result = {}
      for (const [fieldName, fieldType] of structSchema.fields) {
        result[fieldName] = deserializeField(schema, fieldType, reader)
      }
      return result
    } else if (structSchema.kind === 'function') {
      return structSchema.deser(reader, schema)
    } else {
      throw new Error(
        `Unexpected schema kind: ${structSchema.kind} for ${fieldType}`
      )
    }
  }
}

/// Serialize given object using schema of the form:
/// { class_name -> [ [field_name, field_type], .. ], .. }
function serialize(schema, fieldType, obj) {
  if (fieldType === null) {
    return new Uint8Array()
  }
  const writer = new nearlib.utils.serialize.BinaryWriter()
  serializeField(schema, obj, fieldType, writer)
  return writer.toArray()
}

class BinaryReader {
  constructor(buf) {
    this.buf = buf
    this.offset = 0
  }

  read_u8() {
    const value = this.buf.readUInt8(this.offset)
    this.offset += 1
    return value
  }

  read_u32() {
    const value = this.buf.readUInt32LE(this.offset)
    this.offset += 4
    return value
  }

  read_u64() {
    const buf = this.read_buffer(8)
    return new BN(buf, 'le')
  }

  read_u128() {
    const buf = this.read_buffer(16)
    return new BN(buf, 'le')
  }

  read_buffer(len) {
    if (this.offset + len > this.buf.length) {
      throw new BorshError(`Expected buffer length ${len} isn't within bounds`)
    }
    const result = this.buf.slice(this.offset, this.offset + len)
    this.offset += len
    return result
  }

  read_string() {
    const len = this.read_u32()
    const buf = this.read_buffer(len)
    // @ts-ignore
    const textDecoder = TextDecoder()
    try {
      // NOTE: Using TextDecoder to fail on invalid UTF-8
      return textDecoder.decode(buf)
    } catch (e) {
      throw new BorshError(`Error decoding UTF-8 string: ${e}`)
    }
  }

  read_fixed_array(len) {
    return new Uint8Array(this.read_buffer(len))
  }

  read_array(fn) {
    const len = this.read_u32()
    const result = []
    for (let i = 0; i < len; ++i) {
      result.push(fn())
    }
    return result
  }
}

function deserialize(schema, fieldType, buffer) {
  if (fieldType === null) {
    return null
  }
  const reader = new BinaryReader(buffer)
  const result = deserializeField(schema, fieldType, reader)
  if (reader.offset < buffer.length) {
    throw new Error(
      `Unexpected ${
        buffer.length - reader.offset
      } bytes after deserialized data`
    )
  }
  return result
}

const DEFAULT_FUNC_CALL_AMOUNT = new BN('300000000000000')

const RETRY_TX_STATUS = 10

const signAndSendTransactionAsync = async (
  accessKey,
  account,
  receiverId,
  actions
) => {
  const status = await account.connection.provider.status()
  let [txHash, signedTx] = await nearlib.transactions.signTransaction(
    receiverId,
    ++accessKey.nonce,
    actions,
    nearlib.utils.serialize.base_decode(status.sync_info.latest_block_hash),
    account.connection.signer,
    account.accountId,
    account.connection.networkId
  )
  const bytes = signedTx.encode()
  await account.connection.provider.sendJsonRpc('broadcast_tx_async', [
    Buffer.from(bytes).toString('base64'),
  ])
  console.log('TxHash', nearlib.utils.serialize.base_encode(txHash))
  return txHash
}

const txnStatus = async (
  account,
  txHash,
  retries = RETRY_TX_STATUS,
  wait = 1000
) => {
  let result
  for (let i = 0; i < retries; i++) {
    try {
      result = await account.connection.provider.txStatus(
        txHash,
        account.accountId
      )
      if (
        result.status.SuccessValue !== undefined ||
        result.status.Failure !== undefined
      ) {
        break
      }
    } catch (e) {
      await sleep(wait)
    }
  }
  if (!result) {
    throw new Error(
      `Transaction ${txHash} didn't finish after ${
        (retries * wait) / 1000
      } seconds`
    )
  }

  const flatLogs = [
    result.transaction_outcome,
    ...result.receipts_outcome,
  ].reduce((acc, it) => acc.concat(it.outcome.logs), [])
  if (flatLogs && flatLogs != []) {
    console.log(flatLogs)
  }

  if (result.status.SuccessValue !== undefined) {
    return result
  }

  throw new Error(JSON.stringify(result.status.Failure))
}

function getBorshTransactionLastResult(txResult) {
  return txResult && Buffer.from(txResult.status.SuccessValue, 'base64')
}

class BorshContract {
  constructor(borshSchema, account, contractId, options) {
    this.account = account
    this.contractId = contractId
    options.viewMethods.forEach((d) => {
      Object.defineProperty(this, d.methodName, {
        writable: false,
        enumerable: true,
        value: async (args) => {
          args = serialize(borshSchema, d.inputFieldType, args)
          const result = await backoff(10, () =>
            this.account.connection.provider.query(
              `call/${this.contractId}/${d.methodName}`,
              nearlib.utils.serialize.base_encode(args)
            )
          )
          if (result.logs) {
            this.account.printLogs(this.contractId, result.logs)
          }
          return (
            result.result &&
            result.result.length > 0 &&
            deserialize(
              borshSchema,
              d.outputFieldType,
              Buffer.from(result.result)
            )
          )
        },
      })
    })
    options.changeMethods.forEach((d) => {
      Object.defineProperty(this, d.methodName, {
        writable: false,
        enumerable: true,
        value: async (args, gas, amount) => {
          args = serialize(borshSchema, d.inputFieldType, args)

          const rawResult = await signAndSendTransaction(
            this.accessKey,
            this.account,
            this.contractId,
            [
              nearlib.transactions.functionCall(
                d.methodName,
                Buffer.from(args),
                gas || DEFAULT_FUNC_CALL_AMOUNT,
                amount
              ),
            ]
          )

          const result = getBorshTransactionLastResult(rawResult)
          return result && deserialize(borshSchema, d.outputFieldType, result)
        },
      })
    })

    options.changeMethods.forEach((d) => {
      Object.defineProperty(this, d.methodName + '_async', {
        writable: false,
        enumerable: true,
        value: async (args, gas, amount) => {
          args = serialize(borshSchema, d.inputFieldType, args)
          return await signAndSendTransactionAsync(
            this.accessKey,
            this.account,
            this.contractId,
            [
              nearlib.transactions.functionCall(
                d.methodName,
                Buffer.from(args),
                gas || DEFAULT_FUNC_CALL_AMOUNT,
                amount
              ),
            ]
          )
        },
      })
    })
  }

  async accessKeyInit() {
    await this.account.ready

    this.accessKey = await this.account.findAccessKey()
    if (!this.accessKey) {
      // @ts-ignore
      throw new Error(
        `Can not sign transactions for account ${this.account.accountId}, no matching key pair found in Signer.`,
        'KeyNotFound'
      )
    }
  }
}

function borshify(block) {
  return Buffer.concat([
    bs58.decode(block.prev_block_hash),
    bs58.decode(block.next_block_inner_hash),
    Buffer.concat([
      // @ts-ignore
      Web3.utils.toBN(block.inner_lite.height).toBuffer('le', 8),
      bs58.decode(block.inner_lite.epoch_id),
      bs58.decode(block.inner_lite.next_epoch_id),
      bs58.decode(block.inner_lite.prev_state_root),
      bs58.decode(block.inner_lite.outcome_root),
      // @ts-ignore
      Web3.utils
        .toBN(block.inner_lite.timestamp_nanosec || block.inner_lite.timestamp)
        .toBuffer('le', 8),
      bs58.decode(block.inner_lite.next_bp_hash),
      bs58.decode(block.inner_lite.block_merkle_root),
    ]),
    bs58.decode(block.inner_rest_hash),

    Buffer.from([1]),
    // @ts-ignore
    Web3.utils.toBN(block.next_bps.length).toBuffer('le', 4),
    Buffer.concat(
      block.next_bps.map((nextBp) =>
        Buffer.concat([
          // @ts-ignore
          Web3.utils.toBN(nextBp.account_id.length).toBuffer('le', 4),
          Buffer.from(nextBp.account_id),
          nextBp.public_key.substr(0, 8) === 'ed25519:'
            ? Buffer.from([0])
            : Buffer.from([1]),
          bs58.decode(nextBp.public_key.substr(8)),
          // @ts-ignore
          Web3.utils.toBN(nextBp.stake).toBuffer('le', 16),
        ])
      )
    ),

    // @ts-ignore
    Web3.utils.toBN(block.approvals_after_next.length).toBuffer('le', 4),
    Buffer.concat(
      block.approvals_after_next.map((signature) =>
        signature === null
          ? Buffer.from([0])
          : Buffer.concat([
              Buffer.from([1]),
              signature.substr(0, 8) === 'ed25519:'
                ? Buffer.from([0])
                : Buffer.from([1]),
              bs58.decode(signature.substr(8)),
            ])
      )
    ),
  ])
}

function borshifyInitialValidators(initialValidators) {
  return Buffer.concat([
    Web3.utils.toBN(initialValidators.length).toBuffer('le', 4),
    Buffer.concat(
      initialValidators.map((nextBp) =>
        Buffer.concat([
          Web3.utils.toBN(nextBp.account_id.length).toBuffer('le', 4),
          Buffer.from(nextBp.account_id),
          nextBp.public_key.substr(0, 8) === 'ed25519:'
            ? Buffer.from([0])
            : Buffer.from([1]),
          bs58.decode(nextBp.public_key.substr(8)),
          Web3.utils.toBN(nextBp.stake).toBuffer('le', 16),
        ])
      )
    ),
  ])
}

// @ts-ignore
const hexToBuffer = (hex) => Buffer.from(Web3.utils.hexToBytes(hex))
// @ts-ignore
const readerToHex = (len) => (reader) =>
  Web3.utils.bytesToHex(reader.read_fixed_array(len))

exports.BorshContract = BorshContract
exports.hexToBuffer = hexToBuffer
exports.readerToHex = readerToHex
exports.borshifyOutcomeProof = borshifyOutcomeProof
exports.txnStatus = txnStatus
exports.borshify = borshify
exports.borshifyInitialValidators = borshifyInitialValidators
exports.signAndSendTransaction = signAndSendTransaction

// For debugging only.
exports.serialize = serialize

'''
'''--- rainbow/borshify-proof.js ---
const Web3 = require('web3')
const bs58 = require('bs58')

function borshifyOutcomeProof(proof) {
  const statusToBuffer = (status) => {
    console.log(status)
    if ('SuccessValue' in status) {
      const data = Buffer.from(status.SuccessValue, 'base64')
      return Buffer.concat([
        Buffer.from([2]),
        Web3.utils.toBN(data.length).toBuffer('le', 4),
        data,
      ])
    } else if ('SuccessReceiptId' in status) {
      return Buffer.concat([
        Buffer.from([3]),
        bs58.decode(status.SuccessReceiptId),
      ])
    } else {
      throw new Error('status not supported')
    }
  }
  return Buffer.concat([
    Web3.utils.toBN(proof.outcome_proof.proof.length).toBuffer('le', 4),
    Buffer.concat(
      proof.outcome_proof.proof.map((p) =>
        Buffer.concat([
          bs58.decode(p.hash),
          Buffer.from([p.direction === 'Right' ? 1 : 0]),
        ])
      )
    ),

    bs58.decode(proof.outcome_proof.block_hash),

    bs58.decode(proof.outcome_proof.id),

    Buffer.concat([
      Web3.utils
        .toBN(proof.outcome_proof.outcome.logs.length)
        .toBuffer('le', 4),

      Web3.utils
        .toBN(proof.outcome_proof.outcome.receipt_ids.length)
        .toBuffer('le', 4),
      Buffer.concat(
        proof.outcome_proof.outcome.receipt_ids.map((r) => bs58.decode(r))
      ),

      Web3.utils.toBN(proof.outcome_proof.outcome.gas_burnt).toBuffer('le', 8),
      Web3.utils
        .toBN(proof.outcome_proof.outcome.tokens_burnt)
        .toBuffer('le', 16),
      Web3.utils
        .toBN(proof.outcome_proof.outcome.executor_id.length)
        .toBuffer('le', 4),
      Buffer.from(proof.outcome_proof.outcome.executor_id, 'utf8'),

      statusToBuffer(proof.outcome_proof.outcome.status),

      Web3.utils.toBN(0).toBuffer('le', 4),

      bs58.decode(proof.block_header_lite.prev_block_hash),
      bs58.decode(proof.block_header_lite.inner_rest_hash),
      Web3.utils
        .toBN(proof.block_header_lite.inner_lite.height)
        .toBuffer('le', 8),
      bs58.decode(proof.block_header_lite.inner_lite.epoch_id),
      bs58.decode(proof.block_header_lite.inner_lite.next_epoch_id),
      bs58.decode(proof.block_header_lite.inner_lite.prev_state_root),
      bs58.decode(proof.block_header_lite.inner_lite.outcome_root),
      // for backward compatible in tests with old dumps
      Web3.utils
        .toBN(
          proof.block_header_lite.inner_lite.timestamp_nanosec ||
            proof.block_header_lite.inner_lite.timestamp
        )
        .toBuffer('le', 8),
      bs58.decode(proof.block_header_lite.inner_lite.next_bp_hash),
      bs58.decode(proof.block_header_lite.inner_lite.block_merkle_root),

      Web3.utils.toBN(proof.block_proof.length).toBuffer('le', 4),
      Buffer.concat(
        proof.block_proof.map((bp) =>
          Buffer.concat([
            bs58.decode(bp.hash),
            Buffer.from([bp.direction === 'Right' ? 1 : 0]),
          ])
        )
      ),
    ]),
  ])
}

exports.borshifyOutcomeProof = borshifyOutcomeProof

'''
'''--- rainbow/helpers.js ---
const nearlib = require('near-api-js')
const fs = require('fs')
const BN = require('bn.js')

const RETRY_NONCE = 10

// Check if account exists and if it does not creates it using master account. Also deploys the code and creates
// an access key.
async function maybeCreateAccount(
  near,
  masterAccountId,
  accountId,
  accountPK,
  initBalance,
  contractPath
) {
  if (!(await accountExists(near, accountId))) {
    console.log('Account %s does not exist creating it.', accountId)
    const masterAccount = new nearlib.Account(near.connection, masterAccountId)
    const balance = new BN(initBalance)
    let accountCreated = false
    for (let i = 0; i < RETRY_NONCE; i++) {
      try {
        await masterAccount.createAccount(accountId, accountPK, balance)
        accountCreated = true
        break
      } catch (e) {
        if (e.type && e.type === 'AccountAlreadyExists') {
          // Last createAccount can timeout, but actually success later
          accountCreated = true
          break
        }
        // retry on timeout, nonce error, and socket hangout
      }
    }
    if (!accountCreated) {
      console.log(
        `Failed to create account %s in ${RETRY_NONCE} retries due to nonce`,
        accountId
      )
      process.exit(1)
    }

    console.log('Created account %s', accountId)

    const account = new nearlib.Account(near.connection, accountId)

    let contractDeployed = false
    for (let i = 0; i < RETRY_NONCE; i++) {
      try {
        const data = fs.readFileSync(contractPath)
        await account.deployContract(data)
        contractDeployed = true
        break
      } catch (e) {
        if (e.message.includes('Transaction nonce')) {
          continue
        }
        console.log(
          'Failed to deploy contract to account %s. ERROR: %s',
          accountId,
          e
        )
        process.exit(1)
      }
    }
    if (!contractDeployed) {
      console.log(
        `Failed to deploy contract to account %s in ${RETRY_NONCE} retries due to nonce`,
        accountId
      )
      process.exit(1)
    }
    console.log('Deployed contract to account %s', accountId)
  }
}

// Checks whether the account exists.
async function accountExists(near, accountId) {
  const account = new nearlib.Account(near.connection, accountId)
  try {
    await account.fetchState()
    return true
  } catch (e) {
    return false
  }
}

// Checks whether the account has the key specified in the keyStore.
async function accountHasTheKey(near, accountId) {
  const account = new nearlib.Account(near.connection, accountId)
  const keyStoreKey = await near.config.deps.keyStore.getKey(
    near.config.networkId,
    accountId
  )
  const keys = await account.getAccessKeys()
  const accessKey = keys.find(
    (key) => key.public_key === keyStoreKey.getPublicKey().toString()
  )
  if (accessKey) {
    return true
  } else {
    return false
  }
}

// Verify that account exists and it has the key that we specified in the keyStore.
async function verifyAccount(near, accountId) {
  if (!(await accountExists(near, accountId))) {
    console.log(
      'Failed to fetch state of the %s account. Is it initialized?',
      accountId
    )
    process.exit(1)
  }

  if (!(await accountHasTheKey(near, accountId))) {
    console.log(
      'Account %s does not have the access key that can be used to operate with it.',
      accountId
    )
    process.exit(1)
  }
  return true
}

// Used in Status
async function verifyAccountGently(near, accountId) {
  if (!(await accountExists(near, accountId))) {
    return false
  }

  if (!(await accountHasTheKey(near, accountId))) {
    return false
  }
  // All checks have passed
  return true
}

exports.maybeCreateAccount = maybeCreateAccount
exports.accountExists = accountExists
exports.accountHasTheKey = accountHasTheKey
exports.verifyAccount = verifyAccount
exports.verifyAccountGently = verifyAccountGently

'''
'''--- rainbow/near-dump.js ---
const fs = require('fs').promises
const Path = require('path')
const { RainbowConfig } = require('../config')
const fetch = require('node-fetch')

async function getLatestBlock(nearNodeUrl) {
  const resp = await fetch(nearNodeUrl, {
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'dontcare',
      method: 'block',
      params: {
        finality: 'final',
      },
    }),
  })
  const data = await resp.json()
  return data.result
}

async function getBlockChunk(nearNodeUrl, block) {
  let resp = await fetch(nearNodeUrl, {
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'dontcare',
      method: 'chunk',
      params: [block.chunks[0].chunk_hash],
    }),
  })
  let data = await resp.json()
  return data.result
}

async function getTxProof(nearNodeUrl, futureBlock, txn) {
  let resp = await fetch(nearNodeUrl, {
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'dontcare',
      method: 'light_client_proof',
      params: {
        type: 'transaction',
        transaction_hash: txn.hash,
        receiver_id: txn.receiver_id,
        sender_id: txn.signer_id,
        light_client_head: futureBlock.header.hash,
      },
    }),
  })
  let data = await resp.json()
  return data.result
}

async function getReceiptProof(nearNodeUrl, futureBlock, receipt) {
  let resp = await fetch(nearNodeUrl, {
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'dontcare',
      method: 'light_client_proof',
      params: {
        type: 'receipt',
        receipt_id: receipt.receipt_id,
        receiver_id: receipt.receiver_id,
        light_client_head: futureBlock.header.hash,
      },
    }),
  })
  let data = await resp.json()
  return data.result
}

async function getNextLightClientBlock(nearNodeUrl, blockHash) {
  const resp = await fetch(nearNodeUrl, {
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'dontcare',
      method: 'next_light_client_block',
      params: [blockHash],
    }),
  })
  const data = await resp.json()
  return data.result
}

class NearDump {
  static async execute(kindOfData, { path, numBlocks }) {
    if (kindOfData !== 'headers' && kindOfData !== 'proofs') {
      console.log(
        'Usage: node index.js near-dump headers\n       node index.js near-dump proofs'
      )
      process.exit(2)
    }

    if (!numBlocks) {
      numBlocks = 100
    }
    const nearNodeUrl = RainbowConfig.getParam('near-node-url')

    let latestBlock = await getLatestBlock(nearNodeUrl)

    if (kindOfData == 'headers') {
      await NearDump.dumpHeaders(nearNodeUrl, path, latestBlock, numBlocks)
    } else if (kindOfData == 'proofs') {
      await NearDump.dumpProofs(nearNodeUrl, path, latestBlock, numBlocks)
    }
  }

  static async dumpHeaders(nearNodeUrl, path, latestBlock, numBlocks) {
    console.log(
      `Downloading ${numBlocks} light client blocks start from ${latestBlock.header.height}`
    )

    let newLatestBlock
    while (numBlocks > 0) {
      newLatestBlock = await getLatestBlock(nearNodeUrl)
      if (newLatestBlock.header.height > latestBlock.header.height) {
        console.log(`Got new block at height ${newLatestBlock.header.height}`)
        let block
        do {
          block = await getNextLightClientBlock(
            nearNodeUrl,
            newLatestBlock.header.hash
          )
        } while (!block)
        console.log(
          `Got new light client block at height ${block.inner_lite.height}`
        )
        await NearDump.saveBlock(block.inner_lite.height, block, path)
        latestBlock = newLatestBlock
        numBlocks--
      } else {
        continue
      }
    }
  }

  static async dumpProofs(nearNodeUrl, path, latestBlock, numBlocks) {
    console.log(
      `Downloading ${numBlocks} light client proofs start from ${latestBlock.header.height}`
    )

    let newLatestBlock
    while (numBlocks > 0) {
      newLatestBlock = await getLatestBlock(nearNodeUrl)
      if (newLatestBlock.header.height > latestBlock.header.height) {
        console.log(`Got new block at height ${newLatestBlock.header.height}`)
        let chunk = await getBlockChunk(nearNodeUrl, latestBlock)
        console.log(
          `There are ${chunk.transactions.length} txns in block ${latestBlock.header.height}'s chunk`
        )
        console.log(
          `There are ${chunk.receipts.length} receipts in block  ${latestBlock.header.height}'s chunk`
        )
        for (let i in chunk.transactions) {
          //let proof = await getTxProof(nearNodeUrl, newLatestBlock, chunk.transactions[i]);
          //await NearDump.saveProof(latestBlock.header.height, 'txn', i, proof, path)
        }
        for (let i in chunk.receipts) {
          let proof = await getReceiptProof(
            nearNodeUrl,
            newLatestBlock,
            chunk.receipts[i]
          )
          await NearDump.saveProof(
            latestBlock.header.height,
            'receipt',
            i,
            proof,
            path
          )
        }
        latestBlock = newLatestBlock
        numBlocks--
      } else {
        continue
      }
    }
  }

  static async saveBlock(i, block, path) {
    const file = Path.join(path, `${i}.json`)
    await fs.writeFile(file, JSON.stringify(block))
  }

  static async saveProof(block_i, type, i, proof, path) {
    const file = Path.join(path, `${block_i}_${type}_${i}.json`)
    await fs.writeFile(file, JSON.stringify(proof))
    console.log('Saved ' + file)
  }
}

exports.NearDump = NearDump

'''
'''--- rainbow/robust.js ---
/// This module gives a few utils for robust error handling,
/// and wrap web3 with error handling and retry
const Web3 = require('web3')
const _ = require('lodash')
const nearlib = require('near-api-js')

const RETRY = 10
const DELAY = 500
const BACKOFF = 1.2

const retry = (retries, fn) =>
  fn().catch((err) =>
    retries > 1 ? retry(retries - 1, fn) : Promise.reject(err)
  )
const sleep = (duration) => new Promise((res) => setTimeout(res, duration))

const backoff = (retries, fn, delay = DELAY, wait = BACKOFF) =>
  fn().catch((err) =>
    retries > 1
      ? sleep(delay).then(() => backoff(retries - 1, fn, delay * wait))
      : Promise.reject(err)
  )

const SLOW_TX_ERROR_MSG = 'transaction not executed within 5 minutes'

class RobustWeb3 {
  constructor(ethNodeUrl) {
    this.ethNodeUrl = ethNodeUrl
    this.web3 = new Web3(ethNodeUrl)
  }

  async getBlockNumber() {
    return await backoff(RETRY, async () => {
      try {
        return await this.web3.eth.getBlockNumber()
      } catch (e) {
        if (e && e.toString() === 'Error: connection not open') {
          this.web3.setProvider(this.ethNodeUrl)
        }
        throw e
      }
    })
  }

  async getBlock(b) {
    return await backoff(RETRY, async () => {
      try {
        let block = await this.web3.eth.getBlock(b)
        // sometimes infura gives null on the very new block, but retry works
        if (block === null) {
          // throw so backoff will do retry
          throw new Error('web3.eth.getBlock returns null')
        }
        return block
      } catch (e) {
        if (e && e.toString() === 'Error: connection not open') {
          this.web3.setProvider(this.ethNodeUrl)
        }
        throw e
      }
    })
  }

  async callContract(contract, method, args, options) {
    let gasPrice = await this.web3.eth.getGasPrice()
    let nonce = await this.web3.eth.getTransactionCount(options.from, 'pending')
    while (gasPrice < 10000 * 1e9) {
      try {
        // Keep sending with same nonce but higher gasPrice to override same txn
        let tx = {
          from: options.from,
          to: contract.options.address,
          handleRevert: options.handleRevert,
          gas: Web3.utils.toHex(options.gas),
          gasPrice: options.gasPrice
            ? options.gasPrice
            : Web3.utils.toHex(gasPrice),
          nonce: Web3.utils.toHex(nonce),
          data: contract.methods[method](...args).encodeABI(),
        }
        // Call transaction via view method to check if there is specific error.
        try {
          await this.web3.eth.call(tx)
        } catch (error) {
          console.log(tx.from)
          console.warn(error)
        }

        let receipt = await promiseWithTimeout(
          5 * 60 * 1000,
          this.web3.eth.sendTransaction(tx),
          SLOW_TX_ERROR_MSG
        )
        if (_.isArray(receipt.logs)) {
          // decode logs
          var events = _.map(receipt.logs, function (log) {
            return contract._decodeEventABI.call(
              {
                name: 'ALLEVENTS',
                jsonInterface: contract.options.jsonInterface,
              },
              log
            )
          })

          // make log names keys
          receipt.events = {}
          var count = 0
          events.forEach(function (ev) {
            if (ev.event) {
              // if > 1 of the same event, don't overwrite any existing events
              if (receipt.events[ev.event]) {
                if (Array.isArray(receipt.events[ev.event])) {
                  receipt.events[ev.event].push(ev)
                } else {
                  receipt.events[ev.event] = [receipt.events[ev.event], ev]
                }
              } else {
                receipt.events[ev.event] = ev
              }
            } else {
              receipt.events[count] = ev
              count++
            }
          })
          delete receipt.logs
        }
        return receipt
      } catch (e) {
        if (e.message === SLOW_TX_ERROR_MSG) {
          console.log(SLOW_TX_ERROR_MSG)
          console.log(
            `current gasPrice: ${gasPrice}. resend tx with double gasPrice`
          )
          gasPrice *= 2
        } else if (
          e.message.indexOf("the tx doesn't have the correct nonce") >= 0
        ) {
          console.log('nonce error, retrying with new nonce')
          nonce++
        } else if (e.toString() === 'Error: connection not open') {
          console.log('web3 disconnected, reconnecting')
          this.web3.setProvider(this.ethNodeUrl)
        } else {
          throw e
        }
      }
    }
    throw new Error('Cannot finish txn within 1e13 gas')
  }

  async getTransactionReceipt(t) {
    return await backoff(RETRY, async () => {
      try {
        return await this.web3.eth.getTransactionReceipt(t)
      } catch (e) {
        if (e && e.toString() === 'Error: connection not open') {
          this.web3.setProvider(this.ethNodeUrl)
        }
        throw e
      }
    })
  }

  destroy() {
    if (this.web3.currentProvider.connection.close) {
      // Only WebSocket provider has close, HTTPS don't
      this.web3.currentProvider.connection.close()
    }
  }
}

function normalizeEthKey(key) {
  let result = key.toLowerCase()
  if (!result.startsWith('0x')) {
    result = '0x' + result
  }
  return result
}

const promiseWithTimeout = (timeoutMs, promise, failureMessage) => {
  let timeoutHandle
  const timeoutPromise = new Promise((resolve, reject) => {
    timeoutHandle = setTimeout(
      () => reject(new Error(failureMessage)),
      timeoutMs
    )
  })

  return Promise.race([promise, timeoutPromise]).then((result) => {
    clearTimeout(timeoutHandle)
    return result
  })
}

async function nearJsonContractFunctionCall(
  contractId,
  sender,
  method,
  args,
  gas,
  amount
) {
  // A robust version of near-api-js account.functionCall. We can't simply retry account.functionCall because
  // we don't know whether txn successfully submitted when timeout, so there's a risk of double sending

  await sender.ready
  let accessKey = await sender.findAccessKey()
  return await signAndSendTransaction(accessKey, sender, contractId, [
    nearlib.transactions.functionCall(
      method,
      Buffer.from(JSON.stringify(args)),
      gas,
      amount
    ),
  ])
}

const RETRY_SEND_TX = 10
const RETRY_TX_STATUS = 10

const signAndSendTransaction = async (
  accessKey,
  account,
  receiverId,
  actions
) => {
  // TODO: Find matching access key based on transaction
  let errorMsg
  let resendLast = false
  let sendTxnAsync
  let txHash

  for (let i = 0; i < RETRY_SEND_TX; i++) {
    try {
      if (resendLast) {
        console.log('resend txn')
        await sendTxnAsync()
        resendLast = false
      } else {
        const status = await account.connection.provider.status()
        let signedTx
        ;[txHash, signedTx] = await nearlib.transactions.signTransaction(
          receiverId,
          ++accessKey.nonce,
          actions,
          nearlib.utils.serialize.base_decode(
            status.sync_info.latest_block_hash
          ),
          account.connection.signer,
          account.accountId,
          account.connection.networkId
        )
        const bytes = signedTx.encode()
        sendTxnAsync = async () => {
          await account.connection.provider.sendJsonRpc('broadcast_tx_async', [
            Buffer.from(bytes).toString('base64'),
          ])
          console.log('TxHash', nearlib.utils.serialize.base_encode(txHash))
        }
        await sendTxnAsync()
      }
    } catch (e) {
      errorMsg = e.message
      // sleep to avoid socket hangout on retry too soon
      await sleep(500)
      continue
    }

    let result
    for (let j = 0; j < RETRY_TX_STATUS; j++) {
      try {
        result = await account.connection.provider.txStatus(
          txHash,
          account.accountId
        )
        if (
          result.status.SuccessValue !== undefined ||
          result.status.Failure !== undefined
        ) {
          break
        }
      } catch (e) {
        errorMsg = e.message
        await sleep((j + 1) * 500)
      }
    }

    if (result) {
      const flatLogs = [
        result.transaction_outcome,
        ...result.receipts_outcome,
      ].reduce((acc, it) => acc.concat(it.outcome.logs), [])
      if (flatLogs && flatLogs != []) {
        console.log(flatLogs)
      }

      if (result.status.SuccessValue !== undefined) {
        return result
      }

      errorMsg = JSON.stringify(result.status.Failure)
      if (errorMsg.includes('Transaction nonce')) {
        // nonce incorrect, re-fetch nonce and retry
        continue
      } else {
        // Indeed txn error, retry doesn't help
        break
      }
    } else {
      // Still no result after a long time, resubmit txn
      resendLast = true
      continue
    }
  }
  throw new Error(errorMsg)
}

module.exports = {
  retry,
  sleep,
  backoff,
  RobustWeb3,
  normalizeEthKey,
  promiseWithTimeout,
  nearJsonContractFunctionCall,
  signAndSendTransaction,
}

'''
'''--- src/get-config.js ---

function getConfig(env) {
    switch (env) {
        case 'mainnet':
            return {
                networkId: 'mainnet',
                nearNodeUrl: 'https://rpc.mainnet.near.org',
                ethNodeUrl: '',
            };
        case 'testnet':
            return {
                networkId: 'default',
                nearNodeUrl: 'https://rpc.testnet.near.org',
                ethNodeUrl: '',
            };
        case 'local':
        case 'test':
            return {
                networkId: 'local',
                // NEAR configuration.
                nearNodeUrl: 'http://localhost:3030',
                keyPath: `${process.env.HOME}/.near/local/validator_key.json`,
                masterAccount: 'test.near',
                nearEthClientId: 'client.test.near',
                nearEthProverId: 'prover.test.near',
                // Ethereum configuration.
                ethNodeUrl: 'http://localhost:9545',
                ethFromSecretKey: '0x2bdd21761a483f71054e14f5b827213567971c676928d9a1808cbfa4b7501200',
                ethProverAddress: '',
            };
        default:
            throw new Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
    }
}

module.exports = getConfig;

'''
'''--- src/utils.js ---
const homedir = require('os').homedir()
const path = require('path')
const fs = require('fs')
const assert = require('bsert')

const nearAPI = require('near-api-js')
const Web3 = require('web3')

const CREDENTIALS_DIR = '.near-credentials'
const PROJECT_KEY_DIR = './neardev'

const DEFAULT_GAS = 1000000

async function setupNear(config) {
  const deps = await createLocalKeyStore(config.networkId, config.keyPath)
  if (config.keyPath) {
    delete config.keyPath
  }
  return nearAPI.connect({
    networkId: config.networkId,
    nodeUrl: config.nearNodeUrl,
    deps,
  })
}

async function setupEth(config) {
  const web3 = await getWeb3(config)
  web3.eth.defaultAccount = addSecretKey(web3, config.ethFromSecretKey)
  config.ethFrom = web3.eth.defaultAccount
  return web3
}

/**
 * Setup connection to NEAR and Ethereum from given configuration.
 * @param {Object} config Config object which defines nearNodeUrl/ethNodeUrl, networkId and more.
 */
async function setupEthNear(config) {
  const near = await setupNear(config)
  const web3 = await setupEth(config)
  return { near, web3 }
}

/**
 * Remove 0x if prepended
 * @param {String} input data
 * @return {String} string without 0x
 */
function remove0x(value) {
  assert(typeof value === 'string', 'remove0x: must pass in string')

  if (value.slice(0, 2) === '0x') {
    return value.slice(2)
  } else {
    return value
  }
}

function normalizeHex(value) {
  value = value.toLowerCase()
  if (!value.startsWith('0x')) {
    return `0x${value}`
  }
  return value
}

async function accountExists(connection, accountId) {
  try {
    const account = new nearAPI.Account(connection, accountId)
    await account.state()
    return true
  } catch (error) {
    if (!error.message.includes('does not exist while viewing')) {
      throw error
    }
    return false
  }
}

async function createLocalKeyStore(networkId, keyPath) {
  // TODO: this should live in near-api-js
  const credentialsPath = path.join(homedir, CREDENTIALS_DIR)
  const keyStores = [
    new nearAPI.keyStores.UnencryptedFileSystemKeyStore(credentialsPath),
    new nearAPI.keyStores.UnencryptedFileSystemKeyStore(PROJECT_KEY_DIR),
  ]
  if (keyPath) {
    const account = JSON.parse(fs.readFileSync(keyPath).toString())
    const keyPair = nearAPI.utils.KeyPair.fromString(account.secret_key)
    const keyStore = new nearAPI.keyStores.InMemoryKeyStore()
    keyStore.setKey(networkId, account.account_id, keyPair).then(() => {})
    keyStores.push(keyStore)
  }
  return { keyStore: new nearAPI.keyStores.MergeKeyStore(keyStores) }
}

function getWeb3(config) {
  // TODO: add RobustWeb3 usage here.
  return new Web3(config.ethNodeUrl)
}

function getEthContract(web3, path, address) {
  const bin = fs.readFileSync(`${path}.full.bin`)
  const abi = fs.readFileSync(`${path}.full.abi`)
  const contract = new web3.eth.Contract(JSON.parse(abi), address, {
    from: web3.eth.defaultAccount,
  })
  contract.bin = bin
  return contract
}

function addSecretKey(web3, secretKey) {
  let account = web3.eth.accounts.privateKeyToAccount(normalizeHex(secretKey))
  web3.eth.accounts.wallet.add(account)
  return account.address
}

/**
 * Wrap pure calls to Web3 contract to handle errors/reverts/gas usage.
 * TODO: should use RobustWeb3 code.
 */
async function ethCallContract(contract, methodName, args) {
  let dryRun
  try {
    dryRun = await contract.methods[methodName](...args).call()
    return contract.methods[methodName](...args).send({
      gas: DEFAULT_GAS,
    })
  } catch (error) {
    if (error.message.includes('reverted by the EVM')) {
      console.warn(dryRun)
    }
    throw error
  }
}

module.exports = {
  setupEthNear,
  accountExists,
  remove0x,
  createLocalKeyStore,
  getWeb3,
  getEthContract,
  addSecretKey,
  fromWei: Web3.utils.fromWei,
  toWei: Web3.utils.toWei,
  ethCallContract,
}

'''
'''--- transfer-eth-erc20/deploy-token.js ---
const nearlib = require('near-api-js')
const utils = require('../src/utils')
const { RainbowConfig } = require('../config')
const { verifyAccount } = require('../rainbow/helpers')
const { BN } = require('ethereumjs-util')

function tokenAccountParam(tokenName) {
  return 'near-' + tokenName + '-account'
}

function tokenAddressParam(tokenName) {
  return 'eth-' + tokenName + '-address'
}

class DeployToken {
  static async execute(tokenName, tokenAddress) {
    console.log('execute', tokenName, tokenAddress)
    if (RainbowConfig.maybeGetParam(tokenAccountParam(tokenName))) {
      console.log(
        `Token name ${tokenName} is occupied. Is it already deployed?`
      )
      process.exit(1)
    }

    // use init near instead
    const masterAccount = RainbowConfig.getParam('near-master-account')
    const masterSk = RainbowConfig.getParam('near-master-sk')
    const tokenFactoryAccount = RainbowConfig.getParam(
      'near-token-factory-account'
    )
    let tokenSk = RainbowConfig.maybeGetParam('near-token-factory-sk')
    if (!tokenSk) {
      console.log(
        'Secret key for fungible token is not specified. Reusing master secret key.'
      )
      tokenSk = masterSk
      RainbowConfig.setParam('near-token-factory-sk', tokenSk)
    }
    const nearNodeUrl = RainbowConfig.getParam('near-node-url')
    const nearNetworkId = RainbowConfig.getParam('near-network-id')

    const keyStore = new nearlib.keyStores.InMemoryKeyStore()
    await keyStore.setKey(
      nearNetworkId,
      masterAccount,
      nearlib.KeyPair.fromString(masterSk)
    )
    await keyStore.setKey(
      nearNetworkId,
      tokenFactoryAccount,
      nearlib.KeyPair.fromString(tokenSk)
    )
    const near = await nearlib.connect({
      nodeUrl: nearNodeUrl,
      networkId: nearNetworkId,
      masterAccount: masterAccount,
      deps: { keyStore: keyStore },
    })

    await verifyAccount(near, masterAccount)
    await verifyAccount(near, tokenFactoryAccount)

    console.log('Adding token ' + tokenName + ' at ' + tokenAddress)

    const tokenFactoryContract = new nearlib.Contract(
      new nearlib.Account(near.connection, tokenFactoryAccount),
      tokenFactoryAccount,
      {
        changeMethods: ['deploy_bridge_token'],
        viewMethods: ['get_bridge_token_account_id'],
      }
    )

    try {
      // Try initializing the contract.
      await tokenFactoryContract.deploy_bridge_token(
        {
          address: utils.remove0x(tokenAddress),
        },
        new BN('300000000000000'),
        new BN('150000000000000000000000000')
      )
    } catch (err) {
      console.log(
        `Failed to initialize the token ${tokenName} contract: ${err}`
      )
      process.exit(1)
    }
    console.log(`${tokenName} deployed`)
    RainbowConfig.setParam(
      tokenAccountParam(tokenName),
      utils.remove0x(tokenAddress) + '.' + tokenFactoryAccount
    )
    RainbowConfig.setParam(tokenAddressParam(tokenName), tokenAddress)

    RainbowConfig.saveConfig()
    console.log(
      `Token address of ${tokenName} set to ${RainbowConfig.getParam(
        tokenAccountParam(tokenName)
      )}, param ${tokenAccountParam(tokenName)}`
    )
  }
}

module.exports = { DeployToken, tokenAddressParam, tokenAccountParam }

'''
'''--- transfer-eth-erc20/from-near.js ---
const Web3 = require('web3')
const nearlib = require('near-api-js')
const BN = require('bn.js')
const fs = require('fs')
//const assert = require('bsert')
const bs58 = require('bs58')
const { toBuffer } = require('eth-util-lite')
const { tokenAddressParam, tokenAccountParam } = require('./deploy-token')
const { verifyAccount } = require('../rainbow/helpers')
const { NearMintableToken } = require('../near-mintable-token')
const { RainbowConfig } = require('../config')
const { borshifyOutcomeProof } = require('../rainbow/borsh')
const { sleep, RobustWeb3 } = require('../rainbow/robust')
const {
  normalizeEthKey,
  backoff,
  nearJsonContractFunctionCall,
} = require('../rainbow/robust')

let initialCmd

class TransferEthERC20FromNear {
  static showRetryAndExit() {
    console.log('Retry with command:')
    console.log(initialCmd)
    process.exit(1)
  }

  static parseBuffer(obj) {
    for (let i in obj) {
      if (obj[i] && obj[i].type === 'Buffer') {
        obj[i] = Buffer.from(obj[i].data)
      } else if (obj[i] && typeof obj[i] === 'object') {
        obj[i] = TransferEthERC20FromNear.parseBuffer(obj[i])
      }
    }
    return obj
  }

  static loadTransferLog() {
    try {
      let log =
        JSON.parse(
          fs.readFileSync('transfer-eth-erc20-from-near.log.json').toString()
        ) || {}
      return TransferEthERC20FromNear.parseBuffer(log)
    } catch (e) {
      return {}
    }
  }

  static deleteTransferLog() {
    try {
      fs.unlinkSync('transfer-eth-erc20-from-near.log.json')
    } catch (e) {
      console.log('Warning: failed to remove tranfer log')
    }
  }

  static recordTransferLog(obj) {
    fs.writeFileSync(
      'transfer-eth-erc20-from-near.log.json',
      JSON.stringify(obj)
    )
  }

  static async withdraw({
    nearTokenContract,
    nearSenderAccountId,
    tokenAccount,
    amount,
    ethReceiverAddress,
    nearSenderAccount,
  }) {
    // Withdraw the token on Near side.
    try {
      const old_balance = await backoff(10, () =>
        nearTokenContract.get_balance({
          owner_id: nearSenderAccountId,
        })
      )
      console.log(
        `Balance of ${nearSenderAccountId} before withdrawing: ${old_balance}`
      )

      console.log(
        `Withdrawing ${amount} tokens on NEAR blockchain in favor of ${ethReceiverAddress}.`
      )
      const txWithdraw = await nearJsonContractFunctionCall(
        tokenAccount,
        nearSenderAccount,
        'withdraw',
        { amount: amount, recipient: ethReceiverAddress },
        new BN('300000000000000'),
        new BN(0)
      )
      console.log(`tx withdraw: ${JSON.stringify(txWithdraw)}`)

      TransferEthERC20FromNear.recordTransferLog({
        finished: 'withdraw',
        txWithdraw,
      })
    } catch (txRevertMessage) {
      console.log('Failed to withdraw.')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromNear.showRetryAndExit()
    }
  }

  static async findWithdrawInBlock({ txWithdraw, nearSenderAccountId, near }) {
    try {
      let txReceiptId
      let txReceiptBlockHash
      let idType
      /*assert(
        RainbowConfig.getParam('near-token-factory-account') !== nearSenderAccountId
      )*/

      // Getting 1st tx
      const receipts = txWithdraw.transaction_outcome.outcome.receipt_ids
      if (receipts.length === 1) {
        txReceiptId = receipts[0]
        idType = 'receipt'
      } else {
        throw new Error(
          `Fungible token transaction call is expected to produce only one receipt, but produced: ${JSON.stringify(
            txWithdraw
          )}`
        )
      }

      // Getting 2nd tx
      try {
        txReceiptId = txWithdraw.receipts_outcome.find(
          (el) => el.id == txReceiptId
        ).outcome.status.SuccessReceiptId
        txReceiptBlockHash = txWithdraw.receipts_outcome.find(
          (el) => el.id == txReceiptId
        ).block_hash
      } catch (e) {
        throw new Error(`Invalid tx withdraw: ${JSON.stringify(txWithdraw)}`, e)
      }

      // Get block in which the receipt was processed.
      const receiptBlock = await backoff(10, () =>
        near.connection.provider.block({
          blockId: txReceiptBlockHash,
        })
      )
      // Now wait for a final block with a strictly greater height. This block (or one of its ancestors) should hold the outcome, although this is not guaranteed if there are multiple shards.
      const outcomeBlock = await backoff(10, async () => {
        while (true) {
          let block = await near.connection.provider.block({
            finality: "final"
          })
          if (Number(block.header.height) <= Number(receiptBlock.header.height)) {
            await sleep(1000)
            continue
          }
          return block
        }
      })
      TransferEthERC20FromNear.recordTransferLog({
        finished: 'find-withdraw',
        txReceiptBlockHash,
        txReceiptId,
        outcomeBlock,
        idType,
      })
    } catch (txRevertMessage) {
      console.log('Failed to find withdraw in block.')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromNear.showRetryAndExit()
    }
  }

  static async waitBlock({
    clientContract,
    outcomeBlock,
    robustWeb3,
    nearSenderAccountId,
    nearTokenContract,
    amount,
    idType,
    txReceiptId,
  }) {
    // Wait for the block with the given receipt/transaction in Near2EthClient.
    try {
      const outcomeBlockHeight = Number(outcomeBlock.header.height)
      let clientBlockHeight
      let clientBlockHash
      while (true) {
        let clientState = await clientContract.methods.bridgeState().call()
        clientBlockHeight = Number(clientState.currentHeight)
        let clientBlockValidAfter = Number(clientState.nextValidAt)
        clientBlockHash = bs58.encode(toBuffer(await clientContract.methods.blockHashes(clientBlockHeight).call()))

        console.log(`Current light client head is: hash=${clientBlockHash}, height=${clientBlockHeight}`)

        if (clientBlockHeight > outcomeBlockHeight) {
          console.log(`The block at height ${outcomeBlockHeight} is already available to the client.`)
          break
        } else {
          let delay = clientBlockValidAfter == 0
            ? await clientContract.methods.lockDuration().call()
            : clientBlockValidAfter - (await robustWeb3.getBlock('latest')).timestamp
          delay = Math.max(delay, 1)
          console.log(`Block ${outcomeBlockHeight} is not yet available. Sleeping for ${delay} seconds.`)
          await sleep(delay * 1000)
        }
      }
      console.log(`Withdrawn ${JSON.stringify(amount)}`)
      const new_balance = await backoff(10, () =>
        nearTokenContract.get_balance({
          owner_id: nearSenderAccountId,
        })
      )
      console.log(
        `Balance of ${nearSenderAccountId} after withdrawing: ${new_balance}`
      )
      TransferEthERC20FromNear.recordTransferLog({
        finished: 'wait-block',
        clientBlockHashB58: clientBlockHash,
        idType,
        txReceiptId,
        clientBlockHeight,
      })
    } catch (txRevertMessage) {
      console.log('Failed to wait for block occur in near on eth contract')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromNear.showRetryAndExit()
    }
  }

  static async getProof({
    idType,
    near,
    txReceiptId,
    nearSenderAccountId,
    clientBlockHashB58,
    clientBlockHeight,
  }) {
    try {
      // Get the outcome proof only use block merkle root that we know is available on the Near2EthClient.
      let proofRes
      if (idType === 'transaction') {
        proofRes = await near.connection.provider.sendJsonRpc(
          'light_client_proof',
          {
            type: 'transaction',
            transaction_hash: txReceiptId,
            // TODO: Use proper sender.
            receiver_id: nearSenderAccountId,
            light_client_head: clientBlockHashB58,
          }
        )
      } else if (idType === 'receipt') {
        proofRes = await near.connection.provider.sendJsonRpc(
          'light_client_proof',
          {
            type: 'receipt',
            receipt_id: txReceiptId,
            // TODO: Use proper sender.
            receiver_id: nearSenderAccountId,
            light_client_head: clientBlockHashB58,
          }
        )
      } else {
        throw new Error('Unreachable')
      }
      TransferEthERC20FromNear.recordTransferLog({
        finished: 'get-proof',
        proofRes,
        clientBlockHeight,
      })
    } catch (txRevertMessage) {
      console.log('Failed to get proof.')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromNear.showRetryAndExit()
    }
  }

  static async unlock({
    proverContract,
    proofRes,
    clientBlockHeight,
    ethERC20Contract,
    ethReceiverAddress,
    ethTokenLockerContract,
    ethMasterAccount,
    robustWeb3,
  }) {
    try {
      // Check that the proof is correct.
      const borshProofRes = borshifyOutcomeProof(proofRes)
      clientBlockHeight = new BN(clientBlockHeight)
      // Debugging output, uncomment for debugging.
      // console.log(`proof: ${JSON.stringify(proofRes)}`);
      // console.log(`client height: ${clientBlockHeight.toString()}`);
      // console.log(`root: ${clientBlockMerkleRoot}`);
      await proverContract.methods
        .proveOutcome(borshProofRes, clientBlockHeight)
        .call()

      const oldBalance = await ethERC20Contract.methods
        .balanceOf(ethReceiverAddress)
        .call()
      console.log(
        `ERC20 balance of ${ethReceiverAddress} before the transfer: ${oldBalance}`
      )
      await robustWeb3.callContract(
        ethTokenLockerContract,
        'unlockToken',
        [borshProofRes, clientBlockHeight],
        {
          from: ethMasterAccount,
          gas: 5000000,
          handleRevert: true,
          gasPrice: new BN(await robustWeb3.web3.eth.getGasPrice()).mul(
            new BN(RainbowConfig.getParam('eth-gas-multiplier'))
          ),
        }
      )
      /*await ethTokenLockerContract.methods
        .unlockToken(borshProofRes, clientBlockHeight)
        .send({
          from: ethMasterAccount,
          gas: 5000000,
          handleRevert: true,
          gasPrice: new BN(await robustWeb3.web3.eth.getGasPrice()).mul(
            new BN(RainbowConfig.getParam('eth-gas-multiplier'))
          ),
        })*/
      const newBalance = await ethERC20Contract.methods
        .balanceOf(ethReceiverAddress)
        .call()
      console.log(
        `ERC20 balance of ${ethReceiverAddress} after the transfer: ${newBalance}`
      )

      TransferEthERC20FromNear.deleteTransferLog()
    } catch (txRevertMessage) {
      console.log('Failed to unlock.')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromNear.showRetryAndExit()
    }
  }

  static async execute(command) {
    initialCmd = command.parent.rawArgs.join(' ')
    const nearSenderAccountId = command.nearSenderAccount
    let amount = command.amount
    const ethReceiverAddress = command.ethReceiverAddress.startsWith('0x')
      ? command.ethReceiverAddress.substr(2)
      : command.ethReceiverAddress
    const tokenAddress = command.tokenName
      ? RainbowConfig.getParam(tokenAddressParam(command.tokenName))
      : RainbowConfig.getParam('eth-erc20-address')
    const tokenAccount = command.tokenName
      ? RainbowConfig.getParam(tokenAccountParam(command.tokenName))
      : RainbowConfig.getParam('near-erc20-account')

    const keyStore = new nearlib.keyStores.InMemoryKeyStore()
    await keyStore.setKey(
      RainbowConfig.getParam('near-network-id'),
      nearSenderAccountId,
      nearlib.KeyPair.fromString(command.nearSenderSk)
    )
    const near = await nearlib.connect({
      nodeUrl: RainbowConfig.getParam('near-node-url'),
      networkId: RainbowConfig.getParam('near-network-id'),
      masterAccount: nearSenderAccountId,
      deps: { keyStore: keyStore },
    })
    const nearSenderAccount = new nearlib.Account(
      near.connection,
      nearSenderAccountId
    )
    await verifyAccount(near, nearSenderAccountId)

    const nearTokenContract = new nearlib.Contract(
      nearSenderAccount,
      tokenAccount,
      {
        changeMethods: ['new', 'withdraw'],
        viewMethods: ['get_balance'],
      }
    )
    const nearTokenContractBorsh = new NearMintableToken(
      nearSenderAccount,
      tokenAccount
    )
    await nearTokenContractBorsh.accessKeyInit()

    let robustWeb3 = new RobustWeb3(RainbowConfig.getParam('eth-node-url'))
    const web3 = robustWeb3.web3
    let ethMasterAccount = web3.eth.accounts.privateKeyToAccount(
      normalizeEthKey(RainbowConfig.getParam('eth-master-sk'))
    )
    web3.eth.accounts.wallet.add(ethMasterAccount)
    web3.eth.defaultAccount = ethMasterAccount.address
    ethMasterAccount = ethMasterAccount.address
    const clientContract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(RainbowConfig.getParam('eth-client-abi-path'))
      ),
      RainbowConfig.getParam('eth-client-address'),
      {
        from: ethMasterAccount,
        handleRevert: true,
      }
    )
    const proverContract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(RainbowConfig.getParam('eth-prover-abi-path'))
      ),
      RainbowConfig.getParam('eth-prover-address'),
      {
        from: ethMasterAccount,
        handleRevert: true,
      }
    )
    const ethTokenLockerContract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(RainbowConfig.getParam('eth-locker-abi-path'))
      ),
      RainbowConfig.getParam('eth-locker-address'),
      {
        from: ethMasterAccount,
        handleRevert: true,
      }
    )
    const ethERC20Contract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(fs.readFileSync(RainbowConfig.getParam('eth-erc20-abi-path'))),
      tokenAddress,
      {
        from: ethMasterAccount,
        handleRevert: true,
      }
    )

    let transferLog = TransferEthERC20FromNear.loadTransferLog()
    if (transferLog.finished === undefined) {
      await TransferEthERC20FromNear.withdraw({
        nearTokenContract,
        nearSenderAccountId,
        tokenAccount,
        amount,
        ethReceiverAddress,
        nearSenderAccount,
      })
      transferLog = TransferEthERC20FromNear.loadTransferLog()
    }
    if (transferLog.finished === 'withdraw') {
      await TransferEthERC20FromNear.findWithdrawInBlock({
        txWithdraw: transferLog.txWithdraw,
        nearSenderAccountId,
        near,
      })
      transferLog = TransferEthERC20FromNear.loadTransferLog()
    }
    if (transferLog.finished === 'find-withdraw') {
      await TransferEthERC20FromNear.waitBlock({
        clientContract,
        robustWeb3,
        outcomeBlock: transferLog.outcomeBlock,
        nearSenderAccountId,
        nearTokenContract,
        amount,
        idType: transferLog.idType,
        txReceiptId: transferLog.txReceiptId,
      })
      transferLog = TransferEthERC20FromNear.loadTransferLog()
    }
    if (transferLog.finished === 'wait-block') {
      await TransferEthERC20FromNear.getProof({
        idType: transferLog.idType,
        near,
        txReceiptId: transferLog.txReceiptId,
        nearSenderAccountId,
        clientBlockHashB58: transferLog.clientBlockHashB58,
        clientBlockHeight: transferLog.clientBlockHeight,
      })
      transferLog = TransferEthERC20FromNear.loadTransferLog()
    }
    if (transferLog.finished === 'get-proof') {
      await TransferEthERC20FromNear.unlock({
        proverContract,
        proofRes: transferLog.proofRes,
        clientBlockHeight: transferLog.clientBlockHeight,
        ethERC20Contract,
        ethReceiverAddress,
        ethTokenLockerContract,
        ethMasterAccount,
        robustWeb3,
      })
    }

    process.exit(0)
  }
}

exports.TransferEthERC20FromNear = TransferEthERC20FromNear

'''
'''--- transfer-eth-erc20/index.js ---
const { TransferETHERC20ToNear } = require('./to-near')
const { TransferEthERC20FromNear } = require('./from-near')
const { DeployToken } = require('./deploy-token')

exports.TransferETHERC20ToNear = TransferETHERC20ToNear
exports.TransferEthERC20FromNear = TransferEthERC20FromNear
exports.DeployToken = DeployToken

'''
'''--- transfer-eth-erc20/to-near.js ---
const utils = require('ethereumjs-util')
const BN = require('bn.js')
const fs = require('fs')
const nearlib = require('near-api-js')
const {
  EthProofExtractor,
  receiptFromWeb3,
  logFromWeb3,
} = require('../eth-proof-extractor')
const { tokenAddressParam, tokenAccountParam } = require('./deploy-token')
const { verifyAccount } = require('../rainbow/helpers')
const { NearMintableToken } = require('../near-mintable-token')
const { RainbowConfig } = require('../config')
const { EthOnNearClientContract } = require('../eth-on-near-client')
const { sleep, RobustWeb3, normalizeEthKey } = require('../rainbow/robust')

let initialCmd

class TransferETHERC20ToNear {
  static showRetryAndExit() {
    console.log('Retry with command:')
    console.log(initialCmd)
    process.exit(1)
  }

  static async approve({
    robustWeb3,
    ethERC20Contract,
    amount,
    ethSenderAccount,
  }) {
    // Approve tokens for transfer.
    const lockerAddress = RainbowConfig.getParam('eth-locker-address')
    try {
      console.log(
        `Approving token transfer to ${lockerAddress} ${Number(amount)}.`
      )
      await robustWeb3.callContract(
        ethERC20Contract,
        'approve',
        [lockerAddress, Number(amount)],
        {
          from: ethSenderAccount,
          gas: 5000000,
        }
      )
      console.log('Approved token transfer.')
      TransferETHERC20ToNear.recordTransferLog({ finished: 'approve' })
    } catch (txRevertMessage) {
      console.log('Failed to approve.')
      console.log(txRevertMessage.toString())
      TransferETHERC20ToNear.showRetryAndExit()
    }
  }

  static async lock({
    robustWeb3,
    ethTokenLockerContract,
    tokenAddress,
    amount,
    nearReceiverAccount,
    ethSenderAccount,
  }) {
    try {
      console.log(
        `Transferring tokens from the ERC20 account to the token locker account ${Number(
          amount
        )}.`
      )
      const transaction = await robustWeb3.callContract(
        ethTokenLockerContract,
        'lockToken',
        [tokenAddress, Number(amount), nearReceiverAccount],
        {
          from: ethSenderAccount,
          gas: 5000000,
        }
      )
      console.log(transaction)
      const lockedEvent = transaction.events.Locked
      console.log('Success tranfer to locker')
      TransferETHERC20ToNear.recordTransferLog({
        finished: 'lock',
        lockedEvent,
      })
    } catch (txRevertMessage) {
      console.log('Failed to lock account.')
      console.log(txRevertMessage.toString())
      TransferETHERC20ToNear.showRetryAndExit()
    }
  }

  static async findProof({ extractor, lockedEvent, web3 }) {
    const receipt = await extractor.extractReceipt(lockedEvent.transactionHash)
    const block = await extractor.extractBlock(receipt.blockNumber)
    const tree = await extractor.buildTrie(block)
    const proof = await extractor.extractProof(
      web3,
      block,
      tree,
      receipt.transactionIndex
    )
    let txLogIndex = -1

    let logFound = false
    let log
    for (let receiptLog of receipt.logs) {
      txLogIndex++
      const blockLogIndex = receiptLog.logIndex
      if (blockLogIndex === lockedEvent.logIndex) {
        logFound = true
        log = receiptLog
        break
      }
    }
    if (logFound) {
      TransferETHERC20ToNear.recordTransferLog({
        finished: 'find-proof',
        proof,
        log,
        txLogIndex,
        receipt,
        lockedEvent,
        block,
      })
    } else {
      console.log(`Failed to find log for event ${lockedEvent}`)
      TransferETHERC20ToNear.showRetryAndExit()
    }
  }

  static async waitBlockSafe({
    log,
    proof,
    receipt,
    txLogIndex,
    lockedEvent,
    block,
    ethOnNearClientContract,
  }) {
    const log_entry_data = logFromWeb3(log).serialize()
    const receipt_index = proof.txIndex
    const receipt_data = receiptFromWeb3(receipt).serialize()
    const header_data = proof.header_rlp
    const _proof = []
    for (const node of proof.receiptProof) {
      _proof.push(utils.rlp.encode(node))
    }

    const proof_locker = {
      log_index: txLogIndex,
      log_entry_data: log_entry_data,
      receipt_index: receipt_index,
      receipt_data: receipt_data,
      header_data: header_data,
      proof: _proof,
    }

    const new_owner_id = lockedEvent.returnValues.accountId
    const amount = lockedEvent.returnValues.amount
    console.log(
      `Transferring ${amount} tokens from ${lockedEvent.returnValues.token} ERC20. From ${lockedEvent.returnValues.sender} sender to ${new_owner_id} recipient`
    )

    const blockNumber = block.number
    // Wait until client accepts this block number.
    while (true) {
      // @ts-ignore
      const last_block_number = (
        await ethOnNearClientContract.last_block_number()
      ).toNumber()
      const is_safe = await ethOnNearClientContract.block_hash_safe(blockNumber)
      if (!is_safe) {
        const delay = 10
        console.log(
          `Near Client contract is currently at block ${last_block_number}. Waiting for block ${blockNumber} to be confirmed. Sleeping for ${delay} sec.`
        )
        await sleep(delay * 1000)
      } else {
        break
      }
    }
    TransferETHERC20ToNear.recordTransferLog({
      finished: 'block-safe',
      proof_locker,
      new_owner_id,
    })
  }

  static async deposit({
    proof_locker,
    nearFactoryContract,
    nearFactoryContractBorsh,
    nearTokenContract,
    new_owner_id,
  }) {
    // @ts-ignore
    const old_balance = await nearTokenContract.get_balance({
      owner_id: new_owner_id,
    })
    console.log(
      `Balance of ${new_owner_id} before the transfer is ${old_balance}`
    )
    // @ts-ignore
    try {
      await nearFactoryContractBorsh.deposit(
        proof_locker,
        new BN('300000000000000'),
        // We need to attach tokens because minting increases the contract state, by <600 bytes, which
        // requires an additional 0.06 NEAR to be deposited to the account for state staking.
        // Note technically 0.0537 NEAR should be enough, but we round it up to stay on the safe side.
        new BN('100000000000000000000').mul(new BN('600'))
      )
      console.log('Transferred')
    } catch (e) {
      console.log('Deposit failed with error:')
      console.log(e)
      TransferETHERC20ToNear.showRetryAndExit()
    }

    // @ts-ignore
    const new_balance = await nearTokenContract.get_balance({
      owner_id: new_owner_id,
    })
    console.log(
      `Balance of ${new_owner_id} after the transfer is ${new_balance}`
    )
    TransferETHERC20ToNear.deleteTransferLog()
  }

  static recordTransferLog(obj) {
    fs.writeFileSync('transfer-eth-erc20-to-near.log.json', JSON.stringify(obj))
  }

  static parseBuffer(obj) {
    for (let i in obj) {
      if (obj[i] && obj[i].type === 'Buffer') {
        obj[i] = Buffer.from(obj[i].data)
      } else if (obj[i] && typeof obj[i] === 'object') {
        obj[i] = TransferETHERC20ToNear.parseBuffer(obj[i])
      }
    }
    return obj
  }

  static loadTransferLog() {
    try {
      let log =
        JSON.parse(
          fs.readFileSync('transfer-eth-erc20-to-near.log.json').toString()
        ) || {}
      return TransferETHERC20ToNear.parseBuffer(log)
    } catch (e) {
      return {}
    }
  }

  static deleteTransferLog() {
    try {
      fs.unlinkSync('transfer-eth-erc20-to-near.log.json')
    } catch (e) {
      console.log('Warning: failed to remove tranfer log')
    }
  }

  static async execute(command) {
    initialCmd = command.parent.rawArgs.join(' ')
    let transferLog = TransferETHERC20ToNear.loadTransferLog()
    const amount = command.amount
    const ethSenderSk = command.ethSenderSk
    const nearReceiverAccount = command.nearReceiverAccount
    const tokenAddress = command.tokenName
      ? RainbowConfig.getParam(tokenAddressParam(command.tokenName))
      : RainbowConfig.getParam('eth-erc20-address')
    const tokenAccount = command.tokenName
      ? RainbowConfig.getParam(tokenAccountParam(command.tokenName))
      : RainbowConfig.getParam('near-erc20-account')
    console.log(`Using ETH address ${tokenAddress}`)

    // @ts-ignore
    let robustWeb3 = new RobustWeb3(RainbowConfig.getParam('eth-node-url'))
    let web3 = robustWeb3.web3
    let ethSenderAccount = web3.eth.accounts.privateKeyToAccount(
      normalizeEthKey(ethSenderSk)
    )
    web3.eth.accounts.wallet.add(ethSenderAccount)
    web3.eth.defaultAccount = ethSenderAccount.address
    ethSenderAccount = ethSenderAccount.address

    const ethERC20Contract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(fs.readFileSync(RainbowConfig.getParam('eth-erc20-abi-path'))),
      tokenAddress
    )

    const nearMasterAccountId = RainbowConfig.getParam('near-master-account')
    console.log(nearMasterAccountId)
    // @ts-ignore
    const keyStore = new nearlib.keyStores.InMemoryKeyStore()
    await keyStore.setKey(
      RainbowConfig.getParam('near-network-id'),
      nearMasterAccountId,
      nearlib.KeyPair.fromString(RainbowConfig.getParam('near-master-sk'))
    )
    const near = await nearlib.connect({
      nodeUrl: RainbowConfig.getParam('near-node-url'),
      networkId: RainbowConfig.getParam('near-network-id'),
      masterAccount: nearMasterAccountId,
      deps: { keyStore: keyStore },
    })
    const nearMasterAccount = new nearlib.Account(
      near.connection,
      nearMasterAccountId
    )
    await verifyAccount(near, nearMasterAccountId)

    const nearFactoryContract = new nearlib.Contract(
      nearMasterAccount,
      RainbowConfig.getParam('near-token-factory-account'),
      {
        changeMethods: ['deposit'],
        viewMethods: [],
      }
    )
    const nearTokenContract = new nearlib.Contract(
      nearMasterAccount,
      tokenAccount,
      {
        changeMethods: [],
        viewMethods: ['get_balance'],
      }
    )
    const nearFactoryContractBorsh = new NearMintableToken(
      nearMasterAccount,
      RainbowConfig.getParam('near-token-factory-account')
    )
    await nearFactoryContractBorsh.accessKeyInit()

    const extractor = new EthProofExtractor()
    extractor.initialize(RainbowConfig.getParam('eth-node-url'))

    const ethTokenLockerContract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(RainbowConfig.getParam('eth-locker-abi-path'))
      ),
      RainbowConfig.getParam('eth-locker-address')
    )

    const clientAccount = RainbowConfig.getParam('near-client-account')
    const ethOnNearClientContract = new EthOnNearClientContract(
      nearMasterAccount,
      clientAccount
    )

    if (transferLog.finished === undefined) {
      // TODO fix before using
      // Mint tokens first???
      /*await ethERC20Contract.methods
        .mint(ethSenderAccount, Number(amount))
        .send({ from: ethSenderAccount, gas: 5000000 })*/
      console.log(
        'Balance: ',
        await ethERC20Contract.methods.balanceOf(ethSenderAccount).call()
      )
      await TransferETHERC20ToNear.approve({
        robustWeb3,
        ethERC20Contract,
        amount,
        ethSenderAccount,
      })
      transferLog = TransferETHERC20ToNear.loadTransferLog()
    }
    if (transferLog.finished === 'approve') {
      await TransferETHERC20ToNear.lock({
        robustWeb3,
        ethTokenLockerContract,
        tokenAddress,
        amount,
        nearReceiverAccount,
        ethSenderAccount,
      })
      transferLog = TransferETHERC20ToNear.loadTransferLog()
    }
    if (transferLog.finished === 'lock') {
      await TransferETHERC20ToNear.findProof({
        extractor,
        lockedEvent: transferLog.lockedEvent,
        web3,
      })
      transferLog = TransferETHERC20ToNear.loadTransferLog()
    }
    if (transferLog.finished === 'find-proof') {
      await TransferETHERC20ToNear.waitBlockSafe({
        ethOnNearClientContract,
        ...transferLog,
      })
      transferLog = TransferETHERC20ToNear.loadTransferLog()
    }
    if (transferLog.finished === 'block-safe') {
      await TransferETHERC20ToNear.deposit({
        nearFactoryContract,
        nearFactoryContractBorsh,
        nearTokenContract,
        ...transferLog,
      })
    }

    try {
      // Only WebSocket provider can close.
      web3.currentProvider.connection.close()
    } catch (e) {}
    process.exit(0)
  }
}

exports.TransferETHERC20ToNear = TransferETHERC20ToNear

'''
'''--- watchdog/index.js ---
const Web3 = require('web3')
const fs = require('fs')
const { RainbowConfig } = require('../config')
const {
  sleep,
  RobustWeb3,
  normalizeEthKey,
  promiseWithTimeout,
} = require('../rainbow/robust')
const Tx = require('ethereumjs-tx').Transaction

const SLOW_TX_ERROR_MSG = 'transaction not executed within 5 minutes'

class Watchdog {
  async initialize() {
    // @ts-ignore
    this.robustWeb3 = new RobustWeb3(RainbowConfig.getParam('eth-node-url'))
    this.web3 = this.robustWeb3.web3
    const ethMasterAccount = this.web3.eth.accounts.privateKeyToAccount(
      normalizeEthKey(RainbowConfig.getParam('eth-master-sk'))
    )
    this.web3.eth.accounts.wallet.add(ethMasterAccount)
    this.web3.eth.defaultAccount = ethMasterAccount.address
    this.ethMasterAccount = ethMasterAccount.address

    // Initialize client contract.
    console.log('Deploying Near2EthClient contract.')
    this.clientContract = new this.web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(RainbowConfig.getParam('eth-client-abi-path'))
      ),
      RainbowConfig.getParam('eth-client-address'),
      {
        from: this.ethMasterAccount,
        handleRevert: true,
      }
    )
  }

  async run() {
    let privateKey = RainbowConfig.getParam('eth-master-sk')
    if (privateKey.startsWith('0x')) {
      privateKey = privateKey.slice(2)
    }
    privateKey = Buffer.from(privateKey, 'hex')
    const delay = RainbowConfig.getParam('watchdog-delay')
    const errorDelay = RainbowConfig.getParam('watchdog-error-delay')
    while (true) {
      try {
        const bridgeState = await this.clientContract.methods.bridgeState().call()
        if (Number(bridgeState.nextValidAt) == 0) {
          console.log('No block to check.')
        } else {
          console.log('Checking block.')
          // We cannot memorize processed blocks because they might have been re-submitted with different data.
          for (let i = 0; i < Number(bridgeState.numBlockProducers); i++) {
            console.log(`Checking signature ${i}.`)
            let result
            try {
              result = await this.clientContract.methods.checkBlockProducerSignatureInHead(i).call()
            } catch (e) {
              if (!e.reason || !e.signature) {
                throw e
              }
              continue
            }
            if (!result) {
              console.log(`Challenging signature ${i}.`)
              try {
                let gasPrice = await this.web3.eth.getGasPrice()
                let nonce = await this.web3.eth.getTransactionCount(
                  this.ethMasterAccount
                )
                while (gasPrice < 10000 * 1e9) {
                  try {
                    // Keep sending with same nonce but higher gasPrice to override same txn
                    let tx = new Tx({
                      from: this.ethMasterAccount.address,
                      // this is required otherwise gas is infinite
                      to: RainbowConfig.getParam('eth-client-address'),
                      gasLimit: Web3.utils.toHex(2000000),
                      gasPrice: Web3.utils.toHex(gasPrice),
                      nonce: Web3.utils.toHex(nonce),
                      data: this.clientContract.methods
                        .challenge(this.ethMasterAccount, i)
                        .encodeABI(),
                    })
                    tx.sign(privateKey)
                    tx = '0x' + tx.serialize().toString('hex')

                    await promiseWithTimeout(
                      5 * 60 * 1000,
                      this.web3.eth.sendSignedTransaction(tx),
                      SLOW_TX_ERROR_MSG
                    )
                    break
                  } catch (e) {
                    if (e.message === SLOW_TX_ERROR_MSG) {
                      console.log(SLOW_TX_ERROR_MSG)
                      console.log(`current gasPrice: ${gasPrice}. rechallenge with double gasPrice`)
                      gasPrice *= 2
                    } else {
                      throw e
                    }
                  }
                }
              } catch (err) {
                console.log(`Challenge failed. Maybe the block was already reverted? ${err}`)
              }
              break
            }
          }
        }
        console.log(`Sleeping for ${delay} seconds.`)
        await sleep(delay * 1000)
      } catch (e) {
        console.log('Error', e)
        await sleep(errorDelay * 1000)
      }
    }
  }
}

exports.Watchdog = Watchdog

'''