*GitHub Repository "abhinn-aakash/NewRepo_near"*

'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- src/OldApp.js ---
/// Keeping this for reference of previous work

import 'regenerator-runtime/runtime'
import React, { useState } from 'react'
import { fromNear2Yocto, fromYocto2Near, humanReadableDate, login, logout, parseNearAmount } from './utils'
import {
  BrowserRouter as Router,
  Switch,
  Route,
  Link
} from "react-router-dom";
import './global.css'

import getConfig from './config'
import Paper from "@material-ui/core/Paper";
import { makeStyles } from "@material-ui/core/styles";
import Button from "@material-ui/core/Button";
import Big from "big.js";
import TextField from "@material-ui/core/TextField";
import InputLabel from "@material-ui/core/InputLabel";
import FormControl from "@material-ui/core/FormControl";
import Input from "@material-ui/core/Input";
import FormHelperText from "@material-ui/core/FormHelperText";
import moment from "moment";
import TableContainer from "@material-ui/core/TableContainer";
import Table from "@material-ui/core/Table";
import TableHead from "@material-ui/core/TableHead";
import TableRow from "@material-ui/core/TableRow";
import TableCell from "@material-ui/core/TableCell";
import TableBody from "@material-ui/core/TableBody";
import Container from "@material-ui/core/Container";
import Streamform from './pages/streamform';
import zIndex from '@material-ui/core/styles/zIndex';
const { networkId } = getConfig(process.env.NODE_ENV || 'development')

const BOATLOAD_OF_GAS = Big(3).times(10 ** 13).toFixed()

const useStyles = makeStyles({
  card: {
    backgroundColor: '#333',
    color: '#FAFAFA',
    padding: '35px 30px',
    marginTop: '15px',
    marginBottom: '15px',
  },
  label: {
    color: '#ccc'
  },
  field: {
    marginTop: '15px',
    marginBottom: '15px',
  },
  title: {
    color: '#FAFAFA !important',
    textDecoration: 'none'
  },
  table: {
    minWidth: 650,
  },
  menu: {
    display: 'flex',
    justifyContent: 'space-between',
    listStyle: 'katakana',
    textDecoration: 'none',
    color: '#ccc',
  }
})

function App() {
  const classes = useStyles()

  const [events, setEvents] = useState([])
  const [myEvents, setMyEvents] = useState([])

  const updateMyEvents = (events) => {
    events.map(async (event) => {
      try {
        const attendee = await window.contract.check_attendee({ eventId: event.id, caller: window.accountId })
        if (attendee) {
          setMyEvents([event.id, ...myEvents])
        }
      } catch (e) {
        console.log(e)
        console.log('Failed', event.id)
      }
    })
  }

  const updateEvents = () => {
    if (window.walletConnection.isSignedIn()) {
      const timestamp = parseInt(moment().unix())
      console.log(timestamp)

      // window.contract is set by initContract in index.js
      window.contract.get_events({ accountId: window.accountId })
        .then(events => {
          setEvents(events.sort(event => timestamp - parseInt(event.start.slice(0, 10))))
          updateMyEvents(events)
        })
    }
  }

  React.useEffect(
    () => {
      console.log('Execution')
      updateEvents()
    },

    []
  )

  // if not signed in, return early with sign-in prompt
  if (!window.walletConnection.isSignedIn()) {
    return (
      <div>
        <nav class="uk-navbar-container" uk-navbar="true">
          <div class="uk-navbar-left">

            <ul class="uk-navbar-nav">
              <li class="uk-active"><a href="#"><img src="https://xeggo.co/assets/images/logo/xeggo.svg"></img></a></li>

            </ul>

          </div>
          <div class="uk-navbar-right">

            <ul class="uk-navbar-nav">
              <li>
                <a href="#"><i className="fas fa-user-circle fa-lg"></i></a>
                <div class="uk-navbar-dropdown">
                  <ul class="uk-nav uk-navbar-dropdown-nav">
                    <li class="uk-active"><a href="#">Sign In</a></li>

                  </ul>
                </div>
              </li>
            </ul>
          </div>
        </nav>

        <main className="container ">
          <p className="uk-margin-large-top">One stop solution for your recurring payment</p>
          <button className="xeggoBtn" onClick={login}>Start Stream</button>
        </main>
      </div>
    )
  }

  return (
    // use React Fragment, <>, to avoid wrapping elements in unnecessary divs
    <Router>
      <div>
        <nav>
          <ul className={classes.menu}>
            {/* <li>
              <Link to="/"  >Dashboard</Link>
            </li>
            <li>
              <Link to="/new">Stream Money</Link>
            </li>
            <li>
              <Link to="/me">Past Stream</Link>
            </li> */}
            <li>
              {window.accountId}
              <Button className="link" style={{ color: '#C51162' }} onClick={logout}>
                Sign out
              </Button>
            </li>
          </ul>
        </nav>
        <switch>
          <Route path='/new'>
            <NewEvent createEvent={() => { }} />
          </Route>
          <Route path='/me'>
            <MyEvents events={events} myEvents={myEvents} />
          </Route>
          <Route exact path='/event/:id' render={(props) => <EventDetail myEvents={myEvents} events={events}  {...props} />} />
          <Route exact path='/'>
            {/* <Home events={events} myEvents={myEvents} /> */}
            <Streamform></Streamform>

          </Route>
        </switch>
      </div>
    </Router>
  )
}

const NewEvent = (props) => {
  const classes = useStyles(props)

  const [title, setTitle] = useState('')
  const [symbol, setSymbol] = useState('')
  const [maxSeats, setMaxSeats] = useState(10)
  const [seatPrice, setSeatPrice] = useState(1)
  const [startDate, setStartDate] = useState(null)
  const [endDate, setEndDate] = useState(null)

  const createEvent = () => {
    if (window.walletConnection.isSignedIn()) {
      const seatPriceYocto = fromNear2Yocto(seatPrice.toString())
      console.log(startDate)
      const startDateTimestamp = moment(startDate).valueOf() + "000000"
      const endDateTimestamp = moment(endDate).valueOf() + "000000"

      const payload = {
        name: title,
        symbol: symbol.replace(/\s/g, ''),
        seatPrice: seatPriceYocto,
        startDate: startDateTimestamp,
        endDate: endDateTimestamp,
        initialSupply: parseInt(maxSeats)
      }

      console.log(payload)

      // window.contract is set by initContract in index.js
      window.contract.factory(payload).then(events => {
        console.log('Event succesfully created')
        setTitle('')
        setSymbol('')
        setMaxSeats(0)
        setSeatPrice(0)
        setStartDate('')
        setEndDate('')
        window.location = '/'
      }).catch(() => {
        alert('Failed to create event')
      })
    }
  }

  return <Container>
    <Paper className={classes.card}>
      <form action="">

        <FormControl style={{ display: 'block' }} className={classes.field}>
          <InputLabel className={classes.label} htmlFor="title">Enter the name of the event for which you want to stream money</InputLabel>
          <Input style={{ width: '100%' }} onChange={(e) => setTitle(e.target.value)} id="title" aria-describedby="Event title" />
        </FormControl>
        <FormControl className={classes.field}>
          <InputLabel className={classes.label} htmlFor="symbol">Set one unique identifier</InputLabel>
          <Input onChange={(e) => setSymbol(e.target.value)} id="symbol" aria-describedby="Event Symbol" />
          <FormHelperText style={{ color: '#999' }} id="symbol-helper-text">This must be unique, this wil act as the token symbol of this event</FormHelperText>
        </FormControl>

        <div>
          <FormControl className={classes.field}>
            <InputLabel className={classes.label} htmlFor="seats">No. of stream time</InputLabel>
            <Input type="number" onChange={(e) => setMaxSeats(e.target.value)} id="seats" aria-describedby="Max seats for this event" />
            <FormHelperText style={{ color: '#999' }} id="symbol-helper-text">The maximum allowed number of stream with price in near token</FormHelperText>
          </FormControl>
          <FormControl className={classes.field}>
            <InputLabel className={classes.label} htmlFor="seatPrice">Price per Stream</InputLabel>
            <Input type="number" onChange={(e) => setSeatPrice(e.target.value)} id="seatsPrice" aria-describedby="The price per seat" />
          </FormControl>
        </div>

        <div>
          <FormControl className={classes.field}>
            <Input type="datetime-local" onChange={(e) => setStartDate(e.target.value)} id="start" aria-describedby="Event starting date" />
            <FormHelperText style={{ color: '#999' }} id="symbol-helper-text">Starting date (MM/DD/YYYY)</FormHelperText>
          </FormControl>
          <FormControl className={classes.field}>
            <Input type="datetime-local" onChange={(e) => setEndDate(e.target.value)} id="end" aria-describedby="Event ending date" />
            <FormHelperText style={{ color: '#999' }} id="symbol-helper-text">Ending Date</FormHelperText>
          </FormControl>
        </div>

        <Button onClick={createEvent} variant="contained" color="secondary">Stream Money in Near Token</Button>
      </form>
    </Paper>
  </Container>
}

const EventDetail = (props) => {
  const id = props.match.params.id
  const requestedEvents = (props.events || []).filter(event => event.id == id)

  return <Container>
    {requestedEvents.length ? <EventCard showTickets={true} event={requestedEvents[0]} myEvents={props.myEvents} /> : <h1>No events exists</h1>}
  </Container>
}

const MyEvents = (props) => {
  return <Container>
    {props.events.filter(event => props.myEvents.indexOf(event.id) >= 0).map(event => <EventCard myEvents={props.myEvents} event={event} />)}
  </Container>
}

const EventCard = (props) => {
  const classes = useStyles(props)
  const { event, myEvents, showTickets } = props
  const [myTicket, setMyTicket] = useState(null)
  const [tickets, setTickets] = useState([])

  if (showTickets) {
    const updateTickets = async () => {
      const tickets = await window.contract.get_attendess({ eventId: event.id })
      setTickets(tickets)

      tickets.forEach((ticket) => {
        if (ticket.owner === window.accountId) {
          setMyTicket(ticket);
        }
      });

      console.log(tickets)
    }
    React.useEffect(() => { updateTickets() }, event)
  }

  function purchase() {
    if (window.walletConnection.isSignedIn()) {

      // window.contract is set by initContract in index.js
      window.contract.purchase({ eventId: event.id }, BOATLOAD_OF_GAS, event.seatPrice)
        .then(events => {
          console.log('Purchased succesfully')
        })
    }
  }

  function transfer() {
    const person = prompt("Introduce the user id who will receive the ticket");

    if (person == null || person == "") {
      console.log('Transfer cancelled')
    } else {
      if (window.walletConnection.isSignedIn()) {
        // window.contract is set by initContract in index.js
        window.contract.transfer({ new_owner_id: person, token_id: event.id }, BOATLOAD_OF_GAS)
          .then(events => {
            alert('Transfer successfully')
            window.location.reload()
          }).catch((e) => {
            console.log(e)
            alert('Transfer ticket failed')
          })
      }
    }
  }

  function checkIn() {
    if (window.walletConnection.isSignedIn()) {

      // window.contract is set by initContract in index.js
      window.contract.check_in({ eventId: event.id }, BOATLOAD_OF_GAS)
        .then(events => {
          console.log('Succesful check in')
          window.location.reload()
        })
    }
  }

  return <Container>
    <Paper className={classes.card}>
      <Link className={classes.title} to={`/event/${event.id}`}><h1>{event.name} <span>#{event.id} - {event.symbol}</span></h1></Link>
      <p>Hosted by {event.host}</p>
      <p>Available {event.initialSupply - event.occupied} of {event.initialSupply}</p>
      <p>
        <b>Start</b> {humanReadableDate(event.start.slice(0, 10))} <br />
        <b>Ends</b> {humanReadableDate(event.end.slice(0, 10))}
      </p>
      {myTicket && !myTicket.check_in ?
        <Button onClick={checkIn} variant="contained" color="primary">Check In</Button> :
        <></>
      }
      {myEvents.indexOf(event.id) == -1 ?
        <Button onClick={purchase} variant="contained" color="secondary">Stream money  {parseNearAmount(event.seatPrice)} NEAR</Button> :
        <Button onClick={transfer} variant="contained" color="secondary"> Direct Transfer</Button>
      }

    </Paper>
    {showTickets ?
      <TableContainer component={Paper}>
        <Table className={classes.table} aria-label="simple table">
          <TableHead>
            <TableRow>
              <TableCell align="right">Stream people</TableCell>
              <TableCell align="right">Stream At</TableCell>
              <TableCell align="right">Check in</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {tickets.map((row, index) => (
              <TableRow key={index}>
                <TableCell align="right">{row.owner}</TableCell>
                <TableCell align="right">{row.purchased_at ? humanReadableDate(row.purchased_at.slice(0, 10)) : ''}</TableCell>
                <TableCell align="right">{row.check_in ? '✔️' : '❌'}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer> : <></>}
  </Container>
}

const Home = (props) => {
  return <Container>
    {props.events.map(event => <EventCard myEvents={props.myEvents} event={event} />)}
  </Container>
}

// this component gets rendered by App after the form is submitted
function Notification() {
  const urlPrefix = `https://explorer.${networkId}.near.org/accounts`
  return (
    <aside>
      <a target="_blank" rel="noreferrer" href={`${urlPrefix}/${window.accountId}`}>
        {window.accountId}
      </a>
      {' '/* React trims whitespace around tags; insert literal space character when needed */}
      called method: 'setGreeting' in contract:
      {' '}
      <a target="_blank" rel="noreferrer" href={`${urlPrefix}/${window.contract.contractId}`}>
        {window.contract.contractId}
      </a>
      <footer>
        <div>✔ Succeeded</div>
        <div>Just now</div>
      </footer>
    </aside>
  )
}

'''
'''--- src/__mocks__/fileMock.js ---
// NOTE: This is used to mock resource imports in JSX for tests
module.exports = '' 

'''
'''--- src/execute.js ---
const getConfig = require('./config');

// Load environment variables
require("dotenv").config();

// Load NEAR Javascript API components
const near = require("near-api-js");

// Load near configuration

// const nearConfig = getConfig(process.env.NODE_ENV || 'testnet')

// Directory where NEAR credentials are going to be stored
const credentialsPath = "/home/phinelipy/work/official/NEAR Protocol/NewRepo_near/src/credentials/testnet/receiver1.test1232.testnet.json";
// Configure the keyStore to be used with the NEAR Javascript API
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath)
console.log(keyStore);
// Setup default client options
const options = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: 'https://wallet.testnet.near.org',
  helperUrl: 'https://helper.testnet.near.org',
  explorerUrl: 'https://explorer.testnet.near.org',
  accountId: "receiver1.test1232.testnet",
  deps: {
    keyStore: keyStore
  }
}
async function main() {
  // Configure the client with options and our local key store
  const client = await near.connect(options);
  console.log("client: ", client);
  const account = await client.account(options.accountId);
  console.log("account: ", await account.getAccountDetails());
  // We'are using the same contract name, feel free to create a different one.
  const contractName = options.accountId;
  // Construct a new contract object, we'll be using it to perform calls
  const contract = new near.Contract(account, contractName, {
    viewMethods: ["getStream", "balanceOf",],   // our read function
    changeMethods: ["withdrawFromStream", "cancelStreamInternal", "createStream"], // our write function
    sender: options.accountId,   // account used to sign contract call transactions
  });
  console.log("contract: ", contract);
  // We will send the current date when calling `setValue`
  // const value = (new Date()).toString();

  console.log(`Calling contract call 'createStream'`);
  const streamId = await contract.createStream({ recipient: "test1232.testnet", deposit: 10, startTime: 1618423345, stopTime: 1621015325 });
  console.log("streamId: ", streamId);
  // Get the value we assigned
  console.log("Getting stream info");
  result = await contract.getStream(streamId);
  console.log("Result:", result);

  // Alternative way of calling a function
  result = await account.functionCall(
    contractName,
    "getStream",
    { streamId }
  );
  console.log(result);
};

main();
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="icon" href="./assets/favicon.ico" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
  <link rel="apple-touch-icon" href="./assets/favicon.ico" />
  <!-- UIkit CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.6.17/dist/css/uikit.min.css" />

  <!-- UIkit JS -->
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.6.17/dist/js/uikit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.6.17/dist/js/uikit-icons.min.js"></script>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">

  <title>Xeggo - Recurring platform solution</title>
  <meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width" />
</head>

<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
  <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  <script src="./index.tsx"></script>
</body>

</html>
'''
'''--- src/jest.init.js ---
import 'regenerator-runtime/runtime'

'''
'''--- src/main.test.js ---
beforeAll(async function () {
  // NOTE: nearlib and nearConfig are made available by near-cli/test_environment
  const near = await nearlib.connect(nearConfig)
  window.accountId = nearConfig.contractName
  window.contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['getGreeting'],
    changeMethods: [],
    sender: window.accountId
  })

  window.walletConnection = {
    requestSignIn() {
    },
    signOut() {
    },
    isSignedIn() {
      return true
    },
    getAccountId() {
      return window.accountId
    }
  }
})

test('getGreeting', async () => {
  const message = await window.contract.getGreeting({ accountId: window.accountId })
  expect(message).toEqual('Hello')
})

'''
'''--- src/utils.js ---
import { connect, Contract, keyStores, WalletConnection, utils } from 'near-api-js'
import getConfig from './config'
import moment from "moment";

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  const near = await connect(Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig))

  // Initializing Wallet based Account. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(near)

  // Getting the Account ID. If still unauthorized, it's just empty string
  window.accountId = window.walletConnection.getAccountId()

  // Initializing our contract APIs by contract name and configuration
  window.contract = new Contract(window.walletConnection.account(), nearConfig.contractName, {
    // View methods are read only. They don't modify the state, but usually return some value.
    viewMethods: ['balanceOf', 'deltaOf', 'getStream'],
    // Change methods can modify the state. But you don't receive the returned value when called.
    changeMethods: ['createStream', 'cancelStream', 'withdrawFromStream'],
  })

  return { contract, nearConfig, walletConnection };
}

export function logout() {
  window.walletConnection.signOut()
  // reload page
  window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

export const parseNearAmount = (amount) => {
  return utils.format.formatNearAmount(amount)
}

export const fromNear2Yocto = utils.format.parseNearAmount

export function humanReadableDate(timestamp) {
  return moment.unix(timestamp).fromNow();
}

export const createStream = async (recipient, deposit, startTime, stopTime) => {
  const response = await window.contract.createStream({ recipient, deposit, startTime, stopTime }); //startTime and stopTime in unix timestamp format
  return response;
}

export const getStream = async (streamId) => {
  const response = await window.contract.getStream({ streamId });
  return response;
}

export const balanceOf = async (streamId, accountId) => {
  const response = await window.contract.balanceOf({ streamId, accountId });
  return response;
}

export const deltaOf = async (streamId) => {
  const response = await window.contract.deltaOf({ streamId });
  return response;
}

export const cancelStream = async (streamId) => {
  const response = await window.contract.cancelStream({ streamId });
  return response;
}

export const withdrawFromStream = async (streamId, amount) => {
  const response = await window.contract.withdrawFromStream({ streamId, amount });
  return response;
}

'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>For local account login, Please run the following command in NEAR CLI, then enter account id here.
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''
'''--- steps.txt ---
====================================================
Deploy contract:
====================================================
Description: 

deploy contract named "contract-test1.testnet" using contract-test1.testnet account: owner of this contract is set to "contract-test1.     testnet" account.

Command:

near deploy   --contractName=contract-test1.testnet  --keyPath=./src/credentials/testnet/contract-test1.testnet.json  --wasmFile=./out/main.wasm  --initFunction "init" --initArgs "{}"

=======================================================================================================================================================
Scenario 1: Create a stream, withdraw some amount and then withdraw the remaining amount of the stream so that full deposit gets consumed and stream gets deleted on full consumption.
=======================================================================================================================================================

====================================================
fetch a stream by streamId: 
====================================================
Description:

fetching  a stream  using "test-receiver-account.testnet" account which does not even exist. Response will be a message "stream 2 does not exist".

Command:

near view contract-test1.testnet getStream '{"streamId": 2}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
create a new stream: 
====================================================

Description:

"test-sender-account.testnet" account creates a new stream with parameters : {"recipient": "test-receiver-account.testnet", "deposit": 3170, "startTime": 1618745491, "stopTime": 1618747076} details.Output will be `streamId`. Note: deposit should be multiple of (stopTime-startTime).

Command:

near call contract-test1.testnet createStream '{"recipient": "test-receiver-account.testnet", "deposit": 3170, "startTime": 1618745491, "stopTime": 1618747076}' --accountId test-sender-account.testnet --keyPath "./src/credentials/testnet/test-sender-account.testnet.json" --network_id "testnet"

====================================================
fetch stream by streamId: 
====================================================

Description:

check the newly created stream for details using "test-receiver-account.testnet" account.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
withdraw from stream:
====================================================
Description:

"test-receiver-account.testnet" account withdraws 2000 yocto from stream with streamId `1`. remainingBalance of stream will get updated after withdrawing the specific amount from the stream.

Command:

near call contract-test1.testnet withdrawFromStream '{"streamId": 1, "amount":2000}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
fetch stream by streamId:
====================================================

Description:

fetching updated stream after withdrawing 2000 yocto to check the latest value of remainingBalance of the stream.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
withdraw from stream:
====================================================

Description:

"test-receiver-account.testnet" account is withdrawing again and setting withdrawl amount to a value which is higher than the available balance in the stream. you will get the error message "withdrawl amount is higher than available balance in the stream."

Command:

near call contract-test1.testnet withdrawFromStream '{"streamId": 1, "amount":2000}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
withdraw from stream:
====================================================

Description:

"test-receiver-account.testnet" account withdraws 1170 yocto from stream. then remainingBalance of stream will get updated and then gets deleted as the remainingBalance  is zero now after transferring the specific amount to the receiver's account.

Command:

near call contract-test1.testnet withdrawFromStream '{"streamId": 1, "amount":1170}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
fetching stream: 
====================================================

Description:

this should return that stream does not exist as stream gets deleted because the full amount have been withdrawn and remainingBalance is set to zero.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

=======================================================================================================================================================
            Scenario 2: Create a new stream and then withdraw some amount from the stream and then cancel the steam which is partially consumed.
=======================================================================================================================================================

====================================================
Create a new stream:
====================================================

Description:

"test-sender-account.testnet" creates a new stream where recipient is  "test-receiver-account.testnet" and deposit amount gets transferred to the smart contract and returns new streamId. note: deposit should be multiple of (stopTime-startTime).

Command:

near call contract-test1.testnet createStream '{"recipient": "test-receiver-account.testnet", "deposit": 4755, "startTime": 1618745491, "stopTime": 1618747076}' --accountId test-sender-account.testnet --keyPath "./src/credentials/testnet/test-sender-account.testnet.json" --network_id "testnet"

====================================================
fetch stream by stream Id:
====================================================

Description:

fetching the newly created stream to view stream details.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
withdraw some amount from stream:
====================================================

Description:

"test-receiver-account.testnet" withdraws 2000 yocto from stream and remainingBalance of stream get updated after transferring the funds.

Command:

near call contract-test1.testnet withdrawFromStream '{"streamId": 1, "amount":2000}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
fetch stream by stream Id:
====================================================

Description:

fetching updated stream after withdraw.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
cancel stream:
====================================================

Description:

cancelled the existing stream with some remainingBalance. here, sender and receiver  gets remaining amount from stream in their account.Stream also gets deleted.Note: there is still some value left in the remainingBalance of the stream which gets settled between the sender and receiver.

Command:

near call contract-test1.testnet cancelStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
checking canceled stream: 
====================================================

Description:

this should return that stream does not exist as stream gets deleted on cancel.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"
'''
'''--- test-commands.txt ---
compile contract: 
npx asb
====================================================
Deploy contract:
====================================================
Description: 

deploy contract named "contract-test1.testnet" using contract-test1.testnet account: owner of this contract is set to "contract-test1.testnet" account.

Command:

near deploy   --contractName=contract-test1.testnet  --keyPath=./src/credentials/testnet/contract-test1.testnet.json  --wasmFile=./out/main.wasm  --initFunction "init" --initArgs "{}"

=======================================================================================================================================================
Scenario 1: Create a stream, withdraw some amount and then withdraw the remaining amount of the stream so that full deposit gets consumed and stream gets deleted on full consumption.
=======================================================================================================================================================

====================================================
fetch a stream by streamId: 
====================================================
Description:

fetching  a stream  using "test-receiver-account.testnet" account which does not even exist. Response will be a message "stream 2 does not exist".

Command:

near view contract-test1.testnet getStream '{"streamId": 5}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
create a new stream: 
====================================================

Description:

"test-sender-account.testnet" account creates a new stream with parameters : {"recipient": "test-receiver-account.testnet", "deposit": 3170, "startTime": 1618745491, "stopTime": 1618747076} details.Output will be `streamId`. Note: deposit should be multiple of (stopTime-startTime).

Command:

near call contract-test1.testnet createStream '{"recipient": "test-receiver-account.testnet", "deposit": "5000", "frequency": 3 ,"startTime": "1621012154", "stopTime": "1621112154"}' --accountId test-sender-account.testnet --keyPath "./src/credentials/testnet/test-sender-account.testnet.json" --network_id "testnet"

near call contract-test1.testnet createStream '{"recipient": "test-receiver-account.testnet", "deposit": "250000000000", "frequency": 3 ,"startTime": "1621362600000000000", "stopTime": "1621621800000000000"}' --accountId test-sender-account.testnet --keyPath "./src/credentials/testnet/test-sender-account.testnet.json" --network_id "testnet"

near call contract-test1.testnet createStream '{"recipient": "test-receiver-account.testnet", "deposit": 300000000000, "frequency": 2 ,"startTime": 1621006588, "stopTime": 1622006588}' --accountId test-sender-account.testnet --keyPath "./src/credentials/testnet/test-sender-account.testnet.json" --network_id "testnet"

====================================================
fetch stream by streamId: 
====================================================

Description:

check the newly created stream for details using "test-receiver-account.testnet" account.

Command:

near view contract-test1.testnet getStream '{"streamId": 2}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
withdraw from stream:
====================================================
Description:

"test-receiver-account.testnet" account withdraws 2000 yocto from stream with streamId `1`. remainingBalance of stream will get updated after withdrawing the specific amount from the stream.

Command:

near call contract-test1.testnet withdrawFromStream '{"streamId": 1, "amount":"150000000000"}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
fetch stream by streamId:
====================================================

Description:

fetching updated stream after withdrawing 2000 yocto to check the latest value of remainingBalance of the stream.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
withdraw from stream:
====================================================

Description:

"test-receiver-account.testnet" account is withdrawing again and setting withdrawl amount to a value which is higher than the available balance in the stream. you will get the error message "withdrawl amount is higher than available balance in the stream."

Command:

near call contract-test1.testnet withdrawFromStream '{"streamId": 1, "amount":2000}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
withdraw from stream:
====================================================

Description:

"test-receiver-account.testnet" account withdraws 1170 yocto from stream. then remainingBalance of stream will get updated and then gets deleted as the remainingBalance  is zero now after transferring the specific amount to the receiver's account.

Command:

near call contract-test1.testnet withdrawFromStream '{"streamId": 1, "amount":1170}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
fetching stream: 
====================================================

Description:

this should return that stream does not exist as stream gets deleted because the full amount have been withdrawn and remainingBalance is set to zero.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

=======================================================================================================================================================
            Scenario 2: Create a new stream and then withdraw some amount from the stream and then cancel the steam which is partially consumed.
=======================================================================================================================================================

====================================================
Create a new stream:
====================================================

Description:

"test-sender-account.testnet" creates a new stream where recipient is  "test-receiver-account.testnet" and deposit amount gets transferred to the smart contract and returns new streamId. note: deposit should be multiple of (stopTime-startTime).

Command:

near call contract-test1.testnet createStream '{"recipient": "test-receiver-account.testnet", "deposit": 4755, "startTime": 1618745491, "stopTime": 1618747076}' --accountId test-sender-account.testnet --keyPath "./src/credentials/testnet/test-sender-account.testnet.json" --network_id "testnet"

====================================================
fetch stream by stream Id:
====================================================

Description:

fetching the newly created stream to view stream details.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
withdraw some amount from stream:
====================================================

Description:

"test-receiver-account.testnet" withdraws 2000 yocto from stream and remainingBalance of stream get updated after transferring the funds.

Command:

near call contract-test1.testnet withdrawFromStream '{"streamId": 1, "amount":2000}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
fetch stream by stream Id:
====================================================

Description:

fetching updated stream after withdraw.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

====================================================
cancel stream:
====================================================

Description:

cancelled the existing stream with some remainingBalance. here, sender and receiver  gets remaining amount from stream in their account.Stream also gets deleted.Note: there is still some value left in the remainingBalance of the stream which gets settled between the sender and receiver.

Command:

near call contract-test1.testnet cancelStream '{"streamId": 1}' --accountId test-sender-account.testnet  --keyPath "./src/credentials/testnet/test-sender-account.testnet .json" --network_id "testnet"

====================================================
checking canceled stream: 
====================================================

Description:

this should return that stream does not exist as stream gets deleted on cancel.

Command:

near view contract-test1.testnet getStream '{"streamId": 1}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

get spent amount:

near view contract-test1.testnet getSpent '{"accountId": "test-receiver-account.testnet"}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

near view contract-test1.testnet getSpent '{"accountId": "test-sender-account.testnet"}' --accountId test-sender-account.testnet --keyPath "./src/credentials/testnet/test-sender-account.testnet.json" --network_id "testnet"

get earnings:

near view contract-test1.testnet getEarnings '{"accountId": "test-receiver-account.testnet"}' --accountId test-receiver-account.testnet --keyPath "./src/credentials/testnet/test-receiver-account.testnet.json" --network_id "testnet"

near view contract-test1.testnet getStreamsByAccountId '{"accountId": "test-sender-account.testnet"}' --accountId test-sender-account.testnet --keyPath "./src/credentials/testnet/test-sender-account.testnet.json" --network_id "testnet"
'''