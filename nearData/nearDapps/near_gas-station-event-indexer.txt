*GitHub Repository "near/gas-station-event-indexer"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- README.md ---
# gas-station-event-indexer
Picks up events emitted from the gas station contract used for generating signed foreign chain transactions and calls the multichain relayer `/send_funding_and_user_signed_txns` endpoint locally

# Run
1. ensure you have https://github.com/near/multichain-relayer-server running on localhost:3030
2. `make install` create virtual environment and install `requirements.txt`
2. update the config.toml with the appropriate values
3. `make run` runs the `gas_station_event_indexer.py` script

'''
'''--- config.toml ---
network = "testnet"
# gas station contract account id
contract_id = "canhazgas.testnet"

'''
'''--- gas_station_event_indexer.py ---
from __future__ import annotations

import asyncio
import json
import os
from dataclasses import dataclass, fields
from enum import Enum
from typing import Optional, Any

import requests
import toml
from dataclasses_json import DataClassJsonMixin
from near_lake_framework import near_primitives, LakeConfig, streamer

REQUEST_TIMEOUT = 10
ParsedLog = dict[str, Any]

@dataclass
class EventData(DataClassJsonMixin):
    """
    {
      "foreign_chain_id": "97",
      "sender_local_address": "hatchet.testnet",
      "signed_transactions": [
        "f862037882520894c5acb93d901fb260359cd1e982998236cfac65e0834ce7808002a02dfe84af26b45fec8704a6542e828428fcce018a4e266e19e087a55f1f73fff8a06cc72dc5ecc66c84e3b4f02513961235fff5f463ac68fd00f5072a6f64bfe4cc",
        "f85f8078825208940505050505050505050505050505050505050505648003a033d5ef8c991ec82b9a6b38b7f7ca91ba34ec814c9eec1e2a42e4fc4fc9c443f7a0675e56a82d9464d1cba7ef62d7b9d6e1a4b87328c610b28dfc4b81815f8969d0"
      ]
    }
    """

    foreign_chain_id: str
    sender_local_address: str
    signed_transactions: list[str]

    def validate(self) -> bool:
        return len(self.signed_transactions) == 2

    def send_to_service(self) -> None:
        payload = {
            "foreign_chain_id": self.foreign_chain_id,
            "signed_transactions": self.signed_transactions,
        }
        url = "localhost:3030/send_funding_and_user_signed_txns"
        try:
            response = requests.post(url, json=payload, timeout=REQUEST_TIMEOUT)
            if response.status_code not in {200, 201}:
                print(f"Error: calling {url}: {response.text}")
            else:
                print(f"Response from {url}: {response.text}")
        except requests.RequestException as e:
            print(f"HTTP Request failed: {str(e)}")

class Network(Enum):
    """
    Representing Near Lake Framework networks.
    TODO - this Enum actually belongs in the `near_lake_framework.enums` module.
    """

    MAINNET = "mainnet"
    TESTNET = "testnet"

    @staticmethod
    def from_string(value: str) -> Network:
        try:
            return Network(value.lower())
        except ValueError as err:
            valid_values = [v.value for v in Network]
            raise ValueError(
                f"Unknown network: {value}. Valid values are: {valid_values}"
            ) from err

    def __str__(self) -> str:
        return self.value

    def __repr__(self) -> str:
        return self.value

@dataclass
class Config:
    """
    Runtime Configuration class
    """

    network: Network
    contract_id: str

    @staticmethod
    def from_toml(config_path: str = "config.toml") -> Config:
        config_dict = toml.load(config_path)
        required_keys = {field.name for field in fields(Config)}
        if not all(key in config_dict for key in required_keys):
            missing_keys = required_keys - config_dict.keys()
            raise ValueError(f"Missing keys in {config_path}: {missing_keys}")

        config_dict["network"] = Network.from_string(config_dict["network"])
        return Config(**config_dict)

def fetch_latest_block(
    network: Network = Network.MAINNET,
) -> near_primitives.BlockHeight:
    """
    Define the RPC endpoint for the NEAR network
    """
    url = f"https://rpc.{network}.near.org"

    # Define the payload for fetching the latest block
    payload = json.dumps(
        {
            "jsonrpc": "2.0",
            "id": "dontcare",
            "method": "block",
            "params": {"finality": "final"},
        }
    )

    # Define the headers for the HTTP request
    headers = {"Content-Type": "application/json"}

    # Send the HTTP request to the NEAR RPC endpoint
    response = requests.request(
        "POST", url, headers=headers, data=payload, timeout=REQUEST_TIMEOUT
    )

    # Parse the JSON response to get the latest final block height
    latest_final_block = response.json()["result"]["header"]["height"]

    return latest_final_block

# Event format json example:
# {
#     "standard": "x-gas-station",
#     "version": "0.1.0",
#     "event": "transaction_sequence_signed",
#     "data": {
#         "foreign_chain_id": "97",
#         "sender_local_address": "hatchet.testnet",
#         "signed_transactions": [
#             "f862037882520894c5acb93d901fb260359cd1e982998236cfac65e0834ce7808002a02dfe84af26b45fec8704a6542e828428fcce018a4e266e19e087a55f1f73fff8a06cc72dc5ecc66c84e3b4f02513961235fff5f463ac68fd00f5072a6f64bfe4cc",
#             "f85f8078825208940505050505050505050505050505050505050505648003a033d5ef8c991ec82b9a6b38b7f7ca91ba34ec814c9eec1e2a42e4fc4fc9c443f7a0675e56a82d9464d1cba7ef62d7b9d6e1a4b87328c610b28dfc4b81815f8969d0"
#         ]
#     }
# }

def extract_relevant_log(
    log: str, receipt_id: near_primitives.CryptoHash
) -> Optional[ParsedLog]:
    log_key = "EVENT_JSON:"
    if not log.startswith(log_key):
        return None

    try:
        parsed_log: ParsedLog = json.loads(log[len(log_key) :])
    except json.JSONDecodeError:
        print(
            f"Receipt ID: `{receipt_id}`\n"
            f"Error during parsing logs from JSON string to dict"
        )
        return None

    if (
        parsed_log.get("standard") != "x-gas-station"
        or parsed_log.get("event") != "transaction_sequence_signed"
    ):
        return None
    return parsed_log

def process_shard(shard: near_primitives.IndexerShard) -> None:
    for receipt_execution_outcome in shard.receipt_execution_outcomes:
        process_receipt_execution_outcome(receipt_execution_outcome)

def process_receipt_execution_outcome(
    receipt_execution_outcome: near_primitives.IndexerExecutionOutcomeWithReceipt,
) -> None:
    for log in receipt_execution_outcome.execution_outcome.outcome.logs:
        receipt = receipt_execution_outcome.receipt
        if not process_log(log, receipt):
            continue

def process_log(log: str, receipt: near_primitives.Receipt) -> bool:
    parsed_log = extract_relevant_log(log, receipt.receipt_id)
    if parsed_log is None:
        return False

    print(json.dumps(parsed_log, indent=4))
    return process_receipt_if_gas_station_contract(receipt, parsed_log)

def process_receipt_if_gas_station_contract(
    receipt: near_primitives.Receipt, parsed_log: ParsedLog
) -> bool:
    if not receipt.receiver_id.endswith(config.contract_id):
        return False

    try:
        event_data = EventData.from_dict(parsed_log["data"])
        if not event_data.validate():
            print(f"Error: Invalid event data: {event_data}")
            return False

        print(json.dumps(event_data, indent=4))
        event_data.send_to_service()
        return True

    except json.JSONDecodeError:
        print(
            f"Receipt ID: `{receipt.receipt_id}`\n"
            "Error during parsing event data from JSON string to dict"
        )
        return False

async def handle_streamer_message(
    streamer_message: near_primitives.StreamerMessage,
) -> None:
    for shard in streamer_message.shards:
        process_shard(shard)

async def main() -> None:
    latest_final_block = fetch_latest_block(network=config.network)
    lake_config = LakeConfig(
        s3_bucket_name=f"near-lake-data-{config.network}",
        s3_region_name="eu-central-1",
        start_block_height=latest_final_block,
        # These fields must be set!
        aws_access_key_id=os.environ["AWS_ACCESS_KEY_ID"],
        aws_secret_key=os.environ["AWS_SECRET_ACCESS_KEY"],
    )
    print(f"Latest final block: {latest_final_block} on network: {config.network}")

    _stream_handle, streamer_messages_queue = streamer(lake_config)
    while True:
        streamer_message = await streamer_messages_queue.get()
        await handle_streamer_message(streamer_message)

if __name__ == "__main__":
    config = Config.from_toml()
    loop = asyncio.new_event_loop()
    loop.run_until_complete(main())

'''
'''--- requirements.txt ---
asyncio==3.4.3
near-lake-framework==0.0.7
requests==2.31.0
toml==0.10.2

black>=24.4.0
pylint>=3.1.0
mypy>=1.9.0
types-toml>=0.10.8.20240310
types-requests>=2.31.0.20240406

'''