*GitHub Repository "kiethase/Contract-depo"*

'''--- Cargo.toml ---
[package]
name = "account_deposit"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
path = "src/lib.rs"
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
uint = {version = "0.9.3", default-features = false}

[dev-dependencies]
near-sdk-sim = "3.1.0"
rand = "0.8"
rand_pcg = "0.3"

'''
'''--- build.sh ---
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cd ..
cp target/wasm32-unknown-unknown/release/account_deposit.wasm ./res/ref_exchange_local.wasm
'''
'''--- src/account_deposit.rs ---
use near_sdk::collections::UnorderedMap;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId};
use near_sdk::{
     env, near_bindgen, AccountId, Balance, StorageUsage,
};

use crate::*;

const U128_STORAGE: StorageUsage = 16;
const U64_STORAGE: StorageUsage = 8;
const U32_STORAGE: StorageUsage = 4;
// Max length of account id is 64 bytes.
const ACC_ID_STORAGE: StorageUsage = 64;
//As a key, 4 bytes length would be added to head
const ACC_ID_AS_KEY_STORAGE: StorageUsage = ACC_ID_STORAGE + 4;
const KEY_PREFIX_ACC: StorageUsage = 64;
// As a near_sdk::collection key, 1 byte for prefix
const ACC_ID_AS_CLT_KEY_STORAGE: StorageUsage = KEY_PREFIX_ACC + 1;

// ACC_ID: the Contract accounts map key length
// + VAccount enum: 1 byte
// + U128_STORAGE: near_amount storage
// + U32_STORAGE: legacy_tokens HashMap length
// + U32_STORAGE: tokens HashMap length
// + U64_STORAGE: storage_used
pub const INIT_ACCOUNT_STORAGE: StorageUsage =
    ACC_ID_AS_CLT_KEY_STORAGE + 1 + U128_STORAGE + U32_STORAGE + U32_STORAGE + U64_STORAGE;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    pub near_amount: Balance,
    pub tokens: UnorderedMap<AccountId, Balance>,
    pub storage_used: StorageUsage,
}

impl Account {
    pub fn new(account_id: &AccountId) -> Self {
        Account {
            near_amount: 0,
            tokens: UnorderedMap::new(StorageKey::AccountTokens {
                account_id: account_id.clone(),
            }),
            storage_used: 0,
        }
    }

    pub fn get_balance(&self, token_id: &AccountId) -> Option<Balance> {
        if let Some(token_balance) = self.tokens.get(token_id) {
            Some(token_balance)
        } else {
            None
        }
    }

    pub fn get_tokens(&self) -> Vec<AccountId> {
        let a: Vec<AccountId> = self.tokens.keys().collect();
        a
    }
    // Deposit amount to the balance of given token,
    // if given token not register and not enough storage, deposit fails
    pub(crate) fn deposit_with_storage_check(
        &mut self,
        token: &AccountId,
        amount: Balance,
    ) -> bool {
        if let Some(balance) = self.tokens.get(token) {
            let new_balance = balance + amount;
            self.tokens.insert(token, &new_balance);
            true
        } else {
            // check storage after insert, if fail should unregister the token
            self.tokens.insert(token, &(amount));
            if self.storage_usage() <= self.near_amount {
                true
            } else {
                self.tokens.remove(token);
                false
            }
        }
    }
    // [AUDIT_01]
    /// Returns amount of $NEAR necessary to cover storage used by this data structure.
    pub fn storage_usage(&self) -> Balance {
        (INIT_ACCOUNT_STORAGE
            + self.tokens.len() as u64 * (KEY_PREFIX_ACC + ACC_ID_AS_KEY_STORAGE + U128_STORAGE))
            as u128
            * env::storage_byte_cost()
    }

    // Deposit amout to the balance of given token.
    pub(crate) fn deposit(&mut self, token: &AccountId, amount: Balance) {
        if let Some(x) = self.tokens.get(token) {
            self.tokens.insert(token, &(amount + x));
        } else {
            self.tokens.insert(token, &amount);
        }
    }

    pub fn assert_storage_usage(&self) {
        assert!(
            self.storage_usage() <= self.near_amount,
            "{}",
            ERR11_INSUFFICIENT_STORAGE
        );
    }

    pub fn storage_available(&self) -> Balance {
        let locked = self.storage_usage();
        if self.near_amount > locked {
            self.near_amount - locked
        } else {
            0
        }
    }
    /// Returns minimal account deposit storage usage possible.
    pub fn min_storage_usage() -> Balance {
        INIT_ACCOUNT_STORAGE as Balance * env::storage_byte_cost()
    }

    // Register given token set balance to 0
    /// Registers given token and set balance to 0.
    pub(crate) fn register(&mut self, token_ids: &Vec<ValidAccountId>) {
        for token_id in token_ids {
            let t = token_id.as_ref();
            if self.get_balance(t).is_none() {
                self.tokens.insert(t, &0);
            }
        }
    }

    /// Unregisters `token_id` from this account balance.
    /// Panics if the `token_id` balance is not 0.
    pub(crate) fn unregister(&mut self, token_id: &AccountId) {
        let amount = self.tokens.remove(token_id).unwrap_or_default();
        assert_eq!(amount, 0, "{}", ERR24_NON_ZERO_TOKEN_BALANCE);
    }
}

#[near_bindgen]
impl Contract {
    //Registers given token in the user's account deposit
    #[payable]
    pub fn register_tokens(&mut self, token_ids: Vec<ValidAccountId>) {
        let sender_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&sender_id);
        account.register(&token_ids);
        self.internal_save_account(&sender_id, account);
    }

    #[payable]
    pub fn unregister_tokens(&mut self, token_ids: Vec<ValidAccountId>) {
        let sender_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&sender_id);
        for token_id in token_ids {
            account.unregister(token_id.as_ref());
        }
        self.internal_save_account(&sender_id, account);
    }
}

impl Contract {
    pub(crate) fn internal_deposit(
        &mut self,
        sender_id: &AccountId,
        token_id: &AccountId,
        amount: Balance,
    ) {
        let mut account = self.internal_unwrap_account(sender_id);
        account.deposit(token_id, amount);
        self.internal_save_account(&sender_id, account);
    }

    pub(crate) fn internal_save_account(&mut self, account_id: &AccountId, account: Account) {
        account.assert_storage_usage();
        self.accounts.insert(&account_id, &account.into());
    }

      /// storage withdraw
      pub(crate) fn internal_storage_withdraw(&mut self, account_id: &AccountId, amount: Balance) -> u128 {
        let mut account = self.internal_unwrap_account(&account_id);
        let available = account.storage_available();
        assert!(available > 0, "ERR_NO_STORAGE_CAN_WITHDRAW");
        let mut withdraw_amount = amount;
        if amount == 0 {
            withdraw_amount = available;
        }
        assert!(withdraw_amount <= available, "ERR_STORAGE_WITHDRAW_TOO_MUCH");
        account.near_amount -= withdraw_amount;
        self.internal_save_account(&account_id, account);
        withdraw_amount
    }
    /// Registers account in deposited amounts with given amount of $NEAR.
    /// If account already exists, adds amount to it.
    /// This should be used when it's known that storage is prepaid.
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId, amount: Balance) {
        let mut account = self.internal_unwrap_or_default_account(&account_id);
        account.near_amount += amount;
        self.internal_save_account(&account_id, account);
    }

    pub fn internal_get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id)
    }

    pub fn internal_unwrap_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .expect(errors::ERR10_ACC_NOT_REGISTERED)
    }

    pub fn internal_unwrap_or_default_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .unwrap_or_else(|| Account::new(account_id))
    }
    /// Returns current balance of given token for given user. If there is nothing recorded, returns 0.
    pub(crate) fn internal_get_deposit(
        &self,
        sender_id: &AccountId,
        token_id: &AccountId,
    ) -> Balance {
        self.internal_get_account(sender_id)
            .and_then(|x| x.get_balance(token_id))
            .unwrap_or(0)
    }
    
}

'''
'''--- src/errors.rs ---
// Storage errors.

pub const ERR10_ACC_NOT_REGISTERED: &str = "E10: account not registered";
pub const ERR11_INSUFFICIENT_STORAGE: &str = "E11: insufficient $NEAR storage deposit";
pub const ERR12_TOKEN_NOT_WHITELISTED: &str = "E12: token not whitelisted";
pub const ERR13_LP_NOT_REGISTERED: &str = "E13: LP not registered";
pub const ERR14_LP_ALREADY_REGISTERED: &str = "E14: LP already registered";

// Accounts.

pub const ERR21_TOKEN_NOT_REG: &str = "E21: token not registered";
pub const ERR22_NOT_ENOUGH_TOKENS: &str = "E22: not enough tokens in deposit";
// pub const ERR23_NOT_ENOUGH_NEAR: &str = "E23: not enough NEAR in deposit";
pub const ERR24_NON_ZERO_TOKEN_BALANCE: &str = "E24: non-zero token balance";
pub const ERR25_CALLBACK_POST_WITHDRAW_INVALID: &str =
    "E25: expected 1 promise result from withdraw";
// [AUDIT_05]
// pub const ERR26_ACCESS_KEY_NOT_ALLOWED: &str = "E26: access key not allowed";
pub const ERR27_DEPOSIT_NEEDED: &str = 
    "E27: attach 1yN to swap tokens not in whitelist";
pub const ERR28_WRONG_MSG_FORMAT: &str = "E28: Illegal msg in ft_transfer_call";
pub const ERR29_ILLEGAL_WITHDRAW_AMOUNT: &str = "E29: Illegal withdraw amount";

// Liquidity operations.

pub const ERR31_ZERO_AMOUNT: &str = "E31: adding zero amount";
pub const ERR32_ZERO_SHARES: &str = "E32: minting zero shares";
// [AUDIT_07]
pub const ERR33_TRANSFER_TO_SELF: &str = "E33: transfer to self";
pub const ERR34_INSUFFICIENT_LP_SHARES: &str = "E34: insufficient lp shares";

// Action result.

pub const ERR41_WRONG_ACTION_RESULT: &str = "E41: wrong action result type";

// Contract Level
pub const ERR51_CONTRACT_PAUSED: &str = "E51: contract paused";

// Swap
pub const ERR60_DECIMAL_ILLEGAL: &str = "E60: illegal decimal";
pub const ERR61_AMP_ILLEGAL: &str = "E61: illegal amp";
pub const ERR62_FEE_ILLEGAL: &str = "E62: illegal fee";
pub const ERR63_MISSING_TOKEN: &str = "E63: missing token";
pub const ERR64_TOKENS_COUNT_ILLEGAL: &str = "E64: illegal tokens count";
pub const ERR65_INIT_TOKEN_BALANCE: &str = "E65: init token balance should be non-zero";
pub const ERR66_INVARIANT_CALC_ERR: &str = "E66: encounter err when calc invariant D";
pub const ERR67_LPSHARE_CALC_ERR: &str = "E67: encounter err when calc lp shares";
pub const ERR68_SLIPPAGE: &str = "E68: slippage error";
pub const ERR69_MIN_RESERVE: &str = "E69: pool reserved token balance less than MIN_RESERVE";
pub const ERR70_SWAP_OUT_CALC_ERR: &str = "E70: encounter err when calc swap out";
pub const ERR71_SWAP_DUP_TOKENS: &str = "E71: illegal swap with duplicated tokens";

// pool manage
pub const ERR81_AMP_IN_LOCK: &str = "E81: amp is currently in lock";
pub const ERR82_INSUFFICIENT_RAMP_TIME: &str = "E82: insufficient ramp time";
pub const ERR83_INVALID_AMP_FACTOR: &str = "E83: invalid amp factor";
pub const ERR84_AMP_LARGE_CHANGE: &str = "E84: amp factor change is too large";

// Permissions
pub const ERR100_NOT_ALLOWED: &str = "E100: no permission to invoke this";

'''
'''--- src/lib.rs ---
use std::convert::TryInto;
use std::fmt;
use std::collections::HashMap;

use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};

use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet, Vector};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{
    assert_one_yocto, env, log, near_bindgen, AccountId, Balance, PanicOnDefault, Promise,
    PromiseResult, StorageUsage, BorshStorageKey
};

use crate::account_deposit::{Account};
use crate::errors::*;

mod account_deposit;
mod errors;
mod storage_impl;
mod token_receivers;

near_sdk::setup_alloc!();

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Accounts,
    Whitelist,
    AccountTokens {account_id: AccountId},
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub enum RunningState {
    Running, Paused
}

impl fmt::Display for RunningState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            RunningState::Running => write!(f, "Running"),
            RunningState::Paused => write!(f, "Paused"),
        }
    }
}

#[near_bindgen]
#[derive(BorshSerialize,BorshDeserialize,PanicOnDefault)]
pub struct Contract{
    // Account of the owner.
    owner_id: AccountId,
    // Account register, keeping track all the amounts deposited, storage and more.
    accounts: LookupMap<AccountId,Account>,
    // Whitelisted was set by owner
    whitelistied_tokens: UnorderedSet<AccountId>,
}

#[near_bindgen]
impl Contract{
    #[init]
    pub fn new(owner_id:ValidAccountId)->Self{
        Self {
            owner_id:owner_id.as_ref().clone(),
            accounts:LookupMap::new(StorageKey::Accounts),
            whitelistied_tokens: UnorderedSet::new(StorageKey::Whitelist),
        }
    }
    
    pub fn get_deposits(&self, account_id: ValidAccountId) -> HashMap<AccountId, U128> {
        let wrapped_account = self.internal_get_account(account_id.as_ref());
        if let Some(account) = wrapped_account {
            account.get_tokens()
                .iter()
                .map(|token| (token.clone(), U128(account.get_balance(token).unwrap())))
                .collect()
        } else {
            HashMap::new()
        }
    }
}

impl Contract{
    fn internal_check_storage(&self, prev_storage: StorageUsage) {
        let storage_cost = env::storage_usage()
            .checked_sub(prev_storage)
            .unwrap_or_default() as Balance
            * env::storage_byte_cost();

        let refund = env::attached_deposit()
            .checked_sub(storage_cost)
            .expect(
                format!(
                    "ERR_STORAGE_DEPOSIT need {}, attatched {}", 
                    storage_cost, env::attached_deposit()
                ).as_str()
            );
        if refund > 0 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }
    }

  
}

#[cfg(test)]
mod tests {
    use near_sdk::{near_bindgen, PanicOnDefault};

    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}

'''
'''--- src/storage_impl.rs ---
use crate::*;

use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
/// Implements users storage management for the pool.
#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let registration_only = registration_only.unwrap_or(false);
        let min_balance = self.storage_balance_bounds().min.0;
        let already_registered = self.accounts.contains_key(&account_id);
        if amount < min_balance && !already_registered {
            env::panic(b"ERR_DEPOSIT_LESS_THAN_MIN_STORAGE");
        }
        if registration_only {
            // Registration only setups the account but doesn't leave space for tokens.
            if already_registered {
                log!("ERR_ACC_REGISTERED");
                if amount > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(amount);
                }
            } else {
                self.internal_register_account(&account_id, min_balance);
                let refund = amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
            }
        } else {
            self.internal_register_account(&account_id, amount);
        }
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let amount = amount.unwrap_or(U128(0)).0;
        let withdraw_amount = self.internal_storage_withdraw(&account_id, amount);
        Promise::new(account_id.clone()).transfer(withdraw_amount);
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(account_deposit) = self.internal_get_account(&account_id) {
            // TODO: figure out force option logic.
            assert!(
                account_deposit.tokens.is_empty(),
                "ERR_STORAGE_UNREGISTER_TOKENS_NOT_EMPTY"
            );
            self.accounts.remove(&account_id);
            Promise::new(account_id.clone()).transfer(account_deposit.near_amount);
            true
        } else {
            false
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: Account::min_storage_usage().into(),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.internal_get_account(account_id.as_ref())
            .map(|account| 
                { 
                    StorageBalance {
                        total: U128(account.near_amount),
                        available: U128(account.storage_available()),
                    } 
                })
    }
}

'''
'''--- src/token_receivers.rs ---
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{serde_json, PromiseOrValue};

use crate::*;

#[near_bindgen]
impl FungibleTokenReceiver for Contract{
    #[allow(unreachable_code)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_in = env::predecessor_account_id();
        assert!(msg.is_empty(),"Msg much empty on deposit action!!");
        self.internal_save_transfer_information(&sender_id.to_string(), &token_in, amount.into());
        PromiseOrValue::Value(U128(0))
    }
}

impl Contract {
    pub fn internal_save_transfer_information(
        &mut self,
        account_id: &AccountId,
        token_id: &AccountId, 
        amount: Balance,
        
    ){
        //   Thực hiện lấy account thông qua method unwrap account id  
        let mut account = self.internal_unwrap_or_default_account(account_id);
        // THực hiện lấy balance trong account thông qua key token_id và unwrap ra 
        let account_amount = account.tokens.get(token_id).unwrap_or_default();
        //Kiểm tra số lượng được truyền vào có lớn hơn 0 hay không và phải lón hơn 0
        assert!(amount > 0 , "Amount must be greater than 0!");
        //Thực hiện xử lí dữ liệu nếu account_amount = 0 thì ta sẽ đưa vào amount
        //nếu account_amount > 0 thì ta lấy account_amount + amount được truyền vào
        if account_amount ==  0 {
            account.tokens.insert(token_id, &amount);
        } else {
            account.tokens.insert(token_id, &(amount + account_amount));
        }
        // Sau khi thực hiện thay đổi và xử lí các dữ liệu từ transfer ta sẽ thực hịện ghi chú
        // dữ liệu vào account contract từ đó có thể ghi chú lại số liệu
        self.internal_save_account(account_id, account);
    }
}

'''