*GitHub Repository "near-hack-magic-powered/nft-social-network-api"*

'''--- .commitlintrc.json ---
{
  "extends": ["@commitlint/config-conventional"]
}

'''
'''--- .env ---
PORT=3000

NEAR_INDEXER_DATABASE_HOST=35.184.214.98
NEAR_INDEXER_DATABASE_PORT=5432
NEAR_INDEXER_DATABASE_NAME=testnet_explorer
NEAR_INDEXER_DATABASE_USERNAME=public_readonly
NEAR_INDEXER_DATABASE_PASSWORD=nearprotocol

NEAR_NETWORK_ID=testnet
NEAR_NODE_URL=https://rpc.testnet.near.org
NEAR_WALLET_URL=https://wallet.testnet.near.org
NEAR_HELPER_URL=https://helper.testnet.near.org
NEAR_EXPLORER_URL=https://explorer.testnet.near.org
NEAR_PROVIDER_URL=https://archival-rpc.testnet.near.org
NEAR_ACCOUNT_ID=vhorin-dev.testnet

NFT_AGGREGATION_INTERVAL=30000

'''
'''--- .eslintrc.js ---
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};

'''
'''--- README.md ---
## Description

...

## Installation

```bash
$ yarn install
```

## Running the app

```bash
# development
$ yarn run start

# watch mode
$ yarn run start:dev

# production mode
$ yarn run start:prod
```

## Test

```bash
# unit tests
$ yarn run test

# e2e tests
$ yarn run test:e2e

# test coverage
$ yarn run test:cov
```

'''
'''--- docker-compose-dev.yml ---
version: '3.1'

services:
  neo4j:
    image: neo4j:latest
    hostname: neo4j
    container_name: neo4j
    ports:
      - 7474:7474
      - 7687:7687
    env_file:
      - .env.docker-dev

  mongo:
    image: mongo
    restart: always
    env_file:
      - .env.docker-dev
    ports:
      - 27017:27017

  mongo-express:
    image: mongo-express
    restart: always
    ports:
      - 8081:8081
    env_file:
      - .env.docker-dev

'''
'''--- docker-compose.yml ---
version: '3.1'

services:
  neo4j:
    image: neo4j:latest
    restart: always
    hostname: neo4j
    container_name: neo4j
    ports:
      - '7687:7687'
    volumes:
    - "/data/neo4j:/data:rw"
    environment:
      NEO4J_AUTH: ${NEO4J_USERNAME}/${NEO4J_PASSWORD}

  mongo:
    image: mongo
    restart: always
    hostname: mongo
    ports:
      - 27017:27017
    volumes:
    - "/data/mongo:/data/db:rw"
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGODB_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGODB_PASSWORD}
      MONGO_INITDB_DATABASE: nft-social-network-api

  api:
    image: ${AWS_ECR_URL}:${DOCKER_ENV_TAG}
    restart: always
    ports:
      - 3000:3000
    environment:
      MONGODB_URI: mongodb://${MONGODB_USERNAME}:${MONGODB_PASSWORD}@mongo/
      MONGO_DATABASE_HOST: mongo
      NEO4J_USERNAME: ${NEO4J_USERNAME}
      NEO4J_PASSWORD: ${NEO4J_PASSWORD}
      NEO4J_HOST: neo4j
      NEO4J_DATABASE: nft-social-network-api
      INSTAGRAM_CLIENT_ID: ${INSTAGRAM_CLIENT_ID}
      INSTAGRAM_CLIENT_SECRET: ${INSTAGRAM_CLIENT_SECRET}
      INSTAGRAM_CALLBACK_URL: ${INSTAGRAM_CALLBACK_URL}
      JWT_SECRET: ${JWT_SECRET}
    env_file:
    - .github/env.common
    - .github/env.${RUNNER_NAME}

  nginx:
    image: linuxserver/swag:1.20.0
    cap_add:
      - NET_ADMIN
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=UTC
      - URL=${DNS_HOST}
      - VALIDATION=http
      - STAGING=false
    ports:
      - 443:443
      - 80:80
    restart: unless-stopped
    volumes:
      - "./docker/linuxserver/default:/config/nginx/site-confs/default"

'''
'''--- nest-cli.json ---
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}

'''
'''--- package.json ---
{
  "name": "nft-social-network-api",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "prepare": "husky install"
  },
  "dependencies": {
    "@commitlint/cli": "^15.0.0",
    "@commitlint/config-conventional": "^15.0.0",
    "@nestjs-hybrid-auth/instagram": "^1.0.0",
    "@nestjs/axios": "^0.0.3",
    "@nestjs/common": "^8.0.0",
    "@nestjs/config": "^1.1.5",
    "@nestjs/core": "^8.0.0",
    "@nestjs/jwt": "^8.0.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/passport": "^8.0.1",
    "@nestjs/platform-express": "^8.0.0",
    "@nestjs/platform-socket.io": "^8.2.4",
    "@nestjs/schedule": "^1.0.2",
    "@nestjs/typeorm": "^8.0.2",
    "@nestjs/websockets": "^8.2.4",
    "@supercharge/promise-pool": "^2.1.0",
    "camelcase-keys": "^7.0.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.13.2",
    "joi": "^17.5.0",
    "mongodb": "^3.7.3",
    "near-api-js": "^0.44.1",
    "neo4j-driver": "^4.4.1",
    "passport": "^0.5.1",
    "passport-jwt": "^4.0.0",
    "pg": "^8.7.1",
    "reflect-metadata": "^0.1.13",
    "rimraf": "^3.0.2",
    "rxjs": "^7.2.0",
    "socket.io": "^4.4.0",
    "tsc-files": "^1.1.3",
    "tweetnacl": "^1.0.3",
    "typeorm": "^0.2.41",
    "typeorm-naming-strategies": "^2.0.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^8.0.0",
    "@nestjs/schematics": "^8.0.0",
    "@nestjs/testing": "^8.0.0",
    "@types/express": "^4.17.13",
    "@types/jest": "27.0.2",
    "@types/node": "^16.0.0",
    "@types/supertest": "^2.0.11",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.1",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "husky": ">=6",
    "jest": "^27.2.5",
    "lint-staged": ">=10",
    "prettier": "^2.3.2",
    "source-map-support": "^0.5.20",
    "supertest": "^6.1.3",
    "ts-jest": "^27.0.3",
    "ts-loader": "^9.2.3",
    "ts-node": "^10.0.0",
    "tsconfig-paths": "^3.10.1",
    "typescript": "^4.3.5"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  },
  "lint-staged": {
    "*.ts": [
      "eslint --color --cache --max-warnings 0 --no-ignore"
    ],
    "**/*.ts": "tsc-files --noEmit",
    "*.{ts,json,md}": [
      "prettier --write"
    ]
  }
}

'''
'''--- src/app.controller.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

'''
'''--- src/app.controller.ts ---
import { Controller } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
}

'''
'''--- src/app.module.ts ---
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { configuration, ConfigValidationSchema } from './config';
import { Neo4jConfig } from './neo4j/neo4j-config.interface';
import { Neo4jModule } from './neo4j/neo4j.module';
import { InstagramAuthModule } from '@nestjs-hybrid-auth/instagram';

import { AuthModule } from './auth/auth.module';
import { NearIndexerModule } from './near-indexer/near-indexer.module';
import { NearApiModule } from './near-api/near-api.module';
import { NftModule } from './nft/nft.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TypeOrmConfigService } from './config/typeorm-config.service';
import { UserModule } from './user/user.module';
import { CommentsModule } from './comments/comments.module';
import { EventModule } from './event/event.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: configuration,
      validationSchema: ConfigValidationSchema,
      envFilePath: ['.env.local', '.env'],
    }),
    TypeOrmModule.forRootAsync({
      useClass: TypeOrmConfigService,
    }),
    Neo4jModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService): Neo4jConfig => ({
        scheme: configService.get('neo4j.scheme'),
        host: configService.get('neo4j.host'),
        port: configService.get('neo4j.port'),
        username: configService.get('neo4j.username'),
        password: configService.get('neo4j.password'),
        database: configService.get('neo4j.database'),
      }),
    }),
    InstagramAuthModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        clientID: configService.get('instagram.clientID'),
        clientSecret: configService.get('instagram.clientSecret'),
        callbackURL: configService.get('instagram.callbackURL'),
      }),
    }),
    NearIndexerModule,
    NearApiModule,
    AuthModule,
    NftModule,
    UserModule,
    CommentsModule,
    EventModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

'''
'''--- src/app.service.ts ---
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

'''
'''--- src/auth/auth.controller.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

'''
'''--- src/auth/auth.controller.ts ---
import {
  Body,
  Controller,
  Get,
  Post,
  Request,
  UseGuards,
} from '@nestjs/common';
import {
  InstagramAuthResult,
  UseInstagramAuth,
} from '@nestjs-hybrid-auth/instagram';

import { AuthService } from './auth.service';
import { ConfigService } from '@nestjs/config';
import { JwtAuthGuard } from './guards/jwt-auth.quard';
import { AccountAccessGuard } from './guards/account.guard';
import { ConnectWalletDto } from './dto/connect-wallet.dto';

@Controller('auth')
export class AuthController {
  constructor(
    private readonly configService: ConfigService,
    private readonly authService: AuthService,
  ) {}

  @UseGuards(AccountAccessGuard)
  @Post('near/login')
  async loginWithNear(@Body() body: ConnectWalletDto): Promise<string> {
    return this.authService.loginWithNearWallet(body.accountId);
  }

  @UseGuards(AccountAccessGuard, JwtAuthGuard)
  @Post('near/connect-wallet')
  async connectNearWallet(
    @Request() req,
    @Body() body: ConnectWalletDto,
  ): Promise<boolean> {
    return this.authService.connectNearWallet(req.user.userId, body.accountId);
  }

  @UseInstagramAuth()
  @Get('instagram')
  loginWithInstagram() {
    return 'Login with Instagram';
  }

  @UseInstagramAuth()
  @Get('instagram/callback')
  instagramCallback(@Request() req): Partial<InstagramAuthResult> {
    const result: InstagramAuthResult = req.hybridAuthResult;

    // TODO: save to database and link with near account
    return {
      accessToken: result.accessToken,
      refreshToken: result.refreshToken,
      profile: result.profile,
    };
  }
}

'''
'''--- src/auth/auth.module.ts ---
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { JwtModule } from '@nestjs/jwt';

import { UserModule } from 'src/user/user.module';
import { NearApiModule } from 'src/near-api/near-api.module';
import { NftModule } from 'src/nft/nft.module';

import { JwtAuthStrategy } from './strategies/jwt-auth.strategy';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';

@Module({
  imports: [
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const { jwtSecret } = configService.get('app');
        return {
          secret: jwtSecret,
        };
      },
      inject: [ConfigService],
    }),
    UserModule,
    NearApiModule,
    NftModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtAuthStrategy],
  exports: [AuthService],
})
export class AuthModule {}

'''
'''--- src/auth/auth.service.ts ---
import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

import { UserService } from 'src/user/user.service';
import { NftService } from 'src/nft/nft.service';
import { NearApiService } from 'src/near-api/near-api.service';
import { User } from 'src/user/entities/user.entity';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly nftService: NftService,
    private readonly nearApiService: NearApiService,
    private readonly jwtService: JwtService,
  ) {}

  async loginWithNearWallet(accountId: string): Promise<string> {
    let user = await this.userService.findByNearAccount(accountId);

    if (!user) {
      user = await this.userService.create({
        nearAccounts: [{ accountId, enabled: true }],
      });
      await this.nftService.loadAllAccountNfts(accountId);
    }

    return this.generateJwt(user);
  }

  async connectNearWallet(userId: string, accountId: string) {
    const user = await this.userService.findByNearAccount(accountId);

    if (!user) {
      await this.userService.addNearAccount(userId, {
        accountId,
        enabled: true,
      });
      await this.nftService.loadAllAccountNfts(accountId);
    }

    return true;
  }

  private generateJwt(user: User): string {
    return this.jwtService.sign({ userId: user.id });
  }
}

'''
'''--- src/auth/dto/connect-wallet.dto.ts ---
export interface ConnectWalletDto {
  accountId: string;
  publicKey: string;
  signature: string;
}

'''
'''--- src/auth/guards/account.guard.ts ---
import {
  CanActivate,
  ExecutionContext,
  ForbiddenException,
  Injectable,
} from '@nestjs/common';
import { PublicKey } from 'near-api-js/lib/utils';

import { NearApiService } from 'src/near-api/near-api.service';

@Injectable()
export class AccountAccessGuard implements CanActivate {
  constructor(private nearApiService: NearApiService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const req = context.switchToHttp().getRequest();
    const { accountId, publicKey, signature } = req.body;

    const account = await this.nearApiService.getAccount(accountId);

    let accessKeys;
    try {
      accessKeys = await account.getAccessKeys();
    } catch (err) {
      throw new ForbiddenException(`Authorization header is invalid`);
    }

    if (!accessKeys.find((key) => key.public_key === publicKey)) {
      throw new ForbiddenException(
        `Account ${accountId} identity is invalid - public key`,
      );
    }

    let isValid = true;
    try {
      isValid = PublicKey.fromString(publicKey).verify(
        Buffer.from(publicKey),
        Buffer.from(signature, 'base64'),
      );
    } catch (error) {
      throw new ForbiddenException('Invalid signature');
    }

    if (!isValid) {
      throw new ForbiddenException('Invalid signature');
    }

    req.near = { accountId };

    return isValid;
  }
}

'''
'''--- src/auth/guards/jwt-auth.quard.ts ---
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

'''
'''--- src/auth/strategies/jwt-auth.strategy.ts ---
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtAuthStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: true,
      secretOrKey: configService.get('app').jwtSecret,
    });
  }

  async validate(payload) {
    return payload;
  }
}

'''
'''--- src/comments/comments.controller.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { CommentsController } from './comments.controller';
import { CommentsService } from './comments.service';

describe('CommentsController', () => {
  let controller: CommentsController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CommentsController],
      providers: [CommentsService],
    }).compile();

    controller = module.get<CommentsController>(CommentsController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

'''
'''--- src/comments/comments.controller.ts ---
import {
  Controller,
  Request,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
} from '@nestjs/common';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.quard';
import { CommentsService } from './comments.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';
import { PaginationCommentRequest } from './interfaces/pagination-comment-request.interface';

@Controller('comments')
export class CommentsController {
  constructor(private readonly commentsService: CommentsService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  async create(@Request() req, @Body() createCommentDto: CreateCommentDto) {
    return this.commentsService.create(req.body.userId, createCommentDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get()
  findAll(@Query() query: PaginationCommentRequest) {
    return this.commentsService.findAll(query);
  }

  @UseGuards(JwtAuthGuard)
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.commentsService.findOne(id);
  }

  @UseGuards(JwtAuthGuard)
  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCommentDto: UpdateCommentDto) {
    return this.commentsService.update(id, updateCommentDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete(':id')
  delete(@Param('id') id: string) {
    return this.commentsService.delete(id);
  }
}

'''
'''--- src/comments/comments.module.ts ---
import { Module } from '@nestjs/common';
import { CommentsService } from './comments.service';
import { CommentsController } from './comments.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Comment } from './entities/comment.entity';
import { EventModule } from 'src/event/event.module';

@Module({
  imports: [TypeOrmModule.forFeature([Comment]), EventModule],
  controllers: [CommentsController],
  providers: [CommentsService],
})
export class CommentsModule {}

'''
'''--- src/comments/comments.service.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { CommentsService } from './comments.service';

describe('CommentsService', () => {
  let service: CommentsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CommentsService],
    }).compile();

    service = module.get<CommentsService>(CommentsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

'''
'''--- src/comments/comments.service.ts ---
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { PaginationResponse } from 'src/common/pagination.interface';
import { EventService } from 'src/event/event.service';
import { Neo4jService } from 'src/neo4j/neo4j.service';
import { MongoRepository, UpdateResult } from 'typeorm';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';
import { Comment } from './entities/comment.entity';
import { PaginationCommentRequest } from './interfaces/pagination-comment-request.interface';

@Injectable()
export class CommentsService {
  constructor(
    @InjectRepository(Comment)
    private commentRepository: MongoRepository<Comment>,
    private readonly neo4jService: Neo4jService,
    private readonly eventService: EventService,
  ) {}

  async create(userId: string, createCommentDto: CreateCommentDto) {
    const comment = new Comment();
    comment.text = createCommentDto.text;
    comment.parentId = createCommentDto.parentId;
    comment.nftId = createCommentDto.nftId;
    comment.userId = userId;

    const createdComment = await this.commentRepository.save(comment);

    try {
      const result = await this.neo4jService.write(
        `CREATE p = (u:User {id: $userId})-[:COMMENTED]->(c:Comment {id: $commentId}) RETURN p`,
        { userId, commentId: createdComment.id },
      );
      console.log('result: ', result);
    } catch (err) {
      console.error(err);
    }

    this.eventService.emit('create-comment', createdComment);

    return createdComment;
  }

  async findAll({
    userId,
    nftId,
    offset,
    limit,
  }: PaginationCommentRequest): Promise<PaginationResponse<Comment>> {
    const data = await this.commentRepository
      .aggregate([
        { $addFields: { userObjectId: { $toObjectId: '$userId' } } },
        {
          $lookup: {
            from: 'user',
            localField: 'userObjectId',
            foreignField: '_id',
            as: 'user',
          },
        },
        { $match: { userId, nftId } },
      ])
      .skip(Number(offset))
      .limit(Number(limit))
      .toArray();

    const total = await this.commentRepository.count({ userId, nftId });

    return {
      offset,
      limit,
      total,
      data,
    };
  }

  findOne(id: string) {
    return this.commentRepository.findOne(id);
  }

  async update(
    id: string,
    updateCommentDto: UpdateCommentDto,
  ): Promise<UpdateResult> {
    const updatedComment = await this.commentRepository.update(
      id,
      updateCommentDto,
    );

    this.eventService.emit('update-comment', updatedComment);

    return updatedComment;
  }

  async delete(id: string) {
    return this.commentRepository.delete(id);
  }
}

'''
'''--- src/comments/dto/create-comment.dto.ts ---
import { IsString, IsNotEmpty, IsOptional } from 'class-validator';

export class CreateCommentDto {
  @IsNotEmpty()
  @IsString()
  nftId: string;

  @IsOptional()
  @IsString()
  parentId?: string;

  @IsNotEmpty()
  @IsString()
  text: string;
}

'''
'''--- src/comments/dto/update-comment.dto.ts ---
import { IsNotEmpty, IsString } from 'class-validator';

export class UpdateCommentDto {
  @IsNotEmpty()
  @IsString()
  text: string;
}

'''
'''--- src/comments/entities/comment.entity.ts ---
import { BaseEntity } from 'src/common/base.entity';
import { Entity, Column } from 'typeorm';

@Entity()
export class Comment extends BaseEntity {
  @Column()
  text: string;

  @Column()
  parentId: string;

  @Column()
  userId: string;

  @Column()
  nftId: string;
}

'''
'''--- src/comments/interfaces/pagination-comment-request.interface.ts ---
import { PaginationRequest } from 'src/common/pagination.interface';

export interface PaginationCommentRequest extends PaginationRequest {
  userId?: string;
  nftId?: string;
}

'''
'''--- src/common/base.entity.ts ---
import { Exclude } from 'class-transformer';
import {
  CreateDateColumn,
  UpdateDateColumn,
  Column,
  ObjectIdColumn,
  ObjectID,
} from 'typeorm';

export abstract class BaseEntity {
  @ObjectIdColumn({ unique: true })
  id: ObjectID;

  @Exclude()
  @Column({ type: 'boolean', default: false })
  isArchived: boolean;

  @CreateDateColumn({
    type: 'timestamptz',
    default: () => 'CURRENT_TIMESTAMP',
  })
  createdAt: Date;

  @Exclude()
  @UpdateDateColumn({
    type: 'timestamptz',
    default: () => 'CURRENT_TIMESTAMP',
  })
  updatedAt: Date;
}

'''
'''--- src/common/constants.ts ---
export const FIRST_NFT_EVENT_TIMESTAMP = '1636002073366363339';

'''
'''--- src/common/dto/PagingQuery.ts ---
import { IsNumber } from 'class-validator';
import { SortDirection } from './SortParam';

export class PagingQuery {
  @IsNumber()
  offset = 0;

  @IsNumber()
  limit = 50;

  order: SortDirection;
}

'''
'''--- src/common/dto/SearchQuery.ts ---
import { IsNotEmpty } from 'class-validator';
import { PagingQuery } from './PagingQuery';

export class SearchQuery extends PagingQuery {
  @IsNotEmpty()
  query: string;
}

'''
'''--- src/common/dto/SortParam.ts ---
export enum SortDirection {
  // Ascending
  ASC = 'ASC',
  // Descending
  DESC = 'DESC',
}

'''
'''--- src/common/pagination.interface.ts ---
export interface PaginationRequest {
  offset: number;
  limit: number;
}

export interface PaginationResponse<T> {
  offset: number;
  limit: number;
  total: number;
  data: T[];
}

'''
'''--- src/common/search.interface.ts ---
import { PaginationRequest } from './pagination.interface';

export interface SearchRequest extends PaginationRequest {
  search: string;
}

'''
'''--- src/config/app.ts ---
import { registerAs } from '@nestjs/config';

export const app = registerAs('app', () => {
  return {
    port: parseInt(process.env.PORT, 10),
    frontendUrl: process.env.FRONTEND_URL,
    jwtSecret: process.env.JWT_SECRET,
    nftAggregationInterval: parseInt(process.env.NFT_AGGREGATION_INTERVAL, 10),
  };
});

'''
'''--- src/config/database-mongo.ts ---
import { registerAs } from '@nestjs/config';
import { TypeOrmModuleOptions } from '@nestjs/typeorm';

import { Comment } from 'src/comments/entities/comment.entity';
import { Nft } from 'src/nft/entities/nft.entity';
import { NftContract } from 'src/nft/entities/nft-contract.entity';
import { NftEvent } from 'src/nft/entities/nft-event.enity';
import { User } from 'src/user/entities/user.entity';

export const databaseMongo = registerAs(
  `database-mongo`,
  (): TypeOrmModuleOptions => ({
    type: 'mongodb',
    url: process.env.MONGODB_URI,
    entities: [Comment, User, Nft, NftContract, NftEvent],
    synchronize: false,
  }),
);

'''
'''--- src/config/database-near-indexer.ts ---
import { registerAs } from '@nestjs/config';
import { SnakeNamingStrategy } from 'typeorm-naming-strategies';

import { Account } from 'src/near-indexer/entities/account.entity';
import { Receipt } from 'src/near-indexer/entities/receipt.entity';
import { ReceiptAction } from 'src/near-indexer/entities/receipt-action.entity';
import { Transaction } from 'src/near-indexer/entities/transaction.entity';
import { TransactionAction } from 'src/near-indexer/entities/transaction-action.entity';
import { ActionReceiptAction } from 'src/near-indexer/entities/action-receipt-action.entity';
import { AccountChange } from 'src/near-indexer/entities/account-change.entity';
import { AssetsNftEvent } from 'src/near-indexer/entities/assets-nft-event.entity';

export const databaseNearIndexer = registerAs(`database-near-indexer`, () => ({
  type: 'postgres',
  host: process.env.NEAR_INDEXER_DATABASE_HOST,
  port: parseInt(process.env.NEAR_INDEXER_DATABASE_PORT, 10),
  database: process.env.NEAR_INDEXER_DATABASE_NAME,
  username: process.env.NEAR_INDEXER_DATABASE_USERNAME,
  password: process.env.NEAR_INDEXER_DATABASE_PASSWORD,
  entities: [
    Account,
    Receipt,
    ReceiptAction,
    Transaction,
    TransactionAction,
    ActionReceiptAction,
    AccountChange,
    AssetsNftEvent,
  ],
  synchronize: false,
  namingStrategy: new SnakeNamingStrategy(),
}));

'''
'''--- src/config/index.ts ---
import { app } from './app';
import { instagram } from './instagram';
import { mongo } from './mongo';
import { databaseNearIndexer } from './database-near-indexer';
import { neo4j } from './neo4j';
import { near } from './near';
import { databaseMongo } from './database-mongo';

export { ConfigValidationSchema } from './validation/schema';

export const configuration = [
  app,
  mongo,
  databaseNearIndexer,
  databaseMongo,
  neo4j,
  near,
  instagram,
];

'''
'''--- src/config/instagram.ts ---
import { registerAs } from '@nestjs/config';

export const instagram = registerAs('instagram', () => {
  return {
    clientID: process.env.INSTAGRAM_CLIENT_ID,
    clientSecret: process.env.INSTAGRAM_CLIENT_SECRET,
    callbackURL: process.env.INSTAGRAM_CALLBACK_URL,
  };
});

'''
'''--- src/config/mongo.ts ---
import { registerAs } from '@nestjs/config';

export const mongo = registerAs('mongo', () => {
  return {
    uri: process.env.MONGODB_URI,
  };
});

'''
'''--- src/config/near.ts ---
import { registerAs } from '@nestjs/config';

export const near = registerAs('near', () => {
  return {
    networkId: process.env.NEAR_NETWORK_ID,
    nodeUrl: process.env.NEAR_NODE_URL,
    walletUrl: process.env.NEAR_WALLET_URL,
    helperUrl: process.env.NEAR_HELPER_URL,
    explorerUrl: process.env.NEAR_EXPLORER_URL,
    providerUrl: process.env.NEAR_PROVIDER_URL,
    accountId: process.env.NEAR_ACCOUNT_ID,
    nearCredentialsDir: process.env.NEAR_CREDENTIALS_DIR || '.near-credentials',
  };
});

'''
'''--- src/config/neo4j.ts ---
import { registerAs } from '@nestjs/config';

export const neo4j = registerAs('neo4j', () => {
  return {
    scheme: process.env.NEO4J_SCHEME,
    host: process.env.NEO4J_HOST,
    port: process.env.NEO4J_PORT,
    username: process.env.NEO4J_USERNAME,
    password: process.env.NEO4J_PASSWORD,
    database: process.env.NEO4J_DATABASE,
  };
});

'''
'''--- src/config/typeorm-config.service.ts ---
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { TypeOrmOptionsFactory, TypeOrmModuleOptions } from '@nestjs/typeorm';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  constructor(private readonly configService: ConfigService) {}
  createTypeOrmOptions(name = 'database-mongo'): TypeOrmModuleOptions {
    const {
      type,
      host,
      port,
      username,
      password,
      database,
      entities,
      synchronize,
      migrationsTableName,
      migrations,
      cli,
      url,
      namingStrategy,
    } = this.configService.get(name);

    return {
      name,
      type,
      host,
      port,
      username,
      password,
      database,
      entities,
      synchronize,
      migrationsTableName,
      migrations,
      cli,
      url,
      namingStrategy,
    };
  }
}

'''
'''--- src/config/validation/schema.ts ---
import * as Joi from 'joi';

export const ConfigValidationSchema = Joi.object({
  NODE_ENV: Joi.string()
    .valid('development', 'production', 'test')
    .default('development'),
  PORT: Joi.number().default(3000),
  JWT_SECRET: Joi.string().required(),

  MONGODB_URI: Joi.string().required(),
  NEAR_INDEXER_DATABASE_HOST: Joi.string().required(),
  NEAR_INDEXER_DATABASE_PORT: Joi.number().required(),
  NEAR_INDEXER_DATABASE_NAME: Joi.string().required(),
  NEAR_INDEXER_DATABASE_USERNAME: Joi.string().required(),
  NEAR_INDEXER_DATABASE_PASSWORD: Joi.string().required(),

  NEAR_NETWORK_ID: Joi.string().required(),
  NEAR_NODE_URL: Joi.string().required(),
  NEAR_WALLET_URL: Joi.string().required(),
  NEAR_HELPER_URL: Joi.string().required(),
  NEAR_EXPLORER_URL: Joi.string().required(),
  NEAR_PROVIDER_URL: Joi.string().required(),

  NEO4J_SCHEME: Joi.string().default('neo4j'),
  NEO4J_HOST: Joi.string().required(),
  NEO4J_PORT: Joi.number().default(7687),
  NEO4J_USERNAME: Joi.string().required(),
  NEO4J_PASSWORD: Joi.string().required(),
  NEO4J_DATABASE: Joi.string(),

  INSTAGRAM_CLIENT_ID: Joi.string().required(),
  INSTAGRAM_CLIENT_SECRET: Joi.string().required(),
  INSTAGRAM_CALLBACK_URL: Joi.string().required(),

  NFT_AGGREGATION_INTERVAL: Joi.number().default(30000),
});

'''
'''--- src/event/event.gateway.ts ---
import {
  WebSocketGateway,
  OnGatewayInit,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Logger } from '@nestjs/common';
import { Socket, Server } from 'socket.io';

@WebSocketGateway()
export class EventGateway
  implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer() server: Server;

  private logger: Logger = new Logger('EventGateway');

  afterInit() {
    this.logger.log('Init');
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }
}

'''
'''--- src/event/event.module.ts ---
import { Module } from '@nestjs/common';
import { EventGateway } from './event.gateway';
import { EventService } from './event.service';

@Module({
  providers: [EventGateway, EventService],
  exports: [EventGateway, EventService],
})
export class EventModule {}

'''
'''--- src/event/event.service.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { EventService } from './event.service';

describe('EventService', () => {
  let service: EventService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [EventService],
    }).compile();

    service = module.get<EventService>(EventService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

'''
'''--- src/event/event.service.ts ---
import { Injectable } from '@nestjs/common';
import { EventGateway } from './event.gateway';

@Injectable()
export class EventService {
  constructor(private readonly eventGateway: EventGateway) {}

  emit(event: string, message: any) {
    this.eventGateway.server.emit(event, message);
  }
}

'''
'''--- src/main.ts ---
import { Logger, ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Neo4jErrorFilter } from './neo4j/neo4j-error.filter';

async function bootstrap() {
  const logger = new Logger('App');

  const app = await NestFactory.create(AppModule);

  const configService = app.get(ConfigService);

  const { port } = configService.get('app');

  app.useGlobalPipes(new ValidationPipe());
  // Commented due to error with undefined Result,Node, Relationship, in neo4j-driver module
  // app.useGlobalInterceptors(new Neo4jTypeInterceptor());
  app.useGlobalFilters(new Neo4jErrorFilter());
  app.enableCors();

  await app.listen(port, () => logger.log('API Service is listening...'));
}
bootstrap();

'''
'''--- src/near-api/near-api.module.ts ---
import { Module } from '@nestjs/common';

import { NearApiService } from './near-api.service';
import { nearApiProvider } from './near-api.provider';

@Module({
  imports: [],
  providers: [nearApiProvider, NearApiService],
  exports: [nearApiProvider, NearApiService],
})
export class NearApiModule {}

'''
'''--- src/near-api/near-api.provider.ts ---
import { ConfigService } from '@nestjs/config';
import { Account, connect, Near, providers } from 'near-api-js';
import { UnencryptedFileSystemKeyStore } from 'near-api-js/lib/key_stores';
import { Provider } from 'near-api-js/lib/providers';
import { join } from 'path';
import { homedir } from 'os';

export type NearApiProvider = {
  provider: Provider;
  near: Near;
  account: Account;
};

export const nearApiProvider = {
  provide: 'near-api-provider',
  inject: [ConfigService],
  useFactory: async (
    configService: ConfigService,
  ): Promise<NearApiProvider> => {
    const {
      networkId,
      nodeUrl,
      accountId,
      walletUrl,
      helperUrl,
      providerUrl,
      nearCredentialsDir,
    } = configService.get('near');

    const near = await connect({
      keyStore: new UnencryptedFileSystemKeyStore(
        join(homedir(), nearCredentialsDir),
      ),
      networkId,
      nodeUrl,
      walletUrl,
      helperUrl,
      headers: {},
    });
    const account = await near.account(accountId);
    const provider = new providers.JsonRpcProvider({ url: providerUrl });

    return {
      near,
      provider,
      account,
    };
  },
};

'''
'''--- src/near-api/near-api.service.ts ---
import { Inject, Injectable } from '@nestjs/common';
import { Account, Contract } from 'near-api-js';

import { NearApiProvider } from './near-api.provider';

@Injectable()
export class NearApiService {
  constructor(
    @Inject('near-api-provider')
    private nearApiProvider: NearApiProvider,
  ) {}

  async getAccount(accountId: string): Promise<Account> {
    return this.nearApiProvider.near.account(accountId);
  }

  async getNftMetadata(contractId: string) {
    const contract = this.getNftContract(contractId);
    return contract.nft_metadata();
  }

  async getAccountNfts(contractId: string, accountId: string) {
    const contract = this.getNftContract(contractId);
    const chunkSize = 100;
    let nfts = [];
    let chunk = [];
    let fromIndex = 0;

    do {
      try {
        chunk = await contract.nft_tokens_for_owner({
          account_id: accountId,
          from_index: fromIndex.toString(),
          limit: chunkSize,
        });
        fromIndex += chunkSize;
        nfts = nfts.concat(chunk);
      } catch (err) {
        break;
      }
    } while (chunk.length === chunkSize);

    return nfts;
  }

  private getNftContract(contractId: string): Contract & any {
    return new Contract(this.nearApiProvider.account, contractId, {
      viewMethods: ['nft_tokens_for_owner', 'nft_metadata'],
      changeMethods: [],
    });
  }
}

'''
'''--- src/near-indexer/entities/account-change.entity.ts ---
import { Column, Entity, JoinColumn, OneToOne, PrimaryColumn } from 'typeorm';
import { Receipt } from './receipt.entity';

@Entity({ name: 'account_changes' })
export class AccountChange {
  @PrimaryColumn()
  id: string;

  @Column()
  affectedAccountId: string;

  @Column({ nullable: true })
  causedByTransactionHash: string;

  @Column({ type: 'bigint' })
  changedInBlockTimestamp: number;

  @OneToOne(() => Receipt, { cascade: true })
  @JoinColumn({ name: 'caused_by_receipt_id' })
  causedByReceipt: Receipt;
}

'''
'''--- src/near-indexer/entities/account.entity.ts ---
import { Column, Entity, JoinColumn, OneToOne, PrimaryColumn } from 'typeorm';

import { Receipt } from './receipt.entity';

@Entity({ name: 'accounts' })
export class Account {
  @PrimaryColumn()
  id: number;

  @Column()
  accountId: string;

  @Column()
  createdByReceiptId: string;

  @OneToOne(() => Receipt)
  @JoinColumn({ name: 'created_by_receipt_id' })
  receipt: Receipt;

  @Column()
  deletedByReceiptId: string;

  @Column()
  lastUpdateBlockHeight: number;
}

'''
'''--- src/near-indexer/entities/action-receipt-action.entity.ts ---
import { Column, Entity, JoinColumn, OneToOne, PrimaryColumn } from 'typeorm';

import { Transaction } from './transaction.entity';
import { ActionKind } from '../types/action-kind';

@Entity({ name: 'action_receipt_actions' })
export class ActionReceiptAction {
  @PrimaryColumn()
  receiptId: string;

  @PrimaryColumn()
  indexInActionReceipt: number;

  @OneToOne(() => Transaction)
  @JoinColumn({
    name: 'receipt_id',
    referencedColumnName: 'convertedIntoReceiptId',
  })
  transaction: Transaction;

  @Column()
  receiptPredecessorAccountId: string;

  @Column()
  receiptReceiverAccountId: string;

  @Column({
    type: 'enum',
    enum: ActionKind,
  })
  actionKind: string;

  @Column({ type: 'simple-json' })
  args: Record<string, unknown>;
}

'''
'''--- src/near-indexer/entities/assets-nft-event.entity.ts ---
import { Entity, PrimaryColumn } from 'typeorm';
import { NftEventKind } from '../types/nft-event-kind';

@Entity({ name: 'assets__non_fungible_token_events' })
export class AssetsNftEvent {
  @PrimaryColumn()
  emittedForReceiptId: string;

  @PrimaryColumn({ type: 'bigint' })
  emittedAtBlockTimestamp: number;

  @PrimaryColumn({ type: 'bigint' })
  emittedInShardId: number;

  @PrimaryColumn()
  emittedIndexOfEventEntryInShard: number;

  @PrimaryColumn()
  emittedByContractAccountId: string;

  @PrimaryColumn()
  tokenId: string;

  @PrimaryColumn({
    type: 'enum',
    enum: NftEventKind,
  })
  eventKind: string;

  @PrimaryColumn()
  tokenOldOwnerAccountId: string;

  @PrimaryColumn()
  tokenNewOwnerAccountId: string;

  @PrimaryColumn()
  tokenAuthorizedAccountId: string;

  @PrimaryColumn()
  eventMemo: string;
}

'''
'''--- src/near-indexer/entities/receipt-action.entity.ts ---
import { Column, Entity, JoinColumn, ManyToOne, PrimaryColumn } from 'typeorm';

import { ActionKind } from '../types/action-kind';
import { Receipt } from './receipt.entity';

@Entity({ name: 'action_receipt_actions' })
export class ReceiptAction {
  @PrimaryColumn()
  receiptId: string;

  @PrimaryColumn()
  indexInActionReceipt: number;

  @ManyToOne(() => Receipt, (receipt) => receipt.receiptActions, {
    nullable: true,
    createForeignKeyConstraints: false,
  })
  @JoinColumn({ name: 'receipt_id' })
  receipt: Receipt;

  @Column()
  receiptPredecessorAccountId: string;

  @Column()
  receiptReceiverAccountId: string;

  @Column({
    type: 'enum',
    enum: ActionKind,
  })
  actionKind: string;

  @Column({ type: 'simple-json' })
  args: Record<string, unknown>;
}

'''
'''--- src/near-indexer/entities/receipt.entity.ts ---
import {
  Column,
  Entity,
  JoinColumn,
  ManyToOne,
  OneToMany,
  PrimaryColumn,
} from 'typeorm';

import { ReceiptAction } from './receipt-action.entity';
import { Transaction } from './transaction.entity';

@Entity({ name: 'receipts' })
export class Receipt {
  @PrimaryColumn()
  receiptId: string;

  @Column()
  predecessorAccountId: string;

  @Column()
  receiverAccountId: string;

  @Column()
  originatedFromTransactionHash: string;

  @ManyToOne(() => Transaction, (transaction) => transaction.receipts)
  @JoinColumn({ name: 'originated_from_transaction_hash' })
  originatedFromTransaction: Transaction;

  @Column({ type: 'bigint' })
  includedInBlockTimestamp: number;

  @OneToMany(() => ReceiptAction, (receiptAction) => receiptAction.receipt, {
    cascade: true,
    nullable: true,
  })
  @JoinColumn({ name: 'receipt_id' })
  receiptActions: ReceiptAction[];
}

'''
'''--- src/near-indexer/entities/transaction-action.entity.ts ---
import { BaseEntity, Column, Entity, PrimaryColumn } from 'typeorm';

import { ActionKind } from '../types/action-kind';

@Entity({ name: 'transaction_actions' })
export class TransactionAction extends BaseEntity {
  @PrimaryColumn()
  transactionHash: string;

  @Column()
  indexInTransaction: number;

  @Column({
    type: 'enum',
    enum: ActionKind,
  })
  actionKind: string;

  @Column({ type: 'jsonb', nullable: true })
  args: Record<string, unknown>;
}

'''
'''--- src/near-indexer/entities/transaction.entity.ts ---
import {
  Column,
  Entity,
  JoinColumn,
  OneToMany,
  OneToOne,
  PrimaryColumn,
} from 'typeorm';

import { ExecutionOutcomeStatus } from '../types/execution-outcome-status';
import { Receipt } from './receipt.entity';
import { TransactionAction } from './transaction-action.entity';

@Entity({ name: 'transactions' })
export class Transaction {
  @PrimaryColumn()
  transactionHash: string;

  @Column()
  includedInBlockHash: string;

  @Column()
  includedInChunkHash: string;

  @Column()
  indexInChunk: number;

  @OneToOne(() => TransactionAction, { cascade: true })
  @JoinColumn({ name: 'transaction_hash' })
  transactionAction: TransactionAction;

  @OneToMany(() => Receipt, (receipt) => receipt.originatedFromTransaction, {
    cascade: true,
  })
  receipts: Receipt[];

  @Column()
  receiverAccountId: string;

  @Column()
  signerAccountId: string;

  @Column()
  signerPublicKey: string;

  @Column({ type: 'bigint' })
  nonce: number;

  @Column()
  signature: string;

  @Column({
    type: 'enum',
    enum: ExecutionOutcomeStatus,
  })
  status: string;

  @Column()
  convertedIntoReceiptId: string;

  @Column()
  receiptConversionGasBurnt: string;

  @Column()
  receiptConversionTokensBurnt: string;

  @Column({ type: 'bigint' })
  blockTimestamp: number;
}

'''
'''--- src/near-indexer/near-indexer.module.ts ---
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

import { TypeOrmConfigService } from 'src/config/typeorm-config.service';

import { NearIndexerService } from './near-indexer.service';
import { Account } from './entities/account.entity';
import { Receipt } from './entities/receipt.entity';
import { Transaction } from './entities/transaction.entity';
import { TransactionAction } from './entities/transaction-action.entity';
import { ActionReceiptAction } from './entities/action-receipt-action.entity';
import { ReceiptAction } from './entities/receipt-action.entity';
import { AccountChange } from './entities/account-change.entity';
import { AssetsNftEvent } from './entities/assets-nft-event.entity';

@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      name: 'database-near-indexer',
      useClass: TypeOrmConfigService,
    }),
    TypeOrmModule.forFeature(
      [
        Account,
        Receipt,
        Transaction,
        TransactionAction,
        ActionReceiptAction,
        ReceiptAction,
        AccountChange,
        AssetsNftEvent,
      ],
      'database-near-indexer',
    ),
  ],
  providers: [NearIndexerService],
  exports: [NearIndexerService],
})
export class NearIndexerModule {}

'''
'''--- src/near-indexer/near-indexer.service.ts ---
import { Injectable } from '@nestjs/common';
import { InjectConnection, InjectRepository } from '@nestjs/typeorm';
import { Connection, Repository } from 'typeorm';

import { AssetsNftEvent } from './entities/assets-nft-event.entity';

@Injectable()
export class NearIndexerService {
  constructor(
    @InjectRepository(AssetsNftEvent, 'database-near-indexer')
    private readonly assetsNftEventRepository: Repository<AssetsNftEvent>,

    @InjectConnection('database-near-indexer')
    private connection: Connection,
  ) {}

  findLastNftEvents(
    fromBlockTimestamp: string,
    limit: number,
  ): Promise<AssetsNftEvent[]> {
    return this.assetsNftEventRepository
      .createQueryBuilder('event')
      .where('event.emitted_at_block_timestamp > :from', {
        from: fromBlockTimestamp,
      })
      .orderBy('event.emitted_at_block_timestamp', 'ASC')
      .limit(limit)
      .getMany();
  }

  findNftEventsByAccountId(
    accountId: string,
    fromBlockTimestamp?: number,
  ): Promise<AssetsNftEvent[]> {
    const queryBuilder = this.assetsNftEventRepository
      .createQueryBuilder('event')
      .where('event.token_new_owner_account_id = :accountId', {
        accountId,
      });

    if (fromBlockTimestamp) {
      queryBuilder.andWhere('event.emitted_at_block_timestamp >= :from', {
        from: fromBlockTimestamp,
      });
    }

    return queryBuilder.getMany();
  }

  async findLikelyNFTs(accountId: string): Promise<string[]> {
    const received = `
        select distinct receipt_receiver_account_id as receiver_account_id
        from action_receipt_actions
        where action_kind = 'FUNCTION_CALL'
            and args->>'args_json' is not null
            and args->'args_json'->>'receiver_id' = $1
            and args->>'method_name' like 'nft_%'
    `;
    const batched = `
        select distinct receipt_receiver_account_id as receiver_account_id
        from action_receipt_actions
        where action_kind = 'FUNCTION_CALL'
            and args->>'args_json' is not null
            and args->>'method_name' = 'nft_batch_mint'
            and args->'args_json'->>'owner_id' = $1
    `;
    const events = `
        select distinct emitted_by_contract_account_id as receiver_account_id
        from assets__non_fungible_token_events
        where token_new_owner_account_id = $1
    `;

    const receivedTokens = await this.connection.query(received, [accountId]);
    const batchedTokens = await this.connection.query(batched, [accountId]);
    const eventTokens = await this.connection.query(events, [accountId]);

    return [
      ...new Set(
        [...receivedTokens, ...batchedTokens, ...eventTokens].map(
          ({ receiver_account_id }) => receiver_account_id,
        ),
      ),
    ];
  }
}

'''
'''--- src/near-indexer/types/action-kind.ts ---
export enum ActionKind {
  CreateAccount = 'CREATE_ACCOUNT',
  DeployContract = 'DEPLOY_CONTRACT',
  FunctionCall = 'FUNCTION_CALL',
  Transfer = 'TRANSFER',
  Stake = 'STAKE',
  AddKey = 'ADD_KEY',
  DeleteKey = 'DELETE_KEY',
  DeleteAccount = 'DELETE_ACCOUNT',
}

'''
'''--- src/near-indexer/types/execution-outcome-status.ts ---
export enum ExecutionOutcomeStatus {
  Unknown = 'UNKNOWN',
  Failure = 'FAILURE',
  SuccessValue = 'SUCCESS_VALUE',
  SuccessReceiptId = 'SUCCESS_RECEIPT_ID',
}

'''
'''--- src/near-indexer/types/nft-event-kind.ts ---
export enum NftEventKind {
  Mint = 'MINT',
  Transfer = 'TRANSFER',
  Burn = 'BURN',
}

'''
'''--- src/neo4j/neo4j-config.interface.ts ---
export type Neo4jScheme =
  | 'neo4j'
  | 'neo4j+s'
  | 'neo4j+ssc'
  | 'bolt'
  | 'bolt+s'
  | 'bolt+ssc';

export interface Neo4jConfig {
  scheme: Neo4jScheme;
  host: string;
  port: number | string;
  username: string;
  password: string;
  database?: string;
}

'''
'''--- src/neo4j/neo4j-error.filter.ts ---
import { ExceptionFilter, Catch, ArgumentsHost } from '@nestjs/common';
import { Response } from 'express';
import { Neo4jError } from 'neo4j-driver';

@Catch(Neo4jError)
export class Neo4jErrorFilter implements ExceptionFilter {
  catch(exception: Neo4jError, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();

    let statusCode = 500;
    let error = 'Internal Server Error';
    let message: string[] = undefined;

    // Neo.ClientError.Schema.ConstraintValidationFailed
    // Node(54776) already exists with label `User` and property `email` = 'duplicate@email.com'
    if (exception.message.includes('already exists with')) {
      statusCode = 400;
      error = 'Bad Request';

      const [, property] = exception.message.match(/`([a-z0-9]+)`/gi);
      message = [`${property.replace(/`/g, '')} already taken`];
    }
    // Neo.ClientError.Schema.ConstraintValidationFailed
    // Node(54778) with label `Test` must have the property `mustExist`
    else if (exception.message.includes('must have the property')) {
      statusCode = 400;
      error = 'Bad Request';

      const [, property] = exception.message.match(/`([a-z0-9]+)`/gi);
      message = [`${property.replace(/`/g, '')} should not be empty`];
    }

    response.status(statusCode).json({
      statusCode,
      message,
      error,
    });
  }
}

'''
'''--- src/neo4j/neo4j-transaction.interceptor.ts ---
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Neo4jService } from './neo4j.service';
import { Observable } from 'rxjs';
import { Transaction } from 'neo4j-driver';
import { tap, catchError } from 'rxjs/operators';

@Injectable()
export class Neo4jTransactionInterceptor implements NestInterceptor {
  constructor(private readonly neo4jService: Neo4jService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const transaction: Transaction = this.neo4jService.beginTransaction();

    context.switchToHttp().getRequest().transaction = transaction;

    return next.handle().pipe(
      tap(() => {
        transaction.commit();
      }),
      catchError((e) => {
        transaction.rollback();
        throw e;
      }),
    );
  }
}

'''
'''--- src/neo4j/neo4j-type.interceptor.spec.ts ---
import { Neo4jTypeInterceptor } from './neo4j-type.interceptor';
import { Observable } from 'rxjs';

describe('Neo4jTypeInterceptor', () => {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const interceptor: Neo4jTypeInterceptor = new Neo4jTypeInterceptor();

  it('should convert a Node', () => {
    const callHandler = {
      handle: jest.fn().mockReturnThis(),
      pipe: jest.fn().mockReturnValue(
        new Observable((subscriber) => {
          subscriber.next('foo');
        }),
      ),
    };
    expect(callHandler.handle).toBeCalledTimes(1);
    expect(callHandler.pipe).toBeCalledTimes(1);
  });
});

'''
'''--- src/neo4j/neo4j-type.interceptor.ts ---
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import {
  isDuration,
  isLocalTime,
  isTime,
  isDate,
  isDateTime,
  isLocalDateTime,
  isInt,
  isPoint,
  Result,
  Node,
  Relationship,
} from 'neo4j-driver';

const toNative = (
  value: any,
  showLabelsOrType?: boolean,
  showIdentity?: boolean,
): any => {
  if (value === null || value === undefined) return undefined;
  else if (value instanceof Result || value.records) {
    return value.records.map((row) =>
      Object.fromEntries(row.keys.map((key) => [key, toNative(row.get(key))])),
    );
  } else if (Array.isArray(value)) return value.map((value) => toNative(value));
  else if (value instanceof Node)
    return toNative({
      _id: showIdentity ? toNative(value.identity) : null,
      _labels: showLabelsOrType ? toNative(value.labels) : null,
      ...toNative(value.properties),
    });
  else if (value instanceof Relationship)
    return toNative({
      _id: toNative(value.identity),
      _type: showLabelsOrType ? toNative(value.type) : null,
      ...toNative(value.properties),
    });
  // Number
  else if (isInt(value)) return value.toNumber();
  // Temporal
  else if (
    isDuration(value) ||
    isLocalTime(value) ||
    isTime(value) ||
    isDate(value) ||
    isDateTime(value) ||
    isLocalDateTime(value)
  ) {
    return value.toString();
  }

  // Spatial
  if (isPoint(value)) {
    switch (value.srid.toNumber()) {
      case 4326:
        return { longitude: value.y, latitude: value.x };

      case 4979:
        return { longitude: value.y, latitude: value.x, height: value.z };

      default:
        return toNative({ x: value.x, y: value.y, z: value.z });
    }
  }

  // Object
  else if (typeof value === 'object') {
    return Object.fromEntries(
      Object.keys(value).map((key) => [
        key,
        toNative(value[key], showLabelsOrType, showIdentity),
      ]),
    );
  }

  return value;
};

@Injectable()
export class Neo4jTypeInterceptor implements NestInterceptor {
  constructor(
    private readonly showLabelsOrType: boolean = false,
    private readonly showIdentity: boolean = false,
  ) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next
      .handle()
      .pipe(
        map((data) => toNative(data, this.showLabelsOrType, this.showIdentity)),
      );
  }
}

'''
'''--- src/neo4j/neo4j.constants.ts ---
export const NEO4J_CONFIG = 'NEO4J_CONFIG';
export const NEO4J_DRIVER = 'NEO4J_DRIVER';

'''
'''--- src/neo4j/neo4j.module.ts ---
import { Module, DynamicModule, Provider } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { Neo4jService } from './neo4j.service';
import { Neo4jConfig } from './neo4j-config.interface';
import { NEO4J_CONFIG, NEO4J_DRIVER } from './neo4j.constants';
import { createDriver } from './neo4j.util';
import { Neo4jTransactionInterceptor } from './neo4j-transaction.interceptor';

@Module({})
export class Neo4jModule {
  static forRoot(config: Neo4jConfig): DynamicModule {
    return {
      module: Neo4jModule,
      global: true,
      providers: [
        {
          provide: NEO4J_CONFIG,
          useValue: config,
        },
        {
          provide: NEO4J_DRIVER,
          inject: [NEO4J_CONFIG],
          useFactory: async (config: Neo4jConfig) => createDriver(config),
        },
        Neo4jService,
      ],
      exports: [Neo4jService, Neo4jTransactionInterceptor],
    };
  }

  static forRootAsync(configProvider): DynamicModule {
    return {
      module: Neo4jModule,
      global: true,
      imports: [ConfigModule],

      providers: [
        {
          provide: NEO4J_CONFIG,
          ...configProvider,
        } as Provider<any>,
        {
          provide: NEO4J_DRIVER,
          inject: [NEO4J_CONFIG],
          useFactory: async (config: Neo4jConfig) => createDriver(config),
        },
        Neo4jService,
      ],
      exports: [Neo4jService],
    };
  }
}

'''
'''--- src/neo4j/neo4j.service.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { Neo4jService } from './neo4j.service';

describe('Neo4jService', () => {
  let service: Neo4jService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [Neo4jService],
    }).compile();

    service = module.get<Neo4jService>(Neo4jService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

'''
'''--- src/neo4j/neo4j.service.ts ---
import neo4j, { Result, Driver, int, Transaction } from 'neo4j-driver';
import { Injectable, Inject, OnApplicationShutdown } from '@nestjs/common';
import { Neo4jConfig } from './neo4j-config.interface';
import { NEO4J_CONFIG, NEO4J_DRIVER } from './neo4j.constants';
import TransactionImpl from 'neo4j-driver-core/lib/transaction';

@Injectable()
export class Neo4jService implements OnApplicationShutdown {
  constructor(
    @Inject(NEO4J_CONFIG) private readonly config: Neo4jConfig,
    @Inject(NEO4J_DRIVER) private readonly driver: Driver,
  ) {}

  getDriver(): Driver {
    return this.driver;
  }

  getConfig(): Neo4jConfig {
    return this.config;
  }

  int(value: number) {
    return int(value);
  }

  beginTransaction(database?: string): Transaction {
    const session = this.getWriteSession(database);

    return session.beginTransaction();
  }

  getReadSession(database?: string) {
    return this.driver.session({
      database: database || this.config.database,
      defaultAccessMode: neo4j.session.READ,
    });
  }

  getWriteSession(database?: string) {
    return this.driver.session({
      database: database || this.config.database,
      defaultAccessMode: neo4j.session.WRITE,
    });
  }

  read(
    cypher: string,
    params?: Record<string, any>,
    databaseOrTransaction?: string | Transaction,
  ): Result {
    if (databaseOrTransaction instanceof TransactionImpl) {
      return (<Transaction>databaseOrTransaction).run(cypher, params);
    }

    const session = this.getReadSession(<string>databaseOrTransaction);
    return session.run(cypher, params);
  }

  write(
    cypher: string,
    params?: Record<string, any>,
    databaseOrTransaction?: string | Transaction,
  ): Result {
    if (databaseOrTransaction instanceof TransactionImpl) {
      return (<Transaction>databaseOrTransaction).run(cypher, params);
    }

    const session = this.getWriteSession(<string>databaseOrTransaction);
    return session.run(cypher, params);
  }

  onApplicationShutdown() {
    return this.driver.close();
  }
}

'''
'''--- src/neo4j/neo4j.util.ts ---
import neo4j, { Driver } from 'neo4j-driver';
import { Neo4jConfig } from './neo4j-config.interface';

export const createDriver = async (config: Neo4jConfig) => {
  const driver: Driver = neo4j.driver(
    `${config.scheme}://${config.host}:${config.port}`,
    neo4j.auth.basic(config.username, config.password),
  );

  await driver.verifyConnectivity();

  return driver;
};

'''
'''--- src/nft/dto/nft-contract.dto.ts ---
import * as camelcaseKeys from 'camelcase-keys';

export interface NftContractDto {
  contractId: string;
  name: string;
  spec: string;
  icon: string;
  symbol: string;
  baseUri: string;
  reference: string;
}

export function castNftContract(contractId: string, metadata): NftContractDto {
  return {
    ...camelcaseKeys(metadata, { deep: true }),
    contractId,
  };
}

'''
'''--- src/nft/dto/nft-event.dto.ts ---
import { AssetsNftEvent } from 'src/near-indexer/entities/assets-nft-event.entity';
import { NftEventKind } from 'src/near-indexer/types/nft-event-kind';

export interface NftEventDto {
  receiptId: string;
  contract: string;
  tokenId: string;
  tokenOldOwnerAccountId: string;
  tokenNewOwnerAccountId: string;
  timestamp: string;
  type: NftEventKind;
}

export function castNftEvent(assetsNftEvent: AssetsNftEvent): NftEventDto {
  return {
    receiptId: assetsNftEvent.emittedForReceiptId,
    contract: assetsNftEvent.emittedByContractAccountId,
    tokenId: assetsNftEvent.tokenId,
    tokenOldOwnerAccountId: assetsNftEvent.tokenOldOwnerAccountId,
    tokenNewOwnerAccountId: assetsNftEvent.tokenNewOwnerAccountId,
    timestamp: String(assetsNftEvent.emittedAtBlockTimestamp),
    type: assetsNftEvent.eventKind as NftEventKind,
  };
}

'''
'''--- src/nft/dto/nft-query.dto.ts ---
import { IsString } from 'class-validator';
import { PagingQuery } from 'src/common/dto/PagingQuery';

export class NftQuery extends PagingQuery {
  @IsString()
  userId?: string;
}

'''
'''--- src/nft/dto/nft-update.dto.ts ---
export interface NftUpdateDto {
  contractId: string;
  accountId: string;
}

'''
'''--- src/nft/dto/nft.dto.ts ---
import * as camelcaseKeys from 'camelcase-keys';
import { ObjectId } from 'mongodb';

export interface NftDto {
  contractId: string;
  tokenId: string;
  accountId: string;
  owner: string;
  minter: string;
  media: string;
  metadata: Record<string, unknown>;
}

export function castNft(
  contractId: string,
  nearAccountId: string,
  nft: any,
  metadata: any,
  userId: string,
): NftDto {
  const nftToken = camelcaseKeys(nft, { deep: true });
  const nftMetadata = camelcaseKeys(metadata, { deep: true });
  const tokenId = nftToken.id || nftToken.tokenId;
  delete nftToken.id;
  return {
    ...nftToken,
    contractId,
    userId: ObjectId(userId),
    nearAccountId,
    tokenId: tokenId,
    owner: nftToken.ownerId.account || nftToken.ownerId,
    media: nftMetadata.media,
    metadata: nftMetadata,
  };
}

'''
'''--- src/nft/entities/nft-contract.entity.ts ---
import { BaseEntity } from 'src/common/base.entity';
import { Column, Entity, PrimaryColumn } from 'typeorm';
import { Nft } from './nft.entity';

@Entity()
export class NftContract extends BaseEntity {
  @PrimaryColumn({ unique: true })
  contractId: string;

  @Column()
  name: string;

  @Column()
  spec: string;

  @Column()
  icon: string;

  @Column()
  symbol: string;

  @Column()
  baseUri: string;

  @Column()
  reference: string;

  @Column()
  nfts: Nft[];
}

'''
'''--- src/nft/entities/nft-event.enity.ts ---
import { Column, Entity } from 'typeorm';
import { NftEventKind } from 'src/near-indexer/types/nft-event-kind';
import { BaseEntity } from 'src/common/base.entity';

@Entity()
export class NftEvent extends BaseEntity {
  @Column({ unique: true })
  receiptId: string;

  @Column()
  contract: string;

  @Column()
  tokenId: string;

  @Column()
  tokenOldOwnerAccountId: string;

  @Column()
  tokenNewOwnerAccountId: string;

  @Column()
  timestamp: string;

  @Column()
  type: NftEventKind;
}

'''
'''--- src/nft/entities/nft.entity.ts ---
import { BaseEntity } from 'src/common/base.entity';
import { Column, Entity } from 'typeorm';

export class NftMetadata {
  @Column()
  copies: number;

  @Column()
  title: string;

  @Column()
  description: string;

  @Column()
  expiresAt: string;

  @Column()
  extra: unknown;

  @Column()
  issuedAt: string;

  @Column()
  media: string;

  @Column()
  mediaHash: string;

  @Column()
  reference: string;

  @Column()
  referenceHash: string;

  @Column()
  startsAt: string;
}

@Entity()
export class Nft extends BaseEntity {
  @Column()
  contractId: string;

  @Column()
  tokenId: string;

  @Column()
  userId: string;

  @Column()
  nearAccountId: string;

  @Column()
  owner: string;

  @Column()
  minter: string;

  @Column()
  media: string;

  @Column(() => NftMetadata)
  metadata: NftMetadata;

  @Column()
  visible: boolean;
}

'''
'''--- src/nft/nft-aggregator.service.ts ---
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { SchedulerRegistry } from '@nestjs/schedule';

import { NearIndexerService } from 'src/near-indexer/near-indexer.service';
import { FIRST_NFT_EVENT_TIMESTAMP } from 'src/common/constants';
import { UserService } from 'src/user/user.service';

import { NftService } from './nft.service';
import { NftUpdateDto } from './dto/nft-update.dto';
import { castNftEvent } from './dto/nft-event.dto';

@Injectable()
export class NftAggregatorService {
  logger = new Logger(NftAggregatorService.name);
  isInProgress: boolean;
  aggregationInterval: number;

  constructor(
    private nftService: NftService,
    private readonly nearIndexerService: NearIndexerService,
    private readonly userService: UserService,
    private readonly schedulerRegistry: SchedulerRegistry,
    private readonly configService: ConfigService,
  ) {
    const { nftAggregationInterval } = configService.get('app');
    this.aggregationInterval = nftAggregationInterval;
    this.startAggregation();
  }

  async startAggregation() {
    let isUpdatesFound;

    // Aggregate all missed updates
    do {
      isUpdatesFound = await this.aggregateUpdates();
    } while (isUpdatesFound);

    this.schedulerRegistry.addInterval(
      'polling',
      setInterval(() => this.aggregateUpdates(), this.aggregationInterval),
    );
  }

  async aggregateUpdates(): Promise<boolean> {
    if (this.isInProgress) {
      return false;
    }

    this.isInProgress = true;

    const lastSavedEvent = await this.nftService.getLastNftEvent();
    const fromTimestamp =
      lastSavedEvent?.timestamp || FIRST_NFT_EVENT_TIMESTAMP;
    const events = await this.nearIndexerService.findLastNftEvents(
      fromTimestamp,
      1000,
    );
    const lastEvent = events[events.length - 1];

    if (!lastEvent) {
      this.isInProgress = false;
      return false;
    }

    const nearAccountsMap = await this.userService
      .findAllNearAccounts()
      .then((accounts) =>
        accounts.reduce(
          (accountMap, accountId) => ({
            ...accountMap,
            [accountId]: accountId,
          }),
          {},
        ),
      );
    const nftUpdates: NftUpdateDto[] = [];

    events.forEach((event) => {
      if (nearAccountsMap[event.tokenOldOwnerAccountId]) {
        nftUpdates.push({
          contractId: event.emittedByContractAccountId,
          accountId: event.tokenOldOwnerAccountId,
        });
      }

      if (nearAccountsMap[event.tokenNewOwnerAccountId]) {
        nftUpdates.push({
          contractId: event.emittedByContractAccountId,
          accountId: event.tokenNewOwnerAccountId,
        });
      }
    });

    await this.nftService.loadAccountNftUpdates(nftUpdates);
    await this.nftService.createNftEvent(castNftEvent(lastEvent));

    nftUpdates.forEach(({ contractId, accountId }) => {
      this.logger.log(
        `Aggregated NFT update. Contract: ${contractId} Account: ${accountId}`,
      );
    });

    this.isInProgress = false;
    return true;
  }
}

'''
'''--- src/nft/nft.controller.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { NftController } from './nft.controller';

describe('NftController', () => {
  let controller: NftController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [NftController],
    }).compile();

    controller = module.get<NftController>(NftController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

'''
'''--- src/nft/nft.controller.ts ---
import {
  Body,
  Controller,
  Get,
  Param,
  Patch,
  Post,
  Query,
  Request,
  UseGuards,
} from '@nestjs/common';

import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.quard';
import {
  PaginationRequest,
  PaginationResponse,
} from 'src/common/pagination.interface';
import { SearchRequest } from 'src/common/search.interface';
import { NftService } from './nft.service';
import { Nft } from './entities/nft.entity';

@Controller('nfts')
export class NftController {
  constructor(private readonly nftService: NftService) {}

  @Get('popular')
  async getPopularNfts(
    @Query() query: PaginationRequest,
  ): Promise<PaginationResponse<Nft>> {
    return this.nftService.getPopularNfts(query);
  }

  @Get('search')
  async searchNfts(
    @Query() query: SearchRequest,
  ): Promise<PaginationResponse<Nft>> {
    return this.nftService.searchNfts(query);
  }

  @UseGuards(JwtAuthGuard)
  @Get('my')
  async getMyNfts(
    @Request() req,
    @Query() query: PaginationRequest,
  ): Promise<PaginationResponse<Nft>> {
    return this.nftService.getUserNfts(req.user.userId, query);
  }

  @UseGuards(JwtAuthGuard)
  @Post('my/show-list')
  async showNfts(@Request() req, @Body() nftIds: string[]): Promise<Nft[]> {
    return this.nftService.setNftsVisible(req.user.userId, nftIds, true);
  }

  @UseGuards(JwtAuthGuard)
  @Post('my/hide-list')
  async hideNfts(@Request() req, @Body() nftIds: string[]): Promise<Nft[]> {
    return this.nftService.setNftsVisible(req.user.userId, nftIds, false);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('my/:nftId/show')
  async showNft(@Request() req, @Param('nftId') nftId: string): Promise<Nft> {
    return this.nftService.setNftVisible(req.user.userId, nftId, true);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('my/:nftId/hide')
  async hideNft(@Request() req, @Param('nftId') nftId: string): Promise<Nft> {
    return this.nftService.setNftVisible(req.user.userId, nftId, false);
  }
}

'''
'''--- src/nft/nft.module.ts ---
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ScheduleModule } from '@nestjs/schedule';
import { HttpModule } from '@nestjs/axios';
import { NearIndexerModule } from 'src/near-indexer/near-indexer.module';
import { NearApiModule } from 'src/near-api/near-api.module';

import { NftService } from './nft.service';
import { NftAggregatorService } from './nft-aggregator.service';
import { Nft } from './entities/nft.entity';
import { NftContract } from './entities/nft-contract.entity';
import { NftEvent } from './entities/nft-event.enity';
import { UserModule } from 'src/user/user.module';
import { NftController } from './nft.controller';

@Module({
  imports: [
    TypeOrmModule.forFeature([Nft, NftContract, NftEvent]),
    ScheduleModule.forRoot(),
    NearIndexerModule,
    NearApiModule,
    HttpModule,
    UserModule,
  ],
  controllers: [NftController],
  providers: [NftService, NftAggregatorService],
  exports: [NftService, NftAggregatorService],
})
export class NftModule {}

'''
'''--- src/nft/nft.service.ts ---
import { MongoRepository } from 'typeorm';
import { BadRequestException, Injectable } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { lastValueFrom, map } from 'rxjs';
import { PromisePool } from '@supercharge/promise-pool';
import { InjectRepository } from '@nestjs/typeorm';
import { ObjectId } from 'mongodb';

import { NearIndexerService } from 'src/near-indexer/near-indexer.service';
import { NearApiService } from 'src/near-api/near-api.service';

import { castNftContract, NftContractDto } from './dto/nft-contract.dto';
import { castNft, NftDto } from './dto/nft.dto';
import { Nft } from './entities/nft.entity';
import { NftContract } from './entities/nft-contract.entity';
import { NftEvent } from './entities/nft-event.enity';
import {
  PaginationRequest,
  PaginationResponse,
} from '../common/pagination.interface';
import { UserService } from 'src/user/user.service';
import { SearchRequest } from '../common/search.interface';
import { NftEventDto } from './dto/nft-event.dto';
import { NftUpdateDto } from './dto/nft-update.dto';

@Injectable()
export class NftService {
  constructor(
    @InjectRepository(Nft)
    private nftRepository: MongoRepository<Nft>,

    @InjectRepository(NftContract)
    private nftContractRepository: MongoRepository<NftContract>,

    @InjectRepository(NftEvent)
    private nftEventRepository: MongoRepository<NftEvent>,

    private readonly userService: UserService,
    private readonly nearIndexerService: NearIndexerService,
    private readonly nearApiService: NearApiService,
    private readonly httpService: HttpService,
  ) {}

  async createOrUpdateNft(nftDto: NftDto) {
    const nftModel = await this.nftRepository.findOne({
      contractId: nftDto.contractId,
      tokenId: nftDto.tokenId,
    });
    return this.nftRepository.save({ ...nftModel, ...nftDto });
  }

  async createOrUpdateNftContract(nftContractDto: NftContractDto) {
    const nftContractModel = await this.nftContractRepository.findOne({
      contractId: nftContractDto.contractId,
    });
    return this.nftContractRepository.save({
      ...nftContractModel,
      ...nftContractDto,
    });
  }

  async createNftEvent(nftEventDto: NftEventDto) {
    return this.nftEventRepository.save(nftEventDto);
  }

  async getLastNftEvent() {
    return this.nftEventRepository.findOne({
      order: {
        timestamp: 'DESC',
      },
    });
  }

  async setNftVisible(
    userId: string,
    nftId: string,
    visible: boolean,
  ): Promise<Nft> {
    const nftModel = await this.nftRepository.findOne({
      where: { _id: ObjectId(nftId), userId: ObjectId(userId) },
    });

    if (!nftModel) {
      throw new BadRequestException('Invalid nft id');
    }

    return this.nftRepository.save({
      ...nftModel,
      visible,
    });
  }

  async setNftsVisible(
    userId: string,
    nftIds: string[],
    visible: boolean,
  ): Promise<Nft[]> {
    const nftModels = await this.nftRepository.find({
      where: {
        _id: { $in: nftIds.map((id) => ObjectId(id)) },
        userId: ObjectId(userId),
      },
    });
    return this.nftRepository.save(
      nftModels.map((nftModel) => ({ ...nftModel, visible })),
    );
  }

  async getUserNfts(
    userId: string,
    { offset = 0, limit = 10 }: PaginationRequest,
  ): Promise<PaginationResponse<Nft>> {
    const data = await this.nftRepository.find({
      where: { userId: ObjectId(userId) },
      skip: Number(offset),
      take: Number(limit),
    });
    const total = await this.nftRepository.count({ userId: ObjectId(userId) });
    return {
      offset,
      limit,
      total,
      data,
    };
  }

  async getPopularNfts({
    offset = 0,
    limit = 10,
  }: PaginationRequest): Promise<PaginationResponse<Nft>> {
    const data = await this.getNftFeedAggregator()
      .skip(Number(offset))
      .limit(Number(limit))
      .toArray();
    const total = await this.nftRepository.count(this.getNftFeedMatch());
    return {
      offset,
      limit,
      total,
      data: data.map(this.buildNftFeed),
    };
  }

  async searchNfts({
    offset = 0,
    limit = 10,
    search,
  }: SearchRequest): Promise<PaginationResponse<Nft>> {
    const data = await this.getNftFeedAggregator(search)
      .skip(Number(offset))
      .limit(Number(limit))
      .toArray();
    const total = await this.nftRepository.count(this.getNftFeedMatch(search));
    return {
      offset,
      limit,
      total,
      data: data.map(this.buildNftFeed),
    };
  }

  async loadAllAccountNfts(accountId: string) {
    const user = await this.userService.findByNearAccount(accountId);
    const nftContracts = await this.nearIndexerService.findLikelyNFTs(
      accountId,
    );
    await PromisePool.withConcurrency(5)
      .for(nftContracts)
      .process(async (nftContract) =>
        this.loadAccountNftsByContract(
          nftContract,
          accountId,
          user.id.toString(),
        ),
      );
  }

  async loadAccountNftUpdates(nftUpdates: NftUpdateDto[]) {
    const uniqueUpdates = nftUpdates.filter((nftUpdate, index) => {
      return (
        index ===
        nftUpdates.findIndex(
          ({ accountId, contractId }) =>
            nftUpdate.accountId === accountId &&
            nftUpdate.contractId === contractId,
        )
      );
    });
    await PromisePool.withConcurrency(5)
      .for(uniqueUpdates)
      .process(async (nftUpdate) => this.loadAccountNftUpdate(nftUpdate));
  }

  async loadAccountNftUpdate(nftUpdate: NftUpdateDto) {
    const user = await this.userService.findByNearAccount(nftUpdate.accountId);
    return this.loadAccountNftsByContract(
      nftUpdate.contractId,
      nftUpdate.accountId,
      user.id.toString(),
    );
  }

  async loadAccountNftsByContract(
    nftContractId: string,
    accountId: string,
    userId: string,
  ) {
    const nfts = await this.nearApiService.getAccountNfts(
      nftContractId,
      accountId,
    );
    const metadata = await this.nearApiService.getNftMetadata(nftContractId);
    const nftContractDto = castNftContract(nftContractId, metadata);

    await PromisePool.withConcurrency(5)
      .for(nfts)
      .process(async (nft) =>
        this.loadAccountNft(accountId, nftContractDto, nft, userId),
      );

    return this.createOrUpdateNftContract(nftContractDto);
  }

  async loadAccountNft(
    accountId: string,
    nftContractDto: NftContractDto,
    nft,
    userId: string,
  ) {
    const metadata = await this.loadNftMetadata(nftContractDto, nft);
    const nftDto = castNft(
      nftContractDto.contractId,
      accountId,
      nft,
      metadata,
      userId,
    );

    return this.createOrUpdateNft(nftDto);
  }

  async loadNftMetadata(nftContractDto: NftContractDto, nft) {
    const { baseUri } = nftContractDto;
    const { media, reference } = nft.metadata;

    if (media?.indexOf('http') === 0) {
      return nft.metadata;
    }

    if (baseUri && media) {
      return {
        ...nft.metadata,
        media: `${baseUri}/${media}`,
      };
    }

    if (baseUri && !media && reference) {
      try {
        const metadata = await lastValueFrom(
          this.httpService
            .get(`${baseUri}/${reference}`)
            .pipe(map((res) => res.data)),
        );
        return {
          ...nft.metadata,
          ...metadata,
        };
      } catch (err) {}
    }

    if (media) {
      return {
        ...nft.metadata,
        media: `https://cloudflare-ipfs.com/ipfs/${media}`,
      };
    }

    return nft.metadata;
  }

  private getNftFeedAggregator(search?: string) {
    return this.nftRepository.aggregate([
      {
        $lookup: {
          from: 'nft_contract',
          localField: 'contractId',
          foreignField: 'contractId',
          as: 'contract',
        },
      },
      { $addFields: { userObjectId: { $toObjectId: '$userId' } } },
      {
        $lookup: {
          from: 'user',
          localField: 'userObjectId',
          foreignField: '_id',
          as: 'user',
        },
      },
      { $match: this.getNftFeedMatch(search) },
    ]);
  }

  private getNftFeedMatch(search?: string) {
    if (search) {
      const searchRe = new RegExp(`.*${search}.*`, 'i');
      return {
        visible: true,
        $or: [
          { 'metadata.title': searchRe },
          { 'metadata.description': searchRe },
          { nearAccountId: searchRe },
        ],
      };
    }
    return { visible: true };
  }

  private buildNftFeed(nft) {
    const user = nft.user?.[0];
    const contract = nft.contract?.[0];
    return {
      ...nft,
      contract,
      user: user && {
        id: user.id,
        username: user.username,
        profilePicture: user.profilePicture,
        instagram: user.instagram,
        nearAccounts: user.nearAccounts.map(({ accountId }) => accountId),
      },
    };
  }
}

'''
'''--- src/user/dto/update.user.dto.ts ---
import { UserNearAccountDto } from './user-near-account.interface';

export class UserDto {
  nearAccounts: UserNearAccountDto[];
  username?: string;
  bio?: string;
  profilePicture?: string;
  instagram?: string;
}

'''
'''--- src/user/dto/user-near-account.interface.ts ---
export class UserNearAccountDto {
  accountId: string;
  enabled: boolean;
}

'''
'''--- src/user/dto/user-profile.interface.ts ---
export class UserProfileDto {
  username?: string;
  bio?: string;
  profilePicture?: string;
  instagram?: string;
}

'''
'''--- src/user/entities/user.entity.ts ---
import { Entity, Column } from 'typeorm';
import { BaseEntity } from 'src/common/base.entity';

export class UserNearAccount {
  @Column()
  accountId: string;

  @Column()
  enabled: boolean;
}

@Entity()
export class User extends BaseEntity {
  @Column()
  text: string;

  @Column(() => UserNearAccount, { array: true })
  nearAccounts: UserNearAccount[];

  @Column()
  username: string;

  @Column()
  bio: string;

  @Column()
  profilePicture: string;

  @Column()
  instagram: string;
}

'''
'''--- src/user/user.controller.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { UserController } from './user.controller';

describe('UserController', () => {
  let controller: UserController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UserController],
    }).compile();

    controller = module.get<UserController>(UserController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

'''
'''--- src/user/user.controller.ts ---
import {
  Body,
  Controller,
  Get,
  Param,
  Patch,
  Query,
  Request,
  UseGuards,
} from '@nestjs/common';

import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.quard';
import { SearchRequest } from 'src/common/search.interface';
import { PaginationResponse } from 'src/common/pagination.interface';

import { UserService } from './user.service';
import { User } from './entities/user.entity';
import { UserProfileDto } from './dto/user-profile.interface';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @UseGuards(JwtAuthGuard)
  @Get('search')
  async searchUsers(
    @Query() query: SearchRequest,
  ): Promise<PaginationResponse<User>> {
    return this.userService.searchUsers(query);
  }

  @UseGuards(JwtAuthGuard)
  @Get('my')
  async getMyUser(@Request() req): Promise<User> {
    return this.userService.findById(req.user.userId);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('my/profile')
  async updateUserProfile(
    @Request() req,
    @Body() body: UserProfileDto,
  ): Promise<boolean> {
    return this.userService.updateUserProfile(req.user.userId, body);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('my/near-account/:accountId/enable')
  async enableNearWallet(
    @Request() req,
    @Param('accountId') accountId: string,
  ): Promise<User> {
    return this.userService.setNearAccountStatus(
      req.user.userId,
      accountId,
      true,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Patch('my/near-account/:accountId/disable')
  async disableNearWallet(
    @Request() req,
    @Param('accountId') accountId: string,
  ): Promise<User> {
    return this.userService.setNearAccountStatus(
      req.user.userId,
      accountId,
      false,
    );
  }
}

'''
'''--- src/user/user.module.ts ---
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UserService } from './user.service';
import { UserController } from './user.controller';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
})
export class UserModule {}

'''
'''--- src/user/user.service.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UserService],
    }).compile();

    service = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

'''
'''--- src/user/user.service.ts ---
import { BadRequestException, Injectable } from '@nestjs/common';
import { User } from './entities/user.entity';
import { UserDto } from './dto/update.user.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { MongoRepository } from 'typeorm';
import { ObjectId } from 'mongodb';

import { UserProfileDto } from './dto/user-profile.interface';
import { UserNearAccountDto } from './dto/user-near-account.interface';
import { SearchRequest } from '../common/search.interface';
import { PaginationResponse } from '../common/pagination.interface';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: MongoRepository<User>,
  ) {}

  async create(userDto: UserDto): Promise<User> {
    const user = new User();
    user.username = userDto.username;
    user.bio = userDto.bio;
    user.nearAccounts = userDto.nearAccounts;
    user.profilePicture = userDto.profilePicture;
    return this.userRepository.save(user);
  }

  async addNearAccount(
    userId: string,
    nearAccount: UserNearAccountDto,
  ): Promise<User> {
    const user = await this.userRepository.findOne(userId);
    user.nearAccounts = [...user.nearAccounts, nearAccount];

    return this.userRepository.save(user);
  }

  async updateUserProfile(
    userId: string,
    { username, bio, profilePicture, instagram }: UserProfileDto,
  ): Promise<boolean> {
    await this.userRepository.update(userId, {
      username,
      bio,
      profilePicture,
      instagram,
    });
    return true;
  }

  async setNearAccountStatus(
    userId: string,
    nearAccountId: string,
    enabled: boolean,
  ) {
    const user = await this.findById(userId);
    await this.userRepository.save(user);
    const nearAccount = user.nearAccounts.find(
      ({ accountId }) => nearAccountId === accountId,
    );

    if (!nearAccount) {
      throw new BadRequestException('Invalid near account id');
    }
    nearAccount.enabled = enabled;

    return this.userRepository.save(user);
  }

  async findByNearAccount(accountId: string): Promise<User> {
    return this.userRepository.findOne({
      where: { nearAccounts: { $elemMatch: { accountId } } },
    });
  }

  async findById(userId: string): Promise<User> {
    return this.userRepository.findOne({ where: { _id: ObjectId(userId) } });
  }

  async findAllNearAccounts(): Promise<string[]> {
    const allUserAccounts = await this.userRepository.find({
      select: ['nearAccounts'],
    });
    return allUserAccounts.flatMap(({ nearAccounts }) =>
      nearAccounts.map(({ accountId }) => accountId),
    );
  }

  async searchUsers({
    offset = 0,
    limit = 10,
    search,
  }: SearchRequest): Promise<PaginationResponse<User>> {
    const searchRe = new RegExp(`.*${search}.*`, 'i');
    const where = search
      ? {
          $or: [
            { 'nearAccounts.accountId': searchRe },
            { username: searchRe },
            { instagram: searchRe },
          ],
        }
      : undefined;
    const data = await this.userRepository.find({
      where,
      skip: Number(offset),
      take: Number(limit),
    });
    const total = await this.userRepository.count({ ...where });
    return {
      offset,
      limit,
      total,
      data: data,
    };
  }
}

'''
'''--- test/app.e2e-spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

'''
'''--- test/jest-e2e.json ---
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

'''
'''--- tsconfig.build.json ---
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}

'''