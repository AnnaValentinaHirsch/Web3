*GitHub Repository "k3rn3lpanicc/droplinked-near-contract"*

'''--- README.md ---
# Droplinked-NEAR-Contract
## Introduction
On the droplinked protocol, we are registering products on chain and to enable 3rd party publishers to leverage these registered products and sell them across any marketplace, dapp or native site in order to earn commission. We are complimenting this with headless tooling for NFT Gated store fronts on droplinked.com and other valued added NFT solutions.

droplinkeds' contract implements base functionalities of ethereum's ERC-1155 standard. This contract implements SFT tokens (Semi-Fungible Token), which have both uniqueness and value. For example, a producer wants to mint 1M NFTs of the same product (each product has an nft which describes who owns the item); by minting 1M NFT's in a standard such as an ERC-721 is not cost effective (storing 1M ID's and owner address will cost a lot of gas); so instead of minting them one by one, we mint a base token (which contains the ID), and hold that id alongside the number of tokens that a particular account owns. 

This way, we only store a single token ID (which represents the product), and a single number (which represents how many of these token ID's a person owns) for each particular account. 

On droplinked, a publisher can send a publish request to the producer with a particular pre-defined commission amount. The producer can accept or reject requests and if a request is accepted, the publisher is then given the abilkity to publish the product to share with consumers and earn their entitled settlement portion.

## Structure of the contract
Here we explain each structure used within the contract and how they are used:

1. [NFTHolder](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L16-L21) : this struct holds the token ID and its amount for a specific account. remaining_amount is the amount left which is not published for a publisher.
2. [NFTMetadata](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L7-L13) : this struct holds the metadata of a token. It has a name, a URI(it can be IPFS hash), and a checksum (the hash of the file uploaded off-chain), and a price (in USD).
3. [PublishRequest](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L33-L40) : this struct holds the request of a publisher to a producer to publish a token. It has a holder_id, amount, a publisher address, a producer address, and commission. this struct will be saved in a dictionary which maps a request_id to a PublishRequest.
4. [ApprovedNFT](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L23-L31) : this struct holds the data of the approved tokens (for publishers), it has a holder_id, amount, owner and publisher account address, the token_id, and the amount of commission. After approving a PublishRequest by a producer, it will be saved in a dictionary which maps every approved_id to this object.

## Methods
Here we explain each method within the contract and how they are used:

1. [**Mint**](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L95-L149) : gets (`name`,`token_uri`,`checksum`,`price`,`amount`) and mints the `amount` of tokens to `caller`'s account. It first stores the metadata in a `NFTMetadata` struct and saves it in `metadas` dict (which maps a token_id to its `NFTMetadata`). if the `metadata` is already minted, it will use its existing `token_id`. then it will create a `NFTHolder` struct and save it in `holders` dict (which maps a holder_id to a list of `NFTHolder` structs). If the `caller` already owns this token, it will add the `amount` to its `NFTHolder` struct, otherwise it will create a new `NFTHolder` struct and add it to the list.
2. [**publish_request**](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L183-L233) : gets (`producer_account`, `holder_id`, `amount`, `comission`) and creates a `PublishRequest` struct and saves it in `publish_requests` dict (which maps a request_id to a `PublishRequest` struct). Then puts the `request_id` in `producer_requests` dict (which maps a producer account hash to a list of request_ids), also puts the `request_id` in `publisher_requests` dict (which maps a publisher account hash to a list of request_ids). A producer can accept or reject a request and a publisher can cancel any request.
3. [**approve**](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L269-L349) : gets (`request_id`) and approves it, and creates an `ApprovedNFT` struct and saves it in `approved_nfts` dict (which maps a approved_id to an `ApprovedNFT` struct). then puts the `approved_id` in `producer_approved` dict (which maps a producer account hash to a list of approved_ids), also puts the `approved_id` in `publisher_approved` dict (which maps a publisher account hash to a list of approved_ids). A producer can disapprove an approved request at any time post an timestamp.
4. [**disapprove**](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L357-L385) : gets (`approved_id`, `amount`) and disapproves the `approved_id`. If the `amount` is equal to the `amount` of the `ApprovedNFT` struct, it will remove the `approved_id` from `producer_approved` and `publisher_approved` dicts. Otherwise, it will decrease the `amount` of the `ApprovedNFT` struct.
5. [**cancel_request**](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L387-L402) : gets (`request_id`) and removes the `request_id` from `producer_requests` and `publisher_requests` dicts.
6. [**Getter Functions**](https://github.com/FLATLAY/Droplinked-NEAR-Contract/blob/11f6729e439aac45ba8c04289e7508c1316db21f/droplinked-near/src/lib.rs#L151-L181) : These functions are used for interacting with the contract and recieving data.

## Storage Model

![Preview-1](https://user-images.githubusercontent.com/20683538/226114657-869ba832-f870-4571-9692-ff25347f54c3.png)

# Project Feautures
## NFT Gating system
Producers can set a set of rules in order to sell their tokens. They can limit the buyers to accounts which have bought several other tokens by the producer (gating), or they can provide tiered discounts.

These rules (ruleset) are deployed on droplinked.com before the customer purchases the token.

## NFT Storefront
droplinked.com provides a storefront in wich the producers can upload their NFTs and set their prices and rulesets, while customers can explore the NFTs and buy them. These NFT's represent both digital and physical goods.

## Deployed Contract
Account_id for deployed contract : 4bb5d093c0c0e1b4874c41216cdabc5ef1c81c5535b25788202f2a8ce145a7d7

'''
'''--- droplinked-near/Cargo.toml ---
[package]
name = "status-message"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "*", features = ["derive"] }
serde_json = "*"
near-sdk = "4.0.0"
base16 = { version = "0.2", default-features = false, features = ["alloc"] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- droplinked-near/Checking Process .txt ---
Checking Process : 

1. Create 3 different accounts : Prod, Pub, Cust, Deployer : DONE
2. Mint Products to Prod : Pa, Pb with different Metadata (Use real metadata) : DONE
3. Check Holders, Owners, token_metadata, token_id, holder_id : DONE
4. Do a publishRequest from Pub to Prod, using holder_id,prodAcc,amount,comission for product Pa : DONE
5. Check holder's remaining amount, requests, request_id, pubRequests, prodRequests : (RETURN ID instead of Actual Requests in pubRequests,..) - DONE
6. Do another publishRequest from pub to Prod, for product Pb : DONE
7. Do 5 again : DONE
8. Cancel first request : DONE
9. do 5 again : DONE
10. Accept second request with pub account, then with prod account : DONE,DONE
11. Do 5, and check approveds, producer_approved, pub_approved : DONE
12. Do a disapprove, on the approved one, with a amount less than its original amount, and check everything : DONE
13. Do 12 again with the remaining amount, and check if it removes that approved or not : DONE
14. Buy Product (Payable with stablecoin) and check the transfers 
'''
'''--- droplinked-near/keys/k3rn3lpanic.json ---
{"implicit_account_id":"7875e128ffdab2513e27180a406280630476c9a13787da2c6c30677a1a14b936","master_seed_phrase":"    ","private_key":"ed25519:2zbiQ3w85M4LRAnvv8Jg7Rx4X2QdvqpMPiZ8cX7ZASBxsRvCrQ5hBrAqazGMNNwpn45MQ94S747oa1uUNE29y4AZ","public_key":"ed25519:97EBGPGVjBL5h6CZyCjvrqrFN8is48uqVjQZnzFFGhDf","seed_phrase_hd_path":"m/44'/397'/0'"}
'''
'''--- droplinked-near/near_util.py ---
import requests
import base64
import json
from pygments import highlight, lexers, formatters

rpc_url = "https://archival-rpc.testnet.near.org/"
contract_account_id = "4bb5d093c0c0e1b4874c41216cdabc5ef1c81c5535b25788202f2a8ce145a7d7"

publisher_account = "pub_droplinked.testnet"
producer_account = "prod_droplinked.testnet"
customer_account = "cust_droplinked.testnet"

def b64e(s):
    return base64.b64encode(s.encode()).decode()
def b64d(s):
    return base64.b64decode(s).decode()
def parse_args(args):
    return b64e(json.dumps(args).replace(" ", ""))
def parse_result(res):
    return bytes(res).decode()

def resify (res):
    if res == '[]':
        return []
    return res

def query_contract(entry_point : str, args : dict) -> str :
    body = {
        "jsonrpc": "2.0",
        "id": "dontcare",
        "method": "query",
        "params": {
            "request_type": "call_function",
            "finality": "final",
            "account_id": contract_account_id,
            "method_name": entry_point,
            "args_base64": parse_args(args)
        }
    }
    try:
        r = requests.post(rpc_url, json=body)
        js = json.loads(r.content.decode())
        result = parse_result(js['result']['result'])
        if [91, 93] == js['result']['result']:
            return '[]'
        else:
            return result
    except : 
        return "{}"

def get_holder(holder_id : int) -> dict:
    return json.loads(query_contract("get_holder", {"holder_id" : holder_id}))

def get_owner_tokens(account_id : str) -> list:
    return json.loads(query_contract("get_owner_tokens", {"account_id" : account_id}))

def get_token_metadata(token_id : int) -> dict:
    return json.loads(query_contract("get_token_metadata", {"token_id" : token_id}))

def get_request(request_id : int) -> dict:
    return json.loads(query_contract("get_request", {"request_id" : request_id}))

def get_publisher_requests(publisher_account : str) -> list:
    return resify(json.loads(query_contract("get_publisher_requests", {"publisher_account" : publisher_account})))
    
def get_producer_requests(producer_account : str) -> list:
    ll = json.loads(query_contract("get_producer_requests", {"producer_account" : producer_account}))
    return resify(ll)

def get_approved(approved_id : int) -> dict:
    return json.loads(query_contract("get_approved", {"approved_id" : approved_id}))

def producers_approved(producer_account : str) -> list:
    return resify(json.loads(query_contract("producers_approved", {"producer_account" : producer_account})))

def publishers_approved(publisher_account : str) -> list:
    return resify(json.loads(query_contract("publishers_approved", {"publisher_account" : publisher_account})))

def return_state():
    producer_holder_ids = get_owner_tokens(producer_account)
    publisher_holder_ids = get_owner_tokens(publisher_account)
    customer_holder_ids = get_owner_tokens(customer_account)
    producer_holders = [{"holder_id" : holder_id , "holder" : get_holder(holder_id)} for holder_id in producer_holder_ids]
    publisher_holders = [{"holder_id" : holder_id , "holder" : get_holder(holder_id)} for holder_id in publisher_holder_ids]
    customer_holders = [{"holder_id" : holder_id , "holder" : get_holder(holder_id)} for holder_id in customer_holder_ids]
    producer_request_ids = json.loads("["+str(get_producer_requests(producer_account))[1:-2]+"]")
    publisher_request_ids = json.loads("["+str(get_publisher_requests(publisher_account))[1:-2]+"]")
    producer_approved_ids = producers_approved(producer_account)
    publisher_approved_ids = publishers_approved(publisher_account)
    producer_approved = [{"approved_id" : approved_id , "approved" : get_approved(approved_id)} for approved_id in producer_approved_ids]
    publisher_approved = [{"approved_id" : approved_id , "approved" : get_approved(approved_id)} for approved_id in publisher_approved_ids]
    return {
        "producer_holders" : producer_holders,
        "publisher_holders" : publisher_holders,
        "customer_holders" : customer_holders,
        "producer_requests" : producer_request_ids,
        "publisher_requests" : publisher_request_ids,
        "producer_approved" : producer_approved,
        "publisher_approved" : publisher_approved
    }

def print_state():
    print(highlight(json.dumps(return_state(), indent=4), lexers.JsonLexer(), formatters.TerminalFormatter()))

if __name__ == "__main__":
    print_state()

'''
'''--- droplinked-near/src/event_handler.rs ---
use near_sdk::env;

pub (crate) fn log(message: &str) {
    env::log_str(message);
}

pub struct MintEvent {
    pub token_id: String,
    pub holder_id: String,
    pub owner_id: String,
}

pub struct PublishRequestEvent {
    pub request_id : String,
    pub holder_id : String,
    pub owner_id : String,
    pub commission : String,
    pub publisher_id : String,
}

pub struct ApproveEvent {
    pub request_id : String,
    pub holder_id : String,
    pub owner_id : String,
    pub approved_id : String,
}

pub struct DisapproveEvent {
    pub approved_id : String,
    pub holder_id : String,
    pub owner_id : String,
}

pub struct CancelEvent {
    pub request_id : String,
    pub holder_id : String,
    pub owner_id : String,
}

// It should contain Mint, PublishRequest, Approve, Disapprove and Cancel event
pub enum DroplinkedEventData{
    Mint(MintEvent),
    PublishRequest(PublishRequestEvent),
    Approve(ApproveEvent),
    Disapprove(DisapproveEvent),
    Cancel(CancelEvent),
}

impl DroplinkedEventData{
    pub fn emit(&self){
        match self {
            DroplinkedEventData::Mint(mint_event) => {
                log(&format!("{{\"event_kind\":\"Mint\",\"token_id\":\"{}\",\"holder_id\":\"{}\",\"owner_id\":\"{}\"}}", mint_event.token_id, mint_event.holder_id, mint_event.owner_id));
            },
            DroplinkedEventData::PublishRequest(publish_request_event) => {
                log(&format!("{{\"event_kind\":\"PublishRequest\",\"request_id\":\"{}\",\"holder_id\":\"{}\",\"owner_id\":\"{}\",\"commission\":\"{}\",\"publisher_id\":\"{}\"}}", publish_request_event.request_id, publish_request_event.holder_id, publish_request_event.owner_id, publish_request_event.commission, publish_request_event.publisher_id));
            },
            DroplinkedEventData::Approve(approve_event) => {
                log(&format!("{{\"event_kind\":\"Approve\",\"request_id\":\"{}\",\"holder_id\":\"{}\",\"owner_id\":\"{}\",\"approved_id\":\"{}\"}}", approve_event.request_id, approve_event.holder_id, approve_event.owner_id, approve_event.approved_id));
            },
            DroplinkedEventData::Disapprove(disapprove_event) => {
                log(&format!("{{\"event_kind\":\"Disapprove\",\"approved_id\":\"{}\",\"holder_id\":\"{}\",\"owner_id\":\"{}\"}}", disapprove_event.approved_id, disapprove_event.holder_id, disapprove_event.owner_id));
            },
            DroplinkedEventData::Cancel(cancel_event) => {
                log(&format!("{{\"event_kind\":\"Cancel\",\"request_id\":\"{}\",\"holder_id\":\"{}\",\"owner_id\":\"{}\"}}", cancel_event.request_id, cancel_event.holder_id, cancel_event.owner_id));
            },
        }
    }    
}

'''
'''--- droplinked-near/src/lib.rs ---
mod event_handler;

use event_handler::{MintEvent, DroplinkedEventData, PublishRequestEvent, CancelEvent, DisapproveEvent, ApproveEvent};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, Vector};
use near_sdk::env::block_timestamp_ms;
use near_sdk::{env, near_bindgen, AccountId};

#[derive(BorshSerialize,BorshDeserialize)]
pub struct NFTMetadata{
    name : String,
    token_uri : String,
    checksum : String,
    price : u128
}

#[derive(BorshDeserialize,BorshSerialize)]
pub struct NFTHolder {
    rem_amount : u64,
    amount : u64,
    token_id : u64
}

#[derive(BorshDeserialize,BorshSerialize)]
pub struct ApprovedNFT{
    holder_id : u64,
    amount : u64,
    owner_account : AccountId,
    publisher_account : AccountId,
    token_id : u64,
    comission : u8
}

#[derive(BorshDeserialize,BorshSerialize)]
pub struct PublishRequest{
    holder_id : u64,
    amount : u64,
    comission : u8,
    producer : AccountId,
    publisher : AccountId
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct DroplinkedStorage {
    tokens_cnt : u64,
    holders_cnt : u64,
    approved_cnt : u64,
    request_cnt : u64,
    latest_timestamp : u64,
    ratio_verifier : AccountId,
    total_supply : u64,
    requests_objects : LookupMap<u64,PublishRequest>,
    publisher_rejects : LookupMap<AccountId,Vector<u64>>,
    producer_requests : LookupMap<AccountId, Vector<u64>>,
    publisher_requests : LookupMap<AccountId, Vector<u64>>,
    metadatas : LookupMap<u64, NFTMetadata>,
    producer_approved : LookupMap<AccountId,Vector<u64>>,
    publisher_approved : LookupMap<AccountId,Vector<u64>>,
    owners : LookupMap<AccountId,Vector<u64>>,
    holders : LookupMap<u64,NFTHolder>,
    approved : LookupMap<u64,ApprovedNFT>,
    token_id_by_hash : LookupMap<String,u64>
}

impl Default for DroplinkedStorage {
    fn default() -> Self {
        Self {
            tokens_cnt : 0,
            ratio_verifier : "k3rn3lpanicc.testnet".parse().unwrap(),
            metadatas : LookupMap::new(b"m".to_vec()),
            total_supply : 0,
            requests_objects : LookupMap::new(b"r".to_vec()),
            publisher_rejects : LookupMap::new(b"p".to_vec()),
            producer_requests : LookupMap::new(b"q".to_vec()),
            producer_approved : LookupMap::new(b"t".to_vec()),
            publisher_approved : LookupMap::new(b"x".to_vec()),
            owners : LookupMap::new(b"n".to_vec()),
            holders : LookupMap::new(b"k".to_vec()),
            approved : LookupMap::new(b"o".to_vec()),
            token_id_by_hash : LookupMap::new(b"l".to_vec()),
            publisher_requests : LookupMap::new(b"y".to_vec()),
            holders_cnt : 0,
            approved_cnt : 0,
            request_cnt : 0,
            latest_timestamp : 0
        }
    }
}

#[near_bindgen]
impl DroplinkedStorage {
    pub fn get_ratio_verifier(self) -> AccountId{
        self.ratio_verifier
    }

    #[payable]
    pub fn mint(&mut self, name : String, token_uri : String, checksum : String, price : u128,amount : u64) -> u64{
        if near_sdk::env::attached_deposit() < 780000000000000000000{
            near_sdk::env::panic_str("deposit is too low");
        }
        let account_id = env::signer_account_id();
        let metadata_hash = base16::encode_lower(&env::sha256(format!("{}{}{}{}",name,token_uri,checksum,price).as_bytes()));
        let token_id = {
            if self.token_id_by_hash.contains_key(&metadata_hash){
                self.token_id_by_hash.get(&metadata_hash).unwrap()
            }
            else{
                self.tokens_cnt+=1;
                self.token_id_by_hash.insert(&metadata_hash,&self.tokens_cnt);
                self.tokens_cnt
            }
        };
        let metadata = NFTMetadata{
            name,
            token_uri,
            checksum,
            price
        };
        self.metadatas.insert(&token_id,&metadata);
        
        // check if holders exist for this account if not create new
        if !self.owners.contains_key(&account_id){
            let tokens = Vector::new(format!("s{}",block_timestamp_ms()).as_str().as_bytes().to_vec());
            self.owners.insert(&account_id,&tokens);
        }
        let account_holders = self.owners.get(&account_id).unwrap();
        for i in 0..account_holders.len(){
            let holder_id = account_holders.get(i).unwrap();
            let mut t = self.holders.get(&holder_id).unwrap();
            if t.token_id == token_id{
                t.rem_amount += amount;
                t.amount += amount;
                self.holders.insert(&holder_id,&t);
                return holder_id;
            }
        }
        
        self.holders_cnt += 1;
        let holder_id = self.holders_cnt;
        let holder = NFTHolder{
            rem_amount : amount,
            amount,
            token_id
        };
        
        self.holders.insert(&holder_id,&holder);
        if self.owners.contains_key(&account_id){
            let mut tokens = self.owners.get(&account_id).unwrap();
            tokens.push(&holder_id);
            self.owners.insert(&account_id,&tokens);
        }
        else{
            let mut tokens = Vector::new(format!("n{}",block_timestamp_ms()).as_str().as_bytes().to_vec());
            tokens.push(&holder_id);
            self.owners.insert(&account_id,&tokens);
        }
        self.total_supply += amount;
        DroplinkedEventData::Mint(MintEvent {token_id : token_id.to_string(),holder_id : holder_id.to_string(),owner_id:account_id.to_string() }).emit();
        holder_id
    }

    pub fn get_owner_tokens(&self, account_id : AccountId) -> Vec<u64>{
        if self.owners.contains_key(&account_id){
            self.owners.get(&account_id).unwrap().to_vec()
        }
        else{
            vec![]
        }
    }

    pub fn get_token_id_by_hash(&self, hash : String) -> Option<u64>{
        self.token_id_by_hash.get(&hash)
    }

    pub fn get_token_hash_by_id(&self, token_id : u64) -> Option<String>{
        let metadata = self.metadatas.get(&token_id).unwrap();
        
        let hash = base16::encode_lower(&env::sha256(format!("{}{}{}{}",metadata.name,metadata.token_uri,metadata.checksum,metadata.price).as_bytes()));
        Some(hash)
    }

    pub fn get_token_metadata(&self, token_id : u64) -> Option<String>{
        let metadata = self.metadatas.get(&token_id).unwrap();
        let json = format!(r#"{{"name":"{}","token_uri":"{}","checksum":"{}","price":{}}}"#,metadata.name,metadata.token_uri,metadata.checksum,metadata.price);
        Some(json)
    }

    pub fn get_holder(&self, holder_id : u64) -> Option<String>{
        let holder = self.holders.get(&holder_id).unwrap();
        let json = format!(r#"{{"rem_amount":{},"amount":{},"token_id":{}}}"#,holder.rem_amount,holder.amount,holder.token_id);
        Some(json)
    }

    #[payable]
    pub fn publish_request(&mut self, producer_account : AccountId, amount : u64, holder_id : u64, comission : u8) -> u64{
        if env::attached_deposit() < 630000000000000000000 {
            env::panic_str("deposit is too low");
        }
        let account_id = env::signer_account_id();
        
        //-----------------------Cand be simplified using Maps and Sets-----------------------
        // if producer_account is not owner of holder_id then return error
        let producer_holders = self.owners.get(&producer_account).unwrap();
        let mut is_producer_owner = false;
        for i in 0..producer_holders.len(){
            if producer_holders.get(i).unwrap() == holder_id{
                is_producer_owner = true;
                break;
            }
        }
        if !is_producer_owner{
            env::panic_str("Producer is not owner of holder_id");
        }
        //-----------------------------------------------------------------------------------
        
        let request_id = self.request_cnt + 1;
        let request = PublishRequest{
            amount,
            holder_id,
            comission,
            producer : producer_account.clone(),
            publisher : account_id.clone()
        };
        self.requests_objects.insert(&request_id,&request);
        self.request_cnt = request_id;
        // add request_id to publisher_requests and producer_requests
        if self.publisher_requests.contains_key(&account_id){
            let mut requests = self.publisher_requests.get(&account_id).unwrap();
            requests.push(&request_id);
            self.publisher_requests.insert(&account_id,&requests);
        }
        else{
            let mut requests = Vector::new(format!("y{}",block_timestamp_ms()).as_str().as_bytes().to_vec());
            requests.push(&request_id);
            self.publisher_requests.insert(&account_id,&requests);
        }
        if self.producer_requests.contains_key(&producer_account){
            let mut requests = self.producer_requests.get(&producer_account).unwrap();
            requests.push(&request_id);
            self.producer_requests.insert(&producer_account,&requests);
        }
        else{
            let mut requests = Vector::new(format!("z{}",block_timestamp_ms()).as_str().as_bytes().to_vec());
            requests.push(&request_id);
            self.producer_requests.insert(&producer_account,&requests);
        }
        // emit event
        DroplinkedEventData::PublishRequest(PublishRequestEvent { request_id: request_id.to_string(), holder_id: holder_id.to_string(), owner_id : request.producer.to_string(), commission : comission.to_string(), publisher_id : request.publisher.to_string()}).emit();
        request_id       
    }

    pub fn get_request(&self, request_id : u64) -> Option<String>{
        let request = self.requests_objects.get(&request_id).unwrap();
        let json = format!(r#"{{"amount":{},"holder_id":{},"comission":{},"producer":"{}","publisher":"{}"}}"#,request.amount,request.holder_id,request.comission,request.producer,request.publisher);
        Some(json)
    }

    pub fn get_publisher_requests(&self, publisher_account : AccountId) -> Option<String>{
        let mut json = String::from("[");
        if self.publisher_requests.contains_key(&publisher_account){
            let requests = self.publisher_requests.get(&publisher_account).unwrap();
            for request_id in requests.iter(){
                let request = self.requests_objects.get(&request_id).unwrap();
                let json_part = format!(r#"{{"request_id":{},"amount":{},"holder_id":{},"comission":{},"producer":"{}","publisher":"{}"}},"#,request_id,request.amount,request.holder_id,request.comission,request.producer,request.publisher);
                json.push_str(&json_part);
            }
        }
        json.push_str("]");
        Some(json)
    }

    pub fn get_producer_requests(&self, producer_account : AccountId) -> Option<String>{
        let mut json = String::from("[");
        if self.producer_requests.contains_key(&producer_account){
            let requests = self.producer_requests.get(&producer_account).unwrap();
            for request_id in requests.iter(){
                let request = self.requests_objects.get(&request_id).unwrap();
                let json_part = format!(r#"{{"request_id":{},"amount":{},"holder_id":{},"comission":{},"producer":"{}","publisher":"{}"}},"#,request_id,request.amount,request.holder_id,request.comission,request.producer,request.publisher);
                json.push_str(&json_part);
            }
        }
        json.push_str("]");
        Some(json)
    }

    #[payable]
    pub fn approve(&mut self,request_id : u64) -> u64{
        if env::attached_deposit() < 770000000000000000000 {
            env::panic_str("deposit is too low");
        }
        let account_id = env::signer_account_id();
        let request_wrapped = self.requests_objects.get(&request_id);
        if request_wrapped.is_none(){
            env::panic_str("Request does not exist");
        }
        let request = request_wrapped.unwrap();
        if request.producer != account_id{
            env::panic_str("Caller is not producer");
        }
        
        // check if caller owns holder_id
        let producer_holders = self.owners.get(&account_id).unwrap();
        let mut is_producer_owner = false;
                
        for i in 0..producer_holders.len(){
            if producer_holders.get(i).unwrap() == request.holder_id{
                is_producer_owner = true;
                break;
            }
        }
        if !is_producer_owner{
            env::panic_str("Producer is not owner of holder_id");
        }

        let mut holder = self.holders.get(&request.holder_id).unwrap();
        if holder.rem_amount < request.amount{
            env::panic_str("Not enough tokens in holder");
        }
        holder.rem_amount -= request.amount;
        let approved_holder = ApprovedNFT {
            holder_id : request.holder_id,
            amount : request.amount,
            comission : request.comission,
            owner_account : request.producer.clone(),
            publisher_account : request.publisher.clone(),
            token_id : holder.token_id
        };
        self.holders.insert(&request.holder_id,&holder);

        // get approved cnt and increment it
        self.approved_cnt += 1;
        let approved_id = self.approved_cnt;
        self.approved.insert(&approved_id,&approved_holder);

        //add the approved holder to the publishers approved dictionary
        if self.publisher_approved.contains_key(&request.publisher){
            let mut approved = self.publisher_approved.get(&request.publisher).unwrap();
            approved.push(&approved_id);
            self.publisher_approved.insert(&request.publisher,&approved);
        }
        else{
            let mut approved = Vector::new(format!("x{}",block_timestamp_ms()).as_str().as_bytes().to_vec());
            approved.push(&approved_id);
            self.publisher_approved.insert(&request.publisher,&approved);
        }
        //add the approved holder to the producers approved dictionary
        if self.producer_approved.contains_key(&request.producer){
            let mut approved = self.producer_approved.get(&request.producer).unwrap();
            approved.push(&approved_id);
            self.producer_approved.insert(&request.producer,&approved);
        }
        else{
            let mut approved = Vector::new(format!("y{}",block_timestamp_ms()).as_str().as_bytes().to_vec());
            approved.push(&approved_id);
            self.producer_approved.insert(&request.producer,&approved);
        }
        //remove the request from the publishers requests dictionary and the producers requests dictionary
        let mut publisher_requests = self.publisher_requests.get(&request.publisher).unwrap();
        let index_of_request = publisher_requests.iter().position(|x| x == request_id).unwrap();
        publisher_requests.swap_remove(index_of_request as u64);
        self.publisher_requests.insert(&request.publisher,&publisher_requests);
        let mut producer_requests = self.producer_requests.get(&request.producer).unwrap();
        let index_of_request = producer_requests.iter().position(|x| x == request_id).unwrap();
        producer_requests.swap_remove(index_of_request as u64);
        self.producer_requests.insert(&request.producer,&producer_requests);
        //remove the request from the requests_objects dictionary
        self.requests_objects.remove(&request_id);
        // emit event
        DroplinkedEventData::Approve(ApproveEvent{approved_id : approved_id.to_string(), holder_id : request.holder_id.to_string(), request_id : request_id.to_string(), owner_id : request.producer.to_string()}).emit();
        approved_id
    }
    

    pub fn get_approved(&self, approved_id : u64) -> Option<String>{
        let approved = self.approved.get(&approved_id).unwrap();
        let json = format!(r#"{{"approved_id":{},"holder_id":{},"amount":{},"comission":{},"owner_account":"{}","publisher_account":"{}","token_id":{}}}"#,approved_id,approved.holder_id,approved.amount,approved.comission,approved.owner_account,approved.publisher_account,approved.token_id);
        Some(json)
    }

    #[payable]
    pub fn disapprove(&mut self,approved_id : u64, amount : u64){
        if  env::attached_deposit() < 600000000000000000000 {
            env::panic_str("deposit is too low");
        }
        let account_id = env::signer_account_id();
        let approved = self.approved.get(&approved_id).unwrap();
        if approved.owner_account != account_id{
            env::panic_str("Caller is not owner");
        }
        if approved.amount < amount{
            env::panic_str("Not enough tokens in approved");
        }
        let mut holder = self.holders.get(&approved.holder_id).unwrap();
        holder.rem_amount += amount;
        self.holders.insert(&approved.holder_id,&holder);
        if approved.amount == amount{
            self.approved.remove(&approved_id);
            let mut producer_approved = self.producer_approved.get(&approved.owner_account).unwrap();
            let index_of_approved = producer_approved.iter().position(|x| x == approved_id).unwrap();
            producer_approved.swap_remove(index_of_approved as u64);
            self.producer_approved.insert(&approved.owner_account,&producer_approved);
            let mut publisher_approved = self.publisher_approved.get(&approved.publisher_account).unwrap();
            let index_of_approved = publisher_approved.iter().position(|x| x == approved_id).unwrap();
            publisher_approved.swap_remove(index_of_approved as u64);
            self.publisher_approved.insert(&approved.publisher_account,&publisher_approved);
        }
        else{
            let mut approved = self.approved.get(&approved_id).unwrap();
            approved.amount -= amount;
            self.approved.insert(&approved_id,&approved);
        }
        // emit event
        DroplinkedEventData::Disapprove(DisapproveEvent {approved_id : approved_id.to_string(), holder_id : approved.holder_id.to_string(), owner_id : env::signer_account_id().to_string()}).emit();
    }

    #[payable]
    pub fn cancel_request(&mut self,request_id : u64){
        //TODO this amount should be calculated again
        if env::attached_deposit() < 570000000000000000000{
            env::panic_str("deposit is too low");
        }
        let account_id = env::signer_account_id();
        let request = self.requests_objects.get(&request_id).unwrap();
        if request.publisher != account_id{
            env::panic_str("Caller is not producer");
        }
        let mut producer_requests = self.producer_requests.get(&request.producer).unwrap();
        let index_of_request = producer_requests.iter().position(|x| x == request_id).unwrap();
        producer_requests.swap_remove(index_of_request as u64);
        self.producer_requests.insert(&request.producer,&producer_requests);
        let mut publisher_requests = self.publisher_requests.get(&request.publisher).unwrap();
        let index_of_request = publisher_requests.iter().position(|x| x == request_id).unwrap();
        publisher_requests.swap_remove(index_of_request as u64);
        self.publisher_requests.insert(&request.publisher,&publisher_requests);
        self.requests_objects.remove(&request_id);
        // emit event
        DroplinkedEventData::Cancel(CancelEvent { request_id: request_id.to_string(), holder_id: request.holder_id.to_string(), owner_id: request.producer.to_string() }).emit();
    }

    pub fn producers_approved(&self, producer_account : AccountId) -> Option<Vec<u64>>{
        Some(self.producer_approved.get(&producer_account).unwrap().to_vec())
    }
    pub fn publishers_approved(&self, publisher_account : AccountId) -> Option<Vec<u64>>{
        Some(self.publisher_approved.get(&publisher_account).unwrap().to_vec())
    }
    
    // next function is buy function, it is used to buy tokens from approved holders, it is called by user who wants to buy tokens, it takes approved_id and amount of tokens to buy the "price,timestamp" and a signature of that price and timestamp which is signed by the ratio_verifier account
    // and checks if the signature is true, then gets amount*ratio NEARs from the user and sends them to the producer, and publisher with the comission, and sends the tokens to the user
    // #[payable]
    // pub fn buy(&mut self, approved_id : u64, amount : u64, price : u128, timestamp : u64, signature : String){
    //     let account_id = env::signer_account_id();
    //     let approved = self.approved.get(&approved_id).unwrap();
    //     if approved.amount < amount{
    //         env::panic_str("Not enough tokens in approved");
    //     }
    //     let mut holder = self.holders.get(&approved.holder_id).unwrap();
        
    //     // TODO: check the signature
        
        

    // }
}
'''