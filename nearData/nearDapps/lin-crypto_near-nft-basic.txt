*GitHub Repository "lin-crypto/near-nft-basic"*

'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: nvm use default && npm install near-cli -g --no-optional
    init: yarn && brew install tree
    command: clear && echo Explore non-fungible tokens on NEAR Protocol

'''
'''--- Cargo.toml ---
[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "nft",
  "test-approval-receiver",
  "test-token-receiver",
]
exclude  = [
  "integration-tests"
]
'''
'''--- README.md ---
# NFT Basic on NEAR Protocol

## Prerequisites
  * Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs).
  * Make sure [near-cli](https://github.com/near/near-cli) is installed.

## Build
```batch
build.bat
```

## Test
```bash
cargo test -- --nocapture
```
'''
'''--- integration-tests/rs/Cargo.toml ---
[package]
name = "non-fungible-token-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.4.0"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- integration-tests/rs/src/tests.rs ---
use near_units::{parse_gas, parse_near};
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};

const NFT_WASM_FILEPATH: &str = "../../res/non_fungible_token.wasm";
const TR_WASM_FILEPATH: &str = "../../res/token_receiver.wasm";
const AR_WASM_FILEPATH: &str = "../../res/approval_receiver.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // initiate environemnt
    let worker = workspaces::sandbox().await?;

    // deploy contracts
    let nft_wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let nft_contract = worker.dev_deploy(&nft_wasm).await?;
    let tr_wasm = std::fs::read(TR_WASM_FILEPATH)?;
    let tr_contract = worker.dev_deploy(&tr_wasm).await?;
    let ar_wasm = std::fs::read(AR_WASM_FILEPATH)?;
    let ar_contract = worker.dev_deploy(&ar_wasm).await?;

    // create accounts
    let owner = worker.root_account().unwrap();
    let alice = owner
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize contracts
    nft_contract
        .call(&worker, "new_default_meta")
        .args_json(serde_json::json!({
            "owner_id": owner.id()
        }))?
        .transact()
        .await?;
    tr_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({
            "non_fungible_token_account_id": nft_contract.id()
        }))?
        .transact()
        .await?;
    ar_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({
            "non_fungible_token_account_id": nft_contract.id()
        }))?
        .transact()
        .await?;

    // begin tests
    test_simple_approve(&owner, &alice, &nft_contract, &worker).await?;
    test_approval_simple_call(&owner, &nft_contract, &ar_contract, &worker).await?;
    test_approved_account_transfers_token(&owner, &alice, &nft_contract, &worker).await?;
    test_revoke(&owner, &alice, &nft_contract, &tr_contract, &worker).await?;
    test_revoke_all(&owner, &alice, &nft_contract, &tr_contract, &worker).await?;
    test_simple_transfer(&owner, &alice, &nft_contract, &worker).await?;
    test_transfer_call_fast_return_to_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_slow_return_to_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_fast_keep_with_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_slow_keep_with_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_receiver_panics(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_enum_total_supply(&nft_contract, &worker).await?;
    test_enum_nft_tokens(&nft_contract, &worker).await?;
    test_enum_nft_supply_for_owner(&owner, &alice, &nft_contract, &worker).await?;
    test_enum_nft_tokens_for_owner(&owner, &alice, &nft_contract, &worker).await?;
    Ok(())
}

async fn test_simple_approve(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "0",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons",
                "description": "The tallest mountain in the charted solar system",
                "copies": 10000,
            }
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    // root approves alice
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id":  "0",
            "account_id": user.id(),
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    let approval_no_id: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;

    assert!(approval_no_id);

    let approval: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id(),
            "approval_id": 1
        }))?
        .transact()
        .await?
        .json()?;

    assert!(approval);

    let approval_wrong_id: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id(),
            "approval_id": 2
        }))?
        .transact()
        .await?
        .json()?;

    assert!(!approval_wrong_id);
    println!("      Passed ✅ test_simple_approve");
    Ok(())
}

async fn test_approval_simple_call(
    owner: &Account,
    nft_contract: &Contract,
    approval_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "1",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 2",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    let outcome: String = owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": approval_receiver.id(),
            "msg": "return-now"
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?
        .json()?;
    assert_eq!("cool", outcome);

    let msg = "test message";
    let outcome: String = owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": approval_receiver.id(),
            "msg": msg.clone(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?
        .json()?;
    assert_eq!(msg, outcome);

    println!("      Passed ✅ test_approval_simple_call");
    Ok(())
}

async fn test_approved_account_transfers_token(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer")
        .args_json(json!({
            "receiver_id": user.id(),
            "token_id": '0',
            "approval_id": 1,
            "memo": "message for test 3",
        }))?
        .deposit(1)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "0"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(user.id().to_string())));

    println!("      Passed ✅ test_approved_account_transfers_token");
    Ok(())
}

async fn test_revoke(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    token_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root approves token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root revokes user
    owner
        .call(&worker, nft_contract.id(), "nft_revoke")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    // assert user is revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    // assert token receiver still approved
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    // root revokes token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_revoke")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    // assert alice is still revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    // and now so is token_receiver
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    println!("      Passed ✅ test_revoke");
    Ok(())
}

async fn test_revoke_all(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    token_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    // root approves alice
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root approves token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // assert everyone is revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    println!("      Passed ✅ test_revoke_all");
    Ok(())
}

async fn test_simple_transfer(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "1"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    owner
        .call(&worker, nft_contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "1",
            "receiver_id": user.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "1"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(user.id().to_string())));

    println!("      Passed ✅ test_simple_transfer");
    Ok(())
}

async fn test_transfer_call_fast_return_to_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 3",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "return-it-now",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_fast_return_to_sender");
    Ok(())
}

async fn test_transfer_call_slow_return_to_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "return-it-later",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_slow_return_to_sender");
    Ok(())
}

async fn test_transfer_call_fast_keep_with_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "keep-it-now",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(
        token.get("owner_id"),
        Some(&String(token_receiver.id().to_string()))
    );

    println!("      Passed ✅ test_transfer_call_fast_keep_with_sender");
    Ok(())
}

async fn test_transfer_call_slow_keep_with_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "3",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 4",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "3",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "keep-it-later",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "3"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(
        token.get("owner_id"),
        Some(&String(token_receiver.id().to_string()))
    );

    println!("      Passed ✅ test_transfer_call_slow_keep_with_sender");
    Ok(())
}

async fn test_transfer_call_receiver_panics(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "4",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 5",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "4",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "incorrect message",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "4"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_receiver_panics");
    Ok(())
}

async fn test_enum_total_supply(
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let supply: String = nft_contract
        .call(&worker, "nft_total_supply")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(supply, "5");

    println!("      Passed ✅ test_enum_total_supply");
    Ok(())
}

async fn test_enum_nft_tokens(
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(tokens.len(), 5);

    println!("      Passed ✅ test_enum_nft_tokens");
    Ok(())
}

async fn test_enum_nft_supply_for_owner(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let owner_tokens: String = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json(json!({"account_id": owner.id()}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(owner_tokens, "1");

    let user_tokens: String = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json(json!({"account_id": user.id()}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(user_tokens, "2");

    println!("      Passed ✅ test_enum_nft_supply_for_owner");
    Ok(())
}

async fn test_enum_nft_tokens_for_owner(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json(json!({
            "account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 2);

    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json(json!({
            "account_id": owner.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 1);
    println!("      Passed ✅ test_enum_nft_tokens_for_owner");
    Ok(())
}

'''
'''--- integration-tests/ts/package.json ---
{
  "name": "non-fungible-token-integration-tests-ts",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava --verbose"
  },
  "devDependencies": {
    "ava": "^4.2.0",
    "near-workspaces": "^3.1.0",
    "typescript": "^4.6.4",
    "ts-node": "^10.8.0",
    "@types/bn.js": "^5.1.0"
  },
  "dependencies": {}
}

'''
'''--- integration-tests/ts/src/main.ava.ts ---
import { Worker, NearAccount, tGas, NEAR, BN } from 'near-workspaces';
import anyTest, { TestFn } from 'ava';
import { mint_more, nft_total_supply } from './utils';

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;
    const nft = await root.devDeploy(
        '../../res/non_fungible_token.wasm',
        {
            initialBalance: NEAR.parse('100 N').toJSON(),
            method: "new_default_meta",
            args: { owner_id: root }
        },
    );
    await root.call(
        nft,
        "nft_mint",
        {
            token_id: "0",
            receiver_id: root,
            token_metadata: {
                title: "Olympus Mons",
                description: "The tallest mountain in the charted solar system",
                media: null,
                media_hash: null,
                copies: 10000,
                issued_at: null,
                expires_at: null,
                starts_at: null,
                updated_at: null,
                extra: null,
                reference: null,
                reference_hash: null,
            }
        },
        { attachedDeposit: '7000000000000000000000' }
    );

    const alice = await root.createSubAccount('alice', { initialBalance: NEAR.parse('100 N').toJSON() });

    const tokenReceiver = await root.devDeploy(
        '../../res/token_receiver.wasm',
        {
            initialBalance: NEAR.parse('100 N').toJSON(),
            method: "new",
            args: { non_fungible_token_account_id: nft },
        }
    );

    const approvalReceiver = await root.devDeploy(
        '../../res/approval_receiver.wasm',
        {
            initialBalance: NEAR.parse('100 N').toJSON(),
            method: "new",
            args: { non_fungible_token_account_id: nft },
        }
    );

    t.context.worker = worker;
    t.context.accounts = { root, alice, nft, tokenReceiver, approvalReceiver };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Simple approve', async test => {
    const { root, alice, nft, tokenReceiver } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,
        },
        {
            attachedDeposit: new BN('270000000000000000000'), // need more deposit than the sim-tests, cause names are longer
            gas: tGas('150')
        },
    );

    // check nft_is_approved, don't provide approval_id
    test.assert(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
            })
    );

    // check nft_is_approved, with approval_id=1
    test.assert(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 1,
            })
    );

    // check nft_is_approved, with approval_id=2
    test.false(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 2,
            })
    );

    // alternatively, one could check the data returned by nft_token
    const token: any = await nft.view('nft_token', { token_id: '0', });
    test.deepEqual(token.approved_account_ids, { [alice.accountId]: 1 })

    // root approves alice again, which changes the approval_id and doesn't require as much deposit
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,
        },
        { attachedDeposit: '1', gas: tGas('150') }
    );

    test.true(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 2,
            },
        )
    );

    // approving another account gives different approval_id
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        // note that token_receiver's account name is longer, and so takes more bytes to store and
        // therefore requires a larger deposit!
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    test.true(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: tokenReceiver,
                approval_id: 3,
            })
    );
});

test('Approval with call', async test => {
    const { root, nft, approvalReceiver } = test.context.accounts;
    let outcome: string = await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: approvalReceiver,
            msg: 'return-now',
        },
        { attachedDeposit: new BN('390000000000000000000'), gas: tGas('150') },
    );

    test.is(outcome, 'cool');

    const msg = 'hahaha';
    outcome = await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: approvalReceiver,
            msg: msg,
        },
        { attachedDeposit: new BN('390000000000000000000'), gas: tGas('150') },
    );
    test.is(outcome, msg);
});

test('Approved account transfers token', async test => {
    const { root, alice, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    await alice.call(
        nft,
        'nft_transfer',
        {
            receiver_id: alice,
            token_id: '0',
            approval_id: 1,
            memo: 'gotcha! bahahaha',
        },
        { attachedDeposit: '1', gas: tGas('150') }
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, alice.accountId);
});

test('Revoke', async test => {
    const { root, alice, tokenReceiver, nft } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    // root approves token_receiver
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    // root revokes alice
    await root.call(nft, 'nft_revoke', { token_id: '0', account_id: alice }, { attachedDeposit: '1' });

    // alice is revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );

    // but token_receiver is still approved
    test.true(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );

    // root revokes token_receiver
    await root.call(nft, 'nft_revoke', { token_id: '0', account_id: tokenReceiver }, { attachedDeposit: '1' });

    // alice is still revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );

    // ...and now so is token_receiver
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );
})

test('Revoke all', async test => {
    const { root, alice, tokenReceiver, nft } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    // root approves token_receiver
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    await root.call(nft, 'nft_revoke_all', { token_id: '0' }, { attachedDeposit: '1' });

    // everyone revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );
})

test('Simple transfer', async test => {
    const { root, alice, nft } = test.context.accounts;
    let token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);

    const result = await root.callRaw(
        nft,
        'nft_transfer',
        {
            receiver_id: alice,
            token_id: '0',
            memo: "simple transfer",
        },
        { attachedDeposit: '1' },
    );
    test.assert(result.succeeded);
    token = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, alice.accountId);
});

test('Transfer call fast return to sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'return-it-now',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Transfer call slow return to sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'return-it-later',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Transfer call fast keep with sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'keep-it-now',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, tokenReceiver.accountId);
});

test('Transfer call slow keep with sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            approval_id: null,
            memo: 'transfer & call',
            msg: 'keep-it-later',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, tokenReceiver.accountId);
});

test('Transfer call receiver panics', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            approval_id: null,
            memo: 'transfer & call',
            msg: 'incorrect message',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Enum total supply', async test => {
    const { root, alice, nft } = test.context.accounts;
    await mint_more(root, nft);

    const total_supply = await nft_total_supply(nft, alice);
    test.deepEqual(total_supply, new BN(4));
});

test('Enum nft tokens', async test => {
    const { root, nft } = test.context.accounts;
    await mint_more(root, nft);

    // No optional args should return all
    let tokens: any[] = await nft.view('nft_tokens');
    test.is(tokens.length, 4);

    // Start at "1", with no limit arg
    tokens = await nft.view('nft_tokens', { from_index: '1' });
    test.is(tokens.length, 3);
    test.is(tokens[0].token_id, '1');
    test.is(tokens[1].token_id, '2');
    test.is(tokens[2].token_id, '3');

    // Start at "2", with limit 1
    tokens = await nft.view('nft_tokens', { from_index: '2', limit: 1 });
    test.is(tokens.length, 1);
    test.is(tokens[0].token_id, '2');

    // Don't specify from_index, but limit 2
    tokens = await nft.view('nft_tokens', { limit: 2 });
    test.is(tokens.length, 2);
    test.is(tokens[0].token_id, '0');
    test.is(tokens[1].token_id, '1');
});

test('Enum nft supply for owner', async test => {
    const { root, alice, nft } = test.context.accounts;
    // Get number from account with no NFTs
    let ownerNumTokens: BN = new BN(await nft.view('nft_supply_for_owner', { account_id: alice }));
    test.deepEqual(ownerNumTokens, new BN(0));

    ownerNumTokens = new BN(await nft.view('nft_supply_for_owner', { account_id: root }));
    test.deepEqual(ownerNumTokens, new BN(1));

    await mint_more(root, nft);

    ownerNumTokens = new BN(await nft.view('nft_supply_for_owner', { account_id: root }));
    test.deepEqual(ownerNumTokens, new BN(4));
});

test('Enum nft tokens for owner', async test => {
    const { root, alice, nft } = test.context.accounts;
    await mint_more(root, nft);

    // Get tokens from account with no NFTs
    let ownerTokens: any[] = await nft.view('nft_tokens_for_owner', { account_id: alice });
    test.deepEqual(ownerTokens.length, 0);

    // Get tokens with no optional args
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root });
    test.deepEqual(ownerTokens.length, 4);

    // With from_index and no limit
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, from_index: new BN(2) });
    test.deepEqual(ownerTokens.length, 2);
    test.is(ownerTokens[0].token_id, '2');
    test.is(ownerTokens[1].token_id, '3');

    // With from_index and limit 1
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, from_index: new BN(1), limit: 1 });
    test.deepEqual(ownerTokens.length, 1);
    test.is(ownerTokens[0].token_id, '1');

    // No from_index but limit 3
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, limit: 3 });
    test.deepEqual(ownerTokens.length, 3);
    test.is(ownerTokens[0].token_id, '0');
    test.is(ownerTokens[1].token_id, '1');
    test.is(ownerTokens[2].token_id, '2');
});
'''
'''--- integration-tests/ts/src/utils.ts ---
import { NearAccount, BN } from 'near-workspaces';

export async function helper_mint(
    token_id: string,
    root: NearAccount,
    nft: NearAccount,
    title: String,
    desc: String) {
    await root.call(
        nft,
        "nft_mint",
        {
            token_id: token_id,
            receiver_id: root,
            token_metadata: {
                title: title,
                description: desc,
                media: null,
                media_hash: null,
                copies: 1,
                issued_at: null,
                expires_at: null,
                starts_at: null,
                updated_at: null,
                extra: null,
                reference: null,
                reference_hash: null,
            }
        },
        { attachedDeposit: '7000000000000000000000' }
    )
}
export async function mint_more(root: NearAccount, nft: NearAccount) {
    await helper_mint(
        "1",
        root,
        nft,
        "Black as the Night",
        "In charcoal"
    );
    await helper_mint(
        "2",
        root,
        nft,
        "Hamakua",
        "Vintage recording"
    );
    await helper_mint(
        "3",
        root,
        nft,
        "Aloha ke akua",
        "Original with piano"
    );
}

export async function nft_total_supply(nft: NearAccount, user: NearAccount): Promise<BN> {
    return new BN(await nft.view('nft_total_supply'));
}

'''
'''--- nft/Cargo.toml ---
[package]
name = "non-fungible-token"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens.mint(token_id, receiver_id, Some(token_metadata))
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}
'''
'''--- res/README.md ---
# Folder that contains wasm files
'''
'''--- scripts/build.bat ---
@echo off

cd ..
title NFT build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- scripts/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"/..
source scripts/flags.sh
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/
'''
'''--- scripts/flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- test-approval-receiver/Cargo.toml ---
[package]
name = "approval-receiver"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- test-approval-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_approve for simulation testing nft_approve.
*/
use near_contract_standards::non_fungible_token::approval::NonFungibleTokenApprovalReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, PanicOnDefault,
    PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ApprovalReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String>;
}

#[near_bindgen]
impl ApprovalReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id: non_fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl NonFungibleTokenApprovalReceiver for ApprovalReceiver {
    /// Could do anything useful to the approval-receiving contract, such as store the given
    /// approval_id for use later when calling the NFT contract. Can also return whatever it wants,
    /// maybe after further promise calls. This one simulates "return anything" behavior only.
    /// Supports the following `msg` patterns:
    /// * "return-now" - immediately return `"cool"`
    /// * anything else - return the given `msg` after one more cross-contract call
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) -> PromiseOrValue<String> {
        // Verifying that we were called by non-fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_approve; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &token_id,
            &owner_id,
            &approval_id,
            msg
        );
        match msg.as_str() {
            "return-now" => PromiseOrValue::Value("cool".to_string()),
            _ => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(msg).into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for ApprovalReceiver {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String> {
        log!("in ok_go, msg={}", msg);
        PromiseOrValue::Value(msg)
    }
}
'''
'''--- test-token-receiver/Cargo.toml ---
[package]
name = "token-receiver"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- test-token-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_transfer for simulation testing nft_transfer_call.
*/
use near_contract_standards::non_fungible_token::core::NonFungibleTokenReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, PanicOnDefault,
    PromiseOrValue,
};
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool>;
}

#[near_bindgen]
impl TokenReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id: non_fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl NonFungibleTokenReceiver for TokenReceiver {
    /// Returns true if token should be returned to `sender_id`
    /// Four supported `msg`s:
    /// * "return-it-now" - immediately return `true`
    /// * "keep-it-now" - immediately return `false`
    /// * "return-it-later" - make cross-contract call which resolves with `true`
    /// * "keep-it-later" - make cross-contract call which resolves with `false`
    /// Otherwise panics, which should also return token to `sender_id`
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool> {
        // Verifying that we were called by non-fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_transfer; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &sender_id,
            &previous_owner_id,
            &token_id,
            msg
        );
        match msg.as_str() {
            "return-it-now" => PromiseOrValue::Value(true),
            "return-it-later" => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(true).into()
            }
            "keep-it-now" => PromiseOrValue::Value(false),
            "keep-it-later" => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(false).into()
            }
            _ => env::panic_str("unsupported msg"),
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for TokenReceiver {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool> {
        log!("in ok_go, return_it={}", return_it);
        PromiseOrValue::Value(return_it)
    }
}
'''