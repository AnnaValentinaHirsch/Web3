*GitHub Repository "nearprotocol/wasm-mock-vm"*

'''--- .appveyor.yml ---
install:
  - appveyor-retry appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe
  - if not defined RUSTFLAGS rustup-init.exe -y --default-host x86_64-pc-windows-msvc --default-toolchain nightly
  - set PATH=%PATH%;C:\Users\appveyor\.cargo\bin
  - rustc -V
  - cargo -V

build: false

test_script:
  - cargo test --locked

'''
'''--- .github/nodejs.yml ---
name: Node CI

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [12.x]

    steps:
    - uses: actions/checkout@v1
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v1
      with:
        node-version: ${{ matrix.node-version }}
    - name: npm install, build, and test
      run: |
        yarn install
        yarn build
        yarn test
      env:
        CI: true

'''
'''--- .github/workflows/nodejs.yml ---
name: Node.js CI

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [12.x]

    steps:
    - uses: actions/checkout@v2
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v1
      with:
        node-version: ${{ matrix.node-version }}
    - run: yarn
    - run: yarn test
      env:
        CI: true

'''
'''--- .gitpod.yml ---
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - init: nvm install v12.0.0 && nvm use --default v12.0.0 && npm install -g yarn # runs during prebuild
    command: yarn && yarn test --verbose

'''
'''--- .travis.yml ---
language: rust

jobs:
  include:
    - name: fossa     
      before_script:
        - "curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/fc60c6631a5d372d5a45fea35e31665b338f260d/install.sh | sudo bash"
      script:
        - fossa init
        - fossa analyze --server-scan
        - fossa test

'''
'''--- Cargo.toml ---
[package]
name = "wasm-mock-vm"
version = "0.1.0"
authors = ["Willem Wyndham <willem@cs.umd.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
sha2 = "0.8"
sha3 = "0.8.2"
byteorder = "1.2"
bs58 = "0.3"
wasm-bindgen = "0.2.58"
near-vm-logic = { path = "./nearcore/runtime/near-vm-logic" ,version = "0.4.4" }
near-runtime-fees = { path = "./nearcore/runtime/near-runtime-fees", version = "0.4.4" }
near-vm-errors = { path = "./nearcore/runtime/near-vm-errors", version = "0.4.4" }
serde = { version = "1.0", features = ["derive"] }
serde-wasm-bindgen = "0.1.3"
js-sys = "0.3.35"
wasm-bindgen-futures = "0.4.8"

# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for
# code size when deploying.
console_error_panic_hook = { version = "0.1.1", optional = true }

# `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size
# compared to the default allocator's ~10K. It is slower than the default
# allocator, however.
#
# Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now.
wee_alloc = { version = "0.4.2", optional = true }

'''
'''--- README.md ---
# nearcore's VMlogic compiled to WebAssembly

Near smart contracts have access to a runtime API to interact with the host.  Nearcore is written in Rust, which means it can be compiled into WebAsssembly.  By compiling the core VM logic, a mock version of the runtime can be used to test smart contracts without the overhead of running a local node or using the testnet.

Currently rust smart contracts are unit tested by compiling the contract alongside the runtime since they are both in the same language.  This solution shares the same memory at runtime, where as in the actual VM there is a separation between the host memory and the contract's memory.  

This project uses `wasm-bindgen`, to create javascript bindings for the generated WebAssembly, which then can used along side the [`as-pect`](https://github.com/jtenner/as-pect) to write unit tests in AssemblyScript.

# Setup

## Node Version 
Since the runtime uses `u64`, it requires the use of the node flag ` --experimental-wasm-bigint`, which is included by default in `imports.js` of this project, however, this still requires a version of node >= v12.0.0.

## Installation 

In a blank Near AssemblyScript project you need to install the following dependencies:

```
npm install --save-dev wasm-mock-vm @as-pect/cli

```

Next set up `as-pect` with its init command.

```
npx asc --init
```

This creates a `__tests__` folder and a `as-pect.config.js` file in the root of your project. Replace the contents of the `as-pect.config.js` with

```
module.exports = require("wasm-mock-vm/imports");
```
This will configure mock Near VM and `as-pect`.

## Setting up Types
To ensure that the types added by the runtime library are detected by your IDE include a type declaration file in your root `assembly` folder, e.g. `assembly/types.d.ts` with the following line:
```ts
/// <reference types="near-runtime-ts/assembly/as_types" />
```

# Example Usage

In `assembly/contract.ts`:
```ts
//@nearfile

export class Contract {
  constructor(public name: string) {}
}

```

and `assembly/__tests__/contract.spec.ts`

```ts
import { storage } from "near-runtime-ts";
import { Contract } from "../contract";

describe("Contract", () => {
  it("should be able to be stored and retrieved", () => {
    const contract = new Contract("unique name!");
    storage.set("contract", contract);
    const otherContract = storage.get<Contract>("contract");
    expect(otherContract.name).toBe(contract.name, "contracts should have the same name");
    expect(otherContract.name).not.toBe("", "retrieved contract's name should not be the empty string");
  });
});

```

# API

By default the context used by the VM is a local `context.json` file.  It first looks in the project's `assembly/__test__` folder, then the project's root folder, and finally will read the default file in this project's root.

Each runtime API call by default updates the state of the VM.  So in the example above any tests run after it will have "contract" in the storage.  To prevent this there is an API to save and restore the state.  `as-pect` has special functions to run before and after tests, e.g. `beforeAll/beforeEach`.

```ts
import { storage } from "near-runtime-ts";
import { Contract } from "../contract";
import { VM } from "wasm-mock-vm";

describe("Contract", () => {

  beforeEach(() => {
    VM.saveState();
  });

  afterEach(() => {
    VM.restoreState();
  });
  
  it("should be able to be stored and retrieved", () => {
    const contract = new Contract("unique name!");
    storage.set("contract", contract);
    const otherContract = storage.get<Contract>("contract");
    expect(contract.name).toBe(otherContract.name, "contracts should have the same name");
    expect(contract.name).toBe("", "contracts should have the same name");
  });

  it("state should not contain updates of previous test", () => {
    expect(storage.contain("contract")).toBe(false, "contract shouldn't exist is original storage");
  });
});
```

The state also includes the registers that the runtime uses to store values in the host memory.

'''
'''--- as-pect.config.js ---
module.exports = require("./imports");
'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- assembly/__tests__/contract.spec.ts ---
import { storage } from "near-runtime-ts";
import { Contract } from "../contract";
import { VM } from "..";

describe("Contract", () => {
  beforeAll(() => {
    VM.saveState();
  });
  
  afterAll(() => {
    VM.restoreState();
  });

  it("should be able to be stored and retrieved", () => {
    const contract = new Contract("unique name!");
    storage.set("contract", contract);
    const otherContract = storage.get<Contract>("contract")!;
    expect(contract.name).toBe(otherContract.name, "contracts should have the same name");
    expect(contract.name).not.toBe("", "contract's name should not be empty");
  });
  
  it("should still be in the storage", () => {
    const otherContract = storage.get<Contract>("contract")!;
    expect(otherContract.name).toBe("unique name!", "contracts should have the same name");
    expect(otherContract.name).not.toBe("", "contract's name should not be empty");
  });
});

describe("Contract", () => {
  beforeEach( () => {
    VM.saveState();
  });

  afterEach(() => {
    VM.restoreState();
  });

  it("should be able to be stored and retrieved", () => {
    const contract = new Contract("unique name!");
    expect(storage.contains("contract")).toBe(false, "contract shouldn't exist in storage before putting it in.");
    storage.set("contract", contract);
    const otherContract = storage.get<Contract>("contract")!;
    expect(contract.name).toBe(otherContract.name, "contracts should have the same name");
    expect(contract.name).not.toBe("", "contract's name should not be empty");
  });

  it("should not be in the storage", () => {
    // const contract = new Contract("unique name!");
    // storage.set("contract", contract);
    expect(storage.contains("contract")).toBe(false, "the contract shouldn't exist");
  });
});
'''
'''--- assembly/__tests__/model.ts ---
//@nearfile
// Exporting a new class TextMessage so it can be used outside of this file.
export class TextMessage {
  sender: string;
  text: string;
  number: u64;
  isRead: bool;
}

'''
'''--- assembly/__tests__/runtime.spec.ts ---
import { context, storage, base58, base64, PersistentMap, PersistentVector, PersistentDeque, PersistentTopN, ContractPromise, math, logging, runtime_api } from "near-runtime-ts";
import { TextMessage } from "./model";
import { _testTextMessage, _testTextMessageTwo, _testBytes, _testBytesTwo } from "./util";
import { Context, VM } from "..";
import { u128 } from "near-runtime-ts";
import { Outcome } from "../entry";

beforeAll(()=> {
  VM.saveState();
})

// export function hello(): string {
//   const s = simple("a"); // Test that we can call other export functions
//   return "hello".concat(s);
// }

describe("Encodings", () => {
  it("base58 round trip", () => {
    let array: Uint8Array = _testBytes();
    const encoded = base58.encode(array);
    expect(encoded).toBe("1TMu", "Wrong encoded value for base58 encoding")
  });
  
  it("base64 round trip", () => {
    const array = _testBytes();
    const encoded = base64.encode(array);
    expect(encoded).toBe("AAFaZA==", "Incorrect keys contents");
    const decoded = base64.decode("AAFaZA==");
    expect(decoded).toStrictEqual(decoded, "Incorrect decoded value after base64 roundtrip");
  });
});

let outcome: Outcome;
describe("outcome", () => {
  beforeAll(()=> {
    VM.saveState();
  });
  afterAll(() => {
    VM.restoreState();
  });

  it("should return acturate logs", () => {
    logging.log("hello world");
    let outcome = VM.outcome();
    expect(outcome.logs).toIncludeEqual("hello world", "log should include \"hello world\"");
  });

  it("should increase the storage usage more when first added", () => {
    const key = "hello";
    const key_cost = String.UTF8.byteLength(key);
    const value = "world";
    const value_cost = String.UTF8.byteLength(value);
    const initial_base_cost = 40; 

    if (storage.contains("hello")) {
      storage.delete("hello");
    }
    let orig = VM.outcome();
    expect(orig.storage_usage).toBe(runtime_api.storage_usage(), "it should be the same when no storage has been added.");
    storage.set("hello", "world");
    expect(storage.get<string>("hello")).toBe("world", "key hello should be set to \"world\"");
    let newOutcome = VM.outcome();
    expect(newOutcome.storage_usage).toBeGreaterThan(orig.storage_usage, "the new storage usage should be greater than the original.");
    expect(runtime_api.storage_usage()).toBe(initial_base_cost + key_cost + value_cost + orig.storage_usage, "first write cost 40 + length of key + length of value");
  });

  it("should decrease storage usage with smaller value", () => {
    const oldVaule  = "world";
    const newValue = "wor";
    const lenDiff = String.UTF8.byteLength(oldVaule) - String.UTF8.byteLength(newValue);
    const usageBefore = runtime_api.storage_usage();
    storage.set("hello", newValue);
    expect(runtime_api.storage_usage()).toBe(usageBefore - lenDiff, "storage usage should be less with smaller value.");
  });
});

describe("Storage", (): void => {
  beforeEach(() => {
    VM.saveState();
  });

  afterEach(() => {
    VM.restoreState();
  });

  it("String Roundtrip", () => {
    storage.setString("someKey", "myValue1");
    storage.setString("someOtherKey", "otherValue");
    expect(storage.getString("someKey")).toBe("myValue1");
    // expect(getValueResult).toBe("myValue1", "Incorrect value from storage");
    const otherValueResult = storage.getString("someOtherKey");
    expect(otherValueResult).toBe("otherValue", "Incorrect value from someOtherKey from storage");
    expect(storage.getString("nonexistentKey")).toBeNull("Unexpectd value on getting string with a nonexistent key");
  });

  it("Bytes Roundtrip", () => {
    const bytes = _testBytes();
    const bytes2 = _testBytesTwo();
    storage.setBytes("someKey", bytes);
    storage.setBytes("someOtherKey", bytes2);
    const getValueResult = storage.getBytes("someKey");
    expect(getValueResult).toBe(getValueResult, "Incorrect bytes value from storage");
    const otherValueResult = storage.getBytes("someOtherKey");
    expect(otherValueResult).toBe(otherValueResult, "Incorrect bytes value from storage");
    expect(storage.getBytes("nonexistentKey")).toBeNull("Unexpectd value on getting bytes with a nonexistent key");
  });
  
  it("Generic Get/Set Roundtrip", () => {
    const message = _testTextMessage();
    storage.set("message1", message);
  
    const messageFromStorage = storage.get<TextMessage>("message1")!;
    expect(messageFromStorage.sender).toBe("mysteriousStranger", "Incorrect data value (sender) for retrieved object");
    expect(messageFromStorage.text).toBe("Hello world", "Incorrect data value (text) for retrieved object");
    expect(messageFromStorage.number).toBe(415, "Incorrect data value (number) for retrieved object");
    expect(storage.get<TextMessage>("nonexistent", null)).toBeNull("Incorrect data value for get<T> nonexistent key");
  
    storage.set<TextMessage>("message2", new TextMessage());
    // TODO: fix this
    expect(storage.get<TextMessage>("message2")).toStrictEqual(new TextMessage(), "Incorrect empty message on storage roundtrip");
  
    storage.set<u64>("u64key", 20);
    expect(storage.getPrimitive<u64>("u64key", 0)).toBe(20, "Incorrect data value for u64 roundtrip");
    expect(storage.getPrimitive<u64>("nonexistent", 1)).toBe(1, "Incorrect data value for u64 get nonexistent key");
  
    storage.set<u32>("u32key", 12);
    expect(storage.getPrimitive<u32>("u32key", 0)).toBe(12, "Incorrect data value for u32 roundtrip");
    expect(storage.getPrimitive<u32>("nonexistent", 2)).toBe(2, "Incorrect data value for u32 get nonexistent key");
  
    storage.set<i32>("i32key", -5);
    expect(storage.getPrimitive<i32>("i32key", 0)).toBe(-5, "Incorrect data value for i32 roundtrip");
    expect(storage.getPrimitive<i32>("nonexistent", -10)).toBe(-10, "Incorrect data value for i32 get nonexistent key");
  
    storage.set<bool>("boolkey", true);
    expect(storage.getPrimitive<bool>("boolkey", 0)).toBe(true, "Incorrect data value for bool roundtrip");
    expect(storage.getPrimitive<bool>("nonexistent", true)).toBe(true, "Incorrect data value for bool get nonexistent key");
  
    storage.set<String>("stringkey", "StringValue");
    const stringGet = storage.get<String>("stringkey");
    expect(stringGet).toBe("StringValue", "Incorrect data value for string roundtrip");
    expect(storage.get<string>("nonexistent", null)).toBeNull("Incorrect data value for get<T> string nonexistent key");
  });
  
  it("Keys", () => {
    storage.delete("someKey");
    // empty storage
    const emptyKeys = storage.keys("someKey");
    expect(emptyKeys.length).toBe(0, "Incorrect keys contents for empty storage");
  
    // // add some keys
    storage.setString("someApple", "myApple");
    storage.setString("someKey", "myValue1");
    storage.setString("someKey2", "myValue1");
    storage.setString("someKey6", "myValue2");
  
    const keyRange = storage.keyRange("someKey", "someKey3");
    expect(keyRange.length).toBe(2, "Incorrect keys length");
    expect(keyRange[0]).toBe("someKey", "Incorrect keys contents");
    expect(keyRange[1]).toBe("someKey2", "Incorrect keys contents");
    const keyRangeWithLimit = storage.keyRange("someKey", "someKey3", 1);
    expect(keyRangeWithLimit.length).toBe(1, "Incorrect keys length");
    expect(keyRangeWithLimit[0]).toBe("someKey", "Incorrect keys contents");
  
    const keys = storage.keys("someKey");
    expect(keys.length).toBe(3, "Incorrect keys length");
    expect(keys[0]).toBe("someKey", "Incorrect keys contents");
    expect(keys[1]).toBe("someKey2", "Incorrect keys contents");
    expect(keys[2]).toBe("someKey6", "Incorrect keys contents");
    const keysWithLimit = storage.keys("someKey", 1);
    expect(keysWithLimit.length).toBe(1, "Incorrect keys length");
    expect(keys[0]).toBe("someKey", "Incorrect keys contents")
  
    expect(storage.contains("someApple")).toBe(true, "Storage does not contain key");
    expect(storage.contains("someKey")).toBe(true, "Storage does not contain key");
    expect(storage.contains("someKey2")).toBe(true, "Storage does not contain key");
    expect(storage.contains("someKey6")).toBe(true, "Storage does not contain key");
    expect(!storage.contains("nonexisting")).toBe(true, "Storage has unexpected key");
    expect(storage.hasKey("someKey6")).toBe(true, "Storage does not contain key");
    expect(!storage.hasKey("nonexisting")).toBe(true, "Storage has unexpected key");
  
    // remove a key and retry some of the api calls
    storage.delete("someKey");
    expect(!storage.contains("someKey")).toBe(true, "Storage contains key that was deleted");
    expect(storage.contains("someKey2")).toBe(true, "Some other key got deleted");
    const keyswithdelete = storage.keys("someKey");
    expect(keyswithdelete.length).toBe(2, "Incorrect keys length after removing a key")
    expect(keyswithdelete[0]).toBe("someKey2", "Incorrect keyswithdelete contents");
    expect(keyswithdelete[1]).toBe("someKey6", "Incorrect keyswithdelete contents");
  });
});

describe("Map should handle", () => {
  it("empty maps", () => {
    // TODO: values
    // empty map
    const map = new PersistentMap<string, TextMessage>("mapId");
    const valuesEmpty = map.values("", "zzz");
    expect(valuesEmpty.length).toBe(0, "Unexpected values in empty map");
    expect(!map.contains("nonexistentkey")).toBe(true, "Map contains a non existent key");
    expect(map.get("nonexistentkey")).toBeNull("Incorrect result on get with nonexistent key");
  });

  it("some entries", () => {
    const map = new PersistentMap<string, TextMessage>("mapId");
    // add some entries to the map
    const message = _testTextMessage();
    map.set("mapKey1", message);
    map.set("mapKey3", _testTextMessageTwo());
    expect(map.contains("mapKey1")).toBe(true);
    const values = map.values("mapKey1", "zzz");
    expect(values.length).toBe(2, "Unexpected values size in map with 2 entries");
    expect(values[0]).toStrictEqual(message, "Unexpected values contents in map with 2 entries");
    expect(values[1]).toStrictEqual(_testTextMessageTwo(), "Unexpected values contents in map with 2 entries");
    expect(map.values("mapKey3", "zzz").length).toBe(1, "Unexpected values size in map with 2 entries");
    expect(map.values("mapKey1", "mapKey2").length).toBe(1, "Unexpected values size in map with 2 entries");
    expect(map.values("mapKey1", "mapKey4", -1, false).length).toBe(1, "Unexpected values size in map with 2 entries");
    expect(!map.contains("nonexistentkey")).toBe(true, "Map contains a non existent key");
    expect(map.contains("mapKey1")).toBe(true, "Map does not contain a key that was added (mapKey1)");
    expect(map.contains("mapKey3")).toBe(true, "Map does not contain a key that was added (mapKey3)");
    expect(map.get("mapKey1")).toStrictEqual(message, "Incorrect result from map get");
    expect(map.get("mapKey3")).toStrictEqual(_testTextMessageTwo(), "Incorrect result from map get");
    // delete an entry and retry api calls
    map.delete("mapKey3");
    expect(map.values("", "zzz").length).toBe(1, "Unexpected values size in map after delete");
    expect(map.values("", "zzz")[0]).toStrictEqual(message, "Unexpected values contents in map after delete");
    expect(map.values("mapKey1", "zzz").length).toBe(1, "Unexpected values size in map after delete");
    expect(!map.contains("mapKey3")).toBe(true, "Map contains a key that was deleted");
    expect(map.contains("mapKey1")).toBe(true, "Map does not contain a key that should be there after deletion of another key");
    expect(map.get("mapKey1")).toStrictEqual(message, "Incorrect result from map get after delete");
    expect(map.get("mapKey3")).toBeNull("Incorrect result from map get on a deleted key");
  });

  it("should handle primitives", () => {
    // map with primitives
    const map = new PersistentMap<i32, i32>("mapPrimitives");
    map.set(1, -20);
    expect(map.getSome(1)).toBe(-20, "wrong value on map get for i32");
  });
  
  it("should handle arrays", () => {
    // map with arrays
    const map = new PersistentMap<i32, Array<string>>("mapArray");
    const arr1 = new Array<string>();
    arr1.push("123456789");
    // return arr1;
    map.set(1, arr1);
    expect(map.getSome(1)[0]).toBe("123456789");
  });
});

const vector = new PersistentVector<string>("vector1");

describe("Vectors should handle", () => {
  //TODO: Improve tests
  it("no items", () => {
    expect(vector != null).toBe(true, "Vector not initialized");
    expect(vector.length).toBe(0, "Empty vector has incorrect length");
    expect(!vector.containsIndex(0)).toBe(true, "Empty vector incorrectly has index 0");
    expect(vector.isEmpty).toBe(true, "isEmpty incorrect on empty vector");
    //try { expect(vector[0]).toBeNull("");} catch (e) {} not possible to test due to lack of try catch
  });
  
  it("single items", () => {
    vector.push("bb");
    expect(vector.length).toBe(1, "Vector has incorrect length");
    expect(vector.containsIndex(0)).toBe(true, "Non empty vector does not have index 0");
    expect(!vector.containsIndex(1)).toBe(true, "Vector size 1 incorrectly has index 1");
    expect(!vector.isEmpty).toBe(true, "isEmpty incorrect on non-empty vector");
    expect(vector.back).toBe("bb", "Incorrect back entry");
    expect(vector.last).toBe("bb", "Incorrect last entry");
    expect(vector.front).toBe("bb", "Incorrect front entry");
    expect(vector.first).toBe("bb", "Incorrect first entry");
    expect(vector[0]).toBe("bb", "incorrect vector contents");
    expect(_vectorHasContents(vector, ["bb"])).toBe(true, "Unexpected vector contents. Expected [bb]");
  });
  
  it("two items", () => {
    vector.pushBack("bc");
    expect(vector.length).toBe(2, "Vector has incorrect length");
    expect(vector.containsIndex(0)).toBe(true, "Non empty vector does not have index 0");
    expect(vector.containsIndex(1)).toBe(true, "Vector size 2 does not have index 1");
    expect(!vector.containsIndex(2)).toBe(true, "Vector size 2 incorrectly has index 2");
    expect(!vector.isEmpty).toBe(true, "isEmpty incorrect on non-empty vector");
    expect(_vectorHasContents(vector, ["bb", "bc"])).toBe(true, "Unexpected vector contents. Expected [ba, bb]");
    vector[1] = "bd";
    expect(_vectorHasContents(vector, ["bb", "bd"])).toBe(true, "Unexpected vector contents. Expected [ba, bd]");

    vector[0] = "aa";
    expect(_vectorHasContents(vector, ["aa", "bd"])).toBe(true, "Unexpected vector contents. Expected [aa, bd]");
    expect(vector.length).toBe(2, "Vector has incorrect length")
  });
  
  it("three items", () => {
    vector.pushBack("be");
    expect(_vectorHasContents(vector, ["aa", "bd", "be"])).toBe(true, "Unexpected vector contents. Expected [aa, bd, be]");
    expect(vector.length).toBe(3, "Vector has incorrect length")
    expect(vector.back).toBe("be", "Incorrect back entry")
    expect(vector.last).toBe("be", "Incorrect last entry")
    expect(vector.front).toBe("aa", "Incorrect front entry")
    expect(vector.first).toBe("aa", "Incorrect first entry")
  });
  
  it("popping from the front", () => {
    //pop an entry and then try various other methods
    vector.pop();
    expect(_vectorHasContents(vector, ["aa", "bd"])).toBe(true, "Unexpected vector contents. Expected [aa, bd]");
    expect(vector.length).toBe(2, "Vector has incorrect length after delete")
    vector[0] = "ba";
    expect(_vectorHasContents(vector, ["ba", "bd"])).toBe(true, "Unexpected vector contents. Expected [ba, bd]");
    expect(vector.length).toBe(2, "Vector has incorrect length");
  });
  
  it("popping from b items", () => {
    vector.pushBack("bf");
    expect(_vectorHasContents(vector, ["ba", "bd", "bf"])).toBe(true, "Unexpected vector contents. Expected [ba, bd, bf]");
    expect(vector.length).toBe(3, "Vector has incorrect length")
    vector.popBack();
    expect(_vectorHasContents(vector, ["ba", "bd"])).toBe(true, "Unexpected vector contents. Expected [ba, bd]");
    expect(vector.length).toBe(2, "Vector has incorrect length");

    // same id but different object.
    const vectorReread = new PersistentVector<string>("vector1");
    expect(vectorReread != null).toBe(true, "Vector not initialized");
    expect(vectorReread.length).toBe(2, "Vector has incorrect length");

    // vector with primitives
    const vectorI32 = new PersistentVector<i32>("vectori32");
    vectorI32.pushBack(2);
    expect(vectorI32.length).toBe(1, "Vector i32 has incorrect length");
  });
});

const deque = new PersistentDeque<string>("dequeid");

describe("Deque should handle", () => {
  it("no items", () => {
    expect(deque.length).toBe(0, "empty deque length is wrong");
    expect(!deque.containsIndex(0)).toBe(true, "empty deque contains index 0");
    expect(deque.isEmpty).toBe(true, "empty deque returns false for isEmpty");
  });
  
  it("single items", () => {
    deque.pushBack("1");
    expect(deque.length).toBe(1, "deque length is wrong");
    expect(deque.containsIndex(0)).toBe(true, "deque does not contain index 0");
    expect(!deque.containsIndex(-1)).toBe(true, "deque does not contain index 0");
    expect(deque.isEmpty).toBe(false, "deque returns true for isEmpty");
    expect(deque[0]).toBe("1", "wrong element value using []");
    expect(deque.back).toBe("1", "wrong back element");
    expect(deque.front).toBe("1", "wrong front element");
    expect(deque.first).toBe("1", "wrong first element");
    expect(deque.last).toBe("1", "wrong last element");
  });
  
  it("multiple items", () => {
    deque.pushFront("-2");
    expect(deque.length).toBe(2, "deque length is wrong");
    expect(deque.containsIndex(0)).toBe(true, "deque does not contain index 0");
    expect(deque.containsIndex(1)).toBe(true, "deque does not contain index 1");
    expect(deque.isEmpty).toBe(false, "deque returns true for isEmpty");
    expect(deque[1]).toBe("1", "wrong element value using []");
    expect(deque[0]).toBe("-2", "wrong element value using []");
    expect(deque.back).toBe("1", "wrong back element");
    expect(deque.front).toBe("-2", "wrong front element");
    expect(deque.first).toBe("-2", "wrong first element");
    expect(deque.last).toBe("1", "wrong last element");
  });
  
  it("popping front", () => {
    deque.popFront();
    expect(deque.length).toBe(1, "deque length is wrong");
    expect(deque.containsIndex(0)).toBe(true, "deque does not contain index 0");
    expect(!deque.containsIndex(1)).toBe(true, "deque of length 1 contains index 1");
    expect(deque.isEmpty).toBe(false, "deque returns true for isEmpty");
    expect(deque[0]).toBe("1", "wrong element value using []");
    expect(deque.back).toBe("1", "wrong back element");
    expect(deque.front).toBe("1", "wrong front element");
    expect(deque.first).toBe("1", "wrong first element");
    expect(deque.last).toBe("1", "wrong last element");
  });
  
  it("popping back", () => {
    deque.pushFront("-2");
    deque.popBack();
    expect(deque.length).toBe(1, "deque length is wrong");
    expect(deque.containsIndex(0)).toBe(true, "deque does not contain index 0");
    expect(!deque.containsIndex(1)).toBe(true, "deque of length 1 contains index 1");
    expect(deque.isEmpty).toBe(false, "deque returns true for isEmpty");
    expect(deque[0]).toBe("-2", "wrong element value using []");
    expect(deque.back).toBe("-2", "wrong back element");
    expect(deque.front).toBe("-2", "wrong front element");
    expect(deque.first).toBe("-2", "wrong first element");
    expect(deque.last).toBe("-2", "wrong last element");
  });
});

let topn: PersistentTopN<string>;
describe("TopN should", () => {

  beforeAll(() => {
    topn = new PersistentTopN<string>("topnid");
  });
    it("handle empty collection", () => {
      // empty topn cases
    expect(topn != null).toBe(true, "topn is null");
    expect(topn.isEmpty).toBe(true, "empty topn - wrong result for isEmpty");
    expect(topn.length).toBe(0, "empty topn - wrong length");
    expect(!topn.contains("nonexistentKey")).toBe(true, "empty topn - contains nonexistent key");
    topn.delete("nonexistentKey"); // this should not crash
    expect(topn.keysToRatings(new Array<string>(0)).length).toBe(0, "keys to ratings for empty topn is not empty");
    expect(topn.getTop(10).length).toBe(0, "get top for empty topn returned non empty list")
    // expect(topn.getTopFromKey(10, "somekey").length).toBe(0, "getTopFromKey for empty topn returned non empty list") // fails due to key doesn't exist
    expect(topn.getTopWithRating(10).length).toBe(0, "getTopWithRating for empty topn is not empty");
    // expect(topn.getTopWithRatingFromKey(10, "somekey").length).toBe(0, "getTopWithRatingFromKey for empty topn is not empty"); // fails due to key doesn't exist
  });
  
  it("handle single items", () => {
    topn.setRating("k1", 5);
    expect(!topn.isEmpty).toBe(true, "topn - wrong result for isEmpty");
    expect(topn.length).toBe(1, "topn - wrong length");
    expect(!topn.contains("nonexistentKey")).toBe(true, "topn - contains nonexistent key");
    expect(topn.contains("k1")).toBe(true, "topn - does not contain a key that should be there");
    topn.delete("nonexistentKey"); // this should not crash
    expect(topn.keysToRatings(["k1"]).length).toBe(1, "keys to ratings wrong for topn");
    expect(topn.keysToRatings(["k1"])[0].value).toBe(5, "keys to ratings wrong for topn");
    expect(topn.getTop(10).length).toBe(1, "get top for topn returned non empty list");
    expect(topn.getTop(10)[0]).toBe("k1", "wrong key in getTop")
    expect(topn.getTopFromKey(10, "k1").length).toBe(0, "getTopFromKey for topn wrong result");
    expect(topn.getTopWithRating(10).length).toBe(1, "getTopWithRating for topn with 1 element is wrong size");
    expect(topn.getTopWithRatingFromKey(10, "k1").length).toBe(0, "getTopWithRatingFromKey for topn is not empty");
  });

  
  it("handle two entries", () => {
    topn.setRating("k", 5);
    topn.incrementRating("k1");
    expect(!topn.isEmpty).toBe(true, "topn - wrong result for isEmpty");
    expect(topn.length).toBe(2, "topn - wrong length");
    expect(!topn.contains("nonexistentKey")).toBe(true, "topn - contains nonexistent key");
    expect(topn.contains("k")).toBe(true, "topn - does not contain a key that should be there");
    expect(topn.contains("k1")).toBe(true, "topn - does not contain a key that should be there");
    topn.delete("nonexistentKey"); // this should not crash
    expect(topn.keysToRatings(["k1"]).length).toBe(1, "keys to ratings wrong for topn");
    expect(topn.keysToRatings(["k1", "k"]).length).toBe(2, "keys to ratings wrong for topn");
    expect(topn.keysToRatings(["k1", "k"])[0].value).toBe(6, "keys to ratings wrong for topn");
    expect(topn.keysToRatings(["k1", "k"])[1].value).toBe(5, "keys to ratings wrong for topn");
    expect(topn.getTop(10).length).toBe(2, "get top for topn is wrong");
    expect(topn.getTop(10)[0]).toBe("k1", "wrong key in getTop");
    expect(topn.getTop(10)[1]).toBe("k", "wrong key in getTop");
    expect(topn.getTop(1).length).toBe(1, "get top for topn is wrong when limit is applied");
    expect(topn.getTop(1)[0]).toBe("k1", "wrong key in getTop");
    expect(topn.getTopFromKey(10, "k").length).toBe(0, "getTopFromKey for topn wrong result");
    expect(topn.getTopFromKey(10, "k1").length).toBe(1, "getTopFromKey for topn wrong result");
    expect(topn.getTopFromKey(10, "k1")[0]).toBe("k", "getTopFromKey for topn wrong result");
    expect(topn.getTopWithRating(10).length).toBe(2, "getTopWithRating for topn with 1 element is wrong size");
    expect(topn.getTopWithRating(10)[0].value).toBe(6, "getTopWithRating for topn with 1 element is wrong size");
    expect(topn.getTopWithRating(10)[1].value).toBe(5, "getTopWithRating for topn with 1 element is wrong size");
  });

  it("handle deleting items", () => {
    topn.delete("k1");
    topn.incrementRating("k");
    expect(!topn.isEmpty).toBe(true, "topn - wrong result for isEmpty");
    expect(topn.length).toBe(1, "topn - wrong length");
    expect(!topn.contains("nonexistentKey")).toBe(true, "topn - contains nonexistent key");
    expect(topn.contains("k")).toBe(true, "topn - does not contain a key that should be there");
    topn.delete("nonexistentKey"); // this should not crash
    expect(topn.keysToRatings(["k"]).length).toBe(1, "keys to ratings wrong for topn");
    expect(topn.keysToRatings(["k"])[0].value).toBe(6, "keys to ratings wrong for topn");
    expect(topn.getTop(10).length).toBe(1, "get top for topn returned non empty list");
    expect(topn.getTop(10)[0]).toBe("k", "wrong key in getTop");
    expect(topn.getTopFromKey(10, "k").length).toBe(0, "getTopFromKey for topn wrong result");
    expect(topn.getTopWithRating(10).length).toBe(1, "getTopWithRating for topn with 1 element is wrong size");
    expect(topn.getTopWithRatingFromKey(10, "k").length).toBe(0, "getTopWithRatingFromKey for topn is not empty");
  });
});

describe("context", () => {

  beforeEach(() => {
    Context.saveContext();
  });

  afterEach(() => {
    Context.restoreContext();
  });

  it("should read unchanged context", () => {
    expect(context.sender).toBe("bob", "Wrong sender");
    expect(context.attachedDeposit).toBe(u128.fromU64(2), "Wrong receivedAmount");
    expect(context.accountBalance).toBe(u128.fromU32(4), "Account Balance should inclode attached deposit");
  });
  
  describe("Account Balance", () => {
      it("should be updated when attached attached deposit is updated", () => {
          Context.setAttached_deposit(u128.from(4));
          expect(context.accountBalance).toStrictEqual(u128.from(6), "Updating the attached deposit should update the account balance");
        });
    });
      
      
  it("should be editable", () => {
    Context.setCurrent_account_id("contractaccount");
    expect(context.contractName).toBe("contractaccount", "Wrong contract name");
    Context.setBlock_index(113);
    expect(context.blockIndex).toBe(113, "Wrong contract name");
    Context.setAttached_deposit(u128.from(7));
    expect(context.attachedDeposit.toString()).toBe(u128.fromU64(7).toString(), "Wrong receivedAmount");
    // Context.setAccount_balance(u128.from(14))
    
    // expect(context.accountBalance).toBe(u128.fromU64(14), "Wrong receivedAmount");
    Context.setPrepaid_gas(1000000000);
    expect(context.prepaidGas).toBe(1000000000, "Wrong prepaid gas");
    expect(context.usedGas <= 1000000000).toBe(true, "Wrong used gas");
    // expect(context.usedGas > 0).toBe(true, "Wrong used gas");
    //expect(context.storageUsage).toBe(0, "Wrong storage usage"); TODO: test when implemented
  });
});

describe("promises", () => {
  it("should work", () => {
    const emptyResults = ContractPromise.getResults();
    expect(emptyResults.length).toBe(0, "wrong length for results");
    const promise = ContractPromise.create("contractNameForPromise", "methodName", new Uint8Array(0), 10000000000000);
    const promise2 = promise.then("contractNameForPromise", "methodName", new Uint8Array(0), 10000000000000);
    const promise3 = ContractPromise.all([promise2]);
  });
});

const stringValue = "toHash";

describe("Math should handle", () => {
  it("hash 32 from bytes", () => {
    const array = _testBytes();
    const hash = math.hash32Bytes(array);
    expect(hash).toBe(3593695342, "wrong hash");
  });

  it("hash 32 from string ", () => {
    const hashOfString = math.hash32(stringValue);
    expect(hashOfString).toBe(3394043202, "wrong hash of the string");
  });

  it("hash Uint8Aray from string", () => {
    const hash256 = math.hash(stringValue);
    let x: i32[] = [1, 6, 7];
    expect(hash256.length).toBe(32, "wrong output length for hash256");
    expect(hash256[0]).toBe(202, "wrong contents of hash256");
    expect(hash256[1]).toBe(76, "wrong contents of hash256");
    expect(hash256[31]).toBe(184, "wrong contents of hash256");
  });

  it("handle random", () => {

    const randBuf = math.randomBuffer(14);
    const randBuf2 = math.randomBuffer(14);
    const randBuf3 = math.randomBuffer(14);
    const randBuf4 = math.randomBuffer(32);
    const randBuf5 = math.randomBuffer(35);
  });
});

// cruft to compare test objects. TODO: use something standard
function _arrayEqual(first: Uint8Array | null, second: Uint8Array | null): bool {
  if (first == null || second == null) {
    return first == second;
  }
  if (first.length != second.length) {
    return false;
  }
  for (let i = 0; i < first.length; ++i) {
    if (first[i] != second[i]) {
      return false;
    }
  }
  return true;
}

function _modelObjectEqual(first: TextMessage | null, second: TextMessage | null): bool {
  //@ts-ignore
  if (first == null) {
    return second == null;
  }
  if (second == null) return false;
  if (first.sender != second.sender) {
    return false;
  }
  if (first.text != second.text) {
    return false;
  }
  if (first.number != second.number) {
    return false;
  }
  return true;
}

function _vectorHasContents(vector: PersistentVector<string>, expectedContents: Array<string>): bool {
  if (vector.length != expectedContents.length) {
    return false;
  }
  for (let i = 0; i < expectedContents.length; i++) {
    if (expectedContents[i] != vector[i]) {
      //return false;
    }
  }
  return true;
}

export function simple(s: string): string {
  return s;
}

export function setKeyValue(key: string, value: string): void {
  storage.set<string>(key, value);
}

export function getValueByKey(key: string): string | null {
  return storage.get<string>(key);
}

export function setValue(value: string): string {
  storage.set<string>("name", value);
  return value;
}

export function getValue(): string | null {
  return storage.get<string>("name");
}

'''
'''--- assembly/__tests__/util.ts ---
import {TextMessage} from "./model";

//Testing helper functions
export function _testBytes(): Uint8Array {
  const array = new Uint8Array(4);
  array[0] = 0;
  array[1] = 1;
  array[2] = 90;
  array[3] = 100;
  return array;
}
export function _testBytesTwo(): Uint8Array {
  const array = new Uint8Array(3);
  array[0] = 8;
  array[1] = 2;
  array[2] = 101;
  return array;
}
export function _testTextMessage(): TextMessage {
  const message = new TextMessage();
  message.sender = "mysteriousStranger";
  message.text = "Hello world";
  message.number = 415;
  return message;
}
export function _testTextMessageTwo(): TextMessage {
  const message = new TextMessage();
  message.sender = "joe";
  message.text = "Howdy";
  message.number = 20;
  return message;
}

export function roundtrip<T>(obj: T): T {
  return decode<T>(encode<T>(obj));
}
'''
'''--- assembly/as_types.d.ts ---
/// <reference no-default-lib="true"/>
/// <reference types="assemblyscript/std/types/assembly" />
/// <reference types="near-runtime-ts/assembly/as_types" />
'''
'''--- assembly/contract.ts ---
//@nearfile

export class Contract {
  constructor(public name: string) {}
}

'''
'''--- assembly/entry.ts ---
//@notNearfile
export * from "./outcome";

export function newStringArray(): Array<string> {
  return new Array<string>();
}

export function pushString(arr: string[], str: string): Array<string> {
  arr.push(str);
  return arr;
}
'''
'''--- assembly/index.ts ---
import { u128 } from "near-runtime-ts";
import { Outcome } from "./outcome";

/**
 * Methods on the current VM
 */ 
export declare namespace VM {
  /** 
   * Saves the internal state of the VM. 
   * */ 
  //@ts-ignore
  @external("vm", "saveState")
  export function saveState(): void;

  /** 
   * Restores the internal state of the VM. 
   * 
   */ 
  //@ts-ignore
  @external("vm", "restoreState")
  export function restoreState(): void;

  /**
   * Return the VM Outcome of the current running contract
   */ 
  //@ts-ignore
  @external("vm", "outcome")
  export function outcome(): Outcome;

  
}  

//@ts-ignore
@external("vm", "setCurrent_account_id")
declare function _setCurrent_account_id(id: usize): void;

//@ts-ignore
@external("vm", "setInput")
declare function _setInput(input: usize): void;

//@ts-ignore
@external("vm", "setSigner_account_id")
declare function _setSigner_account_id(s: usize): void;
/// The public key that was used to sign the original transaction that led to
/// this execution.
//@ts-ignore
@external("vm", "setSigner_account_pk")
declare function _setSigner_account_pk(s: usize): void;
//@ts-ignore
@external("vm", "setPredecessor_account_id")
declare function _setPredecessor_account_id(s: usize): void;
//@ts-ignore
@external("vm", "setRandom_seed")
declare function _setRandom_seed(s: usize): void;

//@ts-ignore
@external("vm", "setAttached_deposit")
declare function _setAttached_deposit(lo: u64, hi: u64): void;

//@ts-ignore
@external("vm", "setAccount_balance")
declare function _setAccount_balance(lo: u64, hi: u64): void;

//@ts-ignore
@external("vm", "setAccount_locked_balance")
declare function _setAccount_locked_balance(lo: u64, hi: u64): void;

//@ts-ignore
@external("vm", "saveContext")
declare function _saveContext(): void;

//@ts-ignore
@external("vm", "restoreContext")
declare function _restoreContext(): void;

//@ts-ignore
@external("vm", "setBlock_index")
declare function _setBlock_index(block_height: u64): void;
//@ts-ignore
@external("vm", "setBlock_timestamp")
declare function _setBlock_timestamp(stmp: u64): void;

//@ts-ignore
@external("vm", "setPrepaid_gas")
declare function _setPrepaid_gas(_u64: u64): void;

//@ts-ignore
@external("vm", "setIs_view")
declare function _setIs_view(b: bool): void;
//@ts-ignore
@external("vm", "setOutput_data_receivers")
declare function _setOutput_data_receivers(arrA: Array<string>): void;
//@ts-ignore
@external("vm", "setStorage_usage")
declare function _setStorage_usage(amt: u64): void;
/**
 * Functions to edit the current VM's context
 */
export namespace Context {

  export function saveContext(): void {
    _saveContext();
  }

  export function restoreContext(): void {
    _restoreContext();
  }

  export function setCurrent_account_id(id: string): void {
    _setCurrent_account_id(changetype<usize>(String.UTF8.encode(id)));
  }

  export function setInput(input: string): void {
    _setInput(changetype<usize>(String.UTF8.encode(input)));
  }

  export function setSigner_account_id(s: string): void {
    _setSigner_account_id(changetype<usize>(String.UTF8.encode(s)));
  }
  /// The public key that was used to sign the original transaction that led to
  /// this execution.
  export function setSigner_account_pk(s: string): void {
    _setSigner_account_pk(changetype<usize>(String.UTF8.encode(s)));
  }
  export function setPredecessor_account_id(s: string): void {
    _setPredecessor_account_id(changetype<usize>(String.UTF8.encode(s)));
  }

  export function setBlock_index(block_height: u64): void {
    _setBlock_index(block_height);
  }
  
  export function setBlock_timestamp(stmp: u64): void {
    _setBlock_timestamp(stmp);
  }

  export function setAccount_balance(_u128: u128): void {
    _setAccount_balance(_u128.lo, _u128.hi);
  }

  export function setAccount_locked_balance(_u128: u128): void {
    _setAccount_locked_balance(_u128.lo, _u128.hi);
  }

  export function setStorage_usage(amt: u64): void {
    _setStorage_usage(amt);
  }

  export function setAttached_deposit(_u128: u128): void {
    _setAttached_deposit(_u128.lo, _u128.hi);
  }

  export function setPrepaid_gas(_u64: u64): void {
    _setPrepaid_gas(_u64);
  }

  export function setRandom_seed(s: string): void {
    _setRandom_seed(changetype<usize>(String.UTF8.encode(s)));
  }

  export function setIs_view(b: bool): void {
    _setIs_view(b);
  }
  
  export function setOutput_data_receivers(arrA: Array<string>): void {
    _setOutput_data_receivers(arrA);
  }
}
'''
'''--- assembly/outcome.ts ---
import { u128 } from "near-runtime-ts";

export abstract class ReturnData {}

export class Value extends ReturnData {
  constructor(public data: string) { super(); }
}

export class ReceiptIndex extends  ReturnData {
  constructor(public index: u64) { super(); }
}

/// Method hasn't returned any data or promise.
export class None extends ReturnData {}

export const NONE = new None();
export const ValueID = idof<Value>();
export const ReceiptIndexID = idof<ReceiptIndex>();
export const NoneID = idof<None>();

export class Outcome {
  balance: u128;
  constructor(
  balance_lo: u64,
  balance_hi: u64,
  public burnt_gas: u64,
  public used_gas: u64,
  public logs: string[],
  public storage_usage: u64,
  public return_data: ReturnData,
  ){
    this.balance = new u128(balance_lo, balance_hi);
  }
}
'''
'''--- assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json"
}
'''
'''--- context.json ---
{
  "current_account_id": "alice", 
  "signer_account_id": "bob",
  "signer_account_pk": "HuxUynD5GdrcZ5MauxJuu74sGHgS6wLfCqqhQkLWK",
  "predecessor_account_id": "carol",
  "input": "{ \"arg1\": 1 }",
  "block_index": 10,
  "block_timestamp": 42,
  "account_balance": 2,
  "account_locked_balance": 1,
  "storage_usage": 12,
  "attached_deposit": 2,
  "prepaid_gas": 100000000000000,
  "random_seed": "HuxUynD5GdrcZ5MauxJuu74sGHgS6wLfCqqhQkLWK",
  "is_view": false,
  "output_data_receivers": []
}

'''
'''--- imports.js ---
const v8 = require('v8');
v8.setFlagsFromString('--experimental-wasm-bigint');
let rust = require(".");
let fs = require("fs");
let path = require("path");

function toNum(x) { return parseInt(x.toString()); }

// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt

/* utf.js - UTF-8 <=> UTF-16 convertion
 *
 * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0
 * LastModified: Dec 25 1999
 * This library is free.  You can redistribute it and/or modify it.
 */

function UTF8toStr(array) {
    var out, i, len, c;
    var char2, char3;

    out = "";
    len = array.length;
    i = 0;
    while(i < len) {
    c = array[i++];
    switch(c >> 4)
    { 
      case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
        // 0xxxxxxx
        out += String.fromCharCode(c);
        break;
      case 12: case 13:
        // 110x xxxx   10xx xxxx
        char2 = array[i++];
        out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
        break;
      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = array[i++];
        char3 = array[i++];
        out += String.fromCharCode(((c & 0x0F) << 12) |
                       ((char2 & 0x3F) << 6) |
                       ((char3 & 0x3F) << 0));
        break;
    }
    }

    return out;
}

function findContext() {
  let paths = [
                path.join(process.cwd(),
                "assembly", "__tests__"),
                process.cwd(), __dirname
              ]
              .map(p => path.join(p, "context.json"));
  let _paths = paths.filter(p => {
      try {
        require.resolve(p);
      } catch {
          return false;
      }
      return true
  });
  return _paths.length > 0 ? require(_paths[0]) : null;
  
}

function createImports(memory, createImports, instantiateSync, binary) {
  let wasm;
  let I8 = () => new Uint8Array(memory.buffer);

  function readUTF8Str(ptr) {
    let buf = I8();
    let arr = [];
    while (buf[ptr] != 0) {
      arr.push(buf[ptr]);
      ptr++;
    }
    return UTF8toStr(arr);
  }

  // Returns whether the memory interval is completely inside the smart contract memory.
  global.fits_memory = function (offset, len) {
    return toNum(offset) + toNum(len) < I8().length;
  }

  // Reads the content of the given memory interval.
  //
  // # Panics
  //
  // If memory interval is outside the smart contract memory.
  global.read_memory =  function(offset, buffer) {
      buffer.set(I8().slice(toNum(offset), toNum(offset) + buffer.length), 0);
  };

  // Reads a single byte from the memory.
  //
  // # Panics
  //
  // If pointer is outside the smart contract memory.
  global.read_memory_u8 = function (offset) {
    return I8()[toNum(offset)];
  }

  // Writes the buffer into the smart contract memory.
  //
  // # Panics
  //
  // If `offset + buffer.len()` is outside the smart contract memory.
  global.write_memory = function(offset, buffer) {
      I8().set(buffer, toNum(offset));
  }

  const current_account_id = "alice"; 
  const signer_account_id = "bob";
  const signer_account_pk = "HuxUynD5GdrcZ5MauxJuu74sGHgS6wLfCqqhQkLWK";
  const predecessor_account_id = "carol";
  const input = "{ arg1: 1 }";
  const block_index = 10;
  const block_timestamp = 42;
  const account_balance = 2;
  const account_locked_balance = 1;
  const storage_usage = 12;
  const attached_deposit = 2;
  const prepaid_gas = 10**(14);
  const random_seed = "HuxUynD5GdrcZ5MauxJuu74sGHgS6wLfCqqhQkLWK";
  const is_view = false;
  const output_data_receivers= new Uint8Array([]);

  function createContext() {
    const _default = {
        /// The account id of the current contract that we are executing.
        current_account_id, // string
        /// The account id of that signed the original transaction that led to this
        /// execution.
        signer_account_id, // string
        /// The public key that was used to sign the original transaction that led to
        /// this execution.
        signer_account_pk, // string base58
        predecessor_account_id, // string
        input, // JSON string
        block_index, // u128
        block_timestamp,
        account_balance,
        account_locked_balance,
        storage_usage,
        attached_deposit,
        prepaid_gas,
        random_seed,
        is_view,
        output_data_receivers,
    }
    
    return findContext() || _default;
  }

  context =  createContext();
  vm = new rust.VM(context);
  let _imports =  {
    vm: {
        saveState() {
          vm.save_state();
        },
        restoreState() {
          vm.restore_state();
        },
        outcome() {
          let outcome = vm.outcome();
          let strArrPtr = wasm.newStringArray();
          for (let str of outcome.logs) {
            strArrPtr = wasm.pushString(strArrPtr, wasm.__allocString(str));
          }
          let return_data_ptr;
          if (outcome.return_data === "None") {
            return_data_ptr = wasm.NONE;
          }
          let outcomePtr = new wasm.Outcome(BigInt(outcome.balance1),
                                            BigInt(outcome.balance2),
                                            BigInt(outcome.burnt_gas),
                                            BigInt(outcome.used_gas),
                                            strArrPtr,
                                            BigInt(outcome.storage_usage),
                                            return_data_ptr)
          return outcomePtr.valueOf();
        },
        saveContext() {
          vm.save_context();
        },
        restoreContext() {
          vm.restore_context();
        },
        setCurrent_account_id(s) {
          vm.set_current_account_id(readUTF8Str(s));
        },
        setInput(s) {
          vm.set_input(readUTF8Str(s));
        },
        setSigner_account_id(s) {
          vm.set_signer_account_id(readUTF8Str(s));
        }, // string
        /// The public key that was used to sign the original transaction that led to
        /// this execution.
        setSigner_account_pk(s) {
          vm.set_signer_account_pk(readUTF8Str(s));
        }, // string base58
        setPredecessor_account_id(s) {
          vm.set_predecessor_account_id(readUTF8Str(s));
        }, // string
        setBlock_index(block_height) {
          vm.set_block_index(block_height);
        }, // u128
        setBlock_timestamp(stmp) {
          vm.set_block_timestamp(stmp);
        },
        setAccount_balance(lo, hi) {
          //TODO: actually  u128
          vm.set_account_balance(lo, hi);
        },
        setAccount_locked_balance(lo, hi) {
          vm.set_account_locked_balance(lo, hi);
        },
        setStorage_usage(amt) {
          vm.set_storage_usage(amt);
        },
        setAttached_deposit(lo, hi) {
          vm.set_attached_deposit(lo, hi);
        },
        setPrepaid_gas(_u64) {
          vm.set_prepaid_gas(_u64);
        },
        setRandom_seed(s) {
          vm.set_random_seed(readUTF8Str(s));
        },
        setIs_view(b) {
          vm.set_is_view(b==1);
        },
        setOutput_data_receivers(arr) {
          vm.set_output_data_receivers(arr);
        },
      },
      env: {
        /// #################
        /// # Registers API #
        /// #################
        write_register(data_len, data_ptr, register_id) {
          return vm.write_register(data_len, data_ptr, register_id);
        },
        read_register(register_id, ptr) {
            return vm.read_register(register_id, ptr);
        },
        register_len(register_id) {
            return vm.register_len(register_id);
        },
        // ###############
        // # Context API #
        // ###############
        current_account_id(register_id) {
          return vm.current_account_id(register_id);
        },
        signer_account_id(register_id) {
          return vm.signer_account_id(register_id);
        },
        signer_account_pk(register_id) {
          return vm.signer_account_pk(register_id);
        },
        predecessor_account_id(register_id) {
          return vm.predecessor_account_id(register_id);
        },
        input(register_id) {
          return vm.input(register_id);
        },
        block_index() {
          return vm.block_index();
        },
        storage_usage() {
          return vm.storage_usage();
        },

        // #################
        // # Economics API #
        // #################
        account_balance(balance_ptr) {
          return vm.account_balance(balance_ptr);
        },
        attached_deposit(balance_ptr) {
          return vm.attached_deposit(balance_ptr);
        },
        prepaid_gas() {
          return vm.prepaid_gas();
        },
        used_gas() {
          return vm.used_gas();
        },

        // ############
        // # Math API #
        // ############
        random_seed(register_id) {
          return vm.random_seed(register_id);
        },
        sha256(value_len, value_ptr, register_id) {
          return vm.sha256(value_len, value_ptr, register_id);
        },
        keccak256(value_len, value_ptr, register_id) {
          return vm.keccak256(value_len, value_ptr, register_id);
        },
        keccak512(value_len, value_ptr, register_id) {
          return vm.keccak512(value_len, value_ptr, register_id);
        },

        // #####################
        // # Miscellaneous API #
        // #####################
        value_return(value_len, value_ptr) {
          return vm.value_return(value_len, value_ptr);
        },
        panic() {
          return vm.panic();
        },
        log_utf8(len, ptr) {
          return vm.log_utf8(len, ptr);
        },
        log_utf16(len, ptr) {
          return vm.log_utf16(len, ptr);
        },

        // ################
        // # Promises API #
        // ################
        promise_create(account_id_len,account_id_ptr,method_name_len,method_name_ptr,arguments_len, arguments_ptr, amount_ptr, gas) {
          return vm.promise_create(account_id_len,account_id_ptr,method_name_len,method_name_ptr,arguments_len, arguments_ptr, amount_ptr, gas);
        },
        promise_then( promise_index, account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
          return vm.promise_then( promise_index, account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas);
        },
        promise_and(promise_idx_ptr, promise_idx_count) {
          return vm.promise_and(promise_idx_ptr, promise_idx_count);
        },
        promise_results_count() {
          return vm.promise_results_count();
        },
        promise_result(result_idx, register_id) {
          return vm.promise_result(result_idx, register_id);
        },
        promise_return(promise_id) {
          return vm.promise_return(promise_id);
        },
        promise_batch_create(account_id_len, account_id_ptr) {
          return vm.promise_batch_create(account_id_len, account_id_ptr);
        },
        promise_batch_then(promise_index, account_id_len, account_id_ptr) {
          return vm.promise_batch_then(promise_index, account_id_len, account_id_ptr);
        },

        // #######################
        // # Promise API actions #
        // #######################
        promise_batch_action_create_account(promise_index) {
          return vm.promise_batch_action_create_account(promise_index);
        },
        promise_batch_action_deploy_contract(promise_index, code_len, code_ptr) {
          return vm.promise_batch_action_deploy_contract(promise_index, code_len, code_ptr);
        },
        promise_batch_action_function_call(promise_index, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
          return vm.promise_batch_action_function_call(promise_index, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas);
        },
        promise_batch_action_transfer(promise_index, amount_ptr) {
          return vm.promise_batch_action_transfer(promise_index, amount_ptr);
        },
        promise_batch_action_stake(promise_index, amount_ptr, public_key_len, public_key_ptr) {
          return vm.promise_batch_action_stake(promise_index, amount_ptr, public_key_len, public_key_ptr);
        },
        promise_batch_action_add_key_with_full_access(promise_index, public_key_len, public_key_ptr, nonce) {
          return vm.promise_batch_action_add_key_with_full_access(promise_index, public_key_len, public_key_ptr, nonce);
        },
        promise_batch_action_add_key_with_function_call(promise_index, public_key_len, public_key_ptr, nonce, allowance_ptr, receiver_id_len, receiver_id_ptr, method_names_len, method_names_ptr) {
          return vm.promise_batch_action_add_key_with_function_call(promise_index, public_key_len, public_key_ptr, nonce, allowance_ptr, receiver_id_len, receiver_id_ptr, method_names_len, method_names_ptr);
        },
        promise_batch_action_delete_key(promise_index, public_key_len, public_key_ptr) {
          return vm.promise_batch_action_delete_key(promise_index, public_key_len, public_key_ptr);
        },
        promise_batch_action_delete_account(promise_index, beneficiary_id_len, beneficiary_id_ptr) {
          return vm.promise_batch_action_delete_account(promise_index, beneficiary_id_len, beneficiary_id_ptr);
        },

        // ###############
        // # Storage API #
        // ###############
        storage_write(key_len, key_ptr, value_len, value_ptr, register_id) {
          return vm.storage_write(key_len, key_ptr, value_len, value_ptr, register_id);
        },
        storage_read(key_len, key_ptr, register_id) {
          return vm.storage_read(key_len, key_ptr, register_id);
        },
        storage_remove(key_len, key_ptr, register_id) {
          return vm.storage_remove(key_len, key_ptr, register_id);
        },
        storage_has_key(key_len, key_ptr) {
          return vm.storage_has_key(key_len, key_ptr);
        },
        storage_iter_prefix(prefix_len, prefix_ptr) {
          return vm.storage_iter_prefix(prefix_len, prefix_ptr);
        },
        storage_iter_range(start_len, start_ptr, end_len, end_ptr) {
          return vm.storage_iter_range(start_len, start_ptr, end_len, end_ptr);
        },
        storage_iter_next(iterator_id, key_register_id, value_register_id) {
          return vm.storage_iter_next(iterator_id, key_register_id, value_register_id);
        },
        // Function for the injected gas counter. Automatically called by the gas meter.
        gas(gas_amount) {
          return vm.gas(gas_amount);
        }
    }
  };
  // Save reference to the instance
  wasm = instantiateSync(binary, createImports(_imports));
  return wasm;
}

//add an extra entry file
flags = {};
flags[path.join(__dirname, "assembly", "entry.ts")] = [];

module.exports = {
     /**
   * A set of globs passed to the glob package that qualify typescript files for testing.
   */
  include: ["assembly/__tests__/**/*.spec.ts"],
  /**
   * A set of globs passed to the glob package that quality files to be added to each test.
   */
  add: ["assembly/__tests__/**/*.include.ts"],
  /**
   * All the compiler flags needed for this test suite. Make sure that a binary file is output.
   */
  flags: {
    ...flags,
    "--validate": [],
    "--debug": [],
    /** This is required. Do not change this. The filename is ignored, but required by the compiler. */
    "--binaryFile": ["output.wasm"],
    /** To enable wat file output, use the following flag. The filename is ignored, but required by the compiler. */
    // "--textFile": ["output.wat"],
    /** To select an appropriate runtime, use the --runtime compiler flag. */
    "--runtime": ["stub"], // Acceptable values are: full, half, stub (arena), and none,
    "--baseDir": process.cwd(),
    "--runPasses": ["inlining,dce"],
    "--transform": ["near-bindgen-as"]
  },
  /**
   * A set of regexp that will disclude source files from testing.
   */
  disclude: [/node_modules/],
  /**
   * Add your required AssemblyScript imports here.
   */
  imports: createImports,
  /**
   * All performance statistics reporting can be configured here.
   */
  performance: {
    /** Enable performance statistics gathering for every test. */
    enabled: false,
    /** Set the maximum number of samples to run for every test. */
    maxSamples: 10000,
    /** Set the maximum test run time in milliseconds for every test. */
    maxTestRunTime: 2000,
    /** Report the median time in the default reporter for every test. */
    reportMedian: true,
    /** Report the average time in milliseconds for every test. */
    reportAverage: true,
    /** Report the standard deviation for every test. */
    reportStandardDeviation: false,
    /** Report the maximum run time in milliseconds for every test. */
    reportMax: false,
    /** Report the minimum run time in milliseconds for every test. */
    reportMin: false,
  },
  /**
   * Add a custom reporter here if you want one. The following example is in typescript.
   *
   * @example
   * import { TestReporter, TestGroup, TestResult, TestContext } from "as-pect";
   *
   * export class CustomReporter extends TestReporter {
   *   // implement each abstract method here
   *   public abstract onStart(suite: TestContext): void;
   *   public abstract onGroupStart(group: TestGroup): void;
   *   public abstract onGroupFinish(group: TestGroup): void;
   *   public abstract onTestStart(group: TestGroup, result: TestResult): void;
   *   public abstract onTestFinish(group: TestGroup, result: TestResult): void;
   *   public abstract onFinish(suite: TestContext): void;
   * }
   */
  // reporter: new CustomReporter(),
  /**
   * Specify if the binary wasm file should be written to the file system.
   */
  outputBinary: false
};

'''
'''--- package.json ---
{
  "name": "wasm-mock-vm",
  "version": "1.2.1",
  "description": "Mock Near VM core logic for unit testing",
  "main": "./pkg/wasm_mock_vm.js",
  "types": "./assembly/index.ts",
  "author": "Willem Wyndham <willem@nearprotocol.com>",
  "repository": {
    "type": "git",
    "url": "git@:nearprotocol/wasm-mock-vm.git"
  },
  "license": "APACHE",
  "private": false,
  "devDependencies": {
    "assemblyscript": "^0.9.2",
    "bs58": "^4.0.1",
    "near-sdk-as": "^0.0.2"
  },
  "scripts": {
    "build": "./setup.sh && wasm-pack build --target nodejs",
    "build:debug": "yarn build --debug",
    "test": "asp"
  },
  "files": [
    "pkg/wasm*",
    "imports.js",
    "assembly/index.ts",
    "context.json",
    "assembly/*.ts"
  ],
  "engines": {
    "node": ">=12.0.0"
  }
}

'''
'''--- pkg/wasm_mock_vm.d.ts ---
/* tslint:disable */
/* eslint-disable */
/**
* @param {any} wasm_bin 
*/
export function run(wasm_bin: any): void;
export class VM {
  free(): void;
/**
* @param {any} context 
*/
  constructor(context: any);
/**
*/
  save_state(): void;
/**
*/
  restore_state(): void;
/**
*/
  save_context(): void;
/**
*/
  restore_context(): void;
/**
* @param {any} context 
*/
  set_context(context: any): void;
/**
* @param {any} s 
*/
  set_current_account_id(s: any): void;
/**
* @param {any} s 
*/
  set_input(s: any): void;
/**
* @param {any} s 
*/
  set_signer_account_id(s: any): void;
/**
* The public key that was used to sign the original transaction that led to
* this execution.
* @param {any} s 
*/
  set_signer_account_pk(s: any): void;
/**
* @param {any} s 
*/
  set_predecessor_account_id(s: any): void;
/**
* @param {BigInt} block_height 
*/
  set_block_index(block_height: BigInt): void;
/**
* @param {BigInt} stmp 
*/
  set_block_timestamp(stmp: BigInt): void;
/**
* @param {BigInt} lo 
* @param {BigInt} hi 
*/
  set_account_balance(lo: BigInt, hi: BigInt): void;
/**
* @param {BigInt} lo 
* @param {BigInt} hi 
*/
  set_account_locked_balance(lo: BigInt, hi: BigInt): void;
/**
* @param {any} amt 
*/
  set_storage_usage(amt: any): void;
/**
* @param {BigInt} lo 
* @param {BigInt} hi 
*/
  set_attached_deposit(lo: BigInt, hi: BigInt): void;
/**
* @param {BigInt} _u64 
*/
  set_prepaid_gas(_u64: BigInt): void;
/**
* @param {any} s 
*/
  set_random_seed(s: any): void;
/**
* @param {boolean} b 
*/
  set_is_view(b: boolean): void;
/**
* @param {any} arr 
*/
  set_output_data_receivers(arr: any): void;
/**
* #################
* # Registers API #
* #################
* Writes the entire content from the register `register_id` into the memory of the guest starting with `ptr`.
*
* # Arguments
*
* * `register_id` -- a register id from where to read the data;
* * `ptr` -- location on guest memory where to copy the data.
*
* # Errors
*
* * If the content extends outside the memory allocated to the guest. In Wasmer, it returns `MemoryAccessViolation` error message;
* * If `register_id` is pointing to unused register returns `InvalidRegisterId` error message.
*
* # Undefined Behavior
*
* If the content of register extends outside the preallocated memory on the host side, or the pointer points to a
* wrong location this function will overwrite memory that it is not supposed to overwrite causing an undefined behavior.
*
* # Cost
*
* `base + read_register_base + read_register_byte * num_bytes + write_memory_base + write_memory_byte * num_bytes`
* @param {BigInt} register_id 
* @param {BigInt} ptr 
*/
  read_register(register_id: BigInt, ptr: BigInt): void;
/**
* @param {BigInt} register_id 
* @returns {BigInt} 
*/
  register_len(register_id: BigInt): BigInt;
/**
* @param {BigInt} register_id 
* @param {BigInt} data_len 
* @param {BigInt} data_ptr 
*/
  write_register(register_id: BigInt, data_len: BigInt, data_ptr: BigInt): void;
/**
* ###################################
* # String reading helper functions #
* ###################################
* Helper function to read and return utf8-encoding string.
* If `len == u64::MAX` then treats the string as null-terminated with character `\'\\0\'`.
*
* # Errors
*
* * If string extends outside the memory of the guest with `MemoryAccessViolation`;
* * If string is not UTF-8 returns `BadUtf8`.
* * If string is longer than `max_log_len` returns `BadUtf8`.
*
* # Cost
*
* For not nul-terminated string:
* `read_memory_base + read_memory_byte * num_bytes + utf8_decoding_base + utf8_decoding_byte * num_bytes`
*
* For nul-terminated string:
* `(read_memory_base + read_memory_byte) * num_bytes + utf8_decoding_base + utf8_decoding_byte * num_bytes`
* Helper function to read UTF-16 formatted string from guest memory.
* # Errors
*
* * If string extends outside the memory of the guest with `MemoryAccessViolation`;
* * If string is not UTF-16 returns `BadUtf16`.
*
* # Cost
*
* For not nul-terminated string:
* `read_memory_base + read_memory_byte * num_bytes + utf16_decoding_base + utf16_decoding_byte * num_bytes`
*
* For nul-terminated string:
* `read_memory_base * num_bytes / 2 + read_memory_byte * num_bytes + utf16_decoding_base + utf16_decoding_byte * num_bytes`
* ###############
* # Context API #
* ###############
* Saves the account id of the current contract that we execute into the register.
*
* # Errors
*
* If the registers exceed the memory limit returns `MemoryAccessViolation`.
*
* # Cost
*
* `base + write_register_base + write_register_byte * num_bytes`
* @param {BigInt} register_id 
*/
  current_account_id(register_id: BigInt): void;
/**
* All contract calls are a result of some transaction that was signed by some account using
* some access key and submitted into a memory pool (either through the wallet using RPC or by
* a node itself). This function returns the id of that account. Saves the bytes of the signer
* account id into the register.
*
* # Errors
*
* * If the registers exceed the memory limit returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `base + write_register_base + write_register_byte * num_bytes`
* @param {BigInt} register_id 
*/
  signer_account_id(register_id: BigInt): void;
/**
* Saves the public key fo the access key that was used by the signer into the register. In
* rare situations smart contract might want to know the exact access key that was used to send
* the original transaction, e.g. to increase the allowance or manipulate with the public key.
*
* # Errors
*
* * If the registers exceed the memory limit returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `base + write_register_base + write_register_byte * num_bytes`
* @param {BigInt} register_id 
*/
  signer_account_pk(register_id: BigInt): void;
/**
* All contract calls are a result of a receipt, this receipt might be created by a transaction
* that does function invocation on the contract or another contract as a result of
* cross-contract call. Saves the bytes of the predecessor account id into the register.
*
* # Errors
*
* * If the registers exceed the memory limit returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `base + write_register_base + write_register_byte * num_bytes`
* @param {BigInt} register_id 
*/
  predecessor_account_id(register_id: BigInt): void;
/**
* Reads input to the contract call into the register. Input is expected to be in JSON-format.
* If input is provided saves the bytes (potentially zero) of input into register. If input is
* not provided writes 0 bytes into the register.
*
* # Cost
*
* `base + write_register_base + write_register_byte * num_bytes`
* @param {BigInt} register_id 
*/
  input(register_id: BigInt): void;
/**
* Returns the current block height.
*
* # Cost
*
* `base`
* TODO #1903 rename to `block_height`
* @returns {BigInt} 
*/
  block_index(): BigInt;
/**
* Returns the current block timestamp.
*
* # Cost
*
* `base`
* @returns {BigInt} 
*/
  block_timestamp(): BigInt;
/**
* Returns the number of bytes used by the contract if it was saved to the trie as of the
* invocation. This includes:
* * The data written with storage_* functions during current and previous execution;
* * The bytes needed to store the access keys of the given account.
* * The contract code size
* * A small fixed overhead for account metadata.
*
* # Cost
*
* `base`
* @returns {BigInt} 
*/
  storage_usage(): BigInt;
/**
* #################
* # Economics API #
* #################
* The current balance of the given account. This includes the attached_deposit that was
* attached to the transaction.
*
* # Cost
*
* `base + memory_write_base + memory_write_size * 16`
* @param {BigInt} balance_ptr 
*/
  account_balance(balance_ptr: BigInt): void;
/**
* The current amount of tokens locked due to staking.
*
* # Cost
*
* `base + memory_write_base + memory_write_size * 16`
* @param {BigInt} balance_ptr 
*/
  account_locked_balance(balance_ptr: BigInt): void;
/**
* The balance that was attached to the call that will be immediately deposited before the
* contract execution starts.
*
* # Errors
*
* If called as view function returns `ProhibitedInView``.
*
* # Cost
*
* `base + memory_write_base + memory_write_size * 16`
* @param {BigInt} balance_ptr 
*/
  attached_deposit(balance_ptr: BigInt): void;
/**
* The amount of gas attached to the call that can be used to pay for the gas fees.
*
* # Errors
*
* If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `base`
* @returns {BigInt} 
*/
  prepaid_gas(): BigInt;
/**
* The gas that was already burnt during the contract execution (cannot exceed `prepaid_gas`)
*
* # Errors
*
* If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `base`
* @returns {BigInt} 
*/
  used_gas(): BigInt;
/**
* ############
* # Math API #
* ############
* Writes random seed into the register.
*
* # Errors
*
* If the size of the registers exceed the set limit `MemoryAccessViolation`.
*
* # Cost
*
* `base + write_register_base + write_register_byte * num_bytes`.
* @param {BigInt} register_id 
*/
  random_seed(register_id: BigInt): void;
/**
* Hashes the random sequence of bytes using sha256 and returns it into `register_id`.
*
* # Errors
*
* If `value_len + value_ptr` points outside the memory or the registers use more memory than
* the limit with `MemoryAccessViolation`.
*
* # Cost
*
* `base + write_register_base + write_register_byte * num_bytes + sha256_base + sha256_byte * num_bytes`
* @param {BigInt} value_len 
* @param {BigInt} value_ptr 
* @param {BigInt} register_id 
*/
  sha256(value_len: BigInt, value_ptr: BigInt, register_id: BigInt): void;
/**
* Called by gas metering injected into Wasm. Counts both towards `burnt_gas` and `used_gas`.
*
* # Errors
*
* * If passed gas amount somehow overflows internal gas counters returns `IntegerOverflow`;
* * If we exceed usage limit imposed on burnt gas returns `GasLimitExceeded`;
* * If we exceed the `prepaid_gas` then returns `GasExceeded`.
* @param {number} gas_amount 
*/
  gas(gas_amount: number): void;
/**
* ################
* # Promises API #
* ################
* A helper function to pay gas fee for creating a new receipt without actions.
* # Args:
* * `sir`: whether contract call is addressed to itself;
* * `data_dependencies`: other contracts that this execution will be waiting on (or rather
*   their data receipts), where bool indicates whether this is sender=receiver communication.
*
* # Cost
*
* This is a convenience function that encapsulates several costs:
* `burnt_gas := dispatch cost of the receipt + base dispatch cost  cost of the data receipt`
* `used_gas := burnt_gas + exec cost of the receipt + base exec cost  cost of the data receipt`
* Notice that we prepay all base cost upon the creation of the data dependency, we are going to
* pay for the content transmitted through the dependency upon the actual creation of the
* DataReceipt.
* A helper function to subtract balance on transfer or attached deposit for promises.
* # Args:
* * `amount`: the amount to deduct from the current account balance.
* Creates a promise that will execute a method on account with given arguments and attaches
* the given amount and gas. `amount_ptr` point to slices of bytes representing `u128`.
*
* # Errors
*
* * If `account_id_len + account_id_ptr` or `method_name_len + method_name_ptr` or
* `arguments_len + arguments_ptr` or `amount_ptr + 16` points outside the memory of the guest
* or host returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Returns
*
* Index of the new promise that uniquely identifies it within the current execution of the
* method.
*
* # Cost
*
* Since `promise_create` is a convenience wrapper around `promise_batch_create` and
* `promise_batch_action_function_call`. This also means it charges `base` cost twice.
* @param {BigInt} account_id_len 
* @param {BigInt} account_id_ptr 
* @param {BigInt} method_name_len 
* @param {BigInt} method_name_ptr 
* @param {BigInt} arguments_len 
* @param {BigInt} arguments_ptr 
* @param {BigInt} amount_ptr 
* @param {BigInt} gas 
* @returns {BigInt} 
*/
  promise_create(account_id_len: BigInt, account_id_ptr: BigInt, method_name_len: BigInt, method_name_ptr: BigInt, arguments_len: BigInt, arguments_ptr: BigInt, amount_ptr: BigInt, gas: BigInt): BigInt;
/**
* Attaches the callback that is executed after promise pointed by `promise_idx` is complete.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`;
* * If `account_id_len + account_id_ptr` or `method_name_len + method_name_ptr` or
*   `arguments_len + arguments_ptr` or `amount_ptr + 16` points outside the memory of the
*   guest or host returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Returns
*
* Index of the new promise that uniquely identifies it within the current execution of the
* method.
*
* # Cost
*
* Since `promise_create` is a convenience wrapper around `promise_batch_then` and
* `promise_batch_action_function_call`. This also means it charges `base` cost twice.
* @param {BigInt} promise_idx 
* @param {BigInt} account_id_len 
* @param {BigInt} account_id_ptr 
* @param {BigInt} method_name_len 
* @param {BigInt} method_name_ptr 
* @param {BigInt} arguments_len 
* @param {BigInt} arguments_ptr 
* @param {BigInt} amount_ptr 
* @param {BigInt} gas 
* @returns {BigInt} 
*/
  promise_then(promise_idx: BigInt, account_id_len: BigInt, account_id_ptr: BigInt, method_name_len: BigInt, method_name_ptr: BigInt, arguments_len: BigInt, arguments_ptr: BigInt, amount_ptr: BigInt, gas: BigInt): BigInt;
/**
* Creates a new promise which completes when time all promises passed as arguments complete.
* Cannot be used with registers. `promise_idx_ptr` points to an array of `u64` elements, with
* `promise_idx_count` denoting the number of elements. The array contains indices of promises
* that need to be waited on jointly.
*
* # Errors
*
* * If `promise_ids_ptr + 8 * promise_idx_count` extend outside the guest memory returns
*   `MemoryAccessViolation`;
* * If any of the promises in the array do not correspond to existing promises returns
*   `InvalidPromiseIndex`.
* * If called as view function returns `ProhibitedInView`.
*
* # Returns
*
* Index of the new promise that uniquely identifies it within the current execution of the
* method.
*
* # Cost
*
* `base + promise_and_base + promise_and_per_promise * num_promises + cost of reading promise ids from memory`.
* @param {BigInt} promise_idx_ptr 
* @param {BigInt} promise_idx_count 
* @returns {BigInt} 
*/
  promise_and(promise_idx_ptr: BigInt, promise_idx_count: BigInt): BigInt;
/**
* Creates a new promise towards given `account_id` without any actions attached to it.
*
* # Errors
*
* * If `account_id_len + account_id_ptr` points outside the memory of the guest or host
* returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Returns
*
* Index of the new promise that uniquely identifies it within the current execution of the
* method.
*
* # Cost
*
* `burnt_gas := base + cost of reading and decoding the account id + dispatch cost of the receipt`.
* `used_gas := burnt_gas + exec cost of the receipt`.
* @param {BigInt} account_id_len 
* @param {BigInt} account_id_ptr 
* @returns {BigInt} 
*/
  promise_batch_create(account_id_len: BigInt, account_id_ptr: BigInt): BigInt;
/**
* Creates a new promise towards given `account_id` without any actions attached, that is
* executed after promise pointed by `promise_idx` is complete.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`;
* * If `account_id_len + account_id_ptr` points outside the memory of the guest or host
* returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Returns
*
* Index of the new promise that uniquely identifies it within the current execution of the
* method.
*
* # Cost
*
* `base + cost of reading and decoding the account id + dispatch&execution cost of the receipt
*  + dispatch&execution base cost for each data dependency`
* @param {BigInt} promise_idx 
* @param {BigInt} account_id_len 
* @param {BigInt} account_id_ptr 
* @returns {BigInt} 
*/
  promise_batch_then(promise_idx: BigInt, account_id_len: BigInt, account_id_ptr: BigInt): BigInt;
/**
* Appends `CreateAccount` action to the batch of actions for the given promise pointed by
* `promise_idx`.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action fee`
* `used_gas := burnt_gas + exec action fee`
* @param {BigInt} promise_idx 
*/
  promise_batch_action_create_account(promise_idx: BigInt): void;
/**
* Appends `DeployContract` action to the batch of actions for the given promise pointed by
* `promise_idx`.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If `code_len + code_ptr` points outside the memory of the guest or host returns
* `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory `
* `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
* @param {BigInt} promise_idx 
* @param {BigInt} code_len 
* @param {BigInt} code_ptr 
*/
  promise_batch_action_deploy_contract(promise_idx: BigInt, code_len: BigInt, code_ptr: BigInt): void;
/**
* Appends `FunctionCall` action to the batch of actions for the given promise pointed by
* `promise_idx`.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If `method_name_len + method_name_ptr` or `arguments_len + arguments_ptr` or
* `amount_ptr + 16` points outside the memory of the guest or host returns
* `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory
*  + cost of reading u128, method_name and arguments from the memory`
* `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
* @param {BigInt} promise_idx 
* @param {BigInt} method_name_len 
* @param {BigInt} method_name_ptr 
* @param {BigInt} arguments_len 
* @param {BigInt} arguments_ptr 
* @param {BigInt} amount_ptr 
* @param {BigInt} gas 
*/
  promise_batch_action_function_call(promise_idx: BigInt, method_name_len: BigInt, method_name_ptr: BigInt, arguments_len: BigInt, arguments_ptr: BigInt, amount_ptr: BigInt, gas: BigInt): void;
/**
* Appends `Transfer` action to the batch of actions for the given promise pointed by
* `promise_idx`.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If `amount_ptr + 16` points outside the memory of the guest or host returns
* `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading u128 from memory `
* `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
* @param {BigInt} promise_idx 
* @param {BigInt} amount_ptr 
*/
  promise_batch_action_transfer(promise_idx: BigInt, amount_ptr: BigInt): void;
/**
* Appends `Stake` action to the batch of actions for the given promise pointed by
* `promise_idx`.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
* * If `amount_ptr + 16` or `public_key_len + public_key_ptr` points outside the memory of the
* guest or host returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
* `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
* @param {BigInt} promise_idx 
* @param {BigInt} amount_ptr 
* @param {BigInt} public_key_len 
* @param {BigInt} public_key_ptr 
*/
  promise_batch_action_stake(promise_idx: BigInt, amount_ptr: BigInt, public_key_len: BigInt, public_key_ptr: BigInt): void;
/**
* Appends `AddKey` action to the batch of actions for the given promise pointed by
* `promise_idx`. The access key will have `FullAccess` permission.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
* * If `public_key_len + public_key_ptr` points outside the memory of the guest or host
* returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
* `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
* @param {BigInt} promise_idx 
* @param {BigInt} public_key_len 
* @param {BigInt} public_key_ptr 
* @param {BigInt} nonce 
*/
  promise_batch_action_add_key_with_full_access(promise_idx: BigInt, public_key_len: BigInt, public_key_ptr: BigInt, nonce: BigInt): void;
/**
* Appends `AddKey` action to the batch of actions for the given promise pointed by
* `promise_idx`. The access key will have `FunctionCall` permission.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
* * If `public_key_len + public_key_ptr`, `allowance_ptr + 16`,
* `receiver_id_len + receiver_id_ptr` or `method_names_len + method_names_ptr` points outside
* the memory of the guest or host returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory
*  + cost of reading u128, method_names and public key from the memory + cost of reading and parsing account name`
* `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
* @param {BigInt} promise_idx 
* @param {BigInt} public_key_len 
* @param {BigInt} public_key_ptr 
* @param {BigInt} nonce 
* @param {BigInt} allowance_ptr 
* @param {BigInt} receiver_id_len 
* @param {BigInt} receiver_id_ptr 
* @param {BigInt} method_names_len 
* @param {BigInt} method_names_ptr 
*/
  promise_batch_action_add_key_with_function_call(promise_idx: BigInt, public_key_len: BigInt, public_key_ptr: BigInt, nonce: BigInt, allowance_ptr: BigInt, receiver_id_len: BigInt, receiver_id_ptr: BigInt, method_names_len: BigInt, method_names_ptr: BigInt): void;
/**
* Appends `DeleteKey` action to the batch of actions for the given promise pointed by
* `promise_idx`.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
* * If `public_key_len + public_key_ptr` points outside the memory of the guest or host
* returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
* `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
* @param {BigInt} promise_idx 
* @param {BigInt} public_key_len 
* @param {BigInt} public_key_ptr 
*/
  promise_batch_action_delete_key(promise_idx: BigInt, public_key_len: BigInt, public_key_ptr: BigInt): void;
/**
* Appends `DeleteAccount` action to the batch of actions for the given promise pointed by
* `promise_idx`.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If the promise pointed by the `promise_idx` is an ephemeral promise created by
* `promise_and` returns `CannotAppendActionToJointPromise`.
* * If `beneficiary_id_len + beneficiary_id_ptr` points outside the memory of the guest or
* host returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading and parsing account id from memory `
* `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
* @param {BigInt} promise_idx 
* @param {BigInt} beneficiary_id_len 
* @param {BigInt} beneficiary_id_ptr 
*/
  promise_batch_action_delete_account(promise_idx: BigInt, beneficiary_id_len: BigInt, beneficiary_id_ptr: BigInt): void;
/**
* If the current function is invoked by a callback we can access the execution results of the
* promises that caused the callback. This function returns the number of complete and
* incomplete callbacks.
*
* Note, we are only going to have incomplete callbacks once we have promise_or combinator.
*
*
* * If there is only one callback returns `1`;
* * If there are multiple callbacks (e.g. created through `promise_and`) returns their number;
* * If the function was called not through the callback returns `0`.
*
* # Cost
*
* `base`
* @returns {BigInt} 
*/
  promise_results_count(): BigInt;
/**
* If the current function is invoked by a callback we can access the execution results of the
* promises that caused the callback. This function returns the result in blob format and
* places it into the register.
*
* * If promise result is complete and successful copies its blob into the register;
* * If promise result is complete and failed or incomplete keeps register unused;
*
* # Returns
*
* * If promise result is not complete returns `0`;
* * If promise result is complete and successful returns `1`;
* * If promise result is complete and failed returns `2`.
*
* # Errors
*
* * If `result_id` does not correspond to an existing result returns `InvalidPromiseResultIndex`;
* * If copying the blob exhausts the memory limit it returns `MemoryAccessViolation`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `base + cost of writing data into a register`
* @param {BigInt} result_idx 
* @param {BigInt} register_id 
* @returns {BigInt} 
*/
  promise_result(result_idx: BigInt, register_id: BigInt): BigInt;
/**
* When promise `promise_idx` finishes executing its result is considered to be the result of
* the current function.
*
* # Errors
*
* * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
* * If called as view function returns `ProhibitedInView`.
*
* # Cost
*
* `base + promise_return`
* @param {BigInt} promise_idx 
*/
  promise_return(promise_idx: BigInt): void;
/**
* #####################
* # Miscellaneous API #
* #####################
* sets the blob of data as the return value of the contract.
*
* # Errors
*
* If `value_len + value_ptr` exceeds the memory container or points to an unused register it
* returns `MemoryAccessViolation`.
*
* # Cost
* `base + cost of reading return value from memory or register + dispatch&exec cost per byte of the data sent * num data receivers`
* @param {BigInt} value_len 
* @param {BigInt} value_ptr 
*/
  value_return(value_len: BigInt, value_ptr: BigInt): void;
/**
* Terminates the execution of the program with panic `GuestPanic`.
*
* # Cost
*
* `base`
*/
  panic(): void;
/**
* Guest panics with the UTF-8 encoded string.
* If `len == u64::MAX` then treats the string as null-terminated with character `\'\\0\'`.
*
* # Errors
*
* * If string extends outside the memory of the guest with `MemoryAccessViolation`;
* * If string is not UTF-8 returns `BadUtf8`.
* * If string is longer than `max_log_len` returns `BadUtf8`.
*
* # Cost
* `base + cost of reading and decoding a utf8 string`
* @param {BigInt} len 
* @param {BigInt} ptr 
*/
  panic_utf8(len: BigInt, ptr: BigInt): void;
/**
* Logs the UTF-8 encoded string.
* If `len == u64::MAX` then treats the string as null-terminated with character `\'\\0\'`.
*
* # Errors
*
* * If string extends outside the memory of the guest with `MemoryAccessViolation`;
* * If string is not UTF-8 returns `BadUtf8`.
* * If string is longer than `max_log_len` returns `BadUtf8`.
*
* # Cost
*
* `base + log_base + log_byte + num_bytes + utf8 decoding cost`
* @param {BigInt} len 
* @param {BigInt} ptr 
*/
  log_utf8(len: BigInt, ptr: BigInt): void;
/**
* Logs the UTF-16 encoded string. If `len == u64::MAX` then treats the string as
* null-terminated with two-byte sequence of `0x00 0x00`.
*
* # Errors
*
* * If string extends outside the memory of the guest with `MemoryAccessViolation`;
* * If string is not UTF-16 returns `BadUtf16`.
*
* # Cost
*
* `base + log_base + log_byte * num_bytes + utf16 decoding cost`
* @param {BigInt} len 
* @param {BigInt} ptr 
*/
  log_utf16(len: BigInt, ptr: BigInt): void;
/**
* Special import kept for compatibility with AssemblyScript contracts. Not called by smart
* contracts directly, but instead called by the code generated by AssemblyScript.
*
* # Cost
*
* `base +  log_base + log_byte * num_bytes + utf16 decoding cost`
* @param {number} msg_ptr 
* @param {number} filename_ptr 
* @param {number} line 
* @param {number} col 
*/
  abort(msg_ptr: number, filename_ptr: number, line: number, col: number): void;
/**
* ###############
* # Storage API #
* ###############
* Reads account id from the given location in memory.
*
* # Errors
*
* * If account is not UTF-8 encoded then returns `BadUtf8`;
*
* # Cost
*
* This is a helper function that encapsulates the following costs:
* cost of reading buffer from register or memory,
* `utf8_decoding_base + utf8_decoding_byte * num_bytes`.
* Writes key-value into storage.
* * If key is not in use it inserts the key-value pair and does not modify the register. Returns `0`;
* * If key is in use it inserts the key-value and copies the old value into the `register_id`. Returns `1`.
*
* # Errors
*
* * If `key_len + key_ptr` or `value_len + value_ptr` exceeds the memory container or points
*   to an unused register it returns `MemoryAccessViolation`;
* * If returning the preempted value into the registers exceed the memory container it returns
*   `MemoryAccessViolation`.
*
* # Cost
*
* `base + storage_write_base + storage_write_key_byte * num_key_bytes + storage_write_value_byte * num_value_bytes
* + get_vec_from_memory_or_register_cost x 2`.
*
* If a value was evicted it costs additional `storage_write_value_evicted_byte * num_evicted_bytes + internal_write_register_cost`.
* @param {BigInt} key_len 
* @param {BigInt} key_ptr 
* @param {BigInt} value_len 
* @param {BigInt} value_ptr 
* @param {BigInt} register_id 
* @returns {BigInt} 
*/
  storage_write(key_len: BigInt, key_ptr: BigInt, value_len: BigInt, value_ptr: BigInt, register_id: BigInt): BigInt;
/**
* Reads the value stored under the given key.
* * If key is used copies the content of the value into the `register_id`, even if the content
*   is zero bytes. Returns `1`;
* * If key is not present then does not modify the register. Returns `0`;
*
* # Errors
*
* * If `key_len + key_ptr` exceeds the memory container or points to an unused register it
*   returns `MemoryAccessViolation`;
* * If returning the preempted value into the registers exceed the memory container it returns
*   `MemoryAccessViolation`.
*
* # Cost
*
* `base + storage_read_base + storage_read_key_byte * num_key_bytes + storage_read_value_byte + num_value_bytes
*  cost to read key from register + cost to write value into register`.
* @param {BigInt} key_len 
* @param {BigInt} key_ptr 
* @param {BigInt} register_id 
* @returns {BigInt} 
*/
  storage_read(key_len: BigInt, key_ptr: BigInt, register_id: BigInt): BigInt;
/**
* Removes the value stored under the given key.
* * If key is used, removes the key-value from the trie and copies the content of the value
*   into the `register_id`, even if the content is zero bytes. Returns `1`;
* * If key is not present then does not modify the register. Returns `0`.
*
* # Errors
*
* * If `key_len + key_ptr` exceeds the memory container or points to an unused register it
*   returns `MemoryAccessViolation`;
* * If the registers exceed the memory limit returns `MemoryAccessViolation`;
* * If returning the preempted value into the registers exceed the memory container it returns
*   `MemoryAccessViolation`.
*
* # Cost
*
* `base + storage_remove_base + storage_remove_key_byte * num_key_bytes + storage_remove_ret_value_byte * num_value_bytes
* + cost to read the key + cost to write the value`.
* @param {BigInt} key_len 
* @param {BigInt} key_ptr 
* @param {BigInt} register_id 
* @returns {BigInt} 
*/
  storage_remove(key_len: BigInt, key_ptr: BigInt, register_id: BigInt): BigInt;
/**
* Checks if there is a key-value pair.
* * If key is used returns `1`, even if the value is zero bytes;
* * Otherwise returns `0`.
*
* # Errors
*
* If `key_len + key_ptr` exceeds the memory container it returns `MemoryAccessViolation`.
*
* # Cost
*
* `base + storage_has_key_base + storage_has_key_byte * num_bytes + cost of reading key`
* @param {BigInt} key_len 
* @param {BigInt} key_ptr 
* @returns {BigInt} 
*/
  storage_has_key(key_len: BigInt, key_ptr: BigInt): BigInt;
/**
* Creates an iterator object inside the host. Returns the identifier that uniquely
* differentiates the given iterator from other iterators that can be simultaneously created.
* * It iterates over the keys that have the provided prefix. The order of iteration is defined
*   by the lexicographic order of the bytes in the keys;
* * If there are no keys, it creates an empty iterator, see below on empty iterators.
*
* # Errors
*
* If `prefix_len + prefix_ptr` exceeds the memory container it returns `MemoryAccessViolation`.
*
* # Cost
*
* `base + storage_iter_create_prefix_base + storage_iter_create_key_byte * num_prefix_bytes
*  cost of reading the prefix`.
* @param {BigInt} prefix_len 
* @param {BigInt} prefix_ptr 
* @returns {BigInt} 
*/
  storage_iter_prefix(prefix_len: BigInt, prefix_ptr: BigInt): BigInt;
/**
* Iterates over all key-values such that keys are between `start` and `end`, where `start` is
* inclusive and `end` is exclusive. Unless lexicographically `start < end`, it creates an
* empty iterator. Note, this definition allows for `start` or `end` keys to not actually exist
* on the given trie.
*
* # Errors
*
* If `start_len + start_ptr` or `end_len + end_ptr` exceeds the memory container or points to
* an unused register it returns `MemoryAccessViolation`.
*
* # Cost
*
* `base + storage_iter_create_range_base + storage_iter_create_from_byte * num_from_bytes
*  + storage_iter_create_to_byte * num_to_bytes + reading from prefix + reading to prefix`.
* @param {BigInt} start_len 
* @param {BigInt} start_ptr 
* @param {BigInt} end_len 
* @param {BigInt} end_ptr 
* @returns {BigInt} 
*/
  storage_iter_range(start_len: BigInt, start_ptr: BigInt, end_len: BigInt, end_ptr: BigInt): BigInt;
/**
* Advances iterator and saves the next key and value in the register.
* * If iterator is not empty (after calling next it points to a key-value), copies the key
*   into `key_register_id` and value into `value_register_id` and returns `1`;
* * If iterator is empty returns `0`;
* This allows us to iterate over the keys that have zero bytes stored in values.
*
* # Errors
*
* * If `key_register_id == value_register_id` returns `MemoryAccessViolation`;
* * If the registers exceed the memory limit returns `MemoryAccessViolation`;
* * If `iterator_id` does not correspond to an existing iterator returns `InvalidIteratorId`;
* * If between the creation of the iterator and calling `storage_iter_next` the range over
*   which it iterates was modified returns `IteratorWasInvalidated`. Specifically, if
*   `storage_write` or `storage_remove` was invoked on the key key such that:
*   * in case of `storage_iter_prefix`. `key` has the given prefix and:
*     * Iterator was not called next yet.
*     * `next` was already called on the iterator and it is currently pointing at the `key`
*       `curr` such that `curr <= key`.
*   * in case of `storage_iter_range`. `start<=key<end` and:
*     * Iterator was not called `next` yet.
*     * `next` was already called on the iterator and it is currently pointing at the key
*       `curr` such that `curr<=key<end`.
*
* # Cost
*
* `base + storage_iter_next_base + storage_iter_next_key_byte * num_key_bytes + storage_iter_next_value_byte * num_value_bytes
*  + writing key to register + writing value to register`.
* @param {BigInt} iterator_id 
* @param {BigInt} key_register_id 
* @param {BigInt} value_register_id 
* @returns {BigInt} 
*/
  storage_iter_next(iterator_id: BigInt, key_register_id: BigInt, value_register_id: BigInt): BigInt;
/**
*Computes the outcome of execution.
* @returns {any} 
*/
  outcome(): any;
}

'''
'''--- pkg/wasm_mock_vm.js ---
let imports = {};
imports['__wbindgen_placeholder__'] = module.exports;
let wasm;
const { TextDecoder } = require(String.raw`util`);

const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachegetFloat64Memory0 = null;
function getFloat64Memory0() {
    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {
        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachegetFloat64Memory0;
}

let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}

let WASM_VECTOR_LEN = 0;

let cachegetNodeBufferMemory0 = null;
function getNodeBufferMemory0() {
    if (cachegetNodeBufferMemory0 === null || cachegetNodeBufferMemory0.buffer !== wasm.memory.buffer) {
        cachegetNodeBufferMemory0 = Buffer.from(wasm.memory.buffer);
    }
    return cachegetNodeBufferMemory0;
}

function passStringToWasm0(arg, malloc) {

    const len = Buffer.byteLength(arg);
    const ptr = malloc(len);
    getNodeBufferMemory0().write(arg, ptr, len);
    WASM_VECTOR_LEN = len;
    return ptr;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

const u32CvtShim = new Uint32Array(2);

const uint64CvtShim = new BigUint64Array(u32CvtShim.buffer);

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
* @param {any} wasm_bin
*/
module.exports.run = function(wasm_bin) {
    wasm.run(addHeapObject(wasm_bin));
};

function handleError(e) {
    wasm.__wbindgen_exn_store(addHeapObject(e));
}
/**
*/
class VM {

    static __wrap(ptr) {
        const obj = Object.create(VM.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_vm_free(ptr);
    }
    /**
    * @param {any} context
    */
    constructor(context) {
        var ret = wasm.vm_new(addHeapObject(context));
        return VM.__wrap(ret);
    }
    /**
    */
    save_state() {
        wasm.vm_save_state(this.ptr);
    }
    /**
    */
    restore_state() {
        wasm.vm_restore_state(this.ptr);
    }
    /**
    */
    save_context() {
        wasm.vm_save_context(this.ptr);
    }
    /**
    */
    restore_context() {
        wasm.vm_restore_context(this.ptr);
    }
    /**
    * @param {any} context
    */
    set_context(context) {
        wasm.vm_set_context(this.ptr, addHeapObject(context));
    }
    /**
    * @param {any} s
    */
    set_current_account_id(s) {
        wasm.vm_set_current_account_id(this.ptr, addHeapObject(s));
    }
    /**
    * @param {any} s
    */
    set_input(s) {
        wasm.vm_set_input(this.ptr, addHeapObject(s));
    }
    /**
    * @param {any} s
    */
    set_signer_account_id(s) {
        wasm.vm_set_signer_account_id(this.ptr, addHeapObject(s));
    }
    /**
    * The public key that was used to sign the original transaction that led to
    * this execution.
    * @param {any} s
    */
    set_signer_account_pk(s) {
        wasm.vm_set_signer_account_pk(this.ptr, addHeapObject(s));
    }
    /**
    * @param {any} s
    */
    set_predecessor_account_id(s) {
        wasm.vm_set_predecessor_account_id(this.ptr, addHeapObject(s));
    }
    /**
    * @param {BigInt} block_height
    */
    set_block_index(block_height) {
        uint64CvtShim[0] = block_height;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_set_block_index(this.ptr, low0, high0);
    }
    /**
    * @param {BigInt} stmp
    */
    set_block_timestamp(stmp) {
        uint64CvtShim[0] = stmp;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_set_block_timestamp(this.ptr, low0, high0);
    }
    /**
    * @param {BigInt} lo
    * @param {BigInt} hi
    */
    set_account_balance(lo, hi) {
        uint64CvtShim[0] = lo;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = hi;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_set_account_balance(this.ptr, low0, high0, low1, high1);
    }
    /**
    * @param {BigInt} lo
    * @param {BigInt} hi
    */
    set_account_locked_balance(lo, hi) {
        uint64CvtShim[0] = lo;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = hi;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_set_account_locked_balance(this.ptr, low0, high0, low1, high1);
    }
    /**
    * @param {any} amt
    */
    set_storage_usage(amt) {
        wasm.vm_set_storage_usage(this.ptr, addHeapObject(amt));
    }
    /**
    * @param {BigInt} lo
    * @param {BigInt} hi
    */
    set_attached_deposit(lo, hi) {
        uint64CvtShim[0] = lo;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = hi;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_set_attached_deposit(this.ptr, low0, high0, low1, high1);
    }
    /**
    * @param {BigInt} _u64
    */
    set_prepaid_gas(_u64) {
        uint64CvtShim[0] = _u64;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_set_prepaid_gas(this.ptr, low0, high0);
    }
    /**
    * @param {any} s
    */
    set_random_seed(s) {
        wasm.vm_set_random_seed(this.ptr, addHeapObject(s));
    }
    /**
    * @param {boolean} b
    */
    set_is_view(b) {
        wasm.vm_set_is_view(this.ptr, b);
    }
    /**
    * @param {any} arr
    */
    set_output_data_receivers(arr) {
        wasm.vm_set_output_data_receivers(this.ptr, addHeapObject(arr));
    }
    /**
    * #################
    * # Registers API #
    * #################
    * Writes the entire content from the register `register_id` into the memory of the guest starting with `ptr`.
    *
    * # Arguments
    *
    * * `register_id` -- a register id from where to read the data;
    * * `ptr` -- location on guest memory where to copy the data.
    *
    * # Errors
    *
    * * If the content extends outside the memory allocated to the guest. In Wasmer, it returns `MemoryAccessViolation` error message;
    * * If `register_id` is pointing to unused register returns `InvalidRegisterId` error message.
    *
    * # Undefined Behavior
    *
    * If the content of register extends outside the preallocated memory on the host side, or the pointer points to a
    * wrong location this function will overwrite memory that it is not supposed to overwrite causing an undefined behavior.
    *
    * # Cost
    *
    * `base + read_register_base + read_register_byte * num_bytes + write_memory_base + write_memory_byte * num_bytes`
    * @param {BigInt} register_id
    * @param {BigInt} ptr
    */
    read_register(register_id, ptr) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_read_register(this.ptr, low0, high0, low1, high1);
    }
    /**
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    register_len(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_register_len(8, this.ptr, low0, high0);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n1 = uint64CvtShim[0];
        return n1;
    }
    /**
    * @param {BigInt} register_id
    * @param {BigInt} data_len
    * @param {BigInt} data_ptr
    */
    write_register(register_id, data_len, data_ptr) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = data_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = data_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_write_register(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * ###################################
    * # String reading helper functions #
    * ###################################
    * Helper function to read and return utf8-encoding string.
    * If `len == u64::MAX` then treats the string as null-terminated with character `\'\\0\'`.
    *
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-8 returns `BadUtf8`.
    * * If string is longer than `max_log_len` returns `BadUtf8`.
    *
    * # Cost
    *
    * For not nul-terminated string:
    * `read_memory_base + read_memory_byte * num_bytes + utf8_decoding_base + utf8_decoding_byte * num_bytes`
    *
    * For nul-terminated string:
    * `(read_memory_base + read_memory_byte) * num_bytes + utf8_decoding_base + utf8_decoding_byte * num_bytes`
    * Helper function to read UTF-16 formatted string from guest memory.
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-16 returns `BadUtf16`.
    *
    * # Cost
    *
    * For not nul-terminated string:
    * `read_memory_base + read_memory_byte * num_bytes + utf16_decoding_base + utf16_decoding_byte * num_bytes`
    *
    * For nul-terminated string:
    * `read_memory_base * num_bytes / 2 + read_memory_byte * num_bytes + utf16_decoding_base + utf16_decoding_byte * num_bytes`
    * ###############
    * # Context API #
    * ###############
    * Saves the account id of the current contract that we execute into the register.
    *
    * # Errors
    *
    * If the registers exceed the memory limit returns `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    current_account_id(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_current_account_id(this.ptr, low0, high0);
    }
    /**
    * All contract calls are a result of some transaction that was signed by some account using
    * some access key and submitted into a memory pool (either through the wallet using RPC or by
    * a node itself). This function returns the id of that account. Saves the bytes of the signer
    * account id into the register.
    *
    * # Errors
    *
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    signer_account_id(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_signer_account_id(this.ptr, low0, high0);
    }
    /**
    * Saves the public key fo the access key that was used by the signer into the register. In
    * rare situations smart contract might want to know the exact access key that was used to send
    * the original transaction, e.g. to increase the allowance or manipulate with the public key.
    *
    * # Errors
    *
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    signer_account_pk(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_signer_account_pk(this.ptr, low0, high0);
    }
    /**
    * All contract calls are a result of a receipt, this receipt might be created by a transaction
    * that does function invocation on the contract or another contract as a result of
    * cross-contract call. Saves the bytes of the predecessor account id into the register.
    *
    * # Errors
    *
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    predecessor_account_id(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_predecessor_account_id(this.ptr, low0, high0);
    }
    /**
    * Reads input to the contract call into the register. Input is expected to be in JSON-format.
    * If input is provided saves the bytes (potentially zero) of input into register. If input is
    * not provided writes 0 bytes into the register.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    input(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_input(this.ptr, low0, high0);
    }
    /**
    * Returns the current block height.
    *
    * # Cost
    *
    * `base`
    * TODO #1903 rename to `block_height`
    * @returns {BigInt}
    */
    block_index() {
        wasm.vm_block_index(8, this.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n0 = uint64CvtShim[0];
        return n0;
    }
    /**
    * Returns the current block timestamp.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    block_timestamp() {
        wasm.vm_block_timestamp(8, this.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n0 = uint64CvtShim[0];
        return n0;
    }
    /**
    * Returns the number of bytes used by the contract if it was saved to the trie as of the
    * invocation. This includes:
    * * The data written with storage_* functions during current and previous execution;
    * * The bytes needed to store the access keys of the given account.
    * * The contract code size
    * * A small fixed overhead for account metadata.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    storage_usage() {
        wasm.vm_storage_usage(8, this.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n0 = uint64CvtShim[0];
        return n0;
    }
    /**
    * #################
    * # Economics API #
    * #################
    * The current balance of the given account. This includes the attached_deposit that was
    * attached to the transaction.
    *
    * # Cost
    *
    * `base + memory_write_base + memory_write_size * 16`
    * @param {BigInt} balance_ptr
    */
    account_balance(balance_ptr) {
        uint64CvtShim[0] = balance_ptr;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_account_balance(this.ptr, low0, high0);
    }
    /**
    * The current amount of tokens locked due to staking.
    *
    * # Cost
    *
    * `base + memory_write_base + memory_write_size * 16`
    * @param {BigInt} balance_ptr
    */
    account_locked_balance(balance_ptr) {
        uint64CvtShim[0] = balance_ptr;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_account_locked_balance(this.ptr, low0, high0);
    }
    /**
    * The balance that was attached to the call that will be immediately deposited before the
    * contract execution starts.
    *
    * # Errors
    *
    * If called as view function returns `ProhibitedInView``.
    *
    * # Cost
    *
    * `base + memory_write_base + memory_write_size * 16`
    * @param {BigInt} balance_ptr
    */
    attached_deposit(balance_ptr) {
        uint64CvtShim[0] = balance_ptr;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_attached_deposit(this.ptr, low0, high0);
    }
    /**
    * The amount of gas attached to the call that can be used to pay for the gas fees.
    *
    * # Errors
    *
    * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    prepaid_gas() {
        wasm.vm_prepaid_gas(8, this.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n0 = uint64CvtShim[0];
        return n0;
    }
    /**
    * The gas that was already burnt during the contract execution (cannot exceed `prepaid_gas`)
    *
    * # Errors
    *
    * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    used_gas() {
        wasm.vm_used_gas(8, this.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n0 = uint64CvtShim[0];
        return n0;
    }
    /**
    * ############
    * # Math API #
    * ############
    * Writes random seed into the register.
    *
    * # Errors
    *
    * If the size of the registers exceed the set limit `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`.
    * @param {BigInt} register_id
    */
    random_seed(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_random_seed(this.ptr, low0, high0);
    }
    /**
    * Hashes the random sequence of bytes using sha256 and returns it into `register_id`.
    *
    * # Errors
    *
    * If `value_len + value_ptr` points outside the memory or the registers use more memory than
    * the limit with `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes + sha256_base + sha256_byte * num_bytes`
    * @param {BigInt} value_len
    * @param {BigInt} value_ptr
    * @param {BigInt} register_id
    */
    sha256(value_len, value_ptr, register_id) {
        uint64CvtShim[0] = value_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = value_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = register_id;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_sha256(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * Called by gas metering injected into Wasm. Counts both towards `burnt_gas` and `used_gas`.
    *
    * # Errors
    *
    * * If passed gas amount somehow overflows internal gas counters returns `IntegerOverflow`;
    * * If we exceed usage limit imposed on burnt gas returns `GasLimitExceeded`;
    * * If we exceed the `prepaid_gas` then returns `GasExceeded`.
    * @param {number} gas_amount
    */
    gas(gas_amount) {
        wasm.vm_gas(this.ptr, gas_amount);
    }
    /**
    * ################
    * # Promises API #
    * ################
    * A helper function to pay gas fee for creating a new receipt without actions.
    * # Args:
    * * `sir`: whether contract call is addressed to itself;
    * * `data_dependencies`: other contracts that this execution will be waiting on (or rather
    *   their data receipts), where bool indicates whether this is sender=receiver communication.
    *
    * # Cost
    *
    * This is a convenience function that encapsulates several costs:
    * `burnt_gas := dispatch cost of the receipt + base dispatch cost  cost of the data receipt`
    * `used_gas := burnt_gas + exec cost of the receipt + base exec cost  cost of the data receipt`
    * Notice that we prepay all base cost upon the creation of the data dependency, we are going to
    * pay for the content transmitted through the dependency upon the actual creation of the
    * DataReceipt.
    * A helper function to subtract balance on transfer or attached deposit for promises.
    * # Args:
    * * `amount`: the amount to deduct from the current account balance.
    * Creates a promise that will execute a method on account with given arguments and attaches
    * the given amount and gas. `amount_ptr` point to slices of bytes representing `u128`.
    *
    * # Errors
    *
    * * If `account_id_len + account_id_ptr` or `method_name_len + method_name_ptr` or
    * `arguments_len + arguments_ptr` or `amount_ptr + 16` points outside the memory of the guest
    * or host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * Since `promise_create` is a convenience wrapper around `promise_batch_create` and
    * `promise_batch_action_function_call`. This also means it charges `base` cost twice.
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @param {BigInt} method_name_len
    * @param {BigInt} method_name_ptr
    * @param {BigInt} arguments_len
    * @param {BigInt} arguments_ptr
    * @param {BigInt} amount_ptr
    * @param {BigInt} gas
    * @returns {BigInt}
    */
    promise_create(account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
        uint64CvtShim[0] = account_id_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = account_id_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = method_name_len;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = method_name_ptr;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        uint64CvtShim[0] = arguments_len;
        const low4 = u32CvtShim[0];
        const high4 = u32CvtShim[1];
        uint64CvtShim[0] = arguments_ptr;
        const low5 = u32CvtShim[0];
        const high5 = u32CvtShim[1];
        uint64CvtShim[0] = amount_ptr;
        const low6 = u32CvtShim[0];
        const high6 = u32CvtShim[1];
        uint64CvtShim[0] = gas;
        const low7 = u32CvtShim[0];
        const high7 = u32CvtShim[1];
        wasm.vm_promise_create(8, this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4, low5, high5, low6, high6, low7, high7);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n8 = uint64CvtShim[0];
        return n8;
    }
    /**
    * Attaches the callback that is executed after promise pointed by `promise_idx` is complete.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`;
    * * If `account_id_len + account_id_ptr` or `method_name_len + method_name_ptr` or
    *   `arguments_len + arguments_ptr` or `amount_ptr + 16` points outside the memory of the
    *   guest or host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * Since `promise_create` is a convenience wrapper around `promise_batch_then` and
    * `promise_batch_action_function_call`. This also means it charges `base` cost twice.
    * @param {BigInt} promise_idx
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @param {BigInt} method_name_len
    * @param {BigInt} method_name_ptr
    * @param {BigInt} arguments_len
    * @param {BigInt} arguments_ptr
    * @param {BigInt} amount_ptr
    * @param {BigInt} gas
    * @returns {BigInt}
    */
    promise_then(promise_idx, account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = account_id_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = account_id_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = method_name_len;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        uint64CvtShim[0] = method_name_ptr;
        const low4 = u32CvtShim[0];
        const high4 = u32CvtShim[1];
        uint64CvtShim[0] = arguments_len;
        const low5 = u32CvtShim[0];
        const high5 = u32CvtShim[1];
        uint64CvtShim[0] = arguments_ptr;
        const low6 = u32CvtShim[0];
        const high6 = u32CvtShim[1];
        uint64CvtShim[0] = amount_ptr;
        const low7 = u32CvtShim[0];
        const high7 = u32CvtShim[1];
        uint64CvtShim[0] = gas;
        const low8 = u32CvtShim[0];
        const high8 = u32CvtShim[1];
        wasm.vm_promise_then(8, this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4, low5, high5, low6, high6, low7, high7, low8, high8);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n9 = uint64CvtShim[0];
        return n9;
    }
    /**
    * Creates a new promise which completes when time all promises passed as arguments complete.
    * Cannot be used with registers. `promise_idx_ptr` points to an array of `u64` elements, with
    * `promise_idx_count` denoting the number of elements. The array contains indices of promises
    * that need to be waited on jointly.
    *
    * # Errors
    *
    * * If `promise_ids_ptr + 8 * promise_idx_count` extend outside the guest memory returns
    *   `MemoryAccessViolation`;
    * * If any of the promises in the array do not correspond to existing promises returns
    *   `InvalidPromiseIndex`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * `base + promise_and_base + promise_and_per_promise * num_promises + cost of reading promise ids from memory`.
    * @param {BigInt} promise_idx_ptr
    * @param {BigInt} promise_idx_count
    * @returns {BigInt}
    */
    promise_and(promise_idx_ptr, promise_idx_count) {
        uint64CvtShim[0] = promise_idx_ptr;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = promise_idx_count;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_promise_and(8, this.ptr, low0, high0, low1, high1);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n2 = uint64CvtShim[0];
        return n2;
    }
    /**
    * Creates a new promise towards given `account_id` without any actions attached to it.
    *
    * # Errors
    *
    * * If `account_id_len + account_id_ptr` points outside the memory of the guest or host
    * returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * `burnt_gas := base + cost of reading and decoding the account id + dispatch cost of the receipt`.
    * `used_gas := burnt_gas + exec cost of the receipt`.
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @returns {BigInt}
    */
    promise_batch_create(account_id_len, account_id_ptr) {
        uint64CvtShim[0] = account_id_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = account_id_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_promise_batch_create(8, this.ptr, low0, high0, low1, high1);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n2 = uint64CvtShim[0];
        return n2;
    }
    /**
    * Creates a new promise towards given `account_id` without any actions attached, that is
    * executed after promise pointed by `promise_idx` is complete.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`;
    * * If `account_id_len + account_id_ptr` points outside the memory of the guest or host
    * returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * `base + cost of reading and decoding the account id + dispatch&execution cost of the receipt
    *  + dispatch&execution base cost for each data dependency`
    * @param {BigInt} promise_idx
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @returns {BigInt}
    */
    promise_batch_then(promise_idx, account_id_len, account_id_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = account_id_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = account_id_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_promise_batch_then(8, this.ptr, low0, high0, low1, high1, low2, high2);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n3 = uint64CvtShim[0];
        return n3;
    }
    /**
    * Appends `CreateAccount` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action fee`
    * `used_gas := burnt_gas + exec action fee`
    * @param {BigInt} promise_idx
    */
    promise_batch_action_create_account(promise_idx) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_promise_batch_action_create_account(this.ptr, low0, high0);
    }
    /**
    * Appends `DeployContract` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If `code_len + code_ptr` points outside the memory of the guest or host returns
    * `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} code_len
    * @param {BigInt} code_ptr
    */
    promise_batch_action_deploy_contract(promise_idx, code_len, code_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = code_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = code_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_promise_batch_action_deploy_contract(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * Appends `FunctionCall` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If `method_name_len + method_name_ptr` or `arguments_len + arguments_ptr` or
    * `amount_ptr + 16` points outside the memory of the guest or host returns
    * `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory
    *  + cost of reading u128, method_name and arguments from the memory`
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} method_name_len
    * @param {BigInt} method_name_ptr
    * @param {BigInt} arguments_len
    * @param {BigInt} arguments_ptr
    * @param {BigInt} amount_ptr
    * @param {BigInt} gas
    */
    promise_batch_action_function_call(promise_idx, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = method_name_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = method_name_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = arguments_len;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        uint64CvtShim[0] = arguments_ptr;
        const low4 = u32CvtShim[0];
        const high4 = u32CvtShim[1];
        uint64CvtShim[0] = amount_ptr;
        const low5 = u32CvtShim[0];
        const high5 = u32CvtShim[1];
        uint64CvtShim[0] = gas;
        const low6 = u32CvtShim[0];
        const high6 = u32CvtShim[1];
        wasm.vm_promise_batch_action_function_call(this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4, low5, high5, low6, high6);
    }
    /**
    * Appends `Transfer` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If `amount_ptr + 16` points outside the memory of the guest or host returns
    * `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading u128 from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} amount_ptr
    */
    promise_batch_action_transfer(promise_idx, amount_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = amount_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_promise_batch_action_transfer(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Appends `Stake` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
    * * If `amount_ptr + 16` or `public_key_len + public_key_ptr` points outside the memory of the
    * guest or host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} amount_ptr
    * @param {BigInt} public_key_len
    * @param {BigInt} public_key_ptr
    */
    promise_batch_action_stake(promise_idx, amount_ptr, public_key_len, public_key_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = amount_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_len;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_ptr;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        wasm.vm_promise_batch_action_stake(this.ptr, low0, high0, low1, high1, low2, high2, low3, high3);
    }
    /**
    * Appends `AddKey` action to the batch of actions for the given promise pointed by
    * `promise_idx`. The access key will have `FullAccess` permission.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
    * * If `public_key_len + public_key_ptr` points outside the memory of the guest or host
    * returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} public_key_len
    * @param {BigInt} public_key_ptr
    * @param {BigInt} nonce
    */
    promise_batch_action_add_key_with_full_access(promise_idx, public_key_len, public_key_ptr, nonce) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = nonce;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        wasm.vm_promise_batch_action_add_key_with_full_access(this.ptr, low0, high0, low1, high1, low2, high2, low3, high3);
    }
    /**
    * Appends `AddKey` action to the batch of actions for the given promise pointed by
    * `promise_idx`. The access key will have `FunctionCall` permission.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
    * * If `public_key_len + public_key_ptr`, `allowance_ptr + 16`,
    * `receiver_id_len + receiver_id_ptr` or `method_names_len + method_names_ptr` points outside
    * the memory of the guest or host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory
    *  + cost of reading u128, method_names and public key from the memory + cost of reading and parsing account name`
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} public_key_len
    * @param {BigInt} public_key_ptr
    * @param {BigInt} nonce
    * @param {BigInt} allowance_ptr
    * @param {BigInt} receiver_id_len
    * @param {BigInt} receiver_id_ptr
    * @param {BigInt} method_names_len
    * @param {BigInt} method_names_ptr
    */
    promise_batch_action_add_key_with_function_call(promise_idx, public_key_len, public_key_ptr, nonce, allowance_ptr, receiver_id_len, receiver_id_ptr, method_names_len, method_names_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = nonce;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        uint64CvtShim[0] = allowance_ptr;
        const low4 = u32CvtShim[0];
        const high4 = u32CvtShim[1];
        uint64CvtShim[0] = receiver_id_len;
        const low5 = u32CvtShim[0];
        const high5 = u32CvtShim[1];
        uint64CvtShim[0] = receiver_id_ptr;
        const low6 = u32CvtShim[0];
        const high6 = u32CvtShim[1];
        uint64CvtShim[0] = method_names_len;
        const low7 = u32CvtShim[0];
        const high7 = u32CvtShim[1];
        uint64CvtShim[0] = method_names_ptr;
        const low8 = u32CvtShim[0];
        const high8 = u32CvtShim[1];
        wasm.vm_promise_batch_action_add_key_with_function_call(this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4, low5, high5, low6, high6, low7, high7, low8, high8);
    }
    /**
    * Appends `DeleteKey` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
    * * If `public_key_len + public_key_ptr` points outside the memory of the guest or host
    * returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} public_key_len
    * @param {BigInt} public_key_ptr
    */
    promise_batch_action_delete_key(promise_idx, public_key_len, public_key_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_promise_batch_action_delete_key(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * Appends `DeleteAccount` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If `beneficiary_id_len + beneficiary_id_ptr` points outside the memory of the guest or
    * host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading and parsing account id from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} beneficiary_id_len
    * @param {BigInt} beneficiary_id_ptr
    */
    promise_batch_action_delete_account(promise_idx, beneficiary_id_len, beneficiary_id_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = beneficiary_id_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = beneficiary_id_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_promise_batch_action_delete_account(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * If the current function is invoked by a callback we can access the execution results of the
    * promises that caused the callback. This function returns the number of complete and
    * incomplete callbacks.
    *
    * Note, we are only going to have incomplete callbacks once we have promise_or combinator.
    *
    *
    * * If there is only one callback returns `1`;
    * * If there are multiple callbacks (e.g. created through `promise_and`) returns their number;
    * * If the function was called not through the callback returns `0`.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    promise_results_count() {
        wasm.vm_promise_results_count(8, this.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n0 = uint64CvtShim[0];
        return n0;
    }
    /**
    * If the current function is invoked by a callback we can access the execution results of the
    * promises that caused the callback. This function returns the result in blob format and
    * places it into the register.
    *
    * * If promise result is complete and successful copies its blob into the register;
    * * If promise result is complete and failed or incomplete keeps register unused;
    *
    * # Returns
    *
    * * If promise result is not complete returns `0`;
    * * If promise result is complete and successful returns `1`;
    * * If promise result is complete and failed returns `2`.
    *
    * # Errors
    *
    * * If `result_id` does not correspond to an existing result returns `InvalidPromiseResultIndex`;
    * * If copying the blob exhausts the memory limit it returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + cost of writing data into a register`
    * @param {BigInt} result_idx
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    promise_result(result_idx, register_id) {
        uint64CvtShim[0] = result_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = register_id;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_promise_result(8, this.ptr, low0, high0, low1, high1);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n2 = uint64CvtShim[0];
        return n2;
    }
    /**
    * When promise `promise_idx` finishes executing its result is considered to be the result of
    * the current function.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + promise_return`
    * @param {BigInt} promise_idx
    */
    promise_return(promise_idx) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_promise_return(this.ptr, low0, high0);
    }
    /**
    * #####################
    * # Miscellaneous API #
    * #####################
    * sets the blob of data as the return value of the contract.
    *
    * # Errors
    *
    * If `value_len + value_ptr` exceeds the memory container or points to an unused register it
    * returns `MemoryAccessViolation`.
    *
    * # Cost
    * `base + cost of reading return value from memory or register + dispatch&exec cost per byte of the data sent * num data receivers`
    * @param {BigInt} value_len
    * @param {BigInt} value_ptr
    */
    value_return(value_len, value_ptr) {
        uint64CvtShim[0] = value_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = value_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_value_return(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Terminates the execution of the program with panic `GuestPanic`.
    *
    * # Cost
    *
    * `base`
    */
    panic() {
        wasm.vm_panic(this.ptr);
    }
    /**
    * Guest panics with the UTF-8 encoded string.
    * If `len == u64::MAX` then treats the string as null-terminated with character `\'\\0\'`.
    *
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-8 returns `BadUtf8`.
    * * If string is longer than `max_log_len` returns `BadUtf8`.
    *
    * # Cost
    * `base + cost of reading and decoding a utf8 string`
    * @param {BigInt} len
    * @param {BigInt} ptr
    */
    panic_utf8(len, ptr) {
        uint64CvtShim[0] = len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_panic_utf8(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Logs the UTF-8 encoded string.
    * If `len == u64::MAX` then treats the string as null-terminated with character `\'\\0\'`.
    *
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-8 returns `BadUtf8`.
    * * If string is longer than `max_log_len` returns `BadUtf8`.
    *
    * # Cost
    *
    * `base + log_base + log_byte + num_bytes + utf8 decoding cost`
    * @param {BigInt} len
    * @param {BigInt} ptr
    */
    log_utf8(len, ptr) {
        uint64CvtShim[0] = len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_log_utf8(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Logs the UTF-16 encoded string. If `len == u64::MAX` then treats the string as
    * null-terminated with two-byte sequence of `0x00 0x00`.
    *
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-16 returns `BadUtf16`.
    *
    * # Cost
    *
    * `base + log_base + log_byte * num_bytes + utf16 decoding cost`
    * @param {BigInt} len
    * @param {BigInt} ptr
    */
    log_utf16(len, ptr) {
        uint64CvtShim[0] = len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_log_utf16(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Special import kept for compatibility with AssemblyScript contracts. Not called by smart
    * contracts directly, but instead called by the code generated by AssemblyScript.
    *
    * # Cost
    *
    * `base +  log_base + log_byte * num_bytes + utf16 decoding cost`
    * @param {number} msg_ptr
    * @param {number} filename_ptr
    * @param {number} line
    * @param {number} col
    */
    abort(msg_ptr, filename_ptr, line, col) {
        wasm.vm_abort(this.ptr, msg_ptr, filename_ptr, line, col);
    }
    /**
    * ###############
    * # Storage API #
    * ###############
    * Reads account id from the given location in memory.
    *
    * # Errors
    *
    * * If account is not UTF-8 encoded then returns `BadUtf8`;
    *
    * # Cost
    *
    * This is a helper function that encapsulates the following costs:
    * cost of reading buffer from register or memory,
    * `utf8_decoding_base + utf8_decoding_byte * num_bytes`.
    * Writes key-value into storage.
    * * If key is not in use it inserts the key-value pair and does not modify the register. Returns `0`;
    * * If key is in use it inserts the key-value and copies the old value into the `register_id`. Returns `1`.
    *
    * # Errors
    *
    * * If `key_len + key_ptr` or `value_len + value_ptr` exceeds the memory container or points
    *   to an unused register it returns `MemoryAccessViolation`;
    * * If returning the preempted value into the registers exceed the memory container it returns
    *   `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_write_base + storage_write_key_byte * num_key_bytes + storage_write_value_byte * num_value_bytes
    * + get_vec_from_memory_or_register_cost x 2`.
    *
    * If a value was evicted it costs additional `storage_write_value_evicted_byte * num_evicted_bytes + internal_write_register_cost`.
    * @param {BigInt} key_len
    * @param {BigInt} key_ptr
    * @param {BigInt} value_len
    * @param {BigInt} value_ptr
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    storage_write(key_len, key_ptr, value_len, value_ptr, register_id) {
        uint64CvtShim[0] = key_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = key_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = value_len;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = value_ptr;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        uint64CvtShim[0] = register_id;
        const low4 = u32CvtShim[0];
        const high4 = u32CvtShim[1];
        wasm.vm_storage_write(8, this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n5 = uint64CvtShim[0];
        return n5;
    }
    /**
    * Reads the value stored under the given key.
    * * If key is used copies the content of the value into the `register_id`, even if the content
    *   is zero bytes. Returns `1`;
    * * If key is not present then does not modify the register. Returns `0`;
    *
    * # Errors
    *
    * * If `key_len + key_ptr` exceeds the memory container or points to an unused register it
    *   returns `MemoryAccessViolation`;
    * * If returning the preempted value into the registers exceed the memory container it returns
    *   `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_read_base + storage_read_key_byte * num_key_bytes + storage_read_value_byte + num_value_bytes
    *  cost to read key from register + cost to write value into register`.
    * @param {BigInt} key_len
    * @param {BigInt} key_ptr
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    storage_read(key_len, key_ptr, register_id) {
        uint64CvtShim[0] = key_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = key_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = register_id;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_storage_read(8, this.ptr, low0, high0, low1, high1, low2, high2);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n3 = uint64CvtShim[0];
        return n3;
    }
    /**
    * Removes the value stored under the given key.
    * * If key is used, removes the key-value from the trie and copies the content of the value
    *   into the `register_id`, even if the content is zero bytes. Returns `1`;
    * * If key is not present then does not modify the register. Returns `0`.
    *
    * # Errors
    *
    * * If `key_len + key_ptr` exceeds the memory container or points to an unused register it
    *   returns `MemoryAccessViolation`;
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`;
    * * If returning the preempted value into the registers exceed the memory container it returns
    *   `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_remove_base + storage_remove_key_byte * num_key_bytes + storage_remove_ret_value_byte * num_value_bytes
    * + cost to read the key + cost to write the value`.
    * @param {BigInt} key_len
    * @param {BigInt} key_ptr
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    storage_remove(key_len, key_ptr, register_id) {
        uint64CvtShim[0] = key_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = key_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = register_id;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_storage_remove(8, this.ptr, low0, high0, low1, high1, low2, high2);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n3 = uint64CvtShim[0];
        return n3;
    }
    /**
    * Checks if there is a key-value pair.
    * * If key is used returns `1`, even if the value is zero bytes;
    * * Otherwise returns `0`.
    *
    * # Errors
    *
    * If `key_len + key_ptr` exceeds the memory container it returns `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_has_key_base + storage_has_key_byte * num_bytes + cost of reading key`
    * @param {BigInt} key_len
    * @param {BigInt} key_ptr
    * @returns {BigInt}
    */
    storage_has_key(key_len, key_ptr) {
        uint64CvtShim[0] = key_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = key_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_storage_has_key(8, this.ptr, low0, high0, low1, high1);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n2 = uint64CvtShim[0];
        return n2;
    }
    /**
    * Creates an iterator object inside the host. Returns the identifier that uniquely
    * differentiates the given iterator from other iterators that can be simultaneously created.
    * * It iterates over the keys that have the provided prefix. The order of iteration is defined
    *   by the lexicographic order of the bytes in the keys;
    * * If there are no keys, it creates an empty iterator, see below on empty iterators.
    *
    * # Errors
    *
    * If `prefix_len + prefix_ptr` exceeds the memory container it returns `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_iter_create_prefix_base + storage_iter_create_key_byte * num_prefix_bytes
    *  cost of reading the prefix`.
    * @param {BigInt} prefix_len
    * @param {BigInt} prefix_ptr
    * @returns {BigInt}
    */
    storage_iter_prefix(prefix_len, prefix_ptr) {
        uint64CvtShim[0] = prefix_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = prefix_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_storage_iter_prefix(8, this.ptr, low0, high0, low1, high1);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n2 = uint64CvtShim[0];
        return n2;
    }
    /**
    * Iterates over all key-values such that keys are between `start` and `end`, where `start` is
    * inclusive and `end` is exclusive. Unless lexicographically `start < end`, it creates an
    * empty iterator. Note, this definition allows for `start` or `end` keys to not actually exist
    * on the given trie.
    *
    * # Errors
    *
    * If `start_len + start_ptr` or `end_len + end_ptr` exceeds the memory container or points to
    * an unused register it returns `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_iter_create_range_base + storage_iter_create_from_byte * num_from_bytes
    *  + storage_iter_create_to_byte * num_to_bytes + reading from prefix + reading to prefix`.
    * @param {BigInt} start_len
    * @param {BigInt} start_ptr
    * @param {BigInt} end_len
    * @param {BigInt} end_ptr
    * @returns {BigInt}
    */
    storage_iter_range(start_len, start_ptr, end_len, end_ptr) {
        uint64CvtShim[0] = start_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = start_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = end_len;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = end_ptr;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        wasm.vm_storage_iter_range(8, this.ptr, low0, high0, low1, high1, low2, high2, low3, high3);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n4 = uint64CvtShim[0];
        return n4;
    }
    /**
    * Advances iterator and saves the next key and value in the register.
    * * If iterator is not empty (after calling next it points to a key-value), copies the key
    *   into `key_register_id` and value into `value_register_id` and returns `1`;
    * * If iterator is empty returns `0`;
    * This allows us to iterate over the keys that have zero bytes stored in values.
    *
    * # Errors
    *
    * * If `key_register_id == value_register_id` returns `MemoryAccessViolation`;
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`;
    * * If `iterator_id` does not correspond to an existing iterator returns `InvalidIteratorId`;
    * * If between the creation of the iterator and calling `storage_iter_next` the range over
    *   which it iterates was modified returns `IteratorWasInvalidated`. Specifically, if
    *   `storage_write` or `storage_remove` was invoked on the key key such that:
    *   * in case of `storage_iter_prefix`. `key` has the given prefix and:
    *     * Iterator was not called next yet.
    *     * `next` was already called on the iterator and it is currently pointing at the `key`
    *       `curr` such that `curr <= key`.
    *   * in case of `storage_iter_range`. `start<=key<end` and:
    *     * Iterator was not called `next` yet.
    *     * `next` was already called on the iterator and it is currently pointing at the key
    *       `curr` such that `curr<=key<end`.
    *
    * # Cost
    *
    * `base + storage_iter_next_base + storage_iter_next_key_byte * num_key_bytes + storage_iter_next_value_byte * num_value_bytes
    *  + writing key to register + writing value to register`.
    * @param {BigInt} iterator_id
    * @param {BigInt} key_register_id
    * @param {BigInt} value_register_id
    * @returns {BigInt}
    */
    storage_iter_next(iterator_id, key_register_id, value_register_id) {
        uint64CvtShim[0] = iterator_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = key_register_id;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = value_register_id;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_storage_iter_next(8, this.ptr, low0, high0, low1, high1, low2, high2);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        u32CvtShim[0] = r0;
        u32CvtShim[1] = r1;
        const n3 = uint64CvtShim[0];
        return n3;
    }
    /**
    *Computes the outcome of execution.
    * @returns {any}
    */
    outcome() {
        var ret = wasm.vm_outcome(this.ptr);
        return takeObject(ret);
    }
}
module.exports.VM = VM;

module.exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

module.exports.__wbg_log_48ca1fd2a2225c63 = function(arg0, arg1) {
    console.log(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbg_fitsmemory_f71b8896c5364aa6 = function(arg0, arg1, arg2, arg3) {
    u32CvtShim[0] = arg0;
    u32CvtShim[1] = arg1;
    const n0 = uint64CvtShim[0];
    u32CvtShim[0] = arg2;
    u32CvtShim[1] = arg3;
    const n1 = uint64CvtShim[0];
    var ret = fits_memory(n0, n1);
    return ret;
};

module.exports.__wbg_readmemory_3d24d10499747c05 = function(arg0, arg1, arg2, arg3) {
    u32CvtShim[0] = arg0;
    u32CvtShim[1] = arg1;
    const n0 = uint64CvtShim[0];
    read_memory(n0, getArrayU8FromWasm0(arg2, arg3));
};

module.exports.__wbg_readmemoryu8_25dab78803ad9146 = function(arg0, arg1) {
    u32CvtShim[0] = arg0;
    u32CvtShim[1] = arg1;
    const n0 = uint64CvtShim[0];
    var ret = read_memory_u8(n0);
    return ret;
};

module.exports.__wbg_writememory_6367d7da2a7cc862 = function(arg0, arg1, arg2, arg3) {
    u32CvtShim[0] = arg0;
    u32CvtShim[1] = arg1;
    const n0 = uint64CvtShim[0];
    write_memory(n0, getArrayU8FromWasm0(arg2, arg3));
};

module.exports.__wbg_runbinary_93df230ef572384b = function(arg0, arg1, arg2, arg3, arg4) {
    var ret = run_binary(getArrayU8FromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    uint64CvtShim[0] = ret;
    const low0 = u32CvtShim[0];
    const high0 = u32CvtShim[1];
    getInt32Memory0()[arg0 / 4 + 1] = high0;
    getInt32Memory0()[arg0 / 4 + 0] = low0;
};

module.exports.__wbg_new_59cb74e423758ede = function() {
    var ret = new Error();
    return addHeapObject(ret);
};

module.exports.__wbg_stack_558ba5917b466edd = function(arg0, arg1) {
    var ret = getObject(arg1).stack;
    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_error_4bb6c2a97407129a = function(arg0, arg1) {
    try {
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
};

module.exports.__wbindgen_is_null = function(arg0) {
    var ret = getObject(arg0) === null;
    return ret;
};

module.exports.__wbindgen_is_undefined = function(arg0) {
    var ret = getObject(arg0) === undefined;
    return ret;
};

module.exports.__wbindgen_string_new = function(arg0, arg1) {
    var ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
};

module.exports.__wbindgen_object_clone_ref = function(arg0) {
    var ret = getObject(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_new_68adb0d58759a4ed = function() {
    var ret = new Object();
    return addHeapObject(ret);
};

module.exports.__wbindgen_number_new = function(arg0) {
    var ret = arg0;
    return addHeapObject(ret);
};

module.exports.__wbg_set_2e79e744454afade = function(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
};

module.exports.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    var ret = typeof(val) === 'object' && val !== null;
    return ret;
};

module.exports.__wbindgen_is_function = function(arg0) {
    var ret = typeof(getObject(arg0)) === 'function';
    return ret;
};

module.exports.__wbg_next_8e20ccfba8b36336 = function(arg0) {
    var ret = getObject(arg0).next;
    return addHeapObject(ret);
};

module.exports.__wbg_next_1d4b79eb1b9baf74 = function(arg0) {
    try {
        var ret = getObject(arg0).next();
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_done_45cf31906da300ce = function(arg0) {
    var ret = getObject(arg0).done;
    return ret;
};

module.exports.__wbg_value_170ae240f5dce1ea = function(arg0) {
    var ret = getObject(arg0).value;
    return addHeapObject(ret);
};

module.exports.__wbg_iterator_d8f236f351456524 = function() {
    var ret = Symbol.iterator;
    return addHeapObject(ret);
};

module.exports.__wbg_get_d37934344331757a = function(arg0, arg1) {
    try {
        var ret = Reflect.get(getObject(arg0), getObject(arg1));
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_call_183c0b733b35a027 = function(arg0, arg1) {
    try {
        var ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_new_6ebe5d19b58a40e1 = function() {
    var ret = new Array();
    return addHeapObject(ret);
};

module.exports.__wbg_isArray_f2072707e18b2a55 = function(arg0) {
    var ret = Array.isArray(getObject(arg0));
    return ret;
};

module.exports.__wbg_push_9f1ae2f6575ac2d1 = function(arg0, arg1) {
    var ret = getObject(arg0).push(getObject(arg1));
    return ret;
};

module.exports.__wbg_instanceof_ArrayBuffer_4ef858c408d7eadd = function(arg0) {
    var ret = getObject(arg0) instanceof ArrayBuffer;
    return ret;
};

module.exports.__wbg_values_d0179fc5f9291ea1 = function(arg0) {
    var ret = getObject(arg0).values();
    return addHeapObject(ret);
};

module.exports.__wbg_new_28282f1280cc761a = function(arg0, arg1) {
    var ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_isSafeInteger_d0006cb3317288ec = function(arg0) {
    var ret = Number.isSafeInteger(getObject(arg0));
    return ret;
};

module.exports.__wbg_buffer_459b85bd7a0b346a = function(arg0) {
    var ret = getObject(arg0).buffer;
    return addHeapObject(ret);
};

module.exports.__wbg_length_9e997d8eaac24d6e = function(arg0) {
    var ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_new_0e176355c854c502 = function(arg0) {
    var ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_set_6a285c41fb4fd43e = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

module.exports.__wbg_instanceof_Uint8Array_83a3d34114d9ebb6 = function(arg0) {
    var ret = getObject(arg0) instanceof Uint8Array;
    return ret;
};

module.exports.__wbg_byteLength_b793543bac98964f = function(arg0) {
    var ret = getObject(arg0).byteLength;
    return ret;
};

module.exports.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    var ret = typeof(obj) === 'number' ? obj : undefined;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
};

module.exports.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    var ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    var ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
    return ret;
};

module.exports.__wbindgen_debug_string = function(arg0, arg1) {
    var ret = debugString(getObject(arg1));
    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbindgen_memory = function() {
    var ret = wasm.memory;
    return addHeapObject(ret);
};

const path = require('path').join(__dirname, 'wasm_mock_vm_bg.wasm');
const bytes = require('fs').readFileSync(path);

const wasmModule = new WebAssembly.Module(bytes);
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
wasm = wasmInstance.exports;
module.exports.__wasm = wasm;

'''
'''--- pkg/wasm_mock_vm_bg.d.ts ---
/* tslint:disable */
/* eslint-disable */
export const memory: WebAssembly.Memory;
export function __wbg_vm_free(a: number): void;
export function vm_new(a: number): number;
export function vm_save_state(a: number): void;
export function vm_restore_state(a: number): void;
export function vm_save_context(a: number): void;
export function vm_restore_context(a: number): void;
export function vm_set_context(a: number, b: number): void;
export function vm_set_current_account_id(a: number, b: number): void;
export function vm_set_input(a: number, b: number): void;
export function vm_set_signer_account_id(a: number, b: number): void;
export function vm_set_signer_account_pk(a: number, b: number): void;
export function vm_set_predecessor_account_id(a: number, b: number): void;
export function vm_set_block_index(a: number, b: number, c: number): void;
export function vm_set_block_timestamp(a: number, b: number, c: number): void;
export function vm_set_account_balance(a: number, b: number, c: number, d: number, e: number): void;
export function vm_set_account_locked_balance(a: number, b: number, c: number, d: number, e: number): void;
export function vm_set_storage_usage(a: number, b: number): void;
export function vm_set_attached_deposit(a: number, b: number, c: number, d: number, e: number): void;
export function vm_set_prepaid_gas(a: number, b: number, c: number): void;
export function vm_set_random_seed(a: number, b: number): void;
export function vm_set_is_view(a: number, b: number): void;
export function vm_set_output_data_receivers(a: number, b: number): void;
export function vm_read_register(a: number, b: number, c: number, d: number, e: number): void;
export function vm_register_len(a: number, b: number, c: number, d: number): void;
export function vm_write_register(a: number, b: number, c: number, d: number, e: number, f: number, g: number): void;
export function vm_current_account_id(a: number, b: number, c: number): void;
export function vm_signer_account_id(a: number, b: number, c: number): void;
export function vm_signer_account_pk(a: number, b: number, c: number): void;
export function vm_predecessor_account_id(a: number, b: number, c: number): void;
export function vm_input(a: number, b: number, c: number): void;
export function vm_block_index(a: number, b: number): void;
export function vm_block_timestamp(a: number, b: number): void;
export function vm_storage_usage(a: number, b: number): void;
export function vm_account_balance(a: number, b: number, c: number): void;
export function vm_account_locked_balance(a: number, b: number, c: number): void;
export function vm_attached_deposit(a: number, b: number, c: number): void;
export function vm_prepaid_gas(a: number, b: number): void;
export function vm_used_gas(a: number, b: number): void;
export function vm_random_seed(a: number, b: number, c: number): void;
export function vm_sha256(a: number, b: number, c: number, d: number, e: number, f: number, g: number): void;
export function vm_gas(a: number, b: number): void;
export function vm_promise_create(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number, n: number, o: number, p: number, q: number, r: number): void;
export function vm_promise_then(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number, n: number, o: number, p: number, q: number, r: number, s: number, t: number): void;
export function vm_promise_and(a: number, b: number, c: number, d: number, e: number, f: number): void;
export function vm_promise_batch_create(a: number, b: number, c: number, d: number, e: number, f: number): void;
export function vm_promise_batch_then(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number): void;
export function vm_promise_batch_action_create_account(a: number, b: number, c: number): void;
export function vm_promise_batch_action_deploy_contract(a: number, b: number, c: number, d: number, e: number, f: number, g: number): void;
export function vm_promise_batch_action_function_call(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number, n: number, o: number): void;
export function vm_promise_batch_action_transfer(a: number, b: number, c: number, d: number, e: number): void;
export function vm_promise_batch_action_stake(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number): void;
export function vm_promise_batch_action_add_key_with_full_access(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number): void;
export function vm_promise_batch_action_add_key_with_function_call(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number, n: number, o: number, p: number, q: number, r: number, s: number): void;
export function vm_promise_batch_action_delete_key(a: number, b: number, c: number, d: number, e: number, f: number, g: number): void;
export function vm_promise_batch_action_delete_account(a: number, b: number, c: number, d: number, e: number, f: number, g: number): void;
export function vm_promise_results_count(a: number, b: number): void;
export function vm_promise_result(a: number, b: number, c: number, d: number, e: number, f: number): void;
export function vm_promise_return(a: number, b: number, c: number): void;
export function vm_value_return(a: number, b: number, c: number, d: number, e: number): void;
export function vm_panic(a: number): void;
export function vm_panic_utf8(a: number, b: number, c: number, d: number, e: number): void;
export function vm_log_utf8(a: number, b: number, c: number, d: number, e: number): void;
export function vm_log_utf16(a: number, b: number, c: number, d: number, e: number): void;
export function vm_abort(a: number, b: number, c: number, d: number, e: number): void;
export function vm_storage_write(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number): void;
export function vm_storage_read(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number): void;
export function vm_storage_remove(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number): void;
export function vm_storage_has_key(a: number, b: number, c: number, d: number, e: number, f: number): void;
export function vm_storage_iter_prefix(a: number, b: number, c: number, d: number, e: number, f: number): void;
export function vm_storage_iter_range(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number): void;
export function vm_storage_iter_next(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number): void;
export function vm_outcome(a: number): number;
export function run(a: number): void;
export function __wbindgen_malloc(a: number): number;
export function __wbindgen_realloc(a: number, b: number, c: number): number;
export function __wbindgen_free(a: number, b: number): void;
export function __wbindgen_exn_store(a: number): void;

'''
'''--- pkg/wasm_mock_vm_bg.js ---

const path = require('path').join(__dirname, 'wasm_mock_vm_bg.wasm');
const bytes = require('fs').readFileSync(path);
let imports = {};
imports['./wasm_mock_vm.js'] = require('./wasm_mock_vm.js');

const wasmModule = new WebAssembly.Module(bytes);
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
module.exports = wasmInstance.exports;

'''
'''--- setup.sh ---
#!/bin/bash
CARGO_HOME="${CARGO_HOME:-$HOME/.cargo}"
RUST_VERSION=nightly
if [[ -e nearcore ]]; then
    cd nearcore
    git pull
else
    git clone -b mock_vm_helper_methods https://github.com/nearprotocol/nearcore
fi

if [[ ! -e $CARGO_HOME ]]; then
    curl https://sh.rustup.rs -sSf | sh -s -- -y --no-modify-path --default-toolchain $RUST_VERSION
fi
'''
'''--- src/lib.rs ---
mod mock;
mod utils;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

'''
'''--- src/mock/memory.rs ---
use wasm_bindgen::prelude::*;
use near_vm_logic::*;

#[wasm_bindgen]
extern {
    // Returns whether the memory interval is completely inside the smart contract memory.
    pub fn fits_memory(offset: u64, len: u64) -> bool;

    // Reads the content of the given memory interval.
    //
    // # Panics
    //
    // If memory interval is outside the smart contract memory.
    pub fn read_memory(offset: u64, buffer: &mut [u8]);

    // Reads a single byte from the memory.
    //
    // # Panics
    //
    // If pointer is outside the smart contract memory.
    pub fn read_memory_u8(offset: u64) -> u8;

    // Writes the buffer into the smart contract memory.
    //
    // # Panics
    //
    // If `offset + buffer.len()` is outside the smart contract memory.
    pub fn write_memory(offset: u64, buffer: &[u8]);
    
    pub fn alert(s: &str);
}

pub struct MockedMemory {}

impl MemoryLike for MockedMemory {
    fn fits_memory(&self, _offset: u64, _len: u64) -> bool {
        fits_memory(_offset, _len)
    }
    
    fn read_memory(&self, offset: u64, buffer: &mut [u8]) {
        read_memory(offset, buffer)
    }
    
    fn read_memory_u8(&self, offset: u64) -> u8 {
        read_memory_u8(offset)
    }
    
    fn write_memory(&mut self, offset: u64, buffer: &[u8]) {
        write_memory(offset, buffer)
    }
}
'''
'''--- src/mock/mod.rs ---
pub mod memory;
pub mod vm_logic;
pub mod runner;
'''
'''--- src/mock/runner.rs ---

use js_sys::{Function, Object, Reflect, WebAssembly};
use wasm_bindgen::prelude::*;
// use wasm_bindgen::JsCast;
// use near-vm-runner::*;

// use wasm_bindgen_futures::, JsFuture};

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(a: &str);

    #[wasm_bindgen]
    fn run_binary(bin: &[u8], method: &str) -> u64;
}

macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

const WASM: &[u8] = include_bytes!("add.wasm");

fn run_wasm(wasm: &[u8]) -> Result<(), JsValue> {
    console_log!("instantiating a new wasm module directly");
    
    console_log!("1 + 2 = {}", run_binary(wasm, &"add"));

    // let b: WebAssembly::Instance = WebAssembly::Instance::new(&module, &Object::new()).unwrap();

    // let c = b.exports();

    // let add = Reflect::get(c.as_ref(), &"add".into())?
    //     .dyn_into::<Function>()
    //     .expect("add export wasn't a function");

    // let three = add.call2(&JsValue::undefined(), &1.into(), &2.into())?;
    // console_log!("1 + 2 = {:?}", three);
    // let mem = Reflect::get(c.as_ref(), &"memory".into())?
    //     .dyn_into::<WebAssembly::Memory>()
    //     .expect("memory export wasn't a `WebAssembly.Memory`");
    // console_log!("created module has {} pages of memory", mem.grow(0));
    // console_log!("giving the module 4 more pages of memory");
    // mem.grow(4);
    // console_log!("now the module has {} pages of memory", mem.grow(0));
    Ok(())
}

#[wasm_bindgen]
pub fn run(wasm_bin: JsValue) {
  let arr: Vec<u8> = serde_wasm_bindgen::from_value(wasm_bin).unwrap();
  run_wasm(&arr).unwrap_throw();
}
'''
'''--- src/mock/vm_logic.rs ---
use serde::{Serialize};
use near_vm_logic::mocks::mock_external::MockedExternal;
use crate::mock::memory::*;
use near_vm_logic::types::*;
use near_vm_logic::*;
use wasm_bindgen::prelude::*;

use near_runtime_fees::RuntimeFeesConfig;
use crate::utils::*;
// lifted from the `console_log` example
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(a: &str);
}

macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

type Result<T, E> = ::std::result::Result<T, E>;

type VMResult<T> = Result<T, VMLogicError>;

pub struct VMLogicBuilder {
    pub ext: MockedExternal,
    pub config: VMConfig,
    pub fees_config: RuntimeFeesConfig,
    pub promise_results: Vec<PromiseResult>,
    pub memory: MockedMemory,
}

impl Default for VMLogicBuilder {
    fn default() -> Self {
        VMLogicBuilder {
            config: VMConfig::default(),
            fees_config: RuntimeFeesConfig::default(),
            ext: MockedExternal::default(),
            memory: MockedMemory {},
            promise_results: vec![],
        }
    }
}

impl VMLogicBuilder {
    pub fn build(&mut self, context: VMContext) -> VMLogic {
        VMLogic::new(
            &mut self.ext,
            context,
            &self.config,
            &self.fees_config,
            &self.promise_results,
            &mut self.memory,
        )
    }
    #[allow(dead_code)]
    pub fn free() -> Self {
        VMLogicBuilder {
            config: VMConfig::free(),
            fees_config: RuntimeFeesConfig::free(),
            ext: MockedExternal::new(),
            memory: MockedMemory {},
            promise_results: vec![],
        }
    }
}

#[wasm_bindgen]
pub struct VM {
    builder: VMLogicBuilder,
    context: VMContext,
    internal_state: Option<InternalVMState>,
    saved_state: Option<InternalVMState>,
    saved_context: Option<VMContext>,
    saved_ext: Option<MockedExternal>
}

#[allow(dead_code)]
fn print_str(s: String) {
    console_log!("{}", s)
}

#[wasm_bindgen]
impl VM {
    #[wasm_bindgen(constructor)]
    pub fn new(context: JsValue) -> Self {
        set_panic_hook();
        let c: VMContext = serde_wasm_bindgen::from_value(context).unwrap();
        Self {
            builder: VMLogicBuilder::default(),
            context: c,
            internal_state: None,
            saved_state: None,
            saved_context: None,
            saved_ext: None
        }
    }
    
    fn run_vm<T, F: FnOnce(&mut VMLogic) -> VMResult<T>>(&mut self, f: F) -> VMResult<T> {
        let mut vm = self.builder.build(self.context.clone());
        if self.internal_state.is_some() {
            vm.restore_state(self.internal_state.as_ref().unwrap());
        }
        let res: VMResult<T> = f(&mut vm);
        // console::log_1(&vm.storage_usage().unwrap().to_string().into());
        if res.is_ok() {
            self.internal_state = Some(vm.save_state());
        }
        res
    }
    
    pub fn save_state(&mut self) {
        self.saved_state = self.internal_state.clone();
        self.saved_ext = Some(self.builder.ext.clone());
    }

    pub fn restore_state(&mut self) {
        self.internal_state = self.saved_state.clone();
        if self.saved_ext.is_some() {
            self.builder.ext = self.saved_ext.as_ref().unwrap().clone()
        }
    }

    pub fn save_context(&mut self) {
        self.saved_context = Some(self.context.clone())
    }

    pub fn restore_context(&mut self) {
        if self.saved_context.is_some() {
            self.context = self.saved_context.as_ref().unwrap().clone();
        }
    }

    pub fn set_context(&mut self, context: JsValue) {
        self.context = serde_wasm_bindgen::from_value(context).unwrap()
    }

    pub fn set_current_account_id(&mut self, s: JsValue) {
      self.context.current_account_id = serde_wasm_bindgen::from_value(s).unwrap()
    }

    pub fn set_input(&mut self, s: JsValue) {
      self.context.input = serde_wasm_bindgen::from_value(s).unwrap()
    }

    pub fn set_signer_account_id(&mut self, s: JsValue) {
      self.context.signer_account_id = serde_wasm_bindgen::from_value(s).unwrap()
    }
 // string
      /// The public key that was used to sign the original transaction that led to
      /// this execution.
    pub fn set_signer_account_pk(&mut self, s: JsValue) {
      self.context.signer_account_pk = serde_wasm_bindgen::from_value(s).unwrap()
    }
 // string base58
    pub fn set_predecessor_account_id(&mut self, s: JsValue) {
      self.context.predecessor_account_id = serde_wasm_bindgen::from_value(s).unwrap()
    }
 // string
    pub fn set_block_index(&mut self, block_height: u64) {
      self.context.block_index = block_height
    }
 // u128
    pub fn set_block_timestamp(&mut self, stmp: u64) {
      self.context.block_timestamp = stmp
    }

    pub fn set_account_balance(&mut self, lo: u64, hi: u64) {
        self.context.account_balance = u128_from_u64s(lo, hi) + self.context.attached_deposit // TODO: serde_wasm_bindgen::from_value(_u128).unwrap()
        
    }

    pub fn set_account_locked_balance(&mut self, lo: u64, hi: u64) {
        self.context.account_locked_balance = u128_from_u64s(lo, hi) // TODO: serde_wasm_bindgen::from_value(_u128).unwrap()
    }

    pub fn set_storage_usage(&mut self, amt: JsValue) {
      self.context.storage_usage = serde_wasm_bindgen::from_value(amt).unwrap()
    }

    pub fn set_attached_deposit(&mut self, lo: u64, hi: u64) {
        self.context.attached_deposit = u128_from_u64s(lo, hi) // TODO: serde_wasm_bindgen::from_value(_u128).unwrap()
    }

    pub fn set_prepaid_gas(&mut self, _u64: u64) {
      self.context.prepaid_gas = _u64
    }

    pub fn set_random_seed(&mut self, s: JsValue) {
      self.context.random_seed = serde_wasm_bindgen::from_value(s).unwrap()
    }

    pub fn set_is_view(&mut self, b: bool) {
      self.context.is_view = b
    }

    pub fn set_output_data_receivers(&mut self, arr: JsValue) {
      self.context.output_data_receivers = serde_wasm_bindgen::from_value(arr).unwrap()
    }

   /// #################
   /// # Registers API #
   /// #################

   /// Writes the entire content from the register `register_id` into the memory of the guest starting with `ptr`.
   ///
   /// # Arguments
   ///
   /// * `register_id` -- a register id from where to read the data;
   /// * `ptr` -- location on guest memory where to copy the data.
   ///
   /// # Errors
   ///
   /// * If the content extends outside the memory allocated to the guest. In Wasmer, it returns `MemoryAccessViolation` error message;
   /// * If `register_id` is pointing to unused register returns `InvalidRegisterId` error message.
   ///
   /// # Undefined Behavior
   ///
   /// If the content of register extends outside the preallocated memory on the host side, or the pointer points to a
   /// wrong location this function will overwrite memory that it is not supposed to overwrite causing an undefined behavior.
   ///
   /// # Cost
   ///
   /// `base + read_register_base + read_register_byte * num_bytes + write_memory_base + write_memory_byte * num_bytes`
    pub fn read_register(&mut self, register_id: u64, ptr: u64) {
        // let data = &vec![42];
        // vm.wrapped_internal_write_register(register_id, &data);
        let res = self.run_vm(|vm| vm.read_register(register_id, ptr));
        match res {
            Ok(()) => (),
            Err(VMLogicError::HostError(_e)) => console_log!("Host Error"),
            Err(e) => panic!(e)
        }
    }

    // Returns the size of the blob stored in the given register.
    // * If register is used, then returns the size, which can potentially be zero;
    // * If register is not used, returns `u64::MAX`
    //
    // # Arguments
    //
    // * `register_id` -- a register id from where to read the data;
    //
    // # Cost
    //
    // `base`
    pub fn register_len(&mut self, register_id: u64) -> u64 {
        self.run_vm(|vm| vm.register_len(register_id)).unwrap_or(std::u64::MAX)
    }

    // Copies `data` from the guest memory into the register. If register is unused will initialize
    // it. If register has larger capacity than needed for `data` will not re-allocate it. The
    // register will lose the pre-existing data if any.
    //
    // # Arguments
    //
    // * `register_id` -- a register id where to write the data;
    // * `data_len` -- length of the data in bytes;
    // * `data_ptr` -- pointer in the guest memory where to read the data from.
    //
    // # Cost
    //
    // `base + read_memory_base + read_memory_bytes * num_bytes + write_register_base + write_register_bytes * num_bytes`
    pub fn write_register(&mut self, register_id: u64, data_len: u64, data_ptr: u64) -> () {
        self.run_vm(|vm| vm.write_register(register_id, data_len, data_ptr)).unwrap()
    }
   /// ###################################
   /// # String reading helper functions #
   /// ###################################

   /// Helper function to read and return utf8-encoding string.
   /// If `len == u64::MAX` then treats the string as null-terminated with character `'\0'`.
   ///
   /// # Errors
   ///
   /// * If string extends outside the memory of the guest with `MemoryAccessViolation`;
   /// * If string is not UTF-8 returns `BadUtf8`.
   /// * If string is longer than `max_log_len` returns `BadUtf8`.
   ///
   /// # Cost
   ///
   /// For not nul-terminated string:
   /// `read_memory_base + read_memory_byte * num_bytes + utf8_decoding_base + utf8_decoding_byte * num_bytes`
   ///
   /// For nul-terminated string:
   /// `(read_memory_base + read_memory_byte) * num_bytes + utf8_decoding_base + utf8_decoding_byte * num_bytes`

   /// Helper function to read UTF-16 formatted string from guest memory.
   /// # Errors
   ///
   /// * If string extends outside the memory of the guest with `MemoryAccessViolation`;
   /// * If string is not UTF-16 returns `BadUtf16`.
   ///
   /// # Cost
   ///
   /// For not nul-terminated string:
   /// `read_memory_base + read_memory_byte * num_bytes + utf16_decoding_base + utf16_decoding_byte * num_bytes`
   ///
   /// For nul-terminated string:
   /// `read_memory_base * num_bytes / 2 + read_memory_byte * num_bytes + utf16_decoding_base + utf16_decoding_byte * num_bytes`

   /// ###############
   /// # Context API #
   /// ###############

   /// Saves the account id of the current contract that we execute into the register.
   ///
   /// # Errors
   ///
   /// If the registers exceed the memory limit returns `MemoryAccessViolation`.
   ///
   /// # Cost
   ///
   /// `base + write_register_base + write_register_byte * num_bytes`
    pub fn current_account_id(&mut self, register_id: u64) -> () {
        self.run_vm(|vm| vm.current_account_id(register_id)).unwrap()
    }
   /// All contract calls are a result of some transaction that was signed by some account using
   /// some access key and submitted into a memory pool (either through the wallet using RPC or by
   /// a node itself). This function returns the id of that account. Saves the bytes of the signer
   /// account id into the register.
   ///
   /// # Errors
   ///
   /// * If the registers exceed the memory limit returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `base + write_register_base + write_register_byte * num_bytes`
    pub fn signer_account_id(&mut self, register_id: u64) -> () {
        self.run_vm(|vm| vm.signer_account_id(register_id)).unwrap()
    }
   /// Saves the public key fo the access key that was used by the signer into the register. In
   /// rare situations smart contract might want to know the exact access key that was used to send
   /// the original transaction, e.g. to increase the allowance or manipulate with the public key.
   ///
   /// # Errors
   ///
   /// * If the registers exceed the memory limit returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `base + write_register_base + write_register_byte * num_bytes`
    pub fn signer_account_pk(&mut self, register_id: u64) -> () {
        self.run_vm(|vm| vm.signer_account_pk(register_id)).unwrap()
    }
   /// All contract calls are a result of a receipt, this receipt might be created by a transaction
   /// that does function invocation on the contract or another contract as a result of
   /// cross-contract call. Saves the bytes of the predecessor account id into the register.
   ///
   /// # Errors
   ///
   /// * If the registers exceed the memory limit returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `base + write_register_base + write_register_byte * num_bytes`
    pub fn predecessor_account_id(&mut self, register_id: u64) -> () {
        self.run_vm(|vm| vm.predecessor_account_id(register_id)).unwrap()
    }
   /// Reads input to the contract call into the register. Input is expected to be in JSON-format.
   /// If input is provided saves the bytes (potentially zero) of input into register. If input is
   /// not provided writes 0 bytes into the register.
   ///
   /// # Cost
   ///
   /// `base + write_register_base + write_register_byte * num_bytes`
    pub fn input(&mut self, register_id: u64) -> () {
        self.run_vm(|vm| vm.input(register_id)).unwrap()
    }
   /// Returns the current block height.
   ///
   /// # Cost
   ///
   /// `base`
   /// TODO #1903 rename to `block_height`
    pub fn block_index(&mut self) -> u64 {
        self.run_vm(|vm| vm.block_index()).unwrap()
    }
   /// Returns the current block timestamp.
   ///
   /// # Cost
   ///
   /// `base`
    pub fn block_timestamp(&mut self) -> u64 {
        self.run_vm(|vm| vm.block_timestamp()).unwrap()
    }
   /// Returns the number of bytes used by the contract if it was saved to the trie as of the
   /// invocation. This includes:
   /// * The data written with storage_* functions during current and previous execution;
   /// * The bytes needed to store the access keys of the given account.
   /// * The contract code size
   /// * A small fixed overhead for account metadata.
   ///
   /// # Cost
   ///
   /// `base`
    pub fn storage_usage(&mut self) -> StorageUsage {
        self.run_vm(|vm| vm.storage_usage()).unwrap()
    }
   /// #################
   /// # Economics API #
   /// #################

   /// The current balance of the given account. This includes the attached_deposit that was
   /// attached to the transaction.
   ///
   /// # Cost
   ///
   /// `base + memory_write_base + memory_write_size * 16`
    pub fn account_balance(&mut self, balance_ptr: u64) -> () {
        // self.builder.memory.write_memory(balance_ptr, &self.context.account_balance.to_le_bytes())
        self.run_vm(|vm| vm.account_balance(balance_ptr)).unwrap()
    }
   /// The current amount of tokens locked due to staking.
   ///
   /// # Cost
   ///
   /// `base + memory_write_base + memory_write_size * 16`
    pub fn account_locked_balance(&mut self, balance_ptr: u64) -> () {
        self.run_vm(|vm| vm.account_locked_balance(balance_ptr)).unwrap()
    }
   /// The balance that was attached to the call that will be immediately deposited before the
   /// contract execution starts.
   ///
   /// # Errors
   ///
   /// If called as view function returns `ProhibitedInView``.
   ///
   /// # Cost
   ///
   /// `base + memory_write_base + memory_write_size * 16`
    pub fn attached_deposit(&mut self, balance_ptr: u64) -> () {
        self.run_vm(|vm| vm.attached_deposit(balance_ptr)).unwrap()
    }
   /// The amount of gas attached to the call that can be used to pay for the gas fees.
   ///
   /// # Errors
   ///
   /// If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `base`
    pub fn prepaid_gas(&mut self) -> Gas {
        self.run_vm(|vm| vm.prepaid_gas()).unwrap()
    }
   /// The gas that was already burnt during the contract execution (cannot exceed `prepaid_gas`)
   ///
   /// # Errors
   ///
   /// If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `base`
    pub fn used_gas(&mut self) -> Gas {
        self.run_vm(|vm| vm.used_gas()).unwrap()
    }
   /// ############
   /// # Math API #
   /// ############

   /// Writes random seed into the register.
   ///
   /// # Errors
   ///
   /// If the size of the registers exceed the set limit `MemoryAccessViolation`.
   ///
   /// # Cost
   ///
   /// `base + write_register_base + write_register_byte * num_bytes`.
    pub fn random_seed(&mut self, register_id: u64) -> () {
        self.run_vm(|vm| vm.random_seed(register_id)).unwrap()
    }
   /// Hashes the random sequence of bytes using sha256 and returns it into `register_id`.
   ///
   /// # Errors
   ///
   /// If `value_len + value_ptr` points outside the memory or the registers use more memory than
   /// the limit with `MemoryAccessViolation`.
   ///
   /// # Cost
   ///
   /// `base + write_register_base + write_register_byte * num_bytes + sha256_base + sha256_byte * num_bytes`
    pub fn sha256(&mut self, value_len: u64, value_ptr: u64, register_id: u64) -> () {
        self.run_vm(|vm| vm.sha256(value_len, value_ptr, register_id)).unwrap()
        
    }
   /// Called by gas metering injected into Wasm. Counts both towards `burnt_gas` and `used_gas`.
   ///
   /// # Errors
   ///
   /// * If passed gas amount somehow overflows internal gas counters returns `IntegerOverflow`;
   /// * If we exceed usage limit imposed on burnt gas returns `GasLimitExceeded`;
   /// * If we exceed the `prepaid_gas` then returns `GasExceeded`.
    pub fn gas(&mut self, gas_amount: u32) -> () {
        self.run_vm(|vm| vm.gas(gas_amount)).unwrap()
    }

   /// ################
   /// # Promises API #
   /// ################

   /// A helper function to pay gas fee for creating a new receipt without actions.
   /// # Args:
   /// * `sir`: whether contract call is addressed to itself;
   /// * `data_dependencies`: other contracts that this execution will be waiting on (or rather
   ///   their data receipts), where bool indicates whether this is sender=receiver communication.
   ///
   /// # Cost
   ///
   /// This is a convenience function that encapsulates several costs:
   /// `burnt_gas := dispatch cost of the receipt + base dispatch cost  cost of the data receipt`
   /// `used_gas := burnt_gas + exec cost of the receipt + base exec cost  cost of the data receipt`
   /// Notice that we prepay all base cost upon the creation of the data dependency, we are going to
   /// pay for the content transmitted through the dependency upon the actual creation of the
   /// DataReceipt.

   /// A helper function to subtract balance on transfer or attached deposit for promises.
   /// # Args:
   /// * `amount`: the amount to deduct from the current account balance.

   /// Creates a promise that will execute a method on account with given arguments and attaches
   /// the given amount and gas. `amount_ptr` point to slices of bytes representing `u128`.
   ///
   /// # Errors
   ///
   /// * If `account_id_len + account_id_ptr` or `method_name_len + method_name_ptr` or
   /// `arguments_len + arguments_ptr` or `amount_ptr + 16` points outside the memory of the guest
   /// or host returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Returns
   ///
   /// Index of the new promise that uniquely identifies it within the current execution of the
   /// method.
   ///
   /// # Cost
   ///
   /// Since `promise_create` is a convenience wrapper around `promise_batch_create` and
   /// `promise_batch_action_function_call`. This also means it charges `base` cost twice.
    pub fn promise_create(
        &mut self,
        account_id_len: u64,
        account_id_ptr: u64,
        method_name_len: u64,
        method_name_ptr: u64,
        arguments_len: u64,
        arguments_ptr: u64,
        amount_ptr: u64,
        gas: Gas,
    ) -> u64 {
        self.run_vm(|vm| vm.promise_create(
            account_id_len,
            account_id_ptr,
            method_name_len,
            method_name_ptr,
            arguments_len,
            arguments_ptr,
            amount_ptr,
            gas)).unwrap()
    }

   /// Attaches the callback that is executed after promise pointed by `promise_idx` is complete.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`;
   /// * If `account_id_len + account_id_ptr` or `method_name_len + method_name_ptr` or
   ///   `arguments_len + arguments_ptr` or `amount_ptr + 16` points outside the memory of the
   ///   guest or host returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Returns
   ///
   /// Index of the new promise that uniquely identifies it within the current execution of the
   /// method.
   ///
   /// # Cost
   ///
   /// Since `promise_create` is a convenience wrapper around `promise_batch_then` and
   /// `promise_batch_action_function_call`. This also means it charges `base` cost twice.
    pub fn promise_then(
        &mut self,
        promise_idx: u64,
        account_id_len: u64,
        account_id_ptr: u64,
        method_name_len: u64,
        method_name_ptr: u64,
        arguments_len: u64,
        arguments_ptr: u64,
        amount_ptr: u64,
        gas: u64,
    ) -> u64 {
        self.run_vm(|vm| vm.promise_then(
            promise_idx,
            account_id_len,
            account_id_ptr,
            method_name_len,
            method_name_ptr,
            arguments_len,
            arguments_ptr,
            amount_ptr,
            gas,
        )).unwrap()
    }

   /// Creates a new promise which completes when time all promises passed as arguments complete.
   /// Cannot be used with registers. `promise_idx_ptr` points to an array of `u64` elements, with
   /// `promise_idx_count` denoting the number of elements. The array contains indices of promises
   /// that need to be waited on jointly.
   ///
   /// # Errors
   ///
   /// * If `promise_ids_ptr + 8 * promise_idx_count` extend outside the guest memory returns
   ///   `MemoryAccessViolation`;
   /// * If any of the promises in the array do not correspond to existing promises returns
   ///   `InvalidPromiseIndex`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Returns
   ///
   /// Index of the new promise that uniquely identifies it within the current execution of the
   /// method.
   ///
   /// # Cost
   ///
   /// `base + promise_and_base + promise_and_per_promise * num_promises + cost of reading promise ids from memory`.
    pub fn promise_and(
        &mut self,
        promise_idx_ptr: u64,
        promise_idx_count: u64,
    ) -> PromiseIndex {
        self.run_vm(|vm| vm.promise_and(promise_idx_ptr, promise_idx_count)).unwrap()
    }

   /// Creates a new promise towards given `account_id` without any actions attached to it.
   ///
   /// # Errors
   ///
   /// * If `account_id_len + account_id_ptr` points outside the memory of the guest or host
   /// returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Returns
   ///
   /// Index of the new promise that uniquely identifies it within the current execution of the
   /// method.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + cost of reading and decoding the account id + dispatch cost of the receipt`.
   /// `used_gas := burnt_gas + exec cost of the receipt`.
    pub fn promise_batch_create(
        &mut self,
        account_id_len: u64,
        account_id_ptr: u64,
    ) -> u64 {
        self.run_vm(|vm| vm.promise_batch_create(account_id_len, account_id_ptr)).unwrap()
    }

   /// Creates a new promise towards given `account_id` without any actions attached, that is
   /// executed after promise pointed by `promise_idx` is complete.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`;
   /// * If `account_id_len + account_id_ptr` points outside the memory of the guest or host
   /// returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Returns
   ///
   /// Index of the new promise that uniquely identifies it within the current execution of the
   /// method.
   ///
   /// # Cost
   ///
   /// `base + cost of reading and decoding the account id + dispatch&execution cost of the receipt
   ///  + dispatch&execution base cost for each data dependency`
    pub fn promise_batch_then(
        &mut self,
        promise_idx: u64,
        account_id_len: u64,
        account_id_ptr: u64,
    ) -> u64 {
        self.run_vm(|vm| vm.promise_batch_then(promise_idx, account_id_len, account_id_ptr)).unwrap()
    }

   /// Appends `CreateAccount` action to the batch of actions for the given promise pointed by
   /// `promise_idx`.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action fee`
   /// `used_gas := burnt_gas + exec action fee`
    pub fn promise_batch_action_create_account(&mut self, promise_idx: u64) -> () {
        self.run_vm(|vm| vm.promise_batch_action_create_account(promise_idx)).unwrap()
    }
   /// Appends `DeployContract` action to the batch of actions for the given promise pointed by
   /// `promise_idx`.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If `code_len + code_ptr` points outside the memory of the guest or host returns
   /// `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory `
   /// `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    pub fn promise_batch_action_deploy_contract(
        &mut self,
        promise_idx: u64,
        code_len: u64,
        code_ptr: u64,
    ) -> () {
        self.run_vm(|vm| vm.promise_batch_action_deploy_contract(promise_idx, code_len, code_ptr)).unwrap()
    }

   /// Appends `FunctionCall` action to the batch of actions for the given promise pointed by
   /// `promise_idx`.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If `method_name_len + method_name_ptr` or `arguments_len + arguments_ptr` or
   /// `amount_ptr + 16` points outside the memory of the guest or host returns
   /// `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory
   ///  + cost of reading u128, method_name and arguments from the memory`
   /// `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    pub fn promise_batch_action_function_call(
        &mut self,
        promise_idx: u64,
        method_name_len: u64,
        method_name_ptr: u64,
        arguments_len: u64,
        arguments_ptr: u64,
        amount_ptr: u64,
        gas: Gas,
    ) -> () {
        self.run_vm(|vm| vm.promise_batch_action_function_call(promise_idx, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas)).unwrap()
    }

   /// Appends `Transfer` action to the batch of actions for the given promise pointed by
   /// `promise_idx`.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If `amount_ptr + 16` points outside the memory of the guest or host returns
   /// `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading u128 from memory `
   /// `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    pub fn promise_batch_action_transfer(
        &mut self,
        promise_idx: u64,
        amount_ptr: u64,
    ) -> () {
        self.run_vm(|vm| vm.promise_batch_action_transfer(promise_idx, amount_ptr)).unwrap()
    }

   /// Appends `Stake` action to the batch of actions for the given promise pointed by
   /// `promise_idx`.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
   /// * If `amount_ptr + 16` or `public_key_len + public_key_ptr` points outside the memory of the
   /// guest or host returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
   /// `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    pub fn promise_batch_action_stake(
        &mut self,
        promise_idx: u64,
        amount_ptr: u64,
        public_key_len: u64,
        public_key_ptr: u64,
    ) -> () {
        self.run_vm(|vm| vm.promise_batch_action_stake(promise_idx, amount_ptr, public_key_len, public_key_ptr)).unwrap()
    }

   /// Appends `AddKey` action to the batch of actions for the given promise pointed by
   /// `promise_idx`. The access key will have `FullAccess` permission.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
   /// * If `public_key_len + public_key_ptr` points outside the memory of the guest or host
   /// returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
   /// `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    pub fn promise_batch_action_add_key_with_full_access(
        &mut self,
        promise_idx: u64,
        public_key_len: u64,
        public_key_ptr: u64,
        nonce: u64,
    ) -> () {
        self.run_vm(|vm| vm.promise_batch_action_add_key_with_full_access(promise_idx, public_key_len, public_key_ptr, nonce)).unwrap()
    }

   /// Appends `AddKey` action to the batch of actions for the given promise pointed by
   /// `promise_idx`. The access key will have `FunctionCall` permission.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
   /// * If `public_key_len + public_key_ptr`, `allowance_ptr + 16`,
   /// `receiver_id_len + receiver_id_ptr` or `method_names_len + method_names_ptr` points outside
   /// the memory of the guest or host returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory
   ///  + cost of reading u128, method_names and public key from the memory + cost of reading and parsing account name`
   /// `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    pub fn promise_batch_action_add_key_with_function_call(
        &mut self,
        promise_idx: u64,
        public_key_len: u64,
        public_key_ptr: u64,
        nonce: u64,
        allowance_ptr: u64,
        receiver_id_len: u64,
        receiver_id_ptr: u64,
        method_names_len: u64,
        method_names_ptr: u64,
    ) -> () {
        self.run_vm(|vm| vm.promise_batch_action_add_key_with_function_call(
            promise_idx,
            public_key_len,
            public_key_ptr,
            nonce,
            allowance_ptr,
            receiver_id_len,
            receiver_id_ptr,
            method_names_len,
            method_names_ptr,
        )).unwrap()

    }

   /// Appends `DeleteKey` action to the batch of actions for the given promise pointed by
   /// `promise_idx`.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
   /// * If `public_key_len + public_key_ptr` points outside the memory of the guest or host
   /// returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
   /// `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    pub fn promise_batch_action_delete_key(
        &mut self,
        promise_idx: u64,
        public_key_len: u64,
        public_key_ptr: u64,
    ) -> () {
        self.run_vm(|vm| vm.promise_batch_action_delete_key(promise_idx, public_key_len, public_key_ptr)).unwrap()
    }

   /// Appends `DeleteAccount` action to the batch of actions for the given promise pointed by
   /// `promise_idx`.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If the promise pointed by the `promise_idx` is an ephemeral promise created by
   /// `promise_and` returns `CannotAppendActionToJointPromise`.
   /// * If `beneficiary_id_len + beneficiary_id_ptr` points outside the memory of the guest or
   /// host returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading and parsing account id from memory `
   /// `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    pub fn promise_batch_action_delete_account(
        &mut self,
        promise_idx: u64,
        beneficiary_id_len: u64,
        beneficiary_id_ptr: u64,
    ) -> () {
       self.run_vm(|vm| vm.promise_batch_action_delete_account(promise_idx, beneficiary_id_len, beneficiary_id_ptr)).unwrap()
    }

   /// If the current function is invoked by a callback we can access the execution results of the
   /// promises that caused the callback. This function returns the number of complete and
   /// incomplete callbacks.
   ///
   /// Note, we are only going to have incomplete callbacks once we have promise_or combinator.
   ///
   ///
   /// * If there is only one callback returns `1`;
   /// * If there are multiple callbacks (e.g. created through `promise_and`) returns their number;
   /// * If the function was called not through the callback returns `0`.
   ///
   /// # Cost
   ///
   /// `base`
    pub fn promise_results_count(&mut self) -> u64 {
        self.run_vm(|vm| vm.promise_results_count()).unwrap()
    }
   /// If the current function is invoked by a callback we can access the execution results of the
   /// promises that caused the callback. This function returns the result in blob format and
   /// places it into the register.
   ///
   /// * If promise result is complete and successful copies its blob into the register;
   /// * If promise result is complete and failed or incomplete keeps register unused;
   ///
   /// # Returns
   ///
   /// * If promise result is not complete returns `0`;
   /// * If promise result is complete and successful returns `1`;
   /// * If promise result is complete and failed returns `2`.
   ///
   /// # Errors
   ///
   /// * If `result_id` does not correspond to an existing result returns `InvalidPromiseResultIndex`;
   /// * If copying the blob exhausts the memory limit it returns `MemoryAccessViolation`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `base + cost of writing data into a register`
    pub fn promise_result(&mut self, result_idx: u64, register_id: u64) -> u64 {
        self.run_vm(|vm| vm.promise_result(result_idx, register_id)).unwrap()
    }
   /// When promise `promise_idx` finishes executing its result is considered to be the result of
   /// the current function.
   ///
   /// # Errors
   ///
   /// * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
   /// * If called as view function returns `ProhibitedInView`.
   ///
   /// # Cost
   ///
   /// `base + promise_return`
    pub fn promise_return(&mut self, promise_idx: u64) -> () {
        self.run_vm(|vm| vm.promise_return(promise_idx)).unwrap()
    }
   /// #####################
   /// # Miscellaneous API #
   /// #####################

   /// sets the blob of data as the return value of the contract.
   ///
   /// # Errors
   ///
   /// If `value_len + value_ptr` exceeds the memory container or points to an unused register it
   /// returns `MemoryAccessViolation`.
   ///
   /// # Cost
   /// `base + cost of reading return value from memory or register + dispatch&exec cost per byte of the data sent * num data receivers`
    pub fn value_return(&mut self, value_len: u64, value_ptr: u64) -> () {
        self.run_vm(|vm| vm.value_return(value_len, value_ptr)).unwrap()
    }
   /// Terminates the execution of the program with panic `GuestPanic`.
   ///
   /// # Cost
   ///
   /// `base`
    pub fn panic(&mut self) -> () {
        self.run_vm(|vm| vm.panic()).unwrap()
    }
   /// Guest panics with the UTF-8 encoded string.
   /// If `len == u64::MAX` then treats the string as null-terminated with character `'\0'`.
   ///
   /// # Errors
   ///
   /// * If string extends outside the memory of the guest with `MemoryAccessViolation`;
   /// * If string is not UTF-8 returns `BadUtf8`.
   /// * If string is longer than `max_log_len` returns `BadUtf8`.
   ///
   /// # Cost
   /// `base + cost of reading and decoding a utf8 string`
    pub fn panic_utf8(&mut self, len: u64, ptr: u64) -> () {
        self.run_vm(|vm| vm.panic_utf8(len, ptr)).unwrap()
    }
   /// Logs the UTF-8 encoded string.
   /// If `len == u64::MAX` then treats the string as null-terminated with character `'\0'`.
   ///
   /// # Errors
   ///
   /// * If string extends outside the memory of the guest with `MemoryAccessViolation`;
   /// * If string is not UTF-8 returns `BadUtf8`.
   /// * If string is longer than `max_log_len` returns `BadUtf8`.
   ///
   /// # Cost
   ///
   /// `base + log_base + log_byte + num_bytes + utf8 decoding cost`
    pub fn log_utf8(&mut self, len: u64, ptr: u64) -> () {
        self.run_vm(|vm| vm.log_utf8(len, ptr)).unwrap()
    }
   /// Logs the UTF-16 encoded string. If `len == u64::MAX` then treats the string as
   /// null-terminated with two-byte sequence of `0x00 0x00`.
   ///
   /// # Errors
   ///
   /// * If string extends outside the memory of the guest with `MemoryAccessViolation`;
   /// * If string is not UTF-16 returns `BadUtf16`.
   ///
   /// # Cost
   ///
   /// `base + log_base + log_byte * num_bytes + utf16 decoding cost`
    pub fn log_utf16(&mut self, len: u64, ptr: u64) -> () {
        self.run_vm(|vm| vm.log_utf16(len, ptr)).unwrap()
    }
   /// Special import kept for compatibility with AssemblyScript contracts. Not called by smart
   /// contracts directly, but instead called by the code generated by AssemblyScript.
   ///
   /// # Cost
   ///
   /// `base +  log_base + log_byte * num_bytes + utf16 decoding cost`
    pub fn abort(&mut self, msg_ptr: u32, filename_ptr: u32, line: u32, col: u32) -> () {
        self.run_vm(|vm| vm.abort(msg_ptr, filename_ptr, line, col)).unwrap()
    }
   /// ###############
   /// # Storage API #
   /// ###############

   /// Reads account id from the given location in memory.
   ///
   /// # Errors
   ///
   /// * If account is not UTF-8 encoded then returns `BadUtf8`;
   ///
   /// # Cost
   ///
   /// This is a helper function that encapsulates the following costs:
   /// cost of reading buffer from register or memory,
   /// `utf8_decoding_base + utf8_decoding_byte * num_bytes`.

   /// Writes key-value into storage.
   /// * If key is not in use it inserts the key-value pair and does not modify the register. Returns `0`;
   /// * If key is in use it inserts the key-value and copies the old value into the `register_id`. Returns `1`.
   ///
   /// # Errors
   ///
   /// * If `key_len + key_ptr` or `value_len + value_ptr` exceeds the memory container or points
   ///   to an unused register it returns `MemoryAccessViolation`;
   /// * If returning the preempted value into the registers exceed the memory container it returns
   ///   `MemoryAccessViolation`.
   ///
   /// # Cost
   ///
   /// `base + storage_write_base + storage_write_key_byte * num_key_bytes + storage_write_value_byte * num_value_bytes
   /// + get_vec_from_memory_or_register_cost x 2`.
   ///
   /// If a value was evicted it costs additional `storage_write_value_evicted_byte * num_evicted_bytes + internal_write_register_cost`.
    pub fn storage_write(
        &mut self,
        key_len: u64,
        key_ptr: u64,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
    ) -> u64 {
        self.run_vm(|vm| {
            // console::log_1(&vm.current_storage_usage.to_string().into());
            let res = vm.storage_write(key_len, key_ptr, value_len, value_ptr, register_id); 
            // console::log_1(&vm.current_storage_usage.to_string().into());
            res
        }).unwrap()
    }

   /// Reads the value stored under the given key.
   /// * If key is used copies the content of the value into the `register_id`, even if the content
   ///   is zero bytes. Returns `1`;
   /// * If key is not present then does not modify the register. Returns `0`;
   ///
   /// # Errors
   ///
   /// * If `key_len + key_ptr` exceeds the memory container or points to an unused register it
   ///   returns `MemoryAccessViolation`;
   /// * If returning the preempted value into the registers exceed the memory container it returns
   ///   `MemoryAccessViolation`.
   ///
   /// # Cost
   ///
   /// `base + storage_read_base + storage_read_key_byte * num_key_bytes + storage_read_value_byte + num_value_bytes
   ///  cost to read key from register + cost to write value into register`.
    pub fn storage_read(&mut self, key_len: u64, key_ptr: u64, register_id: u64) -> u64 {
        self.run_vm(|vm| vm.storage_read(key_len, key_ptr, register_id)).unwrap()
    }
   /// Removes the value stored under the given key.
   /// * If key is used, removes the key-value from the trie and copies the content of the value
   ///   into the `register_id`, even if the content is zero bytes. Returns `1`;
   /// * If key is not present then does not modify the register. Returns `0`.
   ///
   /// # Errors
   ///
   /// * If `key_len + key_ptr` exceeds the memory container or points to an unused register it
   ///   returns `MemoryAccessViolation`;
   /// * If the registers exceed the memory limit returns `MemoryAccessViolation`;
   /// * If returning the preempted value into the registers exceed the memory container it returns
   ///   `MemoryAccessViolation`.
   ///
   /// # Cost
   ///
   /// `base + storage_remove_base + storage_remove_key_byte * num_key_bytes + storage_remove_ret_value_byte * num_value_bytes
   /// + cost to read the key + cost to write the value`.
    pub fn storage_remove(&mut self, key_len: u64, key_ptr: u64, register_id: u64) -> u64 {
        self.run_vm(|vm| vm.storage_remove(key_len, key_ptr, register_id)).unwrap()
    }
    /// Checks if there is a key-value pair.
    /// * If key is used returns `1`, even if the value is zero bytes;
    /// * Otherwise returns `0`.
    ///
    /// # Errors
    ///
    /// If `key_len + key_ptr` exceeds the memory container it returns `MemoryAccessViolation`.
    ///
    /// # Cost
    ///
    /// `base + storage_has_key_base + storage_has_key_byte * num_bytes + cost of reading key`
    pub fn storage_has_key(&mut self, key_len: u64, key_ptr: u64) -> u64 {
        self.run_vm(|vm| vm.storage_has_key(key_len, key_ptr)).unwrap()
    }
   /// Creates an iterator object inside the host. Returns the identifier that uniquely
   /// differentiates the given iterator from other iterators that can be simultaneously created.
   /// * It iterates over the keys that have the provided prefix. The order of iteration is defined
   ///   by the lexicographic order of the bytes in the keys;
   /// * If there are no keys, it creates an empty iterator, see below on empty iterators.
   ///
   /// # Errors
   ///
   /// If `prefix_len + prefix_ptr` exceeds the memory container it returns `MemoryAccessViolation`.
   ///
   /// # Cost
   ///
   /// `base + storage_iter_create_prefix_base + storage_iter_create_key_byte * num_prefix_bytes
   ///  cost of reading the prefix`.
    pub fn storage_iter_prefix(&mut self, prefix_len: u64, prefix_ptr: u64) -> u64 {
        self.run_vm(|vm| vm.storage_iter_prefix(prefix_len, prefix_ptr)).unwrap()
    }
   /// Iterates over all key-values such that keys are between `start` and `end`, where `start` is
   /// inclusive and `end` is exclusive. Unless lexicographically `start < end`, it creates an
   /// empty iterator. Note, this definition allows for `start` or `end` keys to not actually exist
   /// on the given trie.
   ///
   /// # Errors
   ///
   /// If `start_len + start_ptr` or `end_len + end_ptr` exceeds the memory container or points to
   /// an unused register it returns `MemoryAccessViolation`.
   ///
   /// # Cost
   ///
   /// `base + storage_iter_create_range_base + storage_iter_create_from_byte * num_from_bytes
   ///  + storage_iter_create_to_byte * num_to_bytes + reading from prefix + reading to prefix`.
    pub fn storage_iter_range(
        &mut self,
        start_len: u64,
        start_ptr: u64,
        end_len: u64,
        end_ptr: u64,
    ) -> u64 {
        self.run_vm(|vm| vm.storage_iter_range(start_len, start_ptr, end_len, end_ptr)).unwrap()
    }

   /// Advances iterator and saves the next key and value in the register.
   /// * If iterator is not empty (after calling next it points to a key-value), copies the key
   ///   into `key_register_id` and value into `value_register_id` and returns `1`;
   /// * If iterator is empty returns `0`;
   /// This allows us to iterate over the keys that have zero bytes stored in values.
   ///
   /// # Errors
   ///
   /// * If `key_register_id == value_register_id` returns `MemoryAccessViolation`;
   /// * If the registers exceed the memory limit returns `MemoryAccessViolation`;
   /// * If `iterator_id` does not correspond to an existing iterator returns `InvalidIteratorId`;
   /// * If between the creation of the iterator and calling `storage_iter_next` the range over
   ///   which it iterates was modified returns `IteratorWasInvalidated`. Specifically, if
   ///   `storage_write` or `storage_remove` was invoked on the key key such that:
   ///   * in case of `storage_iter_prefix`. `key` has the given prefix and:
   ///     * Iterator was not called next yet.
   ///     * `next` was already called on the iterator and it is currently pointing at the `key`
   ///       `curr` such that `curr <= key`.
   ///   * in case of `storage_iter_range`. `start<=key<end` and:
   ///     * Iterator was not called `next` yet.
   ///     * `next` was already called on the iterator and it is currently pointing at the key
   ///       `curr` such that `curr<=key<end`.
   ///
   /// # Cost
   ///
   /// `base + storage_iter_next_base + storage_iter_next_key_byte * num_key_bytes + storage_iter_next_value_byte * num_value_bytes
   ///  + writing key to register + writing value to register`.
    pub fn storage_iter_next(
        &mut self,
        iterator_id: u64,
        key_register_id: u64,
        value_register_id: u64,
    ) -> u64 {
        self.run_vm(|vm| vm.storage_iter_next(iterator_id, key_register_id, value_register_id)).unwrap()
    }

   ///Computes the outcome of execution.
    pub fn outcome(&mut self) -> JsValue {
        let mut vm = self.builder.build(self.context.clone());
        if self.internal_state.is_some() {
            vm.restore_state(self.internal_state.as_ref().unwrap());
        }
        let res = vm.outcome();
        let outcome = _VMOutcome {
            balance1: (res.balance >> 64) as u64,
            balance2: ((res.balance << 64) >> 64) as u64,
            storage_usage: res.storage_usage,
            return_data: res.return_data,
            burnt_gas: res.burnt_gas,
            used_gas: res.used_gas,
            logs: res.logs
        };
        serde_wasm_bindgen::to_value(&outcome).unwrap()
    }
}

#[derive(Serialize)]
pub struct _VMOutcome {
    pub balance1: u64,
    pub balance2: u64,
    pub storage_usage: StorageUsage,
    pub return_data: ReturnData,
    pub burnt_gas: Gas,
    pub used_gas: Gas,
    pub logs: Vec<String>,
}

'''
'''--- src/utils.rs ---
pub fn set_panic_hook() {
    // When the `console_error_panic_hook` feature is enabled, we can call the
    // `set_panic_hook` function at least once during initialization, and then
    // we will get better error messages if our code ever panics.
    //
    // For more details see
    // https://github.com/rustwasm/console_error_panic_hook#readme
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();
}

pub fn u128_from_u64s(lo: u64, hi: u64) -> u128 {
    u128::from(hi).rotate_left(64) + u128::from(lo)
}

'''
'''--- test.sh ---
#! /usr/bin/sh
wasm-pack --verbose build --target nodejs --debug && node tests/test.js 
'''
'''--- tests/runWasm.js ---
let rust = require("../pkg/wasm_mock_vm");
let fs = require("fs");

global.run_binary = (bin, method) => {
  let mod = new WebAssembly.Module(bin);
  let inst = new WebAssembly.Instance(mod, {});
  return BigInt(inst.exports[method](1, 2));
}
let bin = fs.readFileSync("src/mock/add.wasm")
rust.run(bin);

'''
'''--- tests/test.js ---
let rust = require("../pkg/wasm_mock_vm");
let assert = require("assert");
let utils = require('./utils');
let bs58 = require("bs58");

const memory = new Uint8Array(10000);

// Returns whether the memory interval is completely inside the smart contract memory.
global.fits_memory = (offset, len) => utils.toNum(offset) + utils.toNum(len) < memory.length;

// Reads the content of the given memory interval.
//
// # Panics
//
// If memory interval is outside the smart contract memory.
global.read_memory = (offset, buffer) => {
    offset = utils.toNum(offset)
    buffer.set(memory.slice(offset, offset + buffer.length), 0)
};

// Reads a single byte from the memory.
//
// # Panics
//
// If pointer is outside the smart contract memory.
global.read_memory_u8 = (offset) => memory[utils.toNum(offset)];

// Writes the buffer into the smart contract memory.
//
// # Panics
//
// If `offset + buffer.len()` is outside the smart contract memory.
global.write_memory = (offset, buffer) => {
    memory.set(buffer, utils.toNum(offset));
}

const current_account_id = "alice"; 
const signer_account_id = "bob";
const signer_account_pk = "HuxUynD5GdrcZ5MauxJuu74sGHgS6wLfCqqhQkLWK";
const predecessor_account_id = "carol";
const input = "{ arg1: 1 }";
const block_index = 10;
const block_timestamp = 42;
const account_balance = 2;
const account_locked_balance = 1;
const storage_usage = 12;
const attached_deposit = 2;
const prepaid_gas = 10**(14);
const random_seed = "HuxUynD5GdrcZ5MauxJuu74sGHgS6wLfCqqhQkLWK";
const is_view = false;
const output_data_receivers= new Uint8Array([]);

context =  {
    /// The account id of the current contract that we are executing.
    current_account_id, // string
    /// The account id of that signed the original transaction that led to this
    /// execution.
    signer_account_id, // string
    /// The public key that was used to sign the original transaction that led to
    /// this execution.
    signer_account_pk,
    predecessor_account_id,
    input,
    block_index,
    block_timestamp,
    account_balance,
    account_locked_balance,
    storage_usage,
    attached_deposit,
    prepaid_gas,
    random_seed,
    is_view,
    output_data_receivers,
}

function readReg(id) {
    const ptr = 10;
    let len = utils.toNum(vm.register_len(BigInt(id)));
    let before = memory.slice(ptr, ptr + len);
    vm.read_register(BigInt(id), BigInt(ptr));
    const res = memory.slice(ptr, ptr + utils.toNum(len));
    memory.set(before, ptr);
    return res;
}

// let map = new Array();
// map[0] = [0, new Uint8Array([42])];
let vm = new rust.VM(context);
vm.signer_account_pk(BigInt(1));
// vm.read_register(BigInt(1), BigInt(1));
assert.equal(bs58.encode(Buffer.from(readReg(1))), signer_account_pk);
debugger;
// vm.read_register(BigInt(0), BigInt(0));
// assert(memory[0] == 42);
memory[1] = 85;
vm.write_register(BigInt(1), BigInt(1), BigInt(1));
assert.equal(readReg(1)[0], 85);

vm.input(BigInt(0));
assert.equal(utils.UTF8toStr(readReg(0)), input);

function storage_write(_key, _value) {
    let key = utils.StrtoUTF8(_key);
    let value = utils.StrtoUTF8(_value);
    memory.set(key, 1000);
    memory.set(value, 2000);
    vm.storage_write(BigInt(key.length), BigInt(1000), BigInt(value.length), BigInt(2000), BigInt(1));
    vm.storage_read(BigInt(key.length), BigInt(1000), BigInt(1));
}

function storage_read(_key, ptr) {
    let key = utils.StrtoUTF8(_key);
    memory.set(key, ptr);
    vm.storage_read(BigInt(key.length), BigInt(ptr), BigInt(0));
    return utils.UTF8toStr(readReg(0));
}

function storage_has_key(_key) {
    let key = utils.StrtoUTF8(_key);
    const saved = memory.slice(1000, 1000 + key.length);
    memory.set(key, 1000);
    let res = vm.storage_has_key(BigInt(key.length), BigInt(1000));
    memory.set(saved, 1000);
    return res;
}

const data = "I am data";
storage_write("key", data);
assert.equal(storage_read("key", 1000), data)
// assert.deepEqual(utils.UTF8toStr(memory.slice(1000, 1000 + toNum(vm.register_len(BigInt(0))))), data);
assert(storage_has_key("key"));

var errored = false
vm.read_register(BigInt(10), BigInt(0));
storage_write("key1", data);

let key = utils.StrtoUTF8("key");
// const saved = memory.slice(1000, 1000 + key.length);
memory.set(key, 2000);

let iterid = vm.storage_iter_prefix(BigInt(key.length), BigInt(2000));
console.log(iterid);
vm.storage_iter_next(iterid, BigInt(2), BigInt(3));
console.log(utils.UTF8toStr(readReg(2)),utils.UTF8toStr(readReg(3)));
vm.storage_iter_next(iterid, BigInt(2), BigInt(3));
console.log(utils.UTF8toStr(readReg(2)),utils.UTF8toStr(readReg(3)));

// storage_write("aa", "bar1");
// storage_write("aaa", "bar2");
// storage_write("ab", "bar2");
// storage_write("abb", "bar3");

// key = utils.StrtoUTF8("key");
// // const saved = memory.slice(1000, 1000 + key.length);
// memory.set(key, 2000);

key2 = utils.StrtoUTF8("key9");
// const saved = memory.slice(1000, 1000 + key.length);
memory.set(key2, 3000);

iterid = vm.storage_iter_range(BigInt(key.length), BigInt(2000), BigInt(key2.length), BigInt(3000));
console.log(iterid);
while (vm.storage_iter_next(iterid, BigInt(2), BigInt(3)) > 0) {
    console.log(utils.UTF8toStr(readReg(2)),utils.UTF8toStr(readReg(3)));
}
str = utils.StrtoUTF8("hello dolly!");
memory.set(str, 4000);
vm.log_utf8(BigInt(str.length), BigInt(4000));

console.log(vm.outcome());
// vm.read_register(BigInt(0), BigInt(0));
// assert(memory[0] == 84);

// vm.signer_account_pk(BigInt(1));

// assert.equal(vm.storage_usage(), storage_usage);
// assert.equal(vm.used_gas(), used_gas);
// assert.equal(vm.)

// rust.pass_context(context);
// rust.set_context(new VMContext());

console.log("PASSED!");
'''
'''--- tests/utils.js ---

exports.toNum = function(x) { return parseInt(x.toString());}
// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt

/* utf.js - UTF-8 <=> UTF-16 convertion
 *
 * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0
 * LastModified: Dec 25 1999
 * This library is free.  You can redistribute it and/or modify it.
 */

exports.UTF8toStr = function(array) {
    var out, i, len, c;
    var char2, char3;

    out = "";
    len = array.length;
    i = 0;
    while(i < len) {
    c = array[i++];
    switch(c >> 4)
    { 
      case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
        // 0xxxxxxx
        out += String.fromCharCode(c);
        break;
      case 12: case 13:
        // 110x xxxx   10xx xxxx
        char2 = array[i++];
        out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
        break;
      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = array[i++];
        char3 = array[i++];
        out += String.fromCharCode(((c & 0x0F) << 12) |
                       ((char2 & 0x3F) << 6) |
                       ((char3 & 0x3F) << 0));
        break;
    }
    }

    return out;
}

exports.StrtoUTF8 = (str) => {
  var utf8 = [];
  for (var i=0; i < str.length; i++) {
      var charcode = str.charCodeAt(i);
      if (charcode < 0x80) utf8.push(charcode);
      else if (charcode < 0x800) {
          utf8.push(0xc0 | (charcode >> 6), 
                    0x80 | (charcode & 0x3f));
      }
      else if (charcode < 0xd800 || charcode >= 0xe000) {
          utf8.push(0xe0 | (charcode >> 12), 
                    0x80 | ((charcode>>6) & 0x3f), 
                    0x80 | (charcode & 0x3f));
      }
      // surrogate pair
      else {
          i++;
          // UTF-16 encodes 0x10000-0x10FFFF by
          // subtracting 0x10000 and splitting the
          // 20 bits of 0x0-0xFFFFF into two halves
          charcode = 0x10000 + (((charcode & 0x3ff)<<10)
                    | (str.charCodeAt(i) & 0x3ff))
          utf8.push(0xf0 | (charcode >>18), 
                    0x80 | ((charcode>>12) & 0x3f), 
                    0x80 | ((charcode>>6) & 0x3f), 
                    0x80 | (charcode & 0x3f));
      }
  }
  return new Uint8Array(utf8);
};
'''