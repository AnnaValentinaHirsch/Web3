*GitHub Repository "imatomster/campaignlayer-nep245"*

'''--- Cargo.toml ---
[package]
name = "Campaign Layer's NEP245"
version = "0.1.0"
authors = ["Campaign Layers", "support@campaignlayers.com"]
edition = "2023"

[dev-dependencies]
anyhow = "1.0"
near-primitives = "0.5.0"
near-contract-standards = { path = "../../near-contract-standards" }
near-sdk = "4.0.0-pre.6"
near-units = "0.2.0"
serde_json = "1.0"
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.1.1"

# remember to include a line for each contract
multi-token = { path = "./mt" }
defi = { path = "./test-contract-defi" }
approval-receiver = { path = "./test-approval-receiver" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "mt",
  "test-contract-defi",
  "test-approval-receiver",
]
'''
'''--- README.md ---
# CampaignLayerNEP245 Smart Contract

The CampaignLayerNEP245 smart contract is designed to provide multi-token management functionality on the NEAR Protocol. This should mimic the existing ERC1155 we have been using on the Ethereum blockchain.

This includes features for token minting, transferring, approvals, batch transfers, and now token burning!

## Functions

### `new_default_meta(owner_id: AccountId)`

Initializes the contract with default metadata.

### `new(owner_id: AccountId, metadata: MtContractMetadata)`

Initializes the contract with custom metadata.

### `mt_mint(token_owner_id: AccountId, token_metadata: TokenMetadata, supply: Balance) -> Token`

Mints new tokens and assigns them to a specified account.

### `register(token_id: TokenId, account_id: AccountId)`

Registers an account as the owner of a specific token.

### `mt_transfer(receiver_id: AccountId, token_id: TokenId, amount: U128, memo: Option<String>, msg: Option<String>)`

Transfers tokens from the caller's account to another account.

### `mt_batch_transfer(receiver_id: AccountId, token_ids: Vec<TokenId>, amounts: Vec<U128>, memos: Option<Vec<String>>, msgs: Option<Vec<String>>)`

Transfers batches of tokens from the caller's account to another account.

### `mt_approve(token_ids: Vec<TokenId>, amounts: Vec<U128>, account_id: AccountId, msg: Option<String>)`

Approves an account to spend a specific amount of tokens on behalf of the caller.

### `mt_revoke(token_ids: Vec<TokenId>, account_id: AccountId)`

Revokes approval for an account to spend tokens.

### `mt_revoke_all(token_ids: Vec<TokenId>)`

Revokes all approvals for a set of token IDs.

### `mt_balance_of(account_id: AccountId, token_id: TokenId) -> U128`

Retrieves the balance of a specific token for a given account.

### `mt_is_approved(token_ids: Vec<TokenId>, account_id: AccountId, amounts: Vec<U128>, msg: Option<String>) -> bool`

Checks if an account is approved to spend a specific amount of tokens.

### `mt_burn(token_id: TokenId, amount: U128)`

Burns a specified amount of tokens owned by the caller, reducing the token supply.

## Deploying the Smart Contract

1. Clone this repository to your local machine.
2. Install the necessary tools: Rust, Rustup, and NEAR CLI.
3. Compile the smart contract: Run `cargo build --target wasm32-unknown-unknown --release` in the project root directory.
4. Deploy the smart contract: Use NEAR CLI to deploy the compiled Wasm file to the NEAR Protocol.

Example deployment command:

```sh
near deploy --wasmFile target/wasm32-unknown-unknown/release/campaignlayernep245.wasm --accountId YOUR_ACCOUNT_ID
```

'''
'''--- build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "`dirname $0`"

cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/defi.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/multi_token.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/approval_receiver.wasm ./res/

'''
'''--- mt/Cargo.toml ---
[package]
name = "Campaign Layer's NEP245"
version = "0.1.0"
authors = ["Campaign Layers", "support@campaignlayers.com"]
edition = "2023"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { path = "../../../near-sdk" }
near-contract-standards = { path = "../../../near-contract-standards" }

'''
'''--- mt/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::Promise;
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, BorshStorageKey, PanicOnDefault, PromiseOrValue,
};
use near_contract_standards::multi_token::metadata::MT_METADATA_SPEC;
use near_contract_standards::multi_token::token::{Token, TokenId};
use near_contract_standards::multi_token::{
    core::MultiToken,
    metadata::{MtContractMetadata, TokenMetadata},
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ExampleMTContract {
    tokens: MultiToken,
    metadata: LazyOption<MtContractMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    MultiToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl CampaignLayerNEP245 {
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        let metadata = MtContractMetadata {
            spec: MT_METADATA_SPEC.to_string(),
            name: "Test".to_string(),
            symbol: "OMG".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        };

        Self::new(owner_id, metadata)
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: MtContractMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();

        Self {
            tokens: MultiToken::new(
                StorageKey::MultiToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    #[payable]
    pub fn mt_mint(
        &mut self,
        token_owner_id: AccountId,
        token_metadata: TokenMetadata,
        supply: Balance,
    ) -> Token {
        // Only the owner of the MT contract can perform this operation
        assert_eq!(
            env::predecessor_account_id(),
            self.tokens.owner_id,
            "Unauthorized: {} != {}",
            env::predecessor_account_id(),
            self.tokens.owner_id
        );
        self.tokens.internal_mint(token_owner_id, Some(supply), Some(token_metadata), None)
    }

    pub fn mt_burn(&mut self, token_id: TokenId, amount: U128) {
        // Ensure the caller owns the tokens and has sufficient balance
        let caller = env::predecessor_account_id();
        let balance = self.tokens.internal_unwrap_balance(&caller, &token_id);
        require!(
            balance >= amount.0,
            "Not enough balance to burn"
        );

        // Burn the tokens
        self.tokens.internal_burn(&caller, &token_id, amount.0);

        // Update token supply and balances
        self.metadata.get_mut().total_supply -= amount.0;
    }

    pub fn register(&mut self, token_id: TokenId, account_id: AccountId) {
        self.tokens.internal_register_account(&token_id, &account_id)
    }
}

near_contract_standards::impl_multi_token_core!(ExampleMTContract, tokens);
near_contract_standards::impl_multi_token_approval!(ExampleMTContract, tokens);
near_contract_standards::impl_multi_token_enumeration!(ExampleMTContract, tokens);

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    fn create_token_md(title: String, description: String) -> TokenMetadata {
        TokenMetadata {
            title: Some(title),
            description: Some(description),
            media: None,
            media_hash: None,
            issued_at: Some(String::from("123456")),
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_transfer() {
        let mut context = VMContextBuilder::new();
        set_caller(&mut context, 0);
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        let (token, _) = init_tokens(&mut contract);
        contract.register(token.token_id.clone(), accounts(1));

        // Initial balances are what we expect.
        assert_eq!(
            contract.mt_balance_of(accounts(0), token.token_id.clone()),
            U128(1000),
            "Wrong balance"
        );
        assert_eq!(
            contract.mt_balance_of(accounts(1), token.token_id.clone()),
            U128(0),
            "Wrong balance"
        );

        // Transfer some tokens
        testing_env!(context.attached_deposit(1).build());
        contract.mt_transfer(accounts(1), token.token_id.clone(), 4.into(), None, None);

        // Transfer should have succeeded.
        assert_eq!(
            contract.mt_balance_of(accounts(0), token.token_id.clone()).0,
            996,
            "Wrong balance"
        );
        assert_eq!(
            contract.mt_balance_of(accounts(1), token.token_id.clone()).0,
            4,
            "Wrong balance"
        );

        // Transfer some of the tokens back to original owner.
        set_caller(&mut context, 1);
        contract.mt_transfer(accounts(0), token.token_id.clone(), 3.into(), None, None);

        assert_eq!(
            contract.mt_balance_of(accounts(0), token.token_id.clone()).0,
            999,
            "Wrong balance"
        );
        assert_eq!(
            contract.mt_balance_of(accounts(1), token.token_id.clone()).0,
            1,
            "Wrong balance"
        );
    }

    #[test]
    #[should_panic(expected = "Transferred amounts must be greater than 0")]
    fn test_transfer_amount_must_be_positive() {
        let mut context = VMContextBuilder::new();
        set_caller(&mut context, 0);
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        let (token, _) = init_tokens(&mut contract);
        contract.register(token.token_id.clone(), accounts(1));
        testing_env!(context.attached_deposit(1).build());

        contract.mt_transfer(accounts(1), token.token_id.clone(), U128(0), None, None)
    }

    #[test]
    #[should_panic(expected = "The account doesn't have enough balance")]
    fn test_sender_account_must_have_sufficient_balance() {
        let mut context = VMContextBuilder::new();
        set_caller(&mut context, 0);
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        let (token, _) = init_tokens(&mut contract);
        contract.register(token.token_id.clone(), accounts(1));
        testing_env!(context.attached_deposit(1).build());

        // account(0) has only 2000 of token.
        contract.mt_transfer(accounts(1), token.token_id.clone(), U128(3000), None, None)
    }

    #[test]
    #[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
    fn test_transfers_require_one_yocto() {
        let mut context = VMContextBuilder::new();
        set_caller(&mut context, 0);
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        let (token, _) = init_tokens(&mut contract);
        contract.register(token.token_id.clone(), accounts(1));
        contract.mt_transfer(accounts(1), token.token_id.clone(), U128(1000), None, None)
    }

    #[test]
    #[should_panic(expected = "The account charlie is not registered")]
    fn test_receiver_must_be_registered() {
        let mut context = VMContextBuilder::new();
        set_caller(&mut context, 0);
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        let (token, _) = init_tokens(&mut contract);
        contract.register(token.token_id.clone(), accounts(1));
        testing_env!(context.attached_deposit(1).build());

        contract.mt_transfer(accounts(2), token.token_id.clone(), U128(100), None, None)
    }

    #[test]
    #[should_panic(expected = "Sender and receiver must differ")]
    fn test_cannot_transfer_to_self() {
        let mut context = VMContextBuilder::new();
        set_caller(&mut context, 0);
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        let (token, _) = init_tokens(&mut contract);
        contract.register(token.token_id.clone(), accounts(1));
        testing_env!(context.attached_deposit(1).build());

        contract.mt_transfer(accounts(0), token.token_id.clone(), U128(100), None, None)
    }

    #[test]
    fn test_batch_transfer() {
        let mut context = VMContextBuilder::new();
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        set_caller(&mut context, 0);

        let (quote_token, base_token) = init_tokens(&mut contract);

        contract.register(quote_token.token_id.clone(), accounts(1));
        contract.register(base_token.token_id.clone(), accounts(1));

        testing_env!(context.attached_deposit(1).build());

        // Perform the transfers
        contract.mt_batch_transfer(
            accounts(1),
            vec![quote_token.token_id.clone(), base_token.token_id.clone()],
            vec![U128(4), U128(600)],
            None,
            None,
        );

        assert_eq!(
            contract.mt_balance_of(accounts(0), quote_token.token_id.clone()).0,
            996,
            "Wrong balance"
        );
        assert_eq!(
            contract.mt_balance_of(accounts(1), quote_token.token_id.clone()).0,
            4,
            "Wrong balance"
        );

        assert_eq!(
            contract.mt_balance_of(accounts(0), base_token.token_id.clone()).0,
            1400,
            "Wrong balance"
        );
        assert_eq!(
            contract.mt_balance_of(accounts(1), base_token.token_id.clone()).0,
            600,
            "Wrong balance"
        );
    }

    #[test]
    #[should_panic(expected = "The account doesn't have enough balance")]
    fn test_batch_transfer_all_balances_must_be_sufficient() {
        let mut context = VMContextBuilder::new();
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        set_caller(&mut context, 0);

        let (quote_token, base_token) = init_tokens(&mut contract);

        contract.register(quote_token.token_id.clone(), accounts(1));
        contract.register(base_token.token_id.clone(), accounts(1));
        testing_env!(context.attached_deposit(1).build());

        contract.mt_batch_transfer(
            accounts(1),
            vec![quote_token.token_id.clone(), base_token.token_id.clone()],
            vec![U128(4), U128(6000)],
            None,
            None,
        );
    }

    #[test]
    fn test_simple_approvals() {
        let mut context = VMContextBuilder::new();
        let mut contract = ExampleMTContract::new_default_meta(accounts(0));
        set_caller(&mut context, 0);

        let (quote_token, base_token) = init_tokens(&mut contract);

        contract.register(quote_token.token_id.clone(), accounts(1));
        contract.register(base_token.token_id.clone(), accounts(1));

        // Initially, Account 1 is not approved.
        testing_env!(context.attached_deposit(1).build());
        assert!(!contract.mt_is_approved(
            vec![quote_token.token_id.clone()],
            accounts(1),
            vec![20],
            None,
        ));

        // Create approval for account 1 to transfer 20 of quote token from account 0.
        testing_env!(context.attached_deposit(150000000000000000000).build());
        contract.mt_approve(
            vec![quote_token.token_id.clone()],
            vec![20],
            accounts(1),
            None,
        );

        // Account 1 is approved for 20 tokens.
        testing_env!(context.attached_deposit(1).build());
        assert!(contract.mt_is_approved(
            vec![quote_token.token_id.clone()],
            accounts(1),
            vec![20],
            None,
        ));

        // Account 1 is NOT approved for more than 20 tokens.
        testing_env!(context.attached_deposit(1).build());
        assert!(!contract.mt_is_approved(
            vec![quote_token.token_id.clone()],
            accounts(1),
            vec![21],
            None,
        ));

        // Account 1 is NOT approved for the other token.
        testing_env!(context.attached_deposit(1).build());
        assert!(!contract.mt_is_approved(
            vec![base_token.token_id.clone()],
            accounts(1),
            vec![20],
            None,
        ));

        // Revoke the approval
        contract.mt_revoke(
            vec![quote_token.token_id.clone()],
            accounts(1),
        );
        assert!(!contract.mt_is_approved(
            vec![quote_token.token_id.clone()],
            accounts(1),
            vec![20],
            None,
        ));

        // Create 2 approvals for 2 tokens in one call.
        testing_env!(context.attached_deposit(2 * 150000000000000000000).build());
        contract.mt_approve(
            vec![quote_token.token_id.clone(), base_token.token_id.clone()],
            vec![10, 500],
            accounts(1),
            None,
        );
        assert!(contract.mt_is_approved(
            vec![quote_token.token_id.clone(), base_token.token_id.clone()],
            accounts(1),
            vec![10, 500],
            None,
        ));

        // Approve a different account
        contract.mt_approve(
            vec![quote_token.token_id.clone()],
            vec![30],
            accounts(2),
            None,
        );

        // Revoke all approvals for the quote token
        testing_env!(context.attached_deposit(1).build());
        contract.mt_revoke_all(
            vec![quote_token.token_id.clone()],
        );

        // Neither account is still approved
        assert!(!contract.mt_is_approved(
            vec![quote_token.token_id.clone(), base_token.token_id.clone()],
            accounts(1),
            vec![10, 500],
            None,
        ));
        assert!(!contract.mt_is_approved(
            vec![quote_token.token_id.clone()],
            accounts(2),
            vec![30],
            None,
        ));

    }

    fn init_tokens(contract: &mut ExampleMTContract) -> (Token, Token) {
        let quote_token_md = create_token_md("PYC".into(), "Python token".into());
        let base_token_md = create_token_md("ABC".into(), "Alphabet token".into());

        let quote_token = contract.mt_mint(accounts(0), quote_token_md.clone(), 1000);
        let base_token = contract.mt_mint(accounts(0), base_token_md.clone(), 2000);

        (quote_token, base_token)
    }

    fn set_caller(context: &mut VMContextBuilder, account_id: usize) {
        testing_env!(context
            .signer_account_id(accounts(account_id))
            .predecessor_account_id(accounts(account_id))
            .build())
    }
}

'''
'''--- test-approval-receiver/Cargo.toml ---
[package]
name = "approval-receiver"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { path = "../../../near-sdk" }
near-contract-standards = { path = "../../../near-contract-standards" }

'''
'''--- test-approval-receiver/src/lib.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env, near_bindgen, AccountId, PanicOnDefault, PromiseOrValue,
};
use near_contract_standards::multi_token::{approval::MultiTokenApprovalReceiver, token::TokenId};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default data and the owner ID
        that's passed in
    */
    #[init]
    pub fn new() -> Self {
        Self {}
    }
}

#[near_bindgen]
impl MultiTokenApprovalReceiver for Contract {
    fn mt_on_approve(
        &mut self,
        tokens: Vec<TokenId>,
        owner_id: AccountId,
        approval_ids: Vec<u64>,
        msg: String,
    ) -> PromiseOrValue<String> {
        env::log_str(
            format!("Tokens: {:?} Owner: {}, approval_ids: {:?}", tokens, owner_id, approval_ids)
                .as_str(),
        );
        env::log_str(&msg);

        PromiseOrValue::Value("yeeeeeeeeeeeeeeee".to_string())
    }
}

'''
'''--- test-contract-defi/Cargo.toml ---
[package]
name = "defi"
version = "0.0.1"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { path = "../../../near-sdk" }
near-contract-standards = { path = "../../../near-contract-standards" }

'''
'''--- test-contract-defi/src/lib.rs ---
/*!
Some hypothetical DeFi contract that will do smart things with the transferred tokens
*/
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{
    env, ext_contract, log, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault,
    PromiseOrValue,
};
use near_contract_standards::multi_token::core::MultiTokenReceiver;
use near_contract_standards::multi_token::token::TokenId;

const BASE_GAS: u64 = 5_000_000_000_000;
const PROMISE_CALL: u64 = 5_000_000_000_000;
const GAS_FOR_MT_ON_TRANSFER: Gas = Gas(BASE_GAS + PROMISE_CALL);

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct DeFi {
    multi_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn value_please(
        &self,
        num_tokens: usize,
        amount_to_return: String,
    ) -> PromiseOrValue<Vec<U128>>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn value_please(
        &self,
        num_tokens: usize,
        amount_to_return: String,
    ) -> PromiseOrValue<Vec<U128>>;
}

#[near_bindgen]
impl DeFi {
    #[init]
    pub fn new(multi_token_account_id: AccountId) -> Self {
        require!(!env::state_exists(), "Already initialized");
        Self { multi_token_account_id }
    }
}

#[near_bindgen]
impl MultiTokenReceiver for DeFi {
    /// If given `msg: "take-my-money", immediately returns U128::From(0)
    /// Otherwise, makes a cross-contract call to own `value_please` function, passing `msg`
    /// value_please will attempt to parse `msg` as an integer and return a vec of
    /// token_ids.len() many copies of the U128 version of it.
    fn mt_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_ids: Vec<AccountId>,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        msg: String,
    ) -> PromiseOrValue<Vec<U128>> {
        // Verifying that we were called by multi-token contract that we expect.
        require!(
            env::predecessor_account_id() == self.multi_token_account_id,
            "Only supports the one multi-token contract"
        );

        log!(
            "received {} types of tokens from @{} mt_on_transfer, msg = {}, previous_owner_ids = {:?}",
            token_ids.len(),
            sender_id.as_ref(),
            msg,
            previous_owner_ids
        );

        for i in 0..token_ids.len() {
            log!("-> {} of token {}", token_ids[i], amounts[i].0)
        }

        match msg.as_str() {
            "take-my-money" => PromiseOrValue::Value(vec![U128::from(0); token_ids.len()]),
            _ => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::value_please(
                    token_ids.len(),
                    msg,
                    account_id,
                    NO_DEPOSIT,
                    prepaid_gas - GAS_FOR_MT_ON_TRANSFER,
                )
                .into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for DeFi {
    fn value_please(
        &self,
        num_tokens: usize,
        amount_to_return: String,
    ) -> PromiseOrValue<Vec<U128>> {
        log!("in value_please, amount_to_return = {}", amount_to_return);
        let amount: Balance = amount_to_return.parse().expect("Not an integer");
        PromiseOrValue::Value(vec![amount.into(); num_tokens])
    }
}

'''
'''--- tests/workspaces/main.rs ---
mod test_approval;
mod test_core;
mod test_enumeration;
mod utils;

'''
'''--- tests/workspaces/test_approval.rs ---
use crate::utils::{helper_mint, init, init_approval_receiver_contract};
use near_contract_standards::multi_token::token::Token;

#[tokio::test]
async fn simulate_mt_approval_with_receiver() -> anyhow::Result<()> {
  let worker = workspaces::sandbox();
  let (mt, alice, _) = init(&worker).await?;
  let approval_receiver = init_approval_receiver_contract(&worker).await?;

  let token: Token = helper_mint(&mt, &worker, alice.id().clone(), 1000u128, "title1".to_string(), "desc1".to_string()).await?;

  // Grant approval_receiver contract an approval to take 50 of alice's tokens.
  let res = alice.call(&worker, mt.id().clone(), "mt_approve")
    .args_json((
      [token.token_id.clone()],
      [50u64],
      approval_receiver.id(),
      Option::<String>::Some("some-msg".to_string()),
    ))?
    .gas(300_000_000_000_000)
    .deposit(450000000000000000000)
    .transact()
    .await?;
  assert_eq!(res.json::<String>()?, "yeeeeeeeeeeeeeeee".to_string());

  Ok(())
}
'''
'''--- tests/workspaces/test_core.rs ---
use crate::utils::{init, helper_mint, register_user_for_token};
use near_primitives::views::FinalExecutionStatus;
use near_sdk::json_types::U128;
use near_sdk::{ONE_YOCTO};
use workspaces::AccountId;
use near_contract_standards::multi_token::token::Token;

#[tokio::test]
async fn simulate_mt_transfer_and_call() -> anyhow::Result<()> {
    
    // Setup MT contract, user, and DeFi contract.
    let worker = workspaces::sandbox();
    let (mt, alice, defi) = init(&worker).await?;

    // Mint 2 tokens.
    let token_1: Token = helper_mint(
        &mt,
        &worker,
        alice.id().clone(),
        1000u128,
        "title1".to_string(),
        "desc1".to_string(),
    ).await?;
    let token_2: Token = helper_mint(
        &mt,
        &worker,
        alice.id().clone(),
        20_000u128,
        "title2".to_string(),
        "desc2".to_string(),
    ).await?;

    // Register defi account; alice (the token owner) was already registered during the mint.
    register_user_for_token(&worker, &mt, defi.id(), token_1.token_id.clone()).await?;
    register_user_for_token(&worker, &mt, defi.id(), token_2.token_id.clone()).await?;

    // Transfer some tokens using transfer_and_call to hit DeFi contract with XCC.
    let res = alice
        .call(&worker, mt.id().clone(), "mt_transfer_call")
        .args_json((
            defi.id(),
            token_1.token_id.clone(),
            "100",
            Option::<(AccountId, u64)>::None,
            Option::<String>::None,
            "30", // Number of tokens that the DeFi contract should refund.
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    let amounts_kept: Vec<U128> = res.json()?;
    assert_eq!(amounts_kept, vec![U128(70)]);

    let alice_balance: Vec<U128> = mt.call(&worker, "mt_batch_balance_of")
        .args_json((alice.id(), vec![token_1.token_id.clone()], ))?
        .view()
        .await?
        .json()?;
    assert_eq!(alice_balance, vec![U128(930)]);

    let defi_balance: Vec<U128> = mt.call(&worker, "mt_batch_balance_of")
        .args_json((defi.id(), vec![token_1.token_id.clone()], ))?
        .view()
        .await?
        .json()?;
    assert_eq!(defi_balance, vec![U128(70)]);

    // Next, do a batch transfer call, and use special msg 'take-my-money' so DeFi contract refunds nothing.
    let res = alice
        .call(&worker, mt.id().clone(), "mt_batch_transfer_call")
        .args_json((
            defi.id(),
            [token_1.token_id.clone(), token_2.token_id.clone()],
            ["100", "5000"],
            Option::<(AccountId, u64)>::None,
            Option::<String>::None,
            "take-my-money", // DeFi contract will keep all sent tokens.
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // Attempt a transfer where DeFi contract will panic. Token transfer should be reverted in the callback.
    let res = alice
        .call(&worker, mt.id().clone(), "mt_batch_transfer_call")
        .args_json((
            defi.id(),
            [token_1.token_id.clone(), token_2.token_id.clone()],
            ["100", "5000"],
            Option::<(AccountId, u64)>::None,
            Option::<String>::None,
            "not-a-parsable-number",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    let amounts_kept_by_receiver: Vec<U128> = res.json()?;
    assert_eq!(amounts_kept_by_receiver, vec![U128(0), U128(0)]);

    // Balance hasn't changed.
    let alice_balance: Vec<U128> = mt.call(&worker, "mt_batch_balance_of")
        .args_json((alice.id(), vec![token_1.token_id.clone(), token_2.token_id.clone()], ))?
        .view()
        .await?
        .json()?;
    assert_eq!(alice_balance, vec![U128(830), U128(15_000)]);

    Ok(())
}

'''
'''--- tests/workspaces/test_enumeration.rs ---
use crate::utils::{helper_mint, init};
use near_contract_standards::multi_token::token::Token;
use near_sdk::json_types::U128;

#[tokio::test]
async fn simulate_enum_all_tokens() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (mt, alice, _) = init(&worker).await?;

    // Mint 3 tokens
    let token_1: Token = helper_mint(&mt, &worker, alice.id().clone(), 1000u128, "title1".to_string(), "desc1".to_string()).await?;
    let token_2: Token = helper_mint(&mt, &worker, alice.id().clone(), 20_000u128, "title2".to_string(), "desc2".to_string()).await?;
    let token_3: Token = helper_mint(&mt, &worker, alice.id().clone(), 5u128, "title3".to_string(), "desc3".to_string()).await?;

    // Get all tokens
    let res: Vec<Token> = mt.call(&worker, "mt_tokens")
        .view()
        .await?
        .json()?;
    assert_eq!(res, vec![token_1.clone(), token_2.clone(), token_3.clone()]);

    // Get limit=None token at from_index=1
    let res: Vec<Token> = mt.call(&worker, "mt_tokens")
        .args_json((Some(U128(1)), Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(res, vec![token_2.clone(), token_3.clone()]);

    // Get limit=2 tokens at from_index=None
    let res: Vec<Token> = mt.call(&worker, "mt_tokens")
        .args_json((Option::<U128>::None, Some(2u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(res, vec![token_1.clone(), token_2.clone()]);

    // Get limit=1 tokens at from_index=2
    let res: Vec<Token> = mt.call(&worker, "mt_tokens")
        .args_json((Some(U128(2)), Some(1u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(res, vec![token_3.clone()]);

    Ok(())
}

#[tokio::test]
async fn simulate_enum_tokens_for_owner() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (mt, alice, defi) = init(&worker).await?;

    // Mint 5 tokens, alternating ownership between alice and the defi contract account.
    let token_1: Token = helper_mint(&mt, &worker, alice.id().clone(), 1000u128, "title1".to_string(), "desc1".to_string()).await?;
    helper_mint(&mt, &worker, defi.id().clone(), 20_000u128, "title2".to_string(), "desc2".to_string()).await?;
    let token_3: Token = helper_mint(&mt, &worker, alice.id().clone(), 5u128, "title3".to_string(), "desc3".to_string()).await?;
    let token_4: Token = helper_mint(&mt, &worker, defi.id().clone(), 20_000u128, "title4".to_string(), "desc4".to_string()).await?;
    let token_5: Token = helper_mint(&mt, &worker, alice.id().clone(), 5u128, "title5".to_string(), "desc5".to_string()).await?;

    // Get all tokens for a specific owner, alice.
    let res: Vec<Token> = mt.call(&worker, "mt_tokens_for_owner")
        .args_json((alice.id().clone(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(res, vec![token_1.clone(), token_3.clone(), token_5.clone()]);

    // Get limit=None tokens at from_index=1 for defi account.
    let res: Vec<Token> = mt.call(&worker, "mt_tokens_for_owner")
        .args_json((defi.id().clone(), Some(U128(1)), Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(res, vec![token_4.clone()]);

    Ok(())
}

'''
'''--- tests/workspaces/utils.rs ---
use near_primitives::views::FinalExecutionStatus;
use near_units::parse_near;
use workspaces::prelude::*;
use workspaces::{Account, AccountId, Contract, DevNetwork, Network, Worker};
use near_contract_standards::multi_token::{
    metadata::{TokenMetadata},
};
use near_contract_standards::multi_token::token::{Token, TokenId};
use near_sdk::{Balance};

pub async fn register_user_for_token(
    worker: &Worker<impl Network>,
    contract: &Contract,
    account_id: &AccountId,
    token_id: TokenId,
) -> anyhow::Result<()> {
    let res = contract
        .call(worker, "register")
        .args_json((token_id.clone(), account_id))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    Ok(())
}

pub async fn helper_mint(
    mt_contract: &Contract,
    worker: &Worker<impl DevNetwork>,
    owner_id: AccountId,
    amount: Balance,
    title: String,
    desc: String,
) -> anyhow::Result<Token> {
    let token_md: TokenMetadata = TokenMetadata {
        title: Some(title),
        description: Some(desc),
        media: None,
        media_hash: None,
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };

    let res = mt_contract
        .call(worker, "mt_mint")
        .args_json((owner_id, token_md, amount))?
        .gas(300_000_000_000_000)
        .deposit(parse_near!("7 mN"))
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    let token: Token = res.json()?;

    Ok(token)
}

// Returns Multi-token contract, a non-owner user Alice, and a DeFi contract
// for receiving cross-contract calls.
pub async fn init(
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<(Contract, Account, Contract)> {
    let mt_contract = worker.dev_deploy(include_bytes!("../../res/multi_token.wasm").to_vec()).await?;

    let res = mt_contract
        .call(worker, "new_default_meta")
        .args_json((mt_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let defi_contract = worker.dev_deploy(include_bytes!("../../res/defi.wasm").to_vec()).await?;

    let res = defi_contract
        .call(worker, "new")
        .args_json((mt_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let alice = mt_contract
        .as_account()
        .create_subaccount(worker, "alice")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .into_result()?;

    Ok((mt_contract, alice, defi_contract))
}

pub async fn init_approval_receiver_contract(worker: &Worker<impl DevNetwork>) -> anyhow::Result<Contract> {
    let approval_receiver_contract = worker.dev_deploy(include_bytes!("../../res/approval_receiver.wasm").to_vec()).await?;
    let res = approval_receiver_contract
        .call(worker, "new")
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    Ok(approval_receiver_contract)
}
'''