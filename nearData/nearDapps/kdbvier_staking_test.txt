*GitHub Repository "kdbvier/staking_test"*

'''--- Cargo.toml ---
[package]
name = "rust-template"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.3"
near-sdk-sim = "4.0.0-pre.3"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- README.md ---
# Rust Smart Contract Template

## Getting started

To get started with this template:

1. Click the "Use this template" button to create a new repo based on this template
2. Update line 2 of `Cargo.toml` with your project name
3. Update line 4 of `Cargo.toml` with your project author names
4. Set up the [prerequisites](https://github.com/near/near-sdk-rs#pre-requisites)
5. Begin writing your smart contract in `src/lib.rs`
6. Test the contract 

    `cargo test -- --nocapture`

8. Build the contract

    `RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release`

**Get more info at:**

* [Rust Smart Contract Quick Start](https://docs.near.org/develop/prerequisites)
* [Rust SDK Book](https://www.near-sdk.io/)

'''
'''--- build.bat ---
cargo build --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\*.wasm res
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, LookupSet, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, AccountId, Balance, CryptoHash,
    PanicOnDefault, Promise, PromiseOrValue, PromiseResult,
};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    pub address: AccountId,
    pub token_id: String,
    pub claimed_amount: U128,
    pub unclaimed_amount: U128,
    pub claimed_timestamp: u64,
    pub create_unstake_timestamp: u64,
    pub last_timestamp: u64,
}
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    //contract owner
    pub owner_id: AccountId,

    //keeps track of all the token IDs for a given account
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<String>>,

    //keeps track of the token struct for a given token ID
    pub tokens_by_id: LookupMap<String, Token>,

    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub nft_address: AccountId,
    pub ft_address: AccountId,
    pub daily_reward: U128,
    pub interval: u64,
    pub lock_time: u64,
    pub enabled: bool,
}

#[derive(BorshSerialize)]
pub enum StorageKey {
    TokensPerOwner,
    TokensById,
    ConfigData,
    StorageDeposits,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        owner_id: AccountId,
        nft_address: AccountId,
        ft_address: AccountId,
        daily_reward: U128,
        interval: u64,
        lock_time: u64,
    ) -> Self {
        let this = Self {
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokensById),
            owner_id,
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
            nft_address,
            ft_address,
            daily_reward,
            interval,
            lock_time,
            enabled: false,
        };

        this
    }
    #[payable]
    pub fn update_owner(&mut self, owner_id: AccountId) {
        assert_one_yocto();
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Marble: Owner only"
        );
        self.owner_id = owner_id;
    }

    #[payable]
    pub fn update_enable(&mut self, enabled: bool) {
        assert_one_yocto();
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Marble: Owner only"
        );
        self.enabled = enabled;
    }

    #[payable]
    fn _internal_receive_nft(
        &mut self,
        _nft_contract_id: AccountId,
        _previous_owner_id: AccountId,
        _token_id: String,
    ) {
    }

    pub fn get_owner(&self) -> AccountId {
        self.owner_id.clone()
    }

    pub fn get_enable_status(&self) -> bool {
        self.enabled.clone()
    }
    pub fn get_supply_by_owner_id(&self, account_id: AccountId) -> U64 {
        self.tokens_per_owner
            .get(&account_id)
            .map_or(0, |by_owner_id| by_owner_id.len())
            .into()
    }
    // // Storage
    // #[payable]
    // pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
    //     let storage_account_id = account_id
    //         .map(|a| a.into())
    //         .unwrap_or_else(env::predecessor_account_id);
    //     let deposit = env::attached_deposit();
    //     assert!(
    //         deposit >= STORAGE_ADD_STAKING_DATA,
    //         "Requires minimum deposit of {}",
    //         STORAGE_ADD_STAKING_DATA
    //     );

    //     let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
    //     balance += deposit;
    //     self.storage_deposits.insert(&storage_account_id, &balance);
    // }

    // #[payable]
    // pub fn storage_withdraw(&mut self) {
    //     assert_one_yocto();
    //     let owner_id = env::predecessor_account_id();
    //     let mut amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);
    //     let market_data_owner = self.tokens_per_owner.get(&owner_id);
    //     let len = market_data_owner.map(|s| s.len()).unwrap_or_default();
    //     let diff = u128::from(len) * STORAGE_ADD_STAKING_DATA;
    //     amount -= diff;
    //     if amount > 0 {
    //         Promise::new(owner_id.clone()).transfer(amount);
    //     }
    //     if diff > 0 {
    //         self.storage_deposits.insert(&owner_id, &diff);
    //     }
    // }

    // pub fn storage_minimum_balance(&self) -> U128 {
    //     U128(STORAGE_ADD_STAKING_DATA)
    // }

    // pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
    //     self.storage_deposits.get(&account_id).unwrap_or(0).into()
    // }
}

/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-template -- --nocapture
 * Note: 'rust-template' comes from Cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, AccountId};

    // part of writing unit tests is setting up a mock context
    // provide a `predecessor` here, it'll modify the default context
    fn get_context(predecessor: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }
    fn setup_contract() -> (VMContextBuilder, Contract) {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let contract = Contract::new(
            accounts(0),
            accounts(1),
            accounts(2),
            U128::from(100),
            1000000,
            1000000000,
        );
        (context, contract)
    }

    #[test]
    fn test_new() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        assert_eq!(contract.get_owner(), accounts(0));
        contract.update_owner(accounts(1));
        assert_eq!(contract.get_owner(), accounts(1));
    }
    #[test]
    fn test_enable() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());
        assert_eq!(contract.get_enable_status(), false);
        contract.update_enable(true);
        assert_eq!(contract.get_enable_status(), true);
    }
}

'''
'''--- test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''
'''--- tests/simulation_tests.rs ---
use near_contract_standards::non_fungible_token::Token;
use near_sdk::{
    json_types::{U128, U64},
    serde::{Deserialize, Serialize},
    serde_json::json,
    AccountId, Gas,
};
use near_sdk_sim::{call, deploy, init_simulator, to_yocto, view, ContractAccount, UserAccount};

use crate::utils::{
    account_o, create_nft_and_mint_one, init, DEFAULT_GAS, GAS_BUY, STORAGE_ADD_MARKET_DATA,
    STORAGE_APPROVE,
};

mod utils;

#[test]
fn test_init() {
    let (staking, nft, _, _, _, _, _, _) = init();
    let owner = staking
        .view(
            staking.account_id(),
            "get_owner",
            &json!({}).to_string().into_bytes(),
        )
        .unwrap_json();
    println!("ownerrrrrrrr: {:?} \n\n", owner);
}

'''
'''--- tests/utils.rs ---
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::{serde_json::json, AccountId};
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, view, ContractAccount, UserAccount, STORAGE_AMOUNT,
};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    NFT_WASM_BYTES => "../res/paras_nft_contract.wasm",
    STAKING_WASM_BYTES => "../res/main.wasm",
    FT_WASM_BYTES => "../res/test_token.wasm"
}

pub const DEFAULT_GAS: u64 = near_sdk_sim::DEFAULT_GAS;
pub const NFT_ID_STR: &str = "nft";
pub const FT_ID_STR: &str = "ft";
pub const STAKING_ID_STR: &str = "staking";
pub const STORAGE_MINT_ESTIMATE: u128 = 11280000000000000000000;
pub const STORAGE_CREATE_SERIES_ESTIMATE: u128 = 8540000000000000000000;

// After calculation
pub const STORAGE_ADD_MARKET_DATA: u128 = 10590000000000000000000;
pub const STORAGE_APPROVE: u128 = 8590000000000000000000;
pub const GAS_BUY: u64 = 100 * 10u64.pow(12);

pub fn create_nft_and_mint_one(
    nft: &UserAccount,
    owner: &UserAccount,
    creator: &UserAccount,
    receiver_id_1: &UserAccount,
    receiver_id_2: &UserAccount,
) {
    owner
        .call(
            nft.account_id(),
            "nft_create_series",
            &json!({
                "token_metadata": {
                    "title": "A".repeat(200),
                    "reference": "A".repeat(59),
                    "media": "A".repeat(59),
                    "copies": 100u64,
                },
                "creator_id": creator.account_id(),
                "price": to_yocto("1").to_string(),
                "royalty": {
                    owner.account_id.clone(): 1000u32,
                    "g".repeat(64): 1000u32,
                    "h".repeat(64): 1000u32,
                    "i".repeat(64): 1000u32,
                    "j".repeat(64): 1000u32,
                    "k".repeat(64): 1000u32,
                    "l".repeat(64): 1000u32,
                    "m".repeat(64): 500u32,
                },
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS,
            STORAGE_CREATE_SERIES_ESTIMATE * 2, //royalty
        )
        .assert_success();

    receiver_id_1
        .call(
            nft.account_id(),
            "nft_buy",
            &json!({
                "token_series_id": "1",
                "receiver_id": receiver_id_1.account_id(),
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS,
            to_yocto("1") + STORAGE_MINT_ESTIMATE,
        )
        .assert_success();

    receiver_id_2
        .call(
            nft.account_id(),
            "nft_buy",
            &json!({
                "token_series_id": "1",
                "receiver_id": receiver_id_2.account_id(),
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS,
            to_yocto("1") + STORAGE_MINT_ESTIMATE,
        )
        .assert_success();

    receiver_id_2
        .call(
            nft.account_id(),
            "nft_buy",
            &json!({
                "token_series_id": "1",
                "receiver_id": receiver_id_2.account_id(),
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS,
            to_yocto("1") + STORAGE_MINT_ESTIMATE,
        )
        .assert_success();
}

pub fn init() -> (
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
) {
    let root = init_simulator(None);

    let alice = root.create_user(account_from(&"x"), to_yocto("100"));

    let bob = root.create_user(account_from(&"y"), to_yocto("100"));

    let chandra = root.create_user(account_from(&"z"), to_yocto("100"));

    let darmaji = root.create_user(account_from(&"n"), to_yocto("100"));

    let nft_account_id = AccountId::new_unchecked(NFT_ID_STR.to_string());
    let nft_contract = root.deploy(&NFT_WASM_BYTES, nft_account_id.clone(), STORAGE_AMOUNT);
    let staking_account_id = AccountId::new_unchecked(STAKING_ID_STR.to_string());
    let staking_contract = root.deploy(
        &STAKING_WASM_BYTES,
        staking_account_id.clone(),
        STORAGE_AMOUNT,
    );
    let ft_account_id = AccountId::new_unchecked(FT_ID_STR.to_string());
    let ft_contract = root.deploy(&FT_WASM_BYTES, ft_account_id.clone(), STORAGE_AMOUNT);
    nft_contract.call(
        nft_account_id,
        "new_default_meta",
        &json!({
            "owner_id": alice.account_id(),
            "treasury_id": alice.account_id(),
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS,
        0,
    );
    staking_contract.call(
        staking_account_id,
        "new",
        &json!({
            "owner_id": alice.account_id(),
            "nft_address": nft_account_id,
            "ft_address":ft_account_id,
            "daily_reward": 1000,
            "interval": 1000000,
            "lock_time": 1000000000
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS,
        0,
    );
    ft_contract.call(
        ft_account_id.clone(),
        "new",
        &json!({}).to_string().into_bytes(),
        DEFAULT_GAS,
        0,
    );
    (
        staking_contract,
        nft_contract,
        ft_contract,
        alice,
        bob,
        chandra,
        darmaji,
        root,
    )
}

pub fn account_o() -> AccountId {
    account_from("o")
}

pub fn account_from(s: &str) -> AccountId {
    AccountId::new_unchecked(s.repeat(64).to_string())
}

'''