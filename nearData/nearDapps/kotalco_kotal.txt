*GitHub Repository "kotalco/kotal"*

'''--- .github/workflows/docker.yml ---
name: Build-Push kotal

on:
  push:
    branches: [ master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ master ]

jobs:

  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Generate Docker metadata
      id: meta
      uses: docker/metadata-action@v3
      with:
        images: |
          docker.io/kotalco/kotal
        tags: |
          type=ref,event=tag
          type=sha,prefix=,suffix=,format=short
        flavor: |
          latest=true

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1

    - name: Login to DockerHub
      uses: docker/login-action@v2
      with:
        username: kotalco
        password: ${{ secrets.DOCKERHUB_PASSWORD }}

    - name: Build and push
      uses: docker/build-push-action@v3
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
'''
'''--- .github/workflows/go.yml ---
name: Go build and test

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

env:
  K8S_VERSION: 1.23.3

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Clone repo
        uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: 1.21

      - name: Build
        run: go build -v ./...

      - name: Download envtest binaries
        run: |
          curl -sSLo envtest-bins.tar.gz "https://go.kubebuilder.io/test-tools/${K8S_VERSION}/$(go env GOOS)/$(go env GOARCH)"
          sudo tar -vxzf envtest-bins.tar.gz -C /usr/local/

      - name: Test
        run: go test -v ./...

'''
'''--- README.md ---
# Kotal Operator

Kotal operator is a **cloud agnostic blockchain deployer** that makes it super easy to deploy highly-available, self-managing, self-healing blockchain infrastructure (networks, nodes, storage clusters ...) on any cloud.

## What can I do with Kotal Operator ?

- Deploy Bitcoin rpc nodes
- Deploy ipfs peers and cluster peers
- Deploy ipfs swarms
- Deploy Ethereum transaction and mining nodes
- Deploy Ethereum 2 beacon and validation nodes
- Deploy private Ethereum networks
- Deploy NEAR rpc, archive, and validator nodes
- Deploy Polkadot rpc and validator nodes
- Deploy Chainlink nodes
- Deploy Filecoin nodes
- Deploy Filecoin backed pinning services (FPS)
- Deploy Stacks rpc and api nodes
- Deploy Aptos full and validator nodes

## Kubernetes Custom Resources

Kotal extended kubernetes with custom resources in different API groups.

| Protocol         | Description                                      | API Group                   | Status |
| ---------------- | ------------------------------------------------ | --------------------------- | ------ |
| **Aptos**        | Deploy Aptos full and validator nodes            | aptos.kotal.io/v1alpha1     | alpha  |
| **Bitcoin**      | Deploy Bitcoin nodes                             | bitcoin.kotal.io/v1alpha1   | alpha  |
| **Chainlink**    | Deploy Chainlink nodes                           | chainlink.kotal.io/v1alpha1 | alpha  |
| **Ethereum**     | Deploy private and public network Ethereum nodes | ethereum.kotal.io/v1alpha1  | alpha  |
| **Ethereum 2.0** | Deploy validator and beacon chain nodes          | ethereum2.kotal.io/v1alpha1 | alpha  |
| **Filecoin**     | Deploy Filecoin nodes                            | filecoin.kotal.io/v1alpha1  | alpha  |
| **Graph**        | Deploy graph nodes                               | graph.kotal.io/v1alpha1     | alpha  |
| **IPFS**         | Deploy IPFS peers, cluster peers, and swarms     | ipfs.kotal.io/v1alpha1      | alpha  |
| **NEAR**         | Deploy NEAR rpc, archive and validator nodes     | near.kotal.io/v1alpha1      | alpha  |
| **Polkadot**     | Deploy Polkadot nodes and validator nodes        | polkadot.kotal.io/v1alpha1  | alpha  |
| **Stacks**       | Deploy Stacks rpc and api nodes                  | stacks.kotal.io/v1alpha1    | alpha  |

## Client support

For each protocol, kotal supports at least 1 client (reference client):

| Protocol         | Client(s)                                                                                                                                                                                        |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Aptos**        | [Aptos Core](https://github.com/aptos-labs/aptos-core)                                                                                                                                           |
| **Bitcoin**      | [Bitcoin Core](https://github.com/bitcoin/bitcoin)                                                                                                                                               |
| **Chainlink**    | [Chainlink](https://github.com/smartcontractkit/chainlink)                                                                                                                                       |
| **Ethereum**     | [Hyperledger Besu](https://github.com/hyperledger/besu), [Go-Ethereum](https://github.com/ethereum/go-ethereum), [Nethermind](https://github.com/NethermindEth/nethermind)                       |
| **Ethereum 2.0** | [Teku](https://github.com/ConsenSys/teku), [Prysm](https://github.com/prysmaticlabs/prysm), [Lighthouse](https://github.com/sigp/lighthouse), [Nimbus](https://github.com/status-im/nimbus-eth2) |
| **Filecoin**     | [Lotus](https://github.com/filecoin-project/lotus)                                                                                                                                               |
| **Graph**        | [graph-node](https://github.com/graphprotocol/graph-node)                                                                                                                                        |
| **IPFS**         | [kubo](https://github.com/ipfs/kubo), [ipfs-cluster-service](https://github.com/ipfs/ipfs-cluster)                                                                                         |
| **NEAR**         | [nearcore](https://github.com/near/nearcore)                                                                                                                                                     |
| **Polkadot**     | [Parity Polkadot](https://github.com/paritytech/polkadot)                                                                                                                                        |
| **Stacks**       | [Stacks Node](https://github.com/stacks-network/stacks-blockchain)                                                                                                                               |

## Install Kotal

Kotal requires access to Kubernetes cluster with cert-manager installed.

For development purposes, we recommend [KinD](https://kind.sigs.k8s.io/) (Kubernetes in Docker) to create kubernetes clusters and tear down kubernetes clusters in seconds:

```bash
kind create cluster
```

After the cluster is up and running, [install](https://cert-manager.io/docs/installation/kubernetes/) cert-manager:

```bash
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.5/cert-manager.yaml
```

Install kotal custom resources and controllers:

```bash
kubectl apply -f https://github.com/kotalco/kotal/releases/download/v0.3.0/kotal.yaml
```

## Example

Ethereum node using Hyperleger Besu client, joining goerli network, and enabling RPC HTTP server:

```yaml
# ethereum-node.yaml
apiVersion: ethereum.kotal.io/v1alpha1
kind: Node
metadata:
  name: ethereum-node
spec:
  client: besu
  network: goerli
  rpc: true
```

```bash
kubectl apply -f ethereum-node.yaml
```

## Documentation

Kotal documentation is available [here](https://docs.kotal.co)

## Get in touch

- [Discord](https://discord.com/invite/kTxy4SA)
- [website](https://kotal.co)
- [@kotalco](https://twitter.com/kotalco)
- [mostafa@kotal.co](mailto:mostafa@kotal.co)

## Contriubuting

TODO

## Licensing

Kotal Blockchain Kubernetes operator is free and open-source software licensed under the [Apache 2.0](LICENSE) License

'''
'''--- apis/aptos/v1alpha1/defaults.go ---
package v1alpha1

// Resources
const (
	// DefaultNodeCPURequest is the cpu requested by Aptos node
	DefaultNodeCPURequest = "2"
	// DefaultNodeCPULimit is the cpu limit for Aptos node
	DefaultNodeCPULimit = "4"

	// DefaultNodeMemoryRequest is the memory requested by Aptos node
	DefaultNodeMemoryRequest = "4Gi"
	// DefaultNodeMemoryLimit is the memory limit for Aptos node
	DefaultNodeMemoryLimit = "8Gi"

	// DefaultNodeStorageRequest is the Storage requested by Aptos node
	DefaultNodeStorageRequest = "250Gi"
)

const (
	// DefaultAptosCoreImage is the default Aptos core client image
	DefaultAptosCoreImage = "aptoslabs/validator:aptos-node-v1.11.2"
)

const (
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// DefaultMetricsPort is the default metrics server port
	DefaultMetricsPort uint = 9101
	// DefaultAPIPort is the default API server port
	DefaultAPIPort uint = 8080
	// DefaultFullnodeP2PPort is the default full node p2p port
	DefaultFullnodeP2PPort uint = 6182
	// DefaultValidatorP2PPort is the default validator node p2p port
	DefaultValidatorP2PPort uint = 6180
)

'''
'''--- apis/aptos/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the aptos v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=aptos.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "aptos.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/aptos/v1alpha1/node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// AptosNetwork is Aptos network
type AptosNetwork string

const (
	Devnet  AptosNetwork = "devnet"
	Mainnet AptosNetwork = "mainnet"
	Testnet AptosNetwork = "testnet"
)

// Peer is Aptos network peer
type Peer struct {
	// ID is peer identifier
	ID string `json:"id"`
	// Addresses is array of peer multiaddress
	// +listType=set
	// +kubebuilder:validation:MinItems=1
	Addresses []string `json:"addresses"`
}

// NodeSpec defines the desired state of Node
type NodeSpec struct {
	// Image is Aptos node client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// Network is Aptos network to join and sync
	// +kubebuilder:validation:Enum=devnet;testnet;mainnet
	Network AptosNetwork `json:"network"`
	// Validator enables validator mode
	Validator bool `json:"validator,omitempty"`
	// Waypoint provides an off-chain mechanism to verify the sync process after restart or epoch change
	Waypoint string `json:"waypoint,omitempty"`
	// GenesisConfigmapName is Kubernetes configmap name holding genesis blob
	GenesisConfigmapName string `json:"genesisConfigmapName,omitempty"`
	// NodePrivateKeySecretName is the secret name holding node private key
	NodePrivateKeySecretName string `json:"nodePrivateKeySecretName,omitempty"`
	// PeerId is the node identity
	PeerId string `json:"peerId,omitempty"`
	// SeedPeers is seed peers
	SeedPeers []Peer `json:"seedPeers,omitempty"`
	// API enables REST API server
	API bool `json:"api,omitempty"`
	// APIPort is api server port
	APIPort uint `json:"apiPort,omitempty"`
	// P2PPort is p2p communications port
	P2PPort uint `json:"p2pPort,omitempty"`
	// MetricsPort is metrics server port
	MetricsPort uint `json:"metricsPort,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// NodeStatus defines the observed state of Node
type NodeStatus struct {
}

// +kubebuilder:object:root=true

// Node is the Schema for the nodes API
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/aptos/v1alpha1/node_defaulting_webhook.go ---
package v1alpha1

import (
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-aptos-kotal-io-v1alpha1-node,mutating=true,failurePolicy=fail,groups=aptos.kotal.io,resources=nodes,verbs=create;update,versions=v1alpha1,name=mutate-aptos-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Node{}

func (r *Node) DefaultNodeResources() {

	if r.Spec.Resources.CPU == "" {
		r.Spec.Resources.CPU = DefaultNodeCPURequest
	}

	if r.Spec.Resources.CPULimit == "" {
		r.Spec.Resources.CPULimit = DefaultNodeCPULimit
	}

	if r.Spec.Resources.Memory == "" {
		r.Spec.Resources.Memory = DefaultNodeMemoryRequest
	}

	if r.Spec.Resources.MemoryLimit == "" {
		r.Spec.Resources.MemoryLimit = DefaultNodeMemoryLimit
	}

	if r.Spec.Resources.Storage == "" {
		r.Spec.Resources.Storage = DefaultNodeStorageRequest
	}

}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Node) Default() {
	nodelog.Info("default", "name", r.Name)

	r.DefaultNodeResources()

	if r.Spec.Image == "" {
		r.Spec.Image = DefaultAptosCoreImage
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	if r.Spec.MetricsPort == 0 {
		r.Spec.MetricsPort = DefaultMetricsPort
	}

	if r.Spec.APIPort == 0 {
		r.Spec.APIPort = DefaultAPIPort
	}

	if r.Spec.P2PPort == 0 {
		if r.Spec.Validator {
			r.Spec.P2PPort = DefaultValidatorP2PPort
		} else {
			r.Spec.P2PPort = DefaultFullnodeP2PPort
		}
	}

}

'''
'''--- apis/aptos/v1alpha1/node_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Aptos node defaulting", func() {
	It("Should default Aptos node", func() {
		node := Node{
			ObjectMeta: metav1.ObjectMeta{},
			Spec: NodeSpec{
				Network:   Devnet,
				Validator: true,
			},
		}
		// TODO: create a test for full node, p2p port

		node.Default()

		Expect(node.Spec.Image).To(Equal(DefaultAptosCoreImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.CPU).To(Equal(DefaultNodeCPURequest))
		Expect(node.Spec.CPULimit).To(Equal(DefaultNodeCPULimit))
		Expect(node.Spec.Memory).To(Equal(DefaultNodeMemoryRequest))
		Expect(node.Spec.MemoryLimit).To(Equal(DefaultNodeMemoryLimit))
		Expect(node.Spec.Storage).To(Equal(DefaultNodeStorageRequest))
		Expect(node.Spec.APIPort).To(Equal(DefaultAPIPort))
		Expect(node.Spec.MetricsPort).To(Equal(DefaultMetricsPort))
		Expect(node.Spec.P2PPort).To(Equal(DefaultValidatorP2PPort))

	})
})

'''
'''--- apis/aptos/v1alpha1/node_validation_webhook.go ---
package v1alpha1

import (
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-aptos-kotal-io-v1alpha1-node,mutating=false,failurePolicy=fail,groups=aptos.kotal.io,resources=nodes,versions=v1alpha1,name=validate-aptos-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Node{}

// validate shared validation logic for create and update resources
func (r *Node) validate() field.ErrorList {
	var nodeErrors field.ErrorList

	if r.Spec.NodePrivateKeySecretName != "" && r.Spec.PeerId == "" {
		err := field.Invalid(field.NewPath("spec").Child("peerId"), r.Spec.PeerId, "must provide peerId if nodePrivateKeySecretName is provided")
		nodeErrors = append(nodeErrors, err)
	}

	if r.Spec.PeerId != "" && r.Spec.NodePrivateKeySecretName == "" {
		err := field.Invalid(field.NewPath("spec").Child("nodePrivateKeySecretName"), r.Spec.NodePrivateKeySecretName, "must provide nodePrivateKeySecretName if peerId is provided")
		nodeErrors = append(nodeErrors, err)
	}

	return nodeErrors
}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	nodelog.Info("validate create", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldNode := old.(*Node)

	nodelog.Info("validate update", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if r.Spec.Network != oldNode.Spec.Network {
		err := field.Invalid(field.NewPath("spec").Child("network"), r.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", r.Name)

	return nil, nil
}

'''
'''--- apis/aptos/v1alpha1/node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Aptos node validation", func() {
	createCases := []struct {
		Title  string
		Node   *Node
		Errors field.ErrorList
	}{
		{
			Title: "missing peerId",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:                  Devnet,
					NodePrivateKeySecretName: "my-private-key",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.peerId",
					BadValue: "",
					Detail:   "must provide peerId if nodePrivateKeySecretName is provided",
				},
			},
		},
		{
			Title: "missing nodePrivateKeySecretName",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: Devnet,
					PeerId:  "76c8ca8bb75d1abd853fc17b70cc72cb78a63425fa85be96743825d93cc57d6f",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.nodePrivateKeySecretName",
					BadValue: "",
					Detail:   "must provide nodePrivateKeySecretName if peerId is provided",
				},
			},
		},
	}

	updateCases := []struct {
		Title   string
		OldNode *Node
		NewNode *Node
		Errors  field.ErrorList
	}{
		{
			Title: "updated network",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: Devnet,
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: Testnet,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: Testnet,
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "missing peerId",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:                  Devnet,
					NodePrivateKeySecretName: "my-private-key",
					PeerId:                   "76c8ca8bb75d1abd853fc17b70cc72cb78a63425fa85be96743825d93cc57d6f",
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:                  Devnet,
					NodePrivateKeySecretName: "my-private-key",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.peerId",
					BadValue: "",
					Detail:   "must provide peerId if nodePrivateKeySecretName is provided",
				},
			},
		},
		{
			Title: "missing nodePrivateKeySecretName",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:                  Devnet,
					NodePrivateKeySecretName: "my-private-key",
					PeerId:                   "76c8ca8bb75d1abd853fc17b70cc72cb78a63425fa85be96743825d93cc57d6f",
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: Devnet,
					PeerId:  "76c8ca8bb75d1abd853fc17b70cc72cb78a63425fa85be96743825d93cc57d6f",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.nodePrivateKeySecretName",
					BadValue: "",
					Detail:   "must provide nodePrivateKeySecretName if peerId is provided",
				},
			},
		},
	}

	Context("While creating node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Node.Default()
					_, err := cc.Node.ValidateCreate()

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldNode.Default()
					cc.NewNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/aptos/v1alpha1/node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var nodelog = logf.Log.WithName("node-resource")

func (r *Node) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/aptos/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/aptos/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.SeedPeers != nil {
		in, out := &in.SeedPeers, &out.SeedPeers
		*out = make([]Peer, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Peer) DeepCopyInto(out *Peer) {
	*out = *in
	if in.Addresses != nil {
		in, out := &in.Addresses, &out.Addresses
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Peer.
func (in *Peer) DeepCopy() *Peer {
	if in == nil {
		return nil
	}
	out := new(Peer)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/bitcoin/v1alpha1/defaults.go ---
package v1alpha1

const (
	// DefaultMainnetRPCPort is the default JSON-RPC port for mainnet
	DefaultMainnetRPCPort uint = 8332
	// DefaultTestnetRPCPort is the default JSON-RPC port for testnet
	DefaultTestnetRPCPort uint = 18332
	// DefaultMainnetP2PPort is the default p2p port for mainnet
	DefaultMainnetP2PPort uint = 8333
	// DefaultTestnetP2PPort is the default p2p port for testnet
	DefaultTestnetP2PPort uint = 18333
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// DefaultListen is the default connection to outside strategy
	DefaultListen = true
	// DefaultDBCacheSize is the default database cache size
	DefaultDBCacheSize uint = 450
	// DefaultMaxConnections is the default maximum connections to peers
	DefaultMaxConnections uint = 125
)

const (
	// DefaultBitcoinCoreImage is the default Bitcoin core client image
	DefaultBitcoinCoreImage = "lncm/bitcoind:v26.0"
)

// Resources
const (
	// DefaultNodeCPURequest is the cpu requested by Bitcoin node
	DefaultNodeCPURequest = "2"
	// DefaultNodeCPULimit is the cpu limit for Bitcoin node
	DefaultNodeCPULimit = "4"

	// DefaultNodeMemoryRequest is the memory requested by Bitcoin node
	DefaultNodeMemoryRequest = "4Gi"
	// DefaultNodeMemoryLimit is the memory limit for Bitcoin node
	DefaultNodeMemoryLimit = "8Gi"

	// DefaultNodeStorageRequest is the Storage requested by Bitcoin node
	DefaultNodeStorageRequest = "100Gi"
)

'''
'''--- apis/bitcoin/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the bitcoin v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=bitcoin.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "bitcoin.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/bitcoin/v1alpha1/node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// BitcoinNetwork is Bitcoin network
type BitcoinNetwork string

// Bitcoin networks
const (
	Mainnet BitcoinNetwork = "mainnet"
	Testnet BitcoinNetwork = "testnet"
)

// RPCUsers is JSON-RPC users credentials
type RPCUser struct {
	// Username is JSON-RPC username
	Username string `json:"username"`
	// PasswordSecretName is k8s secret name holding JSON-RPC user password
	PasswordSecretName string `json:"passwordSecretName"`
}

// NodeSpec defines the desired state of Node
type NodeSpec struct {
	// Image is Bitcoin node client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// Network is Bitcoin network to join and sync
	// +kubebuilder:validation:Enum=mainnet;testnet
	Network BitcoinNetwork `json:"network"`
	// Listen accepts connections from outside
	Listen *bool `json:"listen,omitempty"`
	// P2PPort is p2p communications port
	P2PPort uint `json:"p2pPort,omitempty"`
	// MaxConnections is maximum connections to peers
	MaxConnections *uint `json:"maxConnections,omitempty"`
	// RPC enables JSON-RPC server
	RPC bool `json:"rpc,omitempty"`
	// RPCPort is JSON-RPC server port
	RPCPort uint `json:"rpcPort,omitempty"`
	// RPCUsers is JSON-RPC users credentials
	RPCUsers []RPCUser `json:"rpcUsers,omitempty"`
	// RPCWhitelist is a list of whitelisted rpc method
	// +listType=set
	RPCWhitelist []string `json:"rpcWhitelist,omitempty"`
	// Wallet load wallet and enables wallet RPC calls
	Wallet bool `json:"wallet,omitempty"`
	// TransactionIndex maintains a full tx index
	TransactionIndex bool `json:"txIndex,omitempty"`
	// CoinStatsIndex maintains coinstats index used by the gettxoutsetinfo RPC
	CoinStatsIndex bool `json:"coinStatsIndex,omitempty"`
	// ReIndex rebuild chain state and block index
	ReIndex bool `json:"reIndex,omitempty"`
	// Pruning allows pruneblockchain RPC to delete specific blocks
	Pruning bool `json:"pruning,omitempty"`
	// BlocksOnly rejects transactions from network peers
	// https://bitcointalk.org/index.php?topic=1377345.0
	BlocksOnly bool `json:"blocksOnly,omitempty"`
	// DBCacheSize is database cache size
	// +kubebuilder:validation:Minimum=4
	// +kubebuilder:validation:Maximum=16384
	DBCacheSize uint `json:"dbCacheSize,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// NodeStatus defines the observed state of Node
type NodeStatus struct {
	Client string `json:"client,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Node is the Schema for the nodes API
// +kubebuilder:printcolumn:name="Network",type=string,JSONPath=".spec.network"
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".status.client"
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/bitcoin/v1alpha1/node_defaulting_webhook.go ---
package v1alpha1

import (
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-bitcoin-kotal-io-v1alpha1-node,mutating=true,failurePolicy=fail,groups=bitcoin.kotal.io,resources=nodes,verbs=create;update,versions=v1alpha1,name=mutate-bitcoin-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Node{}

func (r *Node) DefaultNodeResources() {
	if r.Spec.Resources.CPU == "" {
		r.Spec.Resources.CPU = DefaultNodeCPURequest
	}

	if r.Spec.Resources.CPULimit == "" {
		r.Spec.Resources.CPULimit = DefaultNodeCPULimit
	}

	if r.Spec.Resources.Memory == "" {
		r.Spec.Resources.Memory = DefaultNodeMemoryRequest
	}

	if r.Spec.Resources.MemoryLimit == "" {
		r.Spec.Resources.MemoryLimit = DefaultNodeMemoryLimit
	}

	if r.Spec.Resources.Storage == "" {
		r.Spec.Resources.Storage = DefaultNodeStorageRequest
	}
}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Node) Default() {
	nodelog.Info("default", "name", r.Name)

	r.DefaultNodeResources()

	if r.Spec.Image == "" {
		r.Spec.Image = DefaultBitcoinCoreImage
	}

	if r.Spec.RPCPort == 0 {
		if r.Spec.Network == Mainnet {
			r.Spec.RPCPort = DefaultMainnetRPCPort
		}
		if r.Spec.Network == Testnet {
			r.Spec.RPCPort = DefaultTestnetRPCPort
		}
	}

	if r.Spec.P2PPort == 0 {
		if r.Spec.Network == Mainnet {
			r.Spec.P2PPort = DefaultMainnetP2PPort
		}
		if r.Spec.Network == Testnet {
			r.Spec.P2PPort = DefaultTestnetP2PPort
		}
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	if r.Spec.Listen == nil {
		// constants are not addressable
		defaultListen := DefaultListen
		r.Spec.Listen = &defaultListen
	}

	if r.Spec.DBCacheSize == 0 {
		r.Spec.DBCacheSize = DefaultDBCacheSize
	}

	if r.Spec.MaxConnections == nil {
		// constants are not addressable
		maxConnections := DefaultMaxConnections
		r.Spec.MaxConnections = &maxConnections
	}

}

'''
'''--- apis/bitcoin/v1alpha1/node_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Bitcoin node defaulting", func() {
	It("Should default Bitcoin node", func() {
		node := Node{
			ObjectMeta: metav1.ObjectMeta{},
			Spec: NodeSpec{
				Network: Mainnet,
			},
		}

		node.Default()

		Expect(node.Spec.Image).To(Equal(DefaultBitcoinCoreImage))
		Expect(node.Spec.P2PPort).To(Equal(DefaultMainnetP2PPort))
		Expect(*node.Spec.Listen).To(Equal(DefaultListen))
		Expect(*node.Spec.MaxConnections).To(Equal(DefaultMaxConnections))
		Expect(node.Spec.DBCacheSize).To(Equal(DefaultDBCacheSize))
		Expect(node.Spec.RPCPort).To(Equal(DefaultMainnetRPCPort))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.CPU).To(Equal(DefaultNodeCPURequest))
		Expect(node.Spec.CPULimit).To(Equal(DefaultNodeCPULimit))
		Expect(node.Spec.Memory).To(Equal(DefaultNodeMemoryRequest))
		Expect(node.Spec.MemoryLimit).To(Equal(DefaultNodeMemoryLimit))
		Expect(node.Spec.Storage).To(Equal(DefaultNodeStorageRequest))

	})
})

'''
'''--- apis/bitcoin/v1alpha1/node_validation_webhook.go ---
package v1alpha1

import (
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-bitcoin-kotal-io-v1alpha1-node,mutating=false,failurePolicy=fail,groups=bitcoin.kotal.io,resources=nodes,versions=v1alpha1,name=validate-bitcoin-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Node{}

// Validate is common create and update validation rules
func (n *Node) validate() field.ErrorList {
	var nodeErrors field.ErrorList

	// can't work in pruning and transaction index mode at the same time
	if n.Spec.TransactionIndex && n.Spec.Pruning {
		err := field.Invalid(field.NewPath("spec").Child("pruning"), n.Spec.Pruning, "must be false if transaction index is enabled")
		nodeErrors = append(nodeErrors, err)
	}

	return nodeErrors
}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	nodelog.Info("validate create", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldNode := old.(*Node)

	nodelog.Info("validate update", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if r.Spec.Network != oldNode.Spec.Network {
		err := field.Invalid(field.NewPath("spec").Child("network"), r.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", r.Name)

	return nil, nil
}

'''
'''--- apis/bitcoin/v1alpha1/node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Bitcoin node validation", func() {
	createCases := []struct {
		Title  string
		Node   *Node
		Errors field.ErrorList
	}{

		{
			Title: "updated transactionIndex",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:          "mainnet",
					Pruning:          true,
					TransactionIndex: true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.pruning",
					BadValue: true,
					Detail:   "must be false if transaction index is enabled",
				},
			},
		},
	}

	updateCases := []struct {
		Title   string
		OldNode *Node
		NewNode *Node
		Errors  field.ErrorList
	}{
		{
			Title: "updated network",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "mainnet",
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "testnet",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: "testnet",
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "updated transactionIndex",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "mainnet",
					Pruning: true,
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:          "mainnet",
					Pruning:          true,
					TransactionIndex: true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.pruning",
					BadValue: true,
					Detail:   "must be false if transaction index is enabled",
				},
			},
		},
	}

	Context("While creating node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Node.Default()
					_, err := cc.Node.ValidateCreate()

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldNode.Default()
					cc.NewNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/bitcoin/v1alpha1/node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var nodelog = logf.Log.WithName("node-resource")

func (r *Node) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/bitcoin/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/bitcoin/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.Listen != nil {
		in, out := &in.Listen, &out.Listen
		*out = new(bool)
		**out = **in
	}
	if in.MaxConnections != nil {
		in, out := &in.MaxConnections, &out.MaxConnections
		*out = new(uint)
		**out = **in
	}
	if in.RPCUsers != nil {
		in, out := &in.RPCUsers, &out.RPCUsers
		*out = make([]RPCUser, len(*in))
		copy(*out, *in)
	}
	if in.RPCWhitelist != nil {
		in, out := &in.RPCWhitelist, &out.RPCWhitelist
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPCUser) DeepCopyInto(out *RPCUser) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPCUser.
func (in *RPCUser) DeepCopy() *RPCUser {
	if in == nil {
		return nil
	}
	out := new(RPCUser)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/chainlink/v1alpha1/defaults.go ---
package v1alpha1

const (
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// DefaultAPIPort is the default API and GUI port
	DefaultAPIPort uint = 6688
	// DefaultTLSPort is the default tls port
	DefaultTLSPort uint = 6689
	// DefaultP2PPort is the default p2p port
	DefaultP2PPort uint = 30303
)

var (
	// DefaultCorsDomains is the default cors domains from which to accept requests
	DefaultCorsDomains = []string{"*"}
)

const (
	// DefaultChainlinkImage is the default chainlink client image
	DefaultChainlinkImage = "kotalco/chainlink:v2.9.1"
)

// Resources
const (
	// DefaultNodeCPURequest is the cpu requested by chainlink node
	DefaultNodeCPURequest = "2"
	// DefaultNodeCPULimit is the cpu limit for chainlink node
	DefaultNodeCPULimit = "4"

	// DefaultNodeMemoryRequest is the memory requested by chainlink node
	DefaultNodeMemoryRequest = "2Gi"
	// DefaultNodeMemoryLimit is the memory limit for chainlink node
	DefaultNodeMemoryLimit = "4Gi"

	// DefaultNodeStorageRequest is the Storage requested by chainlink node
	DefaultNodeStorageRequest = "20Gi"
)

'''
'''--- apis/chainlink/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the chainlink v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=chainlink.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "chainlink.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/chainlink/v1alpha1/node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// APICredentials is api credentials
type APICredentials struct {
	// Email is user email
	Email string `json:"email"`
	// PasswordSecretName is the k8s secret name that holds password
	PasswordSecretName string `json:"passwordSecretName"`
}

// NodeSpec defines the desired state of Node
type NodeSpec struct {
	// Image is Chainlink node client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// EthereumChainId is ethereum chain id
	EthereumChainId uint `json:"ethereumChainId"`
	// EthereumWSEndpoint is ethereum websocket endpoint
	EthereumWSEndpoint string `json:"ethereumWsEndpoint"`
	// EthereumHTTPEndpoints is ethereum http endpoints
	// +listType=set
	EthereumHTTPEndpoints []string `json:"ethereumHttpEndpoints,omitempty"`
	// LinkContractAddress is link contract address
	LinkContractAddress string `json:"linkContractAddress"`
	// DatabaseURL is postgres database connection URL
	DatabaseURL string `json:"databaseURL"`
	// KeystorePasswordSecretName is k8s secret name that holds keystore password
	KeystorePasswordSecretName string `json:"keystorePasswordSecretName"`
	// APICredentials is api credentials
	APICredentials APICredentials `json:"apiCredentials"`
	// CORSDomains is the domains from which to accept cross origin requests
	// +listType=set
	CORSDomains []string `json:"corsDomains,omitempty"`
	// CertSecretName is k8s secret name that holds tls.key and tls.cert
	CertSecretName string `json:"certSecretName,omitempty"`
	// TLSPort is port used for HTTPS connections
	TLSPort uint `json:"tlsPort,omitempty"`
	// P2PPort is port used for p2p communcations
	P2PPort uint `json:"p2pPort,omitempty"`
	// API enables node API server
	API bool `json:"api,omitempty"`
	// APIPort is port used for node API and GUI
	APIPort uint `json:"apiPort,omitempty"`
	// SecureCookies enables secure cookies for authentication
	SecureCookies bool `json:"secureCookies,omitempty"`
	// Logging is logging verboisty level
	// +kubebuilder:validation:Enum=debug;info;warn;error;panic
	Logging shared.VerbosityLevel `json:"logging,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// NodeStatus defines the observed state of Node
type NodeStatus struct {
	Client string `json:"client,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Node is the Schema for the nodes API
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".status.client"
// +kubebuilder:printcolumn:name="EthereumChainId",type=number,JSONPath=".spec.ethereumChainId"
// +kubebuilder:printcolumn:name="LinkContractAddress",type=string,JSONPath=".spec.linkContractAddress",priority=10
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/chainlink/v1alpha1/node_defaulting_webhook.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-chainlink-kotal-io-v1alpha1-node,mutating=true,failurePolicy=fail,groups=chainlink.kotal.io,resources=nodes,verbs=create;update,versions=v1alpha1,name=mutate-chainlink-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Node{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Node) Default() {
	nodelog.Info("default", "name", r.Name)

	if r.Spec.Image == "" {
		r.Spec.Image = DefaultChainlinkImage
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	if r.Spec.P2PPort == 0 {
		r.Spec.P2PPort = DefaultP2PPort
	}

	if r.Spec.APIPort == 0 {
		r.Spec.APIPort = DefaultAPIPort
	}

	if r.Spec.CPU == "" {
		r.Spec.CPU = DefaultNodeCPURequest
	}

	if r.Spec.CPULimit == "" {
		r.Spec.CPULimit = DefaultNodeCPULimit
	}

	if r.Spec.Memory == "" {
		r.Spec.Memory = DefaultNodeMemoryRequest
	}

	if r.Spec.MemoryLimit == "" {
		r.Spec.MemoryLimit = DefaultNodeMemoryLimit
	}

	if r.Spec.Storage == "" {
		r.Spec.Storage = DefaultNodeStorageRequest
	}

	if r.Spec.TLSPort == 0 {
		r.Spec.TLSPort = DefaultTLSPort
	}

	if r.Spec.Logging == "" {
		r.Spec.Logging = shared.InfoLogs
	}

	if len(r.Spec.CORSDomains) == 0 {
		r.Spec.CORSDomains = DefaultCorsDomains
	}

}

'''
'''--- apis/chainlink/v1alpha1/node_defaulting_webhook_test.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Chainlink node defaulting", func() {
	It("Should default node", func() {

		node := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "my-node",
			},
			Spec: NodeSpec{
				CertSecretName: "my-certificate",
			},
		}

		node.Default()

		Expect(node.Spec.Image).To(Equal(DefaultChainlinkImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.TLSPort).To(Equal(DefaultTLSPort))
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.APIPort).To(Equal(DefaultAPIPort))
		Expect(node.Spec.Logging).To(Equal(shared.InfoLogs))
		Expect(node.Spec.CORSDomains).To(Equal(DefaultCorsDomains))
		// resources
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultNodeCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultNodeCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultNodeMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultNodeMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultNodeStorageRequest))

	})
})

'''
'''--- apis/chainlink/v1alpha1/node_validation_webhook.go ---
package v1alpha1

import (
	"fmt"

	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-chainlink-kotal-io-v1alpha1-node,mutating=false,failurePolicy=fail,groups=chainlink.kotal.io,resources=nodes,versions=v1alpha1,name=validate-chainlink-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Node{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	nodelog.Info("validate create", "name", r.Name)

	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)

}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldNode := old.(*Node)

	nodelog.Info("validate update", "name", r.Name)

	allErrors = append(allErrors, r.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if oldNode.Spec.EthereumChainId != r.Spec.EthereumChainId {
		err := field.Invalid(field.NewPath("spec").Child("ethereumChainId"), fmt.Sprintf("%d", r.Spec.EthereumChainId), "field is immutable")
		allErrors = append(allErrors, err)
	}

	if oldNode.Spec.LinkContractAddress != r.Spec.LinkContractAddress {
		err := field.Invalid(field.NewPath("spec").Child("linkContractAddress"), r.Spec.LinkContractAddress, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", r.Name)
	return nil, nil
}

'''
'''--- apis/chainlink/v1alpha1/node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Chainlink node validation", func() {
	createCases := []struct {
		Title  string
		Node   *Node
		Errors field.ErrorList
	}{}

	updateCases := []struct {
		Title   string
		OldNode *Node
		NewNode *Node
		Errors  field.ErrorList
	}{
		{
			Title: "updating ethereum chain ID",
			OldNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					EthereumChainId: 111,
				},
			},
			NewNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					EthereumChainId: 222,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.ethereumChainId",
					BadValue: "222",
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "updating LINK contract address",
			OldNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					LinkContractAddress: "0x514910771af9ca656af840dff83e8264ecf986ca",
				},
			},
			NewNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					LinkContractAddress: "0x326c977e6efc84e512bb9c30f76e30c160ed06fb",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.linkContractAddress",
					BadValue: "0x326c977e6efc84e512bb9c30f76e30c160ed06fb",
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Node.Default()
					_, err := cc.Node.ValidateCreate()

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldNode.Default()
					cc.NewNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/chainlink/v1alpha1/node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var nodelog = logf.Log.WithName("node-resource")

func (r *Node) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/chainlink/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/chainlink/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *APICredentials) DeepCopyInto(out *APICredentials) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new APICredentials.
func (in *APICredentials) DeepCopy() *APICredentials {
	if in == nil {
		return nil
	}
	out := new(APICredentials)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.EthereumHTTPEndpoints != nil {
		in, out := &in.EthereumHTTPEndpoints, &out.EthereumHTTPEndpoints
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	out.APICredentials = in.APICredentials
	if in.CORSDomains != nil {
		in, out := &in.CORSDomains, &out.CORSDomains
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/ethereum/v1alpha1/defaults.go ---
package v1alpha1

import "github.com/kotalco/kotal/apis/shared"

var (
	// DefaultAPIs is the default rpc, ws APIs
	DefaultAPIs []API = []API{Web3API, ETHAPI, NetworkAPI}
	// DefaultOrigins is the default origins
	DefaultOrigins []string = []string{"*"}
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
)

const (
	// DefaultBesuImage is hyperledger besu image
	DefaultBesuImage = "hyperledger/besu:24.3.0"
	// DefaultGethImage is go-ethereum image
	DefaultGethImage = "kotalco/geth:v1.13.14"
	// DefaultNethermindImage is nethermind image
	DefaultNethermindImage = "kotalco/nethermind:v1.25.4"
)

// Node defaults
const (
	// DefaultLogging is the default logging verbosity level
	DefaultLogging = shared.InfoLogs
	// DefaultP2PPort is the default p2p port
	DefaultP2PPort uint = 30303
	// DefaultPublicNetworkSyncMode is the default sync mode for public networks
	DefaultPublicNetworkSyncMode = FastSynchronization
	// DefaultPrivateNetworkSyncMode is the default sync mode for private networks
	DefaultPrivateNetworkSyncMode = FullSynchronization
	// DefaultEngineRPCPort is the default engine rpc port
	DefaultEngineRPCPort uint = 8551
	// DefaultRPCPort is the default rpc port
	DefaultRPCPort uint = 8545
	// DefaultWSPort is the default ws port
	DefaultWSPort uint = 8546
	// DefaultGraphQLPort is the default graphQL port
	DefaultGraphQLPort uint = 8547
)

// Genesis block defaults
const (
	// DefaultCoinbase is the default coinbase
	DefaultCoinbase = shared.EthereumAddress("0x0000000000000000000000000000000000000000")
	// DefaultDifficulty is the default difficulty
	DefaultDifficulty = HexString("0x1")
	// DefaultMixHash is the default mix hash
	DefaultMixHash = Hash("0x0000000000000000000000000000000000000000000000000000000000000000")
	// DefaultGasLimit is the default gas limit
	DefaultGasLimit = HexString("0x47b760")
	// DefaultNonce is the default nonce
	DefaultNonce = HexString("0x0")
	// DefaultTimestamp is the default timestamp
	DefaultTimestamp = HexString("0x0")
)

// Ethash engine defaults
const (
	// DefaultEthashFixedDifficulty is the default ethash fixed difficulty
	DefaultEthashFixedDifficulty uint = 1000
)

// Clique engine defaults
const (
	// DefaultCliqueBlockPeriod is the default clique block period
	DefaultCliqueBlockPeriod uint = 15
	// DefaultCliqueEpochLength is th default clique epoch length
	DefaultCliqueEpochLength uint = 3000
)

// IBFT2 engine defaults
const (
	// DefaultIBFT2BlockPeriod is the default ibft2 block period
	DefaultIBFT2BlockPeriod uint = 15
	// DefaultIBFT2EpochLength is the default ibft2 epoch length
	DefaultIBFT2EpochLength uint = 3000
	// DefaultIBFT2RequestTimeout is the default ibft2 request timeout
	DefaultIBFT2RequestTimeout uint = 10
	// DefaultIBFT2MessageQueueLimit is the default ibft2 message queue limit
	DefaultIBFT2MessageQueueLimit uint = 1000
	// DefaultIBFT2DuplicateMessageLimit is the default ibft2 duplicate message limit
	DefaultIBFT2DuplicateMessageLimit uint = 100
	// DefaultIBFT2FutureMessagesLimit is the default ibft2 future message limit
	DefaultIBFT2FutureMessagesLimit uint = 1000
	// DefaultIBFT2FutureMessagesMaxDistance is the default ibft2 future message max distance
	DefaultIBFT2FutureMessagesMaxDistance uint = 10
)

// Resources
const (
	// DefaultPrivateNetworkNodeCPURequest is the cpu requested by private network node
	DefaultPrivateNetworkNodeCPURequest = "2"
	// DefaultPrivateNetworkNodeCPULimit is the cpu limit for private network node
	DefaultPrivateNetworkNodeCPULimit = "3"
	// DefaultPublicNetworkNodeCPURequest is the cpu requested by public network node
	DefaultPublicNetworkNodeCPURequest = "4"
	// DefaultPublicNetworkNodeCPULimit is the cpu limit for public network node
	DefaultPublicNetworkNodeCPULimit = "6"
	// DefaultPrivateNetworkNodeMemoryRequest is the memory requested by private network node
	DefaultPrivateNetworkNodeMemoryRequest = "4Gi"
	// DefaultPrivateNetworkNodeMemoryLimit is the memory limit for private network node
	DefaultPrivateNetworkNodeMemoryLimit = "6Gi"
	// DefaultPublicNetworkNodeMemoryRequest is the Memory requested by public network node
	DefaultPublicNetworkNodeMemoryRequest = "8Gi"
	// DefaultPublicNetworkNodeMemoryLimit is the Memory limit for public network node
	DefaultPublicNetworkNodeMemoryLimit = "16Gi"
	// DefaultPrivateNetworkNodeStorageRequest is the Storage requested by private network node
	DefaultPrivateNetworkNodeStorageRequest = "100Gi"
	// DefaultMainNetworkFullNodeStorageRequest is the Storage requested by main network archive node
	DefaultMainNetworkFullNodeStorageRequest = "6Ti"
	// DefaultMainNetworkFastNodeStorageRequest is the Storage requested by main network full node
	DefaultMainNetworkFastNodeStorageRequest = "750Gi"
	// DefaultTestNetworkStorageRequest is the Storage requested by main network full node
	DefaultTestNetworkStorageRequest = "25Gi"
)

'''
'''--- apis/ethereum/v1alpha1/genesis.go ---
package v1alpha1

import "github.com/kotalco/kotal/apis/shared"

// Genesis is genesis block sepcficition
type Genesis struct {
	// Accounts is array of accounts to fund or associate with code and storage
	Accounts []Account `json:"accounts,omitempty"`

	// NetworkID is network id
	NetworkID uint `json:"networkId"`

	// ChainID is the the chain ID used in transaction signature to prevent reply attack
	// more details https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
	ChainID uint `json:"chainId"`

	// Address to pay mining rewards to
	Coinbase shared.EthereumAddress `json:"coinbase,omitempty"`

	// Difficulty is the diffculty of the genesis block
	Difficulty HexString `json:"difficulty,omitempty"`

	// MixHash is hash combined with nonce to prove effort spent to create block
	MixHash Hash `json:"mixHash,omitempty"`

	// Ethash PoW engine configuration
	Ethash *Ethash `json:"ethash,omitempty"`

	// Clique PoA engine cinfiguration
	Clique *Clique `json:"clique,omitempty"`

	// IBFT2 PoA engine configuration
	IBFT2 *IBFT2 `json:"ibft2,omitempty"`

	// Forks is supported forks (network upgrade) and corresponding block number
	Forks *Forks `json:"forks,omitempty"`

	// GastLimit is the total gas limit for all transactions in a block
	GasLimit HexString `json:"gasLimit,omitempty"`

	// Nonce is random number used in block computation
	Nonce HexString `json:"nonce,omitempty"`

	// Timestamp is block creation date
	Timestamp HexString `json:"timestamp,omitempty"`
}

// PoA is Shared PoA engine config
type PoA struct {
	// BlockPeriod is block time in seconds
	BlockPeriod uint `json:"blockPeriod,omitempty"`

	// EpochLength is the Number of blocks after which to reset all votes
	EpochLength uint `json:"epochLength,omitempty"`
}

// IBFT2 configuration
type IBFT2 struct {
	PoA `json:",inline"`

	// Validators are initial ibft2 validators
	// +kubebuilder:validation:MinItems=1
	Validators []shared.EthereumAddress `json:"validators,omitempty"`

	// RequestTimeout is the timeout for each consensus round in seconds
	RequestTimeout uint `json:"requestTimeout,omitempty"`

	// MessageQueueLimit is the message queue limit
	MessageQueueLimit uint `json:"messageQueueLimit,omitempty"`

	// DuplicateMessageLimit is duplicate messages limit
	DuplicateMessageLimit uint `json:"duplicateMessageLimit,omitempty"`

	// futureMessagesLimit is future messages buffer limit
	FutureMessagesLimit uint `json:"futureMessagesLimit,omitempty"`

	// FutureMessagesMaxDistance is maximum height from current chain height for buffering future messages
	FutureMessagesMaxDistance uint `json:"futureMessagesMaxDistance,omitempty"`
}

// Clique configuration
type Clique struct {
	PoA `json:",inline"`

	// Signers are PoA initial signers, at least one signer is required
	// +kubebuilder:validation:MinItems=1
	Signers []shared.EthereumAddress `json:"signers,omitempty"`
}

// Ethash configurations
type Ethash struct {
	// FixedDifficulty is fixed difficulty to be used in private PoW networks
	FixedDifficulty *uint `json:"fixedDifficulty,omitempty"`
}

// Forks is the supported forks by the network
type Forks struct {
	// Homestead fork
	Homestead uint `json:"homestead,omitempty"`

	// DAO fork
	DAO *uint `json:"dao,omitempty"`

	// EIP150 (Tangerine Whistle) fork
	EIP150 uint `json:"eip150,omitempty"`

	// EIP155 (Spurious Dragon) fork
	EIP155 uint `json:"eip155,omitempty"`

	// EIP158 (state trie clearing) fork
	EIP158 uint `json:"eip158,omitempty"`

	// Byzantium fork
	Byzantium uint `json:"byzantium,omitempty"`

	// Constantinople fork
	Constantinople uint `json:"constantinople,omitempty"`

	// Petersburg fork
	Petersburg uint `json:"petersburg,omitempty"`

	// Istanbul fork
	Istanbul uint `json:"istanbul,omitempty"`

	// MuirGlacier fork
	MuirGlacier uint `json:"muirglacier,omitempty"`

	// Berlin fork
	Berlin uint `json:"berlin,omitempty"`

	// London fork
	London uint `json:"london,omitempty"`

	// ArrowGlacier fork
	ArrowGlacier uint `json:"arrowGlacier,omitempty"`
}

// Account is Ethereum account
type Account struct {
	// Address is account address
	Address shared.EthereumAddress `json:"address"`

	// Balance is account balance in wei
	Balance HexString `json:"balance,omitempty"`

	// Code is account contract byte code
	Code HexString `json:"code,omitempty"`

	// Storage is account contract storage as key value pair
	Storage map[HexString]HexString `json:"storage,omitempty"`
}

'''
'''--- apis/ethereum/v1alpha1/genesis_defaulting.go ---
package v1alpha1

// Default defaults genesis block parameters
func (g *Genesis) Default() {
	if g.Coinbase == "" {
		g.Coinbase = DefaultCoinbase
	}

	if g.Difficulty == "" {
		g.Difficulty = DefaultDifficulty
	}

	if g.Forks == nil {
		g.Forks = &Forks{}
	}

	if g.MixHash == "" {
		g.MixHash = DefaultMixHash
	}

	if g.GasLimit == "" {
		g.GasLimit = DefaultGasLimit
	}

	if g.Nonce == "" {
		g.Nonce = DefaultNonce
	}

	if g.Timestamp == "" {
		g.Timestamp = DefaultTimestamp
	}

	if g.Clique != nil {
		if g.Clique.BlockPeriod == 0 {
			g.Clique.BlockPeriod = DefaultCliqueBlockPeriod
		}
		if g.Clique.EpochLength == 0 {
			g.Clique.EpochLength = DefaultCliqueEpochLength
		}
	}

	if g.IBFT2 != nil {
		if g.IBFT2.BlockPeriod == 0 {
			g.IBFT2.BlockPeriod = DefaultIBFT2BlockPeriod
		}
		if g.IBFT2.EpochLength == 0 {
			g.IBFT2.EpochLength = DefaultIBFT2EpochLength
		}
		if g.IBFT2.RequestTimeout == 0 {
			g.IBFT2.RequestTimeout = DefaultIBFT2RequestTimeout
		}
		if g.IBFT2.MessageQueueLimit == 0 {
			g.IBFT2.MessageQueueLimit = DefaultIBFT2MessageQueueLimit
		}
		if g.IBFT2.DuplicateMessageLimit == 0 {
			g.IBFT2.DuplicateMessageLimit = DefaultIBFT2DuplicateMessageLimit
		}
		if g.IBFT2.FutureMessagesLimit == 0 {
			g.IBFT2.FutureMessagesLimit = DefaultIBFT2FutureMessagesLimit
		}
		if g.IBFT2.FutureMessagesMaxDistance == 0 {
			g.IBFT2.FutureMessagesMaxDistance = DefaultIBFT2FutureMessagesMaxDistance
		}
	}
}

'''
'''--- apis/ethereum/v1alpha1/genesis_validation.go ---
package v1alpha1

import (
	"fmt"
	"math/big"
	"reflect"
	"sort"
	"strings"

	"k8s.io/apimachinery/pkg/util/validation/field"
)

var (
	// ChainByID is public chains indexed by ID
	ChainByID = map[uint]string{
		1:        MainNetwork,
		3:        RopstenNetwork,
		4:        RinkebyNetwork,
		5:        GoerliNetwork,
		6:        KottiNetwork,
		61:       ClassicNetwork,
		63:       MordorNetwork,
		2018:     DevNetwork,
		11155111: SepoliaNetwork,
	}
)

// EnabledConsensusConfigs returns enabled consensus configs
func (g *Genesis) EnabledConsensusConfigs() []string {
	configs := map[string]bool{
		"ethash": g.Ethash != nil,
		"clique": g.Clique != nil,
		"ibft2":  g.IBFT2 != nil,
	}

	enabledConfigs := []string{}

	for consensus, enabled := range configs {
		if enabled {
			enabledConfigs = append(enabledConfigs, consensus)
		}
	}

	return enabledConfigs
}

// ReservedAccountIsUsed returns true if reserved account is used
// reserved accounts are accounts from 0x00...01 to 0x00...ff (1 to 256)
// reserved accounts are used for precompiles
func (g *Genesis) ReservedAccountIsUsed() (bool, string) {
	// space of reserved addresses
	space := new(big.Int)
	space.SetInt64(256)

	for _, account := range g.Accounts {
		address := string(account.Address)
		i := new(big.Int)
		i.SetString(address[2:], 16)
		// address must be outside (with greater int value) reserved space
		if i.Cmp(space) != 1 {
			return true, address
		}
	}
	return false, ""
}

// validate validates network genesis block spec
func (g *Genesis) validate() field.ErrorList {

	var allErrors field.ErrorList

	// validate accounts from 0x00...01 to 0x00...ff are reserved
	if used, address := g.ReservedAccountIsUsed(); used {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("accounts"), address, "reserved account is used")
		allErrors = append(allErrors, err)
	}

	// validate consensus config (ethash, clique, ibft2) is not missing
	// validate only one consensus configuration can be set
	// TODO: update this validation after suporting new consensus algorithm
	configs := g.EnabledConsensusConfigs()
	if len(configs) == 0 {
		err := field.Invalid(field.NewPath("spec").Child("genesis"), "", "consensus configuration (ethash, clique, or ibft2) is missing")
		allErrors = append(allErrors, err)
	} else if len(configs) > 1 {
		sort.Strings(configs)
		err := field.Invalid(field.NewPath("spec").Child("genesis"), "", fmt.Sprintf("multiple consensus configurations (%s) are enabled", strings.Join(configs, ", ")))
		allErrors = append(allErrors, err)
	}

	// don't use existing network chain id
	if chain := ChainByID[g.ChainID]; chain != "" {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("chainId"), fmt.Sprintf("%d", g.ChainID), fmt.Sprintf("can't use chain id of %s network to avoid tx replay", chain))
		allErrors = append(allErrors, err)
	}

	// validate forks order
	allErrors = append(allErrors, g.ValidateForksOrder()...)
	return allErrors
}

// ValidateForksOrder validates that forks are in correct order
func (g *Genesis) ValidateForksOrder() field.ErrorList {
	var orderErrors field.ErrorList
	forks := g.Forks

	forkNames := []string{
		"homestead",
		"eip150",
		"eip155",
		"eip155",
		"byzantium",
		"constantinople",
		"petersburg",
		"istanbul",
		"muirglacier",
		"berlin",
		"london",
		"arrowglacier",
	}

	// milestones at the correct order
	milestones := []uint{
		forks.Homestead,
		forks.EIP150,
		forks.EIP155,
		forks.EIP155,
		forks.Byzantium,
		forks.Constantinople,
		forks.Petersburg,
		forks.Istanbul,
		forks.MuirGlacier,
		forks.Berlin,
		forks.London,
		forks.ArrowGlacier,
	}

	for i := 1; i < len(milestones); i++ {
		if milestones[i] < milestones[i-1] {
			path := field.NewPath("spec").Child("genesis").Child("forks").Child(forkNames[i])
			msg := fmt.Sprintf("Fork %s can't be activated (at block %d) before fork %s (at block %d)", forkNames[i], milestones[i], forkNames[i-1], milestones[i-1])
			orderErrors = append(orderErrors, field.Invalid(path, fmt.Sprintf("%d", milestones[i]), msg))
		}
	}

	return orderErrors

}

// ValidateCreate validates genesis block during node creation
func (g *Genesis) ValidateCreate() field.ErrorList {
	var allErrors field.ErrorList

	allErrors = append(allErrors, g.validate()...)

	return allErrors
}

func (g *Genesis) ValidateUpdate(oldGenesis *Genesis) field.ErrorList {
	var allErrors field.ErrorList

	if g.Coinbase != oldGenesis.Coinbase {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("coinbase"), g.Coinbase, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if g.Difficulty != oldGenesis.Difficulty {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("difficulty"), g.Difficulty, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if g.MixHash != oldGenesis.MixHash {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("mixHash"), g.MixHash, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if g.GasLimit != oldGenesis.GasLimit {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("gasLimit"), g.GasLimit, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if g.Nonce != oldGenesis.Nonce {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("nonce"), g.Nonce, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if g.Timestamp != oldGenesis.Timestamp {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("timestamp"), g.Timestamp, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if !reflect.DeepEqual(g.Accounts, oldGenesis.Accounts) {
		err := field.Invalid(field.NewPath("spec").Child("genesis").Child("accounts"), "", "field is immutable")
		allErrors = append(allErrors, err)
	}

	allErrors = append(allErrors, g.validate()...)

	return allErrors
}

'''
'''--- apis/ethereum/v1alpha1/genesis_validation_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Genesis Block validation", func() {

	createCases := []struct {
		Title   string
		Genesis *Genesis
		Errors  field.ErrorList
	}{
		{
			Title: "using mainnet chain id",
			Genesis: &Genesis{
				ChainID:   1,
				NetworkID: 55555,
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.chainId",
					BadValue: "1",
					Detail:   "can't use chain id of mainnet network to avoid tx replay",
				},
			},
		},
		{
			Title: "bad fork activation order",
			Genesis: &Genesis{
				ChainID:   55555,
				NetworkID: 55555,
				Ethash:    &Ethash{},
				Forks: &Forks{
					EIP150:    1,
					Homestead: 2,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.forks.eip150",
					BadValue: "1",
					Detail:   "Fork eip150 can't be activated (at block 1) before fork homestead (at block 2)",
				},
			},
		},
		{
			Title: "consensus configuration is missing",
			Genesis: &Genesis{
				ChainID:   4444,
				NetworkID: 4444,
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis",
					BadValue: "",
					Detail:   "consensus configuration (ethash, clique, or ibft2) is missing",
				},
			},
		},
		{
			Title: "multiple consensus configurations are used",
			Genesis: &Genesis{
				ChainID:   4444,
				NetworkID: 4444,
				Ethash:    &Ethash{},
				Clique:    &Clique{},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis",
					BadValue: "",
					Detail:   "multiple consensus configurations (clique, ethash) are enabled",
				},
			},
		},
		{
			Title: "reserved account is used",
			Genesis: &Genesis{
				ChainID:   4444,
				NetworkID: 4444,
				Ethash:    &Ethash{},
				Accounts: []Account{
					{
						Address: shared.EthereumAddress("0x0000000000000000000000000000000000000015"),
						Balance: HexString("0xffffff"),
					},
				},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.accounts",
					BadValue: "0x0000000000000000000000000000000000000015",
					Detail:   "reserved account is used",
				},
			},
		},
	}

	updateCases := []struct {
		Title      string
		OldGenesis *Genesis
		NewGenesis *Genesis
		Errors     field.ErrorList
	}{
		{
			Title: "updating coinbase",
			OldGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			NewGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Coinbase:  "0x0000000000000000000000000000000000000001",
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.coinbase",
					BadValue: shared.EthereumAddress("0x0000000000000000000000000000000000000001"),
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "updating difficulty",
			OldGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			NewGenesis: &Genesis{
				NetworkID:  55555,
				ChainID:    55555,
				Difficulty: "0xffff",
				Ethash:     &Ethash{},
				Forks:      &Forks{},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.difficulty",
					BadValue: HexString("0xffff"),
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "updating mixHash",
			OldGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			NewGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				MixHash:   Hash("0x00000000000000000000000000000000000000000000000000000000000000ff"),
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.mixHash",
					BadValue: Hash("0x00000000000000000000000000000000000000000000000000000000000000ff"),
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "updating gasLimit",
			OldGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			NewGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				GasLimit:  HexString("0x47bfff"),
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.gasLimit",
					BadValue: HexString("0x47bfff"),
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "updating nonce",
			OldGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			NewGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Nonce:     HexString("0x1"),
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.nonce",
					BadValue: HexString("0x1"),
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "updating timestamp",
			OldGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			NewGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Timestamp: HexString("0x1"),
				Ethash:    &Ethash{},
				Forks:     &Forks{},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.timestamp",
					BadValue: HexString("0x1"),
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "updating accounts",
			OldGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Ethash:    &Ethash{},
				Forks:     &Forks{},
				Accounts: []Account{
					{
						Address: shared.EthereumAddress("0xB1368D309179D8E7f25B34398e4cF9D9dEFdC75C"),
						Balance: HexString("0xffffff"),
					},
				},
			},
			NewGenesis: &Genesis{
				NetworkID: 55555,
				ChainID:   55555,
				Ethash:    &Ethash{},
				Forks:     &Forks{},
				Accounts: []Account{
					{
						Address: shared.EthereumAddress("0xB1368D309179D8E7f25B34398e4cF9D9dEFdC75C"),
						Balance: HexString("0x111111"), // change account balance
					},
				},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis.accounts",
					BadValue: "",
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating genesis", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Genesis.Default()

					err := cc.Genesis.ValidateCreate()

					Expect(err).To(ContainElements(cc.Errors))
				})
			}()
		}
	})

	Context("While updating genesis", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldGenesis.Default()
					cc.NewGenesis.Default()

					err := cc.NewGenesis.ValidateUpdate(cc.OldGenesis)

					Expect(err).To(ContainElements(cc.Errors))
				})
			}()
		}
	})

})

'''
'''--- apis/ethereum/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the ethereum v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=ethereum.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "ethereum.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/ethereum/v1alpha1/network.go ---
package v1alpha1

const (
	// MainNetwork is ethereum main network
	MainNetwork = "mainnet"
	// RopstenNetwork is ropsten pos network
	RopstenNetwork = "ropsten"
	// RinkebyNetwork is rinkeby poa network
	RinkebyNetwork = "rinkeby"
	// GoerliNetwork is goerli pos cross-client network
	GoerliNetwork = "goerli"
	// SepoliaNetwork is sepolia pos network
	SepoliaNetwork = "sepolia"
	// XDaiNetwork is xdai pos network
	XDaiNetwork = "xdai"
	// KottiNetwork is kotti poa ethereum classic test network
	KottiNetwork = "kotti"
	// ClassicNetwork is ethereum classic network
	ClassicNetwork = "classic"
	// MordorNetwork is mordon poe ethereum classic test network
	MordorNetwork = "mordor"
	// DevNetwork is local development network
	DevNetwork = "dev"
)

// HexString is String in hexadecial format
// +kubebuilder:validation:Pattern="^0[xX][0-9a-fA-F]+$"
type HexString string

// Hash is KECCAK-256 hash
// +kubebuilder:validation:Pattern="^0[xX][0-9a-fA-F]{64}$"
type Hash string

'''
'''--- apis/ethereum/v1alpha1/node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NodeStatus defines the observed state of Node
type NodeStatus struct {
	// Consensus is network consensus algorithm
	Consensus string `json:"consensus,omitempty"`
	// Network is the network this node is joining
	Network string `json:"network,omitempty"`
	// EnodeURL is the node URL
	EnodeURL string `json:"enodeURL,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Node is the Schema for the nodes API
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".spec.client"
// +kubebuilder:printcolumn:name="Consensus",type=string,JSONPath=".status.consensus"
// +kubebuilder:printcolumn:name="Network",type=string,JSONPath=".status.network"
// +kubebuilder:printcolumn:name="enodeURL",type=string,JSONPath=".status.enodeURL",priority=10
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

// NodeSpec is the specification of the node
type NodeSpec struct {

	// Image is Ethereum node client image
	Image string `json:"image,omitempty"`

	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`

	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`

	// Genesis is genesis block configuration
	Genesis *Genesis `json:"genesis,omitempty"`

	// Network specifies the network to join
	Network string `json:"network,omitempty"`

	// Client is ethereum client running on the node
	Client EthereumClient `json:"client"`

	// import is account to import
	Import *ImportedAccount `json:"import,omitempty"`

	// Bootnodes is set of ethereum node URLS for p2p discovery bootstrap
	// +listType=set
	Bootnodes []Enode `json:"bootnodes,omitempty"`

	// NodePrivateKeySecretName is the secret name holding node private key
	NodePrivateKeySecretName string `json:"nodePrivateKeySecretName,omitempty"`

	// StaticNodes is a set of ethereum nodes to maintain connection to
	// +listType=set
	StaticNodes []Enode `json:"staticNodes,omitempty"`

	// P2PPort is port used for peer to peer communication
	P2PPort uint `json:"p2pPort,omitempty"`

	// SyncMode is the node synchronization mode
	SyncMode SynchronizationMode `json:"syncMode,omitempty"`

	// Miner is whether node is mining/validating blocks or no
	Miner bool `json:"miner,omitempty"`

	// Logging is logging verboisty level
	// +kubebuilder:validation:Enum=off;fatal;error;warn;info;debug;trace;all
	Logging shared.VerbosityLevel `json:"logging,omitempty"`

	// Coinbase is the account to which mining rewards are paid
	Coinbase shared.EthereumAddress `json:"coinbase,omitempty"`

	// Hosts is a list of hostnames to to whitelist for RPC access
	// +listType=set
	Hosts []string `json:"hosts,omitempty"`

	// CORSDomains is the domains from which to accept cross origin requests
	// +listType=set
	CORSDomains []string `json:"corsDomains,omitempty"`

	// Engine enables authenticated Engine RPC APIs
	Engine bool `json:"engine,omitempty"`

	// EnginePort is engine authenticated RPC APIs port
	EnginePort uint `json:"enginePort,omitempty"`

	// JWTSecretName is kubernetes secret name holding JWT secret
	JWTSecretName string `json:"jwtSecretName,omitempty"`

	// RPC is whether HTTP-RPC server is enabled or not
	RPC bool `json:"rpc,omitempty"`

	// RPCPort is HTTP-RPC server listening port
	RPCPort uint `json:"rpcPort,omitempty"`

	// RPCAPI is a list of rpc services to enable
	// +listType=set
	RPCAPI []API `json:"rpcAPI,omitempty"`

	// WS is whether web socket server is enabled or not
	WS bool `json:"ws,omitempty"`

	// WSPort is the web socket server listening port
	WSPort uint `json:"wsPort,omitempty"`

	// WSAPI is a list of WS services to enable
	// +listType=set
	WSAPI []API `json:"wsAPI,omitempty"`

	// GraphQL is whether GraphQL server is enabled or not
	GraphQL bool `json:"graphql,omitempty"`

	// GraphQLPort is the GraphQL server listening port
	GraphQLPort uint `json:"graphqlPort,omitempty"`

	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// Enode is ethereum node url
type Enode string

// SynchronizationMode is the node synchronization mode
// +kubebuilder:validation:Enum=fast;full;light;snap
type SynchronizationMode string

const (
	//SnapSynchronization is the snap synchronization mode
	SnapSynchronization SynchronizationMode = "snap"

	//FastSynchronization is the fast synchronization mode
	FastSynchronization SynchronizationMode = "fast"

	//LightSynchronization is the light synchronization mode
	LightSynchronization SynchronizationMode = "light"

	//FullSynchronization is full archival synchronization mode
	FullSynchronization SynchronizationMode = "full"
)

// API is RPC API to be exposed by RPC or web socket server
// +kubebuilder:validation:Enum=admin;clique;debug;eea;eth;ibft;miner;net;perm;plugins;priv;txpool;web3
type API string

const (
	// AdminAPI is administration API
	AdminAPI API = "admin"

	// CliqueAPI is clique (Proof of Authority consensus) API
	CliqueAPI API = "clique"

	// DebugAPI is debugging API
	DebugAPI API = "debug"

	// EEAAPI is EEA (Enterprise Ethereum Alliance) API
	EEAAPI API = "eea"

	// ETHAPI is ethereum API
	ETHAPI API = "eth"

	// IBFTAPI is IBFT consensus API
	IBFTAPI API = "ibft"

	// MinerAPI is miner API
	MinerAPI API = "miner"

	// NetworkAPI is network API
	NetworkAPI API = "net"

	// PermissionAPI is permission API
	PermissionAPI API = "perm"

	// PluginsAPI is plugins API
	PluginsAPI API = "plugins"

	// PrivacyAPI is privacy API
	PrivacyAPI API = "privacy"

	// TransactionPoolAPI is transaction pool API
	TransactionPoolAPI API = "txpool"

	// Web3API is web3 API
	Web3API API = "web3"
)

// EthereumClient is the ethereum client running on a given node
// +kubebuilder:validation:Enum=besu;geth;nethermind
type EthereumClient string

func (e EthereumClient) SupportsVerbosityLevel(level shared.VerbosityLevel) bool {
	switch e {
	case BesuClient:
		switch level {
		case shared.NoLogs,
			shared.FatalLogs,
			shared.ErrorLogs,
			shared.WarnLogs,
			shared.InfoLogs,
			shared.DebugLogs,
			shared.TraceLogs,
			shared.AllLogs:
			return true
		}
	case GethClient:
		switch level {
		case shared.NoLogs,
			shared.ErrorLogs,
			shared.WarnLogs,
			shared.InfoLogs,
			shared.DebugLogs,
			shared.AllLogs:
			return true
		}
	case NethermindClient:
		switch level {
		case shared.ErrorLogs,
			shared.WarnLogs,
			shared.InfoLogs,
			shared.DebugLogs,
			shared.TraceLogs:
			return true
		}

	}
	return false
}

const (
	// BesuClient is hyperledger besu ethereum client
	BesuClient EthereumClient = "besu"
	// GethClient is go ethereum client
	GethClient EthereumClient = "geth"
	// NethermindClient is Nethermind .NET client
	NethermindClient EthereumClient = "nethermind"
)

// ImportedAccount is account derived from private key
type ImportedAccount struct {
	// PrivateKeySecretName is the secret name holding account private key
	PrivateKeySecretName string `json:"privateKeySecretName"`
	// PasswordSecretName is the secret holding password used to encrypt account private key
	PasswordSecretName string `json:"passwordSecretName"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/ethereum/v1alpha1/node_defaulting_webhook.go ---
package v1alpha1

import (
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-ethereum-kotal-io-v1alpha1-node,mutating=true,failurePolicy=fail,groups=ethereum.kotal.io,resources=nodes,verbs=create;update,versions=v1alpha1,name=mutate-ethereum-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Node{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (n *Node) Default() {
	defaultAPIs := []API{Web3API, ETHAPI, NetworkAPI}
	client := n.Spec.Client
	nethermindNode := client == NethermindClient

	if n.Spec.Image == "" {
		var image string

		switch client {
		case BesuClient:
			image = DefaultBesuImage
		case GethClient:
			image = DefaultGethImage
		case NethermindClient:
			image = DefaultNethermindImage
		}

		n.Spec.Image = image
	}

	if n.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		n.Spec.Replicas = &replicas
	}

	// default genesis block
	if n.Spec.Genesis != nil {
		n.Spec.Genesis.Default()
	}

	if n.Spec.P2PPort == 0 {
		n.Spec.P2PPort = DefaultP2PPort
	}

	if n.Spec.SyncMode == "" {
		// public network
		if n.Spec.Genesis == nil {
			if n.Spec.Client == GethClient {
				n.Spec.SyncMode = SnapSynchronization
			} else {
				n.Spec.SyncMode = FastSynchronization
			}
		} else {
			n.Spec.SyncMode = FullSynchronization
		}
	}

	// must be called after defaulting sync mode because it's depending on its value
	n.DefaultNodeResources()

	// nethermind doesn't support host whitelisting
	if len(n.Spec.Hosts) == 0 && !nethermindNode {
		n.Spec.Hosts = DefaultOrigins
	}

	// nethermind doesn't support cors domains
	if len(n.Spec.CORSDomains) == 0 && !nethermindNode {
		n.Spec.CORSDomains = DefaultOrigins
	}

	if n.Spec.EnginePort == 0 {
		n.Spec.EnginePort = DefaultEngineRPCPort
	}

	if n.Spec.RPCPort == 0 {
		n.Spec.RPCPort = DefaultRPCPort
	}

	if len(n.Spec.RPCAPI) == 0 {
		n.Spec.RPCAPI = defaultAPIs
	}

	if n.Spec.WSPort == 0 {
		n.Spec.WSPort = DefaultWSPort
	}

	if len(n.Spec.WSAPI) == 0 {
		n.Spec.WSAPI = defaultAPIs
	}

	if n.Spec.GraphQLPort == 0 {
		n.Spec.GraphQLPort = DefaultGraphQLPort
	}

	if n.Spec.Logging == "" {
		n.Spec.Logging = DefaultLogging
	}

}

// DefaultNodeResources defaults node cpu, memory and storage resources
func (n *Node) DefaultNodeResources() {
	var cpu, cpuLimit, memory, memoryLimit, storage string
	privateNetwork := n.Spec.Genesis != nil
	network := n.Spec.Network

	if n.Spec.Resources.CPU == "" {
		if privateNetwork {
			cpu = DefaultPrivateNetworkNodeCPURequest
		} else {
			cpu = DefaultPublicNetworkNodeCPURequest
		}

		n.Spec.Resources.CPU = cpu
	}

	if n.Spec.Resources.CPULimit == "" {
		if privateNetwork {
			cpuLimit = DefaultPrivateNetworkNodeCPULimit
		} else {
			cpuLimit = DefaultPublicNetworkNodeCPULimit
		}

		n.Spec.Resources.CPULimit = cpuLimit
	}

	if n.Spec.Resources.Memory == "" {
		if privateNetwork {
			memory = DefaultPrivateNetworkNodeMemoryRequest
		} else {
			memory = DefaultPublicNetworkNodeMemoryRequest
		}

		n.Spec.Resources.Memory = memory
	}

	if n.Spec.Resources.MemoryLimit == "" {
		if privateNetwork {
			memoryLimit = DefaultPrivateNetworkNodeMemoryLimit
		} else {
			memoryLimit = DefaultPublicNetworkNodeMemoryLimit
		}

		n.Spec.Resources.MemoryLimit = memoryLimit
	}

	if n.Spec.Resources.Storage == "" {
		if privateNetwork {
			storage = DefaultPrivateNetworkNodeStorageRequest
		} else if network == MainNetwork && n.Spec.SyncMode == FastSynchronization {
			storage = DefaultMainNetworkFastNodeStorageRequest
		} else if network == MainNetwork && n.Spec.SyncMode == FullSynchronization {
			storage = DefaultMainNetworkFullNodeStorageRequest
		} else {
			storage = DefaultTestNetworkStorageRequest
		}

		n.Spec.Resources.Storage = storage
	}

}

'''
'''--- apis/ethereum/v1alpha1/node_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Ethereum defaulting", func() {
	It("Should default nodes joining mainnet", func() {
		node1 := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "node-1",
			},
			Spec: NodeSpec{
				Client:  BesuClient,
				Network: MainNetwork,
				Engine:  true,
			},
		}

		node2 := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "node-2",
			},
			Spec: NodeSpec{
				Client:   NethermindClient,
				Network:  MainNetwork,
				SyncMode: FullSynchronization,
			},
		}

		node1.Default()
		node2.Default()

		// node1 defaulting
		Expect(node1.Spec.Image).To(Equal(DefaultBesuImage))
		Expect(*node1.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node1.Spec.EnginePort).To(Equal(DefaultEngineRPCPort))
		Expect(node1.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node1.Spec.SyncMode).To(Equal(DefaultPublicNetworkSyncMode))
		Expect(node1.Spec.Resources.CPU).To(Equal(DefaultPublicNetworkNodeCPURequest))
		Expect(node1.Spec.Resources.CPULimit).To(Equal(DefaultPublicNetworkNodeCPULimit))
		Expect(node1.Spec.Resources.Memory).To(Equal(DefaultPublicNetworkNodeMemoryRequest))
		Expect(node1.Spec.Resources.MemoryLimit).To(Equal(DefaultPublicNetworkNodeMemoryLimit))
		Expect(node1.Spec.Resources.Storage).To(Equal(DefaultMainNetworkFastNodeStorageRequest))
		Expect(node1.Spec.Logging).To(Equal(DefaultLogging))
		// node2 defaulting
		Expect(node2.Spec.Image).To(Equal(DefaultNethermindImage))
		Expect(*node2.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node2.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node2.Spec.SyncMode).To(Equal(FullSynchronization))
		Expect(node2.Spec.Resources.CPU).To(Equal(DefaultPublicNetworkNodeCPURequest))
		Expect(node2.Spec.Resources.CPULimit).To(Equal(DefaultPublicNetworkNodeCPULimit))
		Expect(node2.Spec.Resources.Memory).To(Equal(DefaultPublicNetworkNodeMemoryRequest))
		Expect(node2.Spec.Resources.MemoryLimit).To(Equal(DefaultPublicNetworkNodeMemoryLimit))
		Expect(node2.Spec.Resources.Storage).To(Equal(DefaultMainNetworkFullNodeStorageRequest))
		Expect(node2.Spec.Logging).To(Equal(DefaultLogging))

	})

	It("Should default nodes joining goerli", func() {

		node := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "node-1",
			},
			Spec: NodeSpec{
				Client:  BesuClient,
				Network: GoerliNetwork,
			},
		}

		node.Default()
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.SyncMode).To(Equal(DefaultPublicNetworkSyncMode))
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultPublicNetworkNodeCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultPublicNetworkNodeCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultPublicNetworkNodeMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultPublicNetworkNodeMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultTestNetworkStorageRequest))
		Expect(node.Spec.Logging).To(Equal(DefaultLogging))
	})

	It("Should default geth node joining goerli", func() {

		node := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "node-1",
			},
			Spec: NodeSpec{
				Client:  GethClient,
				Network: GoerliNetwork,
			},
		}

		node.Default()
		Expect(node.Spec.Image).To(Equal(DefaultGethImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.SyncMode).To(Equal(SnapSynchronization))
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultPublicNetworkNodeCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultPublicNetworkNodeCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultPublicNetworkNodeMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultPublicNetworkNodeMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultTestNetworkStorageRequest))
		Expect(node.Spec.Logging).To(Equal(DefaultLogging))
	})

	It("Should default nodes joining network pow consensus", func() {
		node := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "node-1",
			},
			Spec: NodeSpec{
				Genesis: &Genesis{
					ChainID:   55555,
					NetworkID: 55555,
					Ethash:    &Ethash{},
				},
				Client: BesuClient,
			},
		}

		node.Default()
		var block0 uint = 0
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.SyncMode).To(Equal(DefaultPrivateNetworkSyncMode))
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultPrivateNetworkNodeCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultPrivateNetworkNodeCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultPrivateNetworkNodeMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultPrivateNetworkNodeMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultPrivateNetworkNodeStorageRequest))
		Expect(node.Spec.Logging).To(Equal(DefaultLogging))
		// genesis defaulting
		Expect(node.Spec.Genesis.Coinbase).To(Equal(DefaultCoinbase))
		Expect(node.Spec.Genesis.MixHash).To(Equal(DefaultMixHash))
		Expect(node.Spec.Genesis.Difficulty).To(Equal(DefaultDifficulty))
		Expect(node.Spec.Genesis.GasLimit).To(Equal(DefaultGasLimit))
		Expect(node.Spec.Genesis.Nonce).To(Equal(DefaultNonce))
		Expect(node.Spec.Genesis.Timestamp).To(Equal(DefaultTimestamp))
		// forks defaulting
		Expect(node.Spec.Genesis.Forks.Homestead).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.DAO).To(BeNil())
		Expect(node.Spec.Genesis.Forks.EIP150).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.EIP155).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.EIP158).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Byzantium).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Constantinople).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Petersburg).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Istanbul).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.MuirGlacier).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Berlin).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.London).To(Equal(block0))
	})

	It("Should default nodes joining network with poa consensus", func() {
		node := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "node-1",
			},
			Spec: NodeSpec{
				Genesis: &Genesis{
					ChainID:   55555,
					NetworkID: 55555,
					Clique:    &Clique{},
				},
				Client: BesuClient,
				RPC:    true,
			},
		}

		node.Default()
		var block0 uint = 0
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.SyncMode).To(Equal(DefaultPrivateNetworkSyncMode))
		Expect(node.Spec.Hosts).To(Equal(DefaultOrigins))
		Expect(node.Spec.CORSDomains).To(Equal(DefaultOrigins))
		Expect(node.Spec.RPCPort).To(Equal(DefaultRPCPort))
		Expect(node.Spec.RPCAPI).To(Equal(DefaultAPIs))
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultPrivateNetworkNodeCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultPrivateNetworkNodeCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultPrivateNetworkNodeMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultPrivateNetworkNodeMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultPrivateNetworkNodeStorageRequest))
		Expect(node.Spec.Logging).To(Equal(DefaultLogging))
		// genesis defaulting
		Expect(node.Spec.Genesis.Coinbase).To(Equal(DefaultCoinbase))
		Expect(node.Spec.Genesis.MixHash).To(Equal(DefaultMixHash))
		Expect(node.Spec.Genesis.Difficulty).To(Equal(DefaultDifficulty))
		Expect(node.Spec.Genesis.GasLimit).To(Equal(DefaultGasLimit))
		Expect(node.Spec.Genesis.Nonce).To(Equal(DefaultNonce))
		Expect(node.Spec.Genesis.Timestamp).To(Equal(DefaultTimestamp))
		// forks defaulting
		Expect(node.Spec.Genesis.Forks.Homestead).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.DAO).To(BeNil())
		Expect(node.Spec.Genesis.Forks.EIP150).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.EIP155).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.EIP158).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Byzantium).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Constantinople).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Petersburg).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Istanbul).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.MuirGlacier).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Berlin).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.London).To(Equal(block0))
		// clique defaulting
		Expect(node.Spec.Genesis.Clique.BlockPeriod).To(Equal(DefaultCliqueBlockPeriod))
		Expect(node.Spec.Genesis.Clique.EpochLength).To(Equal(DefaultCliqueEpochLength))
	})

	It("Should default nodes joining network with ibft2 consensus", func() {
		node := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "node-1",
			},
			Spec: NodeSpec{
				Genesis: &Genesis{
					ChainID:   55555,
					NetworkID: 55555,
					IBFT2:     &IBFT2{},
				},
				Client:  BesuClient,
				WS:      true,
				GraphQL: true,
			},
		}

		node.Default()
		var block0 uint = 0
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.SyncMode).To(Equal(DefaultPrivateNetworkSyncMode))
		Expect(node.Spec.Hosts).To(Equal(DefaultOrigins))
		Expect(node.Spec.CORSDomains).To(Equal(DefaultOrigins))
		Expect(node.Spec.WSPort).To(Equal(DefaultWSPort))
		Expect(node.Spec.WSAPI).To(Equal(DefaultAPIs))
		Expect(node.Spec.GraphQLPort).To(Equal(DefaultGraphQLPort))
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultPrivateNetworkNodeCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultPrivateNetworkNodeCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultPrivateNetworkNodeMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultPrivateNetworkNodeMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultPrivateNetworkNodeStorageRequest))
		Expect(node.Spec.Logging).To(Equal(DefaultLogging))
		// genesis defaulting
		Expect(node.Spec.Genesis.Coinbase).To(Equal(DefaultCoinbase))
		Expect(node.Spec.Genesis.MixHash).To(Equal(DefaultMixHash))
		Expect(node.Spec.Genesis.Difficulty).To(Equal(DefaultDifficulty))
		Expect(node.Spec.Genesis.GasLimit).To(Equal(DefaultGasLimit))
		Expect(node.Spec.Genesis.Nonce).To(Equal(DefaultNonce))
		Expect(node.Spec.Genesis.Timestamp).To(Equal(DefaultTimestamp))
		// forks defaulting
		Expect(node.Spec.Genesis.Forks.Homestead).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.DAO).To(BeNil())
		Expect(node.Spec.Genesis.Forks.EIP150).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.EIP155).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.EIP158).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Byzantium).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Constantinople).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Petersburg).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Istanbul).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.MuirGlacier).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.Berlin).To(Equal(block0))
		Expect(node.Spec.Genesis.Forks.London).To(Equal(block0))
		// IBFT2 defaulting
		Expect(node.Spec.Genesis.IBFT2.BlockPeriod).To(Equal(DefaultIBFT2BlockPeriod))
		Expect(node.Spec.Genesis.IBFT2.EpochLength).To(Equal(DefaultIBFT2EpochLength))
		Expect(node.Spec.Genesis.IBFT2.RequestTimeout).To(Equal(DefaultIBFT2RequestTimeout))
		Expect(node.Spec.Genesis.IBFT2.MessageQueueLimit).To(Equal(DefaultIBFT2MessageQueueLimit))
		Expect(node.Spec.Genesis.IBFT2.DuplicateMessageLimit).To(Equal(DefaultIBFT2DuplicateMessageLimit))
		Expect(node.Spec.Genesis.IBFT2.FutureMessagesLimit).To(Equal(DefaultIBFT2FutureMessagesLimit))
		Expect(node.Spec.Genesis.IBFT2.FutureMessagesMaxDistance).To(Equal(DefaultIBFT2FutureMessagesMaxDistance))
	})
})

'''
'''--- apis/ethereum/v1alpha1/node_validation_webhook.go ---
package v1alpha1

import (
	"fmt"

	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-ethereum-kotal-io-v1alpha1-node,mutating=false,failurePolicy=fail,groups=ethereum.kotal.io,resources=nodes,versions=v1alpha1,name=validate-ethereum-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Node{}

// validate validates a node with a given path
func (n *Node) validate() field.ErrorList {
	var nodeErrors field.ErrorList

	privateNetwork := n.Spec.Genesis != nil

	path := field.NewPath("spec")

	// network: can't specifiy genesis while joining existing network
	if n.Spec.Network != "" && n.Spec.Genesis != nil {
		err := field.Invalid(field.NewPath("spec").Child("network"), n.Spec.Network, "must be none if spec.genesis is specified")
		nodeErrors = append(nodeErrors, err)
	}

	// genesis: must specify genesis if there's no network to join
	if n.Spec.Network == "" && n.Spec.Genesis == nil {
		err := field.Invalid(field.NewPath("spec").Child("genesis"), "", "must be specified if spec.network is none")
		nodeErrors = append(nodeErrors, err)
	}

	if !n.Spec.Client.SupportsVerbosityLevel(n.Spec.Logging) {
		err := field.Invalid(path.Child("logging"), n.Spec.Logging, fmt.Sprintf("not supported by client %s", n.Spec.Client))
		nodeErrors = append(nodeErrors, err)
	}

	// validate coinbase is provided if node is miner
	if n.Spec.Miner && n.Spec.Coinbase == "" {
		err := field.Invalid(path.Child("coinbase"), "", "must provide coinbase if miner is true")
		nodeErrors = append(nodeErrors, err)
	}

	// validate jwtSecretName is provided if engine is enabled
	if n.Spec.Engine && n.Spec.JWTSecretName == "" {
		err := field.Invalid(path.Child("jwtSecretName"), "", "must provide jwtSecretName if engine is true")
		nodeErrors = append(nodeErrors, err)
	}

	// validate coinbase can't be set if miner is not set explicitly as true
	if n.Spec.Coinbase != "" && !n.Spec.Miner {
		err := field.Invalid(path.Child("miner"), false, "must set miner to true if coinbase is provided")
		nodeErrors = append(nodeErrors, err)
	}

	// validate that besu doesn't support importing ethereum accounts
	// Netermind, go-ethereum, and OpenEthereum support importing accounts
	if n.Spec.Client == BesuClient && n.Spec.Import != nil {
		err := field.Invalid(path.Child("client"), n.Spec.Client, "client doesn't support importing accounts")
		nodeErrors = append(nodeErrors, err)
	}

	// validate rpc must be enabled if grapql is enabled and geth is used
	if n.Spec.Client == GethClient && n.Spec.GraphQL && !n.Spec.RPC {
		err := field.Invalid(path.Child("rpc"), n.Spec.RPC, "must enable rpc if client is geth and graphql is enabled")
		nodeErrors = append(nodeErrors, err)
	}

	// validate nethermind doesn't support GraphQL
	if n.Spec.GraphQL && n.Spec.Client == NethermindClient {
		err := field.Invalid(path.Child("client"), n.Spec.Client, "client doesn't support GraphQL")
		nodeErrors = append(nodeErrors, err)
	}

	// validate nethermind doesn't support hosts whitelisting
	if len(n.Spec.Hosts) > 0 && n.Spec.Client == NethermindClient {
		err := field.Invalid(path.Child("client"), n.Spec.Client, "client doesn't support hosts whitelisting")
		nodeErrors = append(nodeErrors, err)
	}

	// validate nethermind doesn't support CORS domains
	if len(n.Spec.CORSDomains) > 0 && n.Spec.Client == NethermindClient {
		err := field.Invalid(path.Child("client"), n.Spec.Client, "client doesn't support CORS domains")
		nodeErrors = append(nodeErrors, err)
	}

	// validate only geth client supports light sync mode
	if (n.Spec.SyncMode == LightSynchronization || n.Spec.SyncMode == SnapSynchronization) && n.Spec.Client != GethClient {
		err := field.Invalid(path.Child("syncMode"), n.Spec.SyncMode, fmt.Sprintf("not supported by client %s", n.Spec.Client))
		nodeErrors = append(nodeErrors, err)
	}

	// validate geth supports only pow and poa
	if privateNetwork && n.Spec.Genesis.IBFT2 != nil && n.Spec.Client != BesuClient {
		err := field.Invalid(path.Child("client"), n.Spec.Client, "client doesn't support ibft2 consensus")
		nodeErrors = append(nodeErrors, err)
	}

	// validate besu only support fixed difficulty ethash networks
	if privateNetwork && n.Spec.Genesis.Ethash != nil && n.Spec.Genesis.Ethash.FixedDifficulty != nil && n.Spec.Client != BesuClient {
		err := field.Invalid(path.Child("client"), n.Spec.Client, "client doesn't support fixed difficulty pow networks")
		nodeErrors = append(nodeErrors, err)
	}

	// validate account must be imported if coinbase is provided
	if n.Spec.Client != BesuClient && n.Spec.Coinbase != "" && n.Spec.Import == nil {
		err := field.Invalid(path.Child("import"), "", "must import coinbase account")
		nodeErrors = append(nodeErrors, err)
	}

	// validate rpc can't be enabled for node with imported account
	if n.Spec.Client != BesuClient && n.Spec.Import != nil && n.Spec.RPC {
		err := field.Invalid(path.Child("rpc"), n.Spec.RPC, "must be false if import is provided")
		nodeErrors = append(nodeErrors, err)
	}

	// validate ws can't be enabled for node with imported account
	if n.Spec.Client != BesuClient && n.Spec.Import != nil && n.Spec.WS {
		err := field.Invalid(path.Child("ws"), n.Spec.WS, "must be false if import is provided")
		nodeErrors = append(nodeErrors, err)
	}

	// validate graphql can't be enabled for node with imported account
	if n.Spec.Client != BesuClient && n.Spec.Import != nil && n.Spec.GraphQL {
		err := field.Invalid(path.Child("graphql"), n.Spec.GraphQL, "must be false if import is provided")
		nodeErrors = append(nodeErrors, err)
	}

	return nodeErrors
}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	nodelog.Info("validate create", "name", n.Name)

	allErrors = append(allErrors, n.validate()...)
	allErrors = append(allErrors, n.Spec.Resources.ValidateCreate()...)

	// validate genesis block
	if n.Spec.Genesis != nil {
		allErrors = append(allErrors, n.Spec.Genesis.ValidateCreate()...)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, n.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldNode := old.(*Node)

	nodelog.Info("validate update", "name", n.Name)

	if n.Spec.Client != oldNode.Spec.Client {
		err := field.Invalid(field.NewPath("spec").Child("client"), n.Spec.Client, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if oldNode.Spec.Network != n.Spec.Network {
		err := field.Invalid(field.NewPath("spec").Child("network"), n.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	// validate genesis block
	if oldNode.Spec.Genesis != nil {
		allErrors = append(allErrors, n.Spec.Genesis.ValidateUpdate(oldNode.Spec.Genesis)...)
	}

	allErrors = append(allErrors, n.validate()...)
	allErrors = append(allErrors, n.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, n.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", n.Name)

	return nil, nil
}

'''
'''--- apis/ethereum/v1alpha1/node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Ethereum node validation", func() {

	var (
		networkID       uint = 77777
		fixedDifficulty uint = 1500
		coinbase             = shared.EthereumAddress("0xd2c21213027cbf4d46c16b55fa98e5252b048706")
	)

	createCases := []struct {
		Title  string
		Node   *Node
		Errors field.ErrorList
	}{
		{
			Title: "node #2",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID: 444,
					},
					Client:  BesuClient,
					Network: GoerliNetwork,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: GoerliNetwork,
					Detail:   "must be none if spec.genesis is specified",
				},
			},
		},
		{
			Title: "node #3",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client: BesuClient,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.genesis",
					BadValue: "",
					Detail:   "must be specified if spec.network is none",
				},
			},
		},
		{
			Title: "node #10",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID: 55555,
					},
					Miner:  true,
					Client: BesuClient,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.coinbase",
					BadValue: "",
					Detail:   "must provide coinbase if miner is true",
				},
			},
		},
		{
			Title: "node #10",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Engine:  true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.jwtSecretName",
					BadValue: "",
					Detail:   "must provide jwtSecretName if engine is true",
				},
			},
		},
		{
			Title: "node #11",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID: 55555,
						IBFT2:   &IBFT2{},
					},
					Coinbase: shared.EthereumAddress("0x676aEda2E67D24eb304cFf75A5190824831E3399"),
					Client:   BesuClient,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.miner",
					BadValue: false,
					Detail:   "must set miner to true if coinbase is provided",
				},
			},
		},
		{
			Title: "node #16",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID:   55555,
						NetworkID: networkID,
						Ethash:    &Ethash{},
					},
					Client:   GethClient,
					Miner:    true,
					Coinbase: coinbase,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.import",
					BadValue: "",
					Detail:   "must import coinbase account",
				},
			},
		},
		{
			Title: "node #18",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID:   55555,
						NetworkID: networkID,
						Ethash:    &Ethash{},
					},
					Client:   BesuClient,
					Miner:    true,
					Coinbase: coinbase,
					Import: &ImportedAccount{
						PrivateKeySecretName: "my-account-privatekey",
						PasswordSecretName:   "my-account-password",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.client",
					BadValue: "besu",
					Detail:   "client doesn't support importing accounts",
				},
			},
		},
		{
			Title: "node #19",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						NetworkID: networkID,
						ChainID:   55555,
						IBFT2:     &IBFT2{},
					},
					Client: GethClient,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.client",
					BadValue: "geth",
					Detail:   "client doesn't support ibft2 consensus",
				},
			},
		},
		{
			Title: "node #20",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID:   55555,
						NetworkID: networkID,
						Clique:    &Clique{},
					},
					Client:   GethClient,
					RPC:      true,
					Miner:    true,
					Coinbase: coinbase,
					Import: &ImportedAccount{
						PrivateKeySecretName: "my-account-privatekey",
						PasswordSecretName:   "my-account-password",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rpc",
					BadValue: true,
					Detail:   "must be false if import is provided",
				},
			},
		},
		{
			Title: "node #21",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID:   55555,
						NetworkID: networkID,
						Clique:    &Clique{},
					},
					Client:   GethClient,
					WS:       true,
					Miner:    true,
					Coinbase: coinbase,
					Import: &ImportedAccount{
						PrivateKeySecretName: "my-account-privatekey",
						PasswordSecretName:   "my-account-password",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.ws",
					BadValue: true,
					Detail:   "must be false if import is provided",
				},
			},
		},
		{
			Title: "node #22",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID:   55555,
						NetworkID: networkID,
						Clique:    &Clique{},
					},
					Client:   GethClient,
					GraphQL:  true,
					Miner:    true,
					Coinbase: coinbase,
					Import: &ImportedAccount{
						PrivateKeySecretName: "my-account-privatekey",
						PasswordSecretName:   "my-account-password",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.graphql",
					BadValue: true,
					Detail:   "must be false if import is provided",
				},
			},
		},
		{
			Title: "node #23",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Genesis: &Genesis{
						ChainID:   55555,
						NetworkID: networkID,
						Ethash: &Ethash{
							FixedDifficulty: &fixedDifficulty,
						},
					},
					Client: GethClient,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.client",
					BadValue: "geth",
					Detail:   "client doesn't support fixed difficulty pow networks",
				},
			},
		},
		{
			Title: "node #24",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:   BesuClient,
					Network:  GoerliNetwork,
					SyncMode: LightSynchronization,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.syncMode",
					BadValue: LightSynchronization,
					Detail:   "not supported by client besu",
				},
			},
		},
		{
			Title: "node #24",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:   NethermindClient,
					Network:  GoerliNetwork,
					SyncMode: SnapSynchronization,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.syncMode",
					BadValue: SnapSynchronization,
					Detail:   "not supported by client nethermind",
				},
			},
		},
		{
			Title: "node #25",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Resources: shared.Resources{
						CPU:      "2",
						CPULimit: "1",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.cpuLimit",
					BadValue: "1",
					Detail:   "must be greater than or equal to cpu 2",
				},
			},
		},
		{
			Title: "node #26",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Resources: shared.Resources{
						CPU:         "1",
						CPULimit:    "2",
						Memory:      "2Gi",
						MemoryLimit: "1Gi",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.memoryLimit",
					BadValue: "1Gi",
					Detail:   "must be greater than memory 2Gi",
				},
			},
		},
		{
			Title: "node #28",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  GethClient,
					Network: GoerliNetwork,
					Logging: shared.FatalLogs,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.logging",
					BadValue: shared.FatalLogs,
					Detail:   "not supported by client geth",
				},
			},
		},
		{
			Title: "node #29",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  GethClient,
					Network: GoerliNetwork,
					Logging: shared.TraceLogs,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.logging",
					BadValue: shared.TraceLogs,
					Detail:   "not supported by client geth",
				},
			},
		},
		{
			Title: "node #37",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  GethClient,
					Network: GoerliNetwork,
					GraphQL: true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rpc",
					BadValue: false,
					Detail:   "must enable rpc if client is geth and graphql is enabled",
				},
			},
		},
		{
			Title: "node #38",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  NethermindClient,
					Network: GoerliNetwork,
					Hosts:   []string{"kotal.com"},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.client",
					BadValue: NethermindClient,
					Detail:   "client doesn't support hosts whitelisting",
				},
			},
		},
		{
			Title: "node #39",
			Node: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:      NethermindClient,
					Network:     GoerliNetwork,
					CORSDomains: []string{"kotal.com"},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.client",
					BadValue: NethermindClient,
					Detail:   "client doesn't support CORS domains",
				},
			},
		},
	}

	// TODO: move .resources validation to shared resources package
	updateCases := []struct {
		Title   string
		OldNode *Node
		NewNode *Node
		Errors  field.ErrorList
	}{
		{
			Title: "node #1",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-1",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: MainNetwork,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: MainNetwork,
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "node #2",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-2",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Resources: shared.Resources{
						Storage: "20Gi",
					},
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-2",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Resources: shared.Resources{
						Storage: "10Gi",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.storage",
					BadValue: "10Gi",
					Detail:   "must be greater than or equal to old storage 20Gi",
				},
			},
		},
		{
			Title: "node #3",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-3",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Resources: shared.Resources{
						CPU:      "1",
						CPULimit: "2",
					},
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-3",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Resources: shared.Resources{
						CPU:      "2",
						CPULimit: "1",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.cpuLimit",
					BadValue: "1",
					Detail:   "must be greater than or equal to cpu 2",
				},
			},
		},
		{
			Title: "node #4",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-4",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Resources: shared.Resources{
						Memory:      "1Gi",
						MemoryLimit: "2Gi",
					},
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-4",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
					Resources: shared.Resources{
						Memory:      "1Gi",
						MemoryLimit: "1Gi",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.memoryLimit",
					BadValue: "1Gi",
					Detail:   "must be greater than memory 1Gi",
				},
			},
		},
		{
			Title: "node #5",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-5",
				},
				Spec: NodeSpec{
					Client:  BesuClient,
					Network: GoerliNetwork,
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "node-5",
				},
				Spec: NodeSpec{
					Client:  GethClient,
					Network: GoerliNetwork,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.client",
					BadValue: GethClient,
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Node.Default()
					_, err := cc.Node.ValidateCreate()

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldNode.Default()
					cc.NewNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/ethereum/v1alpha1/node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var nodelog = logf.Log.WithName("node-resource")

// SetupWebhookWithManager sets up the webook with a given controller manager
func (r *Node) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/ethereum/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/ethereum/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Account) DeepCopyInto(out *Account) {
	*out = *in
	if in.Storage != nil {
		in, out := &in.Storage, &out.Storage
		*out = make(map[HexString]HexString, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Account.
func (in *Account) DeepCopy() *Account {
	if in == nil {
		return nil
	}
	out := new(Account)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Clique) DeepCopyInto(out *Clique) {
	*out = *in
	out.PoA = in.PoA
	if in.Signers != nil {
		in, out := &in.Signers, &out.Signers
		*out = make([]shared.EthereumAddress, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Clique.
func (in *Clique) DeepCopy() *Clique {
	if in == nil {
		return nil
	}
	out := new(Clique)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Ethash) DeepCopyInto(out *Ethash) {
	*out = *in
	if in.FixedDifficulty != nil {
		in, out := &in.FixedDifficulty, &out.FixedDifficulty
		*out = new(uint)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Ethash.
func (in *Ethash) DeepCopy() *Ethash {
	if in == nil {
		return nil
	}
	out := new(Ethash)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Forks) DeepCopyInto(out *Forks) {
	*out = *in
	if in.DAO != nil {
		in, out := &in.DAO, &out.DAO
		*out = new(uint)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Forks.
func (in *Forks) DeepCopy() *Forks {
	if in == nil {
		return nil
	}
	out := new(Forks)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Genesis) DeepCopyInto(out *Genesis) {
	*out = *in
	if in.Accounts != nil {
		in, out := &in.Accounts, &out.Accounts
		*out = make([]Account, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Ethash != nil {
		in, out := &in.Ethash, &out.Ethash
		*out = new(Ethash)
		(*in).DeepCopyInto(*out)
	}
	if in.Clique != nil {
		in, out := &in.Clique, &out.Clique
		*out = new(Clique)
		(*in).DeepCopyInto(*out)
	}
	if in.IBFT2 != nil {
		in, out := &in.IBFT2, &out.IBFT2
		*out = new(IBFT2)
		(*in).DeepCopyInto(*out)
	}
	if in.Forks != nil {
		in, out := &in.Forks, &out.Forks
		*out = new(Forks)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Genesis.
func (in *Genesis) DeepCopy() *Genesis {
	if in == nil {
		return nil
	}
	out := new(Genesis)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IBFT2) DeepCopyInto(out *IBFT2) {
	*out = *in
	out.PoA = in.PoA
	if in.Validators != nil {
		in, out := &in.Validators, &out.Validators
		*out = make([]shared.EthereumAddress, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IBFT2.
func (in *IBFT2) DeepCopy() *IBFT2 {
	if in == nil {
		return nil
	}
	out := new(IBFT2)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ImportedAccount) DeepCopyInto(out *ImportedAccount) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ImportedAccount.
func (in *ImportedAccount) DeepCopy() *ImportedAccount {
	if in == nil {
		return nil
	}
	out := new(ImportedAccount)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.Genesis != nil {
		in, out := &in.Genesis, &out.Genesis
		*out = new(Genesis)
		(*in).DeepCopyInto(*out)
	}
	if in.Import != nil {
		in, out := &in.Import, &out.Import
		*out = new(ImportedAccount)
		**out = **in
	}
	if in.Bootnodes != nil {
		in, out := &in.Bootnodes, &out.Bootnodes
		*out = make([]Enode, len(*in))
		copy(*out, *in)
	}
	if in.StaticNodes != nil {
		in, out := &in.StaticNodes, &out.StaticNodes
		*out = make([]Enode, len(*in))
		copy(*out, *in)
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.CORSDomains != nil {
		in, out := &in.CORSDomains, &out.CORSDomains
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.RPCAPI != nil {
		in, out := &in.RPCAPI, &out.RPCAPI
		*out = make([]API, len(*in))
		copy(*out, *in)
	}
	if in.WSAPI != nil {
		in, out := &in.WSAPI, &out.WSAPI
		*out = make([]API, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PoA) DeepCopyInto(out *PoA) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PoA.
func (in *PoA) DeepCopy() *PoA {
	if in == nil {
		return nil
	}
	out := new(PoA)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/ethereum2/v1alpha1/beacon_node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// BeaconNodeSpec defines the desired state of BeaconNode
type BeaconNodeSpec struct {
	// Image is Ethereum 2.0 Beacon node client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`

	// Network is the network to join
	Network string `json:"network"`
	// Client is the Ethereum 2.0 client to use
	Client Ethereum2Client `json:"client"`
	// ExecutionEngineEndpoint is Ethereum Execution engine node endpoint
	ExecutionEngineEndpoint string `json:"executionEngineEndpoint"`
	// JWTSecretName is kubernetes secret name holding JWT secret
	JWTSecretName string `json:"jwtSecretName"`
	// FeeRecipient is ethereum address collecting transaction fees
	FeeRecipient shared.EthereumAddress `json:"feeRecipient,omitempty"`

	// CheckpointSyncURL is trusted beacon node rest api endpoint
	CheckpointSyncURL string `json:"checkpointSyncUrl,omitempty"`

	// REST enables Beacon REST API
	REST bool `json:"rest,omitempty"`
	// RESTPort is Beacon REST API server port
	RESTPort uint `json:"restPort,omitempty"`

	// RPC enables RPC server
	RPC bool `json:"rpc,omitempty"`
	// RPCPort is RPC server port
	RPCPort uint `json:"rpcPort,omitempty"`

	// GRPC enables GRPC gateway server
	GRPC bool `json:"grpc,omitempty"`
	// GRPCPort is GRPC gateway server port
	GRPCPort uint `json:"grpcPort,omitempty"`

	// CertSecretName is k8s secret name that holds tls.key and tls.cert
	CertSecretName string `json:"certSecretName,omitempty"`

	// Logging is logging verboisty level
	// +kubebuilder:validation:Enum=off;fatal;error;warn;info;debug;trace;all;notice;crit;panic;none
	Logging shared.VerbosityLevel `json:"logging,omitempty"`

	// Hosts is a list of hostnames to to whitelist for API access
	// +listType=set
	Hosts []string `json:"hosts,omitempty"`
	// CORSDomains is the domains from which to accept cross origin requests
	// +listType=set
	CORSDomains []string `json:"corsDomains,omitempty"`

	// P2PPort is p2p and discovery port
	P2PPort uint `json:"p2pPort,omitempty"`

	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// BeaconNodeStatus defines the observed state of BeaconNode
type BeaconNodeStatus struct {
}

// +kubebuilder:object:root=true

// BeaconNode is the Schema for the beaconnodes API
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".spec.client"
// +kubebuilder:printcolumn:name="Network",type=string,JSONPath=".spec.network"
type BeaconNode struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   BeaconNodeSpec   `json:"spec,omitempty"`
	Status BeaconNodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BeaconNodeList contains a list of BeaconNodes
type BeaconNodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BeaconNode `json:"items"`
}

func init() {
	SchemeBuilder.Register(&BeaconNode{}, &BeaconNodeList{})
}

'''
'''--- apis/ethereum2/v1alpha1/beacon_node_defaulting_webhook.go ---
package v1alpha1

import "sigs.k8s.io/controller-runtime/pkg/webhook"

// +kubebuilder:webhook:path=/mutate-ethereum2-kotal-io-v1alpha1-beaconnode,mutating=true,failurePolicy=fail,groups=ethereum2.kotal.io,resources=beaconnodes,verbs=create;update,versions=v1alpha1,name=mutate-ethereum2-v1alpha1-beaconnode.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &BeaconNode{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *BeaconNode) Default() {
	nodelog.Info("default", "name", r.Name)

	if r.Spec.Image == "" {
		var image string

		switch r.Spec.Client {
		case TekuClient:
			image = DefaultTekuBeaconNodeImage
		case PrysmClient:
			image = DefaultPrysmBeaconNodeImage
		case NimbusClient:
			image = DefaultNimbusBeaconNodeImage
		case LighthouseClient:
			image = DefaultLighthouseBeaconNodeImage
		}

		r.Spec.Image = image
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	if r.Spec.P2PPort == 0 {
		r.Spec.P2PPort = DefaultP2PPort
	}

	if r.Spec.Logging == "" {
		r.Spec.Logging = DefaultLogging
	}

	if r.Spec.RESTPort == 0 {
		r.Spec.RESTPort = DefaultRestPort
	}

	if r.Spec.RPCPort == 0 {
		r.Spec.RPCPort = DefaultRPCPort
	}

	if r.Spec.GRPCPort == 0 {
		r.Spec.GRPCPort = DefaultGRPCPort
	}

	if len(r.Spec.CORSDomains) == 0 {
		r.Spec.CORSDomains = DefaultOrigins
	}
	if len(r.Spec.Hosts) == 0 {
		r.Spec.Hosts = DefaultOrigins
	}

	if r.Spec.FeeRecipient == "" {
		r.Spec.FeeRecipient = ZeroAddress
	}

	r.DefaultNodeResources()

}

// DefaultNodeResources defaults Ethereum 2.0 node cpu, memory and storage resources
func (r *BeaconNode) DefaultNodeResources() {
	if r.Spec.Resources.CPU == "" {
		r.Spec.Resources.CPU = DefaultCPURequest
	}

	if r.Spec.Resources.CPULimit == "" {
		r.Spec.Resources.CPULimit = DefaultCPULimit
	}

	if r.Spec.Resources.Memory == "" {
		r.Spec.Resources.Memory = DefaultMemoryRequest
	}

	if r.Spec.Resources.MemoryLimit == "" {
		r.Spec.Resources.MemoryLimit = DefaultMemoryLimit
	}

	if r.Spec.Resources.Storage == "" {
		r.Spec.Resources.Storage = DefaultStorage
	}
}

'''
'''--- apis/ethereum2/v1alpha1/beacon_node_defaulting_webhook_test.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Ethereum 2.0 beacon node defaulting", func() {

	It("Should default beacon node with missing fee recipient and p2p port and logging", func() {
		node := BeaconNode{
			Spec: BeaconNodeSpec{
				Network: "mainnet",
				Client:  TekuClient,
			},
		}
		node.Default()
		Expect(node.Spec.Image).To(Equal(DefaultTekuBeaconNodeImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.Logging).To(Equal(DefaultLogging))
		Expect(node.Spec.FeeRecipient).To(Equal(shared.EthereumAddress(ZeroAddress)))
	})

	It("Should default beacon node with missing node resources", func() {
		node := BeaconNode{
			Spec: BeaconNodeSpec{
				Network: "mainnet",
				Client:  LighthouseClient,
			},
		}
		node.Default()
		Expect(node.Spec.Image).To(Equal(DefaultLighthouseBeaconNodeImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultStorage))
	})

	It("Should default beacon node with missing client and rest port/host", func() {
		node := BeaconNode{
			Spec: BeaconNodeSpec{
				Network: "mainnet",
				Client:  TekuClient,
				REST:    true,
			},
		}
		node.Default()
		Expect(node.Spec.RESTPort).To(Equal(DefaultRestPort))
		Expect(node.Spec.CORSDomains).To(ConsistOf(DefaultOrigins))
		Expect(node.Spec.Hosts).To(ConsistOf(DefaultOrigins))
	})

	It("Should default beacon node with missing rpc port and host", func() {
		node := BeaconNode{
			Spec: BeaconNodeSpec{
				Network: "mainnet",
				Client:  NimbusClient,
				RPC:     true,
			},
		}
		node.Default()
		Expect(node.Spec.Image).To(Equal(DefaultNimbusBeaconNodeImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.RPCPort).To(Equal(DefaultRPCPort))
		Expect(node.Spec.CORSDomains).To(ConsistOf(DefaultOrigins))
		Expect(node.Spec.Hosts).To(ConsistOf(DefaultOrigins))
	})

	It("Should default beacon node with missing grpc port", func() {
		node := BeaconNode{
			Spec: BeaconNodeSpec{
				Client:  PrysmClient,
				Network: "mainnet",
				GRPC:    true,
			},
		}
		node.Default()
		Expect(node.Spec.Image).To(Equal(DefaultPrysmBeaconNodeImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.GRPCPort).To(Equal(DefaultGRPCPort))
		Expect(node.Spec.CORSDomains).To(ConsistOf(DefaultOrigins))
		Expect(node.Spec.Hosts).To(ConsistOf(DefaultOrigins))
	})

	It("Should default beacon node with missing grpc host", func() {
		node := BeaconNode{
			Spec: BeaconNodeSpec{
				Client:  PrysmClient,
				Network: "mainnet",
				GRPC:    true,
			},
		}
		node.Default()
		Expect(node.Spec.CORSDomains).To(ConsistOf(DefaultOrigins))
		Expect(node.Spec.Hosts).To(ConsistOf(DefaultOrigins))
	})

	It("Should default beacon node with missing cors domains", func() {
		node := BeaconNode{
			Spec: BeaconNodeSpec{
				Client: TekuClient,
				REST:   true,
			},
		}
		node.Default()
		Expect(node.Spec.CORSDomains).To(ConsistOf(DefaultOrigins))
		Expect(node.Spec.Hosts).To(ConsistOf(DefaultOrigins))
	})

})

'''
'''--- apis/ethereum2/v1alpha1/beacon_node_validation_webhook.go ---
package v1alpha1

import (
	"fmt"

	apierrors "k8s.io/apimachinery/pkg/api/errors"
	runtime "k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-ethereum2-kotal-io-v1alpha1-beaconnode,mutating=false,failurePolicy=fail,groups=ethereum2.kotal.io,resources=beaconnodes,versions=v1alpha1,name=validate-ethereum2-v1alpha1-beaconnode.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &BeaconNode{}

// validate is the shared validate create and update logic
func (r *BeaconNode) validate() field.ErrorList {
	var nodeErrors field.ErrorList

	path := field.NewPath("spec")

	// rest is supported by all clients except prysm
	if r.Spec.REST && r.Spec.Client == PrysmClient {
		err := field.Invalid(path.Child("rest"), r.Spec.REST, fmt.Sprintf("not supported by %s client", r.Spec.Client))
		nodeErrors = append(nodeErrors, err)
	}

	// rpc is supported by prysm only
	if r.Spec.RPC && r.Spec.Client != PrysmClient {
		err := field.Invalid(path.Child("rpc"), r.Spec.RPC, fmt.Sprintf("not supported by %s client", r.Spec.Client))
		nodeErrors = append(nodeErrors, err)
	}

	// validate verbosity level support
	if !r.Spec.Client.SupportsVerbosityLevel(r.Spec.Logging, false) {
		err := field.Invalid(path.Child("logging"), r.Spec.Logging, fmt.Sprintf("not supported by %s client", r.Spec.Client))
		nodeErrors = append(nodeErrors, err)
	}

	// grpc is supported by prysm only
	if r.Spec.GRPC && r.Spec.Client != PrysmClient {
		err := field.Invalid(path.Child("grpc"), r.Spec.GRPC, fmt.Sprintf("not supported by %s client", r.Spec.Client))
		nodeErrors = append(nodeErrors, err)
	}

	// validate cert secret name is supported by prysm only
	if r.Spec.CertSecretName != "" && r.Spec.Client != PrysmClient {
		err := field.Invalid(path.Child("certSecretName"), r.Spec.CertSecretName, fmt.Sprintf("not supported by %s client", r.Spec.Client))
		nodeErrors = append(nodeErrors, err)
	}

	// rpc is always on in prysm
	if r.Spec.Client == PrysmClient && !r.Spec.RPC {
		err := field.Invalid(path.Child("rpc"), r.Spec.RPC, "can't be disabled in prysm client")
		nodeErrors = append(nodeErrors, err)
	}

	return nodeErrors
}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *BeaconNode) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	nodelog.Info("validate create", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)

}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *BeaconNode) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldNode := old.(*BeaconNode)
	path := field.NewPath("spec")

	nodelog.Info("validate update", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if oldNode.Spec.Client != r.Spec.Client {
		err := field.Invalid(path.Child("client"), r.Spec.Client, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if oldNode.Spec.Network != r.Spec.Network {
		err := field.Invalid(path.Child("network"), r.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *BeaconNode) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", r.Name)

	return nil, nil
}

'''
'''--- apis/ethereum2/v1alpha1/beacon_node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Ethereum 2.0 beacon node validation", func() {

	createCases := []struct {
		Title  string
		Node   *BeaconNode
		Errors field.ErrorList
	}{
		{
			Title: "Node #1",
			Node: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  PrysmClient,
					REST:    true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rest",
					BadValue: true,
					Detail:   "not supported by prysm client",
				},
			},
		},
		{
			Title: "Node #2",
			Node: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  PrysmClient,
					REST:    true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rest",
					BadValue: true,
					Detail:   "not supported by prysm client",
				},
			},
		},
		{
			Title: "Node #3",
			Node: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  TekuClient,
					RPC:     true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rpc",
					BadValue: true,
					Detail:   "not supported by teku client",
				},
			},
		},
		{
			Title: "Node #4",
			Node: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  LighthouseClient,
					RPC:     true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rpc",
					BadValue: true,
					Detail:   "not supported by lighthouse client",
				},
			},
		},
		{
			Title: "Node #5",
			Node: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  PrysmClient,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rpc",
					BadValue: false,
					Detail:   "can't be disabled in prysm client",
				},
			},
		},
		{
			Title: "Node #6",
			Node: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  TekuClient,
					GRPC:    true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.grpc",
					BadValue: true,
					Detail:   "not supported by teku client",
				},
			},
		},
		{
			Title: "Node #9",
			Node: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network:        "mainnet",
					Client:         TekuClient,
					CertSecretName: "my-cert",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.certSecretName",
					BadValue: "my-cert",
					Detail:   "not supported by teku client",
				},
			},
		},
	}

	updateCases := []struct {
		Title   string
		OldNode *BeaconNode
		NewNode *BeaconNode
		Errors  field.ErrorList
	}{
		{
			Title: "Node #1",
			OldNode: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  TekuClient,
				},
			},
			NewNode: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "goerli",
					Client:  TekuClient,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: "goerli",
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "Node #2",
			OldNode: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  TekuClient,
				},
			},
			NewNode: &BeaconNode{
				Spec: BeaconNodeSpec{
					Network: "mainnet",
					Client:  PrysmClient,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.client",
					BadValue: PrysmClient,
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating beacon node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Node.Default()
					_, err := cc.Node.ValidateCreate()
					Expect(err).ToNot(BeNil())

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating beacon node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.NewNode.Default()
					cc.OldNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)
					Expect(err).ToNot(BeNil())

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/ethereum2/v1alpha1/beacon_node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var nodelog = logf.Log.WithName("node-resource")

// SetupWebhookWithManager sets up the webook with a given controller manager
func (r *BeaconNode) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/ethereum2/v1alpha1/client.go ---
package v1alpha1

import "github.com/kotalco/kotal/apis/shared"

// Ethereum2Client is Ethereum 2.0 client
// +kubebuilder:validation:Enum=teku;prysm;lighthouse;nimbus
type Ethereum2Client string

const (
	// TekuClient is ConsenSys Pegasys Ethereum 2.0 client
	TekuClient Ethereum2Client = "teku"
	// PrysmClient is Prysmatic Labs Ethereum 2.0 client
	PrysmClient Ethereum2Client = "prysm"
	// LighthouseClient is SigmaPrime Ethereum 2.0 client
	LighthouseClient Ethereum2Client = "lighthouse"
	// NimbusClient is Status Ethereum 2.0 client
	NimbusClient Ethereum2Client = "nimbus"
)

func (client Ethereum2Client) SupportsVerbosityLevel(level shared.VerbosityLevel, validator bool) bool {
	switch client {

	case TekuClient:
		switch level {
		case shared.NoLogs,
			shared.FatalLogs,
			shared.ErrorLogs,
			shared.WarnLogs,
			shared.InfoLogs,
			shared.DebugLogs,
			shared.TraceLogs,
			shared.AllLogs:
			return true
		}

	case PrysmClient:
		switch level {
		case shared.TraceLogs,
			shared.DebugLogs,
			shared.InfoLogs,
			shared.WarnLogs,
			shared.ErrorLogs,
			shared.FatalLogs,
			shared.PanicLogs:
			return true
		}

	case LighthouseClient:
		switch level {
		case shared.InfoLogs,
			shared.DebugLogs,
			shared.TraceLogs,
			shared.WarnLogs,
			shared.ErrorLogs,
			shared.CriticalLogs:
			return true
		}

	case NimbusClient:
		switch level {
		case shared.TraceLogs,
			shared.DebugLogs,
			shared.InfoLogs,
			shared.NoticeLogs,
			shared.WarnLogs,
			shared.ErrorLogs,
			shared.FatalLogs,
			shared.NoneLogs:
			return true
		}
	}

	return false
}

'''
'''--- apis/ethereum2/v1alpha1/defaults.go ---
package v1alpha1

import "github.com/kotalco/kotal/apis/shared"

var (
	// DefaultOrigins is the default domains from which to accept cross origin requests
	DefaultOrigins = []string{"*"}
)

const (
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// ZeroAddress is Ethereum zero address
	ZeroAddress = "0x0000000000000000000000000000000000000000"
	// DefaultP2PPort is the default port used for p2p and discovery
	DefaultP2PPort uint = 9000
	// DefaultRestPort is the default Beacon REST api port
	DefaultRestPort uint = 5051
	// DefaultRPCPort is the default RPC server port
	DefaultRPCPort uint = 4000
	// DefaultGRPCPort is the default GRPC gateway server port
	DefaultGRPCPort uint = 3500
	// DefaultGraffiti is the default text to include in proposed blocks
	DefaultGraffiti = "Powered by Kotal"
	// DefaultLogging is the default logging verbosity
	DefaultLogging = shared.InfoLogs
)

const (
	// DefaultLighthouseBeaconNodeImage is the default SigmaPrime Ethereum 2.0 beacon node image
	DefaultLighthouseBeaconNodeImage = "kotalco/lighthouse:v5.1.3"
	// DefaultTekuBeaconNodeImage is PegaSys Teku beacon node image
	DefaultTekuBeaconNodeImage = "consensys/teku:24.3.1"
	// DefaultPrysmBeaconNodeImage is Prysmatic Labs beacon node image
	DefaultPrysmBeaconNodeImage = "kotalco/prysm:v5.0.3"
	// DefaultNimbusBeaconNodeImage is the default Status Ethereum 2.0 beacon node image
	DefaultNimbusBeaconNodeImage = "kotalco/nimbus:v24.3.0"
)

const (
	// DefaultTekuValidatorImage is PegaSys Teku validator client image
	DefaultTekuValidatorImage = "consensys/teku:24.3.1"
	// DefaultPrysmValidatorImage is Prysmatic Labs validator client image
	DefaultPrysmValidatorImage = "kotalco/prysm:v5.0.3"
	// DefaultNimbusValidatorImage is the default Status Ethereum 2.0 validator client image
	DefaultNimbusValidatorImage = "kotalco/nimbus:v24.3.0"
	// DefaultLighthouseValidatorImage is the default SigmaPrime Ethereum 2.0 validator client image
	DefaultLighthouseValidatorImage = "kotalco/lighthouse:v5.1.3"
)

const (
	// DefaultCPURequest is the default CPU cores required by Ethereum 2.0 node
	DefaultCPURequest = "4"
	// DefaultCPULimit is the default CPU cores limit by Ethereum 2.0 node
	DefaultCPULimit = "8"
	// DefaultMemoryRequest is the default memory required by Ethereum 2.0 node
	DefaultMemoryRequest = "8Gi"
	// DefaultMemoryLimit is the default memory limit by Ethereum 2.0 node
	DefaultMemoryLimit = "16Gi"
	// DefaultStorage is the default disk space used by Ethereum 2.0 node
	DefaultStorage = "200Gi"
)

'''
'''--- apis/ethereum2/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the ethereum2 v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=ethereum2.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "ethereum2.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/ethereum2/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/ethereum2/v1alpha1/validator.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ValidatorSpec defines the desired state of Validator
type ValidatorSpec struct {
	// Image is Ethereum 2.0 validator client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`

	// Network is the network this validator is validating blocks for
	Network string `json:"network"`
	// Client is the Ethereum 2.0 client to use
	Client Ethereum2Client `json:"client"`
	// FeeRecipient is ethereum address collecting transaction fees
	FeeRecipient shared.EthereumAddress `json:"feeRecipient,omitempty"`
	// BeaconEndpoints is beacon node endpoints
	// +kubebuilder:validation:MinItems=1
	// +listType=set
	BeaconEndpoints []string `json:"beaconEndpoints"`
	// Graffiti is the text to include in proposed blocks
	Graffiti string `json:"graffiti,omitempty"`
	// Logging is logging verboisty level
	// +kubebuilder:validation:Enum=off;fatal;error;warn;info;debug;trace;all;notice;crit;panic;none
	Logging shared.VerbosityLevel `json:"logging,omitempty"`
	// CertSecretName is k8s secret name that holds tls.crt
	CertSecretName string `json:"certSecretName,omitempty"`
	// Keystores is a list of Validator keystores
	// +kubebuilder:validation:MinItems=1
	Keystores []Keystore `json:"keystores"`
	// WalletPasswordSecret is wallet password secret
	WalletPasswordSecret string `json:"walletPasswordSecret,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// Keystore is Ethereum 2.0 validator EIP-2335 BLS12-381 keystore https://eips.ethereum.org/EIPS/eip-2335
type Keystore struct {
	// PublicKey is the validator public key in hexadecimal
	// +kubebuilder:validation:Pattern="^0[xX][0-9a-fA-F]{96}$"
	PublicKey string `json:"publicKey,omitempty"`
	// SecretName is the kubernetes secret holding [keystore] and [password]
	SecretName string `json:"secretName"`
}

// ValidatorStatus defines the observed state of Validator
type ValidatorStatus struct{}

// +kubebuilder:object:root=true

// Validator is the Schema for the validators API
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".spec.client"
// +kubebuilder:printcolumn:name="Network",type=string,JSONPath=".spec.network"
type Validator struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ValidatorSpec   `json:"spec,omitempty"`
	Status ValidatorStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ValidatorList contains a list of Validator
type ValidatorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Validator `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Validator{}, &ValidatorList{})
}

'''
'''--- apis/ethereum2/v1alpha1/validator_defaulting_webhook.go ---
package v1alpha1

import (
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-ethereum2-kotal-io-v1alpha1-validator,mutating=true,failurePolicy=fail,groups=ethereum2.kotal.io,resources=validators,verbs=create;update,versions=v1alpha1,name=mutate-ethereum2-v1alpha1-validator.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Validator{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Validator) Default() {
	validatorlog.Info("default", "name", r.Name)

	if r.Spec.Graffiti == "" {
		r.Spec.Graffiti = DefaultGraffiti
	}

	if r.Spec.FeeRecipient == "" {
		r.Spec.FeeRecipient = ZeroAddress
	}

	if r.Spec.Image == "" {
		var image string

		switch r.Spec.Client {
		case TekuClient:
			image = DefaultTekuValidatorImage
		case LighthouseClient:
			image = DefaultLighthouseValidatorImage
		case NimbusClient:
			image = DefaultNimbusValidatorImage
		case PrysmClient:
			image = DefaultPrysmValidatorImage
		}

		r.Spec.Image = image
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	r.DefaultNodeResources()

}

// DefaultNodeResources defaults Ethereum 2.0 validator client cpu, memory and storage resources
func (r *Validator) DefaultNodeResources() {
	if r.Spec.Resources.CPU == "" {
		r.Spec.Resources.CPU = DefaultCPURequest
	}

	if r.Spec.Resources.CPULimit == "" {
		r.Spec.Resources.CPULimit = DefaultCPULimit
	}

	if r.Spec.Resources.Memory == "" {
		r.Spec.Resources.Memory = DefaultMemoryRequest
	}

	if r.Spec.Resources.MemoryLimit == "" {
		r.Spec.Resources.MemoryLimit = DefaultMemoryLimit
	}

	if r.Spec.Resources.Storage == "" {
		r.Spec.Resources.Storage = DefaultStorage
	}

	if r.Spec.Logging == "" {
		r.Spec.Logging = DefaultLogging
	}
}

'''
'''--- apis/ethereum2/v1alpha1/validator_defaulting_webhook_test.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Ethereum 2.0 validator client defaulting", func() {

	It("Should default validator client with missing client, graffiti, and resources", func() {
		node := Validator{
			Spec: ValidatorSpec{
				Network: "mainnet",
				Client:  TekuClient,
			},
		}
		node.Default()
		Expect(node.Spec.Image).To(Equal(DefaultTekuValidatorImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.Graffiti).To(Equal(DefaultGraffiti))
		Expect(node.Spec.FeeRecipient).To(Equal(shared.EthereumAddress(ZeroAddress)))
		Expect(node.Spec.Logging).To(Equal(DefaultLogging))
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultStorage))
	})

})

'''
'''--- apis/ethereum2/v1alpha1/validator_validation_webhook.go ---
package v1alpha1

import (
	"fmt"
	"strings"

	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-ethereum2-kotal-io-v1alpha1-validator,mutating=false,failurePolicy=fail,groups=ethereum2.kotal.io,resources=validators,versions=v1alpha1,name=validate-ethereum2-v1alpha1-validator.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Validator{}

// validate validates an Ethereum 2.0 validator client
func (r *Validator) validate() field.ErrorList {
	var validatorErrors field.ErrorList

	// prysm requires wallet password
	if r.Spec.Client == PrysmClient && r.Spec.WalletPasswordSecret == "" {
		msg := "must provide walletPasswordSecret if client is prysm"
		err := field.Invalid(field.NewPath("spec").Child("walletPasswordSecret"), r.Spec.WalletPasswordSecret, msg)
		validatorErrors = append(validatorErrors, err)
	}

	if r.Spec.CertSecretName != "" && r.Spec.Client != PrysmClient {
		err := field.Invalid(field.NewPath("spec").Child("certSecretName"), r.Spec.CertSecretName, fmt.Sprintf("not supported by %s client", r.Spec.Client))
		validatorErrors = append(validatorErrors, err)
	}

	if !r.Spec.Client.SupportsVerbosityLevel(r.Spec.Logging, false) {
		err := field.Invalid(field.NewPath("spec").Child("logging"), r.Spec.Logging, fmt.Sprintf("not supported by %s client", r.Spec.Client))
		validatorErrors = append(validatorErrors, err)
	}

	// lighthouse is the only client supporting multiple beacon endpoints
	if r.Spec.Client != LighthouseClient && len(r.Spec.BeaconEndpoints) > 1 {
		msg := fmt.Sprintf("multiple beacon node endpoints not supported by %s client", r.Spec.Client)
		err := field.Invalid(field.NewPath("spec").Child("beaconEndpoints"), strings.Join(r.Spec.BeaconEndpoints, ","), msg)
		validatorErrors = append(validatorErrors, err)
	}

	if r.Spec.Client == LighthouseClient {
		for i, keystore := range r.Spec.Keystores {
			if keystore.PublicKey == "" {
				msg := "keystore public key is required if client is lighthouse"
				err := field.Invalid(field.NewPath("spec").Child("keystores").Index(i).Child("publicKey"), "", msg)
				validatorErrors = append(validatorErrors, err)
			}
		}
	}

	return validatorErrors
}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *Validator) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	validatorlog.Info("validate create", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *Validator) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldValidator := old.(*Validator)

	validatorlog.Info("validate update", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateUpdate(&oldValidator.Spec.Resources)...)

	if oldValidator.Spec.Client != r.Spec.Client {
		err := field.Invalid(field.NewPath("spec").Child("client"), r.Spec.Client, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if oldValidator.Spec.Network != r.Spec.Network {
		err := field.Invalid(field.NewPath("spec").Child("network"), r.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *Validator) ValidateDelete() (admission.Warnings, error) {
	validatorlog.Info("validate delete", "name", r.Name)

	return nil, nil
}

'''
'''--- apis/ethereum2/v1alpha1/validator_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Ethereum 2.0 validator client validation", func() {

	createCases := []struct {
		Title     string
		Validator *Validator
		Errors    field.ErrorList
	}{
		{
			Title: "Validator #1",
			Validator: &Validator{
				Spec: ValidatorSpec{
					Network:  "mainnet",
					Client:   PrysmClient,
					Graffiti: "Kotal is amazing",
					Keystores: []Keystore{
						{
							SecretName: "my-validator",
						},
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.walletPasswordSecret",
					BadValue: "",
					Detail:   "must provide walletPasswordSecret if client is prysm",
				},
			},
		},
		{
			Title: "Validator #2",
			Validator: &Validator{
				Spec: ValidatorSpec{
					Network:  "mainnet",
					Client:   TekuClient,
					Graffiti: "Kotal is amazing",
					BeaconEndpoints: []string{
						"http://10.96.130.88:9999",
						"http://10.96.130.88:9988",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.beaconEndpoints",
					BadValue: "http://10.96.130.88:9999,http://10.96.130.88:9988",
					Detail:   "multiple beacon node endpoints not supported by teku client",
				},
			},
		},
		{
			Title: "Validator #3",
			Validator: &Validator{
				Spec: ValidatorSpec{
					Network:  "mainnet",
					Client:   LighthouseClient,
					Graffiti: "Kotal is amazing",
					BeaconEndpoints: []string{
						"http://10.96.130.88:9999",
					},
					Keystores: []Keystore{
						{
							SecretName: "my-validator",
						},
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.keystores[0].publicKey",
					BadValue: "",
					Detail:   "keystore public key is required if client is lighthouse",
				},
			},
		},
		{
			Title: "Validator #4",
			Validator: &Validator{
				Spec: ValidatorSpec{
					Network:        "mainnet",
					Client:         LighthouseClient,
					CertSecretName: "my-cert",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.certSecretName",
					BadValue: "my-cert",
					Detail:   "not supported by lighthouse client",
				},
			},
		},
	}

	updateCases := []struct {
		Title        string
		OldValidator *Validator
		NewValidator *Validator
		Errors       field.ErrorList
	}{
		{
			Title: "Validator #1",
			OldValidator: &Validator{
				Spec: ValidatorSpec{
					Network:  "mainnet",
					Client:   TekuClient,
					Graffiti: "Kotal is amazing",
					Keystores: []Keystore{
						{
							SecretName: "my-validator",
						},
					},
				},
			},
			NewValidator: &Validator{
				Spec: ValidatorSpec{
					Network:  "mainnet",
					Client:   PrysmClient,
					Graffiti: "Kotal is amazing",
					Keystores: []Keystore{
						{
							SecretName: "my-validator",
						},
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.walletPasswordSecret",
					BadValue: "",
					Detail:   "must provide walletPasswordSecret if client is prysm",
				},
			},
		},
		{
			Title: "Validator #2",
			OldValidator: &Validator{
				Spec: ValidatorSpec{
					Network:  "mainnet",
					Client:   TekuClient,
					Graffiti: "Kotal is amazing",
					Keystores: []Keystore{
						{
							SecretName: "my-validator",
						},
					},
				},
			},
			NewValidator: &Validator{
				Spec: ValidatorSpec{
					Network:  "goerli",
					Client:   TekuClient,
					Graffiti: "Kotal is amazing",
					Keystores: []Keystore{
						{
							SecretName: "my-validator",
						},
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: "goerli",
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "Validator #3",
			OldValidator: &Validator{
				Spec: ValidatorSpec{
					Network:  "mainnet",
					Client:   TekuClient,
					Graffiti: "Kotal is amazing",
					Keystores: []Keystore{
						{
							SecretName: "my-validator",
						},
					},
				},
			},
			NewValidator: &Validator{
				Spec: ValidatorSpec{
					Network:  "mainnet",
					Client:   PrysmClient,
					Graffiti: "Kotal is amazing",
					Keystores: []Keystore{
						{
							SecretName: "my-validator",
						},
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.client",
					BadValue: "prysm",
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating validator client", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Validator.Default()
					_, err := cc.Validator.ValidateCreate()

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating validator client", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldValidator.Default()
					cc.NewValidator.Default()
					_, err := cc.NewValidator.ValidateUpdate(cc.OldValidator)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/ethereum2/v1alpha1/validator_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var validatorlog = logf.Log.WithName("validator-resource")

// SetupWebhookWithManager sets up the webook with a given controller manager
func (r *Validator) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/ethereum2/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BeaconNode) DeepCopyInto(out *BeaconNode) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BeaconNode.
func (in *BeaconNode) DeepCopy() *BeaconNode {
	if in == nil {
		return nil
	}
	out := new(BeaconNode)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *BeaconNode) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BeaconNodeList) DeepCopyInto(out *BeaconNodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]BeaconNode, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BeaconNodeList.
func (in *BeaconNodeList) DeepCopy() *BeaconNodeList {
	if in == nil {
		return nil
	}
	out := new(BeaconNodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *BeaconNodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BeaconNodeSpec) DeepCopyInto(out *BeaconNodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.CORSDomains != nil {
		in, out := &in.CORSDomains, &out.CORSDomains
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BeaconNodeSpec.
func (in *BeaconNodeSpec) DeepCopy() *BeaconNodeSpec {
	if in == nil {
		return nil
	}
	out := new(BeaconNodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BeaconNodeStatus) DeepCopyInto(out *BeaconNodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BeaconNodeStatus.
func (in *BeaconNodeStatus) DeepCopy() *BeaconNodeStatus {
	if in == nil {
		return nil
	}
	out := new(BeaconNodeStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Keystore) DeepCopyInto(out *Keystore) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Keystore.
func (in *Keystore) DeepCopy() *Keystore {
	if in == nil {
		return nil
	}
	out := new(Keystore)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Validator) DeepCopyInto(out *Validator) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Validator.
func (in *Validator) DeepCopy() *Validator {
	if in == nil {
		return nil
	}
	out := new(Validator)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Validator) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ValidatorList) DeepCopyInto(out *ValidatorList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Validator, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ValidatorList.
func (in *ValidatorList) DeepCopy() *ValidatorList {
	if in == nil {
		return nil
	}
	out := new(ValidatorList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ValidatorList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ValidatorSpec) DeepCopyInto(out *ValidatorSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.BeaconEndpoints != nil {
		in, out := &in.BeaconEndpoints, &out.BeaconEndpoints
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Keystores != nil {
		in, out := &in.Keystores, &out.Keystores
		*out = make([]Keystore, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ValidatorSpec.
func (in *ValidatorSpec) DeepCopy() *ValidatorSpec {
	if in == nil {
		return nil
	}
	out := new(ValidatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ValidatorStatus) DeepCopyInto(out *ValidatorStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ValidatorStatus.
func (in *ValidatorStatus) DeepCopy() *ValidatorStatus {
	if in == nil {
		return nil
	}
	out := new(ValidatorStatus)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/filecoin/v1alpha1/defaults.go ---
package v1alpha1

import "github.com/kotalco/kotal/apis/shared"

const (
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// DefaultAPIPort is the default port the API server is listening to
	DefaultAPIPort uint = 1234
	// DefaultP2PPort is the default p2p port
	DefaultP2PPort uint = 4444
	// DefaultAPIRequestTimeout is the default API request timeout
	DefaultAPIRequestTimeout uint = 30
	// DefaultLogging is the default logging verbosity
	DefaultLogging = shared.InfoLogs

	// DefaultMainnetNodeCPURequest is the default mainnet node cpu request
	DefaultMainnetNodeCPURequest = "8"
	// DefaultMainnetNodeCPULimit is the default mainnet node cpu limit
	DefaultMainnetNodeCPULimit = "16"
	// DefaultMainnetNodeMemoryRequest is the default mainnet node memory request
	DefaultMainnetNodeMemoryRequest = "16Gi"
	// DefaultMainnetNodeMemoryLimit is the default mainnet node memory limit
	DefaultMainnetNodeMemoryLimit = "32Gi"
	// DefaultMainnetNodeStorageRequest is the default mainnet node storage
	DefaultMainnetNodeStorageRequest = "200Gi"

	// DefaultCalibrationNodeCPURequest is the default calibration node cpu request
	DefaultCalibrationNodeCPURequest = "8"
	// DefaultCalibrationNodeCPULimit is the default calibration node cpu limit
	DefaultCalibrationNodeCPULimit = "16"
	// DefaultCalibrationNodeMemoryRequest is the default calibration node memory request
	DefaultCalibrationNodeMemoryRequest = "16Gi"
	// DefaultCalibrationNodeMemoryLimit is the default calibration node memory limit
	DefaultCalibrationNodeMemoryLimit = "32Gi"
	// DefaultCalibrationNodeStorageRequest is the default calibration node storage
	DefaultCalibrationNodeStorageRequest = "200Gi"
)

const (
	// DefaultLotusImage is the default lotus client image
	DefaultLotusImage = "filecoin/lotus:v1.26.3"
	// DefaultLotusCalibrationImage is the default lotus client image for calibration network
	DefaultLotusCalibrationImage = "kotalco/lotus:v1.26.3-calibnet"
)

'''
'''--- apis/filecoin/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the filecoin v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=filecoin.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "filecoin.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/filecoin/v1alpha1/node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NodeSpec defines the desired state of Node
type NodeSpec struct {
	// Image is Filecoin node client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// API enables API server
	API bool `json:"api,omitempty"`
	// APIPort is API server listening port
	APIPort uint `json:"apiPort,omitempty"`
	// APIRequestTimeout is API request timeout in seconds
	APIRequestTimeout uint `json:"apiRequestTimeout,omitempty"`
	// DisableMetadataLog disables metadata log
	DisableMetadataLog bool `json:"disableMetadataLog,omitempty"`
	// P2PPort is p2p port
	P2PPort uint `json:"p2pPort,omitempty"`
	// Network is the Filecoin network the node will join and sync
	Network FilecoinNetwork `json:"network"`
	// IPFSPeerEndpoint is ipfs peer endpoint
	IPFSPeerEndpoint string `json:"ipfsPeerEndpoint,omitempty"`
	// IPFSOnlineMode sets ipfs online mode
	IPFSOnlineMode bool `json:"ipfsOnlineMode,omitempty"`
	// IPFSForRetrieval uses ipfs for retrieval
	IPFSForRetrieval bool `json:"ipfsForRetrieval,omitempty"`
	// Logging is logging verboisty level
	// +kubebuilder:validation:Enum=error;warn;info;debug
	Logging shared.VerbosityLevel `json:"logging,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// FilecoinNetwork is Filecoin network
// +kubebuilder:validation:Enum=mainnet;calibration
type FilecoinNetwork string

const (
	// MainNetwork is the Filecoin main network
	MainNetwork FilecoinNetwork = "mainnet"
	// CalibrationNetwork is the Filecoin main network
	CalibrationNetwork FilecoinNetwork = "calibration"
)

// NodeStatus defines the observed state of Node
type NodeStatus struct {
	Client string `json:"client"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Node is the Schema for the nodes API
// +kubebuilder:printcolumn:name="Network",type=string,JSONPath=".spec.network"
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".status.client"
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/filecoin/v1alpha1/node_defaulting_webhook.go ---
package v1alpha1

import (
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-filecoin-kotal-io-v1alpha1-node,mutating=true,failurePolicy=fail,groups=filecoin.kotal.io,resources=nodes,verbs=create;update,versions=v1alpha1,name=mutate-filecoin-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Node{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (n *Node) Default() {
	nodelog.Info("default", "name", n.Name)

	mainnet := n.Spec.Network == MainNetwork
	calibration := n.Spec.Network == CalibrationNetwork

	if n.Spec.Image == "" {
		var image string

		switch n.Spec.Network {
		case MainNetwork:
			image = DefaultLotusImage
		case CalibrationNetwork:
			image = DefaultLotusCalibrationImage
		}

		n.Spec.Image = image
	}

	if n.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		n.Spec.Replicas = &replicas
	}

	if n.Spec.Logging == "" {
		n.Spec.Logging = DefaultLogging
	}

	if n.Spec.APIPort == 0 {
		n.Spec.APIPort = DefaultAPIPort
	}
	if n.Spec.APIRequestTimeout == 0 {
		n.Spec.APIRequestTimeout = DefaultAPIRequestTimeout
	}

	if n.Spec.P2PPort == 0 {
		n.Spec.P2PPort = DefaultP2PPort
	}

	if n.Spec.Resources.CPU == "" {
		if mainnet {
			n.Spec.CPU = DefaultMainnetNodeCPURequest
		}
		if calibration {
			n.Spec.CPU = DefaultCalibrationNodeCPURequest
		}
	}

	if n.Spec.CPULimit == "" {
		if mainnet {
			n.Spec.CPULimit = DefaultMainnetNodeCPULimit
		}
		if calibration {
			n.Spec.CPULimit = DefaultCalibrationNodeCPULimit
		}
	}

	if n.Spec.Memory == "" {
		if mainnet {
			n.Spec.Memory = DefaultMainnetNodeMemoryRequest
		}
		if calibration {
			n.Spec.Memory = DefaultCalibrationNodeMemoryRequest
		}
	}

	if n.Spec.MemoryLimit == "" {
		if mainnet {
			n.Spec.MemoryLimit = DefaultMainnetNodeMemoryLimit
		}
		if calibration {
			n.Spec.MemoryLimit = DefaultCalibrationNodeMemoryLimit
		}
	}

	if n.Spec.Storage == "" {
		if mainnet {
			n.Spec.Storage = DefaultMainnetNodeStorageRequest
		}
		if calibration {
			n.Spec.Storage = DefaultCalibrationNodeStorageRequest
		}
	}

}

'''
'''--- apis/filecoin/v1alpha1/node_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Filecoin node defaulting", func() {
	It("Should default Filecoin mainnet node", func() {
		node := Node{
			Spec: NodeSpec{
				Network: MainNetwork,
				API:     true,
			},
		}

		node.Default()

		Expect(node.Spec.Image).To((Equal(DefaultLotusImage)))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.Resources.CPU).To((Equal(DefaultMainnetNodeCPURequest)))
		Expect(node.Spec.Resources.CPULimit).To((Equal(DefaultMainnetNodeCPULimit)))
		Expect(node.Spec.Resources.Memory).To((Equal(DefaultMainnetNodeMemoryRequest)))
		Expect(node.Spec.Resources.MemoryLimit).To((Equal(DefaultMainnetNodeMemoryLimit)))
		Expect(node.Spec.Resources.Storage).To((Equal(DefaultMainnetNodeStorageRequest)))
		Expect(node.Spec.Logging).To(Equal(DefaultLogging))
		Expect(node.Spec.APIPort).To(Equal(DefaultAPIPort))
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.APIRequestTimeout).To(Equal(DefaultAPIRequestTimeout))

	})

	It("Should default Filecoin calibration node", func() {
		node := Node{
			Spec: NodeSpec{
				Network: CalibrationNetwork,
			},
		}

		node.Default()

		Expect(node.Spec.Image).To((Equal(DefaultLotusCalibrationImage)))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.Resources.CPU).To((Equal(DefaultCalibrationNodeCPURequest)))
		Expect(node.Spec.Resources.CPULimit).To((Equal(DefaultCalibrationNodeCPULimit)))
		Expect(node.Spec.Resources.Memory).To((Equal(DefaultCalibrationNodeMemoryRequest)))
		Expect(node.Spec.Resources.MemoryLimit).To((Equal(DefaultCalibrationNodeMemoryLimit)))
		Expect(node.Spec.Resources.Storage).To((Equal(DefaultCalibrationNodeStorageRequest)))

	})

})

'''
'''--- apis/filecoin/v1alpha1/node_validation_webhook.go ---
package v1alpha1

import (
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-filecoin-kotal-io-v1alpha1-node,mutating=false,failurePolicy=fail,groups=filecoin.kotal.io,resources=nodes,versions=v1alpha1,name=validate-filecoin-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Node{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateCreate() (admission.Warnings, error) {
	nodelog.Info("validate create", "name", n.Name)

	var allErrors field.ErrorList

	allErrors = append(allErrors, n.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, n.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	nodelog.Info("validate update", "name", n.Name)

	var allErrors field.ErrorList

	oldNode := old.(*Node)

	// validate network is immutable
	if oldNode.Spec.Network != n.Spec.Network {
		err := field.Invalid(field.NewPath("spec").Child("network"), n.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	allErrors = append(allErrors, n.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, n.Name, allErrors)

}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", n.Name)

	return nil, nil
}

'''
'''--- apis/filecoin/v1alpha1/node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Filecoin node validation", func() {

	updateCases := []struct {
		Title   string
		OldNode *Node
		NewNode *Node
		Errors  field.ErrorList
	}{
		{
			Title: "network #1",
			OldNode: &Node{
				Spec: NodeSpec{
					Network: MainNetwork,
				},
			},
			NewNode: &Node{
				Spec: NodeSpec{
					Network: CalibrationNetwork,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: CalibrationNetwork,
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.NewNode.Default()
					cc.OldNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/filecoin/v1alpha1/node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var nodelog = logf.Log.WithName("node-resource")

// SetupWebhookWithManager sets up the webook with a given controller manager
func (n *Node) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(n).
		Complete()
}

'''
'''--- apis/filecoin/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/filecoin/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/graph/v1alpha1/defaults.go ---
package v1alpha1

// DefaultGraphNodeImage is the default Graph node client image
const DefaultGraphNodeImage = "graphprotocol/graph-node:v0.27.0"

'''
'''--- apis/graph/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the graph v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=graph.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "graph.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/graph/v1alpha1/node.go ---
package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NodeSpec defines the desired state of Node
type NodeSpec struct {
	// TODO: default node image
	// Image is Graph node client image
	Image string `json:"image,omitempty"`
}

// NodeStatus defines the observed state of Node
type NodeStatus struct {
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// Node is the Schema for the nodes API
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/graph/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/ipfs/v1alpha1/cluster_peer.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ClusterPeerSpec defines the desired state of ClusterPeer
type ClusterPeerSpec struct {
	// Image is ipfs cluster peer client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// ID is the the cluster peer id
	ID string `json:"id,omitempty"`
	// PrivateKeySecretName is k8s secret holding private key
	PrivateKeySecretName string `json:"privateKeySecretName,omitempty"`
	// TrustedPeers is CRDT trusted cluster peers who can manage the pinset
	// +listType=set
	TrustedPeers []string `json:"trustedPeers,omitempty"`
	// BootstrapPeers are ipfs cluster peers to connect to
	// +listType=set
	BootstrapPeers []string `json:"bootstrapPeers,omitempty"`
	// Consensus is ipfs cluster consensus algorithm
	Consensus ConsensusAlgorithm `json:"consensus,omitempty"`
	// ClusterSecretName is k8s secret holding cluster secret
	ClusterSecretName string `json:"clusterSecretName"`
	// PeerEndpoint is ipfs peer http API endpoint
	PeerEndpoint string `json:"peerEndpoint"`
	// Logging is logging verboisty level
	// +kubebuilder:validation:Enum=error;warn;info;debug
	Logging shared.VerbosityLevel `json:"logging,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// ConsensusAlgorithm is IPFS cluster consensus algorithm
// +kubebuilder:validation:Enum=crdt;raft
type ConsensusAlgorithm string

const (
	// CRDT consensus algorithm
	CRDT ConsensusAlgorithm = "crdt"
	// Raft consensus algorithm
	Raft ConsensusAlgorithm = "raft"
)

// ClusterPeerStatus defines the observed state of ClusterPeer
type ClusterPeerStatus struct {
	Client    string `json:"client"`
	Consensus string `json:"consensus"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// ClusterPeer is the Schema for the clusterpeers API
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".status.client"
// +kubebuilder:printcolumn:name="Consensus",type=string,JSONPath=".spec.consensus"
type ClusterPeer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ClusterPeerSpec   `json:"spec,omitempty"`
	Status ClusterPeerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterPeerList contains a list of ClusterPeer
type ClusterPeerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterPeer `json:"items"`
}

func init() {
	SchemeBuilder.Register(&ClusterPeer{}, &ClusterPeerList{})
}

'''
'''--- apis/ipfs/v1alpha1/cluster_peer_defaulting_webhook.go ---
package v1alpha1

import "sigs.k8s.io/controller-runtime/pkg/webhook"

// +kubebuilder:webhook:path=/mutate-ipfs-kotal-io-v1alpha1-clusterpeer,mutating=true,failurePolicy=fail,groups=ipfs.kotal.io,resources=clusterpeers,verbs=create;update,versions=v1alpha1,name=mutate-ipfs-v1alpha1-clusterpeer.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &ClusterPeer{}

// DefaultResources defaults cluster peer resources
func (r *ClusterPeer) DefaultResources() {
	if r.Spec.Resources.CPU == "" {
		r.Spec.Resources.CPU = DefaultNodeCPURequest
	}

	if r.Spec.Resources.CPULimit == "" {
		r.Spec.Resources.CPULimit = DefaultNodeCPULimit
	}

	if r.Spec.Resources.Memory == "" {
		r.Spec.Resources.Memory = DefaultNodeMemoryRequest
	}

	if r.Spec.Resources.MemoryLimit == "" {
		r.Spec.Resources.MemoryLimit = DefaultNodeMemoryLimit
	}

	if r.Spec.Resources.Storage == "" {
		r.Spec.Resources.Storage = DefaultNodeStorageRequest
	}
}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *ClusterPeer) Default() {
	clusterpeerlog.Info("default", "name", r.Name)

	if r.Spec.Image == "" {
		r.Spec.Image = DefaultGoIPFSClusterImage
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	if r.Spec.Logging == "" {
		r.Spec.Logging = DefaultLogging
	}

	if r.Spec.Consensus == "" {
		r.Spec.Consensus = DefaultIPFSClusterConsensus
	}

	if len(r.Spec.TrustedPeers) == 0 {
		r.Spec.TrustedPeers = []string{"*"}
	}

	r.DefaultResources()
}

'''
'''--- apis/ipfs/v1alpha1/cluster_peer_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("IPFS cluster peer defaulting", func() {
	It("Should default ipfs cluster peer", func() {
		peer := ClusterPeer{
			ObjectMeta: metav1.ObjectMeta{},
			Spec:       ClusterPeerSpec{},
		}

		peer.Default()

		Expect(peer.Spec.Image).To(Equal(DefaultGoIPFSClusterImage))
		Expect(*peer.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(peer.Spec.Logging).To(Equal(DefaultLogging))
		Expect(peer.Spec.Resources.CPU).To(Equal(DefaultNodeCPURequest))
		Expect(peer.Spec.Resources.CPULimit).To(Equal(DefaultNodeCPULimit))
		Expect(peer.Spec.Resources.Memory).To(Equal(DefaultNodeMemoryRequest))
		Expect(peer.Spec.Resources.MemoryLimit).To(Equal(DefaultNodeMemoryLimit))
		Expect(peer.Spec.Resources.Storage).To(Equal(DefaultNodeStorageRequest))
		Expect(peer.Spec.Consensus).To(Equal(DefaultIPFSClusterConsensus))
	})
})

'''
'''--- apis/ipfs/v1alpha1/cluster_peer_validation_webhook.go ---
package v1alpha1

import (
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-ipfs-kotal-io-v1alpha1-clusterpeer,mutating=false,failurePolicy=fail,groups=ipfs.kotal.io,resources=clusterpeers,versions=v1alpha1,name=validate-ipfs-v1alpha1-clusterpeer.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &ClusterPeer{}

// validate validates a node with a given path
func (r *ClusterPeer) validate() field.ErrorList {
	var nodeErrors field.ErrorList

	// privateKeySecretName is required if id is given
	if r.Spec.ID != "" && r.Spec.PrivateKeySecretName == "" {
		err := field.Invalid(field.NewPath("spec").Child("privateKeySecretName"), "", "must provide privateKeySecretName if id is provided")
		nodeErrors = append(nodeErrors, err)
	}

	// id is required if privateKeySecretName is given
	if r.Spec.PrivateKeySecretName != "" && r.Spec.ID == "" {
		err := field.Invalid(field.NewPath("spec").Child("id"), "", "must provide id if privateKeySecretName is provided")
		nodeErrors = append(nodeErrors, err)
	}

	return nodeErrors

}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *ClusterPeer) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	clusterpeerlog.Info("validate create", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *ClusterPeer) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldClusterPeer := old.(*ClusterPeer)

	clusterpeerlog.Info("validate update", "name", r.Name)

	if oldClusterPeer.Spec.Consensus != r.Spec.Consensus {
		err := field.Invalid(field.NewPath("spec").Child("consensus"), r.Spec.Consensus, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if oldClusterPeer.Spec.ID != r.Spec.ID {
		err := field.Invalid(field.NewPath("spec").Child("id"), r.Spec.ID, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if oldClusterPeer.Spec.PrivateKeySecretName != r.Spec.PrivateKeySecretName {
		err := field.Invalid(field.NewPath("spec").Child("privateKeySecretName"), r.Spec.PrivateKeySecretName, "field is immutable")
		allErrors = append(allErrors, err)
	}

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateUpdate(&oldClusterPeer.Spec.Resources)...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *ClusterPeer) ValidateDelete() (admission.Warnings, error) {
	clusterpeerlog.Info("validate delete", "name", r.Name)

	return nil, nil
}

'''
'''--- apis/ipfs/v1alpha1/cluster_peer_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("IPFS cluster peer validation", func() {
	createCases := []struct {
		Title  string
		Peer   *ClusterPeer
		Errors field.ErrorList
	}{
		{
			Title: "Cluster Peer #1",
			Peer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					ID: "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuiq",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.privateKeySecretName",
					BadValue: "",
					Detail:   "must provide privateKeySecretName if id is provided",
				},
			},
		},
		{
			Title: "Cluster Peer #1",
			Peer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					PrivateKeySecretName: "my-cluster-privatekey",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.id",
					BadValue: "",
					Detail:   "must provide id if privateKeySecretName is provided",
				},
			},
		},
	}

	updateCases := []struct {
		Title   string
		Peer    *ClusterPeer
		NewPeer *ClusterPeer
		Errors  field.ErrorList
	}{
		{
			Title: "Cluster Peer #1",
			Peer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					ID:                   "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuiq",
					PrivateKeySecretName: "my-cluster-privatekey",
				},
			},
			NewPeer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					ID: "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuiq",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.privateKeySecretName",
					BadValue: "",
					Detail:   "must provide privateKeySecretName if id is provided",
				},
			},
		},
		{
			Title: "Cluster Peer #2",
			Peer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					PrivateKeySecretName: "my-cluster-privatekey",
					ID:                   "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuiq",
				},
			},
			NewPeer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					PrivateKeySecretName: "my-cluster-privatekey",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.id",
					BadValue: "",
					Detail:   "must provide id if privateKeySecretName is provided",
				},
			},
		},
		{
			Title: "Cluster Peer #3",
			Peer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					Consensus: CRDT,
				},
			},
			NewPeer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					Consensus: Raft,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.consensus",
					BadValue: Raft,
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "Cluster Peer #4",
			Peer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					PrivateKeySecretName: "my-cluster-privatekey",
					ID:                   "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuiq",
				},
			},
			NewPeer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					PrivateKeySecretName: "my-cluster-privatekey",
					ID:                   "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuir",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.id",
					BadValue: "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuir",
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "Cluster Peer #5",
			Peer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					PrivateKeySecretName: "my-cluster-privatekey",
					ID:                   "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuir",
				},
			},
			NewPeer: &ClusterPeer{
				Spec: ClusterPeerSpec{
					PrivateKeySecretName: "your-cluster-privatekey",
					ID:                   "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuir",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.privateKeySecretName",
					BadValue: "your-cluster-privatekey",
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating cluster peer", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Peer.Default()
					_, err := cc.Peer.ValidateCreate()

					// all test cases has validation errors
					Expect(err).NotTo(BeNil())

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating cluster peer", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Peer.Default()
					cc.NewPeer.Default()
					_, err := cc.NewPeer.ValidateUpdate(cc.Peer)

					// all test cases has validation errors
					Expect(err).NotTo(BeNil())

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})
})

'''
'''--- apis/ipfs/v1alpha1/cluster_peer_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var clusterpeerlog = logf.Log.WithName("clusterpeer-resource")

func (r *ClusterPeer) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/ipfs/v1alpha1/defaults.go ---
package v1alpha1

import "github.com/kotalco/kotal/apis/shared"

const (
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// DefaultRoutingMode is the default content routing mechanism
	DefaultRoutingMode = DHTRouting
	// DefaultAPIPort is the default API port
	DefaultAPIPort uint = 5001
	// DefaultGatewayPort is the default local gateway port
	DefaultGatewayPort uint = 8080
	// DefaultLogging is the default logging verbosity level
	DefaultLogging = shared.InfoLogs
)

const (
	// DefaultGoIPFSImage is the default go ipfs client image
	DefaultGoIPFSImage = "kotalco/kubo:v0.28.0"
	// DefaultGoIPFSClusterImage is the default go ipfs cluster client image
	DefaultGoIPFSClusterImage = "kotalco/ipfs-cluster:v1.0.8"
)

// Resources
const (
	// DefaultNodeCPURequest is the cpu requested by ipfs node
	DefaultNodeCPURequest = "1"
	// DefaultNodeCPULimit is the cpu limit for ipfs node
	DefaultNodeCPULimit = "2"

	// DefaultNodeMemoryRequest is the memory requested by ipfs node
	DefaultNodeMemoryRequest = "2Gi"
	// DefaultNodeMemoryLimit is the memory limit for ipfs node
	DefaultNodeMemoryLimit = "4Gi"

	// DefaultNodeStorageRequest is the Storage requested by ipfs node
	DefaultNodeStorageRequest = "10Gi"
)

// Cluster peer
const (
	// DefaultIPFSClusterConsensus is the default ipfs cluster consensus algorithm
	DefaultIPFSClusterConsensus = CRDT
)

'''
'''--- apis/ipfs/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the ipfs v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=ipfs.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "ipfs.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/ipfs/v1alpha1/peer.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// PeerSpec defines the desired state of Peer
type PeerSpec struct {
	// Image is ipfs peer client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// InitProfiles is the intial profiles to apply during
	// +listType=set
	InitProfiles []Profile `json:"initProfiles,omitempty"`
	// Profiles is the configuration profiles to apply after peer initialization
	// +listType=set
	Profiles []Profile `json:"profiles,omitempty"`
	// API enables API server
	API bool `json:"api,omitempty"`
	// APIPort is api server port
	APIPort uint `json:"apiPort,omitempty"`
	// Gateway enables IPFS gateway server
	Gateway bool `json:"gateway,omitempty"`
	// GatewayPort is local gateway port
	GatewayPort uint `json:"gatewayPort,omitempty"`
	// Routing is the content routing mechanism
	Routing RoutingMechanism `json:"routing,omitempty"`
	// SwarmKeySecretName is the k8s secret holding swarm key
	SwarmKeySecretName string `json:"swarmKeySecretName,omitempty"`
	// Logging is logging verboisty level
	// +kubebuilder:validation:Enum=error;warn;info;debug;notice
	Logging shared.VerbosityLevel `json:"logging,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// Profile is ipfs configuration
// +kubebuilder:validation:Enum=server;randomports;default-datastore;local-discovery;test;default-networking;flatfs;badgerds;lowpower
type Profile string

const (
	// ServerProfile is the server profile
	ServerProfile Profile = "server"
	// RandomPortsProfile is the random ports profile
	RandomPortsProfile Profile = "randomports"
	// DefaultDatastoreProfile is the default data store profile
	DefaultDatastoreProfile Profile = "default-datastore"
	// LocalDiscoveryProfile is the local discovery profile
	LocalDiscoveryProfile Profile = "local-discovery"
	// TestProfile is the test profile
	TestProfile Profile = "test"
	// DefaultNetworkingProfile is the default networking profile
	DefaultNetworkingProfile Profile = "default-networking"
	// FlatFSProfile is the flat file system profile
	FlatFSProfile Profile = "flatfs"
	// BadgerDSProfile is badger data store profile
	BadgerDSProfile Profile = "badgerds"
	// LowPowerProfile is the low power profile
	LowPowerProfile Profile = "lowpower"
)

// RoutingMechanism is the content routing mechanism
// +kubebuilder:validation:Enum=none;dht;dhtclient;dhtserver
type RoutingMechanism string

const (
	// NoneRouting is no routing mechanism
	NoneRouting RoutingMechanism = "none"
	// DHTRouting is automatic dht routing mechanism
	DHTRouting RoutingMechanism = "dht"
	// DHTClientRouting is the dht client routing mechanism
	DHTClientRouting RoutingMechanism = "dhtclient"
	// DHTServerRouting is the dht server routing mechanism
	DHTServerRouting RoutingMechanism = "dhtserver"
)

// PeerStatus defines the observed state of Peer
type PeerStatus struct {
	Client string `json:"client,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Peer is the Schema for the peers API
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".status.client"
type Peer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   PeerSpec   `json:"spec,omitempty"`
	Status PeerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PeerList contains a list of Peer
type PeerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Peer `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Peer{}, &PeerList{})
}

'''
'''--- apis/ipfs/v1alpha1/peer_defaulting_webhook.go ---
package v1alpha1

import "sigs.k8s.io/controller-runtime/pkg/webhook"

// +kubebuilder:webhook:path=/mutate-ipfs-kotal-io-v1alpha1-peer,mutating=true,failurePolicy=fail,groups=ipfs.kotal.io,resources=peers,verbs=create;update,versions=v1alpha1,name=mutate-ipfs-v1alpha1-peer.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Peer{}

// DefaultPeerResources defaults peer resources
func (r *Peer) DefaultPeerResources() {
	if r.Spec.Resources.CPU == "" {
		r.Spec.Resources.CPU = DefaultNodeCPURequest
	}

	if r.Spec.Resources.CPULimit == "" {
		r.Spec.Resources.CPULimit = DefaultNodeCPULimit
	}

	if r.Spec.Resources.Memory == "" {
		r.Spec.Resources.Memory = DefaultNodeMemoryRequest
	}

	if r.Spec.Resources.MemoryLimit == "" {
		r.Spec.Resources.MemoryLimit = DefaultNodeMemoryLimit
	}

	if r.Spec.Resources.Storage == "" {
		r.Spec.Resources.Storage = DefaultNodeStorageRequest
	}
}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Peer) Default() {
	peerlog.Info("default", "name", r.Name)

	if r.Spec.Image == "" {
		r.Spec.Image = DefaultGoIPFSImage
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	if r.Spec.Routing == "" {
		r.Spec.Routing = DefaultRoutingMode
	}

	if r.Spec.APIPort == 0 {
		r.Spec.APIPort = DefaultAPIPort
	}

	if r.Spec.GatewayPort == 0 {
		r.Spec.GatewayPort = DefaultGatewayPort
	}

	if len(r.Spec.InitProfiles) == 0 {
		r.Spec.InitProfiles = []Profile{DefaultDatastoreProfile}
	}

	if r.Spec.Logging == "" {
		r.Spec.Logging = DefaultLogging
	}

	r.DefaultPeerResources()

}

'''
'''--- apis/ipfs/v1alpha1/peer_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("IPFS peer defaulting", func() {
	It("Should default ipfs peer", func() {
		peer := Peer{
			ObjectMeta: metav1.ObjectMeta{},
			Spec:       PeerSpec{},
		}

		peer.Default()

		Expect(peer.Spec.Image).To(Equal(DefaultGoIPFSImage))
		Expect(*peer.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(peer.Spec.Logging).To(Equal(DefaultLogging))
		Expect(peer.Spec.InitProfiles).To(ContainElements(DefaultDatastoreProfile))
		Expect(peer.Spec.APIPort).To(Equal(DefaultAPIPort))
		Expect(peer.Spec.GatewayPort).To(Equal(DefaultGatewayPort))
		Expect(peer.Spec.Routing).To(Equal(DefaultRoutingMode))
		Expect(peer.Spec.Resources.CPU).To(Equal(DefaultNodeCPURequest))
		Expect(peer.Spec.Resources.CPULimit).To(Equal(DefaultNodeCPULimit))
		Expect(peer.Spec.Resources.Memory).To(Equal(DefaultNodeMemoryRequest))
		Expect(peer.Spec.Resources.MemoryLimit).To(Equal(DefaultNodeMemoryLimit))
		Expect(peer.Spec.Resources.Storage).To(Equal(DefaultNodeStorageRequest))
	})
})

'''
'''--- apis/ipfs/v1alpha1/peer_validation_webhook.go ---
package v1alpha1

import (
	"strings"

	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-ipfs-kotal-io-v1alpha1-peer,mutating=false,failurePolicy=fail,groups=ipfs.kotal.io,resources=peers,versions=v1alpha1,name=validate-ipfs-v1alpha1-peer.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Peer{}

// ValidateCreate valdates ipfs peers during their creation
func (p *Peer) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	peerlog.Info("validate create", "name", p.Name)

	allErrors = append(allErrors, p.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, p.Name, allErrors)
}

// initProfilesChanged returns true if initial profiles changed
func initProfilesChanged(old, peer *Peer) bool {
	for i, profile := range old.Spec.InitProfiles {
		if peer.Spec.InitProfiles[i] != profile {
			return true
		}
	}
	return false
}

// ValidateUpdate validates ipfs peers while being updated
func (p *Peer) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldPeer := old.(*Peer)

	peerlog.Info("validate update", "name", p.Name)

	if oldPeer.Spec.SwarmKeySecretName != p.Spec.SwarmKeySecretName {
		err := field.Invalid(field.NewPath("spec").Child("swarmKeySecretName"), p.Spec.SwarmKeySecretName, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if len(oldPeer.Spec.InitProfiles) != len(p.Spec.InitProfiles) || initProfilesChanged(oldPeer, p) {
		profiles := []string{}
		for _, profile := range p.Spec.InitProfiles {
			profiles = append(profiles, string(profile))
		}
		err := field.Invalid(field.NewPath("spec").Child("initProfiles"), strings.Join(profiles, ","), "field is immutable")
		allErrors = append(allErrors, err)
	}

	allErrors = append(allErrors, p.Spec.Resources.ValidateUpdate(&oldPeer.Spec.Resources)...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, p.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (p *Peer) ValidateDelete() (admission.Warnings, error) {
	peerlog.Info("validate delete", "name", p.Name)

	return nil, nil
}

'''
'''--- apis/ipfs/v1alpha1/peer_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("IPFS peer validation", func() {
	createCases := []struct {
		Title  string
		Peer   *Peer
		Errors field.ErrorList
	}{
		{
			Title: "Peer #1",
			Peer: &Peer{
				Spec: PeerSpec{
					Resources: shared.Resources{
						CPU:      "2",
						CPULimit: "1",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.cpuLimit",
					BadValue: "1",
					Detail:   "must be greater than or equal to cpu 2",
				},
			},
		},
		{
			Title: "Peer #3",
			Peer: &Peer{
				Spec: PeerSpec{
					Resources: shared.Resources{
						Memory:      "2Gi",
						MemoryLimit: "1Gi",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.memoryLimit",
					BadValue: "1Gi",
					Detail:   "must be greater than memory 2Gi",
				},
			},
		},
	}

	updateCases := []struct {
		Title   string
		Peer    *Peer
		NewPeer *Peer
		Errors  field.ErrorList
	}{
		{
			Title: "Peer #1",
			Peer: &Peer{
				Spec: PeerSpec{
					Resources: shared.Resources{
						CPU:      "1",
						CPULimit: "1",
					},
				},
			},
			NewPeer: &Peer{
				Spec: PeerSpec{
					Resources: shared.Resources{
						CPU:      "2",
						CPULimit: "1",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.cpuLimit",
					BadValue: "1",
					Detail:   "must be greater than or equal to cpu 2",
				},
			},
		},
		{
			Title: "Peer #3",
			Peer: &Peer{
				Spec: PeerSpec{
					Resources: shared.Resources{
						Memory:      "1Gi",
						MemoryLimit: "2Gi",
					},
				},
			},
			NewPeer: &Peer{
				Spec: PeerSpec{
					Resources: shared.Resources{
						Memory:      "2Gi",
						MemoryLimit: "1Gi",
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.memoryLimit",
					BadValue: "1Gi",
					Detail:   "must be greater than memory 2Gi",
				},
			},
		},
		{
			Title: "Peer #4",
			Peer: &Peer{
				Spec: PeerSpec{
					SwarmKeySecretName: "my-swarm-key",
				},
			},
			NewPeer: &Peer{
				Spec: PeerSpec{
					SwarmKeySecretName: "your-swarm-key",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.swarmKeySecretName",
					BadValue: "your-swarm-key",
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "Peer #5",
			Peer: &Peer{
				Spec: PeerSpec{
					InitProfiles: []Profile{
						ServerProfile,
						BadgerDSProfile,
					},
				},
			},
			NewPeer: &Peer{
				Spec: PeerSpec{
					InitProfiles: []Profile{
						TestProfile,
						ServerProfile,
					},
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.initProfiles",
					BadValue: "test,server",
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating peer", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Peer.Default()
					_, err := cc.Peer.ValidateCreate()

					// all test cases has validation errors
					Expect(err).NotTo(BeNil())

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating peer", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Peer.Default()
					cc.NewPeer.Default()
					_, err := cc.NewPeer.ValidateUpdate(cc.Peer)

					// all test cases has validation errors
					Expect(err).NotTo(BeNil())

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})
})

'''
'''--- apis/ipfs/v1alpha1/peer_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var peerlog = logf.Log.WithName("peer-resource")

func (r *Peer) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/ipfs/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/ipfs/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterPeer) DeepCopyInto(out *ClusterPeer) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterPeer.
func (in *ClusterPeer) DeepCopy() *ClusterPeer {
	if in == nil {
		return nil
	}
	out := new(ClusterPeer)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterPeer) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterPeerList) DeepCopyInto(out *ClusterPeerList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClusterPeer, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterPeerList.
func (in *ClusterPeerList) DeepCopy() *ClusterPeerList {
	if in == nil {
		return nil
	}
	out := new(ClusterPeerList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterPeerList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterPeerSpec) DeepCopyInto(out *ClusterPeerSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.TrustedPeers != nil {
		in, out := &in.TrustedPeers, &out.TrustedPeers
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.BootstrapPeers != nil {
		in, out := &in.BootstrapPeers, &out.BootstrapPeers
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterPeerSpec.
func (in *ClusterPeerSpec) DeepCopy() *ClusterPeerSpec {
	if in == nil {
		return nil
	}
	out := new(ClusterPeerSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterPeerStatus) DeepCopyInto(out *ClusterPeerStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterPeerStatus.
func (in *ClusterPeerStatus) DeepCopy() *ClusterPeerStatus {
	if in == nil {
		return nil
	}
	out := new(ClusterPeerStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Peer) DeepCopyInto(out *Peer) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Peer.
func (in *Peer) DeepCopy() *Peer {
	if in == nil {
		return nil
	}
	out := new(Peer)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Peer) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PeerList) DeepCopyInto(out *PeerList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Peer, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PeerList.
func (in *PeerList) DeepCopy() *PeerList {
	if in == nil {
		return nil
	}
	out := new(PeerList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PeerList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PeerSpec) DeepCopyInto(out *PeerSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.InitProfiles != nil {
		in, out := &in.InitProfiles, &out.InitProfiles
		*out = make([]Profile, len(*in))
		copy(*out, *in)
	}
	if in.Profiles != nil {
		in, out := &in.Profiles, &out.Profiles
		*out = make([]Profile, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PeerSpec.
func (in *PeerSpec) DeepCopy() *PeerSpec {
	if in == nil {
		return nil
	}
	out := new(PeerSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PeerStatus) DeepCopyInto(out *PeerStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PeerStatus.
func (in *PeerStatus) DeepCopy() *PeerStatus {
	if in == nil {
		return nil
	}
	out := new(PeerStatus)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/near/v1alpha1/defaults.go ---
package v1alpha1

const (
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// DefaultRPCPort is the default JSON-RPC port
	DefaultRPCPort uint = 3030
	// DefaultP2PPort is the default p2p port
	DefaultP2PPort uint = 24567
	// DefaultMinPeers is the default minimum number of peers required to start syncing/producing blocks
	DefaultMinPeers uint = 5
	// DefaultPrometheusPort is the default prometheus exporter port
	DefaultPrometheusPort uint = 9615
)

const (
	// DefaultNearImage is the default NEAR core client image
	DefaultNearImage = "kotalco/nearcore:v1.39.1"
)

// Resources
const (
	// DefaultNodeCPURequest is the cpu requested by NEAR node
	DefaultNodeCPURequest = "4"
	// DefaultNodeCPULimit is the cpu limit for NEAR node
	DefaultNodeCPULimit = "8"

	// DefaultNodeMemoryRequest is the memory requested by NEAR node
	DefaultNodeMemoryRequest = "4Gi"
	// DefaultNodeMemoryLimit is the memory limit for NEAR node
	DefaultNodeMemoryLimit = "8Gi"

	// DefaultNodeStorageRequest is the Storage requested by NEAR node
	DefaultNodeStorageRequest = "250Gi"
	// DefaultArchivalNodeStorageRequest is the Storage requested by NEAR archival node
	DefaultArchivalNodeStorageRequest = "4Ti"
)

'''
'''--- apis/near/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the near v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=near.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "near.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/near/v1alpha1/node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NodeSpec defines the desired state of Node
type NodeSpec struct {
	// Image is NEAR node client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// Network is NEAR network to join and sync
	// +kubebuilder:validation:Enum=mainnet;testnet;betanet
	Network string `json:"network"`
	// NodePrivateKeySecretName is the secret name holding node Ed25519 private key
	NodePrivateKeySecretName string `json:"nodePrivateKeySecretName,omitempty"`
	// ValidatorSecretName is the secret name holding node Ed25519 validator key
	ValidatorSecretName string `json:"validatorSecretName,omitempty"`
	// MinPeers is minimum number of peers to start syncing/producing blocks
	MinPeers uint `json:"minPeers,omitempty"`
	// Archive keeps old blocks in the storage
	Archive bool `json:"archive,omitempty"`
	// P2PPort is p2p port
	P2PPort uint `json:"p2pPort,omitempty"`
	// RPC enables JSON-RPC server
	RPC bool `json:"rpc,omitempty"`
	// RPCPort is JSON-RPC server listening port
	RPCPort uint `json:"rpcPort,omitempty"`
	// PrometheusPort is prometheus exporter port
	PrometheusPort uint `json:"prometheusPort,omitempty"`
	// TelemetryURL is telemetry service URL
	TelemetryURL string `json:"telemetryURL,omitempty"`
	// Bootnodes is array of boot nodes to bootstrap network from
	// +listType=set
	Bootnodes []string `json:"bootnodes,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// NodeStatus defines the observed state of Node
type NodeStatus struct {
	Client string `json:"client,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Node is the Schema for the nodes API
// +kubebuilder:printcolumn:name="Network",type=string,JSONPath=".spec.network"
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".status.client"
// +kubebuilder:printcolumn:name="Validator",type=boolean,JSONPath=".spec.validator",priority=10
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/near/v1alpha1/node_defaulting_webhook.go ---
package v1alpha1

import (
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-near-kotal-io-v1alpha1-node,mutating=true,failurePolicy=fail,groups=near.kotal.io,resources=nodes,verbs=create;update,versions=v1alpha1,name=mutate-near-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Node{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (n *Node) Default() {
	nodelog.Info("default", "name", n.Name)

	if n.Spec.Image == "" {
		n.Spec.Image = DefaultNearImage
	}

	if n.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		n.Spec.Replicas = &replicas
	}

	if n.Spec.MinPeers == 0 {
		n.Spec.MinPeers = DefaultMinPeers
	}

	if n.Spec.RPCPort == 0 {
		n.Spec.RPCPort = DefaultRPCPort
	}

	if n.Spec.PrometheusPort == 0 {
		n.Spec.PrometheusPort = DefaultPrometheusPort
	}

	if n.Spec.P2PPort == 0 {
		n.Spec.P2PPort = DefaultP2PPort
	}

	if n.Spec.CPU == "" {
		n.Spec.CPU = DefaultNodeCPURequest
	}
	if n.Spec.CPULimit == "" {
		n.Spec.CPULimit = DefaultNodeCPULimit
	}

	if n.Spec.Memory == "" {
		n.Spec.Memory = DefaultNodeMemoryRequest
	}
	if n.Spec.MemoryLimit == "" {
		n.Spec.MemoryLimit = DefaultNodeMemoryLimit
	}

	if n.Spec.Storage == "" {
		storage := DefaultNodeStorageRequest
		if n.Spec.Archive {
			storage = DefaultArchivalNodeStorageRequest
		}
		n.Spec.Storage = storage
	}

}

'''
'''--- apis/near/v1alpha1/node_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("NEAR node defaulting", func() {
	It("Should default NEAR node", func() {
		node := Node{
			ObjectMeta: metav1.ObjectMeta{},
			Spec: NodeSpec{
				Network: "mainnet",
				RPC:     true,
			},
		}

		node.Default()

		Expect(node.Spec.Image).To(Equal(DefaultNearImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.RPCPort).To(Equal(DefaultRPCPort))
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.MinPeers).To(Equal(DefaultMinPeers))
		Expect(node.Spec.PrometheusPort).To(Equal(DefaultPrometheusPort))

		Expect(node.Spec.Resources.CPU).To(Equal(DefaultNodeCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultNodeCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultNodeMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultNodeMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultNodeStorageRequest))
	})
})

'''
'''--- apis/near/v1alpha1/node_validation_webhook.go ---
package v1alpha1

import (
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-near-kotal-io-v1alpha1-node,mutating=false,failurePolicy=fail,groups=near.kotal.io,resources=nodes,versions=v1alpha1,name=validate-near-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Node{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	nodelog.Info("validate create", "name", n.Name)

	allErrors = append(allErrors, n.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, n.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldNode := old.(*Node)

	nodelog.Info("validate update", "name", n.Name)

	allErrors = append(allErrors, n.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if n.Spec.Network != oldNode.Spec.Network {
		err := field.Invalid(field.NewPath("spec").Child("network"), n.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, n.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (n *Node) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", n.Name)

	return nil, nil
}

'''
'''--- apis/near/v1alpha1/node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("NEAR node validation", func() {
	createCases := []struct {
		Title  string
		Node   *Node
		Errors field.ErrorList
	}{}

	updateCases := []struct {
		Title   string
		OldNode *Node
		NewNode *Node
		Errors  field.ErrorList
	}{
		{
			Title: "updated network",
			OldNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "mainnet",
				},
			},
			NewNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "testnet",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: "testnet",
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Node.Default()
					_, err := cc.Node.ValidateCreate()

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldNode.Default()
					cc.NewNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/near/v1alpha1/node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var nodelog = logf.Log.WithName("node-resource")

func (n *Node) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(n).
		Complete()
}

'''
'''--- apis/near/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/near/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.Bootnodes != nil {
		in, out := &in.Bootnodes, &out.Bootnodes
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/polkadot/v1alpha1/defaults.go ---
package v1alpha1

import "github.com/kotalco/kotal/apis/shared"

const (
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// DefaultSyncMode is the default blockchain sync mode
	DefaultSyncMode = FullSynchronization
	// DefaultLoggingVerbosity is the default node logging verbosity
	DefaultLoggingVerbosity = shared.InfoLogs
	// DefaultRetainedBlocks is the default node of blocks to retain if node isn't archive
	DefaultRetainedBlocks uint = 256
	// DefaultRPCPort is the default JSON-RPC server port
	DefaultRPCPort uint = 9933
	// DefaultP2PPort is the p2p protocol tcp port
	DefaultP2PPort uint = 30333
	// DefaultWSPort is the default websocket server port
	DefaultWSPort uint = 9944
	// DefaultTelemetryURL is the default telemetry service URL
	DefaultTelemetryURL = "wss://telemetry.polkadot.io/submit/ 0"
	// DefaultPrometheusPort is the default prometheus exporter port
	DefaultPrometheusPort uint = 9615
	// DefaultCORSDomain is the default browser origin allowed to access the JSON-RPC HTTP and WS servers
	DefaultCORSDomain = "all"
	// DefaultDatabaseBackend is the default database backend
	DefaultDatabaseBackend DatabaseBackend = Auto
)

const (
	// DefaultPolkadotImage is the default polkadot client image
	DefaultPolkadotImage = "parity/polkadot:v1.10.0"
)

// Resources
const (
	// DefaultNodeCPURequest is the cpu requested by polkadot node
	DefaultNodeCPURequest = "4"
	// DefaultNodeCPULimit is the cpu limit for polkadot node
	DefaultNodeCPULimit = "8"

	// DefaultNodeMemoryRequest is the memory requested by polkadot node
	DefaultNodeMemoryRequest = "4Gi"
	// DefaultNodeMemoryLimit is the memory limit for polkadot node
	DefaultNodeMemoryLimit = "8Gi"

	// DefaultNodeStorageRequest is the Storage requested by polkadot node
	DefaultNodeStorageRequest = "80Gi"
)

'''
'''--- apis/polkadot/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the polkadot v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=polkadot.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "polkadot.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/polkadot/v1alpha1/node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// SynchronizationMode is the blockchain synchronization mode
// +kubebuilder:validation:Enum=fast;full
type SynchronizationMode string

// +kubebuilder:validation:Enum=auto;paritydb;rocksdb
type DatabaseBackend string

const (
	//FastSynchronization is the fast synchronization mode
	FastSynchronization SynchronizationMode = "fast"
	//FullSynchronization is the full archival synchronization mode
	FullSynchronization SynchronizationMode = "full"
)

const (
	// Auto databse backend
	Auto DatabaseBackend = "auto"
	// ParityDB databse backend
	ParityDB DatabaseBackend = "paritydb"
	// RocksDB databse backend
	RocksDB DatabaseBackend = "rocksdb"
)

// NodeSpec defines the desired state of Node
type NodeSpec struct {
	// Image is Polkadot node client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// Network is the polkadot network/chain to join
	// +kubebuilder:validation:Enum=polkadot;kusama;rococo;westend
	Network string `json:"network"`
	// P2PPort is p2p protocol tcp port
	P2PPort uint `json:"p2pPort,omitempty"`
	// NodePrivateKeySecretName is the secret name holding node Ed25519 private key
	NodePrivateKeySecretName string `json:"nodePrivateKeySecretName,omitempty"`
	// Validator enables validator mode
	Validator bool `json:"validator,omitempty"`
	// SyncMode is the blockchain synchronization mode
	SyncMode SynchronizationMode `json:"syncMode,omitempty"`
	// Pruning keeps recent or all blocks
	Pruning *bool `json:"pruning,omitempty"`
	// RetainedBlocks is the number of blocks to keep state for
	RetainedBlocks uint `json:"retainedBlocks,omitempty"`
	// Database is database backend
	Database DatabaseBackend `json:"database,omitempty"`
	// Logging is logging verboisty level
	// +kubebuilder:validation:Enum=error;warn;info;debug;trace
	Logging shared.VerbosityLevel `json:"logging,omitempty"`
	// Telemetry enables connecting to telemetry server
	Telemetry bool `json:"telemetry,omitempty"`
	// TelemetryURL is telemetry service URL
	TelemetryURL string `json:"telemetryURL,omitempty"`
	// Prometheus exposes a prometheus exporter endpoint.
	Prometheus bool `json:"prometheus,omitempty"`
	// PrometheusPort is prometheus exporter port
	PrometheusPort uint `json:"prometheusPort,omitempty"`
	// RPC enables JSON-RPC server
	RPC bool `json:"rpc,omitempty"`
	// RPCPort is JSON-RPC server port
	RPCPort uint `json:"rpcPort,omitempty"`
	// WS enables Websocket server
	WS bool `json:"ws,omitempty"`
	// WSPort is Websocket server port
	WSPort uint `json:"wsPort,omitempty"`
	// CORSDomains is browser origins allowed to access the JSON-RPC HTTP and WS servers
	// +listType=set
	CORSDomains []string `json:"corsDomains,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// NodeStatus defines the observed state of Node
type NodeStatus struct {
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Node is the Schema for the nodes API
// +kubebuilder:printcolumn:name="Network",type=string,JSONPath=".spec.network"
// +kubebuilder:printcolumn:name="Validator",type=boolean,JSONPath=".spec.validator"
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/polkadot/v1alpha1/node_defaulting_webhook.go ---
package v1alpha1

import (
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-polkadot-kotal-io-v1alpha1-node,mutating=true,failurePolicy=fail,groups=polkadot.kotal.io,resources=nodes,verbs=create;update,versions=v1alpha1,name=mutate-polkadot-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Node{}

func (r *Node) DefaultNodeResources() {
	if r.Spec.Resources.CPU == "" {
		r.Spec.Resources.CPU = DefaultNodeCPURequest
	}

	if r.Spec.Resources.CPULimit == "" {
		r.Spec.Resources.CPULimit = DefaultNodeCPULimit
	}

	if r.Spec.Resources.Memory == "" {
		r.Spec.Resources.Memory = DefaultNodeMemoryRequest
	}

	if r.Spec.Resources.MemoryLimit == "" {
		r.Spec.Resources.MemoryLimit = DefaultNodeMemoryLimit
	}

	if r.Spec.Resources.Storage == "" {
		r.Spec.Resources.Storage = DefaultNodeStorageRequest
	}
}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Node) Default() {
	nodelog.Info("default", "name", r.Name)

	r.DefaultNodeResources()

	if r.Spec.Image == "" {
		r.Spec.Image = DefaultPolkadotImage
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	if r.Spec.SyncMode == "" {
		r.Spec.SyncMode = DefaultSyncMode
	}

	if r.Spec.P2PPort == 0 {
		r.Spec.P2PPort = DefaultP2PPort
	}

	if r.Spec.Pruning == nil {
		t := true
		r.Spec.Pruning = &t
	}

	if r.Spec.Database == "" {
		r.Spec.Database = DefaultDatabaseBackend
	}

	if r.Spec.RetainedBlocks == 0 {
		r.Spec.RetainedBlocks = DefaultRetainedBlocks
	}

	if r.Spec.Logging == "" {
		r.Spec.Logging = DefaultLoggingVerbosity
	}

	if r.Spec.RPCPort == 0 {
		r.Spec.RPCPort = DefaultRPCPort
	}

	if r.Spec.WSPort == 0 {
		r.Spec.WSPort = DefaultWSPort
	}

	if len(r.Spec.CORSDomains) == 0 {
		r.Spec.CORSDomains = []string{DefaultCORSDomain}
	}

	if r.Spec.TelemetryURL == "" {
		r.Spec.TelemetryURL = DefaultTelemetryURL
	}

	if r.Spec.PrometheusPort == 0 {
		r.Spec.PrometheusPort = DefaultPrometheusPort
	}

}

'''
'''--- apis/polkadot/v1alpha1/node_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Polkadot node defaulting", func() {
	It("Should default node", func() {

		node := Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "my-node",
			},
			Spec: NodeSpec{
				RPC:        true,
				WS:         true,
				Telemetry:  true,
				Prometheus: true,
				// TODO: create test for node with pruning enabled
			},
		}

		t := true

		node.Default()

		Expect(node.Spec.Image).To(Equal(DefaultPolkadotImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.Resources.CPU).To(Equal(DefaultNodeCPURequest))
		Expect(node.Spec.Resources.CPULimit).To(Equal(DefaultNodeCPULimit))
		Expect(node.Spec.Resources.Memory).To(Equal(DefaultNodeMemoryRequest))
		Expect(node.Spec.Resources.MemoryLimit).To(Equal(DefaultNodeMemoryLimit))
		Expect(node.Spec.Resources.Storage).To(Equal(DefaultNodeStorageRequest))
		Expect(node.Spec.SyncMode).To(Equal(DefaultSyncMode))
		Expect(node.Spec.Logging).To(Equal(DefaultLoggingVerbosity))
		Expect(node.Spec.RPCPort).To(Equal(DefaultRPCPort))
		Expect(node.Spec.WSPort).To(Equal(DefaultWSPort))
		Expect(node.Spec.TelemetryURL).To(Equal(DefaultTelemetryURL))
		Expect(node.Spec.PrometheusPort).To(Equal(DefaultPrometheusPort))
		Expect(node.Spec.Pruning).To(Equal(&t))
		Expect(node.Spec.Database).To(Equal(DefaultDatabaseBackend))
		Expect(node.Spec.CORSDomains).To(ContainElement(DefaultCORSDomain))

	})
})

'''
'''--- apis/polkadot/v1alpha1/node_validation_webhook.go ---
package v1alpha1

import (
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-polkadot-kotal-io-v1alpha1-node,mutating=false,failurePolicy=fail,groups=polkadot.kotal.io,resources=nodes,versions=v1alpha1,name=validate-polkadot-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Node{}

// validate shared validation logic for create and update resources
func (r *Node) validate() field.ErrorList {
	var nodeErrors field.ErrorList

	if r.Spec.Validator {
		// validate rpc must be disabled if node is validator
		if r.Spec.RPC {
			err := field.Invalid(field.NewPath("spec").Child("rpc"), r.Spec.RPC, "must be false if node is validator")
			nodeErrors = append(nodeErrors, err)
		}
		// validate ws must be disabled if node is validator
		if r.Spec.WS {
			err := field.Invalid(field.NewPath("spec").Child("ws"), r.Spec.WS, "must be false if node is validator")
			nodeErrors = append(nodeErrors, err)
		}
		// validate pruning must be disabled if node is validator
		if pruning := r.Spec.Pruning; pruning != nil && *pruning {
			err := field.Invalid(field.NewPath("spec").Child("pruning"), r.Spec.Pruning, "must be false if node is validator")
			nodeErrors = append(nodeErrors, err)
		}

	}

	return nodeErrors
}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	nodelog.Info("validate create", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldNode := old.(*Node)

	nodelog.Info("validate update", "name", r.Name)

	allErrors = append(allErrors, r.validate()...)
	allErrors = append(allErrors, r.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if r.Spec.Network != oldNode.Spec.Network {
		err := field.Invalid(field.NewPath("spec").Child("network"), r.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", r.Name)

	return nil, nil
}

'''
'''--- apis/polkadot/v1alpha1/node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Polkadot node validation", func() {
	t := true
	createCases := []struct {
		Title  string
		Node   *Node
		Errors field.ErrorList
	}{
		{
			Title: "validator node with rpc enabled",
			Node: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:   "kusama",
					Validator: true,
					RPC:       true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rpc",
					BadValue: true,
					Detail:   "must be false if node is validator",
				},
			},
		},
		{
			Title: "validator node with ws enabled",
			Node: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:   "kusama",
					Validator: true,
					WS:        true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.ws",
					BadValue: true,
					Detail:   "must be false if node is validator",
				},
			},
		},
		{
			Title: "validator node with pruning enabled",
			Node: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:   "kusama",
					Validator: true,
					Pruning:   &t,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.pruning",
					BadValue: true,
					Detail:   "must be false if node is validator",
				},
			},
		},
	}

	updateCases := []struct {
		Title   string
		OldNode *Node
		NewNode *Node
		Errors  field.ErrorList
	}{
		{
			Title: "updated network",
			OldNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "kusama",
				},
			},
			NewNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "polkadot",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: "polkadot",
					Detail:   "field is immutable",
				},
			},
		},
		{
			Title: "enabling rpc for validator node",
			OldNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:   "kusama",
					Validator: true,
				},
			},
			NewNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:   "kusama",
					Validator: true,
					RPC:       true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.rpc",
					BadValue: true,
					Detail:   "must be false if node is validator",
				},
			},
		},
		{
			Title: "enabling ws for validator node",
			OldNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:   "kusama",
					Validator: true,
				},
			},
			NewNode: &Node{
				ObjectMeta: v1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network:   "kusama",
					Validator: true,
					WS:        true,
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.ws",
					BadValue: true,
					Detail:   "must be false if node is validator",
				},
			},
		},
	}

	Context("While creating node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Node.Default()
					_, err := cc.Node.ValidateCreate()

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldNode.Default()
					cc.NewNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/polkadot/v1alpha1/node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

var nodelog = logf.Log.WithName("node-resource")

func (r *Node) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/polkadot/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/polkadot/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	if in.Pruning != nil {
		in, out := &in.Pruning, &out.Pruning
		*out = new(bool)
		**out = **in
	}
	if in.CORSDomains != nil {
		in, out := &in.CORSDomains, &out.CORSDomains
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/shared/extraargs.go ---
package shared

import "fmt"

// ExtraArgs is extra arguments to add to the cli
// if kv is true, arguments will bey key=val format
type ExtraArgs map[string]string

func (extra ExtraArgs) Encode(kv bool) (args []string) {

	for key, val := range extra {
		// for toggles
		if val == "" {
			args = append(args, key)
			continue
		}

		if kv {
			args = append(args, fmt.Sprintf("%s=%s", key, val))
		} else {
			args = append(args, key, val)
		}
	}

	return
}

'''
'''--- apis/shared/logging.go ---
package shared

// VerbosityLevel is logging verbosity levels
type VerbosityLevel string

const (
	// NoLogs outputs no logs
	NoLogs VerbosityLevel = "off"
	// FatalLogs outputs only fatal logs
	FatalLogs VerbosityLevel = "fatal"
	// ErrorLogs outputs only error logs
	ErrorLogs VerbosityLevel = "error"
	// WarnLogs outputs only warning logs
	WarnLogs VerbosityLevel = "warn"
	// InfoLogs outputs only informational logs
	InfoLogs VerbosityLevel = "info"
	// DebugLogs outputs only debugging logs
	DebugLogs VerbosityLevel = "debug"
	// TraceLogs outputs only tracing logs
	TraceLogs VerbosityLevel = "trace"
	// AllLogs outputs only all logs
	AllLogs VerbosityLevel = "all"
	// NoticeLogs outputs only notice logs
	NoticeLogs VerbosityLevel = "notice"
	// CriticalLogs outputs only critical logs
	CriticalLogs VerbosityLevel = "crit"
	// PanicLogs outputs only panic logs
	PanicLogs VerbosityLevel = "panic"
	// NoneLogs outputs no logs
	NoneLogs VerbosityLevel = "none"
)

'''
'''--- apis/shared/resources.go ---
package shared

import (
	"fmt"

	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

// Resources is node compute and storage resources
// +k8s:deepcopy-gen=true
type Resources struct {
	// CPU is cpu cores the node requires
	// +kubebuilder:validation:Pattern="^[1-9][0-9]*m?$"
	CPU string `json:"cpu,omitempty"`
	// CPULimit is cpu cores the node is limited to
	// +kubebuilder:validation:Pattern="^[1-9][0-9]*m?$"
	CPULimit string `json:"cpuLimit,omitempty"`
	// Memory is memmory requirements
	// +kubebuilder:validation:Pattern="^[1-9][0-9]*[KMGTPE]i$"
	Memory string `json:"memory,omitempty"`
	// MemoryLimit is cpu cores the node is limited to
	// +kubebuilder:validation:Pattern="^[1-9][0-9]*[KMGTPE]i$"
	MemoryLimit string `json:"memoryLimit,omitempty"`
	// Storage is disk space storage requirements
	// +kubebuilder:validation:Pattern="^[1-9][0-9]*[KMGTPE]i$"
	Storage string `json:"storage,omitempty"`
	// StorageClass is the volume storage class
	StorageClass *string `json:"storageClass,omitempty"`
}

// validate is the shared validation logic
func (r *Resources) validate() (errors field.ErrorList) {
	cpu := r.CPU
	cpuLimit := r.CPULimit

	if cpu != cpuLimit {
		// validate cpuLimit can't be less than cpu request
		cpuQuantity := resource.MustParse(cpu)
		cpuLimitQuantity := resource.MustParse(cpuLimit)
		if cpuLimitQuantity.Cmp(cpuQuantity) == -1 {
			msg := fmt.Sprintf("must be greater than or equal to cpu %s", string(cpu))
			err := field.Invalid(field.NewPath("spec").Child("resources").Child("cpuLimit"), cpuLimit, msg)
			errors = append(errors, err)
		}
	}

	memory := r.Memory
	memoryLimit := r.MemoryLimit
	memoryQuantity := resource.MustParse(memory)
	memoryLimitQuantity := resource.MustParse(memoryLimit)

	// validate memory limit must be greater than memory
	if memoryLimitQuantity.Cmp(memoryQuantity) != 1 {
		msg := fmt.Sprintf("must be greater than memory %s", string(memory))
		err := field.Invalid(field.NewPath("spec").Child("resources").Child("memoryLimit"), memoryLimit, msg)
		errors = append(errors, err)
	}

	return
}

// ValidateCreate validates resources during creation
func (r *Resources) ValidateCreate() (errors field.ErrorList) {
	errors = append(errors, r.validate()...)
	return
}

// ValidateUpdate validates resources during update
func (r *Resources) ValidateUpdate(oldResources *Resources) (errors field.ErrorList) {

	oldStorage := oldResources.Storage
	oldStorageClass := oldResources.StorageClass

	errors = append(errors, r.validate()...)

	// requested storage can't be decreased
	if oldStorage != r.Storage {

		oldStorageQuantity := resource.MustParse(oldStorage)
		newStorageQuantity := resource.MustParse(r.Storage)

		if newStorageQuantity.Cmp(oldStorageQuantity) == -1 {
			msg := fmt.Sprintf("must be greater than or equal to old storage %s", oldStorage)
			err := field.Invalid(field.NewPath("spec").Child("resources").Child("storage"), r.Storage, msg)
			errors = append(errors, err)
		}

	}

	// storage class is immutable
	if oldStorageClass != nil && r.StorageClass != nil && *oldStorageClass != *r.StorageClass {
		msg := "field is immutable"
		err := field.Invalid(field.NewPath("spec").Child("resources").Child("storageClass"), *r.StorageClass, msg)
		errors = append(errors, err)
	}

	return
}

'''
'''--- apis/shared/resources_test.go ---
package shared

import (
	"fmt"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Resource validation", func() {
	createCases := []struct {
		Title     string
		Resources *Resources
		Errors    field.ErrorList
	}{
		{
			Title: "invalid cpu limit value",
			Resources: &Resources{
				CPU:         "2",
				CPULimit:    "1",
				Memory:      "1Gi",
				MemoryLimit: "2Gi",
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.cpuLimit",
					BadValue: "1",
					Detail:   "must be greater than or equal to cpu 2",
				},
			},
		},
		{
			Title: "invalid memory limit value",
			Resources: &Resources{
				CPU:         "1",
				CPULimit:    "2",
				Memory:      "2Gi",
				MemoryLimit: "1Gi",
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.memoryLimit",
					BadValue: "1Gi",
					Detail:   "must be greater than memory 2Gi",
				},
			},
		},
	}

	storageClass := "standard"
	newStorageClass := "custom"

	updateCases := []struct {
		Title        string
		OldResources *Resources
		NewResources *Resources
		Errors       field.ErrorList
	}{
		{
			Title: "invalid new cpu limit value",
			OldResources: &Resources{
				CPU:         "1",
				CPULimit:    "2",
				Memory:      "1Gi",
				MemoryLimit: "2Gi",
			},
			NewResources: &Resources{
				CPU:         "2",
				CPULimit:    "1",
				Memory:      "1Gi",
				MemoryLimit: "2Gi",
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.cpuLimit",
					BadValue: "1",
					Detail:   "must be greater than or equal to cpu 2",
				},
			},
		},
		{
			Title: "invalid new memory limit value",
			OldResources: &Resources{
				CPU:         "1",
				CPULimit:    "2",
				Memory:      "1Gi",
				MemoryLimit: "2Gi",
			},
			NewResources: &Resources{
				CPU:         "1",
				CPULimit:    "2",
				Memory:      "2Gi",
				MemoryLimit: "1Gi",
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.memoryLimit",
					BadValue: "1Gi",
					Detail:   "must be greater than memory 2Gi",
				},
			},
		},
		{
			Title: "invalid new storage class value",
			OldResources: &Resources{
				CPU:          "1",
				CPULimit:     "2",
				Memory:       "1Gi",
				MemoryLimit:  "2Gi",
				StorageClass: &storageClass,
			},
			NewResources: &Resources{
				CPU:          "1",
				CPULimit:     "2",
				Memory:       "1Gi",
				MemoryLimit:  "2Gi",
				StorageClass: &newStorageClass,
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.resources.storageClass",
					BadValue: "custom",
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					errorList := cc.Resources.ValidateCreate()
					Expect(errorList).To(ContainElements(cc.Errors))
				})
			}()
		}
	})

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					errorList := cc.NewResources.ValidateUpdate(cc.OldResources)
					Expect(errorList).To(ContainElements(cc.Errors))
				})
			}()
		}
	})

})

'''
'''--- apis/shared/suite_test.go ---
package shared

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestShared(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Shared Suite")
}

'''
'''--- apis/shared/types.go ---
package shared

// EthereumAddress is ethereum address
// +kubebuilder:validation:Pattern="^0[xX][0-9a-fA-F]{40}$"
type EthereumAddress string

'''
'''--- apis/shared/utils.go ---
package shared

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

// ErrorsToCauses converts error list into array of status cause
func ErrorsToCauses(errs field.ErrorList) []metav1.StatusCause {
	causes := make([]metav1.StatusCause, 0, len(errs))

	for i := range errs {
		err := errs[i]
		causes = append(causes, metav1.StatusCause{
			Type:    metav1.CauseType(err.Type),
			Message: err.ErrorBody(),
			Field:   err.Field,
		})
	}

	return causes
}

'''
'''--- apis/shared/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package shared

import ()

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Resources) DeepCopyInto(out *Resources) {
	*out = *in
	if in.StorageClass != nil {
		in, out := &in.StorageClass, &out.StorageClass
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Resources.
func (in *Resources) DeepCopy() *Resources {
	if in == nil {
		return nil
	}
	out := new(Resources)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- apis/stacks/v1alpha1/defaults.go ---
package v1alpha1

const (
	// DefaltReplicas is the default replicas
	DefaltReplicas uint = 1
	// DefaultHost is the default JSON-RPC server host
	DefaultHost = "0.0.0.0"
	// DefaultRPCPort is the default JSON-RPC port
	DefaultRPCPort uint = 20443
	// DefaultP2PPort is the default p2p bind port
	DefaultP2PPort uint = 20444
)

const (
	// DefaultStacksNodeImage is the default Stacks node client image
	DefaultStacksNodeImage = "kotalco/stacks:v2.5.0.0.3"
)

// Resources
const (
	// DefaultNodeCPURequest is the cpu requested by Stacks node
	DefaultNodeCPURequest = "2"
	// DefaultNodeCPULimit is the cpu limit for Stacks node
	DefaultNodeCPULimit = "4"

	// DefaultNodeMemoryRequest is the memory requested by Stacks node
	DefaultNodeMemoryRequest = "4Gi"
	// DefaultNodeMemoryLimit is the memory limit for Stacks node
	DefaultNodeMemoryLimit = "8Gi"

	// DefaultNodeStorageRequest is the Storage requested by Stacks node
	DefaultNodeStorageRequest = "100Gi"
)

'''
'''--- apis/stacks/v1alpha1/groupversion_info.go ---
// Package v1alpha1 contains API Schema definitions for the stacks v1alpha1 API group
// +kubebuilder:object:generate=true
// +groupName=stacks.kotal.io
package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/scheme"
)

var (
	// GroupVersion is group version used to register these objects
	GroupVersion = schema.GroupVersion{Group: "stacks.kotal.io", Version: "v1alpha1"}

	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)

'''
'''--- apis/stacks/v1alpha1/node.go ---
package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// StacksNetwork is Stacks network
type StacksNetwork string

const (
	Mainnet StacksNetwork = "mainnet"
	Testnet StacksNetwork = "testnet"
	Xenon   StacksNetwork = "xenon"
)

// BitcoinNode is Bitcoin node
type BitcoinNode struct {
	// Endpoint is bitcoin node JSON-RPC endpoint
	Endpoint string `json:"endpoint"`
	// P2pPort is bitcoin node p2p port
	P2pPort uint `json:"p2pPort"`
	// RpcPort is bitcoin node JSON-RPC port
	RpcPort uint `json:"rpcPort"`
	// RpcUsername is bitcoin node JSON-RPC username
	RpcUsername string `json:"rpcUsername"`
	// RpcPasswordSecretName is k8s secret name holding bitcoin node JSON-RPC password
	RpcPasswordSecretName string `json:"rpcPasswordSecretName"`
}

// NodeSpec defines the desired state of Node
type NodeSpec struct {
	// Image is Stacks node client image
	Image string `json:"image,omitempty"`
	// ExtraArgs is extra arguments to pass down to the cli
	ExtraArgs shared.ExtraArgs `json:"extraArgs,omitempty"`
	// Replicas is number of replicas
	// +kubebuilder:validation:Enum=0;1
	Replicas *uint `json:"replicas,omitempty"`
	// Network is stacks network
	// +kubebuilder:validation:Enum=mainnet;testnet;xenon
	Network StacksNetwork `json:"network"`
	// RPC enables JSON-RPC server
	RPC bool `json:"rpc,omitempty"`
	// RPCPort is JSON-RPC server port
	RPCPort uint `json:"rpcPort,omitempty"`
	// P2PPort is p2p bind port
	P2PPort uint `json:"p2pPort,omitempty"`
	// BitcoinNode is Bitcoin node
	BitcoinNode BitcoinNode `json:"bitcoinNode"`
	// Miner enables mining
	Miner bool `json:"miner,omitempty"`
	// SeedPrivateKeySecretName is k8s secret holding seed private key used for mining
	SeedPrivateKeySecretName string `json:"seedPrivateKeySecretName,omitempty"`
	// MineMicroblocks mines Stacks micro blocks
	MineMicroblocks bool `json:"mineMicroblocks,omitempty"`
	// NodePrivateKeySecretName is k8s secret holding node private key
	NodePrivateKeySecretName string `json:"nodePrivateKeySecretName,omitempty"`
	// Resources is node compute and storage resources
	shared.Resources `json:"resources,omitempty"`
}

// NodeStatus defines the observed state of Node
type NodeStatus struct {
	Client string `json:"client,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Node is the Schema for the nodes API
// +kubebuilder:printcolumn:name="Network",type=string,JSONPath=".spec.network"
// +kubebuilder:printcolumn:name="Client",type=string,JSONPath=".status.client"
// +kubebuilder:printcolumn:name="Miner",type=boolean,JSONPath=".spec.miner"
type Node struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   NodeSpec   `json:"spec,omitempty"`
	Status NodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeList contains a list of Node
type NodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Node `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Node{}, &NodeList{})
}

'''
'''--- apis/stacks/v1alpha1/node_defaulting_webhook.go ---
package v1alpha1

import (
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

// +kubebuilder:webhook:path=/mutate-stacks-kotal-io-v1alpha1-node,mutating=true,failurePolicy=fail,groups=stacks.kotal.io,resources=nodes,verbs=create;update,versions=v1alpha1,name=mutate-stacks-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Defaulter = &Node{}

func (r *Node) DefaultNodeResources() {
	if r.Spec.Resources.CPU == "" {
		r.Spec.Resources.CPU = DefaultNodeCPURequest
	}

	if r.Spec.Resources.CPULimit == "" {
		r.Spec.Resources.CPULimit = DefaultNodeCPULimit
	}

	if r.Spec.Resources.Memory == "" {
		r.Spec.Resources.Memory = DefaultNodeMemoryRequest
	}

	if r.Spec.Resources.MemoryLimit == "" {
		r.Spec.Resources.MemoryLimit = DefaultNodeMemoryLimit
	}

	if r.Spec.Resources.Storage == "" {
		r.Spec.Resources.Storage = DefaultNodeStorageRequest
	}
}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Node) Default() {
	nodelog.Info("default", "name", r.Name)

	r.DefaultNodeResources()

	if r.Spec.Image == "" {
		r.Spec.Image = DefaultStacksNodeImage
	}

	if r.Spec.Replicas == nil {
		// constants are not addressable
		replicas := DefaltReplicas
		r.Spec.Replicas = &replicas
	}

	if r.Spec.P2PPort == 0 {
		r.Spec.P2PPort = DefaultP2PPort
	}

	if r.Spec.RPCPort == 0 {
		r.Spec.RPCPort = DefaultRPCPort
	}

}

'''
'''--- apis/stacks/v1alpha1/node_defaulting_webhook_test.go ---
package v1alpha1

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Stacks node defaulting", func() {
	It("Should default Stacks node", func() {
		node := Node{
			ObjectMeta: metav1.ObjectMeta{},
			Spec: NodeSpec{
				Network: Mainnet,
			},
		}

		node.Default()

		Expect(node.Spec.Image).To(Equal(DefaultStacksNodeImage))
		Expect(*node.Spec.Replicas).To(Equal(DefaltReplicas))
		Expect(node.Spec.P2PPort).To(Equal(DefaultP2PPort))
		Expect(node.Spec.RPCPort).To(Equal(DefaultRPCPort))
		Expect(node.Spec.CPU).To(Equal(DefaultNodeCPURequest))
		Expect(node.Spec.CPULimit).To(Equal(DefaultNodeCPULimit))
		Expect(node.Spec.Memory).To(Equal(DefaultNodeMemoryRequest))
		Expect(node.Spec.MemoryLimit).To(Equal(DefaultNodeMemoryLimit))
		Expect(node.Spec.Storage).To(Equal(DefaultNodeStorageRequest))

	})
})

'''
'''--- apis/stacks/v1alpha1/node_validation_webhook.go ---
package v1alpha1

import (
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:verbs=create;update,path=/validate-stacks-kotal-io-v1alpha1-node,mutating=false,failurePolicy=fail,groups=stacks.kotal.io,resources=nodes,versions=v1alpha1,name=validate-stacks-v1alpha1-node.kb.io,sideEffects=None,admissionReviewVersions=v1

var _ webhook.Validator = &Node{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateCreate() (admission.Warnings, error) {
	var allErrors field.ErrorList

	nodelog.Info("validate create", "name", r.Name)

	allErrors = append(allErrors, r.Spec.Resources.ValidateCreate()...)

	if r.Spec.Miner && r.Spec.SeedPrivateKeySecretName == "" {
		err := field.Invalid(field.NewPath("spec").Child("seedPrivateKeySecretName"), r.Spec.SeedPrivateKeySecretName, "seedPrivateKeySecretName is required if node is miner")
		allErrors = append(allErrors, err)
	}

	if r.Spec.SeedPrivateKeySecretName != "" && !r.Spec.Miner {
		err := field.Invalid(field.NewPath("spec").Child("miner"), r.Spec.Miner, "node must be a miner if seedPrivateKeySecretName is given")
		allErrors = append(allErrors, err)
	}

	if r.Spec.MineMicroblocks && !r.Spec.Miner {
		err := field.Invalid(field.NewPath("spec").Child("miner"), r.Spec.Miner, "node must be a miner if mineMicroblocks is true")
		allErrors = append(allErrors, err)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	var allErrors field.ErrorList
	oldNode := old.(*Node)

	nodelog.Info("validate update", "name", r.Name)

	allErrors = append(allErrors, r.Spec.Resources.ValidateUpdate(&oldNode.Spec.Resources)...)

	if r.Spec.Network != oldNode.Spec.Network {
		err := field.Invalid(field.NewPath("spec").Child("network"), r.Spec.Network, "field is immutable")
		allErrors = append(allErrors, err)
	}

	if len(allErrors) == 0 {
		return nil, nil
	}

	return nil, apierrors.NewInvalid(schema.GroupKind{}, r.Name, allErrors)
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *Node) ValidateDelete() (admission.Warnings, error) {
	nodelog.Info("validate delete", "name", r.Name)

	return nil, nil
}

'''
'''--- apis/stacks/v1alpha1/node_validation_webhook_test.go ---
package v1alpha1

import (
	"fmt"

	"github.com/kotalco/kotal/apis/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/validation/field"
)

var _ = Describe("Stacks node validation", func() {
	createCases := []struct {
		Title  string
		Node   *Node
		Errors field.ErrorList
	}{
		{
			Title: "missing seedPrivateKeySecretName",
			Node: &Node{
				Spec: NodeSpec{
					Network: Mainnet,
					Miner:   true,
				},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.seedPrivateKeySecretName",
					BadValue: "",
					Detail:   "seedPrivateKeySecretName is required if node is miner",
				},
			},
		},
		{
			Title: "seedPrivateKeySecretName is given for non miner node",
			Node: &Node{
				Spec: NodeSpec{
					Network:                  Mainnet,
					SeedPrivateKeySecretName: "seed-private-key",
				},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.miner",
					BadValue: false,
					Detail:   "node must be a miner if seedPrivateKeySecretName is given",
				},
			},
		},
		{
			Title: "mineMicroblocks is given for non miner node",
			Node: &Node{
				Spec: NodeSpec{
					Network:         Mainnet,
					MineMicroblocks: true,
				},
			},
			Errors: []*field.Error{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.miner",
					BadValue: false,
					Detail:   "node must be a miner if mineMicroblocks is true",
				},
			},
		},
	}

	updateCases := []struct {
		Title   string
		OldNode *Node
		NewNode *Node
		Errors  field.ErrorList
	}{
		{
			Title: "updated network",
			OldNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "mainnet",
				},
			},
			NewNode: &Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "my-node",
				},
				Spec: NodeSpec{
					Network: "testnet",
				},
			},
			Errors: field.ErrorList{
				{
					Type:     field.ErrorTypeInvalid,
					Field:    "spec.network",
					BadValue: "testnet",
					Detail:   "field is immutable",
				},
			},
		},
	}

	Context("While creating node", func() {
		for _, c := range createCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.Node.Default()
					_, err := cc.Node.ValidateCreate()

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

	Context("While updating node", func() {
		for _, c := range updateCases {
			func() {
				cc := c
				It(fmt.Sprintf("Should validate %s", cc.Title), func() {
					cc.OldNode.Default()
					cc.NewNode.Default()
					_, err := cc.NewNode.ValidateUpdate(cc.OldNode)

					errStatus := err.(*errors.StatusError)

					causes := shared.ErrorsToCauses(cc.Errors)

					Expect(errStatus.ErrStatus.Details.Causes).To(ContainElements(causes))
				})
			}()
		}
	})

})

'''
'''--- apis/stacks/v1alpha1/node_webhook.go ---
package v1alpha1

import (
	ctrl "sigs.k8s.io/controller-runtime"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// log is for logging in this package.
var nodelog = logf.Log.WithName("node-resource")

func (r *Node) SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		For(r).
		Complete()
}

'''
'''--- apis/stacks/v1alpha1/suite_test.go ---
package v1alpha1

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestWebhooks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Webhooks Suite")
}

'''
'''--- apis/stacks/v1alpha1/zz_generated.deepcopy.go ---
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/kotalco/kotal/apis/shared"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BitcoinNode) DeepCopyInto(out *BitcoinNode) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BitcoinNode.
func (in *BitcoinNode) DeepCopy() *BitcoinNode {
	if in == nil {
		return nil
	}
	out := new(BitcoinNode)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Node) DeepCopyInto(out *Node) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Node.
func (in *Node) DeepCopy() *Node {
	if in == nil {
		return nil
	}
	out := new(Node)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Node) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeList) DeepCopyInto(out *NodeList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Node, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeList.
func (in *NodeList) DeepCopy() *NodeList {
	if in == nil {
		return nil
	}
	out := new(NodeList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) {
	*out = *in
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make(shared.ExtraArgs, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(uint)
		**out = **in
	}
	out.BitcoinNode = in.BitcoinNode
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec {
	if in == nil {
		return nil
	}
	out := new(NodeSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeStatus) DeepCopyInto(out *NodeStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeStatus.
func (in *NodeStatus) DeepCopy() *NodeStatus {
	if in == nil {
		return nil
	}
	out := new(NodeStatus)
	in.DeepCopyInto(out)
	return out
}

'''
'''--- clients/aptos/aptos_core_client.go ---
package aptos

import (
	"fmt"

	aptosv1alpha1 "github.com/kotalco/kotal/apis/aptos/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// AptosCoreClient is Aptos core client
// https://github.com/aptos-labs/aptos-core
type AptosCoreClient struct {
	node *aptosv1alpha1.Node
}

// Images
const (
	// AptosCoreHomeDir is Aptos Core image home dir
	// TODO: create aptos image with non root user and /home/aptos home directory
	AptosCoreHomeDir = "/opt/aptos"
)

// Command returns environment variables for the client
func (c *AptosCoreClient) Env() (env []corev1.EnvVar) {
	return
}

// Command is Aptos Core client entrypoint
func (c *AptosCoreClient) Command() (command []string) {
	command = append(command, "aptos-node")
	return
}

// Args returns Aptos Core client args
func (c *AptosCoreClient) Args() (args []string) {
	configPath := fmt.Sprintf("%s/config.yaml", shared.PathConfig(c.HomeDir()))
	args = append(args, AptosArgConfig, configPath)
	return
}

// HomeDir is the home directory of Aptos Core client image
func (c *AptosCoreClient) HomeDir() string {
	return AptosCoreHomeDir
}

'''
'''--- clients/aptos/aptos_core_client_test.go ---
package aptos

import (
	"fmt"

	aptosv1alpha1 "github.com/kotalco/kotal/apis/aptos/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Aptos core client", func() {

	node := &aptosv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "aptos-node",
			Namespace: "default",
		},
		Spec: aptosv1alpha1.NodeSpec{
			Network: aptosv1alpha1.Testnet,
		},
	}

	node.Default()

	client := NewClient(node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("aptos-node"))
	})

	It("Should get correct environment variables", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home directory", func() {
		Expect(client.HomeDir()).To(Equal(AptosCoreHomeDir))
	})

	It("Should generate correct client arguments", func() {

		Expect(client.Args()).To(ContainElements([]string{
			AptosArgConfig,
			fmt.Sprintf("%s/config.yaml", shared.PathConfig(client.HomeDir())),
		}))
	})

})

'''
'''--- clients/aptos/client.go ---
package aptos

import (
	aptosv1alpha1 "github.com/kotalco/kotal/apis/aptos/v1alpha1"
	clients "github.com/kotalco/kotal/clients"
)

// NewClient returns new Aptos client
func NewClient(node *aptosv1alpha1.Node) clients.Interface {
	return &AptosCoreClient{node}
}

'''
'''--- clients/aptos/suite_test.go ---
package aptos

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestAptosCoreClient(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Aptos Core Client Suite")
}

'''
'''--- clients/aptos/types.go ---
package aptos

const (
	// AptosArgConfig is argument used to locate node config file
	AptosArgConfig = "--config"
)

'''
'''--- clients/bitcoin/bitcoin_core_client.go ---
package bitcoin

import (
	"context"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"

	bitcoinv1alpha1 "github.com/kotalco/kotal/apis/bitcoin/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// BitcoinCoreClient is Bitcoin core client
// https://github.com/bitcoin/bitcoin
type BitcoinCoreClient struct {
	node   *bitcoinv1alpha1.Node
	client client.Client
}

var hashCash map[string]string = map[string]string{}

// Images
const (
	// BitcoinCoreHomeDir is Bitcoin core image home dir
	BitcoinCoreHomeDir = "/data"
)

// Command returns environment variables for the client
func (c *BitcoinCoreClient) Env() (env []corev1.EnvVar) {
	env = append(env, corev1.EnvVar{
		Name:  EnvBitcoinData,
		Value: shared.PathData(c.HomeDir()),
	})

	return
}

// Command is Bitcoin core client entrypoint
func (c *BitcoinCoreClient) Command() (command []string) {
	command = append(command, "bitcoind")
	return
}

// Args returns Bitcoin core client args
func (c *BitcoinCoreClient) Args() (args []string) {
	node := c.node

	networks := map[string]string{
		"mainnet": "main",
		"testnet": "test",
	}

	// convert bool to 0 or 1
	var Btoi = func(b bool) uint {
		if b {
			return 1
		}
		return 0
	}

	args = append(args, fmt.Sprintf("%s=%s", BitcoinArgDataDir, shared.PathData(c.HomeDir())))
	args = append(args, fmt.Sprintf("%s=%d", BitcoinArgListen, Btoi(*node.Spec.Listen)))
	args = append(args, fmt.Sprintf("%s=%d", BitcoinArgMaxConnections, *node.Spec.MaxConnections))
	args = append(args, fmt.Sprintf("%s=%s", BitcoinArgChain, networks[string(node.Spec.Network)]))
	args = append(args, fmt.Sprintf("%s=%s:%d", BitcoinArgBind, shared.Host(true), node.Spec.P2PPort))

	if c.node.Spec.RPC {
		args = append(args, fmt.Sprintf("%s=1", BitcoinArgServer))
		args = append(args, fmt.Sprintf("%s=%d", BitcoinArgRPCPort, node.Spec.RPCPort))
		args = append(args, fmt.Sprintf("%s=%s", BitcoinArgRPCBind, shared.Host(node.Spec.RPC)))
		args = append(args, fmt.Sprintf("%s=%s/0", BitcoinArgRPCAllowIp, shared.Host(node.Spec.RPC)))

		// TODO: mock k8s secret getter to test rpc users and whitelist
		for _, rpcUser := range node.Spec.RPCUsers {
			name := types.NamespacedName{Name: rpcUser.PasswordSecretName, Namespace: node.Namespace}
			password, _ := shared.GetSecret(context.TODO(), c.client, name, "password")
			saltedHash, found := hashCash[password]
			if !found {
				salt, hash := HmacSha256(password)
				saltedHash = fmt.Sprintf("%s$%s", salt, hash)
				hashCash[password] = saltedHash
			}
			args = append(args, fmt.Sprintf("%s=%s:%s", BitcoinArgRPCAuth, rpcUser.Username, saltedHash))

			if len(node.Spec.RPCWhitelist) != 0 {
				list := strings.Join(node.Spec.RPCWhitelist, ",")
				args = append(args, fmt.Sprintf("%s=%s:%s", BitcoinArgRpcWhitelist, rpcUser.Username, list))
			}
		}

	} else {
		args = append(args, fmt.Sprintf("%s=0", BitcoinArgServer))
	}

	args = append(args, fmt.Sprintf("%s=%d", BitcoinArgReIndex, Btoi(node.Spec.ReIndex)))
	args = append(args, fmt.Sprintf("%s=%d", BitcoinArgTransactionIndex, Btoi(node.Spec.TransactionIndex)))
	args = append(args, fmt.Sprintf("%s=%d", BitcoinArgBlocksOnly, Btoi(node.Spec.BlocksOnly)))
	args = append(args, fmt.Sprintf("%s=%d", BitcoinArgCoinStatsIndex, Btoi(node.Spec.CoinStatsIndex)))
	args = append(args, fmt.Sprintf("%s=%d", BitcoinArgPrune, Btoi(node.Spec.Pruning)))

	args = append(args, fmt.Sprintf("%s=%d", BitcoinArgDBCacheSize, node.Spec.DBCacheSize))

	if !node.Spec.Wallet {
		args = append(args, BitcoinArgDisableWallet)
	}

	return
}

// HomeDir is the home directory of Bitcoin core client image
func (c *BitcoinCoreClient) HomeDir() string {
	return BitcoinCoreHomeDir
}

// HmacSha256 creates new hmac sha256 hash
// reference implementation:
// https://github.com/bitcoin/bitcoin/blob/master/share/rpcauth/rpcauth.py
func HmacSha256(password string) (salt, hash string) {
	random := make([]byte, 16)
	rand.Read(random)
	salt = hex.EncodeToString(random)

	h := hmac.New(sha256.New, []byte(salt))
	h.Write([]byte(password))

	hash = fmt.Sprintf("%x", h.Sum(nil))

	return
}

'''
'''--- clients/bitcoin/bitcoin_core_client_test.go ---
package bitcoin

import (
	bitcoinv1alpha1 "github.com/kotalco/kotal/apis/bitcoin/v1alpha1"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Bitcoin core client", func() {

	listen := false
	var maxConnections uint = 123
	node := &bitcoinv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "bitcoin-node",
			Namespace: "default",
		},
		Spec: bitcoinv1alpha1.NodeSpec{
			Network:          "mainnet",
			Listen:           &listen,
			MaxConnections:   &maxConnections,
			RPC:              true,
			P2PPort:          8888,
			RPCPort:          7777,
			Wallet:           false,
			TransactionIndex: true,
			CoinStatsIndex:   true,
			BlocksOnly:       true,
			Pruning:          true,
			ReIndex:          true,
			DBCacheSize:      2048,
		},
	}

	node.Default()
	// nil is passed because there's no reconciler client
	// TODO: create test for rpcUsers where client is not nil
	client := NewClient(node, nil)

	It("Should get correct command", func() {
		Expect(client.Command()).To(Equal([]string{
			"bitcoind",
		}))
	})

	It("Should get correct home directory", func() {
		Expect(client.HomeDir()).To(Equal(BitcoinCoreHomeDir))
	})

	It("Should generate correct client arguments", func() {
		Expect(client.Args()).To(ContainElements([]string{
			"-chain=main",
			"-listen=0",
			"-datadir=/data/kotal-data",
			"-server=1",
			"-bind=0.0.0.0:8888",
			"-rpcport=7777",
			"-rpcbind=0.0.0.0",
			"-rpcallowip=0.0.0.0/0",
			"-disablewallet",
			"-txindex=1",
			"-blocksonly=1",
			"-reindex=1",
			"-coinstatsindex=1",
			"-prune=1",
			"-dbcache=2048",
			"-maxconnections=123",
		}))
	})

})

'''
'''--- clients/bitcoin/client.go ---
package bitcoin

import (
	bitcoinv1alpha1 "github.com/kotalco/kotal/apis/bitcoin/v1alpha1"
	clients "github.com/kotalco/kotal/clients"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func NewClient(node *bitcoinv1alpha1.Node, client client.Client) clients.Interface {
	return &BitcoinCoreClient{node, client}
}

'''
'''--- clients/bitcoin/suite_test.go ---
package bitcoin

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestBitcoinCoreClient(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Bitcoin Core Client Suite")
}

'''
'''--- clients/bitcoin/types.go ---
package bitcoin

const (
	// EnvBitcoinData is environment variable used to set data directory
	EnvBitcoinData = "BITCOIN_DATA"
)

const (
	// BitcoinArgChain is argument used to set chain
	BitcoinArgChain = "-chain"
	// BitcoinArgListen is argument used to accept connections from outside
	BitcoinArgListen = "-listen"
	// BitcoinArgBind is argument used to bind and listen to the given address
	BitcoinArgBind = "-bind"
	// BitcoinArgServer is argument used to enable CLI and JSON-RPC server
	BitcoinArgServer = "-server"
	// BitcoinArgRPCPort is argument used to set JSON-RPC port
	BitcoinArgRPCPort = "-rpcport"
	// BitcoinArgDataDir is argument used to set data directory
	BitcoinArgDataDir = "-datadir"
	// BitcoinArgRPCBind is argument used to set JSON-RPC server host
	BitcoinArgRPCBind = "-rpcbind"
	// BitcoinArgRPCAllowIp is argument used to allow JSON-RPC connections from specific sources
	BitcoinArgRPCAllowIp = "-rpcallowip"
	// BitcoinArgRPCAuth is argument used to set JSON-RPC user and password in the format of user:salt$hash
	BitcoinArgRPCAuth = "-rpcauth"
	// BitcoinArgDisableWallet is argument used to disable wallet and RPC calls
	BitcoinArgDisableWallet = "-disablewallet"
	// BitcoinArgReIndex is argument used to rebuild chain state and block index
	BitcoinArgReIndex = "-reindex"
	// BitcoinArgTransactionIndex is argument used to maintain a full transaction index
	BitcoinArgTransactionIndex = "-txindex"
	// BitcoinArgCoinStatsIndex is argument used to maintain coinstats index
	BitcoinArgCoinStatsIndex = "-coinstatsindex"
	// BitcoinArgBlocksOnly is argument used to reject transactions from network peers
	BitcoinArgBlocksOnly = "-blocksonly"
	// BitcoinArgPrune is argument used to allows pruneblockchain RPC to be called to delete specific blocks
	BitcoinArgPrune = "-prune"
	// BitcoinArgRpcWhitelist is argument used to set default rpc whitelist
	BitcoinArgRpcWhitelist = "-rpcwhitelist"
	// BitcoinArgDBCacheSize is argument used to set maximum database cache size
	BitcoinArgDBCacheSize = "-dbcache"
	// BitcoinArgMaxConnections is argument used to set maximum connections to peers
	BitcoinArgMaxConnections = "-maxconnections"
)

'''
'''--- clients/chainlink/chainlink_client.go ---
package chainlink

import (
	"fmt"

	chainlinkv1alpha1 "github.com/kotalco/kotal/apis/chainlink/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// ChainlinkClient is chainlink official client
// https://github.com/smartcontractkit/chainlink
type ChainlinkClient struct {
	node *chainlinkv1alpha1.Node
}

// Images
const (
	// ChainlinkHomeDir is chainlink image home dir
	// TODO: update the home directory
	ChainlinkHomeDir = "/home/chainlink"
)

// Command is chainlink entrypoint
func (c *ChainlinkClient) Command() []string {
	return []string{"chainlink"}
}

// Args returns chainlink args
func (c *ChainlinkClient) Args() []string {
	args := []string{
		"local",
		"--config",
		fmt.Sprintf("%s/config.toml", shared.PathConfig(c.HomeDir())),
		"--secrets",
		fmt.Sprintf("%s/secrets.toml", shared.PathConfig(c.HomeDir())),
		"node",
	}

	args = append(args, ChainlinkAPI, fmt.Sprintf("%s/.api", shared.PathData(c.HomeDir())))

	return args
}

func (c *ChainlinkClient) Env() []corev1.EnvVar {
	return nil
}

// HomeDir returns chainlink image home directory
func (c *ChainlinkClient) HomeDir() string {
	return ChainlinkHomeDir
}

'''
'''--- clients/chainlink/chainlink_client_test.go ---
package chainlink

import (
	"fmt"

	chainlinkv1alpha1 "github.com/kotalco/kotal/apis/chainlink/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Chainlink Client", func() {
	node := &chainlinkv1alpha1.Node{
		Spec: chainlinkv1alpha1.NodeSpec{
			EthereumChainId:    1,
			EthereumWSEndpoint: "ws://my-eth-node:8546",
			EthereumHTTPEndpoints: []string{
				"http://my-eth-node:8545",
				"http://my-eth-node2:8545",
				"http://my-eth-node3:8545",
			},
			LinkContractAddress: "0x01BE23585060835E02B77ef475b0Cc51aA1e0709",
			DatabaseURL:         "postgresql://postgres:secret@postgres:5432/postgres",
			CertSecretName:      "my-certificate",
			TLSPort:             9999,
			P2PPort:             4444,
			APIPort:             7777,
			Logging:             sharedAPI.PanicLogs,
			CORSDomains:         []string{"*"},
			SecureCookies:       true,
		},
	}

	client := NewClient(node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("chainlink"))
	})

	It("Should get correct environment variables", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(ChainlinkHomeDir))
	})

	It("Should get correct args", func() {
		Expect(client.Args()).To(ContainElements(
			"local",
			"node",
			ChainlinkAPI,
			fmt.Sprintf("%s/.api", shared.PathData(client.HomeDir())),
		))
	})

})

'''
'''--- clients/chainlink/client.go ---
package chainlink

import (
	chainlinkv1alpha1 "github.com/kotalco/kotal/apis/chainlink/v1alpha1"
	clients "github.com/kotalco/kotal/clients"
)

// NewClient returns chainlink client for the given node
func NewClient(node *chainlinkv1alpha1.Node) clients.Interface {
	return &ChainlinkClient{node}
}

'''
'''--- clients/chainlink/suite_test.go ---
package chainlink

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestChainlinkClients(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Chainlink Client Suite")
}

'''
'''--- clients/chainlink/types.go ---
package chainlink

// arguments
const (
	// ChainlinkAPI is the argument used to locate api credentials file
	ChainlinkAPI = "--api"
)

'''
'''--- clients/ethereum/accounts.go ---
package ethereum

import (
	"fmt"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
)

// genesisAccounts returns genesis config accounts
func genesisAccounts(withBuiltins bool, forks *ethereumv1alpha1.Forks) map[string]interface{} {
	accounts := map[string]interface{}{}
	for i := 0; i < 256; i++ {
		address := fmt.Sprintf("%#040x", i)
		var fn map[string]interface{}
		if i >= 1 && i <= 9 {
			if withBuiltins {
				fn = builtinFunction(i, forks)
			}
			accounts[address] = map[string]interface{}{
				"balance": "0x1",
				"builtin": fn,
			}
		} else {
			accounts[address] = map[string]interface{}{
				"balance": "0x1",
			}
		}
	}
	return accounts
}

// builtinFunction returns built in parity functions
func builtinFunction(i int, forks *ethereumv1alpha1.Forks) map[string]interface{} {
	switch i {
	case 1:
		return ecRecover()
	case 2:
		return sha256()
	case 3:
		return ripemd160()
	case 4:
		return identity()
	case 5:
		return modexp(forks)
	case 6:
		return altBn128Add(forks)
	case 7:
		return altBn128Mul(forks)
	case 8:
		return altBn128Pairing(forks)
	case 9:
		return blake2(forks)
	}
	return nil
}

// ecRecover revcovers public key from elliptic curve signature
func ecRecover() map[string]interface{} {
	return map[string]interface{}{
		"name": "ecrecover",
		"pricing": map[string]interface{}{
			"linear": map[string]int{
				"base": 3000,
				"word": 0,
			},
		},
	}
}

// sha256 is sha256 function
func sha256() map[string]interface{} {
	return map[string]interface{}{
		"name": "sha256",
		"pricing": map[string]interface{}{
			"linear": map[string]int{
				"base": 60,
				"word": 12,
			},
		},
	}
}

// ripemd160 is ripemd160 hash function
func ripemd160() map[string]interface{} {
	return map[string]interface{}{
		"name": "ripemd160",
		"pricing": map[string]interface{}{
			"linear": map[string]int{
				"base": 600,
				"word": 120,
			},
		},
	}
}

// identity function
func identity() map[string]interface{} {
	return map[string]interface{}{
		"name": "identity",
		"pricing": map[string]interface{}{
			"linear": map[string]int{
				"base": 15,
				"word": 3,
			},
		},
	}
}

// modexp is modular exponentiaiton function
func modexp(forks *ethereumv1alpha1.Forks) map[string]interface{} {
	byzantiumBlock := fmt.Sprintf("%#x", forks.Byzantium)
	berlinBlock := fmt.Sprintf("%#x", forks.Berlin)

	return map[string]interface{}{
		"name": "modexp",
		"pricing": map[string]interface{}{
			byzantiumBlock: map[string]interface{}{
				"info": "EIP-198: Big integer modular exponentiation.",
				"price": map[string]interface{}{
					"modexp": map[string]uint{
						"divisor": 20,
					},
				},
			},
			berlinBlock: map[string]interface{}{
				"info": "EIP-2565: ModExp Gas Cost.",
				"price": map[string]interface{}{
					"modexp2565": map[string]interface{}{},
				},
			},
		},
	}
}

// altBn128Add is elliptic curve add function
func altBn128Add(forks *ethereumv1alpha1.Forks) map[string]interface{} {

	byzantiumBlock := fmt.Sprintf("%#x", forks.Byzantium)
	istanbulBlock := fmt.Sprintf("%#x", forks.Istanbul)

	return map[string]interface{}{
		"name": "alt_bn128_add",
		"pricing": map[string]interface{}{
			byzantiumBlock: map[string]interface{}{
				"price": map[string]interface{}{
					"alt_bn128_const_operations": map[string]int{
						"price": 500,
					},
				},
			},
			istanbulBlock: map[string]interface{}{
				"info": "EIP 1108 transition",
				"price": map[string]interface{}{
					"alt_bn128_const_operations": map[string]int{
						"price": 150,
					},
				},
			},
		},
	}
}

// altBn128Mul is elliptic function Multiplication funciton
func altBn128Mul(forks *ethereumv1alpha1.Forks) map[string]interface{} {

	byzantiumBlock := fmt.Sprintf("%#x", forks.Byzantium)
	istanbulBlock := fmt.Sprintf("%#x", forks.Istanbul)

	return map[string]interface{}{
		"name": "alt_bn128_mul",
		"pricing": map[string]interface{}{
			byzantiumBlock: map[string]interface{}{
				"price": map[string]interface{}{
					"alt_bn128_const_operations": map[string]int{
						"price": 40000,
					},
				},
			},
			istanbulBlock: map[string]interface{}{
				"info": "EIP 1108 transition",
				"price": map[string]interface{}{
					"alt_bn128_const_operations": map[string]int{
						"price": 6000,
					},
				},
			},
		},
	}
}

// altBn128Pairing is elliptic curve pairing function
func altBn128Pairing(forks *ethereumv1alpha1.Forks) map[string]interface{} {

	byzantiumBlock := fmt.Sprintf("%#x", forks.Byzantium)
	istanbulBlock := fmt.Sprintf("%#x", forks.Istanbul)

	return map[string]interface{}{
		"name": "alt_bn128_pairing",
		"pricing": map[string]interface{}{
			byzantiumBlock: map[string]interface{}{
				"price": map[string]interface{}{
					"alt_bn128_pairing": map[string]int{
						"base": 100000,
						"pair": 80000,
					},
				},
			},
			istanbulBlock: map[string]interface{}{
				"info": "EIP 1108 transition",
				"price": map[string]interface{}{
					"alt_bn128_pairing": map[string]int{
						"base": 45000,
						"pair": 34000,
					},
				},
			},
		},
	}
}

// blake2 is blake hash function
func blake2(forks *ethereumv1alpha1.Forks) map[string]interface{} {

	return map[string]interface{}{
		"name":        "blake2_f",
		"activate_at": fmt.Sprintf("%#x", forks.Istanbul),
		"pricing": map[string]interface{}{
			"blake2_f": map[string]interface{}{
				"gas_per_round": 1,
			},
		},
	}
}

'''
'''--- clients/ethereum/besu_client.go ---
package ethereum

import (
	"encoding/json"
	"fmt"
	"strings"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// BesuClient is Hyperledger Besu client
// https://github.com/hyperledger/besu
type BesuClient struct {
	node *ethereumv1alpha1.Node
}

const (
	// BesuHomeDir is besu docker image home directory
	BesuHomeDir = "/opt/besu"
)

// HomeDir returns besu client home directory
func (b *BesuClient) HomeDir() string {
	return BesuHomeDir
}

func (b *BesuClient) Command() []string {
	return nil
}

func (b *BesuClient) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client run
func (b *BesuClient) Args() (args []string) {

	node := b.node

	args = append(args, BesuNatMethod, "KUBERNETES")
	args = append(args, BesuDataPath, shared.PathData(b.HomeDir()))
	args = append(args, BesuP2PPort, fmt.Sprintf("%d", node.Spec.P2PPort))
	args = append(args, BesuSyncMode, string(node.Spec.SyncMode))
	args = append(args, BesuLogging, strings.ToUpper(string(node.Spec.Logging)))

	if node.Spec.NodePrivateKeySecretName != "" {
		args = append(args, BesuNodePrivateKey, fmt.Sprintf("%s/nodekey", shared.PathSecrets(b.HomeDir())))
	}

	if len(node.Spec.StaticNodes) != 0 {
		args = append(args, BesuStaticNodesFile, fmt.Sprintf("%s/static-nodes.json", shared.PathConfig(b.HomeDir())))
	}

	if len(node.Spec.Bootnodes) != 0 {
		bootnodes := []string{}
		for _, bootnode := range node.Spec.Bootnodes {
			bootnodes = append(bootnodes, string(bootnode))
		}
		args = append(args, BesuBootnodes, strings.Join(bootnodes, ","))
	}

	// public network
	if node.Spec.Genesis == nil {
		args = append(args, BesuNetwork, node.Spec.Network)
	} else { // private network
		args = append(args, BesuGenesisFile, fmt.Sprintf("%s/genesis.json", shared.PathConfig(b.HomeDir())))
		args = append(args, BesuNetworkID, fmt.Sprintf("%d", node.Spec.Genesis.NetworkID))
		args = append(args, BesuDiscoveryEnabled, "false")
	}

	if node.Spec.Miner {
		args = append(args, BesuMinerEnabled)
		args = append(args, BesuMinerCoinbase, string(node.Spec.Coinbase))
	}

	// convert spec rpc modules into format suitable for cli option
	normalizedAPIs := func(modules []ethereumv1alpha1.API) string {
		apis := []string{}
		for _, api := range modules {
			apis = append(apis, strings.ToUpper(string(api)))
		}
		return strings.Join(apis, ",")
	}

	if node.Spec.RPC {
		args = append(args, BesuRPCHTTPEnabled)
		args = append(args, BesuRPCHTTPHost, shared.Host(node.Spec.RPC))
		args = append(args, BesuRPCHTTPPort, fmt.Sprintf("%d", node.Spec.RPCPort))
		args = append(args, BesuRPCHTTPAPI, normalizedAPIs(node.Spec.RPCAPI))
	}

	if node.Spec.Engine {
		args = append(args, BesuEngineRpcEnabled)
		args = append(args, BesuEngineRpcPort, fmt.Sprintf("%d", node.Spec.EnginePort))
		jwtSecretPath := fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(b.HomeDir()))
		args = append(args, BesuEngineJwtSecret, jwtSecretPath)
	}

	if node.Spec.WS {
		args = append(args, BesuRPCWSEnabled)
		args = append(args, BesuRPCWSHost, shared.Host(node.Spec.WS))
		args = append(args, BesuRPCWSPort, fmt.Sprintf("%d", node.Spec.WSPort))
		args = append(args, BesuRPCWSAPI, normalizedAPIs(node.Spec.WSAPI))
	}

	if node.Spec.GraphQL {
		args = append(args, BesuGraphQLHTTPEnabled)
		args = append(args, BesuGraphQLHTTPHost, shared.Host(node.Spec.GraphQL))
		args = append(args, BesuGraphQLHTTPPort, fmt.Sprintf("%d", node.Spec.GraphQLPort))
	}

	if len(node.Spec.Hosts) != 0 {
		commaSeperatedHosts := strings.Join(node.Spec.Hosts, ",")
		args = append(args, BesuHostAllowlist, commaSeperatedHosts)
		if node.Spec.Engine {
			args = append(args, BesuEngineHostAllowList, commaSeperatedHosts)
		}
	}

	if len(node.Spec.CORSDomains) != 0 {
		commaSeperatedDomains := strings.Join(node.Spec.CORSDomains, ",")
		if node.Spec.RPC {
			args = append(args, BesuRPCHTTPCorsOrigins, commaSeperatedDomains)
		}
		if node.Spec.GraphQL {
			args = append(args, BesuGraphQLHTTPCorsOrigins, commaSeperatedDomains)
		}
		// no ws cors setting
	}

	return args
}

// Genesis returns genesis config parameter
func (b *BesuClient) Genesis() (content string, err error) {
	node := b.node
	genesis := node.Spec.Genesis
	mixHash := genesis.MixHash
	nonce := genesis.Nonce
	extraData := "0x00"
	difficulty := genesis.Difficulty
	result := map[string]interface{}{}

	var consensusConfig map[string]uint
	var engine string

	// ethash PoW settings
	if genesis.Ethash != nil {
		consensusConfig = map[string]uint{}

		if genesis.Ethash.FixedDifficulty != nil {
			consensusConfig["fixeddifficulty"] = *genesis.Ethash.FixedDifficulty
		}

		engine = "ethash"
	}

	// clique PoA settings
	if genesis.Clique != nil {
		consensusConfig = map[string]uint{
			"blockperiodseconds": genesis.Clique.BlockPeriod,
			"epochlength":        genesis.Clique.EpochLength,
		}
		engine = "clique"
		extraData = createExtraDataFromSigners(genesis.Clique.Signers)
	}

	// clique ibft2 settings
	if genesis.IBFT2 != nil {

		consensusConfig = map[string]uint{
			"blockperiodseconds":        genesis.IBFT2.BlockPeriod,
			"epochlength":               genesis.IBFT2.EpochLength,
			"requesttimeoutseconds":     genesis.IBFT2.RequestTimeout,
			"messageQueueLimit":         genesis.IBFT2.MessageQueueLimit,
			"duplicateMessageLimit":     genesis.IBFT2.DuplicateMessageLimit,
			"futureMessagesLimit":       genesis.IBFT2.FutureMessagesLimit,
			"futureMessagesMaxDistance": genesis.IBFT2.FutureMessagesMaxDistance,
		}
		engine = "ibft2"
		mixHash = "0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365"
		nonce = "0x0"
		difficulty = "0x1"
		extraData, err = createExtraDataFromValidators(genesis.IBFT2.Validators)
		if err != nil {
			return
		}
	}

	config := map[string]interface{}{
		"chainId":             genesis.ChainID,
		"homesteadBlock":      genesis.Forks.Homestead,
		"eip150Block":         genesis.Forks.EIP150,
		"eip155Block":         genesis.Forks.EIP155,
		"eip158Block":         genesis.Forks.EIP158,
		"byzantiumBlock":      genesis.Forks.Byzantium,
		"constantinopleBlock": genesis.Forks.Constantinople,
		"petersburgBlock":     genesis.Forks.Petersburg,
		"istanbulBlock":       genesis.Forks.Istanbul,
		"muirGlacierBlock":    genesis.Forks.MuirGlacier,
		"berlinBlock":         genesis.Forks.Berlin,
		"londonBlock":         genesis.Forks.London,
		"arrowGlacierBlock":   genesis.Forks.ArrowGlacier,
		engine:                consensusConfig,
	}

	if genesis.Forks.DAO != nil {
		config["daoForkBlock"] = genesis.Forks.DAO
	}

	// If london fork is activated at genesis block
	// set baseFeePerGas to 0x3B9ACA00
	// https://discord.com/channels/697535391594446898/743193040197386451/900791897700859916
	if genesis.Forks.London == 0 {
		result["baseFeePerGas"] = "0x3B9ACA00"
	}

	result["config"] = config
	result["nonce"] = nonce
	result["timestamp"] = genesis.Timestamp
	result["gasLimit"] = genesis.GasLimit
	result["difficulty"] = difficulty
	result["coinbase"] = genesis.Coinbase
	result["mixHash"] = mixHash
	result["extraData"] = extraData

	alloc := genesisAccounts(false, genesis.Forks)
	for _, account := range genesis.Accounts {
		m := map[string]interface{}{
			"balance": account.Balance,
		}

		if account.Code != "" {
			m["code"] = account.Code
		}

		if account.Storage != nil {
			m["storage"] = account.Storage
		}

		alloc[string(account.Address)] = m
	}

	result["alloc"] = alloc

	data, err := json.Marshal(result)
	if err != nil {
		return
	}

	content = string(data)

	return
}

// EncodeStaticNodes returns the static nodes, one per line
func (b *BesuClient) EncodeStaticNodes() string {

	if len(b.node.Spec.StaticNodes) == 0 {
		return "[]"
	}

	encoded, _ := json.Marshal(b.node.Spec.StaticNodes)
	return string(encoded)
}

'''
'''--- clients/ethereum/besu_client_test.go ---
package ethereum

import (
	"fmt"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Besu Client", func() {

	enode := ethereumv1alpha1.Enode("enode://2281549869465d98e90cebc45e1d6834a01465a990add7bcf07a49287e7e66b50ca27f9c70a46190cef7ad746dd5d5b6b9dfee0c9954104c8e9bd0d42758ec58@10.5.0.2:30300")
	coinbase := "0x5A0b54D5dc17e0AadC383d2db43B0a0D3E029c4c"

	Context("general", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "gneral",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Client: ethereumv1alpha1.BesuClient,
				StaticNodes: []ethereumv1alpha1.Enode{
					enode,
				},
			},
		}
		client, _ := NewClient(node)

		It("should return correct home directory", func() {
			Expect(client.HomeDir()).To(Equal(BesuHomeDir))
		})

		It("should encode static nodes correctly", func() {
			Expect(client.EncodeStaticNodes()).To(Equal(fmt.Sprintf("[\"%s\"]", enode)))
		})

	})

	Context("Joining mainnet", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "besu-mainnet-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Client:                   ethereumv1alpha1.BesuClient,
				Network:                  ethereumv1alpha1.MainNetwork,
				Bootnodes:                []ethereumv1alpha1.Enode{enode},
				NodePrivateKeySecretName: "besu-mainnet-nodekey",
				StaticNodes:              []ethereumv1alpha1.Enode{enode},
				P2PPort:                  3333,
				SyncMode:                 ethereumv1alpha1.LightSynchronization,
				Logging:                  sharedAPI.WarnLogs,
				Hosts:                    []string{"whitelisted.host.com"},
				CORSDomains:              []string{"allowed.domain.com"},
				RPC:                      true,
				RPCPort:                  8888,
				RPCAPI: []ethereumv1alpha1.API{
					ethereumv1alpha1.NetworkAPI,
					ethereumv1alpha1.AdminAPI,
					ethereumv1alpha1.DebugAPI,
				},
				Engine:        true,
				EnginePort:    8552,
				JWTSecretName: "jwt-secret",
				WS:            true,
				WSPort:        7777,
				WSAPI: []ethereumv1alpha1.API{
					ethereumv1alpha1.ETHAPI,
					ethereumv1alpha1.TransactionPoolAPI,
				},
				GraphQL:     true,
				GraphQLPort: 9999,
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).To(ContainElements(
				BesuDataPath,
				shared.PathData(client.HomeDir()),
				BesuNatMethod,
				"KUBERNETES",
				BesuNetwork,
				ethereumv1alpha1.MainNetwork,
				BesuLogging,
				"WARN",
				BesuNodePrivateKey,
				fmt.Sprintf("%s/nodekey", shared.PathSecrets(client.HomeDir())),
				BesuStaticNodesFile,
				fmt.Sprintf("%s/static-nodes.json", shared.PathConfig(client.HomeDir())),
				BesuBootnodes,
				string(enode),
				BesuP2PPort,
				"3333",
				BesuSyncMode,
				string(ethereumv1alpha1.LightSynchronization),
				BesuRPCHTTPEnabled,
				BesuRPCHTTPHost,
				"0.0.0.0",
				BesuRPCHTTPPort,
				"8888",
				BesuRPCHTTPAPI,
				"NET,ADMIN,DEBUG",
				BesuEngineRpcEnabled,
				BesuEngineHostAllowList,
				"whitelisted.host.com",
				BesuEngineRpcPort,
				"8552",
				BesuEngineJwtSecret,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				BesuRPCWSEnabled,
				BesuRPCWSHost,
				"0.0.0.0",
				BesuRPCWSPort,
				"7777",
				BesuRPCWSAPI,
				"ETH,TXPOOL",
				BesuGraphQLHTTPEnabled,
				BesuGraphQLHTTPHost,
				"0.0.0.0",
				BesuGraphQLHTTPPort,
				"9999",
				BesuHostAllowlist,
				"whitelisted.host.com",
				BesuRPCHTTPCorsOrigins,
				"allowed.domain.com",
				BesuGraphQLHTTPCorsOrigins,
				"allowed.domain.com",
			))
		})

	})

	Context("miner in private PoW network", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "besu-pow-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Genesis: &ethereumv1alpha1.Genesis{
					ChainID:   12345,
					NetworkID: 12345,
					Ethash:    &ethereumv1alpha1.Ethash{},
				},
				Client:                   ethereumv1alpha1.BesuClient,
				Miner:                    true,
				NodePrivateKeySecretName: "besu-pow-nodekey",
				Coinbase:                 sharedAPI.EthereumAddress(coinbase),
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).NotTo(ContainElements(BesuNetwork))
			Expect(client.Args()).To(ContainElements(
				BesuGenesisFile,
				fmt.Sprintf("%s/genesis.json", shared.PathConfig(client.HomeDir())),
				BesuMinerEnabled,
				BesuMinerCoinbase,
				coinbase,
				BesuNetworkID,
				"12345",
				BesuDiscoveryEnabled,
				"false",
			))
		})

	})

	Context("signer in private PoA network", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "besu-poa-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Genesis: &ethereumv1alpha1.Genesis{
					ChainID:   12345,
					NetworkID: 12345,
					Clique: &ethereumv1alpha1.Clique{
						Signers: []sharedAPI.EthereumAddress{
							"0xcF2C3fB8F36A863FD1A8c72E2473f81744B4CA6C",
							"0x1990E5760d9f8Ae0ec55dF8B0819C77e59846Ff2",
							"0xB87c1c66b36D98D1A74a9875EbA12c001e0bcEda",
						},
					},
				},
				Client:                   ethereumv1alpha1.BesuClient,
				Miner:                    true,
				NodePrivateKeySecretName: "besu-poa-nodekey",
				Coinbase:                 sharedAPI.EthereumAddress(coinbase),
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).NotTo(ContainElements(BesuNetwork))
			Expect(client.Args()).To(ContainElements(
				BesuGenesisFile,
				fmt.Sprintf("%s/genesis.json", shared.PathConfig(client.HomeDir())),
				BesuMinerEnabled,
				BesuMinerCoinbase,
				coinbase,
				BesuNetworkID,
				"12345",
				BesuDiscoveryEnabled,
				"false",
			))
		})

	})

	Context("validator in private IBFT2 network", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "besu-ibft2-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Genesis: &ethereumv1alpha1.Genesis{
					ChainID:   12345,
					NetworkID: 12345,
					IBFT2: &ethereumv1alpha1.IBFT2{
						Validators: []sharedAPI.EthereumAddress{
							"0xcF2C3fB8F36A863FD1A8c72E2473f81744B4CA6C",
							"0x1990E5760d9f8Ae0ec55dF8B0819C77e59846Ff2",
							"0xB87c1c66b36D98D1A74a9875EbA12c001e0bcEda",
						},
					},
				},
				Client:                   ethereumv1alpha1.BesuClient,
				Miner:                    true,
				NodePrivateKeySecretName: "besu-ibft2-nodekey",
				Coinbase:                 sharedAPI.EthereumAddress(coinbase),
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).NotTo(ContainElements(BesuNetwork))
			Expect(client.Args()).To(ContainElements(
				BesuGenesisFile,
				fmt.Sprintf("%s/genesis.json", shared.PathConfig(client.HomeDir())),
				BesuMinerEnabled,
				BesuMinerCoinbase,
				coinbase,
				BesuNetworkID,
				"12345",
				BesuDiscoveryEnabled,
				"false",
			))
		})

	})

})

'''
'''--- clients/ethereum/client.go ---
package ethereum

import (
	"fmt"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	"github.com/kotalco/kotal/clients"
)

// EthereumClient is Ethereum client
type EthereumClient interface {
	clients.Interface
	Genesis() (string, error)
	EncodeStaticNodes() string
}

// NewClient returns an Ethereum client instance
func NewClient(node *ethereumv1alpha1.Node) (EthereumClient, error) {
	switch node.Spec.Client {
	case ethereumv1alpha1.BesuClient:
		return &BesuClient{node}, nil
	case ethereumv1alpha1.GethClient:
		return &GethClient{node}, nil
	case ethereumv1alpha1.NethermindClient:
		return &NethermindClient{&ParityGenesis{}, node}, nil
	default:
		return nil, fmt.Errorf("client %s is not supported", node.Spec.Client)
	}
}

'''
'''--- clients/ethereum/client_test.go ---
package ethereum

import (
	"testing"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func TestNewClient(t *testing.T) {
	node := &ethereumv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name: "node-with-invalid-client",
		},
		Spec: ethereumv1alpha1.NodeSpec{
			Client:  ethereumv1alpha1.EthereumClient("nokia"),
			Network: ethereumv1alpha1.MainNetwork,
		},
	}

	client, err := NewClient(node)
	if err == nil {
		t.Error("expecting an error")
	}

	if client != nil {
		t.Error("expecting client to be nil")
	}

	expected := "client nokia is not supported"
	got := err.Error()
	if expected != got {
		t.Errorf("expected error message to be: %s", expected)
	}
}

'''
'''--- clients/ethereum/extradata.go ---
package ethereum

import (
	"bytes"
	"encoding/hex"
	"strings"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/kotalco/kotal/apis/shared"
)

// createExtraDataFromSigners creates extraDta genesis field value from initial signers
func createExtraDataFromSigners(signers []shared.EthereumAddress) string {
	extraData := "0x"
	// vanity data
	extraData += strings.Repeat("00", 32)
	// signers
	for _, signer := range signers {
		// append address without the 0x
		extraData += string(signer)[2:]
	}
	// proposer signature
	extraData += strings.Repeat("00", 65)
	return extraData
}

// createExtraDataFromValidators creates extraDta genesis field value from initial validators
func createExtraDataFromValidators(validators []shared.EthereumAddress) (string, error) {
	data := []interface{}{}
	extraData := "0x"

	// empty vanity bytes
	vanity := bytes.Repeat([]byte{0x00}, 32)

	// validator addresses bytes
	decodedValidators := []interface{}{}
	for _, validator := range validators {
		validatorBytes, err := hex.DecodeString(string(validator)[2:])
		if err != nil {
			return extraData, err
		}
		decodedValidators = append(decodedValidators, validatorBytes)
	}

	// no vote
	var vote []byte

	// round 0, must be 4 bytes
	round := bytes.Repeat([]byte{0x00}, 4)

	// no committer seals
	committers := []interface{}{}

	// pack all required info into data
	data = append(data, vanity)
	data = append(data, decodedValidators)
	data = append(data, vote)
	data = append(data, round)
	data = append(data, committers)

	// rlp encode data
	payload, err := rlp.EncodeToBytes(data)
	if err != nil {
		return extraData, err
	}

	return extraData + common.Bytes2Hex(payload), nil

}

'''
'''--- clients/ethereum/geth_client.go ---
package ethereum

import (
	"encoding/json"
	"fmt"
	"strings"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// GethClient is Go-Ethereum client
// https://github.com/ethereum/go-ethereum
type GethClient struct {
	node *ethereumv1alpha1.Node
}

const (
	// GethHomeDir is go-ethereum docker image home directory
	GethHomeDir = "/home/ethereum"
)

var (
	verbosityLevels = map[sharedAPI.VerbosityLevel]string{
		sharedAPI.NoLogs:    "0",
		sharedAPI.ErrorLogs: "1",
		sharedAPI.WarnLogs:  "2",
		sharedAPI.InfoLogs:  "3",
		sharedAPI.DebugLogs: "4",
		sharedAPI.AllLogs:   "5",
	}
)

// HomeDir returns go-ethereum docker image home directory
func (g *GethClient) HomeDir() string {
	return GethHomeDir
}

func (g *GethClient) Command() []string {
	return nil
}

func (g *GethClient) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client run
func (g *GethClient) Args() (args []string) {

	node := g.node

	args = append(args, GethDataDir, shared.PathData(g.HomeDir()))
	args = append(args, GethDisableIPC)
	args = append(args, GethP2PPort, fmt.Sprintf("%d", node.Spec.P2PPort))
	args = append(args, GethSyncMode, string(node.Spec.SyncMode))
	if g.node.Spec.SyncMode == ethereumv1alpha1.FullSynchronization {
		args = append(args, GethGcMode, "archive")
		args = append(args, GethHistoryTxs, "0")
		args = append(args, GethCachePreImages)
	}
	args = append(args, GethLogging, verbosityLevels[node.Spec.Logging])

	// config.toml holding static nodes
	if len(node.Spec.StaticNodes) != 0 {
		args = append(args, GethConfig, fmt.Sprintf("%s/config.toml", shared.PathConfig(g.HomeDir())))
	}

	if node.Spec.NodePrivateKeySecretName != "" {
		args = append(args, GethNodeKey, fmt.Sprintf("%s/nodekey", shared.PathSecrets(g.HomeDir())))
	}

	if len(node.Spec.Bootnodes) != 0 {
		bootnodes := []string{}
		for _, bootnode := range node.Spec.Bootnodes {
			bootnodes = append(bootnodes, string(bootnode))
		}
		args = append(args, GethBootnodes, strings.Join(bootnodes, ","))
	}

	if node.Spec.Genesis == nil {
		args = append(args, fmt.Sprintf("--%s", node.Spec.Network))
	} else {
		args = append(args, GethNoDiscovery)
		args = append(args, GethNetworkID, fmt.Sprintf("%d", node.Spec.Genesis.NetworkID))
	}

	if node.Spec.Miner {
		args = append(args, GethMinerEnabled)
		args = append(args, GethMinerCoinbase, string(node.Spec.Coinbase))
		args = append(args, GethUnlock, string(node.Spec.Coinbase))
		args = append(args, GethPassword, fmt.Sprintf("%s/account.password", shared.PathSecrets(g.HomeDir())))
	}

	if node.Spec.RPC {
		args = append(args, GethRPCHTTPEnabled)
		args = append(args, GethRPCHTTPHost, shared.Host(node.Spec.RPC))
		args = append(args, GethRPCHTTPPort, fmt.Sprintf("%d", node.Spec.RPCPort))
		// JSON-RPC API
		apis := []string{}
		for _, api := range node.Spec.RPCAPI {
			apis = append(apis, string(api))
		}
		commaSeperatedAPIs := strings.Join(apis, ",")
		args = append(args, GethRPCHTTPAPI, commaSeperatedAPIs)
	}

	if node.Spec.Engine {
		args = append(args, GethAuthRPCPort, fmt.Sprintf("%d", node.Spec.EnginePort))
		jwtSecretPath := fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(g.HomeDir()))
		args = append(args, GethAuthRPCJwtSecret, jwtSecretPath)
	}
	args = append(args, GethAuthRPCAddress, shared.Host(node.Spec.Engine))

	if node.Spec.WS {
		args = append(args, GethRPCWSEnabled)
		args = append(args, GethRPCWSHost, shared.Host(node.Spec.WS))
		args = append(args, GethRPCWSPort, fmt.Sprintf("%d", node.Spec.WSPort))
		// WebSocket API
		apis := []string{}
		for _, api := range node.Spec.WSAPI {
			apis = append(apis, string(api))
		}
		commaSeperatedAPIs := strings.Join(apis, ",")
		args = append(args, GethRPCWSAPI, commaSeperatedAPIs)
	}

	if node.Spec.GraphQL {
		args = append(args, GethGraphQLHTTPEnabled)
		//NOTE: .GraphQLPort is ignored because rpc port will be used by graphql server
		// .GraphQLPort will be used in the service that point to the pod
	}

	if len(node.Spec.Hosts) != 0 {
		commaSeperatedHosts := strings.Join(node.Spec.Hosts, ",")
		if node.Spec.RPC {
			args = append(args, GethRPCHostWhitelist, commaSeperatedHosts)
		}
		if node.Spec.GraphQL {
			args = append(args, GethGraphQLHostWhitelist, commaSeperatedHosts)
		}
		if node.Spec.Engine {
			args = append(args, GethAuthRPCHosts, commaSeperatedHosts)
		}
		// no ws hosts settings
	}

	if len(node.Spec.CORSDomains) != 0 {
		commaSeperatedDomains := strings.Join(node.Spec.CORSDomains, ",")
		if node.Spec.RPC {
			args = append(args, GethRPCHTTPCorsOrigins, commaSeperatedDomains)
		}
		if node.Spec.GraphQL {
			args = append(args, GethGraphQLHTTPCorsOrigins, commaSeperatedDomains)
		}
		if node.Spec.WS {
			args = append(args, GethWSOrigins, commaSeperatedDomains)
		}
	}

	return args
}

// EncodeStaticNodes returns the static nodes
// [Node.P2P]
// StaticNodes = [enodeURL1, enodeURL2 ...]
func (g *GethClient) EncodeStaticNodes() string {

	var encoded []byte

	if len(g.node.Spec.StaticNodes) == 0 {
		encoded = []byte("[]")
	} else {
		encoded, _ = json.Marshal(g.node.Spec.StaticNodes)
	}

	return fmt.Sprintf("[Node.P2P]\nStaticNodes = %s", string(encoded))
}

// Genesis returns genesis config parameter
func (g *GethClient) Genesis() (content string, err error) {
	node := g.node
	genesis := node.Spec.Genesis
	mixHash := genesis.MixHash
	nonce := genesis.Nonce
	extraData := "0x00"
	difficulty := genesis.Difficulty
	result := map[string]interface{}{}

	var consensusConfig map[string]uint
	var engine string

	// ethash PoW settings
	if genesis.Ethash != nil {
		consensusConfig = map[string]uint{}
		engine = "ethash"
	}

	// clique PoA settings
	if genesis.Clique != nil {
		consensusConfig = map[string]uint{
			"period": genesis.Clique.BlockPeriod,
			"epoch":  genesis.Clique.EpochLength,
		}
		engine = "clique"
		extraData = createExtraDataFromSigners(genesis.Clique.Signers)
	}

	config := map[string]interface{}{
		"chainId":             genesis.ChainID,
		"homesteadBlock":      genesis.Forks.Homestead,
		"eip150Block":         genesis.Forks.EIP150,
		"eip155Block":         genesis.Forks.EIP155,
		"eip158Block":         genesis.Forks.EIP158,
		"byzantiumBlock":      genesis.Forks.Byzantium,
		"constantinopleBlock": genesis.Forks.Constantinople,
		"petersburgBlock":     genesis.Forks.Petersburg,
		"istanbulBlock":       genesis.Forks.Istanbul,
		"muirGlacierBlock":    genesis.Forks.MuirGlacier,
		"berlinBlock":         genesis.Forks.Berlin,
		"londonBlock":         genesis.Forks.London,
		"arrowGlacierBlock":   genesis.Forks.ArrowGlacier,
		engine:                consensusConfig,
	}

	if genesis.Forks.DAO != nil {
		config["daoForkBlock"] = genesis.Forks.DAO
		config["daoForkSupport"] = true
	}

	result["config"] = config

	result["nonce"] = nonce
	result["timestamp"] = genesis.Timestamp
	result["gasLimit"] = genesis.GasLimit
	result["difficulty"] = difficulty
	result["coinbase"] = genesis.Coinbase
	result["mixHash"] = mixHash
	result["extraData"] = extraData

	alloc := genesisAccounts(false, genesis.Forks)
	for _, account := range genesis.Accounts {
		m := map[string]interface{}{
			"balance": account.Balance,
		}

		if account.Code != "" {
			m["code"] = account.Code
		}

		if account.Storage != nil {
			m["storage"] = account.Storage
		}

		alloc[string(account.Address)] = m
	}

	result["alloc"] = alloc

	data, err := json.Marshal(result)
	if err != nil {
		return
	}

	content = string(data)

	return
}

'''
'''--- clients/ethereum/geth_client_test.go ---
package ethereum

import (
	"fmt"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Geth Client", func() {

	enode := ethereumv1alpha1.Enode("enode://2281549869465d98e90cebc45e1d6834a01465a990add7bcf07a49287e7e66b50ca27f9c70a46190cef7ad746dd5d5b6b9dfee0c9954104c8e9bd0d42758ec58@10.5.0.2:30300")
	coinbase := "0x5A0b54D5dc17e0AadC383d2db43B0a0D3E029c4c"

	Context("general", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "gneral",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Client: ethereumv1alpha1.GethClient,
				StaticNodes: []ethereumv1alpha1.Enode{
					enode,
				},
			},
		}
		client, _ := NewClient(node)

		It("should return correct home directory", func() {
			Expect(client.HomeDir()).To(Equal(GethHomeDir))
		})

		It("should encode static nodes correctly", func() {

			Expect(client.EncodeStaticNodes()).To(Equal(fmt.Sprintf("[Node.P2P]\nStaticNodes = [\"%s\"]", string(enode))))
		})
	})

	Context("Joining mainnet", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "geth-mainnet-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Network:                  ethereumv1alpha1.MainNetwork,
				Client:                   ethereumv1alpha1.GethClient,
				Bootnodes:                []ethereumv1alpha1.Enode{enode},
				NodePrivateKeySecretName: "geth-mainnet-nodekey",
				StaticNodes:              []ethereumv1alpha1.Enode{enode},
				P2PPort:                  3333,
				SyncMode:                 ethereumv1alpha1.LightSynchronization,
				Logging:                  sharedAPI.WarnLogs,
				Hosts:                    []string{"whitelisted.host.com"},
				CORSDomains:              []string{"allowed.domain.com"},
				RPC:                      true,
				RPCPort:                  8888,
				RPCAPI: []ethereumv1alpha1.API{
					ethereumv1alpha1.NetworkAPI,
					ethereumv1alpha1.AdminAPI,
					ethereumv1alpha1.DebugAPI,
				},
				Engine:        true,
				EnginePort:    8552,
				JWTSecretName: "jwt-secret",
				WS:            true,
				WSPort:        7777,
				WSAPI: []ethereumv1alpha1.API{
					ethereumv1alpha1.ETHAPI,
					ethereumv1alpha1.TransactionPoolAPI,
				},
				GraphQL:     true,
				GraphQLPort: 9999,
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).To(ContainElements(
				GethDataDir,
				shared.PathData(client.HomeDir()),
				GethDisableIPC,
				fmt.Sprintf("--%s", ethereumv1alpha1.MainNetwork),
				GethLogging,
				"2", // warn logs
				GethNodeKey,
				fmt.Sprintf("%s/nodekey", shared.PathSecrets(client.HomeDir())),
				GethConfig,
				fmt.Sprintf("%s/config.toml", shared.PathConfig(client.HomeDir())),
				GethBootnodes,
				string(enode),
				GethP2PPort,
				"3333",
				GethSyncMode,
				string(ethereumv1alpha1.LightSynchronization),
				GethRPCHTTPEnabled,
				GethRPCHTTPHost,
				"0.0.0.0",
				GethRPCHTTPPort,
				"8888",
				GethRPCHTTPAPI,
				"net,admin,debug",
				GethRPCWSEnabled,
				GethRPCWSHost,
				"0.0.0.0",
				GethAuthRPCAddress,
				"0.0.0.0",
				GethAuthRPCPort,
				"8552",
				GethAuthRPCHosts,
				"whitelisted.host.com",
				GethAuthRPCJwtSecret,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				GethRPCWSPort,
				"7777",
				GethRPCWSAPI,
				"eth,txpool",
				GethGraphQLHTTPEnabled,
				GethRPCHostWhitelist,
				"whitelisted.host.com",
				GethGraphQLHostWhitelist,
				"whitelisted.host.com",
				GethRPCHTTPCorsOrigins,
				"allowed.domain.com",
				GethGraphQLHTTPCorsOrigins,
				"allowed.domain.com",
				GethWSOrigins,
				"allowed.domain.com",
			))
		})
	})

	Context("miner in private PoW network", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "geth-pow-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Genesis: &ethereumv1alpha1.Genesis{
					ChainID:   12345,
					NetworkID: 12345,
					Ethash:    &ethereumv1alpha1.Ethash{},
				},
				Client:   ethereumv1alpha1.GethClient,
				Miner:    true,
				Coinbase: sharedAPI.EthereumAddress(coinbase),
				Import: &ethereumv1alpha1.ImportedAccount{
					PrivateKeySecretName: "geth-pow-account-key",
					PasswordSecretName:   "geth-pow-account-password",
				},
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).To(ContainElements(
				GethMinerEnabled,
				GethMinerCoinbase,
				coinbase,
				GethUnlock,
				coinbase,
				GethPassword,
				fmt.Sprintf("%s/account.password", shared.PathSecrets(client.HomeDir())),
				GethNetworkID,
				"12345",
				GethNoDiscovery,
			))
		})

	})

	Context("signer in private PoA network", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "geth-poa-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Genesis: &ethereumv1alpha1.Genesis{
					ChainID:   12345,
					NetworkID: 12345,
					Clique: &ethereumv1alpha1.Clique{
						Signers: []sharedAPI.EthereumAddress{
							"0xcF2C3fB8F36A863FD1A8c72E2473f81744B4CA6C",
							"0x1990E5760d9f8Ae0ec55dF8B0819C77e59846Ff2",
							"0xB87c1c66b36D98D1A74a9875EbA12c001e0bcEda",
						},
					},
				},
				Client:   ethereumv1alpha1.GethClient,
				SyncMode: ethereumv1alpha1.FullSynchronization,
				Miner:    true,
				Coinbase: sharedAPI.EthereumAddress(coinbase),
				Import: &ethereumv1alpha1.ImportedAccount{
					PrivateKeySecretName: "geth-poa-account-key",
					PasswordSecretName:   "geth-poa-account-password",
				},
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).To(ContainElements(
				GethSyncMode,
				string(node.Spec.SyncMode),
				GethCachePreImages,
				GethHistoryTxs,
				"0",
				GethMinerEnabled,
				GethMinerCoinbase,
				coinbase,
				GethUnlock,
				coinbase,
				GethPassword,
				fmt.Sprintf("%s/account.password", shared.PathSecrets(client.HomeDir())),
				GethNetworkID,
				"12345",
				GethNoDiscovery,
			))
		})

	})

})

'''
'''--- clients/ethereum/nethermind_client.go ---
package ethereum

import (
	"encoding/json"
	"fmt"
	"strings"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

const (
	// NethermindHomeDir is nethermind docker image home directory
	NethermindHomeDir = "/home/nethermind"
)

// NethermindClient is nethermind client
// https://github.com/NethermindEth/nethermind
type NethermindClient struct {
	*ParityGenesis
	node *ethereumv1alpha1.Node
}

// HomeDir returns besu client home directory
func (n *NethermindClient) HomeDir() string {
	return NethermindHomeDir
}

func (n *NethermindClient) Command() []string {
	return nil
}

func (n *NethermindClient) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client run
// NOTE:
// - Network ID can be set in genesis config
func (n *NethermindClient) Args() (args []string) {

	node := n.node

	args = append(args, NethermindDataPath, shared.PathData(n.HomeDir()))
	args = append(args, NethermindP2PPort, fmt.Sprintf("%d", node.Spec.P2PPort))
	args = append(args, NethermindLogging, strings.ToUpper(string(node.Spec.Logging)))

	if node.Spec.NodePrivateKeySecretName != "" {
		// use enode private key in binary format
		// that has been converted using nethermind_convert_enode_privatekey.sh script
		args = append(args, NethermindNodePrivateKey, fmt.Sprintf("%s/kotal_nodekey", shared.PathData(n.HomeDir())))
	}

	if len(node.Spec.StaticNodes) != 0 {
		args = append(args, NethermindStaticNodesFile, fmt.Sprintf("%s/static-nodes.json", shared.PathConfig(n.HomeDir())))
	}

	if len(node.Spec.Bootnodes) != 0 {
		bootnodes := []string{}
		for _, bootnode := range node.Spec.Bootnodes {
			bootnodes = append(bootnodes, string(bootnode))
		}
		args = append(args, NethermindBootnodes, strings.Join(bootnodes, ","))
	}

	if node.Spec.Genesis == nil {
		args = append(args, NethermindNetwork, node.Spec.Network)
	} else {
		// use empty config, because nethermind uses mainnet.cfg by default which can shadow some settings here
		args = append(args, NethermindNetwork, fmt.Sprintf("%s/empty.cfg", shared.PathConfig(n.HomeDir())))
		args = append(args, NethermindGenesisFile, fmt.Sprintf("%s/genesis.json", shared.PathConfig(n.HomeDir())))
		args = append(args, NethermindDiscoveryEnabled, "false")
	}

	switch node.Spec.SyncMode {
	case ethereumv1alpha1.FullSynchronization:
		args = append(args, NethermindFastSync, "false")
		args = append(args, NethermindFastBlocks, "false")
		args = append(args, NethermindDownloadBodiesInFastSync, "false")
		args = append(args, NethermindDownloadReceiptsInFastSync, "false")
	case ethereumv1alpha1.FastSynchronization:
		args = append(args, NethermindFastSync, "true")
		args = append(args, NethermindFastBlocks, "true")
		args = append(args, NethermindDownloadBodiesInFastSync, "true")
		args = append(args, NethermindDownloadReceiptsInFastSync, "true")
	}

	if node.Spec.Miner {
		args = append(args, NethermindMiningEnabled, "true")
		args = append(args, NethermindMinerCoinbase, string(node.Spec.Coinbase))
		args = append(args, NethermindUnlockAccounts, fmt.Sprintf("[%s]", node.Spec.Coinbase))
		args = append(args, NethermindPasswordFiles, fmt.Sprintf("[%s/account.password]", shared.PathSecrets(n.HomeDir())))
	}

	if node.Spec.RPC {
		args = append(args, NethermindRPCHTTPEnabled, "true")
		args = append(args, NethermindRPCHTTPPort, fmt.Sprintf("%d", node.Spec.RPCPort))
		args = append(args, NethermindRPCHTTPHost, shared.Host(node.Spec.RPC))
		// JSON-RPC API
		apis := []string{}
		for _, api := range node.Spec.RPCAPI {
			apis = append(apis, string(api))
		}
		commaSeperatedAPIs := strings.Join(apis, ",")
		args = append(args, NethermindRPCHTTPAPI, commaSeperatedAPIs)
	}

	if node.Spec.Engine {
		args = append(args, NethermindRPCEnginePort, fmt.Sprintf("%d", node.Spec.EnginePort))
		jwtSecretPath := fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(n.HomeDir()))
		args = append(args, NethermindRPCJwtSecretFile, jwtSecretPath)
	}
	args = append(args, NethermindRPCEngineHost, shared.Host(node.Spec.Engine))

	if node.Spec.WS {
		args = append(args, NethermindRPCWSEnabled, "true")
		args = append(args, NethermindRPCWSPort, fmt.Sprintf("%d", node.Spec.WSPort))
		// no option for ws host, ws uses same http host as JSON-RPC
		// nethermind ws reuses enabled JSON-RPC modules
	}

	return args
}

// Genesis returns genesis config parameter
func (p *NethermindClient) Genesis() (string, error) {
	return p.ParityGenesis.Genesis(p.node)
}

// EncodeStaticNodes returns the static nodes, one per line
func (n *NethermindClient) EncodeStaticNodes() string {

	if len(n.node.Spec.StaticNodes) == 0 {
		return "[]"
	}

	encoded, _ := json.Marshal(n.node.Spec.StaticNodes)
	return string(encoded)
}

'''
'''--- clients/ethereum/nethermind_client_test.go ---
package ethereum

import (
	"fmt"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Nethermind Client", func() {

	enode := ethereumv1alpha1.Enode("enode://2281549869465d98e90cebc45e1d6834a01465a990add7bcf07a49287e7e66b50ca27f9c70a46190cef7ad746dd5d5b6b9dfee0c9954104c8e9bd0d42758ec58@10.5.0.2:30300")
	coinbase := "0x5A0b54D5dc17e0AadC383d2db43B0a0D3E029c4c"

	Context("general", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "gneral",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Client: ethereumv1alpha1.NethermindClient,
				StaticNodes: []ethereumv1alpha1.Enode{
					enode,
				},
			},
		}
		client, _ := NewClient(node)

		It("should return correct home directory", func() {
			Expect(client.HomeDir()).To(Equal(NethermindHomeDir))
		})

		It("should encode static nodes correctly", func() {
			Expect(client.EncodeStaticNodes()).To(Equal(fmt.Sprintf("[\"%s\"]", string(enode))))
		})
	})

	Context("Joining mainnet", func() {
		node := ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "nethermind-mainnet-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Client:                   ethereumv1alpha1.NethermindClient,
				Network:                  ethereumv1alpha1.MainNetwork,
				NodePrivateKeySecretName: "mainnet-nethermind-nodekey",
				Logging:                  sharedAPI.WarnLogs,
				RPC:                      true,
				RPCPort:                  8799,
				RPCAPI: []ethereumv1alpha1.API{
					ethereumv1alpha1.AdminAPI,
					ethereumv1alpha1.NetworkAPI,
				},
				Engine:        true,
				EnginePort:    8552,
				JWTSecretName: "jwt-secret",
				P2PPort:       30306,
				WS:            true,
				WSPort:        30307,
				SyncMode:      ethereumv1alpha1.FastSynchronization,
				StaticNodes: []ethereumv1alpha1.Enode{
					enode,
				},
			},
		}

		node.Default()

		It("Should generate correct args", func() {
			client, err := NewClient(&node)

			Expect(err).To(BeNil())
			Expect(client.Args()).To(ContainElements(
				NethermindNodePrivateKey,
				fmt.Sprintf("%s/kotal_nodekey", shared.PathData(client.HomeDir())),
				NethermindStaticNodesFile,
				fmt.Sprintf("%s/static-nodes.json", shared.PathConfig(client.HomeDir())),
				NethermindDataPath,
				shared.PathData(client.HomeDir()),
				NethermindNetwork,
				node.Spec.Network,
				NethermindP2PPort,
				"30306",
				NethermindFastSync,
				"true",
				NethermindFastBlocks,
				"true",
				NethermindDownloadBodiesInFastSync,
				"true",
				NethermindDownloadReceiptsInFastSync,
				"true",
				NethermindRPCHTTPEnabled,
				"true",
				NethermindRPCHTTPHost,
				"0.0.0.0",
				NethermindRPCHTTPPort,
				"8799",
				NethermindRPCHTTPAPI,
				"admin,net",
				NethermindRPCEnginePort,
				"8552",
				NethermindRPCEngineHost,
				"0.0.0.0",
				NethermindRPCJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				NethermindRPCWSEnabled,
				"true",
				NethermindRPCWSPort,
				"30307",
			))

		})

	})

	Context("miner in private PoW network", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "nethermind-pow-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Genesis: &ethereumv1alpha1.Genesis{
					ChainID:   12345,
					NetworkID: 12345,
					Ethash:    &ethereumv1alpha1.Ethash{},
				},
				Client:   ethereumv1alpha1.NethermindClient,
				Miner:    true,
				Coinbase: sharedAPI.EthereumAddress(coinbase),
				Import: &ethereumv1alpha1.ImportedAccount{
					PrivateKeySecretName: "nethermind-pow-account-key",
					PasswordSecretName:   "nethermind-pow-account-password",
				},
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).To(ContainElements(
				NethermindMiningEnabled,
				"true",
				NethermindMinerCoinbase,
				coinbase,
				NethermindUnlockAccounts,
				fmt.Sprintf("[%s]", coinbase),
				NethermindPasswordFiles,
				fmt.Sprintf("[%s/account.password]", shared.PathSecrets(client.HomeDir())),
				NethermindDiscoveryEnabled,
				"false",
				NethermindNetwork,
				fmt.Sprintf("%s/empty.cfg", shared.PathConfig(client.HomeDir())),
			))
		})

	})

	Context("signer in private PoA network", func() {
		node := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name: "nethermind-poa-node",
			},
			Spec: ethereumv1alpha1.NodeSpec{
				Genesis: &ethereumv1alpha1.Genesis{
					ChainID:   12345,
					NetworkID: 12345,
					Clique: &ethereumv1alpha1.Clique{
						Signers: []sharedAPI.EthereumAddress{
							"0xcF2C3fB8F36A863FD1A8c72E2473f81744B4CA6C",
							"0x1990E5760d9f8Ae0ec55dF8B0819C77e59846Ff2",
							"0xB87c1c66b36D98D1A74a9875EbA12c001e0bcEda",
						},
					},
				},
				Client:   ethereumv1alpha1.NethermindClient,
				Miner:    true,
				Coinbase: sharedAPI.EthereumAddress(coinbase),
				Import: &ethereumv1alpha1.ImportedAccount{
					PrivateKeySecretName: "nethermind-poa-account-key",
					PasswordSecretName:   "nethermind-poa-account-password",
				},
			},
		}
		node.Default()

		It("should generate correct arguments", func() {

			client, err := NewClient(node)

			Expect(err).To(BeNil())
			Expect(client.Args()).To(ContainElements(
				NethermindMiningEnabled,
				"true",
				NethermindMinerCoinbase,
				coinbase,
				NethermindUnlockAccounts,
				fmt.Sprintf("[%s]", coinbase),
				NethermindPasswordFiles,
				fmt.Sprintf("[%s/account.password]", shared.PathSecrets(client.HomeDir())),
				NethermindDiscoveryEnabled,
				"false",
				NethermindNetwork,
				fmt.Sprintf("%s/empty.cfg", shared.PathConfig(client.HomeDir())),
			))
		})

	})

})

'''
'''--- clients/ethereum/parity_genesis.go ---
package ethereum

import (
	"encoding/json"
	"fmt"
	"math/big"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
)

type ParityGenesis struct{}

// NormalizeNonce normalizes nonce to be 8 bytes (16 hex digits)
func (p *ParityGenesis) NormalizeNonce(data string) string {
	n := new(big.Int)
	i, _ := n.SetString(data, 16)
	return fmt.Sprintf("%#0.16x", i)
}

// Genesis returns genesis config parameter
func (p *ParityGenesis) Genesis(node *ethereumv1alpha1.Node) (content string, err error) {
	genesis := node.Spec.Genesis
	extraData := "0x00"
	var engineConfig map[string]interface{}

	// clique PoA settings
	if genesis.Clique != nil {
		extraData = createExtraDataFromSigners(genesis.Clique.Signers)
		engineConfig = map[string]interface{}{
			"clique": map[string]interface{}{
				"params": map[string]interface{}{
					"period": genesis.Clique.BlockPeriod,
					"epoch":  genesis.Clique.EpochLength,
				},
			},
		}
	}

	hex := func(n uint) string {
		return fmt.Sprintf("%#x", n)
	}

	tingerineWhistleBlock := hex(genesis.Forks.EIP150)
	spuriousDragonBlock := hex(genesis.Forks.EIP155)
	homesteadBlock := hex(genesis.Forks.Homestead)
	byzantiumBlock := hex(genesis.Forks.Byzantium)
	constantinopleBlock := hex(genesis.Forks.Constantinople)
	petersburgBlock := hex(genesis.Forks.Petersburg)
	istanbulBlock := hex(genesis.Forks.Istanbul)
	muirGlacierBlock := hex(genesis.Forks.MuirGlacier)
	berlinBlock := hex(genesis.Forks.Berlin)
	londonBlock := hex(genesis.Forks.London)
	arrowGlacierBlock := hex(genesis.Forks.ArrowGlacier)

	// ethash PoW settings
	if genesis.Ethash != nil {
		params := map[string]interface{}{
			"minimumDifficulty":      "0x020000",
			"difficultyBoundDivisor": "0x0800",
			"durationLimit":          "0x0d",
			"blockReward": map[string]string{
				tingerineWhistleBlock: "0x4563918244f40000",
				byzantiumBlock:        "0x29a2241af62c0000",
				constantinopleBlock:   "0x1bc16d674ec80000",
			},
			"homesteadTransition": homesteadBlock,
			"eip100bTransition":   byzantiumBlock,
			"difficultyBombDelays": map[string]string{
				byzantiumBlock:      "0x2dc6c0",
				constantinopleBlock: "0x1e8480",
				muirGlacierBlock:    "0x3d0900",
				londonBlock:         "0xaae60",
				arrowGlacierBlock:   "0xf4240",
			},
		}

		if genesis.Forks.DAO != nil {
			params["daoHardforkTransition"] = hex(*genesis.Forks.DAO)
		}

		engineConfig = map[string]interface{}{
			"Ethash": map[string]interface{}{
				"params": params,
			},
		}
	}

	genesisConfig := map[string]interface{}{
		"seal": map[string]interface{}{
			"ethereum": map[string]interface{}{
				"nonce":   p.NormalizeNonce(string(genesis.Nonce)[2:]),
				"mixHash": genesis.MixHash,
			},
		},
		"parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
		"timestamp":  genesis.Timestamp,
		"gasLimit":   genesis.GasLimit,
		"difficulty": genesis.Difficulty,
		"author":     genesis.Coinbase,
		"extraData":  extraData,
	}

	// specify base fee per gas if london fork is activated at genesis block
	// https://github.com/openethereum/openethereum/issues/440
	if genesis.Forks.London == 0 {
		genesisConfig["baseFeePerGas"] = "0x3B9ACA00"
	}

	paramsConfig := map[string]interface{}{
		// other non fork parameters
		"chainID":              hex(genesis.ChainID),
		"accountStartNonce":    "0x00",
		"gasLimitBoundDivisor": "0x0400",
		"maximumExtraDataSize": "0xffff",
		"minGasLimit":          "0x1388",
		"networkID":            hex(node.Spec.Genesis.NetworkID),
		// Tingerine Whistle
		"eip150Transition": tingerineWhistleBlock,
		// Spurious Dragon
		"eip155Transition":      spuriousDragonBlock,
		"eip160Transition":      spuriousDragonBlock,
		"eip161abcTransition":   spuriousDragonBlock,
		"eip161dTransition":     spuriousDragonBlock,
		"maxCodeSizeTransition": spuriousDragonBlock, //eip170
		"maxCodeSize":           "0x6000",
		// Byzantium
		"eip140Transition": byzantiumBlock,
		"eip211Transition": byzantiumBlock,
		"eip214Transition": byzantiumBlock,
		"eip658Transition": byzantiumBlock,
		// Constantinople
		"eip145Transition":  constantinopleBlock,
		"eip1014Transition": constantinopleBlock,
		"eip1052Transition": constantinopleBlock,
		"eip1283Transition": constantinopleBlock,
		// PetersBurg
		"eip1283DisableTransition": petersburgBlock,
		// Istanbul
		"eip1283ReenableTransition": istanbulBlock,
		"eip1344Transition":         istanbulBlock,
		"eip1706Transition":         istanbulBlock,
		"eip1884Transition":         istanbulBlock,
		"eip2028Transition":         istanbulBlock,
		// Berlin
		"eip2315Transition": berlinBlock, // Simple Subroutines for the EVM
		"eip2929Transition": berlinBlock, // Gas cost increases for state access opcodes
		"eip2930Transition": berlinBlock, // Access lists. Requires eips 2718 (Typed Transaction Envelope), and 2929
		// London
		"eip1559Transition":                  londonBlock, // Fee market
		"eip3198Transition":                  londonBlock, // BASEFEE opcode
		"eip3541Transition":                  londonBlock, // Reject new contracts starting with the 0xEF byte
		"eip3529Transition":                  londonBlock, // Reduction in refunds
		"eip1559BaseFeeMaxChangeDenominator": "0x8",
		"eip1559ElasticityMultiplier":        "0x2",
		"eip1559BaseFeeInitialValue":         "0x3B9ACA00",
	}

	alloc := genesisAccounts(true, genesis.Forks)
	for _, account := range genesis.Accounts {
		m := map[string]interface{}{
			"balance": account.Balance,
		}

		if account.Code != "" {
			m["code"] = account.Code
		}

		if account.Storage != nil {
			m["storage"] = account.Storage
		}

		alloc[string(account.Address)] = m
	}

	result := map[string]interface{}{
		"name":     "network",
		"genesis":  genesisConfig,
		"params":   paramsConfig,
		"engine":   engineConfig,
		"accounts": alloc,
	}

	data, err := json.Marshal(result)
	if err != nil {
		return
	}

	content = string(data)

	return
}

'''
'''--- clients/ethereum/suite_test.go ---
package ethereum

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestEthereumClient(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Ethereum Clients Suite")
}

'''
'''--- clients/ethereum/types.go ---
package ethereum

// Hyperledger Besu client arguments
const (
	// BesuLogging is the argument used for logging verbosity level
	BesuLogging = "--logging"
	// BesuNetworkID is the argument used for network id
	BesuNetworkID = "--network-id"
	// BesuNatMethod is the argument used for nat method
	BesuNatMethod = "--nat-method"
	// BesuNodePrivateKey is the argument used for node private key
	BesuNodePrivateKey = "--node-private-key-file"
	// BesuGenesisFile is the argument used for genesis file
	BesuGenesisFile = "--genesis-file"
	// BesuDataPath is the argument used for data path
	BesuDataPath = "--data-path"
	// BesuNetwork is the argument used for selecting network
	BesuNetwork = "--network"
	// BesuDiscoveryEnabled is the argument used to enabled discovery
	BesuDiscoveryEnabled = "--discovery-enabled"
	// BesuP2PPort is the argument used for p2p port
	BesuP2PPort = "--p2p-port"
	// BesuBootnodes is the argument used for bootnodes
	BesuBootnodes = "--bootnodes"
	// BesuSyncMode is the argument used for sync mode
	BesuSyncMode = "--sync-mode"
	// BesuMinerEnabled is the argument used for turning on mining
	BesuMinerEnabled = "--miner-enabled"
	// BesuMinerCoinbase is the argument used for setting coinbase account
	BesuMinerCoinbase = "--miner-coinbase"
	// BesuRPCHTTPCorsOrigins is the argument used for setting rpc HTTP cors origins
	BesuRPCHTTPCorsOrigins = "--rpc-http-cors-origins"
	// BesuRPCHTTPEnabled is the argument used to enable RPC over HTTP
	BesuRPCHTTPEnabled = "--rpc-http-enabled"
	// BesuRPCHTTPPort is the argument used for RPC HTTP port
	BesuRPCHTTPPort = "--rpc-http-port"
	// BesuRPCHTTPHost is the argument used for RPC HTTP Host
	BesuRPCHTTPHost = "--rpc-http-host"
	// BesuRPCHTTPAPI is the argument used for RPC HTTP APIs
	BesuRPCHTTPAPI = "--rpc-http-api"

	// BesuEngineRpcEnabled is the argument used to enable Engine RPC APIs
	BesuEngineRpcEnabled = "--engine-rpc-enabled"
	// BesuEngineJwtSecret is the argument used to locate JWT secret
	BesuEngineJwtSecret = "--engine-jwt-secret"
	// BesuEngineRpcPort is the argument used to set Engine RPC listening port
	BesuEngineRpcPort = "--engine-rpc-port"
	// BesuEngineHostAllowList is the argument used to set hosts from which to accept requests
	BesuEngineHostAllowList = "--engine-host-allowlist"

	// BesuRPCWSEnabled is the argument used to enable RPC WS
	BesuRPCWSEnabled = "--rpc-ws-enabled"
	// BesuRPCWSPort is the argument used for RPC WS port
	BesuRPCWSPort = "--rpc-ws-port"
	// BesuRPCWSHost is the argument used for RPC WS host
	BesuRPCWSHost = "--rpc-ws-host"
	// BesuRPCWSAPI is the argument used for RPC WS APIs
	BesuRPCWSAPI = "--rpc-ws-api"
	// BesuGraphQLHTTPEnabled is the argument used to enable QraphQL HTTP server
	BesuGraphQLHTTPEnabled = "--graphql-http-enabled"
	// BesuGraphQLHTTPPort is the argument used for GraphQL HTTP port
	BesuGraphQLHTTPPort = "--graphql-http-port"
	// BesuGraphQLHTTPHost is the argument used for GraphQL HTTP host
	BesuGraphQLHTTPHost = "--graphql-http-host"
	// BesuGraphQLHTTPCorsOrigins is the argument used for GraphQL HTTP Cors origins
	BesuGraphQLHTTPCorsOrigins = "--graphql-http-cors-origins"
	// BesuHostAllowlist is the argument used for whitelisting hosts
	BesuHostAllowlist = "--host-allowlist"
	// BesuStaticNodesFile is the argument used to locate static nodes file
	BesuStaticNodesFile = "--static-nodes-file"
)

// Go ethereum client arguments
const (
	// GethLogging is the argument used for logging verbosity level
	GethLogging = "--verbosity"
	// GethConfig is the argument used for config file
	GethConfig = "--config"
	// GethNetworkID is the argument used for network id
	GethNetworkID = "--networkid"
	// GethNodeKey is the argument used for node private key
	GethNodeKey = "--nodekey"
	// GethNoDiscovery is the argument used to disable discovery
	GethNoDiscovery = "--nodiscover"
	// GethDataDir is the argument used for data path
	GethDataDir = "--datadir"
	// GethDisableIPC is the argument used to disable ipc servr
	GethDisableIPC = "--ipcdisable"
	// GethP2PPort is the argument used for p2p port
	GethP2PPort = "--port"
	// GethBootnodes is the argument used for bootnodes
	GethBootnodes = "--bootnodes"
	// GethSyncMode is the argument used for sync mode
	GethSyncMode = "--syncmode"
	// GethGcMode is the argument used for garbage collection mode
	GethGcMode = "--gcmode"
	// GethHistoryTxs is the argument used to set recent number of blocks to maintain transactions index for
	GethHistoryTxs = "--history.transactions"
	// GethCachePreImages is the argument used to enable recording the sha3 preimages of trie keys
	GethCachePreImages = "--cache.preimages"

	// GethMinerEnabled is the argument used for turning on mining
	GethMinerEnabled = "--mine"
	// GethMinerCoinbase is the argument used for setting coinbase account
	GethMinerCoinbase = "--miner.etherbase"

	// GethRPCHTTPCorsOrigins is the argument used for setting rpc HTTP cors origins
	GethRPCHTTPCorsOrigins = "--http.corsdomain"
	// GethRPCHTTPEnabled is the argument used to enable RPC over HTTP
	GethRPCHTTPEnabled = "--http"
	// GethRPCHTTPPort is the argument used for RPC HTTP port
	GethRPCHTTPPort = "--http.port"
	// GethRPCHTTPHost is the argument used for RPC HTTP Host
	GethRPCHTTPHost = "--http.addr"
	// GethRPCHTTPAPI is the argument used for RPC HTTP APIs
	GethRPCHTTPAPI = "--http.api"
	// GethRPCHostWhitelist is the argument used for whitelisting hosts
	GethRPCHostWhitelist = "--http.vhosts"

	// GethAuthRPCAddress is the argument used for listening address for authenticated APIs
	GethAuthRPCAddress = "--authrpc.addr"
	// GethAuthRPCPort is the argument used for listening port for authenticated APIs
	GethAuthRPCPort = "--authrpc.port"
	// GethAuthRPCHosts is the argument used for hostnames from which to accept requests
	GethAuthRPCHosts = "--authrpc.vhosts"
	// GethAuthRPCJwtSecret is the argument used for JWT secret to use for authenticated RPC endpoints
	GethAuthRPCJwtSecret = "--authrpc.jwtsecret"

	// --authrpc.jwtsecret

	// GethRPCWSEnabled is the argument used to enable RPC WS
	GethRPCWSEnabled = "--ws"
	// GethRPCWSPort is the argument used for RPC WS port
	GethRPCWSPort = "--ws.port"
	// GethRPCWSHost is the argument used for RPC WS host
	GethRPCWSHost = "--ws.addr"
	// GethRPCWSAPI is the argument used for RPC WS APIs
	GethRPCWSAPI = "--ws.api"
	// GethWSOrigins is the argument used for RPC WS origins
	GethWSOrigins = "--ws.origins"

	// GethGraphQLHTTPEnabled is the argument used to enable QraphQL HTTP server
	GethGraphQLHTTPEnabled = "--graphql"
	// GethGraphQLHTTPCorsOrigins is the argument used for GraphQL HTTP Cors origins
	GethGraphQLHTTPCorsOrigins = "--graphql.corsdomain"
	// GethGraphQLHostWhitelist is the argument used for whitelisting hosts
	GethGraphQLHostWhitelist = "--graphql.vhosts"
	// GethUnlock is the argument used for unlocking imported ethereum account
	GethUnlock = "--unlock"
	// GethPassword is the argument used for locking imported ethereum address
	GethPassword = "--password"
)

// Parity client arguments
const (
	// ParityLogging is the argument used for logging verbosity level
	ParityLogging = "--logging"
	// ParityNetworkID is the argument used for network id
	ParityNetworkID = "--network-id"
	// ParityNodeKey is the argument used for node key
	ParityNodeKey = "--node-key"
	// ParityDataDir is the argument used for data path
	ParityDataDir = "--base-path"
	// ParityReservedPeers is the argument used for static nodes (reserved peers)
	ParityReservedPeers = "--reserved-peers"
	// ParityNetwork is the argument used for selecting network
	ParityNetwork = "--chain"
	// ParityNoDiscovery is the argument used to disable discovery
	ParityNoDiscovery = "--no-discovery"
	// ParityP2PPort is the argument used for p2p port
	ParityP2PPort = "--port"
	// ParityBootnodes is the argument used for bootnodes
	ParityBootnodes = "--bootnodes"
	// ParitySyncMode is the argument used for sync mode
	ParitySyncMode = "--pruning"
	// ParityMinerCoinbase is the argument used for setting coinbase account
	ParityMinerCoinbase = "--author"
	// ParityEngineSigner is the argument used for engine singer
	ParityEngineSigner = "--engine-signer"

	// ParityDisableRPC is the argument used to disable JSON RPC HTTP server
	ParityDisableRPC = "--no-jsonrpc"
	// ParityRPCHTTPCorsOrigins is the argument used for setting rpc HTTP cors origins
	ParityRPCHTTPCorsOrigins = "--jsonrpc-cors"
	// ParityRPCHTTPPort is the argument used for RPC HTTP port
	ParityRPCHTTPPort = "--jsonrpc-port"
	// ParityRPCHTTPHost is the argument used for RPC HTTP Host
	ParityRPCHTTPHost = "--jsonrpc-interface"
	// ParityRPCHTTPAPI is the argument used for RPC HTTP APIs
	ParityRPCHTTPAPI = "--jsonrpc-apis"
	// ParityRPCHostWhitelist is the argument used for whitelisting hosts
	ParityRPCHostWhitelist = "--jsonrpc-hosts"

	// ParityDisableWS is the argument used for RPC WS port
	ParityDisableWS = "--no-ws"
	// ParityRPCWSCorsOrigins is the argument used for setting RPC WS cors origins
	ParityRPCWSCorsOrigins = "--ws-origins"
	// ParityRPCWSPort is the argument used for RPC WS port
	ParityRPCWSPort = "--ws-port"
	// ParityRPCWSHost is the argument used for RPC WS host
	ParityRPCWSHost = "--ws-interface"
	// ParityRPCWSAPI is the argument used for RPC WS APIs
	ParityRPCWSAPI = "--ws-apis"
	// ParityRPCWSWhitelist is the argument used for whitelisting hosts for WS server
	ParityRPCWSWhitelist = "--ws-hosts"

	// ParityUnlock is the argument used for unlocking imported ethereum account
	ParityUnlock = "--unlock"
	// ParityPassword is the argument used for locking imported ethereum address
	ParityPassword = "--password"
)

// Nethermind client arguments
const (
	// NethermindLogging is the argument used for logging verbosity level
	NethermindLogging = "--log"
	// NethermindNodePrivateKey is the argument used for node private key
	NethermindNodePrivateKey = "--KeyStore.EnodeKeyFile"
	// NethermindStaticNodesFile is the argument used to locate static nodes file
	NethermindStaticNodesFile = "--Init.StaticNodesPath"
	// NethermindBootnodes is the argument used to set bootnodes
	NethermindBootnodes = "--Discovery.Bootnodes"
	// NethermindGenesisFile is the argument used for genesis file
	NethermindGenesisFile = "--Init.ChainSpecPath"
	// NethermindDataPath is the argument used for data path
	NethermindDataPath = "--datadir"
	// NethermindNetwork is the argument used for selecting network
	NethermindNetwork = "--config"
	// NethermindDiscoveryEnabled is the argument used to enabled discovery
	NethermindDiscoveryEnabled = "--Init.DiscoveryEnabled"
	// NethermindP2PPort is the argument used for p2p port
	NethermindP2PPort = "--Network.P2PPort"
	// NethermindFastSync is the argument used to enable beam sync
	NethermindFastSync = "--Sync.FastSync"
	// NethermindFastBlocks is the argument used to enable fast blocks sync
	NethermindFastBlocks = "--Sync.FastBlocks"
	// NethermindDownloadBodiesInFastSync is the argument used to enable downloading block bodies in fast sync
	NethermindDownloadBodiesInFastSync = "--Sync.DownloadBodiesInFastSync"
	// NethermindDownloadReceiptsInFastSync is the argument used to enable downloading block receipts in fast sync
	NethermindDownloadReceiptsInFastSync = "--Sync.DownloadReceiptsInFastSync"
	// NethermindDownloadHeadersInFastSync is the argument used to enable downloading block headers in fast sync
	NethermindDownloadHeadersInFastSync = "--Sync.DownloadHeadersInFastSync"
	// NethermindMinerCoinbase is the argument used for setting coinbase account
	NethermindMinerCoinbase = "--KeyStore.BlockAuthorAccount"
	// NethermindRPCHTTPEnabled is the argument used to enable RPC over HTTP
	NethermindRPCHTTPEnabled = "--JsonRpc.Enabled"
	// NethermindRPCHTTPHost is the argument used for RPC HTTP Host
	NethermindRPCHTTPHost = "--JsonRpc.Host"
	// NethermindRPCHTTPPort is the argument used for RPC HTTP port
	NethermindRPCHTTPPort = "--JsonRpc.Port"
	// NethermindRPCHTTPAPI is the argument used for RPC HTTP APIs
	NethermindRPCHTTPAPI = "--JsonRpc.EnabledModules"

	// NethermindRPCEnginePort is the argument used to set engine API listening port
	NethermindRPCEnginePort = "--JsonRpc.EnginePort"
	// NethermindRPCEngineHost is the argument used to set engine API listening address
	NethermindRPCEngineHost = "--JsonRpc.EngineHost"
	// NethermindRPCJwtSecretFile is the argument used to locate jwt secret file
	NethermindRPCJwtSecretFile = "--JsonRpc.JwtSecretFile"

	// NethermindRPCWSEnabled is the argument used to enable RPC WS
	NethermindRPCWSEnabled = "--Init.WebSocketsEnabled"
	// NethermindRPCWSPort is the argument used for RPC WS port
	NethermindRPCWSPort = "--JsonRpc.WebSocketsPort"
	// NethermindUnlockAccounts is the argument used to unlock accounts
	NethermindUnlockAccounts = "--KeyStore.UnlockAccounts"
	// NethermindPasswordFiles is the argument used locate password files for unlocked accounts
	NethermindPasswordFiles = "--KeyStore.PasswordFiles"
	// NethermindMiningEnabled is the argument used for turning on mining
	NethermindMiningEnabled = "--Mining.Enabled"
)

'''
'''--- clients/ethereum2/client.go ---
package ethereum2

import (
	"fmt"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/clients"
	"k8s.io/apimachinery/pkg/runtime"
)

// Ethereum2Client is Ethereum 2.0 beacon node or validator client
type Ethereum2Client interface {
	clients.Interface
}

// NewClient creates new ethereum 2.0 beacon node or validator client
func NewClient(obj runtime.Object) (Ethereum2Client, error) {

	switch component := obj.(type) {

	// create beacon nodes
	case *ethereum2v1alpha1.BeaconNode:
		switch component.Spec.Client {
		case ethereum2v1alpha1.TekuClient:
			return &TekuBeaconNode{component}, nil
		case ethereum2v1alpha1.PrysmClient:
			return &PrysmBeaconNode{component}, nil
		case ethereum2v1alpha1.LighthouseClient:
			return &LighthouseBeaconNode{component}, nil
		case ethereum2v1alpha1.NimbusClient:
			return &NimbusBeaconNode{component}, nil
		default:
			return nil, fmt.Errorf("client %s is not supported", component.Spec.Client)
		}

	// create validator clients
	case *ethereum2v1alpha1.Validator:
		switch component.Spec.Client {
		case ethereum2v1alpha1.TekuClient:
			return &TekuValidatorClient{component}, nil
		case ethereum2v1alpha1.PrysmClient:
			return &PrysmValidatorClient{component}, nil
		case ethereum2v1alpha1.LighthouseClient:
			return &LighthouseValidatorClient{component}, nil
		case ethereum2v1alpha1.NimbusClient:
			return &NimbusValidatorClient{component}, nil
		default:
			return nil, fmt.Errorf("client %s is not supported", component.Spec.Client)
		}
	default:
		return nil, fmt.Errorf("no client support for %s", obj)
	}
}

'''
'''--- clients/ethereum2/lighthouse_beacon_node.go ---
package ethereum2

import (
	"fmt"
	"strings"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// LighthouseBeaconNode is SigmaPrime Ethereum 2.0 client
// https://github.com/sigp/lighthouse
type LighthouseBeaconNode struct {
	node *ethereum2v1alpha1.BeaconNode
}

// HomeDir returns container home directory
func (t *LighthouseBeaconNode) HomeDir() string {
	return LighthouseHomeDir
}

// Command returns environment variables for running the client
func (t *LighthouseBeaconNode) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client
func (t *LighthouseBeaconNode) Args() (args []string) {

	node := t.node

	args = append(args, LighthouseDataDir, shared.PathData(t.HomeDir()))

	args = append(args, LighthouseDebugLevel, string(t.node.Spec.Logging))

	args = append(args, LighthouseNetwork, node.Spec.Network)

	args = append(args, LighthouseExecutionEngineEndpoint, node.Spec.ExecutionEngineEndpoint)

	args = append(args, LighthouseFeeRecipient, string(node.Spec.FeeRecipient))

	jwtSecretPath := fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(t.HomeDir()))
	args = append(args, LighthouseJwtSecretFile, jwtSecretPath)

	if node.Spec.REST {
		args = append(args, LighthouseHTTP)
		args = append(args, LighthouseAllowOrigins, strings.Join(node.Spec.CORSDomains, ","))
		args = append(args, LighthouseHTTPPort, fmt.Sprintf("%d", node.Spec.RESTPort))
		args = append(args, LighthouseHTTPAddress, shared.Host(node.Spec.REST))
	}

	if node.Spec.CheckpointSyncURL != "" {
		args = append(args, LighthouseCheckpointSyncUrl, node.Spec.CheckpointSyncURL)
	}

	args = append(args, LighthousePort, fmt.Sprintf("%d", node.Spec.P2PPort))
	args = append(args, LighthouseDiscoveryPort, fmt.Sprintf("%d", node.Spec.P2PPort))

	return
}

// Command returns command for running the client
func (t *LighthouseBeaconNode) Command() (command []string) {
	command = []string{"lighthouse", "bn"}
	return
}

'''
'''--- clients/ethereum2/lighthouse_beacon_node_test.go ---
package ethereum2

import (
	"fmt"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Lighthouse beacon node", func() {

	node := ethereum2v1alpha1.BeaconNode{
		Spec: ethereum2v1alpha1.BeaconNodeSpec{
			Client:  ethereum2v1alpha1.LighthouseClient,
			Network: "mainnet",
		},
	}
	client, _ := NewClient(&node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("lighthouse", "bn"))
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(LighthouseHomeDir))
	})

	cases := []struct {
		title  string
		node   *ethereum2v1alpha1.BeaconNode
		result []string
	}{
		{
			title: "beacon node syncing mainnet",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:  ethereum2v1alpha1.LighthouseClient,
					Network: "mainnet",
					Logging: sharedAPI.TraceLogs,
				},
			},
			result: []string{
				LighthouseDataDir,
				LighthouseNetwork,
				"mainnet",
				LighthouseDebugLevel,
				string(sharedAPI.TraceLogs),
			},
		},
		{
			title: "beacon node syncing mainnet",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.LighthouseClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					FeeRecipient:            "0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
				},
			},
			result: []string{
				LighthouseDataDir,
				LighthouseNetwork,
				"mainnet",
				LighthouseExecutionEngineEndpoint,
				"https://localhost:8551",
				LighthouseJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				LighthouseFeeRecipient,
				"0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
			},
		},
		{
			title: "beacon node syncing mainnet and http enabled with checkpoint syncing",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.LighthouseClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
					CheckpointSyncURL:       "https://kotal.cloud/eth2/beacon/checkpoint",
				},
			},
			result: []string{
				LighthouseDataDir,
				LighthouseNetwork,
				"mainnet",
				LighthouseExecutionEngineEndpoint,
				"https://localhost:8551",
				LighthouseJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				LighthouseHTTP,
				LighthouseAllowOrigins,
				"*",
				LighthouseCheckpointSyncUrl,
				"https://kotal.cloud/eth2/beacon/checkpoint",
			},
		},
		{
			title: "beacon node syncing mainnet and http enabled with port",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.LighthouseClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
					RESTPort:                4444,
				},
			},
			result: []string{
				LighthouseDataDir,
				LighthouseNetwork,
				"mainnet",
				LighthouseExecutionEngineEndpoint,
				"https://localhost:8551",
				LighthouseJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				LighthouseHTTP,
				LighthouseHTTPPort,
				"4444",
				LighthouseAllowOrigins,
				"*",
			},
		},
		{
			title: "beacon node syncing mainnet with http enabled with port and host",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.LighthouseClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
					RESTPort:                4444,
				},
			},
			result: []string{
				LighthouseDataDir,
				LighthouseNetwork,
				"mainnet",
				LighthouseExecutionEngineEndpoint,
				"https://localhost:8551",
				LighthouseJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				LighthouseHTTP,
				LighthouseHTTPPort,
				"4444",
				LighthouseHTTPAddress,
				"0.0.0.0",
				LighthouseAllowOrigins,
				"*",
			},
		},
		{
			title: "beacon node syncing mainnet with p2p port, http enabled with port and host",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.LighthouseClient,
					P2PPort:                 7891,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
					RESTPort:                4444,
				},
			},
			result: []string{
				LighthouseDataDir,
				LighthousePort,
				"7891",
				LighthouseDiscoveryPort,
				"7891",
				LighthouseNetwork,
				"mainnet",
				LighthouseExecutionEngineEndpoint,
				"https://localhost:8551",
				LighthouseJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				LighthouseHTTP,
				LighthouseHTTPPort,
				"4444",
				LighthouseHTTPAddress,
				"0.0.0.0",
				LighthouseAllowOrigins,
				"*",
			},
		},
	}

	for _, c := range cases {
		func() {
			cc := c
			It(fmt.Sprintf("Should create correct client arguments for %s", cc.title), func() {
				cc.node.Default()
				client, _ := NewClient(cc.node)
				args := client.Args()
				Expect(args).To(ContainElements(cc.result))
			})
		}()
	}

})

'''
'''--- clients/ethereum2/lighthouse_validator_client.go ---
package ethereum2

import (
	"strings"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// LighthouseValidatorClient is SigmaPrime Ethereum 2.0 validator client
// https://github.com/sigp/lighthouse
type LighthouseValidatorClient struct {
	validator *ethereum2v1alpha1.Validator
}

// HomeDir returns container home directory
func (t *LighthouseValidatorClient) HomeDir() string {
	return LighthouseHomeDir
}

// Command returns environment variables for the client
func (t *LighthouseValidatorClient) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client
func (t *LighthouseValidatorClient) Args() (args []string) {

	validator := t.validator

	args = append(args, LighthouseDataDir, shared.PathData(t.HomeDir()))

	args = append(args, LighthouseDebugLevel, string(t.validator.Spec.Logging))

	args = append(args, LighthouseNetwork, validator.Spec.Network)

	args = append(args, LighthouseFeeRecipient, string(validator.Spec.FeeRecipient))

	if len(validator.Spec.BeaconEndpoints) != 0 {
		args = append(args, LighthouseBeaconNodeEndpoints, strings.Join(validator.Spec.BeaconEndpoints, ","))
	}

	if validator.Spec.Graffiti != "" {
		args = append(args, LighthouseGraffiti, validator.Spec.Graffiti)
	}

	return
}

// Command returns command for running the client
func (t *LighthouseValidatorClient) Command() (command []string) {
	command = []string{"lighthouse", "vc"}
	return
}

'''
'''--- clients/ethereum2/lighthouse_validator_client_test.go ---
package ethereum2

import (
	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Lighthouse validator client", func() {

	validator := &ethereum2v1alpha1.Validator{
		Spec: ethereum2v1alpha1.ValidatorSpec{
			Client:  ethereum2v1alpha1.LighthouseClient,
			Network: "mainnet",
			BeaconEndpoints: []string{
				"http://localhost:8899",
				"http://localhost:9988",
			},
			Graffiti:     "Validated by Kotal",
			Logging:      sharedAPI.WarnLogs,
			FeeRecipient: "0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
		},
	}

	validator.Default()
	client, _ := NewClient(validator)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("lighthouse", "vc"))
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(LighthouseHomeDir))
	})

	It("Should generate correct client arguments", func() {
		args := client.Args()

		Expect(args).To(ContainElements([]string{
			LighthouseDataDir,
			shared.PathData(client.HomeDir()),
			LighthouseNetwork,
			"mainnet",
			LighthouseBeaconNodeEndpoints,
			"http://localhost:8899,http://localhost:9988",
			LighthouseGraffiti,
			"Validated by Kotal",
			LighthouseDebugLevel,
			string(sharedAPI.WarnLogs),
			LighthouseFeeRecipient,
			"0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
		}))
	})

})

'''
'''--- clients/ethereum2/nimbus_beacon_node.go ---
package ethereum2

import (
	"fmt"
	"strings"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// NimbusBeaconNode is Status Ethereum 2.0 client
// https://github.com/status-im/nimbus-eth2
type NimbusBeaconNode struct {
	node *ethereum2v1alpha1.BeaconNode
}

// HomeDir returns container home directory
func (t *NimbusBeaconNode) HomeDir() string {
	return NimbusHomeDir
}

// Command returns environment variables for running the client
func (t *NimbusBeaconNode) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client
func (t *NimbusBeaconNode) Args() (args []string) {

	node := t.node

	args = append(args, NimbusNonInteractive)

	args = append(args, argWithVal(NimbusDataDir, shared.PathData(t.HomeDir())))

	args = append(args, argWithVal(NimbusLogging, string(t.node.Spec.Logging)))

	args = append(args, argWithVal(NimbusNetwork, node.Spec.Network))

	args = append(args, argWithVal(NimbusExecutionEngineEndpoint, node.Spec.ExecutionEngineEndpoint))

	args = append(args, argWithVal(NimbusFeeRecipient, string(node.Spec.FeeRecipient)))

	jwtSecretPath := fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(t.HomeDir()))
	args = append(args, argWithVal(NimbusJwtSecretFile, jwtSecretPath))

	if node.Spec.REST {
		args = append(args, NimbusREST)
		args = append(args, argWithVal(NimbusRESTAddress, shared.Host(node.Spec.REST)))
		args = append(args, argWithVal(NimbusRESTPort, fmt.Sprintf("%d", node.Spec.RESTPort)))
		args = append(args, argWithVal(NimbusRESTAllowOrigin, strings.Join(node.Spec.CORSDomains, ",")))
	}

	args = append(args, argWithVal(NimbusTCPPort, fmt.Sprintf("%d", node.Spec.P2PPort)))
	args = append(args, argWithVal(NimbusUDPPort, fmt.Sprintf("%d", node.Spec.P2PPort)))

	return
}

// Command returns command for running the client
func (t *NimbusBeaconNode) Command() (command []string) {
	command = []string{"nimbus_beacon_node"}
	return
}

// nimbus accepts arguments in the form of --arg=val
// --arg val is not recoginized by nimbus
func argWithVal(arg, val string) string {
	return fmt.Sprintf("%s=%s", arg, val)
}

'''
'''--- clients/ethereum2/nimbus_beacon_node_test.go ---
package ethereum2

import (
	"fmt"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Nimbus beacon node", func() {

	node := ethereum2v1alpha1.BeaconNode{
		Spec: ethereum2v1alpha1.BeaconNodeSpec{
			Client:  ethereum2v1alpha1.NimbusClient,
			Network: "mainnet",
		},
	}
	client, _ := NewClient(&node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("nimbus_beacon_node"))
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(NimbusHomeDir))
	})

	cases := []struct {
		title  string
		node   *ethereum2v1alpha1.BeaconNode
		result []string
	}{
		{
			title: "beacon node syncing mainnet",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:  ethereum2v1alpha1.NimbusClient,
					Network: "mainnet",
					Logging: sharedAPI.DebugLogs,
				},
			},
			result: []string{
				NimbusNonInteractive,
				argWithVal(NimbusNetwork, "mainnet"),
				argWithVal(NimbusLogging, string(sharedAPI.DebugLogs)),
			},
		},
		{
			title: "beacon node syncing mainnet with eth1 endpoint",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.NimbusClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
					RESTPort:                8957,
					CORSDomains:             []string{"kotal.pro", "kotal.cloud"},
				},
			},
			result: []string{
				NimbusNonInteractive,
				argWithVal(NimbusNetwork, "mainnet"),
				argWithVal(NimbusExecutionEngineEndpoint, "https://localhost:8551"),
				argWithVal(NimbusJwtSecretFile, fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir()))),
				argWithVal(NimbusRESTAddress, "0.0.0.0"),
				argWithVal(NimbusRESTPort, "8957"),
				argWithVal(NimbusRESTAllowOrigin, "kotal.pro,kotal.cloud"),
			},
		},
		{
			title: "beacon node syncing mainnet with eth1 endpoint",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.NimbusClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
				},
			},
			result: []string{
				NimbusNonInteractive,
				argWithVal(NimbusNetwork, "mainnet"),
				argWithVal(NimbusExecutionEngineEndpoint, "https://localhost:8551"),
				argWithVal(NimbusJwtSecretFile, fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir()))),
			},
		},
		{
			title: "beacon node syncing mainnet with eth1 endpoint",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.NimbusClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
				},
			},
			result: []string{
				NimbusNonInteractive,
				argWithVal(NimbusNetwork, "mainnet"),
				argWithVal(NimbusExecutionEngineEndpoint, "https://localhost:8551"),
				argWithVal(NimbusJwtSecretFile, fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir()))),
			},
		},
		{
			title: "beacon node syncing mainnet with eth1 endpoint",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.NimbusClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
				},
			},
			result: []string{
				NimbusNonInteractive,
				argWithVal(NimbusNetwork, "mainnet"),
				argWithVal(NimbusExecutionEngineEndpoint, "https://localhost:8551"),
				argWithVal(NimbusJwtSecretFile, fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir()))),
			},
		},
		{
			title: "beacon node syncing mainnet with p2p port, eth1 endpoint",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.NimbusClient,
					P2PPort:                 7891,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					FeeRecipient:            "0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
				},
			},
			result: []string{
				NimbusNonInteractive,
				argWithVal(NimbusTCPPort, "7891"),
				argWithVal(NimbusUDPPort, "7891"),
				argWithVal(NimbusNetwork, "mainnet"),
				argWithVal(NimbusExecutionEngineEndpoint, "https://localhost:8551"),
				argWithVal(NimbusJwtSecretFile, fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir()))),
				argWithVal(NimbusFeeRecipient, "0xd8da6bf26964af9d7eed9e03e53415d37aa96045"),
			},
		},
	}

	for _, c := range cases {
		func() {
			cc := c
			It(fmt.Sprintf("Should create correct client arguments for %s", cc.title), func() {
				cc.node.Default()
				client, _ := NewClient(cc.node)
				args := client.Args()
				Expect(args).To(ContainElements(cc.result))
			})
		}()
	}

})

'''
'''--- clients/ethereum2/nimbus_validator_client.go ---
package ethereum2

import (
	"fmt"
	"strings"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// NimbusValidatorClient is Status Ethereum 2.0 client
// https://github.com/status-im/nimbus-eth2
type NimbusValidatorClient struct {
	validator *ethereum2v1alpha1.Validator
}

// HomeDir returns container home directory
func (t *NimbusValidatorClient) HomeDir() string {
	return NimbusHomeDir
}

// Command returns environment variables for the client
func (t *NimbusValidatorClient) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client
func (t *NimbusValidatorClient) Args() (args []string) {

	validator := t.validator

	args = append(args, NimbusNonInteractive)

	args = append(args, argWithVal(NimbusLogging, string(t.validator.Spec.Logging)))

	args = append(args, argWithVal(NimbusDataDir, shared.PathData(t.HomeDir())))

	args = append(args, argWithVal(NimbusFeeRecipient, string(validator.Spec.FeeRecipient)))

	args = append(args, argWithVal(NimbusValidatorsDir, fmt.Sprintf("%s/kotal-validators/validator-keys", shared.PathData(t.HomeDir()))))

	args = append(args, argWithVal(NimbusSecretsDir, fmt.Sprintf("%s/kotal-validators/validator-secrets", shared.PathData(t.HomeDir()))))

	args = append(args, argWithVal(NimbusBeaconNodes, strings.Join(validator.Spec.BeaconEndpoints, ",")))

	if validator.Spec.Graffiti != "" {
		args = append(args, argWithVal(NimbusGraffiti, validator.Spec.Graffiti))
	}

	return
}

// Command returns command for running the client
func (t *NimbusValidatorClient) Command() (command []string) {
	command = []string{"nimbus_validator_client"}
	return
}

'''
'''--- clients/ethereum2/nimbus_validator_client_test.go ---
package ethereum2

import (
	"fmt"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Nimbus validator client", func() {
	validator := &ethereum2v1alpha1.Validator{
		Spec: ethereum2v1alpha1.ValidatorSpec{
			Client:          ethereum2v1alpha1.NimbusClient,
			Network:         "mainnet",
			BeaconEndpoints: []string{"http://nimbus-beacon-node"},
			Graffiti:        "Validated by Kotal",
			Keystores: []ethereum2v1alpha1.Keystore{
				{
					SecretName: "my-validator",
				},
			},
			FeeRecipient: "0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
			Logging:      sharedAPI.FatalLogs,
		},
	}

	validator.Default()
	client, _ := NewClient(validator)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("nimbus_validator_client"))
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(NimbusHomeDir))
	})

	It("Should generate correct client arguments", func() {

		args := client.Args()

		Expect(args).To(ContainElements([]string{
			NimbusNonInteractive,
			argWithVal(NimbusLogging, string(validator.Spec.Logging)),
			argWithVal(NimbusDataDir, shared.PathData(client.HomeDir())),
			argWithVal(NimbusBeaconNodes, "http://nimbus-beacon-node"),
			argWithVal(NimbusGraffiti, "Validated by Kotal"),
			argWithVal(NimbusValidatorsDir, fmt.Sprintf("%s/kotal-validators/validator-keys", shared.PathData(client.HomeDir()))),
			argWithVal(NimbusSecretsDir, fmt.Sprintf("%s/kotal-validators/validator-secrets", shared.PathData(client.HomeDir()))),
			argWithVal(NimbusFeeRecipient, "0xd8da6bf26964af9d7eed9e03e53415d37aa96045"),
		}))

	})

})

'''
'''--- clients/ethereum2/prysm_beacon_node.go ---
package ethereum2

import (
	"fmt"
	"strings"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// PrysmBeaconNode is Prysmatic Labs Ethereum 2.0 client
// https://github.com/prysmaticlabs/prysm
type PrysmBeaconNode struct {
	node *ethereum2v1alpha1.BeaconNode
}

// HomeDir returns container home directory
func (t *PrysmBeaconNode) HomeDir() string {
	return PrysmHomeDir
}

// Command returns environment variables for running the client
func (t *PrysmBeaconNode) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client
func (t *PrysmBeaconNode) Args() (args []string) {

	node := t.node

	args = append(args, PrysmAcceptTermsOfUse)

	args = append(args, PrysmDataDir, shared.PathData(t.HomeDir()))

	args = append(args, PrysmLogging, string(t.node.Spec.Logging))

	args = append(args, PrysmExecutionEngineEndpoint, node.Spec.ExecutionEngineEndpoint)

	args = append(args, PrysmFeeRecipient, string(node.Spec.FeeRecipient))

	jwtSecretPath := fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(t.HomeDir()))
	args = append(args, PrysmJwtSecretFile, jwtSecretPath)

	args = append(args, fmt.Sprintf("--%s", node.Spec.Network))

	if node.Spec.CheckpointSyncURL != "" {
		args = append(args, PrysmCheckpointSyncUrl, node.Spec.CheckpointSyncURL)
		args = append(args, PrysmGenesisBeaconApiUrl, node.Spec.CheckpointSyncURL)
	}

	if node.Spec.RPCPort != 0 {
		args = append(args, PrysmRPCPort, fmt.Sprintf("%d", node.Spec.RPCPort))
	}

	// RPC is always on in prysm
	args = append(args, PrysmRPCHost, shared.Host(true))

	if node.Spec.GRPC {
		args = append(args, PrysmGRPCGatewayCorsDomains, strings.Join(node.Spec.CORSDomains, ","))
		args = append(args, PrysmGRPCPort, fmt.Sprintf("%d", node.Spec.GRPCPort))
		args = append(args, PrysmGRPCHost, shared.Host(node.Spec.GRPC))
	} else {
		args = append(args, PrysmDisableGRPC)
	}

	if node.Spec.CertSecretName != "" {
		args = append(args, PrysmTLSCert, fmt.Sprintf("%s/tls.crt", shared.PathSecrets(t.HomeDir())))
		args = append(args, PrysmTLSKey, fmt.Sprintf("%s/tls.key", shared.PathSecrets(t.HomeDir())))
	}

	args = append(args, PrysmP2PTCPPort, fmt.Sprintf("%d", node.Spec.P2PPort))
	args = append(args, PrysmP2PUDPPort, fmt.Sprintf("%d", node.Spec.P2PPort))

	return
}

// Command returns command for running the client
func (t *PrysmBeaconNode) Command() (command []string) {
	command = []string{"beacon-chain"}
	return
}

'''
'''--- clients/ethereum2/prysm_beacon_node_test.go ---
package ethereum2

import (
	"fmt"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Prysm beacon node", func() {

	node := ethereum2v1alpha1.BeaconNode{
		Spec: ethereum2v1alpha1.BeaconNodeSpec{
			Client:  ethereum2v1alpha1.PrysmClient,
			Network: "mainnet",
		},
	}
	client, _ := NewClient(&node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("beacon-chain"))
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(PrysmHomeDir))
	})

	cases := []struct {
		title  string
		node   *ethereum2v1alpha1.BeaconNode
		result []string
	}{
		{
			title: "beacon node syncing mainnet",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:  ethereum2v1alpha1.PrysmClient,
					Network: "mainnet",
					RPC:     true,
					Logging: sharedAPI.WarnLogs,
				},
			},
			result: []string{
				PrysmAcceptTermsOfUse,
				PrysmDataDir,
				"--mainnet",
				PrysmLogging,
				string(sharedAPI.WarnLogs),
			},
		},
		{
			title: "beacon node syncing mainnet with checkpoint sync",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.PrysmClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					FeeRecipient:            "0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
					RPC:                     true,
					CheckpointSyncURL:       "https://kotal.cloud/eth2/beacon/checkpoint",
				},
			},
			result: []string{
				PrysmAcceptTermsOfUse,
				PrysmDataDir,
				"--mainnet",
				PrysmExecutionEngineEndpoint,
				"https://localhost:8551",
				PrysmJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				PrysmFeeRecipient,
				"0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
				PrysmCheckpointSyncUrl,
				"https://kotal.cloud/eth2/beacon/checkpoint",
				PrysmGenesisBeaconApiUrl,
				"https://kotal.cloud/eth2/beacon/checkpoint",
			},
		},
		{
			title: "beacon node syncing mainnet with rpc port",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.PrysmClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					RPC:                     true,
					RPCPort:                 9976,
				},
			},
			result: []string{
				PrysmAcceptTermsOfUse,
				PrysmDataDir,
				"--mainnet",
				PrysmExecutionEngineEndpoint,
				"https://localhost:8551",
				PrysmJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				PrysmRPCPort,
				"9976",
			},
		},
		{
			title: "beacon node syncing mainnet with rpc port and host",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.PrysmClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					RPC:                     true,
					RPCPort:                 9976,
				},
			},
			result: []string{
				PrysmAcceptTermsOfUse,
				PrysmDataDir,
				"--mainnet",
				PrysmExecutionEngineEndpoint,
				"https://localhost:8551",
				PrysmJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				PrysmRPCPort,
				"9976",
				PrysmRPCHost,
				"0.0.0.0",
			},
		},
		{
			title: "beacon node syncing mainnet with grpc disabled",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.PrysmClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
				},
			},
			result: []string{
				PrysmAcceptTermsOfUse,
				PrysmDataDir,
				"--mainnet",
				PrysmExecutionEngineEndpoint,
				"https://localhost:8551",
				PrysmJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				PrysmDisableGRPC,
			},
		},
		{
			title: "beacon node syncing mainnet with certificate and grpc with port",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.PrysmClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					GRPC:                    true,
					GRPCPort:                4445,
					CertSecretName:          "my-certificate",
				},
			},
			result: []string{
				PrysmAcceptTermsOfUse,
				PrysmDataDir,
				"--mainnet",
				PrysmExecutionEngineEndpoint,
				"https://localhost:8551",
				PrysmJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				PrysmGRPCPort,
				"4445",
				PrysmGRPCGatewayCorsDomains,
				"*",
				PrysmTLSCert,
				fmt.Sprintf("%s/tls.crt", shared.PathSecrets(PrysmHomeDir)),
				PrysmTLSKey,
				fmt.Sprintf("%s/tls.key", shared.PathSecrets(PrysmHomeDir)),
			},
		},
		{
			title: "beacon node syncing mainnet with grpc with port and host",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.PrysmClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					GRPC:                    true,
					GRPCPort:                4445,
				},
			},
			result: []string{
				PrysmAcceptTermsOfUse,
				PrysmDataDir,
				"--mainnet",
				PrysmExecutionEngineEndpoint,
				"https://localhost:8551",
				PrysmJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				PrysmGRPCPort,
				"4445",
				PrysmGRPCHost,
				"0.0.0.0",
				PrysmGRPCGatewayCorsDomains,
				"*",
			},
		},
		{
			title: "beacon node syncing mainnet with p2p port and grpc with port and host",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.PrysmClient,
					P2PPort:                 7891,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					GRPC:                    true,
					GRPCPort:                4445,
				},
			},
			result: []string{
				PrysmAcceptTermsOfUse,
				PrysmDataDir,
				PrysmP2PTCPPort,
				"7891",
				PrysmP2PUDPPort,
				"7891",
				"--mainnet",
				PrysmExecutionEngineEndpoint,
				"https://localhost:8551",
				PrysmJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				PrysmGRPCPort,
				"4445",
				PrysmGRPCHost,
				"0.0.0.0",
				PrysmGRPCGatewayCorsDomains,
				"*",
			},
		},
	}

	for _, c := range cases {
		func() {
			cc := c
			It(fmt.Sprintf("Should create correct client arguments for %s", cc.title), func() {
				cc.node.Default()
				client, _ := NewClient(cc.node)
				args := client.Args()
				Expect(args).To(ContainElements(cc.result))
			})
		}()
	}

})

'''
'''--- clients/ethereum2/prysm_validator_client.go ---
package ethereum2

import (
	"fmt"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// PrysmValidatorClient is Prysmatic labs validator client
// https://github.com/prysmaticlabs/prysm
type PrysmValidatorClient struct {
	validator *ethereum2v1alpha1.Validator
}

// HomeDir returns container home directory
func (t *PrysmValidatorClient) HomeDir() string {
	return PrysmHomeDir
}

// Command returns environment variables for the client
func (t *PrysmValidatorClient) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client
func (t *PrysmValidatorClient) Args() (args []string) {

	validator := t.validator

	args = append(args, PrysmAcceptTermsOfUse)

	args = append(args, PrysmDataDir, shared.PathData(t.HomeDir()))

	args = append(args, PrysmLogging, string(t.validator.Spec.Logging))

	args = append(args, PrysmWalletDir, fmt.Sprintf("%s/prysm-wallet", shared.PathData(t.HomeDir())))

	args = append(args, PrysmWalletPasswordFile, fmt.Sprintf("%s/prysm-wallet/prysm-wallet-password.txt", shared.PathSecrets(t.HomeDir())))

	args = append(args, PrysmFeeRecipient, string(t.validator.Spec.FeeRecipient))

	args = append(args, fmt.Sprintf("--%s", validator.Spec.Network))

	if len(validator.Spec.BeaconEndpoints) != 0 {
		args = append(args, PrysmBeaconRPCProvider, validator.Spec.BeaconEndpoints[0])
	}

	if validator.Spec.Graffiti != "" {
		args = append(args, PrysmGraffiti, validator.Spec.Graffiti)
	}

	if validator.Spec.CertSecretName != "" {
		args = append(args, PrysmTLSCert, fmt.Sprintf("%s/cert/tls.crt", shared.PathSecrets(t.HomeDir())))
	}

	return args
}

// Command returns command for running the client
func (t *PrysmValidatorClient) Command() (command []string) {
	command = []string{"validator"}
	return
}

'''
'''--- clients/ethereum2/prysm_validator_client_test.go ---
package ethereum2

import (
	"fmt"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Prysm validator client", func() {

	validator := &ethereum2v1alpha1.Validator{
		Spec: ethereum2v1alpha1.ValidatorSpec{
			Client:          ethereum2v1alpha1.PrysmClient,
			Network:         "mainnet",
			BeaconEndpoints: []string{"http://localhost:8899"},
			Graffiti:        "Validated by Kotal",
			Keystores: []ethereum2v1alpha1.Keystore{
				{
					SecretName: "my-validator",
				},
			},
			WalletPasswordSecret: "wallet-password",
			FeeRecipient:         "0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
			CertSecretName:       "my-cert",
			Logging:              sharedAPI.ErrorLogs,
		},
	}

	validator.Default()
	client, _ := NewClient(validator)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("validator"))
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(PrysmHomeDir))
	})

	It("Should generate correct client arguments", func() {
		args := client.Args()

		Expect(args).To(ContainElements([]string{
			PrysmAcceptTermsOfUse,
			PrysmDataDir,
			shared.PathData(client.HomeDir()),
			"--mainnet",
			PrysmBeaconRPCProvider,
			"http://localhost:8899",
			PrysmGraffiti,
			"Validated by Kotal",
			PrysmWalletDir,
			fmt.Sprintf("%s/prysm-wallet", shared.PathData(client.HomeDir())),
			PrysmWalletPasswordFile,
			fmt.Sprintf("%s/prysm-wallet/prysm-wallet-password.txt", shared.PathSecrets(client.HomeDir())),
			PrysmLogging,
			string(sharedAPI.ErrorLogs),
			PrysmTLSCert,
			fmt.Sprintf("%s/cert/tls.crt", shared.PathSecrets(client.HomeDir())),
			PrysmFeeRecipient,
			"0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
		}))

	})

})

'''
'''--- clients/ethereum2/suite_test.go ---
package ethereum2

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestEthereum2Client(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Ethereum 2.0 Clients Suite")
}

'''
'''--- clients/ethereum2/teku_beacon_node.go ---
package ethereum2

import (
	"fmt"
	"strings"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// TekuBeaconNode is ConsenSys Pegasys Ethereum 2.0 client
// https://github.com/Consensys/teku/
type TekuBeaconNode struct {
	node *ethereum2v1alpha1.BeaconNode
}

// HomeDir returns container home directory
func (t *TekuBeaconNode) HomeDir() string {
	return TekuHomeDir
}

// Args returns command line arguments required for client
func (t *TekuBeaconNode) Args() (args []string) {

	node := t.node

	args = append(args, TekuDataPath, shared.PathData(t.HomeDir()))

	args = append(args, TekuNetwork, node.Spec.Network)

	args = append(args, TekuLogging, strings.ToUpper(string(node.Spec.Logging)))

	args = append(args, TekuExecutionEngineEndpoint, node.Spec.ExecutionEngineEndpoint)

	args = append(args, TekuFeeRecipient, string(node.Spec.FeeRecipient))

	jwtSecretPath := fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(t.HomeDir()))
	args = append(args, TekuJwtSecretFile, jwtSecretPath)

	if node.Spec.REST {
		args = append(args, TekuRestEnabled)
		args = append(args, TekuRESTAPICorsOrigins, strings.Join(node.Spec.CORSDomains, ","))
		args = append(args, TekuRESTAPIHostAllowlist, strings.Join(node.Spec.Hosts, ","))
		args = append(args, TekuRestPort, fmt.Sprintf("%d", node.Spec.RESTPort))
		args = append(args, TekuRestHost, shared.Host(node.Spec.REST))
	}

	if node.Spec.CheckpointSyncURL != "" {
		args = append(args, TekuInitialState, node.Spec.CheckpointSyncURL)
	}

	args = append(args, TekuP2PPort, fmt.Sprintf("%d", node.Spec.P2PPort))

	return
}

// Command returns command for running the client
func (t *TekuBeaconNode) Command() (command []string) {
	return
}

// Command returns environment variables for running the client
func (t *TekuBeaconNode) Env() []corev1.EnvVar {
	return nil
}

'''
'''--- clients/ethereum2/teku_beacon_node_test.go ---
package ethereum2

import (
	"fmt"
	"strings"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Teku beacon node", func() {

	node := ethereum2v1alpha1.BeaconNode{
		Spec: ethereum2v1alpha1.BeaconNodeSpec{
			Client:  ethereum2v1alpha1.TekuClient,
			Network: "mainnet",
		},
	}
	client, _ := NewClient(&node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(BeNil())
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(TekuHomeDir))
	})

	cases := []struct {
		title  string
		node   *ethereum2v1alpha1.BeaconNode
		result []string
	}{
		{
			title: "beacon node syncing mainnet",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:  ethereum2v1alpha1.TekuClient,
					Network: "mainnet",
					Logging: sharedAPI.ErrorLogs,
				},
			},
			result: []string{
				TekuDataPath,
				TekuNetwork,
				"mainnet",
				TekuLogging,
				strings.ToUpper(string(sharedAPI.ErrorLogs)),
			},
		},
		{
			title: "beacon node syncing mainnet with checkpoint syncing",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.TekuClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					FeeRecipient:            "0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
					CheckpointSyncURL:       "https://kotal.cloud/eth2/beacon/checkpoint",
				},
			},
			result: []string{
				TekuDataPath,
				TekuNetwork,
				"mainnet",
				TekuExecutionEngineEndpoint,
				"https://localhost:8551",
				TekuJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				TekuFeeRecipient,
				"0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
				TekuInitialState,
				"https://kotal.cloud/eth2/beacon/checkpoint",
			},
		},
		{
			title: "beacon node syncing mainnet with http enabled",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.TekuClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
				},
			},
			result: []string{
				TekuDataPath,
				TekuNetwork,
				"mainnet",
				TekuExecutionEngineEndpoint,
				"https://localhost:8551",
				TekuJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				TekuRestEnabled,
				TekuRESTAPICorsOrigins,
				"*",
				TekuRESTAPIHostAllowlist,
				"*",
			},
		},
		{
			title: "beacon node syncing mainnet with http enabled with port",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.TekuClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
					RESTPort:                3333,
				},
			},
			result: []string{
				TekuDataPath,
				TekuNetwork,
				"mainnet",
				TekuExecutionEngineEndpoint,
				"https://localhost:8551",
				TekuJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				TekuRestEnabled,
				TekuRestPort,
				"3333",
				TekuRESTAPICorsOrigins,
				"*",
				TekuRESTAPIHostAllowlist,
				"*",
			},
		},
		{
			title: "beacon node syncing mainnet with http enabled with port and host",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.TekuClient,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
					RESTPort:                3333,
				},
			},
			result: []string{
				TekuDataPath,
				TekuNetwork,
				"mainnet",
				TekuExecutionEngineEndpoint,
				"https://localhost:8551",
				TekuJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				TekuRestEnabled,
				TekuRestPort,
				"3333",
				TekuRestHost,
				"0.0.0.0",
				TekuRESTAPICorsOrigins,
				"*",
				TekuRESTAPIHostAllowlist,
				"*",
			},
		},
		{
			title: "beacon node syncing mainnet with p2p port, http enabled with port and host",
			node: &ethereum2v1alpha1.BeaconNode{
				Spec: ethereum2v1alpha1.BeaconNodeSpec{
					Client:                  ethereum2v1alpha1.TekuClient,
					P2PPort:                 7891,
					Network:                 "mainnet",
					ExecutionEngineEndpoint: "https://localhost:8551",
					JWTSecretName:           "jwt-secret",
					REST:                    true,
					RESTPort:                3333,
				},
			},
			result: []string{
				TekuDataPath,
				TekuP2PPort,
				"7891",
				TekuNetwork,
				"mainnet",
				TekuExecutionEngineEndpoint,
				"https://localhost:8551",
				TekuJwtSecretFile,
				fmt.Sprintf("%s/jwt.secret", shared.PathSecrets(client.HomeDir())),
				TekuRestEnabled,
				TekuRestPort,
				"3333",
				TekuRestHost,
				"0.0.0.0",
				TekuRESTAPICorsOrigins,
				"*",
				TekuRESTAPIHostAllowlist,
				"*",
			},
		},
	}

	for _, c := range cases {
		func() {
			cc := c
			It(fmt.Sprintf("Should create correct client arguments for %s", cc.title), func() {
				cc.node.Default()
				client, _ := NewClient(cc.node)
				args := client.Args()
				Expect(args).To(ContainElements(cc.result))
			})
		}()
	}

})

'''
'''--- clients/ethereum2/teku_validator_client.go ---
package ethereum2

import (
	"fmt"
	"strings"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// TekuValidatorClient is Teku validator client
// https://github.com/Consensys/teku/
type TekuValidatorClient struct {
	validator *ethereum2v1alpha1.Validator
}

// HomeDir returns container home directory
func (t *TekuValidatorClient) HomeDir() string {
	return TekuHomeDir
}

// Command returns environment variables for running the client
func (t *TekuValidatorClient) Env() []corev1.EnvVar {
	return nil
}

// Args returns command line arguments required for client
func (t *TekuValidatorClient) Args() (args []string) {

	validator := t.validator

	args = append(args, TekuVC)

	args = append(args, TekuDataPath, shared.PathData(t.HomeDir()))

	args = append(args, TekuNetwork, "auto")

	args = append(args, TekuValidatorsKeystoreLockingEnabled, "false")

	args = append(args, TekuFeeRecipient, string(validator.Spec.FeeRecipient))

	if len(validator.Spec.BeaconEndpoints) != 0 {
		args = append(args, TekuBeaconNodeEndpoint, validator.Spec.BeaconEndpoints[0])
	}

	if validator.Spec.Graffiti != "" {
		args = append(args, TekuGraffiti, validator.Spec.Graffiti)
	}

	keyPass := []string{}
	for i, keystore := range validator.Spec.Keystores {
		path := fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(t.HomeDir()), keystore.SecretName)
		keyPass = append(keyPass, fmt.Sprintf("%s/keystore-%d.json:%s/password.txt", path, i, path))
	}

	args = append(args, TekuValidatorKeys, strings.Join(keyPass, ","))

	return args
}

// Command returns command for running the client
func (t *TekuValidatorClient) Command() (command []string) {
	return
}

'''
'''--- clients/ethereum2/teku_validator_client_test.go ---
package ethereum2

import (
	"fmt"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Teku Ethereum 2.0 validator client arguments", func() {

	validator := &ethereum2v1alpha1.Validator{
		Spec: ethereum2v1alpha1.ValidatorSpec{
			Client:          ethereum2v1alpha1.TekuClient,
			Network:         "mainnet",
			BeaconEndpoints: []string{"http://localhost:9988"},
			Graffiti:        "Validated by Kotal",
			FeeRecipient:    "0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
			Keystores: []ethereum2v1alpha1.Keystore{
				{
					SecretName: "my-validator",
				},
			},
		},
	}

	validator.Default()
	client, _ := NewClient(validator)

	It("Should get correct command", func() {
		Expect(client.Command()).To(BeNil())
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(TekuHomeDir))
	})

	It("Should generate correct client arguments", func() {
		args := client.Args()

		Expect(args).To(ContainElements([]string{
			"vc",
			TekuDataPath,
			shared.PathData(client.HomeDir()),
			TekuNetwork,
			"auto",
			TekuBeaconNodeEndpoint,
			"http://localhost:9988",
			TekuGraffiti,
			"Validated by Kotal",
			TekuValidatorKeys,
			fmt.Sprintf(
				"%s/validator-keys/my-validator/keystore-0.json:%s/validator-keys/my-validator/password.txt",
				shared.PathSecrets(client.HomeDir()),
				shared.PathSecrets(client.HomeDir()),
			),
			TekuFeeRecipient,
			"0xd8da6bf26964af9d7eed9e03e53415d37aa96045",
		}))

	})

})

'''
'''--- clients/ethereum2/types.go ---
package ethereum2

// Client home directories
const (
	// TekuHomeDir is teku home directory
	TekuHomeDir = "/opt/teku"
	// PrysmHomeDir is prysm home directory
	PrysmHomeDir = "/home/prysm"
	// NimbusHomeDir is nimbus home directory
	NimbusHomeDir = "/home/nimbus"
	// LighthouseHomeDir is lighthouse home directory
	LighthouseHomeDir = "/home/lighthouse"
)

// Teku client arguments
const (
	// TekuNetwork is the argument used for selecting network
	TekuNetwork = "--network"
	// TekuExecutionEngineEndpoint is the argument used to set execution engine endpoint
	TekuExecutionEngineEndpoint = "--ee-endpoint"
	// TekuFeeRecipient is the argument used to set default fee recipient
	TekuFeeRecipient = "--validators-proposer-default-fee-recipient"
	// TekuJwtSecretFile is the argument used to locate jwt secret file
	TekuJwtSecretFile = "--ee-jwt-secret-file"
	// TekuDataPath is the argument used for data directory
	TekuDataPath = "--data-path"
	// TekuRestEnabled is the argument used to enable Beacon REST API
	TekuRestEnabled = "--rest-api-enabled"
	// TekuRestPort is the argument used for Beacon REST API server port
	TekuRestPort = "--rest-api-port"
	// TekuRestHost is the argument used for Beacon REST API server host
	TekuRestHost = "--rest-api-interface"
	// TekuP2PPort is the argument used p2p and discovery port
	TekuP2PPort = "--p2p-port"
	// TekuRESTAPICorsOrigins is the argument used to whitelist domains for cross domain requests
	TekuRESTAPICorsOrigins = "--rest-api-cors-origins"
	// TekuRESTAPIHostAllowlist is the argument used to whitelist hosts for API access
	TekuRESTAPIHostAllowlist = "--rest-api-host-allowlist"
	// TekuLogging is the argument used to set logging verbosity level
	TekuLogging = "--logging"
	// TekuInitialState is the argument used for checkpoint sync
	TekuInitialState = "--initial-state"
	// TekuVC is the argument used to run validator client
	TekuVC = "vc"
	// TekuBeaconNodeEndpoint is the argument used for beacon node api endpoint
	TekuBeaconNodeEndpoint = "--beacon-node-api-endpoint"
	// TekuGraffiti is the argument used for text include in proposed blocks
	TekuGraffiti = "--validators-graffiti"
	// TekuValidatorKeys is the argument used for Validator keys and secrets
	TekuValidatorKeys = "--validator-keys"
	// TekuValidatorsKeystoreLockingEnabled is the argument used to enable keystore locking files
	TekuValidatorsKeystoreLockingEnabled = "--validators-keystore-locking-enabled"
)

// Prysm client arguments
const (
	// PrysmDataDir is the argument used for data directory
	PrysmDataDir = "--datadir"
	// PrysmExecutionEngineEndpoint is the argument used to set execution engine endpoint
	PrysmExecutionEngineEndpoint = "--execution-endpoint"
	// PrysmFeeRecipient is the argument used to set fee recipient
	PrysmFeeRecipient = "--suggested-fee-recipient"
	// PrysmJwtSecretFile is the argument used to locate jwt secret file
	PrysmJwtSecretFile = "--jwt-secret"
	// PrysmCheckpointSyncUrl is the argument used to set checkpoint sync beacon node rest api endpoint
	PrysmCheckpointSyncUrl = "--checkpoint-sync-url"
	// PrysmGenesisBeaconApiUrl is the argument used to set genesis beacon node api url
	PrysmGenesisBeaconApiUrl = "--genesis-beacon-api-url"
	// PrysmAcceptTermsOfUse is the argument used for accepting terms of use
	PrysmAcceptTermsOfUse = "--accept-terms-of-use"
	// PrysmRPCPort is the argument used for RPC server port
	PrysmRPCPort = "--rpc-port"
	// PrysmRPCHost is the argument used for host on which RPC server should listen
	PrysmRPCHost = "--rpc-host"
	// PrysmDisableGRPC is the argument used to disable GRPC gateway server
	PrysmDisableGRPC = "--disable-grpc-gateway"
	// PrysmGRPCPort is the argument used for GRPC gateway server port
	PrysmGRPCPort = "--grpc-gateway-port"
	// PrysmGRPCHost is the argument used for GRPC gateway server host
	PrysmGRPCHost = "--grpc-gateway-host"
	// PrysmP2PTCPPort is the argument used p2p tcp port
	PrysmP2PTCPPort = "--p2p-tcp-port"
	// PrysmP2PUDPPort is the argument used p2p discovery udp port
	PrysmP2PUDPPort = "--p2p-udp-port"
	// PrysmGRPCGatewayCorsDomains is the argument used to whitelist domains for cross domain requests
	PrysmGRPCGatewayCorsDomains = "--grpc-gateway-corsdomain"
	// PrysmLogging is the argument used to set logging verbosity level
	PrysmLogging = "--verbosity"

	// PrysmTLSCert is the argument used to locate tls certificate
	PrysmTLSCert = "--tls-cert"
	// PrysmTLSKey is the argument used to locate tls key
	PrysmTLSKey = "--tls-key"

	// PrysmBeaconRPCProvider is the argument used for beacon node rpc endpoint
	PrysmBeaconRPCProvider = "--beacon-rpc-provider"
	// PrysmGraffiti is the argument used to include in proposed blocks
	PrysmGraffiti = "--graffiti"
	// PrysmKeysDir is the argument used to locate keystores to be imported are stored
	PrysmKeysDir = "--keys-dir"
	// PrysmWalletDir is the argument used to locate wallet directory
	PrysmWalletDir = "--wallet-dir"
	// PrysmAccountPasswordFile is the argument used to locate account password file
	PrysmAccountPasswordFile = "--account-password-file"
	// PrysmWalletPasswordFile is the argument used to locate wallet password file
	PrysmWalletPasswordFile = "--wallet-password-file"
)

// Lighthouse client arguments
const (
	// LighthouseDataDir is the argument used for data directory
	LighthouseDataDir = "--datadir"
	// LighthouseNetwork is the argument used for selecting network
	LighthouseNetwork = "--network"
	// LighthouseCheckpointSyncUrl is the argument used for checkpoint sync
	LighthouseCheckpointSyncUrl = "--checkpoint-sync-url"
	// LighthouseHTTP is the argument used to enable Beacon REST API
	LighthouseHTTP = "--http"
	// LighthouseAllowOrigins is the argument used to whitelist domains for cross domain requests
	LighthouseAllowOrigins = "--http-allow-origin"
	// LighthouseHTTPPort is the argument used for Beacon REST API server port
	LighthouseHTTPPort = "--http-port"
	// LighthouseHTTPAddress is the argument used for Beacon REST API server host
	LighthouseHTTPAddress = "--http-address"
	// LighthouseExecutionEngineEndpoint is the argument used for Execution engine endpoint
	LighthouseExecutionEngineEndpoint = "--execution-endpoint"
	// LighthouseJwtSecretFile is the argument used to locate jwt secret file
	LighthouseJwtSecretFile = "--execution-jwt"
	// LighthouseFeeRecipient is the argument used to set fee recipient
	LighthouseFeeRecipient = "--suggested-fee-recipient"
	// LighthousePort is the argument used for p2p tcp port
	LighthousePort = "--port"
	// LighthouseDiscoveryPort is the argument used for discovery udp port
	LighthouseDiscoveryPort = "--discovery-port"
	// LighthouseDebugLevel is the argument used to set logging verbosity level
	LighthouseDebugLevel = "--debug-level"

	// LighthouseBeaconNodeEndpoints is the argument used for beacon node endpoint
	LighthouseBeaconNodeEndpoints = "--beacon-nodes"
	// LighthouseGraffiti is the argument used to include in proposed blocks
	LighthouseGraffiti = "--graffiti"
	// LighthouseDisableAutoDiscover is the argument used to disable auto validator keystores discovery
	LighthouseDisableAutoDiscover = "--disable-auto-discover"
	// LighthouseInitSlashingProtection is the argument used to init slashing protection
	LighthouseInitSlashingProtection = "--init-slashing-protection"
	// LighthouseReusePassword is the argument used to reuse password during keystore import
	LighthouseReusePassword = "--reuse-password"
	// LighthouseKeystore is the argument used to locate keystore file
	LighthouseKeystore = "--keystore"
	// LighthousePasswordFile is the argument used to locate password file
	LighthousePasswordFile = "--password-file"
)

// Nimbus client arguments
const (
	// NimbusDataDir is the argument used for data directory
	NimbusDataDir = "--data-dir"
	// NimbusNonInteractive is the argument used for non interactive mode
	NimbusNonInteractive = "--non-interactive"
	// NimbusNetwork is the argument used for selecting network
	NimbusNetwork = "--network"
	// NimbusExecutionEngineEndpoint is the argument used for Execution engine endpoint
	NimbusExecutionEngineEndpoint = "--web3-url"
	// NimbusJwtSecretFile is the argument used to locate jwt secret file
	NimbusJwtSecretFile = "--jwt-secret"
	// NimbusFeeRecipient is the argument used to set fee recipient
	NimbusFeeRecipient = "--suggested-fee-recipient"
	// NimbusTCPPort is the argument used for p2p tcp port
	NimbusTCPPort = "--tcp-port"
	// NimbusUDPPort is the argument used for discovery udp port
	NimbusUDPPort = "--udp-port"
	// NimbusLogging is the argument used to set logging verbosity level
	NimbusLogging = "--log-level"
	// NimbusREST is the argument used to enable REST server
	NimbusREST = "--rest"
	// NimbusRESTPort is the argument used to set REST server port
	NimbusRESTPort = "--rest-port"
	// NimbusRESTAddress is the argument used to set REST server listening address
	NimbusRESTAddress = "--rest-address"
	// NimbusRESTAllowOrigin is the argument used to limit access to the REST API
	NimbusRESTAllowOrigin = "--rest-allow-origin"
	// NimbusGraffiti is the argument used to include in proposed blocks
	NimbusGraffiti = "--graffiti"
	// NimbusValidatorsDir is the argument used to locate validator keystores directory
	NimbusValidatorsDir = "--validators-dir"
	// NimbusSecretsDir is the argument used to locate validator keystores secrets directory
	NimbusSecretsDir = "--secrets-dir"
	// NimbusBeaconNodes is the argument used to set one or more beacon node HTTP REST APIs
	NimbusBeaconNodes = "--beacon-node"
)

'''
'''--- clients/filecoin/client.go ---
package filecoin

import (
	filecoinv1alpha1 "github.com/kotalco/kotal/apis/filecoin/v1alpha1"
	clients "github.com/kotalco/kotal/clients"
)

func NewClient(node *filecoinv1alpha1.Node) clients.Interface {
	return &LotusClient{node}
}

'''
'''--- clients/filecoin/lotus_client.go ---
package filecoin

import (
	filecoinv1alpha1 "github.com/kotalco/kotal/apis/filecoin/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// LotusClient is lotus filecoin client
// https://github.com/filecoin-project/lotus
type LotusClient struct {
	node *filecoinv1alpha1.Node
}

// Images
const (
	//  LotusHomeDir is lotus client image home dir
	LotusHomeDir = "/home/fc"
)

// Command is lotus image command
func (c *LotusClient) Command() (command []string) {
	command = append(command, "lotus", "daemon")
	return
}

// Command returns environment variables for the client
func (c *LotusClient) Env() []corev1.EnvVar {
	return []corev1.EnvVar{
		{
			Name:  EnvLotusPath,
			Value: shared.PathData(c.HomeDir()),
		},
		{
			Name:  EnvLogLevel,
			Value: string(c.node.Spec.Logging),
		},
	}
}

// Args returns lotus client args from node spec
func (c *LotusClient) Args() []string {
	return nil
}

// HomeDir returns lotus image home directory
func (c *LotusClient) HomeDir() string {
	return LotusHomeDir
}

'''
'''--- clients/filecoin/lotus_client_test.go ---
package filecoin

import (
	filecoinv1alpha1 "github.com/kotalco/kotal/apis/filecoin/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Lotus Filecoin Client", func() {
	node := filecoinv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "calibration-node",
			Namespace: "filecoin",
		},
		Spec: filecoinv1alpha1.NodeSpec{
			Network: filecoinv1alpha1.CalibrationNetwork,
		},
	}

	client := NewClient(&node)

	It("Should get correct args", func() {
		Expect(client.Args()).To(BeNil())
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(ContainElements(
			corev1.EnvVar{
				Name:  EnvLotusPath,
				Value: shared.PathData(client.HomeDir()),
			},
			corev1.EnvVar{
				Name:  EnvLogLevel,
				Value: string(node.Spec.Logging),
			},
		))
	})

	It("Should get correct command", func() {
		Expect(client.Command()).To(ContainElements(
			"lotus",
			"daemon",
		))
	})

	It("Should get image home directory", func() {
		Expect(client.HomeDir()).To(Equal(LotusHomeDir))
	})
})

'''
'''--- clients/filecoin/suite_test.go ---
package filecoin

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestFilecoinClient(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Filecoin Clients Suite")
}

'''
'''--- clients/filecoin/types.go ---
package filecoin

const (
	// EnvLotusPath is the environment variable used for lotus data directory
	EnvLotusPath = "LOTUS_PATH"
	// EnvLogLevel is the environment variable used for log verbosity level
	EnvLogLevel = "GOLOG_LOG_LEVEL"
)

'''
'''--- clients/graph/client.go ---
package graph

import (
	graphv1alpha1 "github.com/kotalco/kotal/apis/graph/v1alpha1"
	clients "github.com/kotalco/kotal/clients"
)

// NewClient creates new graph node client
func NewClient(node *graphv1alpha1.Node) clients.Interface {
	return &GraphNodeClient{node}
}

'''
'''--- clients/graph/graph_node_client.go ---
package graph

import (
	graphv1alpha1 "github.com/kotalco/kotal/apis/graph/v1alpha1"
	corev1 "k8s.io/api/core/v1"
)

// GraphNodeClient is graph node client
// https://github.com/graphprotocol/graph-node
type GraphNodeClient struct {
	node *graphv1alpha1.Node
}

// Images
const (
	// GraphNodeHomeDir is Graph node image home dir
	// TODO: update home dir after creating a new docker image
	GraphNodeHomeDir = "/root"
)

// Command returns environment variables for the client
func (c *GraphNodeClient) Env() (env []corev1.EnvVar) {
	return
}

// Command is Graph node client entrypoint
func (c *GraphNodeClient) Command() (command []string) {

	command = append(command, GraphNodeCommand)

	return
}

// Args returns Graph node client args
func (c *GraphNodeClient) Args() (args []string) {
	_ = c.node

	return
}

// HomeDir is the home directory of Graph node client image
func (c *GraphNodeClient) HomeDir() string {
	return GraphNodeHomeDir
}

'''
'''--- clients/graph/graph_node_client_test.go ---
package graph

import (
	graphv1alpha1 "github.com/kotalco/kotal/apis/graph/v1alpha1"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Graph node client", func() {

	node := &graphv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "graph-node",
			Namespace: "default",
		},
		Spec: graphv1alpha1.NodeSpec{},
	}

	// TODO: default node

	client := NewClient(node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(Equal(
			[]string{
				GraphNodeCommand,
			},
		))
	})

	It("Should get correct home directory", func() {
		Expect(client.HomeDir()).To(Equal(GraphNodeHomeDir))
	})

	It("Should generate correct client arguments", func() {
		Expect(client.Args()).To(ContainElements(
			[]string{},
		))
	})

})

'''
'''--- clients/graph/suite_test.go ---
package graph

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestGraphNodeClient(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Graph Node Client Suite")
}

'''
'''--- clients/graph/types.go ---
package graph

const (
	// GraphNodeCommand is graph node exec command
	GraphNodeCommand = "graph-node"
)

'''
'''--- clients/interface.go ---
package clients

import corev1 "k8s.io/api/core/v1"

// Interface is client interface
type Interface interface {
	Args() []string
	Command() []string
	Env() []corev1.EnvVar
	HomeDir() string
}

'''
'''--- clients/ipfs/client.go ---
package ipfs

import (
	"fmt"

	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	"github.com/kotalco/kotal/clients"
	"k8s.io/apimachinery/pkg/runtime"
)

// IPFSClient is IPFS peer client
type IPFSClient interface {
	clients.Interface
}

// NewClient creates a new client for ipfs peer or cluster peer
func NewClient(obj runtime.Object) (IPFSClient, error) {
	switch peer := obj.(type) {
	case *ipfsv1alpha1.Peer:
		return &KuboClient{peer}, nil
	case *ipfsv1alpha1.ClusterPeer:
		return &GoIPFSClusterClient{peer}, nil
	}
	return nil, fmt.Errorf("no client support for %s", obj)
}

'''
'''--- clients/ipfs/go_ipfs_cluster_client.go ---
package ipfs

import (
	"strings"

	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// GoIPFSClusterClient is ipfs cluster service client
// https://github.com/ipfs/ipfs-cluster
type GoIPFSClusterClient struct {
	peer *ipfsv1alpha1.ClusterPeer
}

const (
	//  GoIPFSClusterHomeDir is go ipfs cluster image home dir
	GoIPFSClusterHomeDir = "/home/ipfs-cluster"
)

// Command returns go ipfs cluster entrypoint
func (c *GoIPFSClusterClient) Command() []string {
	return []string{"ipfs-cluster-service"}
}

// Command returns environment variables for the client
func (c *GoIPFSClusterClient) Env() []corev1.EnvVar {
	return []corev1.EnvVar{
		{
			Name:  EnvIPFSClusterPath,
			Value: shared.PathData(c.HomeDir()),
		},
		{
			Name:  EnvIPFSClusterPeerName,
			Value: c.peer.Name,
		},
		{
			Name:  EnvIPFSLogging,
			Value: string(c.peer.Spec.Logging),
		},
	}
}

// Arg returns go ipfs cluster arguments
func (c *GoIPFSClusterClient) Args() (args []string) {
	args = append(args, GoIPFSClusterDaemonArg)

	if len(c.peer.Spec.BootstrapPeers) != 0 {
		args = append(args, GoIPFSClusterBootstrapArg, strings.Join(c.peer.Spec.BootstrapPeers, ","))
	}

	return
}

// HomeDir returns go ipfs cluster image home directory
func (c *GoIPFSClusterClient) HomeDir() string {
	return GoIPFSClusterHomeDir
}

'''
'''--- clients/ipfs/go_ipfs_cluster_client_test.go ---
package ipfs

import (
	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
)

var _ = Describe("Go IPFS Cluster Client", func() {
	peer := &ipfsv1alpha1.ClusterPeer{
		Spec: ipfsv1alpha1.ClusterPeerSpec{
			Consensus:    ipfsv1alpha1.Raft,
			PeerEndpoint: "/dns4/bare-peer/tcp/5001",
			BootstrapPeers: []string{
				"/ip4/95.111.253.236/tcp/4001/p2p/Qmd3FERyCvxvkC8su1DYhjybRaLueHveKysUVPxWAqR4U7",
			},
			ClusterSecretName: "cluster-secret",
		},
	}

	client, _ := NewClient(peer)

	It("Should get correct env", func() {
		Expect(client.Env()).To(Equal(
			[]corev1.EnvVar{
				{
					Name:  EnvIPFSClusterPath,
					Value: shared.PathData(client.HomeDir()),
				},
				{
					Name:  EnvIPFSClusterPeerName,
					Value: peer.Name,
				},
				{
					Name:  EnvIPFSLogging,
					Value: string(peer.Spec.Logging),
				},
			},
		))
	})

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("ipfs-cluster-service"))
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(GoIPFSClusterHomeDir))
	})

	It("Should get correct args", func() {
		Expect(client.Args()).To(ContainElements(
			GoIPFSDaemonArg,
			GoIPFSClusterBootstrapArg,
			"/ip4/95.111.253.236/tcp/4001/p2p/Qmd3FERyCvxvkC8su1DYhjybRaLueHveKysUVPxWAqR4U7",
		))
	})

})

'''
'''--- clients/ipfs/kubo_client.go ---
package ipfs

import (
	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// KuboClient is an ipfs implementation in golang
// https://github.com/ipfs/kubo
type KuboClient struct {
	peer *ipfsv1alpha1.Peer
}

// Images
const (
	//  GoIPFSHomeDir is go ipfs image home dir
	GoIPFSHomeDir = "/home/ipfs"
)

// Command is kubo entrypoint
func (c *KuboClient) Command() []string {
	return []string{"ipfs"}
}

// Command returns environment variables for the client
func (c *KuboClient) Env() []corev1.EnvVar {
	return []corev1.EnvVar{
		{
			Name:  EnvIPFSPath,
			Value: shared.PathData(c.HomeDir()),
		},
		{
			Name:  EnvIPFSLogging,
			Value: string(c.peer.Spec.Logging),
		},
	}
}

// Args returns kubo args
func (c *KuboClient) Args() (args []string) {

	peer := c.peer

	args = append(args, GoIPFSDaemonArg)

	args = append(args, GoIPFSRoutingArg, string(peer.Spec.Routing))

	return
}

func (c *KuboClient) HomeDir() string {
	return GoIPFSHomeDir
}

'''
'''--- clients/ipfs/kubo_client_test.go ---
package ipfs

import (
	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
)

var _ = Describe("Go IPFS Client", func() {
	peer := &ipfsv1alpha1.Peer{
		Spec: ipfsv1alpha1.PeerSpec{
			Routing: ipfsv1alpha1.DHTClientRouting,
		},
	}

	client, _ := NewClient(peer)

	It("Should get correct command", func() {
		Expect(client.Command()).To(ConsistOf("ipfs"))
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(Equal(
			[]corev1.EnvVar{
				{
					Name:  EnvIPFSPath,
					Value: shared.PathData(client.HomeDir()),
				},
				{
					Name:  EnvIPFSLogging,
					Value: string(peer.Spec.Logging),
				},
			},
		))
	})

	It("Should get correct home dir", func() {
		Expect(client.HomeDir()).To(Equal(GoIPFSHomeDir))
	})

	It("Should get correct args", func() {
		Expect(client.Args()).To(ContainElements(
			GoIPFSDaemonArg,
			GoIPFSRoutingArg,
			string(ipfsv1alpha1.DHTClientRouting),
		))
	})

})

'''
'''--- clients/ipfs/suite_test.go ---
package ipfs

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestIPFSClients(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "IPFS Clients Suite")
}

'''
'''--- clients/ipfs/types.go ---
package ipfs

const (
	// EnvIPFSPath is the environment variable used for kubo path
	EnvIPFSPath = "IPFS_PATH"
	// EnvIPFSLogging is the environment variable used for logging verbosity level
	EnvIPFSLogging = "IPFS_LOGGING"
	// EnvSecretsPath is the environment variable used for secrets path
	EnvSecretsPath = "SECRETS_PATH"
	// EnvIPFSAPIPort is the environment variable used for api port
	EnvIPFSAPIPort = "IPFS_API_PORT"
	// EnvIPFSAPIHost is the environment variable used for api host
	EnvIPFSAPIHost = "IPFS_API_HOST"
	// EnvIPFSGatewayPort is the environment variable used for local gateway port
	EnvIPFSGatewayPort = "IPFS_GATEWAY_PORT"
	// EnvIPFSGatewayHost is the environment variable used for local gateway host
	EnvIPFSGatewayHost = "IPFS_GATEWAY_HOST"
	// EnvIPFSInitProfiles is the environment variables used for initial profiles
	EnvIPFSInitProfiles = "IPFS_INIT_PROFILES"
	// EnvIPFSProfiles is the environment variables used for configuration profiles after peer intialization
	EnvIPFSProfiles = "IPFS_PROFILES"

	// EnvIPFSClusterPath is the environment variables used for ipfs-cluster-service path
	EnvIPFSClusterPath = "IPFS_CLUSTER_PATH"
	// EnvIPFSClusterConsensus is the environment variables used for ipfs cluster consnsus
	EnvIPFSClusterConsensus = "IPFS_CLUSTER_CONSENSUS"
	// EnvIPFSClusterPeerEndpoint is the environment variables used for ipfs cluster peer API endpoint
	EnvIPFSClusterPeerEndpoint = "CLUSTER_IPFSHTTP_NODEMULTIADDRESS"
	// EnvIPFSClusterPeerName is the environment variables used for ipfs cluster peer name
	EnvIPFSClusterPeerName = "CLUSTER_PEERNAME"
	// EnvIPFSClusterSecret is the environment variables used for ipfs cluster secret
	EnvIPFSClusterSecret = "CLUSTER_SECRET"
	// EnvIPFSClusterTrustedPeers is the environment variables used for ipfs cluster trusted peers
	EnvIPFSClusterTrustedPeers = "CLUSTER_CRDT_TRUSTEDPEERS"
	// EnvIPFSClusterId is the environment variables used for ipfs cluster id
	EnvIPFSClusterId = "CLUSTER_ID"
	// EnvIPFSClusterPrivateKey is the environment variables used for ipfs cluster private key
	EnvIPFSClusterPrivateKey = "CLUSTER_PRIVATEKEY"
)

const (
	// GoIPFSDaemonArg is the argument used to run go ipfs daemon
	GoIPFSDaemonArg = "daemon"
	// GoIPFSRoutingArg is the argument used to set content routing mechanism
	GoIPFSRoutingArg = "--routing"

	// GoIPFSClusterDaemonArg is the argument used to run go ipfs cluster daemon
	GoIPFSClusterDaemonArg = "daemon"
	// GoIPFSClusterBootstrapArg is the argument used for go ipfs cluster bootstrap peers
	GoIPFSClusterBootstrapArg = "--bootstrap"
)

'''
'''--- clients/near/client.go ---
package near

import (
	nearv1alpha1 "github.com/kotalco/kotal/apis/near/v1alpha1"
	clients "github.com/kotalco/kotal/clients"
)

func NewClient(node *nearv1alpha1.Node) clients.Interface {
	return &NearClient{node}
}

'''
'''--- clients/near/near_client.go ---
package near

import (
	"fmt"
	"strings"

	nearv1alpha1 "github.com/kotalco/kotal/apis/near/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// NearClient is NEAR core client
// https://github.com/near/nearcore/
type NearClient struct {
	node *nearv1alpha1.Node
}

// Images
const (
	// NearHomeDir is go ipfs image home dir
	// TODO: update home dir after building docker image with non-root user and home dir
	NearHomeDir = "/home/near"
)

// Command returns environment variables for the client
func (c *NearClient) Env() []corev1.EnvVar {
	return nil
}

// Command is NEAR core client entrypoint
func (c *NearClient) Command() []string {
	return nil
}

// Args returns NEAR core client args
func (c *NearClient) Args() (args []string) {

	node := c.node

	args = append(args, "neard")
	args = append(args, NearArgHome, shared.PathData(c.HomeDir()))
	args = append(args, "run")

	args = append(args, NearArgNetworkAddress, fmt.Sprintf("%s:%d", shared.Host(true), node.Spec.P2PPort))

	if node.Spec.RPC {
		args = append(args, NearArgRPCAddress, fmt.Sprintf("%s:%d", shared.Host(node.Spec.RPC), node.Spec.RPCPort))
		args = append(args, NearArgPrometheusAddress, fmt.Sprintf("%s:%d", shared.Host(true), node.Spec.PrometheusPort))
	} else {
		args = append(args, NearArgDisableRPC)
	}

	if node.Spec.TelemetryURL != "" {
		args = append(args, NearArgTelemetryURL, node.Spec.TelemetryURL)
	}

	if node.Spec.Archive {
		args = append(args, NearArgArchive)
	}

	args = append(args, NearArgMinimumPeers, fmt.Sprintf("%d", node.Spec.MinPeers))

	if len(node.Spec.Bootnodes) != 0 {
		args = append(args, NearArgBootnodes, strings.Join(node.Spec.Bootnodes, ","))
	}

	return
}

// HomeDir is the home directory of NEAR core client image
func (c *NearClient) HomeDir() string {
	return NearHomeDir
}

'''
'''--- clients/near/near_client_test.go ---
package near

import (
	nearv1alpha1 "github.com/kotalco/kotal/apis/near/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("NEAR core client", func() {

	node := &nearv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "near-node",
			Namespace: "default",
		},
		// TODO: create test for rpc: false node
		Spec: nearv1alpha1.NodeSpec{
			Network:        "mainnet",
			MinPeers:       77,
			P2PPort:        3334,
			Archive:        true,
			RPC:            true,
			RPCPort:        7444,
			PrometheusPort: 9991,
			TelemetryURL:   "https://explorer.mainnet.near.org/api/nodes",
			Bootnodes: []string{
				"ed25519:86EtEy7epneKyrcJwSWP7zsisTkfDRH5CFVszt4qiQYw@35.195.32.249:24567",
				"ed25519:BFB78VTDBBfCY4jCP99zWxhXUcFAZqR22oSx2KEr8UM1@35.229.222.235:24567",
			},
		},
	}

	node.Default()
	client := NewClient(node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(BeNil())
	})

	It("Should get correct home directory", func() {
		Expect(client.HomeDir()).To(Equal(NearHomeDir))
	})

	It("Should generate correct client arguments", func() {
		Expect(client.Args()).To(ContainElements([]string{
			"neard",
			NearArgHome,
			shared.PathData(client.HomeDir()),
			"run",
			NearArgMinimumPeers,
			"77",
			NearArgNetworkAddress,
			"0.0.0.0:3334",
			NearArgArchive,
			NearArgRPCAddress,
			"0.0.0.0:7444",
			NearArgPrometheusAddress,
			"0.0.0.0:9991",
			NearArgBootnodes,
			"ed25519:86EtEy7epneKyrcJwSWP7zsisTkfDRH5CFVszt4qiQYw@35.195.32.249:24567,ed25519:BFB78VTDBBfCY4jCP99zWxhXUcFAZqR22oSx2KEr8UM1@35.229.222.235:24567",
			NearArgTelemetryURL,
			"https://explorer.mainnet.near.org/api/nodes",
		}))

	})

})

'''
'''--- clients/near/suite_test.go ---
package near

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestEthereum2Client(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "NEAR Core Client Suite")
}

'''
'''--- clients/near/types.go ---
package near

const (
	// NearArgHome is argument used to set home directory
	NearArgHome = "--home"
	// NearArgDisableRPC is argument used to disable JSON-RPC server
	NearArgDisableRPC = "--disable-rpc"
	// NearArgRPCAddress is argument used to set JSON-RPC address
	NearArgRPCAddress = "--rpc-addr"
	// NearArgPrometheusAddress is argument used to set prometheus exporter address
	NearArgPrometheusAddress = "--rpc-prometheus-addr"
	// NearArgBootnodes is argument used to set the boot nodes to bootstrap network from
	NearArgBootnodes = "--boot-nodes"
	// NearArgNetworkAddress is argument used to set network listening address
	NearArgNetworkAddress = "--network-addr"
	// NearArgMinimumPeers is argument used to set minimum number of peers required to start syncing/producing blocks
	NearArgMinimumPeers = "--min-peers"
	// NearArgTelemetryURL is argument used to set telemetry URL
	NearArgTelemetryURL = "--telemetry-url"
	// NearArgArchive is argument used to keeps old blocks in the storage
	NearArgArchive = "--archive"
)

'''
'''--- clients/polkadot/client.go ---
package polkadot

import (
	polkadotv1alpha1 "github.com/kotalco/kotal/apis/polkadot/v1alpha1"
	clients "github.com/kotalco/kotal/clients"
)

func NewClient(node *polkadotv1alpha1.Node) clients.Interface {
	return &PolkadotClient{node}
}

'''
'''--- clients/polkadot/polkadot_client.go ---
package polkadot

import (
	"fmt"
	"strings"

	polkadotv1alpha1 "github.com/kotalco/kotal/apis/polkadot/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// PolkadotClient is parity Polkadot client
// https://github.com/paritytech/polkadot-sdk
type PolkadotClient struct {
	node *polkadotv1alpha1.Node
}

// Images
const (
	//  PolkadotHomeDir is go ipfs image home dir
	PolkadotHomeDir = "/polkadot"
)

// Command returns environment variables for the client
func (c *PolkadotClient) Env() []corev1.EnvVar {
	return nil
}

// Command is go-ipfs entrypoint
func (c *PolkadotClient) Command() []string {
	return nil
}

// Args returns go-ipfs args
func (c *PolkadotClient) Args() (args []string) {

	node := c.node

	args = append(args, PolkadotArgBasePath, shared.PathData(c.HomeDir()))
	args = append(args, PolkadotArgChain, node.Spec.Network)
	args = append(args, PolkadotArgName, node.Name)
	args = append(args, PolkadotArgPort, fmt.Sprintf("%d", node.Spec.P2PPort))
	args = append(args, PolkadotArgSync, string(node.Spec.SyncMode))
	args = append(args, PolkadotArgLogging, string(node.Spec.Logging))

	args = append(args, PolkadotArgDatabase, string(node.Spec.Database))

	if node.Spec.Pruning != nil {
		var pruning bool = *node.Spec.Pruning
		if pruning {
			args = append(args, PolkadotArgPruning, fmt.Sprintf("%d", node.Spec.RetainedBlocks))
		} else {
			args = append(args, PolkadotArgPruning, "archive")
		}
	}

	if node.Spec.WS || node.Spec.RPC {
		args = append(args, PolkadotArgRPCPort, fmt.Sprintf("%d", node.Spec.RPCPort))
		args = append(args, PolkadotArgRPCExternal)
		args = append(args, PolkadotArgRPCCors, strings.Join(node.Spec.CORSDomains, ","))
	}

	if node.Spec.NodePrivateKeySecretName != "" {
		args = append(args, PolkadotArgNodeKeyType, "Ed25519")
		args = append(args, PolkadotArgNodeKeyFile, fmt.Sprintf("%s/kotal_nodekey", shared.PathData(c.HomeDir())))
	}

	if node.Spec.Telemetry {
		args = append(args, PolkadotArgTelemetryURL, node.Spec.TelemetryURL)
	} else {
		args = append(args, PolkadotArgNoTelemetry)
	}

	if node.Spec.Prometheus {
		args = append(args, PolkadotArgPrometheusExternal)
		args = append(args, PolkadotArgPrometheusPort, fmt.Sprintf("%d", node.Spec.PrometheusPort))
	} else {
		args = append(args, PolkadotArgNoPrometheus)
	}

	if node.Spec.Validator {
		args = append(args, PolkadotArgValidator)
	}

	return
}

func (c *PolkadotClient) HomeDir() string {
	return PolkadotHomeDir
}

'''
'''--- clients/polkadot/polkadot_client_test.go ---
package polkadot

import (
	"fmt"

	polkadotv1alpha1 "github.com/kotalco/kotal/apis/polkadot/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Polkadot client", func() {

	t := false
	node := &polkadotv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "kusama-node",
			Namespace: "default",
		},
		Spec: polkadotv1alpha1.NodeSpec{
			Network:                  "kusama",
			P2PPort:                  4444,
			NodePrivateKeySecretName: "kusama-node-key",
			Validator:                true,
			SyncMode:                 "fast",
			Logging:                  "warn",
			RPC:                      true,
			RPCPort:                  6789,
			WS:                       true,
			WSPort:                   3456,
			Telemetry:                true,
			TelemetryURL:             "wss://telemetry.kotal.io/submit/ 0",
			Prometheus:               true,
			PrometheusPort:           5432,
			Pruning:                  &t,
			CORSDomains:              []string{"kotal.com"},
			Database:                 polkadotv1alpha1.ParityDB,
			// TODO: create test for node with telemetry disabled
			// TODO: create test for node with prometheus disabled
			// TODO: create test for node with pruning true
		},
	}

	node.Default()
	client := NewClient(node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(BeNil())
	})

	It("Should get correct env", func() {
		Expect(client.Env()).To(BeNil())
	})

	It("Should get correct home directory", func() {
		Expect(client.HomeDir()).To(Equal(PolkadotHomeDir))
	})

	It("Should generate correct client arguments", func() {

		args := client.Args()

		Expect(args).To(ContainElements([]string{
			PolkadotArgBasePath,
			shared.PathData(client.HomeDir()),
			PolkadotArgChain,
			"kusama",
			PolkadotArgName,
			"kusama-node",
			PolkadotArgPort,
			"4444",
			PolkadotArgValidator,
			PolkadotArgLogging,
			string(sharedAPI.WarnLogs),
			PolkadotArgRPCExternal,
			PolkadotArgRPCPort,
			"6789",
			PolkadotArgNodeKeyType,
			"Ed25519",
			PolkadotArgNodeKeyFile,
			fmt.Sprintf("%s/kotal_nodekey", shared.PathData(client.HomeDir())),
			PolkadotArgTelemetryURL,
			"wss://telemetry.kotal.io/submit/ 0",
			PolkadotArgPrometheusExternal,
			PolkadotArgPrometheusPort,
			"5432",
			PolkadotArgPruning,
			"archive",
			PolkadotArgRPCCors,
			"kotal.com",
			PolkadotArgDatabase,
			string(polkadotv1alpha1.ParityDB),
		}))

	})

})

'''
'''--- clients/polkadot/suite_test.go ---
package polkadot

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestEthereum2Client(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Polkadot Client Suite")
}

'''
'''--- clients/polkadot/types.go ---
package polkadot

const (
	// PolkadotArgChain is argument used to set chain
	PolkadotArgChain = "--chain"
	// PolkadotArgName is node name reported to the telemetry server if enabled
	PolkadotArgName = "--name"
	// PolkadotArgPort is argument used to set p2p tcp port
	PolkadotArgPort = "--port"
	// PolkadotArgBasePath is argument to set base path
	PolkadotArgBasePath = "--base-path"
	// PolkadotArgSync is argument to set blockchain sync mode
	PolkadotArgSync = "--sync"
	// PolkadotArgPruning is argument used to keep recent blocks or archive all
	PolkadotArgPruning = "--pruning"
	// PolkadotArgDatabase is argument to set database backend
	PolkadotArgDatabase = "--database"
	// PolkadotArgLogging is argument to set logging verbosity
	PolkadotArgLogging = "--log"
	// PolkadotArgRPCExternal is argument used to enable rpc server on all hosts
	PolkadotArgRPCExternal = "--rpc-external"
	// PolkadotArgRPCPort is argument used to set JSON-RPC server port
	PolkadotArgRPCPort = "--rpc-port"
	// PolkadotArgRPCCors is argument used to set origins allowed to access the JSON-RPC HTTP and WS servers
	PolkadotArgRPCCors = "--rpc-cors"
	// PolkadotArgNodeKeyFile is argument used to locate node key
	PolkadotArgNodeKeyFile = "--node-key-file"
	// PolkadotArgNodeKeyType is argument used to set node key type
	PolkadotArgNodeKeyType = "--node-key-type"
	// PolkadotArgValidator is argument used to enable validator mode
	PolkadotArgValidator = "--validator"
	// PolkadotArgNoTelemetry is argument used to disable connecting to telemetry server
	PolkadotArgNoTelemetry = "--no-telemetry"
	// PolkadotArgTelemetryURL is argument used to connect to telemetry service
	PolkadotArgTelemetryURL = "--telemetry-url"
	// PolkadotArgNoPrometheus is argument used to disable prometheus exporter
	PolkadotArgNoPrometheus = "--no-prometheus"
	// PolkadotArgPrometheusExternal is argument used to enable prometheus exporter
	PolkadotArgPrometheusExternal = "--prometheus-external"
	// PolkadotArgPrometheusPort is argument used to set prometheus exporter port
	PolkadotArgPrometheusPort = "--prometheus-port"
)

'''
'''--- clients/stacks/client.go ---
package stacks

import (
	stacksv1alpha1 "github.com/kotalco/kotal/apis/stacks/v1alpha1"
	clients "github.com/kotalco/kotal/clients"
)

func NewClient(node *stacksv1alpha1.Node) clients.Interface {
	return &StacksNodeClient{node}
}

'''
'''--- clients/stacks/stacks_node_client.go ---
package stacks

import (
	"fmt"

	stacksv1alpha1 "github.com/kotalco/kotal/apis/stacks/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	corev1 "k8s.io/api/core/v1"
)

// StacksNodeClient is Stacks blockchain node client
// https://github.com/stacks-network/stacks-blockchain
type StacksNodeClient struct {
	node *stacksv1alpha1.Node
}

// Images
const (
	// StacksNodeHomeDir is Stacks node image home dir
	// TODO: update home dir after creating a new docker image
	StacksNodeHomeDir = "/home/stacks"
)

// Command returns environment variables for the client
func (c *StacksNodeClient) Env() (env []corev1.EnvVar) {
	return
}

// Command is Stacks node client entrypoint
func (c *StacksNodeClient) Command() (command []string) {

	command = append(command, StacksNodeCommand, StacksStartCommand)

	return
}

// Args returns Stacks node client args
func (c *StacksNodeClient) Args() (args []string) {
	_ = c.node

	args = append(args, StacksArgConfig, fmt.Sprintf("%s/config.toml", shared.PathConfig(c.HomeDir())))

	return
}

// HomeDir is the home directory of Stacks node client image
func (c *StacksNodeClient) HomeDir() string {
	return StacksNodeHomeDir
}

'''
'''--- clients/stacks/stacks_node_client_test.go ---
package stacks

import (
	"fmt"

	stacksv1alpha1 "github.com/kotalco/kotal/apis/stacks/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("Stacks node client", func() {

	node := &stacksv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "stacks-node",
			Namespace: "default",
		},
		Spec: stacksv1alpha1.NodeSpec{
			Network: "mainnet",
		},
	}

	node.Default()

	client := NewClient(node)

	It("Should get correct command", func() {
		Expect(client.Command()).To(Equal(
			[]string{
				StacksNodeCommand,
				StacksStartCommand,
			},
		))
	})

	It("Should get correct home directory", func() {
		Expect(client.HomeDir()).To(Equal(StacksNodeHomeDir))
	})

	It("Should generate correct client arguments", func() {
		Expect(client.Args()).To(ContainElements(
			[]string{
				StacksArgConfig,
				fmt.Sprintf("%s/config.toml", shared.PathConfig(client.HomeDir())),
			},
		))
	})

})

'''
'''--- clients/stacks/suite_test.go ---
package stacks

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestStacksNodeClient(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Stacks Node Client Suite")
}

'''
'''--- clients/stacks/types.go ---
package stacks

const (
	// StacksNodeCommand is stacks node exec command
	StacksNodeCommand = "stacks-node"
	// StacksStartCommand is command used to start stacks node
	StacksStartCommand = "start"
)

const (
	// StacksArgConfig is argument used to set configuration file
	StacksArgConfig = "--config"
)

'''
'''--- controllers/aptos/config.go ---
package controllers

import (
	"context"
	"fmt"

	aptosv1alpha1 "github.com/kotalco/kotal/apis/aptos/v1alpha1"
	aptosClients "github.com/kotalco/kotal/clients/aptos"
	"github.com/kotalco/kotal/controllers/shared"
	"gopkg.in/yaml.v2"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type Waypoint struct {
	FromConfig string `yaml:"from_config,omitempty"`
	FromFile   string `yaml:"from_file,omitempty"`
}

type Execution struct {
	GenesisFileLocation string `yaml:"genesis_file_location"`
}

type Base struct {
	Role     string   `yaml:"role"`
	DataDir  string   `yaml:"data_dir"`
	Waypoint Waypoint `yaml:"waypoint"`
}

type Identity struct {
	Type   string `yaml:"type"`
	Key    string `yaml:"key"`
	PeerId string `yaml:"peer_id"`
}

type Peer struct {
	Addresses []string `yaml:"addresses"`
	Role      string   `yaml:"role"`
}

type Network struct {
	NetworkId       string          `yaml:"network_id"`
	DiscoveryMethod string          `yaml:"discovery_method"`
	ListenAddress   string          `yaml:"listen_address"`
	Identity        Identity        `yaml:"identity,omitempty"`
	Seeds           map[string]Peer `yaml:"seeds,omitempty"`
}

type API struct {
	Enabled bool   `yaml:"enabled"`
	Address string `yaml:"address"`
}

type InspectionService struct {
	Port uint `yaml:"port"`
}

type Config struct {
	Base              Base              `yaml:"base"`
	Execution         Execution         `yaml:"execution"`
	FullNodeNetworks  []Network         `yaml:"full_node_networks,omitempty"`
	API               API               `yaml:"api"`
	InspectionService InspectionService `yaml:"inspection_service"`
}

// ConfigFromSpec generates config.toml file from node spec
func ConfigFromSpec(node *aptosv1alpha1.Node, client client.Client) (config string, err error) {
	var role string
	if node.Spec.Validator {
		role = "validator"
	} else {
		role = "full_node"
	}

	var nodePrivateKey string
	var identity Identity
	if node.Spec.NodePrivateKeySecretName != "" {
		key := types.NamespacedName{
			Name:      node.Spec.NodePrivateKeySecretName,
			Namespace: node.Namespace,
		}

		if nodePrivateKey, err = shared.GetSecret(context.Background(), client, key, "key"); err != nil {
			return
		}

		identity = Identity{
			Type:   "from_config",
			Key:    nodePrivateKey,
			PeerId: node.Spec.PeerId,
		}

	}

	seeds := map[string]Peer{}

	if len(node.Spec.SeedPeers) != 0 {
		for _, peer := range node.Spec.SeedPeers {
			seeds[peer.ID] = Peer{
				Addresses: peer.Addresses,
				Role:      "Upstream",
			}
		}
	}

	homeDir := aptosClients.NewClient(node).HomeDir()
	configDir := shared.PathConfig(homeDir)
	dataDir := shared.PathData(homeDir)

	waypoint := Waypoint{}
	var genesisFileLocation string

	if node.Spec.Waypoint == "" {
		waypoint.FromFile = fmt.Sprintf("%s/kotal_waypoint.txt", shared.PathData(homeDir))
	} else {
		waypoint.FromConfig = node.Spec.Waypoint
	}

	if node.Spec.GenesisConfigmapName == "" {
		genesisFileLocation = fmt.Sprintf("%s/kotal_genesis.blob", dataDir)
	} else {
		genesisFileLocation = fmt.Sprintf("%s/genesis.blob", configDir)
	}

	c := Config{
		Base: Base{
			Role:     role,
			DataDir:  shared.PathData(homeDir),
			Waypoint: waypoint,
		},
		Execution: Execution{
			GenesisFileLocation: genesisFileLocation,
		},
		FullNodeNetworks: []Network{
			{
				NetworkId:       "public",
				DiscoveryMethod: "onchain",
				ListenAddress:   fmt.Sprintf("/ip4/%s/tcp/%d", shared.Host(true), node.Spec.P2PPort),
				Identity:        identity,
				Seeds:           seeds,
			},
		},
		API: API{
			Enabled: node.Spec.API,
			Address: fmt.Sprintf("%s:%d", shared.Host(node.Spec.API), node.Spec.APIPort),
		},
		InspectionService: InspectionService{
			Port: node.Spec.MetricsPort,
		},
	}

	data, err := yaml.Marshal(&c)
	if err != nil {
		return
	}

	config = string(data)
	return
}

'''
'''--- controllers/aptos/download_genesis_block.sh ---
if [ -z "$(ls -A $KOTAL_DATA_PATH/kotal_genesis.blob)" ]
then
    echo "downloading genesis block"
    curl https://raw.githubusercontent.com/aptos-labs/aptos-networks/main/$KOTAL_NETWORK/genesis.blob -o $KOTAL_DATA_PATH/kotal_genesis.blob
else
    echo "genesis block has been downloaded before"
fi
'''
'''--- controllers/aptos/download_waypoint.sh ---
curl https://raw.githubusercontent.com/aptos-labs/aptos-networks/main/$KOTAL_NETWORK/waypoint.txt -o $KOTAL_DATA_PATH/kotal_waypoint.txt
'''
'''--- controllers/aptos/node_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"

	aptosv1alpha1 "github.com/kotalco/kotal/apis/aptos/v1alpha1"
	aptosClients "github.com/kotalco/kotal/clients/aptos"
	"github.com/kotalco/kotal/controllers/shared"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	shared.Reconciler
}

var (
	//go:embed download_waypoint.sh
	downloadWaypoint string
	//go:embed download_genesis_block.sh
	downloadGenesisBlock string
)

// +kubebuilder:rbac:groups=aptos.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=aptos.kotal.io,resources=nodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=services;configmaps;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node aptosv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, "aptos-core", string(node.Spec.Network))

	// reconcile config map
	r.ReconcileOwned(ctx, &node, &corev1.ConfigMap{}, func(obj client.Object) error {
		r.specConfigmap(&node, obj.(*corev1.ConfigMap))
		return nil
	})

	// reconcile service
	r.ReconcileOwned(ctx, &node, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&node, obj.(*corev1.Service))
		return nil
	})

	// reconcile persistent volume claim
	r.ReconcileOwned(ctx, &node, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&node, obj.(*corev1.PersistentVolumeClaim))
		return nil
	})

	// reconcile statefulset
	r.ReconcileOwned(ctx, &node, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client := aptosClients.NewClient(&node)

		homeDir := client.HomeDir()
		cmd := client.Command()
		args := client.Args()
		args = append(args, node.Spec.ExtraArgs.Encode(false)...)
		env := client.Env()

		return r.specStatefulSet(&node, obj.(*appsv1.StatefulSet), homeDir, env, cmd, args)
	})

	return
}

// specConfigmap updates node configmap
func (n *NodeReconciler) specConfigmap(node *aptosv1alpha1.Node, configmap *corev1.ConfigMap) {
	configmap.ObjectMeta.Labels = node.Labels

	if configmap.Data == nil {
		configmap.Data = map[string]string{}
	}

	config, err := ConfigFromSpec(node, n.Client)
	if err != nil {
		return
	}

	configmap.Data["config.yaml"] = config
	configmap.Data["download_waypoint.sh"] = downloadWaypoint
	configmap.Data["download_genesis_block.sh"] = downloadGenesisBlock

}

// specPVC updates Aptos node persistent volume claim
func (r *NodeReconciler) specPVC(node *aptosv1alpha1.Node, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(node.Spec.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = node.Labels
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
	}
}

// specService updates Aptos node service spec
func (r *NodeReconciler) specService(node *aptosv1alpha1.Node, svc *corev1.Service) {
	labels := node.Labels

	svc.ObjectMeta.Labels = labels

	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
		{
			Name:       "metrics",
			Port:       int32(node.Spec.MetricsPort),
			TargetPort: intstr.FromString("metrics"),
		},
	}

	if node.Spec.API {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "api",
			Port:       int32(node.Spec.APIPort),
			TargetPort: intstr.FromString("api"),
		})
	}

	svc.Spec.Selector = labels
}

// specStatefulSet updates node statefulset spec
func (r *NodeReconciler) specStatefulSet(node *aptosv1alpha1.Node, sts *appsv1.StatefulSet, homeDir string, env []corev1.EnvVar, cmd, args []string) error {

	sts.ObjectMeta.Labels = node.Labels

	initContainers := []corev1.Container{}

	if node.Spec.Waypoint == "" {
		initContainers = append(initContainers, corev1.Container{
			Name:  "download-waypoint",
			Image: "curlimages/curl:8.00.1",
			Env: []corev1.EnvVar{
				{
					Name:  "KOTAL_NETWORK",
					Value: string(node.Spec.Network),
				},
				{
					Name:  shared.EnvDataPath,
					Value: shared.PathData(homeDir),
				},
			},
			Command: []string{"/bin/sh"},
			Args:    []string{fmt.Sprintf("%s/download_waypoint.sh", shared.PathConfig(homeDir))},
			VolumeMounts: []corev1.VolumeMount{
				{
					Name:      "config",
					MountPath: shared.PathConfig(homeDir),
					ReadOnly:  true,
				},
				{
					Name:      "data",
					MountPath: shared.PathData(homeDir),
				},
			},
		})
	}

	sources := []corev1.VolumeProjection{
		{
			// config.yaml
			ConfigMap: &corev1.ConfigMapProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Name,
				},
			},
		},
	}

	if node.Spec.GenesisConfigmapName == "" {
		initContainers = append(initContainers, corev1.Container{
			Name:  "download-genesis-block",
			Image: "curlimages/curl:8.00.1",
			Env: []corev1.EnvVar{
				{
					Name:  "KOTAL_NETWORK",
					Value: string(node.Spec.Network),
				},
				{
					Name:  shared.EnvDataPath,
					Value: shared.PathData(homeDir),
				},
			},
			Command: []string{"/bin/sh"},
			Args:    []string{fmt.Sprintf("%s/download_genesis_block.sh", shared.PathConfig(homeDir))},
			VolumeMounts: []corev1.VolumeMount{
				{
					Name:      "config",
					MountPath: shared.PathConfig(homeDir),
					ReadOnly:  true,
				},
				{
					Name:      "data",
					MountPath: shared.PathData(homeDir),
				},
			},
		})
	} else {
		sources = append(sources, corev1.VolumeProjection{
			// genesis.blob
			ConfigMap: &corev1.ConfigMapProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.GenesisConfigmapName,
				},
			},
		})
	}

	ports := []corev1.ContainerPort{
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
		{
			Name:          "metrics",
			ContainerPort: int32(node.Spec.MetricsPort),
		},
	}

	if node.Spec.API {
		ports = append(ports, corev1.ContainerPort{
			Name:          "api",
			ContainerPort: int32(node.Spec.APIPort),
		})
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: node.Labels,
		},
		ServiceName: node.Name,
		Replicas:    &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: node.Labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				InitContainers:  initContainers,
				Containers: []corev1.Container{
					{
						Name:    "node",
						Image:   node.Spec.Image,
						Command: cmd,
						Args:    args,
						Env:     env,
						Ports:   ports,
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPU),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPULimit),
								corev1.ResourceMemory: resource.MustParse(node.Spec.MemoryLimit),
							},
						},
						VolumeMounts: []corev1.VolumeMount{
							{
								Name:      "config",
								MountPath: shared.PathConfig(homeDir),
								ReadOnly:  true,
							},
							{
								Name:      "data",
								MountPath: shared.PathData(homeDir),
							},
						},
					},
				},
				Volumes: []corev1.Volume{
					{
						Name: "data",
						VolumeSource: corev1.VolumeSource{
							PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
								ClaimName: node.Name,
							},
						},
					},
					{
						Name: "config",
						VolumeSource: corev1.VolumeSource{
							Projected: &corev1.ProjectedVolumeSource{
								Sources: sources,
							},
						},
					},
				},
			},
		},
	}

	return nil
}

func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&aptosv1alpha1.Node{}).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Owns(&corev1.Service{}).
		Owns(&corev1.ConfigMap{}).
		Complete(r)
}

'''
'''--- controllers/aptos/node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	aptosv1alpha1 "github.com/kotalco/kotal/apis/aptos/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("aptos node controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "aptos",
		},
	}

	key := types.NamespacedName{
		Name:      "aptos-node",
		Namespace: ns.Name,
	}

	testImage := "kotalco/aptos:controller-test"

	spec := aptosv1alpha1.NodeSpec{
		Image:       testImage,
		Network:     "testnet",
		API:         true,
		APIPort:     4321,
		P2PPort:     5432,
		MetricsPort: 9099,
	}

	toCreate := &aptosv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	t := true

	nodeOwnerReference := metav1.OwnerReference{
		APIVersion:         "aptos.kotal.io/v1alpha1",
		Kind:               "Node",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("should create aptos node", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("Should get aptos node", func() {
		fetched := &aptosv1alpha1.Node{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		nodeOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		Expect(fetched.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
	})

	It("Should create allocate correct resources to node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(aptosv1alpha1.DefaultNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(aptosv1alpha1.DefaultNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(aptosv1alpha1.DefaultNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(aptosv1alpha1.DefaultNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create node configmap", func() {
		fetched := &corev1.ConfigMap{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Data).To(HaveKey("config.yaml"))

	})

	It("Should create node data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(aptosv1alpha1.DefaultNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It("Should create node service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "p2p",
					Port:       int32(spec.P2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "metrics",
					Port:       int32(spec.MetricsPort),
					TargetPort: intstr.FromString("metrics"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "api",
					Port:       int32(spec.APIPort),
					TargetPort: intstr.FromString("api"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/aptos/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	aptosv1alpha1 "github.com/kotalco/kotal/apis/aptos/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	// start the test environment
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = aptosv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	// create new k8s client
	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start node reconciler
	nodeReconciler := &NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	nodeReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	cancel()
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/bitcoin/node_controller.go ---
package controllers

import (
	"context"

	bitcoinClients "github.com/kotalco/kotal/clients/bitcoin"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"

	bitcoinv1alpha1 "github.com/kotalco/kotal/apis/bitcoin/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	shared.Reconciler
}

// +kubebuilder:rbac:groups=bitcoin.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=bitcoin.kotal.io,resources=nodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=services;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

// Reconcile Bitcoin node
func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node bitcoinv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, "bitcoind", string(node.Spec.Network))

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &node, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&node, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile service
	if err = r.ReconcileOwned(ctx, &node, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&node, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile statefulset
	if err = r.ReconcileOwned(ctx, &node, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client := bitcoinClients.NewClient(&node, r.Client)
		homeDir := client.HomeDir()
		cmd := client.Command()
		args := client.Args()
		args = append(args, node.Spec.ExtraArgs.Encode(true)...)
		env := client.Env()
		return r.specStatefulSet(&node, obj.(*appsv1.StatefulSet), homeDir, env, cmd, args)
	}); err != nil {
		return
	}

	if err = r.updateStatus(ctx, &node); err != nil {
		return
	}

	return
}

// updateStatus updates Bitcoin node status
func (r *NodeReconciler) updateStatus(ctx context.Context, node *bitcoinv1alpha1.Node) error {
	node.Status.Client = "bitcoincore"

	if err := r.Status().Update(ctx, node); err != nil {
		log.FromContext(ctx).Error(err, "unable to update node status")
		return err
	}

	return nil
}

// specPVC updates Bitcoin node persistent volume claim
func (r *NodeReconciler) specPVC(node *bitcoinv1alpha1.Node, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(node.Spec.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = node.Labels
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
	}
}

// specService updates Bitcoin node service spec
func (r *NodeReconciler) specService(node *bitcoinv1alpha1.Node, svc *corev1.Service) {
	labels := node.Labels

	svc.ObjectMeta.Labels = labels

	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
	}

	if node.Spec.RPC {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "rpc",
			Port:       int32(node.Spec.RPCPort),
			TargetPort: intstr.FromString("rpc"),
		})
	}

	svc.Spec.Selector = labels
}

// specStatefulSet updates node statefulset spec
func (r *NodeReconciler) specStatefulSet(node *bitcoinv1alpha1.Node, sts *appsv1.StatefulSet, homeDir string, env []corev1.EnvVar, cmd, args []string) error {

	sts.ObjectMeta.Labels = node.Labels

	ports := []corev1.ContainerPort{
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
	}

	if node.Spec.RPC {
		ports = append(ports, corev1.ContainerPort{
			Name:          "rpc",
			ContainerPort: int32(node.Spec.RPCPort),
		})
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: node.Labels,
		},
		Replicas:    &replicas,
		ServiceName: node.Name,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: node.Labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				Containers: []corev1.Container{
					{
						Name:    "node",
						Image:   node.Spec.Image,
						Command: cmd,
						Args:    args,
						Env:     env,
						Ports:   ports,
						VolumeMounts: []corev1.VolumeMount{
							{
								Name:      "data",
								MountPath: shared.PathData(homeDir),
							},
						},
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPU),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPULimit),
								corev1.ResourceMemory: resource.MustParse(node.Spec.MemoryLimit),
							},
						},
					},
				},
				Volumes: []corev1.Volume{
					{
						Name: "data",
						VolumeSource: corev1.VolumeSource{
							PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
								ClaimName: node.Name,
							},
						},
					},
				},
			},
		},
	}

	return nil
}

func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	pred := predicate.GenerationChangedPredicate{}
	return ctrl.NewControllerManagedBy(mgr).
		For(&bitcoinv1alpha1.Node{}).
		WithEventFilter(pred).
		Owns(&corev1.PersistentVolumeClaim{}).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.Service{}).
		Complete(r)
}

'''
'''--- controllers/bitcoin/node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	bitcoinv1alpha1 "github.com/kotalco/kotal/apis/bitcoin/v1alpha1"
	bitcoinClients "github.com/kotalco/kotal/clients/bitcoin"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("Bitcoin node controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "bitcoin",
		},
	}

	key := types.NamespacedName{
		Name:      "bitcoin-node",
		Namespace: ns.Name,
	}

	testImage := "kotalco/bitcoin-core:controller-test"

	spec := bitcoinv1alpha1.NodeSpec{
		Image:   testImage,
		Network: bitcoinv1alpha1.Mainnet,
		RPC:     true,
	}

	toCreate := &bitcoinv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	client := bitcoinClients.NewClient(toCreate, nil)

	t := true

	nodeOwnerReference := metav1.OwnerReference{
		APIVersion:         "bitcoin.kotal.io/v1alpha1",
		Kind:               "Node",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("should create Bitcoin node", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("Should get Bitcoin node", func() {
		fetched := &bitcoinv1alpha1.Node{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		nodeOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		Expect(fetched.Spec.Template.Spec.Containers[0].Name).To(Equal("node"))
		Expect(fetched.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
		Expect(fetched.Spec.Template.Spec.Containers[0].Env).To(Equal(client.Env()))
		Expect(fetched.Spec.Template.Spec.Containers[0].Command).To(Equal(client.Command()))
		Expect(fetched.Spec.Template.Spec.Containers[0].Args).To(Equal(client.Args()))
		Expect(fetched.Spec.Template.Spec.Containers[0].VolumeMounts).To(ContainElements(
			corev1.VolumeMount{
				Name:      "data",
				MountPath: shared.PathData(client.HomeDir()),
			},
		))
		// volumes
		Expect(fetched.Spec.Template.Spec.Volumes).To(ContainElements(
			[]corev1.Volume{
				{
					Name: "data",
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: toCreate.Name,
						},
					},
				},
			},
		))
	})

	It("Should create allocate correct resources to node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(bitcoinv1alpha1.DefaultNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(bitcoinv1alpha1.DefaultNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(bitcoinv1alpha1.DefaultNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(bitcoinv1alpha1.DefaultNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create node data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(bitcoinv1alpha1.DefaultNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It("Should create node service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "p2p",
					Port:       int32(bitcoinv1alpha1.DefaultMainnetP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "rpc",
					Port:       int32(bitcoinv1alpha1.DefaultMainnetRPCPort),
					TargetPort: intstr.FromString("rpc"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/bitcoin/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	bitcoinv1alpha1 "github.com/kotalco/kotal/apis/bitcoin/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	// start the test environment
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = bitcoinv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	// create new k8s client
	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start node reconciler
	nodeReconciler := &NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	nodeReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	cancel()
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/chainlink/config.go ---
package controllers

import (
	"bytes"
	"context"
	"fmt"
	"strings"

	"github.com/kotalco/kotal/controllers/shared"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/BurntSushi/toml"
	chainlinkv1alpha1 "github.com/kotalco/kotal/apis/chainlink/v1alpha1"
)

// Chainlink node configuration is documented here
// https://github.com/smartcontractkit/chainlink/blob/develop/docs/CONFIG.md

type WebServer struct {
	AllowOrigins  string
	SecureCookies bool
	HTTPPort      uint
	TLS           WebServerTLS
}

type WebServerTLS struct {
	HTTPSPort uint
	CertPath  string
	KeyPath   string
}

type EVM struct {
	ChainID             string
	LinkContractAddress string
	Nodes               []Node
}

type Node struct {
	Name    string
	WSURL   string
	HTTPURL string
}

type P2PV2 struct {
	ListenAddresses []string
}

type P2P struct {
	V2 P2PV2
}

type Log struct {
	Level string
}

type Config struct {
	RootDir   string
	P2P       P2P
	Log       Log
	WebServer WebServer
	// WebServerTLS WebServerTLS `toml:"WebServer.TLS,omitempty"`
	EVM   []EVM
	Nodes []Node `toml:"EVM.Nodes"`
}

// ConfigFromSpec generates config.toml file from node spec
func ConfigFromSpec(node *chainlinkv1alpha1.Node, homeDir string) (config string, err error) {
	c := &Config{}

	c.RootDir = shared.PathData(homeDir)

	c.Log = Log{
		Level: string(node.Spec.Logging),
	}

	c.EVM = []EVM{
		{
			ChainID:             fmt.Sprintf("%d", node.Spec.EthereumChainId),
			LinkContractAddress: node.Spec.LinkContractAddress,
			Nodes: []Node{
				{
					Name:    "node",
					WSURL:   node.Spec.EthereumWSEndpoint,
					HTTPURL: strings.Join(node.Spec.EthereumHTTPEndpoints, ","),
				},
			},
		},
	}

	c.P2P = P2P{
		V2: P2PV2{
			ListenAddresses: []string{
				fmt.Sprintf("%s:%d", shared.Host(true), node.Spec.P2PPort),
			},
		},
	}

	c.WebServer = WebServer{
		AllowOrigins:  strings.Join(node.Spec.CORSDomains, ","),
		SecureCookies: node.Spec.SecureCookies,
		HTTPPort:      node.Spec.APIPort,
	}

	if node.Spec.CertSecretName != "" {
		c.WebServer.TLS = WebServerTLS{
			HTTPSPort: node.Spec.TLSPort,
			KeyPath:   fmt.Sprintf("%s/tls.key", shared.PathSecrets(homeDir)),
			CertPath:  fmt.Sprintf("%s/tls.crt", shared.PathSecrets(homeDir)),
		}
	}

	var buff bytes.Buffer
	enc := toml.NewEncoder(&buff)
	err = enc.Encode(c)
	if err != nil {
		return
	}

	config = buff.String()

	return
}

type SecretsConfig struct {
	Database Database
	Password Password
}

type Database struct {
	URL string
}

type Password struct {
	Keystore string
}

// SecretsFromSpec generates config.toml file from node spec
func SecretsFromSpec(node *chainlinkv1alpha1.Node, homeDir string, client client.Client) (config string, err error) {
	c := &SecretsConfig{}

	c.Database = Database{
		URL: node.Spec.DatabaseURL,
	}

	key := types.NamespacedName{
		Name:      node.Spec.KeystorePasswordSecretName,
		Namespace: node.Namespace,
	}

	var password string
	if password, err = shared.GetSecret(context.Background(), client, key, "password"); err != nil {
		return
	}

	c.Password = Password{
		Keystore: password,
	}

	var buff bytes.Buffer
	enc := toml.NewEncoder(&buff)
	err = enc.Encode(c)
	if err != nil {
		return
	}

	config = buff.String()

	return
}

'''
'''--- controllers/chainlink/copy_api_credentials.sh ---
#!/bin/sh

set -e

mkdir -p ${KOTAL_DATA_PATH}
echo $KOTAL_API_EMAIL > ${KOTAL_DATA_PATH}/.api
cat ${KOTAL_SECRETS_PATH}/api-password >> ${KOTAL_DATA_PATH}/.api

'''
'''--- controllers/chainlink/node_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"

	chainlinkv1alpha1 "github.com/kotalco/kotal/apis/chainlink/v1alpha1"
	chainlinkClients "github.com/kotalco/kotal/clients/chainlink"
	"github.com/kotalco/kotal/controllers/shared"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	shared.Reconciler
}

const (
	envApiEmail = "KOTAL_API_EMAIL"
)

var (
	//go:embed copy_api_credentials.sh
	CopyAPICredentials string
)

// +kubebuilder:rbac:groups=chainlink.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=chainlink.kotal.io,resources=nodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=services;configmaps;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node chainlinkv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, "chainlink", "")

	// reconcile service
	if err = r.ReconcileOwned(ctx, &node, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&node, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile config map
	if err = r.ReconcileOwned(ctx, &node, &corev1.ConfigMap{}, func(obj client.Object) error {
		homeDir := chainlinkClients.NewClient(&node).HomeDir()

		configToml, err := ConfigFromSpec(&node, homeDir)
		if err != nil {
			return err
		}

		secretsConfigToml, err := SecretsFromSpec(&node, homeDir, r.Client)
		if err != nil {
			return err
		}
		r.specConfigmap(&node, obj.(*corev1.ConfigMap), configToml, secretsConfigToml)
		return nil
	}); err != nil {
		return
	}

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &node, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&node, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile stateful set
	if err = r.ReconcileOwned(ctx, &node, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client := chainlinkClients.NewClient(&node)

		command := client.Command()
		args := client.Args()
		args = append(args, node.Spec.ExtraArgs.Encode(false)...)
		env := client.Env()
		homeDir := client.HomeDir()
		return r.specStatefulSet(&node, obj.(*appsv1.StatefulSet), homeDir, command, args, env)
	}); err != nil {
		return
	}

	if err = r.updateStatus(ctx, &node); err != nil {
		return
	}

	return
}

// updateStatus updates chainlink node status
func (r *NodeReconciler) updateStatus(ctx context.Context, node *chainlinkv1alpha1.Node) error {
	node.Status.Client = "chainlink"

	if err := r.Status().Update(ctx, node); err != nil {
		log.FromContext(ctx).Error(err, "unable to update node status")
		return err
	}

	return nil
}

// specService updates node service spec
func (r *NodeReconciler) specService(node *chainlinkv1alpha1.Node, svc *corev1.Service) {
	labels := node.Labels

	svc.ObjectMeta.Labels = labels

	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
	}

	if node.Spec.API {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "api",
			Port:       int32(node.Spec.APIPort),
			TargetPort: intstr.FromString("api"),
		})
	}

	if node.Spec.TLSPort != 0 {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "tls",
			Port:       int32(node.Spec.TLSPort),
			TargetPort: intstr.FromString("tls"),
		})
	}

	svc.Spec.Selector = labels
}

// specConfigmap updates chainlink node configmap spec
func (r *NodeReconciler) specConfigmap(node *chainlinkv1alpha1.Node, config *corev1.ConfigMap, configToml, secretsConfigToml string) {
	config.ObjectMeta.Labels = node.Labels

	if config.Data == nil {
		config.Data = make(map[string]string)
	}

	config.Data["config.toml"] = configToml
	config.Data["secrets.toml"] = secretsConfigToml
	config.Data["copy_api_credentials.sh"] = CopyAPICredentials
}

func (r *NodeReconciler) createVolumes(node *chainlinkv1alpha1.Node) []corev1.Volume {
	volumes := []corev1.Volume{}

	// data volume
	volumes = append(volumes, corev1.Volume{
		Name: "data",
		VolumeSource: corev1.VolumeSource{
			PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
				ClaimName: node.Name,
			},
		},
	})

	// config volume
	volumes = append(volumes, corev1.Volume{
		Name: "config",
		VolumeSource: corev1.VolumeSource{
			ConfigMap: &corev1.ConfigMapVolumeSource{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Name,
				},
			},
		},
	})

	// projected volume sources
	sources := []corev1.VolumeProjection{
		{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.APICredentials.PasswordSecretName,
				},
				Items: []corev1.KeyToPath{
					{
						Key:  "password",
						Path: "api-password",
					},
				},
			},
		},
	}

	if node.Spec.CertSecretName != "" {
		sources = append(sources, corev1.VolumeProjection{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.CertSecretName,
				},
			},
		})
	}

	// secrets volume
	volumes = append(volumes, corev1.Volume{
		Name: "secrets",
		VolumeSource: corev1.VolumeSource{
			Projected: &corev1.ProjectedVolumeSource{
				Sources: sources,
			},
		},
	})

	return volumes
}

func (r *NodeReconciler) createVolumeMounts(node *chainlinkv1alpha1.Node, homeDir string) []corev1.VolumeMount {
	// chainlink chmod the root dir
	// we mount data volume at home dir
	// chainlink root dir will be mounted at $data/kotal-data
	return []corev1.VolumeMount{
		{
			Name:      "data",
			MountPath: homeDir,
		},
		{
			Name:      "config",
			MountPath: shared.PathConfig(homeDir),
		},
		{
			Name:      "secrets",
			MountPath: shared.PathSecrets(homeDir),
		},
	}
}

// specStatefulSet updates node statefulset spec
func (r *NodeReconciler) specStatefulSet(node *chainlinkv1alpha1.Node, sts *appsv1.StatefulSet, homeDir string, command, args []string, env []corev1.EnvVar) error {

	sts.ObjectMeta.Labels = node.Labels

	ports := []corev1.ContainerPort{
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
	}

	if node.Spec.API {
		ports = append(ports, corev1.ContainerPort{
			Name:          "api",
			ContainerPort: int32(node.Spec.APIPort),
		})
	}

	if node.Spec.TLSPort != 0 {
		ports = append(ports, corev1.ContainerPort{
			Name:          "tls",
			ContainerPort: int32(node.Spec.TLSPort),
		})
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: node.Labels,
		},
		Replicas:    &replicas,
		ServiceName: node.Name,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: node.Labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				InitContainers: []corev1.Container{
					{
						Name:    "copy-api-credentials",
						Image:   shared.BusyboxImage,
						Command: []string{"/bin/sh"},
						Env: []corev1.EnvVar{
							{
								Name:  shared.EnvDataPath,
								Value: shared.PathData(homeDir),
							},
							{
								Name:  envApiEmail,
								Value: node.Spec.APICredentials.Email,
							},
							{
								Name:  shared.EnvSecretsPath,
								Value: shared.PathSecrets(homeDir),
							},
						},
						Args:         []string{fmt.Sprintf("%s/copy_api_credentials.sh", shared.PathConfig(homeDir))},
						VolumeMounts: r.createVolumeMounts(node, homeDir),
					},
				},
				Containers: []corev1.Container{
					{
						Name:    "node",
						Image:   node.Spec.Image,
						Command: command,
						Args:    args,
						Env:     env,
						Ports:   ports,
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.Resources.CPU),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Resources.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.Resources.CPULimit),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Resources.MemoryLimit),
							},
						},
						VolumeMounts: r.createVolumeMounts(node, homeDir),
					},
				},
				Volumes: r.createVolumes(node),
			},
		},
	}

	return nil
}

// specPVC updates chainlink persistent volume claim
func (r *NodeReconciler) specPVC(node *chainlinkv1alpha1.Node, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(node.Spec.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = node.Labels
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: node.Spec.StorageClass,
	}
}

func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	pred := predicate.GenerationChangedPredicate{}
	return ctrl.NewControllerManagedBy(mgr).
		For(&chainlinkv1alpha1.Node{}).
		WithEventFilter(pred).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.ConfigMap{}).
		Owns(&corev1.Service{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Complete(r)
}

'''
'''--- controllers/chainlink/node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	chainlinkv1alpha1 "github.com/kotalco/kotal/apis/chainlink/v1alpha1"
	chainlinkClients "github.com/kotalco/kotal/clients/chainlink"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("Chainlink node controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "chainlink",
		},
	}

	key := types.NamespacedName{
		Name:      "chainlink-node",
		Namespace: ns.Name,
	}

	testImage := "kotalco/chainlink:controller-test"

	spec := chainlinkv1alpha1.NodeSpec{
		Image:                      testImage,
		EthereumChainId:            1,
		EthereumWSEndpoint:         "wss://my-eth-node:8546",
		LinkContractAddress:        "0x01BE23585060835E02B77ef475b0Cc51aA1e0709",
		DatabaseURL:                "postgresql://postgres:password@postgres:5432/postgres",
		KeystorePasswordSecretName: "keystore-password",
		API:                        true,
		APICredentials: chainlinkv1alpha1.APICredentials{
			Email:              "mostafa@kotal.co",
			PasswordSecretName: "api-password",
		},
	}

	toCreate := &chainlinkv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	client := chainlinkClients.NewClient(toCreate)

	t := true

	nodeOwnerReference := metav1.OwnerReference{
		APIVersion:         "chainlink.kotal.io/v1alpha1",
		Kind:               "Node",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("Should create keystore password secret", func() {
		secret := corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "keystore-password",
				Namespace: ns.Name,
			},
			StringData: map[string]string{
				"password": "99%OfBlockchainNodesRunOnAWS",
			},
		}
		Expect(k8sClient.Create(context.Background(), &secret)).To(Succeed())
	})

	It("should create chainlink node", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("Should get chainlink node", func() {
		fetched := &chainlinkv1alpha1.Node{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		nodeOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		// init container
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Image).To(Equal(shared.BusyboxImage))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Command).To(ConsistOf("/bin/sh"))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Args).To(ConsistOf(
			fmt.Sprintf("%s/copy_api_credentials.sh", shared.PathConfig(client.HomeDir())),
		))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Env).To(ContainElements(
			corev1.EnvVar{
				Name:  shared.EnvDataPath,
				Value: shared.PathData(client.HomeDir()),
			},
			corev1.EnvVar{
				Name:  envApiEmail,
				Value: toCreate.Spec.APICredentials.Email,
			},
			corev1.EnvVar{
				Name:  shared.EnvSecretsPath,
				Value: shared.PathSecrets(client.HomeDir()),
			},
		))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].VolumeMounts).To(ContainElements(
			corev1.VolumeMount{
				Name:      "data",
				MountPath: client.HomeDir(),
			},
			corev1.VolumeMount{
				Name:      "config",
				MountPath: shared.PathConfig(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "secrets",
				MountPath: shared.PathSecrets(client.HomeDir()),
			},
		))
		// node container
		Expect(fetched.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
		Expect(fetched.Spec.Template.Spec.Containers[0].Command).To(Equal(client.Command()))
		Expect(fetched.Spec.Template.Spec.Containers[0].Args).To(Equal(client.Args()))
		Expect(fetched.Spec.Template.Spec.Containers[0].Env).To(Equal(client.Env()))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].VolumeMounts).To(ContainElements(
			corev1.VolumeMount{
				Name:      "data",
				MountPath: client.HomeDir(),
			},
			corev1.VolumeMount{
				Name:      "secrets",
				MountPath: shared.PathSecrets(client.HomeDir()),
			},
		))
	})

	It("Should create allocate correct resources to peer statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(chainlinkv1alpha1.DefaultNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(chainlinkv1alpha1.DefaultNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(chainlinkv1alpha1.DefaultNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(chainlinkv1alpha1.DefaultNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create node configmap", func() {
		fetched := &corev1.ConfigMap{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Data).To(HaveKey("copy_api_credentials.sh"))

	})

	It("Should create node service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "p2p",
					Port:       int32(toCreate.Spec.P2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "api",
					Port:       int32(toCreate.Spec.APIPort),
					TargetPort: intstr.FromString("api"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))

	})

	It("Should create node data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(chainlinkv1alpha1.DefaultNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/chainlink/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	chainlinkv1alpha1 "github.com/kotalco/kotal/apis/chainlink/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

// These tests use Ginkgo (BDD-style Go testing framework). Refer to
// http://onsi.github.io/ginkgo/ to learn more about Ginkgo.

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	// start the test environment
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = chainlinkv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start node reconciler
	nodeReconciler := &NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	nodeReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()
})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	cancel()
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/ethereum/geth_import_account.sh ---
#!/bin/sh

set -e

if [ -z "$(ls -A $KOTAL_DATA_PATH/keystore)" ]
then
	echo "importing account"
	geth account import --datadir $KOTAL_DATA_PATH --password $KOTAL_SECRETS_PATH/account.password $KOTAL_SECRETS_PATH/account.key
else
	echo "account has been imported before!"
fi
'''
'''--- controllers/ethereum/geth_init_genesis.sh ---
#!/bin/sh

set -e

if [ ! -d $KOTAL_DATA_PATH/geth ]
then
	echo "initializing geth genesis block"
	geth init --datadir $KOTAL_DATA_PATH $KOTAL_CONFIG_PATH/genesis.json
else
	echo "genesis block has been initialized before!"
fi
'''
'''--- controllers/ethereum/keystore.go ---
package controllers

import (
	"io/ioutil"
	"os"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/crypto"
)

// KeyStoreFromPrivateKey generates key store from private key (hex without 0x)
func KeyStoreFromPrivateKey(key, password string) (content []byte, err error) {
	dir, err := ioutil.TempDir(os.TempDir(), "tmp")
	if err != nil {
		return
	}
	defer os.RemoveAll(dir)

	ks := keystore.NewKeyStore(dir, keystore.StandardScryptN, keystore.StandardScryptP)
	privateKey, err := crypto.HexToECDSA(key)
	if err != nil {
		return
	}

	acc, err := ks.ImportECDSA(privateKey, password)
	if err != nil {
		return
	}

	content, err = ks.Export(acc, password, password)

	return
}

'''
'''--- controllers/ethereum/nethermind_convert_enode_privatekey.sh ---
#!/bin/sh

set -e

mkdir -p $KOTAL_DATA_PATH

# convert enode private key to binary format
# nethermind doesn't accept text format
# more info: https://discord.com/channels/629004402170134531/629004402170134537/862516237477347338
xxd -r -p -c 32 $KOTAL_SECRETS_PATH/nodekey > $KOTAL_DATA_PATH/kotal_nodekey
'''
'''--- controllers/ethereum/nethermind_copy_keystore.sh ---
#!/bin/sh

set -e

mkdir -p $KOTAL_DATA_PATH/keystore

cp $KOTAL_SECRETS_PATH/account  $KOTAL_DATA_PATH/keystore/key-$KOTAL_COINBASE
'''
'''--- controllers/ethereum/node_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"
	"strings"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	ethereumClients "github.com/kotalco/kotal/clients/ethereum"
	"github.com/kotalco/kotal/controllers/shared"
	"github.com/kotalco/kotal/helpers"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

const (
	envCoinbase = "KOTAL_COINBASE"
)

var (
	//go:embed geth_init_genesis.sh
	GethInitGenesisScript string
	//go:embed geth_import_account.sh
	gethImportAccountScript string
	//go:embed nethermind_convert_enode_privatekey.sh
	nethermindConvertEnodePrivateKeyScript string
	//go:embed nethermind_copy_keystore.sh
	nethermindConvertCopyKeystoreScript string
)

// +kubebuilder:rbac:groups=ethereum.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ethereum.kotal.io,resources=nodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=secrets;services;configmaps;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

// Reconcile reconciles ethereum networks
func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node ethereumv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, string(node.Spec.Client), node.Spec.Network)
	r.updateStaticNodes(ctx, &node)
	r.updateBootnodes(ctx, &node)

	if err = r.reconcilePVC(ctx, &node); err != nil {
		return
	}

	if err = r.reconcileConfigmap(ctx, &node); err != nil {
		return
	}

	ip, err := r.reconcileService(ctx, &node)
	if err != nil {
		return
	}

	if err = r.reconcileStatefulSet(ctx, &node); err != nil {
		return
	}

	var publicKey string
	if publicKey, err = r.reconcileSecret(ctx, &node); err != nil {
		return
	}

	enodeURL := fmt.Sprintf("enode://%s@%s:%d", publicKey, ip, node.Spec.P2PPort)

	if err = r.updateStatus(ctx, &node, enodeURL); err != nil {
		return
	}

	return ctrl.Result{}, nil
}

// getEnodeURL fetch enodeURL from enode that has the format of node.namespace
// name is the node name, and namespace is the node namespace
func (r *NodeReconciler) getEnodeURL(ctx context.Context, enode, ns string) (string, error) {
	node := &ethereumv1alpha1.Node{}
	var name, namespace string

	if parts := strings.Split(enode, "."); len(parts) > 1 {
		name = parts[0]
		namespace = parts[1]
	} else {
		// nodes without . refered to nodes in the current node namespace
		name = enode
		namespace = ns
	}

	namespacedName := types.NamespacedName{
		Name:      name,
		Namespace: namespace,
	}

	if err := r.Client.Get(ctx, namespacedName, node); err != nil {
		return "", err
	}

	return node.Status.EnodeURL, nil
}

// updateStaticNodes replaces Ethereum node references with their enodeURL
func (r *NodeReconciler) updateStaticNodes(ctx context.Context, node *ethereumv1alpha1.Node) {
	log := log.FromContext(ctx)
	for i, enode := range node.Spec.StaticNodes {
		if !strings.HasPrefix(string(enode), "enode://") {
			enodeURL, err := r.getEnodeURL(ctx, string(enode), node.Namespace)
			if err != nil {
				// remove static node reference, so it won't be included into static nodes file
				// don't return the error, node maybe not up and running yet
				node.Spec.StaticNodes = append(node.Spec.StaticNodes[:i], node.Spec.StaticNodes[i+1:]...)
				log.Error(err, "failed to get static node")
				continue
			}
			log.Info("static node enodeURL", string(enode), enodeURL)
			// replace reference with actual enode url
			if strings.HasPrefix(enodeURL, "enode://") {
				node.Spec.StaticNodes[i] = ethereumv1alpha1.Enode(enodeURL)
			} else {
				// remove static node reference, so it won't be included into static nodes file
				node.Spec.StaticNodes = append(node.Spec.StaticNodes[:i], node.Spec.StaticNodes[i+1:]...)
			}
		}
	}
}

// updateBootnodes replaces Ethereum node references with their enodeURL
func (r *NodeReconciler) updateBootnodes(ctx context.Context, node *ethereumv1alpha1.Node) {
	log := log.FromContext(ctx)
	for i, enode := range node.Spec.Bootnodes {
		if !strings.HasPrefix(string(enode), "enode://") {
			enodeURL, err := r.getEnodeURL(ctx, string(enode), node.Namespace)
			if err != nil {
				// remove bootnode reference, so it won't be included into bootnodes
				// don't return the error, node maybe not up and running yet
				node.Spec.Bootnodes = append(node.Spec.Bootnodes[:i], node.Spec.Bootnodes[i+1:]...)
				log.Error(err, "failed to get bootnode")
				continue
			}
			log.Info("bootnode enodeURL", string(enode), enodeURL)
			// replace reference with actual enode url
			if strings.HasPrefix(enodeURL, "enode://") {
				node.Spec.Bootnodes[i] = ethereumv1alpha1.Enode(enodeURL)
			} else {
				// remove bootnode reference, so it won't be included into bootnodes
				node.Spec.Bootnodes = append(node.Spec.Bootnodes[:i], node.Spec.Bootnodes[i+1:]...)
			}
		}
	}
}

// updateStatus updates network status
func (r *NodeReconciler) updateStatus(ctx context.Context, node *ethereumv1alpha1.Node, enodeURL string) error {
	var consensus, network string

	log := log.FromContext(ctx)

	if node.Spec.Genesis == nil {
		switch node.Spec.Network {
		case ethereumv1alpha1.MainNetwork,
			ethereumv1alpha1.RopstenNetwork,
			ethereumv1alpha1.XDaiNetwork,
			ethereumv1alpha1.GoerliNetwork:
			consensus = "pos"
		case ethereumv1alpha1.RinkebyNetwork:
			consensus = "poa"
		}
	} else {
		if node.Spec.Genesis.Ethash != nil {
			consensus = "pow"
		} else if node.Spec.Genesis.Clique != nil {
			consensus = "poa"
		} else if node.Spec.Genesis.IBFT2 != nil {
			consensus = "ibft2"
		}
	}

	node.Status.Consensus = consensus

	if network = node.Spec.Network; network == "" {
		network = "private"
	}

	node.Status.Network = network

	if node.Spec.NodePrivateKeySecretName == "" {
		switch node.Spec.Client {
		case ethereumv1alpha1.BesuClient:
			enodeURL = "call net_enode JSON-RPC method"
		case ethereumv1alpha1.GethClient:
			enodeURL = "call admin_nodeInfo JSON-RPC method"
		case ethereumv1alpha1.NethermindClient:
			enodeURL = "call net_localEnode JSON-RPC method"
		}
	}

	node.Status.EnodeURL = enodeURL

	if err := r.Status().Update(ctx, node); err != nil {
		log.Error(err, "unable to update node status")
		return err
	}

	return nil
}

// specConfigmap updates genesis configmap spec
func (r *NodeReconciler) specConfigmap(node *ethereumv1alpha1.Node, configmap *corev1.ConfigMap, genesis, staticNodes string) {
	if configmap.Data == nil {
		configmap.Data = map[string]string{}
	}

	var key, importAccountScript string

	switch node.Spec.Client {
	case ethereumv1alpha1.GethClient:
		key = "config.toml"
		importAccountScript = gethImportAccountScript
	case ethereumv1alpha1.BesuClient:
		key = "static-nodes.json"
	case ethereumv1alpha1.NethermindClient:
		key = "static-nodes.json"
	}

	if node.Spec.Genesis != nil {
		configmap.Data["genesis.json"] = genesis
		if node.Spec.Client == ethereumv1alpha1.GethClient {
			configmap.Data["geth-init-genesis.sh"] = GethInitGenesisScript
		}
	}

	if node.Spec.Import != nil {
		configmap.Data["import-account.sh"] = importAccountScript
	}

	if node.Spec.Client == ethereumv1alpha1.NethermindClient {
		configmap.Data["nethermind_convert_enode_privatekey.sh"] = nethermindConvertEnodePrivateKeyScript
		configmap.Data["nethermind_copy_keystore.sh"] = nethermindConvertCopyKeystoreScript
	}

	currentStaticNodes := configmap.Data[key]
	// update static nodes config if it's empty
	// update static nodes config if more static nodes has been created
	if currentStaticNodes == "" || len(currentStaticNodes) < len(staticNodes) {
		configmap.Data[key] = staticNodes
	}

	// create empty config for ptivate networks so it won't be ovverriden by
	if node.Spec.Client == ethereumv1alpha1.NethermindClient && node.Spec.Genesis != nil {
		configmap.Data["empty.cfg"] = "{}"
	}

}

// reconcileConfigmap creates genesis config map if it doesn't exist or update it
func (r *NodeReconciler) reconcileConfigmap(ctx context.Context, node *ethereumv1alpha1.Node) error {

	var genesis string

	log := log.FromContext(ctx)

	configmap := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      node.Name,
			Namespace: node.Namespace,
		},
	}

	client, err := ethereumClients.NewClient(node)
	if err != nil {
		return err
	}

	staticNodes := client.EncodeStaticNodes()

	// private network with custom genesis
	if node.Spec.Genesis != nil {

		// create client specific genesis configuration
		if genesis, err = client.Genesis(); err != nil {
			return err
		}
	}

	_, err = ctrl.CreateOrUpdate(ctx, r.Client, configmap, func() error {
		if err := ctrl.SetControllerReference(node, configmap, r.Scheme); err != nil {
			log.Error(err, "Unable to set controller reference on genesis configmap")
			return err
		}

		r.specConfigmap(node, configmap, genesis, staticNodes)

		return nil
	})

	return err
}

// specPVC update node data pvc spec
func (r *NodeReconciler) specPVC(node *ethereumv1alpha1.Node, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(node.Spec.Resources.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = node.GetLabels()
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: node.Spec.Resources.StorageClass,
	}
}

// reconcilePVC creates node data pvc if it doesn't exist
func (r *NodeReconciler) reconcilePVC(ctx context.Context, node *ethereumv1alpha1.Node) error {

	pvc := &corev1.PersistentVolumeClaim{
		ObjectMeta: metav1.ObjectMeta{
			Name:      node.Name,
			Namespace: node.Namespace,
		},
	}

	_, err := ctrl.CreateOrUpdate(ctx, r.Client, pvc, func() error {
		if err := ctrl.SetControllerReference(node, pvc, r.Scheme); err != nil {
			return err
		}
		r.specPVC(node, pvc)
		return nil
	})

	return err
}

// createNodeVolumes creates all the required volumes for the node
func (r *NodeReconciler) createNodeVolumes(node *ethereumv1alpha1.Node) []corev1.Volume {

	volumes := []corev1.Volume{}
	projections := []corev1.VolumeProjection{}

	// authenticated APIs jwt secret
	if node.Spec.JWTSecretName != "" {
		jwtSecretProjection := corev1.VolumeProjection{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.JWTSecretName,
				},
				Items: []corev1.KeyToPath{
					{
						Key:  "secret",
						Path: "jwt.secret",
					},
				},
			},
		}
		projections = append(projections, jwtSecretProjection)
	}

	// nodekey (node private key) projection
	if node.Spec.NodePrivateKeySecretName != "" {
		nodekeyProjection := corev1.VolumeProjection{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.NodePrivateKeySecretName,
				},
				Items: []corev1.KeyToPath{
					{
						Key:  "key",
						Path: "nodekey",
					},
				},
			},
		}
		projections = append(projections, nodekeyProjection)
	}

	// importing ethereum account
	if node.Spec.Import != nil {
		// account private key projection
		privateKeyProjection := corev1.VolumeProjection{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.Import.PrivateKeySecretName,
				},
				Items: []corev1.KeyToPath{
					{
						Key:  "key",
						Path: "account.key",
					},
				},
			},
		}
		projections = append(projections, privateKeyProjection)

		// account password projection
		passwordProjection := corev1.VolumeProjection{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.Import.PasswordSecretName,
				},
				Items: []corev1.KeyToPath{
					{
						Key:  "password",
						Path: "account.password",
					},
				},
			},
		}
		projections = append(projections, passwordProjection)

		// nethermind : account keystore
		if node.Spec.Client == ethereumv1alpha1.NethermindClient {
			accountKeystoreProjection := corev1.VolumeProjection{
				Secret: &corev1.SecretProjection{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: node.Name,
					},
				},
			}
			projections = append(projections, accountKeystoreProjection)
		}
	}

	if len(projections) != 0 {
		secretsVolume := corev1.Volume{
			Name: "secrets",
			VolumeSource: corev1.VolumeSource{
				Projected: &corev1.ProjectedVolumeSource{
					Sources: projections,
				},
			},
		}
		volumes = append(volumes, secretsVolume)
	}

	configVolume := corev1.Volume{
		Name: "config",
		VolumeSource: corev1.VolumeSource{
			ConfigMap: &corev1.ConfigMapVolumeSource{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Name,
				},
			},
		},
	}
	volumes = append(volumes, configVolume)

	dataVolume := corev1.Volume{
		Name: "data",
		VolumeSource: corev1.VolumeSource{
			PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
				ClaimName: node.Name,
			},
		},
	}
	volumes = append(volumes, dataVolume)

	return volumes
}

// createNodeVolumeMounts creates all required volume mounts for the node
func (r *NodeReconciler) createNodeVolumeMounts(node *ethereumv1alpha1.Node, homedir string) []corev1.VolumeMount {

	volumeMounts := []corev1.VolumeMount{}

	if node.Spec.NodePrivateKeySecretName != "" || node.Spec.Import != nil || node.Spec.JWTSecretName != "" {
		secretsMount := corev1.VolumeMount{
			Name:      "secrets",
			MountPath: shared.PathSecrets(homedir),
			ReadOnly:  true,
		}
		volumeMounts = append(volumeMounts, secretsMount)
	}

	configMount := corev1.VolumeMount{
		Name:      "config",
		MountPath: shared.PathConfig(homedir),
		ReadOnly:  true,
	}
	volumeMounts = append(volumeMounts, configMount)

	dataMount := corev1.VolumeMount{
		Name:      "data",
		MountPath: shared.PathData(homedir),
	}
	volumeMounts = append(volumeMounts, dataMount)

	return volumeMounts
}

// specStatefulset updates node statefulset spec
func (r *NodeReconciler) specStatefulset(node *ethereumv1alpha1.Node, sts *appsv1.StatefulSet, homedir string, args []string, volumes []corev1.Volume, volumeMounts []corev1.VolumeMount) {
	labels := node.GetLabels()
	// used by geth to init genesis and import account(s)
	initContainers := []corev1.Container{}

	client := node.Spec.Client
	ports := []corev1.ContainerPort{
		{
			Name:          "discovery",
			ContainerPort: int32(node.Spec.P2PPort),
			Protocol:      corev1.ProtocolUDP,
		},
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
	}

	if node.Spec.RPC {
		ports = append(ports, corev1.ContainerPort{
			Name:          "rpc",
			ContainerPort: int32(node.Spec.RPCPort),
		})
	}

	if node.Spec.WS {
		ports = append(ports, corev1.ContainerPort{
			Name:          "ws",
			ContainerPort: int32(node.Spec.WSPort),
		})
	}

	if node.Spec.Engine {
		ports = append(ports, corev1.ContainerPort{
			Name:          "engine",
			ContainerPort: int32(node.Spec.EnginePort),
		})
	}

	if node.Spec.GraphQL {
		targetPort := node.Spec.GraphQLPort
		if client == ethereumv1alpha1.GethClient {
			targetPort = node.Spec.RPCPort
		}
		ports = append(ports, corev1.ContainerPort{
			Name:          "graphql",
			ContainerPort: int32(targetPort),
		})
	}

	// node client container
	nodeContainer := corev1.Container{
		Name:  "node",
		Image: node.Spec.Image,
		Args:  args,
		Ports: ports,
		Resources: corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(node.Spec.Resources.CPU),
				corev1.ResourceMemory: resource.MustParse(node.Spec.Resources.Memory),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(node.Spec.Resources.CPULimit),
				corev1.ResourceMemory: resource.MustParse(node.Spec.Resources.MemoryLimit),
			},
		},
		VolumeMounts: volumeMounts,
	}

	if node.Spec.Client == ethereumv1alpha1.GethClient {
		if node.Spec.Genesis != nil {
			initGenesis := corev1.Container{
				Name:  "init-geth-genesis",
				Image: node.Spec.Image,
				Env: []corev1.EnvVar{
					{
						Name:  shared.EnvDataPath,
						Value: shared.PathData(homedir),
					},
					{
						Name:  shared.EnvConfigPath,
						Value: shared.PathConfig(homedir),
					},
				},
				Command:      []string{"/bin/sh"},
				Args:         []string{fmt.Sprintf("%s/geth-init-genesis.sh", shared.PathConfig(homedir))},
				VolumeMounts: volumeMounts,
			}
			initContainers = append(initContainers, initGenesis)
		}
		if node.Spec.Import != nil {
			importAccount := corev1.Container{
				Name:  "import-account",
				Image: node.Spec.Image,
				Env: []corev1.EnvVar{
					{
						Name:  shared.EnvDataPath,
						Value: shared.PathData(homedir),
					},
					{
						Name:  shared.EnvSecretsPath,
						Value: shared.PathSecrets(homedir),
					},
				},
				Command:      []string{"/bin/sh"},
				Args:         []string{fmt.Sprintf("%s/import-account.sh", shared.PathConfig(homedir))},
				VolumeMounts: volumeMounts,
			}
			initContainers = append(initContainers, importAccount)
		}

	} else if node.Spec.Client == ethereumv1alpha1.NethermindClient {
		if node.Spec.NodePrivateKeySecretName != "" {
			convertEnodePrivateKey := corev1.Container{
				Name:  "convert-enode-privatekey",
				Image: shared.BusyboxImage,
				Env: []corev1.EnvVar{
					{
						Name:  shared.EnvDataPath,
						Value: shared.PathData(homedir),
					},
					{
						Name:  shared.EnvSecretsPath,
						Value: shared.PathSecrets(homedir),
					},
				},
				Command:      []string{"/bin/sh"},
				Args:         []string{fmt.Sprintf("%s/nethermind_convert_enode_privatekey.sh", shared.PathConfig(homedir))},
				VolumeMounts: volumeMounts,
			}
			initContainers = append(initContainers, convertEnodePrivateKey)
		}

		if node.Spec.Import != nil {
			copyKeystore := corev1.Container{
				Name:  "copy-keystore",
				Image: shared.BusyboxImage,
				Env: []corev1.EnvVar{
					{
						Name:  shared.EnvDataPath,
						Value: shared.PathData(homedir),
					},
					{
						Name:  shared.EnvSecretsPath,
						Value: shared.PathSecrets(homedir),
					},
					{
						Name:  envCoinbase,
						Value: strings.ToLower(string(node.Spec.Coinbase))[2:],
					},
				},
				Command:      []string{"/bin/sh"},
				Args:         []string{fmt.Sprintf("%s/nethermind_copy_keystore.sh", shared.PathConfig(homedir))},
				VolumeMounts: volumeMounts,
			}
			initContainers = append(initContainers, copyKeystore)
		}
	}

	sts.ObjectMeta.Labels = labels
	if sts.Spec.Selector == nil {
		sts.Spec.Selector = &metav1.LabelSelector{}
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec.Replicas = &replicas
	sts.Spec.ServiceName = node.Name
	sts.Spec.Selector.MatchLabels = labels
	sts.Spec.Template.ObjectMeta.Labels = labels
	sts.Spec.Template.Spec = corev1.PodSpec{
		SecurityContext: shared.SecurityContext(),
		Volumes:         volumes,
		InitContainers:  initContainers,
		Containers:      []corev1.Container{nodeContainer},
	}
}

// reconcileStatefulSet creates node statefulset if it doesn't exist, update it if it does exist
func (r *NodeReconciler) reconcileStatefulSet(ctx context.Context, node *ethereumv1alpha1.Node) error {

	sts := &appsv1.StatefulSet{
		ObjectMeta: metav1.ObjectMeta{
			Name:      node.Name,
			Namespace: node.Namespace,
		},
	}

	client, err := ethereumClients.NewClient(node)
	if err != nil {
		return err
	}
	homedir := client.HomeDir()
	args := client.Args()
	args = append(args, node.Spec.ExtraArgs.Encode(false)...)
	volumes := r.createNodeVolumes(node)
	mounts := r.createNodeVolumeMounts(node, homedir)

	_, err = ctrl.CreateOrUpdate(ctx, r.Client, sts, func() error {
		if err := ctrl.SetControllerReference(node, sts, r.Scheme); err != nil {
			return err
		}
		r.specStatefulset(node, sts, homedir, args, volumes, mounts)
		return nil
	})

	return err
}

// specSecret creates keystore from account private key for nethermind client
func (r *NodeReconciler) specSecret(ctx context.Context, node *ethereumv1alpha1.Node, secret *corev1.Secret) error {
	secret.ObjectMeta.Labels = node.GetLabels()

	if node.Spec.Import != nil && node.Spec.Client == ethereumv1alpha1.NethermindClient {
		key := types.NamespacedName{
			Name:      node.Spec.Import.PrivateKeySecretName,
			Namespace: node.Namespace,
		}

		privateKey, err := shared.GetSecret(ctx, r.Client, key, "key")
		if err != nil {
			return err
		}

		key = types.NamespacedName{
			Name:      node.Spec.Import.PasswordSecretName,
			Namespace: node.Namespace,
		}

		password, err := shared.GetSecret(ctx, r.Client, key, "password")
		if err != nil {
			return err
		}

		account, err := KeyStoreFromPrivateKey(privateKey, password)
		if err != nil {
			return err
		}

		secret.Data = map[string][]byte{
			"account": account,
		}
	}

	return nil
}

// reconcileSecret creates node secret if it doesn't exist, update it if it exists
func (r *NodeReconciler) reconcileSecret(ctx context.Context, node *ethereumv1alpha1.Node) (publicKey string, err error) {

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      node.Name,
			Namespace: node.Namespace,
		},
	}

	// pubkey is required by the caller
	// 1. read the private key secret content
	// 2. derive public key from the private key
	if node.Spec.NodePrivateKeySecretName != "" {
		key := types.NamespacedName{
			Name:      node.Spec.NodePrivateKeySecretName,
			Namespace: node.Namespace,
		}

		var nodekey string
		nodekey, err = shared.GetSecret(ctx, r.Client, key, "key")
		if err != nil {
			return
		}

		// hex private key without the leading 0x
		publicKey, err = helpers.DerivePublicKey(nodekey)
		if err != nil {
			return
		}
	}

	_, err = ctrl.CreateOrUpdate(ctx, r.Client, secret, func() error {
		if err := ctrl.SetControllerReference(node, secret, r.Scheme); err != nil {
			return err
		}

		return r.specSecret(ctx, node, secret)
	})

	return
}

// specService updates node service spec
func (r *NodeReconciler) specService(node *ethereumv1alpha1.Node, svc *corev1.Service) {
	labels := node.GetLabels()

	svc.ObjectMeta.Labels = labels
	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "discovery",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("discovery"),
			Protocol:   corev1.ProtocolUDP,
		},
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
	}

	if node.Spec.RPC {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "rpc",
			Port:       int32(node.Spec.RPCPort),
			TargetPort: intstr.FromString("rpc"),
		})
	}

	if node.Spec.WS {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "ws",
			Port:       int32(node.Spec.WSPort),
			TargetPort: intstr.FromString("ws"),
		})
	}

	if node.Spec.Engine {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "engine",
			Port:       int32(node.Spec.EnginePort),
			TargetPort: intstr.FromString("engine"),
		})
	}

	if node.Spec.GraphQL {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "graphql",
			Port:       int32(node.Spec.GraphQLPort),
			TargetPort: intstr.FromString("graphql"),
		})
	}

	svc.Spec.Selector = labels
}

// reconcileService reconciles node service
func (r *NodeReconciler) reconcileService(ctx context.Context, node *ethereumv1alpha1.Node) (ip string, err error) {

	svc := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      node.Name,
			Namespace: node.Namespace,
		},
	}

	_, err = ctrl.CreateOrUpdate(ctx, r.Client, svc, func() error {
		if err = ctrl.SetControllerReference(node, svc, r.Scheme); err != nil {
			return err
		}

		r.specService(node, svc)

		return nil
	})

	if err != nil {
		return
	}

	ip = svc.Spec.ClusterIP

	return
}

// SetupWithManager adds reconciler to the manager
func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	pred := predicate.GenerationChangedPredicate{}
	return ctrl.NewControllerManagedBy(mgr).
		For(&ethereumv1alpha1.Node{}).
		WithEventFilter(pred).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.Service{}).
		Owns(&corev1.Secret{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Owns(&corev1.ConfigMap{}).
		Complete(r)
}

'''
'''--- controllers/ethereum/node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	sharedAPI "github.com/kotalco/kotal/apis/shared"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("Ethereum network controller", func() {

	const (
		sleepTime = 5 * time.Second
		interval  = 2 * time.Second
		timeout   = 2 * time.Minute
		networkID = 7777
		// node private key
		privatekey = "608e9b6f67c65e47531e08e8e501386dfae63a540fa3c48802c8aad854510b4e"
		// imported account
		accountKey      = "5df5eff7ef9e4e82739b68a34c6b23608d79ee8daf3b598a01ffb0dd7aa3a2fd"
		accountAddress  = sharedAPI.EthereumAddress("0x2b3430337f12Ce89EaBC7b0d865F4253c7744c0d")
		accountPassword = "secret"
	)

	var (
		useExistingCluster = os.Getenv(shared.EnvUseExistingCluster) == "true"
	)

	Context("Joining Mainnet", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "mainnet",
			},
		}
		key := types.NamespacedName{
			Name:      "my-node",
			Namespace: ns.Name,
		}

		spec := ethereumv1alpha1.NodeSpec{
			Client:                   ethereumv1alpha1.BesuClient,
			Network:                  "mainnet",
			NodePrivateKeySecretName: "nodekey",
			SyncMode:                 ethereumv1alpha1.FullSynchronization,
			Logging:                  sharedAPI.NoLogs,
		}

		toCreate := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}
		t := true

		nodeOwnerReference := metav1.OwnerReference{
			APIVersion:         "ethereum.kotal.io/v1alpha1",
			Kind:               "Node",
			Name:               toCreate.Name,
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.Background(), ns)).Should(Succeed())
		})

		It("Should create nodekey secret", func() {
			secret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "nodekey",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"key": privatekey,
				},
			}
			Expect(k8sClient.Create(context.Background(), &secret)).To(Succeed())
		})

		It("Should create the node", func() {
			if !useExistingCluster {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should get the node", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			// TODO: test status
			nodeOwnerReference.UID = fetched.GetUID()
		})

		It("Should create node configmap", func() {
			config := &corev1.ConfigMap{}
			Expect(k8sClient.Get(context.Background(), key, config)).Should(Succeed())
			Expect(config.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
		})

		It("Should create node service", func() {
			svc := &corev1.Service{}
			Expect(k8sClient.Get(context.Background(), key, svc)).To(Succeed())
			Expect(svc.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(svc.Spec.Ports).To(ContainElements([]corev1.ServicePort{
				{
					Name:       "discovery",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("discovery"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "p2p",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
			}))
		})

		It("Should create node statefulset with correct arguments", func() {
			sts := &appsv1.StatefulSet{}
			Expect(k8sClient.Get(context.Background(), key, sts)).To(Succeed())
			Expect(sts.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(*sts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(sts.Spec.Template.Spec.Containers[0].Image).To(Equal(toCreate.Spec.Image))
		})

		It("Should allocate correct resources to node statefulset", func() {
			sts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPublicNetworkNodeCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPublicNetworkNodeMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPublicNetworkNodeCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPublicNetworkNodeMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, sts)).To(Succeed())
			Expect(sts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create node data persistent volume with correct resources", func() {
			pvc := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereumv1alpha1.DefaultMainNetworkFullNodeStorageRequest),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, pvc)).To(Succeed())
			Expect(pvc.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(pvc.Spec.Resources).To(Equal(expectedResources))
		})

		It("Should delete the node", func() {
			toDelete := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, toDelete)).To(Succeed())
			Expect(k8sClient.Delete(context.Background(), toDelete)).To(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should not get the node after deletion", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).ToNot(Succeed())
		})

		if useExistingCluster {
			It("Should delete node statefulset", func() {
				nodeSts := &appsv1.StatefulSet{}
				Expect(k8sClient.Get(context.Background(), key, nodeSts)).ToNot(Succeed())
			})

			It("Should delete node service", func() {
				nodeSvc := &corev1.Service{}
				Expect(k8sClient.Get(context.Background(), key, nodeSvc)).ToNot(Succeed())
			})
		}

		It(fmt.Sprintf("should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).Should(Succeed())
		})
	})

	Context("Joining Goerli", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: ethereumv1alpha1.GoerliNetwork,
			},
		}
		key := types.NamespacedName{
			Name:      "my-node",
			Namespace: ns.Name,
		}

		spec := ethereumv1alpha1.NodeSpec{
			Client:                   ethereumv1alpha1.BesuClient,
			Network:                  ethereumv1alpha1.GoerliNetwork,
			NodePrivateKeySecretName: "nodekey",
			Logging:                  sharedAPI.FatalLogs,
		}

		toCreate := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}
		t := true
		nodeOwnerReference := metav1.OwnerReference{
			APIVersion:         "ethereum.kotal.io/v1alpha1",
			Kind:               "Node",
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.Background(), ns)).Should(Succeed())
		})

		It("Should create nodekey secret", func() {
			secret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "nodekey",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"key": privatekey,
				},
			}
			Expect(k8sClient.Create(context.Background(), &secret)).To(Succeed())
		})

		It("Should create account private key and password secrets", func() {
			accountPrivateKeySecret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "my-account-privatekey",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"key": accountKey,
				},
			}
			Expect(k8sClient.Create(context.Background(), &accountPrivateKeySecret)).To(Succeed())

			accountPasswordSecret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "my-account-password",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"password": accountPassword,
				},
			}
			Expect(k8sClient.Create(context.Background(), &accountPasswordSecret)).To(Succeed())
		})

		It("Should create the node", func() {
			if !useExistingCluster {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should get the node", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			nodeOwnerReference.UID = fetched.GetUID()
			nodeOwnerReference.Name = key.Name
		})

		It("Should create node config", func() {
			config := &corev1.ConfigMap{}
			Expect(k8sClient.Get(context.Background(), key, config)).Should(Succeed())
		})

		It("Should create node service", func() {
			svc := &corev1.Service{}
			Expect(k8sClient.Get(context.Background(), key, svc)).To(Succeed())
			Expect(svc.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(svc.Spec.Ports).To(ContainElements([]corev1.ServicePort{
				{
					Name:       "discovery",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("discovery"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "p2p",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
			}))
		})

		It("Should create node statefulset with correct arguments", func() {
			sts := &appsv1.StatefulSet{}
			Expect(k8sClient.Get(context.Background(), key, sts)).To(Succeed())
			Expect(sts.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(*sts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(sts.Spec.Template.Spec.Containers[0].Image).To(Equal(toCreate.Spec.Image))
		})

		It("Should allocate correct resources to node statefulset", func() {
			nodeSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPublicNetworkNodeCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPublicNetworkNodeMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPublicNetworkNodeCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPublicNetworkNodeMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodeSts)).To(Succeed())
			Expect(nodeSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))

		})

		It("Should create bootnode data persistent volume with correct resources", func() {
			nodePVC := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereumv1alpha1.DefaultTestNetworkStorageRequest),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodePVC)).To(Succeed())
			Expect(nodePVC.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(nodePVC.Spec.Resources).To(Equal(expectedResources))
		})

		It("Should delete node", func() {
			toDelete := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, toDelete)).To(Succeed())
			Expect(k8sClient.Delete(context.Background(), toDelete)).To(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should not get node after deletion", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).ToNot(Succeed())
		})

		if useExistingCluster {
			It("Should delete node statefulset", func() {
				nodeSts := &appsv1.StatefulSet{}
				Expect(k8sClient.Get(context.Background(), key, nodeSts)).ToNot(Succeed())
			})

			// TODO: remove this test
			It("Should delete node privatekey secret", func() {
				nodeSecret := &corev1.Secret{}
				Expect(k8sClient.Get(context.Background(), key, nodeSecret)).ToNot(Succeed())
			})

			It("Should delete node service", func() {
				nodeSvc := &corev1.Service{}
				Expect(k8sClient.Get(context.Background(), key, nodeSvc)).ToNot(Succeed())
			})
		}

		It(fmt.Sprintf("should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).Should(Succeed())
		})
	})

	Context("private PoA network", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "poa",
			},
		}
		key := types.NamespacedName{
			Name:      "my-poa-node",
			Namespace: ns.Name,
		}

		spec := ethereumv1alpha1.NodeSpec{
			Genesis: &ethereumv1alpha1.Genesis{
				ChainID:   55555,
				NetworkID: networkID,
				Clique: &ethereumv1alpha1.Clique{
					Signers: []sharedAPI.EthereumAddress{
						sharedAPI.EthereumAddress("0xd2c21213027cbf4d46c16b55fa98e5252b048706"),
					},
				},
			},
			Client:                   ethereumv1alpha1.BesuClient,
			NodePrivateKeySecretName: "nodekey",
		}

		toCreate := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}
		t := true
		nodeOwnerReference := metav1.OwnerReference{
			// TODO: update version
			APIVersion:         "ethereum.kotal.io/v1alpha1",
			Kind:               "Node",
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.Background(), ns)).Should(Succeed())
		})

		It("Should create nodekey secret", func() {
			secret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "nodekey",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"key": privatekey,
				},
			}
			Expect(k8sClient.Create(context.Background(), &secret)).To(Succeed())
		})

		It("Should create account private key and password secrets", func() {
			accountPrivateKeySecret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "my-account-privatekey",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"key": accountKey,
				},
			}
			Expect(k8sClient.Create(context.Background(), &accountPrivateKeySecret)).To(Succeed())

			accountPasswordSecret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "my-account-password",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"password": accountPassword,
				},
			}
			Expect(k8sClient.Create(context.Background(), &accountPasswordSecret)).To(Succeed())
		})

		It("Should create the node", func() {
			if !useExistingCluster {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should get the node", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			nodeOwnerReference.UID = fetched.GetUID()
			nodeOwnerReference.Name = key.Name
		})

		It("Should create node service", func() {
			svc := &corev1.Service{}
			Expect(k8sClient.Get(context.Background(), key, svc)).To(Succeed())
			Expect(svc.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(svc.Spec.Ports).To(ContainElements([]corev1.ServicePort{
				{
					Name:       "discovery",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("discovery"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "p2p",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
			}))
		})

		It("Should create node statefulset with correct arguments", func() {
			nodeSts := &appsv1.StatefulSet{}
			Expect(k8sClient.Get(context.Background(), key, nodeSts)).To(Succeed())
			Expect(nodeSts.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(*nodeSts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(nodeSts.Spec.Template.Spec.Containers[0].Image).To(Equal(toCreate.Spec.Image))
		})

		It("Should create node genesis block config", func() {
			genesisConfig := &corev1.ConfigMap{}
			expectedExtraData := "0x0000000000000000000000000000000000000000000000000000000000000000d2c21213027cbf4d46c16b55fa98e5252b0487060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
			Expect(k8sClient.Get(context.Background(), key, genesisConfig)).To(Succeed())
			Expect(genesisConfig.Data["genesis.json"]).To(ContainSubstring(expectedExtraData))
		})

		It("Should allocate correct resources to node statefulset", func() {
			nodeSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodeSts)).To(Succeed())
			Expect(nodeSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create bootnode data persistent volume with correct resources", func() {
			nodePVC := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeStorageRequest),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodePVC)).To(Succeed())
			Expect(nodePVC.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(nodePVC.Spec.Resources).To(Equal(expectedResources))
		})

		It("Should delete node", func() {
			toDelete := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, toDelete)).To(Succeed())
			Expect(k8sClient.Delete(context.Background(), toDelete)).To(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should not get node after deletion", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).ToNot(Succeed())
		})

		if useExistingCluster {
			It("Should delete node statefulset", func() {
				nodeSts := &appsv1.StatefulSet{}
				Expect(k8sClient.Get(context.Background(), key, nodeSts)).ToNot(Succeed())
			})

			It("Should delete node service", func() {
				nodeSvc := &corev1.Service{}
				Expect(k8sClient.Get(context.Background(), key, nodeSvc)).ToNot(Succeed())
			})

			It("Should delete besu genesis block configmap", func() {
				genesisConfig := &corev1.ConfigMap{}
				genesisKey := types.NamespacedName{
					Name:      fmt.Sprintf("%s-besu", key.Name),
					Namespace: key.Namespace,
				}
				Expect(k8sClient.Get(context.Background(), genesisKey, genesisConfig)).ToNot(Succeed())
			})
		}

		It(fmt.Sprintf("should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).Should(Succeed())
		})
	})

	Context("private PoW network", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "pow",
			},
		}
		key := types.NamespacedName{
			Name:      "my-pow-node",
			Namespace: ns.Name,
		}

		spec := ethereumv1alpha1.NodeSpec{
			Genesis: &ethereumv1alpha1.Genesis{
				ChainID:   55555,
				NetworkID: networkID,
				Ethash:    &ethereumv1alpha1.Ethash{},
			},
			Client:                   ethereumv1alpha1.BesuClient,
			NodePrivateKeySecretName: "nodekey",
			Logging:                  sharedAPI.TraceLogs,
		}

		toCreate := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}
		t := true
		nodeOwnerReference := metav1.OwnerReference{
			// TODO: update version
			APIVersion:         "ethereum.kotal.io/v1alpha1",
			Kind:               "Node",
			Name:               toCreate.Name,
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.Background(), ns)).Should(Succeed())
		})

		It("Should create nodekey secret", func() {
			secret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "nodekey",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"key": privatekey,
				},
			}
			Expect(k8sClient.Create(context.Background(), &secret)).To(Succeed())
		})

		It("Should create account private key and password secrets", func() {
			accountPrivateKeySecret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "my-account-privatekey",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"key": accountKey,
				},
			}
			Expect(k8sClient.Create(context.Background(), &accountPrivateKeySecret)).To(Succeed())

			accountPasswordSecret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "my-account-password",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"password": accountPassword,
				},
			}
			Expect(k8sClient.Create(context.Background(), &accountPasswordSecret)).To(Succeed())
		})

		It("Should create the network", func() {
			if !useExistingCluster {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should create the node", func() {
			node := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, node)).To(Succeed())
			Expect(node.Spec).To(Equal(toCreate.Spec))
			nodeOwnerReference.UID = node.GetUID()
			nodeOwnerReference.Name = key.Name
		})

		It("Should create node genesis block configmap", func() {
			config := &corev1.ConfigMap{}
			Expect(k8sClient.Get(context.Background(), key, config)).To(Succeed())
		})

		It("Should create node service", func() {
			svc := &corev1.Service{}
			Expect(k8sClient.Get(context.Background(), key, svc)).To(Succeed())
			Expect(svc.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(svc.Spec.Ports).To(ContainElements([]corev1.ServicePort{
				{
					Name:       "discovery",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("discovery"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "p2p",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
			}))
		})

		It("Should create node statefulset with correct arguments", func() {
			sts := &appsv1.StatefulSet{}
			Expect(k8sClient.Get(context.Background(), key, sts)).To(Succeed())
			Expect(sts.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(*sts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(sts.Spec.Template.Spec.Containers[0].Image).To(Equal(toCreate.Spec.Image))
		})

		It("Should allocate correct resources to node statefulset", func() {
			nodeSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodeSts)).To(Succeed())
			Expect(nodeSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create node data persistent volume with correct resources", func() {
			pvc := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeStorageRequest),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, pvc)).To(Succeed())
			Expect(pvc.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(pvc.Spec.Resources).To(Equal(expectedResources))
		})

		It("Should delete node", func() {
			toDelete := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, toDelete)).To(Succeed())
			Expect(k8sClient.Delete(context.Background(), toDelete)).To(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should not get node after deletion", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).ToNot(Succeed())
		})

		if useExistingCluster {
			It("Should delete node statefulset", func() {
				nodeSts := &appsv1.StatefulSet{}
				Expect(k8sClient.Get(context.Background(), key, nodeSts)).ToNot(Succeed())
			})

			It("Should delete node service", func() {
				nodeSvc := &corev1.Service{}
				Expect(k8sClient.Get(context.Background(), key, nodeSvc)).ToNot(Succeed())
			})

			It("Should delete besu genesis block configmap", func() {
				genesisConfig := &corev1.ConfigMap{}
				genesisKey := types.NamespacedName{
					Name:      fmt.Sprintf("%s-besu", key.Name),
					Namespace: key.Namespace,
				}
				Expect(k8sClient.Get(context.Background(), genesisKey, genesisConfig)).ToNot(Succeed())
			})
		}

		It(fmt.Sprintf("should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).Should(Succeed())
		})
	})

	Context("private ibft2 network", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "ibft2",
			},
		}
		key := types.NamespacedName{
			Name:      "my-ibft2-node",
			Namespace: ns.Name,
		}

		spec := ethereumv1alpha1.NodeSpec{
			Genesis: &ethereumv1alpha1.Genesis{
				ChainID:   55555,
				NetworkID: networkID,
				IBFT2: &ethereumv1alpha1.IBFT2{
					Validators: []sharedAPI.EthereumAddress{
						"0x427e2c7cecd72bc4cdd4f7ebb8bb6e49789c8044",
						"0xd2c21213027cbf4d46c16b55fa98e5252b048706",
						"0x8e1f6c7c76a1d7f74eda342d330ca9749f31cc2b",
					},
				},
			},
			Client:                   ethereumv1alpha1.BesuClient,
			NodePrivateKeySecretName: "nodekey",
			Logging:                  sharedAPI.WarnLogs,
		}

		toCreate := &ethereumv1alpha1.Node{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}
		t := true

		nodeOwnerReference := metav1.OwnerReference{
			// TODO: update version
			APIVersion:         "ethereum.kotal.io/v1alpha1",
			Kind:               "Node",
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.Background(), ns)).Should(Succeed())
		})

		It("Should create nodekey secret", func() {
			secret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "nodekey",
					Namespace: ns.Name,
				},
				StringData: map[string]string{
					"key": privatekey,
				},
			}
			Expect(k8sClient.Create(context.Background(), &secret)).To(Succeed())
		})

		It("Should create the node", func() {
			if !useExistingCluster {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should get the node", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			nodeOwnerReference.UID = fetched.GetUID()
			nodeOwnerReference.Name = key.Name
		})

		It("Should create node genesis block configmap", func() {
			genesisConfig := &corev1.ConfigMap{}
			expectedExtraData := "0xf869a00000000000000000000000000000000000000000000000000000000000000000f83f94427e2c7cecd72bc4cdd4f7ebb8bb6e49789c804494d2c21213027cbf4d46c16b55fa98e5252b048706948e1f6c7c76a1d7f74eda342d330ca9749f31cc2b808400000000c0"
			Expect(k8sClient.Get(context.Background(), key, genesisConfig)).To(Succeed())
			Expect(genesisConfig.Data["genesis.json"]).To(ContainSubstring(expectedExtraData))
		})

		It("Should create node service", func() {
			nodeSvc := &corev1.Service{}
			Expect(k8sClient.Get(context.Background(), key, nodeSvc)).To(Succeed())
			Expect(nodeSvc.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(nodeSvc.Spec.Ports).To(ContainElements([]corev1.ServicePort{
				{
					Name:       "discovery",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("discovery"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "p2p",
					Port:       int32(ethereumv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
			}))
		})

		It("Should create node statefulset with correct arguments", func() {
			nodeSts := &appsv1.StatefulSet{}
			Expect(k8sClient.Get(context.Background(), key, nodeSts)).To(Succeed())
			Expect(nodeSts.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(*nodeSts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(nodeSts.Spec.Template.Spec.Containers[0].Image).To(Equal(toCreate.Spec.Image))
		})

		It("Should allocate correct resources to bootnode statefulset", func() {
			nodeSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodeSts)).To(Succeed())
			Expect(nodeSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create bootnode data persistent volume with correct resouces", func() {
			nodePVC := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereumv1alpha1.DefaultPrivateNetworkNodeStorageRequest),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodePVC)).To(Succeed())
			Expect(nodePVC.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(nodePVC.Spec.Resources).To(Equal(expectedResources))
		})

		It("Should delete node", func() {
			toDelete := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, toDelete)).To(Succeed())
			Expect(k8sClient.Delete(context.Background(), toDelete)).To(Succeed())
			time.Sleep(sleepTime)
		})

		It("Should not get network after deletion", func() {
			fetched := &ethereumv1alpha1.Node{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).ToNot(Succeed())
		})

		if useExistingCluster {
			It("Should delete node statefulset", func() {
				nodeSts := &appsv1.StatefulSet{}
				Expect(k8sClient.Get(context.Background(), key, nodeSts)).ToNot(Succeed())
			})

			It("Should delete node service", func() {
				nodeSvc := &corev1.Service{}
				Expect(k8sClient.Get(context.Background(), key, nodeSvc)).ToNot(Succeed())
			})

			It("Should delete genesis block configmap", func() {
				genesisConfig := &corev1.ConfigMap{}
				genesisKey := types.NamespacedName{
					Name:      fmt.Sprintf("%s-besu", key.Name),
					Namespace: key.Namespace,
				}
				Expect(k8sClient.Get(context.Background(), genesisKey, genesisConfig)).ToNot(Succeed())
			})
		}

		It(fmt.Sprintf("should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).Should(Succeed())
		})
	})

})

'''
'''--- controllers/ethereum/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

// These tests use Ginkgo (BDD-style Go testing framework). Refer to
// http://onsi.github.io/ginkgo/ to learn more about Ginkgo.

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var nodeReconciler *NodeReconciler
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = ethereumv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	// create a new k8s client
	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start node reconciler
	nodeReconciler = &NodeReconciler{
		Client: k8sManager.GetClient(),
		Scheme: scheme.Scheme,
	}
	nodeReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	cancel()
	By("tearing down the test environment")
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/ethereum/types.go ---
package controllers

'''
'''--- controllers/ethereum2/beacon_node_controller.go ---
package controllers

import (
	"context"
	"fmt"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	ethereum2Clients "github.com/kotalco/kotal/clients/ethereum2"
	"github.com/kotalco/kotal/controllers/shared"
)

// BeaconNodeReconciler reconciles a Node object
type BeaconNodeReconciler struct {
	shared.Reconciler
}

// +kubebuilder:rbac:groups=ethereum2.kotal.io,resources=beaconnodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ethereum2.kotal.io,resources=beaconnodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=services;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

// Reconcile reconciles Ethereum 2.0 beacon node
func (r *BeaconNodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node ethereum2v1alpha1.BeaconNode

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the beacon node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, string(node.Spec.Client), node.Spec.Network)

	// reconcile persistent volume clain
	if err = r.ReconcileOwned(ctx, &node, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&node, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile service
	if err = r.ReconcileOwned(ctx, &node, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&node, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile service
	if err = r.ReconcileOwned(ctx, &node, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client, err := ethereum2Clients.NewClient(&node)
		if err != nil {
			return err
		}

		args := client.Args()
		// encode extra arguments as key=value only if client is numbus
		kv := node.Spec.Client == ethereum2v1alpha1.NimbusClient
		args = append(args, node.Spec.ExtraArgs.Encode(kv)...)
		command := client.Command()
		homeDir := client.HomeDir()

		r.specStatefulset(&node, obj.(*appsv1.StatefulSet), args, command, homeDir)
		return nil
	}); err != nil {
		return
	}

	return
}

func (r *BeaconNodeReconciler) specService(node *ethereum2v1alpha1.BeaconNode, svc *corev1.Service) {
	labels := node.GetLabels()

	svc.ObjectMeta.Labels = labels
	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "discovery",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("discovery"),
			Protocol:   corev1.ProtocolUDP,
		},
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
	}

	if node.Spec.RPC {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "rpc",
			Port:       int32(node.Spec.RPCPort),
			TargetPort: intstr.FromString("rpc"),
		})
	}

	if node.Spec.GRPC {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "grpc",
			Port:       int32(node.Spec.GRPCPort),
			TargetPort: intstr.FromString("grpc"),
		})
	}

	if node.Spec.REST {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "rest",
			Port:       int32(node.Spec.RESTPort),
			TargetPort: intstr.FromString("rest"),
		})
	}

	svc.Spec.Selector = labels
}

// specPVC updates beacon node persistent volume claim spec
func (r *BeaconNodeReconciler) specPVC(node *ethereum2v1alpha1.BeaconNode, pvc *corev1.PersistentVolumeClaim) {

	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(node.Spec.Resources.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.Labels = node.GetLabels()

	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: node.Spec.Resources.StorageClass,
	}
}

// nodeVolumes returns node volumes
func (r *BeaconNodeReconciler) nodeVolumes(node *ethereum2v1alpha1.BeaconNode) (volumes []corev1.Volume) {
	dataVolume := corev1.Volume{
		Name: "data",
		VolumeSource: corev1.VolumeSource{
			PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
				ClaimName: node.Name,
			},
		},
	}
	volumes = append(volumes, dataVolume)

	// projected volume sources
	volumeProjections := []corev1.VolumeProjection{
		{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.JWTSecretName,
				},
				Items: []corev1.KeyToPath{
					{
						Key:  "secret",
						Path: "jwt.secret",
					},
				},
			},
		},
	}

	if node.Spec.CertSecretName != "" {
		volumeProjections = append(volumeProjections, corev1.VolumeProjection{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.CertSecretName,
				},
			},
		})
	}

	volumes = append(volumes, corev1.Volume{
		Name: "secrets",
		VolumeSource: corev1.VolumeSource{
			Projected: &corev1.ProjectedVolumeSource{
				Sources: volumeProjections,
			},
		},
	})

	return
}

// nodeVolumeMounts returns node volume mounts
func (r *BeaconNodeReconciler) nodeVolumeMounts(node *ethereum2v1alpha1.BeaconNode, homeDir string) (mounts []corev1.VolumeMount) {
	dataDir := shared.PathData(homeDir)

	// Nimbus required changing permission of the data dir to be
	// read and write by owner only
	// that's why we mount volume at $HOME
	// but data dir is atatched at $HOME/kota-data
	if node.Spec.Client == ethereum2v1alpha1.NimbusClient {
		dataDir = homeDir
	}

	dataMount := corev1.VolumeMount{
		Name:      "data",
		MountPath: dataDir,
	}
	mounts = append(mounts, dataMount)

	secretMount := corev1.VolumeMount{
		Name:      "secrets",
		MountPath: shared.PathSecrets(homeDir),
	}
	mounts = append(mounts, secretMount)

	return
}

// specStatefulset updates beacon node statefulset spec
func (r *BeaconNodeReconciler) specStatefulset(node *ethereum2v1alpha1.BeaconNode, sts *appsv1.StatefulSet, args, command []string, homeDir string) {

	sts.Labels = node.GetLabels()

	volumes := r.nodeVolumes(node)
	volumeMounts := r.nodeVolumeMounts(node, homeDir)

	initContainers := []corev1.Container{}

	if node.Spec.Client == ethereum2v1alpha1.NimbusClient {
		// Nimbus client requires data dir path to be read and write only by the owner 0700
		fixPermissionContainer := corev1.Container{
			Name:  "fix-datadir-permission",
			Image: node.Spec.Image,
			Command: []string{
				"/bin/sh",
				"-c",
			},
			Args: []string{
				fmt.Sprintf(`
					mkdir -p %s &&
					chmod 700 %s`,
					shared.PathData(homeDir),
					shared.PathData(homeDir),
				),
			},
			VolumeMounts: volumeMounts,
		}
		initContainers = append(initContainers, fixPermissionContainer)

		if node.Spec.CheckpointSyncURL != "" {
			checkpointSyncContainer := corev1.Container{
				Name:    "checkpoint-sync",
				Image:   node.Spec.Image,
				Command: []string{"nimbus_beacon_node", "trustedNodeSync"},
				Args: []string{
					fmt.Sprintf("--network=%s", node.Spec.Network),
					fmt.Sprintf("--data-dir=%s", shared.PathData(homeDir)),
					fmt.Sprintf("--trusted-node-url=%s", node.Spec.CheckpointSyncURL),
				},
				VolumeMounts: volumeMounts,
			}
			initContainers = append(initContainers, checkpointSyncContainer)
		}
	}

	ports := []corev1.ContainerPort{
		{
			Name:          "discovery",
			ContainerPort: int32(node.Spec.P2PPort),
			Protocol:      corev1.ProtocolUDP,
		},
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
	}

	if node.Spec.RPC {
		ports = append(ports, corev1.ContainerPort{
			Name:          "rpc",
			ContainerPort: int32(node.Spec.RPCPort),
		})
	}

	if node.Spec.GRPC {
		ports = append(ports, corev1.ContainerPort{
			Name:          "grpc",
			ContainerPort: int32(node.Spec.GRPCPort),
		})
	}

	if node.Spec.REST {
		ports = append(ports, corev1.ContainerPort{
			Name:          "rest",
			ContainerPort: int32(node.Spec.RESTPort),
		})
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: node.GetLabels(),
		},
		Replicas: &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: node.GetLabels(),
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				InitContainers:  initContainers,
				Containers: []corev1.Container{
					{
						Name:         "node",
						Command:      command,
						Args:         args,
						Ports:        ports,
						Image:        node.Spec.Image,
						VolumeMounts: volumeMounts,
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.Resources.CPU),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Resources.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.Resources.CPULimit),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Resources.MemoryLimit),
							},
						},
					},
				},
				Volumes: volumes,
			},
		},
	}
}

// SetupWithManager adds reconciler to the manager
func (r *BeaconNodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&ethereum2v1alpha1.BeaconNode{}).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.Service{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Complete(r)
}

'''
'''--- controllers/ethereum2/beacon_node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
)

var _ = Describe("Ethereum 2.0 beacon node", func() {

	Context("Joining Mainnet", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "beacon-node",
			},
		}

		key := types.NamespacedName{
			Name:      "my-node",
			Namespace: ns.Name,
		}

		testImage := "kotalco/teku:controller-test"

		spec := ethereum2v1alpha1.BeaconNodeSpec{
			Image:   testImage,
			Client:  ethereum2v1alpha1.TekuClient,
			Network: "mainnet",
		}

		toCreate := &ethereum2v1alpha1.BeaconNode{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}

		t := true

		nodeOwnerReference := metav1.OwnerReference{
			APIVersion:         "ethereum2.kotal.io/v1alpha1",
			Kind:               "BeaconNode",
			Name:               toCreate.Name,
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.TODO(), ns))
		})

		It("Should create beacon node", func() {
			if os.Getenv(shared.EnvUseExistingCluster) != "true" {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
		})

		It("should get beacon node", func() {
			fetched := &ethereum2v1alpha1.BeaconNode{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			nodeOwnerReference.UID = fetched.GetUID()
			time.Sleep(5 * time.Second)
		})

		It("Should create statefulset with correct arguments", func() {
			nodeSts := &appsv1.StatefulSet{}

			Expect(k8sClient.Get(context.Background(), key, nodeSts)).To(Succeed())
			Expect(nodeSts.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(*nodeSts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(nodeSts.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
		})

		It("Should allocate correct resources to bootnode statefulset", func() {
			nodeSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodeSts)).To(Succeed())
			Expect(nodeSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create data persistent volume with correct resources", func() {
			nodePVC := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereum2v1alpha1.DefaultStorage),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, nodePVC)).To(Succeed())
			Expect(nodePVC.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(nodePVC.Spec.Resources).To(Equal(expectedResources))
		})

		It("Should create node service", func() {
			nodeSVC := &corev1.Service{}
			Expect(k8sClient.Get(context.Background(), key, nodeSVC)).To(Succeed())
			Expect(nodeSVC.GetOwnerReferences()).To(ContainElement(nodeOwnerReference))
			Expect(nodeSVC.Spec.Ports).To(ContainElements([]corev1.ServicePort{
				{
					Name:       "discovery",
					Port:       int32(ethereum2v1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("discovery"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "p2p",
					Port:       int32(ethereum2v1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
			}))
		})

		It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
		})

	})
})

'''
'''--- controllers/ethereum2/lighthouse_import_keystore.sh ---
#!/bin/sh

set -e

lighthouse account validator import --datadir ${KOTAL_DATA_PATH} --network ${KOTAL_NETWORK} \
--keystore ${KOTAL_KEY_DIR}/keystore-${KOTAL_KEYSTORE_INDEX}.json \
--reuse-password \
--password-file ${KOTAL_KEY_DIR}/password.txt
'''
'''--- controllers/ethereum2/nimbus_copy_validators.sh ---
#!/bin/sh

set -e

mkdir -p ${KOTAL_VALIDATORS_PATH}
cp -RL ${KOTAL_SECRETS_PATH}/validator-keys ${KOTAL_VALIDATORS_PATH}
cp -RL ${KOTAL_SECRETS_PATH}/validator-secrets ${KOTAL_VALIDATORS_PATH}
'''
'''--- controllers/ethereum2/prysm_import_keystore.sh ---
#!/bin/sh

set -e

validator accounts import --accept-terms-of-use \
--${KOTAL_NETWORK} \
--wallet-dir=${KOTAL_DATA_PATH}/prysm-wallet \
--keys-dir=${KOTAL_KEY_DIR}/keystore-${KOTAL_KEYSTORE_INDEX}.json \
--account-password-file=${KOTAL_KEY_DIR}/password.txt \
--wallet-password-file=${KOTAL_SECRETS_PATH}/prysm-wallet/prysm-wallet-password.txt
'''
'''--- controllers/ethereum2/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

// These tests use Ginkgo (BDD-style Go testing framework). Refer to
// http://onsi.github.io/ginkgo/ to learn more about Ginkgo.

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = ethereum2v1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	// create a new k8s client
	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start beacon node reconciler
	beaconNodeReconciler := &BeaconNodeReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	beaconNodeReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	// start validator reconciler
	validatorReconciler := &ValidatorReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	validatorReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	cancel()
	By("tearing down the test environment")
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/ethereum2/validator_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	ethereum2Clients "github.com/kotalco/kotal/clients/ethereum2"
	"github.com/kotalco/kotal/controllers/shared"
)

// ValidatorReconciler reconciles a Validator object
type ValidatorReconciler struct {
	shared.Reconciler
}

const (
	envNetwork        = "KOTAL_NETWORK"
	envKeyDir         = "KOTAL_KEY_DIR"
	envKeystoreIndex  = "KOTAL_KEYSTORE_INDEX"
	envValidatorsPath = "KOTAL_VALIDATORS_PATH"
)

var (
	//go:embed prysm_import_keystore.sh
	PrysmImportKeyStore string
	//go:embed lighthouse_import_keystore.sh
	LighthouseImportKeyStore string
	//go:embed nimbus_copy_validators.sh
	NimbusCopyValidators string
)

// +kubebuilder:rbac:groups=ethereum2.kotal.io,resources=validators,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ethereum2.kotal.io,resources=validators/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=configmaps;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

// Reconcile reconciles Ethereum 2.0 validator client
func (r *ValidatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var validator ethereum2v1alpha1.Validator

	if err = r.Client.Get(ctx, req.NamespacedName, &validator); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the peer if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		validator.Default()
	}

	shared.UpdateLabels(&validator, string(validator.Spec.Client), validator.Spec.Network)

	// reconcile config map
	if err = r.ReconcileOwned(ctx, &validator, &corev1.ConfigMap{}, func(obj client.Object) error {
		r.specConfigmap(&validator, obj.(*corev1.ConfigMap))
		return nil
	}); err != nil {
		return
	}

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &validator, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&validator, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile stateful set
	if err = r.ReconcileOwned(ctx, &validator, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client, err := ethereum2Clients.NewClient(&validator)
		if err != nil {
			return err
		}

		command := client.Command()
		args := client.Args()
		// encode extra arguments as key=value only if client is numbus
		kv := validator.Spec.Client == ethereum2v1alpha1.NimbusClient
		args = append(args, validator.Spec.ExtraArgs.Encode(kv)...)
		homeDir := client.HomeDir()

		r.specStatefulset(&validator, obj.(*appsv1.StatefulSet), command, args, homeDir)
		return nil
	}); err != nil {
		return
	}

	return
}

// specPVC updates validator persistent volume claim spec
func (r *ValidatorReconciler) specPVC(validator *ethereum2v1alpha1.Validator, pvc *corev1.PersistentVolumeClaim) {

	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(validator.Spec.Resources.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.Labels = validator.GetLabels()

	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: validator.Spec.Resources.StorageClass,
	}
}

// createValidatorVolumes creates validator volumes
func (r *ValidatorReconciler) createValidatorVolumes(validator *ethereum2v1alpha1.Validator) (volumes []corev1.Volume) {

	var volumeProjections []corev1.VolumeProjection

	dataVolume := corev1.Volume{
		Name: "data",
		VolumeSource: corev1.VolumeSource{
			PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
				ClaimName: validator.Name,
			},
		},
	}
	volumes = append(volumes, dataVolume)

	configVolume := corev1.Volume{
		Name: "config",
		VolumeSource: corev1.VolumeSource{
			ConfigMap: &corev1.ConfigMapVolumeSource{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: validator.Name,
				},
			},
		},
	}
	volumes = append(volumes, configVolume)

	// validator key/secret volumes
	for i, keystore := range validator.Spec.Keystores {

		var keystorePath string

		// Nimbus: looking for keystore.json files
		// Prysm: looking for keystore-{any suffix}.json files
		// lighthouse:
		//	- in auto discover mode: looking for voting-keystore.json files
		//	- in validator_defintions.yml: any file name or directory structure can be used
		// teku: indifferernt to file names or directory structure
		if validator.Spec.Client == ethereum2v1alpha1.NimbusClient {
			keystorePath = "keystore.json"
		} else {
			keystorePath = fmt.Sprintf("keystore-%d.json", i)
		}

		// rename the keystore file (available in key "keystore")
		// will take effect after mounting this volume
		keystoreVolume := corev1.Volume{
			Name: keystore.SecretName,
			VolumeSource: corev1.VolumeSource{
				Secret: &corev1.SecretVolumeSource{
					SecretName: keystore.SecretName,
					Items: []corev1.KeyToPath{
						{
							Key:  "keystore",
							Path: keystorePath,
						},
					},
				},
			},
		}

		// nimbus requires that all passwords are in same directory
		// each password file holds the name of the key
		// that's why we're creating aggregate volume projections
		if validator.Spec.Client == ethereum2v1alpha1.NimbusClient {
			volumeProjections = append(volumeProjections, corev1.VolumeProjection{
				Secret: &corev1.SecretProjection{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: keystore.SecretName,
					},
					Items: []corev1.KeyToPath{
						{
							Key:  "password",
							Path: keystore.SecretName,
						},
					},
				},
			})
		} else {
			// update keystore volume with password for other clients
			keystoreVolume.VolumeSource.Secret.Items = append(keystoreVolume.VolumeSource.Secret.Items, corev1.KeyToPath{
				Key:  "password",
				Path: "password.txt",
			})
		}

		volumes = append(volumes, keystoreVolume)

	}
	// end of keystores loop

	// nimbus: create projected volume that holds all secrets
	if validator.Spec.Client == ethereum2v1alpha1.NimbusClient {
		validatorSecretsVolume := corev1.Volume{
			Name: "validator-secrets",
			VolumeSource: corev1.VolumeSource{
				Projected: &corev1.ProjectedVolumeSource{
					Sources: volumeProjections,
				},
			},
		}
		volumes = append(volumes, validatorSecretsVolume)
	}

	// prysm: wallet password volume
	if validator.Spec.Client == ethereum2v1alpha1.PrysmClient {
		walletPasswordVolume := corev1.Volume{
			// TODO: rename volume name to prysm-wallet-password
			Name: validator.Spec.WalletPasswordSecret,
			VolumeSource: corev1.VolumeSource{
				Secret: &corev1.SecretVolumeSource{
					SecretName: validator.Spec.WalletPasswordSecret,
					Items: []corev1.KeyToPath{
						{
							Key:  "password",
							Path: "prysm-wallet-password.txt",
						},
					},
				},
			},
		}
		volumes = append(volumes, walletPasswordVolume)

		// tls certificate
		if validator.Spec.CertSecretName != "" {
			certVolume := corev1.Volume{
				Name: "cert",
				VolumeSource: corev1.VolumeSource{
					Secret: &corev1.SecretVolumeSource{
						SecretName: validator.Spec.CertSecretName,
					},
				},
			}
			volumes = append(volumes, certVolume)
		}
	}

	return
}

// createValidatorVolumeMounts creates validator volume mounts
// secrets-dir/
// |___validator-keys/
// |		|__key-name
// |			|_ keystore[-n].json
// |			|_ password.txt
// |___validator-secrets/
// |		|_ key-name-1.txt
// |		|_ key-name-n.txt
// |___prysm-wallet
// |        |_prysm-wallet-pasword.txt
func (r *ValidatorReconciler) createValidatorVolumeMounts(validator *ethereum2v1alpha1.Validator, homeDir string) (mounts []corev1.VolumeMount) {
	dataMount := corev1.VolumeMount{
		Name:      "data",
		MountPath: shared.PathData(homeDir),
	}
	mounts = append(mounts, dataMount)

	configMount := corev1.VolumeMount{
		Name:      "config",
		MountPath: shared.PathConfig(homeDir),
	}
	mounts = append(mounts, configMount)

	for _, keystore := range validator.Spec.Keystores {

		keystoreMount := corev1.VolumeMount{
			Name:      keystore.SecretName,
			MountPath: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(homeDir), keystore.SecretName),
		}
		mounts = append(mounts, keystoreMount)
	}

	// prysm wallet password
	if validator.Spec.Client == ethereum2v1alpha1.PrysmClient {
		walletPasswordMount := corev1.VolumeMount{
			Name:      validator.Spec.WalletPasswordSecret,
			ReadOnly:  true,
			MountPath: fmt.Sprintf("%s/prysm-wallet", shared.PathSecrets(homeDir)),
		}
		mounts = append(mounts, walletPasswordMount)

		if validator.Spec.CertSecretName != "" {
			certMount := corev1.VolumeMount{
				Name:      "cert",
				ReadOnly:  true,
				MountPath: fmt.Sprintf("%s/cert", shared.PathSecrets(homeDir)),
			}
			mounts = append(mounts, certMount)
		}
	}

	// nimbus client
	if validator.Spec.Client == ethereum2v1alpha1.NimbusClient {
		ValidatorSecretsMount := corev1.VolumeMount{
			Name:      "validator-secrets",
			MountPath: fmt.Sprintf("%s/validator-secrets", shared.PathSecrets(homeDir)),
		}
		mounts = append(mounts, ValidatorSecretsMount)
	}

	return
}

// specStatefulset updates vvalidator statefulset spec
func (r *ValidatorReconciler) specStatefulset(validator *ethereum2v1alpha1.Validator, sts *appsv1.StatefulSet, command, args []string, homeDir string) {

	sts.Labels = validator.GetLabels()

	initContainers := []corev1.Container{}

	mounts := r.createValidatorVolumeMounts(validator, homeDir)

	// prysm: import validator keys from secrets dir
	// keystores are imported into wallet after being decrypted with keystore secret
	// then encrypted with wallet password
	if validator.Spec.Client == ethereum2v1alpha1.PrysmClient {
		for i, keystore := range validator.Spec.Keystores {
			keyDir := fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(homeDir), keystore.SecretName)
			importKeystoreContainer := corev1.Container{
				Name:  fmt.Sprintf("import-keystore-%s", keystore.SecretName),
				Image: validator.Spec.Image,
				Env: []corev1.EnvVar{
					{
						Name:  envNetwork,
						Value: validator.Spec.Network,
					},
					{
						Name:  shared.EnvDataPath,
						Value: shared.PathData(homeDir),
					},
					{
						Name:  envKeyDir,
						Value: keyDir,
					},
					{
						Name:  envKeystoreIndex,
						Value: fmt.Sprintf("%d", i),
					},
					{
						Name:  shared.EnvSecretsPath,
						Value: shared.PathSecrets(homeDir),
					},
				},
				Command:      []string{"/bin/sh"},
				Args:         []string{fmt.Sprintf("%s/prysm_import_keystore.sh", shared.PathConfig(homeDir))},
				VolumeMounts: mounts,
			}
			initContainers = append(initContainers, importKeystoreContainer)
		}
	}

	if validator.Spec.Client == ethereum2v1alpha1.LighthouseClient {
		for i, keystore := range validator.Spec.Keystores {
			keyDir := fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(homeDir), keystore.SecretName)
			importKeystoreContainer := corev1.Container{
				Name:  fmt.Sprintf("import-keystore-%s", keystore.SecretName),
				Image: validator.Spec.Image,
				Env: []corev1.EnvVar{
					{
						Name:  envNetwork,
						Value: validator.Spec.Network,
					},
					{
						Name:  shared.EnvDataPath,
						Value: shared.PathData(homeDir),
					},
					{
						Name:  envKeyDir,
						Value: keyDir,
					},
					{
						Name:  envKeystoreIndex,
						Value: fmt.Sprintf("%d", i),
					},
				},
				Command:      []string{"/bin/sh"},
				Args:         []string{fmt.Sprintf("%s/lighthouse_import_keystore.sh", shared.PathConfig(homeDir))},
				VolumeMounts: mounts,
			}
			initContainers = append(initContainers, importKeystoreContainer)

		}
		// TODO: delete validator definitions file
	}

	if validator.Spec.Client == ethereum2v1alpha1.NimbusClient {
		// copy secrets into rw directory under blockchain data directory
		validatorsPath := fmt.Sprintf("%s/kotal-validators", shared.PathData(homeDir))
		copyValidators := corev1.Container{
			Name:  "copy-validators",
			Image: validator.Spec.Image,
			Env: []corev1.EnvVar{
				{
					Name:  shared.EnvSecretsPath,
					Value: shared.PathSecrets(homeDir),
				},
				{
					Name:  envValidatorsPath,
					Value: validatorsPath,
				},
			},
			Command:      []string{"/bin/sh"},
			Args:         []string{fmt.Sprintf("%s/nimbus_copy_validators.sh", shared.PathConfig(homeDir))},
			VolumeMounts: mounts,
		}
		initContainers = append(initContainers, copyValidators)
	}

	replicas := int32(*validator.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: validator.GetLabels(),
		},
		Replicas: &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: validator.GetLabels(),
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				Containers: []corev1.Container{
					{
						Name:         "validator",
						Image:        validator.Spec.Image,
						Command:      command,
						Args:         args,
						VolumeMounts: mounts,
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(validator.Spec.Resources.CPU),
								corev1.ResourceMemory: resource.MustParse(validator.Spec.Resources.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(validator.Spec.Resources.CPULimit),
								corev1.ResourceMemory: resource.MustParse(validator.Spec.Resources.MemoryLimit),
							},
						},
					},
				},
				InitContainers: initContainers,
				Volumes:        r.createValidatorVolumes(validator),
			},
		},
	}
}

// specConfigmap updates validator configmap spec
func (r *ValidatorReconciler) specConfigmap(validator *ethereum2v1alpha1.Validator, configmap *corev1.ConfigMap) {
	if configmap.Data == nil {
		configmap.Data = map[string]string{}
	}

	switch validator.Spec.Client {
	case ethereum2v1alpha1.PrysmClient:
		configmap.Data["prysm_import_keystore.sh"] = PrysmImportKeyStore
	case ethereum2v1alpha1.LighthouseClient:
		configmap.Data["lighthouse_import_keystore.sh"] = LighthouseImportKeyStore
	case ethereum2v1alpha1.NimbusClient:
		configmap.Data["nimbus_copy_validators.sh"] = NimbusCopyValidators
	}

}

// SetupWithManager adds reconciler to the manager
func (r *ValidatorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&ethereum2v1alpha1.Validator{}).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.ConfigMap{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Complete(r)
}

'''
'''--- controllers/ethereum2/validator_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/types"

	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	ethereum2Clients "github.com/kotalco/kotal/clients/ethereum2"
	"github.com/kotalco/kotal/controllers/shared"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
)

var _ = Describe("Ethereum 2.0 validator client", func() {

	Context("Teku validator client", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "teku",
			},
		}

		key := types.NamespacedName{
			Name:      "teku-validator",
			Namespace: ns.Name,
		}

		testImage := "kotalco/teku:test"

		spec := ethereum2v1alpha1.ValidatorSpec{
			Image:           testImage,
			Network:         "mainnet",
			Client:          ethereum2v1alpha1.TekuClient,
			BeaconEndpoints: []string{"http://10.96.130.88:9999"},
			Graffiti:        "testing Kotal validator controller",
			Keystores: []ethereum2v1alpha1.Keystore{
				{
					SecretName: "my-validator",
				},
			},
		}

		toCreate := &ethereum2v1alpha1.Validator{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}

		t := true

		validatorOwnerReference := metav1.OwnerReference{
			APIVersion:         "ethereum2.kotal.io/v1alpha1",
			Kind:               "Validator",
			Name:               toCreate.Name,
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.TODO(), ns))
		})

		It("Should create validator client", func() {
			if os.Getenv(shared.EnvUseExistingCluster) != "true" {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
		})

		It("should get validator client", func() {
			fetched := &ethereum2v1alpha1.Validator{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			validatorOwnerReference.UID = fetched.GetUID()
			time.Sleep(5 * time.Second)
		})

		It("Should create statefulset", func() {
			validatorSts := &appsv1.StatefulSet{}

			Expect(k8sClient.Get(context.Background(), key, validatorSts)).To(Succeed())
			Expect(validatorSts.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(*validatorSts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(validatorSts.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
			// container volume mounts
			Expect(validatorSts.Spec.Template.Spec.Containers[0].VolumeMounts).To(ContainElements(
				corev1.VolumeMount{
					Name:      "data",
					MountPath: shared.PathData(ethereum2Clients.TekuHomeDir),
				},
				corev1.VolumeMount{
					Name:      "config",
					MountPath: shared.PathConfig(ethereum2Clients.TekuHomeDir),
				},
				corev1.VolumeMount{
					Name:      "my-validator",
					MountPath: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.TekuHomeDir), "my-validator"),
				},
			))
			// container volume
			mode := corev1.ConfigMapVolumeSourceDefaultMode
			Expect(validatorSts.Spec.Template.Spec.Volumes).To(ContainElements(
				corev1.Volume{
					Name: "data",
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: validatorSts.Name,
						},
					},
				},
				corev1.Volume{
					Name: "config",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{Name: validatorSts.Name},
							DefaultMode:          &mode,
						},
					},
				},
				corev1.Volume{
					Name: "my-validator",
					VolumeSource: corev1.VolumeSource{
						Secret: &corev1.SecretVolumeSource{
							SecretName: "my-validator",
							Items: []corev1.KeyToPath{
								{
									Key:  "keystore",
									Path: "keystore-0.json",
								},
								{
									Key:  "password",
									Path: "password.txt",
								},
							},
							DefaultMode: &mode,
						},
					},
				},
			))
			// teku doesn't require init containers
		})

		It("Should allocate correct resources to validator statefulset", func() {
			validatorSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, validatorSts)).To(Succeed())
			Expect(validatorSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create validator configmap", func() {
			configmap := &corev1.ConfigMap{}
			Expect(k8sClient.Get(context.Background(), key, configmap)).To(Succeed())
			Expect(configmap.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
		})

		It("Should create data persistent volume with correct resources", func() {
			validatorPVC := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereum2v1alpha1.DefaultStorage),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, validatorPVC)).To(Succeed())
			Expect(validatorPVC.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(validatorPVC.Spec.Resources).To(Equal(expectedResources))
		})

		It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
		})

	})

	Context("Prysm validator client", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "prysm",
			},
		}

		key := types.NamespacedName{
			Name:      "prysm-validator",
			Namespace: ns.Name,
		}

		testImage := "kotalco/prysm:test"

		spec := ethereum2v1alpha1.ValidatorSpec{
			Image:                testImage,
			Network:              "mainnet",
			Client:               ethereum2v1alpha1.PrysmClient,
			BeaconEndpoints:      []string{"http://10.96.130.88:9999"},
			Graffiti:             "testing Kotal validator controller",
			WalletPasswordSecret: "my-wallet-password",
			Keystores: []ethereum2v1alpha1.Keystore{
				{
					SecretName: "my-validator",
				},
			},
			CertSecretName: "my-cert",
		}

		toCreate := &ethereum2v1alpha1.Validator{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}

		t := true

		validatorOwnerReference := metav1.OwnerReference{
			APIVersion:         "ethereum2.kotal.io/v1alpha1",
			Kind:               "Validator",
			Name:               toCreate.Name,
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.TODO(), ns))
		})

		It("Should create validator client", func() {
			if os.Getenv(shared.EnvUseExistingCluster) != "true" {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
		})

		It("should get validator client", func() {
			fetched := &ethereum2v1alpha1.Validator{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			validatorOwnerReference.UID = fetched.GetUID()
			time.Sleep(5 * time.Second)
		})

		It("Should create statefulset", func() {
			validatorSts := &appsv1.StatefulSet{}

			Expect(k8sClient.Get(context.Background(), key, validatorSts)).To(Succeed())
			Expect(validatorSts.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(*validatorSts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(validatorSts.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
			// container volume mounts
			Expect(validatorSts.Spec.Template.Spec.Containers[0].VolumeMounts).To(ContainElements(
				corev1.VolumeMount{
					Name:      "data",
					MountPath: shared.PathData(ethereum2Clients.PrysmHomeDir),
				},
				corev1.VolumeMount{
					Name:      "config",
					MountPath: shared.PathConfig(ethereum2Clients.PrysmHomeDir),
				},
				corev1.VolumeMount{
					Name:      "my-validator",
					MountPath: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.PrysmHomeDir), "my-validator"),
				},
				corev1.VolumeMount{
					Name:      "my-wallet-password",
					ReadOnly:  true,
					MountPath: fmt.Sprintf("%s/prysm-wallet", shared.PathSecrets(ethereum2Clients.PrysmHomeDir)),
				},
				corev1.VolumeMount{
					Name:      "cert",
					ReadOnly:  true,
					MountPath: fmt.Sprintf("%s/cert", shared.PathSecrets(ethereum2Clients.PrysmHomeDir)),
				},
			))
			// container volume
			mode := corev1.ConfigMapVolumeSourceDefaultMode
			Expect(validatorSts.Spec.Template.Spec.Volumes).To(ContainElements(
				corev1.Volume{
					Name: "data",
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: validatorSts.Name,
						},
					},
				},
				corev1.Volume{
					Name: "config",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{Name: validatorSts.Name},
							DefaultMode:          &mode,
						},
					},
				},
				corev1.Volume{
					Name: "my-validator",
					VolumeSource: corev1.VolumeSource{
						Secret: &corev1.SecretVolumeSource{
							SecretName: "my-validator",
							Items: []corev1.KeyToPath{
								{
									Key:  "keystore",
									Path: "keystore-0.json",
								},
								{
									Key:  "password",
									Path: "password.txt",
								},
							},
							DefaultMode: &mode,
						},
					},
				},
				corev1.Volume{
					Name: "my-wallet-password",
					VolumeSource: corev1.VolumeSource{
						Secret: &corev1.SecretVolumeSource{
							SecretName: "my-wallet-password",
							Items: []corev1.KeyToPath{
								{
									Key:  "password",
									Path: "prysm-wallet-password.txt",
								},
							},
							DefaultMode: &mode,
						},
					},
				},
				corev1.Volume{
					Name: "cert",
					VolumeSource: corev1.VolumeSource{
						Secret: &corev1.SecretVolumeSource{
							SecretName:  toCreate.Spec.CertSecretName,
							DefaultMode: &mode,
						},
					},
				},
			))
			// init containers
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Image).To(Equal(testImage))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Env).To(ContainElements(
				corev1.EnvVar{
					Name:  envNetwork,
					Value: "mainnet",
				},
				corev1.EnvVar{
					Name:  shared.EnvDataPath,
					Value: shared.PathData(ethereum2Clients.PrysmHomeDir),
				},
				corev1.EnvVar{
					Name:  envKeyDir,
					Value: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.PrysmHomeDir), "my-validator"),
				},
				corev1.EnvVar{
					Name:  envKeystoreIndex,
					Value: "0",
				},
				corev1.EnvVar{
					Name:  shared.EnvSecretsPath,
					Value: shared.PathSecrets(ethereum2Clients.PrysmHomeDir),
				},
			))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Command).To(ConsistOf("/bin/sh"))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Args).To(ConsistOf(
				fmt.Sprintf("%s/prysm_import_keystore.sh", shared.PathConfig(ethereum2Clients.PrysmHomeDir))),
			)
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].VolumeMounts).To(ContainElements(
				corev1.VolumeMount{
					Name:      "data",
					MountPath: shared.PathData(ethereum2Clients.PrysmHomeDir),
				},
				corev1.VolumeMount{
					Name:      "config",
					MountPath: shared.PathConfig(ethereum2Clients.PrysmHomeDir),
				},
				corev1.VolumeMount{
					Name:      "my-validator",
					MountPath: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.PrysmHomeDir), "my-validator"),
				},
				corev1.VolumeMount{
					Name:      "my-wallet-password",
					ReadOnly:  true,
					MountPath: fmt.Sprintf("%s/prysm-wallet", shared.PathSecrets(ethereum2Clients.PrysmHomeDir)),
				},
			))

		})

		It("Should allocate correct resources to validator statefulset", func() {
			validatorSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, validatorSts)).To(Succeed())
			Expect(validatorSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create validator configmap", func() {
			configmap := &corev1.ConfigMap{}
			Expect(k8sClient.Get(context.Background(), key, configmap)).To(Succeed())
			Expect(configmap.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(configmap.Data).To(HaveKey("prysm_import_keystore.sh"))
		})

		It("Should create data persistent volume with correct resources", func() {
			validatorPVC := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereum2v1alpha1.DefaultStorage),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, validatorPVC)).To(Succeed())
			Expect(validatorPVC.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(validatorPVC.Spec.Resources).To(Equal(expectedResources))
		})

		It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
		})

	})

	Context("Lighthouse validator client", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "lighthouse",
			},
		}

		key := types.NamespacedName{
			Name:      "lighthouse-validator",
			Namespace: ns.Name,
		}

		testImage := "kotalco/lighthouse:test"

		spec := ethereum2v1alpha1.ValidatorSpec{
			Image:                testImage,
			Network:              "mainnet",
			Client:               ethereum2v1alpha1.LighthouseClient,
			BeaconEndpoints:      []string{"http://10.96.130.88:9999"},
			Graffiti:             "testing Kotal validator controller",
			WalletPasswordSecret: "my-wallet-password",
			Keystores: []ethereum2v1alpha1.Keystore{
				{
					SecretName: "my-validator",
					PublicKey:  "0x83dbb18e088cb16a07fca598db2ac24da3e8549601eedd75eb28d8a9d4be405f49f7dbdcad5c9d7df54a8a40a143e852",
				},
			},
		}

		toCreate := &ethereum2v1alpha1.Validator{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}

		t := true

		validatorOwnerReference := metav1.OwnerReference{
			APIVersion:         "ethereum2.kotal.io/v1alpha1",
			Kind:               "Validator",
			Name:               toCreate.Name,
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.TODO(), ns))
		})

		It("Should create validator client", func() {
			if os.Getenv(shared.EnvUseExistingCluster) != "true" {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
		})

		It("should get validator client", func() {
			fetched := &ethereum2v1alpha1.Validator{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			validatorOwnerReference.UID = fetched.GetUID()
			time.Sleep(5 * time.Second)
		})

		It("Should create statefulset", func() {
			validatorSts := &appsv1.StatefulSet{}

			Expect(k8sClient.Get(context.Background(), key, validatorSts)).To(Succeed())
			Expect(validatorSts.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(*validatorSts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(validatorSts.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
			// container volume mounts
			Expect(validatorSts.Spec.Template.Spec.Containers[0].VolumeMounts).To(ContainElements(
				corev1.VolumeMount{
					Name:      "data",
					MountPath: shared.PathData(ethereum2Clients.LighthouseHomeDir),
				},
				corev1.VolumeMount{
					Name:      "config",
					MountPath: shared.PathConfig(ethereum2Clients.LighthouseHomeDir),
				},
				corev1.VolumeMount{
					Name:      "my-validator",
					MountPath: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.LighthouseHomeDir), "my-validator"),
				},
			))
			// container volume
			mode := corev1.ConfigMapVolumeSourceDefaultMode
			Expect(validatorSts.Spec.Template.Spec.Volumes).To(ContainElements(
				corev1.Volume{
					Name: "data",
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: validatorSts.Name,
						},
					},
				},
				corev1.Volume{
					Name: "config",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{Name: validatorSts.Name},
							DefaultMode:          &mode,
						},
					},
				},
				corev1.Volume{
					Name: "my-validator",
					VolumeSource: corev1.VolumeSource{
						Secret: &corev1.SecretVolumeSource{
							SecretName: "my-validator",
							Items: []corev1.KeyToPath{
								{
									Key:  "keystore",
									Path: "keystore-0.json",
								},
								{
									Key:  "password",
									Path: "password.txt",
								},
							},
							DefaultMode: &mode,
						},
					},
				},
			))
			// init containers
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Image).To(Equal(testImage))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Env).To(ContainElements(
				corev1.EnvVar{
					Name:  envNetwork,
					Value: "mainnet",
				},
				corev1.EnvVar{
					Name:  shared.EnvDataPath,
					Value: shared.PathData(ethereum2Clients.LighthouseHomeDir),
				},
				corev1.EnvVar{
					Name:  envKeyDir,
					Value: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.LighthouseHomeDir), "my-validator"),
				},
				corev1.EnvVar{
					Name:  envKeystoreIndex,
					Value: "0",
				},
			))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Command).To(ConsistOf("/bin/sh"))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Args).To(ConsistOf(
				fmt.Sprintf("%s/lighthouse_import_keystore.sh", shared.PathConfig(ethereum2Clients.LighthouseHomeDir))),
			)
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].VolumeMounts).To(ContainElements(
				corev1.VolumeMount{
					Name:      "data",
					MountPath: shared.PathData(ethereum2Clients.LighthouseHomeDir),
				},
				corev1.VolumeMount{
					Name:      "config",
					MountPath: shared.PathConfig(ethereum2Clients.LighthouseHomeDir),
				},
				corev1.VolumeMount{
					Name:      "my-validator",
					MountPath: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.LighthouseHomeDir), "my-validator"),
				},
			))

		})

		It("Should allocate correct resources to validator statefulset", func() {
			validatorSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, validatorSts)).To(Succeed())
			Expect(validatorSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create validator configmap", func() {
			configmap := &corev1.ConfigMap{}
			Expect(k8sClient.Get(context.Background(), key, configmap)).To(Succeed())
			Expect(configmap.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(configmap.Data).To(HaveKey("lighthouse_import_keystore.sh"))
		})

		It("Should create data persistent volume with correct resources", func() {
			validatorPVC := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereum2v1alpha1.DefaultStorage),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, validatorPVC)).To(Succeed())
			Expect(validatorPVC.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(validatorPVC.Spec.Resources).To(Equal(expectedResources))
		})

		It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
		})

	})

	Context("Nimbus validator client", func() {
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "nimbus",
			},
		}

		key := types.NamespacedName{
			Name:      "nimbus-validator",
			Namespace: ns.Name,
		}

		testImage := "kotalco/nimbus:test"

		spec := ethereum2v1alpha1.ValidatorSpec{
			Image:                testImage,
			Network:              "mainnet",
			Client:               ethereum2v1alpha1.NimbusClient,
			BeaconEndpoints:      []string{"http://10.96.130.88:9999"},
			Graffiti:             "testing Kotal validator controller",
			WalletPasswordSecret: "my-wallet-password",
			Keystores: []ethereum2v1alpha1.Keystore{
				{
					SecretName: "my-validator",
				},
			},
		}

		toCreate := &ethereum2v1alpha1.Validator{
			ObjectMeta: metav1.ObjectMeta{
				Name:      key.Name,
				Namespace: key.Namespace,
			},
			Spec: spec,
		}

		t := true

		validatorOwnerReference := metav1.OwnerReference{
			APIVersion:         "ethereum2.kotal.io/v1alpha1",
			Kind:               "Validator",
			Name:               toCreate.Name,
			Controller:         &t,
			BlockOwnerDeletion: &t,
		}

		It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
			Expect(k8sClient.Create(context.TODO(), ns))
		})

		It("Should create validator client", func() {
			if os.Getenv(shared.EnvUseExistingCluster) != "true" {
				toCreate.Default()
			}
			Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
		})

		It("should get validator client", func() {
			fetched := &ethereum2v1alpha1.Validator{}
			Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
			Expect(fetched.Spec).To(Equal(toCreate.Spec))
			validatorOwnerReference.UID = fetched.GetUID()
			time.Sleep(5 * time.Second)
		})

		It("Should create statefulset", func() {
			validatorSts := &appsv1.StatefulSet{}

			Expect(k8sClient.Get(context.Background(), key, validatorSts)).To(Succeed())
			Expect(validatorSts.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(*validatorSts.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
				"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
				"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
				"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
				"RunAsNonRoot": gstruct.PointTo(Equal(true)),
			}))
			Expect(validatorSts.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
			// container volume mounts
			Expect(validatorSts.Spec.Template.Spec.Containers[0].VolumeMounts).To(ContainElements(
				corev1.VolumeMount{
					Name:      "data",
					MountPath: shared.PathData(ethereum2Clients.NimbusHomeDir),
				},
				corev1.VolumeMount{
					Name:      "config",
					MountPath: shared.PathConfig(ethereum2Clients.NimbusHomeDir),
				},
				corev1.VolumeMount{
					Name:      "my-validator",
					MountPath: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.NimbusHomeDir), "my-validator"),
				},
				corev1.VolumeMount{
					Name:      "validator-secrets",
					MountPath: fmt.Sprintf("%s/validator-secrets", shared.PathSecrets(ethereum2Clients.NimbusHomeDir)),
				},
			))
			// container volume
			mode := corev1.ConfigMapVolumeSourceDefaultMode
			fmt.Sprintln(validatorSts.Spec.Template.Spec.Volumes)
			Expect(validatorSts.Spec.Template.Spec.Volumes).To(ContainElements(
				corev1.Volume{
					Name: "data",
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: validatorSts.Name,
						},
					},
				},
				corev1.Volume{
					Name: "config",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{Name: validatorSts.Name},
							DefaultMode:          &mode,
						},
					},
				},
				corev1.Volume{
					Name: "my-validator",
					VolumeSource: corev1.VolumeSource{
						Secret: &corev1.SecretVolumeSource{
							SecretName: "my-validator",
							Items: []corev1.KeyToPath{
								{
									Key:  "keystore",
									Path: "keystore.json",
								},
							},
							DefaultMode: &mode,
						},
					},
				},
				corev1.Volume{
					Name: "validator-secrets",
					VolumeSource: corev1.VolumeSource{
						Projected: &corev1.ProjectedVolumeSource{
							Sources: []corev1.VolumeProjection{
								{
									Secret: &corev1.SecretProjection{
										LocalObjectReference: corev1.LocalObjectReference{
											Name: "my-validator",
										},
										Items: []corev1.KeyToPath{
											{
												Key:  "password",
												Path: "my-validator",
											},
										},
									},
								},
							},
							DefaultMode: &mode,
						},
					},
				},
			))
			// init containers
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Image).To(Equal(testImage))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Env).To(ContainElements(
				corev1.EnvVar{
					Name:  shared.EnvSecretsPath,
					Value: shared.PathSecrets(ethereum2Clients.NimbusHomeDir),
				},
				corev1.EnvVar{
					Name:  envValidatorsPath,
					Value: fmt.Sprintf("%s/kotal-validators", shared.PathData(ethereum2Clients.NimbusHomeDir)),
				},
			))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Command).To(ConsistOf("/bin/sh"))
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].Args).To(ConsistOf(
				fmt.Sprintf("%s/nimbus_copy_validators.sh", shared.PathConfig(ethereum2Clients.NimbusHomeDir))),
			)
			Expect(validatorSts.Spec.Template.Spec.InitContainers[0].VolumeMounts).To(ContainElements(
				corev1.VolumeMount{
					Name:      "data",
					MountPath: shared.PathData(ethereum2Clients.NimbusHomeDir),
				},
				corev1.VolumeMount{
					Name:      "config",
					MountPath: shared.PathConfig(ethereum2Clients.NimbusHomeDir),
				},
				corev1.VolumeMount{
					Name:      "my-validator",
					MountPath: fmt.Sprintf("%s/validator-keys/%s", shared.PathSecrets(ethereum2Clients.NimbusHomeDir), "my-validator"),
				},
			))

		})

		It("Should allocate correct resources to validator statefulset", func() {
			validatorSts := &appsv1.StatefulSet{}
			expectedResources := corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPURequest),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryRequest),
				},
				Limits: corev1.ResourceList{
					corev1.ResourceCPU:    resource.MustParse(ethereum2v1alpha1.DefaultCPULimit),
					corev1.ResourceMemory: resource.MustParse(ethereum2v1alpha1.DefaultMemoryLimit),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, validatorSts)).To(Succeed())
			Expect(validatorSts.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
		})

		It("Should create validator configmap", func() {
			configmap := &corev1.ConfigMap{}
			Expect(k8sClient.Get(context.Background(), key, configmap)).To(Succeed())
			Expect(configmap.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(configmap.Data).To(HaveKey("nimbus_copy_validators.sh"))
		})

		It("Should create data persistent volume with correct resources", func() {
			validatorPVC := &corev1.PersistentVolumeClaim{}
			expectedResources := corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(ethereum2v1alpha1.DefaultStorage),
				},
			}
			Expect(k8sClient.Get(context.Background(), key, validatorPVC)).To(Succeed())
			Expect(validatorPVC.GetOwnerReferences()).To(ContainElement(validatorOwnerReference))
			Expect(validatorPVC.Spec.Resources).To(Equal(expectedResources))
		})

		It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
			Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
		})

	})

})

'''
'''--- controllers/filecoin/config.go ---
package controllers

import (
	"bytes"
	"fmt"

	"github.com/BurntSushi/toml"
	filecoinv1alpha1 "github.com/kotalco/kotal/apis/filecoin/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
)

type API struct {
	ListenAddress  string
	RequestTimeout string
}

type Backup struct {
	DisableMetadataLog bool
}

type LibP2P struct {
	ListenAddresses []string
}

type Client struct {
	UseIpfs             bool
	IpfsOnlineMode      bool
	IpfsMAddr           string
	IpfsUseForRetrieval bool
}

type Chainstore struct {
	EnableSplitstore bool
}

type Config struct {
	API        *API `toml:"API,omitempty"`
	Backup     Backup
	LibP2P     LibP2P `toml:"Libp2p"`
	Client     *Client
	Chainstore Chainstore
}

// ConfigFromSpec generates config.toml file from node spec
func ConfigFromSpec(node *filecoinv1alpha1.Node) (config string, err error) {
	c := &Config{}

	if node.Spec.API {
		c.API = &API{
			ListenAddress: fmt.Sprintf("/ip4/%s/tcp/%d/http", shared.Host(node.Spec.API), node.Spec.APIPort),
		}
		c.API.RequestTimeout = fmt.Sprintf("%ds", node.Spec.APIRequestTimeout)
	}

	c.Backup.DisableMetadataLog = node.Spec.DisableMetadataLog

	c.LibP2P.ListenAddresses = []string{fmt.Sprintf("/ip4/%s/tcp/%d", shared.Host(true), node.Spec.P2PPort)}

	if node.Spec.IPFSPeerEndpoint != "" {
		c.Client = &Client{
			UseIpfs:             true,
			IpfsMAddr:           node.Spec.IPFSPeerEndpoint,
			IpfsOnlineMode:      node.Spec.IPFSOnlineMode,
			IpfsUseForRetrieval: node.Spec.IPFSForRetrieval,
		}
	}

	c.Chainstore.EnableSplitstore = true

	var buff bytes.Buffer
	enc := toml.NewEncoder(&buff)
	err = enc.Encode(c)
	if err != nil {
		return
	}

	config = buff.String()

	return
}

'''
'''--- controllers/filecoin/copy_config_toml.sh ---
#!/bin/sh

set -e

mkdir -p $KOTAL_DATA_PATH

cp $KOTAL_CONFIG_PATH/config.toml $KOTAL_DATA_PATH
'''
'''--- controllers/filecoin/node_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"

	filecoinv1alpha1 "github.com/kotalco/kotal/apis/filecoin/v1alpha1"
	filecoinClients "github.com/kotalco/kotal/clients/filecoin"
	"github.com/kotalco/kotal/controllers/shared"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	shared.Reconciler
}

var (
	//go:embed copy_config_toml.sh
	CopyConfigToml string
)

// +kubebuilder:rbac:groups=filecoin.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=filecoin.kotal.io,resources=nodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=configmaps;services;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

// Reconcile reconciles Filecoin network node
func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node filecoinv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, "lotus", string(node.Spec.Network))

	// reconcile service
	if err = r.ReconcileOwned(ctx, &node, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&node, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile ConfigMap
	if err = r.ReconcileOwned(ctx, &node, &corev1.ConfigMap{}, func(obj client.Object) error {
		// generates filecoin config.toml file from node spec
		configToml, err := ConfigFromSpec(&node)
		if err != nil {
			return err
		}
		r.specConfigmap(&node, obj.(*corev1.ConfigMap), configToml)
		return nil
	}); err != nil {
		return
	}

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &node, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&node, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile stateful set
	if err = r.ReconcileOwned(ctx, &node, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client := filecoinClients.NewClient(&node)
		args := client.Args()
		args = append(args, node.Spec.ExtraArgs.Encode(false)...)
		env := client.Env()
		cmd := client.Command()
		homeDir := client.HomeDir()
		return r.specStatefulSet(&node, obj.(*appsv1.StatefulSet), homeDir, cmd, args, env)
	}); err != nil {
		return
	}

	if err = r.updateStatus(ctx, &node); err != nil {
		return
	}

	return
}

// updateStatus updates filecoin node status
func (r *NodeReconciler) updateStatus(ctx context.Context, node *filecoinv1alpha1.Node) error {
	node.Status.Client = "lotus"

	if err := r.Status().Update(ctx, node); err != nil {
		log.FromContext(ctx).Error(err, "unable to update filecoin node status")
		return err
	}

	return nil
}

// specPVC updates node PVC spec
func (r *NodeReconciler) specPVC(node *filecoinv1alpha1.Node, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(node.Spec.Resources.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = node.Labels

	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: node.Spec.Resources.StorageClass,
	}
}

// specConfigmap updates node statefulset spec
func (r *NodeReconciler) specConfigmap(node *filecoinv1alpha1.Node, configmap *corev1.ConfigMap, configToml string) {
	configmap.ObjectMeta.Labels = node.Labels

	if configmap.Data == nil {
		configmap.Data = map[string]string{}
	}

	configmap.Data["config.toml"] = configToml
	configmap.Data["copy_config_toml.sh"] = CopyConfigToml

}

// specService updates node statefulset spec
func (r *NodeReconciler) specService(node *filecoinv1alpha1.Node, svc *corev1.Service) {
	labels := node.Labels

	svc.ObjectMeta.Labels = labels

	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
	}

	if node.Spec.API {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "api",
			Port:       int32(node.Spec.APIPort),
			TargetPort: intstr.FromString("api"),
		})
	}

	svc.Spec.Selector = labels
}

// specStatefulSet updates node statefulset spec
func (r *NodeReconciler) specStatefulSet(node *filecoinv1alpha1.Node, sts *appsv1.StatefulSet, homeDir string, cmd, args []string, env []corev1.EnvVar) error {
	labels := node.Labels

	sts.ObjectMeta.Labels = labels

	ports := []corev1.ContainerPort{
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
	}

	if node.Spec.API {
		ports = append(ports, corev1.ContainerPort{
			Name:          "api",
			ContainerPort: int32(node.Spec.APIPort),
		})
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: labels,
		},
		ServiceName: node.Name,
		Replicas:    &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				InitContainers: []corev1.Container{
					{
						Name:  "copy-config-toml",
						Image: shared.BusyboxImage,
						Env: []corev1.EnvVar{
							{
								Name:  shared.EnvDataPath,
								Value: shared.PathData(homeDir),
							},
							{
								Name:  shared.EnvConfigPath,
								Value: shared.PathConfig(homeDir),
							},
						},
						Command: []string{"/bin/sh"},
						Args:    []string{fmt.Sprintf("%s/copy_config_toml.sh", shared.PathConfig(homeDir))},
						VolumeMounts: []corev1.VolumeMount{
							{
								Name:      "data",
								MountPath: shared.PathData(homeDir),
							},
							{
								Name:      "config",
								MountPath: shared.PathConfig(homeDir),
							},
						},
					},
				},
				Containers: []corev1.Container{
					{
						Name:    "node",
						Image:   node.Spec.Image,
						Args:    args,
						Command: cmd,
						Env:     env,
						Ports:   ports,
						VolumeMounts: []corev1.VolumeMount{
							{
								Name:      "data",
								MountPath: shared.PathData(homeDir),
							},
							{
								Name:      "proof-parameters",
								MountPath: "/var/tmp/filecoin-proof-parameters",
							},
						},
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.Resources.CPU),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Resources.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.Resources.CPULimit),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Resources.MemoryLimit),
							},
						},
					},
				},
				Volumes: []corev1.Volume{
					{
						Name: "data",
						VolumeSource: corev1.VolumeSource{
							PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
								ClaimName: node.Name,
							},
						},
					},
					{
						Name: "config",
						VolumeSource: corev1.VolumeSource{
							ConfigMap: &corev1.ConfigMapVolumeSource{
								LocalObjectReference: corev1.LocalObjectReference{
									Name: node.Name,
								},
							},
						},
					},
					{
						Name: "proof-parameters",
						VolumeSource: corev1.VolumeSource{
							EmptyDir: &corev1.EmptyDirVolumeSource{},
						},
					},
				},
			},
		},
	}

	return nil
}

// SetupWithManager adds reconciler to the manager
func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	pred := predicate.GenerationChangedPredicate{}
	return ctrl.NewControllerManagedBy(mgr).
		For(&filecoinv1alpha1.Node{}).
		WithEventFilter(pred).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.ConfigMap{}).
		Owns(&corev1.Service{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Complete(r)
}

'''
'''--- controllers/filecoin/node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	filecoinv1alpha1 "github.com/kotalco/kotal/apis/filecoin/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("Filecoin node controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "filecoin",
		},
	}

	key := types.NamespacedName{
		Name:      "calibration-node",
		Namespace: ns.Name,
	}

	testImage := "kotalco/lotus:controller-test"

	spec := filecoinv1alpha1.NodeSpec{
		Image:   testImage,
		Network: filecoinv1alpha1.CalibrationNetwork,
		API:     true,
	}

	toCreate := &filecoinv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	t := true

	nodeOwnerReference := metav1.OwnerReference{
		APIVersion:         "filecoin.kotal.io/v1alpha1",
		Kind:               "Node",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("should create kusama node", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("Should get kusama node", func() {
		fetched := &filecoinv1alpha1.Node{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		nodeOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		Expect(fetched.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
	})

	It("Should create allocate correct resources to peer statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(filecoinv1alpha1.DefaultCalibrationNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(filecoinv1alpha1.DefaultCalibrationNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(filecoinv1alpha1.DefaultCalibrationNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(filecoinv1alpha1.DefaultCalibrationNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create node configmap", func() {
		fetched := &corev1.ConfigMap{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Data).To(HaveKey("config.toml"))
		Expect(fetched.Data).To(HaveKey("copy_config_toml.sh"))
	})

	It("Should create node data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(filecoinv1alpha1.DefaultCalibrationNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It("Should create node service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "p2p",
					Port:       int32(filecoinv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "api",
					Port:       int32(filecoinv1alpha1.DefaultAPIPort),
					TargetPort: intstr.FromString("api"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/filecoin/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	filecoinv1alpha1 "github.com/kotalco/kotal/apis/filecoin/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

// These tests use Ginkgo (BDD-style Go testing framework). Refer to
// http://onsi.github.io/ginkgo/ to learn more about Ginkgo.

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	// start the test environment
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = filecoinv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start node reconciler
	nodeReconciler := &NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	nodeReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	cancel()
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/filecoin/types.go ---
package controllers

'''
'''--- controllers/graph/node_controller.go ---
package graph

import (
	"context"

	graphv1alpha1 "github.com/kotalco/kotal/apis/graph/v1alpha1"
	graphClients "github.com/kotalco/kotal/clients/graph"
	"github.com/kotalco/kotal/controllers/shared"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

//+kubebuilder:rbac:groups=graph.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=graph.kotal.io,resources=nodes/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=graph.kotal.io,resources=nodes/finalizers,verbs=update
//+kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete

func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node graphv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// TODO: default the node if webhooks are disabled

	shared.UpdateLabels(&node, "graph-node", "")

	if err = r.reconcileStatefulset(ctx, &node); err != nil {
		return
	}

	return
}

// reconcileStatefulset reconciles node statefulset
func (r *NodeReconciler) reconcileStatefulset(ctx context.Context, node *graphv1alpha1.Node) error {
	sts := &appsv1.StatefulSet{
		ObjectMeta: metav1.ObjectMeta{
			Name:      node.Name,
			Namespace: node.Namespace,
		},
	}

	client := graphClients.NewClient(node)

	homeDir := client.HomeDir()
	cmd := client.Command()
	args := client.Args()
	env := client.Env()

	_, err := ctrl.CreateOrUpdate(ctx, r.Client, sts, func() error {
		if err := ctrl.SetControllerReference(node, sts, r.Scheme); err != nil {
			return err
		}
		if err := r.specStatefulSet(node, sts, homeDir, env, cmd, args); err != nil {
			return err
		}
		return nil
	})

	return err
}

// specStatefulSet updates node statefulset spec
func (r *NodeReconciler) specStatefulSet(node *graphv1alpha1.Node, sts *appsv1.StatefulSet, homeDir string, env []corev1.EnvVar, cmd, args []string) error {

	sts.ObjectMeta.Labels = node.Labels

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: node.Labels,
		},
		ServiceName: node.Name,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: node.Labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				Containers: []corev1.Container{
					{
						Name:    "node",
						Image:   node.Spec.Image,
						Command: cmd,
						Args:    args,
						Env:     env,
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse("1"),
								corev1.ResourceMemory: resource.MustParse("1Gi"),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse("2"),
								corev1.ResourceMemory: resource.MustParse("2Gi"),
							},
						},
						VolumeMounts: []corev1.VolumeMount{
							{
								Name:      "data",
								MountPath: shared.PathData(homeDir),
							},
						},
					},
				},
				Volumes: []corev1.Volume{
					{
						Name: "data",
						VolumeSource: corev1.VolumeSource{
							EmptyDir: &corev1.EmptyDirVolumeSource{},
						},
					},
				},
			},
		},
	}

	return nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&graphv1alpha1.Node{}).
		Owns(&appsv1.StatefulSet{}).
		Complete(r)
}

'''
'''--- controllers/graph/suite_test.go ---
package graph

import (
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	//+kubebuilder:scaffold:imports
)

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	By("bootstrapping test environment")
	testEnv = &envtest.Environment{
		CRDDirectoryPaths:     []string{filepath.Join("..", "..", "config", "crd", "bases")},
		ErrorIfCRDPathMissing: false,
	}

	var err error
	// cfg is defined in this file globally.
	cfg, err = testEnv.Start()
	Expect(err).NotTo(HaveOccurred())
	Expect(cfg).NotTo(BeNil())

	//+kubebuilder:scaffold:scheme

	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).NotTo(HaveOccurred())
	Expect(k8sClient).NotTo(BeNil())

})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	err := testEnv.Stop()
	Expect(err).NotTo(HaveOccurred())
})

'''
'''--- controllers/ipfs/cluster_peer_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"
	"strings"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"

	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	ipfsClients "github.com/kotalco/kotal/clients/ipfs"
	"github.com/kotalco/kotal/controllers/shared"
)

// ClusterPeerReconciler reconciles a ClusterPeer object
type ClusterPeerReconciler struct {
	shared.Reconciler
}

var (
	//go:embed init_ipfs_cluster_config.sh
	initIPFSClusterConfig string
)

// +kubebuilder:rbac:groups=ipfs.kotal.io,resources=clusterpeers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ipfs.kotal.io,resources=clusterpeers/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=configmaps;services;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

func (r *ClusterPeerReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var peer ipfsv1alpha1.ClusterPeer

	if err = r.Client.Get(ctx, req.NamespacedName, &peer); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the cluster peer if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		peer.Default()
	}

	shared.UpdateLabels(&peer, "ipfs-cluster-service", "")

	// reconcile service
	if err = r.ReconcileOwned(ctx, &peer, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&peer, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &peer, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&peer, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile config map
	if err = r.ReconcileOwned(ctx, &peer, &corev1.ConfigMap{}, func(obj client.Object) error {
		r.specConfigmap(&peer, obj.(*corev1.ConfigMap))
		return nil
	}); err != nil {
		return
	}

	// reconcile stateful set
	if err = r.ReconcileOwned(ctx, &peer, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client, err := ipfsClients.NewClient(&peer)
		if err != nil {
			return err
		}

		command := client.Command()
		args := client.Args()
		args = append(args, peer.Spec.ExtraArgs.Encode(false)...)
		env := client.Env()
		homeDir := client.HomeDir()

		r.specStatefulset(&peer, obj.(*appsv1.StatefulSet), homeDir, env, command, args)
		return nil
	}); err != nil {
		return
	}

	if err = r.updateStatus(ctx, &peer); err != nil {
		return
	}

	return
}

// updateStatus updates ipfs cluster peer status
func (r *ClusterPeerReconciler) updateStatus(ctx context.Context, peer *ipfsv1alpha1.ClusterPeer) error {
	// TODO: update after multi-client support
	peer.Status.Client = "ipfs-cluster-service"

	if err := r.Status().Update(ctx, peer); err != nil {
		log.FromContext(ctx).Error(err, "unable to update cluster peer status")
		return err
	}

	return nil
}

// specService updates ipfs peer service spec
func (r *ClusterPeerReconciler) specService(peer *ipfsv1alpha1.ClusterPeer, svc *corev1.Service) {
	labels := peer.Labels

	svc.ObjectMeta.Labels = labels

	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "swarm",
			Port:       9096,
			TargetPort: intstr.FromString("swarm"),
		},
		{
			Name:       "swarm-udp",
			Port:       9096,
			TargetPort: intstr.FromString("swarm-udp"),
			Protocol:   corev1.ProtocolUDP,
		},
		{
			// Pinning service API
			// https://ipfscluster.io/documentation/reference/pinsvc_api/
			Name:       "api",
			Port:       5001,
			TargetPort: intstr.FromString("api"),
		},
		{
			// Proxy API
			// https://ipfscluster.io/documentation/reference/proxy/
			Name:       "proxy-api",
			Port:       9095,
			TargetPort: intstr.FromString("proxy-api"),
		},
		{
			// REST API
			//https://ipfscluster.io/documentation/reference/api/
			Name:       "rest",
			Port:       9094,
			TargetPort: intstr.FromString("rest"),
		},
		{
			Name:       "metrics",
			Port:       8888,
			TargetPort: intstr.FromString("metrics"),
		},
		{
			Name:       "tracing",
			Port:       6831,
			TargetPort: intstr.FromString("tracing"),
		},
	}

	svc.Spec.Selector = labels
}

// specConfigmap updates IPFS cluster peer configmap spec
func (r *ClusterPeerReconciler) specConfigmap(peer *ipfsv1alpha1.ClusterPeer, config *corev1.ConfigMap) {
	config.ObjectMeta.Labels = peer.Labels

	if config.Data == nil {
		config.Data = make(map[string]string)
	}

	config.Data["init_ipfs_cluster_config.sh"] = initIPFSClusterConfig
}

// specPVC updates IPFS cluster peer persistent volume claim
func (r *ClusterPeerReconciler) specPVC(peer *ipfsv1alpha1.ClusterPeer, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(peer.Spec.Resources.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = peer.Labels
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: peer.Spec.Resources.StorageClass,
	}
}

// specStatefulset updates IPFS cluster peer statefulset
func (r *ClusterPeerReconciler) specStatefulset(peer *ipfsv1alpha1.ClusterPeer, sts *appsv1.StatefulSet, homeDir string, env []corev1.EnvVar, command, args []string) {
	labels := peer.Labels

	sts.Labels = labels

	// environment variables required by `ipfs-cluster-service init`
	initClusterPeerENV := []corev1.EnvVar{
		{
			Name:  ipfsClients.EnvIPFSClusterPath,
			Value: shared.PathData(homeDir),
		},
		{
			Name:  ipfsClients.EnvIPFSClusterConsensus,
			Value: string(peer.Spec.Consensus),
		},
		{
			Name:  ipfsClients.EnvIPFSClusterPeerEndpoint,
			Value: peer.Spec.PeerEndpoint,
		},
		{
			Name: ipfsClients.EnvIPFSClusterSecret,
			ValueFrom: &corev1.EnvVarSource{
				SecretKeyRef: &corev1.SecretKeySelector{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: peer.Spec.ClusterSecretName,
					},
					Key: "secret",
				},
			},
		},
		{
			Name:  ipfsClients.EnvIPFSClusterTrustedPeers,
			Value: strings.Join(peer.Spec.TrustedPeers, ","),
		},
	}

	// if cluster peer ID (which implies private key) is provided
	// append cluster id and private key environment variables
	if peer.Spec.ID != "" {
		// cluster id
		initClusterPeerENV = append(initClusterPeerENV, corev1.EnvVar{
			Name:  ipfsClients.EnvIPFSClusterId,
			Value: peer.Spec.ID,
		})
		// cluster private key
		initClusterPeerENV = append(initClusterPeerENV, corev1.EnvVar{
			Name: ipfsClients.EnvIPFSClusterPrivateKey,
			ValueFrom: &corev1.EnvVarSource{
				SecretKeyRef: &corev1.SecretKeySelector{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: peer.Spec.PrivateKeySecretName,
					},
					Key: "key",
				},
			},
		})
	}

	ports := []corev1.ContainerPort{
		{
			Name:          "swarm",
			ContainerPort: 9096,
		},
		{
			Name:          "swarm-udp",
			ContainerPort: 9096,
			Protocol:      corev1.ProtocolUDP,
		},
		{
			Name:          "api",
			ContainerPort: 5001,
		},
		{
			Name:          "proxy-api",
			ContainerPort: 9095,
		},
		{
			Name:          "rest",
			ContainerPort: 9094,
		},
		{
			Name:          "metrics",
			ContainerPort: 8888,
		},
		{
			Name:          "tracing",
			ContainerPort: 6831,
		},
	}

	replicas := int32(*peer.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: labels,
		},
		Replicas: &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				InitContainers: []corev1.Container{
					{
						Name:    "init-cluster-peer",
						Image:   peer.Spec.Image,
						Command: []string{"/bin/sh"},
						Env:     initClusterPeerENV,
						Args: []string{
							fmt.Sprintf("%s/init_ipfs_cluster_config.sh", shared.PathConfig(homeDir)),
						},
						VolumeMounts: []corev1.VolumeMount{
							{
								Name:      "data",
								MountPath: shared.PathData(homeDir),
							},
							{
								Name:      "config",
								MountPath: shared.PathConfig(homeDir),
							},
						},
					},
				},
				Containers: []corev1.Container{
					{
						Name:    "cluster-peer",
						Image:   peer.Spec.Image,
						Command: command,
						Env:     env,
						Args:    args,
						Ports:   ports,
						VolumeMounts: []corev1.VolumeMount{
							{
								Name:      "data",
								MountPath: shared.PathData(homeDir),
							},
						},
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(peer.Spec.CPU),
								corev1.ResourceMemory: resource.MustParse(peer.Spec.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(peer.Spec.CPULimit),
								corev1.ResourceMemory: resource.MustParse(peer.Spec.MemoryLimit),
							},
						},
					},
				},
				Volumes: []corev1.Volume{
					{
						Name: "data",
						VolumeSource: corev1.VolumeSource{
							PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
								ClaimName: peer.Name,
							},
						},
					},
					{
						Name: "config",
						VolumeSource: corev1.VolumeSource{
							ConfigMap: &corev1.ConfigMapVolumeSource{
								LocalObjectReference: corev1.LocalObjectReference{
									Name: peer.Name,
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *ClusterPeerReconciler) SetupWithManager(mgr ctrl.Manager) error {
	pred := predicate.GenerationChangedPredicate{}
	return ctrl.NewControllerManagedBy(mgr).
		For(&ipfsv1alpha1.ClusterPeer{}).
		WithEventFilter(pred).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Owns(&corev1.Service{}).
		Owns(&corev1.ConfigMap{}).
		Complete(r)
}

'''
'''--- controllers/ipfs/cluster_peer_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"

	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	ipfsClients "github.com/kotalco/kotal/clients/ipfs"
	"github.com/kotalco/kotal/controllers/shared"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("IPFS cluster peer controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "ipfs-cluster-peer",
		},
	}

	key := types.NamespacedName{
		Name:      "my-cluster-peer",
		Namespace: ns.Name,
	}

	image := "kotalco/ipfs-cluster:test"

	spec := ipfsv1alpha1.ClusterPeerSpec{
		Image:                image,
		ID:                   "12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuiq",
		PrivateKeySecretName: "cluster-privatekey",
		ClusterSecretName:    "cluster-secret",
		Consensus:            ipfsv1alpha1.CRDT,
		TrustedPeers: []string{
			"12D3KooWBcEtY8GH4mNkri9kM3haeWhEXtQV7mi81ErWrqLYGuiq",
			"12D3KooWQ9yZnqowEDme3gSgS45KY9ZoEmAiGYRxusdEaqtFa9pr",
		},
		PeerEndpoint: "/dns4/ipfs-peer/tcp/5001",
	}

	toCreate := &ipfsv1alpha1.ClusterPeer{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	t := true

	peerOwnerReference := metav1.OwnerReference{
		APIVersion:         "ipfs.kotal.io/v1alpha1",
		Kind:               "ClusterPeer",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("should create cluster privatekey secret", func() {
		secret := &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "cluster-privatekey",
				Namespace: ns.Name,
			},
			StringData: map[string]string{
				"key": "CAESQOH/DvUJmeJ9z6m3wAStpkrlBwJQxIyNSK0YGf0EI5ZRGpwsWxl4wmgReqmHl8LQjTC2iPM0QbYAjeY3Z63AFnI=",
			},
		}

		Expect(k8sClient.Create(context.TODO(), secret)).To(Succeed())
	})

	It("should create cluster secret", func() {
		secret := &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "cluster-secret",
				Namespace: ns.Name,
			},
			StringData: map[string]string{
				"secret": "clu$ter$3cr3t",
			},
		}

		Expect(k8sClient.Create(context.TODO(), secret)).To(Succeed())
	})

	It("should create ipfs cluster peer", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("should get ipfs cluster peer", func() {
		fetched := &ipfsv1alpha1.ClusterPeer{}
		Expect(k8sClient.Get(context.TODO(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		peerOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create ipfs cluster peer statefulset with correct image and arguments", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(peerOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		container := fetched.Spec.Template.Spec.Containers[0]
		Expect(container.Image).To(Equal(image))

	})

	It("Should pass correct environment variables to ipfs cluster peer statefulset containers", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())

		container := fetched.Spec.Template.Spec.Containers[0]
		Expect(container.Env).To(ContainElements([]corev1.EnvVar{
			{
				Name:  ipfsClients.EnvIPFSClusterPath,
				Value: shared.PathData(ipfsClients.GoIPFSClusterHomeDir),
			},
			{
				Name:  ipfsClients.EnvIPFSClusterPeerName,
				Value: toCreate.Name,
			},
		}))

		initContainer := fetched.Spec.Template.Spec.InitContainers[0]
		Expect(initContainer.Env).To(ContainElements([]corev1.EnvVar{
			{
				Name:  ipfsClients.EnvIPFSClusterPath,
				Value: shared.PathData(ipfsClients.GoIPFSClusterHomeDir),
			},
			{
				Name:  ipfsClients.EnvIPFSClusterConsensus,
				Value: string(toCreate.Spec.Consensus),
			},
			{
				Name:  ipfsClients.EnvIPFSClusterPeerEndpoint,
				Value: toCreate.Spec.PeerEndpoint,
			},
			{
				Name: ipfsClients.EnvIPFSClusterSecret,
				ValueFrom: &corev1.EnvVarSource{
					SecretKeyRef: &corev1.SecretKeySelector{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: toCreate.Spec.ClusterSecretName,
						},
						Key: "secret",
					},
				},
			},
			{
				Name:  ipfsClients.EnvIPFSClusterTrustedPeers,
				Value: strings.Join(toCreate.Spec.TrustedPeers, ","),
			},
			{
				Name:  ipfsClients.EnvIPFSClusterId,
				Value: toCreate.Spec.ID,
			},
			{
				Name: ipfsClients.EnvIPFSClusterPrivateKey,
				ValueFrom: &corev1.EnvVarSource{
					SecretKeyRef: &corev1.SecretKeySelector{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: toCreate.Spec.PrivateKeySecretName,
						},
						Key: "key",
					},
				},
			},
		}))
	})

	It("Should create allocate correct resources to cluster peer statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(ipfsv1alpha1.DefaultNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(ipfsv1alpha1.DefaultNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(ipfsv1alpha1.DefaultNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(ipfsv1alpha1.DefaultNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create peer configmap", func() {
		fetched := &corev1.ConfigMap{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(peerOwnerReference))
		Expect(fetched.Data).To(HaveKey("init_ipfs_cluster_config.sh"))
	})

	It("Should create peer data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(peerOwnerReference))

		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(ipfsv1alpha1.DefaultNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It("Should create peer service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(peerOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "swarm",
					Port:       9096,
					TargetPort: intstr.FromString("swarm"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "swarm-udp",
					Port:       9096,
					TargetPort: intstr.FromString("swarm-udp"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "api",
					Port:       5001,
					TargetPort: intstr.FromString("api"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "proxy-api",
					Port:       9095,
					TargetPort: intstr.FromString("proxy-api"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "rest",
					Port:       9094,
					TargetPort: intstr.FromString("rest"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "metrics",
					Port:       8888,
					TargetPort: intstr.FromString("metrics"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "tracing",
					Port:       6831,
					TargetPort: intstr.FromString("tracing"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/ipfs/config_ipfs.sh ---
#!/bin/sh

set -e

ipfs config Addresses.API /ip4/$IPFS_API_HOST/tcp/$IPFS_API_PORT
ipfs config Addresses.Gateway /ip4/$IPFS_GATEWAY_HOST/tcp/$IPFS_GATEWAY_PORT

export IFS=";"
for profile in $IPFS_PROFILES; do
    ipfs config profile apply $profile
    echo "$profile profile has been applied"
done

'''
'''--- controllers/ipfs/copy_swarm_key.sh ---
#!/bin/sh

set -e

mkdir -p $IPFS_PATH &&
cp $KOTAL_SECRETS_PATH/swarm.key $IPFS_PATH
'''
'''--- controllers/ipfs/init_ipfs_cluster_config.sh ---
#!/bin/sh

set -e

if [ -e $IPFS_CLUSTER_PATH/service.json ]
then
	echo "ipfs cluster config has already been initialized"
else
	echo "initializing ipfs cluster config"
	ipfs-cluster-service init --consensus $IPFS_CLUSTER_CONSENSUS
fi
'''
'''--- controllers/ipfs/init_ipfs_config.sh ---
#!/bin/sh

set -e

if [ -e $IPFS_PATH/config ]
then
	echo "ipfs config has already been initialized"
else 
	echo "initializing ipfs config"
	ipfs init --empty-repo --profile $IPFS_INIT_PROFILES
fi
'''
'''--- controllers/ipfs/peer_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"
	"strings"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"

	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	ipfsClients "github.com/kotalco/kotal/clients/ipfs"
	"github.com/kotalco/kotal/controllers/shared"
)

// PeerReconciler reconciles a Peer object
type PeerReconciler struct {
	shared.Reconciler
}

var (
	//go:embed init_ipfs_config.sh
	initIPFSConfigScript string
	//go:embed copy_swarm_key.sh
	copySwarmKeyScript string
	//go:embed config_ipfs.sh
	configIPFSScript string
)

// +kubebuilder:rbac:groups=ipfs.kotal.io,resources=peers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ipfs.kotal.io,resources=peers/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=services;configmaps;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

func (r *PeerReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var peer ipfsv1alpha1.Peer

	if err = r.Client.Get(ctx, req.NamespacedName, &peer); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the peer if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		peer.Default()
	}

	shared.UpdateLabels(&peer, "kubo", "")

	// reconcile config map
	if err = r.ReconcileOwned(ctx, &peer, &corev1.ConfigMap{}, func(obj client.Object) error {
		r.specConfigmap(&peer, obj.(*corev1.ConfigMap))
		return nil
	}); err != nil {
		return
	}

	// reconcile service
	if err = r.ReconcileOwned(ctx, &peer, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&peer, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &peer, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&peer, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile stateful set
	if err = r.ReconcileOwned(ctx, &peer, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client, err := ipfsClients.NewClient(&peer)
		if err != nil {
			return err
		}

		command := client.Command()
		env := client.Env()
		args := client.Args()
		args = append(args, peer.Spec.ExtraArgs.Encode(false)...)
		homeDir := client.HomeDir()

		r.specStatefulSet(&peer, obj.(*appsv1.StatefulSet), homeDir, env, command, args)
		return nil
	}); err != nil {
		return
	}

	if err = r.updateStatus(ctx, &peer); err != nil {
		return
	}

	return
}

// updateStatus updates ipfs peer status
func (r *PeerReconciler) updateStatus(ctx context.Context, peer *ipfsv1alpha1.Peer) error {
	// TODO: update after multi-client support
	peer.Status.Client = "kubo"

	if err := r.Status().Update(ctx, peer); err != nil {
		log.FromContext(ctx).Error(err, "unable to update peer status")
		return err
	}

	return nil
}

// specService updates ipfs peer service spec
func (r *PeerReconciler) specService(peer *ipfsv1alpha1.Peer, svc *corev1.Service) {
	labels := peer.Labels

	svc.ObjectMeta.Labels = labels

	ports := []corev1.ServicePort{
		{
			Name:       "swarm",
			Port:       4001,
			TargetPort: intstr.FromString("swarm"),
		},
		{
			Name:       "swarm-udp",
			Port:       4001,
			TargetPort: intstr.FromString("swarm-udp"),
			Protocol:   corev1.ProtocolUDP,
		},
	}

	if peer.Spec.API {
		ports = append(ports, corev1.ServicePort{
			Name:       "api",
			Port:       int32(peer.Spec.APIPort),
			TargetPort: intstr.FromString("api"),
		})
	}

	if peer.Spec.Gateway {
		ports = append(ports, corev1.ServicePort{
			Name:       "gateway",
			Port:       int32(peer.Spec.GatewayPort),
			TargetPort: intstr.FromString("gateway"),
		})
	}

	svc.Spec.Ports = ports

	svc.Spec.Selector = labels
}

// specConfigmap updates ipfs peer config spec
func (r *PeerReconciler) specConfigmap(peer *ipfsv1alpha1.Peer, config *corev1.ConfigMap) {
	config.ObjectMeta.Labels = peer.Labels
	if config.Data == nil {
		config.Data = make(map[string]string)
	}
	config.Data["init_ipfs_config.sh"] = initIPFSConfigScript
	config.Data["copy_swarm_key.sh"] = copySwarmKeyScript
	config.Data["config_ipfs.sh"] = configIPFSScript
}

// specPVC updates ipfs peer persistent volume claim
func (r *PeerReconciler) specPVC(peer *ipfsv1alpha1.Peer, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(peer.Spec.Resources.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = peer.Labels
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: peer.Spec.Resources.StorageClass,
	}
}

// specStatefulSet updates ipfs peer statefulset spec
func (r *PeerReconciler) specStatefulSet(peer *ipfsv1alpha1.Peer, sts *appsv1.StatefulSet, homeDir string, env []corev1.EnvVar, command, args []string) {
	labels := peer.Labels

	sts.ObjectMeta.Labels = labels

	volumes := []corev1.Volume{
		{
			Name: "data",
			VolumeSource: corev1.VolumeSource{
				PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
					ClaimName: peer.Name,
				},
			},
		},
		{
			Name: "config",
			VolumeSource: corev1.VolumeSource{
				ConfigMap: &corev1.ConfigMapVolumeSource{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: peer.Name,
					},
				},
			},
		},
	}

	volumeMounts := []corev1.VolumeMount{
		{
			Name:      "data",
			MountPath: shared.PathData(homeDir),
		},
		{
			Name:      "config",
			MountPath: shared.PathConfig(homeDir),
		},
	}

	initContainers := []corev1.Container{}

	// copy swarm key before init ipfs
	if peer.Spec.SwarmKeySecretName != "" {
		volumes = append(volumes, corev1.Volume{
			Name: "swarm-key",
			VolumeSource: corev1.VolumeSource{
				Secret: &corev1.SecretVolumeSource{
					SecretName: peer.Spec.SwarmKeySecretName,
				},
			},
		})

		volumeMounts = append(volumeMounts, corev1.VolumeMount{
			Name:      "swarm-key",
			MountPath: shared.PathSecrets(homeDir),
		})

		initContainers = append(initContainers, corev1.Container{
			Name:  "copy-swarm-key",
			Image: shared.BusyboxImage,
			Env: []corev1.EnvVar{
				{
					Name:  ipfsClients.EnvIPFSPath,
					Value: shared.PathData(homeDir),
				},
				{
					Name:  shared.EnvSecretsPath,
					Value: shared.PathSecrets(homeDir),
				},
			},
			Command: []string{"/bin/sh"},
			Args: []string{
				fmt.Sprintf("%s/copy_swarm_key.sh", shared.PathConfig(homeDir)),
			},
			VolumeMounts: volumeMounts,
		})

	}

	// init ipfs config
	initProfiles := []string{}
	for _, profile := range peer.Spec.InitProfiles {
		initProfiles = append(initProfiles, string(profile))
	}
	initContainers = append(initContainers, corev1.Container{
		Name:  "init-ipfs",
		Image: peer.Spec.Image,
		Env: []corev1.EnvVar{
			{
				Name:  ipfsClients.EnvIPFSPath,
				Value: shared.PathData(homeDir),
			},
			{
				Name:  ipfsClients.EnvIPFSInitProfiles,
				Value: strings.Join(initProfiles, ","),
			},
		},
		Command: []string{"/bin/sh"},
		Args: []string{
			fmt.Sprintf("%s/init_ipfs_config.sh", shared.PathConfig(homeDir)),
		},
		VolumeMounts: volumeMounts,
	})

	// init ipfs config
	profiles := []string{}
	for _, profile := range peer.Spec.Profiles {
		profiles = append(profiles, string(profile))
	}
	// config ipfs
	initContainers = append(initContainers, corev1.Container{
		Name:  "config-ipfs",
		Image: peer.Spec.Image,
		Env: []corev1.EnvVar{
			{
				Name:  ipfsClients.EnvIPFSPath,
				Value: shared.PathData(homeDir),
			},
			{
				Name:  ipfsClients.EnvIPFSAPIPort,
				Value: fmt.Sprintf("%d", peer.Spec.APIPort),
			},
			{
				Name:  ipfsClients.EnvIPFSAPIHost,
				Value: shared.Host(peer.Spec.API),
			},
			{
				Name:  ipfsClients.EnvIPFSGatewayPort,
				Value: fmt.Sprintf("%d", peer.Spec.GatewayPort),
			},
			{
				Name:  ipfsClients.EnvIPFSGatewayHost,
				Value: shared.Host(peer.Spec.Gateway),
			},
			{
				Name:  ipfsClients.EnvIPFSProfiles,
				Value: strings.Join(profiles, ";"),
			},
		},
		Command: []string{"/bin/sh"},
		Args: []string{
			fmt.Sprintf("%s/config_ipfs.sh", shared.PathConfig(homeDir)),
		},
		VolumeMounts: volumeMounts,
	})

	ports := []corev1.ContainerPort{
		{
			Name:          "swarm",
			ContainerPort: 4001,
		},
		{
			Name:          "swarm-udp",
			ContainerPort: 4001,
			Protocol:      corev1.ProtocolUDP,
		},
	}

	if peer.Spec.API {
		ports = append(ports, corev1.ContainerPort{
			Name:          "api",
			ContainerPort: int32(peer.Spec.APIPort),
		})
	}

	if peer.Spec.Gateway {
		ports = append(ports, corev1.ContainerPort{
			Name:          "gateway",
			ContainerPort: int32(peer.Spec.GatewayPort),
		})
	}

	replicas := int32(*peer.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: labels,
		},
		Replicas: &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				InitContainers:  initContainers,
				Containers: []corev1.Container{
					{
						Name:         "peer",
						Image:        peer.Spec.Image,
						Env:          env,
						Command:      command,
						Args:         args,
						Ports:        ports,
						VolumeMounts: volumeMounts,
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(peer.Spec.Resources.CPU),
								corev1.ResourceMemory: resource.MustParse(peer.Spec.Resources.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(peer.Spec.Resources.CPULimit),
								corev1.ResourceMemory: resource.MustParse(peer.Spec.Resources.MemoryLimit),
							},
						},
					},
				},
				Volumes: volumes,
			},
		},
	}
}

// SetupWithManager registers the controller to be started with the given manager
func (r *PeerReconciler) SetupWithManager(mgr ctrl.Manager) error {
	pred := predicate.GenerationChangedPredicate{}
	return ctrl.NewControllerManagedBy(mgr).
		For(&ipfsv1alpha1.Peer{}).
		WithEventFilter(pred).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Owns(&corev1.ConfigMap{}).
		Owns(&corev1.Service{}).
		Complete(r)
}

'''
'''--- controllers/ipfs/peer_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"

	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("IPFS peer controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "ipfs-peer",
		},
	}

	key := types.NamespacedName{
		Name:      "my-peer",
		Namespace: ns.Name,
	}

	image := "kotalco/kubo:test"

	spec := ipfsv1alpha1.PeerSpec{
		Image:              image,
		API:                true,
		APIPort:            3333,
		Gateway:            true,
		GatewayPort:        4444,
		Routing:            ipfsv1alpha1.DHTClientRouting,
		SwarmKeySecretName: "my-swarm",
	}

	toCreate := &ipfsv1alpha1.Peer{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	t := true

	peerOwnerReference := metav1.OwnerReference{
		APIVersion:         "ipfs.kotal.io/v1alpha1",
		Kind:               "Peer",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("should create ipfs peer", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("Should get ipfs peer", func() {
		fetched := &ipfsv1alpha1.Peer{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		peerOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create peer statefulset with correct arguments", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(peerOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		Expect(fetched.Spec.Template.Spec.Containers[0].Image).To(Equal(image))
	})

	It("Should create allocate correct resources to peer statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(ipfsv1alpha1.DefaultNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(ipfsv1alpha1.DefaultNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(ipfsv1alpha1.DefaultNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(ipfsv1alpha1.DefaultNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create peer configmap", func() {
		fetched := &corev1.ConfigMap{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(peerOwnerReference))
		Expect(fetched.Data).To(HaveKey("init_ipfs_config.sh"))
		Expect(fetched.Data).To(HaveKey("config_ipfs.sh"))
		Expect(fetched.Data).To(HaveKey("copy_swarm_key.sh"))
	})

	It("Should create peer data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(peerOwnerReference))
		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(ipfsv1alpha1.DefaultNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It("Should create peer service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(peerOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "swarm",
					Port:       4001,
					TargetPort: intstr.FromString("swarm"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "swarm-udp",
					Port:       4001,
					TargetPort: intstr.FromString("swarm-udp"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "api",
					Port:       int32(3333),
					TargetPort: intstr.FromString("api"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "gateway",
					Port:       int32(4444),
					TargetPort: intstr.FromString("gateway"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/ipfs/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

// These tests use Ginkgo (BDD-style Go testing framework). Refer to
// http://onsi.github.io/ginkgo/ to learn more about Ginkgo.

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	// start the test environment
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = ipfsv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	// create new k8s client
	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start peer reconciler
	peerReconciler := &PeerReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	peerReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	// start cluster peer reconciler
	clusterPeerReconciler := &ClusterPeerReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	clusterPeerReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	cancel()
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/near/copy_node_key.sh ---
#!/bin/sh

set -e

echo "Copying node key from secrets dir to data dir"

mkdir -p ${KOTAL_DATA_PATH}
cp ${KOTAL_SECRETS_PATH}/node_key.json ${KOTAL_DATA_PATH}

'''
'''--- controllers/near/copy_validator_key.sh ---
#!/bin/sh

set -e

echo "Copying validator key from secrets dir to data dir"

mkdir -p ${KOTAL_DATA_PATH}
cp ${KOTAL_SECRETS_PATH}/validator_key.json ${KOTAL_DATA_PATH}

'''
'''--- controllers/near/init_near_node.sh ---
#!/bin/sh

set -e

if [ -z "$(ls -A $KOTAL_DATA_PATH/genesis.json)" ]
then
    echo "Initializing NEAR node"
	neard --home $KOTAL_DATA_PATH init --chain-id $KOTAL_NEAR_NETWORK --download-genesis --download-config --account-id validator
else
	echo "NEAR node has already been initialized before!"
fi
'''
'''--- controllers/near/node_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"

	nearv1alpha1 "github.com/kotalco/kotal/apis/near/v1alpha1"
	nearClients "github.com/kotalco/kotal/clients/near"
	"github.com/kotalco/kotal/controllers/shared"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	shared.Reconciler
}

const (
	envNetwork = "KOTAL_NEAR_NETWORK"
)

var (
	//go:embed init_near_node.sh
	InitNearNode string
	//go:embed copy_node_key.sh
	CopyNodeKey string
	//go:embed copy_validator_key.sh
	CopyValidatorKey string
)

// +kubebuilder:rbac:groups=near.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=near.kotal.io,resources=nodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=configmaps;persistentvolumeclaims;services,verbs=watch;get;create;update;list;delete

func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node nearv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, "nearcore", node.Spec.Network)

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &node, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&node, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile config map
	if err = r.ReconcileOwned(ctx, &node, &corev1.ConfigMap{}, func(obj client.Object) error {
		r.specConfigmap(&node, obj.(*corev1.ConfigMap))
		return nil
	}); err != nil {
		return
	}

	// reconcile service
	if err = r.ReconcileOwned(ctx, &node, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&node, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile stateful set
	if err = r.ReconcileOwned(ctx, &node, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client := nearClients.NewClient(&node)
		homeDir := client.HomeDir()
		args := client.Args()
		args = append(args, node.Spec.ExtraArgs.Encode(false)...)

		r.specStatefulSet(&node, obj.(*appsv1.StatefulSet), homeDir, args)
		return nil
	}); err != nil {
		return
	}

	if err = r.updateStatus(ctx, &node); err != nil {
		return
	}

	return
}

// updateStatus updates NEAR node status
func (r *NodeReconciler) updateStatus(ctx context.Context, peer *nearv1alpha1.Node) error {
	peer.Status.Client = "nearcore"

	if err := r.Status().Update(ctx, peer); err != nil {
		log.FromContext(ctx).Error(err, "unable to update node status")
		return err
	}

	return nil
}

// specService updates NEAR node service spec
func (r *NodeReconciler) specService(node *nearv1alpha1.Node, svc *corev1.Service) {
	labels := node.Labels

	svc.ObjectMeta.Labels = labels

	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
		{
			Name:       "discovery",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("discovery"),
			Protocol:   corev1.ProtocolUDP,
		},
	}

	if node.Spec.RPC {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "rpc",
			Port:       int32(node.Spec.RPCPort),
			TargetPort: intstr.FromString("rpc"),
		})
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "prometheus",
			Port:       int32(node.Spec.PrometheusPort),
			TargetPort: intstr.FromString("prometheus"),
		})
	}

	svc.Spec.Selector = labels
}

// specPVC updates NEAR node persistent volume claim
func (n *NodeReconciler) specPVC(peer *nearv1alpha1.Node, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(peer.Spec.Resources.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = peer.Labels
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: peer.Spec.Resources.StorageClass,
	}
}

// specConfigmap updates node configmap
func (n *NodeReconciler) specConfigmap(node *nearv1alpha1.Node, configmap *corev1.ConfigMap) {
	configmap.ObjectMeta.Labels = node.Labels

	if configmap.Data == nil {
		configmap.Data = map[string]string{}
	}

	configmap.Data["init_near_node.sh"] = InitNearNode
	configmap.Data["copy_node_key.sh"] = CopyNodeKey
	configmap.Data["copy_validator_key.sh"] = CopyValidatorKey

}

func (r *NodeReconciler) createVolumes(node *nearv1alpha1.Node) []corev1.Volume {

	var volumeProjections []corev1.VolumeProjection

	volumes := []corev1.Volume{
		{
			Name: "data",
			VolumeSource: corev1.VolumeSource{
				PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
					ClaimName: node.Name,
				},
			},
		},
		{
			Name: "config",
			VolumeSource: corev1.VolumeSource{
				ConfigMap: &corev1.ConfigMapVolumeSource{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: node.Name,
					},
				},
			},
		},
	}

	if node.Spec.NodePrivateKeySecretName != "" {
		volumeProjections = append(volumeProjections, corev1.VolumeProjection{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.NodePrivateKeySecretName,
				},
				Items: []corev1.KeyToPath{
					{
						Key:  "key",
						Path: "node_key.json",
					},
				},
			},
		})
	}

	if node.Spec.ValidatorSecretName != "" {
		volumeProjections = append(volumeProjections, corev1.VolumeProjection{
			Secret: &corev1.SecretProjection{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Spec.ValidatorSecretName,
				},
				Items: []corev1.KeyToPath{
					{
						Key:  "key",
						Path: "validator_key.json",
					},
				},
			},
		})
	}

	secretsVolume := corev1.Volume{
		Name: "secrets",
		VolumeSource: corev1.VolumeSource{
			Projected: &corev1.ProjectedVolumeSource{
				Sources: volumeProjections,
			},
		},
	}
	volumes = append(volumes, secretsVolume)

	return volumes
}

func (r *NodeReconciler) createVolumeMounts(node *nearv1alpha1.Node, homeDir string) []corev1.VolumeMount {
	mounts := []corev1.VolumeMount{
		{
			Name:      "data",
			MountPath: shared.PathData(homeDir),
		},
		{
			Name:      "config",
			MountPath: shared.PathConfig(homeDir),
		},
	}

	if node.Spec.NodePrivateKeySecretName != "" || node.Spec.ValidatorSecretName != "" {
		mounts = append(mounts, corev1.VolumeMount{
			Name:      "secrets",
			MountPath: shared.PathSecrets(homeDir),
		})
	}

	return mounts
}

// specStatefulSet updates node statefulset spec
func (r *NodeReconciler) specStatefulSet(node *nearv1alpha1.Node, sts *appsv1.StatefulSet, homeDir string, args []string) {

	sts.ObjectMeta.Labels = node.Labels

	initContainers := []corev1.Container{
		{
			Name:  "init-near-node",
			Image: node.Spec.Image,
			Env: []corev1.EnvVar{
				{
					Name:  shared.EnvDataPath,
					Value: shared.PathData(homeDir),
				},
				{
					Name:  envNetwork,
					Value: node.Spec.Network,
				},
			},
			Command:      []string{"/bin/sh"},
			Args:         []string{fmt.Sprintf("%s/init_near_node.sh", shared.PathConfig(homeDir))},
			VolumeMounts: r.createVolumeMounts(node, homeDir),
		},
	}

	if node.Spec.NodePrivateKeySecretName != "" {
		initContainers = append(initContainers, corev1.Container{
			Name:    "copy-node-key",
			Image:   shared.BusyboxImage,
			Command: []string{"/bin/sh"},
			Env: []corev1.EnvVar{
				{
					Name:  shared.EnvDataPath,
					Value: shared.PathData(homeDir),
				},
				{
					Name:  shared.EnvSecretsPath,
					Value: shared.PathSecrets(homeDir),
				},
			},
			Args:         []string{fmt.Sprintf("%s/copy_node_key.sh", shared.PathConfig(homeDir))},
			VolumeMounts: r.createVolumeMounts(node, homeDir),
		})
	}

	if node.Spec.ValidatorSecretName != "" {
		initContainers = append(initContainers, corev1.Container{
			Name:    "copy-validator-key",
			Image:   shared.BusyboxImage,
			Command: []string{"/bin/sh"},
			Env: []corev1.EnvVar{
				{
					Name:  shared.EnvDataPath,
					Value: shared.PathData(homeDir),
				},
				{
					Name:  shared.EnvSecretsPath,
					Value: shared.PathSecrets(homeDir),
				},
			},
			Args:         []string{fmt.Sprintf("%s/copy_validator_key.sh", shared.PathConfig(homeDir))},
			VolumeMounts: r.createVolumeMounts(node, homeDir),
		})
	}

	ports := []corev1.ContainerPort{
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
		{
			Name:          "discovery",
			ContainerPort: int32(node.Spec.P2PPort),
			Protocol:      corev1.ProtocolUDP,
		},
	}

	if node.Spec.RPC {
		ports = append(ports, corev1.ContainerPort{
			Name:          "rpc",
			ContainerPort: int32(node.Spec.RPCPort),
		})
		ports = append(ports, corev1.ContainerPort{
			Name:          "prometheus",
			ContainerPort: int32(node.Spec.PrometheusPort),
		})
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: node.Labels,
		},
		ServiceName: node.Name,
		Replicas:    &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: node.Labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				InitContainers:  initContainers,
				Containers: []corev1.Container{
					{
						Name:         "node",
						Image:        node.Spec.Image,
						Args:         args,
						Ports:        ports,
						VolumeMounts: r.createVolumeMounts(node, homeDir),
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPU),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPULimit),
								corev1.ResourceMemory: resource.MustParse(node.Spec.MemoryLimit),
							},
						},
					},
				},
				Volumes: r.createVolumes(node),
			},
		},
	}

}

func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	pred := predicate.GenerationChangedPredicate{}
	return ctrl.NewControllerManagedBy(mgr).
		For(&nearv1alpha1.Node{}).
		WithEventFilter(pred).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.ConfigMap{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Owns(&corev1.Service{}).
		Complete(r)
}

'''
'''--- controllers/near/node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	nearv1alpha1 "github.com/kotalco/kotal/apis/near/v1alpha1"
	nearClients "github.com/kotalco/kotal/clients/near"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("NEAR node controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "near",
		},
	}

	key := types.NamespacedName{
		Name:      "near-node",
		Namespace: ns.Name,
	}

	testImage := "kotalco/nearcore:controller-test"

	spec := nearv1alpha1.NodeSpec{
		Image:                    testImage,
		Network:                  "mainnet",
		RPC:                      true,
		Archive:                  true, // test volume storage size
		NodePrivateKeySecretName: "my-node-key",
		ValidatorSecretName:      "validator-key",
	}

	toCreate := &nearv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	client := nearClients.NewClient(toCreate)

	t := true

	nodeOwnerReference := metav1.OwnerReference{
		APIVersion:         "near.kotal.io/v1alpha1",
		Kind:               "Node",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("should create NEAR node", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("Should get NEAR node", func() {
		fetched := &nearv1alpha1.Node{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		nodeOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		// init near node
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Name).To(Equal("init-near-node"))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Image).To(Equal(testImage))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Command).To(Equal([]string{"/bin/sh"}))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Args).To(ContainElements(
			fmt.Sprintf("%s/init_near_node.sh", shared.PathConfig(client.HomeDir())),
		))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].Env).To(ContainElements(
			corev1.EnvVar{
				Name:  shared.EnvDataPath,
				Value: shared.PathData(client.HomeDir()),
			},
			corev1.EnvVar{
				Name:  envNetwork,
				Value: toCreate.Spec.Network,
			},
		))
		Expect(fetched.Spec.Template.Spec.InitContainers[0].VolumeMounts).To(ContainElements(
			corev1.VolumeMount{
				Name:      "data",
				MountPath: shared.PathData(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "config",
				MountPath: shared.PathConfig(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "secrets",
				MountPath: shared.PathSecrets(client.HomeDir()),
			},
		))
		// copy node key
		Expect(fetched.Spec.Template.Spec.InitContainers[1].Name).To(Equal("copy-node-key"))
		Expect(fetched.Spec.Template.Spec.InitContainers[1].Image).To(Equal(shared.BusyboxImage))
		Expect(fetched.Spec.Template.Spec.InitContainers[1].Command).To(Equal([]string{"/bin/sh"}))
		Expect(fetched.Spec.Template.Spec.InitContainers[1].Args).To(ContainElements(
			fmt.Sprintf("%s/copy_node_key.sh", shared.PathConfig(client.HomeDir())),
		))
		Expect(fetched.Spec.Template.Spec.InitContainers[1].Env).To(ContainElements(
			corev1.EnvVar{
				Name:  shared.EnvDataPath,
				Value: shared.PathData(client.HomeDir()),
			},
			corev1.EnvVar{
				Name:  shared.EnvSecretsPath,
				Value: shared.PathSecrets(client.HomeDir()),
			},
		))
		Expect(fetched.Spec.Template.Spec.InitContainers[1].VolumeMounts).To(ContainElements(
			corev1.VolumeMount{
				Name:      "data",
				MountPath: shared.PathData(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "config",
				MountPath: shared.PathConfig(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "secrets",
				MountPath: shared.PathSecrets(client.HomeDir()),
			},
		))
		// copy validator key
		Expect(fetched.Spec.Template.Spec.InitContainers[2].Name).To(Equal("copy-validator-key"))
		Expect(fetched.Spec.Template.Spec.InitContainers[2].Image).To(Equal(shared.BusyboxImage))
		Expect(fetched.Spec.Template.Spec.InitContainers[2].Command).To(Equal([]string{"/bin/sh"}))
		Expect(fetched.Spec.Template.Spec.InitContainers[2].Args).To(ContainElements(
			fmt.Sprintf("%s/copy_validator_key.sh", shared.PathConfig(client.HomeDir())),
		))
		Expect(fetched.Spec.Template.Spec.InitContainers[2].Env).To(ContainElements(
			corev1.EnvVar{
				Name:  shared.EnvDataPath,
				Value: shared.PathData(client.HomeDir()),
			},
			corev1.EnvVar{
				Name:  shared.EnvSecretsPath,
				Value: shared.PathSecrets(client.HomeDir()),
			},
		))
		Expect(fetched.Spec.Template.Spec.InitContainers[2].VolumeMounts).To(ContainElements(
			corev1.VolumeMount{
				Name:      "data",
				MountPath: shared.PathData(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "config",
				MountPath: shared.PathConfig(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "secrets",
				MountPath: shared.PathSecrets(client.HomeDir()),
			},
		))
		// node
		Expect(fetched.Spec.Template.Spec.Containers[0].Name).To(Equal("node"))
		Expect(fetched.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
		Expect(fetched.Spec.Template.Spec.Containers[0].Command).To(Equal(client.Command()))
		Expect(fetched.Spec.Template.Spec.Containers[0].Args).To(Equal(client.Args()))
		Expect(fetched.Spec.Template.Spec.Containers[0].VolumeMounts).To(ContainElements(
			corev1.VolumeMount{
				Name:      "data",
				MountPath: shared.PathData(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "config",
				MountPath: shared.PathConfig(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "secrets",
				MountPath: shared.PathSecrets(client.HomeDir()),
			},
		))
		// volumes
		mode := corev1.ConfigMapVolumeSourceDefaultMode
		Expect(fetched.Spec.Template.Spec.Volumes).To(ContainElements(
			[]corev1.Volume{
				{
					Name: "data",
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: toCreate.Name,
						},
					},
				},
				{
					Name: "config",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: toCreate.Name,
							},
							DefaultMode: &mode,
						},
					},
				},
				{
					Name: "secrets",
					VolumeSource: corev1.VolumeSource{
						Projected: &corev1.ProjectedVolumeSource{
							Sources: []corev1.VolumeProjection{
								{
									Secret: &corev1.SecretProjection{
										LocalObjectReference: corev1.LocalObjectReference{
											Name: toCreate.Spec.NodePrivateKeySecretName,
										},
										Items: []corev1.KeyToPath{
											{
												Key:  "key",
												Path: "node_key.json",
											},
										},
									},
								},
								{
									Secret: &corev1.SecretProjection{
										LocalObjectReference: corev1.LocalObjectReference{
											Name: toCreate.Spec.ValidatorSecretName,
										},
										Items: []corev1.KeyToPath{
											{
												Key:  "key",
												Path: "validator_key.json",
											},
										},
									},
								},
							},
							DefaultMode: &mode,
						},
					},
				},
			},
		))
	})

	It("Should create allocate correct resources to peer statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(nearv1alpha1.DefaultNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(nearv1alpha1.DefaultNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(nearv1alpha1.DefaultNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(nearv1alpha1.DefaultNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create node configmap", func() {
		fetched := &corev1.ConfigMap{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Data).To(HaveKey("init_near_node.sh"))
		Expect(fetched.Data).To(HaveKey("copy_node_key.sh"))

	})

	It("Should create node data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(nearv1alpha1.DefaultArchivalNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It("Should create node service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "p2p",
					Port:       int32(nearv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "discovery",
					Port:       int32(nearv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("discovery"),
					Protocol:   corev1.ProtocolUDP,
				},
				{
					Name:       "prometheus",
					Port:       int32(nearv1alpha1.DefaultPrometheusPort),
					TargetPort: intstr.FromString("prometheus"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "rpc",
					Port:       int32(nearv1alpha1.DefaultRPCPort),
					TargetPort: intstr.FromString("rpc"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/near/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	nearv1alpha1 "github.com/kotalco/kotal/apis/near/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

// These tests use Ginkgo (BDD-style Go testing framework). Refer to
// http://onsi.github.io/ginkgo/ to learn more about Ginkgo.

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	// start the test environment
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = nearv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	// create new k8s client
	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start node reconciler
	nodeReconciler := &NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	nodeReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	cancel()
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/near/types.go ---
package controllers

'''
'''--- controllers/polkadot/convert_node_private_key.sh ---
#!/bin/sh

set -e

mkdir -p $KOTAL_DATA_PATH

# convert node private key to binary format
xxd -r -p -c 32 $KOTAL_SECRETS_PATH/nodekey > $KOTAL_DATA_PATH/kotal_nodekey
'''
'''--- controllers/polkadot/node_controller.go ---
package controllers

import (
	"context"
	_ "embed"
	"fmt"

	polkadotv1alpha1 "github.com/kotalco/kotal/apis/polkadot/v1alpha1"
	polkadotClients "github.com/kotalco/kotal/clients/polkadot"
	"github.com/kotalco/kotal/controllers/shared"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	shared.Reconciler
}

var (
	//go:embed convert_node_private_key.sh
	convertNodePrivateKeyScript string
)

// +kubebuilder:rbac:groups=polkadot.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=polkadot.kotal.io,resources=nodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=services;configmaps;persistentvolumeclaims,verbs=watch;get;create;update;list;delete

func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node polkadotv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, "polkadot", node.Spec.Network)

	// reconcile config map
	if err = r.ReconcileOwned(ctx, &node, &corev1.ConfigMap{}, func(obj client.Object) error {
		r.specConfigmap(&node, obj.(*corev1.ConfigMap))
		return nil
	}); err != nil {
		return
	}

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &node, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&node, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile service
	if err = r.ReconcileOwned(ctx, &node, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&node, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile stateful set
	if err = r.ReconcileOwned(ctx, &node, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client := polkadotClients.NewClient(&node)
		args := client.Args()
		args = append(args, node.Spec.ExtraArgs.Encode(false)...)
		homeDir := client.HomeDir()

		return r.specStatefulSet(&node, obj.(*appsv1.StatefulSet), homeDir, args)
	}); err != nil {
		return
	}

	return
}

// specConfigmap updates polkadot node configmap spec
func (r *NodeReconciler) specConfigmap(node *polkadotv1alpha1.Node, config *corev1.ConfigMap) {
	config.ObjectMeta.Labels = node.Labels

	if config.Data == nil {
		config.Data = make(map[string]string)
	}

	config.Data["convert_node_private_key.sh"] = convertNodePrivateKeyScript
}

// specService updates polkadot node service spec
func (r *NodeReconciler) specService(node *polkadotv1alpha1.Node, svc *corev1.Service) {
	labels := node.Labels

	svc.ObjectMeta.Labels = labels

	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
	}

	if node.Spec.Prometheus {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "prometheus",
			Port:       int32(node.Spec.PrometheusPort),
			TargetPort: intstr.FromString("prometheus"),
		})
	}

	if node.Spec.RPC {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "rpc",
			Port:       int32(node.Spec.RPCPort),
			TargetPort: intstr.FromString("rpc"),
		})
	}

	if node.Spec.WS {
		svc.Spec.Ports = append(svc.Spec.Ports, corev1.ServicePort{
			Name:       "ws",
			Port:       int32(node.Spec.WSPort),
			TargetPort: intstr.FromString("ws"),
		})
	}

	svc.Spec.Selector = labels
}

// nodeVolumes returns node volumes
func (r *NodeReconciler) nodeVolumes(node *polkadotv1alpha1.Node) (volumes []corev1.Volume) {
	dataVolume := corev1.Volume{
		Name: "data",
		VolumeSource: corev1.VolumeSource{
			PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
				ClaimName: node.Name,
			},
		},
	}
	volumes = append(volumes, dataVolume)

	configVolume := corev1.Volume{
		Name: "config",
		VolumeSource: corev1.VolumeSource{
			ConfigMap: &corev1.ConfigMapVolumeSource{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: node.Name,
				},
			},
		},
	}
	volumes = append(volumes, configVolume)

	if node.Spec.NodePrivateKeySecretName != "" {
		secretVolume := corev1.Volume{
			Name: "secret",
			VolumeSource: corev1.VolumeSource{
				Secret: &corev1.SecretVolumeSource{
					SecretName: node.Spec.NodePrivateKeySecretName,
					Items: []corev1.KeyToPath{
						{
							Key:  "key",
							Path: "nodekey",
						},
					},
				},
			},
		}
		volumes = append(volumes, secretVolume)
	}

	return
}

// nodeVolumeMounts returns node volume mounts
func (r *NodeReconciler) nodeVolumeMounts(node *polkadotv1alpha1.Node, homeDir string) (mounts []corev1.VolumeMount) {
	dataMount := corev1.VolumeMount{
		Name:      "data",
		MountPath: shared.PathData(homeDir),
	}
	mounts = append(mounts, dataMount)

	configMount := corev1.VolumeMount{
		Name:      "config",
		MountPath: shared.PathConfig(homeDir),
	}
	mounts = append(mounts, configMount)

	if node.Spec.NodePrivateKeySecretName != "" {
		secretMount := corev1.VolumeMount{
			Name:      "secret",
			MountPath: shared.PathSecrets(homeDir),
		}
		mounts = append(mounts, secretMount)
	}
	return
}

// specStatefulSet updates node statefulset spec
func (r *NodeReconciler) specStatefulSet(node *polkadotv1alpha1.Node, sts *appsv1.StatefulSet, homeDir string, args []string) error {

	sts.ObjectMeta.Labels = node.Labels

	var initContainers []corev1.Container

	if node.Spec.NodePrivateKeySecretName != "" {
		convertEnodePrivateKey := corev1.Container{
			Name:  "convert-node-private-key",
			Image: shared.BusyboxImage,
			Env: []corev1.EnvVar{
				{
					Name:  shared.EnvDataPath,
					Value: shared.PathData(homeDir),
				},
				{
					Name:  shared.EnvSecretsPath,
					Value: shared.PathSecrets(homeDir),
				},
			},
			Command:      []string{"/bin/sh"},
			Args:         []string{fmt.Sprintf("%s/convert_node_private_key.sh", shared.PathConfig(homeDir))},
			VolumeMounts: r.nodeVolumeMounts(node, homeDir),
		}
		initContainers = append(initContainers, convertEnodePrivateKey)
	}

	ports := []corev1.ContainerPort{
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
	}

	if node.Spec.Prometheus {
		ports = append(ports, corev1.ContainerPort{
			Name:          "prometheus",
			ContainerPort: int32(node.Spec.PrometheusPort),
		})
	}

	if node.Spec.RPC {
		ports = append(ports, corev1.ContainerPort{
			Name:          "rpc",
			ContainerPort: int32(node.Spec.RPCPort),
		})
	}

	if node.Spec.WS {
		ports = append(ports, corev1.ContainerPort{
			Name:          "ws",
			ContainerPort: int32(node.Spec.RPCPort),
		})
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: node.Labels,
		},
		ServiceName: node.Name,
		Replicas:    &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: node.Labels,
			},
			Spec: corev1.PodSpec{
				InitContainers:  initContainers,
				SecurityContext: shared.SecurityContext(),
				Containers: []corev1.Container{
					{
						Name:         "node",
						Image:        node.Spec.Image,
						Args:         args,
						Ports:        ports,
						VolumeMounts: r.nodeVolumeMounts(node, homeDir),
						Resources: corev1.ResourceRequirements{
							Requests: map[corev1.ResourceName]resource.Quantity{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPU),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Memory),
							},
							Limits: map[corev1.ResourceName]resource.Quantity{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPULimit),
								corev1.ResourceMemory: resource.MustParse(node.Spec.MemoryLimit),
							},
						},
					},
				},
				Volumes: r.nodeVolumes(node),
			},
		},
	}

	return nil
}

// specPVC updates ipfs peer persistent volume claim
func (r *NodeReconciler) specPVC(node *polkadotv1alpha1.Node, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(node.Spec.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = node.Labels
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
		StorageClassName: node.Spec.StorageClass,
	}
}

func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&polkadotv1alpha1.Node{}).
		Owns(&corev1.PersistentVolumeClaim{}).
		Owns(&corev1.Service{}).
		Owns(&corev1.ConfigMap{}).
		Owns(&appsv1.StatefulSet{}).
		Complete(r)
}

'''
'''--- controllers/polkadot/node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	polkadotv1alpha1 "github.com/kotalco/kotal/apis/polkadot/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("kusama node controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "polkadot",
		},
	}

	key := types.NamespacedName{
		Name:      "kusama-node",
		Namespace: ns.Name,
	}

	testImage := "kotalco/polkadot:controller-test"

	spec := polkadotv1alpha1.NodeSpec{
		Image:      testImage,
		Network:    "kusama",
		RPC:        true,
		WS:         true,
		Prometheus: true,
	}

	toCreate := &polkadotv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	t := true

	nodeOwnerReference := metav1.OwnerReference{
		APIVersion:         "polkadot.kotal.io/v1alpha1",
		Kind:               "Node",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("should create kusama node", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("Should get kusama node", func() {
		fetched := &polkadotv1alpha1.Node{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		nodeOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		Expect(fetched.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
	})

	It("Should create allocate correct resources to peer statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(polkadotv1alpha1.DefaultNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(polkadotv1alpha1.DefaultNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(polkadotv1alpha1.DefaultNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(polkadotv1alpha1.DefaultNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create node configmap", func() {
		fetched := &corev1.ConfigMap{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Data).To(HaveKey("convert_node_private_key.sh"))

	})

	It("Should create node data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(polkadotv1alpha1.DefaultNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It("Should create node service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "p2p",
					Port:       int32(polkadotv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "prometheus",
					Port:       int32(polkadotv1alpha1.DefaultPrometheusPort),
					TargetPort: intstr.FromString("prometheus"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "rpc",
					Port:       int32(polkadotv1alpha1.DefaultRPCPort),
					TargetPort: intstr.FromString("rpc"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "ws",
					Port:       int32(polkadotv1alpha1.DefaultWSPort),
					TargetPort: intstr.FromString("ws"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/polkadot/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	polkadotv1alpha1 "github.com/kotalco/kotal/apis/polkadot/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

// These tests use Ginkgo (BDD-style Go testing framework). Refer to
// http://onsi.github.io/ginkgo/ to learn more about Ginkgo.

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	// start the test environment
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = polkadotv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start node reconciler
	peerReconciler := &NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	peerReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	cancel()
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- controllers/polkadot/types.go ---
package controllers

'''
'''--- controllers/shared/env.go ---
package shared

const (
	EnvDataPath           = "KOTAL_DATA_PATH"
	EnvConfigPath         = "KOTAL_CONFIG_PATH"
	EnvSecretsPath        = "KOTAL_SECRETS_PATH"
	EnvUseExistingCluster = "USE_EXISTING_CLUSTER"
)

'''
'''--- controllers/shared/errors.go ---
package shared

import "k8s.io/apimachinery/pkg/api/errors"

// IgnoreConflicts ignore conflict errors
func IgnoreConflicts(err *error) {
	if errors.IsConflict(*err) {
		*err = nil
	}
}

'''
'''--- controllers/shared/host.go ---
package shared

// Host returns localhost if toggle is not enabled
// otherwise returns the wildcard address
func Host(toggle bool) string {
	if toggle {
		return "0.0.0.0"
	} else {
		return "127.0.0.1"
	}
}

'''
'''--- controllers/shared/host_test.go ---
package shared

import (
	"testing"
)

func TestHost(t *testing.T) {
	expected := "127.0.0.1"
	got := Host(false)

	if got != expected {
		t.Errorf("expected host to be %s but got %s", expected, got)
	}
}

'''
'''--- controllers/shared/labels.go ---
package shared

import (
	"fmt"
	"strings"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type CustomResource interface {
	metav1.Object
	GroupVersionKind() schema.GroupVersionKind
}

// UpdateLabels adds missing labels to the resource
func UpdateLabels(cr CustomResource, client, network string) {

	gvk := cr.GroupVersionKind()
	group := strings.Replace(gvk.Group, ".kotal.io", "", 1)
	kind := strings.ToLower(gvk.Kind)

	labels := cr.GetLabels()
	if labels == nil {
		labels = map[string]string{}
	}

	labels["app.kubernetes.io/name"] = client
	labels["app.kubernetes.io/instance"] = cr.GetName()
	labels["app.kubernetes.io/component"] = fmt.Sprintf("%s-%s", group, kind)
	labels["app.kubernetes.io/managed-by"] = "kotal-operator"
	labels["app.kubernetes.io/created-by"] = fmt.Sprintf("%s-%s-controller", group, kind)
	labels["kotal.io/protocol"] = group
	if network != "" {
		labels["kotal.io/network"] = network
	}

	cr.SetLabels(labels)

}

'''
'''--- controllers/shared/labels_test.go ---
package shared

import (
	"testing"

	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/scheme"
)

func TestUpdateLabels(t *testing.T) {

	if err := ethereumv1alpha1.AddToScheme(scheme.Scheme); err != nil {
		t.Error(err)
	}

	ethereumNode := ethereumv1alpha1.Node{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Node",
			APIVersion: "ethereum/v1alpha1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      "my-node",
			Namespace: "default",
		},
		Spec: ethereumv1alpha1.NodeSpec{
			Client:  ethereumv1alpha1.BesuClient,
			Network: ethereumv1alpha1.GoerliNetwork,
		},
	}

	UpdateLabels(&ethereumNode, string(ethereumNode.Spec.Client), ethereumv1alpha1.GoerliNetwork)

	labels := map[string]string{
		"app.kubernetes.io/name":       string(ethereumNode.Spec.Client),
		"app.kubernetes.io/instance":   ethereumNode.Name,
		"app.kubernetes.io/component":  "ethereum-node",
		"app.kubernetes.io/managed-by": "kotal-operator",
		"app.kubernetes.io/created-by": "ethereum-node-controller",
		"kotal.io/protocol":            "ethereum",
		"kotal.io/network":             ethereumv1alpha1.GoerliNetwork,
	}

	for k, v := range labels {
		if ethereumNode.Labels[k] != v {
			t.Errorf("Expecting label with key %s to have value %s, but got %s", k, v, ethereumNode.Labels[k])
		}
	}

}

'''
'''--- controllers/shared/path.go ---
package shared

import "fmt"

const (
	// BlockchainDataSubDir is the blockchain data sub directory
	BlockchainDataSubDir = "kotal-data"
	// SecretsSubDir is the secrets (private keys, password ... etc) sub directory
	SecretsSubDir = ".kotal-secrets"
	// ConfigSubDir is the configuration sub directory
	ConfigSubDir = "kotal-config"
)

// PathData returns blockchain data directory
func PathData(homeDir string) string {
	return fmt.Sprintf("%s/%s", homeDir, BlockchainDataSubDir)
}

// PathSecrets returns secrets directory
func PathSecrets(homeDir string) string {
	return fmt.Sprintf("%s/%s", homeDir, SecretsSubDir)
}

// PathConfig returns configuration directory
func PathConfig(homeDir string) string {
	return fmt.Sprintf("%s/%s", homeDir, ConfigSubDir)
}

'''
'''--- controllers/shared/path_test.go ---
package shared

import "testing"

const (
	testHomeDir = "/users/test"
)

func TestPathData(t *testing.T) {
	expected := "/users/test/kotal-data"
	got := PathData(testHomeDir)

	if got != expected {
		t.Errorf("expected data directory to be %s, got %s", expected, got)
	}
}

func TestPathConfig(t *testing.T) {
	expected := "/users/test/kotal-config"
	got := PathConfig(testHomeDir)

	if got != expected {
		t.Errorf("expected configuration directory to be %s, got %s", expected, got)
	}
}

func TestPathSecrets(t *testing.T) {
	expected := "/users/test/.kotal-secrets"
	got := PathSecrets(testHomeDir)

	if got != expected {
		t.Errorf("expected secrets directory to be %s, got %s", expected, got)
	}
}

'''
'''--- controllers/shared/reconciler.go ---
package shared

import (
	"context"

	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type Reconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

func (r *Reconciler) GetClient() client.Client {
	return r.Client
}

func (r *Reconciler) GetScheme() *runtime.Scheme {
	return r.Scheme
}

// ReconcileOwned reconciles k8s object according to custom resource spec
func (r Reconciler) ReconcileOwned(ctx context.Context, cr CustomResource, obj client.Object, updateFn func(client.Object) error) error {

	obj.SetName(cr.GetName())
	obj.SetNamespace(cr.GetNamespace())

	_, err := ctrl.CreateOrUpdate(ctx, r.GetClient(), obj, func() error {
		if err := ctrl.SetControllerReference(cr, obj, r.GetScheme()); err != nil {
			return err
		}

		updateFn(obj)

		return nil
	})

	return err
}

'''
'''--- controllers/shared/secret.go ---
package shared

import (
	"context"

	"sigs.k8s.io/controller-runtime/pkg/client"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
)

// GetSecret returns k8s secret stored at key
func GetSecret(ctx context.Context, client client.Client, name types.NamespacedName, key string) (value string, err error) {
	secret := &corev1.Secret{}

	if err = client.Get(ctx, name, secret); err != nil {
		return
	}

	value = string(secret.Data[key])

	return
}

'''
'''--- controllers/shared/security_context.go ---
package shared

import corev1 "k8s.io/api/core/v1"

// SecurityContext is the pod security policy used by all containers
func SecurityContext() *corev1.PodSecurityContext {
	var userId int64 = 1000
	var groupId int64 = 3000
	var fsGroupId int64 = 2000
	var nonRoot = true
	policy := corev1.FSGroupChangeOnRootMismatch

	return &corev1.PodSecurityContext{
		RunAsUser:           &userId,
		RunAsGroup:          &groupId,
		RunAsNonRoot:        &nonRoot,
		FSGroup:             &fsGroupId,
		FSGroupChangePolicy: &policy,
	}
}

'''
'''--- controllers/shared/security_context_test.go ---
package shared

import (
	"testing"

	corev1 "k8s.io/api/core/v1"
)

func TestSecurityContext(t *testing.T) {
	var userId int64 = 1000
	var groupId int64 = 3000
	var fsGroupId int64 = 2000
	var nonRoot = true
	policy := corev1.FSGroupChangeOnRootMismatch

	context := SecurityContext()

	if *context.RunAsUser != userId {
		t.Errorf("expected user id to be %d, got %d", userId, *context.RunAsUser)
	}

	if *context.RunAsGroup != groupId {
		t.Errorf("expected group id to be %d, got %d", groupId, *context.RunAsGroup)
	}

	if *context.FSGroup != fsGroupId {
		t.Errorf("expected fs group id to be %d, got %d", fsGroupId, *context.FSGroup)
	}

	if *context.RunAsNonRoot != nonRoot {
		t.Errorf("expected non root to be %t, got %t", nonRoot, *context.RunAsNonRoot)
	}

	if *context.FSGroupChangePolicy != policy {
		t.Errorf("expected fs group change policy to be %s, got %s", policy, *context.FSGroupChangePolicy)
	}

}

'''
'''--- controllers/shared/types.go ---
package shared

const (
	// BusyboxImage is the busybox images used by init containers
	BusyboxImage = "busybox:1.34.1"
)

'''
'''--- controllers/shared/webhook.go ---
package shared

import "os"

// IsWebhookEnabled checks if webhooks are enabled
func IsWebhookEnabled() bool {
	return os.Getenv("ENABLE_WEBHOOKS") != "false"
}

'''
'''--- controllers/shared/webhook_test.go ---
package shared

import "testing"

func TestIsWebhookEnabled(t *testing.T) {
	expected := true
	got := IsWebhookEnabled()
	if got != expected {
		t.Errorf("Expected webhook enabled to be %t , got %t", expected, got)
	}
}

'''
'''--- controllers/stacks/config.go ---
package controllers

import (
	"bytes"
	"context"
	"fmt"

	"github.com/BurntSushi/toml"
	stacksv1alpha1 "github.com/kotalco/kotal/apis/stacks/v1alpha1"
	stacksClients "github.com/kotalco/kotal/clients/stacks"
	"github.com/kotalco/kotal/controllers/shared"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type BurnChain struct {
	Chain    string `toml:"chain"`
	Mode     string `toml:"mode"`
	PeerHost string `toml:"peer_host"`
	Username string `toml:"username"`
	Password string `toml:"password"`
	RPCPort  uint   `toml:"rpc_port"`
	PeerPort uint   `toml:"peer_port"`
}

type Node struct {
	WorkingDir      string `toml:"working_dir"`
	RPCBind         string `toml:"rpc_bind"`
	P2PBind         string `toml:"p2p_bind"`
	Seed            string `toml:"seed,omitempty"`
	LocalPeerSeed   string `toml:"local_peer_seed"`
	Miner           bool   `toml:"miner"`
	MineMicroblocks bool   `toml:"mine_microblocks,omitempty"`
}

type Config struct {
	Node      Node      `toml:"node"`
	BurnChain BurnChain `toml:"burnchain"`
}

// ConfigFromSpec generates config.toml file from node spec
func ConfigFromSpec(node *stacksv1alpha1.Node, client client.Client) (config string, err error) {
	c := &Config{}

	c.Node = Node{
		WorkingDir: shared.PathData(stacksClients.StacksNodeHomeDir),
		RPCBind:    fmt.Sprintf("%s:%d", shared.Host(node.Spec.RPC), node.Spec.RPCPort),
		P2PBind:    fmt.Sprintf("%s:%d", shared.Host(true), node.Spec.P2PPort),
		Miner:      node.Spec.Miner,
	}

	if node.Spec.Miner {
		var seedPrivateKey string
		name := types.NamespacedName{
			Name:      node.Spec.SeedPrivateKeySecretName,
			Namespace: node.Namespace,
		}
		seedPrivateKey, err = shared.GetSecret(context.Background(), client, name, "key")
		if err != nil {
			return
		}

		c.Node.Seed = seedPrivateKey
		c.Node.MineMicroblocks = node.Spec.MineMicroblocks
	}

	if node.Spec.NodePrivateKeySecretName != "" {
		var nodePrivateKey string
		name := types.NamespacedName{
			Name:      node.Spec.NodePrivateKeySecretName,
			Namespace: node.Namespace,
		}
		nodePrivateKey, err = shared.GetSecret(context.Background(), client, name, "key")
		if err != nil {
			return
		}

		c.Node.LocalPeerSeed = nodePrivateKey
	}

	name := types.NamespacedName{
		Name:      node.Spec.BitcoinNode.RpcPasswordSecretName,
		Namespace: node.Namespace,
	}
	password, err := shared.GetSecret(context.Background(), client, name, "password")
	if err != nil {
		return
	}

	c.BurnChain = BurnChain{
		Chain:    "bitcoin",
		Mode:     string(node.Spec.Network),
		PeerHost: node.Spec.BitcoinNode.Endpoint,
		Username: node.Spec.BitcoinNode.RpcUsername,
		Password: password,
		RPCPort:  node.Spec.BitcoinNode.RpcPort,
		PeerPort: node.Spec.BitcoinNode.P2pPort,
	}

	var buff bytes.Buffer
	enc := toml.NewEncoder(&buff)
	err = enc.Encode(c)
	if err != nil {
		return
	}

	config = buff.String()

	return
}

'''
'''--- controllers/stacks/node_controller.go ---
package controllers

import (
	"context"

	stacksClients "github.com/kotalco/kotal/clients/stacks"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"

	stacksv1alpha1 "github.com/kotalco/kotal/apis/stacks/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
)

// NodeReconciler reconciles a Node object
type NodeReconciler struct {
	shared.Reconciler
}

// +kubebuilder:rbac:groups=stacks.kotal.io,resources=nodes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=stacks.kotal.io,resources=nodes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=watch;get;list;create;update;delete
// +kubebuilder:rbac:groups=core,resources=services;configmaps,verbs=watch;get;create;update;list;delete

func (r *NodeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	defer shared.IgnoreConflicts(&err)

	var node stacksv1alpha1.Node

	if err = r.Client.Get(ctx, req.NamespacedName, &node); err != nil {
		err = client.IgnoreNotFound(err)
		return
	}

	// default the node if webhooks are disabled
	if !shared.IsWebhookEnabled() {
		node.Default()
	}

	shared.UpdateLabels(&node, "stacks-node", string(node.Spec.Network))

	// reconcile config map
	if err = r.ReconcileOwned(ctx, &node, &corev1.ConfigMap{}, func(obj client.Object) error {
		configToml, err := ConfigFromSpec(&node, r.Client)
		if err != nil {
			return err
		}
		r.specConfigmap(&node, obj.(*corev1.ConfigMap), configToml)
		return nil
	}); err != nil {
		return
	}

	// reconcile persistent volume claim
	if err = r.ReconcileOwned(ctx, &node, &corev1.PersistentVolumeClaim{}, func(obj client.Object) error {
		r.specPVC(&node, obj.(*corev1.PersistentVolumeClaim))
		return nil
	}); err != nil {
		return
	}

	// reconcile service
	if err = r.ReconcileOwned(ctx, &node, &corev1.Service{}, func(obj client.Object) error {
		r.specService(&node, obj.(*corev1.Service))
		return nil
	}); err != nil {
		return
	}

	// reconcile stateful set
	if err = r.ReconcileOwned(ctx, &node, &appsv1.StatefulSet{}, func(obj client.Object) error {
		client := stacksClients.NewClient(&node)

		homeDir := client.HomeDir()
		cmd := client.Command()
		args := client.Args()
		args = append(args, node.Spec.ExtraArgs.Encode(false)...)
		env := client.Env()

		return r.specStatefulSet(&node, obj.(*appsv1.StatefulSet), homeDir, env, cmd, args)
	}); err != nil {
		return
	}

	if err = r.updateStatus(ctx, &node); err != nil {
		return
	}

	return
}

// updateStatus updates Stacks node status
func (r *NodeReconciler) updateStatus(ctx context.Context, node *stacksv1alpha1.Node) error {
	node.Status.Client = "stacks"

	if err := r.Status().Update(ctx, node); err != nil {
		log.FromContext(ctx).Error(err, "unable to update node status")
		return err
	}

	return nil
}

// specConfigmap updates node statefulset spec
func (r *NodeReconciler) specConfigmap(node *stacksv1alpha1.Node, configmap *corev1.ConfigMap, configToml string) {
	configmap.ObjectMeta.Labels = node.Labels

	if configmap.Data == nil {
		configmap.Data = map[string]string{}
	}

	configmap.Data["config.toml"] = configToml

}

// specPVC updates Stacks node persistent volume claim
func (r *NodeReconciler) specPVC(node *stacksv1alpha1.Node, pvc *corev1.PersistentVolumeClaim) {
	request := corev1.ResourceList{
		corev1.ResourceStorage: resource.MustParse(node.Spec.Storage),
	}

	// spec is immutable after creation except resources.requests for bound claims
	if !pvc.CreationTimestamp.IsZero() {
		pvc.Spec.Resources.Requests = request
		return
	}

	pvc.ObjectMeta.Labels = node.Labels
	pvc.Spec = corev1.PersistentVolumeClaimSpec{
		AccessModes: []corev1.PersistentVolumeAccessMode{
			corev1.ReadWriteOnce,
		},
		Resources: corev1.VolumeResourceRequirements{
			Requests: request,
		},
	}
}

// specService updates Bitcoin node service spec
func (r *NodeReconciler) specService(node *stacksv1alpha1.Node, svc *corev1.Service) {
	labels := node.Labels

	svc.ObjectMeta.Labels = labels

	svc.Spec.Ports = []corev1.ServicePort{
		{
			Name:       "p2p",
			Port:       int32(node.Spec.P2PPort),
			TargetPort: intstr.FromString("p2p"),
		},
		{
			Name:       "rpc",
			Port:       int32(node.Spec.RPCPort),
			TargetPort: intstr.FromString("rpc"),
		},
	}

	svc.Spec.Selector = labels
}

// specStatefulSet updates node statefulset spec
func (r *NodeReconciler) specStatefulSet(node *stacksv1alpha1.Node, sts *appsv1.StatefulSet, homeDir string, env []corev1.EnvVar, cmd, args []string) error {

	sts.ObjectMeta.Labels = node.Labels

	ports := []corev1.ContainerPort{
		{
			Name:          "p2p",
			ContainerPort: int32(node.Spec.P2PPort),
		},
		{
			Name:          "rpc",
			ContainerPort: int32(node.Spec.RPCPort),
		},
	}

	replicas := int32(*node.Spec.Replicas)

	sts.Spec = appsv1.StatefulSetSpec{
		Selector: &metav1.LabelSelector{
			MatchLabels: node.Labels,
		},
		ServiceName: node.Name,
		Replicas:    &replicas,
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Labels: node.Labels,
			},
			Spec: corev1.PodSpec{
				SecurityContext: shared.SecurityContext(),
				Containers: []corev1.Container{
					{
						Name:    "node",
						Image:   node.Spec.Image,
						Command: cmd,
						Args:    args,
						Ports:   ports,
						Env:     env,
						Resources: corev1.ResourceRequirements{
							Requests: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPU),
								corev1.ResourceMemory: resource.MustParse(node.Spec.Memory),
							},
							Limits: corev1.ResourceList{
								corev1.ResourceCPU:    resource.MustParse(node.Spec.CPULimit),
								corev1.ResourceMemory: resource.MustParse(node.Spec.MemoryLimit),
							},
						},
						VolumeMounts: []corev1.VolumeMount{
							{
								Name:      "data",
								MountPath: shared.PathData(homeDir),
							},
							{
								Name:      "config",
								ReadOnly:  true,
								MountPath: shared.PathConfig(homeDir),
							},
						},
					},
				},
				Volumes: []corev1.Volume{
					{
						Name: "config",
						VolumeSource: corev1.VolumeSource{
							ConfigMap: &corev1.ConfigMapVolumeSource{
								LocalObjectReference: corev1.LocalObjectReference{
									Name: node.Name,
								},
							},
						},
					},
					{
						Name: "data",
						VolumeSource: corev1.VolumeSource{
							PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
								ClaimName: node.Name,
							},
						},
					},
				},
			},
		},
	}

	return nil
}

func (r *NodeReconciler) SetupWithManager(mgr ctrl.Manager) error {
	pred := predicate.GenerationChangedPredicate{}
	return ctrl.NewControllerManagedBy(mgr).
		For(&stacksv1alpha1.Node{}).
		WithEventFilter(pred).
		Owns(&appsv1.StatefulSet{}).
		Owns(&corev1.ConfigMap{}).
		Owns(&corev1.Service{}).
		Complete(r)
}

'''
'''--- controllers/stacks/node_controller_test.go ---
package controllers

import (
	"context"
	"fmt"
	"os"
	"time"

	stacksv1alpha1 "github.com/kotalco/kotal/apis/stacks/v1alpha1"
	stacksClients "github.com/kotalco/kotal/clients/stacks"
	"github.com/kotalco/kotal/controllers/shared"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var _ = Describe("Stacks node controller", func() {
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "stacks",
		},
	}

	key := types.NamespacedName{
		Name:      "stacks-node",
		Namespace: ns.Name,
	}

	testImage := "kotalco/stacks:controller-test"

	spec := stacksv1alpha1.NodeSpec{
		Image:   testImage,
		Network: stacksv1alpha1.Mainnet,
		BitcoinNode: stacksv1alpha1.BitcoinNode{
			Endpoint:              "bitcoin.blockstack.com",
			P2pPort:               8332,
			RpcPort:               8333,
			RpcUsername:           "blockstack",
			RpcPasswordSecretName: "bitcoin-node-rpc-password",
		},
	}

	toCreate := &stacksv1alpha1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name:      key.Name,
			Namespace: key.Namespace,
		},
		Spec: spec,
	}

	client := stacksClients.NewClient(toCreate)

	t := true

	nodeOwnerReference := metav1.OwnerReference{
		APIVersion:         "stacks.kotal.io/v1alpha1",
		Kind:               "Node",
		Name:               toCreate.Name,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}

	It(fmt.Sprintf("Should create %s namespace", ns.Name), func() {
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())
	})

	It("Should create Bitcoin node rpc password secret", func() {
		secret := corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "bitcoin-node-rpc-password",
				Namespace: ns.Name,
			},
			StringData: map[string]string{
				"password": "blockstacksystem",
			},
		}
		Expect(k8sClient.Create(context.Background(), &secret)).To(Succeed())
	})

	It("should create Stacks node", func() {
		if os.Getenv(shared.EnvUseExistingCluster) != "true" {
			toCreate.Default()
		}
		Expect(k8sClient.Create(context.Background(), toCreate)).Should(Succeed())
	})

	It("Should get Stacks node", func() {
		fetched := &stacksv1alpha1.Node{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec).To(Equal(toCreate.Spec))
		nodeOwnerReference.UID = fetched.UID
		time.Sleep(5 * time.Second)
	})

	It("Should create peer configmap", func() {
		fetched := &corev1.ConfigMap{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Data).To(HaveKey("config.toml"))
	})

	It("Should create node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(*fetched.Spec.Template.Spec.SecurityContext).To(gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
			"RunAsUser":    gstruct.PointTo(Equal(int64(1000))),
			"RunAsGroup":   gstruct.PointTo(Equal(int64(3000))),
			"FSGroup":      gstruct.PointTo(Equal(int64(2000))),
			"RunAsNonRoot": gstruct.PointTo(Equal(true)),
		}))
		Expect(fetched.Spec.Template.Spec.Containers[0].Name).To(Equal("node"))
		Expect(fetched.Spec.Template.Spec.Containers[0].Image).To(Equal(testImage))
		Expect(fetched.Spec.Template.Spec.Containers[0].Env).To(Equal(client.Env()))
		Expect(fetched.Spec.Template.Spec.Containers[0].Command).To(Equal(client.Command()))
		Expect(fetched.Spec.Template.Spec.Containers[0].Args).To(Equal(client.Args()))
		Expect(fetched.Spec.Template.Spec.Containers[0].VolumeMounts).To(ContainElements(
			corev1.VolumeMount{
				Name:      "data",
				MountPath: shared.PathData(client.HomeDir()),
			},
			corev1.VolumeMount{
				Name:      "config",
				ReadOnly:  true,
				MountPath: shared.PathConfig(client.HomeDir()),
			},
		))
		// volumes
		mode := corev1.ConfigMapVolumeSourceDefaultMode
		Expect(fetched.Spec.Template.Spec.Volumes).To(ContainElements(
			[]corev1.Volume{
				{
					Name: "data",
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: toCreate.Name,
						},
					},
				},
				{
					Name: "config",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: toCreate.Name,
							},
							DefaultMode: &mode,
						},
					},
				},
			},
		))
	})

	It("Should create allocate correct resources to node statefulset", func() {
		fetched := &appsv1.StatefulSet{}
		expectedResources := corev1.ResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(stacksv1alpha1.DefaultNodeCPURequest),
				corev1.ResourceMemory: resource.MustParse(stacksv1alpha1.DefaultNodeMemoryRequest),
			},
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse(stacksv1alpha1.DefaultNodeCPULimit),
				corev1.ResourceMemory: resource.MustParse(stacksv1alpha1.DefaultNodeMemoryLimit),
			},
		}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.Spec.Template.Spec.Containers[0].Resources).To(Equal(expectedResources))
	})

	It("Should create node data persistent volume with correct resources", func() {
		fetched := &corev1.PersistentVolumeClaim{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		expectedResources := corev1.VolumeResourceRequirements{
			Requests: corev1.ResourceList{
				corev1.ResourceStorage: resource.MustParse(stacksv1alpha1.DefaultNodeStorageRequest),
			},
		}
		Expect(fetched.Spec.Resources).To(Equal(expectedResources))
	})

	It("Should create node service", func() {
		fetched := &corev1.Service{}
		Expect(k8sClient.Get(context.Background(), key, fetched)).To(Succeed())
		Expect(fetched.OwnerReferences).To(ContainElements(nodeOwnerReference))
		Expect(fetched.Spec.Ports).To(ContainElements(
			[]corev1.ServicePort{
				{
					Name:       "p2p",
					Port:       int32(stacksv1alpha1.DefaultP2PPort),
					TargetPort: intstr.FromString("p2p"),
					Protocol:   corev1.ProtocolTCP,
				},
				{
					Name:       "rpc",
					Port:       int32(stacksv1alpha1.DefaultRPCPort),
					TargetPort: intstr.FromString("rpc"),
					Protocol:   corev1.ProtocolTCP,
				},
			},
		))
	})

	It(fmt.Sprintf("Should delete %s namespace", ns.Name), func() {
		Expect(k8sClient.Delete(context.Background(), ns)).To(Succeed())
	})

})

'''
'''--- controllers/stacks/suite_test.go ---
package controllers

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"

	stacksv1alpha1 "github.com/kotalco/kotal/apis/stacks/v1alpha1"
	"github.com/kotalco/kotal/controllers/shared"
	// +kubebuilder:scaffold:imports
)

var cfg *rest.Config
var k8sClient client.Client
var testEnv *envtest.Environment
var ctx context.Context
var cancel context.CancelFunc

func TestAPIs(t *testing.T) {
	RegisterFailHandler(Fail)

	suiteConfig, reporterConfig := GinkgoConfiguration()

	RunSpecs(t,
		"Controller Suite",
		suiteConfig,
		reporterConfig)
}

var _ = BeforeSuite(func() {
	logf.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))

	ctx, cancel = context.WithCancel(context.TODO())

	By("bootstrapping test environment")
	// create new test environment
	if os.Getenv(shared.EnvUseExistingCluster) == "true" {
		t := true
		testEnv = &envtest.Environment{
			UseExistingCluster: &t,
		}
	} else {
		testEnv = &envtest.Environment{
			CRDDirectoryPaths: []string{filepath.Join("..", "..", "config", "crd", "bases")},
		}
	}

	var err error
	// start the test environment
	cfg, err = testEnv.Start()
	Expect(err).ToNot(HaveOccurred())
	Expect(cfg).ToNot(BeNil())

	err = stacksv1alpha1.AddToScheme(scheme.Scheme)
	Expect(err).NotTo(HaveOccurred())

	// +kubebuilder:scaffold:scheme

	// create new controller manager
	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Metrics: server.Options{BindAddress: "0"},
		Scheme:  scheme.Scheme,
	})
	Expect(err).ToNot(HaveOccurred())

	k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sClient).ToNot(BeNil())

	// start node reconciler
	nodeReconciler := &NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: k8sManager.GetClient(),
			Scheme: scheme.Scheme,
		},
	}
	nodeReconciler.SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

})

var _ = AfterSuite(func() {
	By("tearing down the test environment")
	cancel()
	err := testEnv.Stop()
	Expect(err).ToNot(HaveOccurred())
})

'''
'''--- hack/boilerplate.go.txt ---

'''
'''--- helpers/node.go ---
package helpers

import (
	"crypto/ecdsa"
	"errors"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/crypto"
)

func derive(fromPrivateKey string) (publicKeyECDSA *ecdsa.PublicKey, err error) {
	// private key
	privateKey, err := crypto.HexToECDSA(fromPrivateKey)
	if err != nil {
		return
	}

	// public key
	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		err = errors.New("publicKey is not of type *ecdsa.PublicKey")
		return
	}

	return
}

// DerivePublicKey drives node public key from private key
func DerivePublicKey(fromPrivateKey string) (publicKeyHex string, err error) {
	publicKeyECDSA, err := derive(fromPrivateKey)
	if err != nil {
		return
	}

	publicKeyBytes := crypto.FromECDSAPub(publicKeyECDSA)
	publicKeyHex = hexutil.Encode(publicKeyBytes)[4:]

	return

}

// DeriveAddress drives ethereum address from private key
func DeriveAddress(fromPrivateKey string) (addressHex string, err error) {
	publicKeyECDSA, err := derive(fromPrivateKey)
	if err != nil {
		return
	}

	addressHex = crypto.PubkeyToAddress(*publicKeyECDSA).Hex()
	return

}

'''
'''--- main.go ---
package main

import (
	"flag"
	"os"

	"k8s.io/apimachinery/pkg/runtime"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	_ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/healthz"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"
	"sigs.k8s.io/controller-runtime/pkg/webhook"

	aptosv1alpha1 "github.com/kotalco/kotal/apis/aptos/v1alpha1"
	bitcoinv1alpha1 "github.com/kotalco/kotal/apis/bitcoin/v1alpha1"
	chainlinkv1alpha1 "github.com/kotalco/kotal/apis/chainlink/v1alpha1"
	ethereumv1alpha1 "github.com/kotalco/kotal/apis/ethereum/v1alpha1"
	ethereum2v1alpha1 "github.com/kotalco/kotal/apis/ethereum2/v1alpha1"
	filecoinv1alpha1 "github.com/kotalco/kotal/apis/filecoin/v1alpha1"
	graphv1alpha1 "github.com/kotalco/kotal/apis/graph/v1alpha1"
	ipfsv1alpha1 "github.com/kotalco/kotal/apis/ipfs/v1alpha1"
	nearv1alpha1 "github.com/kotalco/kotal/apis/near/v1alpha1"
	polkadotv1alpha1 "github.com/kotalco/kotal/apis/polkadot/v1alpha1"
	stacksv1alpha1 "github.com/kotalco/kotal/apis/stacks/v1alpha1"
	aptoscontroller "github.com/kotalco/kotal/controllers/aptos"
	bitcoincontroller "github.com/kotalco/kotal/controllers/bitcoin"
	chainlinkcontroller "github.com/kotalco/kotal/controllers/chainlink"
	ethereumcontroller "github.com/kotalco/kotal/controllers/ethereum"
	ethereum2controller "github.com/kotalco/kotal/controllers/ethereum2"
	filecoincontroller "github.com/kotalco/kotal/controllers/filecoin"
	graphcontrollers "github.com/kotalco/kotal/controllers/graph"
	ipfscontroller "github.com/kotalco/kotal/controllers/ipfs"
	nearcontroller "github.com/kotalco/kotal/controllers/near"
	polkadotcontroller "github.com/kotalco/kotal/controllers/polkadot"
	"github.com/kotalco/kotal/controllers/shared"
	stackscontroller "github.com/kotalco/kotal/controllers/stacks"
	// +kubebuilder:scaffold:imports
)

var (
	scheme         = runtime.NewScheme()
	setupLog       = ctrl.Log.WithName("setup")
	enableWebhooks = os.Getenv("ENABLE_WEBHOOKS") != "false"
)

func init() {
	utilruntime.Must(clientgoscheme.AddToScheme(scheme))
	utilruntime.Must(ethereumv1alpha1.AddToScheme(scheme))
	utilruntime.Must(ethereum2v1alpha1.AddToScheme(scheme))
	utilruntime.Must(ipfsv1alpha1.AddToScheme(scheme))
	utilruntime.Must(filecoinv1alpha1.AddToScheme(scheme))
	utilruntime.Must(polkadotv1alpha1.AddToScheme(scheme))
	utilruntime.Must(chainlinkv1alpha1.AddToScheme(scheme))
	utilruntime.Must(nearv1alpha1.AddToScheme(scheme))
	utilruntime.Must(bitcoinv1alpha1.AddToScheme(scheme))
	utilruntime.Must(stacksv1alpha1.AddToScheme(scheme))
	utilruntime.Must(aptosv1alpha1.AddToScheme(scheme))
	utilruntime.Must(graphv1alpha1.AddToScheme(scheme))
	// +kubebuilder:scaffold:scheme
}

func main() {
	var metricsAddr, probeAddr string
	var enableLeaderElection bool

	flag.StringVar(&metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
	flag.StringVar(&probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
	flag.BoolVar(&enableLeaderElection, "leader-elect", false,
		"Enable leader election for controller manager. "+
			"Enabling this will ensure there is only one active controller manager.")

	opts := zap.Options{
		Development: true,
	}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()

	ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))

	webhookServer := webhook.NewServer(webhook.Options{
		Port: 9443,
	})
	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme: scheme,
		Metrics: server.Options{
			BindAddress: metricsAddr,
		},
		HealthProbeBindAddress: probeAddr,
		WebhookServer:          webhookServer,
		LeaderElection:         enableLeaderElection,
		LeaderElectionID:       "2b1fce2f.kotal.io",
	})
	if err != nil {
		setupLog.Error(err, "unable to start manager")
		os.Exit(1)
	}

	if err = (&filecoincontroller.NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&filecoinv1alpha1.Node{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}

	if err = (&ethereumcontroller.NodeReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&ethereumv1alpha1.Node{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}

	if err = (&ethereum2controller.BeaconNodeReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "BeaconNode")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&ethereum2v1alpha1.BeaconNode{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}

	if err = (&ethereum2controller.ValidatorReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Validator")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&ethereum2v1alpha1.Validator{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Validator")
			os.Exit(1)
		}
	}

	if err = (&ipfscontroller.PeerReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Peer")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&ipfsv1alpha1.Peer{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Peer")
			os.Exit(1)
		}
	}

	if err = (&ipfscontroller.ClusterPeerReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "ClusterPeer")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&ipfsv1alpha1.ClusterPeer{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "ClusterPeer")
			os.Exit(1)
		}
	}

	if err = (&polkadotcontroller.NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&polkadotv1alpha1.Node{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}

	if err = (&chainlinkcontroller.NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&chainlinkv1alpha1.Node{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}

	if err = (&nearcontroller.NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&nearv1alpha1.Node{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}

	if err = (&bitcoincontroller.NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&bitcoinv1alpha1.Node{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}

	if err = (&stackscontroller.NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&stacksv1alpha1.Node{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}
	if err = (&aptoscontroller.NodeReconciler{
		Reconciler: shared.Reconciler{
			Client: mgr.GetClient(),
			Scheme: mgr.GetScheme(),
		},
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	if enableWebhooks {
		if err = (&aptosv1alpha1.Node{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create webhook", "webhook", "Node")
			os.Exit(1)
		}
	}
	if err = (&graphcontrollers.NodeReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Node")
		os.Exit(1)
	}
	// +kubebuilder:scaffold:builder

	if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil {
		setupLog.Error(err, "unable to set up health check")
		os.Exit(1)
	}
	if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil {
		setupLog.Error(err, "unable to set up ready check")
		os.Exit(1)
	}

	setupLog.Info("starting manager")
	if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {
		setupLog.Error(err, "problem running manager")
		os.Exit(1)
	}
}

'''
'''--- multi.sh ---
#!/bin/sh

set -e

K8S_PROVIDER="${K8S_PROVIDER:-kind}"

function cleanup {
  echo "🧽 Cleaning up"
  if [ "$K8S_PROVIDER" == "minikube" ]
    then
      minikube delete --all
    else
      kind delete clusters --all
  fi
}

trap cleanup EXIT

if ! docker info > /dev/null 2>&1; then
  echo "Docker isn't running"
  echo "Start docker, then try again!"
  exit 1
fi

if [ "$KOTAL_VERSION" == "" ]
then
  # build manager image once
  echo "Building docker image"
  make docker-build
fi

if [ "$K8S_PROVIDER" == "minikube" ]
then
# minikube cluster versions
VERSIONS=("1.19.0" "1.20.0" "1.21.0" "1.22.0" "1.23.0" "1.24.0" "1.25.0" "1.26.0")
echo "🗑 Deleting all Minikube clusters"
minikube delete --all
else
# kind cluster versions
# https://hub.docker.com/r/kindest/node/tags
VERSIONS=("1.19.16" "1.20.15" "1.21.14" "1.22.17" "1.23.17" "1.24.15" "1.25.11" "1.26.6" "1.27.3" "1.28.0" "1.29.0")
echo "🗑 Deleting all Kind clusters"
kind delete clusters --all
fi

for VERSION in "${VERSIONS[@]}"
do
  echo "Testing Kotal operator in kubernetes v$VERSION"
    # start Kubernetes in Docker with this kubernetes version
    echo "Creating cluster"
    if [ "$K8S_PROVIDER" == "minikube" ]
    then
      minikube start --kubernetes-version=v${VERSION}
    else
	    kind create cluster --image=kindest/node:v${VERSION}
    fi
    # install cert-manager
    echo "Installing cert manager"
    kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.5.3/cert-manager.yaml
    # load image and deploy manifests
    echo "⏳ Waiting for cert manager to be up and running"
    sleep 5
    kubectl wait -n cert-manager --for=condition=available deployments/cert-manager --timeout=600s
    kubectl wait -n cert-manager --for=condition=available deployments/cert-manager-cainjector --timeout=600s
    kubectl wait -n cert-manager --for=condition=available deployments/cert-manager-webhook --timeout=600s
    echo "🚀 Cert manager is up and running"

    if [ "$KOTAL_VERSION" == "" ]
    then
      echo "Installing Kotal custom resources"
      echo "Deploying Kotal controller manager"
      if [ "$K8S_PROVIDER" == "minikube" ]
      then
        make minikube
      else
        make kind
      fi
    else
      kubectl apply -f https://github.com/kotalco/kotal/releases/download/$KOTAL_VERSION/kotal.yaml
    fi

    echo "⏳ Waiting for kotal controller manager to be up and running"
    kubectl wait -n kotal --for=condition=available deployments/controller-manager --timeout=600s
    echo "🚀 Kotal is up and running"

    echo "🔥 Running tests"
    # test against image
    USE_EXISTING_CLUSTER=true make test
    # delete cluster
    echo "🎉 All tests has been passed"

    echo "🔥 Deleting kubernetes cluster v$VERSION"
    if [ "$K8S_PROVIDER" == "minikube" ]
    then
      minikube delete
    else
      kind delete cluster
    fi
done
'''