*GitHub Repository "hdriqi/near-textile-indexer-example"*

'''--- README.md ---
# near-textile-indexer-example

This repo is example on how to use [near-textile-indexer](https://github.com/hdriqi/near-textile-indexer)

This example is using AssemblyScript-based smart contract. The indexer is also available for Rust-based smart contract as long it is satisfy the required `methods` and the `Event type`

## How to

1. Clone this repo
```bash
git clone https://github.com/hdriqi/near-textile-indexer-example
```

2. Install dependency
```bash
yarn install or npm install
``` 

# Env Setup

Create `env` based on the `env.sample`.

Here's the basic setup for NEAR testnet
```
NETWORK_ID=default
NODE_URL=https://rpc.testnet.near.org
```

## Contract

You need to deploy the smart contract to NEAR blockchain.

```bash
yarn deploy:dev
```

or use the already deployed contract on testnet at [dev-1601093501138-5843386](https://explorer.testnet.near.org/accounts/dev-1601093501138-5843386)

update the `env`

```
CONTRACT_NAME=dev-1601093501138-5843386
```

## Generate Textile API Key

You need to generate `user group` API key from Textile and put it in `env`

[Read from Textile docs](https://docs.textile.io/hub/apis/)

OPTIONAL:

You also can generate another `user group` API key from Textile to be a client-side API & public use.
Make sure both of them are on the same org.

```
TEXTILE_API_KEY=xxx(required)
PUBLIC_TEXTILE_API_KEY=xxx(optional)
```

## Generate Account

You need to provide a master account that can write to the database.

```bash
node gen-account.js
```

Copy the privateKey and put it in to `env` variables for indexer authentication.

```
ADMIN_PRIVATE_KEY=xxx(required)
```

Copy the publicKey and put it in in writeValidator function in `index.js`. 

```js
const writeValidator = (writer) => {
	// only allow admin public key to write new data to thread
	if (writer == 'UPDATE_PUBLIC_KEY') {
		return true
	}
	return false
}
```

Notes: `writeValidator` only does not support external variable, so you can only update the pubKey via string.

## Run Indexer

When everything is ready, you can run the indexer by using:

```bash
node index.js
```

## Query

After indexing, you can query the data using the example query provided on `example-query.js`

```bash
node example-query.js
```
'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports');
'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json", 
  "entry": "assembly/main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
}
'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__tests__/main.spec.ts ---
import { Memento, Img, Post, Content } from '../model'
import { createPost, createMemento, init, balanceOf, piecePost } from '../main'
import { u128 } from 'near-sdk-as'

var memento: Memento

describe('Memento ', () => {
  beforeEach(() => {
    const name = 'Hello World'
    const category = 'art'
    const img = new Img()
    const desc = 'Memento test'
    const type = 'personal'
    memento = createMemento(name, category, img, desc, type)

    init('bob')

    for (let i = 0; i < 5; i++) {
      const contentList: Content[] = []
      const mementoId = memento.id
      createPost(contentList, mementoId)
    }
  })
  afterEach(() => {

  })

  it('should create published post', () => {
    const contentList: Content[] = []
    const mementoId = memento.id
    const p = createPost(contentList, mementoId)
    expect(p instanceof Post).toBeTruthy()
  })

  it('should get balance', () => {
    const balance = balanceOf('bob')
    log(balance.toString())
  })

  it('should piecePost', () => {
    const contentList: Content[] = []
    const mementoId = memento.id
    const p = createPost(contentList, mementoId)
    if (p) {
      piecePost(p.id, "10")
    }
  })
})

'''
'''--- assembly/__tests__/memento.spec.ts ---
import { createMemento, updateMemento } from '../main'
import { Memento, mementoCollection, Img } from '../model'

describe('Memento ', () => {
  afterEach( () => {
    mementoCollection.delete('list')
  })

  it('should create memento', () => {
    const name = 'Hello World'
    const category = 'tech'
    const img: Img = {
      url: 'test',
      type: 'ipfs'
    }
    const desc = 'Memento test'
    const type = 'public'
    const m = createMemento(name, category, img, desc, type)

    const newM = mementoCollection.getSome(m.id)
    expect(m.id).toBe(newM.id)
  })

  it('should update memento', () => {
    const name = 'Hello World'
    const category = 'tech'
    const img: Img = {
      url: 'test',
      type: 'ipfs'
    }
    const desc = 'Memento test'
    const type = 'public'
    const m = createMemento(name, category, img, desc, type)

    const newDesc = 'Hello world'
    updateMemento(m.id, m.img, newDesc)

    const newM = mementoCollection.get(m.id)
    if(newM) {
      expect(newM.desc).toBe(newDesc)  
    }
  })

  // itThrows('should throw error Memento type', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'random'
  //   createMemento(name, desc, descRaw, type)
  // })

  // it('should get all memento list', () => {
  //   const len = 10
  //   for (let i = 0; i < len; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList()
  //   expect(result.length).toBe(len)
  // })

  // it('should get memento list by name', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   for (let i = 0; i < 5; i++) {
  //     const name = 'Another World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['name:=Hello World'])
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento list by name like', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Another World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['name_like:=worl'])
  //   expect(result.length).toBe(6)
  // })

  // it('should get memento list by owner', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['owner:='.concat(context.sender)])
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento list with sort by desc', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList([], {
  //     _embed: true,
  //     _order: 'createdAt',
  //     _sort: 'desc',
  //     _limit: 10
  //   })
  //   expect(result[0].createdAt).toBeGreaterThanOrEqual(result[1].createdAt)
  // })

  // it('should get memento list with limit', () => {
  //   for (let i = 0; i < 10; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList([], {
  //     _embed: true,
  //     _order: 'createdAt',
  //     _sort: 'desc',
  //     _limit: 3
  //   })
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento by id', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'public'
  //   const m = createMemento(name, desc, descRaw, type)
  //   const result = getMementoById(m.id)
  //   if(result) {
  //     expect(result.name).toBe(m.name)
  //   }
  //   else {
  //     expect(result).toBe(null)
  //   }
  // })

  // it('should delete memento by id', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'public'
  //   createMemento(name, desc, descRaw, type)

  //   const list = mementoCollection.get('list')
  //   if(list) {
  //     const id = list.data[0].id
  //     deleteMementoById(id)
  //     const mementoList = getMementoList()
  //     expect(mementoList.length).toBe(0)
  //   }
  // })
})

'''
'''--- assembly/__tests__/user.spec.ts ---
// import { createUser, getUserList, getUserById, getUserByUsername, updateUserById, getPostListByUserFollowing } from '../main'
// import { Img, User, userCollection } from '../model'

// let newUser: User = <User>{}

// describe('User ', () => {
//   beforeEach(() => {
//     const imgAvatar = new Img()
//     imgAvatar.url = 'asdf'
//     imgAvatar.type = 'ipfs'
//     const bio = 'test'
//     const bioRaw = 'test'

//     newUser = createUser(imgAvatar, bio, bioRaw)
//   })
//   afterEach(() => {
//     userCollection.delete('list')
//   })

//   it('should create new user', () => {
//     userCollection.delete('list')
    
//     const imgAvatar = new Img()
//     imgAvatar.url = 'asdf'
//     imgAvatar.type = 'ipfs'
//     const bio = 'test'
//     const bioRaw = 'test'

//     const newUser = createUser(imgAvatar, bio, bioRaw)
//     expect(newUser instanceof User).toBeTruthy()
//     const userList = userCollection.get('list')
//     if(userList) {
//       expect(userList.data.length).toBe(1)
//     }
//   })

//   it('should get all users', () => {
//     const userList = getUserList()
//     expect(userList.length).toBe(1)
//   })

//   it('should get users by id', () => {
//     const userList = getUserList(['id:='.concat(newUser.id)])
//     expect(userList.length).toBe(1)
//   })

//   it('should get users by username', () => {
//     const userList = getUserList(['username:=bo'])
//     expect(userList.length).toBe(0)
//   })

//   it('should get users by username_like', () => {
//     const userList = getUserList(['username_like:=bo'])
//     expect(userList.length).toBe(1)
//   })

//   it('should get user by id', () => {
//     const user = getUserById(newUser.id)
//     if(user) expect(user.id).toBe(newUser.id)
//   })

//   it('should get user by username', () => {
//     const user = getUserByUsername(newUser.username)
//     if(user) expect(user.username).toBe(newUser.username)
//   })

//   it('should update user', () => {
//     const newImgAvatar = new Img()
//     newImgAvatar.url = 'new avatar'
//     newImgAvatar.type = 'ipfs'
//     const newBio = 'new bio'
//     const newBioRaw = 'new bio'
//     const nUser = updateUserById(newUser.id, newImgAvatar, newBio, newBioRaw)
//     if(nUser) {
//       expect(nUser.imgAvatar.url).toBe(newImgAvatar.url)
//       expect(nUser.bio).toBe(newBio)
//       expect(nUser.bioRaw).toBe(newBioRaw)
//     }
//   })

//   it('should get postlist by user following', () => {
//     const postList = getPostListByUserFollowing('bob')
//     expect(postList.length).toBe(0)
//   })
// })

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/event.ts ---
import { PersistentVector } from 'near-sdk-as'

const events = new PersistentVector<Event>('events')

@nearBindgen
export class Event {
	collection: string
	action: string
	params: string[]

	constructor(collection: string, action: string, params: string[]) {
		this.collection = collection
		this.action = action
		this.params = params
	}
}

export function _getEvent(index: i32): Event {
	return events[index]
}

export function _getEventHeight(): i32 {
	return events.length
}

export function pushEvent(
	collection: string,
	action: string,
	params: string[]
): void {
	const event = new Event(collection, action, params)
	events.push(event)
}

'''
'''--- assembly/main.ts ---
import { PersistentMap } from 'near-sdk-as'
import { _getEvent, _getEventHeight, Event, pushEvent } from './event'

const mappedPerson = new PersistentMap<string, Person>('m::person')

@nearBindgen
class Person {
	name: string
	bio: string

	constructor(name: string, bio: string) {
		this.name = name
		this.bio = bio
	}
}

export function getEvent(index: i32): Event {
	return _getEvent(index)
}

export function getEventHeight(): i32 {
	return _getEventHeight()
}

export function addPerson(name: string, bio: string): Person {
	const person = mappedPerson.get(name)

	assert(!person, 'Person name already exist')
	const newPerson = new Person(name, bio)
	mappedPerson.set(newPerson.name, newPerson)

	pushEvent('person', 'create', [newPerson.name, newPerson.bio])

	return newPerson
}

export function updatePerson(name: string, bio: string): Person | null {
	const person = mappedPerson.get(name)

	if (person) {
		const updatedPerson = new Person(name, bio)
		mappedPerson.set(person.name, updatedPerson)

		pushEvent('person', 'update', [updatedPerson.name, updatedPerson.bio])

		return updatedPerson
	}
	return null
}

export function deletePerson(name: string): void {
	const person = mappedPerson.get(name)

	if (person) {
		mappedPerson.delete(person.name)

		pushEvent('person', 'delete', [person.name])
	}
}

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- example-query.js ---
const dotenv = require('dotenv')
const { Client, ThreadID, PrivateKey } = require('@textile/hub')

dotenv.config()

const keyInfo = {
	key: process.env.PUBLIC_TEXTILE_API_KEY,
}
const threadID = 'bafk4e6cem4dy6eucaha2oirhdsoxrrshuzz6i4cxepa7dtxmwvzx6fa'

async function find() {
	const client = await Client.withKeyInfo(keyInfo)
	const identity = PrivateKey.fromRandom()
	await client.getToken(identity)
	const tID = ThreadID.fromString(threadID)
	const personList = await client.find(tID, 'person', {})
	console.log(personList)
}

find()

'''
'''--- gen-account.js ---
const { PrivateKey } = require('@textile/hub')

async function genAccount() {
	const identity = PrivateKey.fromRandom()
	console.log({
    publicKey: identity.public.toString(),
    privateKey: identity.toString()
  })
}

genAccount()

'''
'''--- index.js ---
const dotenv = require('dotenv')
const indexer = require('near-textile-indexer')
const { Where } = require('near-textile-indexer/textile')

dotenv.config()

const writeValidator = (writer) => {
	// only allow admin public key to write new data to thread
	if (writer == 'bbaareigzrypntrkuzr54rg2q235qqqpmhtda3jwelvmxbutnupifumy26i') {
		return true
	}
	return false
}

const config = {
	networkId: process.env.NETWORK_ID,
	nodeUrl: process.env.NODE_URL,
	contractName: process.env.CONTRACT_NAME,
	keyInfo: {
		key: process.env.TEXTILE_API_KEY
	},
	privateKey: process.env.ADMIN_PRIVATE_KEY,
	// collections config setting
	collections: [
		{
			name: 'person',
			schema: {
				title: 'Person',
				type: 'object',
				properties: {
					_id: { type: 'string' },
					name: { type: 'string' },
					bio: { type: 'string' },
				},
			},
			writeValidator
		},
	],
	// callback called when new event found
	async processEvent(ctx, event, textileClient) {
		console.log(`${event.collection}::${event.action}`)
		if (event.collection === 'person') {
			if (event.action === 'create') {
				const newPerson = {
					_id: '',
					name: event.params[0],
					bio: event.params[1],
				}
				await textileClient.create(ctx.threadID, event.collection, [newPerson])
			}
			if (event.action === 'update') {
				const query = new Where('name').eq(event.params[0])
				const result = await textileClient.find(
					ctx.threadID,
					event.collection,
					query
				)

				if (result.length > 0) {
					const person = result[0]
					person.bio = event.params[1]

					await textileClient.save(ctx.threadID, event.collection, [person])
				}
			}
			if (event.action === 'delete') {
				const query = new Where('name').eq(event.params[0])
				const result = await textileClient.find(
					ctx.threadID,
					event.collection,
					query
				)

				if (result.length > 0) {
					const ids = await result.map((instance) => instance._id)
					await textileClient.delete(ctx.threadID, event.collection, ids)
				}
			}
		}
	},
}

// start indexer based on config
indexer(config)

'''
'''--- package.json ---
{
  "name": "near-textile-indexer-example",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev:contract": "NODE_ENV=development nodemon --watch assembly -e ts --exec asp",
    "build:contract": "npx asb",
    "deploy:dev": "NODE_ENV=development npm run build:contract && near dev-deploy"
  },
  "dependencies": {
    "@textile/hub": "^1.0.0",
    "dotenv": "^8.2.0",
    "isomorphic-ws": "^4.0.1",
    "near-api-js": "^0.29.1",
    "near-textile-indexer": "^1.0.0",
    "ws": "^7.3.1"
  },
  "devDependencies": {
    "near-sdk-as": "^1.0.1",
    "near-shell": "^0.24.9",
    "nodemon": "^2.0.4"
  },
  "author": "Rahmat Albariqi",
  "license": "MIT"
}

'''