*GitHub Repository "pseudo-exchange/nym-spec"*

'''--- .travis.yml ---
language: node_js
node_js:
  - 12.0
os:
  - linux
  - osx
  - windows
before_install:
  - curl https://sh.rustup.rs -sSf -m 60 | sh -s -- -y -v --default-toolchain stable
  - if [[ "$TRAVIS_OS_NAME" == "windows" ]]; then HOME="/c/Users/travis"; fi
  - export PATH="$HOME/.cargo/bin:$PATH"
  - rustup target add wasm32-unknown-unknown
script:
  - npm run build
  - cargo test --package nym-near -- --nocapture
'''
'''--- Cargo.toml ---
[package]
name = "nym-near"
version = "0.1.0"
authors = ["Trevor <hello@tjtc.me>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "*", features = ["derive"] }
serde_json = "*"
borsh = "*"
near-sdk = "2.0.0"
wee_alloc = { version = "0.4.5", default-features = false, features = [] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- README.md ---
Nym.Near
==============

A name auction for Near.

See [User Stories](./USER_STORIES.md) for detailed interaction info.

## Prerequisite
Ensure `near-cli` is installed by running:

```
near --version
```

If needed, install `near-cli`:

```
npm install near-cli -g
```

## Building this contract
To make the build process compatible with multiple operating systems, the build process exists as a script in `package.json`.
There are a number of special flags used to compile the smart contract into the wasm file.
Run this command to build and place the wasm file in the `res` directory:
```bash
npm run build
```

**Note**: Instead of `npm`, users of [yarn](https://yarnpkg.com) may run:
```bash
yarn build
```

## Using this contract

### Quickest deploy
Build and deploy this smart contract to an development account. This development account will be created automatically and is not intended to be permanent. Please see the "Standard deploy" section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/nym_near.wasm --helperUrl https://near-contract-helper.onrender.com
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing the key to the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an environment variable containing this development account id and use that when copy/pasting commands.
Run this command to the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will call the contract's `set_thing` method:

```bash
near call $CONTRACT_NAME set_thing '{"msg": "aloha!"}' --accountId $CONTRACT_NAME
```

To retrieve the message from the contract, call `get_thing` with the following:

```bash
near view $CONTRACT_NAME get_thing '{"account_id": "'$CONTRACT_NAME'"}'
```

### Standard deploy
In this second option, the smart contract will get deployed to a specific account created with the NEAR Wallet.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.nearprotocol.com).

In the project root, login with `near-cli` by following the instructions after this command:

```
near login
```

Deploy the contract:

```bash
near deploy --wasmFile res/nym_near.wasm --accountId YOUR_ACCOUNT_NAME
```

## Testing
To test run:
```bash
cargo test --package status-message -- --nocapture
```

## Cool Commands:

```
// create account for the contract
near create-account nym.t.testnet --masterAccount t.testnet --initialBalance 100
near create-account escrowbar.t.testnet --masterAccount t.testnet --initialBalance 100
near create-account auction.t.testnet --masterAccount t.testnet --initialBalance 100

// no account creation, just use testnet autogen account
NEAR_ENV=testnet near deploy --accountId t.testnet --wasmFile res/nym_near.wasm --initFunction new --initArgs '{"escrow_account_id":"t.testnet","escrow_public_key":"ed25519:4cKe5SWR4QTwc7MTLrzNuC633gLzFg9FgiygPVzKYvb1"}'

NEAR_ENV=testnet near call t.testnet create '{"asset": "tc", "owner_beneficiary": "t.testnet", "auction_start_bid_amount": 100, "auction_close_block": null}' --accountId t.testnet

// deploy to created contract account
near deploy --wasmFile res/nym_near.wasm --accountId v0.nym.t.testnet --masterAccount nym.t.testnet

// call function on deployed account, only call for things that change state
near call dev-1606630107890-6675680 create '{"asset": "thank god its friday"}' --accountId t.testnet

near call dev-1606630107890-6675680 create '{"asset": "tc", "owner_beneficiary": "t.testnet", "auction_start_bid_amount": 100, "auction_close_block": null}' --accountId t.testnet

"auction_close_block": "", 

// view state via view function call with params
near view dev-1606630107890-6675680 get_auction_by_id '{"id":"1234"}' --accountId t.testnet

// call more things with diff params #yay
near call dev-1606630107890-6675680 place_bid '{"auction_id": "1234"}' --accountId t.testnet

// call more things with diff params #yay #youGetThePicture
near call dev-1606630107890-6675680 cancel_auction '{"auction_id": "1234"}' --accountId t.testnet
```
'''
'''--- USER_STORIES.md ---
# User Stories

## Auction House Creation
- can pause entire auction house
- can withdraw funds to auction house owners (multisig?)
- can upgrade (if paused)

**TYPE**: `contract deploy`, `call?`

**ADMIN STORY**:
As an admin, i want to create a sexy environment for blockchain domain name auctions. Giving users a place where they can exchange value for vanity names could not be done without a place like nym.near. As an admin, i want to be able to deploy an auction house that allows any user that owns a name to place it up for auction, in the end allowing for me to earn fees from each auction. An auction house consists of some top level controls, fee structure/settings, and a mapping of auctions. Keep it dead simple so users want to trade names like its 1999.

**FUNCTION**: `Constructor`

```rust
// Logic:
// - creates an auction house with empty mapping of auctions
// - started contract as paused: false (but owner can call to change this!)
// - ensure owner has full access keys
// - ensure contract acts as an escrow owner of each auction name item
// - ensure contract keeps Ⓝ balance to cover all auction rewards
// - ensure contract can forward Ⓝ profit balance to multisig owners (TC & ZK)
// 
// Optional:
// - Create back door -- for Auction House owners to be able to create auctions without fees
```

**PARAMS**:

`None`

**RESULT**:

`Success`

**POSSIBLE EXPLOITS**:

* Needs to keep full access keys for owner
* Should not allow anyone (including owner) to auction off the deployed contract name
* Should only allow deploy to upgrade contract if deployed contract is "paused"
* ensure contract does NOT get deployed over -- as all state is wiped, releasing all names

----

## Auction House Viewing Auction Items

**TYPE**: `view`

**USER STORY**:
As a user, i want to view all available name auctions, so I can see if I want to place a bid for any of them. I do not yet have permission to own, edit, destroy or otherwise mutate these items, I only can view the listing. This list is an array of names & IDs such that I know how to place a bid with the information available without any further calls.
I also want to get a list of closed auctions, so I can see what has historically been traded if possible. The main goal is to get a list of active auctions only, but inactive would be nice too :)
As a bonus, I want to be able to get a single listing item by ID, so that if I link or get linked directly to a specific auction item, I can load that data and proceed with bidding.

**ADMIN STORY**:
As an admin, I want to view all listing items the same way a user would. I also want to be able to get a list of all closed auctions so I can see history about my auction house.

**FUNCTION**: `get_auctions`, `get_auctions_by_id`

```rust
// Logic:
// - 
```

**PARAMS**:

`None`, `id`

**RESULT**:

```rust
// TBD: Array of items, Single Item
```

**FEES/ECONOMICS**:
None, viewing items should be free, fast, friendly.

**POSSIBLE EXPLOITS**:

`None` - Assuming view is safe from DOS

----

## Auction Item Creation

**TYPE**: `call`

**USER STORY**:

As a user, i want to create an auction for my cool near name: `too.near`, so that i can turn a profit for claiming this name first. I want to be able to specify when this auction will close, so that I can give other users time to place their bids. I need to be okay with moving my precious name to be owned by the auction house as escrow until the auction finishes or I cancel this auction. I am okay paying a small listing fee. I need to 

**ADMIN STORY**:

As an admin, I want to allow anyone that owns a near account id to place it up for auction. I take a small listing fee as reward for facilitating the txn, and guarantee safe ownership in escrow during auction.

**FUNCTION**: 

```rust
// Logic:
// - User inputs name (Required)
// - User inputs payment name (beneficiary), that receives all funds associated with auctionable name (if any) (Required)
// - User inputs starting bid amount (Optional, Defaults to TBD: 10T GAS?)
// - User inputs closing block (Optional, Defaults to 7days from now amount of blocks, does not override min/max block ranges)
// - Contract: Confirms this name is not already being auctioned (ok if previously auctioned)
// - Contract: Confirms this name is not the same as transaction signer, this would be bad :D
// - Contract: Confirms this name does not have a contract deployed to this name (is that possible??? Should this be allowed???)
// - Contract: Creates new auction item:
//    - assigns owner to be auction owner, this is also used as auction beneficiary
//    - assigns name as asset
//    - assigns close block
//    - assigns default empty bids
// - Contract: Adds Auction House as full access key
// - Contract: Removes all other access keys
// - Contract: Returns newly created auction item ID
```

**PARAMS**:

`Asset <AccountId>`, `CloseBlock <BlockIndex>`

**RESULT**:

```rust
// Vec<u8> Auction ID
```

**FEES/ECONOMICS**:

Create auction fee: GAS(TBD) (function call gas required to delete/store data for this auction) - taken immediately as part of create auction transaction.

**POSSIBLE EXPLOITS**:

* Confirm an asset is not being auctioned again during an active auction with same asset
* Close block never closes - ensure maximum and minimum range definitions
* Invalid asset, unparse-able or malicious payload in asset
* enforce asset is a near domain, such that `*.near`, and no other format (for now not allowing sub-domains, since this causes root access/ownership issues)
* Minimum auctionable name: 1 chars - for `*.near`, 32 for `*` (See near name definitions)
* Maximum auctionable name: 64 chars (See near name definitions)
* Only allow chars `[A-Za-z0-9]` (See near name definitions)
* Auction payment too little
* Auction payment too much (?? Pretty sure default transaction behaviour returns overpayments)
* Auctioning a name associated to a contract could be bad
* Auctioning the account owned by transaction signer
* Creator can specify starting bid amount
* Cannot be created if auction house is paused

----

## Auction Item Bid

**TYPE**: `call`

**USER STORY**:

As a user, I want to place a bid on a near name that I like, so I can potentially claim `lol.near` because i MUST have it. I am willing to pay a small bid fee, and I am willing to wait until auction closes to claim this name. To bid, I send a fee, bid amount & beneficiary near account id.

**ADMIN STORY**:

As an auction house admin, I want anyone with a valid near account ID to 

**FUNCTION**: 

```rust
// Logic:
// - User inputs auction item ID (Required)
// - User inputs bid amount (Required)
```

**PARAMS**:

`AuctionId <Vec<u8>>`, `Bid <Balance>`

**RESULT**:

`Success`, `Error`

**FEES/ECONOMICS**:

1. Place bid fee: GAS(10T - TBD) (function call gas * 2) - taken immediately as part of place bid transaction.

**POSSIBLE EXPLOITS**:

* Must not be owner of auction
* Must submit bid amount of greater than zero
* Must be an active auction
* Bidder cannot be original name owner
* Bid amount needs to be greater than 0
* Bid must be greater than MIN bid diff amount (Example: if lowest bid is 10T GAS, then next bid must be 10T GAS higher) (Default bid min: 10T GAS - TBD)
* Bidder can update their bid at any time, but fee applies each time
* Cannot bid if auction house is paused

----

## Auction Item Finalization

**TYPE**: `call`

**USER STORY**:

As a user I want to find out if I won an auction item. I want to either send a transaction to finalize auction to get my reward for winning the auction item, or get the auction item directly if someone else finalized, or lastly get my bid amount (minus fees) returned to me if I lost the auction.

**ADMIN STORY**:

As an auction house admin, I want to be able to call the finalize auction to cover the transaction fee for users if I'm feeling nice. I also am okay with anyone that placed bids to call finalize to pay for transaction fees to release auction outcome.

**FUNCTION**: 

```rust
// Logic:
// - User inputs auction item ID
// - User cannot call this function unless they are: A. the auction owner, B. a bidder, C. Admin
// - Contract: If no bids
//    - add auction item owner account id to full access key
//    - mark auction as inactive
//    - return
// - Contract: Adds Winner account ID as full access key
// - Contract: Sends Auction item owner account ID highest bid amount, minus auction percentage fee
// - Contract: Removes Auction House access keys
// - Contract: all bidders get their bid amounts back, minus fees
// - Contract: Marks auction item as inactive
```

**PARAMS**:

`AuctionId <Vec<u8>>`

**RESULT**:

`Success`, `Error`

**FEES/ECONOMICS**:

1. Auction Finalization Fee: 3-5% total Sale GAS(??) - computed upon resolving final winner bid amount
2. Auction without bids only costs txn execution gas.

**POSSIBLE EXPLOITS**:

* too many bids, transaction fee is too high to complete
* too little balance remaining to return to auction bid loser
* finalization doesnt get called, leaving
* Auction never becoming inactive - failure to allow future auctions
* No bidders, revert auction to owner

----

## Auction Item Cancelation

**TYPE**: `call`

**USER STORY**:

As an auction item owner, i want to be able to cancel my auction at any time between an opened auction, so I dont lose my account ID if I no longer want to auction it. I am okay with paying some fees to return any/all bid money and return the account ID back to me.

**ADMIN STORY**:

As an auction house admin, I want to allow any auction item owner to be able to cancel an auction to allow them to feel in control of their account IDs. This will give more trust and is what users expect to be able to do.

**FUNCTION**: 

```rust
// Logic:
// - User inputs auction ID for auction item
// - Contract: Confirms auction is still active
// - Contract: Confirms transaction signer is auction owner OR Auction house admin
// - Contract: Transfers full access keys to auction item owner
// - Contract: Transfers any/all bid amounts back to bidders
```

**PARAMS**:

`AuctionId <Vec<u8>>`

**RESULT**:

`Success`, `Error`

**FEES/ECONOMICS**:

1. Auction Removal Fee: GAS(10T - TBD) (function call gas * 2 + data deletion gas) - taken in addition to transaction fee

**POSSIBLE EXPLOITS**:

* Not the auction owner calling
* Not enough gas to cover transfer fees for account ID
* Not enough gas to cover transfer fees for any bid returns
* Auction inactive

----

# Scratch notes:

Thoughts on escrow:
Since contracts can be easily upgraded, and state is therefore completely obliterated -- an account for only escrow should be used. It would be something that can own all accounts used during an auction, have 0 full access keys for the escrow contract itself, and live within the namespace of "escrow.nym.near" or similar. This escrow can own both names & colleteral, meaning that if the state of "auction.nym.near" was ever completely wiped, the escrow assets were not affected. It also seems easier to make transfers to/from an escrow account rather than keeping within the auction contract/account.

Another thing to consider:
Abandoned auctions -- until cron, someone has to finalize a name auction. There should be a max window to release the name.
This could allow for the auction house to benefit by either:

1. Allowing a finalized auction item to be purchased directly
2. Allowing finalized auction item to be released (deleted) and all bid amounts paid to auction house
'''
'''--- package-lock.json ---
{
  "name": "nym-near",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "version": "1.0.0",
      "license": "Apache-2.0",
      "devDependencies": {}
    }
  }
}

'''
'''--- package.json ---
{
  "name": "nym-near",
  "version": "1.0.0",
  "description": "An auction for NEAR account names",
  "scripts": {
    "build": "cargo build --target wasm32-unknown-unknown --release",
    "postbuild": "cp target/wasm32-unknown-unknown/release/nym_near.wasm ./res/"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/TrevorJTClarke/nym-near.git"
  },
  "keywords": [
    "near-protocol",
    "blockchain",
    "rust",
    "smart-contract"
  ],
  "author": "TrevorJTClarke",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/TrevorJTClarke/nym-near/issues"
  },
  "homepage": "https://github.com/TrevorJTClarke/nym-near#readme",
  "devDependencies": {}
}

'''
'''--- src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{env, near_bindgen, AccountId, Balance, BlockHeight, Promise};
mod util;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

pub const ONE_NEAR: u128 = 1_000_000_000_000_000_000_000_000;
const ACCESS_KEY_ALLOWANCE: u128 = 1_000_000_000_000_000_000_000;
const CLOSE_BLOCK_OFFSET: u64 = 1_000_000;

// fn only_admin() {
//     // require only admins
//     assert_eq!(
//         &env::current_account_id(),
//         &env::signer_account_id(),
//         "Only owner can execute this fn",
//     )
// }

// TODO: How to i get the current list of access keys?
// TODO: One way to do this (BADLY) is to delete the account entirely,
// cause this contract to be beneficiary,
// then recreate it and send overflow balance to previous owner -- this is not a great solution
fn transfer_ownership(
    from_account_id: AccountId,
    from_public_key: Base58PublicKey,
    to_public_key: Base58PublicKey,
    to_account_id: AccountId,
) -> Promise {
    // TODO: Remove once fully tested
    logger!("from_account_id: {:?}", &from_account_id);
    logger!("from_public_key: {:?}", &from_public_key);
    logger!("to_public_key: {:?}", &to_public_key);
    logger!("to_account_id: {:?}", &to_account_id);

    // Here be the magix
    // First grant all access keys to the escrow account
    Promise::new(to_account_id).add_full_access_key(to_public_key.into());
    // Next remove all other access keys, so only the escrow account "owns" the
    // TODO: Make sure this deletes all PKs -- I dont think i found that yet
    Promise::new(from_account_id).delete_key(from_public_key.into())
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Auction {
    pub owner_id: AccountId, // near account
    pub winner_account_id: Option<AccountId>,
    pub asset: AccountId,
    pub close_block: Option<BlockHeight>, // Needs checking that theres no race case transactions
    bids: UnorderedMap<AccountId, Balance>,
}

impl ToString for Auction {
    fn to_string(&self) -> String {
        let fields = vec![
            self.owner_id.to_string(),
            self.asset.to_string(),
            self.close_block.unwrap().to_string(),
        ];
        fields.join("")
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct AuctionHouse {
    pub auctions: UnorderedMap<String, Auction>,
    pub paused: bool,
    pub escrow_account_id: Option<AccountId>,
    pub escrow_public_key: Option<Base58PublicKey>,
}

impl Default for AuctionHouse {
    fn default() -> Self {
        AuctionHouse {
            paused: false,
            escrow_account_id: None,
            escrow_public_key: None,
            auctions: UnorderedMap::new(env::keccak256(env::block_index().to_string().as_bytes())),
        }
    }
}

// TODO: Add admin FNs for pause/unpause
#[near_bindgen]
impl AuctionHouse {
    /// Constructor:
    /// See notes regarding escrow contract, ownership & state  separation
    /// This method instantiates new auction house contract with baseline config
    #[init]
    pub fn new(escrow_account_id: AccountId, escrow_public_key: Base58PublicKey) -> Self {
        // Make absolutely sure this contract doesnt get state removed easily
        assert!(!env::state_exists(), "The contract is already initialized");
        assert!(
            env::is_valid_account_id(&escrow_account_id.as_bytes()),
            "Must be a valid escrow contract id"
        );
        AuctionHouse {
            paused: false,
            auctions: UnorderedMap::new(env::keccak256(env::block_index().to_string().as_bytes())),
            escrow_account_id: Some(escrow_account_id),
            escrow_public_key: Some(escrow_public_key),
        }
    }

    // TODO: Confirm an asset is not being auctioned again during an active auction
    #[payable]
    #[allow(unused_variables)] // TODO: remove when impl done
    pub fn create(
        &mut self,
        asset: AccountId,
        owner_beneficiary: AccountId,
        auction_close_block: Option<BlockHeight>,
        auction_start_bid_amount: Balance,
    ) -> String {
        assert!(
            env::is_valid_account_id(&asset.as_bytes()),
            "Must be a valid root name"
        );
        assert_ne!(
            &asset,
            &env::signer_account_id(),
            "Auction cannot be signer name"
        );

        let close_block = match auction_close_block {
            Some(close_block) => close_block,
            None => env::block_index() + CLOSE_BLOCK_OFFSET,
        };

        let auction = Auction {
            owner_id: env::signer_account_id(),
            asset,
            winner_account_id: None,
            close_block: Some(close_block),
            bids: UnorderedMap::new(env::keccak256(env::block_index().to_string().as_bytes())),
        };
        logger!("auction string: {}", &auction.to_string());
        // Convert our auction to a string & compute the keccak256 hash
        let hash = env::keccak256(&auction.to_string().as_bytes());

        let key: Vec<String> = hash.iter().map(|b| format!("{:02x}", b)).collect();

        // Check if there is already an auction with this same matching hash
        // AND if that auction is ongoing (ongoing = current block < closing block)
        let previous_auction = self.auctions.get(&key.join(""));
        match previous_auction {
            Some(previous_auction) => {
                assert!(
                    env::block_index() > previous_auction.close_block.unwrap(),
                    "Auction is already happening"
                );
            }
            None => (),
        }

        self.auctions.insert(&key.join(""), &auction);

        // Use our fancy Macro, because KA CHING!
        logger!("New Auction:{}", &key.join(""));

        // Transfer ownership from ALL previous keys, to the escrow account
        transfer_ownership(
            env::signer_account_id(),
            Base58PublicKey {
                0: env::signer_account_pk(),
            },
            self.escrow_public_key.as_ref().unwrap().clone(),
            self.escrow_account_id.as_ref().unwrap().clone(),
        );

        // Allow original owner to call the cancel auction for their previously owned auction item
        // TODO: Do i need to do this? Or is it just super duper nice because im a nice person?
        Promise::new(env::signer_account_id()).add_access_key(
            env::signer_account_pk(),
            ACCESS_KEY_ALLOWANCE, // TODO: Check this value is right for this FN!
            env::signer_account_id(),
            b"cancel_auction".to_vec(),
        );

        key.join("")
    }

    // return single auction item
    pub fn get_auction_by_id(&self, id: String) -> String {
        // match id {
        //     Some(result) => self.auctions.get(
        //         &result.try_to_vec().unwrap()
        //     ).unwrap(),
        //     None => panic!("Auction ID: {:?} not found", id.as_ref()),
        // }
        self.auctions.get(&id).unwrap().to_string()
    }

    // Allow anyone to place a bid on an auction,
    // which accepts an auction id and attached_deposit balance for contribution which buys the asset
    //
    // Requires:
    // - user to NOT be owner
    // - auction amount needs to be greater than 0
    // - auction needs to not be closed
    //
    // Optional:
    // - user CAN update bid by calling this fn multiple times
    #[payable]
    pub fn place_bid(&mut self, auction_id: String) -> Promise {
        match self.auctions.get(&auction_id) {
            Some(auction) => {
                assert_ne!(
                    auction.owner_id,
                    env::signer_account_id(),
                    "Must not be owner of auction"
                );
                assert!(
                    env::attached_deposit() > 0,
                    "Must submit bid amount of greater than zero"
                );
                assert!(
                    env::block_index() > auction.close_block.unwrap(),
                    "Must be an active auction"
                );
            }
            None => {
                panic!("Shit got real");
            }
        }

        // TODO: Finish
        // Transfer amount from transaction into the escrow account
        // Annotate how much balance user spent
        Promise::new(self.escrow_account_id.as_ref().unwrap().clone())
            .transfer(env::attached_deposit())
    }

    // removes an auction if owner called it
    // sends back all auction bidders their funds
    pub fn cancel_auction(&mut self, auction_id: String) {
        if let Some(auction) = self.auctions.get(&auction_id) {
            assert_eq!(
                auction.owner_id,
                env::signer_account_id(),
                "Must be owner to cancel auction"
            );

            // TODO: Send bidders their funds

            // remove auction data
            self.auctions.remove(&auction_id);
        } else {
            panic!("Failed to cancel auction")
        }

        // TODO:
        // // Transfer ownership from escrow account, back to the original owner account
        // transfer_ownership(
        //     env::signer_account_id(),
        //     env::signer_account_pk() as Base58PublicKey,
        //     self.escrow_public_key.into(),
        //     self.escrow_account_id
        // );
    }

    // finalize auction:
    // - award winner the asset, if they were highest bidder
    // - all bidders get their bid amounts back, minus fees
    //
    // NOTE: anyone can call this method, as it is paid by the person wanting the final outcome
    pub fn finalize_auction(&mut self, auction_id: String) {
        // TBD!!!!!
        logger!("{}", auction_id);

        // TODO:
        // // Transfer ownership from escrow account, to the new owner account
        // transfer_ownership(
        //     env::signer_account_id(),
        //     env::signer_account_pk() as Base58PublicKey,
        //     self.escrow_public_key.into(),
        //     self.escrow_account_id
        // );
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn create_blank_auction_house() -> AuctionHouse {
        AuctionHouse::new(
            "escrow_near".to_string(),
            Base58PublicKey { 0: vec![0, 1, 2] },
        )
    }

    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice_near".to_string(),
            signer_account_id: "bob_near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "carol_near".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn initialize_constructor() {
        let context = get_context(vec![], true);
        testing_env!(context);
        // Init with escrow data
        let contract = create_blank_auction_house();

        assert_eq!(
            false, contract.paused,
            "Auction MUST not be paused initially"
        );

        assert_eq!(
            "escrow_near".to_string(),
            contract.escrow_account_id.unwrap(),
            "Escrow account ID is set appropriately"
        );

        assert_eq!(
            Base58PublicKey { 0: vec![0, 1, 2] },
            contract.escrow_public_key.unwrap(),
            "Escrow account public key is set appropriately"
        );

        // TODO: Figure out how to test this!
        // assert_eq!(
        //     env::signer_account_pk(),
        //     // HOw do i get contract full access keys list?,
        //     "Ensure the contract is owned by deployment signer"
        // );
    }

    #[test]
    #[should_panic(expected = "Auction is already happening")]
    fn new_auction_item_same_during_auction() {
        let mut context = get_context(vec![], true);
        testing_env!(context.clone());
        // Init with escrow data
        let mut contract = create_blank_auction_house();
        // ----------------------------------------------------------------
        // THIS IS HOW THE BLOCKCHAIN PROGRESSES STATE
        // IF YOU ARE USING ANY TYPE OF PROMISE OR NON-VIEW FN,
        // YOU MUST CHANGE "is_view" TO SHOW THE TEST RUNNER TO DO THE SHITS
        // ----------------------------------------------------------------
        context.is_view = false;
        testing_env!(context.clone());

        // call the contract create twice, so we can panic when the auction item already exists
        // AND is active (within the current block height)
        contract.create(
            "zanzibar_near".to_string(),
            "yokohama_near".to_string(),
            Some(1_000),
            1 * ONE_NEAR,
        );
        testing_env!(context.clone());
        contract.create(
            "zanzibar_near".to_string(),
            "yokohama_near".to_string(),
            Some(1_000),
            1 * ONE_NEAR,
        );
    }

    #[test]
    #[should_panic(expected = "Auction cannot be signer name")]
    fn new_auction_item_not_same_as_signer() {
        let context = get_context(vec![], true);
        testing_env!(context);
        // Init with escrow data
        let mut contract = create_blank_auction_house();

        // call the contract create twice, so we can panic when the auction item already exists
        // AND is active (within the current block height)
        contract.create(
            "bob_near".to_string(),
            env::signer_account_id(),
            Some(env::block_index() + 1_000),
            1 * ONE_NEAR,
        );
    }

    #[test]
    fn create_auction_item() {
        let context = get_context(vec![], true);
        testing_env!(context);
        // Init with escrow data
        let mut contract = create_blank_auction_house();

        // check all the auction item THANGS
        contract.create(
            "zanzibar_near".to_string(),
            env::signer_account_id(),
            Some(env::block_index() + 1_000),
            1 * ONE_NEAR,
        );

        assert_eq!(
            1,
            contract.auctions.len(),
            "Contract: Creates new auction item"
        );

        // assert!("Contract: Adds Auction House as full access key");

        // assert!("Contract: Removes all other access keys");

        // assert!("Contract: Returns newly created auction item ID");
    }
}

'''
'''--- src/util.rs ---
// convenient logger
#[macro_export]
macro_rules! logger {
  ($($arg:tt)*) => ({
    let log_message = format!($($arg)*);
    let log = log_message.as_bytes();
    env::log(&log)
  })
}

'''