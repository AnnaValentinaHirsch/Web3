*GitHub Repository "NEAR-DevHub/badges-contract"*

'''--- README.md ---
## DevHub Badges -  NFT Series Contract

This project is a NEP-171 compliant Non-Fungible Token (NFT) contract that introduces the concept of a "series". A series is a collection of NFTs that share the same metadata and are owned by the same account. When a new NFT is minted, it is added to a specific series and inherits the metadata of that series.
Features

- Minting NFTs as part of a series
- Updating series metadata
- Setting allowed addresses for transfers
- Transferring non-transferable tokens

### Usage
#### Prerequisites

- Install and configure near-cli
#### Creating a Series

To create a series with all the correct metadata, use the create_series function:

```
near call YOUR_CONTRACT_ID create_series '{
  "id": 1,
  "metadata": {
    "title": "Series Title",
    "description": "Series Description",
    ...
  }
}' --accountId YOUR_ACCOUNT_ID --amount 1
```

#### Minting NFTs

To mint a new NFT that is part of a series, use the nft_mint function:
```near call YOUR_CONTRACT_ID nft_mint '{"id": 1, "receiver_id": "RECEIVER_ACCOUNT_ID"}' --accountId YOUR_ACCOUNT_ID --amount 1```

#### Setting Allowed Addresses

To add an address to set_allowed_addresses, use the set_allowed_addresses function:
```
near call YOUR_CONTRACT_ID set_allowed_addresses '{
  "addresses": ["address1", "address2", "address3"]
}' --accountId YOUR_ACCOUNT_ID
```

*Note: The set_allowed_addresses function will overwrite the existing list of allowed addresses each time it's called. It does not append to the existing list. If you want to add new addresses without removing the existing ones, you would need to include all addresses (both old and new) every time you call the function.
Contributing*

Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.

#### License

MIT

'''
'''--- integration-tests/rs/Cargo.toml ---
[package]
name = "fungible-token-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.3.1"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"
'''
'''--- integration-tests/rs/src/helpers.rs ---
use serde_json::json;
use workspaces::{network::Sandbox, Account, Contract, Worker, AccountDetails};

pub const DEFAULT_DEPOSIT: u128 = 6760000000000000000000 as u128;
pub const DEFAULT_GAS: u128 = 300000000000000 as u128;

pub async fn mint_nft(
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
) -> anyhow::Result<()> { 
    let request_payload = json!({
        "token_id": token_id,
        "receiver_id": user.id(),
        "metadata": {
            "title": "Grumpy Cat",
            "description": "Not amused.",
            "media": "https://www.adamsdrafting.com/wp-content/uploads/2018/06/More-Grumpy-Cat.jpg"
        },
    });

    user.call(&worker, nft_contract.id(), "nft_mint")
        .args_json(request_payload)?
        .deposit(DEFAULT_DEPOSIT)
        .transact()
        .await?;
    
    Ok(())
}

pub async fn approve_nft(
    market_contract: &Contract,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
) -> anyhow::Result<()> {
    let request_payload  = json!({
        "token_id": token_id,
        "account_id": market_contract.id(),
        "msg": serde_json::Value::Null,
    });

    user.call(&worker, nft_contract.id(), "nft_approve")
        .args_json(request_payload)?
        .deposit(DEFAULT_DEPOSIT)
        .transact()
        .await?;

    Ok(())
}

pub async fn pay_for_storage(
    user: &Account,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
    amount: u128,
) -> anyhow::Result<()> {
    let request_payload = json!({});
    
    user.call(&worker, market_contract.id(), "storage_deposit")
        .args_json(request_payload)?
        .deposit(amount)
        .transact()
        .await?;

    Ok(())
}

pub async fn place_nft_for_sale(
    user: &Account,
    market_contract: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
    price: u128,
) -> anyhow::Result<()> {
    let request_payload  = json!({
        "token_id": token_id,
        "account_id": market_contract.id(),
        "msg": format!(r#"{{ "sale_conditions" : "{}" }}"#, price.to_string()),
    });

    user.call(&worker, nft_contract.id(), "nft_approve")
        .args_json(request_payload)?
        .deposit(DEFAULT_DEPOSIT)
        .transact()
        .await?;

    Ok(())
}

pub async fn get_user_balance(
    user: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<u128> {
    let details: AccountDetails = user.view_account(worker).await?;
    Ok(details.balance)
}

pub async fn purchase_listed_nft(
    bidder: &Account,
    market_contract: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
    offer_price: u128
) -> anyhow::Result<()> {
    let request_payload  = json!({
        "token_id": token_id,
        "nft_contract_id": nft_contract.id(),
    });

    bidder.call(&worker, market_contract.id(), "offer")
        .args_json(request_payload)?
        .gas(DEFAULT_GAS as u64)
        .deposit(offer_price)
        .transact()
        .await?;

    Ok(())
}

pub async fn transfer_nft(
    sender: &Account,
    receiver: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
) -> anyhow::Result<()> {
    let request_payload  = json!({
        "token_id": token_id,
        "receiver_id": receiver.id(),
        "approval_id": 1 as u64,
    });

    sender.call(&worker, nft_contract.id(), "nft_transfer")
        .args_json(request_payload)?
        .gas(DEFAULT_GAS as u64)
        .deposit(1)
        .transact()
        .await?;
    
    Ok(())
}

pub async fn get_nft_token_info(
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
) -> anyhow::Result<serde_json::Value> {
    let token_info: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": token_id}))?
        .transact()
        .await?
        .json()?;

    Ok(token_info)
}

pub fn round_to_near_dp(
    amount: u128,
    sf: u128,
) -> String {
    let near_amount = amount as f64 / 1_000_000_000_000_000_000_000_000.0;  // yocto in 1 NEAR
    return format!("{:.1$}", near_amount, sf as usize);
} 

'''
'''--- integration-tests/rs/src/tests.rs ---
use near_units::parse_near;
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};

mod helpers;

const NFT_WASM_FILEPATH: &str = "../../out/main.wasm";
const MARKET_WASM_FILEPATH: &str = "../../out/market.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // initiate environemnt
    let worker = workspaces::sandbox().await?;

    // deploy contracts
    let nft_wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let nft_contract = worker.dev_deploy(&nft_wasm).await?;
    let market_wasm = std::fs::read(MARKET_WASM_FILEPATH)?;
    let market_contract = worker.dev_deploy(&market_wasm).await?;

    // create accounts
    let owner = worker.root_account();
    let alice = owner
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;
    let bob = owner
        .create_subaccount(&worker, "bob")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;
    let charlie = owner
        .create_subaccount(&worker, "charlie")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize contracts
    nft_contract
        .call(&worker, "new_default_meta")
        .args_json(serde_json::json!({"owner_id": owner.id()}))?
        .transact()
        .await?;
    market_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({"owner_id": owner.id()}))?
        .transact()
        .await?;

    // begin tests
    test_nft_metadata_view(&owner, &nft_contract, &worker).await?;
    test_nft_mint_call(&owner, &alice, &nft_contract, &worker).await?;
    test_nft_approve_call(&bob, &nft_contract, &market_contract, &worker).await?;
    test_nft_approve_call_long_msg_string(&alice, &nft_contract, &market_contract, &worker).await?;
    test_sell_nft_listed_on_marketplace(&alice, &nft_contract, &market_contract, &bob, &worker).await?;
    test_transfer_nft_when_listed_on_marketplace(&alice, &bob, &charlie, &nft_contract, &market_contract, &worker).await?;
    test_approval_revoke(&alice, &bob, &nft_contract, &market_contract, &worker).await?;
    test_reselling_and_royalties(&alice, &bob, &charlie, &nft_contract, &market_contract, &worker).await?;

    Ok(())
}

async fn test_nft_metadata_view(
    owner: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let expected = json!({
        "base_uri": serde_json::Value::Null,
        "icon": serde_json::Value::Null,
        "name": "NFT Tutorial Contract",
        "reference": serde_json::Value::Null,
        "reference_hash": serde_json::Value::Null,
        "spec": "nft-1.0.0",
        "symbol": "GOTEAM",
    });
    let res: serde_json::Value = owner
        .call(&worker, contract.id(), "nft_metadata")
        .args_json(json!({  "account_id": owner.id()  }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(res, expected);
    println!("      Passed âœ… test_nft_metadata_view");
    Ok(())
}

async fn test_nft_mint_call(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let request_payload = json!({
        "token_id": "1",
        "receiver_id": user.id(),
        "metadata": {
            "title": "LEEROYYYMMMJENKINSSS",
            "description": "Alright time's up, let's do this.",
            "media": "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1"
        },
    });

    user.call(&worker, contract.id(), "nft_mint")
        .args_json(request_payload)?
        .deposit(parse_near!("0.008 N"))
        .transact()
        .await?;

    let tokens: serde_json::Value = owner
        .call(&worker, contract.id(), "nft_tokens")
        .args_json(serde_json::json!({}))?
        .transact()
        .await?
        .json()?;

    let expected = json!([
        {   
            "approved_account_ids": {},
            "royalty": {},
            "token_id": "1",
            "owner_id": user.id(),
            "metadata": {
                "expires_at": serde_json::Value::Null, 
                "extra": serde_json::Value::Null, 
                "issued_at": serde_json::Value::Null, 
                "copies": serde_json::Value::Null,
                "media_hash": serde_json::Value::Null,
                "reference": serde_json::Value::Null,
                "reference_hash": serde_json::Value::Null,
                "starts_at": serde_json::Value::Null,
                "updated_at": serde_json::Value::Null,
                "title": "LEEROYYYMMMJENKINSSS",
                "description": "Alright time's up, let's do this.",
                "media": "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1"
            }
        }
    ]);

    assert_eq!(tokens, expected);
    println!("      Passed âœ… test_nft_mint_call");
    Ok(())
}

async fn test_nft_approve_call(
    user: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "2";
    helpers::mint_nft(user, nft_contract, worker, token_id).await?;
    helpers::approve_nft(market_contract, user, nft_contract, worker, token_id).await?;

    let view_payload = json!({
        "token_id": token_id,
        "approved_account_id": market_contract.id(),
    });
    let result: bool = user
        .call(&worker, nft_contract.id(), "nft_is_approved")
        .args_json(view_payload)?
        .transact()
        .await?
        .json()?;
    
    assert_eq!(result, true);
    println!("      Passed âœ… test_nft_approve_call");
    Ok(())
}

async fn test_nft_approve_call_long_msg_string(
    user: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "3";
    helpers::mint_nft(user, nft_contract, worker, token_id).await?;
    helpers::pay_for_storage(user, market_contract, worker, 10000000000000000000000).await?;

    let approve_payload  = json!({
        "token_id": token_id,
        "account_id": market_contract.id(),
        "msg": "sample message".repeat(10240),
    });

    match user.call(&worker, nft_contract.id(), "nft_approve")
        .args_json(approve_payload)?
        .deposit(helpers::DEFAULT_DEPOSIT)
        .gas(helpers::DEFAULT_GAS as u64)
        .transact()
        .await
    {
        Ok(_result) => {
            panic!("test_nft_approve_call_long_msg_string worked despite insufficient gas")
        }
        Err(e) => {
            let e_string = e.to_string();
            if !e_string
                .contains("Not valid SaleArgs")
            {
                panic!("test_nft_approve_call_long_msg_string displays unexpected error message: {:?}", e_string);
            }

            let view_payload = json!({
                "token_id": token_id,
                "approved_account_id": market_contract.id(),
            });
            let result: bool = user
                .call(&worker, nft_contract.id(), "nft_is_approved")
                .args_json(view_payload)?
                .transact()
                .await?
                .json()?;
            
            assert_eq!(result, true);
            println!("      Passed âœ… test_nft_approve_call_long_msg_string");
        }
    }
    Ok(())
}

async fn test_sell_nft_listed_on_marketplace(
    seller: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    buyer: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "4";
    let sale_price = 300000000000000000000000 as u128;  // 0.3 NEAR in yoctoNEAR
    helpers::mint_nft(seller, nft_contract, worker, token_id).await?;
    helpers::pay_for_storage(seller, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(seller, market_contract, nft_contract, worker, token_id, sale_price).await?;

    let before_seller_balance: u128 = helpers::get_user_balance(seller, worker).await?;
    let before_buyer_balance: u128 = helpers::get_user_balance(buyer, worker).await?;
    helpers::purchase_listed_nft(buyer, market_contract, nft_contract, worker, token_id, sale_price).await?;
    let after_seller_balance: u128 = helpers::get_user_balance(seller, worker).await?;
    let after_buyer_balance: u128 = helpers::get_user_balance(buyer, worker).await?;

    let dp = 1;  // being exact requires keeping track of gas usage 
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, dp), helpers::round_to_near_dp(before_seller_balance + sale_price, dp), "seller did not receive the sale price");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, dp), helpers::round_to_near_dp(before_buyer_balance - sale_price, dp), "buyer did not receive the sale price");

    println!("      Passed âœ… test_sell_nft_listed_on_marketplace");
    Ok(())
}

async fn test_transfer_nft_when_listed_on_marketplace(
    seller: &Account,
    first_buyer: &Account,
    second_buyer: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "5";
    let sale_price = 3000000000000000000000000 as u128;  // 3 NEAR in yoctoNEAR
    helpers::mint_nft(seller, nft_contract, worker, token_id).await?;
    helpers::pay_for_storage(seller, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(seller, market_contract, nft_contract, worker, token_id, sale_price).await?;

    helpers::transfer_nft(seller, first_buyer, nft_contract, worker, token_id).await?;

    // attempt purchase NFT
    let before_seller_balance: u128 = helpers::get_user_balance(seller, worker).await?;
    let before_buyer_balance: u128 = helpers::get_user_balance(second_buyer, worker).await?;
    helpers::purchase_listed_nft(second_buyer, market_contract, nft_contract, worker, token_id, sale_price).await?;
    let after_seller_balance: u128 = helpers::get_user_balance(seller, worker).await?;
    let after_buyer_balance: u128 = helpers::get_user_balance(second_buyer, worker).await?;

    // assert owner remains first_buyer
    let token_info: serde_json::Value = helpers::get_nft_token_info(nft_contract, worker, token_id).await?;
    let owner_id: String = token_info["owner_id"].as_str().unwrap().to_string();
    assert_eq!(owner_id, first_buyer.id().to_string(), "token owner is not first_buyer");

    // assert balances remain equal
    let dp = 1;     
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, dp), helpers::round_to_near_dp(before_seller_balance, dp), "seller balance changed");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, dp), helpers::round_to_near_dp(before_buyer_balance, dp), "buyer balance changed");

    println!("      Passed âœ… test_transfer_nft_when_listed_on_marketplace");

    Ok(())
}

async fn test_approval_revoke(
    first_user: &Account,
    second_user: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "6";
    let sale_price = 3000000000000000000000000 as u128;  // 3 NEAR in yoctoNEAR
    helpers::mint_nft(first_user, nft_contract, worker, token_id).await?;
    helpers::pay_for_storage(first_user, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(first_user, market_contract, nft_contract, worker, token_id, sale_price).await?;

    // nft_revoke market_contract call
    let revoke_payload = json!({
        "account_id": market_contract.id(),
        "token_id": token_id,
    });
    first_user.call(&worker, nft_contract.id(), "nft_revoke")
        .args_json(revoke_payload)?
        .deposit(1)
        .transact()
        .await?;

    // market_contract attempts to nft_transfer, when second_user tries to purchase NFT on market
    let before_seller_balance: u128 = helpers::get_user_balance(first_user, worker).await?;
    let before_buyer_balance: u128 = helpers::get_user_balance(second_user, worker).await?;
    helpers::purchase_listed_nft(
        second_user, market_contract, nft_contract, worker, token_id, sale_price
    ).await?;
    let after_seller_balance: u128 = helpers::get_user_balance(first_user, worker).await?;
    let after_buyer_balance: u128 = helpers::get_user_balance(second_user, worker).await?;

    // assert owner remains first_user
    let token_info: serde_json::Value = helpers::get_nft_token_info(nft_contract, worker, token_id).await?;
    let owner_id: String = token_info["owner_id"].as_str().unwrap().to_string();
    assert_eq!(owner_id, first_user.id().to_string(), "token owner is not first_user");

    // assert balances unchanged
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, 0), helpers::round_to_near_dp(before_seller_balance, 0), "seller balance changed");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, 0), helpers::round_to_near_dp(before_buyer_balance, 0), "buyer balance changed");    

    println!("      Passed âœ… test_approval_revoke");
    Ok(())
}

async fn test_reselling_and_royalties(
    user: &Account,
    first_buyer: &Account,
    second_buyer: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "7";
    let sale_price = 3000000000000000000000000 as u128;  // 3 NEAR in yoctoNEAR

    // mint with royalties
    let request_payload = json!({
        "token_id": token_id,
        "receiver_id": user.id(),
        "metadata": {
            "title": "Grumpy Cat",
            "description": "Not amused.",
            "media": "https://www.adamsdrafting.com/wp-content/uploads/2018/06/More-Grumpy-Cat.jpg"
        },
        "perpetual_royalties": {
            user.id().to_string(): 2000 as u128
        }
    });
    user.call(&worker, nft_contract.id(), "nft_mint")
        .args_json(request_payload)?
        .deposit(helpers::DEFAULT_DEPOSIT)
        .transact()
        .await?;

    helpers::pay_for_storage(user, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(user, market_contract, nft_contract, worker, token_id, sale_price).await?;

    // first_buyer purchases NFT
    let mut before_seller_balance: u128 = helpers::get_user_balance(user, worker).await?;
    let mut before_buyer_balance: u128 = helpers::get_user_balance(first_buyer, worker).await?;
    helpers::purchase_listed_nft(first_buyer, market_contract, nft_contract, worker, token_id, sale_price).await?;
    let mut after_seller_balance: u128 = helpers::get_user_balance(user, worker).await?;
    let mut after_buyer_balance: u128 = helpers::get_user_balance(first_buyer, worker).await?;

    // assert owner becomes first_buyer
    let token_info: serde_json::Value = helpers::get_nft_token_info(nft_contract, worker, token_id).await?;
    let owner_id: String = token_info["owner_id"].as_str().unwrap().to_string();
    assert_eq!(owner_id, first_buyer.id().to_string(), "token owner is not first_buyer");

    // assert balances changed
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, 0), helpers::round_to_near_dp(before_seller_balance + sale_price, 0), "seller balance unchanged");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, 0), helpers::round_to_near_dp(before_buyer_balance - sale_price, 0), "buyer balance unchanged");

    // first buyer lists nft for sale
    helpers::pay_for_storage(first_buyer, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(first_buyer, market_contract, nft_contract, worker, token_id, sale_price).await?;

    // second_buyer purchases NFT
    let resale_price = sale_price * 5;  // 15 NEAR
    before_seller_balance = helpers::get_user_balance(first_buyer, worker).await?;
    before_buyer_balance = helpers::get_user_balance(second_buyer, worker).await?;
    let before_user_balance: u128 = helpers::get_user_balance(user, worker).await?;
    helpers::purchase_listed_nft(second_buyer, market_contract, nft_contract, worker, token_id, resale_price).await?;
    let after_user_balance: u128 = helpers::get_user_balance(user, worker).await?;
    after_seller_balance = helpers::get_user_balance(first_buyer, worker).await?;
    after_buyer_balance = helpers::get_user_balance(second_buyer, worker).await?;

    // assert owner changes to second_buyer
    let token_info: serde_json::Value = helpers::get_nft_token_info(nft_contract, worker, token_id).await?;
    let owner_id: String = token_info["owner_id"].as_str().unwrap().to_string();
    assert_eq!(owner_id, second_buyer.id().to_string(), "token owner is not second_buyer");

    // assert balances changed
    let royalty_fee = resale_price / 5;
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, 0), helpers::round_to_near_dp(before_seller_balance + resale_price - royalty_fee, 0), "seller balance unchanged");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, 0), helpers::round_to_near_dp(before_buyer_balance - resale_price, 0), "buyer balance unchanged");
    assert_eq!(helpers::round_to_near_dp(after_user_balance, 0), helpers::round_to_near_dp(before_user_balance + royalty_fee, 0), "user balance unchanged");

    println!("      Passed âœ… test_reselling_and_royalties");
    Ok(())
}

'''
'''--- integration-tests/ts/package.json ---
{
  "name": "nft-tutorial-integration-tests-ts",
  "version": "0.1.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava"
  },
  "devDependencies": {
    "ava": "^4.3.3",
    "near-workspaces": "^3.2.2",
    "typescript": "^4.6.4",
    "ts-node": "^10.8.0",
    "@types/bn.js": "^5.1.0"
  },
  "dependencies": {}
}

'''
'''--- integration-tests/ts/src/main.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, BN } from "near-workspaces";
import path from "path";
import {
  approveNFT, defaultCallOptions, DEFAULT_GAS, mintNFT, payForStorage,
  placeNFTForSale, purchaseListedNFT, transferNFT
} from "./utils";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  const worker = await Worker.init();
  const root = worker.rootAccount;

  const nftContractLocation = path.join(__dirname, "../../../out/main.wasm");
  const nft_contract = await root.devDeploy(
    nftContractLocation,
    {
      method: "new_default_meta",
      args: { owner_id: root },
      initialBalance: NEAR.parse("100 N").toJSON()
    }
  );

  const marketContractLocation = path.join(__dirname, "../../../out/market.wasm");
  const market_contract = await root.devDeploy(
    marketContractLocation,
    {
      method: "new",
      args: { owner_id: root },
      initialBalance: NEAR.parse("100 N").toJSON()
    }
  );

  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("100 N").toJSON(),
  });

  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("100 N").toJSON(),
  });

  const charlie = await root.createSubAccount("charlie", {
    initialBalance: NEAR.parse("100 N").toJSON(),
  });

  t.context.worker = worker;
  t.context.accounts = { root, nft_contract, market_contract, alice, bob, charlie };
});

test.afterEach.always(async (t) => {
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to tear down the worker:", error);
  });
});

test("nft contract: nft metadata view", async (t) => {
  const { root, nft_contract } = t.context.accounts;
  const expected = {
    base_uri: null,
    icon: null,
    name: "NFT Tutorial Contract",
    reference: null,
    reference_hash: null,
    spec: "nft-1.0.0",
    symbol: "GOTEAM",
  };
  t.deepEqual(
    await nft_contract.view("nft_metadata", { account_id: root }),
    expected
  );
});

test("nft contract: nft mint call", async (t) => {
  const { alice, nft_contract } = t.context.accounts;
  const request_payload = {
    token_id: "TEST123",
    metadata: {
      title: "LEEROYYYMMMJENKINSSS",
      description: "Alright time's up, let's do this.",
      media:
        "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1",
    },
    receiver_id: alice,
  };
  await alice.call(
    nft_contract,
    "nft_mint",
    request_payload,
    defaultCallOptions()
  );

  const tokens = await nft_contract.view("nft_tokens");
  const expected = [
    {
      approved_account_ids: {},
      metadata: {
        copies: null,
        description: "Alright time's up, let's do this.",
        expires_at: null,
        extra: null,
        issued_at: null,
        media:
          "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1",
        media_hash: null,
        reference: null,
        reference_hash: null,
        starts_at: null,
        title: "LEEROYYYMMMJENKINSSS",
        updated_at: null,
      },
      owner_id: alice.accountId,
      royalty: {},
      token_id: "TEST123",
    },
  ];
  t.deepEqual(tokens, expected, "Expected to find one minted NFT");
});

test("nft contract: nft approve call", async (t) => {
  const { alice, nft_contract, market_contract } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await approveNFT(market_contract, alice, nft_contract);

  // test if approved
  const view_payload = {
    token_id: "TEST123",
    approved_account_id: market_contract,
  };
  const approved = await nft_contract.view("nft_is_approved", view_payload);
  t.true(approved, "Failed to approve NFT");
});

test("nft contract: nft approve call long msg string", async (t) => {
  const { alice, nft_contract, market_contract } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await payForStorage(alice, market_contract);

  // approve NFT
  const approve_payload = {
    token_id: "TEST123",
    account_id: market_contract,
    msg: "sample message".repeat(10 * 1024),
  };
  const result = await alice.callRaw(
    nft_contract,
    "nft_approve",
    approve_payload,
    defaultCallOptions()
  );
  t.regex(result.receiptFailureMessages.join("\n"), /Not valid SaleArgs+/);

  // test if approved
  const view_payload = {
    token_id: "TEST123",
    approved_account_id: market_contract,
  };
  const approved = await nft_contract.view("nft_is_approved", view_payload);
  t.true(approved, "NFT approval apss without sale args");
});

test("cross contract: sell NFT listed on marketplace", async (t) => {
  const { alice, nft_contract, market_contract, bob } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await payForStorage(alice, market_contract);

  const sale_price = "300000000000000000000000"; // sale price string in yoctoNEAR is 0.3 NEAR
  await placeNFTForSale(market_contract, alice, nft_contract, sale_price);

  const alice_balance_before = await alice.availableBalance();
  const bob_balance_before = await bob.availableBalance();
  await purchaseListedNFT(nft_contract, bob, market_contract, sale_price);
  const alice_balance_after = await alice.availableBalance();
  const bob_balance_after = await bob.availableBalance();

  // assert alice balance increased by sale price
  const test_precision_dp_near = 1;
  const slice_val = test_precision_dp_near - 24;
  t.is(
    alice_balance_after.toString().slice(0, slice_val),
    alice_balance_before.add(NEAR.from(sale_price)).toString().slice(0, slice_val),
    "Alice balance should increase by sale price"
  );
  // bob balance should decrease by sale price
  t.is(
    bob_balance_after.toString().slice(0, slice_val),
    bob_balance_before.sub(NEAR.from(sale_price)).toString().slice(0, slice_val),
    "Bob balance should decrease by sale price"
  );

  // NFT has new owner
  const view_payload = {
    token_id: "TEST123",
  };
  const token_info: any = await nft_contract.view("nft_token", view_payload);
  t.is(token_info.owner_id, bob.accountId, "NFT should have been sold");
  // nothing left for sale on market
  const sale_supply = await market_contract.view("get_supply_sales");
  t.is(sale_supply, "0", "Expected no sales to be left on market");
});

test("cross contract: transfer NFT when listed on marketplace", async (t) => {
  const { alice, nft_contract, market_contract, bob, charlie } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await payForStorage(alice, market_contract);

  const sale_price = "300000000000000000000000"; // sale price string in yoctoNEAR is 0.3 NEAR
  await placeNFTForSale(market_contract, alice, nft_contract, sale_price);

  await transferNFT(bob, market_contract, nft_contract);

  // purchase NFT
  const offer_payload = {
    nft_contract_id: nft_contract,
    token_id: "TEST123",
  };
  const result = await charlie.callRaw(
    market_contract,
    "offer",
    offer_payload,
    defaultCallOptions(
      DEFAULT_GAS + "0", // 10X default amount for XCC
      sale_price // Attached deposit must be greater than or equal to the current price
    )
  );

  // assert expectations
  // NFT has same owner
  const view_payload = {
    token_id: "TEST123",
  };
  const token_info: any = await nft_contract.view("nft_token", view_payload);
  t.is(
    token_info.owner_id,
    bob.accountId, // NFT was transferred to bob
    "NFT should have bob as owner"
  );
  // Unauthorized error should be found
  t.regex(result.receiptFailureMessages.join("\n"), /Unauthorized+/);
});

test("cross contract: approval revoke", async (t) => {
  const { alice, nft_contract, market_contract, bob } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await payForStorage(alice, market_contract);
  await placeNFTForSale(
    market_contract,
    alice,
    nft_contract,
    "300000000000000000000000"
  );

  // revoke approval
  const revoke_payload = {
    token_id: "TEST123",
    account_id: market_contract, // revoke market contract authorization
  };
  await alice.call(
    nft_contract,
    "nft_revoke",
    revoke_payload,
    defaultCallOptions(DEFAULT_GAS, "1") // Requires attached deposit of exactly 1 yoctoNEAR
  );

  // transfer NFT
  const transfer_payload = {
    receiver_id: bob,
    token_id: "TEST123",
    approval_id: 1,
  };
  const result = await market_contract.callRaw(
    nft_contract,
    "nft_transfer",
    transfer_payload,
    defaultCallOptions(DEFAULT_GAS, "1")
  );

  // assert expectations
  // Unauthorized error should be found
  t.regex(result.receiptFailureMessages.join("\n"), /Unauthorized+/);
});

test("cross contract: reselling and royalties", async (t) => {
  const { alice, nft_contract, market_contract, bob, charlie } = t.context.accounts;
  const royalties_string = `{"${alice.accountId}":2000}`;
  const royalties = JSON.parse(royalties_string);
  await mintNFT(alice, nft_contract, royalties);
  await payForStorage(alice, market_contract);
  const ask_price = "300000000000000000000000";
  await placeNFTForSale(market_contract, alice, nft_contract, ask_price);

  const bid_price = ask_price + "0";

  const alice_balance_before = await alice.availableBalance();
  const bob_balance_before = await bob.availableBalance();
  await purchaseListedNFT(nft_contract, bob, market_contract, bid_price);
  const alice_balance_after = await alice.availableBalance();
  const bob_balance_after = await bob.availableBalance();

  const test_precision_dp_near = 1;
  const slice_val = test_precision_dp_near - 24;
  t.is(
    alice_balance_after.toString().slice(0, slice_val),
    alice_balance_before.add(NEAR.from(bid_price)).toString().slice(0, slice_val),
    "Alice balance should increase by sale price"
  );
  t.is(
    bob_balance_after.toString().slice(0, slice_val),
    bob_balance_before.sub(NEAR.from(bid_price)).toString().slice(0, slice_val),
    "Bob balance should decrease by sale price"
  );

  // bob relists NFT for higher price
  await payForStorage(bob, market_contract);
  const resell_ask_price = bid_price + "0";
  await placeNFTForSale(market_contract, bob, nft_contract, resell_ask_price);

  // bob updates price to lower ask
  const lowered_resell_ask_price = "600000000000000000000000";
  const update_price_payload = {
    nft_contract_id: nft_contract,
    token_id: "TEST123",
    price: lowered_resell_ask_price,
  };
  await bob.call(
    market_contract,
    "update_price",
    update_price_payload,
    defaultCallOptions(DEFAULT_GAS, "1")
  );

  const alice_balance_before_2 = await alice.availableBalance();
  const bob_balance_before_2 = await bob.availableBalance();
  const charlie_balance_before_2 = await charlie.availableBalance();
  await purchaseListedNFT(nft_contract, charlie, market_contract, resell_ask_price);
  const alice_balance_after_2 = await alice.availableBalance();
  const bob_balance_after_2 = await bob.availableBalance();
  const charlie_balance_after_2 = await charlie.availableBalance();

  t.is(
    alice_balance_after_2.sub(alice_balance_before_2).toHuman(),
    "6 N",
    "Alice balance should increase by royalty fee of 20% of sale price"
  )
  t.is(
    bob_balance_after_2.sub(bob_balance_before_2).toHuman(),
    "24.00031 N",
    "Bob balance should decrease by sale price minus royalty fee of 20% of sale price"
  )
  t.is(
    charlie_balance_before_2.sub(charlie_balance_after_2).toHuman().slice(0, 2),
    "30",
    "Charlie balance should decrease by sale price"
  )
});

'''
'''--- integration-tests/ts/src/utils.ts ---
import { BN, NearAccount } from "near-workspaces";

export const DEFAULT_GAS: string = "30000000000000";
export const DEFAULT_DEPOSIT: string = "9050000000000000000000";

export async function purchaseListedNFT(
  nft_contract: NearAccount,
  bidder_account: NearAccount,
  market_contract: NearAccount,
  bid_price: string
) {
  const offer_payload = {
    nft_contract_id: nft_contract,
    token_id: "TEST123",
  };
  await bidder_account.callRaw(
    market_contract,
    "offer",
    offer_payload,
    defaultCallOptions(DEFAULT_GAS + "0", bid_price)
  );
}

export async function placeNFTForSale(
  market_contract: NearAccount,
  owner: NearAccount,
  nft_contract: NearAccount,
  ask_price: string // sale price string in yoctoNEAR
) {
  await approveNFT(
    market_contract,
    owner,
    nft_contract,
    '{"sale_conditions": ' + `"${ask_price}"` + " }" // msg string trigger XCC
  );
}

export function defaultCallOptions(
  gas: string = DEFAULT_GAS,
  deposit: string = DEFAULT_DEPOSIT
) {
  return {
    gas: new BN(gas),
    attachedDeposit: new BN(deposit),
  };
}
export async function approveNFT(
  account_to_approve: NearAccount,
  owner: NearAccount,
  nft_contract: NearAccount,
  message?: string
) {
  const approve_payload = {
    token_id: "TEST123",
    account_id: account_to_approve,
    msg: message,
  };
  await owner.call(
    nft_contract,
    "nft_approve",
    approve_payload,
    defaultCallOptions()
  );
}

export async function mintNFT(
  user: NearAccount,
  nft_contract: NearAccount,
  royalties?: object
) {
  const mint_payload = {
    token_id: "TEST123",
    metadata: {
      title: "LEEROYYYMMMJENKINSSS",
      description: "Alright time's up, let's do this.",
      media:
        "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1",
    },
    receiver_id: user,
    perpetual_royalties: royalties,
  };
  await user.call(nft_contract, "nft_mint", mint_payload, defaultCallOptions());
}

export async function payForStorage(
  alice: NearAccount,
  market_contract: NearAccount
) {
  await alice.call(
    market_contract,
    "storage_deposit",
    {},
    defaultCallOptions(DEFAULT_GAS, "10000000000000000000000") // Requires minimum deposit of 10000000000000000000000
  );
}

export async function transferNFT(
  receiver: NearAccount,
  sender: NearAccount,
  nft_contract: NearAccount
) {
  const transfer_payload = {
    receiver_id: receiver,
    token_id: "TEST123",
    approval_id: 0, // first and only approval done in line 224
  };
  await sender.call(
    nft_contract,
    "nft_transfer",
    transfer_payload,
    defaultCallOptions(DEFAULT_GAS, "1")
  );
}

'''
'''--- nft-series/Cargo.toml ---
[package]
name = "nft_series_nontransfer"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde_json = "1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- nft-series/README.md ---
# TBD

'''
'''--- nft-series/build.sh ---
#!/bin/bash
set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ../out && cp target/wasm32-unknown-unknown/release/*.wasm ../out/series.wasm
'''
'''--- nft-series/misc/devhub.json ---
{
	"attributes": [
	  {
		"trait_type": "Collection",
		"value": "DevHub"
	  }
	]
  }
'''
'''--- nft-series/misc/generalCommands.md ---

'''
'''--- nft-series/neardev/dev-account.env ---
CONTRACT_NAME=dev-1680150945565-47157982260258
'''
'''--- nft-series/src/approval.rs ---
use crate::*;
use near_sdk::ext_contract;

pub trait NonFungibleTokenCore {
    //approve an account ID to transfer a token on your behalf
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);

    //check if the passed in account has access to approve the token ID
    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool;

    //revoke a specific account from transferring the token on your behalf
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId);

    //revoke all accounts from transferring the token on your behalf
    fn nft_revoke_all(&mut self, token_id: TokenId);
}

#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    //cross contract call to an external contract that is initiated during nft_approve
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //allow a specific account ID to approve a token on your behalf
    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>) {
        /*
            assert at least one yocto for security reasons - this will cause a redirect to the NEAR wallet.
            The user needs to attach enough to pay for storage on the contract
        */
        assert_at_least_one_yocto();

        //get the token object from the token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //make sure that the person calling the function is the owner of the token
        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Predecessor must be the token owner."
        );

        //get the next approval ID if we need a new approval
        let approval_id: u64 = token.next_approval_id;

        //check if the account has been approved already for this token
        let is_new_approval = token
            .approved_account_ids
            //insert returns none if the key was not present.
            .insert(account_id.clone(), approval_id)
            //if the key was not present, .is_none() will return true so it is a new approval.
            .is_none();

        //if it was a new approval, we need to calculate how much storage is being used to add the account.
        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
        //if it was not a new approval, we used no storage.
        } else {
            0
        };

        //increment the token's next approval ID by 1
        token.next_approval_id += 1;
        //insert the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        //refund any excess storage attached by the user. If the user didn't attach enough, panic.
        refund_deposit(storage_used);

        //if some message was passed into the function, we initiate a cross contract call on the
        //account we're giving access to.
        if let Some(msg) = msg {
            // Defaulting GAS weight to 1, no attached deposit, and no static GAS to attach.
            ext_non_fungible_approval_receiver::ext(account_id)
                .nft_on_approve(token_id, token.owner_id, approval_id, msg)
                .as_return();
        }
    }

    //check if the passed in account has access to approve the token ID
    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool {
        //get the token object from the token_id
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the approval number for the passed in account ID
        let approval = token.approved_account_ids.get(&approved_account_id);

        //if there was some approval ID found for the account ID
        if let Some(approval) = approval {
            //if a specific approval_id was passed into the function
            if let Some(approval_id) = approval_id {
                //return if the approval ID passed in matches the actual approval ID for the account
                approval_id == *approval
                //if there was no approval_id passed into the function, we simply return true
            } else {
                true
            }
            //if there was no approval ID found for the account ID, we simply return false
        } else {
            false
        }
    }

    //revoke a specific account from transferring the token on your behalf
    #[payable]
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId) {
        //assert that the user attached exactly 1 yoctoNEAR for security reasons
        assert_one_yocto();
        //get the token object using the passed in token_id
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the caller of the function and assert that they are the owner of the token
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //if the account ID was in the token's approval, we remove it and the if statement logic executes
        if token.approved_account_ids.remove(&account_id).is_some() {
            //refund the funds released by removing the approved_account_id to the caller of the function
            refund_approved_account_ids_iter(predecessor_account_id, [account_id].iter());

            //insert the token back into the tokens_by_id collection with the account_id removed from the approval list
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    //revoke all accounts from transferring the token on your behalf
    #[payable]
    fn nft_revoke_all(&mut self, token_id: TokenId) {
        //assert that the caller attached exactly 1 yoctoNEAR for security
        assert_one_yocto();

        //get the token object from the passed in token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");
        //get the caller and make sure they are the owner of the tokens
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //only revoke if the approved account IDs for the token is not empty
        if !token.approved_account_ids.is_empty() {
            //refund the approved account IDs to the caller of the function
            refund_approved_account_ids(predecessor_account_id, &token.approved_account_ids);
            //clear the approved account IDs
            token.approved_account_ids.clear();
            //insert the token back into the tokens_by_id collection with the approved account IDs cleared
            self.tokens_by_id.insert(&token_id, &token);
        }
    }
}

'''
'''--- nft-series/src/enumeration.rs ---
use crate::*;
use crate::nft_core::NonFungibleTokenCore;

/// Struct to return in views to query for specific data related to a series
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonSeries {
    series_id: u64,
    // Metadata including title, num copies etc.. that all tokens will derive from
    metadata: TokenMetadata,
    // Royalty used for all tokens in the collection
    royalty: Option<HashMap<AccountId, u32>>,
    // Owner of the collection
    owner_id: AccountId,
}

#[near_bindgen]
impl Contract {
    //Query for the total supply of NFTs on the contract
    pub fn nft_total_supply(&self) -> U128 {
        //return the length of the tokens by id
        U128(self.tokens_by_id.len() as u128)
    }

    //Query for nft tokens on the contract regardless of the owner using pagination
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each token using an iterator
        self.tokens_by_id
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the total supply of NFTs for a given owner
    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    //Query for all the tokens for an owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        //if there is some set of tokens, we'll set the tokens variable equal to that set
        let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            tokens_for_owner_set
        } else {
            //if there is no set of tokens, we'll simply return an empty vector.
            return vec![];
        };

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        tokens
            .iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    // Get the total supply of series on the contract
    pub fn get_series_total_supply(&self) -> u64 {
        self.series_by_id.len()
    }

    // Paginate through all the series on the contract and return the a vector of JsonSeries
    pub fn get_series(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonSeries> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each series using an iterator
        self.series_by_id
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the series IDs which are strings into Json Series
            .map(|series_id| self.get_series_details(series_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    // get info for a specific series
    pub fn get_series_details(&self, id: u64) -> Option<JsonSeries> {
        //get the series from the map
        let series = self.series_by_id.get(&id);
        //if there is some series, we'll return the series
        if let Some(series) = series {
            Some(JsonSeries {
                series_id: id,
                metadata: series.metadata,
                royalty: series.royalty,
                owner_id: series.owner_id,
            })
        } else {
            //if there isn't a series, we'll return None
            None
        }
    }

    //get the total supply of NFTs on a current series
    pub fn nft_supply_for_series(&self, id: u64) -> U128 {
        //get the series
        let series = self.series_by_id.get(&id);

        //if there is some series, get the length of the tokens. Otherwise return -
        if let Some(series) = series {
            U128(series.tokens.len() as u128)
        } else {
            U128(0)
        }
    }

    /// Paginate through NFTs within a given series 
    pub fn nft_tokens_for_series(
        &self,
        id: u64,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        // Get the series and its tokens
        let series = self.series_by_id.get(&id);
        let tokens = if let Some(series) = series {
            series.tokens
        } else {
            return vec![];
        };

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the tokens
        tokens
            .iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }
}

'''
'''--- nft-series/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nep_format_vector() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![
                NftMintLog {
                    owner_id: "foundation.near".to_owned(),
                    token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                    memo: None,
                },
                NftMintLog {
                    owner_id: "user1.near".to_owned(),
                    token_ids: vec!["meme".to_string()],
                    memo: None,
                },
            ]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_mint() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: "foundation.near".to_owned(),
                token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                memo: None,
            }]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_transfer_all_fields() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: Some("market.near".to_string()),
                old_owner_id: "user1.near".to_string(),
                new_owner_id: "user2.near".to_string(),
                token_ids: vec!["token".to_string()],
                memo: Some("Go Team!".to_owned()),
            }]),
        };
        assert_eq!(expected, log.to_string());
    }
}

'''
'''--- nft-series/src/internal.rs ---
use crate::*;
use near_sdk::CryptoHash;
use std::mem::size_of;

//convert the royalty percentage and amount to pay into a payout (U128)
pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}

//calculate how many bytes the account ID is taking up
pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

//refund the storage taken up by passed in approved account IDs and send the funds to the passed in account ID.
pub(crate) fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I, //the approved account IDs must be passed in as an iterator
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    //get the storage total by going through and summing all the bytes for each approved account IDs
    let storage_released: u64 = approved_account_ids
        .map(bytes_for_approved_account_id)
        .sum();
    //transfer the account the storage that is released
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

//refund a map of approved account IDs and send the funds to the passed in account ID
pub(crate) fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    //call the refund_approved_account_ids_iter with the approved account IDs as keys
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &String) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

//used to make sure the user attached exactly 1 yoctoNEAR
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
}

//Assert that the user has attached at least 1 yoctoNEAR (for security reasons and to pay for storage)
pub(crate) fn assert_at_least_one_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Requires attached deposit of at least 1 yoctoNEAR",
    )
}

// Send all the non storage funds to the series owner
pub(crate) fn payout_series_owner(storage_used: u64, price_per_token: Balance, owner_id: AccountId) {
    //get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    //get the attached deposit
    let attached_deposit = env::attached_deposit();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        attached_deposit >= required_cost + price_per_token,
        "Must attach {} yoctoNEAR to cover storage and price per token {}",
        required_cost,
        price_per_token
    );

    // If there's a price for the token, transfer everything but the storage to the series owner
    if price_per_token > 0 {
        Promise::new(owner_id).transfer(attached_deposit - required_cost);
    }
}

//refund the initial deposit based on the amount of storage that was used up
pub(crate) fn refund_deposit(storage_used: u64) {
    //get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    //get the attached deposit
    let attached_deposit = env::attached_deposit();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    //get the refund amount from the attached deposit - required cost
    let refund = attached_deposit - required_cost;

    //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

impl Contract {
    /// Ensure that the caller is the owner of the contract
    pub(crate) fn assert_contract_owner(&mut self) {
        assert!(
            self.owner_id == env::predecessor_account_id(),
            "only contract owner"
        )
    }

    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //get the set of tokens for the given account
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id.to_string()),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        tokens_set.insert(token_id);

        //we insert that set for the given account ID.
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    //remove a token from an owner (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //we get the set of tokens that the owner has
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            //if there is no set of tokens for the owner, we panic with the following message:
            .expect("Token should be owned by the sender");

        //we remove the the token_id from the set of tokens
        tokens_set.remove(token_id);

        //if the token set is now empty, we remove the owner from the tokens_per_owner collection
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
            //if the token set is not empty, we simply insert it back for the account ID.
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    //transfers the NFT to the receiver_id (internal method and can't be called directly via CLI).
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    ) -> Token {
        //get the token object by passing in the token_id
        let token = self.tokens_by_id.get(token_id).expect("No token");

        //if the sender doesn't equal the owner, we check if the sender is in the approval list
        if sender_id != &token.owner_id {
            //if the token's approved account IDs doesn't contain the sender, we panic
            if !token.approved_account_ids.contains_key(sender_id) {
                env::panic_str("Unauthorized");
            }

            // If they included an approval_id, check if the sender's actual approval_id is the same as the one included
            if let Some(enforced_approval_id) = approval_id {
                //get the actual approval ID
                let actual_approval_id = token
                    .approved_account_ids
                    .get(sender_id)
                    //if the sender isn't in the map, we panic
                    .expect("Sender is not approved account");

                //make sure that the actual approval ID is the same as the one provided
                assert_eq!(
                    actual_approval_id, &enforced_approval_id,
                    "The actual approval_id {} is different from the given approval_id {}",
                    actual_approval_id, enforced_approval_id,
                );
            }
        }

        //we make sure that the sender isn't sending the token to themselves
        assert_ne!(
            &token.owner_id, receiver_id,
            "The token owner and the receiver should be different"
        );

        //we remove the token from it's current owner's set
        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        //we then add the token to the receiver_id's set
        self.internal_add_token_to_owner(receiver_id, token_id);

        //we create a new token struct
        let new_token = Token {
            series_id: token.series_id,
            owner_id: receiver_id.clone(),
            //reset the approval account IDs
            approved_account_ids: Default::default(),
            next_approval_id: token.next_approval_id,
        };
        //insert that new token into the tokens_by_id, replacing the old entry
        self.tokens_by_id.insert(token_id, &new_token);

        //if there was some memo attached, we log it.
        if let Some(memo) = memo.as_ref() {
            env::log_str(&format!("Memo: {}", memo).to_string());
        }

        // Default the authorized ID to be None for the logs.
        let mut authorized_id = None;
        //if the approval ID was provided, set the authorized ID equal to the sender
        if approval_id.is_some() {
            authorized_id = Some(sender_id.to_string());
        }

        // Construct the transfer log as per the events standard.
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: token.owner_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: receiver_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_transfer_log.to_string());

        //return the previous token object that was transferred.
        token
    }
}

'''
'''--- nft-series/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, LookupSet, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, BorshStorageKey, CryptoHash, PanicOnDefault,
    Promise, PromiseOrValue,
};
use std::collections::HashMap;
use near_sdk::serde_json::json;

pub use crate::approval::*;
pub use crate::events::*;
use crate::internal::*;
pub use crate::metadata::*;
pub use crate::nft_core::*;
pub use crate::owner::*;
pub use crate::royalty::*;
pub use crate::series::*;

mod approval;
mod enumeration;
mod events;
mod internal;
mod metadata;
mod nft_core;
mod owner;
mod royalty;
mod series;

/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";

// Represents the series type. All tokens will derive this data.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Series {
    // Metadata including title, num copies etc.. that all tokens will derive from
    metadata: TokenMetadata,
    // Royalty used for all tokens in the collection
    royalty: Option<HashMap<AccountId, u32>>,
    // Set of tokens in the collection
    tokens: UnorderedSet<TokenId>,
    // What is the price of each token in this series? If this is specified, when minting,
    // Users will need to attach enough $NEAR to cover the price.
    price: Option<Balance>,
    // Owner of the collection
    owner_id: AccountId,
}

impl Series {
    pub fn update_metadata(&mut self, metadata: TokenMetadata) {
        self.metadata = metadata;
    }

    pub fn update_royalty(&mut self, royalty: Option<HashMap<AccountId, u32>>) {
        self.royalty = royalty;
    }

    pub fn update_price(&mut self, price: Option<Balance>) {
        self.price = price;
    }

    pub fn update_owner_id(&mut self, owner_id: AccountId) {
        self.owner_id = owner_id;
    }
}

pub type SeriesId = u64;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    //contract owner
    pub owner_id: AccountId,

    //approved minters
    pub approved_minters: LookupSet<AccountId>,

    //approved users that can create series
    pub approved_creators: LookupSet<AccountId>,

    //Map the collection ID (stored in Token obj) to the collection data
    pub series_by_id: UnorderedMap<SeriesId, Series>,

    //keeps track of the token struct for a given token ID
    pub tokens_by_id: UnorderedMap<TokenId, Token>,

    //keeps track of all the token IDs for a given account
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

    //keeps track of the metadata for the contract
    pub metadata: LazyOption<NFTContractMetadata>,
     
    // Add a new field for the allowed addresses
    pub allowed_transfers: UnorderedSet<AccountId>,
    
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    ApprovedMinters,
    ApprovedCreators,
    SeriesById,
    SeriesByIdInner { account_id_hash: CryptoHash },
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokensById,
    NFTContractMetadata,
    AllowedTransfers,
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default metadata so the
        user doesn't have to manually type metadata.
    */
    #[init]

    pub fn new_default_meta(owner_id: AccountId) -> Self {
         const UPDATED_ICON: &str = "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";
        //const UPDATED_ICON: &str = "https://bafybeiaxaw2hkasbwfm27k56h2ntr2vkh2jzvdztqor6kjqzw7goqze7rm.ipfs.nftstorage.link/meteor_icon.png";
    
        let metadata = NFTContractMetadata {
            spec: "nft-1.0.0".to_string(),
            name: "DevHub Badges".to_string(),
            symbol: "DEVHUB".to_string(),
            icon: Some(UPDATED_ICON.to_string()),
            base_uri: None,
            reference: None,
            reference_hash: None,
        };
    
        let event_data = json!({
            "standard": "nep171",
            "version": "1.1.0",
            "event": "contract_metadata_update",
            "data": metadata
        });
        env::log_str(&event_data.to_string());
    
        Self::new(owner_id, metadata)
    }
   
    pub fn update_metadata(&mut self, owner_id: AccountId, metadata: NFTContractMetadata) {
        require!(env::predecessor_account_id() == self.owner_id, "Only the contract owner can update the metadata");
    
        // Update the metadata
        self.metadata = LazyOption::new(
            StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
            Some(&metadata),
        );
    
        // Log the event
        let event_data = json!({
            "standard": "nep171",
            "version": "1.1.0",
            "event": "contract_metadata_update",
            "data": metadata
        });
        env::log_str(&event_data.to_string());
    }

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id.
    */

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        // Create the approved minters set and insert the owner
        let mut approved_minters =
            LookupSet::new(StorageKey::ApprovedMinters.try_to_vec().unwrap());
        approved_minters.insert(&owner_id);

        // Create the approved creators set and insert the owner
        let mut approved_creators =
            LookupSet::new(StorageKey::ApprovedCreators.try_to_vec().unwrap());
        approved_creators.insert(&owner_id);
        
        
        // Create a variable of type Self with all the fields initialized.
        let this = Self {
            approved_minters,
            approved_creators,
            series_by_id: UnorderedMap::new(StorageKey::SeriesById.try_to_vec().unwrap()),
            //Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: UnorderedMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            //set the &owner_id field equal to the passed in owner_id.
            owner_id,
            metadata: LazyOption::new(
                StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
            allowed_transfers: UnorderedSet::new(StorageKey::AllowedTransfers.try_to_vec().unwrap()),
        };

        //return the Contract object
        this
    }

  
    //near call CONTRACT_ACCOUNT_ID new_default_meta '{"owner_id": "OWNER_ACCOUNT_ID"}' --accountId YOUR_ACCOUNT_ID

    pub fn update_series_metadata(&mut self, series_id: SeriesId, metadata: TokenMetadata) {
        let mut series = self.series_by_id.get(&series_id).expect("Series not found");
        series.update_metadata(metadata);
        self.series_by_id.insert(&series_id, &series);

        // Emit the event
        let event_data = json!({
            "standard": "nep171",
            "version": "1.1.0",
            "event": "nft_metadata_update",
            "data": []
        });
        env::log_str(&event_data.to_string());
    }

    pub fn update_series_royalty(
        &mut self,
        series_id: SeriesId,
        royalty: Option<HashMap<AccountId, u32>>,
    ) {
        let mut series = self.series_by_id.get(&series_id).expect("Series not found");
        series.update_royalty(royalty);
        self.series_by_id.insert(&series_id, &series);

        // Emit the event
        let event_data = json!({
            "standard": "nep171",
            "version": "1.1.0",
            "event": "contract_metadata_update",
            "data": []
        });
        env::log_str(&event_data.to_string());
    }

    pub fn update_series_price(&mut self, series_id: SeriesId, price: Option<Balance>) {
        let mut series = self.series_by_id.get(&series_id).expect("Series not found");
        series.update_price(price);
        self.series_by_id.insert(&series_id, &series);

        // Emit the event
        let event_data = json!({
            "standard": "nep171",
            "version": "1.1.0",
            "event": "contract_metadata_update",
            "data": []
        });
        env::log_str(&event_data.to_string());
    }

    pub fn update_series_owner_id(&mut self, series_id: SeriesId, owner_id: AccountId) {
        let mut series = self.series_by_id.get(&series_id).expect("Series not found");
        series.update_owner_id(owner_id);
        self.series_by_id.insert(&series_id, &series);

        // Emit the event
        let event_data = json!({
            "standard": "nep171",
            "version": "1.1.0",
            "event": "contract_metadata_update",
            "data": []
        });
        env::log_str(&event_data.to_string());
    }

    
    // Add a new function for setting allowed addresses
    pub fn set_allowed_addresses(&mut self, addresses: Vec<AccountId>) {
        assert_eq!(env::signer_account_id(), self.owner_id, "Only the owner can set allowed addresses");
        for address in addresses {
            self.allowed_transfers.insert(&address);
        }
    }

    // Add a new function for transferring non-transferable tokens
    pub fn transfer(&mut self, new_owner_id: AccountId, token_id: String) {
        assert!(self.allowed_transfers.contains(&new_owner_id), "Transfer not allowed to this address");
        let mut token = self.tokens_by_id.get(&token_id).expect("Token not found");
        token.owner_id = new_owner_id.clone();
        self.tokens_by_id.insert(&token_id, &token);
    }

}
'''
'''--- nft-series/src/metadata.rs ---
use crate::*;
pub type TokenId = String;
//defines the payout type we'll be returning as a part of the royalty standards.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSAIC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub animation_url: Option<String>,
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    pub achievement_type: Option<String>, // The following are specific to achievement tracking for badges
    pub achievement_level: Option<String>,
    pub activity_name: Option<String>,
    pub completion_date: Option<String>,
    pub community_event: Option<String>,
    pub external_links: Option<String>,
    pub creator: Option<String>,   
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    // Series that the token belongs to
    pub series_id: u64,
    //owner of the token
    pub owner_id: AccountId,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //the next approval ID to give out.
    pub next_approval_id: u64,
}

//The Json token is what will be returned from view calls.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    // Series that the token belongs to
    pub series_id: u64,
    //token ID
    pub token_id: TokenId,
    //owner of the token
    pub owner_id: AccountId,
    //token metadata
    pub metadata: TokenMetadata,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: Option<HashMap<AccountId, u32>>,
}

pub trait NonFungibleTokenMetadata {
    //view call for returning the contract metadata
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- nft-series/src/nft_core.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_ON_TRANSFER: Gas = Gas(25_000_000_000_000);

pub trait NonFungibleTokenCore {
    //transfers an NFT to a receiver ID
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    );

    //transfers an NFT to a receiver and calls a function on the receiver ID's contract
    /// Returns `true` if the token was transferred from the sender's account.
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    //get information about the NFT token passed in
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    //Method stored on the receiver contract that is called via cross contract call when nft_transfer_call is called
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
/*
    resolves the promise of the cross contract call to the receiver contract
    this is stored on THIS contract and is meant to analyze what happened in the cross contract call when nft_on_transfer was called
    as part of the nft_transfer_call method
*/
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver.
    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        //assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be redirected to the NEAR wallet.
        assert_one_yocto();
        //get the sender to transfer the token from the sender to the receiver
        let sender_id = env::predecessor_account_id();
        assert!(self.allowed_transfers.contains(&receiver_id), "Transfer not allowed to this address");
        //call the internal transfer method and get back the previous token so we can refund the approved account IDs
        let previous_token =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, approval_id, memo);

        //we refund the owner for releasing the storage used up by the approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
    }

    //implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract
    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        //assert that the user attached exactly 1 yocto for security reasons.
        assert_one_yocto();

        //get the sender ID
        let sender_id = env::predecessor_account_id();
        assert!(self.allowed_transfers.contains(&receiver_id), "Transfer not allowed to this address");
        //transfer the token and get the previous token object
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            approval_id,
            memo.clone(),
        );

        //default the authorized_id to none
        let mut authorized_id = None;
        //if the sender isn't the owner of the token, we set the authorized ID equal to the sender.
        if sender_id != previous_token.owner_id {
            authorized_id = Some(sender_id.to_string());
        }

        // Initiating receiver's call and the callback
        // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for nft on transfer.
        ext_non_fungible_token_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_NFT_ON_TRANSFER)
            .nft_on_transfer(
                sender_id,
                previous_token.owner_id.clone(),
                token_id.clone(),
                msg,
            )
            // We then resolve the promise and call nft_resolve_transfer on our own contract
            .then(
                // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .nft_resolve_transfer(
                        authorized_id, // we introduce an authorized ID so that we can log the transfer
                        previous_token.owner_id,
                        receiver_id,
                        token_id,
                        previous_token.approved_account_ids,
                        memo, // we introduce a memo for logging in the events standard
                    ),
            )
            .into()
    }

    //get the information for a specific token ID
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        //if there is some token ID in the tokens_by_id collection
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            // Get the series information
            let cur_series = self
                .series_by_id
                .get(&token.series_id)
                .expect("Not a series");
            // Get the metadata for the series
            let mut metadata = cur_series.metadata;

            // Get the edition number and series ID
            let split: Vec<&str> = token_id.split(":").collect();
            let edition_number = split[1];
            // If there is a title for the NFT, add the token ID to it.
            if let Some(title) = metadata.title {
                metadata.title = Some(format!("{} - {}", title, edition_number));
            } else {
                // If there is no title, we simply create one based on the series number and edition number
                metadata.title = Some(format!("Series {} : Edition {}", split[0], split[1]));
            }

            //we return the JsonToken (wrapped by Some since we return an option)
            Some(JsonToken {
                series_id: token.series_id,
                token_id,
                owner_id: token.owner_id,
                metadata,
                approved_account_ids: token.approved_account_ids,
                royalty: cur_series.royalty,
            })
        } else {
            //if there wasn't a token ID in the tokens_by_id collection, we return None
            None
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    //resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
    //returns true if the token was successfully transferred to the receiver_id
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool {
        // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`
        // call result.
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            //As per the standard, the nft_on_transfer should return whether we should return the token to it's owner or not
            if let Ok(return_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                //if we need don't need to return the token, we simply return true meaning everything went fine
                if !return_token {
                    /*
                        since we've already transferred the token and nft_on_transfer returned false, we don't have to
                        revert the original transfer and thus we can just return true since nothing went wrong.
                    */
                    //we refund the owner for releasing the storage used up by the approved account IDs
                    refund_approved_account_ids(owner_id, &approved_account_ids);
                    return true;
                }
            }
        }

        //get the token object if there is some token object
        let mut token = if let Some(token) = self.tokens_by_id.get(&token_id) {
            if token.owner_id != receiver_id {
                //we refund the owner for releasing the storage used up by the approved account IDs
                refund_approved_account_ids(owner_id, &approved_account_ids);
                // The token is not owner by the receiver anymore. Can't return it.
                return true;
            }
            token
        //if there isn't a token object, it was burned and so we return true
        } else {
            //we refund the owner for releasing the storage used up by the approved account IDs
            refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };

        //we remove the token from the receiver
        self.internal_remove_token_from_owner(&receiver_id.clone(), &token_id);
        //we add the token to the original owner
        self.internal_add_token_to_owner(&owner_id, &token_id);

        //we change the token struct's owner to be the original owner
        token.owner_id = owner_id.clone();

        //we refund the receiver any approved account IDs that they may have set on the token
        refund_approved_account_ids(receiver_id.clone(), &token.approved_account_ids);
        //reset the approved account IDs to what they were before the transfer
        token.approved_account_ids = approved_account_ids;

        //we inset the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        /*
            We need to log that the NFT was reverted back to the original owner.
            The old_owner_id will be the receiver and the new_owner_id will be the
            original owner of the token since we're reverting the transfer.
        */
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: receiver_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: owner_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        //we perform the actual logging
        env::log_str(&nft_transfer_log.to_string());

        //return false
        false
    }
}

'''
'''--- nft-series/src/owner.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// Add a specified account as an approved minter
    pub fn add_approved_minter(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_minters.insert(&account_id);
    }

    /// Remove a specified account as an approved minter
    pub fn remove_approved_minter(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_minters.remove(&account_id);
    }

    /// Check if a specified account is an approved minter
    pub fn is_approved_minter(&self, account_id: AccountId) -> bool {
        self.approved_minters.contains(&account_id)
    }

    /// Add a specified account as an approved creator
    pub fn add_approved_creator(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_creators.insert(&account_id);
    }

    /// Remove a specified account as an approved creator
    pub fn remove_approved_creator(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_creators.remove(&account_id);
    }

    /// Check if a specified account is an approved creator
    pub fn is_approved_creator(&self, account_id: AccountId) -> bool {
        self.approved_creators.contains(&account_id)
    }
}

'''
'''--- nft-series/src/royalty.rs ---
use crate::*;

pub trait NonFungibleTokenCore {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout;

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance.
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout {
        //get the token object
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the owner of the token
        let owner_id = token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        //keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };
        //get the royalty object from series
        let cur_series = self
            .series_by_id
            .get(&token.series_id)
            .expect("Not a series");

        // If the series doesn't have a royalty, we'll return an a payout object that just includes the owner
        let royalty_option = cur_series.royalty;
        if royalty_option.is_none() {
            let mut payout = HashMap::new();
            payout.insert(owner_id, balance);
            return Payout {
                payout: payout
            };
        }
        // Otherwise, we will get the royalty object from the series
        let royalty = royalty_option.unwrap();

        //make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market can&not payout to that many receivers"
        );

        //go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            //get the key
            let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
            if key != owner_id {
                //
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // payout to previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        //return the payout object
        payout_object
    }

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance.
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout {
        //assert that the user attached 1 yocto NEAR for security reasons
        assert_one_yocto();
        //get the sender ID
        let sender_id = env::predecessor_account_id();
        //transfer the token to the passed in receiver and get the previous token object back
        let previous_token =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, Some(approval_id), memo);

        //refund the previous token owner for the storage used up by the previous approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );

        //get the owner of the token
        let owner_id = previous_token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        //keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };

        //get the royalty object from series
        let cur_series = self
            .series_by_id
            .get(&previous_token.series_id)
            .expect("Not a series");

        // If the series doesn't have a royalty, we'll return an a payout object that just includes the owner
        let royalty_option = cur_series.royalty;
        if royalty_option.is_none() {
            let mut payout = HashMap::new();
            payout.insert(owner_id, balance);
            return Payout {
                payout: payout
            };
        }
        // Otherwise, we will get the royalty object from the series
        let royalty = royalty_option.unwrap();

        //make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        //go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            //get the key
            let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
            if key != owner_id {
                //
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // payout to previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        //return the payout object
        payout_object
    }
}

'''
'''--- nft-series/src/samplecommmands.sh ---
export NEAR_ENV=testnet

near call dev-1702466998641-81286433793519 create_series '{"id":1,"metadata":{"title":"Series Title","description":"Series Description","media":"https://nftstorage.link/ipfs/bafybeidd2etayblrtdajjyhgndj5ld2mb7ltezajt6iy7y76axn7btowfy","media_hash":"aHR0cHM6Ly9uZnRzdG9yYWdlLmxpbmsvaXBmcy9iYWZ5YmVpZGQyZXRheWJscnRkYWpqeWhnbmRqNWxkMm1iN2x0ZXphanQ2aXk3eTc2YXhuN2J0b3dmeQ==","animation_url":"https://nftstorage.link/ipfs/bafkreibr2cq4brpmdb3wdrm5ug6nrvvsqzi464zv5mdcbzpyhep7elqf4i","copies":100,"issued_at":1702476504,"expires_at":1733027582,"starts_at":1702476504,"updated_at":1702476504,"extra":"Extra data","reference":"https://nftstorage.link/ipfs/bafkreig2tgkje43rq4iazdtkzibg5pa6bmafq2bnnvgvepam3fnawyecsi","reference_hash":"hS2qrlGlPhP6kHPqqRyubuV0MFkupQoSGbu0QlwkV/M=","achievement_type":"Achievement Type","achievement_level":"Achievement Level","activity_name":"Activity Name","completion_date":"1/1/1979","community_event":"Community Event","external_links":"External Links","creator":"DevHub via ShardDog"}}' --accountId dev-1702466998641-81286433793519 --amount 1

near call dev-1702466998641-81286433793519 new_default_meta '{"owner_id": "'dev-1702466998641-81286433793519'"}' --accountId dev-1702466998641-81286433793519

near call dev-1702466998641-81286433793519 update_metadata '{"owner_id": "dev-1702466998641-81286433793519", "metadata": {"spec": "nft-1.0.0", "name": "DevHub Badges", "symbol": "DEVHUB", "icon": "data:image/png;base64,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", "base_uri": "", "reference": "", "reference_hash": ""}}' --accountId dev-1702466998641-81286433793519

near call dev-1702466998641-81286433793519 nft_mint '{"id": "1", "receiver_id": "joespano.testnet"}' --accountId dev-1702466998641-81286433793519 --amount 1

near call dev-1702466998641-81286433793519  set_allowed_addresses '{"addresses": ["readylayerone.testnet"]}' --accountId dev-1702466998641-81286433793519 
'''
'''--- nft-series/src/series.rs ---
use near_sdk::json_types::U64;

use crate::*;

#[near_bindgen]
impl Contract {
    /// Create a new series. The caller must be an approved creator. All tokens in the series will inherit the same metadata
    /// If copies are set in the metadata, it will enforce that only that number of NFTs can be minted. If not, unlimited NFTs can be minted.
    /// If a title is set in the metadata, enumeration methods will return the `${title} - ${edition}` else, `${series_id} - ${edition}`
    /// All token IDs internally are stored as `${series_id}:${edition}`
    /// Caller must attach enough $NEAR to cover storage.
    #[payable]
    pub fn create_series(
        &mut self,
        id: u64,
        metadata: TokenMetadata,
        royalty: Option<HashMap<AccountId, u32>>,
        price: Option<U128>
    ) {
        // Measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        // Ensure the caller is an approved creator
        let caller = env::predecessor_account_id();
        require!(
            self.approved_creators.contains(&caller) == true,
            "only approved creators can add a type"
        );

        // Insert the series and ensure it doesn't already exist
        require!(
            self.series_by_id
                .insert(
                    &id,
                    &Series {
                        metadata,
                        royalty,
                        tokens: UnorderedSet::new(StorageKey::SeriesByIdInner {
                            // We get a new unique prefix for the collection
                            account_id_hash: hash_account_id(&format!(
                                "{}{}",
                                id, caller
                            )),
                        }),
                        owner_id: caller,
                        price: price.map(|p| p.into()),
                    }
                )
                .is_none(),
            "collection ID already exists"
        );

        //calculate the required storage which was the used - initial
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        //refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes);
    }

    /// Mint a new NFT that is part of a series. The caller must be an approved minter.
    /// The series ID must exist and if the metadata specifies a copy limit, you cannot exceed it.
    #[payable]
    pub fn nft_mint(&mut self, id: U64, receiver_id: AccountId) {
         // Check if the receiver is in the allowed transfers list
        //assert!(self.allowed_transfers.contains(&receiver_id), "Transfer not allowed to this address");

        // Measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        // Get the series and how many tokens currently exist (edition number = cur_len + 1)
        let mut series = self.series_by_id.get(&id.0).expect("Not a series");
        
        // Check if the series has a price per token. If it does, ensure the caller has attached at least that amount
        let mut price_per_token = 0; 
        if let Some(price) = series.price {
            price_per_token = price;
            require!(env::attached_deposit() > price_per_token, "Need to attach at least enough to cover price");
        // If the series doesn't have a price, ensure the caller is an approved minter.
        } else {
            // Ensure the caller is an approved minter
            let predecessor = env::predecessor_account_id();
            assert!(
                self.approved_minters.contains(&predecessor),
                "Not approved minter"
            );
        }

        let cur_len = series.tokens.len();
        // Ensure we haven't overflowed on the number of copies minted
        if let Some(copies) = series.metadata.copies {
            require!(
                cur_len < copies,
                "cannot mint anymore NFTs for the given series. Limit reached"
            );
        }

        // The token ID is stored internally as `${series_id}:${edition}`
        let token_id = format!("{}:{}", id.0, cur_len + 1);
        series.tokens.insert(&token_id);
        self.series_by_id.insert(&id.0, &series);

        //specify the token struct that contains the owner ID
        let token = Token {
            // Series ID that the token belongs to
            series_id: id.0,
            //set the owner ID equal to the receiver ID passed into the function
            owner_id: receiver_id,
            //we set the approved account IDs to the default value (an empty map)
            approved_account_ids: Default::default(),
            //the next approval ID is set to 0
            next_approval_id: 0,
        };

        //insert the token ID and token struct and make sure that the token doesn't exist
        require!(
            self.tokens_by_id.insert(&token_id, &token).is_none(),
            "Token already exists"
        );

        //call the internal method for adding the token to the owner
        self.internal_add_token_to_owner(&token.owner_id, &token_id);

        // Construct the mint log as per the events standard.
        let nft_mint_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftMint(vec![NftMintLog {
                // Owner of the token.
                owner_id: token.owner_id.to_string(),
                // Vector of token IDs that were minted.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo: None,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_mint_log.to_string());

        //calculate the required storage which was the used - initial
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        // If there's some price for the token, we'll payout the series owner. Otherwise, refund the excess deposit for storage to the caller
        if price_per_token > 0 {
            payout_series_owner(required_storage_in_bytes, price_per_token, series.owner_id);
        } else {
            refund_deposit(required_storage_in_bytes);
        }
    }
}

'''
'''--- nft-series/src/series_open.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen};

// Define the token structure
#[derive(BorshSerialize, BorshDeserialize)]
pub struct Token {
    pub id: u64,
    pub series_id: u64,
    pub owner: String,
    pub image_url: String,
    pub reference: String,
    pub title: String,
    pub description: String,
}

// Define the series structure
#[derive(BorshSerialize, BorshDeserialize)]
pub struct Series {
    pub id: u64,
    pub name: String,
}

// Define the contract
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct OpenCollection {
    pub tokens: Vec<Token>,
    pub series: Vec<Series>,
}

#[near_bindgen]
impl OpenCollection {
    // Mint a new token with specified details
    pub fn mint_token(
        &mut self,
        id: u64,
        series_id: u64,
        owner: String,
        image_url: String,
        reference: String,
        title: String,
        description: String,
    ) {
        let new_token = Token {
            id,
            series_id,
            owner,
            image_url,
            reference,
            title,
            description,
        };
        self.tokens.push(new_token);
    }

    // Create a new series
    pub fn create_series(&mut self, id: u64, name: String) {
        let new_series = Series { id, name };
        self.series.push(new_series);
    }

    // Get the token details by ID
    pub fn get_token(&self, id: u64) -> Option<Token> {
        self.tokens.iter().find(|token| token.id == id).cloned()
    }

    // Get the series details by ID
    pub fn get_series(&self, id: u64) -> Option<Series> {
        self.series.iter().find(|series| series.id == id).cloned()
    }

    // Update the series name by ID
    pub fn update_series_name(&mut self, id: u64, name: String) {
        if let Some(series) = self.series.iter_mut().find(|series| series.id == id) {
            series.name = name;
        }
    }

    // Update the token details by ID
    pub fn update_token_details(
        &mut self,
        id: u64,
        owner: String,
        image_url: String,
        reference: String,
        title: String,
        description: String,
    ) {
        if let Some(token) = self.tokens.iter_mut().find(|token| token.id == id) {
            token.owner = owner;
            token.image_url = image_url;
            token.reference = reference;
            token.title = title;
            token.description = description;
        }
    }
}

'''
'''--- package.json ---
{
    "name": "devhub-badges",
    "version": "1.0.0",
    "description": "DevHub Badges",
    "author": "Ben Kurrek & Joe Spano",
    "license": "ISC",
    "scripts": {
        "build": "cd nft-series && bash build.sh && cd .."
    }
}

'''