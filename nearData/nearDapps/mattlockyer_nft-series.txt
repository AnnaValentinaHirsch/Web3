*GitHub Repository "mattlockyer/nft-series"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- README.md ---
# NFT Series Implementation

# WARNING

This is using some non-standard stuff

## Rough notes on token series (type) and editions

```
// Mappings pseudo code
TokenTypeString -> TokenTypeInt
TokenTypeInt -> TokenTypeStruct (data)

TokenId.split(":")[0] -> TokenTypeInt
TokenId.split(":")[1] -> TokenEditionInt (unique token in type)

In Rust:
// getting owner of token
let owner_id = self.tokens.owner_by_id.get(&token_id)

// getting metadata for token (TokenTypeStruct)
let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
let token_type_id = token_id_iter.next().unwrap().parse().unwrap();
let metadata = self.token_type_by_id.get(&token_type_id).unwrap().metadata;
```

## Instructions

`yarn && yarn test:deploy`

#### Pre-reqs

Rust, cargo, near-cli, etc...
Everything should work if you have NEAR development env for Rust contracts set up.

[Tests](test/api.test.js)
[Contract](contract/src/lib.rs)

'''
'''--- contract/Cargo.toml ---
[package]
name = "nft-series"
version = "0.1.0"
authors = ["Matt Lockyer <mattdlockyer@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.5"
near-contract-standards = "4.0.0-pre.5"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm

'''
'''--- contract/src/lib.rs ---
mod utils;
use crate::utils::*;

use std::collections::HashMap;
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::core::{
	NonFungibleTokenCore, NonFungibleTokenResolver
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, Vector, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U64, U128};
use near_sdk::{
    env, near_bindgen, serde_json::json, Balance, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};
use near_sdk::serde::{Deserialize, Serialize};

/// CUSTOM TYPES

/// log series const
pub const EVENT_JSON: &str = "EVENT_JSON:";
/// between token_series_id and edition number e.g. 42:2 where 42 is series and 2 is edition
pub const TOKEN_DELIMETER: char = ':';
/// TokenMetadata.title returned for individual token e.g. "Title — 2/10" where 10 is max copies
pub const TITLE_DELIMETER: &str = " — ";
/// e.g. "Title — 2/10" where 10 is max copies
pub const EDITION_DELIMETER: &str = "/";
pub type TokenSeriesId = u64;
pub type TokenSeriesTitle = String;
#[derive(BorshDeserialize, BorshSerialize)]
pub struct TokenSeries {
	metadata: TokenMetadata,
	owner_id: AccountId,
	royalty: HashMap<AccountId, u32>,
	tokens: UnorderedSet<TokenId>,
	approved_market_id: Option<AccountId>,
}
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson {
	metadata: TokenMetadata,
	owner_id: AccountId,
	royalty: HashMap<AccountId, u32>,
}
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SeriesMintArgs {
	token_series_title: TokenSeriesTitle,
	receiver_id: AccountId,
}

/// payout series for royalties to market
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
	payout: HashMap<AccountId, U128>
}

/// STANDARD
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
	// CUSTOM
	token_series_by_title: LookupMap<TokenSeriesTitle, TokenSeriesId>,
	token_series_by_id: UnorderedMap<TokenSeriesId, TokenSeries>,
}
const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";
#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
	// STANDARD
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
	// CUSTOM
    TokenSeriesByTitle,
    TokenSeriesById,
    TokensBySeriesInner { token_series_id: u64 },
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "NFT Series".to_string(),
                symbol: "NFT".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
			token_series_by_id: UnorderedMap::new(StorageKey::TokenSeriesById),
			token_series_by_title: LookupMap::new(StorageKey::TokenSeriesByTitle),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

	// CUSTOM
    
    #[payable]
    pub fn nft_create_series(
        &mut self,
        metadata: TokenMetadata,
        royalty: HashMap<AccountId, u32>,
    ) {
		let initial_storage_usage = env::storage_usage();
        let owner_id = env::predecessor_account_id();
		let title = metadata.title.clone();
		assert!(title.is_some(), "token_metadata.title is required");
		let token_series_id = self.token_series_by_id.len() + 1;
        assert!(self.token_series_by_title.insert(&title.unwrap(), &token_series_id).is_none(), "token_metadata.title exists");
        self.token_series_by_id.insert(&token_series_id, &TokenSeries{
			metadata,
			owner_id,
			royalty,
			tokens: UnorderedSet::new(
				StorageKey::TokensBySeriesInner {
					token_series_id
				}
				.try_to_vec()
				.unwrap(),
			),
			approved_market_id: None,
		});

        refund_deposit(env::storage_usage() - initial_storage_usage);
    }

	pub fn cap_copies(
		&mut self,
		token_series_title: TokenSeriesTitle,
	) {
		assert_eq!(env::predecessor_account_id(), self.tokens.owner_id, "Unauthorized");
		let token_series_id = self.token_series_by_title.get(&token_series_title).expect("no series");
		let mut token_series = self.token_series_by_id.get(&token_series_id).expect("no token");
		token_series.metadata.copies = Some(token_series.tokens.len());
		self.token_series_by_id.insert(&token_series_id, &token_series);
	}

	#[payable]
	pub fn nft_mint_series(
		&mut self,
		token_series_title: TokenSeriesTitle,
		receiver_id: AccountId,
	) -> Token {
		let initial_storage_usage = env::storage_usage();

		let token_series_id = self.token_series_by_title.get(&token_series_title).expect("no series");
		let mut token_series = self.token_series_by_id.get(&token_series_id).expect("no token");
		assert_eq!(&env::predecessor_account_id(), &token_series.owner_id, "not series owner");

		let num_tokens = token_series.tokens.len();
		let max_copies = token_series.metadata.copies.unwrap_or(u64::MAX);
		assert_ne!(num_tokens, max_copies, "series supply maxed");

		let token_id = format!("{}{}{}", &token_series_id, TOKEN_DELIMETER, num_tokens + 1);
		token_series.tokens.insert(&token_id);
		self.token_series_by_id.insert(&token_series_id, &token_series);

		// you can add custom metadata to each token here
		// make sure you update self.nft_token to "patch" over the series metadata
		let metadata = Some(TokenMetadata {
			title: None, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
			description: None, // free-form description
			media: None, // URL to associated media, preferably to decentralized, content-addressed storage
			copies: None, // number of copies of this set of metadata in existence when token was minted.
			media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
			issued_at: None, // ISO 8601 datetime when token was issued or minted
			expires_at: None, // ISO 8601 datetime when token expires
			starts_at: None, // ISO 8601 datetime when token starts being valid
			updated_at: None, // ISO 8601 datetime when token was last updated
			extra: None, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
			reference: None, // URL to an off-chain JSON file with more info.
			reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
		});
		let token = self.tokens.internal_mint(token_id.clone(), receiver_id.clone(), metadata);

        refund_deposit(env::storage_usage() - initial_storage_usage);

		env::log_str(format!("{}{}", EVENT_JSON, json!({
			"standard": "nep171",
			"version": "1.0.0",
			"event": "nft_mint",
			"data": [
			  	{
					  "owner_id": receiver_id,
					  "token_ids": [token_id]
				}
			]
		})).as_ref());
			
		token
	}

	/// CUSTOM re-implement core standard here, not using macros from near-contract-standards

	/// pass through
	#[payable]
	pub fn nft_transfer(
		&mut self,
		receiver_id: AccountId,
		token_id: TokenId,
		approval_id: Option<u64>,
		memo: Option<String>,
	) {
		self.tokens.nft_transfer(receiver_id, token_id, approval_id, memo)
	}

	/// pass through
	#[payable]
	pub fn nft_transfer_call(
		&mut self,
		receiver_id: AccountId,
		token_id: TokenId,
		approval_id: Option<u64>,
		memo: Option<String>,
		msg: String,
	) -> PromiseOrValue<bool> {
		self.tokens.nft_transfer_call(receiver_id, token_id, approval_id, memo, msg)
	}

	/// CUSTOM royalties payout
	#[payable]
	pub fn nft_transfer_payout(
		&mut self,
		receiver_id: AccountId,
		token_id: TokenId,
		approval_id: u64,
		memo: Option<String>,
		balance: Option<U128>,
		max_len_payout: Option<u32>,
	) -> Option<Payout> {

		// lazy minting?
		let series_mint_args = memo.clone();
		let previous_token = if let Some(series_mint_args) = series_mint_args {
			let SeriesMintArgs{token_series_title, receiver_id} = near_sdk::serde_json::from_str(&series_mint_args).expect("invalid SeriesMintArgs");
			self.nft_mint_series(token_series_title, receiver_id.clone())
		} else {
			let prev_token = self.nft_token(token_id.clone()).expect("no token");
			self.tokens.nft_transfer(receiver_id.clone(), token_id.clone(), Some(approval_id), memo);
			prev_token
		};

        // compute payouts based on balance option
        let owner_id = previous_token.owner_id;
        let payout_struct = if let Some(balance) = balance {
			let complete_royalty = 10_000u128;
            let balance_piece = u128::from(balance) / complete_royalty;
			let mut total_royalty_percentage = 0;
            let mut payout_struct: Payout = Payout{
				payout: HashMap::new()
			};
			let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
			let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
            let royalty = self.token_series_by_id.get(&token_series_id).expect("no series").royalty;

            if let Some(max_len_payout) = max_len_payout {
                assert!(royalty.len() as u32 <= max_len_payout, "exceeds max_len_payout");
            }
            for (k, v) in royalty.iter() {
                let key = k.clone();
				// skip seller and payout once at end
                if key != owner_id {
                    payout_struct.payout.insert(key, U128(*v as u128 * balance_piece));
                    total_royalty_percentage += *v;
                }
            }
            // payout to seller
            payout_struct.payout.insert(owner_id.clone(), U128((complete_royalty - total_royalty_percentage as u128) * balance_piece));
            Some(payout_struct)
        } else {
            None
        };

		env::log_str(format!("{}{}", EVENT_JSON, json!({
			"standard": "nep171",
			"version": "1.0.0",
			"event": "nft_transfer",
			"data": [
				{
					"old_owner_id": owner_id, "new_owner_id": receiver_id, "token_ids": [token_id]
				}
			]
		})).as_ref());

        payout_struct
	}

	/// CUSTOM re-implementation of near-contract-standards (not using macros)
	
	/// CUSTOM every enumeration method goes through here (watch the gas on views...)
	
	pub fn nft_token(&self, token_id: TokenId) -> Option<Token> {
		let owner_id = self.tokens.owner_by_id.get(&token_id)?;
        let approved_account_ids = self.tokens
            .approvals_by_id
			.as_ref()
            .and_then(|by_id| by_id.get(&token_id).or_else(|| Some(HashMap::new())));

		// CUSTOM (switch metadata for the token_series metadata)
		let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
		let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
		// make edition titles nice for showing in wallet
		let mut metadata = self.token_series_by_id.get(&token_series_id).unwrap().metadata;
		let copies = metadata.copies;
		if let Some(copies) = copies {
			metadata.title = Some(
				format!(
					"{}{}{}{}{}",
					metadata.title.unwrap(),
					TITLE_DELIMETER,
					token_id_iter.next().unwrap(),
					EDITION_DELIMETER,
					copies
				)
			);
		}
		
		// CUSTOM
		// implement this if you need to combine individual token metadata
		// e.g. metadata.extra with TokenSeries.metadata.extra and return something unique
		// let token_metadata = self.tokens.token_metadata_by_id.get(&token_id)?;
		// metadata.extra = token_metadata.extra;

        Some(Token { token_id, owner_id, metadata: Some(metadata), approved_account_ids })
	}

	pub fn nft_total_supply(&self) -> U128 {
		(self.tokens.owner_by_id.len() as u128).into()
	}

    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.tokens.owner_by_id.len() as u128) > start_index,
            "start_index gt len"
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        self.tokens.owner_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_id, _)| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_supply_for_owner(self, account_id: AccountId) -> U128 {
        let tokens_per_owner = self.tokens.tokens_per_owner.expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        tokens_per_owner
            .get(&account_id)
            .map(|account_tokens| U128::from(account_tokens.len() as u128))
            .unwrap_or(U128(0))
    }

	pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Token> { 
		let tokens = self.tokens.tokens_per_owner.as_ref().expect("no tokens").get(&account_id).expect("no tokens");
		unordered_set_pagination(&tokens, from_index, limit)
			.iter()
			.map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }

	/// CUSTOM VIEWS for seriesd tokens

	pub fn nft_get_series_json(&self, token_series_title: TokenSeriesTitle) -> TokenSeriesJson {
		let token_series = self.token_series_by_id.get(&self.token_series_by_title.get(&token_series_title).expect("no series")).expect("no series");
		TokenSeriesJson{
			metadata: token_series.metadata,
			owner_id: token_series.owner_id,
			royalty: token_series.royalty,
		}
	}

	pub fn nft_get_series(
		&self,
		from_index: Option<U128>,
		limit: Option<u64>
	) -> Vec<TokenSeriesJson> {
		unordered_map_val_pagination(&self.token_series_by_id, from_index, limit)
			.iter()
			.map(|token_series| TokenSeriesJson{
				metadata: token_series.metadata.clone(),
				owner_id: token_series.owner_id.clone(),
				royalty: token_series.royalty.clone(),
			})
            .collect()
    }

	pub fn nft_supply_for_series(
        &self,
        token_series_title: TokenSeriesTitle,
    ) -> U64 {
        self.token_series_by_id.get(&self.token_series_by_title.get(&token_series_title).expect("no series")).expect("no series").tokens.len().into()
    }

	pub fn nft_tokens_by_series(
		&self,
        token_series_title: TokenSeriesTitle,
		from_index: Option<U128>,
		limit: Option<u64>
	) -> Vec<Token> {
		let tokens = self.token_series_by_id.get(&self.token_series_by_title.get(&token_series_title).expect("no series")).expect("no series").tokens;
		unordered_set_pagination(&tokens, from_index, limit)
			.iter()
			.map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }

	pub fn nft_get_series_format(&self) -> (char, &'static str, &'static str) {
		(TOKEN_DELIMETER, TITLE_DELIMETER, EDITION_DELIMETER)
	}
}

// near-contract-standards macros
// near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
// near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
	#[private]
	fn nft_resolve_transfer(
		&mut self,
		previous_owner_id: AccountId,
		receiver_id: AccountId,
		token_id: TokenId,
		approved_account_ids: Option<HashMap<AccountId, u64>>,
	) -> bool {
		self.tokens.nft_resolve_transfer(
			previous_owner_id,
			receiver_id,
			token_id,
			approved_account_ids,
		)
	}
}
'''
'''--- contract/src/utils.rs ---
use crate::*;

pub(crate) fn paginate<V>(
	values: &Vector<V>,
	from_index: Option<U128>,
    limit: Option<u64>,
) -> Vec<V> where V: BorshSerialize + BorshDeserialize {
	let len = values.len();
	if len == 0 {
		return vec![];
	}
	let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
	assert_ne!(limit, 0, "limit 0");
	let start_index: u128 = from_index.map(From::from).unwrap_or_default();
	assert!(
		len as u128 > start_index,
		"start_index gt len"
	);
	values
		.iter()
		.skip(start_index as usize)
		.take(limit)
		.map(|v| v)
		.collect()
}

pub(crate) fn unordered_map_val_pagination<K, V>(
    map: &UnorderedMap<K, V>,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> Vec<V> where K: BorshSerialize + BorshDeserialize, V: BorshSerialize + BorshDeserialize {
	paginate(map.values_as_vector(), from_index, limit)
}

// pub(crate) fn unordered_map_key_pagination<K, V>(
//     map: &UnorderedMap<K, V>,
//     from_index: Option<U128>,
//     limit: Option<u64>,
// ) -> Vec<K> where K: BorshSerialize + BorshDeserialize, V: BorshSerialize + BorshDeserialize {
// 	paginate(map.keys_as_vector(), from_index, limit)
// }

pub(crate) fn unordered_set_pagination<V>(
    set: &UnorderedSet<V>,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> Vec<V> where V: BorshSerialize + BorshDeserialize {
	paginate(set.as_vector(), from_index, limit)
}

pub(crate) fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;
	// log!("refund_deposit amount {}", refund);
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

'''
'''--- market/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.2"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- market/README.md ---
# TBD

'''
'''--- market/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/market.wasm

'''
'''--- market/clippy.toml ---
too-many-arguments-threshold = 10
'''
'''--- market/src/external.rs ---
use crate::*;

/// external contract calls

#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        msg: Option<String>,
        balance: U128,
    );
    fn ft_transfer(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>
    );
}
'''
'''--- market/src/ft_callbacks.rs ---
use crate::*;

/// callbacks from FT Contracts

trait FungibleTokenReceiver {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128> {
        let PurchaseArgs {
            nft_contract_id,
            token_id,
        } = near_sdk::serde_json::from_str(&msg).expect("Invalid PurchaseArgs");

        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        let sale = self
            .sales
            .get(&contract_and_token_id)
            .expect("No sale in ft_on_transfer");
            
        assert_ne!(sale.owner_id, sender_id, "Cannot buy your own sale.");

        let ft_token_id = env::predecessor_account_id();
        let price = *sale
            .conditions
            .get(&ft_token_id)
            .expect("Not for sale in that token type");

        assert!(amount.0 > 0, "Amount must be greater than 0");

        if amount == price {
            self.process_purchase(
                sale,
                nft_contract_id.into(),
                token_id,
                ft_token_id,
                None,
                amount,
                price,
                sender_id,
            ).into()
        } else {
            self.add_bid(
                contract_and_token_id,
                price.0,
                amount.0,
                ft_token_id,
                sender_id,
            );
            PromiseOrValue::Value(U128(0))
        }
    }
}

'''
'''--- market/src/internal.rs ---
use crate::*;

pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

impl Contract {
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_id,
            "Owner's method"
        );
    }

    pub(crate) fn internal_remove_sale(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
    ) -> Sale {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        let sale = self.sales.remove(&contract_and_token_id).expect("No sale");

        let mut by_owner_id = self.by_owner_id.get(&sale.owner_id).expect("No sale by_owner_id");
        by_owner_id.remove(&contract_and_token_id);
        if by_owner_id.is_empty() {
            self.by_owner_id.remove(&sale.owner_id);
        } else {
            self.by_owner_id.insert(&sale.owner_id, &by_owner_id);
        }

        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .expect("No sale by nft_contract_id");
        by_nft_contract_id.remove(&contract_and_token_id);
        if by_nft_contract_id.is_empty() {
            self.by_nft_contract_id.remove(&nft_contract_id);
        } else {
            self.by_nft_contract_id
                .insert(&nft_contract_id, &by_nft_contract_id);
        }

        let token_type = sale.token_type.clone();
        if let Some(token_type) = token_type {
            let mut by_nft_token_type = self.by_nft_token_type.get(&token_type).expect("No sale by nft_token_type");
            by_nft_token_type.remove(&contract_and_token_id);
            if by_nft_token_type.is_empty() {
                self.by_nft_token_type.remove(&token_type);
            } else {
                self.by_nft_token_type.insert(&token_type, &by_nft_token_type);
            }
        }

        sale
    }
}

'''
'''--- market/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, AccountId, Balance, CryptoHash, Gas,
    BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};
use std::cmp::min;
use std::collections::HashMap;

use crate::external::*;
use crate::internal::*;
use crate::sale::*;
use near_sdk::env::STORAGE_PRICE_PER_BYTE;

mod external;
mod ft_callbacks;
mod internal;
mod nft_callbacks;
mod sale;
mod sale_views;

// TODO check seller supports storage_deposit at ft_token_id they want to post sale in

const NO_DEPOSIT: Balance = 0;
const STORAGE_PER_SALE: u128 = 1000 * STORAGE_PRICE_PER_BYTE;
static DELIMETER: &str = "||";

pub type SaleConditions = HashMap<FungibleTokenId, U128>;
pub type TokenId = String;
pub type TokenType = String;
pub type FungibleTokenId = AccountId;
pub type ContractAndTokenId = String;
// TODO: Capital U128
/// payout series for royalties to market
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
	payout: HashMap<AccountId, U128>
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
	pub near_ft: AccountId,
    pub owner_id: AccountId,
    pub sales: UnorderedMap<ContractAndTokenId, Sale>,
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,
    pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,
    pub by_nft_token_type: LookupMap<TokenType, UnorderedSet<ContractAndTokenId>>,
    pub ft_token_ids: UnorderedSet<AccountId>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
}

/// Helper structure to for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Sales,
    ByOwnerId,
    ByOwnerIdInner { account_id_hash: CryptoHash },
    ByNFTContractId,
    ByNFTContractIdInner { account_id_hash: CryptoHash },
    ByNFTTokenType,
    ByNFTTokenTypeInner { token_type_hash: CryptoHash },
    FTTokenIds,
    StorageDeposits,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId, ft_token_ids: Option<Vec<AccountId>>) -> Self {
        let mut this = Self {
			near_ft: AccountId::new_unchecked("near".to_string()),
            owner_id,
            sales: UnorderedMap::new(StorageKey::Sales),
            by_owner_id: LookupMap::new(StorageKey::ByOwnerId),
            by_nft_contract_id: LookupMap::new(StorageKey::ByNFTContractId),
            by_nft_token_type: LookupMap::new(StorageKey::ByNFTTokenType),
            ft_token_ids: UnorderedSet::new(StorageKey::FTTokenIds),
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
        };
        // support NEAR by default
        this.ft_token_ids.insert(&AccountId::new_unchecked("near".to_string()));

        if let Some(ft_token_ids) = ft_token_ids {
            for ft_token_id in ft_token_ids {
                this.ft_token_ids.insert(&ft_token_id);
            }
        }

        this
    }

    /// only owner
    pub fn add_ft_token_ids(&mut self, ft_token_ids: Vec<AccountId>) -> Vec<bool> {
        self.assert_owner();
        ft_token_ids
            .into_iter()
            .map(|ft_token_id| self.ft_token_ids.insert(&ft_token_id))
            .collect()
    }

    /// TODO remove token (should check if sales can complete even if owner stops supporting token type)

    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>, amount: Option<Balance>) {
        let storage_account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        let deposit = if let Some(amount) = amount {
            amount
        } else {
            env::attached_deposit()
        };
        assert!(
            deposit >= STORAGE_PER_SALE,
            "Requires minimum deposit of {}",
            STORAGE_PER_SALE
        );
        let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
        balance += deposit;
        self.storage_deposits.insert(&storage_account_id, &balance);
    }

    #[payable]
    pub fn storage_withdraw(&mut self) {
        assert_one_yocto();
        let owner_id = env::predecessor_account_id();
        let mut amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);
        let sales = self.by_owner_id.get(&owner_id);
        let len = sales.map(|s| s.len()).unwrap_or(0);
        amount -= u128::from(len) * STORAGE_PER_SALE;
        if amount > 0 {
            Promise::new(owner_id).transfer(amount);
        }
    }

    /// views

    pub fn supported_ft_token_ids(&self) -> Vec<AccountId> {
        self.ft_token_ids.to_vec()
    }

    pub fn storage_amount(&self) -> U128 {
        U128(STORAGE_PER_SALE)
    }

    pub fn storage_paid(&self, account_id: AccountId) -> U128 {
        U128(self.storage_deposits.get(&account_id).unwrap_or(0))
    }
}

'''
'''--- market/src/nft_callbacks.rs ---
use crate::*;

/// approval callbacks from NFT Contracts

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleArgs {
    pub sale_conditions: SaleConditions,
    pub token_type: TokenType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_auction: Option<bool>,
}

trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    #[payable]
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        self.check_valid_callback(owner_id.clone());

        let nft_contract_id = env::predecessor_account_id();

        let SaleArgs { sale_conditions, token_type, is_auction: _ } =
            near_sdk::serde_json::from_str(&msg).expect("Not valid SaleArgs");

        for (ft_token_id, _price) in sale_conditions.clone() {
            if !self.ft_token_ids.contains(&ft_token_id) {
                env::panic_str(
                    &format!("Token {} not supported by this market", ft_token_id),
                );
            }
        }

        // log!("add_sale for owner: {}", &owner_id);

        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        self.sales.insert(
            &contract_and_token_id,
            &Sale {
                owner_id: owner_id.clone(),
                created_at: env::block_timestamp().into(),
                approval_id,
                nft_contract_id: nft_contract_id.clone(),
                token_id: token_id.clone(),
                conditions: sale_conditions,
                is_series: None,
                token_type: Some(token_type.clone()),
                bids: None,
            },
        );

        // extra for views

        let mut by_owner_id = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(StorageKey::ByOwnerIdInner {
                account_id_hash: hash_account_id(&owner_id),
            })
        });
        by_owner_id.insert(&contract_and_token_id);
        self.by_owner_id.insert(&owner_id, &by_owner_id);

        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::ByNFTContractIdInner {
                    account_id_hash: hash_account_id(&nft_contract_id),
                })
            });
        by_nft_contract_id.insert(&contract_and_token_id);
        self.by_nft_contract_id
            .insert(&nft_contract_id, &by_nft_contract_id);

		assert!(
			token_id.contains(&token_type),
			"TokenType should be substr of TokenId"
		);
		let mut by_nft_token_type =
			self.by_nft_token_type.get(&token_type).unwrap_or_else(|| {
				UnorderedSet::new(
					StorageKey::ByNFTTokenTypeInner {
						token_type_hash: hash_account_id(&AccountId::new_unchecked(token_type.clone())),
					}
				)
			});
		by_nft_token_type.insert(&contract_and_token_id);
		self.by_nft_token_type
			.insert(&token_type, &by_nft_token_type);
    }
}

// trait NonFungibleSeriesApprovalReceiver {
//     fn series_on_approve(&mut self, series_name: String, owner_id: AccountId, msg: String);
// }

// #[near_bindgen]
// impl NonFungibleSeriesApprovalReceiver for Contract {
//     #[payable]
//     fn series_on_approve(&mut self, series_name: String, owner_id: AccountId, msg: String) {
//         self.check_valid_callback(owner_id.clone());

//         let nft_contract_id = env::predecessor_account_id();

//         let SaleArgs {
//             sale_conditions,
//             token_type: _,
//         } = near_sdk::serde_json::from_str(&msg).expect("Not valid SaleArgs");

//         let mut conditions = HashMap::new();
//         for Price { price, ft_token_id } in sale_conditions {
//             if !self.ft_token_ids.contains(&ft_token_id) {
//                 env::panic_str(
//                     &format!("Token {} not supported by this market", ft_token_id),
//                 );
//             }
//             conditions.insert(ft_token_id.into(), price.unwrap_or(U128(0)));
//         }

//         // log!("add_sale for owner: {}", &owner_id);

//         let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, series_name);
//         self.sales.insert(
//             &contract_and_token_id,
//             &Sale {
//                 owner_id: owner_id.clone().into(),
//                 created_at: env::block_timestamp().into(),
//                 approval_id: u64(0),
//                 nft_contract_id: nft_contract_id.clone(),
//                 token_id: series_name.clone(),
//                 conditions,
//                 is_series: Some(true),
//                 token_type: None,
//                 bids: None,
//             },
//         );

//         // extra for views

//         let mut by_owner_id = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
//             UnorderedSet::new(
//                 StorageKey::ByOwnerIdInner {
//                     account_id_hash: hash_account_id(&owner_id),
//                 }
//             )
//         });

//         by_owner_id.insert(&contract_and_token_id);
//         self.by_owner_id.insert(&owner_id, &by_owner_id);

//         let mut by_nft_contract_id = self
//             .by_nft_contract_id
//             .get(&nft_contract_id)
//             .unwrap_or_else(|| {
//                 UnorderedSet::new(
//                     StorageKey::ByNFTContractIdInner {
//                         account_id_hash: hash_account_id(&nft_contract_id),
//                     }
//                 )
//             });
//         by_nft_contract_id.insert(&contract_and_token_id);
//         self.by_nft_contract_id
//             .insert(&nft_contract_id, &by_nft_contract_id);

//         let mut by_nft_token_type = self.by_nft_token_type.get(&series_name).unwrap_or_else(|| {
//             UnorderedSet::new(
//                 StorageKey::ByNFTTokenTypeInner {
//                     token_type_hash: hash_account_id(&AccountId::new_unchecked(series_name.clone())),
//                 }
//             )
//         });
//         by_nft_token_type.insert(&contract_and_token_id);
//         self.by_nft_token_type
//             .insert(&series_name, &by_nft_token_type);
//     }

// }

#[near_bindgen]
impl Contract {

    #[private]
    pub fn check_valid_callback(&mut self, owner_id: AccountId) {

        // enforce cross contract calls and owner_id is signer

        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();
        assert_ne!(
            nft_contract_id,
            signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        assert_eq!(
            &owner_id,
            &signer_id,
            "owner_id should be signer_id"
        );

        // pay storage for 1 sale listing with attached deposit and refund the rest

        let storage_amount = self.storage_amount().0;
        self.storage_deposit(Some(owner_id.clone()), Some(storage_amount));
        let refund = env::attached_deposit().saturating_sub(storage_amount);
        if refund > 1 {
            Promise::new(owner_id.clone().into()).transfer(refund);
        }

        // enforce owner's storage is enough to cover + 1 more sale 

        let owner_paid_storage = self.storage_deposits.get(&owner_id).unwrap_or(0);
        let signer_storage_required = (self.get_supply_by_owner_id(owner_id.into()).0 + 1) as u128 * storage_amount;
        assert!(
            owner_paid_storage >= signer_storage_required,
            "Insufficient storage paid: {}, for {} sales at {} rate of per sale",
            owner_paid_storage, signer_storage_required / STORAGE_PER_SALE, STORAGE_PER_SALE
        );
    }
}

'''
'''--- market/src/sale.rs ---
use crate::*;
use near_sdk::{log, promise_result_as_success};

/// measuring how many royalties can be paid
const GAS_FOR_FT_TRANSFER: Gas = Gas(5_000_000_000_000);
/// seems to be max Tgas can attach to resolve_purchase
const GAS_FOR_ROYALTIES: Gas = Gas(120_000_000_000_000);
const GAS_FOR_NFT_TRANSFER: Gas = Gas(20_000_000_000_000);

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Bid {
    pub owner_id: AccountId,
    pub price: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    pub owner_id: AccountId,
    pub approval_id: u64,
    pub nft_contract_id: AccountId,
    pub token_id: String,
    pub conditions: HashMap<FungibleTokenId, U128>,
    pub created_at: U64,
    pub is_series: Option<bool>,
    pub token_type: Option<String>,
    pub bids: Option<HashMap<FungibleTokenId, Bid>>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    pub ft_token_id: AccountId,
    pub price: Option<U128>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PurchaseArgs {
    pub nft_contract_id: AccountId,
    pub token_id: TokenId,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SeriesMintArgs {
    pub series_name: String,
    pub mint: Vec<String>,
    pub owner: Vec<String>,
    pub perpetual_royalties: Option<HashMap<AccountId, u32>>,
    pub receiver_id: Option<AccountId>,
}

#[near_bindgen]
impl Contract {
    /// for add sale see: nft_callbacks.rs
    #[payable]
    pub fn remove_sale(&mut self, nft_contract_id: AccountId, token_id: String) {
        assert_one_yocto();
        let sale = self.internal_remove_sale(nft_contract_id.into(), token_id);
        let owner_id = env::predecessor_account_id();
        assert_eq!(owner_id, sale.owner_id, "Must be sale owner");
        self.refund_bids(sale.bids.unwrap_or_default());
    }

    #[payable]
    pub fn update_price(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        ft_token_id: AccountId,
        price: U128,
    ) {
        assert_one_yocto();
        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");
        assert_eq!(
            env::predecessor_account_id(),
            sale.owner_id,
            "Must be sale owner"
        );
        if !self.ft_token_ids.contains(&ft_token_id) {
            env::panic_str(&format!("Token {} not supported by this market", ft_token_id));
        }
        sale.conditions.insert(ft_token_id.into(), price);
        self.sales.insert(&contract_and_token_id, &sale);
    }

    #[payable]
    pub fn offer(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        msg: Option<String>,
    ) {
        let contract_id: AccountId = nft_contract_id;
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        let sale = self.sales.get(&contract_and_token_id).expect("No sale");
        let buyer_id = env::predecessor_account_id();
        if sale.is_series.is_none() {
            assert_ne!(sale.owner_id, buyer_id, "Cannot bid on your own sale.");
        }
        let price = sale
            .conditions
            .get(&self.near_ft)
            .expect("Not for sale in NEAR")
            .0;

        let deposit = env::attached_deposit();
        let msg_is_some = msg.is_some();
        assert!(deposit > 0, "Attached deposit must be greater than 0");
        // there's a fixed price user can buy for so process purchase
        // or, with memo user is passing through their deposit
        if deposit == price || msg_is_some {
            let diff = deposit.checked_sub(price).expect("Attached deposit for minting is less than price.");
            if msg_is_some {
                assert!(diff > 0, "Attached deposit must be greater than price (to pay for storage of minted NFT).");
            }
            self.process_purchase(
                sale,
                contract_id,
                token_id,
                self.near_ft.clone(),
                msg,
                U128(deposit),
                U128(price),
                buyer_id,
            );
        } else {
            self.add_bid(contract_and_token_id, price, deposit, self.near_ft.clone(), buyer_id)
        }
    }

    #[private]
    pub fn process_purchase(
        &mut self,
        sale: Sale,
        nft_contract_id: AccountId,
        token_id: String,
        ft_token_id: AccountId,
        msg: Option<String>,
        paid: U128,
        price: U128,
        buyer_id: AccountId,
    ) -> Promise {
        if sale.is_series.is_none() {
            self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());
        }

        let mut nft_transfer_deposit = paid.0.saturating_sub(price.0);
        if nft_transfer_deposit < 1 {
            nft_transfer_deposit = 1
        }

        ext_contract::nft_transfer_payout(
            buyer_id.clone(),
            token_id,
            sale.approval_id,
            msg,
            price,
            nft_contract_id,
            // price paid remains with contract (excess deposit for storage cost of series lazy mint)
            nft_transfer_deposit,
            GAS_FOR_NFT_TRANSFER,
        )
        .then(ext_self::resolve_purchase(
            ft_token_id,
            buyer_id,
            sale,
            paid,
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_ROYALTIES,
        ))
    }

    /// self callback

    #[private]
    pub fn resolve_purchase(
        &mut self,
        ft_token_id: AccountId,
        buyer_id: AccountId,
        sale: Sale,
        paid: U128,
    ) -> U128 {
        let bids = sale.bids.unwrap_or_default();
        let price = sale.conditions[&ft_token_id];

        // checking for payout information
        let payout_option = promise_result_as_success().and_then(|value| {
            // None means a bad payout from bad NFT contract
            near_sdk::serde_json::from_slice::<Payout>(&value)
                .ok()
                .and_then(|payout_struct| {
                    // gas to do 10 FT transfers (and definitely 10 NEAR transfers)
                    if payout_struct.payout.len() + bids.len() > 10 || payout_struct.payout.is_empty() {
                        log!("Cannot have more than 10 royalties and sale.bids refunds");
                        None
                    } else {
                        // TODO off by 1 e.g. payouts are fractions of 3333 + 3333 + 3333
                        let mut remainder = price.0;
                        for &value in payout_struct.payout.values() {
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        if remainder == 0 || remainder == 1 {
                            Some(payout_struct)
                        } else {
                            None
                        }
                    }
                })
        });
        // is payout option valid?
        let payout_struct = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            if ft_token_id == self.near_ft {
                // TODO pay back the deposit for minting the token if this was a series purchase and unsuccessful
                Promise::new(buyer_id).transfer(u128::from(paid));
            }
            // leave function and return all FTs in ft_resolve_transfer
            return paid;
        };
        // Goint to payout everyone, first return all outstanding bids (accepted offer bid was already removed)
        self.refund_bids(bids);

        // NEAR payouts
        if ft_token_id == self.near_ft.clone() {
            for (receiver_id, amount) in payout_struct.payout {
                Promise::new(receiver_id).transfer(amount.0);
            }
            // refund all FTs (won't be any)
            price
        } else {
            // FT payouts
            for (receiver_id, amount) in payout_struct.payout {
                ext_contract::ft_transfer(
                    receiver_id,
                    amount,
                    None,
                    ft_token_id.clone(),
                    1,
                    GAS_FOR_FT_TRANSFER,
                );
            }
            // keep all FTs (already transferred for payouts)
            U128(0)
        }
    }

    #[private]
    pub fn add_bid(
        &mut self,
        contract_and_token_id: ContractAndTokenId,
        price: Balance,
        amount: Balance,
        ft_token_id: AccountId,
        buyer_id: AccountId,
    ) {
        assert!(
            price == 0 || amount < price,
            "Paid more {} than price {}",
            amount,
            price
        );
        // store a bid and refund any current bid lower
        let new_bid = Bid {
            owner_id: buyer_id,
            price: U128(amount),
        };
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");
        let mut bids = sale.bids.unwrap_or_default();
        let current_bid = bids.get(&ft_token_id);
        if let Some(current_bid) = current_bid {
            // refund current bid holder
            let current_price: u128 = current_bid.price.into();
            assert!(
                amount > current_price,
                "Can't pay less than or equal to current bid price: {}",
                current_price
            );
            Promise::new(current_bid.owner_id.clone()).transfer(current_bid.price.into());
            bids.insert(ft_token_id, new_bid);
        } else {
            bids.insert(ft_token_id, new_bid);
        }
        sale.bids = Some(bids);
        self.sales.insert(&contract_and_token_id, &sale);
    }

    #[payable]
    pub fn accept_offer(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        ft_token_id: AccountId,
    ) {
        assert_one_yocto();

        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        // remove bid before proceeding to process purchase
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");
        let mut bids = sale.bids.unwrap_or_default();
        let bid = bids.remove(&ft_token_id).expect("No bid");
        sale.bids = Some(bids);
        self.sales.insert(&contract_and_token_id, &sale);
        // panics at `self.internal_remove_sale` and reverts above if predecessor is not sale.owner_id
        self.process_purchase(
            sale,
            contract_id,
            token_id,
            ft_token_id.into(),
            None,
            bid.price,
            bid.price,
            bid.owner_id,
        );
    }

    /// internal

    fn refund_bids(&mut self, bids: HashMap<FungibleTokenId, Bid>) {
        for (bid_ft, bid) in bids {
            if bid_ft == self.near_ft {
                Promise::new(bid.owner_id.clone()).transfer(u128::from(bid.price));
            } else {
                ext_contract::ft_transfer(
                    bid.owner_id.clone(),
                    bid.price,
                    None,
                    bid_ft,
                    1,
                    GAS_FOR_FT_TRANSFER,
                );
            }
        }
    }
}

/// self call

#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        ft_token_id: AccountId,
        buyer_id: AccountId,
        sale: Sale,
        paid: U128,
    ) -> Promise;
}

'''
'''--- market/src/sale_views.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    /// views
    pub fn get_supply_sales(
        &self,
    ) -> U64 {
        U64(self.sales.len())
    }

    pub fn get_sales(
        &self,
        from_index: U64,
        limit: U64,
    ) -> Vec<Sale> {
        let mut tmp = vec![];
        let keys = self.sales.keys_as_vector();
        let start = u64::from(from_index);
        let end = min(start + u64::from(limit), self.sales.len());
        for i in start..end {
            tmp.push(self.sales.get(&keys.get(i).unwrap()).unwrap());
        }
        tmp
    }

    pub fn get_sales_batch(
        &self,
        sales_names: Vec<ContractAndTokenId>
    ) -> Vec<Option<Sale>> {
        let mut tmp = vec![];
        for sale_name in sales_names {
            tmp.push(self.sales.get(&sale_name));
        }
        tmp
    }
    
    pub fn get_supply_by_owner_id(
        &self,
        account_id: AccountId,
    ) -> U64 {
        let by_owner_id = self.by_owner_id.get(&account_id);
        if let Some(by_owner_id) = by_owner_id {
            U64(by_owner_id.len())
        } else {
            U64(0)
        }
    }

    pub fn get_sales_by_owner_id(
        &self,
        account_id: AccountId,
        from_index: U64,
        limit: u64,
    ) -> Vec<Sale> {
        let mut tmp = vec![];
        let by_owner_id = self.by_owner_id.get(&account_id);
        let sales = if let Some(by_owner_id) = by_owner_id {
            by_owner_id
        } else {
            return vec![];
        };
        let keys = sales.as_vector();
        let start = u64::from(from_index);
        let end = min(start + limit, sales.len());
        for i in start..end {
            tmp.push(self.sales.get(&keys.get(i).unwrap()).unwrap());
        }
        tmp
    }

    pub fn get_supply_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
    ) -> U64 {
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        if let Some(by_nft_contract_id) = by_nft_contract_id {
            U64(by_nft_contract_id.len())
        } else {
            U64(0)
        }
    }

    pub fn get_sales_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
        from_index: U64,
        limit: u64,
    ) -> Vec<Sale> {
        let mut tmp = vec![];
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        let sales = if let Some(by_nft_contract_id) = by_nft_contract_id {
            by_nft_contract_id
        } else {
            return vec![];
        };
        let keys = sales.as_vector();
        let start = u64::from(from_index);
        let end = min(start + limit, sales.len());
        for i in start..end {
            tmp.push(self.sales.get(&keys.get(i).unwrap()).unwrap());
        }
        tmp
    }

    pub fn get_supply_by_nft_token_type(
        &self,
        token_type: String,
    ) -> U64 {
        let by_nft_token_type = self.by_nft_token_type.get(&token_type);
        if let Some(by_nft_token_type) = by_nft_token_type {
            U64(by_nft_token_type.len())
        } else {
            U64(0)
        }
    }

    pub fn get_sales_by_nft_token_type(
        &self,
        token_type: String,
        from_index: U64,
        limit: u64,
    ) -> Vec<Sale> {
        let mut tmp = vec![];
        let by_nft_token_type = self.by_nft_token_type.get(&token_type);
        let sales = if let Some(by_nft_token_type) = by_nft_token_type {
            by_nft_token_type
        } else {
            return vec![];
        };
        let keys = sales.as_vector();
        let start = u64::from(from_index);
        let end = min(start + limit, sales.len());
        for i in start..end {
            tmp.push(self.sales.get(&keys.get(i).unwrap()).unwrap());
        }
        tmp
    }

    pub fn get_sale(&self, nft_contract_token: ContractAndTokenId) -> Option<Sale> {
        self.sales.get(&nft_contract_token)
    }
    
}

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1641935074168-64489245476742
'''
'''--- package.json ---
{
  "name": "nft-standard",
  "version": "0.1.0",
  "license": "MIT",
  "scripts": {
    "build-contract": "cd contract && ./build.sh && cd ..",
    "build-market": "cd market && ./build.sh && cd ..",
    "build-all": "yarn build-contract && yarn build-market",
    "patch-config": "node ./utils/patch-config.js",
    "dev-deploy": "rm -rf neardev && (near dev-deploy || exit 0) && yarn patch-config",
    "test-deploy": "yarn build-all && yarn dev-deploy && mocha",
	"fix": "eslint test/ --fix",
    "test": "mocha"
  },
  "dependencies": {
    "mocha": "^9.0.1"
  },
  "devDependencies": {
    "acquit": "^1.2.1",
    "acquit-markdown": "^0.1.0",
    "eslint": "^7.29.0",
    "near-api-js": "^0.42.0",
    "node-fetch": "^2.6.1"
  }
}

'''
'''--- test/api.test.js ---
const fs = require('fs');
const assert = require('assert');
const testUtils = require('./test-utils');
const nearAPI = require('near-api-js');
const BN = require('bn.js');
const {
	utils: { format: { parseNearAmount, formatNearAmount } },
	transactions: { deployContract, functionCall }
} = nearAPI;

const {
	gas,
	contractId,
	contractAccount,
	getAccount,
	createOrInitAccount,
	getAccountBalance,
} = testUtils;

const COPIES_TO_MINT = 2;
const APPROVALS_TO_ATTEMPT = 2;
const TOKEN_DELIMETER = ':';
const CONTRACT_TOKEN_DELIMETER = '||';

describe('NFT Series', function () {
	this.timeout(60000);

	const now = Date.now().toString();
	let token_series_title = 'dog-' + now;
	let token_id;

	/// users
	const aliceId = 'alice-' + now + '.' + contractId;
	const bobId = 'bob-' + now + '.' + contractId;
	const marketId = 'market.' + contractId;
	let alice, bob, market;
	it('should create user & contract accounts', async function () {
		alice = await getAccount(aliceId);
		bob = await getAccount(bobId);
		console.log('\n\n created:', aliceId, '\n\n');

		market = await createOrInitAccount(marketId);
		const marketState = await market.state();
		if (marketState.code_hash === '11111111111111111111111111111111') {

			const marketBytes = fs.readFileSync('./out/market.wasm');
			console.log('\n\n deploying market contractBytes:', marketBytes.length, '\n\n');
			const newMarketArgs = {
				owner_id: contractId,
			};
			const actions = [
				deployContract(marketBytes),
				functionCall('new', newMarketArgs, gas)
			];
			await market.signAndSendTransaction(marketId, actions);
			console.log('\n\n created:', marketId, '\n\n');
		}
	});

	it('should be deployed', async function () {
		const state = await contractAccount.state();
		try {
			await contractAccount.functionCall({
				contractId,
				methodName: 'new_default_meta',
				args: {
					owner_id: contractId
				},
				gas
			});
		} catch (e) {
			if (!/contract has already been initialized/.test(e.toString())) {
				console.warn(e);
			}
		}

		assert.notStrictEqual(state.code_hash, '11111111111111111111111111111111');
	});

	it('should allow someone to create a series', async function () {
		await contractAccount.functionCall({
			contractId,
			methodName: 'nft_create_series',
			args: {
				metadata: {
					title: token_series_title,
					media: 'https://placedog.net/500',
					copies: COPIES_TO_MINT * 2,
				},
				royalty: {
					[bobId]: 1000,
				}
			},
			gas,
			attachedDeposit: parseNearAmount('0.1')
		});

		const token_series = await contractAccount.viewFunction(
			contractId,
			'nft_get_series_json',
			{
				token_series_title
			}
		);

		assert.strictEqual(token_series.owner_id, contractId);
		assert.strictEqual(token_series.metadata.copies, COPIES_TO_MINT * 2);
		console.log(token_series.metadata.copies)
		assert.strictEqual(token_series.royalty[bobId], 1000);
	});

	it('should NOT allow a NON owner to mint copies', async function () {
		try {
			await alice.functionCall({
				contractId,
				methodName: 'nft_mint_series',
				args: {
					token_series_title,
					receiver_id: contractId
				},
				gas,
				attachedDeposit: parseNearAmount('0.1')
			});
			assert(false);
		} catch(e) {
			assert(true);
		}
	});

	it('should allow the owner to mint a token of a particular series', async function () {

		// const stateBefore = await (await getAccount(contractId)).state();
		// console.log('stateBefore', stateBefore)
		const contractBalanceBefore = (await getAccountBalance(contractId)).available;

		for (let i = 0; i < COPIES_TO_MINT; i++) {
			await contractAccount.functionCall({
				contractId,
				methodName: 'nft_mint_series',
				args: {
					token_series_title,
					receiver_id: contractId
				},
				gas,
				attachedDeposit: parseNearAmount('0.1')
			});
		}
		
		const contractBalanceAfter = (await getAccountBalance(contractId)).available;
		console.log('\n\n\n Contract Balance Available', formatNearAmount(new BN(contractBalanceBefore).sub(new BN(contractBalanceAfter)).toString(), 6));

		// const stateAfter = await (await getAccount(contractId)).state();
		// console.log('stateAfter', stateAfter)

		const supply_for_series = await contractAccount.viewFunction(
			contractId,
			'nft_supply_for_series',
			{
				token_series_title
			}
		);
		assert.strictEqual(parseInt(supply_for_series, 10), COPIES_TO_MINT);

		const tokens = await contractAccount.viewFunction(
			contractId,
			'nft_tokens_by_series',
			{
				token_series_title
			}
		);
		const [TOKEN_DELIMETER, TITLE_DELIMETER, EDITION_DELIMETER] = await contractAccount.viewFunction(
			contractId,
			'nft_get_series_format',
		);
		const { token_id: _token_id, owner_id, metadata: { title, copies } } = tokens[tokens.length - 1];
		assert.strictEqual(owner_id, contractId);
		token_id = _token_id;
		const formattedTitle = `${token_series_title}${TITLE_DELIMETER}${token_id.split(TOKEN_DELIMETER)[1]}${EDITION_DELIMETER}${copies}`;
		assert.strictEqual(title, formattedTitle);
	});

	it('should allow the owner cap the copies to whatever is already minted', async function () {
		await contractAccount.functionCall({
			contractId,
			methodName: 'cap_copies',
			args: {
				token_series_title,
			},
			gas,
		});

		const token_series = await contractAccount.viewFunction(
			contractId,
			'nft_get_series_json',
			{
				token_series_title
			}
		);

		assert.strictEqual(token_series.metadata.copies, COPIES_TO_MINT);
	});

	it('should NOT allow the owner to mint more than copies', async function () {
		try {
			await contractAccount.functionCall({
				contractId,
				methodName: 'nft_mint_series',
				args: {
					token_series_title,
					receiver_id: contractId
				},
				gas,
				attachedDeposit: parseNearAmount('0.1')
			});
			assert(false);
		} catch(e) {
			assert(true);
		}
	});

	it('should allow the owner to transfer the nft', async function () {
		console.log('\n\n\ token_id', token_id);

		await contractAccount.functionCall({
			contractId: contractId,
			methodName: 'nft_transfer',
			args: {
				receiver_id: aliceId,
				token_id,
			},
			gas,
			attachedDeposit: '1'
		});

		const { owner_id } = await contractAccount.viewFunction(
			contractId,
			'nft_token',
			{ token_id }
		);
		assert.strictEqual(owner_id, aliceId);
	});

	it('should allow alice to list the token for sale', async function () {
		let sale_args = {
			sale_conditions: {
				near: parseNearAmount('1')
			},
			token_type: token_id.split(TOKEN_DELIMETER)[0],
			is_auction: false,
		};

		for (let i = 0; i < APPROVALS_TO_ATTEMPT; i++) {
			try {
				await alice.functionCall({
					contractId: contractId,
					methodName: 'nft_approve',
					args: {
						token_id,
						account_id: marketId,
						msg: JSON.stringify(sale_args)
					},
					gas,
					attachedDeposit: parseNearAmount('0.01')
				});
			} catch(e) {
				// swallow and keep iterating
				console.warn(e)
			}
		}
		
	});

	it('should allow someone to buy the token and should have paid alice a royalty', async function () {
		const bobBalanceBefore = (await getAccountBalance(bobId)).total;

		await contractAccount.functionCall({
			contractId: marketId,
			methodName: 'offer',
			args: {
				nft_contract_id: contractId,
				token_id: token_id,
			},
			gas,
			attachedDeposit: parseNearAmount('1')
		});

		const bobBalanceAfter = (await getAccountBalance(bobId)).total;
		
		assert.strictEqual(new BN(bobBalanceAfter).sub(new BN(bobBalanceBefore)).toString(), parseNearAmount('0.1'));
		const { owner_id } = await contractAccount.viewFunction(
			contractId,
			'nft_token',
			{ token_id }
		);
		console.log(owner_id);
		assert.strictEqual(owner_id, contractId);
	});
});

'''
'''--- test/config.js ---
const contractName = 'dev-1641935074168-64489245476742';

module.exports = function getConfig(network = 'mainnet') {
	let config = {
		networkId: "testnet",
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
	};

	switch (network) {
	case 'testnet':
		config = {
			explorerUrl: "https://explorer.testnet.near.org",
			...config,
			GAS: "200000000000000",
			gas: "200000000000000",
			DEFAULT_NEW_ACCOUNT_AMOUNT: "2",
			DEFAULT_NEW_CONTRACT_AMOUNT: "5",
			GUESTS_ACCOUNT_SECRET:
			"7UVfzoKZL4WZGF98C3Ue7tmmA6QamHCiB1Wd5pkxVPAc7j6jf3HXz5Y9cR93Y68BfGDtMLQ9Q29Njw5ZtzGhPxv",
	
			contractMethods: {
				changeMethods: [
					"new",
				],
				viewMethods: [],
			},
				
			contractId: contractName,
			marketId: "market." + contractName,
			fungibleId: "ft.hhft.testnet",
		};
		break;
	case 'mainnet':
		config = {
			...config,
			networkId: "mainnet",
			nodeUrl: "https://rpc.mainnet.near.org",
			walletUrl: "https://wallet.near.org",
			helperUrl: "https://helper.mainnet.near.org",
			contractName: "uhhmnft.near",
			contractId: "uhhmnft.near",
			marketId: "market.uhhmnft.near",
			fungibleId: "ft.hip-hop.near",
			ownerId: 'owner.uhhmnft.near',
		};
		break;
	}

	return config;
};

'''
'''--- test/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("./config");
const { nodeUrl, networkId, contractName, contractMethods } = getConfig('testnet');

const {
	keyStores: { InMemoryKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

let credentials;
try {
	credentials = JSON.parse(
		fs.readFileSync(
			`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
		)
	);
} catch(e) {
	console.warn('credentials not found, looking in /neardev');
	credentials = JSON.parse(
		fs.readFileSync(
			`./neardev/${networkId}/${contractName}.json`
		)
	);
}

const keyStore = new InMemoryKeyStore();
keyStore.setKey(
	networkId,
	contractName,
	KeyPair.fromString(credentials.private_key)
);
const near = new Near({
	networkId,
	nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) =>
	contractAccount.addKey(
		publicKey,
		contractName,
		contractMethods,
		parseNearAmount("0.1")
	);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	credentials,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
	contractMethods,
};

'''
'''--- test/test-utils.js ---
const fs = require("fs");
const BN = require('bn.js');
const fetch = require('node-fetch');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount } } } = nearAPI;
const { near, credentials, connection, keyStore, contract, contractAccount } = require('./near-utils');
const getConfig = require('./config');
const {
	networkId, contractName, contractMethods, gas,
	DEFAULT_NEW_ACCOUNT_AMOUNT, 
	DEFAULT_NEW_CONTRACT_AMOUNT,
	GUESTS_ACCOUNT_SECRET,
} = getConfig('testnet');

const TEST_HOST = 'http://localhost:3000';
/// exports
async function initContract() {
	/// try to call new on contract, swallow e if already initialized
	try {
		const newArgs = {
			owner_id: contractAccount.accountId,
			"metadata": {
				"spec": "nft-1",
				"name": "NFT Series",
				"symbol": "NFT"
			},
			supply_cap_by_type: {
				test: '1000000',
			},
		};
		await contract.new(newArgs);
	} catch (e) {
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}
const getAccountBalance = async (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();

const initAccount = async(accountId, secret) => {
	account = new nearAPI.Account(connection, accountId);
	const newKeyPair = KeyPair.fromString(secret);
	keyStore.setKey(networkId, accountId, newKeyPair);
	return account;
};

const createOrInitAccount = async(accountId, secret = GUESTS_ACCOUNT_SECRET, amount = DEFAULT_NEW_CONTRACT_AMOUNT) => {
	let account;
	try {
		account = await createAccount(accountId, amount, secret);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = initAccount(accountId, secret);
	}
	return account;
};

async function getAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	accountId = accountId || generateUniqueSubAccount();
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount, secret);
};

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

const createAccessKeyAccount = (key) => {
	connection.signer.keyStore.setKey(networkId, contractName, key);
	return new Account(connection, contractName);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => {
		// console.log(res)
		return res.json();
	});
};

const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({ ...data })
	}).then((res) => {
		console.log(res);
		return res.json();
	});
};

function generateUniqueSubAccount() {
	return `t${Date.now()}.${contractName}`;
}

/// internal
async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

const loadCredentials = (accountId) => {
	const credPath = `./neardev/${networkId}/${accountId}.json`;
	console.log(
		"Loading Credentials:\n",
		credPath
	);

	let credentials;
	try {
		credentials = JSON.parse(
			fs.readFileSync(
				credPath
			)
		);
	} catch(e) {
		console.warn('credentials not in /neardev');
		/// attempt to load backup creds from local machine
		credentials = JSON.parse(
			fs.readFileSync(
				`${process.env.HOME}/.near-credentials/${networkId}/${accountId}.json`
			)
		);
	}

	return credentials;
};

module.exports = { 
	TEST_HOST,
	near,
	gas,
	connection,
	credentials,
	keyStore,
	getContract,
	getAccountBalance,
	contract,
	contractName,
	contractId: contractName,
	contractMethods,
	contractAccount,
	initAccount,
	createOrInitAccount,
	createAccessKeyAccount,
	initContract, getAccount, postSignedJson, postJson,
	loadCredentials,
};

'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './test/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''