*GitHub Repository "Graate-Org/NEAR-Block-Dice--AssemblyScript"*

'''--- README.md ---
# Block-Dice

This repository includes a complete Smart Contract for a dice game built on the NEAR blockchain. This is the first variant of the smart contract with a fault.

- The error in the the smart contract is that you can see what other players rolled before a game has ended, this gives those joining late an edge as they can make a decision based on what other players rolled. This will be corrected in the second variant.

For additional informtion on the smart contract methods view [here](src/block-dice/)

```

It's a simple contract demonstrating how to build a dice game on the NEAR blockchain using AssemblyScript:
- Why you should avoid leaks and have data restrictions on your smart contracts
- How to implement random number generation and id checks on the NEAR blockchain

## Usage

### Getting started

1. clone this repo to a local folder
2. run `yarn`
3. run `yarn test:unit`

### Top-level `yarn` commands

- run `yarn test` to run all tests
- run `yarn build` to quickly verify build status
- run `yarn clean` to clean up build folder

### Other documentation

- Sample contract and test documentation
  - see `/src/block-dice/README` for contract interface
  - see `/src/block-dice/__tests__/README` for Sample unit testing details
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/block-dice"
  ]
}

'''
'''--- package.json ---
{
  "name": "block-dice",
  "version": "0.0.1",
  "description": "This repository includes a complete Smart Contract for a dice game built on the NEAR blockchain. This is the first variant of the smart contract with a fault.",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "deploy": "bash ./scripts/deploy.sh"
  },
  "keywords": [],
  "author": "support@graate.org",
  "license": "ISC",
  "devDependencies": {},
  "dependencies": {
    "near-sdk-as": "^3.2.0"
  }
}

'''
'''--- scripts/README.md ---
## Deploying contract through your terminal

The `deploy.sh` file within the scripts folder demonstrates a simple way of deploying a smart contract to the testnet.

```sh
[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"
```
The above commands searches the environment variables for `$CONTRACT` and `$OWNER` variables.

```sh
echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER
```
These commands deletes the two environment variable , `$CONTRACT` and `$OWNER` if any is found in the codebase, resolving the conflict of having two set of `$CONTRACT` and `$OWNER` variables.

```sh
echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev
```
The above shell commands deletes the `./neardev` folder. This folder contains details about the smart contract once deploy, expample is the `CONTRACT_NAME` found in the `dev-account.env` file. This way we can always generate a new `./neardev` folder on every deploy.

```sh
echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release
```
These commands compiles/builds the AssemlyScript code down to WebAssembly code. This action generates a file with `.wasm` extension that contains the WebAssembly code.

```sh
echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ../build/release/block-dice.wasm
```
These commands deploys/redeploys the resulting WebAssembly file from the previous action, `yarn build:release`. This file is deployed to the Near blockchain.

```sh
echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo
echo
```

These final commands prompts the developer to export the exported interfaces, making it available for consumption on the local machine.
'''
'''--- scripts/claim_winning.sh ---

# export function createdNewGame(): GameID
near call $CONTRACT claimWinnings '{"gameId": "BD-689191485"}' --account_id $OWNER

exit 0
'''
'''--- scripts/create_new_game.sh ---
#!/usr/bin/env bash

# export function createdNewGame(): GameID
near call $CONTRACT createNewGame --account_id $OWNER --amount 0.5

exit 0
'''
'''--- scripts/deploy.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER

echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release

echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./build/release/block-dice.wasm

echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo
echo

exit 0

'''
'''--- scripts/get_active_games.sh ---
# export function getActiveGames()
near call $CONTRACT getActiveGames --account_id $OWNER

exit 
'''
'''--- scripts/get_completed_games.sh ---
# export function getCompletedGames()
near call $CONTRACT getCompletedGames --account_id $OWNER

exit 0
'''
'''--- scripts/get_created_games.sh ---
# export function getCreatedGames()
near call $CONTRACT getCreatedGames --account_id $OWNER

exit 0
'''
'''--- scripts/get_game_winners.sh ---
# export function getWinners(): GameID
near call $CONTRACT getWinners '{"gameId": "BD-689191485"}' --account_id $OWNER

exit 0
'''
'''--- scripts/get_profile_details.sh ---
# export function getProfileDetails(): GameID
near view $CONTRACT getProfileDetails '{"account": "melvinmanni09.testnet"}'

exit 0
'''
'''--- scripts/join_game.sh ---
# export function joinGame(): GameID
near call $CONTRACT joinGame --account_id $PLAYER '{"gameId": "BD-689191485"}' --amount 0.5

exit 0
'''
'''--- scripts/roll_dice.sh ---
# export function rollDIce(): GameID
near call $CONTRACT rollDice --account_id $OWNER '{"gameId": "BD-2374400498"}'

exit 0
'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/block-dice/README.md ---
![Near, Inc. logo](https://near.org/wp-content/themes/near-19/assets/img/logo.svg?t=1553011311)

## Design

### Interface

```ts
function createNewGame
```
- "Change" function (ie. a function that alters contract state)
- Creates a new game and returns the unique id for that game

```ts
function joinGame
```
- "Change" function (ie. a function that alters contract state)
- Recieves a game's unique id as parameter
- Allows the account initiating the contract call tp join the game with id passed in

```ts
function rollDice
```
- "Change" function (ie. a function that alters contract state)
- Recieves a game's unique id as parameter
- Allows the account initiating the contract call to roll dice for the game 
- Once the first dice is rolled in a game, it becomes active
- Each active game lasts for 30 minutes on being active 

```ts
function getWinners
```
- "Change" function
- Recieves a game's unique id as parameter
- Returns an array with the account id of the winners for the game id passed in

```ts
function claimWinnings
```
- "Change" function (ie. a function that alters contract state)
- Recieves a game's unique id as parameter
- Allows the account initiating the contract call to claim winning for the game 
- Panics if account has already claimed winnings or is not a winner
- Returns true if winnings was successfully claimed

```ts
function getGameDetails
```
- "View" function
- Recieves a game's unique id as parameter
- Returns details of the game id passed in

```ts
function getPlayersDetails
```
- "View" function
- Recieves a game's unique id as parameter
- Returns details of the players for the game id passed in

```ts
function getProfileDetails
```
- "View" function
- Returns details of the profile of the user calling the contract

```ts
function getActiveGames
```
- "Change" function
- Returns active games

```ts
function getCompletedGames
```
- "Change" function
- Returns completed games

```ts
function getCreatedGames
```
- "Change" function
- Returns created games

'''
'''--- src/block-dice/__tests__/README.md ---
## Unit tests

Unit tests can be run from the top level folder using the following command:

```
yarn test:unit
```

### Tests for Contract in `index.unit.spec.ts`

```
[Describe]: Checks for creating account

 [Success]: ✔ creates a new game
 [Success]: ✔ creates throws when fee is not attached

[Describe]: Checks for joining a game

 [Success]: ✔ allows a new user join a game
 [Success]: ✔ can't when join when fee is zero
 [Success]: ✔ can't when join when completed

[Describe]: Rolling dice

 [Success]: ✔ rolls the dice
 [Success]: ✔ can't roll the dice twice

[Describe]: Claiming winning error catch

 [Success]: ✔ verifies if game has ended before win is claimed

[Describe]: Claiming winning

 [Success]: ✔ claims win if among winners
 [Success]: ✔ verifies winners
 [Success]: ✔ cant claims win if not among winners
 [Success]: ✔ cannot claim winnings twice

    [File]: src/block-dice/__tests__/index.unit.spec.ts
  [Groups]: 6 pass, 6 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 12 pass,  0 fail, 12 total
    [Time]: 270.067ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: ✔ PASS
   [Files]: 1 total
  [Groups]: 6 count, 6 pass
   [Tests]: 12 pass, 0 fail, 12 total
    [Time]: 16716.679ms
✨  Done in 18.13s.
```

'''
'''--- src/block-dice/__tests__/index.unit.spec.ts ---
import { VMContext } from "near-mock-vm";
import { context, u128 } from "near-sdk-core";
import { claimWinnings, createNewGame, getPlayersDetails, getWinners, joinGame, rollDice } from "../assembly";
import { GameStatus, Player } from "../assembly/model";
import { games, players, profiles } from "../assembly/storage";
import { FEE } from "../utils";

const creator = "melvin.testnet";
const player = "fortune.testnet";
const player2 = "yemi.testnet";
let testGameId: string;

describe("Checks for creating account", () => {
  beforeEach(() => {
    VMContext.setAttached_deposit(FEE);
    VMContext.setSigner_account_id(creator);
  });

  it("creates a new game", () => {
    const gameId = createNewGame();

    expect(games.length).toBeGreaterThan(0, "A new game is expected to be added to the array");

    expect(games[0].id).toStrictEqual(gameId, "The game id at index 0 is expected to match");
  });

  it("creates throws when fee is not attached", () => {
    VMContext.setAttached_deposit(u128.Zero);
    function createGameWithZeroDeposit(): void {
      createNewGame();
    }

    expect(createGameWithZeroDeposit).toThrow(
      "Attached deposit is expected to be equal to: " + FEE.toString() + " Yocto"
    );
  });
});

describe("Checks for joining a game", () => {
  beforeEach(() => {
    VMContext.setAttached_deposit(FEE);
    VMContext.setSigner_account_id(creator);
    testGameId = createNewGame();
  });

  it("allows a new user join a game", () => {
    VMContext.setSigner_account_id(player);
    joinGame(testGameId);
    const gamePlayers = players.get(testGameId) as Player[];
    expect(gamePlayers.length).toStrictEqual(
      2,
      "Expect players to be atleast 2, the creator and the player that just joined"
    );

    expect(gamePlayers[1].playerId).toStrictEqual(player, "The playerId joined should match " + player);
  });

  it("can't when join when fee is zero", () => {
    VMContext.setSigner_account_id(player2);
    VMContext.setAttached_deposit(u128.Zero);

    function joinAGame(): void {
      joinGame(testGameId);
    }
    expect(joinAGame).toThrow("expect to only be able to join active or created game");
  });

  it("can't when join when completed", () => {
    VMContext.setSigner_account_id(player2);
    const completedGame = games[0];
    completedGame.status = GameStatus.Completed;

    games.replace(0, completedGame);

    function joinAGame(): void {
      joinGame(testGameId);
    }
    expect(joinAGame).toThrow("expect to only be able to join active or created game");
  });
});

describe("Rolling dice", () => {
  beforeEach(() => {
    VMContext.setAttached_deposit(FEE);
    VMContext.setSigner_account_id(creator);
    testGameId = createNewGame();
  });

  it("rolls the dice", () => {
    const dices = rollDice(testGameId);
    const player = getPlayersDetails(testGameId)[0];
    expect(dices[0]).toStrictEqual(player.roll1, "Expect dice at index '0' to equal players roll1");
    expect(dices[1]).toStrictEqual(player.roll2, "Expect dice at index '0' to equal players roll2");
  });

  it("can't roll the dice twice", () => {
    rollDice(testGameId);
    function rollsAgain(): void {
      rollDice(testGameId);
    }
    expect(rollsAgain).toThrow("Expect to throw on rolling dice a second time");
  });
});

describe("Claiming winning error catch", () => {
  beforeEach(() => {
    VMContext.setAttached_deposit(FEE);
    VMContext.setSigner_account_id(creator);
    testGameId = createNewGame();
    rollDice(testGameId);
  });

  it("verifies if game has ended before win is claimed", () => {
    function claimBeforeEnd(): void {
      claimWinnings(testGameId);
    }
    expect(claimBeforeEnd).toThrow("Game is expected to end before claiming winning");
  });
});

describe("Claiming winning", () => {
  beforeEach(() => {
    VMContext.setAttached_deposit(FEE);
    VMContext.setSigner_account_id(creator);
    testGameId = createNewGame();
    rollDice(testGameId);
    const endedGame = games[0];
    endedGame.ended = context.blockTimestamp;
    games.replace(0, endedGame);
  });

  it("claims win if among winners", () => {
    expect(claimWinnings(testGameId)).toBeTruthy("Winnings is claimed if it is truthy");
  });

  it("verifies winners", () => {
    expect(getWinners(testGameId)).toStrictEqual([creator], "expect to verify accurate winners");
  });

  it("cant claims win if not among winners", () => {
    VMContext.setSigner_account_id(player2);
    function claim(): void {
      claimWinnings(testGameId);
    }
    expect(claim).toThrow("expect only winners to claim winning");
  });

  it("cannot claim winnings twice", () => {
    claimWinnings(testGameId);
    function claimAgain(): void {
      claimWinnings(creator);
    }
    expect(claimAgain).toThrow("expect winnings to be claimed only once");
  });
});

'''
'''--- src/block-dice/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/block-dice/assembly/index.ts ---
import { Context, ContractPromiseBatch, logging, RNG, u128 } from "near-sdk-core";
import { AccountID, FEE, GameID, Profile } from "../utils";
import { Game, GameStatus, Player, ClaimedWin, GameReturnData } from "./model";
import { games, players, profiles } from "./storage";

/**
 *
 * @returns @GameID
 * creates a new game and return the game id
 * Needs minimun attached deposit to be 0.2 NEAR as fee
 */
export function createNewGame(): GameID {
  const sender = Context.sender;
  verifyGameFee(Context.attachedDeposit);
  const game = new Game();
  const gameId = game.id;

  //   increments the players count
  game.addNewPlayer();

  logging.log("Game: " + gameId + " created");

  //   sets storage data for new game
  games.push(game);

  addGameToProfile(gameId, sender);
  addToPlayersList(gameId, sender);

  return gameId;
}

/**
 *
 * @param gameId
 * @returns success message
 * Allows other users to join a  game using the gameId
 */

export function joinGame(gameId: GameID): string {
  const sender = Context.sender;
  verifyGameId(gameId);
  verifyGameFee(Context.attachedDeposit);
  for (let index = 0; index < games.length; index++) {
    if (games[index].id == gameId) {
      const game: Game = games[index];
      assert(game.canJoinGame(), "Cannot join, this game have already ended!");

      game.addNewPlayer();
      addGameToProfile(gameId, sender);
      addToPlayersList(gameId, sender);

      games.replace(index, game);
    }
  }

  return `You have joined game:  + ${gameId}`;
}

/**
 *
 * @param gameId
 * @returns an arraay of the value of dice rolled
 */
export function rollDice(gameId: GameID): Array<u32> {
  let roll1: u32;
  let roll2: u32;
  const sender = Context.sender;
  verifyGameId(gameId);

  for (let index = 0; index < games.length; index++) {
    if (games[index].id == gameId) {
      const game: Game = games[index];
      assert(game.canRollInGame(), "This game has ended!");

      if (game.status == GameStatus.Created) {
        const time = Context.blockTimestamp;
        game.status = GameStatus.Active;
        game.started = time;
        game.ended = time + 1800000000000;
        games.replace(index, game);
      }
    }
  }

  const gamePlayers = players.get(gameId) as Player[];

  const dice1 = new RNG<u32>(1, 5);
  const dice2 = new RNG<u32>(1, 5);
  roll1 = dice1.next() + 1;
  roll2 = dice2.next() + 1;

  for (let index = 0; index < gamePlayers.length; index++) {
    if (sender == gamePlayers[index].playerId) {
      const player = gamePlayers[index];
      assert(player.timeRolled <= 0, "You have already rolled");
      player.timeRolled = Context.blockTimestamp;
      player.roll1 = roll1;
      player.roll2 = roll2;

      // assign the mutated player to the game players array
      gamePlayers[index] = player;
      players.set(gameId, gamePlayers);
    }
  }

  return [roll1, roll2];
}

/**
 *
 * @param gameId
 * @returns an array of winners
 * @throws if game has not ended
 */
export function getWinners(gameId: GameID): Array<string> {
  verifyGameId(gameId);
  for (let index = 0; index < games.length; index++) {
    const game: Game = games[index];
    if (game.id == gameId) {
      if (game.status != GameStatus.Completed) {
        if (game.status == GameStatus.Active) {
          assert(game.ended <= Context.blockTimestamp, "Game is active but not ended yet!");
          game.status = GameStatus.Completed;
          games.replace(index, game);
        } else {
          assert(false, "Game is started but not completed");
        }
      }
    }
  }
  const gamePlayers = players.get(gameId) as Player[];
  const winners: string[] = [];
  let maxScore: u32 = 0;

  for (let index = 0; index < gamePlayers.length; index++) {
    const diceCount = gamePlayers[index].sumDiceRoll();
    maxScore = max(diceCount, maxScore);
  }

  for (let index = 0; index < gamePlayers.length; index++) {
    const player = gamePlayers[index];
    const diceCount = gamePlayers[index].sumDiceRoll();
    if (diceCount == maxScore) {
      winners.push(player.playerId);
    }
  }

  return winners;
}

/**
 *
 * @param gameId
 * @returns true if win is  claimed
 * @throws if you are not a winner
 * calls @function getWinners to access winners array
 * calculates the amount each winner gets from the pool
 */

export function claimWinnings(gameId: GameID): bool {
  const sender = Context.sender;
  let pool: u128 = u128.Zero;

  verifyGameId(gameId);
  const winners = getWinners(gameId);
  const gamePlayers = players.get(gameId) as Player[];

  for (let index = 0; index < games.length; index++) {
    if (games[index].id == gameId) {
      pool = games[index].prize;
    }
  }

  assert(winners.includes(sender), "You did not win for this game :(");

  for (let index = 0; index < gamePlayers.length; index++) {
    if (gamePlayers[index].playerId == sender) {
      const player = gamePlayers[index];
      assert(player.claimedWin != ClaimedWin.Claimed, "You have already claimed prize!");
      const prize = u128.div(pool, u128.from(winners.length));

      const transfer_win = ContractPromiseBatch.create(sender);
      transfer_win.transfer(prize);
      player.claimedWin = ClaimedWin.Claimed;
      gamePlayers[index] = player;

      players.set(gameId, gamePlayers);
    }
  }

  return true;
}

/**
 *
 * GETTER Functions
 */

/**
 *
 * @param gameId
 * @returns an array of all games
 */

export function getGameDetails(gameId: GameID): Game[] {
  verifyGameId(gameId);
  let result: Game[] = [];
  //   const gamePlayers = players.get(gameId) as Player[];

  for (let index = 0; index < games.length; index++) {
    if (games[index].id == gameId) {
      result.push(games[index]);
    }
  }

  return result;
}

/**
 *
 * @param gameId
 * @returns an array of players
 */

export function getPlayersDetails(gameId: GameID): Player[] {
  verifyGameId(gameId);

  const getGamePlayers = players.get(gameId) as Player[];

  return getGamePlayers;
}

/**
 *
 * @returns Profile/user profile with array of games
 */
export function getProfileDetails(account: AccountID): Profile {
  const sender = account;

  if (profiles.contains(sender)) {
    return profiles.get(sender) as Profile;
  }
  return [];
}

/**
 *
 * @param page
 * @returns GameReturnData
 * For additional information check
 * @function getGameType
 */

export function getActiveGames(): GameReturnData {
  return getGameType(GameStatus.Active);
}

export function getCompletedGames(): GameReturnData {
  return getGameType(GameStatus.Completed);
}

export function getCreatedGames(): GameReturnData {
  return getGameType(GameStatus.Created);
}

/**
 *
 * HELPER FUNCTIONS FOR MAIN DAPP
 */

/**
 * @param deposit
 * Verify that deposit attached is equal to or greater than the fee
 */
function verifyGameFee(deposit: u128): void {
  assert(deposit >= FEE, "You need to have at least 0.5 NEAR tokens to continue");
}

/**
 * @param gameId
 * updates the game id with
 */

function addGameToProfile(gameId: GameID, sender: AccountID): void {
  let profile: Profile = [];
  if (profiles.contains(sender)) {
    profile = profiles.get(sender) as Profile;
  }

  for (let index = 0; index < profile.length; index++) {
    assert(profile[index] != gameId, "Game id already added to profile");
  }

  profile.push(gameId);

  //   set to storage
  profiles.set(sender, profile);
}

/**
 * @param gameId
 * Adds a new player to a game
 */

/**
 *
 * @param gameId
 * @param playerId
 * adds the playerid passed to the list of players for a game
 */
function addToPlayersList(gameId: GameID, playerId: AccountID): void {
  const player = new Player(gameId, playerId);
  let newPlayers: Player[] = [];
  if (players.contains(gameId)) {
    newPlayers = players.get(gameId) as Player[];
  }

  newPlayers.push(player);

  //   set to storage
  players.set(gameId, newPlayers);
}

/**
 *
 * @param gameId
 * checks if game ID exist
 * panics if game ID does not exist
 */

function verifyGameId(gameId: GameID): void {
  assert(players.contains(gameId), "This game ID does not exist");
}

/**
 *
 * @param _page
 * @param type
 * @returns GameReturnData
 * helper function for returning games based on status
 * used by:
 *@function getActiveGames
 *@function getCompletedGames
 *@function getCreatedGames
 */
export function getGameType(type: GameStatus): GameReturnData {
  const gameType: Game[] = [];

  for (let index = 0; index < games.length; index++) {
    const game: Game = games[index];
    if (game.status == GameStatus.Active) {
      if (Context.blockTimestamp > game.ended) {
        game.status = GameStatus.Completed;
        games.replace(index, game);
      }
    }

    if (game.status == type) {
      gameType.push(game);
    }
  }

  const total: u32 = gameType.length;

  const result = new GameReturnData(gameType, total);

  return result;
}

'''
'''--- src/block-dice/assembly/model.ts ---
import { context, RNG, u128 } from "near-sdk-as";
import { AccountID, FEE, GameID, Timestamp } from "../utils";
import { players } from "./storage";

export enum GameStatus {
  Created = 0,
  Active,
  Completed,
}

export enum ClaimedWin {
  No = 0,
  Claimed,
}

@nearBindgen
export class Game {
  id: GameID;
  players: u32;
  prize: u128;
  started: Timestamp;
  ended: Timestamp;
  createdBy: string;
  createdAt: Timestamp;
  status: GameStatus;

  constructor() {
    this.createdBy = context.sender;
    this.players = 0;
    this.createdAt = context.blockTimestamp;
    this.status = GameStatus.Created;
    this.id = this.generateGameId();
  }

  //   Static method
  static getGameRules(): string {
    return "You need to create or join a game with a 0.05 NEAR fee \n A game starts when the first player rolls \n Each game lasts 30 minutes";
  }

  addNewPlayer(): void {
    this.players += 1;
    this.prize = u128.add(this.prize, FEE);
  }

  /**
   * Generates a new id and checks if ID already exists
   * if ID exists a new ID will be generated by calling the function again
   * @returns Game ID
   */
  private generateGameId(): GameID {
    const roll = new RNG<u32>(1, u32.MAX_VALUE);
    const id = "BD-" + roll.next().toString();
    if (players.contains(id)) {
      this.generateGameId();
    }

    return id;
  }

  canJoinGame(): bool {
    if (this.status !== GameStatus.Completed) {
      if (this.status === GameStatus.Active && this.ended >= context.blockTimestamp) {
        return true;
      }
      return true;
    }
    return false;
  }

  canRollInGame(): bool {
    if (this.status !== GameStatus.Completed) {
      if (this.status === GameStatus.Active && this.ended >= context.blockTimestamp) {
        return true;
      }
      return true;
    }
    return false;
  }
}

@nearBindgen
export class Player {
  roll1: u32;
  roll2: u32;
  timeJoined: Timestamp;
  timeRolled: Timestamp;
  claimedWin: ClaimedWin;
  constructor(public gameId: GameID, public playerId: AccountID) {
    this.timeJoined = context.blockTimestamp;
    this.claimedWin = ClaimedWin.No;
  }

  sumDiceRoll(): u32 {
    return this.roll1 + this.roll2;
  }
}

@nearBindgen
export class GameReturnData {
  constructor(
    public data: Game[],
    public total: u32,
  ) {}
}

'''
'''--- src/block-dice/assembly/storage.ts ---
import { PersistentMap, PersistentVector } from "near-sdk-core";
import { AccountID, GameID, Profile } from "../utils";
import { Game, Player } from "./model";

export const profiles = new PersistentMap<AccountID, Profile>("profiles");
export const games = new PersistentVector<Game>("games");
export const players = new PersistentMap<GameID, Player[]>("players");

'''
'''--- src/block-dice/utils.ts ---
import { u128 } from "near-sdk-core";

export type Timestamp = u64;

export type AccountID = string;

export type GameID = string;

export type Profile = string[];

export const FEE = u128.from("200000000000000000000000");

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''