*GitHub Repository "NEARFoundation/transaction-tracking-app"*

'''--- .eslintrc.json ---
{
  "extends": "next/core-web-vitals"
}

'''
'''--- README.md ---
# Intro

This is a temporary app while https://github.com/NEARFoundation/tx-tracking-app is being improved.

# Framework

This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

# Deployments

It automatically deploys each commit of the `main` branch to https://tta-basic.onrender.com/

See https://dashboard.render.com/

## Getting Started

`cp .env.development.local.example .env.development.local`

Then edit the values.

Run the development server:

```bash
npm run dev
# or
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `pages/index.tsx`. The page auto-updates as you edit the file.

[API routes](https://nextjs.org/docs/api-routes/introduction) can be accessed on [http://localhost:3000/api/hello](http://localhost:3000/api/hello). This endpoint can be edited in `pages/api/hello.ts`.

The `pages/api` directory is mapped to `/api/*`. Files in this directory are treated as [API routes](https://nextjs.org/docs/api-routes/introduction) instead of React pages.

'''
'''--- db/AvailableTokens.ts ---
export enum AvailableTokens {
  DAI = '6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near',
  USDC = 'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near',
  USDT = 'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near',
}

'''
'''--- db/export.ts ---
// @ts-ignore
import json2csv from 'csvjson-json2csv'; // https://www.npmjs.com/package/csvjson-json2csv
import Row from './row';

export default function jsonToCsv(object: Row[]): string {
  const csv = json2csv(object, { output_csvjson_variant: false, flatten: false, separator: ',' });
  return csv;
}

'''
'''--- db/queries/all.ts ---
export const ALL_OUTGOING = `
SELECT *
FROM TRANSACTIONS T
         LEFT JOIN RECEIPTS R ON (T.CONVERTED_INTO_RECEIPT_ID = R.RECEIPT_ID OR
                                  t.TRANSACTION_HASH = R.ORIGINATED_FROM_TRANSACTION_HASH)
         LEFT JOIN ACTION_RECEIPT_ACTIONS ARA ON ARA.RECEIPT_ID = R.RECEIPT_ID
         LEFT JOIN BLOCKS B ON B.BLOCK_HASH = R.INCLUDED_IN_BLOCK_HASH
         LEFT JOIN EXECUTION_OUTCOMES EO ON EO.RECEIPT_ID = R.RECEIPT_ID
WHERE eo.status IN ('SUCCESS_RECEIPT_ID', 'SUCCESS_VALUE')
  and receipt_predecessor_account_id = ANY($1)
  and to_char(to_timestamp(b.block_timestamp / 1000000000), 'YYYY-MM-DD"T"HH24:MI:SS"Z"') >= $2
  and to_char(to_timestamp(b.block_timestamp / 1000000000), 'YYYY-MM-DD"T"HH24:MI:SS"Z"') < $3
  AND NOT EXISTS (
    SELECT 1
    FROM RECEIPTS R2
    JOIN EXECUTION_OUTCOMES EO2 ON EO2.RECEIPT_ID = R2.RECEIPT_ID
    WHERE (T.CONVERTED_INTO_RECEIPT_ID = R2.RECEIPT_ID OR T.TRANSACTION_HASH = R2.ORIGINATED_FROM_TRANSACTION_HASH)
    AND EO2.STATUS = 'FAILURE'
);`;

export const ALL_INCOMING = `
SELECT *
FROM TRANSACTIONS T
         LEFT JOIN RECEIPTS R ON (T.CONVERTED_INTO_RECEIPT_ID = R.RECEIPT_ID OR
                                  t.TRANSACTION_HASH = R.ORIGINATED_FROM_TRANSACTION_HASH)
         LEFT JOIN ACTION_RECEIPT_ACTIONS ARA ON ARA.RECEIPT_ID = R.RECEIPT_ID
         LEFT JOIN BLOCKS B ON B.BLOCK_HASH = R.INCLUDED_IN_BLOCK_HASH
         LEFT JOIN EXECUTION_OUTCOMES EO ON EO.RECEIPT_ID = R.RECEIPT_ID
WHERE eo.status IN ('SUCCESS_RECEIPT_ID', 'SUCCESS_VALUE')
  and receipt_receiver_account_id = ANY($1)
  and to_char(to_timestamp(b.block_timestamp / 1000000000), 'YYYY-MM-DD"T"HH24:MI:SS"Z"') >= $2
  and to_char(to_timestamp(b.block_timestamp / 1000000000), 'YYYY-MM-DD"T"HH24:MI:SS"Z"') < $3
  AND NOT EXISTS (
    SELECT 1
    FROM RECEIPTS R2
    JOIN EXECUTION_OUTCOMES EO2 ON EO2.RECEIPT_ID = R2.RECEIPT_ID
    WHERE (T.CONVERTED_INTO_RECEIPT_ID = R2.RECEIPT_ID OR T.TRANSACTION_HASH = R2.ORIGINATED_FROM_TRANSACTION_HASH)
    AND EO2.STATUS = 'FAILURE'
);`;

export const FT_INCOMING = `
  SELECT *
  FROM TRANSACTIONS t
           LEFT JOIN RECEIPTS R ON (T.CONVERTED_INTO_RECEIPT_ID = R.RECEIPT_ID OR
                                    t.TRANSACTION_HASH = R.ORIGINATED_FROM_TRANSACTION_HASH)
           LEFT JOIN ACTION_RECEIPT_ACTIONS ARA ON ARA.RECEIPT_ID = R.RECEIPT_ID
           LEFT JOIN BLOCKS B ON B.BLOCK_HASH = R.INCLUDED_IN_BLOCK_HASH
           LEFT JOIN EXECUTION_OUTCOMES EO ON EO.RECEIPT_ID = R.RECEIPT_ID
  WHERE eo.status IN ('SUCCESS_RECEIPT_ID', 'SUCCESS_VALUE')
    AND (r.receiver_account_id = '6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near'     -- DAI
    OR r.receiver_account_id = 'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near'       -- USDC
    OR r.receiver_account_id = 'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near'       -- USDT.e
    OR r.receiver_account_id = 'usn'                                                                -- USN
    OR r.receiver_account_id = 'usdn'
    OR r.receiver_account_id = 'usdt.tether-token.near')                                             -- USDT
    AND ARA.action_kind = 'FUNCTION_CALL'
    AND (ARA.args -> 'args_json' ->> 'receiver_id' = ANY($1) OR ARA.args -> 'args_json' ->> 'account_id' = ANY($1))
    and to_char(to_timestamp(b.block_timestamp / 1000000000), 'YYYY-MM-DD"T"HH24:MI:SS"Z"') >= $2
    and to_char(to_timestamp(b.block_timestamp / 1000000000), 'YYYY-MM-DD"T"HH24:MI:SS"Z"') < $3
    AND NOT EXISTS (
      SELECT 1
      FROM RECEIPTS R2
      JOIN EXECUTION_OUTCOMES EO2 ON EO2.RECEIPT_ID = R2.RECEIPT_ID
      WHERE (T.CONVERTED_INTO_RECEIPT_ID = R2.RECEIPT_ID OR T.TRANSACTION_HASH = R2.ORIGINATED_FROM_TRANSACTION_HASH)
      AND EO2.STATUS = 'FAILURE'
  );`;

'''
'''--- db/query.ts ---
import { Pool, QueryResult } from 'pg';
import fs from 'node:fs';
import path from 'node:path';
import jsonToCsv from './export';
import { ALL_OUTGOING, ALL_INCOMING, FT_INCOMING } from './queries/all';
import Row from './row';
import { AccountId, FTBalance, getCurrencyByContractFromNear, getFTBalance } from '../helpers/currency';
import { getLockup } from '../helpers/lockup';
import { AvailableTokens } from './AvailableTokens';
const CONNECTION_STRING = process.env.POSTGRESQL_CONNECTION_STRING;

const SQL_STATEMENT_TIMEOUT = 3600 * 1_000; // 1 hour in milliseconds.

export default async function query_all(startDate: string, endDate: string, accountIds: Set<string>) {
  const pool = new Pool({ connectionString: CONNECTION_STRING, statement_timeout: SQL_STATEMENT_TIMEOUT });
  let rows_promises = [];

  console.log('query_all', startDate, endDate, accountIds);

  for (const accountId of accountIds) {
    const lockupAccountId = getLockup('near', accountId);

    const all_outgoing_txs_promise = pool.query(ALL_OUTGOING, [[accountId, lockupAccountId], startDate, endDate]);
    const all_incoming_txs_promise = pool.query(ALL_INCOMING, [[accountId, lockupAccountId], startDate, endDate]);
    const ft_incoming_txs_promise = pool.query(FT_INCOMING, [[accountId, lockupAccountId], startDate, endDate]);
    const [all_outgoing_txs, all_incoming_txs, ft_incoming_txs] = await Promise.all([all_outgoing_txs_promise, all_incoming_txs_promise, ft_incoming_txs_promise]);

    console.log(
      `account: ${accountId}, all_outgoing_txs: ${all_outgoing_txs.rowCount}, all_incoming_txs: ${all_incoming_txs.rowCount}, ft_incoming_txs: ${ft_incoming_txs.rowCount}`,
    );

    // TODO(pierre): consider using async to parallelize this
    for (const row of all_outgoing_txs.rows) {
      rows_promises.push(handleOutgoing(accountId, row));
    }

    for (const row of all_incoming_txs.rows) {
      rows_promises.push(handleIncoming(accountId, row));
    }

    for (const row of ft_incoming_txs.rows) {
      rows_promises.push(handleFtIncoming(accountId, row));
    }
  }

  let rows = await Promise.all(rows_promises);

  const r = removeZeroRows(rows);
  const sortedRows = sortByBlockTimestamp(r);
  const csv = jsonToCsv(sortedRows);
  return csv;
}

function formatDate(date: Date): string {
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  const monthIndex = date.getMonth();
  const month = months[monthIndex];
  const day = date.getDate();
  const year = date.getFullYear();
  return `${month} ${day}, ${year}`;
}

async function handleOutgoing(accountId: AccountId, row: any): Promise<Row> {
  let near_amount = row.args?.deposit ? -1 * (row.args.deposit / 10 ** 24) : 0;
  // Remove very small transfers, eg. -1E-24
  near_amount = Math.abs(near_amount) >= 0.000001 ? near_amount : 0;

  let in_amount = '';
  let in_currency = '';

  let out_amount = '';
  let out_currency = '';

  if (row.args.method_name === 'ft_transfer') {
    let args_json = row.args?.args_json ? row.args.args_json : JSON.parse(atob(row.args.args_base64));
    if (args_json.amount && row.receipt_receiver_account_id) {
      var { symbol, decimals } = await getCurrencyByContractFromNear(row.receipt_receiver_account_id);

      out_currency = symbol;
      out_amount = String(-1 * (args_json.amount / 10 ** decimals));
    }
  } else if (row.args.method_name === 'swap') {
    var { symbol, decimals } = await getCurrencyByContractFromNear(row.args.args_json.actions[0].token_in);

    let raw_amount_out = row.args?.args_json?.actions[0].min_amount_out;
    out_currency = symbol;
    out_amount = String(-1 * (raw_amount_out / 10 ** decimals));

    var { symbol, decimals } = await getCurrencyByContractFromNear(row.args.args_json.actions[0].token_out);

    let raw_amount_in = row.args?.args_json?.actions[0].amount_in;
    in_currency = symbol;
    in_amount = String(raw_amount_in / 10 ** decimals);
  } else if (row.args.method_name === 'ft_transfer_call') {
    // Gets arguments for function, converts from base64 if necessary
    let args_json = row.args?.args_json ? row.args.args_json : JSON.parse(atob(row.args.args_base64));

    if (args_json.receiver_id?.includes('bulksender.near')) {
      let raw_amount_out = args_json.amount;
      var { symbol, decimals } = await getCurrencyByContractFromNear(row.receipt_receiver_account_id);
      out_currency = symbol;
      out_amount = String(-1 * (raw_amount_out / 10 ** decimals));
    } else if (args_json.msg?.includes('force')) {
      let msg = JSON.parse(args_json.msg?.replaceAll('\\', ''));
      let raw_amount_out = args_json.amount;
      var { symbol, decimals } = await getCurrencyByContractFromNear(msg.actions[0].token_in);
      out_currency = symbol;
      out_amount = String(-1 * (raw_amount_out / 10 ** decimals));
    } else {
      let raw_amount_out = args_json.amount;
      var { symbol, decimals } = await getCurrencyByContractFromNear(row.receipt_receiver_account_id);
      out_currency = symbol;
      out_amount = String(-1 * (raw_amount_out / 10 ** decimals));
    }
  } else if (row.args.method_name === 'withdraw' && row.receipt_receiver_account_id.endsWith('.factory.bridge.near')) {
    let args_json = row.args?.args_json ? row.args.args_json : JSON.parse(atob(row.args.args_base64));
    if (args_json.amount && row.receipt_receiver_account_id) {
      var { symbol, decimals } = await getCurrencyByContractFromNear(row.receipt_receiver_account_id);

      out_currency = symbol;
      out_amount = String(-1 * (args_json.amount / 10 ** decimals));
    }
  } else if (row.args.method_name === 'near_deposit') {
    if (row.receipt_receiver_account_id) {
      try {
        var { symbol, decimals } = await getCurrencyByContractFromNear(row.receipt_receiver_account_id);

        in_currency = symbol;
        in_amount = String(-1 * near_amount);
      } catch (e) {
        console.log(e);
      }
    }
  }

  let b = null;
  if (row.receipt_receiver_account_id === AvailableTokens.USDC || row.receipt_receiver_account_id === AvailableTokens.USDT) {
    const ftBalances = await getBalances(accountId, row.block_height, [AvailableTokens.USDC, AvailableTokens.USDT]);
    b = ftBalances;
  }

  let r = <Row>{
    date: formatDate(new Date(row.block_timestamp / 1000000)),
    account_id: accountId,
    method_name: row.action_kind == 'TRANSFER' ? 'transfer' : row.args.method_name,
    block_timestamp: row.block_timestamp,
    from_account: row.receipt_predecessor_account_id,
    block_height: row.block_height,
    args: JSON.stringify(getCommandsArgs(row.args)),
    transaction_hash: row.transaction_hash,
    // NEAR tokens
    amount_transferred: near_amount,
    currency_transferred: 'NEAR',
    // Fugible Token
    ft_amount_out: out_amount,
    ft_currency_out: out_currency,
    ft_amount_in: in_amount,
    ft_currency_in: in_currency,
    to_account: row.receipt_receiver_account_id,
    // onchain_dai_balance: ft_balances.dai.balance / 10 ** ft_balances.dai.decimals,
    // onchain_usdc_balance: ft_balances.usdc.balance / 10 ** ft_balances.usdc.decimals,
    amount_staked: handle_staking(row, near_amount),
  };

  if (b) {
    if (b[AvailableTokens.USDC]) {
      r.onchain_usdc_balance = b[AvailableTokens.USDC]?.balance / 10 ** b[AvailableTokens.USDC]?.decimals;
    }
    if (b[AvailableTokens.USDT]) {
      r.onchain_usdt_balance = b[AvailableTokens.USDT]?.balance / 10 ** b[AvailableTokens.USDT]?.decimals;
    }
  }

  return r;
}

async function handleIncoming(accountId: AccountId, row: any): Promise<Row> {
  let near_amount = row.args?.deposit ? row.args.deposit / 10 ** 24 : 0;
  near_amount = Math.abs(near_amount) >= 0.000001 ? near_amount : 0;
  // Gas refund are already accounted in other transactions.
  if (row.receipt_predecessor_account_id == 'system') {
    near_amount = Math.abs(near_amount) >= 0.5 ? near_amount : 0;
  }

  let in_amount = '';
  let in_currency = '';
  if (row.args.method_name === 'ft_transfer') {
    if (row.args?.args_json?.amount && row.receipt_receiver_account_id) {
      const { symbol, decimals } = await getCurrencyByContractFromNear(row.receipt_receiver_account_id);
      in_currency = symbol;

      let raw_amount = row.args?.args_json?.amount;
      in_amount = String(raw_amount / 10 ** decimals);
    }
  }

  let r = <Row>{
    date: formatDate(new Date(row.block_timestamp / 1000000)),
    account_id: accountId,
    method_name: row.action_kind == 'TRANSFER' ? 'transfer' : row.args.method_name,
    block_timestamp: row.block_timestamp,
    from_account: row.receipt_predecessor_account_id,
    block_height: row.block_height,
    args: JSON.stringify(getCommandsArgs(row.args)),
    transaction_hash: row.transaction_hash,
    // NEAR tokens
    amount_transferred: near_amount,
    currency_transferred: 'NEAR',
    // Fugible Token
    ft_amount_out: '',
    ft_currency_out: '',
    ft_amount_in: in_amount,
    ft_currency_in: in_currency,
    to_account: row.receipt_receiver_account_id,
    // onchain_dai_balance: ft_balances.dai.balance / 10 ** ft_balances.dai.decimals,
    // onchain_usdc_balance: ft_balances.usdc.balance / 10 ** ft_balances.usdc.decimals,
    amount_staked: handle_staking(row, near_amount),
  };

  return r;
}

async function handleFtIncoming(accountId: AccountId, row: any): Promise<Row> {
  let to = row.receiver_account_id;
  let near_amount = row.args?.deposit ? row.args.deposit / 10 ** 24 : 0;
  near_amount = Math.abs(near_amount) >= 0.000001 ? near_amount : 0;
  // Gas refund are already accounted in other transactions.
  if (row.receipt_predecessor_account_id == 'system') {
    near_amount = Math.abs(near_amount) >= 0.5 ? near_amount : 0;
  }

  // Skipping NEAR Amount when it is not going to NF associated account ids
  if (to != accountId || to != getLockup('near', accountId)) {
    near_amount = 0;
  }

  let in_amount = '';
  let in_currency = '';
  if (row.args?.args_json?.amount && row.receipt_receiver_account_id) {
    const { symbol, decimals } = await getCurrencyByContractFromNear(row.receipt_receiver_account_id);
    in_currency = symbol;

    let raw_amount = row.args?.args_json?.amount;
    in_amount = String(raw_amount / 10 ** decimals);
  }

  let b = null;
  if (row.receipt_receiver_account_id === AvailableTokens.USDC || row.receipt_receiver_account_id === AvailableTokens.USDT) {
    const ftBalances = await getBalances(accountId, row.block_height, [AvailableTokens.USDC, AvailableTokens.USDT]);
    b = ftBalances;
  }

  let r = <Row>{
    date: formatDate(new Date(row.block_timestamp / 1000000)),
    account_id: accountId,
    method_name: row.action_kind == 'TRANSFER' ? 'transfer' : row.args.method_name,
    block_timestamp: row.block_timestamp,
    from_account: row.receipt_predecessor_account_id,
    block_height: row.block_height,
    args: JSON.stringify(getCommandsArgs(row.args)),
    transaction_hash: row.transaction_hash,
    // NEAR tokens
    amount_transferred: near_amount,
    currency_transferred: 'NEAR',
    // Fugible Token
    ft_amount_out: '',
    ft_currency_out: '',
    ft_amount_in: in_amount,
    ft_currency_in: in_currency,
    to_account: to,
    amount_staked: handle_staking(row, near_amount),
  };

  if (b) {
    if (b[AvailableTokens.USDC]) {
      r.onchain_usdc_balance = b[AvailableTokens.USDC]?.balance / 10 ** b[AvailableTokens.USDC]?.decimals;
    }
    if (b[AvailableTokens.USDT]) {
      r.onchain_usdt_balance = b[AvailableTokens.USDT]?.balance / 10 ** b[AvailableTokens.USDT]?.decimals;
    }
  }

  return r;
}

function sortByBlockTimestamp(rows: Row[]): Row[] {
  return rows.sort(function (a, b) {
    return a.account_id.localeCompare(b.account_id) || a.block_timestamp - b.block_timestamp;
  });
}

function removeZeroRows(rows: Row[]): Row[] {
  return rows.filter((row) => {
    const ftAmountIn = parseFloat(row.ft_amount_in);
    const ftAmountOut = parseFloat(row.ft_amount_out);
    const amountTransferred = row.amount_transferred;

    return (!isNaN(ftAmountIn) && ftAmountIn !== 0) || (!isNaN(ftAmountOut) && ftAmountOut !== 0) || amountTransferred !== 0;
  });
}

type BalanceKey = string;
type BalanceValue = {
  [token in AvailableTokens]?: FTBalance | null;
};

const seenBalances = new Map<BalanceKey, BalanceValue>();

// Function is required. We will use it the future to get onchain balances
export async function getBalances(accountId: AccountId, blockId: number, neededTokens: AvailableTokens[]): Promise<BalanceValue> {
  const key: BalanceKey = JSON.stringify({ accId: accountId, b_id: blockId });

  if (seenBalances.has(key)) {
    return seenBalances.get(key) as BalanceValue;
  }

  for (const token of neededTokens) {
    const balance = await getFTBalance(token, accountId, Number(blockId));
    seenBalances.set(key, { ...seenBalances.get(key), [token]: balance });
  }

  return seenBalances.get(key) as BalanceValue;
}

function getCommandsArgs(args: any): any {
  let pretty = {};
  if (args?.args_json) {
    pretty = args.args_json;
  } else if (args?.args_base64) {
    pretty = JSON.parse(atob(args.args_base64));
  }
  return pretty;
}

function handle_staking(row: any, nearAmount: number) {
  let tokens = 0;
  // It's a transfer out of the account but for staking.
  if (row.receipt_receiver_account_id.endsWith('.poolv1.near') && (row.args.method_name === 'deposit' || row.args.method_name === 'deposit_and_stake')) {
    tokens = -1 * nearAmount;
  }
  if (row.receipt_predecessor_account_id.endsWith('.poolv1.near')) {
    tokens = -1 * nearAmount;
  }
  return tokens;
}

'''
'''--- db/row.ts ---
export default interface Row {
  date: string;
  account_id: string;
  block_timestamp_utc: string;
  block_timestamp: number;
  block_height: number;
  transaction_hash: string;
  transaction_type: string;
  from_account: string;
  to_account: string;
  amount_transferred: number;
  currency_transferred: string;
  ft_currency_in: string;
  ft_amount_in: string;
  ft_currency_out: string;
  ft_amount_out: string;
  args_base64: string;
  action_kind: string;
  method_name: string;
  args: string;
  onchain_usdc_balance: number;
  onchain_dai_balance: number;
  onchain_usdt_balance: number;
  amount_staked: number;
}

'''
'''--- helpers/RateLimiter.ts ---
import { Mutex } from 'async-mutex';

const RATE_LIMIT = 10; // number of tokens per second
const BUCKET_SIZE = 20; // maximum number of tokens in the bucket
const REFILL_INTERVAL = 1000; // in milliseconds

export class RateLimiter {
  private tokens: number;
  private lastRefill: number;
  private mutex: Mutex;

  constructor() {
    this.tokens = BUCKET_SIZE;
    this.lastRefill = Date.now();
    this.mutex = new Mutex();
  }

  private refillTokens(): void {
    const now = Date.now();
    const elapsed = now - this.lastRefill;

    if (elapsed >= REFILL_INTERVAL) {
      const tokensToAdd = Math.floor((elapsed * RATE_LIMIT) / REFILL_INTERVAL);
      this.tokens = Math.min(this.tokens + tokensToAdd, BUCKET_SIZE);
      this.lastRefill = now;
    }
  }

  async acquireToken(): Promise<void> {
    await this.mutex.runExclusive(async () => {
      while (this.tokens === 0) {
        await new Promise((resolve) => setTimeout(resolve, REFILL_INTERVAL));
        this.refillTokens();
      }
      this.tokens -= 1;
    });
  }
}

'''
'''--- helpers/currency.ts ---
import * as nearAPI from 'near-api-js'; // https://docs.near.org/tools/near-api-js/quick-reference#import
import { getNearApiConnection } from './nearConnection';
import { RateLimiter } from './RateLimiter';

export type AccountId = string;

const NEAR_NODE_URL = process.env.NEAR_NODE_URL ?? 'https://rpc.mainnet.near.org';
const { provider, connection } = getNearApiConnection(NEAR_NODE_URL);

let ftDetails = new Map<AccountId, { symbol: string; name: string; decimals: number }>();

export async function getCurrencyByContractFromNear(fungibleTokenContractAccountId: AccountId): Promise<{ decimals: any; name: string; symbol: string }> {
  // if not in the map, get the details from the contract and
  // cache in the map
  if (!ftDetails.has(fungibleTokenContractAccountId)) {
    // from https://github.com/NEARFoundation/tx-tracking-app/blob/1922c5f6059bb38583bc524a525d976731854284/backend/src/helpers/getCurrency.ts#L73
    const ftMetadataResult = await new nearAPI.Account(connection, '').viewFunction(fungibleTokenContractAccountId, 'ft_metadata', {});
    const { symbol, name, decimals } = ftMetadataResult;

    ftDetails.set(fungibleTokenContractAccountId, { symbol, name, decimals });
  }

  const ftDetailsResult = ftDetails.get(fungibleTokenContractAccountId);
  if (!ftDetailsResult) {
    throw new Error(`ftDetails is undefined for ${fungibleTokenContractAccountId}`);
  }

  return ftDetailsResult;
}

type query = {
  request_type: string;
  block_id: number;
  account_id: string;
  method_name: string;
  args_base64: string;
};
export type FTBalance = {
  balance: number;
  symbol: string;
  name: string;
  decimals: number;
};

const rateLimiter = new RateLimiter();

export async function getFTBalance(ftContractAccountId: AccountId, accountId: AccountId, blockId: number): Promise<FTBalance> {
  await rateLimiter.acquireToken();

  const provider = new nearAPI.providers.JsonRpcProvider({ url: 'https://archival-rpc.mainnet.near.org' });

  const rawResult: any = await provider.query({
    request_type: 'call_function',
    account_id: ftContractAccountId,
    method_name: 'ft_balance_of',
    args_base64: btoa(JSON.stringify({ account_id: accountId })),
    block_id: Number(blockId),
  });
  const balance = JSON.parse(Buffer.from(rawResult.result).toString());

  const { symbol, name, decimals } = await getCurrencyByContractFromNear(ftContractAccountId);
  return { balance, symbol, name, decimals };
}

'''
'''--- helpers/datetime.ts ---
import dayjs from 'dayjs';
// eslint-disable-next-line import/extensions
import relativeTime from 'dayjs/plugin/relativeTime.js';
import utc from 'dayjs/plugin/utc.js';
// eslint-disable-next-line import/order
import timezone from 'dayjs/plugin/timezone.js'; // dependent on utc plugin https://day.js.org/docs/en/plugin/timezone

dayjs.extend(utc); // https://day.js.org/docs/en/plugin/utc
dayjs.extend(relativeTime); // https://day.js.org/docs/en/plugin/relative-time
dayjs.extend(timezone);

/**
 *
 * @param {Date} date
 * @returns {string} like 2022-08-03 17:32:00 UTC
 */
export const getFormattedUtcDatetime = (date: Date): string => {
  return dayjs(date).utc().format('YYYY-MM-DD HH:mm:ss [UTC]'); // https://day.js.org/docs/en/manipulate/utc
};

export function getFormattedUtcDatetimeNow(): string {
  return getFormattedUtcDatetime(new Date());
}

export const getFormattedUtcDatetimeForFilename = (date: Date): string => {
  const formattedUtcDatetime = getFormattedUtcDatetime(date);
  return formattedUtcDatetime.replaceAll(' ', '_').replaceAll(':', '');
};

'''
'''--- helpers/lockup.ts ---
const { createHash } = require('crypto');

export function getLockup(masterAccountId: string, accountId: string): string {
  return `${sha256(accountId).slice(0, 40)}.lockup.${masterAccountId}`;
}

function sha256(value: any) {
  return createHash('sha256').update(value).digest('hex');
}

'''
'''--- helpers/nearConnection.ts ---
import * as nearAPI from 'near-api-js'; // https://docs.near.org/tools/near-api-js/quick-reference#import
import { InMemoryKeyStore } from 'near-api-js/lib/key_stores/in_memory_key_store.js';
import { type KeyStore } from 'near-api-js/lib/key_stores/keystore.js';

export function getNearApiConnection(nodeUrl: string, keyStore?: KeyStore) {
  const connectionInfo = { url: nodeUrl };
  const provider = new nearAPI.providers.JsonRpcProvider(connectionInfo);
  const signer = new nearAPI.InMemorySigner(keyStore ?? new InMemoryKeyStore());
  const connection = new nearAPI.Connection(nodeUrl, provider, signer);
  return { provider, connection };
}

'''
'''--- next.config.js ---
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
};

module.exports = {
  env: {
    ...nextConfig.env,
    GIT_COMMIT: process.env.GIT_COMMIT,
  },
  ...nextConfig,
};

'''
'''--- package.json ---
{
    "name": "tta-basic",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "GIT_COMMIT=$(git rev-parse HEAD) next dev",
        "build": "GIT_COMMIT=$(git rev-parse HEAD) next build",
        "start": "next start",
        "lint": "next lint"
    },
    "dependencies": {
        "@types/node": "18.11.9",
        "@types/react": "18.0.25",
        "@types/react-dom": "18.0.9",
        "async-mutex": "^0.4.0",
        "csvjson-json2csv": "^1.0.3",
        "dayjs": "^1.11.6",
        "eslint": "8.28.0",
        "eslint-config-next": "13.0.4",
        "near-api-js": "^0.44.2",
        "next": "13.0.4",
        "pg": "^8.8.0",
        "react": "18.2.0",
        "react-dom": "18.2.0",
        "typescript": "4.9.3"
    },
    "devDependencies": {
        "@nearfoundation/near-prettier-config": "^1.0.1",
        "@types/pg": "^8.6.5",
        "prettier": "^2.7.1"
    },
    "prettier": "@nearfoundation/near-prettier-config",
    "engines": {
        "node": ">=16.0.0 <19.0.0"
    }
}
'''
'''--- pages/api/csv.ts ---
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type { NextApiRequest, NextApiResponse } from 'next';
import query_all from '../../db/query';
import { getFormattedUtcDatetimeNow } from '../../helpers/datetime';

const STATUS_SUCCESS = 200;
const STATUS_ERROR = 500;

function getFilename(accounts: Set<string>): string {
  if (accounts.size === 1) {
    return `${Array.from(accounts)[0]}_${getFormattedUtcDatetimeNow()}.csv`;
  } else if (accounts.size > 1) {
    const firstAccount = Array.from(accounts)[0];
    return `${firstAccount}+${accounts.size - 1}_more_${getFormattedUtcDatetimeNow()}.csv`;
  }
  return `download_${getFormattedUtcDatetimeNow()}.csv`;
}

function getCleanedAccountIds(accountIds: string): Set<string> {
  return new Set(
    accountIds
      .replaceAll('\r', '')
      .split('\n')
      .filter((id) => id.trim() !== ''),
  );
}

export default async function handler(request: NextApiRequest, res: NextApiResponse<string>) {
  const { startDate, endDate, accountIds } = request.body;

  console.log({ startDate, endDate, accountIds });
  const accounts = getCleanedAccountIds(accountIds as string);
  const rowsCsv = await query_all(startDate as string, endDate as string, accounts);

  // https://medium.com/@aitchkhan/downloading-csv-files-from-express-server-7a3beb3ae52c
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', `attachment; filename="${getFilename(accounts)}"`);
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Pragma', 'no-cache');

  try {
    res.status(STATUS_SUCCESS).send(rowsCsv);
  } catch (error) {
    console.error('error:', error);
    res.status(STATUS_ERROR).send(JSON.stringify(error));
  }
}

export const config = {
  api: {
    bodyParser: {
      sizeLimit: '8mb',
    },
  },
};

'''
'''--- public/vercel.svg ---
<svg width="283" height="64" viewBox="0 0 283 64" fill="none" 
    xmlns="http://www.w3.org/2000/svg">
    <path d="M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z" fill="#000"/>
</svg>
'''
'''--- styles/Home.module.css ---
.container {
  padding: 0 2rem;
}

.main {
  min-height: 100vh;
  padding: 4rem 0;
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.code {
  background: #fafafa;
  border-radius: 5px;
  padding: 0.75rem;
  font-size: 1.1rem;
  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace;
}

.grid {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  max-width: 800px;
}

@media (max-width: 600px) {
  .grid {
    width: 100%;
    flex-direction: column;
  }
}

'''
'''--- styles/globals.css ---
html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
  body {
    color: white;
    background: black;
  }
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es6",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

'''