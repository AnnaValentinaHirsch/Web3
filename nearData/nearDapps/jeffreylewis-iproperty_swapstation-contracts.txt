*GitHub Repository "jeffreylewis-iproperty/swapstation-contracts"*

'''--- README.md ---
# Swap Station

<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/screenshots/screenshot-intro-small.png" alt="">
</p>

#### Swap NFTs Across Blockchains

[SwapStation.io](https://www.swapstation.io/) is a platform that facilitates NFT swaps in and across chains. Featuring a one of a kind marketplace for NFT collectors to showcase, discover, and swap NFTs across different blockchains.

You can import any NFTs to SwapStation, put your token up for trade and start receiving swap offers. Likewise, if you see anything you like you can place an offer using a token you wish to exchange. The swap takes place when both parties accept the trade.

Absolutely no gas fees required when importing, creating listings and making offers. The only time a payment is required if when an actual swap transaction takes place.

**Contents**

- [Features](#features)
- [Process Flow](#process-flow)
- [Technologies](#technologies)
- [Live Product Preview](#live-product-preview)
- [Developer Quick Start Guide](#developer-quick-start-guide)
- [Interacting With the Contracts](#interacting-with-the-contracts)
- [Screenshots](#screenshots)

## Features

- Import any NFT into your personal collection.
- Put your tokens up for trade by creating discoverable listings.
- Browse other listings to find interesting NFTs where you can offer up your own NFT to exchange for it.
- Manage your collections, listings and offers through a personal dashboard.
- Accept offers for your NFT to make an exchange.
- Swap transactions takes place in the blockchain and is immutable.
- No gas fees required for importing, listing and making offers. The only time a payment is required if when an actual swap transaction takes place. (See architecture section to understand)

## Process Flow

<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/images/swapstation-flow.png" alt="Process">
</p>

1. **Seller/Maker** imports NFT from supported blockchains into SwapStation, then puts their NFT up for trade by creating a listing.

2. **Buyer/Taker** browses available listings and make an offer on a listing by importing their own NFT into SwapStation.

3. If **seller** accepts an offer, the listed NFT is transfered to the buyer and the offered NFT is transfered to the seller.

4. **Seller** can cancels a listing and remove it from discoverability and all pending offers.

5. **Buyer** can retract an offer for a listing if it has not been accepted by the seller yet.

#### Same-Chain Swap Process

<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/images/swapstation-samechain-process.png" alt="Same-Chain Process">
</p>

#### Cross-Chain Swap Process

<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/images/swapstation-crosschain-process.png" alt="Cross-Chain Process">
</p>

## Technologies

<p align="center">
    <img width="600px" src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/images/swapstation-architecture.png" alt="Architecture">
</p>

**Web Application (UX)**

- The frontend web application is developed in React using the **NextJS** framework. Integration with **NEAR** is via NEAR Wallet, and **TRON** via TronLink and TronWeb. Upcoming integrations with Ethereum and NEO blockchains is on the roadmap.

**API**

- There is a REST API that interface between the frontend web application with the underlying offchain database. The API is developed in NodeJS Express. We have plans to expand this API in the future to allow for third party integrations with SwapStation.

**Offchain Database**

- Most of the data powering the frontend application is held in an offchain database, which includes imported NFT collections, listings, offers and carbon copies of swap tranasction records. The only time where a transaction takes place in the blockchain is when an offer is accepted and a swap needs to take place.
- The primary purpose of this offchain database is to allow for zero fees so anyone can create as many listings and offers as they wish without worrying about cost, and they only need to pay once they decide to make a swap.

**Blockchain Smart Contracts**

- **SwapStation**: Smart Contracts repesenting the swap contract. This contract is responsible for the swap transaction that takes place when an offer is accepted. See [SwapStation Contract functions](#swap-station-contract-functions) for functions.

- **NFT**: A sample ERC-721/NEP-171 NFT contract using [OpenZeppelin](https://www.openzeppelin.com/) standard. We are using this contract as a sample for developing and testing the integration with the application.

## Developer Quick Start Guides

[NEAR](/contracts/near/README.md)

[TRON](/contracts/tron/README.md)

[Ethereum](/contracts/ethereum/README.md)

## Screenshots

<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/screenshots/screenshot-intro-large.png" alt="">
</p>
<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/screenshots/screenshot-import.png" alt="">
</p>
<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/screenshots/screenshot-mycollection.png" alt="">
</p>
<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/screenshots/screenshot-makeoffer.png" alt="">
</p>
<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/screenshots/screenshot-viewlisting.png" alt="">
</p>
<p align="center">
    <img src="https://raw.githubusercontent.com/SwapStation/swapstation-contracts/main/docs/screenshots/screenshot-myoffer.png" alt="">
</p>

'''
'''--- contracts/ethereum/README.md ---
# Swap Station Contract - Ethereum

SwapStation Ethereum support is under development.

'''
'''--- contracts/near/README.md ---
# Swap Station Contract - NEAR

#### Deploying to NEAR development environment

Pre-requisite: [NEAR CLI](https://docs.near.org/docs/tools/near-cli#installation)
1. Clone the source code from repo

2. Deploy the sample NFT Contract

```
From the project root folder:
> cd packages/contract-nft
> near dev-deploy --wasmFile res/non_fungible_token.wasm
> source neardev/dev-account.env
> near call $CONTRACT_NAME new_default_meta '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME
```
*View packages/contract-nft/README.md for explanation of each steps.*

2. Build and deploy the Exchange Contract
```
From the project root folder:
> cd packages/contract-exchange
> yarn
> yarn deploy:dev
```

#### Interacting With the Contracts

Example calls:

```
export ID=jeffreylewis.testnet
export ALICEID=jeffreylewis-alice.testnet
export BOBID=jeffreylewis-bob.testnet
```

# View Owner Tokens
near view nft.$ID nft_tokens_for_owner '{"account_id": "'$ALICEID'"}'
near view nft.$ID nft_tokens_for_owner '{"account_id": "'$BOBID'"}'
near view nft.$ID nft_tokens_for_owner '{"account_id": "'$ID'"}'
near view nft.$ID nft_tokens_for_owner '{"account_id": "'exchange.$ID'"}'

# Transfer
near call nft.$ID nft_transfer '{"token_id": "1", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $ALICEID --depositYocto 1

'''
'''--- contracts/near/sample-nft-contract/README.md ---
## NFT Contract Sample

This package contains only the build output from the official NEAR NFT example contract from https://github.com/near-examples/NFT.
We are using this to create dummy NFTs for testing and development of NFT Exchange.

See [README](https://github.com/SwapStation/swapstation-contracts) for setup instructions.

### Usage Instructions
#### Deploying to Development Environment

1. Open a new terminal.

2. Deploy the contract to a development account. Account ID will be automatically generated.
```
near dev-deploy --wasmFile res/non_fungible_token.wasm
```

3. Set the environment variable of the development account.
```
source neardev/dev-account.env
echo $CONTRACT_NAME
```

4. Initialize the NFT contract and verify.
```
near call $CONTRACT_NAME new_default_meta '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME
near view $CONTRACT_NAME nft_metadata
```

#### Deploying to Testnet

1. Open a new terminal.

2. Set the environment variable of the testnet account.
```
export ID=jeffreylewis.testnet
```

3. Deploy the contract to the testnet account.
```
near deploy --wasmFile res/non_fungible_token.wasm --accountId nft.$ID
```

4. Initialize the NFT contract and verify.
```
near call nft.$ID new_default_meta '{"owner_id": "'nft.$ID'"}' --accountId nft.$ID
near view nft.$ID nft_metadata
```

#### Minting & Transferring

1. Set the environment variable of the testnet account.
```
export ID=jeffreylewis.testnet
```

2. NFT Contract Functions

**Mint**
```
near call nft.$ID nft_mint '{"token_id": "0", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "Olympus Mons", "description": "Tallest mountain in charted solar system", "media": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Olympus_Mons_alt.jpg/1024px-Olympus_Mons_alt.jpg", "copies": 1}}' --accountId nft.$ID --deposit 0.1
```

**Transfer**
```
near call nft.$ID nft_transfer '{"token_id": "0", "receiver_id": "alice.'$ID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1
```

**Get Owner Tokens**
```
near view nft.$ID nft_tokens_for_owner '{"account_id": "'alice.$ID'"}'
near view nft.$ID nft_tokens_for_owner '{"account_id": "'bob.$ID'"}'
```

'''
'''--- contracts/near/scripts/exchange-utils.sh ---
export ID=jeffreylewis.testnet
export ALICEID=jeffreylewis-alice.testnet
export BOBID=jeffreylewis-bob.testnet

# View Listings
near call exchange.$ID getListings '{}' --accountId $ID --deposit 0.1

# View Offers
near call exchange.$ID getOffers '{}' --accountId $ID --deposit 0.1

# Create Listing
near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "1", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "a1.png", "title": "Karafuru #2321", "description": "Karafuru is home to 5555 generative arts where colors reign supreme. Leave the drab reality and enter the world of Karafuru by Museum of Toys." }}' --accountId $ALICEID --deposit 0.1

# Cancel Listing
near call exchange.$ID cancelListing '{"tokenContract": "'nft.$ID'", "tokenId": "1"}' --accountId $ALICEID --deposit 0.1

# Make Offer
near call exchange.$ID makeOffer '{"tokenContract": "'nft.$ID'", "tokenId": "9", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "c3.png", "title": "CryptoCities #056 - Undead City", "description": "An art collection made up of voxel-based microcosms displaying iconic cities from real life/fiction. Only 333 unique cities to be minted." }}' --accountId $BOBID --deposit 0.1

# Cancel Offer
near call exchange.$ID cancelOffer '{"tokenContract": "'nft.$ID'", "tokenId": "9"}' --accountId $BOBID --deposit 0.1

# Accept Offer
near call exchange.$ID acceptOffer '{"tokenContract": "'nft.$ID'", "tokenId": "9"}' --accountId $ALICEID --deposit 0.1

'''
'''--- contracts/near/scripts/init-exchange-listings.sh ---
#
# The following scripts assumes that the NFT and Exchange contracts has been deployed
# and that tokens 1-9 has been minted accordingly
#

export ID=jeffreylewis.testnet
export ALICEID=jeffreylewis-alice.testnet
export BOBID=jeffreylewis-bob.testnet

# CREATE DEMO LISTINGS (from ALICE)
near call nft.$ID nft_transfer '{"token_id": "1", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $ALICEID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "2", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $ALICEID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "3", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $ALICEID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "4", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $ALICEID --depositYocto 1
# near call nft.$ID nft_transfer '{"token_id": "5", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $ALICEID --depositYocto 1
# near call nft.$ID nft_transfer '{"token_id": "6", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $ALICEID --depositYocto 1

near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "1", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "a1.png", "title": "Karafuru #2321", "description": "Karafuru is home to 5555 generative arts where colors reign supreme. Leave the drab reality and enter the world of Karafuru by Museum of Toys." }}' --accountId $ALICEID --deposit 0.1
near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "2", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "a2.png", "title": "Karafuru #4827", "description": "Karafuru is home to 5555 generative arts where colors reign supreme. Leave the drab reality and enter the world of Karafuru by Museum of Toys." }}' --accountId $ALICEID --deposit 0.1
near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "3", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "a3.png", "title": "Karafuru #3982", "description": "Karafuru is home to 5555 generative arts where colors reign supreme. Leave the drab reality and enter the world of Karafuru by Museum of Toys." }}' --accountId $ALICEID --deposit 0.1
near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "4", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "s1.png", "title": "Coolmans Universe #4078", "description": "Spesh is looking for his best friend throughout Coolmans Universe. To travel through this universe Spesh uses a surfboard and a compass." }}' --accountId $ALICEID --deposit 0.1
# near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "5", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "s2.png", "title": "Coolmans Universe #2639", "description": "Spesh is looking for his best friend throughout Coolmans Universe. To travel through this universe Spesh uses a surfboard and a compass." }}' --accountId $ALICEID --deposit 0.1 --gas=300000000000000
# near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "6", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "s3.png", "title": "Coolmans Universe #8023", "description": "Spesh is looking for his best friend throughout Coolmans Universe. To travel through this universe Spesh uses a surfboard and a compass." }}' --accountId $ALICEID --deposit 0.1 --gas=300000000000000

# CREATE DEMO LISTINGS (from BOB)
near call nft.$ID nft_transfer '{"token_id": "7", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $BOBID --depositYocto 1
# near call nft.$ID nft_transfer '{"token_id": "8", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $BOBID --depositYocto 1
# near call nft.$ID nft_transfer '{"token_id": "9", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $BOBID --depositYocto 1

near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "7", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "c1.png", "title": "CryptoCities #034 - Sydney", "description": "An art collection made up of voxel-based microcosms displaying iconic cities from real life/fiction. Only 333 unique cities to be minted." }}' --accountId $BOBID --deposit 0.1
# near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "8", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "c2.png", "title": "CryptoCities #029 - Athens", "description": "An art collection made up of voxel-based microcosms displaying iconic cities from real life/fiction. Only 333 unique cities to be minted." }}' --accountId $BOBID --deposit 0.1
# near call exchange.$ID createListing '{"tokenContract": "'nft.$ID'", "tokenId": "9", "lookingFor": "Looking for anything of similar value.", "tokenMeta": { "image": "c3.png", "title": "CryptoCities #056 - Undead City", "description": "An art collection made up of voxel-based microcosms displaying iconic cities from real life/fiction. Only 333 unique cities to be minted." }}' --accountId $BOBID --deposit 0.1 --gas=300000000000000

'''
'''--- contracts/near/scripts/init-nft-mint.sh ---
export ID=jeffreylewis.testnet
export ALICEID=jeffreylewis-alice.testnet
export BOBID=jeffreylewis-bob.testnet

# Mint tokens
near call nft.$ID nft_mint '{"token_id": "1", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "Karafuru #2321", "description": "Karafuru is home to 5555 generative arts where colors reign supreme. Leave the drab reality and enter the world of Karafuru by Museum of Toys.", "media": "a1.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1
near call nft.$ID nft_mint '{"token_id": "2", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "Karafuru #4827", "description": "Karafuru is home to 5555 generative arts where colors reign supreme. Leave the drab reality and enter the world of Karafuru by Museum of Toys.", "media": "a2.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1
near call nft.$ID nft_mint '{"token_id": "3", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "Karafuru #3982", "description": "Karafuru is home to 5555 generative arts where colors reign supreme. Leave the drab reality and enter the world of Karafuru by Museum of Toys.", "media": "a3.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1

near call nft.$ID nft_mint '{"token_id": "4", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "Coolmans Universe #4078", "description": "Spesh is looking for his best friend throughout Coolmans Universe. To travel through this universe Spesh uses a surfboard and a compass.", "media": "s1.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1
near call nft.$ID nft_mint '{"token_id": "5", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "Coolmans Universe #2639", "description": "Spesh is looking for his best friend throughout Coolmans Universe. To travel through this universe Spesh uses a surfboard and a compass.", "media": "s2.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1
near call nft.$ID nft_mint '{"token_id": "6", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "Coolmans Universe #8023", "description": "Spesh is looking for his best friend throughout Coolmans Universe. To travel through this universe Spesh uses a surfboard and a compass.", "media": "s3.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1

near call nft.$ID nft_mint '{"token_id": "7", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "CryptoCities #034 - Sydney", "description": "An art collection made up of voxel-based microcosms displaying iconic cities from real life/fiction. Only 333 unique cities to be minted.", "media": "c1.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1
near call nft.$ID nft_mint '{"token_id": "8", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "CryptoCities #029 - Athens", "description": "An art collection made up of voxel-based microcosms displaying iconic cities from real life/fiction. Only 333 unique cities to be minted.", "media": "c2.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1
near call nft.$ID nft_mint '{"token_id": "9", "receiver_id": "'nft.$ID'", "token_metadata": { "title": "CryptoCities #056 - Undead City", "description": "An art collection made up of voxel-based microcosms displaying iconic cities from real life/fiction. Only 333 unique cities to be minted.", "media": "c3.png", "copies": 1}}' --accountId nft.$ID --deposit 0.1

# Transfer to alice
near call nft.$ID nft_transfer '{"token_id": "1", "receiver_id": "'$ALICEID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "2", "receiver_id": "'$ALICEID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "3", "receiver_id": "'$ALICEID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1

near call nft.$ID nft_transfer '{"token_id": "4", "receiver_id": "'$ALICEID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "5", "receiver_id": "'$ALICEID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "6", "receiver_id": "'$ALICEID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1

# Transfer to bob
near call nft.$ID nft_transfer '{"token_id": "7", "receiver_id": "'$BOBID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "8", "receiver_id": "'$BOBID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1
near call nft.$ID nft_transfer '{"token_id": "9", "receiver_id": "'$BOBID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1

'''
'''--- contracts/near/scripts/nft-utils.sh ---
export ID=jeffreylewis.testnet
export ALICEID=jeffreylewis-alice.testnet
export BOBID=jeffreylewis-bob.testnet

# View Owner Tokens
near view nft.$ID nft_tokens_for_owner '{"account_id": "'$ALICEID'"}'
near view nft.$ID nft_tokens_for_owner '{"account_id": "'$BOBID'"}'
near view nft.$ID nft_tokens_for_owner '{"account_id": "'$ID'"}'
near view nft.$ID nft_tokens_for_owner '{"account_id": "'exchange.$ID'"}'

# Transfer
near call nft.$ID nft_transfer '{"token_id": "1", "receiver_id": "'exchange.$ID'", "memo": "transfer ownership"}' --accountId $ALICEID --depositYocto 1

'''
'''--- contracts/near/swapstation-contract/README.md ---
## NFT Exchange Contract

This NEAR Smart Contract powers the NFT Exchange marketplace.

See [README](https://github.com/SwapStation/swapstation-contracts) for setup instructions.

'''
'''--- contracts/near/swapstation-contract/as-pect.config.js ---
module.exports = require("near-sdk-as/imports")
'''
'''--- contracts/near/swapstation-contract/asconfig.json ---
{
    "extends": "near-sdk-as/asconfig.json"
  } 
  
'''
'''--- contracts/near/swapstation-contract/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- contracts/near/swapstation-contract/assembly/__tests__/exchange.spec.ts ---
import { context, storage, VMContext } from 'near-sdk-as';
import { acceptOffer, cancelListing, cancelOffer, createListing, getListing, getListings, getOffer, getOffers, makeOffer } from '..';

describe("Exchange ", () => {
  // Creating listing
  it("should be able to call createListing", () => {
      createListing("nft.jeffreylewis.testnet", "1");
      expect(getListings().length).toBe(1, "listings count should be one after creating a listing.");
  });

  // Getting listings
  it("should be able to call getListings", () => {
    createListing("nft.jeffreylewis.testnet", "1");
    createListing("nft.jeffreylewis.testnet", "2");
    createListing("nft.jeffreylewis.testnet", "3");

    const listings = getListings();

    expect(listings[0].tokenId).toBe("1", "listings tokenId should be correct after creating a listing.");
    expect(listings[1].tokenId).toBe("2", "listings tokenId should be correct after creating a listing.");
    expect(listings[2].tokenId).toBe("3", "listings tokenId should be correct after creating a listing.");
    expect(listings[1].seller).toBe("bob", "listings seller should be correct after creating a listing.");
    expect(listings[1].tokenContract).toBe("nft.jeffreylewis.testnet", "listings seller should be correct after creating a listing.");
  });

  it("should be able to call getListing", () => {
    createListing("nft.jeffreylewis.testnet", "1");
    const listing = getListing("nft.jeffreylewis.testnet", "1");
    expect(listing).not.toBeNull("listings tokenId should be correct after creating a listing.");
  });

  // Cancelling listing
  it("should be able to call cancelListing", () => {
    createListing("nft.jeffreylewis.testnet", "1");
    createListing("nft.jeffreylewis.testnet", "2");
    cancelListing("nft.jeffreylewis.testnet", "1");
    expect(getListings().length).toBe(1, "listings count should be one after creating a listing.");
  });

  // Making offer
  it("should be able to call makeOffer", () => {
    createListing("nft.jeffreylewis.testnet", "1");
    makeOffer("nft.jeffreylewis.testnet", "2", "nft.jeffreylewis.testnet", "1");
    expect(getOffers().length).toBe(1, "offers count should be one after making an offer.");
  });

  it("should not be able to call makeOffer if a listing does not exist", () => {
    makeOffer("nft.jeffreylewis.testnet", "2", "nft.jeffreylewis.testnet", "1");
    expect(getOffers().length).toBe(0, "offers count should be zero after making an offer for an invalid listing.");
  });

  // Cancelling offer
  it("should be able to call cancelOffer", () => {
    createListing("nft.jeffreylewis.testnet", "1");
    makeOffer("nft.jeffreylewis.testnet", "2", "nft.jeffreylewis.testnet", "1");
    cancelOffer("nft.jeffreylewis.testnet", "2");
    expect(getOffers().length).toBe(0, "offers count should be one after making an offer.");
  });

  it("should not be able to call cancelOffer if a offer does not exist", () => {
    createListing("nft.jeffreylewis.testnet", "1");
    makeOffer("nft.jeffreylewis.testnet", "2", "nft.jeffreylewis.testnet", "1");
    cancelOffer("nft.jeffreylewis.testnet", "3");
    expect(getOffers().length).toBe(1, "offers count should be zero after making an offer for an invalid listing.");
  });

  // Accepting offer
  it("should be able to call acceptOffer", () => {
    createListing("nft.jeffreylewis.testnet", "1");
    makeOffer("nft.jeffreylewis.testnet", "2", "nft.jeffreylewis.testnet", "1");
    acceptOffer("nft.jeffreylewis.testnet", "2");
    expect(getOffers().length).toBe(0, "offers count should be one after making an offer.");
  });

  it("should not be able to call acceptOffer if a offer does not exist", () => {
    createListing("nft.jeffreylewis.testnet", "1");
    makeOffer("nft.jeffreylewis.testnet", "2", "nft.jeffreylewis.testnet", "1");
    acceptOffer("nft.jeffreylewis.testnet", "3");
    expect(getOffers().length).toBe(1, "offers count should be zero after making an offer for an invalid listing.");
  });

  it("should be adam's account", () => {
    VMContext.setCurrent_account_id("adam");
    expect(context.contractName).toBe("adam");
  });
});

'''
'''--- contracts/near/swapstation-contract/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- contracts/near/swapstation-contract/assembly/index.ts ---
import { context, logging } from "near-sdk-as";
import { ListingInfo, OfferInfo, TokenMeta } from "./models";
import { NFTContractApi } from "./nftContractApi";
import { generateNewListingID, generateNewOfferID, listingsStorage, offersStorage } from "./storage";

const EXCHANGE_CONTRACT_ID = 'exchange.jeffreylewis.testnet';

/**
 * Creates a listing of an NFT token making it available for receiving offers.
 */
export function createListing(tokenContract: string, tokenId: string, lookingFor: string, tokenMeta: TokenMeta): void {
    
    const sellerAddress = context.sender;

    //TODO: Verify token ownership
    // isTokenOwner(tokenContract, tokenId, sellerAddress);

    // Verify that token is not already listed
    const listing = getListing(tokenContract, tokenId);
    if (listing != null) {
        logging.log("createListing failed: Listing already exists.");
        return;
    }

    // Transfer token ownership to exchange contract as escrow
    // Currently this has to be done outside of exchange contract as predecessor (this contract)
    // does not own the NFT and cannot initiate transfers
    // transferNftToken(tokenContract, tokenId, EXCHANGE_CONTRACT_ID);
    
    // Generate new listing ID
    const newListingId = generateNewListingID();

    // Create the listing record
    const listingInfo: ListingInfo = {
        listingId: newListingId,
        seller: sellerAddress,
        tokenContract: tokenContract,
        tokenId: tokenId,
        lookingFor: lookingFor,
        tokenMeta: {
            title: tokenMeta.title,
            description: tokenMeta.description,
            image: tokenMeta.image
        }
    };
    listingsStorage.push(listingInfo);

    logging.log("createListing successful: Listing ID: " + newListingId.toString());
}

/**
 * Cancel an open listing. Caller must be the seller of this listing.
 */
export function cancelListing(tokenContract: string, tokenId: string): void {
    
    // Verify that the listing actually exists
    const listing = getListing(tokenContract, tokenId);
    if (listing == null) {
        logging.log("cancelListing failed: Listing not found");
        return;
    }

    // Verify that caller is seller of listing
    if (listing.seller != context.sender) {
        logging.log("cancelListing failed: Sender is not seller of this listing");
        return;
    }

    // Refund the listing token
    transferNftToken(listing.tokenContract, listing.tokenId, listing.seller);
    
    // Remove the listing
    removeListing(tokenContract, tokenId);

    logging.log("cancelListing successful");
}

/**
 * Makes an offer for an NFT listing, providing an NFT token as the offer item.
 */
export function makeOffer(tokenContract: string, tokenId: string, listingTokenContract: string, listingTokenId: string, tokenMeta: TokenMeta): void {
    
    const buyerAddress = context.sender;

    //TODO: Verify token ownership
    // isTokenOwner(tokenContract, tokenId, buyerAddress);

    // Verify that the listing token is actually on listing
    const listing = getListing(listingTokenContract, listingTokenId);
    if (listing == null) {
        logging.log("makeOffer failed: Listing not found.");
        return;
    }

    // Verify that offering token is not already on offer
    const offer = getOffer(tokenContract, tokenId);
    if (offer != null) {
        logging.log("makeOffer failed: Token is already on offer.");
        return;
    }

    // Transfer token ownership to exchange contract as escrow
    // Currently this has to be done outside of exchange contract as predecessor (this contract)
    // does not own the NFT and cannot initiate transfers
    // transferNftToken(tokenContract, tokenId, buyerAddress);
    
    // Generate new offer ID
    const newOfferId = generateNewOfferID();

    // Create the offer record
    const offerInfo: OfferInfo = {
        offerId: newOfferId,
        buyer: buyerAddress,
        offerTokenContract: tokenContract,
        offerTokenId: tokenId,
        offerTokenMeta: {
            title: tokenMeta.title,
            description: tokenMeta.description,
            image: tokenMeta.image
        },
        listingId: listing.listingId,
        seller: listing.seller,
        listingTokenContract: listingTokenContract,
        listingTokenId: listingTokenId,
        listingTokenMeta: {
            title: listing.tokenMeta.title,
            description: listing.tokenMeta.description,
            image: listing.tokenMeta.image
        }
    };
    offersStorage.push(offerInfo);
    listing
    logging.log("makeOffer successful: OfferID: " + newOfferId.toString());
}

/**
 * Cancel an open offer. Caller must be the creator/buyer of this offer.
 */
export function cancelOffer(tokenContract: string, tokenId: string): void {
    
    // Verify that the token is actually on offer
    const offer = getOffer(tokenContract, tokenId);
    if (offer == null) {
        logging.log("cancelOffer failed: Listing not found.");
        return;
    }

    // Verify that caller is creator/buyer of that offer
    if (offer.buyer != context.sender) {
        logging.log("cancelOffer failed: Sender is not creator/buyer of this offer.");
        return;
    }
    
    //Refund the offerred token
    transferNftToken(offer.offerTokenContract, offer.offerTokenId, offer.buyer);
    
    // Remove the offer
    removeOffer(tokenContract, tokenId);

    logging.log("cancelOffer successful");
}

/**
 * Accept an offer and executes the exchange transaction. Caller must be the seller of the listing.
 */
 export function acceptOffer(tokenContract: string, tokenId: string): void {
    
    // Verify that the token is actually on offer
    const offer = getOffer(tokenContract, tokenId);
    if (offer == null) {
        logging.log("acceptOffer failed: Offer not found.");
        return;
    }

    // Verify that the listing is still available
    const listing = getListing(offer.listingTokenContract, offer.listingTokenId);
    if (listing == null) {
        logging.log("acceptOffer failed: Listing is no longer available.");
        return;
    }

    // Verify that caller is the seller of the listing
    if (listing.seller != context.sender) {
        logging.log("acceptOffer failed: Sender is not seller of this listing");
        return;
    }

    //Transfer the offer token to the listing seller
    transferNftToken(offer.offerTokenContract, offer.offerTokenId, listing.seller);

    //Transfer the listing token to the offerer
    transferNftToken(listing.tokenContract, listing.tokenId, offer.buyer);

    // Remove the listing
    removeListing(tokenContract, tokenId);

    // Remove the offer
    removeOffer(tokenContract, tokenId);

    logging.log("acceptOffer successful");
}

function removeListing(tokenContract: string, tokenId: string): void {

    let removeIndex = -1;

    for(let i = 0; i < listingsStorage.length; i++) {
        if (listingsStorage[i].tokenContract == tokenContract && listingsStorage[i].tokenId == tokenId) {
            removeIndex = i;
            break;
        }
    }

    if (removeIndex >= 0) {
        listingsStorage.swap_remove(removeIndex);
    }
}

function removeOffer(tokenContract: string, tokenId: string): void {

    let removeIndex = -1;

    for(let i = 0; i < offersStorage.length; i++) {
        if (offersStorage[i].offerTokenContract == tokenContract && offersStorage[i].offerTokenId == tokenId) {
            removeIndex = i;
            break;
        }
    }

    if (removeIndex >= 0) {
        offersStorage.swap_remove(removeIndex);
    }
}

// VIEW METHODS

/**
 * Gets all open listings.
 */
export function getListings(): ListingInfo[] {
    const result = new Array<ListingInfo>(listingsStorage.length);
    for(let i = 0; i < listingsStorage.length; i++) {
        result[i] = listingsStorage[i];
    }
    return result;
}

/**
 * Gets a single listing.
 */
export function getListing(tokenContract: string, tokenId: string): ListingInfo | null {

    for(let i = 0; i < listingsStorage.length; i++) {
        if (listingsStorage[i].tokenContract == tokenContract && listingsStorage[i].tokenId == tokenId) {
            return listingsStorage[i];
        }
    }

    return null;
}

/**
 * Gets all open offers.
 */
export function getOffers(): OfferInfo[] {
    const result = new Array<OfferInfo>(offersStorage.length);
    for(let i = 0; i < offersStorage.length; i++) {
        result[i] = offersStorage[i];
    }
    return result;
}

/**
 * Gets a single offer.
 */
export function getOffer(tokenContract: string, tokenId: string): OfferInfo | null {

    for(let i = 0; i < offersStorage.length; i++) {
        if (offersStorage[i].offerTokenContract == tokenContract && offersStorage[i].offerTokenId == tokenId) {
            return offersStorage[i];
        }
    }

    return null;
}

// export function isTokenOwner(tokenContract: string, tokenId: string, accountId: string): void {
//     const result = false;
//     let api = new NFTContractApi();
//     const promise = api.tokensForOwner(tokenContract, accountId)
//     const ownerTokens = promise.returnAsResult();
//     ownerTokens.forEach(element => {
//         if (element.token_id == tokenId) {
//             result = true;
//             break;
//         }
//     });
//     return result;
// }

export function transferNftToken(tokenContract: string, tokenId: string, toAccountId: string): void {
    let api = new NFTContractApi();
    let promise = api.transfer(tokenContract, tokenId, toAccountId);
    promise.returnAsResult();
}

export function getNftOwnerTokens(tokenContract: string, accountId: string): void {
    let api = new NFTContractApi();
    let promise = api.tokensForOwner(tokenContract, accountId);
    promise.returnAsResult();
}

'''
'''--- contracts/near/swapstation-contract/assembly/models.ts ---
@nearBindgen
export class ListingInfo {
  listingId: i32;
  seller: string;
  tokenContract: string;
  tokenId: string;
  lookingFor: string;
  tokenMeta: TokenMeta;
}

@nearBindgen
export class OfferInfo {
  offerId: i32;
  buyer: string;
  offerTokenContract: string;
  offerTokenId: string;
  offerTokenMeta: TokenMeta;
  listingId: i32;
  seller: string;
  listingTokenContract: string;
  listingTokenId: string;
  listingTokenMeta: TokenMeta;
}

@nearBindgen
export class TokenMeta {
  title: string;
  description: string;
  image: string;
}

'''
'''--- contracts/near/swapstation-contract/assembly/nftContractApi.ts ---
import { logging, ContractPromise, u128 } from "near-sdk-as";

export class NFTContractApi {
  
  /**
   * near call nft.$ID nft_transfer '{"token_id": "0", "receiver_id": "alice.'$ID'", "memo": "transfer ownership"}' --accountId nft.$ID --depositYocto 1
   * @param owner 
   * @returns 
   */
   transfer(tokenContract: string, tokenId: string, toAccountId: string): ContractPromise {
    const yoctoNEAR: u128 = u128.One;
    // const gas: number = 300000000000000; // 300 TGas

    let args: TransferArgs = { token_id: tokenId, receiver_id: toAccountId, memo: "transfer ownership" };
    let promise = ContractPromise.create<TransferArgs>(tokenContract, "nft_transfer", args, 300000000000000, yoctoNEAR);  // Need to attach exactly 1 yoctoNEAR (https://docs.near.org/docs/tutorials/contracts/nfts/approvals)
    logging.log("Call NFT_CONTRACT (" + tokenContract + "): nft_transfer");
    return promise;
  }

  /**
   * near view nft.$ID nft_tokens_for_owner '{"account_id": "'alice.$ID'"}'
   * @param owner 
   * @returns 
   */
  tokensForOwner(tokenContract: string, accountId: string): ContractPromise {
    let args: TokensForOwnerArgs = { account_id: accountId };
    let promise = ContractPromise.create<Uint8Array>(tokenContract, "nft_tokens_for_owner", args.encode(), 3000000000000);
    logging.log("Call NFT_CONTRACT (" + tokenContract + "): nft_tokens_for_owner");
    return promise;
  }
}

@nearBindgen
export class TransferArgs {
  token_id: string;
  receiver_id: string;
  memo: string;
}

@nearBindgen
export class TokensForOwnerArgs {
  account_id: string;
}

'''
'''--- contracts/near/swapstation-contract/assembly/storage.ts ---
import { PersistentMap, PersistentVector, storage } from "near-sdk-as";
import { ListingInfo, OfferInfo } from "./models";

// export const sellerListingsMapStorage = new PersistentMap<string, i32>("sellerListings"); // sellerAddress > listingInfo 
export const listingsStorage = new PersistentVector<ListingInfo>("listings");
export const offersStorage = new PersistentVector<OfferInfo>("offers");

export const generateNewListingID = (): i32 => {
  const newId = storage.getPrimitive<i32>("currentListingId", 0) + 1;
  storage.set("currentListingId", newId);
  return newId;
}

export const generateNewOfferID = (): i32 => {
  const newId = storage.getPrimitive<i32>("currentOfferId", 0) + 1;
  storage.set("currentOfferId", newId);
  return newId;
}

'''
'''--- contracts/near/swapstation-contract/assembly/tsconfig.json ---
{
    "extends": "assemblyscript/std/assembly.json",
    "include": [
      "./**/*.ts",
      "../node_modules/**/*/as_types.d.ts"
    ]
  }
  
'''
'''--- contracts/near/swapstation-contract/package.json ---
{
  "name": "near-nft-exchange",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "asp",
    "build": "asb",
    "login": "near login",
    "deploy": "yarn build && near deploy --accountId exchange.jeffreylewis.testnet --wasmFile build/release/near-nft-exchange.wasm",
    "deploy:dev": "yarn build && near dev-deploy --wasmFile build/release/near-nft-exchange.wasm",
    "deploy:notworking": "yarn build && near deploy"
  },
  "author": "Jeffrey Lewis",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.2.3"
  }
}

'''
'''--- contracts/tron/README.md ---
# Swap Station Contract - TRON

#### Deploying the Contracts to TRON

Pre-requisite: [TronBox](https://github.com/tronprotocol/tronbox)
1. Clone the source code from repo

2. Configure environment variables
Create the file .env in packages/contracts. Place the following content in the file:
```
export PRIVATE_KEY_SHASTA=<wallet private key>
export PRIVATE_KEY_NILE=<wallet private key>
export PRIVATE_KEY_LOCAL=<wallet private key>
```

3. Compile and Deploy the NFT Sample and SwapStation smart contracts

```
From the project root folder:
> cd packages/contracts
> tronbox compile --compile-all
> tronbox migrate --reset --network nile
```

Note: If you would like to skip deploying the NFT sample, edit the file `packages/contracts/migrations/2_deploy_contracts.js` to omit it from `artifacts.require`

3. See [Interacting With the Contracts](#interacting-with-the-contracts) for directly using the contracts or [Running Web Application](#running-web-application) for setting up the frontend.

#### Interacting With the Contracts

You can use TRON Block Explorer to directly interact with the contract:
- **SwapStation Contract** - [TWLxY4ugk4xConePYBjeG8RxqWNmsWkZqc](https://nile.tronscan.org/?_ga=2.227027742.2064602395.1658309195-1802108451.1657443118#/contract/TWLxY4ugk4xConePYBjeG8RxqWNmsWkZqc)
- **Sample NFT Contract** - [TUxk4J3dnoQayyqhoUrehokXhrgyUMK8Db](https://nile.tronscan.org/?_ga=2.227027742.2064602395.1658309195-1802108451.1657443118#/contract/TUxk4J3dnoQayyqhoUrehokXhrgyUMK8Db)

'''
'''--- contracts/tron/migrations/1_initial_migration.js ---
var Migrations = artifacts.require("./Migrations.sol");

module.exports = function(deployer) {
  deployer.deploy(Migrations);
};

'''
'''--- contracts/tron/migrations/2_deploy_contracts.js ---
var MyContract = artifacts.require("./SwapStation.sol");

module.exports = function(deployer) {
  deployer.deploy(MyContract);
};

'''
'''--- contracts/tron/package-lock.json ---
{
  "name": "contracts",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "@openzeppelin/contracts": "^4.7.0"
      }
    },
    "node_modules/@openzeppelin/contracts": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@openzeppelin/contracts/-/contracts-4.7.0.tgz",
      "integrity": "sha512-52Qb+A1DdOss8QvJrijYYPSf32GUg2pGaG/yCxtaA3cu4jduouTdg4XZSMLW9op54m1jH7J8hoajhHKOPsoJFw=="
    }
  },
  "dependencies": {
    "@openzeppelin/contracts": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@openzeppelin/contracts/-/contracts-4.7.0.tgz",
      "integrity": "sha512-52Qb+A1DdOss8QvJrijYYPSf32GUg2pGaG/yCxtaA3cu4jduouTdg4XZSMLW9op54m1jH7J8hoajhHKOPsoJFw=="
    }
  }
}

'''
'''--- contracts/tron/package.json ---
{
  "dependencies": {
    "@openzeppelin/contracts": "^4.7.0"
  }
}

'''
'''--- contracts/tron/tronbox-config.js ---
module.exports = {

};

'''
'''--- contracts/tron/tronbox.js ---
const port = process.env.HOST_PORT || 9090

module.exports = {
  networks: {
    mainnet: {
      privateKey: process.env.PRIVATE_KEY_MAINNET,
      userFeePercentage: 100,
      feeLimit: 1000 * 1e6,
      fullHost: 'https://api.trongrid.io',
      network_id: '1'
    },
    shasta: {
      privateKey: process.env.PRIVATE_KEY_SHASTA,
      userFeePercentage: 50,
      feeLimit: 1000 * 1e6,
      fullHost: 'https://api.shasta.trongrid.io',
      network_id: '2'
    },
    nile: {
      privateKey: '445db8b68fc3d7ccbbcf9205292b9850a95ef806eee516ea7e9791a43eb50d71',
      userFeePercentage: 100,
      feeLimit: 1000 * 1e6,
      fullHost: 'https://api.nileex.io',
      network_id: '3'
    },
    development: {
      // For trontools/quickstart docker image
      privateKey: process.env.PRIVATE_KEY_LOCAL,
      userFeePercentage: 0,
      feeLimit: 1000 * 1e6,
      fullHost: 'http://127.0.0.1:' + port,
      network_id: '9'
    },
    compilers: {
      solc: {
        version: '0.8.6'
      }
    }
  },
  // solc compiler optimize
  solc: {
  //   optimizer: {
  //     enabled: true,
  //     runs: 200
  //   },
  //   evmVersion: 'istanbul'
  }
}

'''
'''--- contracts/tron/tronbox.sample.js ---
const port = process.env.HOST_PORT || 9090

module.exports = {
  networks: {
    mainnet: {
      privateKey: process.env.PRIVATE_KEY_MAINNET,
      userFeePercentage: 100,
      feeLimit: 1000 * 1e6,
      fullHost: 'https://api.trongrid.io',
      network_id: '1'
    },
    shasta: {
      privateKey: process.env.PRIVATE_KEY_SHASTA,
      userFeePercentage: 50,
      feeLimit: 1000 * 1e6,
      fullHost: 'https://api.shasta.trongrid.io',
      network_id: '2'
    },
    nile: {
      privateKey: process.env.PRIVATE_KEY_NILE,
      userFeePercentage: 100,
      feeLimit: 1000 * 1e6,
      fullHost: 'https://api.nileex.io',
      network_id: '3'
    },
    development: {
      // For trontools/quickstart docker image
      privateKey: 'da146374a75310b9666e834ee4ad0866d6f4035967bfc76217c5a495fff9f0d0',
      userFeePercentage: 0,
      feeLimit: 1000 * 1e6,
      fullHost: 'http://127.0.0.1:' + port,
      network_id: '9'
    },
    compilers: {
      solc: {
        version: '0.8.6'
      }
    }
  },
  // solc compiler optimize
  solc: {
  //   optimizer: {
  //     enabled: true,
  //     runs: 200
  //   },
  //   evmVersion: 'istanbul'
  }
}

'''