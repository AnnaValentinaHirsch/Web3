*GitHub Repository "megaserg/monty-hall-near"*

'''--- README.md ---
# Monty Hall game as a NEAR contract 🚪🐐💰

Simple simulation of the [Monty Hall show](https://en.wikipedia.org/wiki/Monty_Hall_problem). You're given the choice of three doors. Behind one door is a prize; behind the other two, goats. You pick a door and the host opens another door, which has a goat. Do you want to switch your choice?
## Usage

### Prepare

1. Clone this repo to a local folder
1. Run `yarn`
1. Run `./scripts/1.dev-deploy.sh`
1. Export the contract ID like `export CONTRACT=dev-123123-123123`
1. If running for the first time, init with `near call $CONTRACT init --accountId $CONTRACT '{"owner": "megaserg.testnet"}'` (substitute your own account)

### Play
- Start the game using the `start_game` method:
```
near call $CONTRACT start_game --accountId $CONTRACT --amount 1
```
`1` stands for `1 NEAR`, minimum payment to play the game. After the game is started, your payment is added to the total pot.
- Make your choice of the door using the `make_turn` method:
```
near call $CONTRACT make_turn --accountId $CONTRACT '{"choice": 2}'
```
Here, `2` stands for door #2.
- Another door will open and you will be offered to switch your choice. Either keep your previous choice, or change it, using the same `make_turn` method:
```
near call $CONTRACT make_turn --accountId $CONTRACT '{"choice": 3}' --gas 75000000000000
```
Here, `3` stands for door #3. For some reason, in case you win, the default "prepaid gas" is not enough and results in a confusing message `Transaction ... had 30000000000000 of attached gas but used 2427967954614 of gas`, so we add the `--gas` argument.
- At this point, all doors will open. If the prize was behind your chosen door, you win! Otherwise, you get nothing. Good luck next time!

### Cleanup
1. Set the account receiving contract account balance: `export BENEFICIARY=<your-account-here>`
1. Run `./scripts/3.cleanup.sh`

### Development
- If you made changes to just the logic, run `./scripts/1.dev-deploy.sh` again.
- If you made changes to the data model, run `./scripts/3.cleanup.sh` and re-run all preparation steps just to be safe.
- If something goes wrong during the game, call `near call $CONTRACT reset --accountId $CONTRACT` to reset the game state to after-init.

### Videos

Enjoy the [demo](https://www.loom.com/share/8eb59ec6a9a5427b9171d82b2e3c8b6a)!

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/montyhall"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build:release

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# comment out the line below to deploy the other example contract
near dev-deploy ./build/release/montyhall.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Call 'view' functions on the contract"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

near view $CONTRACT helloWorld

echo
echo

near view $CONTRACT read '{"key":"some-key"}'

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Call 'change' functions on the contract"
echo ---------------------------------------------------------
echo

# the following line fails with an error because we can't write to storage without signing the message
# --> FunctionCallError(HostError(ProhibitedInView { method_name: "storage_write" }))
# near view $CONTRACT write '{"key": "some-key", "value":"some value"}'
near call $CONTRACT write '{"key": "some-key", "value":"some value"}' --accountId $CONTRACT

echo
echo "now run this script again to see changes made by this file"
exit 0

'''
'''--- scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

It uses the following setup:

```sh
# set your terminal up to have 2 windows, A and B like this:
┌─────────────────────────────────┬─────────────────────────────────┐
│                                 │                                 │
│                                 │                                 │
│                A                │                B                │
│                                 │                                 │
│                                 │                                 │
└─────────────────────────────────┴─────────────────────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands

  _helper scripts_
  ```sh
  1.dev-deploy.sh                # helper: build and deploy contracts
  2.use-contract.sh              # helper: call methods on ContractPromise
  3.cleanup.sh                   # helper: delete build and deploy artifacts
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=               # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linuo-watch-command#191068)

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/montyhall/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/montyhall/__tests__/index.unit.spec.ts ---
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  contract = new Contract()
})

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/montyhall/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/montyhall/assembly/index.ts ---
import { storage, } from "near-sdk-core";
import { logging, RNG, Context, u128, ContractPromiseBatch } from "near-sdk-as";
import { AccountId, ONE_NEAR, asNEAR, XCC_GAS } from "../../utils";

@nearBindgen
export class MontyHallGame {

  private owner: AccountId;
  private current_player: AccountId;
  private pot: u128 = ONE_NEAR;
  private fee: u128 = ONE_NEAR;
  private stage: u32 = 0;
  private winningDoor: u32 = -1;
  private firstChoice: u32 = -1;
  private secondChoice: u32 = -1;

  constructor(owner: AccountId) {
    this.owner = owner;
  };

  // --------------------------------------------------------------------------
  // Public VIEW methods
  // --------------------------------------------------------------------------

  get_owner(): AccountId {
    return this.owner;
  }

  get_pot(): string {
    return asNEAR(this.pot) + " NEAR";
  }

  get_fee(): string {
    return asNEAR(this.fee) + " NEAR";
  }

  @mutateState()
  start_game(): void {
    assert(this.stage == 0, this.current_player + " is currently playing.");

    const fee = this.fee;
    assert(Context.attachedDeposit >= fee, "Playing costs " + asNEAR(fee) + " NEAR");
    this.increase_pot();

    this.current_player = Context.sender;
    this.stage = 1;

    this.make_turn();
  }

  @mutateState()
  make_turn(choice: u32 = -1): void {
    if (this.stage == 0) {
      logging.log("\n\n" +
        "The game is not started. Please call start_game method.\n"
      );
    } else if (this.stage == 1) {
      const rng = new RNG<u32>(1, u32.MAX_VALUE);
      this.winningDoor = rng.next() % 3 + 1;

      // request first choice
      logging.log("\n\n" +
        "Welcome to the Monty Hall game!\n" +
        "Here are three doors. Behind one door is " + this.get_pot() + ".\n" +
        "Behind the other two are goats (TODO: implement NFT goat).\n" +
        "Choose your door:\n" +
        "  🚪    🚪    🚪  \n" +
        "   1     2     3  \n"
      );

      logging.log(
        this.winningDoor.toString() +
          " " + this.firstChoice.toString() +
          " " + this.secondChoice.toString()
      );

      this.stage = 2;
    } else if (this.stage == 2) {
      this.firstChoice = choice;

      var canOpen: Array<u32> = [];
      for (var door = 1; door <= 3; door++) {
        if (door != this.winningDoor && door != this.firstChoice) {
          canOpen.push(door);
        }
      }

      const rng = new RNG<u32>(1, u32.MAX_VALUE);
      const openDoor = canOpen[rng.next() % canOpen.length];
      assert(openDoor != this.winningDoor);
      assert(openDoor != this.firstChoice);

      var doorImgs: Array<string> = ["", "🚪", "🚪", "🚪"];
      doorImgs[openDoor] = "🐐";
      const doorString = "  " + doorImgs[1] + "    " + doorImgs[2] + "    " + doorImgs[3] + "  ";

      this.secondChoice = 6 - this.firstChoice - openDoor;

      // offer second choice
      logging.log("\n\n" +
        "You chose door " + this.firstChoice.toString() + ".\n" +
        "I open door " + openDoor.toString() + " and there's a goat!\n" +
        "Do you want to switch your choice to door " + this.secondChoice.toString() + "?\n" +
        "Choose your door:\n" +
        doorString + "\n" +
        "   1     2     3  \n"
      );

      logging.log(
        this.winningDoor.toString() +
          " " + this.firstChoice.toString() +
          " " + this.secondChoice.toString()
      );

      this.stage = 3;
    } else if (this.stage == 3) {

      if (choice != this.firstChoice && choice != this.secondChoice) {
        logging.log("\n\n" +
          "Door " + choice.toString() + " is already open.\n" +
          "Choose another door!\n"
        );
        return;
      }

      var resultImgs: Array<string> = ["", "🐐", "🐐", "🐐"];
      resultImgs[this.winningDoor] = "💰";
      const doorString = "  " + resultImgs[1] + "    " + resultImgs[2] + "    " + resultImgs[3] + "  ";
      logging.log("\n\n" +
        "You chose door " + choice.toString() + ".\n" +
        "What was behind the doors:\n" +
        doorString + "\n" +
        "   1     2     3  \n"
      );

      if (choice == this.winningDoor) {
        this.win();
      } else {
        this.lose();
      }
      this.reset();
    }
  }

  @mutateState()
  reset(): void {
    this.current_player = "";
    this.stage = 0;
    this.winningDoor = -1;
    this.firstChoice = -1;
    this.secondChoice = -1;
  }

  // this method is only here for the promise callback,
  // it should never be called directly
  @mutateState()
  on_payout_complete(): void {
    this.assert_self();
    this.stage = 0;
    this.pot = ONE_NEAR;
    logging.log("\n\n" +
      "Game over.\n"
    );
  }

  private win(): void {
    logging.log("\n\n" +
      "You (" + this.current_player + ") won " + this.get_pot() + "!\n"
    );

    if (this.current_player.length > 0) {
      const to_winner = ContractPromiseBatch.create(this.current_player);
      const self = Context.contractName;

      // transfer payout to winner
      to_winner.transfer(this.pot);

      // receive confirmation of payout before setting game to inactive
      to_winner.then(self).function_call("on_payout_complete", "{}", u128.Zero, XCC_GAS);
    }
  }

  private lose(): void {
    logging.log("\n\n" +
      "You (" + this.current_player + ") did not win.\n" +
      "The pot is currently " + this.get_pot() + ".\n"
    );
  }

  private increase_pot(): void {
    this.pot = u128.add(this.pot, Context.attachedDeposit);
  }

  private assert_self(): void {
    const caller = Context.predecessor
    const self = Context.contractName
    assert(caller == self, "Only this contract may call itself");
  }
}
'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''