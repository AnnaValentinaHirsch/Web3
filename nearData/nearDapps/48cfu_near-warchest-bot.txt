*GitHub Repository "48cfu/near-warchest-bot"*

'''--- blockchain.py ---
# Define a class to the validators in epoch t, t+1 and t+2
import numpy as np

import requests
import json 

import near_api

YOCTO_CONSTANT = 10**24 #how many yocto in 1 unit

class Blockchain():
  def __init__(self, endpoint_url = 'https://rpc.mainnet.near.org'):
    self.status = None
    self.genesis = None
    self.validators = None

    # RPC hook
    self.provider = near_api.providers.JsonProvider(endpoint_url)
    
    self.update()    
    
  def update(self):
    #load validators and update everything
    self.status = self.get_status_rpc()
    self.genesis = self.get_genesis_config_rpc()
    self.validators = self.get_validators_rpc()

    if None in (self.status, self.genesis, self.validators):
        raise SystemExit('Couldn\'t load lists from RPC')

    #self.min_uptime = genesis['online_min_threshold'][0]/genesis['online_min_threshold'][1]

  def get_current_validators(self):
    return self.get_validators('current')
  def get_next_validators(self):
    return self.get_validators('next')
  def get_proposals(self):
    return self.get_validators('proposals')

  def get_percentage_epoch(self):
    epoch_length = self.genesis['epoch_length']
    epoch_start_height = self.validators['epoch_start_height'] 
    latest_block_height = self.status['sync_info']['latest_block_height']

    return 100.0 * (latest_block_height - epoch_start_height)/epoch_length

  def get_validators(self, epoch = 'current'):
    validators = None
    if epoch == 'current':
        validators = {x['account_id']: x for x in self.validators['current_validators']} 
    elif epoch == 'next':
        validators = {x['account_id']: x for x in self.validators['next_validators']} 
    elif epoch == 'proposals':
        '''
        During the epoch, outcome of staking transactions produce `proposals`, which are collected, in the form of `Proposal`s.
        At the end of every epoch `T`, next algorithm gets executed to determine validators for epoch `T + 2`:

        1. For every validator in `current_validators` determine `num_blocks_produced`, `num_chunks_produced` based on what 
        they produced during the epoch.
        2. Remove validators, for whom `num_blocks_produced < num_blocks_expected * BLOCK_PRODUCER_KICKOUT_THRESHOLD` or 
        `num_chunks_produced < num_chunks_expected * CHUNK_PRODUCER_KICKOUT_THRESHOLD`.
        3. Add validators from `proposals`, if validator is also in `current_validators`, considered stake of the proposal is `0 
        if proposal.stake == 0 else proposal.stake + reward[proposal.account_id]`.
        4. Find seat price `seat_price = findSeatPrice(current_validators - kickedout_validators + proposals, num_seats)`, where 
        each validator gets `floor(stake[v] / seat_price)` seats and `seat_price` is highest integer number such that total number 
        of seats is at least `num_seats`.
        '''
        validators = {x['account_id']: x for x in self.validators['current_proposals']}  
        next_validators = {x['account_id']: x for x in self.validators['next_validators']}
        # append next validators to proposal
        for account_id, properties in next_validators.items():
            # if accound id already in proposals, then don't update it with rewards from next
            if account_id not in validators:
                validators[account_id] = {'account_id': account_id, 'stake': properties['stake']}
            
    return validators

  def get_seat_price(self, epoch = 'current'):
    validators = self.get_validators(epoch)
    stakes = []
    total_stakes = 0
    for properties  in validators.values():
        stakes.append(int(properties['stake']))
        total_stakes += int(properties['stake'])

    """
    Find seat price given set of stakes and number of seats required.
    Seat price is highest integer number such that if you sum `floor(stakes[i] / seat_price)` it is at least `number_seats`.
    """        
    number_seats = self.genesis['num_block_producer_seats']
    assert total_stakes >= number_seats, "Total stakes should be above number of seats"
    left, right = YOCTO_CONSTANT, total_stakes + 1
    while True:
        if left == right - 1:
            return left
        seat_price = (left + right) // 2
        found = False
        current_sum = 0
        for stake in stakes:
            current_sum += stake // seat_price # number of seats for current validator = floor(stake / seat_price)
            if current_sum >= number_seats: # if there are too many seats then the current price (=mid) is too low. Move left threshold up
                left = seat_price
                found = True
                break

        if not found:
            right = seat_price

  def get_status_rpc(self):
    # request data for status
    return self.provider.get_status()

  def get_validators_rpc(self):
    # request data to get validators
    return self.provider.get_validators()
  
  def get_genesis_config_rpc(self):
    # request data to genesis config
    return self.provider.json_rpc('EXPERIMENTAL_genesis_config', [None])

  
'''
'''--- near_api/__init__.py ---
import logging

import near_api.providers
import near_api.serializer
import near_api.transactions
import near_api.account
import near_api.signer

log = logging.getLogger(__name__)

'''
'''--- near_api/account.py ---
import base58
import json
import itertools

from near_api import transactions

# Amount of gas attached by default 1e14.
DEFAULT_ATTACHED_GAS = 100000000000000

class TransactionError(Exception):
    pass

class ViewFunctionError(Exception):
    pass

class Account(object):

    def __init__(self, provider, signer, account_id):
        self._provider = provider
        self._signer = signer
        self._account_id = account_id
        self._account = provider.get_account(account_id)
        self._access_key = provider.get_access_key(account_id, signer._key_pair.encoded_public_key())
        print(account_id, self._account, self._access_key)

    def _sign_and_submit_tx(self, receiver_id, actions):
        self._access_key["nonce"] += 1
        block_hash = self._provider.get_status()['sync_info']['latest_block_hash']
        block_hash = base58.b58decode(block_hash.encode('utf8'))
        serialzed_tx = transactions.sign_and_serialize_transaction(
            receiver_id, self._access_key["nonce"], actions, block_hash, self._signer)
        result = self._provider.send_tx_and_wait(serialzed_tx, 10)
        for outcome in itertools.chain([result['transaction_outcome']], result['receipts_outcome']):
            for log in outcome['outcome']['logs']:
                print("Log:", log)
        if 'Failure' in result['status']:
            raise TransactionError(result['status']['Failure'])
        return result

    @property
    def account_id(self):
        return self._account_id

    @property
    def signer(self):
        return self._signer

    @property
    def provider(self):
        return self._provider

    @property
    def access_key(self):
        return self._access_key

    @property
    def state(self):
        return self._account

    def fetch_state(self):
        """Fetch state for given account."""
        self._account = self.provider.get_account(self.account_id)

    def send_money(self, account_id, amount):
        """Sends funds to given account_id given amount."""
        return self._sign_and_submit_tx(account_id, [transactions.create_transfer_action(amount)])

    def function_call(self, contract_id, method_name, args, gas=DEFAULT_ATTACHED_GAS, amount=0):
        args = json.dumps(args).encode('utf8')
        return self._sign_and_submit_tx(contract_id, [transactions.create_function_call_action(method_name, args, gas, amount)])

    def create_account(self, account_id, public_key, initial_balance):
        actions = [
            transactions.create_create_account_action(),
            transactions.create_full_access_key_action(public_key),
            transactions.create_transfer_action(initial_balance)]
        return self._sign_and_submit_tx(account_id, actions)

    def deploy_contract(self, contract_code):
        return self._sign_and_submit_tx(self._account_id, [transactions.create_deploy_contract_action(contract_code)])

    def stake(self, public_key, amount):
        return self._sign_and_submit_tx(self._account_id, [transactions.create_staking_action(public_key, amount)])

    def create_and_deploy_contract(self, contract_id, public_key, contract_code, initial_balance):
        actions = [
            transactions.create_create_account_action(),
            transactions.create_transfer_action(initial_balance),
            transactions.create_deploy_contract_action(contract_code)] + \
                  ([transactions.create_full_access_key_action(public_key)] if public_key is not None else [])
        return self._sign_and_submit_tx(contract_id, actions)

    def create_deploy_and_init_contract(self, contract_id, public_key, contract_code, initial_balance, args,
                                        gas=DEFAULT_ATTACHED_GAS, init_method_name="new"):
        args = json.dumps(args).encode('utf8')
        actions = [
          transactions.create_create_account_action(),
          transactions.create_transfer_action(initial_balance),
          transactions.create_deploy_contract_action(contract_code),
          transactions.create_function_call_action(init_method_name, args, gas, 0)] + \
                  ([transactions.create_full_access_key_action(public_key)] if public_key is not None else [])
        return self._sign_and_submit_tx(contract_id, actions)

    def view_function(self, contract_id, method_name, args):
        result = self._provider.view_call(contract_id, method_name, json.dumps(args).encode('utf8'))
        if "error" in result:
            raise ViewFunctionError(result["error"])
        result["result"] = json.loads(''.join([chr(x) for x in result["result"]]))
        return result

'''
'''--- near_api/providers.py ---
import requests
import base64
import json

class JsonProviderError(Exception):
    pass

class JsonProvider(object):

    def __init__(self, rpc_addr):
        if isinstance(rpc_addr, tuple):
            self._rpc_addr = "http://%s:%s" % rpc_addr
        else:
            self._rpc_addr = rpc_addr

    def rpc_addr(self):
        return self._rpc_addr

    def json_rpc(self, method, params, timeout=2):
        j = {
            'method': method,
            'params': params,
            'id': 'dontcare',
            'jsonrpc': '2.0'
        }
        r = requests.post(self.rpc_addr(), json=j, timeout=timeout)
        r.raise_for_status()
        content = json.loads(r.content.decode('utf-8'))
        if "error" in content:
            raise JsonProviderError(content["error"])
        return content["result"]

    def send_tx(self, signed_tx):
        return self.json_rpc('broadcast_tx_async', [base64.b64encode(signed_tx).decode('utf8')])

    def send_tx_and_wait(self, signed_tx, timeout):
        return self.json_rpc('broadcast_tx_commit', [base64.b64encode(signed_tx).decode('utf8')], timeout=timeout)

    def get_status(self):
        r = requests.get("%s/status" % self.rpc_addr(), timeout=2)
        r.raise_for_status()
        return json.loads(r.content.decode('utf-8'))

    def get_validators(self):
        return self.json_rpc('validators', [None])

    def query(self, query_object):
        return self.json_rpc('query', query_object)

    def get_account(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_account", "account_id": account_id, "finality": finality})

    def get_access_key_list(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key_list", "account_id": account_id, "finality": finality})

    def get_access_key(self, account_id, public_key, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key", "account_id": account_id,
                                       "public_key": public_key, "finality": finality})

    def view_call(self, account_id, method_name, args, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "call_function", "account_id": account_id,
                                       "method_name": method_name, "args_base64": base64.b64encode(args).decode('utf8'), "finality": finality})

    def get_block(self, block_id):
        return self.json_rpc('block', [block_id])

    def get_chunk(self, chunk_id):
        return self.json_rpc('chunk', [chunk_id])

    def get_tx(self, tx_hash, tx_recipient_id):
        return self.json_rpc('tx', [tx_hash, tx_recipient_id])

    def get_changes_in_block(self, changes_in_block_request):
        return self.json_rpc('EXPERIMENTAL_changes_in_block', changes_in_block_request)

'''
'''--- near_api/serializer.py ---
class BinarySerializer:
    def __init__(self, schema):
        self.array = bytearray()
        self.schema = schema

    def serialize_num(self, value, n_bytes):
        orig_value = value
        assert value >= 0, "Can't serialize negative numbers %d" % value
        for i in range(n_bytes):
            self.array.append(value & 255)
            value //= 256
        assert value == 0, "Value %d has more than %d bytes" % (orig_value, n_bytes)

    def serialize_field(self, value, fieldType):
        try:
            if type(fieldType) == str:
                if fieldType[0] == 'u':
                    self.serialize_num(value, int(fieldType[1:]) // 8)
                elif fieldType == 'string':
                    b = value.encode('utf8')
                    self.serialize_num(len(b), 4)
                    self.array += b
                else:
                    assert False, fieldType
            elif type(fieldType) == list:
                assert len(fieldType) == 1
                if type(fieldType[0]) == int:
                    assert type(value) == bytes, "type(%s) = %s != bytes" % (value, type(value))
                    assert len(value) == fieldType[0], "len(%s) = %s != %s" % (value, len(value), fieldType[0])
                    self.array += bytearray(value)
                else:
                    self.serialize_num(len(value), 4)
                    for el in value:
                        self.serialize_field(el, fieldType[0])
            elif type(fieldType) == dict:
                assert fieldType['kind'] == 'option'
                if value is None:
                    self.serialize_num(0, 1)
                else:
                    self.serialize_num(1, 1)
                    self.serialize_field(value, fieldType['type'])
            elif type(fieldType) == type:
                assert type(value) == fieldType, "%s != type(%s)" % (fieldType, value)
                self.serialize_struct(value)
            else:
                 assert False, type(fieldType)
        except:
            print("Failed to serialize %s as %s" % (value, fieldType))
            raise

    def serialize_struct(self, obj):
        structSchema = self.schema[type(obj)]
        if structSchema['kind'] == 'struct':
            for fieldName, fieldType in structSchema['fields']:
                self.serialize_field(getattr(obj, fieldName), fieldType)
        elif structSchema['kind'] == 'enum':
            name = getattr(obj, structSchema['field'])
            for idx, (fieldName, fieldType) in enumerate(structSchema['values']):
                if fieldName == name:
                    self.serialize_num(idx, 1)
                    self.serialize_field(getattr(obj, fieldName), fieldType)
                    break
        else:
            assert False, structSchema

    def serialize(self, obj):
        self.serialize_struct(obj)
        return bytes(self.array)

'''
'''--- near_api/signer.py ---
import base58
import ed25519
import json

class KeyPair(object):

    def __init__(self, secret_key):
        secret_key = secret_key.split(
            ':')[1] if ':' in secret_key else secret_key
        self._secret_key = ed25519.SigningKey(base58.b58decode(secret_key))
        self._public_key = self._secret_key.get_verifying_key()

    @property
    def public_key(self):
        return self._public_key.to_bytes()

    def encoded_public_key(self):
        return base58.b58encode(self._public_key.to_bytes()).decode('utf-8')

    def sign(self, message):
        return self._secret_key.sign(message)

class Signer(object):

    def __init__(self, account_id, key_pair):
        self._account_id = account_id
        self._key_pair = key_pair

    @property
    def account_id(self):
        return self._account_id

    @property
    def key_pair(self):
        return self._key_pair

    @property
    def public_key(self):
        return self._key_pair.public_key

    def sign(self, message):
        return self._key_pair.sign(message)

    @classmethod
    def from_json(self, j):
        return Signer(j['account_id'], KeyPair(j['private_key']))

    @classmethod
    def from_json_file(self, json_file):
        with open(json_file) as f:
            return Signer.from_json(json.loads(f.read()))

'''
'''--- near_api/transactions.py ---
import hashlib
from ed25519 import SigningKey

from near_api.serializer import BinarySerializer

class Signature:
    pass

class SignedTransaction:
    pass

class Transaction:
    pass

class PublicKey:
    pass

class AccessKey:
    pass

class AccessKeyPermission:
    pass

class FunctionCallPermission:
    pass

class FullAccessPermission:
    pass

class Action:
    pass

class CreateAccount:
    pass

class DeployContract:
    pass

class FunctionCall:
    pass

class Transfer:
    pass

class Stake:
    pass

class AddKey:
    pass

class DeleteKey:
    pass

class DeleteAccount:
    pass

tx_schema = dict([[Signature, { 'kind': 'struct', 'fields': [
            ['keyType', 'u8'],
            ['data', [64]]
        ] }],
[SignedTransaction, { 'kind': 'struct', 'fields': [
            ['transaction', Transaction],
            ['signature', Signature]
        ] }],
[Transaction, { 'kind': 'struct', 'fields': [
            ['signerId', 'string'],
            ['publicKey', PublicKey],
            ['nonce', 'u64'],
            ['receiverId', 'string'],
            ['blockHash', [32]],
            ['actions', [Action]]
        ] }],
[PublicKey, { 'kind': 'struct', 'fields': [
            ['keyType', 'u8'],
            ['data', [32]]
        ] }],
[AccessKey, { 'kind': 'struct', 'fields': [
            ['nonce', 'u64'],
            ['permission', AccessKeyPermission],
        ] }],
[AccessKeyPermission, { 'kind': 'enum', 'field': 'enum', 'values': [
            ['functionCall', FunctionCallPermission],
            ['fullAccess', FullAccessPermission],
        ] }],
[FunctionCallPermission, { 'kind': 'struct', 'fields': [
            ['allowance', { 'kind': 'option', type: 'u128' }],
            ['receiverId', 'string'],
            ['methodNames', ['string']],
        ] }],
[FullAccessPermission, { 'kind': 'struct', 'fields': [] }],
[Action, { 'kind': 'enum', 'field': 'enum', 'values': [
            ['createAccount', CreateAccount],
            ['deployContract', DeployContract],
            ['functionCall', FunctionCall],
            ['transfer', Transfer],
            ['stake', Stake],
            ['addKey', AddKey],
            ['deleteKey', DeleteKey],
            ['deleteAccount', DeleteAccount],
        ] }],
[CreateAccount, { 'kind': 'struct', 'fields': [] }],
[DeployContract, { 'kind': 'struct', 'fields': [
            ['code', ['u8']]
        ] }],
[FunctionCall, { 'kind': 'struct', 'fields': [
            ['methodName', 'string'],
            ['args', ['u8']],
            ['gas', 'u64'],
            ['deposit', 'u128']
        ] }],
[Transfer, { 'kind': 'struct', 'fields': [
            ['deposit', 'u128']
        ] }],
[Stake, { 'kind': 'struct', 'fields': [
            ['stake', 'u128'],
            ['publicKey', PublicKey]
        ] }],
[AddKey, { 'kind': 'struct', 'fields': [
            ['publicKey', PublicKey],
            ['accessKey', AccessKey]
        ] }],
[DeleteKey, { 'kind': 'struct', 'fields': [
            ['publicKey', PublicKey]
        ] }],
[DeleteAccount, { 'kind': 'struct', 'fields': [
            ['beneficiaryId', 'string']
        ] }],
])

def sign_and_serialize_transaction(receiverId, nonce, actions, blockHash, signer):
    assert signer.public_key != None
    assert blockHash != None
    tx = Transaction()
    tx.signerId = signer.account_id
    tx.publicKey = PublicKey()
    tx.publicKey.keyType = 0
    tx.publicKey.data = signer.public_key
    tx.nonce = nonce
    tx.receiverId = receiverId
    tx.actions = actions
    tx.blockHash = blockHash

    msg = BinarySerializer(tx_schema).serialize(tx)
    hash_ = hashlib.sha256(msg).digest()

    signature = Signature()
    signature.keyType = 0
    signature.data = signer.sign(hash_)

    signedTx = SignedTransaction()
    signedTx.transaction = tx
    signedTx.signature = signature

    return BinarySerializer(tx_schema).serialize(signedTx)

def create_create_account_action():
    createAccount = CreateAccount()
    action = Action()
    action.enum = 'createAccount'
    action.createAccount = createAccount
    return action

def create_full_access_key_action(pk):
    permission = AccessKeyPermission()
    permission.enum = 'fullAccess'
    permission.fullAccess = FullAccessPermission()
    accessKey = AccessKey()
    accessKey.nonce = 0
    accessKey.permission = permission
    publicKey = PublicKey()
    publicKey.keyType = 0
    publicKey.data = pk
    addKey = AddKey()
    addKey.accessKey = accessKey
    addKey.publicKey = publicKey
    action = Action()
    action.enum = 'addKey'
    action.addKey = addKey
    return action

def create_delete_access_key_action(pk):
    publicKey = PublicKey()
    publicKey.keyType = 0
    publicKey.data = pk
    deleteKey = DeleteKey()
    deleteKey.publicKey = publicKey
    action = Action()
    action.enum = 'deleteKey'
    action.deleteKey = deleteKey
    return action

def create_transfer_action(amount):
    transfer = Transfer()
    transfer.deposit = amount
    action = Action()
    action.enum = 'transfer'
    action.transfer = transfer
    return action

# TODO: deprecate usage of create_payment_action.
create_payment_action = create_transfer_action

def create_staking_action(amount, pk):
    stake = Stake()
    stake.stake = amount
    stake.publicKey = PublicKey()
    stake.publicKey.keyType = 0
    stake.publicKey.data = pk
    action = Action()
    action.enum = 'stake'
    action.stake = stake
    return action

def create_deploy_contract_action(code):
    deployContract = DeployContract()
    deployContract.code = code
    action = Action()
    action.enum = 'deployContract'
    action.deployContract = deployContract
    return action

def create_function_call_action(methodName, args, gas, deposit):
    functionCall = FunctionCall()
    functionCall.methodName = methodName
    functionCall.args = args
    functionCall.gas = gas
    functionCall.deposit = deposit
    action = Action()
    action.enum = 'functionCall'
    action.functionCall = functionCall
    return action

def sign_create_account_tx(creator_signer, new_account_id, nonce, block_hash):
    action = create_create_account_action()
    return sign_and_serialize_transaction(new_account_id, nonce, [action], block_hash, creator_signer)

def sign_create_account_with_full_access_key_and_balance_tx(creator_key, new_account_id, new_key, balance, nonce, block_hash):
    create_account_action = create_create_account_action()
    full_access_key_action = create_full_access_key_action(new_key.decoded_pk())
    payment_action = create_transfer_action(balance)
    actions = [create_account_action, full_access_key_action, payment_action]
    return sign_and_serialize_transaction(new_account_id, nonce, actions, block_hash, creator_key.account_id, creator_key.decoded_pk(), creator_key.decoded_sk())

def sign_delete_access_key_tx(signer_key, target_account_id, key_for_deletion, nonce, block_hash):
    action = create_delete_access_key_action(key_for_deletion.decoded_pk())
    return sign_and_serialize_transaction(target_account_id, nonce, [action], block_hash, signer_key.account_id, signer_key.decoded_pk(), signer_key.decoded_sk())

def sign_payment_tx(key, to, amount, nonce, blockHash):
    action = create_transfer_action(amount)
    return sign_and_serialize_transaction(to, nonce, [action], blockHash, key.account_id, key.decoded_pk(), key.decoded_sk())

def sign_staking_tx(signer_key, validator_key, amount, nonce, blockHash):
    action = create_staking_action(amount, validator_key.decoded_pk())
    return sign_and_serialize_transaction(signer_key.account_id, nonce, [action], blockHash, signer_key.account_id, signer_key.decoded_pk(), signer_key.decoded_sk())

def sign_deploy_contract_tx(signer_key, code, nonce, blockHash):
    action = create_deploy_contract_action(code)
    return sign_and_serialize_transaction(signer_key.account_id, nonce, [action], blockHash, signer_key.account_id, signer_key.decoded_pk(), signer_key.decoded_sk())

def sign_function_call_tx(signer_key, contract_id, methodName, args, gas, deposit, nonce, blockHash):
    action = create_function_call_action(methodName, args, gas, deposit)
    return sign_and_serialize_transaction(contract_id, nonce, [action], blockHash, signer_key.account_id, signer_key.decoded_pk(), signer_key.decoded_sk())

'''
'''--- setup.py ---
import os
from setuptools import setup, find_packages

META_DATA = dict(
    name = "warchest bot",
    version = "0.0.1",
    license = "MIT",
    python_requires='>3.5.1',
    author = "48cfu",
    
    url = "https://github.com/near/near-api-py",

    packages = find_packages(),

    install_requires = ["requests", "base58", "ed25519", 'numpy']
)

if __name__ == "__main__":
    setup(**META_DATA)

'''
'''--- validators.py ---
# Define a class to the validators in epoch t, t+1 and t+2
import numpy as np

import requests
import json 
#from mpmath import mpf, mp
import math

#import eventlet
#eventlet.monkey_patch()

import near_api

YOCTO_CONSTANT = 10**24 #how many yocto in 1 unit

class Validators():
    '''
    The file path_to_json_private_key_file_master_account should contain account_id and secret_key as json fields
    '''
    def __init__(self, pool_name, path_to_json_private_key_file_master_account, endpoint_url = 'https://rpc.mainnet.near.org'):
        self.pool_name = pool_name

        # RPC hook
        self.provider = near_api.providers.JsonProvider(endpoint_url)

        # create master account signer object
        self.signer = near_api.signer.Signer.from_json_file(path_to_json_private_key_file_master_account)

        # create master account object
        self.master_account = near_api.account.Account(self.provider, self.signer, self.signer.account_id)
        self.master_account.fetch_state()
        #print(self.master_account.state)

    def get_master_account(self):
        return self.master_account

    def get_locked_in_contract(self):
        #self.provider.
        pass

'''
'''--- warchest.py ---
# if Microsoft windows uncomment the following 2 lines
#import gevent.monkey
#gevent.monkey.patch_all()

import requests
import json 

import math
import numpy as np

import time
import sys

from validators import Validators
from blockchain import Blockchain

''' 
RUN PARAMETERS
'''
DEBUG = True
UPDATES_PER_HOUR = 12 # at least 12 for betanet to make sure that bot is executed at least once when epoch percentage is between 95% and 100%
NODE_ENV = 'betanet' # define blockchain environment
CONTRACT_NAME = 'validator_italia_contract'
PATH_TO_JSON_PRIVATE_KEY_FILE_MASTER_ACCOUNT = '/root/.near-credentials/betanet/validator_italia.betanet.json'

AGGRESSIVENESS = 0.4 # between 0 and 1. Eg. 0.1 means lock 10% above estimated seat price
YOCTO_CONSTANT = 10**24 #how many yocto in 1 unit
# Amount of gas attached by default 1e14.
DEFAULT_ATTACHED_GAS = 100000000000000
DEPOSIT_ALL_TOKENS_FROM_MASTERACCOUNT_INTO_CONTRACT = True

''' 
NETWORK PARAMETERS
'''
ENDPOINT_URL = 'https://rpc.' + NODE_ENV + '.near.org'
UPDATE_RATE = 60 * (60 // UPDATES_PER_HOUR) #seconds

'''
Main program
'''
bot_has_been_executed = True

while True:
    try: 
        # create blockchain object    
        near_blockchain = Blockchain(ENDPOINT_URL)
        
        # get percentage of epoch and if greater than 95% then update warchest once
        epoch_percentage = near_blockchain.get_percentage_epoch()

        if DEBUG:
            #print('Current', json.dumps(near_blockchain.get_current_validators(), indent=4, sort_keys=True))
            #print('NExt', json.dumps(near_blockchain.get_next_validators(), indent=4, sort_keys=True))
            #print('Proposals',json.dumps(near_blockchain.get_proposals(), indent=4, sort_keys=True))
            #print('Genesis',json.dumps(near_blockchain.genesis, indent=4, sort_keys=True))
            print('Epoch t     seat price', near_blockchain.get_seat_price(epoch='current'))
            print('Epoch t + 1 seat price', near_blockchain.get_seat_price(epoch='next'))
            print('Epoch t + 2 seat price', near_blockchain.get_seat_price(epoch='proposals'))
            print('Percentage current epoch ', epoch_percentage)

        # Make sure bot runs only once per epoch to avoid spamming       
        if epoch_percentage > 95 and bot_has_been_executed:
            bot_has_been_executed = False
        elif epoch_percentage <= 95:
            bot_has_been_executed = True

        # if in debug mode always run
        if not bot_has_been_executed:
            # create master account
            validators_node = Validators(CONTRACT_NAME, PATH_TO_JSON_PRIVATE_KEY_FILE_MASTER_ACCOUNT, ENDPOINT_URL)
            estimated_seat_price_nextnext_epoch = near_blockchain.get_seat_price(epoch='proposals')
            amount_master_account_unlocked = int(validators_node.get_master_account().state['amount'])

            # ping contract before proceding
            # near call my_validator ping '{}' --accountId user1
            
            validators_node.get_master_account().function_call(
                contract_id = CONTRACT_NAME, 
                method_name = 'ping', 
                args = None, 
                gas = DEFAULT_ATTACHED_GAS)
            

            # if master account has more that 1 NEAR deposit it to contract
            if amount_master_account_unlocked > YOCTO_CONSTANT and DEPOSIT_ALL_TOKENS_FROM_MASTERACCOUNT_INTO_CONTRACT:
                # always try to cover for account cost by subtracting 1 NEAR from the available amount
                to_deposit_in_near = amount_master_account_unlocked - YOCTO_CONSTANT 
                
                # near call my_validator deposit '{}' --accountId user1 --amount AMOUNT_IN_NEAR
                validators_node.get_master_account().function_call(
                    contract_id = CONTRACT_NAME, 
                    method_name = 'deposit', 
                    args = None, 
                    gas = DEFAULT_ATTACHED_GAS, 
                    amount = to_deposit_in_near)

            
            # Total staked balance of the entire pool
            # near view my_validator get_total_staked_balance '{}'
            contract_state = validators_node.provider.get_account(account_id = CONTRACT_NAME)

            # Total locked balance of the entire pool
            amount_contract_account_locked = int(validators_node.get_master_account().view_function(
                                                            contract_id = CONTRACT_NAME, 
                                                            method_name = 'get_total_staked_balance', 
                                                            args = None)['result'])

            # Pool's seat price to bid at epoch t + 2
            to_propose = int(estimated_seat_price_nextnext_epoch * (1 + AGGRESSIVENESS))

            if DEBUG:
                print('Master account state', validators_node.get_master_account().state)
                print('Contract staked balance', amount_contract_account_locked)
                print('To propose at time t + 2', to_propose)
            
            if amount_contract_account_locked < to_propose:
                # low current locked stake. Stake some near token

                # master account UNSTACKED balance
                # near view my_validator get_account_unstaked_balance '{"account_id": "user1"}'
                amount_master_account_unstaked_balance = int(validators_node.get_master_account().view_function(
                                                            contract_id = CONTRACT_NAME, 
                                                            method_name = 'get_account_unstaked_balance', 
                                                            args = {'account_id':  validators_node.get_master_account().account_id})['result'])

                if DEBUG:
                    print('Low current locked stake. Stake some near token!')
                    print('Available unstaked balance', amount_master_account_unstaked_balance)

                to_stake = min(to_propose - amount_contract_account_locked, amount_master_account_unstaked_balance)

                if to_stake > 0:
                    # do the actual staking transaction
                    # near call <POOL_ID> stake '{"amount": "<STAKE_AMOUNT>"}' --accountId <WARCHEST_ID>
                    receipt = validators_node.get_master_account().function_call(
                        contract_id = CONTRACT_NAME, 
                        method_name = 'stake', 
                        args = {'amount': str(to_stake)}, 
                        gas = DEFAULT_ATTACHED_GAS)
                    if DEBUG:
                        print('Staking receipt', receipt)
            elif amount_contract_account_locked > to_propose:
                # high current locked stake. Unstake some near token

                # master account STACKED balance
                # near view my_validator get_account_staked_balance '{"account_id": "user1"}'
                amount_master_account_staked_balance = int(validators_node.get_master_account().view_function(
                                                            contract_id = CONTRACT_NAME, 
                                                            method_name = 'get_account_staked_balance', 
                                                            args = {'account_id':  validators_node.get_master_account().account_id})['result'])

                if DEBUG:
                    print('High current locked stake. Unstake some near token!')
                    print('Available staked balance', amount_master_account_staked_balance)

                to_unstake = min(amount_contract_account_locked - to_propose, amount_master_account_staked_balance)
                if to_unstake > 0:
                    # near call <POOL_ID> stake '{"amount": "<STAKE_AMOUNT>"}' --accountId <WARCHEST_ID>
                    receipt = validators_node.get_master_account().function_call(
                        contract_id = CONTRACT_NAME, 
                        method_name = 'unstake', 
                        args = {'amount': str(to_unstake)}, 
                        gas = DEFAULT_ATTACHED_GAS)

                    if DEBUG:
                        print('Staking receipt', receipt)
        else:
            print('Nothing to do now. Epoch at %s percent' % epoch_percentage)
            

    except:
        # avoid service from dying. retry again in 60 seconds
        # can add logging
        if DEBUG:
            print("Unexpected error:", sys.exc_info()[0])
            print('Waiting 60 seconds before sending other requests')
        time.sleep(60) 
        continue
    if DEBUG:
        print('Waiting %s seconds before sending other requests' % UPDATE_RATE)
    # wait some minutes before sending other RPC requests
    time.sleep(UPDATE_RATE)

'''