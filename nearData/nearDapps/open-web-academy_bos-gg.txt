*GitHub Repository "open-web-academy/bos-gg"*

'''--- README.md ---
# Browser

A framework for reusable components to render and modify SocialDB by Near Social.

## Setup & Development

Initialize repo:
```
yarn
```

Start development version:
```
yarn start
```

## Run with docker:
```
docker pull zavodil/nearbos
docker run -p 3000:3000 zavodil/nearbos
```
Your local BOS gateway: http://localhost:3000/#/

## Widget example

Profile view 

```jsx
let accountId = props.accountId || "eugenethedream";
let profile = socialGetr(`${accountId}/profile`);

(
  <div>
    <img src={profile.image.url}/>
    <span>{profile.name}</span> <span>(@{accountId})</span>
  </div>
);
```

Profile editor 

```jsx
let accountId = context.accountId;

if (!accountId) {
  return "Please sign in with NEAR wallet";
}

const profile = socialGetr(`${accountId}/profile`);

if (profile === null) {
  return "Loading";
}

initState({
  name: profile.name,
  url: profile.image.url,
});

const data = {
  profile: {
    name: state.name,
    image: {
      url: state.url,
    },
  },
};

return (
  <div>
    <div>account = {accountId}</div>
    <div>
      Name:
      <input type="text" value={state.name} />
    </div>
    <div>
      Image URL:
      <input type="text" value={state.url} />
    </div>
    <div>Preview</div>
    <div>
      <img src={state.url} alt="profile image" /> {state.name}
    </div>
    <div>
      <CommitButton data={data}>Save profile</CommitButton>
    </div>
  </div>
);

```

'''
'''--- config/paths.js ---
const path = require("path");

const srcPath = path.resolve(__dirname, "../src");
const distPath = path.resolve(__dirname, "../dist");
const publicPath = path.resolve(__dirname, "../public");
const nodeModulesPath = path.resolve(__dirname, "../node_modules");

module.exports = {
  srcPath,
  distPath,
  publicPath,
  nodeModulesPath,
};

'''
'''--- config/presets/loadPreset.js ---
const { merge } = require("webpack-merge");

const loadPresets = (env = { presets: [] }) => {
  const presets = env.presets || [];
  /** @type {string[]} */
  const mergedPresets = [].concat(...[presets]);
  const mergedConfigs = mergedPresets.map((presetName) =>
    require(`./webpack.${presetName}.js`)(env)
  );

  return merge({}, ...mergedConfigs);
};
module.exports = loadPresets;

'''
'''--- config/presets/webpack.analyze.js ---
const WebpackBundleAnalyzer =
  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;

module.exports = () => ({
  plugins: [new WebpackBundleAnalyzer()],
});

'''
'''--- config/webpack.development.js ---
const path = require("path");
const { HotModuleReplacementPlugin } = require("webpack");

module.exports = () => ({
  devtool: false,
  module: {
    rules: [
      {
        test: /\.(scss|css)$/,
        use: [
          {
            // inject CSS to page
            loader: "style-loader",
          },
          {
            // translates CSS into CommonJS modules
            loader: "css-loader",
          },
          {
            // Run postcss actions
            loader: "postcss-loader",
            options: {
              // `postcssOptions` is needed for postcss 8.x;
              // if you use postcss 7.x skip the key
              postcssOptions: {
                // postcss plugins, can be exported to postcss.config.js
                plugins: function () {
                  return [require("autoprefixer")];
                },
              },
            },
          },
          {
            // compiles Sass to CSS
            loader: "sass-loader",
          },
        ],
      },
    ],
  },
  devServer: {
    open: true,
    static: path.resolve(__dirname, "../dist"),
    port: 3000,
    compress: true,
  },
  plugins: [new HotModuleReplacementPlugin()],
});

'''
'''--- config/webpack.production.js ---
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
const path = require("path");

module.exports = () => {
  return {
    output: {
      path: path.resolve(__dirname, "../dist"),
      publicPath: "./",
      filename: "[name].[contenthash].bundle.js",
    },
    devtool: false,
    module: {
      rules: [
        // {
        //   test: /\.(css)$/,
        //   use: [MiniCssExtractPlugin.loader, "css-loader"],
        //   //   options: {
        //   //     sourceMap: false,
        //   //   },
        // },
        {
          test: /\.(scss|css)$/,
          use: [
            {
              // inject CSS to page
              loader: "style-loader",
            },
            {
              // translates CSS into CommonJS modules
              loader: "css-loader",
            },
            {
              // Run postcss actions
              loader: "postcss-loader",
              options: {
                // `postcssOptions` is needed for postcss 8.x;
                // if you use postcss 7.x skip the key
                postcssOptions: {
                  // postcss plugins, can be exported to postcss.config.js
                  plugins: function () {
                    return [require("autoprefixer")];
                  },
                },
              },
            },
            {
              // compiles Sass to CSS
              loader: "sass-loader",
            },
          ],
        },
      ],
    },
    plugins: [
      new MiniCssExtractPlugin({
        filename: "styles/[name].[contenthash].css",
        chunkFilename: "[id].css",
      }),
    ],
    optimization: {
      minimize: true,
      minimizer: [new CssMinimizerPlugin(), "..."],
      runtimeChunk: {
        name: "runtime",
      },
    },
    performance: {
      hints: false,
      maxEntrypointSize: 512000,
      maxAssetSize: 512000,
    },
  };
};

'''
'''--- package.json ---
{
  "name": "frontend",
  "version": "0.7.0",
  "homepage": "/",
  "private": true,
  "dependencies": {
    "@braintree/sanitize-url": "6.0.0",
    "@monaco-editor/react": "^4.4.6",
    "@near-wallet-selector/core": "^7.4.0",
    "@near-wallet-selector/here-wallet": "^7.4.0",
    "@near-wallet-selector/meteor-wallet": "^7.4.0",
    "@near-wallet-selector/modal-ui": "^7.4.0",
    "@near-wallet-selector/my-near-wallet": "^7.4.0",
    "@near-wallet-selector/near-wallet": "^7.4.0",
    "@near-wallet-selector/neth": "^7.4.0",
    "@near-wallet-selector/sender": "^7.4.0",
    "@web3-onboard/core": "^2.15.0",
    "@web3-onboard/injected-wallets": "^2.7.0",
    "@web3-onboard/ledger": "^2.4.2",
    "@web3-onboard/react": "^2.6.2",
    "@web3-onboard/walletconnect": "^2.3.2",
    "acorn": "^8.8.0",
    "acorn-jsx": "^5.3.2",
    "big.js": "^6.1.1",
    "bn.js": "^5.1.1",
    "bootstrap": "^5.2.1",
    "bootstrap-icons": "^1.9.0",
    "collections": "^5.1.12",
    "deep-equal": "^2.2.0",
    "elliptic": "^6.5.4",
    "error-polyfill": "^0.1.2",
    "ethers": "^5.7.2",
    "idb": "^7.1.1",
    "local-storage": "^2.0.0",
    "mdast-util-find-and-replace": "^2.0.0",
    "near-api-js": "^0.45.1",
    "prettier": "^2.7.1",
    "react": "^18.2.0",
    "react-bootstrap": "^2.5.0",
    "react-bootstrap-typeahead": "^6.0.0",
    "react-dom": "^18.2.0",
    "react-error-boundary": "^3.1.4",
    "react-files": "^3.0.0-alpha.3",
    "react-infinite-scroller": "^1.2.6",
    "react-markdown": "^7.1.0",
    "react-router-dom": "^5.2.0",
    "react-singleton-hook": "^3.1.1",
    "react-syntax-highlighter": "^15.5.0",
    "react-uuid": "^1.0.2",
    "remark-gfm": "^3.0.1",
    "styled-components": "^5.3.6",
    "tweetnacl": "^1.0.3"
  },
  "scripts": {
    "serve": "webpack serve",
    "webpack": "webpack",
    "dev": "npm run serve -- --env mode=development",
    "prod": "npm run webpack -- --env mode=production",
    "prod:analyze": "npm run prod -- --env presets=analyze",
    "build": "npm run prod",
    "start": "npm run dev"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/cli": "^7.15.4",
    "@babel/core": "^7.15.5",
    "@babel/preset-env": "^7.15.4",
    "@babel/preset-react": "^7.14.5",
    "assert": "^2.0.0",
    "babel-loader": "^8.2.2",
    "buffer": "^6.0.3",
    "clean-webpack-plugin": "^4.0.0",
    "copy-webpack-plugin": "^9.0.1",
    "cross-env": "^7.0.3",
    "crypto-browserify": "^3.12.0",
    "css-loader": "^6.2.0",
    "css-minimizer-webpack-plugin": "^3.0.2",
    "html-webpack-plugin": "^5.3.2",
    "https-browserify": "^1.0.0",
    "mini-css-extract-plugin": "^2.2.2",
    "node-sass": "^7.0.3",
    "os-browserify": "^0.3.0",
    "postcss-loader": "^7.0.1",
    "process": "^0.11.10",
    "sass-loader": "^13.1.0",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "style-loader": "^3.2.1",
    "url": "^0.11.0",
    "webpack": "^5.52.0",
    "webpack-bundle-analyzer": "^4.4.2",
    "webpack-cli": "^4.8.0",
    "webpack-dev-server": "^4.1.0",
    "webpack-manifest-plugin": "^5.0.0",
    "webpack-merge": "^5.8.0"
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="favicon.png" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="Welcome to the future of decentralized front-ends with BOS - the blockchain-based protocol that's aims to make Web 3.0 more accessible for all. "
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:image" content="https://bos.gg/assets/card.png">
    <meta property="og:image" content="https://bos.gg/assets/card.png">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Blockchain Operating System (BOS)" />
    <meta property="og:description" content="Welcome to the future of decentralized front-ends with BOS - the blockchain-based protocol that aims to make Web 3.0 more accessible for all. " />
    <link rel="apple-touch-icon" href="favicon.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="manifest.json" />
    <title>Blockchain Operating System (BOS)</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "BOS",
  "name": "Blockchain Operating System (BOS)",
  "icons": [
    {
      "src": "favicon.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#ffffff",
  "background_color": "#000000"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- src/App.js ---
import React, { useCallback, useEffect, useState } from "react";
import "error-polyfill";
import "bootstrap-icons/font/bootstrap-icons.css";
import "@near-wallet-selector/modal-ui/styles.css";
import "bootstrap/dist/js/bootstrap.bundle";
import "App.scss";
import { HashRouter as Router, Link, Route, Switch } from "react-router-dom";
import { NearConfig, StorageCostPerByte, useNear } from "./data/near";
import EditorPage from "./pages/EditorPage";
import ViewPage from "./pages/ViewPage";
import { setupModal } from "@near-wallet-selector/modal-ui";
import EmbedPage from "./pages/EmbedPage";
import { useAccount } from "./data/account";
import Big from "big.js";
import { NavigationWrapper } from "./components/navigation/NavigationWrapper";

export const refreshAllowanceObj = {};

function App(props) {
  const [connected, setConnected] = useState(false);
  const [signedIn, setSignedIn] = useState(false);
  const [signedAccountId, setSignedAccountId] = useState(null);
  const [availableStorage, setAvailableStorage] = useState(null);
  const [walletModal, setWalletModal] = useState(null);
  const [widgetSrc, setWidgetSrc] = useState(null);

  const near = useNear();
  const account = useAccount();
  const accountId = account.accountId;

  const location = window.location;

  useEffect(() => {
    if (
      !location.search.includes("?account_id") &&
      !location.search.includes("&account_id") &&
      (location.search || location.href.includes("/?#"))
    ) {
      window.history.replaceState({}, "/", "/" + location.hash);
    }
  }, [location]);

  useEffect(() => {
    if (!near) {
      return;
    }
    near.selector.then((selector) => {
      setWalletModal(
        setupModal(selector, { contractId: NearConfig.contractName })
      );
    });
  }, [near]);

  const requestSignIn = useCallback(
    (e) => {
      e && e.preventDefault();
      walletModal.show();
      return false;
    },
    [walletModal]
  );

  const logOut = useCallback(async () => {
    if (!near) {
      return;
    }
    const wallet = await (await near.selector).wallet();
    wallet.signOut();
    near.accountId = null;
    setSignedIn(false);
    setSignedAccountId(null);
  }, [near]);

  const refreshAllowance = useCallback(async () => {
    alert(
      "You're out of access key allowance. Need sign in again to refresh it"
    );
    await logOut();
    requestSignIn();
  }, [logOut, requestSignIn]);
  refreshAllowanceObj.refreshAllowance = refreshAllowance;

  useEffect(() => {
    if (!near) {
      return;
    }
    setSignedIn(!!accountId);
    setSignedAccountId(accountId);
    setConnected(true);
  }, [near, accountId]);

  useEffect(() => {
    setAvailableStorage(
      account.storageBalance
        ? Big(account.storageBalance.available).div(StorageCostPerByte)
        : Big(0)
    );
  }, [account]);

  const passProps = {
    refreshAllowance: () => refreshAllowance(),
    setWidgetSrc,
    signedAccountId,
    signedIn,
    connected,
    availableStorage,
    widgetSrc,
    logOut,
    requestSignIn,
    NearConfig,
  };

  return (
    <div className="App">
      <Router basename={process.env.PUBLIC_URL}>
        <Switch>
          <Route path={"/embed/:widgetSrc*"}>
            <EmbedPage {...passProps} />
          </Route>
          <Route path={"/edit/:widgetSrc*"}>
            <NavigationWrapper {...passProps} />
            <EditorPage {...passProps} />
          </Route>
          <Route path={"/:widgetSrc*"}>
            <NavigationWrapper {...passProps} />
            <ViewPage {...passProps} />
          </Route>
        </Switch>
      </Router>
    </div>
  );
}

export default App;

'''
'''--- src/components/Commit.js ---
import React, { useCallback, useEffect, useState } from "react";
import {
  asyncCommit,
  prepareCommit,
  requestPermissionAndCommit,
} from "../data/commitData";
import { computeWritePermission, displayNear, Loading } from "../data/utils";
import Modal from "react-bootstrap/Modal";
import { Markdown } from "./Markdown";
import { StorageCostPerByte, useNear } from "../data/near";
import { ToggleButton, ToggleButtonGroup } from "react-bootstrap";
import { useCache } from "../data/cache";
import { useAccountId } from "../data/account";

const jsonMarkdown = (data) => {
  const json = JSON.stringify(data, null, 2);
  return `\`\`\`json
${json}
\`\`\``;
};

const StorageDomain = {
  page: "commit",
};

const StorageType = {
  WritePermission: "write_permission",
};

export const CommitModal = (props) => {
  const near = useNear();
  const accountId = useAccountId();
  const cache = useCache();

  const [asyncCommitStarted, setAsyncAsyncCommitStarted] = useState(false);
  const [extraStorage, setExtraStorage] = useState(0);
  const [commitInProgress, setCommitInProgress] = useState(false);

  const [lastData, setLastData] = useState(null);
  const [commit, setCommit] = useState(null);

  const [writePermission, setWritePermission] = useState(null);
  const [giveWritePermission, setGiveWritePermission] = useState(true);

  const showIntent = props.show;
  const onHide = props.onHide;
  const onCancel = () => {
    if (props.onCancel) {
      try {
        props.onCancel();
      } catch (e) {
        console.error(e);
      }
    }
    onHide();
  };
  const data = props.data;
  const force = props.force;
  const widgetSrc = props.widgetSrc;

  useEffect(() => {
    if (widgetSrc) {
      setWritePermission(null);
      cache
        .asyncLocalStorageGet(StorageDomain, {
          widgetSrc,
          accountId,
          type: StorageType.WritePermission,
        })
        .then((wp) => setWritePermission(wp));
    } else {
      setWritePermission(false);
    }
  }, [widgetSrc, accountId, cache, showIntent]);

  useEffect(() => {
    setGiveWritePermission(writePermission !== false);
  }, [writePermission]);

  useEffect(() => {
    if (commitInProgress || !showIntent || !accountId || !near) {
      return;
    }
    const jdata = JSON.stringify(data ?? null);
    if (!force && jdata === lastData) {
      return;
    }
    setLastData(jdata);
    setCommit(null);
    prepareCommit(near, accountId, data, force).then(setCommit);
  }, [commitInProgress, data, lastData, force, near, accountId, showIntent]);

  const onCommit = async () => {
    setCommitInProgress(true);

    const newWritePermission =
      giveWritePermission &&
      computeWritePermission(writePermission, commit.data[accountId]);
    cache.localStorageSet(
      StorageDomain,
      {
        widgetSrc,
        accountId,
        type: StorageType.WritePermission,
      },
      newWritePermission
    );
    setWritePermission(newWritePermission);

    const deposit = commit.deposit.add(StorageCostPerByte.mul(extraStorage));
    if (commit.permissionGranted) {
      await asyncCommit(near, commit.data, deposit);
    } else {
      if (accountId === near.accountId) {
        await requestPermissionAndCommit(near, commit.data, deposit);
      } else {
        // No permission for another account and not the owner. Can't commit.
        alert("No permission to commit under given account");
      }
    }
    setCommit(null);
    setLastData(null);
    if (props.onCommit) {
      try {
        props.onCommit(commit.data);
      } catch (e) {
        console.error(e);
      }
    }
    cache.invalidateCache(commit.data);
    onHide();
    setCommitInProgress(false);
  };

  const cantCommit =
    commit && !commit.permissionGranted && accountId !== near.accountId;

  if (
    !commitInProgress &&
    !cantCommit &&
    !asyncCommitStarted &&
    commit &&
    showIntent &&
    writePermission &&
    commit.data
  ) {
    const deposit = commit.deposit.add(StorageCostPerByte.mul(extraStorage));
    if (deposit.eq(0) && commit.permissionGranted) {
      if (
        JSON.stringify(
          computeWritePermission(writePermission, commit.data[accountId])
        ) === JSON.stringify(writePermission)
      ) {
        setAsyncAsyncCommitStarted(true);
        onCommit().then(() => setAsyncAsyncCommitStarted(false));
      }
    }
  }

  const show =
    !!commit && showIntent && !asyncCommitStarted && writePermission !== null;

  return (
    <Modal size="xl" centered scrollable show={show} onHide={onCancel}>
      <Modal.Header closeButton>
        <Modal.Title>Saving data</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        {cantCommit ? (
          <div>
            <h5>
              Can't commit, because the account {near.accountId} doesn't have
              permission to write under pretended account {accountId}
            </h5>
          </div>
        ) : commit ? (
          <div>
            <div>
              {commit.data ? (
                <Markdown text={jsonMarkdown(commit.data)} />
              ) : (
                <h5>No new data to save</h5>
              )}
            </div>
            {commit.data && commit?.deposit?.gt(0) && (
              <div>
                <h6>
                  Required storage deposit{" "}
                  <small className="text-secondary">
                    (can be recovered later)
                  </small>
                </h6>
                <div className="mb-2">
                  {commit.deposit.div(StorageCostPerByte).toFixed(0)} bytes ={" "}
                  {displayNear(commit.deposit)}
                </div>
                <h6>
                  Optional storage deposit{" "}
                  <small className="text-secondary">
                    (can be used to avoid future wallet TX confirmation)
                  </small>
                </h6>
                <div>
                  <ToggleButtonGroup
                    type="radio"
                    name="storageDeposit"
                    value={extraStorage}
                    onChange={setExtraStorage}
                    disabled={commitInProgress}
                  >
                    <ToggleButton
                      id="esd-0"
                      variant="outline-success"
                      value={0}
                    >
                      No Deposit
                    </ToggleButton>
                    <ToggleButton
                      id="esd-5000"
                      variant="outline-success"
                      value={5000}
                    >
                      0.05 NEAR (5Kb)
                    </ToggleButton>
                    <ToggleButton
                      id="esd-20000"
                      variant="outline-success"
                      value={20000}
                    >
                      0.2 NEAR (20Kb)
                    </ToggleButton>
                    <ToggleButton
                      id="esd-100000"
                      variant="outline-success"
                      value={100000}
                    >
                      1 NEAR (100Kb)
                    </ToggleButton>
                  </ToggleButtonGroup>
                </div>
              </div>
            )}
            {!cantCommit && widgetSrc && commit.data && (
              <div className="form-check form-switch">
                <input
                  className="form-check-input"
                  type="checkbox"
                  role="switch"
                  id="dont-ask-for-widget"
                  checked={giveWritePermission}
                  onChange={(e) => {
                    setGiveWritePermission(e.target.checked);
                  }}
                />
                <label
                  className="form-check-label"
                  htmlFor="dont-ask-for-widget"
                >
                  Don't ask again for saving similar data by{" "}
                  <span className="font-monospace">{widgetSrc}</span>
                </label>
              </div>
            )}
          </div>
        ) : (
          Loading
        )}
      </Modal.Body>
      <Modal.Footer>
        <button
          className="btn btn-success"
          disabled={!commit?.data || commitInProgress || cantCommit}
          onClick={(e) => {
            e.preventDefault();
            onCommit();
          }}
        >
          {commitInProgress && Loading} Save Data
        </button>
        <button
          className="btn btn-secondary"
          onClick={onCancel}
          disabled={commitInProgress}
        >
          Close
        </button>
      </Modal.Footer>
    </Modal>
  );
};

export const CommitButton = (props) => {
  const accountId = useAccountId();

  const {
    data,
    children,
    onClick,
    onCommit,
    onCancel,
    disabled,
    widgetSrc,
    force,
    ...rest
  } = props;

  const [computedData, setComputedData] = useState(null);

  return (
    <>
      <button
        {...rest}
        disabled={disabled || !data || !!computedData || !accountId}
        onClick={(e) => {
          e.preventDefault();
          setComputedData(typeof data === "function" ? data() : data);
          if (onClick) {
            onClick();
          }
        }}
      >
        {!!computedData && Loading}
        {children}
      </button>
      <CommitModal
        show={!!computedData}
        widgetSrc={widgetSrc}
        data={computedData}
        force={force}
        onHide={() => setComputedData(null)}
        onCancel={onCancel}
        onCommit={onCommit}
      />
    </>
  );
};

'''
'''--- src/components/ConfirmTransactions.js ---
import React, { useState } from "react";
import Modal from "react-bootstrap/Modal";
import { Markdown } from "./Markdown";
import { displayGas, displayNear, Loading } from "../data/utils";
import { useNear } from "../data/near";
import uuid from "react-uuid";

const jsonMarkdown = (data) => {
  const json = JSON.stringify(data, null, 2);
  return `\`\`\`json
${json}
\`\`\``;
};

export default function ConfirmTransactions(props) {
  const gkey = useState(uuid());
  const near = useNear();
  const [loading, setLoading] = useState(false);

  const onHide = props.onHide;
  const transactions = props.transactions;
  const show = !!transactions;

  return (
    <Modal size="xl" centered scrollable show={show} onHide={onHide}>
      <Modal.Header closeButton>
        <Modal.Title>Confirm Transaction</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        {transactions &&
          transactions.map((transaction, i) => (
            <div key={`${gkey}-${i}`}>
              <div>
                <h4>Transaction #{i + 1}</h4>
              </div>
              <div>
                <span className="text-secondary">Contract ID: </span>
                <span className="font-monospace">
                  {transaction.contractName}
                </span>
              </div>
              <div>
                <span className="text-secondary">Method name: </span>
                <span className="font-monospace">{transaction.methodName}</span>
              </div>
              {transaction.deposit && transaction.deposit.gt(0) && (
                <div>
                  <span className="text-secondary">Deposit: </span>
                  <span className="font-monospace">
                    {displayNear(transaction.deposit)}
                  </span>
                </div>
              )}
              <div>
                <span className="text-secondary">Gas: </span>
                <span className="font-monospace">
                  {displayGas(transaction.gas)}
                </span>
              </div>
              <Markdown text={jsonMarkdown(transaction.args)} />
            </div>
          ))}
      </Modal.Body>
      <Modal.Footer>
        <button
          className="btn btn-success"
          disabled={loading}
          onClick={(e) => {
            e.preventDefault();
            setLoading(true);
            near.sendTransactions(transactions).then(() => {
              setLoading(false);
              onHide();
            });
          }}
        >
          {loading && Loading} Confirm
        </button>
        <button
          className="btn btn-secondary"
          onClick={onHide}
          disabled={loading}
        >
          Close
        </button>
      </Modal.Footer>
    </Modal>
  );
}

'''
'''--- src/components/Editor/OpenModal.js ---
import React, { useState } from "react";
import Modal from "react-bootstrap/Modal";

export default function OpenModal(props) {
  const onHide = props.onHide;
  const onOpen = props.onOpen;
  const onNew = props.onNew;
  const show = props.show;

  const [widgetSrc, setWidgetSrc] = useState("");

  return (
    <Modal centered scrollable show={show} onHide={onHide}>
      <Modal.Header closeButton>
        <Modal.Title>Open widget</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        <label htmlFor="widget-src-input" className="form-label">
          Widget name <span className="text-muted">(or path)</span>
        </label>
        <input
          className="form-control"
          id="widget-src-input"
          type="text"
          value={widgetSrc}
          onChange={(e) =>
            setWidgetSrc(e.target.value.replaceAll(/[^a-zA-Z0-9_.\-\/]/g, ""))
          }
        />
      </Modal.Body>
      <Modal.Footer>
        <button
          className="btn btn-success"
          disabled={!widgetSrc}
          onClick={(e) => {
            e.preventDefault();
            onOpen(widgetSrc);
            setWidgetSrc("");
            onHide();
          }}
        >
          Open
        </button>
        <button
          className="btn btn-outline-success"
          disabled={widgetSrc && widgetSrc.indexOf("/") !== -1}
          onClick={(e) => {
            e.preventDefault();
            onNew(widgetSrc);
            setWidgetSrc("");
            onHide();
          }}
        >
          Create New
        </button>
        <button className="btn btn-secondary" onClick={onHide}>
          Close
        </button>
      </Modal.Footer>
    </Modal>
  );
}

'''
'''--- src/components/Editor/RenameModal.js ---
import React, { useState } from "react";
import Modal from "react-bootstrap/Modal";

export default function RenameModal(props) {
  const onHide = props.onHide;
  const name = props.name;
  const onRename = props.onRename;
  const show = props.show;

  const [newName, setNewName] = useState(name);

  return (
    <Modal centered scrollable show={show} onHide={onHide}>
      <Modal.Header closeButton>
        <Modal.Title>Rename</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        <label htmlFor="rename-input" className="form-label">
          New name
        </label>
        <input
          className="form-control"
          id="rename-input"
          type="text"
          value={newName}
          onChange={(e) =>
            setNewName(e.target.value.replaceAll(/[^a-zA-Z0-9_.\-]/g, ""))
          }
        />
      </Modal.Body>
      <Modal.Footer>
        <button
          className="btn btn-success"
          disabled={!newName || newName === name}
          onClick={(e) => {
            e.preventDefault();
            onRename(newName);
            onHide();
          }}
        >
          Confirm
        </button>
        <button className="btn btn-secondary" onClick={onHide}>
          Close
        </button>
      </Modal.Footer>
    </Modal>
  );
}

'''
'''--- src/components/Markdown.js ---
import gfm from "remark-gfm";
import ReactMarkdown from "react-markdown";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { tomorrow } from "react-syntax-highlighter/dist/esm/styles/prism";
import React from "react";
import mentions from "./remark/mentions";
export const Markdown = (props) => {
  const { onLinkClick, text, onMention, ...rest } = props;
  return (
    <ReactMarkdown
      {...rest}
      plugins={[gfm, mentions]}
      components={{
        strong({ node, children, ...props }) {
          if (onMention && node.properties?.accountId) {
            return onMention(node.properties?.accountId);
          }
          return <strong {...props}>{children}</strong>;
        },
        a: ({ node, ...props }) =>
          onLinkClick ? (
            <a onClick={onLinkClick} {...props} />
          ) : (
            <a target="_blank" {...props} />
          ),
        img: ({ node, ...props }) => <img className="img-fluid" {...props} />,
        blockquote: ({ node, ...props }) => (
          <blockquote className="blockquote" {...props} />
        ),
        table: ({ node, ...props }) => (
          <table className="table table-striped" {...props} />
        ),
        code({ node, inline, className, children, ...props }) {
          const match = /language-(\w+)/.exec(className || "");
          return !inline && match ? (
            <SyntaxHighlighter
              children={String(children).replace(/\n$/, "")}
              style={tomorrow}
              language={match[1]}
              PreTag="div"
              {...props}
            />
          ) : (
            <code className={className} {...props}>
              {children}
            </code>
          );
        },
      }}
    >
      {text}
    </ReactMarkdown>
  );
};

'''
'''--- src/components/SecureIframe.js ---
import React, { useCallback, useEffect, useState } from "react";
import { deepCopy, deepEqual } from "../data/utils";

export default function SecureIframe(allProps) {
  const { className, style, src, srcDoc, title, message, onMessage } = allProps;
  const usedProps = { className, style, src, srcDoc, title };

  const [loaded, setLoaded] = useState(false);
  const [prevMessage, setPrevMessage] = useState(undefined);
  const ref = React.useRef();

  const onMessageEvent = useCallback(
    (event) => {
      if (event.source !== ref.current.contentWindow) {
        return;
      }
      onMessage && onMessage(event.data);
    },
    [ref, onMessage]
  );

  useEffect(() => {
    window.addEventListener("message", onMessageEvent, false);
    return () => {
      window.removeEventListener("message", onMessageEvent, false);
    };
  }, [onMessageEvent]);

  useEffect(() => {
    if (ref.current && loaded && !deepEqual(prevMessage, message)) {
      setPrevMessage(deepCopy(message));
      ref.current.contentWindow.postMessage(message, "*");
    }
  }, [message, ref, loaded, prevMessage]);

  useEffect(() => {
    setLoaded(false);
  }, [src, srcDoc]);

  return (
    <iframe
      {...usedProps}
      ref={ref}
      sandbox="allow-scripts"
      onLoad={() => setLoaded(true)}
    />
  );
}

'''
'''--- src/components/Widget/Widget.js ---
import React, {
  useCallback,
  useEffect,
  useLayoutEffect,
  useState,
} from "react";
import { Parser } from "acorn";
import * as jsx from "acorn-jsx";
import { TGas, useNear } from "../../data/near";
import ConfirmTransactions from "../ConfirmTransactions";
import VM from "../../vm/vm";
import {
  deepCopy,
  deepEqual,
  ErrorFallback,
  isObject,
  isString,
  Loading,
} from "../../data/utils";
import { ErrorBoundary } from "react-error-boundary";
import { useCache } from "../../data/cache";
import { CommitModal } from "../Commit";
import { useAccountId } from "../../data/account";
import Big from "big.js";
import { useEthersProvider } from "../../data/ethersProvider";
import { ethers } from "ethers";
import uuid from "react-uuid";
import { isFunction } from "react-bootstrap-typeahead/types/utils";

const AcornOptions = {
  ecmaVersion: 13,
  allowReturnOutsideFunction: true,
};

const ParsedCodeCache = {};
const JsxParser = Parser.extend(jsx());

const parseCode = (code) => {
  if (code in ParsedCodeCache) {
    return ParsedCodeCache[code];
  }
  return (ParsedCodeCache[code] = JsxParser.parse(code, AcornOptions));
};

const computeSrcOrCode = (src, code, configs) => {
  let srcOrCode = src ? { src } : code ? { code } : null;
  for (const config of configs || []) {
    if (srcOrCode?.src) {
      const src = srcOrCode.src;
      let value = isObject(config?.redirectMap) && config.redirectMap[src];
      if (!value) {
        try {
          value = isFunction(config?.redirect) && config.redirect(src);
        } catch {}
      }
      if (isString(value)) {
        srcOrCode = { src: value };
      } else if (isString(value?.code)) {
        return { code: value.code };
      }
    }
  }
  return srcOrCode;
};

export function Widget(props) {
  const propsSrc = props.src;
  const propsCode = props.code;
  const propsProps = props.props;
  const depth = props.depth || 0;
  const propsConfig = props.config;

  const [nonce, setNonce] = useState(0);
  const [code, setCode] = useState(null);
  const [src, setSrc] = useState(null);
  const [state, setState] = useState(undefined);
  const [cacheNonce, setCacheNonce] = useState(0);
  const [parsedCode, setParsedCode] = useState(null);
  const [context, setContext] = useState({});
  const [vm, setVm] = useState(null);
  const [transactions, setTransactions] = useState(null);
  const [commitRequest, setCommitRequest] = useState(null);
  const globalEthersProvider = useEthersProvider();
  const [ethersProvider, setEthersProvider] = useState(null);
  const [prevVmInput, setPrevVmInput] = useState(null);
  const [configs, setConfigs] = useState(null);
  const [srcOrCode, setSrcOrCode] = useState(null);

  const cache = useCache();
  const near = useNear();
  const accountId = useAccountId();
  const [element, setElement] = useState(null);

  useEffect(() => {
    setEthersProvider(
      globalEthersProvider
        ? new ethers.providers.Web3Provider(globalEthersProvider.provider)
        : null
    );
  }, [globalEthersProvider]);

  useEffect(() => {
    const newConfigs = propsConfig
      ? Array.isArray(propsConfig)
        ? propsConfig
        : [propsConfig]
      : [];
    if (!deepEqual(newConfigs, configs)) {
      setConfigs(newConfigs);
    }
  }, [propsConfig, configs]);

  useEffect(() => {
    const computedSrcOrCode = computeSrcOrCode(propsSrc, propsCode, configs);
    if (!deepEqual(computedSrcOrCode, srcOrCode)) {
      setSrcOrCode(computedSrcOrCode);
    }
  }, [propsSrc, propsCode, configs, srcOrCode]);

  useEffect(() => {
    if (!near) {
      return;
    }
    if (srcOrCode?.src) {
      const src = srcOrCode.src;
      const code = cache.socialGet(
        near,
        src.toString(),
        false,
        undefined,
        undefined,
        () => {
          setNonce(nonce + 1);
        }
      );
      setCode(code);
      setSrc(src);
    } else if (srcOrCode?.code) {
      setCode(srcOrCode.code);
      setSrc(null);
    }
  }, [near, srcOrCode, nonce]);

  useEffect(() => {
    setVm(null);
    setElement(null);
    if (!code) {
      if (code === undefined) {
        setElement(
          <div className="alert alert-danger">
            Source code for "{src}" is not found
          </div>
        );
      }
      return;
    }
    try {
      const parsedCode = parseCode(code);
      setParsedCode({ parsedCode });
    } catch (e) {
      setElement(
        <div className="alert alert-danger">
          Compilation error:
          <pre>{e.message}</pre>
          <pre>{e.stack}</pre>
        </div>
      );
      console.error(e);
    }
  }, [code, src]);

  const confirmTransactions = useCallback(
    (transactions) => {
      if (!near || !transactions || transactions.length === 0) {
        return null;
      }
      transactions = transactions.map((t) => ({
        contractName: t.contractName,
        methodName: t.methodName,
        args: t.args || {},
        deposit: t.deposit ? Big(t.deposit) : Big(0),
        gas: t.gas ? Big(t.gas) : TGas.mul(30),
      }));
      console.log("confirm txs", transactions);
      setTransactions(transactions);
    },
    [near]
  );

  const requestCommit = useCallback(
    (commitRequest) => {
      if (!near) {
        return null;
      }
      console.log("commit requested", commitRequest);
      setCommitRequest(commitRequest);
    },
    [near]
  );

  useEffect(() => {
    if (!near || !parsedCode) {
      return;
    }
    setState(undefined);
    const vm = new VM({
      near,
      code: parsedCode.parsedCode,
      setReactState: setState,
      cache,
      refreshCache: () => {
        setCacheNonce((cacheNonce) => cacheNonce + 1);
      },
      confirmTransactions,
      depth,
      widgetSrc: src,
      requestCommit,
      ethersProvider,
      version: uuid(),
      widgetConfigs: configs,
    });
    setVm(vm);
    return () => {
      vm.stop();
    };
  }, [
    src,
    near,
    parsedCode,
    depth,
    requestCommit,
    confirmTransactions,
    ethersProvider,
    configs,
  ]);

  useEffect(() => {
    if (!near) {
      return;
    }
    setContext({
      loading: false,
      accountId: accountId ?? null,
      widgetSrc: src,
    });
  }, [near, accountId, src]);

  useLayoutEffect(() => {
    if (!vm) {
      return;
    }
    const vmInput = {
      props: propsProps || {},
      context,
      state,
      cacheNonce,
      version: vm.version,
    };
    if (deepEqual(vmInput, prevVmInput)) {
      return;
    }
    setPrevVmInput(deepCopy(vmInput));
    try {
      setElement(vm.renderCode(vmInput) ?? "Execution failed");
    } catch (e) {
      setElement(
        <div className="alert alert-danger">
          Execution error:
          <pre>{e.message}</pre>
          <pre>{e.stack}</pre>
        </div>
      );
      console.error(e);
    }
  }, [vm, propsProps, context, state, cacheNonce, prevVmInput]);

  return element !== null && element !== undefined ? (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onReset={() => {
        setElement(null);
      }}
      resetKeys={[element]}
    >
      <>
        {element}
        {transactions && (
          <ConfirmTransactions
            transactions={transactions}
            onHide={() => setTransactions(null)}
          />
        )}
        {commitRequest && (
          <CommitModal
            show={true}
            widgetSrc={src}
            data={commitRequest.data}
            force={commitRequest.force}
            onHide={() => setCommitRequest(null)}
            onCommit={commitRequest.onCommit}
            onCancel={commitRequest.onCancel}
          />
        )}
      </>
    </ErrorBoundary>
  ) : (
    Loading
  );
}

'''
'''--- src/components/common/buttons/BlueButton.js ---
import React from "react";
import { Button } from "./Button";
import styled from "styled-components";

const StyledButton = styled(Button)`
  background-color: var(--blue-light-9);
  border-color: var(--blue-light-9);
  color: white;
`;

export function BlueButton(props) {
  return <StyledButton {...props}>{props.children}</StyledButton>;
}

'''
'''--- src/components/common/buttons/Button.js ---
import React from "react";
import styled from "styled-components";

const StyledButton = styled.button`
  border-radius: 8px;
  border-style: solid;
  border-width: 1px;
  border-color: transparent;
  padding: 8px 16px;
  font-weight: var(--font-weight-bold);
  display: inline-block;
  height: 40px;
`;

export function Button(props) {
  return (
    <StyledButton
      className={props.className}
      onClick={props.onClick}
      title={props.title}
      disabled={props.disabled}
    >
      {props.children}
    </StyledButton>
  );
}

'''
'''--- src/components/common/buttons/GrayBorderButton.js ---
import React from "react";
import { Button } from "./Button";
import styled from "styled-components";

const StyledButton = styled(Button)`
  background-color: var(--slate-dark-6);
  border-color: var(--slate-dark-8);
  color: white;
`;

export function GrayBorderButton(props) {
  return <StyledButton {...props}>{props.children}</StyledButton>;
}

'''
'''--- src/components/ethers/Web3ConnectButton.js ---
import React from "react";
import { useConnectWallet } from "@web3-onboard/react";

export default function Web3ConnectButton() {
  const [{ wallet, connecting }, connect, disconnect] = useConnectWallet();

  return (
    <div>
      <button
        className={`btn ms-3 ${
          connecting || wallet ? "btn-outline-dark" : "btn-outline-primary"
        }`}
        disabled={connecting}
        onClick={() => (wallet ? disconnect(wallet) : connect())}
        style={wallet ? { marginRight: "317px" } : {}}
      >
        {connecting ? "Connecting" : wallet ? "Disconnect" : "Connect Wallet"}
      </button>
    </div>
  );
}

'''
'''--- src/components/ethers/Web3ConnectStyledButton.js ---
import React from "react";
import { useConnectWallet } from "@web3-onboard/react";

export default function Web3ConnectStyledButton(props) {
  const [{ wallet, connecting }, connect, disconnect] = useConnectWallet();

  return (
    <div>
      <button
        className={`btn ${props.className} ${
          connecting || wallet ? "btn-outline-dark" : "btn-outline-primary"
        }`}
        disabled={connecting}
        onClick={() => (wallet ? disconnect(wallet) : connect())}
      >
        {connecting ? props.connectingLabel ?? "Connecting" : wallet ? props.disconnectLabel ?? "Disconnect" : props.connectLabel ?? "Connect Wallet"}
      </button>
    </div>
  );
}

'''
'''--- src/components/icons/ArrowUpRight.js ---
import React from "react";

export function ArrowUpRight() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className="arrow-up-right"
    >
      <path
        d="M17.25 15.25V6.75H8.75"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M17 7L6.75 17.25"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/Book.js ---
import React from "react";

export function Book() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M19.25 5.75C19.25 5.19772 18.8023 4.75 18.25 4.75H14C12.8954 4.75 12 5.64543 12 6.75V19.25L12.8284 18.4216C13.5786 17.6714 14.596 17.25 15.6569 17.25H18.25C18.8023 17.25 19.25 16.8023 19.25 16.25V5.75Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M4.75 5.75C4.75 5.19772 5.19772 4.75 5.75 4.75H10C11.1046 4.75 12 5.64543 12 6.75V19.25L11.1716 18.4216C10.4214 17.6714 9.40401 17.25 8.34315 17.25H5.75C5.19772 17.25 4.75 16.8023 4.75 16.25V5.75Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/Close.js ---
import React from "react";

export function Close() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M17.25 6.75L6.75 17.25"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M6.75 6.75L17.25 17.25"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/Code.js ---
import React from "react";

export function Code() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M4.75 6.75C4.75 5.64543 5.64543 4.75 6.75 4.75H17.25C18.3546 4.75 19.25 5.64543 19.25 6.75V17.25C19.25 18.3546 18.3546 19.25 17.25 19.25H6.75C5.64543 19.25 4.75 18.3546 4.75 17.25V6.75Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M8.75 10.75L11.25 13L8.75 15.25"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/Fork.js ---
import React from "react";

export function Fork() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M9.25 7C9.25 8.24264 8.24264 9.25 7 9.25C5.75736 9.25 4.75 8.24264 4.75 7C4.75 5.75736 5.75736 4.75 7 4.75C8.24264 4.75 9.25 5.75736 9.25 7Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M19.25 7C19.25 8.24264 18.2426 9.25 17 9.25C15.7574 9.25 14.75 8.24264 14.75 7C14.75 5.75736 15.7574 4.75 17 4.75C18.2426 4.75 19.25 5.75736 19.25 7Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M14.25 17C14.25 18.2426 13.2426 19.25 12 19.25C10.7574 19.25 9.75 18.2426 9.75 17C9.75 15.7574 10.7574 14.75 12 14.75C13.2426 14.75 14.25 15.7574 14.25 17Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M6.75 9.5V10.25C6.75 11.3546 7.64543 12.25 8.75 12.25H12M17.25 9.5V10.25C17.25 11.3546 16.3546 12.25 15.25 12.25H12M12 12.25V14.5"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/Home.js ---
import React from "react";

export function Home() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M6.75024 19.2502H17.2502C18.3548 19.2502 19.2502 18.3548 19.2502 17.2502V9.75025L12.0002 4.75024L4.75024 9.75025V17.2502C4.75024 18.3548 5.64568 19.2502 6.75024 19.2502Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M9.74963 15.7493C9.74963 14.6447 10.6451 13.7493 11.7496 13.7493H12.2496C13.3542 13.7493 14.2496 14.6447 14.2496 15.7493V19.2493H9.74963V15.7493Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/LogOut.js ---
import React from "react";

export function LogOut() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M15.75 8.75L19.25 12L15.75 15.25"
        stroke="#697177"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M19 12H10.75"
        stroke="#697177"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M15.25 4.75H6.75C5.64543 4.75 4.75 5.64543 4.75 6.75V17.25C4.75 18.3546 5.64543 19.25 6.75 19.25H15.25"
        stroke="#697177"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/NearSocialLogo.js ---
import React from "react";

export function NearSocialLogo() {
  return (
    <svg
      width="29"
      height="20"
      viewBox="0 0 29 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M9.55396 17.509L2 9.99996L9.55396 2.49097"
        stroke="#3D7FFF"
        strokeWidth="3"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M19.536 2.49097L27 9.99996L19.536 17.509"
        stroke="#3D7FFF"
        strokeWidth="3"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/Pretend.js ---
import React from "react";

export function Pretend() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      fill="none"
      viewBox="0 0 16 16"
    >
      <path
        strokeWidth="0.3px"
        fill="#697177"
        d="M1.5 1a.5.5 0 0 0-.5.5v3a.5.5 0 0 1-1 0v-3A1.5 1.5 0 0 1 1.5 0h3a.5.5 0 0 1 0 1h-3zM11 .5a.5.5 0 0 1 .5-.5h3A1.5 1.5 0 0 1 16 1.5v3a.5.5 0 0 1-1 0v-3a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 1-.5-.5zM.5 11a.5.5 0 0 1 .5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 1 0 1h-3A1.5 1.5 0 0 1 0 14.5v-3a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v3a1.5 1.5 0 0 1-1.5 1.5h-3a.5.5 0 0 1 0-1h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 1 .5-.5z"
      />
      <path
        strokeWidth="0.3px"
        fill="#697177"
        d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm8-9a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/StopPretending.js ---
import React from "react";

export function StopPretending() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      fill="none"
      viewBox="0 0 16 16"
    >
      <path
        strokeWidth="0.3px"
        fill="#697177"
        d="M13.879 10.414a2.501 2.501 0 0 0-3.465 3.465l3.465-3.465Zm.707.707-3.465 3.465a2.501 2.501 0 0 0 3.465-3.465Zm-4.56-1.096a3.5 3.5 0 1 1 4.949 4.95 3.5 3.5 0 0 1-4.95-4.95ZM11 5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm-9 8c0 1 1 1 1 1h5.256A4.493 4.493 0 0 1 8 12.5a4.49 4.49 0 0 1 1.544-3.393C9.077 9.038 8.564 9 8 9c-5 0-6 3-6 4Z"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/User.js ---
import React from "react";

export function User() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M15.25 8C15.25 9.79493 13.7949 11.25 12 11.25C10.2051 11.25 8.75 9.79493 8.75 8C8.75 6.20507 10.2051 4.75 12 4.75C13.7949 4.75 15.25 6.20507 15.25 8Z"
        stroke="#697177"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M6.84751 19.25H17.1525C18.2944 19.25 19.174 18.2681 18.6408 17.2584C17.8563 15.7731 16.068 14 12 14C7.93201 14 6.14367 15.7731 5.35924 17.2584C4.82597 18.2681 5.70559 19.25 6.84751 19.25Z"
        stroke="#697177"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/UserCircle.js ---
import React from "react";

export function UserCircle() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M19.25 12C19.25 16.0041 16.0041 19.25 12 19.25C7.99594 19.25 4.75 16.0041 4.75 12C4.75 7.99594 7.99594 4.75 12 4.75C16.0041 4.75 19.25 7.99594 19.25 12Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M14.25 10C14.25 11.2426 13.2426 12.25 12 12.25C10.7574 12.25 9.75 11.2426 9.75 10C9.75 8.75736 10.7574 7.75 12 7.75C13.2426 7.75 14.25 8.75736 14.25 10Z"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M7.19745 17C8.34392 15.625 10.0698 14.75 12 14.75C13.9302 14.75 15.6561 15.625 16.8025 17"
        stroke="#9BA1A6"
        strokeWidth="1.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
}

'''
'''--- src/components/icons/Withdraw.js ---
import React from "react";

export function Withdraw() {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        strokeWidth="0.3px"
        d="M14.9634 10.8766C15.2234 11.1366 15.2234 11.5567 14.9634 11.8167L12.4701 14.3067C12.2101 14.5701 11.79 14.5701 11.5301 14.3067L9.03676 11.8167C8.77679 11.5567 8.77679 11.1366 9.03676 10.8766C9.30016 10.6133 9.72011 10.6133 9.98008 10.8766L11.3333 12.2267V6.66667C11.3333 5.1933 12.5266 4 14 4H17.3333C18.8067 4 20 5.1933 20 6.66667V17.3333C20 18.8067 18.8067 20 17.3333 20H6.66667C5.1933 20 4 18.8067 4 17.3333V6.66667C4 5.1933 5.1933 4 6.66667 4H9.33333C9.7 4 10 4.3 10 4.66667C10 5.03333 9.7 5.33333 9.33333 5.33333H6.66667C5.93006 5.33333 5.33333 5.93006 5.33333 6.66667V17.3333C5.33333 18.0699 5.93006 18.6667 6.66667 18.6667H17.3333C18.0699 18.6667 18.6667 18.0699 18.6667 17.3333V6.66667C18.6667 5.93006 18.0699 5.33333 17.3333 5.33333H14C13.2634 5.33333 12.6667 5.93006 12.6667 6.66667V12.2267L14.0199 10.8766C14.28 10.6134 14.7 10.6134 14.9634 10.8766Z"
        fill="#697177"
      />
    </svg>
  );
}

'''
'''--- src/components/navigation/Logotype.js ---
import React from "react";

export function Logotype({ color = "white" }) {
  return <h2>BOS</h2>;
  // return (
  //   <svg
  //     width="155"
  //     height="26"
  //     viewBox="0 0 155 26"
  //     fill="none"
  //     xmlns="http://www.w3.org/2000/svg"
  //     className="logotype"
  //   >
  //     <path
  //       d="M9.55396 20.518L2 13.009L9.55396 5.5"
  //       stroke="#3D7FFF"
  //       strokeWidth="3"
  //       strokeLinecap="round"
  //       strokeLinejoin="round"
  //     />
  //     <path
  //       d="M19.536 5.5L27 13.009L19.536 20.518"
  //       stroke="#3D7FFF"
  //       strokeWidth="3"
  //       strokeLinecap="round"
  //       strokeLinejoin="round"
  //     />
  //     <path
  //       d="M39.82 20.5V6.5H42.5L50.24 16.96H49.68C49.6267 16.5467 49.58 16.1467 49.54 15.76C49.5 15.36 49.46 14.96 49.42 14.56C49.3933 14.1467 49.3667 13.7267 49.34 13.3C49.3267 12.86 49.3133 12.4 49.3 11.92C49.2867 11.4267 49.28 10.8933 49.28 10.32V6.5H52.22V20.5H49.5L41.6 9.94L42.36 9.96C42.4267 10.6533 42.48 11.2467 42.52 11.74C42.5733 12.22 42.6133 12.64 42.64 13C42.6667 13.36 42.6867 13.6733 42.7 13.94C42.7267 14.2067 42.74 14.46 42.74 14.7C42.7533 14.94 42.76 15.1933 42.76 15.46V20.5H39.82ZM60.4752 20.7C59.3285 20.7 58.3285 20.4667 57.4752 20C56.6218 19.5333 55.9552 18.8933 55.4752 18.08C54.9952 17.2667 54.7552 16.3333 54.7552 15.28C54.7552 14.4667 54.8885 13.72 55.1552 13.04C55.4218 12.36 55.7952 11.7733 56.2752 11.28C56.7552 10.7733 57.3218 10.3867 57.9752 10.12C58.6418 9.84 59.3618 9.7 60.1352 9.7C60.8552 9.7 61.5218 9.83333 62.1352 10.1C62.7485 10.3533 63.2752 10.72 63.7152 11.2C64.1685 11.6667 64.5152 12.22 64.7552 12.86C64.9952 13.5 65.1018 14.2 65.0752 14.96L65.0552 15.84H56.5552L56.0952 14.1H62.7152L62.3952 14.46V14.02C62.3685 13.66 62.2485 13.3333 62.0352 13.04C61.8352 12.7467 61.5752 12.52 61.2552 12.36C60.9352 12.2 60.5752 12.12 60.1752 12.12C59.5885 12.12 59.0885 12.2333 58.6752 12.46C58.2752 12.6867 57.9685 13.02 57.7552 13.46C57.5418 13.9 57.4352 14.4333 57.4352 15.06C57.4352 15.7 57.5685 16.2533 57.8352 16.72C58.1152 17.1867 58.5018 17.5533 58.9952 17.82C59.5018 18.0733 60.0952 18.2 60.7752 18.2C61.2418 18.2 61.6685 18.1267 62.0552 17.98C62.4418 17.8333 62.8552 17.58 63.2952 17.22L64.6552 19.12C64.2685 19.4667 63.8418 19.76 63.3752 20C62.9085 20.2267 62.4285 20.4 61.9352 20.52C61.4418 20.64 60.9552 20.7 60.4752 20.7ZM71.1339 20.7C70.2539 20.7 69.4606 20.46 68.7539 19.98C68.0472 19.5 67.4872 18.8467 67.0739 18.02C66.6606 17.1933 66.4539 16.2467 66.4539 15.18C66.4539 14.1133 66.6606 13.1733 67.0739 12.36C67.5006 11.5333 68.0739 10.8867 68.7939 10.42C69.5139 9.94 70.3339 9.7 71.2539 9.7C71.7739 9.7 72.2472 9.78 72.6739 9.94C73.1139 10.0867 73.4939 10.2933 73.8139 10.56C74.1472 10.8267 74.4272 11.1333 74.6539 11.48C74.8806 11.8267 75.0406 12.2 75.1339 12.6L74.5339 12.5V9.92H77.3539V20.5H74.4939V17.96L75.1339 17.9C75.0272 18.2733 74.8539 18.6267 74.6139 18.96C74.3739 19.2933 74.0739 19.5933 73.7139 19.86C73.3672 20.1133 72.9739 20.32 72.5339 20.48C72.0939 20.6267 71.6272 20.7 71.1339 20.7ZM71.9139 18.24C72.4472 18.24 72.9139 18.1133 73.3139 17.86C73.7139 17.6067 74.0206 17.2533 74.2339 16.8C74.4606 16.3333 74.5739 15.7933 74.5739 15.18C74.5739 14.58 74.4606 14.0533 74.2339 13.6C74.0206 13.1467 73.7139 12.7933 73.3139 12.54C72.9139 12.2733 72.4472 12.14 71.9139 12.14C71.3939 12.14 70.9339 12.2733 70.5339 12.54C70.1472 12.7933 69.8406 13.1467 69.6139 13.6C69.3872 14.0533 69.2739 14.58 69.2739 15.18C69.2739 15.7933 69.3872 16.3333 69.6139 16.8C69.8406 17.2533 70.1472 17.6067 70.5339 17.86C70.9339 18.1133 71.3939 18.24 71.9139 18.24ZM80.2013 20.5V9.92H82.9413L83.0413 13.32L82.5613 12.62C82.7213 12.0733 82.9813 11.58 83.3413 11.14C83.7013 10.6867 84.1213 10.3333 84.6013 10.08C85.0946 9.82667 85.6079 9.7 86.1413 9.7C86.3679 9.7 86.5879 9.72 86.8013 9.76C87.0146 9.8 87.1946 9.84667 87.3413 9.9L86.5813 13.02C86.4213 12.94 86.2279 12.8733 86.0013 12.82C85.7746 12.7533 85.5413 12.72 85.3013 12.72C84.9813 12.72 84.6813 12.78 84.4013 12.9C84.1346 13.0067 83.9013 13.1667 83.7013 13.38C83.5013 13.58 83.3413 13.82 83.2213 14.1C83.1146 14.38 83.0613 14.6867 83.0613 15.02V20.5H80.2013ZM100.044 20.7C99.1769 20.7 98.3836 20.5933 97.6636 20.38C96.9569 20.1667 96.3236 19.8533 95.7636 19.44C95.2169 19.0267 94.7236 18.5267 94.2836 17.94L96.1636 15.8C96.8169 16.7067 97.4636 17.3267 98.1036 17.66C98.7569 17.98 99.4636 18.14 100.224 18.14C100.637 18.14 101.004 18.0867 101.324 17.98C101.657 17.86 101.917 17.6933 102.104 17.48C102.29 17.2667 102.384 17.0133 102.384 16.72C102.384 16.5067 102.337 16.3133 102.244 16.14C102.15 15.9533 102.017 15.7933 101.844 15.66C101.67 15.5133 101.464 15.3867 101.224 15.28C100.984 15.16 100.717 15.06 100.424 14.98C100.13 14.8867 99.8103 14.8133 99.4636 14.76C98.7169 14.5867 98.0636 14.38 97.5036 14.14C96.9436 13.8867 96.4769 13.58 96.1036 13.22C95.7303 12.8467 95.4503 12.4267 95.2636 11.96C95.0903 11.4933 95.0036 10.9667 95.0036 10.38C95.0036 9.78 95.1369 9.22667 95.4036 8.72C95.6703 8.2 96.0369 7.75333 96.5036 7.38C96.9836 7.00667 97.5303 6.72 98.1436 6.52C98.7703 6.32 99.4303 6.22 100.124 6.22C100.977 6.22 101.724 6.32 102.364 6.52C103.004 6.70667 103.557 6.98 104.024 7.34C104.504 7.7 104.904 8.14 105.224 8.66L103.324 10.5C103.044 10.1267 102.737 9.81333 102.404 9.56C102.084 9.30667 101.73 9.12 101.344 9C100.97 8.86667 100.584 8.8 100.184 8.8C99.7436 8.8 99.3636 8.86 99.0436 8.98C98.7236 9.08667 98.4703 9.24667 98.2836 9.46C98.1103 9.67333 98.0236 9.93333 98.0236 10.24C98.0236 10.48 98.0836 10.6933 98.2036 10.88C98.3236 11.0667 98.4969 11.2333 98.7236 11.38C98.9503 11.5133 99.2236 11.6333 99.5436 11.74C99.8636 11.8467 100.217 11.94 100.604 12.02C101.337 12.1667 101.997 12.36 102.584 12.6C103.17 12.84 103.67 13.1333 104.084 13.48C104.51 13.8133 104.837 14.2133 105.064 14.68C105.29 15.1333 105.404 15.6467 105.404 16.22C105.404 17.1667 105.177 17.9733 104.724 18.64C104.27 19.3067 103.644 19.82 102.844 20.18C102.044 20.5267 101.11 20.7 100.044 20.7ZM112.641 20.7C111.561 20.7 110.594 20.4667 109.741 20C108.901 19.52 108.234 18.8667 107.741 18.04C107.261 17.2133 107.021 16.2667 107.021 15.2C107.021 14.1333 107.261 13.1933 107.741 12.38C108.234 11.5533 108.901 10.9 109.741 10.42C110.594 9.94 111.561 9.7 112.641 9.7C113.707 9.7 114.661 9.94 115.501 10.42C116.354 10.9 117.021 11.5533 117.501 12.38C117.981 13.1933 118.221 14.1333 118.221 15.2C118.221 16.2667 117.981 17.2133 117.501 18.04C117.021 18.8667 116.354 19.52 115.501 20C114.661 20.4667 113.707 20.7 112.641 20.7ZM112.641 18.22C113.161 18.22 113.627 18.0933 114.041 17.84C114.454 17.5733 114.774 17.2133 115.001 16.76C115.241 16.2933 115.361 15.7733 115.361 15.2C115.361 14.6133 115.241 14.0933 115.001 13.64C114.774 13.1733 114.454 12.8133 114.041 12.56C113.627 12.2933 113.161 12.16 112.641 12.16C112.107 12.16 111.634 12.2933 111.221 12.56C110.807 12.8267 110.481 13.1867 110.241 13.64C110.001 14.0933 109.887 14.6133 109.901 15.2C109.887 15.7733 110.001 16.2933 110.241 16.76C110.481 17.2133 110.807 17.5733 111.221 17.84C111.634 18.0933 112.107 18.22 112.641 18.22ZM124.958 20.7C123.944 20.7 123.038 20.46 122.238 19.98C121.438 19.5 120.804 18.8467 120.338 18.02C119.884 17.1933 119.658 16.2533 119.658 15.2C119.658 14.16 119.884 13.2267 120.338 12.4C120.804 11.56 121.438 10.9 122.238 10.42C123.038 9.94 123.944 9.7 124.958 9.7C125.904 9.7 126.771 9.87333 127.558 10.22C128.344 10.5667 128.958 11.0467 129.398 11.66L127.838 13.54C127.651 13.2867 127.418 13.06 127.138 12.86C126.858 12.6467 126.551 12.48 126.218 12.36C125.898 12.24 125.564 12.18 125.218 12.18C124.671 12.18 124.184 12.3133 123.758 12.58C123.344 12.8333 123.018 13.1867 122.778 13.64C122.538 14.0933 122.418 14.6133 122.418 15.2C122.418 15.7733 122.538 16.2867 122.778 16.74C123.031 17.18 123.371 17.54 123.798 17.82C124.224 18.0867 124.704 18.22 125.238 18.22C125.584 18.22 125.911 18.1733 126.218 18.08C126.524 17.9733 126.811 17.82 127.078 17.62C127.358 17.42 127.611 17.18 127.838 16.9L129.378 18.78C128.924 19.3533 128.298 19.82 127.498 20.18C126.698 20.5267 125.851 20.7 124.958 20.7ZM131.437 20.5V9.92H134.277V20.5H131.437ZM132.837 7.74C132.291 7.74 131.864 7.60667 131.557 7.34C131.251 7.07333 131.097 6.69333 131.097 6.2C131.097 5.74667 131.251 5.38 131.557 5.1C131.877 4.80667 132.304 4.66 132.837 4.66C133.384 4.66 133.811 4.8 134.117 5.08C134.424 5.34667 134.577 5.72 134.577 6.2C134.577 6.66667 134.417 7.04 134.097 7.32C133.791 7.6 133.371 7.74 132.837 7.74ZM141.271 20.7C140.391 20.7 139.597 20.46 138.891 19.98C138.184 19.5 137.624 18.8467 137.211 18.02C136.797 17.1933 136.591 16.2467 136.591 15.18C136.591 14.1133 136.797 13.1733 137.211 12.36C137.637 11.5333 138.211 10.8867 138.931 10.42C139.651 9.94 140.471 9.7 141.391 9.7C141.911 9.7 142.384 9.78 142.811 9.94C143.251 10.0867 143.631 10.2933 143.951 10.56C144.284 10.8267 144.564 11.1333 144.791 11.48C145.017 11.8267 145.177 12.2 145.271 12.6L144.671 12.5V9.92H147.491V20.5H144.631V17.96L145.271 17.9C145.164 18.2733 144.991 18.6267 144.751 18.96C144.511 19.2933 144.211 19.5933 143.851 19.86C143.504 20.1133 143.111 20.32 142.671 20.48C142.231 20.6267 141.764 20.7 141.271 20.7ZM142.051 18.24C142.584 18.24 143.051 18.1133 143.451 17.86C143.851 17.6067 144.157 17.2533 144.371 16.8C144.597 16.3333 144.711 15.7933 144.711 15.18C144.711 14.58 144.597 14.0533 144.371 13.6C144.157 13.1467 143.851 12.7933 143.451 12.54C143.051 12.2733 142.584 12.14 142.051 12.14C141.531 12.14 141.071 12.2733 140.671 12.54C140.284 12.7933 139.977 13.1467 139.751 13.6C139.524 14.0533 139.411 14.58 139.411 15.18C139.411 15.7933 139.524 16.3333 139.751 16.8C139.977 17.2533 140.284 17.6067 140.671 17.86C141.071 18.1133 141.531 18.24 142.051 18.24ZM150.358 20.5V5.7H153.198V20.5H150.358Z"
  //       fill={color}
  //     />
  //   </svg>
  // );
}

'''
'''--- src/components/navigation/NavigationButton.js ---
import React from "react";
import styled from "styled-components";
import { NavLink } from "react-router-dom";

const StyledNavigationButton = styled.div`
  a {
    color: var(--slate-dark-11);
    font-size: 16px;
    padding: 10px;
    border-radius: 8px;
    font-weight: var(--font-weight-bold);
    text-transform: uppercase;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;

    &:hover,
    &.active {
      color: white;
      text-decoration: none;
      background-color: var(--slate-dark-6);
    }
  }
  &.disabled {
    opacity: 0.5;
  }
`;

export function NavigationButton(props) {
  return (
    <StyledNavigationButton className={props.disabled ? "disabled" : ""}>
      {props.route ? (
        <NavLink
          onClick={(e) => {
            if (props.disabled) {
              e.preventDefault();
            }
          }}
          to={props.route}
          exact={true}
        >
          {props.children}
        </NavLink>
      ) : (
        <a href={props.href} target="_blank" rel="noopener noreferrer">
          {props.children}
        </a>
      )}
    </StyledNavigationButton>
  );
}

'''
'''--- src/components/navigation/NavigationWrapper.js ---
import React, { useState, useEffect } from "react";
import { DesktopNavigation } from "./desktop/DesktopNavigation";
import { MobileNavigation } from "./mobile/MobileNavigation";

export function NavigationWrapper(props) {
  return (
    <>
      <DesktopNavigation {...props} />
      <div style={{ height: "70px" }} />
    </>
  );
}

'''
'''--- src/components/navigation/NotificationWidget.js ---
import React from "react";
import styled from "styled-components";
import { Widget } from "../Widget/Widget";

const StyledNotificationWidget = styled.div`
  margin: 0 15px;
  background-color: var(--slate-dark-5);
  height: 40px;
  width: 40px;
  border-radius: 50%;

  > div,
  a {
    width: 100%;
    height: 100%;
  }

  a {
    color: var(--slate-dark-11) !important;
    display: flex;
    align-items: center;
    justify-content: center;

    i {
      font-size: 18px !important;
    }
  }

  :hover {
    a,
    i {
      color: white;
    }
  }
`;

export function NotificationWidget({ notificationButtonSrc }) {
  return (
    <StyledNotificationWidget className="nav-notification-widget">
      <Widget src={notificationButtonSrc} />
    </StyledNotificationWidget>
  );
}

'''
'''--- src/components/navigation/PretendModal.js ---
import React, { useState } from "react";
import Modal from "react-bootstrap/Modal";
import { NearConfig } from "../../data/near";
import { useAccount } from "../../data/account";
import { Widget } from "../Widget/Widget";

export default function PretendModal(props) {
  const account = useAccount();
  const onHide = props.onHide;
  const show = props.show;

  const [accountId, setAccountId] = useState("");

  return (
    <Modal centered show={show} onHide={onHide}>
      <Modal.Header closeButton>
        <Modal.Title>Pretend to be another account</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        <div>
          <label htmlFor="widget-src-input" className="form-label">
            Pretend to be account ID:
          </label>
          <input
            className="form-control"
            id="widget-src-input"
            type="text"
            value={accountId}
            onChange={(e) =>
              setAccountId(
                e.target.value.toLowerCase().replaceAll(/[^a-z0-9_.\-]/g, "")
              )
            }
          />
        </div>
        <div className="mt-2">
          <Widget
            src={NearConfig.widgets.profileInlineBlock}
            props={{ accountId }}
          />
        </div>
      </Modal.Body>
      <Modal.Footer>
        <button
          className="btn btn-success"
          disabled={!accountId || !account.startPretending}
          onClick={(e) => {
            e.preventDefault();
            account.startPretending(accountId);
            setAccountId("");
            onHide();
          }}
        >
          Pretend
        </button>
        <button className="btn btn-secondary" onClick={onHide}>
          Cancel
        </button>
      </Modal.Footer>
    </Modal>
  );
}

'''
'''--- src/components/navigation/SignInButton.js ---
import React from "react";
import { GrayBorderButton } from "../common/buttons/GrayBorderButton";

export function SignInButton(props) {
  return (
    <GrayBorderButton className="nav-sign-in-btn" onClick={props.onSignIn}>
      Sign In
    </GrayBorderButton>
  );
}

'''
'''--- src/components/navigation/desktop/DesktopNavigation.js ---
import React from "react";
import styled from "styled-components";
import { Link } from "react-router-dom";
import { Logotype } from "../Logotype";
import { NavigationButton } from "../NavigationButton";
import { ArrowUpRight } from "../../icons/ArrowUpRight";
import { SignInButton } from "../SignInButton";
import { UserDropdown } from "./UserDropdown";
import { DevActionsDropdown } from "./DevActionsDropdown";
import { NotificationWidget } from "../NotificationWidget";
import Web3ConnectButton from "../../ethers/Web3ConnectButton";

const StyledNavigation = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  width: 100%;
  z-index: 1000;
  padding: 12px 0;
  background: linear-gradient(
      252.46deg,
      rgba(82, 0, 255, 0.32) 6.76%,
      rgba(255, 0, 154, 0) 94.32%
    ),
    #000;

  .user-section {
    margin-left: auto;
    > button {
      font-size: 14px;
    }
  }

  .container-fluid {
    display: flex;
    align-items: center;

    .navigation-section {
      margin-left: 50px;
      display: flex;

      > div {
        > a {
          margin-right: 20px;
        }
      }
    }

    .user-section {
      display: flex;
      align-items: center;

      .nav-create-btn {
        margin-left: 10px;
      }
    }

    .arrow-up-right {
      margin-left: 4px;
    }
  }
`;

export function DesktopNavigation(props) {
  return (
    <StyledNavigation>
      <div className="container-fluid">
        <Link to="/" className="logo-link">
          <Logotype />
        </Link>
        <div className="navigation-section">
          <NavigationButton route="/">Home</NavigationButton>
          <NavigationButton route="/edit">Editor</NavigationButton>
          <NavigationButton href="https://docs.bos.gg">
            Documentation
            <ArrowUpRight />
          </NavigationButton>
        </div>
        <div className="user-section">
          <DevActionsDropdown {...props} />
          <Web3ConnectButton />
        </div>
      </div>
    </StyledNavigation>
  );
}

'''
'''--- src/components/navigation/desktop/DevActionsDropdown.js ---
import React from "react";
import styled from "styled-components";
import { Link } from "react-router-dom";
import { Fork } from "../../icons/Fork";
import { Code } from "../../icons/Code";
import { useAccount } from "../../../data/account";

const StyledDropdown = styled.div`
  .dropdown-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--slate-dark-5);
    border-radius: 50px;
    outline: none;
    border: 0;
    width: 40px;
    height: 40px;

    &:after {
      display none;
    }

    .menu {
      width: 18px;
      height: 24px;
      display: flex;
      flex-direction: column;
      justify-content: space-evenly;
  
      div {
        background-color: var(--slate-dark-11);;
        height: 2px;
        width: 100%;
        border-radius: 30px;
      }
    }

    :hover {
      .menu {
        div {
          background-color: white;
        }
      }
    }
  }

  ul {
    background-color: var(--slate-dark-5);
    width: 100%;

    li {
      padding: 0 6px;
    }

    button,
    a {
      color: var(--slate-dark-11);
      display: flex;
      align-items: center;
      border-radius: 8px;
      padding: 12px;

      :hover,
      :focus {
        text-decoration: none;
        background-color: var(--slate-dark-1);
        color: white;

        svg {
          path {
            stroke: white;
          }
        }
      }

      svg {
        margin-right: 7px;
        path {
          stroke: var(--slate-dark-9);
        }
      }
    }
  }
`;

export function DevActionsDropdown(props) {
  const account = useAccount();

  if (props.widgetSrc?.edit || props.widgetSrc?.view) {
    return (
      <StyledDropdown className="dropdown">
        <button
          className="dropdown-toggle"
          type="button"
          id="dropdownMenu2222"
          data-bs-toggle="dropdown"
          aria-expanded="false"
        >
          <div className="menu">
            <div />
            <div />
            <div />
          </div>
        </button>
        <ul className="dropdown-menu" aria-labelledby="dropdownMenu2222">
          {props.widgetSrc?.edit && (
            <li className="text-nowrap">
              <Link to={`/edit/${props.widgetSrc?.edit}`}>
                <Fork />
                {props.widgetSrc.edit.startsWith(`${account.accountId}/widget/`)
                  ? "Edit widget"
                  : "Fork widget"}
              </Link>
            </li>
          )}
          {props.widgetSrc?.view && (
            <li className="text-nowrap">
              <Link
                to={`/${props.NearConfig.widgets.viewSource}?src=${props.widgetSrc?.view}`}
              >
                <Code />
                View source
              </Link>
            </li>
          )}
        </ul>
      </StyledDropdown>
    );
  } else {
    return null;
  }
}

'''
'''--- src/components/navigation/desktop/EditorSignIn.js ---
import { SignInButton } from "../SignInButton";
import { UserDropdown } from "./UserDropdown";
import React from "react";

export default function EditorSignIn(props) {
  return props.signedIn ? (
    <UserDropdown {...props} />
  ) : (
    <div>
      <SignInButton onSignIn={() => props.requestSignIn()} />
      <p>Sign in with a NEAR account to save (BOS uses the NEAR blockchain underneath)</p>
  </div>
  );
}

'''
'''--- src/components/navigation/desktop/UserDropdown.js ---
import React, { useCallback } from "react";
import { Widget } from "../../Widget/Widget";
import styled from "styled-components";
import { User } from "../../icons/User";
import { LogOut } from "../../icons/LogOut";
import { Withdraw } from "../../icons/Withdraw";
import { NavLink } from "react-router-dom";
import { TGas, useNear } from "../../../data/near";
import { useAccount } from "../../../data/account";
import PretendModal from "../PretendModal";
import { Pretend } from "../../icons/Pretend";
import { StopPretend, StopPretending } from "../../icons/StopPretending";

const StyledDropdown = styled.div`
  button,
  a {
    font-weight: var(--font-weight-medium);
  }
  .dropdown-toggle {
    display: flex;
    align-items: center;
    text-align: left;
    background-color: var(--slate-dark-5);
    border-radius: 50px;
    outline: none;
    border: 0;

    &:after {
      margin: 0 15px;
      border-top-color: var(--slate-dark-11);
    }

    img {
      border-radius: 50% !important;
    }

    .profile-info {
      margin: 5px 10px;
      line-height: normal;
      max-width: 140px;

      .profile-name,
      .profile-username {
        text-overflow: ellipsis;
        overflow: hidden;
      }

      .profile-name {
        color: var(--slate-dark-12);
      }
      .profile-username {
        color: var(--slate-dark-11);
      }
    }
  }

  ul {
    background-color: var(--slate-dark-5);
    width: 100%;

    li {
      padding: 0 6px;
    }

    button,
    a {
      color: var(--slate-dark-11);
      display: flex;
      align-items: center;
      border-radius: 8px;
      padding: 12px;

      :hover,
      :focus {
        text-decoration: none;
        background-color: var(--slate-dark-1);
        color: white;

        svg {
          path {
            stroke: white;
          }
        }
      }

      svg {
        margin-right: 7px;
        min-width: 24px;
        path {
          stroke: var(--slate-dark-9);
        }
      }
    }
  }
`;

export function UserDropdown(props) {
  const near = useNear();
  const account = useAccount();

  const withdrawStorage = useCallback(async () => {
    await near.contract.storage_withdraw({}, TGas.mul(30).toFixed(0), "1");
  }, [near]);

  const [showPretendModal, setShowPretendModal] = React.useState(false);

  return (
    <>
      <StyledDropdown className="dropdown">
        <button
          className="dropdown-toggle"
          type="button"
          id="dropdownMenu2222"
          data-bs-toggle="dropdown"
          aria-expanded="false"
        >
          <Widget
            src={props.NearConfig.widgets.profileImage}
            props={{
              accountId: account.accountId,
              className: "d-inline-block",
              style: { width: "40px", height: "40px" },
            }}
          />
          <div className="profile-info">
            {props.NearConfig.widgets.profileName && (
              <div className="profile-name">
                <Widget src={props.NearConfig.widgets.profileName} />
              </div>
            )}
            <div className="profile-username">{account.accountId}</div>
          </div>
        </button>
        <ul
          className="dropdown-menu"
          aria-labelledby="dropdownMenu2222"
          style={{ minWidth: "fit-content" }}
        >
          <li>
            <NavLink
              className="dropdown-item"
              type="button"
              to={`/${props.NearConfig.widgets.profilePage}?accountId=${account.accountId}`}
            >
              <User />
              My Profile
            </NavLink>
          </li>
          <li>
            <button
              className="dropdown-item"
              type="button"
              onClick={() => withdrawStorage()}
            >
              <Withdraw />
              Withdraw {props.availableStorage.div(1000).toFixed(2)}kb
            </button>
          </li>
          {account.pretendAccountId ? (
            <li>
              <button
                className="dropdown-item"
                type="button"
                disabled={!account.startPretending}
                onClick={() => account.startPretending(undefined)}
              >
                <StopPretending />
                Stop pretending
              </button>
            </li>
          ) : (
            <li>
              <button
                className="dropdown-item"
                type="button"
                onClick={() => setShowPretendModal(true)}
              >
                <Pretend />
                Pretend to be another account
              </button>
            </li>
          )}
          <li>
            <button
              className="dropdown-item"
              type="button"
              onClick={() => props.logOut()}
            >
              <LogOut />
              Sign Out
            </button>
          </li>
        </ul>
      </StyledDropdown>
      <PretendModal
        show={showPretendModal}
        onHide={() => setShowPretendModal(false)}
      />
    </>
  );
}

'''
'''--- src/components/navigation/mobile/Menu.js ---
import React from "react";
import styled from "styled-components";
import { Close } from "../../icons/Close";
import { Home } from "../../icons/Home";
import { Book } from "../../icons/Book";
import { Code } from "../../icons/Code";
import { LogOut } from "../../icons/LogOut";
import { Fork } from "../../icons/Fork";
import { UserCircle } from "../../icons/UserCircle";
import { Widget } from "../../Widget/Widget";
import { NavigationButton } from "../NavigationButton";
import { SignInButton } from "../SignInButton";
import { Link } from "react-router-dom";

const StyledMenu = styled.div`
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  display: flex;
  transition: 350ms;
  transform: translateX(-100%);

  &.show {
    transform: translateX(0);
  }

  ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }

  .left-side {
    flex: 80;
    background-color: var(--slate-dark-1);
    position: relative;
    display: flex;
    flex-direction: column;
    padding: 25px;
    overflow-x: auto;

    .nav-sign-in-btn {
      width: fit-content;
    }

    .profile-link {
      max-width: 100%;
      white-space: nowrap;

      :hover {
        text-decoration: none;
      }
    }

    img {
      border-radius: 50% !important;
    }

    .profile-name {
      color: var(--slate-dark-12);
      font-weight: var(--font-weight-bold);
      margin-top: 10px;
    }

    .profile-username {
      color: var(--slate-dark-11);
    }

    .profile-name,
    .profile-username {
      text-overflow: ellipsis;
      overflow: hidden;
    }
  }

  .top-links,
  .bottom-links {
    a,
    button {
      justify-content: flex-start;
      padding: 28px 0;
      display: flex;
      align-items: center;
      color: var(--slate-dark-11);
      font-weight: var(--font-weight-bold);

      svg {
        margin-right: 12px;
      }

      &.active,
      &:hover,
      &:focus {
        background-color: transparent;
        color: white;
        text-decoration: none;
        svg {
          path {
            stroke: white;
          }
        }
      }
    }
  }

  .top-links {
    margin-top: 40px;
  }

  .bottom-links {
    margin-top: auto;

    a,
    button {
      padding: 14px 0;
    }
  }

  .log-out-button {
    background: none;
    border: none;
    color: var(--slate-dark-11);
    font-weight: var(--font-weight-bold);
    padding: 28px 0;

    svg {
      path {
        stroke: #9ba1a6;
      }
    }
  }

  .close-button {
    background: none;
    border: none;
    position: absolute;
    right: 16px;
    top: 16px;
    padding: 10px;

    svg {
      margin: 0;
    }
  }

  .right-side {
    flex: 20;
    opacity: 0.8;
    background-color: var(--slate-dark-1);
  }
`;

export function Menu(props) {
  return (
    <StyledMenu className={props.showMenu ? "show" : ""}>
      <div className="left-side">
        {props.signedIn ? (
          <Link
            to={`/${props.NearConfig.widgets.profilePage}?accountId=${props.signedAccountId}`}
            className="profile-link"
          >
            <Widget
              src={props.NearConfig.widgets.profileImage}
              props={{
                accountId: props.signedAccountId,
                className: "d-inline-block",
                style: { width: "56px", height: "56px" },
              }}
            />
            {props.NearConfig.widgets.profileName && (
              <div className="profile-name">
                <Widget src={props.NearConfig.widgets.profileName} />
              </div>
            )}
            <div className="profile-username">{props.signedAccountId}</div>
          </Link>
        ) : (
          <SignInButton
            onSignIn={() => {
              props.onCloseMenu();
              props.requestSignIn();
            }}
          />
        )}
        <ul className="top-links">
          <li>
            <NavigationButton route="/">
              <Home />
              Home
            </NavigationButton>
          </li>
          <li>
            <NavigationButton
              disabled={!props.signedIn}
              route={`/${props.NearConfig.widgets.profilePage}?accountId=${props.signedAccountId}`}
            >
              <UserCircle />
              Profile
            </NavigationButton>
          </li>
          <li>
            <NavigationButton route="/edit">
              <Code />
              Create
            </NavigationButton>
          </li>
          <li>
            <NavigationButton href="https://docs.bos.gg">
              <Book />
              Documentation
            </NavigationButton>
          </li>
        </ul>
        <ul className="bottom-links">
          {props.widgetSrc?.edit && (
            <li>
              <Link to={`/edit/${props.widgetSrc?.edit}`}>
                <Fork />
                {props.widgetSrc.edit.startsWith(
                  `${props.signedAccountId}/widget/`
                )
                  ? "Edit widget"
                  : "Fork widget"}
              </Link>
            </li>
          )}
          {props.widgetSrc?.view && (
            <li>
              <Link
                to={`/${props.NearConfig.widgets.viewSource}?src=${props.widgetSrc?.view}`}
              >
                <Code />
                View source
              </Link>
            </li>
          )}
          {props.signedIn && (
            <li>
              <button onClick={() => props.logOut()} className="log-out-button">
                <LogOut />
                Sign Out
              </button>
            </li>
          )}
        </ul>
        <button className="close-button" onClick={props.onCloseMenu}>
          <Close />
        </button>
      </div>
      <div className="right-side" onClick={props.onCloseMenu} />
    </StyledMenu>
  );
}

'''
'''--- src/components/navigation/mobile/MobileMenuButton.js ---
import React from "react";
import styled from "styled-components";

const StyledMobileMenuButton = styled.button`
  background-color: transparent;
  border: none;
  display: flex;
  align-items: center;
  color: white;
  font-weight: var(--font-weight-bold);
  padding: 0;

  .menu {
    width: 18px;
    height: 24px;
    display: flex;
    flex-direction: column;
    justify-content: space-evenly;
    margin-right: 10px;

    div {
      background-color: white;
      height: 2px;
      width: 100%;
      border-radius: 30px;
    }
  }
`;

export function MobileMenuButton(props) {
  return (
    <StyledMobileMenuButton onClick={props.onClick}>
      <div className="menu">
        <div />
        <div />
        <div />
      </div>
      {props.currentPage}
    </StyledMobileMenuButton>
  );
}

'''
'''--- src/components/navigation/mobile/MobileNavigation.js ---
import React, { useState, useEffect } from "react";
import { Navigation } from "./Navigation";
import { Menu } from "./Menu";
import { useLocation } from "react-router-dom";
import useScrollBlock from ".././../../hooks/useScrollBlock";

export function MobileNavigation(props) {
  const [showMenu, setShowMenu] = useState(false);
  const [currentPage, setCurrentPage] = useState("");
  const location = useLocation();
  const [blockScroll, allowScroll] = useScrollBlock();

  useEffect(() => {
    setShowMenu(false);
    getCurrentPage();
    allowScroll();
  }, [location.pathname]);

  const getCurrentPage = () => {
    switch (location.pathname) {
      case "/":
        return setCurrentPage("Home");
      case `/${props.NearConfig.widgets.profilePage}`:
        return setCurrentPage("Profile");
      case "/edit":
        return setCurrentPage("Create");
      default:
        return setCurrentPage("");
    }
  };

  return (
    <>
      <Navigation
        {...props}
        currentPage={currentPage}
        onClickShowMenu={() => {
          setShowMenu(true);
          blockScroll();
        }}
      />
      <Menu
        {...props}
        showMenu={showMenu}
        onCloseMenu={() => {
          setShowMenu(false);
          allowScroll();
        }}
      />
    </>
  );
}

'''
'''--- src/components/navigation/mobile/Navigation.js ---
import React from "react";
import styled from "styled-components";
import { Link } from "react-router-dom";
import { MobileMenuButton } from "./MobileMenuButton";
import { NearSocialLogo } from "../../icons/NearSocialLogo";
import { NotificationWidget } from "../NotificationWidget";
import { SignInButton } from "../SignInButton";

const StyledNavigation = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  width: 100%;
  background-color: var(--slate-dark-1);
  z-index: 1000;
  padding: 16px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;

  .logo-link {
    position: absolute;
    left: 0;
    right: 0;
    margin: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: fit-content;
  }

  .nav-notification-widget {
    margin: 0;
  }

  .nav-sign-in-btn {
    background: none;
    border: none;
    padding-right: 0;
  }
`;

export function Navigation(props) {
  return (
    <StyledNavigation>
      <MobileMenuButton
        onClick={props.onClickShowMenu}
        currentPage={props.currentPage}
      />
      <Link to="/" className="logo-link">
        <NearSocialLogo />
      </Link>
      {props.signedIn ? (
        <NotificationWidget
          notificationButtonSrc={props.NearConfig.widgets.notificationButton}
        />
      ) : (
        <SignInButton onSignIn={() => props.requestSignIn()} />
      )}
    </StyledNavigation>
  );
}

'''
'''--- src/components/remark/mentions.js ---
import { findAndReplace } from "mdast-util-find-and-replace";

const mentionRegex =
  /@((?:(?:[a-z\d]+[-_])*[a-z\d]+\.)*(?:[a-z\d]+[-_])*[a-z\d]+)/gi;

export default function mentions() {
  function replace(value, username, match) {
    if (
      /[\w`]/.test(match.input.charAt(match.index - 1)) ||
      /[/\w`]/.test(match.input.charAt(match.index + value.length)) ||
      username.length < 2 ||
      username.length > 64
    ) {
      return false;
    }

    let node = { type: "text", value };
    node = {
      type: "strong",
      children: [node],
      data: {
        hProperties: { accountId: username },
      },
    };

    return node;
  }

  function transform(markdownAST) {
    findAndReplace(markdownAST, mentionRegex, replace);
    return markdownAST;
  }

  return transform;
}

'''
'''--- src/data/account.js ---
import { singletonHook } from "react-singleton-hook";
import { useEffect, useState } from "react";
import { LsKey, NearConfig, useNear } from "./near";
import ls from "local-storage";
import * as nearAPI from "near-api-js";

const LsKeyAccountId = LsKey + ":accountId:";
const LsKeyPretendAccountId = LsKey + ":pretendAccountId:";

const defaultAccount = {
  loading: true,
  signedAccountId: ls.get(LsKeyAccountId) ?? undefined,
  pretendAccountId: ls.get(LsKeyPretendAccountId) ?? undefined,
  accountId:
    ls.get(LsKeyPretendAccountId) ?? ls.get(LsKeyAccountId) ?? undefined,
  state: null,
  near: null,
};

async function updateAccount(near, walletState) {
  near.connectedContractId = walletState?.contract?.contractId;
  if (
    near.connectedContractId &&
    near.connectedContractId !== NearConfig.contractName
  ) {
    const selector = await near.selector;
    const wallet = await selector.wallet();
    await wallet.signOut();
    near.connectedContractId = null;
    walletState = selector.store.getState();
  }
  near.accountId = walletState?.accounts?.[0]?.accountId ?? null;
  if (near.accountId) {
    near.publicKey = null;
    try {
      if (walletState?.selectedWalletId === "here-wallet") {
        const hereKeystore = ls.get("herewallet:keystore");
        near.publicKey = nearAPI.KeyPair.fromString(
          hereKeystore[NearConfig.networkId].accounts[near.accountId]
        ).getPublicKey();
      }
    } catch (e) {
      console.error(e);
    }
    if (!near.publicKey) {
      try {
        near.publicKey = nearAPI.KeyPair.fromString(
          ls.get(
            walletState?.selectedWalletId === "meteor-wallet"
              ? `_meteor_wallet${near.accountId}:${NearConfig.networkId}`
              : `near-api-js:keystore:${near.accountId}:${NearConfig.networkId}`
          )
        ).getPublicKey();
      } catch (e) {
        console.error(e);
      }
    }
  }
}

const loadAccount = async (near, setAccount) => {
  const signedAccountId = near.accountId;
  if (signedAccountId) {
    ls.set(LsKeyAccountId, signedAccountId);
  } else {
    ls.remove(LsKeyAccountId);
  }
  const pretendAccountId = ls.get(LsKeyPretendAccountId) ?? undefined;
  const account = {
    loading: false,
    signedAccountId,
    pretendAccountId,
    accountId: pretendAccountId ?? signedAccountId,
    state: null,
    near,
    refresh: async () => await loadAccount(near, setAccount),
    startPretending: async (pretendAccountId) => {
      if (pretendAccountId) {
        ls.set(LsKeyPretendAccountId, pretendAccountId);
      } else {
        ls.remove(LsKeyPretendAccountId);
      }
      await loadAccount(near, setAccount);
    },
  };
  if (signedAccountId) {
    const [storageBalance, state] = await Promise.all([
      near.contract.storage_balance_of({
        account_id: signedAccountId,
      }),
      near.accountState(signedAccountId),
    ]);
    account.storageBalance = storageBalance;
    account.state = state;
  }

  setAccount(account);
};

export const useAccount = singletonHook(defaultAccount, () => {
  const [account, setAccount] = useState(defaultAccount);
  const near = useNear();

  useEffect(() => {
    if (!near) {
      return;
    }
    near.selector.then((selector) => {
      selector.store.observable.subscribe(async (walletState) => {
        await updateAccount(near, walletState);
        try {
          await loadAccount(near, setAccount);
        } catch (e) {
          console.error(e);
        }
      });
    });
  }, [near]);

  return account;
});

export const useAccountId = () => {
  const account = useAccount();
  return account.accountId;
};

'''
'''--- src/data/cache.js ---
import { NearConfig } from "./near";
import { indexMatch, isObject, patternMatch } from "./utils";
import { openDB } from "idb";
import { singletonHook } from "react-singleton-hook";

const Action = {
  ViewCall: "ViewCall",
  Fetch: "Fetch",
  Block: "Block",
  LocalStorage: "LocalStorage",
  EthersCall: "EthersCall",
  CustomPromise: "CustomPromise",
};

const CacheStatus = {
  NotStarted: "NotStarted",
  InProgress: "InProgress",
  Done: "Done",
  Invalidated: "Invalidated",
};

const ExpirationTimeoutMs = 1000 * 60 * 5; // 5 minutes
const CacheSubscriptionTimeoutMs = 5000;
const CacheDebug = false;

function invalidateCallbacks(cached, isFinal) {
  if (cached.invalidationCallbacks?.length) {
    const callbacks = cached.invalidationCallbacks;
    cached.invalidationCallbacks = [];
    setTimeout(
      () => {
        callbacks.forEach((cb) => {
          try {
            cb();
          } catch {
            // ignore
          }
        });
      },
      isFinal ? NearConfig.finalSynchronizationDelayMs + 50 : 50
    );
  }
}

const CacheDb = "cacheDb";
const CacheDbObject = "cache-v1";

class Cache {
  constructor() {
    this.dbPromise = openDB(CacheDb, 1, {
      upgrade(db) {
        db.createObjectStore(CacheDbObject);
      },
    });
    this.cache = {};
  }

  async innerGet(key) {
    return (await this.dbPromise).get(CacheDbObject, key);
  }

  async innerSet(key, val) {
    return (await this.dbPromise).put(CacheDbObject, val, key);
  }

  cachedPromise(key, promise, invalidate, forceCachedValue) {
    key = JSON.stringify(key);
    const cached = this.cache[key] || {
      status: CacheStatus.NotStarted,
      invalidationCallbacks: [],
      result: null,
      time: new Date().getTime(),
    };
    this.cache[key] = cached;
    if (!isObject(invalidate)) {
      invalidate = {
        onInvalidate: invalidate,
      };
    }
    if (invalidate.onInvalidate) {
      cached.invalidationCallbacks.push(invalidate.onInvalidate);
    }
    if (!cached.subscription && invalidate.subscribe) {
      const makeTimer = () => {
        cached.subscription = setTimeout(() => {
          CacheDebug && console.log("Cached subscription invalidation", key);
          if (document.hidden) {
            makeTimer();
          } else {
            cached.subscription = null;
            cached.status = CacheStatus.Invalidated;
            invalidateCallbacks(cached, false);
          }
        }, CacheSubscriptionTimeoutMs);
      };
      makeTimer();
    }
    if (cached.status === CacheStatus.InProgress) {
      return cached.result;
    }
    if (
      cached.status === CacheStatus.Done &&
      cached.time + ExpirationTimeoutMs > new Date().getTime()
    ) {
      return cached.result;
    }
    if (cached.status === CacheStatus.NotStarted) {
      this.innerGet(key).then((cachedResult) => {
        if (
          (cachedResult || forceCachedValue) &&
          cached.status === CacheStatus.InProgress
        ) {
          CacheDebug && console.log("Cached value", key, cachedResult);
          cached.result = cachedResult;
          cached.time = new Date().getTime();
          invalidateCallbacks(cached, false);
        }
      });
    }
    cached.status = CacheStatus.InProgress;
    if (promise) {
      promise()
        .then((result) => {
          CacheDebug && console.log("Fetched result", key);
          cached.status = CacheStatus.Done;
          cached.time = new Date().getTime();
          if (JSON.stringify(result) !== JSON.stringify(cached.result)) {
            cached.result = result;
            this.innerSet(key, result);
            CacheDebug && console.log("Replacing value", key, result);
            invalidateCallbacks(cached, false);
          }
        })
        .catch((e) => {
          console.error(e);
          cached.status = CacheStatus.Done;
          const result = undefined;
          cached.time = new Date().getTime();
          if (JSON.stringify(result) !== JSON.stringify(cached.result)) {
            cached.result = result;
            this.innerSet(key, result);
            CacheDebug && console.log("Replacing value", key, result);
            invalidateCallbacks(cached, false);
          }
        });
    }
    CacheDebug && console.log("New cache request", key);
    return cached.result;
  }

  invalidateCache(data) {
    const affectedKeys = [];
    const indexUrl = `${NearConfig.apiUrl}/index`;
    Object.keys(this.cache).forEach((stringKey) => {
      let key;
      try {
        key = JSON.parse(stringKey);
      } catch (e) {
        console.error("Key deserialization failed", stringKey);
        return;
      }
      if (
        key.action === Action.ViewCall &&
        key.contractId === NearConfig.contractName &&
        (!key.blockId ||
          key.blockId === "optimistic" ||
          key.blockId === "final")
      ) {
        try {
          const keys = key.args?.keys;
          if (
            keys.some((pattern) => patternMatch(key.methodName, pattern, data))
          ) {
            affectedKeys.push([stringKey, key.blockId === "final"]);
          }
        } catch {
          // ignore
        }
      }
      // Trying to parse index
      if (key.action === Action.Fetch && key.url === indexUrl) {
        try {
          const { action, key: indexKey } = JSON.parse(key.options?.body);
          if (action && indexKey && indexMatch(action, indexKey, data)) {
            // console.log("Invalidating index", action, indexKey);
            affectedKeys.push([stringKey, true]);
          }
        } catch {
          // ignore
        }
      }
    });
    console.log("Cache invalidation", affectedKeys);
    affectedKeys.forEach(([stringKey, isFinal]) => {
      const cached = this.cache[stringKey];
      cached.status = CacheStatus.Invalidated;
      invalidateCallbacks(cached, isFinal);
    });
  }

  cachedBlock(near, blockId, invalidate) {
    return this.cachedPromise(
      {
        action: Action.Block,
        blockId,
      },
      () => near.block(blockId),
      invalidate
    );
  }

  cachedViewCall(near, contractId, methodName, args, blockId, invalidate) {
    return this.cachedPromise(
      {
        action: Action.ViewCall,
        contractId,
        methodName,
        args,
        blockId,
      },
      () => near.viewCall(contractId, methodName, args, blockId),
      invalidate
    );
  }

  async asyncFetch(url, options) {
    const responseType = options?.responseType?.toLowerCase();
    options = {
      method: options?.method,
      headers: options?.headers,
      body: options?.body,
    };
    try {
      const response = await fetch(url, options);
      const status = response.status;
      const ok = response.ok;
      const contentType = response.headers.get("content-type");
      const body = ok
        ? await (responseType === "arraybuffer"
            ? response.arrayBuffer()
            : responseType === "blob"
            ? response.blob()
            : responseType === "formdata"
            ? response.formData()
            : responseType === "json"
            ? response.json()
            : responseType === "text"
            ? response.text()
            : contentType && contentType.indexOf("application/json") !== -1
            ? response.json()
            : response.text())
        : undefined;
      return {
        ok,
        status,
        contentType,
        body,
      };
    } catch (e) {
      return {
        ok: false,
        error: e.message,
      };
    }
  }

  cachedFetch(url, options, invalidate) {
    return this.cachedPromise(
      {
        action: Action.Fetch,
        url,
        options,
      },
      () => this.asyncFetch(url, options),
      invalidate
    );
  }

  cachedCustomPromise(key, promise, invalidate) {
    return this.cachedPromise(
      {
        action: Action.CustomPromise,
        key,
      },
      () => promise(),
      invalidate
    );
  }

  socialGet(near, keys, recursive, blockId, options, invalidate) {
    if (!near) {
      return null;
    }
    keys = Array.isArray(keys) ? keys : [keys];
    keys = keys.map((key) => (recursive ? `${key}/**` : `${key}`));
    const args = {
      keys,
      options,
    };
    let data = this.cachedViewCall(
      near,
      NearConfig.contractName,
      "get",
      args,
      blockId,
      invalidate
    );
    if (data === null) {
      return null;
    }

    if (keys.length === 1) {
      const parts = keys[0].split("/");
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (part === "*" || part === "**") {
          break;
        }
        data = data?.[part];
      }
    }

    return data;
  }

  socialIndex(action, key, options, invalidate) {
    const res = this.cachedFetch(
      `${NearConfig.apiUrl}/index`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          action,
          key,
          options,
        }),
      },
      invalidate
    );

    return res?.ok ? res.body : null;
  }

  localStorageGet(domain, key, invalidate) {
    return this.cachedPromise(
      {
        action: Action.LocalStorage,
        domain,
        key,
      },
      undefined,
      invalidate,
      true
    );
  }

  asyncLocalStorageGet(domain, key) {
    key = JSON.stringify({
      action: Action.LocalStorage,
      domain,
      key,
    });

    return this.innerGet(key);
  }

  localStorageSet(domain, key, value) {
    key = JSON.stringify({
      action: Action.LocalStorage,
      domain,
      key,
    });
    const cached = this.cache[key] || {
      status: CacheStatus.NotStarted,
      invalidationCallbacks: [],
      result: null,
      time: new Date().getTime(),
    };
    this.cache[key] = cached;
    cached.status = CacheStatus.Done;
    if (JSON.stringify(value) !== JSON.stringify(cached.result)) {
      cached.result = value;
      this.innerSet(key, value);
      CacheDebug && console.log("Replacing value", key, value);
      invalidateCallbacks(cached, false);
    }
  }

  cachedEthersCall(ethersProvider, callee, args, invalidate) {
    if (!ethersProvider) {
      return null;
    }
    return this.cachedPromise(
      {
        action: Action.EthersCall,
        callee,
        args,
      },
      () => ethersProvider[callee](...args),
      invalidate
    );
  }
}

const defaultCache = new Cache();
export const useCache = singletonHook(defaultCache, () => {
  return defaultCache;
});

'''
'''--- src/data/commitData.js ---
import { NearConfig, StorageCostPerByte, TGas } from "./near";
import {
  bigMax,
  convertToStringLeaves,
  estimateDataSize,
  extractKeys,
  removeDuplicates,
} from "./utils";
import Big from "big.js";

const MinStorageBalance = StorageCostPerByte.mul(2000);
const InitialAccountStorageBalance = StorageCostPerByte.mul(500);
const ExtraStorageBalance = StorageCostPerByte.mul(500);
const StorageForPermission = StorageCostPerByte.mul(500);

const fetchCurrentData = async (near, data) => {
  const keys = extractKeys(data);
  return await near.contract.get({
    keys,
  });
};

export const prepareCommit = async (
  near,
  accountId,
  originalData,
  forceRewrite
) => {
  const signedAccountId = near.accountId;
  if (!signedAccountId) {
    alert("You're not logged in. Sign in to commit data.");
    return;
  }
  const [storageBalance, permissionGranted] = await Promise.all([
    near.viewCall(NearConfig.contractName, "storage_balance_of", {
      account_id: signedAccountId,
    }),
    signedAccountId !== accountId
      ? near.viewCall(NearConfig.contractName, "is_write_permission_granted", {
          predecessor_id: signedAccountId,
          key: accountId,
        })
      : near.publicKey
      ? near.viewCall(NearConfig.contractName, "is_write_permission_granted", {
          public_key: near.publicKey.toString(),
          key: accountId,
        })
      : Promise.resolve(false),
  ]);
  const availableStorage = Big(storageBalance?.available || "0");
  let data = {
    [accountId]: convertToStringLeaves(originalData),
  };
  let currentData = {};
  if (!forceRewrite) {
    currentData = await fetchCurrentData(near, data);
    data = removeDuplicates(data, currentData);
  }
  const expectedDataBalance = StorageCostPerByte.mul(
    estimateDataSize(data, currentData)
  )
    .add(storageBalance ? Big(0) : InitialAccountStorageBalance)
    .add(permissionGranted ? Big(0) : StorageForPermission)
    .add(ExtraStorageBalance);
  const deposit = bigMax(
    expectedDataBalance.sub(availableStorage),
    permissionGranted ? Big(0) : storageBalance ? Big(1) : MinStorageBalance
  );
  return {
    originalData,
    accountId,
    storageBalance,
    availableStorage,
    currentData,
    data,
    expectedDataBalance,
    deposit,
    permissionGranted,
  };
};

export const asyncCommit = async (near, data, deposit) => {
  console.log("Committing data", data);

  return await near.contract.set(
    {
      data,
    },
    TGas.mul(100).toFixed(0),
    deposit.toFixed(0)
  );
};

export const asyncCommitData = async (near, originalData, forceRewrite) => {
  const { data, deposit } = await prepareCommit(
    near,
    originalData,
    forceRewrite
  );
  return asyncCommit(near, data, deposit);
};

export const requestPermissionAndCommit = async (near, data, deposit) => {
  const wallet = await (await near.selector).wallet();
  const actions = [];
  if (near.publicKey) {
    actions.push({
      type: "FunctionCall",
      params: {
        methodName: "grant_write_permission",
        args: {
          public_key: near.publicKey.toString(),
          keys: [near.accountId],
        },
        gas: TGas.mul(100).toFixed(0),
        deposit: deposit.gt(0) ? deposit.toFixed(0) : "1",
      },
    });
    deposit = Big(0);
  }
  actions.push({
    type: "FunctionCall",
    params: {
      methodName: "set",
      args: {
        data,
      },
      gas: TGas.mul(100).toFixed(0),
      deposit: deposit.gt(0) ? deposit.toFixed(0) : "1",
    },
  });
  return await wallet.signAndSendTransaction({
    receiverId: NearConfig.contractName,
    actions,
  });
};

'''
'''--- src/data/ethersProvider.js ---
import { singletonHook } from "react-singleton-hook";
import { useEffect, useState } from "react";
import { init, useConnectWallet } from "@web3-onboard/react";
import injectedModule from "@web3-onboard/injected-wallets";
import walletConnectModule from "@web3-onboard/walletconnect";
import ledgerModule from "@web3-onboard/ledger";
import { LsKey } from "./near";
import { ethers } from "ethers";
import ls from "local-storage";

const defaultEthersProvider = undefined;
const web3onboardKey = LsKey + "web3-onboard:connectedWallets";

const wcV1InitOptions = {
  qrcodeModalOptions: {
    mobileLinks: ["metamask", "argent", "trust"],
  },
  connectFirstChainId: true,
};

// const wcV2InitOptions = {
//   version: 2,
//   /**
//    * Project ID associated with [WalletConnect account](https://cloud.walletconnect.com)
//    */
//   projectId: "abc123...",
// };
const walletConnect = walletConnectModule(wcV1InitOptions);
const ledger = ledgerModule();
const injected = injectedModule();

// initialize Onboard
export const onboard = init({
  wallets: [injected, walletConnect, ledger],
  chains: [
    {
      id: 1,
      token: "ETH",
      label: "Ethereum Mainnet",
      rpcUrl: "https://rpc.ankr.com/eth",
    },
    {
      id: 3,
      token: "ETH",
      label: "Ropsten - Ethereum Testnet",
      rpcUrl: "https://rpc.ankr.com/eth_ropsten",
    },
    {
      id: 5,
      token: "ETH",
      label: "Goerli - Ethereum Testnet",
      rpcUrl: "https://rpc.ankr.com/eth_goerli",
    },
    {
      id: "0x4e454152",
      token: "ETH",
      label: "Aurora Mainnet",
      rpcUrl: "https://mainnet.aurora.dev",
    },
    {
      id: 137,
      token: "MATIC",
      label: "Matic Mainnet",
      rpcUrl: "https://rpc.ankr.com/polygon",
    },
    {
      id: 324,
      token: "ETH",
      label: "zkSync",
      rpcUrl: "https://zksync2-mainnet.zksync.io",
    },
    {
      id: 56,
      token: "BNB",
      label: "Binance Smart Chain Mainnet",
      rpcUrl: "https://bsc.publicnode.com",
    },
    {
      id: 42161,
      token: "ETH",
      label: "Arbitrum One Mainnet",
      rpcUrl: "https://endpoints.omniatech.io/v1/arbitrum/one/public",
    },
  ],
  appMetadata: {
    name: "BOS",
    icon: '<svg width="30" height="26" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg" class="logotype"><path d="M9.55396 20.518L2 13.009L9.55396 5.5" stroke="#3D7FFF" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path><path d="M19.536 5.5L27 13.009L19.536 20.518" stroke="#3D7FFF" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path></path></svg>',
    description: "Blockchain Operating System",
  },
  theme: "dark",
  containerElements: {
    // connectModal: '#near-social-navigation-bar',
    // accountCenter: "#near-social-web3-account",
  },
});

export const useEthersProvider = singletonHook(defaultEthersProvider, () => {
  const [{ wallet }] = useConnectWallet();
  const [ethersProvider, setEthersProvider] = useState(null);

  useEffect(() => {
    (async () => {
      const walletsSub = onboard.state.select("wallets");
      const { unsubscribe } = walletsSub.subscribe((wallets) => {
        const connectedWallets = wallets.map(({ label }) => label);
        ls.set(web3onboardKey, connectedWallets);
      });

      const previouslyConnectedWallets = ls.get(web3onboardKey) || [];

      if (previouslyConnectedWallets) {
        // You can also auto connect "silently" and disable all onboard modals to avoid them flashing on page load
        await onboard.connectWallet({
          autoSelect: {
            label: previouslyConnectedWallets[0],
            disableModals: true,
          },
        });
      }
    })();
  }, []);

  useEffect(() => {
    setEthersProvider(
      wallet ? new ethers.providers.Web3Provider(wallet.provider) : null
    );
  }, [wallet]);

  return ethersProvider;
});

'''
'''--- src/data/near.js ---
import * as nearAPI from "near-api-js";
import { singletonHook } from "react-singleton-hook";
import Big from "big.js";
import { refreshAllowanceObj } from "../App";
import { useEffect, useState } from "react";
import { setupWalletSelector } from "@near-wallet-selector/core";
import { setupNearWallet } from "@near-wallet-selector/near-wallet";
import { setupMyNearWallet } from "@near-wallet-selector/my-near-wallet";
import { setupSender } from "@near-wallet-selector/sender";
import { setupHereWallet } from "@near-wallet-selector/here-wallet";
import { setupMeteorWallet } from "@near-wallet-selector/meteor-wallet";
import { setupNeth } from "@near-wallet-selector/neth";

export const TGas = Big(10).pow(12);
export const MaxGasPerTransaction = TGas.mul(250);
export const StorageCostPerByte = Big(10).pow(19);

export const randomPublicKey = nearAPI.utils.PublicKey.from(
  "ed25519:8fWHD35Rjd78yeowShh9GwhRudRtLLsGCRjZtgPjAtw9"
);

const TestnetDomains = {
  "test.near.social": true,
  "127.0.0.1": true,
};

const EnableWeb4FastRpc = false;

export const IsMainnet = !(window.location.hostname in TestnetDomains);
const TestnetContract = "v1.social08.testnet";
const TestNearConfig = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  archivalNodeUrl: "https://rpc.testnet.internal.near.org",
  contractName: TestnetContract,
  walletUrl: "https://wallet.testnet.near.org",
  storageCostPerByte: StorageCostPerByte,
  wrapNearAccountId: "wrap.testnet",
  widgets: {
    image: "eugenethedream/widget/Image",
    default: "eugenethedream/widget/Welcome",
    viewSource: "eugenethedream/widget/WidgetSource",
    widgetMetadataEditor: "eugenethedream/widget/WidgetMetadataEditor",
    widgetMetadata: "eugenethedream/widget/WidgetMetadata",
    profileImage: "eugenethedream/widget/ProfileImage",
    profilePage: "eugenethedream/widget/Profile",
    profileName: "eugenethedream/widget/ProfileName",
    notificationButton: "eugenethedream/widget/NotificationButton",
  },
  apiUrl: null,
  finalSynchronizationDelayMs: 3000,
};
const MainnetContract = "social.near";
export const MainNearConfig = {
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
  archivalNodeUrl: "https://rpc.mainnet.internal.near.org",
  contractName: MainnetContract,
  walletUrl: "https://wallet.near.org",
  storageCostPerByte: StorageCostPerByte,
  wrapNearAccountId: "wrap.near",
  widgets: {
    image: "mob.near/widget/Image",
    default: "ethden.near/widget/BosHomepage",
    viewSource: "mob.near/widget/WidgetSource",
    widgetMetadataEditor: "zavodil.near/widget/WidgetMetadataEditor",
    widgetMetadata: "mob.near/widget/WidgetMetadata",
    profileImage: "mob.near/widget/ProfileImage",
    notificationButton: "mob.near/widget/NotificationButton",
    profilePage: "mob.near/widget/ProfilePage",
    profileName: "patrick.near/widget/ProfileName",
    editorComponentSearch: "mob.near/widget/Editor.ComponentSearch",
    profileInlineBlock: "mob.near/widget/Profile.InlineBlock",
  },
  apiUrl: "https://api.near.social",
  finalSynchronizationDelayMs: 3000,
  forcedTag: "ethdenver2023",
};

export const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig;

export const LsKey = NearConfig.contractName + ":v01:";

const ApiEnabled = IsMainnet;
const SupportedApiMethods = {
  get: true,
  keys: true,
};

const apiCall = async (methodName, args, blockId, fallback) => {
  if (!ApiEnabled || !(methodName in SupportedApiMethods)) {
    return fallback();
  }
  args = args || {};

  if (blockId) {
    args.blockHeight = blockId;
  }

  try {
    return await (
      await fetch(`${NearConfig.apiUrl}/${methodName}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(args),
      })
    ).json();
  } catch (e) {
    console.log("API call failed", methodName, args);
    console.error(e);
    return fallback();
  }
};

async function functionCall(
  near,
  contractName,
  methodName,
  args,
  gas,
  deposit
) {
  try {
    const wallet = await (await near.selector).wallet();
    return await wallet.signAndSendTransaction({
      receiverId: contractName,
      actions: [
        {
          type: "FunctionCall",
          params: {
            methodName,
            args,
            gas: gas ?? TGas.mul(30).toFixed(0),
            deposit: deposit ?? "0",
          },
        },
      ],
    });
  } catch (e) {
    const msg = e.toString();
    if (msg.indexOf("does not have enough balance") !== -1) {
      return await refreshAllowanceObj.refreshAllowance();
    }
    throw e;
  }
}

async function accountState(near, accountId) {
  const account = new nearAPI.Account(
    near.nearConnection.connection,
    accountId
  );
  return await account.state();
}

async function sendTransactions(near, functionCalls) {
  try {
    const wallet = await (await near.selector).wallet();
    const transactions = [];
    let currentTotalGas = Big(0);
    functionCalls.forEach(
      ({ contractName, methodName, args, gas, deposit }) => {
        const newTotalGas = currentTotalGas.add(gas);
        const action = {
          type: "FunctionCall",
          params: {
            methodName,
            args,
            gas: gas.toFixed(0),
            deposit: deposit.toFixed(0),
          },
        };
        if (
          transactions[transactions.length - 1]?.receiverId !== contractName ||
          newTotalGas.gt(MaxGasPerTransaction)
        ) {
          transactions.push({
            receiverId: contractName,
            actions: [],
          });
          currentTotalGas = gas;
        } else {
          currentTotalGas = newTotalGas;
        }
        transactions[transactions.length - 1].actions.push(action);
      }
    );
    return await wallet.signAndSendTransactions({ transactions });
  } catch (e) {
    const msg = e.toString();
    if (msg.indexOf("does not have enough balance") !== -1) {
      return await refreshAllowanceObj.refreshAllowance();
    }
    throw e;
  }
}

function setupContract(near, contractId, options) {
  const { viewMethods = [], changeMethods = [] } = options;
  const contract = {
    near,
    contractId,
  };
  viewMethods.forEach((methodName) => {
    contract[methodName] = (args) =>
      near.viewCall(contractId, methodName, args);
  });
  changeMethods.forEach((methodName) => {
    contract[methodName] = (args, gas, deposit) =>
      near.functionCall(contractId, methodName, args, gas, deposit);
  });
  return contract;
}

async function viewCall(
  provider,
  blockId,
  contractId,
  methodName,
  args,
  finality
) {
  args = args || {};
  const result = await provider.query({
    request_type: "call_function",
    account_id: contractId,
    method_name: methodName,
    args_base64: Buffer.from(JSON.stringify(args)).toString("base64"),
    block_id: blockId,
    finality,
  });

  return (
    result.result &&
    result.result.length > 0 &&
    JSON.parse(Buffer.from(result.result).toString())
  );
}

async function web4ViewCall(contractId, methodName, args, fallback) {
  if (!IsMainnet) {
    return fallback();
  }
  args = args || {};
  const url = new URL(
    `https://rpc.web4.near.page/account/${contractId}/view/${methodName}`
  );
  Object.entries(args).forEach(([key, value]) => {
    if (value !== undefined) {
      url.searchParams.append(`${key}.json`, JSON.stringify(value));
    }
  });
  try {
    return await (await fetch(url.toString())).json();
  } catch (e) {
    console.log("Web4 view call failed", url.toString());
    console.error(e);
    return fallback();
  }
}

async function _initNear() {
  const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
  const selector = setupWalletSelector({
    network: IsMainnet ? "mainnet" : "testnet",
    modules: [
      setupNearWallet(),
      setupMyNearWallet(),
      setupSender(),
      setupHereWallet(),
      setupMeteorWallet(),
      setupNeth({
        gas: "300000000000000",
        bundle: false,
      }),
    ],
  });

  const nearConnection = await nearAPI.connect(
    Object.assign({ deps: { keyStore } }, NearConfig)
  );

  const _near = {};
  _near.selector = selector;

  _near.nearArchivalConnection = nearAPI.Connection.fromConfig({
    networkId: NearConfig.networkId,
    provider: {
      type: "JsonRpcProvider",
      args: { url: NearConfig.archivalNodeUrl },
    },
    signer: { type: "InMemorySigner", keyStore },
  });

  _near.keyStore = keyStore;
  _near.nearConnection = nearConnection;

  const transformBlockId = (blockId) =>
    blockId === "optimistic" || blockId === "final"
      ? {
          finality: blockId,
          blockId: undefined,
        }
      : blockId !== undefined && blockId !== null
      ? {
          finality: undefined,
          blockId: parseInt(blockId),
        }
      : {
          finality: "optimistic",
          blockId: undefined,
        };

  _near.viewCall = (contractId, methodName, args, blockHeightOrFinality) => {
    const { blockId, finality } = transformBlockId(blockHeightOrFinality);
    const nearViewCall = () =>
      viewCall(
        blockId
          ? _near.nearArchivalConnection.provider
          : _near.nearConnection.connection.provider,
        blockId ?? undefined,
        contractId,
        methodName,
        args,
        finality
      );

    const fastRpcCall = () =>
      finality === "optimistic" && EnableWeb4FastRpc
        ? web4ViewCall(contractId, methodName, args, nearViewCall)
        : nearViewCall();

    return contractId === NearConfig.contractName &&
      (blockId || finality === "final")
      ? apiCall(methodName, args, blockId, fastRpcCall)
      : fastRpcCall();
  };

  _near.block = (blockHeightOrFinality) => {
    const blockQuery = transformBlockId(blockHeightOrFinality);
    const provider = blockQuery.blockId
      ? _near.nearArchivalConnection.provider
      : _near.nearConnection.connection.provider;
    return provider.block(blockQuery);
  };
  _near.functionCall = (contractName, methodName, args, gas, deposit) =>
    functionCall(_near, contractName, methodName, args, gas, deposit);
  _near.sendTransactions = (transactions) =>
    sendTransactions(_near, transactions);

  _near.contract = setupContract(_near, NearConfig.contractName, {
    viewMethods: [
      "storage_balance_of",
      "get",
      "get_num_accounts",
      "get_accounts_paged",
      "is_write_permission_granted",
      "keys",
    ],
    changeMethods: [
      "set",
      "grant_write_permission",
      "storage_deposit",
      "storage_withdraw",
    ],
  });

  _near.accountState = (accountId) => accountState(_near, accountId);

  return _near;
}

const defaultNearPromise = Promise.resolve(_initNear());
export const useNearPromise = singletonHook(defaultNearPromise, () => {
  return defaultNearPromise;
});

const defaultNear = null;
export const useNear = singletonHook(defaultNear, () => {
  const [near, setNear] = useState(defaultNear);
  const _near = useNearPromise();

  useEffect(() => {
    _near.then(setNear);
  }, [_near]);

  return near;
});

'''
'''--- src/data/utils.js ---
import Big from "big.js";
import { NearConfig, TGas } from "./near";
import React from "react";
import { useLocation } from "react-router-dom";
import equal from "deep-equal";
import { ethers } from "ethers";

const MinAccountIdLen = 2;
const MaxAccountIdLen = 64;
const ValidAccountRe = /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/;
export const OneNear = Big(10).pow(24);
const AccountSafetyMargin = OneNear.div(2);

export const Loading = (
  <span
    className="spinner-grow spinner-grow-sm me-1"
    role="status"
    aria-hidden="true"
  />
);

export const ErrorFallback = ({ error }) => {
  return (
    <div role="alert">
      <p>Something went wrong:</p>
      <pre>{error.message}</pre>
    </div>
  );
};

export function isValidAccountId(accountId) {
  return (
    accountId &&
    accountId.length >= MinAccountIdLen &&
    accountId.length <= MaxAccountIdLen &&
    accountId.match(ValidAccountRe)
  );
}

const toCamel = (s) => {
  return s.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
};

export const isArray = (a) => Array.isArray(a);

export const isObject = (o) =>
  o === Object(o) && !isArray(o) && typeof o !== "function";

export const isString = (s) => typeof s === "string";

export const keysToCamel = function (o) {
  if (isObject(o)) {
    const n = {};

    Object.keys(o).forEach((k) => {
      n[toCamel(k)] = keysToCamel(o[k]);
    });

    return n;
  } else if (isArray(o)) {
    return o.map((i) => {
      return keysToCamel(i);
    });
  }

  return o;
};

export const bigMin = (a, b) => {
  if (a && b) {
    return a.lt(b) ? a : b;
  }
  return a || b;
};

export const bigMax = (a, b) => {
  if (a && b) {
    return a.gt(b) ? a : b;
  }
  return a || b;
};

export const bigToString = (b, p, len) => {
  if (b === null) {
    return "???";
  }
  let s = b.toFixed();
  let pos = s.indexOf(".");
  p = p || 6;
  len = len || 7;
  if (pos > 0) {
    let ap = Math.min(p, Math.max(len - pos, 0));
    if (ap > 0) {
      ap += 1;
    }
    if (pos + ap < s.length) {
      s = s.substring(0, pos + ap);
    }
  } else {
    pos = s.length;
  }
  for (let i = pos - 4; i >= 0; i -= 3) {
    s = s.slice(0, i + 1) + "," + s.slice(i + 1);
  }

  if (s === "0.000000" && p === 6 && len === 7) {
    return "<0.000001";
  }

  return s;
};

export const displayNear = (balance) =>
  !balance ? (
    "???"
  ) : balance.eq(1) ? (
    <>
      1 <span className="text-secondary">yoctoNEAR</span>
    </>
  ) : (
    <>
      {bigToString(balance.div(OneNear))}{" "}
      <span className="text-secondary">NEAR</span>
    </>
  );

export const displayGas = (gas) =>
  gas ? (
    <>
      {bigToString(gas.div(TGas))} <span className="text-secondary">TGas</span>
    </>
  ) : (
    "???"
  );

export const dateToString = (d) => {
  return d.toLocaleString("en-us", {
    day: "numeric",
    month: "short",
    year: "numeric",
  });
};

export const displayTime = (d) => {
  return d.toLocaleString();
};

export const availableNearBalance = (account) => {
  if (account && !account.loading && account.state) {
    let balance = Big(account.state.amount).sub(
      Big(account.state.storage_usage).mul(Big(NearConfig.storageCostPerByte))
    );
    if (balance.gt(AccountSafetyMargin)) {
      return balance.sub(AccountSafetyMargin);
    }
  }
  return Big(0);
};

export const isoDate = (d) =>
  d ? new Date(d).toISOString().substring(0, 10) : "";

export function useQuery() {
  const { search } = useLocation();

  return React.useMemo(() => new URLSearchParams(search), [search]);
}

export const ipfsUpload = async (f) => {
  const res = await fetch("https://ipfs.near.social/add", {
    method: "POST",
    headers: {
      Accept: "application/json",
    },
    body: f,
  });
  return (await res.json()).cid;
};

export const ipfsUrl = (cid) => `https://ipfs.near.social/ipfs/${cid}`;

const EstimatedKeyValueSize = 40 * 3 + 8 + 12;
const EstimatedNodeSize = 40 * 2 + 8 + 10;

export const estimateDataSize = (data, prevData) =>
  isObject(data)
    ? Object.entries(data).reduce(
        (s, [key, value]) => {
          const prevValue = isObject(prevData) ? prevData[key] : undefined;
          return (
            s +
            (prevValue !== undefined
              ? estimateDataSize(value, prevValue)
              : key.length * 2 +
                estimateDataSize(value, undefined) +
                EstimatedKeyValueSize)
          );
        },
        isObject(prevData) ? 0 : EstimatedNodeSize
      )
    : (data?.length || 8) - (isString(prevData) ? prevData.length : 0);

export const extractKeys = (data, prefix = "") =>
  Object.entries(data)
    .map(([key, value]) =>
      isObject(value)
        ? extractKeys(value, `${prefix}${key}/`)
        : `${prefix}${key}`
    )
    .flat();

export const removeDuplicates = (data, prevData) => {
  const obj = Object.entries(data).reduce((obj, [key, value]) => {
    const prevValue = isObject(prevData) ? prevData[key] : undefined;
    if (isObject(value)) {
      const newValue = isObject(prevValue)
        ? removeDuplicates(value, prevValue)
        : value;
      if (newValue !== undefined) {
        obj[key] = newValue;
      }
    } else if (value !== prevValue) {
      obj[key] = value;
    }

    return obj;
  }, {});
  return Object.keys(obj).length ? obj : undefined;
};

const stringify = (s) => (isString(s) || s === null ? s : JSON.stringify(s));

export const convertToStringLeaves = (data) => {
  return isObject(data)
    ? Object.entries(data).reduce((obj, [key, value]) => {
        obj[stringify(key)] = convertToStringLeaves(value);
        return obj;
      }, {})
    : stringify(data);
};

const matchGet = (obj, keys) => {
  const matchKey = keys[0];
  let isRecursiveMatch = matchKey === "**";
  if (isRecursiveMatch) {
    return keys.length === 1;
  }
  const values =
    matchKey === "*" || isRecursiveMatch
      ? Object.values(obj)
      : matchKey in obj
      ? [obj[matchKey]]
      : [];

  return values.some((value) =>
    isObject(value)
      ? keys.length > 1
        ? matchGet(value, keys.slice(1))
        : value[""] !== undefined
      : keys.length === 1
  );
};

const matchKeys = (obj, keys) => {
  const matchKey = keys[0];
  const values =
    matchKey === "*"
      ? Object.values(obj)
      : matchKey in obj
      ? [obj[matchKey]]
      : [];

  return values.some(
    (value) =>
      keys.length === 1 || (isObject(value) && matchKeys(value, keys.slice(1)))
  );
};

export const patternMatch = (method, pattern, data) => {
  const path = pattern.split("/");
  return method === "get"
    ? matchGet(data, path)
    : method === "keys" && matchKeys(data, path);
};

export const indexMatch = (action, key, data) => {
  return Object.values(data).some((value) => {
    const indexValue = value?.index?.[action];
    try {
      return (
        indexValue &&
        JSON.stringify(JSON.parse(indexValue).key) === JSON.stringify(key)
      );
    } catch {
      return false;
    }
  });
};

const KnownSecondLevelKeys = {
  graph: true,
  post: true,
  index: true,
  settings: true,
};

export const computeWritePermission = (previousPermissions, data) => {
  const permissions = isObject(previousPermissions)
    ? JSON.parse(JSON.stringify(previousPermissions))
    : {};

  if (isObject(data)) {
    Object.entries(data).forEach(([key, value]) => {
      if (key in KnownSecondLevelKeys) {
        if (isObject(value)) {
          const subPermissions = (permissions[key] = permissions[key] || {});
          Object.keys(value).forEach((key) => {
            subPermissions[key] = true;
          });
        } else {
          permissions[key] = true;
        }
      } else {
        permissions[key] = true;
      }
    });
  }

  // console.log(
  //   JSON.stringify(previousPermissions),
  //   JSON.stringify(data),
  //   JSON.stringify(permissions)
  // );
  return permissions;
};

function isGetter(obj, prop) {
  return !!Object.getOwnPropertyDescriptor(obj, prop)["get"];
}

export const deepFreeze = (obj) => {
  Object.keys(obj).forEach((prop) => {
    if (
      !isGetter(obj, prop) &&
      typeof obj[prop] === "object" &&
      !Object.isFrozen(obj[prop])
    ) {
      deepFreeze(obj[prop]);
    }
  });
  return Object.freeze(obj);
};

export const ReactKey = "$$typeof";
export const isReactObject = (o) =>
  o !== null && typeof o === "object" && !!o[ReactKey];

export const deepCopy = (o) => {
  if (Array.isArray(o)) {
    return o.map((v) => deepCopy(v));
  } else if (o instanceof Map) {
    return new Map(
      [...o.entries()].map(([k, v]) => [deepCopy(k), deepCopy(v)])
    );
  } else if (o instanceof Set) {
    return new Set([...o].map((v) => deepCopy(v)));
  } else if (Buffer.isBuffer(o)) {
    return Buffer.from(o);
  } else if (o instanceof URL) {
    return new URL(o);
  } else if (o instanceof File) {
    return new File([o], o.name, { type: o.type });
  } else if (o instanceof Blob) {
    return new Blob([o], { type: o.type });
  } else if (o instanceof Uint8Array || o instanceof ArrayBuffer) {
    return o.slice(0);
  } else if (o instanceof ethers.BigNumber) {
    return o;
  } else if (isObject(o)) {
    if (isReactObject(o)) {
      return o;
    }
    return Object.fromEntries(
      Object.entries(o).map(([key, value]) => [key, deepCopy(value)])
    );
  } else if (o === undefined || typeof o === "function") {
    return o;
  } else {
    return JSON.parse(JSON.stringify(o));
  }
};

export const deepEqual = equal;

'''
'''--- src/hooks/useScrollBlock.js ---
import { useRef } from "react";

const safeDocument = typeof document !== "undefined" ? document : {};

/**
 * Usage:
 * const [blockScroll, allowScroll] = useScrollBlock();
 */
export default () => {
  const scrollBlocked = useRef();
  const html = safeDocument.documentElement;
  const { body } = safeDocument;

  const blockScroll = () => {
    if (!body || !body.style || scrollBlocked.current) return;

    const scrollBarWidth = window.innerWidth - html.clientWidth;
    const bodyPaddingRight =
      parseInt(
        window.getComputedStyle(body).getPropertyValue("padding-right")
      ) || 0;

    /**
     * 1. Fixes a bug in iOS and desktop Safari whereby setting
     *    `overflow: hidden` on the html/body does not prevent scrolling.
     * 2. Fixes a bug in desktop Safari where `overflowY` does not prevent
     *    scroll if an `overflow-x` style is also applied to the body.
     */
    html.style.position = "relative"; /* [1] */
    html.style.overflow = "hidden"; /* [2] */
    body.style.position = "relative"; /* [1] */
    body.style.overflow = "hidden"; /* [2] */
    body.style.paddingRight = `${bodyPaddingRight + scrollBarWidth}px`;

    scrollBlocked.current = true;
  };

  const allowScroll = () => {
    if (!body || !body.style || !scrollBlocked.current) return;

    html.style.position = "";
    html.style.overflow = "";
    body.style.position = "";
    body.style.overflow = "";
    body.style.paddingRight = "";

    scrollBlocked.current = false;
  };

  return [blockScroll, allowScroll];
};

'''
'''--- src/index.css ---
:root {
  --slate-dark-1: #151718;
  --slate-dark-5: #2B2F31;
  --slate-dark-6: #313538;
  --slate-dark-8: #4C5155;
  --slate-dark-9: #697177;
  --slate-dark-11: #9BA1A6;
  --slate-dark-12: #ECEDEE;
  --blue-light-9: #0091FF;

  --font-weight-medium: 500;
  --font-weight-bold: 600;

  /* For web3 onboard */
  --account-center-z-index: 1070;
  --account-center-position-top: -10px;
    --account-center-position-right: -10px;
}

'''
'''--- src/index.js ---
import React from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App";

const container = document.getElementById("root");
const root = createRoot(container);
root.render(<App />);

'''
'''--- src/pages/EditorPage.js ---
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { Widget } from "../components/Widget/Widget";
import ls from "local-storage";
import { LsKey, NearConfig, useNear } from "../data/near";
import prettier from "prettier";
import parserBabel from "prettier/parser-babel";
import { useHistory, useParams } from "react-router-dom";
import Editor from "@monaco-editor/react";
import { useCache } from "../data/cache";
import { CommitButton } from "../components/Commit";
import { Nav, OverlayTrigger, Tooltip } from "react-bootstrap";
import RenameModal from "../components/Editor/RenameModal";
import OpenModal from "../components/Editor/OpenModal";
import { useAccountId } from "../data/account";
import EditorSignIn from "../components/navigation/desktop/EditorSignIn";

const StorageDomain = {
  page: "editor",
};

const StorageType = {
  Code: "code",
  Files: "files",
};

const Filetype = {
  Widget: "widget",
  Module: "module",
};

const EditorLayoutKey = LsKey + "editorLayout:";
const WidgetPropsKey = LsKey + "widgetProps:";

const DefaultEditorCode = "return <div>Hello World</div>;";

const Tab = {
  Editor: "Editor",
  Props: "Props",
  Metadata: "Metadata",
  Widget: "Widget",
};

const Layout = {
  Tabs: "Tabs",
  Split: "Split",
};

export default function EditorPage(props) {
  const { widgetSrc } = useParams();
  const history = useHistory();
  const setWidgetSrc = props.setWidgetSrc;

  const [loading, setLoading] = useState(false);
  const [code, setCode] = useState(undefined);
  const [path, setPath] = useState(undefined);
  const [files, setFiles] = useState(undefined);
  const [lastPath, setLastPath] = useState(undefined);
  const [showRenameModal, setShowRenameModal] = useState(false);
  const [showOpenModal, setShowOpenModal] = useState(false);

  const [renderCode, setRenderCode] = useState(code);
  const [widgetProps, setWidgetProps] = useState(
    ls.get(WidgetPropsKey) || "{}"
  );
  const [parsedWidgetProps, setParsedWidgetProps] = useState({});
  const [propsError, setPropsError] = useState(null);
  const [metadata, setMetadata] = useState(undefined);
  const near = useNear();
  const cache = useCache();
  const accountId = useAccountId();

  const [tab, setTab] = useState(Tab.Editor);
  const [layout, setLayoutState] = useState(
    ls.get(EditorLayoutKey) || Layout.Split
  );

  const setLayout = useCallback(
    (layout) => {
      ls.set(EditorLayoutKey, layout);
      setLayoutState(layout);
    },
    [setLayoutState]
  );

  useEffect(() => {
    setWidgetSrc({
      edit: null,
      view: widgetSrc,
    });
  }, [widgetSrc, setWidgetSrc]);

  const updateCode = useCallback(
    (path, code) => {
      cache.localStorageSet(
        StorageDomain,
        {
          path,
          type: StorageType.Code,
        },
        {
          code,
          time: Date.now(),
        }
      );
      setCode(code);
    },
    [cache, setCode]
  );

  useEffect(() => {
    ls.set(WidgetPropsKey, widgetProps);
    try {
      const parsedWidgetProps = JSON.parse(widgetProps);
      setParsedWidgetProps(parsedWidgetProps);
      setPropsError(null);
    } catch (e) {
      setParsedWidgetProps({});
      setPropsError(e.message);
    }
  }, [widgetProps]);

  const removeFromFiles = useCallback(
    (path) => {
      path = JSON.stringify(path);
      setFiles((files) =>
        files.filter((file) => JSON.stringify(file) !== path)
      );
      setLastPath(path);
    },
    [setFiles, setLastPath]
  );

  const addToFiles = useCallback(
    (path) => {
      const jpath = JSON.stringify(path);
      setFiles((files) => {
        const newFiles = [...files];
        if (!files.find((file) => JSON.stringify(file) === jpath)) {
          newFiles.push(path);
        }
        return newFiles;
      });
      setLastPath(path);
    },
    [setFiles, setLastPath]
  );

  useEffect(() => {
    if (files && lastPath) {
      cache.localStorageSet(
        StorageDomain,
        {
          type: StorageType.Files,
        },
        { files, lastPath }
      );
    }
  }, [files, lastPath, cache]);

  const openFile = useCallback(
    (path, code) => {
      setPath(path);
      addToFiles(path);
      setMetadata(undefined);
      setRenderCode(null);
      if (code !== undefined) {
        updateCode(path, code);
      } else {
        setLoading(true);
        cache
          .asyncLocalStorageGet(StorageDomain, {
            path,
            type: StorageType.Code,
          })
          .then(({ code }) => {
            updateCode(path, code);
          })
          .finally(() => {
            setLoading(false);
          });
      }
    },
    [updateCode, addToFiles]
  );

  const toPath = useCallback((type, nameOrPath) => {
    const name =
      nameOrPath.indexOf("/") >= 0
        ? nameOrPath.split("/").slice(2).join("/")
        : nameOrPath;
    return { type, name };
  }, []);

  const loadFile = useCallback(
    (nameOrPath) => {
      if (!near) {
        return;
      }
      const widgetSrc =
        nameOrPath.indexOf("/") >= 0
          ? nameOrPath
          : `${accountId}/widget/${nameOrPath}`;
      const c = () => {
        const code = cache.socialGet(
          near,
          widgetSrc,
          false,
          undefined,
          undefined,
          c
        );
        if (code) {
          const name = widgetSrc.split("/").slice(2).join("/");
          openFile(toPath(Filetype.Widget, widgetSrc), code);
        }
      };

      c();
    },
    [accountId, openFile, toPath, near, cache]
  );

  const generateNewName = useCallback(
    (type) => {
      for (let i = 0; ; i++) {
        const name = `Draft-${i}`;
        const path = toPath(type, name);
        path.unnamed = true;
        const jPath = JSON.stringify(path);
        if (!files?.find((file) => JSON.stringify(file) === jPath)) {
          return path;
        }
      }
    },
    [toPath, files]
  );

  const createFile = useCallback(
    (type) => {
      const path = generateNewName(type);
      openFile(path, DefaultEditorCode);
    },
    [generateNewName, openFile]
  );

  const renameFile = useCallback(
    (newName, code) => {
      const newPath = toPath(path.type, newName);
      const jNewPath = JSON.stringify(newPath);
      const jPath = JSON.stringify(path);
      setFiles((files) => {
        const newFiles = files.filter(
          (file) => JSON.stringify(file) !== jNewPath
        );
        const i = newFiles.findIndex((file) => JSON.stringify(file) === jPath);
        if (i >= 0) {
          newFiles[i] = newPath;
        }
        return newFiles;
      });
      setLastPath(newPath);
      setPath(newPath);
      updateCode(newPath, code);
    },
    [path, toPath, updateCode]
  );

  useEffect(() => {
    cache
      .asyncLocalStorageGet(StorageDomain, { type: StorageType.Files })
      .then((value) => {
        const { files, lastPath } = value || {};
        setFiles(files || []);
        setLastPath(lastPath);
      });
  }, [cache]);

  useEffect(() => {
    if (!near || !files) {
      return;
    }
    if (widgetSrc) {
      if (widgetSrc === "new") {
        createFile(Filetype.Widget);
      } else {
        loadFile(widgetSrc);
      }
      history.replace(`/edit/`);
    } else if (path === undefined) {
      if (files.length === 0) {
        createFile(Filetype.Widget);
      } else {
        openFile(lastPath, undefined);
      }
    }
  }, [near, createFile, lastPath, files, path, widgetSrc, openFile, loadFile]);

  const reformat = useCallback(
    (path, code) => {
      try {
        const formattedCode = prettier.format(code, {
          parser: "babel",
          plugins: [parserBabel],
        });
        updateCode(path, formattedCode);
      } catch (e) {
        console.log(e);
      }
    },
    [updateCode]
  );

  const reformatProps = useCallback(
    (props) => {
      try {
        const formattedProps = JSON.stringify(JSON.parse(props), null, 2);
        setWidgetProps(formattedProps);
      } catch (e) {
        console.log(e);
      }
    },
    [setWidgetProps]
  );

  const layoutClass = layout === Layout.Split ? "col-lg-6" : "";

  const onLayoutChange = useCallback(
    (e) => {
      const layout = e.target.value;
      if (layout === Layout.Split && tab === Tab.Widget) {
        setTab(Tab.Editor);
      }
      setLayout(layout);
    },
    [setLayout, tab, setTab]
  );

  const widgetName = path?.name;

  const commitButton = (
    <CommitButton
      className="btn btn-primary"
      disabled={!widgetName}
      near={near}
      data={{
        widget: {
          [widgetName]: {
            "": code,
            metadata,
          },
        },
      }}
    >
      Save
    </CommitButton>
  );

  const widgetPath = `${accountId}/${path?.type}/${path?.name}`;
  const jpath = JSON.stringify(path);

  return (
    <div className="container-fluid mt-1">
      <RenameModal
        key={`rename-modal-${jpath}`}
        show={showRenameModal}
        name={path?.name}
        onRename={(newName) => renameFile(newName, code)}
        onHide={() => setShowRenameModal(false)}
      />
      <OpenModal
        show={showOpenModal}
        onOpen={(newName) => loadFile(newName)}
        onNew={(newName) =>
          newName
            ? openFile(toPath(Filetype.Widget, newName), DefaultEditorCode)
            : createFile(Filetype.Widget)
        }
        onHide={() => setShowOpenModal(false)}
      />
      <div className="mb-3">
        <Nav
          variant="pills mb-1"
          activeKey={jpath}
          onSelect={(key) => openFile(JSON.parse(key))}
        >
          {files?.map((p, idx) => {
            const jp = JSON.stringify(p);
            return (
              <Nav.Item key={jp}>
                <Nav.Link className="text-decoration-none" eventKey={jp}>
                  {p.name}
                  <button
                    className={`btn btn-sm border-0 py-0 px-1 ms-1 rounded-circle ${
                      jp === jpath
                        ? "btn-outline-light"
                        : "btn-outline-secondary"
                    }`}
                    onClick={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      removeFromFiles(p);
                      if (jp === jpath) {
                        if (files.length > 1) {
                          openFile(files[idx - 1] || files[idx + 1]);
                        } else {
                          createFile(Filetype.Widget);
                        }
                      }
                    }}
                  >
                    <i className="bi bi-x"></i>
                  </button>
                </Nav.Link>
              </Nav.Item>
            );
          })}
          <Nav.Item>
            <Nav.Link
              className="text-decoration-none"
              onClick={() => setShowOpenModal(true)}
            >
              <i className="bi bi-file-earmark-plus"></i> Add
            </Nav.Link>
          </Nav.Item>
        </Nav>
        {NearConfig.widgets.editorComponentSearch && (
          <div>
            <Widget
              src={NearConfig.widgets.editorComponentSearch}
              props={useMemo(
                () => ({
                  extraButtons: ({ widgetName, widgetPath, onHide }) => (
                    <OverlayTrigger
                      placement="auto"
                      overlay={
                        <Tooltip>
                          Open "{widgetName}" component in the editor
                        </Tooltip>
                      }
                    >
                      <button
                        className="btn btn-outline-primary"
                        onClick={(e) => {
                          e.preventDefault();
                          loadFile(widgetPath);
                          onHide && onHide();
                        }}
                      >
                        Open
                      </button>
                    </OverlayTrigger>
                  ),
                }),
                [loadFile]
              )}
            />
          </div>
        )}
      </div>
      <div className="d-flex align-content-start">
        <div className="me-2">
          <div
            className="btn-group-vertical"
            role="group"
            aria-label="Layout selection"
          >
            <input
              type="radio"
              className="btn-check"
              name="layout-radio"
              id="layout-tabs"
              autoComplete="off"
              checked={layout === Layout.Tabs}
              onChange={onLayoutChange}
              value={Layout.Tabs}
              title={"Set layout to Tabs mode"}
            />
            <label className="btn btn-outline-secondary" htmlFor="layout-tabs">
              <i className="bi bi-square" />
            </label>

            <input
              type="radio"
              className="btn-check"
              name="layout-radio"
              id="layout-split"
              autoComplete="off"
              checked={layout === Layout.Split}
              value={Layout.Split}
              title={"Set layout to Split mode"}
              onChange={onLayoutChange}
            />
            <label className="btn btn-outline-secondary" htmlFor="layout-split">
              <i className="bi bi-layout-split" />
            </label>
          </div>
        </div>
        <div className="flex-grow-1">
          <div className="row">
            <div className={layoutClass}>
              <ul className={`nav nav-tabs mb-2`}>
                <li className="nav-item">
                  <button
                    className={`nav-link ${tab === Tab.Editor ? "active" : ""}`}
                    aria-current="page"
                    onClick={() => setTab(Tab.Editor)}
                  >
                    Editor
                  </button>
                </li>
                <li className="nav-item">
                  <button
                    className={`nav-link ${tab === Tab.Props ? "active" : ""}`}
                    aria-current="page"
                    onClick={() => setTab(Tab.Props)}
                  >
                    Props
                  </button>
                </li>
                {NearConfig.widgets.widgetMetadataEditor && (
                  <li className="nav-item">
                    <button
                      className={`nav-link ${
                        tab === Tab.Metadata ? "active" : ""
                      }`}
                      aria-current="page"
                      onClick={() => setTab(Tab.Metadata)}
                    >
                      Metadata
                    </button>
                  </li>
                )}
                {layout === Layout.Tabs && (
                  <li className="nav-item">
                    <button
                      className={`nav-link ${
                        tab === Tab.Widget ? "active" : ""
                      }`}
                      aria-current="page"
                      onClick={() => {
                        setRenderCode(code);
                        setTab(Tab.Widget);
                      }}
                    >
                      Preview
                    </button>
                  </li>
                )}
              </ul>

              <div className={`${tab === Tab.Editor ? "" : "visually-hidden"}`}>
                <div className="form-control mb-3" style={{ height: "70vh" }}>
                  <Editor
                    value={code}
                    path={widgetPath}
                    theme="vs-dark"
                    defaultLanguage="javascript"
                    onChange={(code) => updateCode(path, code)}
                    wrapperProps={{
                      onBlur: () => reformat(path, code),
                    }}
                  />
                </div>
                <div className="mb-3 d-flex gap-2 flex-wrap">
                  <button
                    className="btn btn-success"
                    onClick={() => {
                      setRenderCode(code);
                      if (layout === Layout.Tabs) {
                        setTab(Tab.Widget);
                      }
                    }}
                  >
                    Preview
                  </button>
                  {!path?.unnamed && commitButton}
                  <button
                    className={`btn ${
                      path?.unnamed ? "btn-primary" : "btn-secondary"
                    }`}
                    onClick={() => {
                      setShowRenameModal(true);
                    }}
                  >
                    Rename
                  </button>
                  {path && accountId && (
                    <a
                      className="btn btn-outline-primary"
                      href={`#/${widgetPath}`}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      Open Component in a new tab
                    </a>
                  )}
                </div>
                <div className="mb-3">
                  <EditorSignIn {...props} />
                </div>
              </div>
              <div className={`${tab === Tab.Props ? "" : "visually-hidden"}`}>
                <div className="form-control" style={{ height: "70vh" }}>
                  <Editor
                    value={widgetProps}
                    theme="vs-dark"
                    defaultLanguage="json"
                    onChange={(props) => setWidgetProps(props)}
                    wrapperProps={{
                      onBlur: () => reformatProps(widgetProps),
                    }}
                  />
                </div>
                <div className=" mb-3">^^ Props for debugging (in JSON)</div>
                {propsError && (
                  <pre className="alert alert-danger">{propsError}</pre>
                )}
              </div>
              <div
                className={`${
                  tab === Tab.Metadata &&
                  NearConfig.widgets.widgetMetadataEditor
                    ? ""
                    : "visually-hidden"
                }`}
              >
                <div className="mb-3">
                  <Widget
                    src={NearConfig.widgets.widgetMetadataEditor}
                    key={`metadata-editor-${jpath}`}
                    props={useMemo(
                      () => ({
                        widgetPath,
                        onChange: setMetadata,
                        forcedTag: NearConfig.forcedTag
                      }),
                      [widgetPath]
                    )}
                  />
                </div>
                <div className="mb-3">{commitButton}</div>
              </div>
            </div>
            <div
              className={`${
                tab === Tab.Widget ||
                (layout === Layout.Split && tab !== Tab.Metadata)
                  ? layoutClass
                  : "visually-hidden"
              }`}
            >
              {renderCode ? (
                <Widget
                  key={`preview-${jpath}`}
                  code={renderCode}
                  props={parsedWidgetProps}
                />
              ) : (
                'Click the "Preview" button to render the widget'
              )}
            </div>
            <div
              className={`${
                tab === Tab.Metadata ? layoutClass : "visually-hidden"
              }`}
            >
              <div className="container">
                <div className="row">
                  <div className="d-inline-block position-relative overflow-hidden">
                    <Widget
                      key={`metadata-${jpath}`}
                      src={NearConfig.widgets.widgetMetadata}
                      props={useMemo(
                        () => ({ metadata, accountId, widgetName }),
                        [metadata, accountId, widgetName]
                      )}
                    />
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

'''
'''--- src/pages/EmbedPage.js ---
import React, { useEffect, useState } from "react";
import { Widget } from "../components/Widget/Widget";
import { useParams } from "react-router-dom";
import { useQuery } from "../data/utils";
import { NearConfig } from "../data/near";

export default function EmbedPage(props) {
  const { widgetSrc } = useParams();
  const query = useQuery();
  const [widgetProps, setWidgetProps] = useState({});

  const src = widgetSrc || NearConfig.widgets.default;

  useEffect(() => {
    setWidgetProps(
      [...query.entries()].reduce((props, [key, value]) => {
        props[key] = value;
        return props;
      }, {})
    );
  }, [query]);

  return (
    <div className="d-inline-block position-relative overflow-hidden">
      <Widget key={src} src={src} props={widgetProps} />{" "}
    </div>
  );
}

'''
'''--- src/pages/ViewPage.js ---
import React, { useEffect, useState } from "react";
import { Widget } from "../components/Widget/Widget";
import { useParams } from "react-router-dom";
import { useQuery } from "../data/utils";
import { NearConfig } from "../data/near";

export default function ViewPage(props) {
  const { widgetSrc } = useParams();
  const query = useQuery();
  const [widgetProps, setWidgetProps] = useState({});

  const src = widgetSrc || NearConfig.widgets.default;
  const setWidgetSrc = props.setWidgetSrc;

  useEffect(() => {
    setWidgetProps(Object.fromEntries([...query.entries()]));
  }, [query]);

  useEffect(() => {
    setTimeout(() => {
      setWidgetSrc(
        src === NearConfig.widgets.viewSource && query.get("src")
          ? {
              edit: query.get("src"),
              view: null,
            }
          : {
              edit: src,
              view: src,
            }
      );
    }, 1);
  }, [src, query, setWidgetSrc]);

  return <Widget key={src} src={src} props={widgetProps} />;
}

'''
'''--- src/vm/vm.js ---
import React from "react";
import { Widget } from "../components/Widget/Widget";
import {
  deepCopy,
  deepFreeze,
  ipfsUpload,
  ipfsUrl,
  isArray,
  isObject,
  isReactObject,
  isString,
  Loading,
  ReactKey,
} from "../data/utils";
import Files from "react-files";
import { sanitizeUrl } from "@braintree/sanitize-url";
import { NearConfig } from "../data/near";
import { Markdown } from "../components/Markdown";
import InfiniteScroll from "react-infinite-scroller";
import { CommitButton } from "../components/Commit";
import "react-bootstrap-typeahead/css/Typeahead.css";
import "react-bootstrap-typeahead/css/Typeahead.bs5.css";
import { Typeahead } from "react-bootstrap-typeahead";
import styled, { isStyledComponent, keyframes } from "styled-components";
import { OverlayTrigger, Tooltip } from "react-bootstrap";
import Big from "big.js";
import * as elliptic from "elliptic";
import BN from "bn.js";
import * as nacl from "tweetnacl";
import { ethers } from "ethers";
import SecureIframe from "../components/SecureIframe";
import Web3ConnectStyledButton from "../components/ethers/Web3ConnectStyledButton";

const frozenNacl = Object.freeze({
  randomBytes: deepFreeze(nacl.randomBytes),
  secretbox: deepFreeze(nacl.secretbox),
  scalarMult: deepFreeze(nacl.scalarMult),
  box: deepFreeze(nacl.box),
  sign: deepFreeze(nacl.sign),
  hash: deepFreeze(nacl.hash),
  verify: deepFreeze(nacl.verify),
});

const frozenEthers = Object.freeze({
  utils: deepFreeze(ethers.utils),
  BigNumber: deepFreeze(ethers.BigNumber),
  Contract: deepFreeze(ethers.Contract),
});

// TODO: Fix freezing with ethers.
const frozenElliptic = Object.freeze({});
/*Object.freeze({
  version: deepFreeze(elliptic.version),
  utils: deepFreeze(elliptic.utils),
  curve: deepFreeze(elliptic.curve),
  curves: deepFreeze(elliptic.curves),
  ec: Object.freeze(elliptic.ec),
  eddsa: Object.freeze(elliptic.eddsa),
});*/

const LoopLimit = 1000000;
const MaxDepth = 32;

const StakeKey = "state";

const ExpressionDebug = false;
const StatementDebug = false;

const MAX_INTERVALS = 16;

const StorageType = {
  Private: "private",
  Public: "public",
};

const ApprovedTagsSimple = {
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  div: true,
  span: true,
  strong: true,
  sub: true,
  sup: true,
  pre: true,
  i: true,
  b: true,
  p: true,
  input: true,
  button: true,
  ul: true,
  ol: true,
  li: true,
  table: true,
  tr: true,
  th: true,
  td: true,
  thead: true,
  tbody: true,
  tfoot: true,
  br: false,
  hr: false,
  img: false,
  textarea: true,
  select: true,
  option: true,
  label: true,
  small: true,
  // svg begin
  svg: true,
  animate: false,
  animateMotion: false,
  animateTransform: false,
  defs: true,
  circle: true,
  clipPath: true,
  ellipse: true,
  g: true,
  image: false,
  line: true,
  linearGradient: true,
  marker: true,
  mask: true,
  mpath: false,
  path: true,
  pattern: true,
  polyline: true,
  radialGradient: true,
  rect: true,
  set: false,
  stop: false,
  symbol: true,
  text: true,
  textPath: true,
  tspan: true,
  use: false,
  // svg ends
  a: true,
};

const ApprovedTagsCustom = {
  Widget: false,
  CommitButton: true,
  IpfsImageUpload: false,
  Markdown: false,
  Fragment: true,
  InfiniteScroll: true,
  Typeahead: false,
  Tooltip: true,
  OverlayTrigger: true,
  Files: true,
  iframe: false,
  Web3Connect: false
};

const ApprovedTags = {
  ...ApprovedTagsSimple,
  ...ApprovedTagsCustom,
};

const Keywords = {
  JSON: true,
  Social: true,
  Storage: true,
  Near: true,
  State: true,
  console: true,
  styled: true,
  Object: true,
  Date,
  Number,
  Big,
  Math,
  Buffer,
  Audio,
  Image,
  File,
  Blob,
  FileReader,
  URL,
  Array,
  BN,
  Uint8Array,
  Map,
  Set,
  clipboard: true,
  Ethers: true,
};

const ReservedKeys = {
  [ReactKey]: true,
  constructor: true,
  prototype: true,
  __proto__: true,
  __defineGetter__: true,
  __defineSetter__: true,
  __lookupGetter__: true,
  __lookupSetter__: true,
};

const assertNotReservedKey = (key) => {
  if (ReservedKeys[key] === true) {
    throw new Error(`${key} is reserved and can't be used`);
  }
};

const assertNotReactObject = (o) => {
  if (isReactObject(o)) {
    throw new Error("React objects shouldn't dereferenced");
  }
};

const assertValidObject = (o) => {
  if (o !== null && typeof o === "object") {
    Object.entries(o).forEach(([key, value]) => {
      assertNotReservedKey(key);
      assertValidObject(value);
    });
  }
};

const maybeSubscribe = (subscribe, blockId) =>
  subscribe &&
  (blockId === undefined ||
    blockId === null ||
    blockId === "final" ||
    blockId === "optimistic");

const requireIdentifier = (id) => {
  if (id.type !== "Identifier") {
    throw new Error("Non identifier: " + id.type);
  }
  const name = id.name;
  assertNotReservedKey(name);
  if (name in Keywords) {
    throw new Error("Cannot use keyword: " + name);
  }
  return {
    type: "Identifier",
    name,
  };
};

const requireJSXIdentifier = (id) => {
  if (id.type !== "JSXIdentifier") {
    throw new Error("Non JSXIdentifier: " + id.type);
  }
  return id.name;
};

const requirePattern = (id) => {
  if (id.type === "Identifier") {
    return requireIdentifier(id);
  } else if (id.type === "ArrayPattern") {
    return {
      type: "ArrayPattern",
      elements: id.elements.map(requirePattern),
    };
  } else if (id.type === "ObjectPattern") {
    return {
      type: "ObjectPattern",
      properties: id.properties.map((p) => {
        if (p.type === "Property") {
          return {
            key: requireIdentifier(p.key),
            value: requirePattern(p.value),
          };
        } else if (p.type === "RestElement") {
          return {
            type: "RestElement",
            argument: requireIdentifier(p.argument),
          };
        } else {
          throw new Error("Unknown property type: " + p.type);
        }
      }),
    };
  } else if (id.type === "RestElement") {
    return {
      type: "RestElement",
      argument: requireIdentifier(id.argument),
    };
  } else {
    throw new Error("Unknown pattern: " + id.type);
  }
};

class Stack {
  constructor(prevStack, state) {
    this.prevStack = prevStack;
    this.state = state;
  }

  findObj(name) {
    if (name in this.state) {
      return this.state;
    }
    return this.prevStack ? this.prevStack.findObj(name) : undefined;
  }

  get(name) {
    if (name in this.state) {
      return this.state[name];
    }
    return this.prevStack ? this.prevStack.get(name) : undefined;
  }
}

class VmStack {
  constructor(vm, prevStack, state, isTrusted) {
    this.gIndex = 0;
    this.vm = vm;
    this.isTrusted = !!isTrusted;
    this.stack = new Stack(prevStack, state);
  }

  newStack(isTrusted) {
    return new VmStack(this.vm, this.stack, {}, this.isTrusted || !!isTrusted);
  }

  executeExpression(code) {
    ExpressionDebug && console.log("Executing code:", code?.type);
    const res = this.executeExpressionInternal(code);
    ExpressionDebug && console.log(code?.type, res);
    return res;
  }

  renderElement(code) {
    let element =
      code.type === "JSXFragment"
        ? "Fragment"
        : requireJSXIdentifier(code.openingElement.name);

    let withChildren = ApprovedTags[element];
    const styledComponent =
      withChildren === undefined && this.stack.get(element);
    if (withChildren === undefined) {
      if (styledComponent === undefined) {
        throw new Error("Unknown element: " + element);
      }
      if (!isStyledComponent(styledComponent)) {
        throw new Error("Not a styled component: " + element);
      }
    }

    const attributes = {};
    const status = {};
    if (element === "input") {
      attributes.className = "form-control";
    } else if (element === "CommitButton") {
      attributes.className = "btn btn-success";
    } else if (element === "button") {
      attributes.className = "btn btn-primary";
    } else if (element === "IpfsImageUpload") {
      attributes.className = "btn btn-outline-primary";
    }

    const rawAttributes = {};

    (code.type === "JSXFragment"
      ? code.openingFragment
      : code.openingElement
    ).attributes.forEach((attribute) => {
      if (attribute.type === "JSXAttribute") {
        const name = requireJSXIdentifier(attribute.name);
        attributes[name] =
          attribute.value === null
            ? true
            : this.executeExpression(attribute.value);
        if (name === "value" || name === "image" || name === "onChange") {
          rawAttributes[name] = attribute.value;
        }
      } else if (attribute.type === "JSXSpreadAttribute") {
        const value = this.executeExpression(attribute.argument);
        Object.assign(attributes, value);
      } else {
        throw new Error("Unknown attribute type: " + attribute.type);
      }
    });

    Object.entries(rawAttributes).forEach(([name, value]) => {
      if (
        name === "value" &&
        element === "input" &&
        attributes.type === "text" &&
        value.type === "JSXExpressionContainer" &&
        !("onChange" in rawAttributes)
      ) {
        const { obj, key } = this.resolveMemberExpression(value.expression, {
          requireState: true,
          left: true,
        });
        attributes.value = obj?.[key] || "";
        attributes.onChange = (e) => {
          e.preventDefault();
          obj[key] = e.target.value;
          this.vm.setReactState(this.vm.state.state);
        };
      } else if (
        name === "image" &&
        element === "IpfsImageUpload" &&
        value.type === "JSXExpressionContainer"
      ) {
        const { obj, key } = this.resolveMemberExpression(value.expression, {
          requireState: true,
          left: true,
        });
        status.img = obj[key];
        attributes.onChange = (files) => {
          if (files?.length > 0) {
            obj[key] = {
              uploading: true,
              cid: null,
            };
            this.vm.setReactState(this.vm.state.state);
            ipfsUpload(files[0]).then((cid) => {
              if (!this.vm.alive) {
                return;
              }
              const { obj, key } = this.vm.vmStack.resolveMemberExpression(
                value.expression,
                {
                  requireState: true,
                  left: true,
                }
              );
              obj[key] = {
                cid,
              };
              this.vm.setReactState(this.vm.state.state);
            });
          } else {
            obj[key] = null;
            this.vm.setReactState(this.vm.state.state);
          }
        };
      }
    });
    attributes.key =
      attributes.key ?? `${this.vm.widgetSrc}-${element}-${this.vm.gIndex}`;
    delete attributes.dangerouslySetInnerHTML;
    delete attributes.as;
    delete attributes.forwardedAs;
    const basicElement = styledComponent?.target || element;

    if (basicElement === "img") {
      attributes.alt = attributes.alt ?? "not defined";
    } else if (basicElement === "a") {
      if ("href" in attributes) {
        attributes.href = sanitizeUrl(attributes.href);
      }
    } else if (element === "Widget") {
      attributes.depth = this.vm.depth + 1;
      attributes.config = [attributes.config, ...this.vm.widgetConfigs].filter(
        Boolean
      );
    }

    if (withChildren === false && code.children.length) {
      throw new Error(
        "And element '" + element + "' contains children, but shouldn't"
      );
    }

    const children = code.children.map((child, i) => {
      this.vm.gIndex = i;
      return this.executeExpression(child);
    });

    if (element === "Widget") {
      return <Widget {...attributes} />;
    } else if (element === "CommitButton") {
      return (
        <CommitButton {...attributes} widgetSrc={this.vm.widgetSrc}>
          {children}
        </CommitButton>
      );
    } else if (element === "InfiniteScroll") {
      return <InfiniteScroll {...attributes}>{children}</InfiniteScroll>;
    } else if (element === "Tooltip") {
      return <Tooltip {...attributes}>{children}</Tooltip>;
    } else if (element === "OverlayTrigger") {
      return (
        <OverlayTrigger {...attributes}>
          {children.filter((c) => !isString(c) || !!c.trim())[0]}
        </OverlayTrigger>
      );
    } else if (element === "Typeahead") {
      return <Typeahead {...attributes} />;
    } else if (element === "Markdown") {
      return <Markdown {...attributes} />;
    } else if (element === "Fragment") {
      return <React.Fragment {...attributes}>{children}</React.Fragment>;
    } else if (element === "IpfsImageUpload") {
      return (
        <div className="d-inline-block" key={attributes.key}>
          {status.img?.cid && (
            <div
              className="d-inline-block me-2 overflow-hidden align-middle"
              style={{ width: "2.5em", height: "2.5em" }}
            >
              <img
                className="rounded w-100 h-100"
                style={{ objectFit: "cover" }}
                src={ipfsUrl(status.img?.cid)}
                alt="upload preview"
              />
            </div>
          )}
          <Files
            multiple={false}
            accepts={["image/*"]}
            minFileSize={1}
            clickable
            {...attributes}
          >
            {status.img?.uploading ? (
              <>{Loading} Uploading</>
            ) : status.img?.cid ? (
              "Replace"
            ) : (
              "Upload an Image"
            )}
          </Files>
        </div>
      );
    } else if (element === "Files") {
      return <Files {...attributes}>{children}</Files>;
    } else if (element === "iframe") {
      return <SecureIframe {...attributes} />;
    } else if (element === "Web3Connect") {
      return <Web3ConnectStyledButton {...attributes} />;
    } else if (styledComponent) {
      return React.createElement(
        styledComponent,
        { ...attributes },
        ...children
      );
    } else if (withChildren === true) {
      return React.createElement(element, { ...attributes }, ...children);
    } else if (withChildren === false) {
      return React.createElement(element, { ...attributes });
    } else {
      throw new Error("Unsupported element: " + element);
    }
  }

  resolveKey(code, computed) {
    const key =
      !computed && code.type === "Identifier"
        ? code.name
        : this.executeExpression(code);
    assertNotReservedKey(key);
    return key;
  }

  callFunction(keyword, callee, args, optional, isNew) {
    const keywordType = Keywords[keyword];
    if (keywordType === true || keywordType === undefined) {
      if (
        (keyword === "Social" && callee === "getr") ||
        callee === "socialGetr"
      ) {
        if (args.length < 1) {
          throw new Error("Missing argument 'keys' for Social.getr");
        }
        return this.vm.cachedSocialGet(args[0], true, args[1], args[2]);
      } else if (
        (keyword === "Social" && callee === "get") ||
        callee === "socialGet"
      ) {
        if (args.length < 1) {
          throw new Error("Missing argument 'keys' for Social.get");
        }
        return this.vm.cachedSocialGet(args[0], false, args[1], args[2]);
      } else if (keyword === "Social" && callee === "keys") {
        if (args.length < 1) {
          throw new Error("Missing argument 'keys' for Social.keys");
        }
        return this.vm.cachedSocialKeys(args[0], args[1], args[2]);
      } else if (keyword === "Social" && callee === "index") {
        if (args.length < 2) {
          throw new Error(
            "Missing argument 'action' and 'key` for Social.index"
          );
        }
        return this.vm.cachedIndex(args[0], args[1], args[2]);
      } else if (keyword === "Social" && callee === "set") {
        if (args.length < 1) {
          throw new Error("Missing argument 'data' for Social.set");
        }
        return this.vm.socialSet(args[0], args[1]);
      } else if (keyword === "Near" && callee === "view") {
        if (args.length < 2) {
          throw new Error(
            "Method: Near.view. Required arguments: 'contractName', 'methodName'. Optional: 'args', 'blockId/finality', 'subscribe'"
          );
        }
        const [contractName, methodName, viewArg, blockId, subscribe] = args;

        return this.vm.cachedNearView(
          contractName,
          methodName,
          viewArg,
          blockId,
          maybeSubscribe(subscribe, blockId)
        );
      } else if (keyword === "Near" && callee === "asyncView") {
        if (args.length < 2) {
          throw new Error(
            "Method: Near.asyncView. Required arguments: 'contractName', 'methodName'. Optional: 'args', 'blockId/finality'"
          );
        }
        return this.vm.asyncNearView(...args);
      } else if (keyword === "Near" && callee === "block") {
        const [blockId, subscribe] = args;
        return this.vm.cachedNearBlock(
          blockId,
          maybeSubscribe(subscribe, blockId)
        );
      } else if (keyword === "Near" && callee === "call") {
        if (args.length === 1) {
          if (isObject(args[0])) {
            return this.vm.confirmTransactions([args[0]]);
          } else if (isArray(args[0])) {
            return this.vm.confirmTransactions(args[0]);
          } else {
            throw new Error(
              "Method: Near.call. Required argument: 'tx/txs'. A single argument call requires an TX object or an array of TX objects."
            );
          }
        } else {
          if (args.length < 2 || args.length > 5) {
            throw new Error(
              "Method: Near.call. Required argument: 'contractName'. If the first argument is a string: 'methodName'. Optional: 'args', 'gas' (defaults to 300Tg), 'deposit' (defaults to 0)"
            );
          }

          return this.vm.confirmTransactions([
            {
              contractName: args[0],
              methodName: args[1],
              args: args[2] ?? {},
              gas: args[3],
              deposit: args[4],
            },
          ]);
        }
      } else if (callee === "fetch") {
        if (args.length < 1) {
          throw new Error(
            "Method: fetch. Required arguments: 'url'. Optional: 'options'"
          );
        }
        return this.vm.cachedFetch(...args);
      } else if (callee === "asyncFetch") {
        if (args.length < 1) {
          throw new Error(
            "Method: asyncFetch. Required arguments: 'url'. Optional: 'options'"
          );
        }
        return this.vm.asyncFetch(...args);
      } else if (callee === "useCache") {
        if (args.length < 2) {
          throw new Error(
            "Method: useCache. Required arguments: 'promiseGenerator', 'dataKey'. Optional: 'options'"
          );
        }
        if (!(args[0] instanceof Function)) {
          throw new Error(
            "Method: useCache. The first argument 'promiseGenerator' must be a function"
          );
        }
        return this.vm.useCache(...args);
      } else if (callee === "parseInt") {
        return parseInt(...args);
      } else if (callee === "parseFloat") {
        return parseFloat(...args);
      } else if (callee === "isNaN") {
        return isNaN(...args);
      } else if (callee === "setTimeout") {
        const [callback, timeout] = args;
        const timer = setTimeout(() => {
          if (!this.vm.alive) {
            return;
          }
          callback();
        }, timeout);
        this.vm.timeouts.add(timer);
        return timer;
      } else if (callee === "setInterval") {
        if (this.vm.intervals.size >= MAX_INTERVALS) {
          throw new Error(`Too many intervals. Max allowed: ${MAX_INTERVALS}`);
        }
        const [callback, timeout] = args;
        const timer = setInterval(() => {
          if (!this.vm.alive) {
            return;
          }
          callback();
        }, timeout);
        this.vm.intervals.add(timer);
        return timer;
      } else if (callee === "clearTimeout") {
        const timer = args[0];
        this.vm.timeouts.delete(timer);
        return clearTimeout(timer);
      } else if (callee === "clearInterval") {
        const timer = args[0];
        this.vm.intervals.delete(timer);
        return clearInterval(timer);
      } else if (
        (keyword === "JSON" && callee === "stringify") ||
        callee === "stringify"
      ) {
        if (args.length < 1) {
          throw new Error("Missing argument 'obj' for JSON.stringify");
        }
        assertNotReactObject(args[0]);
        return JSON.stringify(args[0], args[1], args[2]);
      } else if (keyword === "JSON" && callee === "parse") {
        if (args.length < 1) {
          throw new Error("Missing argument 's' for JSON.parse");
        }
        try {
          const obj = JSON.parse(args[0]);
          assertValidObject(obj);
          return obj;
        } catch (e) {
          return null;
        }
      } else if (keyword === "Object") {
        if (callee === "keys") {
          if (args.length < 1) {
            throw new Error("Missing argument 'obj' for Object.keys");
          }
          assertNotReactObject(args[0]);
          return Object.keys(args[0]);
        } else if (callee === "values") {
          if (args.length < 1) {
            throw new Error("Missing argument 'obj' for Object.values");
          }
          assertNotReactObject(args[0]);
          return Object.values(args[0]);
        } else if (callee === "entries") {
          if (args.length < 1) {
            throw new Error("Missing argument 'obj' for Object.entries");
          }
          assertNotReactObject(args[0]);
          return Object.entries(args[0]);
        } else if (callee === "assign") {
          args.forEach((arg) => assertNotReactObject(arg));
          const obj = Object.assign(...args);
          assertValidObject(obj);
          return obj;
        } else if (callee === "fromEntries") {
          const obj = Object.fromEntries(args[0]);
          assertValidObject(obj);
          return obj;
        }
      } else if (
        (keyword === "State" && callee === "init") ||
        callee === "initState"
      ) {
        if (args.length < 1) {
          throw new Error("Missing argument 'initialState' for State.init");
        }
        if (
          args[0] === null ||
          typeof args[0] !== "object" ||
          isReactObject(args[0])
        ) {
          throw new Error("'initialState' is not an object");
        }
        if (this.vm.state.state === undefined) {
          const newState = args[0];
          this.vm.state.state = newState;
          this.vm.setReactState(newState);
        }
        return this.vm.state.state;
      } else if (keyword === "State" && callee === "update") {
        if (isObject(args[0])) {
          this.vm.state.state = this.vm.state.state ?? {};
          Object.assign(this.vm.state.state, deepCopy(args[0]));
        } else if (args[0] instanceof Function) {
          this.vm.state.state = this.vm.state.state ?? {};
          this.vm.state.state = args[0](this.vm.state.state);
        }
        if (this.vm.state.state === undefined) {
          throw new Error("The state was not initialized");
        }
        this.vm.setReactState(this.vm.state.state);
        return this.vm.state.state;
      } else if (keyword === "Storage" && callee === "privateSet") {
        if (args.length < 2) {
          throw new Error(
            "Missing argument 'key' or 'value' for Storage.privateSet"
          );
        }
        return this.vm.storageSet(
          {
            src: this.vm.widgetSrc,
            type: StorageType.Private,
          },
          args[0],
          args[1]
        );
      } else if (keyword === "Storage" && callee === "privateGet") {
        if (args.length < 1) {
          throw new Error("Missing argument 'key' for Storage.privateGet");
        }
        return this.vm.storageGet(
          {
            src: this.vm.widgetSrc,
            type: StorageType.Private,
          },
          args[0]
        );
      } else if (keyword === "Storage" && callee === "set") {
        if (args.length < 2) {
          throw new Error("Missing argument 'key' or 'value' for Storage.set");
        }
        return this.vm.storageSet(
          {
            src: this.vm.widgetSrc,
            type: StorageType.Public,
          },
          args[0],
          args[1]
        );
      } else if (keyword === "Storage" && callee === "get") {
        if (args.length < 1) {
          throw new Error("Missing argument 'key' for Storage.get");
        }
        return this.vm.storageGet(
          {
            src: args[1] ?? this.vm.widgetSrc,
            type: StorageType.Public,
          },
          args[0]
        );
      } else if (keyword === "console" && callee === "log") {
        return console.log(this.vm.widgetSrc, ...args);
      } else if (keyword === "clipboard" && callee === "writeText") {
        return this.isTrusted
          ? navigator.clipboard.writeText(...args)
          : Promise.reject(new Error("Not trusted (not a click)"));
      } else if (keyword === "Ethers") {
        if (callee === "provider") {
          return this.vm.ethersProvider;
        }
        return this.vm.cachedEthersCall(callee, args);
      }
    } else {
      const f = callee === keyword ? keywordType : keywordType[callee];
      if (typeof f === "function") {
        return isNew ? new f(...args) : f(...args);
      }
    }

    if (optional) {
      return undefined;
    }

    throw new Error(
      keyword && keyword !== callee
        ? `Unsupported callee method '${keyword}.${callee}'`
        : `Unsupported callee method '${callee}'`
    );
  }

  /// Resolves the underlying object and the key to modify.
  /// Should only be used by left hand expressions for assignments.
  /// Options:
  /// - requireState requires the top object key be `state`
  resolveMemberExpression(code, options) {
    if (code.type === "Identifier") {
      const key = code.name;
      assertNotReservedKey(key);
      if (options?.requireState && key !== StakeKey) {
        throw new Error(`The top object should be ${StakeKey}`);
      }
      const obj = this.stack.findObj(key) ?? this.stack.state;
      assertNotReactObject(obj);
      if (obj === this.stack.state) {
        if (key in Keywords) {
          if (options?.left) {
            throw new Error("Cannot assign to keyword '" + key + "'");
          }
          return { obj, key, keyword: key };
        }
      }
      if (options?.left) {
        if (!obj || !(key in obj)) {
          throw new Error(`Accessing undeclared identifier '${code.name}'`);
        }
      }
      return { obj, key };
    } else if (code.type === "MemberExpression") {
      if (code.object?.type === "Identifier") {
        const keyword = code.object.name;
        if (keyword in Keywords) {
          if (!options?.callee) {
            throw new Error(
              "Cannot dereference keyword '" +
                keyword +
                "' in non-call expression"
            );
          }
          return {
            obj: this.stack.state,
            key: this.resolveKey(code.property, code.computed),
            keyword,
          };
        }
      }
      const obj = this.executeExpression(code.object);
      assertNotReactObject(obj);
      const key = this.resolveKey(code.property, code.computed);
      return { obj, key };
    } else {
      throw new Error("Unsupported member type: '" + code.type + "'");
    }
  }

  getArray(elements) {
    const result = [];
    elements.forEach((element) => {
      if (element.type === "SpreadElement") {
        result.push(...this.executeExpression(element.argument));
      } else {
        result.push(this.executeExpression(element));
      }
    });
    return result;
  }

  executeExpressionInternal(code) {
    if (!code) {
      return null;
    }
    const type = code?.type;
    if (type === "AssignmentExpression") {
      const { obj, key } = this.resolveMemberExpression(code.left, {
        left: true,
      });
      const right = this.executeExpression(code.right);

      if (code.operator === "=") {
        return (obj[key] = right);
      } else if (code.operator === "+=") {
        return (obj[key] += right);
      } else if (code.operator === "-=") {
        return (obj[key] -= right);
      } else if (code.operator === "*=") {
        return (obj[key] *= right);
      } else if (code.operator === "/=") {
        return (obj[key] /= right);
      } else if (code.operator === "??=") {
        return (obj[key] ??= right);
      } else {
        throw new Error(
          "Unknown AssignmentExpression operator '" + code.operator + "'"
        );
      }
    } else if (type === "ChainExpression") {
      return this.executeExpression(code.expression);
    } else if (type === "MemberExpression") {
      const { obj, key } = this.resolveMemberExpression(code);
      return obj?.[key];
    } else if (type === "Identifier") {
      return this.stack.get(code.name);
    } else if (type === "JSXExpressionContainer") {
      return this.executeExpression(code.expression);
    } else if (type === "TemplateLiteral") {
      const quasis = [];
      for (let i = 0; i < code.quasis.length; i++) {
        const element = code.quasis[i];
        if (element.type !== "TemplateElement") {
          throw new Error("Unknown quasis type: " + element.type);
        }
        quasis.push(element.value.cooked);
        if (!element.tail) {
          quasis.push(this.executeExpression(code.expressions[i]));
        }
      }
      return quasis.join("");
    } else if (type === "CallExpression" || type === "NewExpression") {
      const isNew = type === "NewExpression";
      const { obj, key, keyword } = this.resolveMemberExpression(code.callee, {
        callee: true,
      });
      const args = this.getArray(code.arguments);
      if (!keyword && obj?.[key] instanceof Function) {
        return isNew ? new obj[key](...args) : obj[key](...args);
      } else if (keyword || obj === this.stack.state || obj === this.vm.state) {
        return this.callFunction(
          keyword ?? "",
          key,
          args,
          code.optional,
          isNew
        );
      } else {
        if (code.optional) {
          return undefined;
        }
        throw new Error("Not a function call expression");
      }
    } else if (type === "Literal" || type === "JSXText") {
      return code.value;
    } else if (type === "JSXElement" || type === "JSXFragment") {
      return this.renderElement(code);
    } else if (type === "JSXExpressionContainer") {
      return this.executeExpression(code.expression);
    } else if (type === "BinaryExpression") {
      const left = this.executeExpression(code.left);
      const right = this.executeExpression(code.right);
      if (code.operator === "+") {
        return left + right;
      } else if (code.operator === "-") {
        return left - right;
      } else if (code.operator === "%") {
        return left % right;
      } else if (code.operator === "*") {
        return left * right;
      } else if (code.operator === "/") {
        return left / right;
      } else if (code.operator === "<") {
        return left < right;
      } else if (code.operator === "|") {
        return left | right;
      } else if (code.operator === "&") {
        return left & right;
      } else if (code.operator === ">") {
        return left > right;
      } else if (code.operator === "<=") {
        return left <= right;
      } else if (code.operator === ">=") {
        return left >= right;
      } else if (code.operator === "===" || code.operator === "==") {
        return left === right;
      } else if (code.operator === "!==" || code.operator === "!=") {
        return left !== right;
      } else if (code.operator === "in") {
        return left in right;
      } else {
        throw new Error(
          "Unknown BinaryExpression operator '" + code.operator + "'"
        );
      }
    } else if (type === "UnaryExpression") {
      if (code.operator === "delete") {
        const { obj, key } = this.resolveMemberExpression(code.argument, {
          left: true,
        });
        return delete obj?.[key];
      }
      const argument = this.executeExpression(code.argument);
      if (code.operator === "-") {
        return -argument;
      } else if (code.operator === "!") {
        return !argument;
      } else if (code.operator === "typeof") {
        return typeof argument;
      } else {
        throw new Error(
          "Unknown UnaryExpression operator '" + code.operator + "'"
        );
      }
    } else if (type === "LogicalExpression") {
      const left = this.executeExpression(code.left);
      if (code.operator === "||") {
        return left || this.executeExpression(code.right);
      } else if (code.operator === "&&") {
        return left && this.executeExpression(code.right);
      } else if (code.operator === "??") {
        return left ?? this.executeExpression(code.right);
      } else {
        throw new Error(
          "Unknown LogicalExpression operator '" + code.operator + "'"
        );
      }
    } else if (type === "ConditionalExpression") {
      const test = this.executeExpression(code.test);
      return test
        ? this.executeExpression(code.consequent)
        : this.executeExpression(code.alternate);
    } else if (type === "UpdateExpression") {
      const { obj, key } = this.resolveMemberExpression(code.argument, {
        left: true,
      });
      if (code.operator === "++") {
        return code.prefix ? ++obj[key] : obj[key]++;
      } else if (code.operator === "--") {
        return code.prefix ? --obj[key] : obj[key]--;
      } else {
        throw new Error(
          "Unknown UpdateExpression operator '" + code.operator + "'"
        );
      }
    } else if (type === "ObjectExpression") {
      return code.properties.reduce((object, property) => {
        if (property.type === "Property") {
          const key = this.resolveKey(property.key, property.computed);
          object[key] = this.executeExpression(property.value);
        } else if (property.type === "SpreadElement") {
          const value = this.executeExpression(property.argument);
          assertNotReactObject(value);
          Object.assign(object, value);
        } else {
          throw new Error("Unknown property type: " + property.type);
        }
        return object;
      }, {});
    } else if (type === "ArrayExpression") {
      return this.getArray(code.elements);
    } else if (type === "JSXEmptyExpression") {
      return null;
    } else if (type === "ArrowFunctionExpression") {
      return this.createFunction(code.params, code.body, code.expression);
    } else if (type === "TaggedTemplateExpression") {
      // Currently on `styled` component is supported.

      let styledTemplate, styledKey;

      if (
        code.tag.type === "MemberExpression" ||
        code.tag.type === "CallExpression"
      ) {
        const { key, keyword } = this.resolveMemberExpression(
          code.tag.type === "MemberExpression" ? code.tag : code.tag.callee,
          {
            callee: true,
          }
        );
        if (keyword !== "styled") {
          throw new Error(
            "TaggedTemplateExpression is only supported for `styled` components"
          );
        }

        if (code.tag.type === "CallExpression") {
          const args = this.getArray(code.tag.arguments);
          const arg = args?.[0];
          if (!isStyledComponent(arg)) {
            throw new Error("styled() can only take `styled` components");
          }
          styledTemplate = styled(arg);
        } else {
          if (key === "keyframes") {
            styledTemplate = keyframes;
          } else if (key in ApprovedTagsSimple) {
            styledTemplate = styled(key);
          } else {
            throw new Error("Unsupported styled tag: " + key);
          }
          styledKey = key;
        }
      } else {
        throw new Error(
          "TaggedTemplateExpression is only supported for `styled` components"
        );
      }

      if (code.quasi.type !== "TemplateLiteral") {
        throw new Error("Unknown quasi type: " + code.quasi.type);
      }
      const quasis = code.quasi.quasis.map((element) => {
        if (element.type !== "TemplateElement") {
          throw new Error("Unknown quasis type: " + element.type);
        }
        return element.value.cooked;
      });

      const canCache =
        code.quasi.expressions.length === 0 &&
        code.tag.type !== "CallExpression";

      const cacheKey = JSON.stringify([styledKey, ...quasis]);

      if (canCache && this.vm.cachedStyledComponents.has(cacheKey)) {
        return this.vm.cachedStyledComponents.get(cacheKey);
      }

      const expressions = code.quasi.expressions.map((expression) =>
        this.executeExpression(expression)
      );

      if (styledTemplate instanceof Function) {
        const result = styledTemplate(quasis, ...expressions);
        if (canCache) {
          this.vm.cachedStyledComponents.set(cacheKey, result);
        }
        return result;
      } else {
        throw new Error("styled error");
      }
    } else {
      throw new Error("Unknown expression type '" + type + "'");
    }
  }

  createFunction(params, body, isExpression) {
    params = params.map(requirePattern);
    return (...args) => {
      if (!this.vm.alive) {
        return;
      }
      const isTrusted = !!(
        args?.[0]?.nativeEvent instanceof Event &&
        args?.[0]?.nativeEvent.isTrusted
      );
      const stack = this.newStack(isTrusted);
      params.forEach((param, i) => {
        let v = undefined;
        let arg = args?.[i];
        if (arg !== undefined) {
          try {
            if (arg?.nativeEvent instanceof Event) {
              arg.preventDefault();
              arg = arg.nativeEvent;
              arg = {
                target: {
                  value: arg?.target?.value,
                  id: arg?.target?.id,
                  dataset: arg?.target?.dataset,
                  href: arg?.target?.href,
                  checked: arg?.target?.checked,
                },
                data: arg?.data,
                code: arg?.code,
                key: arg?.key,
                ctrlKey: arg?.ctrlKey,
                altKey: arg?.altKey,
                shiftKey: arg?.shiftKey,
                metaKey: arg?.metaKey,
                button: arg?.button,
                buttons: arg?.buttons,
                clientX: arg?.clientX,
                clientY: arg?.clientY,
                screenX: arg?.screenX,
                screenY: arg?.screenY,
                touches: arg?.touches,
              };
            }
            v = deepCopy(arg);
          } catch (e) {
            console.warn(e);
          }
        }
        stack.stackDeclare(param, v);
      });
      return isExpression
        ? stack.executeExpression(body)
        : stack.executeStatement(body)?.["result"];
    };
  }

  stackDeclare(pattern, value) {
    if (pattern.type === "Identifier") {
      this.stack.state[pattern.name] = value;
    } else if (pattern.type === "ArrayPattern") {
      assertNotReactObject(value);
      pattern.elements.forEach((element, i) => {
        if (element.type === "RestElement") {
          this.stackDeclare(element.argument, value.slice(i));
        } else {
          this.stackDeclare(element, value?.[i]);
        }
      });
    } else if (pattern.type === "ObjectPattern") {
      assertNotReactObject(value);
      const seen = new Set();
      pattern.properties.forEach((property) => {
        if (property.type === "RestElement") {
          const rest = {};
          if (isObject(value)) {
            Object.assign(rest, value);
            seen.forEach((key) => delete rest[key]);
          }
          this.stackDeclare(property.argument, rest);
        } else {
          this.stackDeclare(property.value, value?.[property.key.name]);
          seen.add(property.key.name);
        }
      });
    } else {
      throw new Error("Unknown pattern type: " + pattern.type);
    }
  }

  executeStatement(token) {
    StatementDebug && console.log(token);
    if (!token || token.type === "EmptyStatement") {
      return null;
    } else if (token.type === "VariableDeclaration") {
      token.declarations.forEach((declaration) => {
        if (declaration.type === "VariableDeclarator") {
          this.stackDeclare(
            requirePattern(declaration.id),
            this.executeExpression(declaration.init)
          );
        } else {
          throw new Error(
            "Unknown variable declaration type '" + declaration.type + "'"
          );
        }
      });
    } else if (token.type === "ReturnStatement") {
      return {
        result: this.executeExpression(token.argument),
      };
    } else if (token.type === "FunctionDeclaration") {
      this.stackDeclare(
        requireIdentifier(token.id),
        this.createFunction(token.params, token.body, token.expression)
      );
    } else if (token.type === "ExpressionStatement") {
      this.executeExpression(token.expression);
    } else if (token.type === "BlockStatement" || token.type === "Program") {
      const body = token.body;
      const stack = this.newStack();
      for (let i = 0; i < body.length; i++) {
        const result = stack.executeStatement(body[i]);
        if (result) {
          return result;
        }
      }
    } else if (token.type === "ForStatement") {
      const stack = this.newStack();
      stack.executeStatement(token.init);
      while (this.vm.loopLimit-- > 0) {
        if (token.test) {
          const test = stack.executeExpression(token.test);
          if (!test) {
            break;
          }
        }
        const result = stack.executeStatement(token.body);
        if (result) {
          if (result.break) {
            break;
          } else if (result.continue) {
            // continue
          } else {
            return result;
          }
        }
        stack.executeExpression(token.update);
      }
      if (this.vm.loopLimit <= 0) {
        throw new Error("Exceeded loop limit");
      }
    } else if (token.type === "ForOfStatement") {
      const stack = this.newStack();
      const right = stack.executeExpression(token.right);
      assertNotReactObject(right);
      for (const value of right) {
        if (this.vm.loopLimit-- <= 0) {
          throw new Error("Exceeded loop limit");
        }
        if (token.left.type === "VariableDeclaration") {
          if (token.left.declarations.length !== 1) {
            throw new Error("Invalid for-of statement");
          }
          token.left.declarations.forEach((declaration) => {
            if (declaration.type === "VariableDeclarator") {
              this.stackDeclare(requirePattern(declaration.id), value);
            } else {
              throw new Error(
                "Unknown variable declaration type '" + declaration.type + "'"
              );
            }
          });
        } else {
          const { obj, key } = this.resolveMemberExpression(token.left, {
            left: true,
          });
          obj[key] = value;
        }
        const result = stack.executeStatement(token.body);
        if (result) {
          if (result.break) {
            break;
          } else if (result.continue) {
            // continue
          } else {
            return result;
          }
        }
      }
    } else if (token.type === "WhileStatement") {
      const stack = this.newStack();
      while (this.vm.loopLimit-- > 0) {
        const test = stack.executeExpression(token.test);
        if (!test) {
          break;
        }
        const result = stack.executeStatement(token.body);
        if (result) {
          if (result.break) {
            break;
          } else if (result.continue) {
            // continue
          } else {
            return result;
          }
        }
      }
      if (this.vm.loopLimit <= 0) {
        throw new Error("Exceeded loop limit");
      }
    } else if (token.type === "IfStatement") {
      const test = this.executeExpression(token.test);
      const stack = this.newStack();
      const result = !!test
        ? stack.executeStatement(token.consequent)
        : stack.executeStatement(token.alternate);
      if (result) {
        return result;
      }
    } else if (token.type === "BreakStatement") {
      return {
        break: true,
      };
    } else if (token.type === "ContinueStatement") {
      return {
        continue: true,
      };
    } else if (token.type === "ThrowStatement") {
      throw this.executeExpression(token.argument);
    } else if (token.type === "TryStatement") {
      try {
        const stack = this.newStack();
        const result = stack.executeStatement(token.block);
        if (result) {
          return result;
        }
      } catch (e) {
        if (!this.vm.alive || !token.handler) {
          return null;
        }
        if (token.handler.type !== "CatchClause") {
          throw new Error(
            "Unknown try statement handler type '" + token.handler.type + "'"
          );
        }
        const stack = this.newStack();
        if (token.handler.param) {
          stack.stackDeclare(
            requireIdentifier(token.handler.param),
            deepCopy(
              e instanceof Error
                ? {
                    name: e?.name,
                    message: e?.message,
                    toString: () => e.toString(),
                  }
                : e
            )
          );
        }
        const result = stack.executeStatement(token.handler.body);
        if (result) {
          return result;
        }
      } finally {
        if (this.vm.alive) {
          const stack = this.newStack();
          stack.executeStatement(token.finalizer);
        }
      }
    } else if (token.type === "SwitchStatement") {
      const discriminant = this.executeExpression(token.discriminant);
      const stack = this.newStack();
      const cases = token.cases;
      let found = false;
      for (const caseToken of cases) {
        if (caseToken.type !== "SwitchCase") {
          throw new Error("Unknown switch case type '" + caseToken.type + "'");
        }
        if (!found && caseToken.test) {
          const test = stack.executeExpression(caseToken.test);
          if (test !== discriminant) {
            continue;
          }
          found = true;
        }
        if (found) {
          let isBreak = false;
          for (const statement of caseToken.consequent) {
            const result = stack.executeStatement(statement);
            if (result) {
              if (result.break) {
                isBreak = true;
                break;
              } else {
                return result;
              }
            }
          }
          if (isBreak) {
            break;
          }
        }
      }
    } else {
      throw new Error("Unknown token type '" + token.type + "'");
    }
    return null;
  }
}

export default class VM {
  constructor(options) {
    const {
      near,
      code,
      setReactState,
      cache,
      refreshCache,
      confirmTransactions,
      depth,
      widgetSrc,
      requestCommit,
      ethersProvider,
      version,
      widgetConfigs,
    } = options;

    if (!code) {
      throw new Error("Not a program");
    }

    this.alive = true;

    this.near = near;
    this.code = code;
    this.setReactState = (s) => setReactState(deepCopy(s));
    this.cache = cache;
    this.refreshCache = refreshCache;
    this.confirmTransactions = confirmTransactions;
    this.depth = depth;
    this.widgetSrc = widgetSrc;
    this.requestCommit = requestCommit;
    this.ethersProvider = ethersProvider;
    this.version = version;
    this.cachedStyledComponents = new Map();
    this.widgetConfigs = widgetConfigs;

    this.timeouts = new Set();
    this.intervals = new Set();
  }

  stop() {
    this.alive = false;
    this.timeouts.forEach((timeout) => clearTimeout(timeout));
    this.intervals.forEach((interval) => clearInterval(interval));
  }

  cachedPromise(promise, subscribe) {
    const invalidate = {
      onInvalidate: () => {
        if (this.alive) {
          this.refreshCache();
        }
      },
      subscribe: !!subscribe,
    };
    return deepCopy(promise(invalidate));
  }

  cachedSocialGet(keys, recursive, blockId, options) {
    keys = Array.isArray(keys) ? keys : [keys];
    return this.cachedPromise(
      (invalidate) =>
        this.cache.socialGet(
          this.near,
          keys,
          recursive,
          blockId,
          options,
          invalidate
        ),
      options?.subscribe
    );
  }

  storageGet(domain, key) {
    return this.cachedPromise((invalidate) =>
      this.cache.localStorageGet(domain, key, invalidate)
    );
  }

  storageSet(domain, key, value) {
    return this.cache.localStorageSet(domain, key, value);
  }

  cachedSocialKeys(keys, blockId, options) {
    keys = Array.isArray(keys) ? keys : [keys];
    return this.cachedPromise(
      (invalidate) =>
        this.cache.cachedViewCall(
          this.near,
          NearConfig.contractName,
          "keys",
          {
            keys,
            options,
          },
          blockId,
          invalidate
        ),
      options?.subscribe
    );
  }

  asyncNearView(contractName, methodName, args, blockId) {
    return this.near.viewCall(contractName, methodName, args, blockId);
  }

  cachedEthersCall(callee, args, subscribe) {
    return this.cachedPromise(
      (invalidate) =>
        this.cache.cachedEthersCall(
          this.ethersProvider,
          callee,
          args,
          invalidate
        ),
      subscribe
    );
  }

  cachedNearView(contractName, methodName, args, blockId, subscribe) {
    return this.cachedPromise(
      (invalidate) =>
        this.cache.cachedViewCall(
          this.near,
          contractName,
          methodName,
          args,
          blockId,
          invalidate
        ),
      subscribe
    );
  }

  cachedNearBlock(blockId, subscribe) {
    return this.cachedPromise(
      (invalidate) => this.cache.cachedBlock(this.near, blockId, invalidate),
      subscribe
    );
  }

  asyncFetch(url, options) {
    return this.cache.asyncFetch(url, options);
  }

  cachedFetch(url, options) {
    return this.cachedPromise(
      (invalidate) => this.cache.cachedFetch(url, options, invalidate),
      options?.subscribe
    );
  }

  cachedIndex(action, key, options) {
    return this.cachedPromise(
      (invalidate) => this.cache.socialIndex(action, key, options, invalidate),
      options?.subscribe
    );
  }

  useCache(promiseGenerator, dataKey, options) {
    return this.cachedPromise(
      (invalidate) =>
        this.cache.cachedCustomPromise(
          {
            widgetSrc: this.widgetSrc,
            dataKey,
          },
          promiseGenerator,
          invalidate
        ),
      options?.subscribe
    );
  }

  socialSet(data, options) {
    return this.requestCommit({
      data,
      force: options?.force,
      onCommit: options?.onCommit,
      onCancel: options?.onCancel,
    });
  }

  renderCode({ props, context, state }) {
    if (this.depth >= MaxDepth) {
      return "Too deep";
    }
    this.gIndex = 0;
    this.state = {
      props: deepCopy(props),
      context,
      state: deepCopy(state),
      nacl: frozenNacl,
      elliptic: frozenElliptic,
      ethers: frozenEthers,
    };
    this.loopLimit = LoopLimit;
    this.vmStack = new VmStack(this, undefined, this.state);
    const executionResult = this.vmStack.executeStatement(this.code);
    if (executionResult?.break) {
      throw new Error("BreakStatement outside of a loop");
    }
    if (executionResult?.continue) {
      throw new Error("ContinueStatement outside of a loop");
    }
    const result = executionResult?.result;

    return isReactObject(result) ||
      typeof result === "string" ||
      typeof result === "number" ? (
      result
    ) : (
      <pre>{JSON.stringify(result, undefined, 2)}</pre>
    );
  }
}

'''
'''--- webpack.config.js ---
const webpack = require("webpack");
const paths = require("./config/paths");
const path = require("path");
const ManifestPlugin = require("webpack-manifest-plugin");
const { CleanWebpackPlugin } = require("clean-webpack-plugin");
const HTMLWebpackPlugin = require("html-webpack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");
const { merge } = require("webpack-merge");
const loadPreset = require("./config/presets/loadPreset");
const { WebpackManifestPlugin } = require("webpack-manifest-plugin");
const loadConfig = (mode) => require(`./config/webpack.${mode}.js`)(mode);

module.exports = function (env) {
  const { mode = "production" } = env || {};
  return merge(
    {
      mode,
      entry: `${paths.srcPath}/index.js`,
      output: {
        path: paths.distPath,
        filename: "[name].bundle.js",
        publicPath: "/",
      },
      module: {
        rules: [
          {
            test: /\.m?js/,
            resolve: {
              fullySpecified: false,
            },
          },
          {
            test: /\.js$/,
            use: ["babel-loader"],
            exclude: path.resolve(__dirname, "node_modules"),
          },
          // Images: Copy image files to build folder
          { test: /\.(?:ico|gif|png|jpg|jpeg)$/i, type: "asset/resource" },

          // Fonts and SVGs: Inline files
          { test: /\.(woff(2)?|eot|ttf|otf|svg|)$/, type: "asset/inline" },
        ],
      },
      resolve: {
        modules: [paths.srcPath, "node_modules"],
        extensions: [".js", ".jsx", ".json"],
        fallback: {
          crypto: require.resolve("crypto-browserify"),
          stream: require.resolve("stream-browserify"),
        },
      },
      plugins: [
        new webpack.EnvironmentPlugin({
          // Configure environment variables here.
          ENVIRONMENT: "browser",
        }),
        new CleanWebpackPlugin(),
        // Copies files from target to destination folder
        new CopyWebpackPlugin({
          patterns: [
            {
              from: paths.publicPath,
              to: "assets",
              globOptions: {
                ignore: ["*.DS_Store"],
              },
              noErrorOnMissing: true,
            },
          ],
        }),
        new HTMLWebpackPlugin({
          template: `${paths.publicPath}/index.html`,
          favicon: `${paths.publicPath}/favicon.png`,
          robots: `${paths.publicPath}/robots.txt`,
        }),
        new webpack.ProgressPlugin(),
        new webpack.ProvidePlugin({
          process: "process/browser",
          Buffer: [require.resolve("buffer/"), "Buffer"],
        }),
        new ManifestPlugin.WebpackManifestPlugin(),
      ],
    },
    loadConfig(mode),
    loadPreset(env)
  );
};

'''