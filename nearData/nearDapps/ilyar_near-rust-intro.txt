*GitHub Repository "ilyar/near-rust-intro"*

'''--- .cargo/audit.toml ---
[advisories]
# warn for categories of informational advisories
informational_warnings = [
    "unmaintained",
    "unsound",
]

[target]
arch = "wasm32"

'''
'''--- .cargo/config.toml ---
[build]
rustflags = ["-C", "link-arg=-s"]

'''
'''--- .github/workflows/contract.yml ---
on: [push]

name: contract

jobs:

  fmt:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: rustfmt
          profile: minimal
          override: true
      - uses: actions-rs/cargo@v1
        with:
          command: fmt
          args: --all -- --check

  clippy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: clippy
          profile: minimal
          override: true
      - uses: actions-rs/clippy-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          args: --all-targets

  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/audit-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          target: wasm32-unknown-unknown
          toolchain: stable
          profile: minimal
          override: true
      - run: make test-contract

'''
'''--- Cargo.toml ---
[package]
name = "intro"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]
test = true
doctest = false
bench = false
doc = false

[dev-dependencies]
near-sdk-sim = "3.1.0"

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- readme.md ---
<div align="center">
  <h1><code>near-rust-intro</code></h1>
  <p>
    <strong><a href="https://docs.near.org/docs/tutorials/contracts/intro-to-rust">An Introduction to Rust Smart Contracts</strong>
  </p>
</div>

## Develop

```shell
make fix 
make qa
make build
make clean
```

### Run CI local

Installation [act](https://github.com/nektos/act):
```shell
brew install act
```

Setup env vars:
```shell
echo "GITHUB_TOKEN=%GITHUB_TOKEN%" | tee .secrets
```

Run
```shell
act --help
```

## Deploy test

```shell
make build
near dev-deploy
contractName=$(cat neardev/dev-account)
near state $contractName
```

## Usage

```shell
accountId=ilyar.testnet
contractName=$(cat neardev/dev-account)
near view $contractName get_num
near call $contractName increment --accountId $accountId
near view $contractName get_num
near call $contractName decrement --accountId $accountId
near view $contractName get_num
near delete $contractName $accountId
```

'''
'''--- src/lib.rs ---
//! This contract implements simple counter backed by storage on blockchain.
//!
//! The contract provides methods to [increment] / [decrement] counter and
//! [get it's current value][get_num] or [reset].
//!
//! [increment]: struct.Counter.html#method.increment
//! [decrement]: struct.Counter.html#method.decrement
//! [get_num]: struct.Counter.html#method.get_num
//! [reset]: struct.Counter.html#method.reset

use near_sdk::borsh;
use near_sdk::borsh::BorshDeserialize;
use near_sdk::borsh::BorshSerialize;
use near_sdk::env;
use near_sdk::near_bindgen;
use near_sdk::setup_alloc;

setup_alloc!();

/// Add the following attributes
/// to prepare your code for serialization and invocation on the blockchain
/// More built-in Rust attributes here: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Counter {
    // See more data types at https://doc.rust-lang.org/book/ch03-02-data-types.html
    val: i8, // i8 is signed. unsigned integers are also available: u8, u16, u32, u64, u128
}

#[near_bindgen]
impl Counter {
    /// Returns 8-bit signed integer of the counter value.
    ///
    /// This must match the type from our struct's 'val' defined above.
    ///
    /// Note, the parameter is `&self` (without being mutable) meaning it doesn't modify state.
    /// In the frontend (/src/main.js) this is added to the "viewMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near view counter.YOU.testnet get_num
    /// ```
    pub fn get_num(&self) -> i8 {
        self.val
    }

    /// Increment the counter.
    ///
    /// Note, the parameter is "&mut self" as this function modifies state.
    /// In the frontend (/src/main.js) this is added to the "changeMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near call counter.YOU.testnet increment --accountId donation.YOU.testnet
    /// ```
    pub fn increment(&mut self) {
        // note: adding one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        self.val += 1;
        let log_message = format!("Increased number to {}", self.val);
        env::log(log_message.as_bytes());
        after_counter_change();
    }

    /// Decrement (subtract from) the counter.
    ///
    /// In (/src/main.js) this is also added to the "changeMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near call counter.YOU.testnet decrement --accountId donation.YOU.testnet
    /// ```
    pub fn decrement(&mut self) {
        // note: subtracting one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        self.val -= 1;
        let log_message = format!("Decreased number to {}", self.val);
        env::log(log_message.as_bytes());
        after_counter_change();
    }

    /// Reset to zero.
    pub fn reset(&mut self) {
        self.val = 0;
        // Another way to log is to cast a string into bytes, hence "b" below:
        env::log(b"Reset counter to zero");
    }
}

/// Unlike the struct's functions above
/// this function cannot use attributes #[derive(…)] or #[near_bindgen]
/// any attempts will throw helpful warnings upon 'cargo build'
/// while this function cannot be invoked directly on the blockchain, it can be called from an invoked function
fn after_counter_change() {
    // show helpful warning that i8 (8-bit signed integer) will overflow above 127 or below -128
    env::log("Make sure you don't overflow, my friend.".as_bytes());
}

/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-counter-tutorial -- --nocapture
 * Note: 'rust-counter-tutorial' comes from cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::accounts;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;
    use near_sdk::MockedBlockchain;

    // part of writing unit tests is setting up a mock context
    fn context() -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.signer_account_id(accounts(0));
        builder
    }

    // mark individual unit tests with #[test] for them to be registered and fired
    #[test]
    fn increment() {
        // set up the mock context into the testing environment
        testing_env!(context().build());
        // instantiate a contract variable with the counter at zero
        let mut contract = Counter::default();
        contract.increment();
        println!("Value after increment: {}", contract.get_num());
        // confirm that we received 1 when calling get_num
        assert_eq!(1, contract.get_num());
    }

    #[test]
    fn decrement() {
        testing_env!(context().build());
        let mut contract = Counter::default();
        contract.decrement();
        println!("Value after decrement: {}", contract.get_num());
        // confirm that we received -1 when calling get_num
        assert_eq!(-1, contract.get_num());
    }

    #[test]
    fn increment_and_reset() {
        testing_env!(context().build());
        let mut contract = Counter::default();
        contract.increment();
        contract.reset();
        println!("Value after reset: {}", contract.get_num());
        // confirm that we received -1 when calling get_num
        assert_eq!(0, contract.get_num());
    }
}

'''
'''--- tests/integration/decrement_simulate.rs ---
use crate::utils::init;
use crate::utils::to_gas;
use near_sdk_sim::DEFAULT_GAS;

#[test]
fn default() {
    let (root, contract, _alice) = init();

    let result = root.call(
        contract.account_id(),
        "decrement",
        &[].to_vec(),
        DEFAULT_GAS,
        0, // deposit
    );

    println!(
        "burnt tokens: {:.04}Ⓝ gas: {:.01} TeraGas",
        (result.tokens_burnt()) as f64 / 1e24,
        (result.gas_burnt()) as f64 / 1e12,
    );

    assert!(result.gas_burnt() <= to_gas("2.7"));

    let actual: i8 = root
        .view(contract.account_id(), "get_num", &[].to_vec())
        .unwrap_json();

    assert_eq!(-1, actual);
}

'''
'''--- tests/integration/get_num_simulate.rs ---
use crate::utils::init;

#[test]
fn default() {
    let (root, contract, _alice) = init();

    let actual: i8 = root
        .view(contract.account_id(), "get_num", &[].to_vec())
        .unwrap_json();

    assert_eq!(0, actual);
}

'''
'''--- tests/integration/increment_simulate.rs ---
use crate::utils::init;
use crate::utils::to_gas;
use near_sdk_sim::DEFAULT_GAS;

#[test]
fn default() {
    let (root, contract, _alice) = init();

    let result = root.call(
        contract.account_id(),
        "increment",
        &[].to_vec(),
        DEFAULT_GAS,
        0, // deposit
    );

    println!(
        "burnt tokens: {:.04}Ⓝ gas: {:.01} TeraGas",
        (result.tokens_burnt()) as f64 / 1e24,
        (result.gas_burnt()) as f64 / 1e12,
    );

    assert!(result.gas_burnt() <= to_gas("2.7"));

    let actual: i8 = root
        .view(contract.account_id(), "get_num", &[].to_vec())
        .unwrap_json();

    assert_eq!(1, actual);
}

'''
'''--- tests/integration/main.rs ---
mod decrement_simulate;
mod get_num_simulate;
mod increment_simulate;
mod utils;

'''
'''--- tests/integration/utils.rs ---
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    CONTRACT_WASM_BYTES => "out/main.wasm",
}

use near_sdk_sim::init_simulator;
use near_sdk_sim::to_yocto;
use near_sdk_sim::UserAccount;
use near_sdk_sim::STORAGE_AMOUNT;

const CONTRACT_ID: &str = "contract";

pub fn init() -> (UserAccount, UserAccount, UserAccount) {
    // Use `None` for default genesis configuration; more info below
    let root = init_simulator(None);

    let contract = root.deploy(
        &CONTRACT_WASM_BYTES,
        CONTRACT_ID.to_string(),
        STORAGE_AMOUNT, // attached deposit
    );

    let alice = root.create_user(
        "alice".to_string(),
        to_yocto("100"), // initial balance
    );

    (root, contract, alice)
}

pub fn to_gas(tera_gas: &str) -> u64 {
    let part: Vec<_> = tera_gas.split('.').collect();
    let number = part[0].parse::<u64>().unwrap() * u64::pow(10, 12);
    if part.len() > 1 {
        let power = part[1].len() as u32;
        let mantissa = part[1].parse::<u64>().unwrap() * u64::pow(10, 12 - power);
        number + mantissa
    } else {
        number
    }
}

'''