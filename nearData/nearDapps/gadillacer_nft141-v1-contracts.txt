*GitHub Repository "gadillacer/nft141-v1-contracts"*

'''--- nft/Cargo.toml ---
[package]
name = "non-fungible-token"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
'''
'''--- nft/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

cp target/wasm32-unknown-unknown/release/*.wasm ./res/nft.wasm
'''
'''--- nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
use near_sdk::collections::LazyOption;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: ValidAccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: ValidAccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens.mint(token_id, receiver_id, Some(token_metadata))
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- nft141factory/Cargo.toml ---
[package]
name = "nft141factory"
version = "0.1.0"
authors = ["shardul <shardul.aeer@somaiya.edu>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0" # Compilation issue

# Boilerplate for setup

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- nft141factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

cp target/wasm32-unknown-unknown/release/*.wasm ./res/nft141factory.wasm
'''
'''--- nft141factory/src/lib.rs ---
use std::convert::TryInto;

use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LookupMap, Vector},
    ext_contract, near_bindgen,
    setup_alloc, log, BorshStorageKey,
    serde::{Deserialize, Serialize},
    env, Promise, AccountId, PromiseResult,
    json_types::{ValidAccountId, U64, U128},
};

setup_alloc!();
pub const TGAS: u64 = 1_000_000_000_000;
pub const NO_DEPOSIT: u128 = 0;
pub const XCC_SUCCESS: u64 = 1;

#[ext_contract(ext_pair)]
pub trait NFT141Pair {
    fn init_vault(
        nft_contract_address: AccountId,
        vault_name: String,
        vault_symbol: String,
        feature_media: String
    );
    fn get_infos(self) -> PairInfos;
    fn setParams(
        &mut self,
        _name: String,
        _symbol: String,
        _value: U128,
        _media: String
    );
}

#[ext_contract(ext_self)]
pub trait SelfContract {
    fn pair_info_callback(&self) -> PairInfos;
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PairInfos {
    pub name: String,
    pub symbol: String,
    pub supply: U128,
    pub media: String
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKeyEnum {
    NftToToken,
    IndexToNft,
    PairsInfo
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct NFT141Factory {
    // keep track of nft address to pair address
    nft_to_token: LookupMap<AccountId, AccountId>,
    index_to_nft: LookupMap<u64, AccountId>,
    pairs_info: Vec<PairInfos>,
    counter: u64,
    fee: U128 
}

impl Default for NFT141Factory {
    fn default() -> Self {
        Self {
            nft_to_token: LookupMap::<AccountId, AccountId>::new(StorageKeyEnum::NftToToken),
            index_to_nft: LookupMap::<u64, AccountId>::new(StorageKeyEnum::IndexToNft),
            pairs_info: Vec::new(),
            counter: 0,
            fee: U128::from(0)
        }
    }
}

#[near_bindgen]
impl NFT141Factory {
    #[payable]
    pub fn nft141Pair(
        &mut self,
        name: String,
        nft_origin: AccountId,
        nft_symbol: String,
        feature_media: String
    ) {
        // assert valid nft origin contract address

        assert_eq!(self.nft_to_token.get(&nft_origin), None, "Found this contract address before");
        // Deploy pair contract
        let pair_contract = get_pair_contract_name(
            nft_symbol.clone()
        );
        Promise::new(pair_contract.clone())
            .create_account()
            .transfer(25_00000000000000000000000)
            .add_full_access_key(env::signer_account_pk())
            .deploy_contract(include_bytes!("../../nft141pair/res/nft141pair.wasm").to_vec());

        let owner: ValidAccountId = env::signer_account_id().try_into().unwrap();

        // Call pair contract constructor
        ext_pair::init_vault(
            nft_origin.clone(), 
            name.clone(), 
            nft_symbol.clone(),
            feature_media.clone(),
            &pair_contract,
            0,
            env::prepaid_gas() / 3
        );

        self.nft_to_token.insert(&nft_origin, &pair_contract);
        self.index_to_nft.insert(&self.counter, &nft_origin);
        self.counter += 1

        //emit event
    }

    pub fn getPairByNftAddress(&self, index: u64) {
        let _originalNft = self.index_to_nft.get(&index).unwrap();
        let _nft141pair = self.nft_to_token.get(&_originalNft).unwrap();
        ext_pair::get_infos(
            &_nft141pair,
            0,
            5 * TGAS
        )
        .then(ext_self::pair_info_callback(
            &env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            5 * TGAS // gas to attach to the callback
        ));
    }

    pub fn refreshAllPairsInfo(&mut self) {
        let mut i: u64 = 0;
        self.pairs_info.clear();
        while i < self.counter {
            self.getPairByNftAddress(i);
            i = i + 1;
        };
    }

    pub fn getAllPairsInfo(&self) -> Vec<PairInfos> {
        self.pairs_info.clone()
    }

    pub fn getPairAddressByIndex(&self, index: u64) -> AccountId {
        let _originalNft = self.index_to_nft.get(&index).unwrap();
        let _nft141pair = self.nft_to_token.get(&_originalNft).unwrap();
        _nft141pair
    }

    pub fn getCounter(&self) -> u64 {
        self.counter
    }

    // this is to sset value in case we decided to change tokens given to a tokenizing project.
    pub fn setValue(
        &mut self,
        _pair: AccountId,
        _name: String,
        _symbol: String,
        _value: U128,
        _media: String
    ) {
        //assert owner
        ext_pair::setParams(
            _name,
            _symbol,
            _value,
            _media,
            &_pair,
            0,
            env::prepaid_gas() / 2
        );
    }

    pub fn setFee(&mut self, _fee: U128) {
        //assert owner
        self.fee = _fee;
    }

    pub fn pair_info_callback(&mut self) -> PairInfos {
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
      
        match env::promise_result(0) {
          PromiseResult::NotReady => unreachable!(),
          PromiseResult::Failed => unreachable!(),
          PromiseResult::Successful(result) => {
            let info: PairInfos = near_sdk::serde_json::from_slice::<PairInfos>(&result).unwrap();
            self.pairs_info.push(info.clone());
            info
          }
        }
    }
}

fn get_pair_contract_name(_target: String) -> String {
    let prefix = _target.replace(".", "-");
    format!("{}.{}", prefix, env::current_account_id()).to_lowercase()
}

#[cfg(test)]
mod tests {
    // Testing boilerplate
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    const NFT_CONTRACT_ADDRESS: &'static str = "nft.yoshitoke.testnet";
    const NFT_MEDIA_URI: &'static str = "https://cdn-icons-png.flaticon.com/512/1137/1137074.png";

    // Context initializer function
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "robert.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 10u128.pow(25),
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    // Test cases here
    #[test]
    fn create_factory() {
        // Initialize context
        let context = get_context(vec![], false);
        testing_env!(context);

        // let target_nft_contract = "nft.testnet".to_string();
        // let nft_token_id = "0".to_string();

        let mut contract = NFT141Factory::default();

        contract.nft141Pair(
            "Yeti".into(), 
            NFT_CONTRACT_ADDRESS.into(), 
            "YTI".into(),
            NFT_MEDIA_URI.into()
        );

        // let promise = contract.getPairByNftAddress(0);
        assert_eq!(NFT_CONTRACT_ADDRESS, contract.index_to_nft.get(&0).unwrap());
        // let expected_shares_contract = get_shares_contract_name(target_nft_contract.clone(), nft_token_id.clone());

        // let saved_shares_address = contract.nft_to_shares_address.get(&nft_address);
        // let saved_nft_address = contract.shares_to_nft_address.get(&expected_shares_contract);

        // // Ensure that mappings are correctly saved
        // assert_eq!(saved_shares_address.expect("Saved shares address did not match"), expected_shares_contract);
        // assert_eq!(saved_nft_address.expect("Saved NFT address did not match"), nft_address);
    }

    #[test]
    fn pair_contract_grant_escrow_access() {

    }
}

'''
'''--- nft141pair/Cargo.toml ---
[package]
name = "nft141pair"
version = "0.1.0"
authors = ["shardul <shardul.aeer@somaiya.edu>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0" # Compilation issue

# Boilerplate for setup

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- nft141pair/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

cp target/wasm32-unknown-unknown/release/*.wasm ./res/nft141pair.wasm
'''
'''--- nft141pair/src/lib.rs ---
use std::convert::TryInto;

use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LookupMap, LazyOption}, Balance, PromiseOrValue,
    ext_contract, near_bindgen, PanicOnDefault,
    setup_alloc, log, BorshStorageKey,
    serde::{Deserialize, Serialize},
    env, Promise, AccountId,
    json_types::{ValidAccountId, U64, U128},
};
mod metadata;
use metadata::{NFT141PairMetadata, NFT141PairMetadataProvider, NFT141_FT_METADATA_SPEC};

setup_alloc!();

pub type TokenId = String;

#[ext_contract]
pub trait NonFungibleTokenCore {
    fn nft_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<U64>,
        memo: Option<String>,
    );
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKeyEnum {
    FungibleToken,
    Metadata
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct NFT141Pair {
    pub token: FungibleToken,
    pub metadata: LazyOption<NFT141PairMetadata>,
    pub factory_contract_address: AccountId,
    pub nft_contract_address: AccountId,
    pub nft_value: U128,
    pub vault_name: String,
    pub vault_symbol: String,
    pub feature_media: String
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PairInfos {
    pub name: String,
    pub symbol: String,
    pub supply: U128,
    pub media: String,
}

#[near_bindgen]
impl NFT141Pair {
    #[init]
    pub fn init_vault(
        nft_contract_address: AccountId,
        vault_name: String,
        vault_symbol: String,
        feature_media: String
    ) -> Self {
        // assert!(factory == address(0)); //Watch out TEST this is so we can init several time
        assert!(!env::state_exists(), "Already initialized");

        let metadata = NFT141PairMetadata {
            spec: NFT141_FT_METADATA_SPEC.to_string(),
            name: vault_name.to_string(),
            symbol: vault_symbol.to_string(),
            icon: Some(feature_media.to_string()),
            reference: None,
            reference_hash: None,
            decimals: 24
        };
        metadata.assert_valid();

        let mut this = Self {
            token: FungibleToken::new(StorageKeyEnum::FungibleToken),
            metadata: LazyOption::new(StorageKeyEnum::Metadata, Some(&metadata)),
            factory_contract_address: env::predecessor_account_id(),
            nft_contract_address,
            nft_value: U128::from(100 * 10u128.pow(24)),
            vault_name,
            vault_symbol,
            feature_media
        };
        
        // incentive
        this.token.internal_register_account(&env::current_account_id());
        this.token.internal_deposit(&env::current_account_id(), this.nft_value.0);

        this
    }

    pub fn get_infos(self) -> PairInfos {
        // Handle '0' supply value?
        PairInfos {
            name: self.vault_name,
            symbol: self.vault_symbol,
            supply: U128::from(self.token.total_supply / self.nft_value.0 - 1),
            media: self.feature_media
        }
    }

    pub fn get_nft_contract_address(self) -> AccountId {
        self.nft_contract_address
    }

    #[payable]
    pub fn swap171(&mut self, _in: String, _out: String) {
        // Check approved?

        // Performing swap
        non_fungible_token_core::nft_transfer(
            env::current_account_id().try_into().unwrap(),
            _in.clone(),
            None,
            None,
            &self.nft_contract_address,
            1,
            env::prepaid_gas() / 2
        );
        non_fungible_token_core::nft_transfer(
            env::signer_account_id().try_into().unwrap(),
            _out.clone(),
            None,
            None,
            &self.nft_contract_address,
            1,
            env::prepaid_gas() / 2
        );

        //Emit events
    }

    #[payable]
    pub fn multi_nft_deposits(
        &mut self,
        _ids: Vec<String>
    ) {

        let mut i: u64 = 0;
        while i < _ids.len() as u64 {
            let tokenId: &String = _ids.get(i as usize).unwrap();
            non_fungible_token_core::nft_transfer(
                env::current_account_id().clone().try_into().unwrap(),
                tokenId.clone(),
                None,
                None,
                &self.nft_contract_address,
                1,
                env::prepaid_gas() / 2
            );

            i = i + 1;
        }

        //Check success logs here
        //Start mingting NEP-141 token
        if self.token.accounts.get(&env::predecessor_account_id()) == None {
            self.token.internal_register_account(&env::predecessor_account_id());
        }
        self.token.internal_deposit(&env::predecessor_account_id(), _ids.len() as u128 * self.nft_value.0);
    }

    #[payable]
    pub fn withdraw(&mut self, _id: String) {
        // Check token balance in wallet
        let user_account = env::predecessor_account_id();
        let user_balance = self.ft_balance_of(user_account.clone().try_into().unwrap());
        assert!(&user_balance.0 >= &self.nft_value.0, "Token balance is smaller than the nft value");
        // Promise transfer here
        non_fungible_token_core::nft_transfer(
            user_account.clone().try_into().unwrap(),
            _id.clone(),
            None,
            None,
            &self.nft_contract_address,
            1,
            env::prepaid_gas() / 3
        );
        // Burn nep141 in wallet
        self.token.accounts.insert(&user_account, &(user_balance.0 - self.nft_value.0));
        self.token.total_supply -= &self.nft_value.0;
        self.on_tokens_burned(user_account.clone(), self.nft_value.0);
    }

    #[payable]
    pub fn batch_withdraw(&mut self, _ids: Vec<String>) {
        let user_balance = self.ft_balance_of(env::predecessor_account_id().try_into().unwrap());
        assert!(user_balance.0 >= self.nft_value.0 * _ids.len() as u128,  "Token balance is smaller than the nft batch value");

        let mut i: usize = 0;
        while i < _ids.len() {
            let tokenId: &String = _ids.get(i as usize).unwrap();
            non_fungible_token_core::nft_transfer(
                env::predecessor_account_id().try_into().unwrap(),
                tokenId.clone(),
                None,
                None,
                &self.nft_contract_address,
                1,
                env::prepaid_gas() / 2
            );

            i = i + 1;
        }

        // Burn nep141 in wallet
        self.token.accounts.insert(&env::predecessor_account_id(), &(user_balance.0 - self.nft_value.0 * _ids.len() as u128));
        self.token.total_supply -= self.nft_value.0 * _ids.len() as u128;
        self.on_tokens_burned(env::predecessor_account_id(), self.nft_value.0 * _ids.len() as u128);
    }

    pub fn setParams(
        &mut self,
        _name: String,
        _symbol: String,
        _value: U128,
        _media: String
    ) {
        assert_eq!(env::predecessor_account_id(), self.factory_contract_address, "!authorized");
        self.vault_name = _name;
        self.vault_symbol = _symbol;
        self.nft_value = _value;
        self.feature_media = _media;
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(NFT141Pair, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(NFT141Pair, token, on_account_closed);

#[near_bindgen]
impl NFT141PairMetadataProvider for NFT141Pair {
    fn ft_metadata(&self) -> NFT141PairMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 100_000_000_000_000_000_000_000_000;
    const NFT_CONTRACT_ADDRESS: &'static str = "nft.yoshitoke.testnet";
    const NFT_MEDIA_URI: &'static str = "https://cdn-icons-png.flaticon.com/512/1137/1137074.png";
    const NFT_SYMBOL: &'static str = "yti";

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());

        let contract = NFT141Pair::init_vault(
            NFT_CONTRACT_ADDRESS.into(),
            "yeti".into(),
            NFT_SYMBOL.into(),
            NFT_MEDIA_URI.into()
        );
        testing_env!(context.is_view(true).build());

        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(0)).0, TOTAL_SUPPLY);
    }
}

'''
'''--- nft141pair/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;

pub const NFT141_FT_METADATA_SPEC: &str = "nft141-ft-1.0.0";
pub type TokenId = String;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NFT141PairMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<Base64VecU8>,
    pub decimals: u8
}

pub trait NFT141PairMetadataProvider {
    fn ft_metadata(&self) -> NFT141PairMetadata;
}

impl NFT141PairMetadata {
    pub fn assert_valid(&self) {
        assert_eq!(&self.spec, NFT141_FT_METADATA_SPEC);
        assert_eq!(self.reference.is_some(), self.reference_hash.is_some());
        if let Some(reference_hash) = &self.reference_hash {
            assert_eq!(reference_hash.0.len(), 32, "Hash has to be 32 bytes");
        }
    }
}

'''