*GitHub Repository "ismaelsousa/solana-figment"*

'''--- .gitpod.yml ---
tasks:
  - init: yarn
    command: yarn dev

ports:
  - port: 3000
    onOpen: open-preview

vscode:
  extensions:
    - jpoissonnier.vscode-styled-components

'''
'''--- .prettierrc.json ---
{
  "bracketSpacing": false,
  "singleQuote": true,
  "trailingComma": "all"
}

'''
'''--- README.md ---
# 👋🏼 What is `learn-web3-dapp`?

We made this decentralized application (dApp) to help developers learn about Web 3 protocols.

It's a Next.js app that uses React, TypeScript and various smart contract languages (mostly Solidity and Rust).

We will guide you through using the various blockchain JavaScript SDKs to interact with their networks. Each protocol is slightly different, but we have attempted to standardize the workflow so that you can quickly get up to speed on networks like Solana, NEAR, Polygon and more!

- ✅ Solana
- ✅ Polygon
- ✅ Avalanche
- ✅ NEAR
- ✅ Tezos
- ✅ Secret
- ✅ Polkadot
- ✅ Celo
- ✅ The Graph
- ✅ The Graph for NEAR
- ✅ Pyth
- 🔜 Ceramic
- 🔜 Arweave
- 🔜 Chainlink

- [Let us know which one you'd like us to cover](https://github.com/figment-networks/learn-web3-dapp/issues)

<img width="1024" alt="Screen Shot 1" src="https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/readme_01.png">

<img width="1024" alt="Screen Shot 2" src="https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/readme-02.png">

<img width="1024" alt="Screen Shot 3" src="https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/readme-03.png">

# 🧑‍💻 Get started

## 🤖 Using Gitpod (Recommended)

The best way to go through those courses is using [Gitpod](https://gitpod.io). Gitpod provides prebuilt developer environments in your browser, powered by VS Code. Just sign in using GitHub and you'll be up and running in seconds without having to do any manual setup 🔥

[**Open this repo on Gitpod**](https://gitpod.io/#https://github.com/figment-networks/learn-web3-dapp)

## 🐑 Clone locally

Make sure you have installed [git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git), [Node.js](https://nodejs.org/en/) (Please install **v14.17.0**, we recommend using [nvm](https://github.com/nvm-sh/nvm)) and [yarn](https://yarnpkg.com/getting-started/install).

Then clone the repo, install dependencies and start the server by running all these commands:

```text
git clone https://github.com/figment-networks/learn-web3-dapp.git
cd learn-web3-dapp
yarn
yarn dev
```

# 🤝 Feedback and contributing

If you encounter any errors during this process, please join our [Discord](https://figment.io/devchat) for help.

Feel free to also open an Issue or a Pull Request on the repo itself.

We hope you enjoy our Web 3 education dApps 🚀

-- ❤️ The Figment Learn Team

'''
'''--- __test__/avalanche.test.ts ---
import {getAvalancheClient} from '@avalanche/lib';
import type {BalanceT} from '@avalanche/types';
import {BinTools, BN} from 'avalanche';
import {Address} from 'ethereumjs-util';
import dotenv from 'dotenv';

dotenv.config({path: '.env.local'});

async function connect_step(network: string) {
  const client = getAvalancheClient(network);
  const info = client.Info();
  const version = await info.getNodeVersion();
  return !!version;
}

async function account_step(network: string) {
  const client = getAvalancheClient(network);
  const chain = client.XChain();
  const keyChain = chain.keyChain();
  const keypair = keyChain.makeKey();
  const secret = keypair.getPrivateKeyString();
  const address = keypair.getAddressString();
  return !!secret && !!address;
}

async function balance_step(network: string, address: string) {
  const client = getAvalancheClient(network);
  const chain = client.XChain();
  const balance = (await chain.getBalance(address, 'AVAX')) as BalanceT;
  return !!balance.balance;
}

async function transfer_step(network: string, address: string, secret: string) {
  const recipient = 'X-fuji10f9gsh80unawkxdtug42475u2kq22sv8xryekd';
  const navax = '5000';
  const client = getAvalancheClient(network);
  const chain = client.XChain();
  const keychain = chain.keyChain();
  keychain.importKey(secret);

  const {utxos} = await chain.getUTXOs(address);
  const binTools = BinTools.getInstance();
  const assetInfo = await chain.getAssetDescription('AVAX');
  const assetID = binTools.cb58Encode(assetInfo.assetID);
  const transaction = await chain.buildBaseTx(
    utxos,
    new BN(navax),
    assetID,
    [recipient],
    [address],
    [address],
  );

  const signedTx = transaction.sign(keychain);
  const hash = await chain.issueTx(signedTx);
  return !!hash;
}

async function export_step(network: string, secret: string) {
  const client = getAvalancheClient(network);
  const amount = '5000000';

  const [xChain, cChain] = [client.XChain(), client.CChain()];
  const [xKeychain, cKeychain] = [xChain.keyChain(), cChain.keyChain()];
  const [xKeypair, cKeypair] = [
    xKeychain.importKey(secret),
    cKeychain.importKey(secret),
  ];
  const [xAddress, cAddress] = [
    xKeypair.getAddressString(),
    cKeypair.getAddressString(),
  ];

  const chainId = await client.Info().getBlockchainID('C');
  const {utxos} = await xChain.getUTXOs(xAddress);
  const exportTx = await xChain.buildExportTx(
    utxos,
    new BN(amount),
    chainId,
    [cAddress],
    [xAddress],
    [xAddress],
  );

  const hash = await xChain.issueTx(exportTx.sign(xKeychain));
  return !!hash;
}

async function import_step(network: string, secret: string) {
  const client = getAvalancheClient(network);

  const [xChain, cChain] = [client.XChain(), client.CChain()];
  const [xKeychain, cKeychain] = [xChain.keyChain(), cChain.keyChain()];
  const [xKeypair, cKeypair] = [
    xKeychain.importKey(secret),
    cKeychain.importKey(secret),
  ];
  const [cAddress] = [cKeypair.getAddressString()];

  const xChainId = await client.Info().getBlockchainID('X');
  const {utxos} = await cChain.getUTXOs(cAddress, xChainId);

  const binTools = BinTools.getInstance();
  const keyBuff = binTools.cb58Decode(secret.split('-')[1]);
  const ethAddr = Address.fromPrivateKey(
    Buffer.from(keyBuff.toString('hex'), 'hex'),
  ).toString();

  const importTx = await cChain.buildImportTx(
    utxos,
    ethAddr,
    [cAddress],
    xChainId,
    [cAddress],
  );

  const hash = await cChain.issueTx(importTx.sign(cKeychain));
  return !!hash;
}

describe('Avalanche backend tests', () => {
  jest.setTimeout(15000);
  const network = 'datahub';
  const address = 'X-fuji10f9gsh80unawkxdtug42475u2kq22sv8xryekd';
  const secret = 'PrivateKey-tAUiooXNYuUMFjmiVxbhfBMKUfPgxMC5z4MuYjzwoALXTEzcV';

  test('Connect step', async () => {
    await expect(connect_step(network)).resolves.toBeTruthy();
  });

  test('Account step', async () => {
    await expect(account_step(network)).resolves.toBeTruthy();
  });

  test('Balance step', async () => {
    await expect(balance_step(network, address)).resolves.toBeTruthy();
  });

  test('Transfer step', async () => {
    await expect(transfer_step(network, address, secret)).resolves.toBeTruthy();
  });

  test('Export step', async () => {
    // avoid uxtos issue
    await new Promise((r) => setTimeout(r, 2000));
    await expect(export_step(network, secret)).resolves.toBeTruthy();
  });

  test('Import step', async () => {
    // avoid uxtos issue
    await new Promise((r) => setTimeout(r, 2000));
    await expect(import_step(network, secret)).resolves.toBeTruthy();
  });
});

'''
'''--- __test__/polygon.test.ts ---
import {getNodeURL} from 'components/protocols/polygon/lib';
import {ethers} from 'ethers';
import dotenv from 'dotenv';

dotenv.config({path: '.env.local'});

// Avoid jest open handle error
afterAll(async () => {
  await new Promise<void>((resolve) => setTimeout(() => resolve(), 10000));
});

async function query_step() {
  const url = getNodeURL();
  const provider = new ethers.providers.JsonRpcProvider(url, 'any');
  const blockHeight = await provider.getBlockNumber();
  const blockInfo = await provider.getBlockWithTransactions(blockHeight);
  return {blockInfo};
}

describe('Polygon backend tests', () => {
  // Avoid jest open handle error
  jest.setTimeout(30000);

  test('Query step', async () => {
    await expect(query_step()).resolves.toHaveProperty('blockInfo.number');
  });
});

'''
'''--- __test__/secret.test.ts ---
import {getNodeUrl} from 'components/protocols/secret/lib';
import {
  EnigmaUtils,
  SigningCosmWasmClient,
  CosmWasmClient,
  Secp256k1Pen,
  pubkeyToAddress,
  encodeSecp256k1Pubkey,
} from 'secretjs';
import {Bip39, Random} from '@iov/crypto';
import dotenv from 'dotenv';
import path from 'path';

dotenv.config({path: path.resolve('.env.local')});

// Avoid jest open handle error
afterAll(async () => {
  await new Promise<void>((resolve) => setTimeout(() => resolve(), 10000));
});

const client = new CosmWasmClient(getNodeUrl());

function getSecretExplorerURL(txHash: string) {
  return `https://secretnodes.com/secret/chains/supernova-2/transactions/${txHash}`;
}

async function getSigningPenFromMnemonic(mnemonic: string) {
  return await Secp256k1Pen.fromMnemonic(mnemonic);
}

async function getAddressFromMnemonic(mnemonic: string) {
  const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic);
  return pubkeyToAddress(encodeSecp256k1Pubkey(signingPen.pubkey), 'secret');
}

async function getBalanceFromMnemonic(mnemonic: string) {
  const account = await client.getAccount(
    await getAddressFromMnemonic(mnemonic),
  );
  return account?.balance[0].amount as string;
}

async function connection() {
  return await client.restClient.nodeInfo();
}

async function keypair(mnemonic: string) {
  if (!mnemonic) {
    const randomMnemonic = Bip39.encode(Random.getBytes(16)).toString();
    console.log('Generated mnemonic:', randomMnemonic);
    const signingPen = await Secp256k1Pen.fromMnemonic(randomMnemonic);
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');
    console.log('Address of generated mnemonic:', address);
    return address as string;
  } else {
    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic);
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');
    return address as string;
  }
}

async function balance(mnemonic: string) {
  try {
    return getBalanceFromMnemonic(mnemonic);
  } catch (error) {
    console.log(
      `Get balance for ${getAddressFromMnemonic(mnemonic)} error:`,
      error,
    );
  }
}

async function transfer(recipient: string, sender: string) {
  const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();
  const TX_AMOUNT = '100000';

  const fees = {
    send: {
      amount: [{amount: '80000', denom: 'uscrt'}],
      gas: '80000',
    },
  } as object;

  const signingPenSender = await getSigningPenFromMnemonic(sender);
  const senderAddress = pubkeyToAddress(
    encodeSecp256k1Pubkey(signingPenSender.pubkey),
    'secret',
  ) as string;

  const signingPenRecipient = await getSigningPenFromMnemonic(recipient);
  const receiverAddress = pubkeyToAddress(
    encodeSecp256k1Pubkey(signingPenRecipient.pubkey),
    'secret',
  ) as string;

  const client = new SigningCosmWasmClient(
    getNodeUrl() as string,
    senderAddress as string,
    (signBytes) => signingPenSender.sign(signBytes),
    txEncryptionSeed as Uint8Array,
    fees as object,
  );

  const sent = await client.sendTokens(
    receiverAddress as string,
    [
      {
        amount: TX_AMOUNT as string,
        denom: 'uscrt' as string,
      },
    ],
    'Testing sendTokens()',
  );

  console.log(
    `${senderAddress} to ${receiverAddress} : \n${getSecretExplorerURL(
      sent.transactionHash,
    )}`,
  );

  return sent;
}

/**
 * Test cases
 *
 * FUNDED     - spot history divert episode dove van unable hire bargain legal improve hurdle       // secret1v4n4du5w02degaalj682p03pjkthf4cund49hc
 * NOT FUNDED - expose ring elevator critic panther injury trigger person butter rescue local where // secret1xy0h5qpfssl20vfcx8a2cham6cmrr8mnl9ln4g
 * NOT FUNDED - multiply horror waste this enemy glue act dream camp reopen trophy brick            // secret1xangfqmzvdlf2z44mrv30nar6mv43ma7pc7k2j
 */

describe('Secret backend tests', () => {
  // Avoid jest open handle error
  jest.setTimeout(30000);

  test('Connection', async () => {
    await expect(connection()).resolves.toHaveProperty(
      'application_version.version',
    );
  });

  test('Generate keypair', async () => {
    await expect(keypair('')).resolves.toHaveLength(45);
  });

  test('Keypair from mnemonic', async () => {
    await expect(
      keypair(
        'multiply horror waste this enemy glue act dream camp reopen trophy brick',
      ),
    ).resolves.toHaveLength(45);
  });

  test('Funded balance', async () => {
    await expect(
      balance(
        'spot history divert episode dove van unable hire bargain legal improve hurdle',
      ), // secret1v4n4du5w02degaalj682p03pjkthf4cund49hc
    ).resolves.toBeDefined();
  });

  test('Not funded balance', async () => {
    await expect(
      balance(
        'multiply horror waste this enemy glue act dream camp reopen trophy brick',
      ), // secret1xangfqmzvdlf2z44mrv30nar6mv43ma7pc7k2j
    ).resolves.toBeUndefined();
  });

  test('Transfer', async () => {
    await expect(
      transfer(
        'expose ring elevator critic panther injury trigger person butter rescue local where',
        'spot history divert episode dove van unable hire bargain legal improve hurdle',
      ),
    ).resolves.toBeDefined();
  });
});

'''
'''--- __test__/solana.test.ts ---
import {getNodeURL} from 'components/protocols/solana/lib';
import {
  Connection,
  Keypair,
  PublicKey,
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  TransactionInstruction,
} from '@solana/web3.js';
import path from 'path';
import fs from 'mz/fs';
import dotenv from 'dotenv';
import * as borsh from 'borsh';

dotenv.config({path: '.env.local'});

// The state of a greeting account managed by the hello world program
class GreetingAccount {
  counter = 0;
  constructor(fields: {counter: number} | undefined = undefined) {
    if (fields) {
      this.counter = fields.counter;
    }
  }
}

// Borsh schema definition for greeting accounts
const GreetingSchema = new Map([
  [GreetingAccount, {kind: 'struct', fields: [['counter', 'u32']]}],
]);

// The expected size of each greeting account.
const GREETING_SIZE = borsh.serialize(
  GreetingSchema,
  new GreetingAccount(),
).length;

const PROGRAM_PATH = path.resolve('dist/solana/program');
const PROGRAM_SO_PATH = path.join(PROGRAM_PATH, 'helloworld.so');
const SECRET_PATH = path.resolve('dist/solana/program');
const SECRET_JSON_PATH = path.join(SECRET_PATH, 'helloworld-keypair.json');

async function createKeypairFromFile(filePath: string): Promise<Keypair> {
  const secretKeyString = await fs.readFile(filePath, {encoding: 'utf8'});
  const secretKey = Uint8Array.from(JSON.parse(secretKeyString));
  return Keypair.fromSecretKey(secretKey);
}

const getGreeterPublicKey = async (secret: string) => {
  const programId = (await createKeypairFromFile(SECRET_JSON_PATH)).publicKey;

  const payer = Keypair.fromSecretKey(new Uint8Array(JSON.parse(secret)));
  const GREETING_SEED = 'hello';

  const greetedPubkey = await PublicKey.createWithSeed(
    payer.publicKey,
    GREETING_SEED,
    programId,
  );

  return greetedPubkey;
};

// avoid jest open handle error
afterAll(async () => {
  await new Promise<void>((resolve) => setTimeout(() => resolve(), 10000));
});

// Connection step
async function connection_step(network: string) {
  const url = getNodeURL(network);
  const connection = new Connection(url, 'confirmed');
  const version = await connection.getVersion();
  return version;
}

async function fund_step(network: string, address: string) {
  const url = getNodeURL(network);
  const connection = new Connection(url, 'confirmed');
  const publicKey = new PublicKey(address);
  const hash = await connection.requestAirdrop(publicKey, LAMPORTS_PER_SOL);
  await connection.confirmTransaction(hash);
  return !!hash;
}

async function balance_step(network: string, address: string) {
  const url = getNodeURL(network);
  const connection = new Connection(url, 'confirmed');
  const publicKey = new PublicKey(address);
  const balance = await connection.getBalance(publicKey);
  return balance;
}

async function transfer_step(network: string, address: string, secret: string) {
  const url = getNodeURL(network);
  const connection = new Connection(url, 'confirmed');

  const fromPubkey = new PublicKey(address);
  const toPubkey = new PublicKey(
    'CBQACgyxWq9ndXPvQ2SJLLAp6ukhgrZBi6okHWyPGVZC',
  );
  const lamports = 100 * 1000 * 1000;
  const secretKey = Uint8Array.from(JSON.parse(secret as string));

  const instructions = SystemProgram.transfer({
    fromPubkey,
    toPubkey,
    lamports,
  });

  const signers = [
    {
      publicKey: fromPubkey,
      secretKey,
    },
  ];
  const transaction = new Transaction().add(instructions);

  const hash = await sendAndConfirmTransaction(
    connection,
    transaction,
    signers,
  );

  return !!hash;
}

async function greeter_step(network: string, secret: string) {
  const url = getNodeURL(network);
  const connection = new Connection(url, 'confirmed');
  const programId = (await createKeypairFromFile(SECRET_JSON_PATH)).publicKey;

  const payer = Keypair.fromSecretKey(new Uint8Array(JSON.parse(secret)));
  const GREETING_SEED = 'hello';

  const greetedPubkey = await PublicKey.createWithSeed(
    payer.publicKey,
    GREETING_SEED,
    programId,
  );

  const lamports = await connection.getMinimumBalanceForRentExemption(
    GREETING_SIZE,
  );

  const transaction = new Transaction().add(
    SystemProgram.createAccountWithSeed({
      fromPubkey: payer.publicKey,
      basePubkey: payer.publicKey,
      seed: GREETING_SEED,
      newAccountPubkey: greetedPubkey,
      lamports,
      space: GREETING_SIZE,
      programId,
    }),
  );
  const hash = await sendAndConfirmTransaction(connection, transaction, [
    payer,
  ]);
  return !!hash;
}

async function deploy_step(network: string) {
  const url = getNodeURL(network);
  const connection = new Connection(url, 'confirmed');
  const programId = await createKeypairFromFile(SECRET_JSON_PATH);

  const programInfo = await connection.getAccountInfo(programId.publicKey);

  if (programInfo === null) {
    if (fs.existsSync(PROGRAM_SO_PATH)) {
      throw new Error(
        'Program needs to be deployed with `solana program deploy`',
      );
    } else {
      throw new Error('Program needs to be built and deployed');
    }
  } else if (!programInfo.executable) {
    throw new Error(`Program is not executable`);
  }

  return true;
}

async function getter_step(network: string, secret: string) {
  const url = getNodeURL(network);
  const connection = new Connection(url, 'confirmed');
  const greeterPublicKey = await getGreeterPublicKey(secret);
  const accountInfo = await connection.getAccountInfo(greeterPublicKey);

  if (accountInfo === null) {
    throw new Error('Error: cannot find the greeted account');
  }

  const greeting = borsh.deserialize(
    GreetingSchema,
    GreetingAccount,
    accountInfo.data,
  );

  return greeting.counter;
}

async function setter_step(network: string, secret: string) {
  const url = getNodeURL(network);
  const connection = new Connection(url, 'confirmed');
  const programId = await createKeypairFromFile(SECRET_JSON_PATH);
  const greeterPublicKey = await getGreeterPublicKey(secret);

  const programKey = programId.publicKey;

  const payerSecretKey = new Uint8Array(JSON.parse(secret));
  const payerKeypair = Keypair.fromSecretKey(payerSecretKey);

  const instruction = new TransactionInstruction({
    keys: [{pubkey: greeterPublicKey, isSigner: false, isWritable: true}],
    programId: programKey,
    data: Buffer.alloc(0), // All instructions are hellos
  });

  const hash = await sendAndConfirmTransaction(
    connection,
    new Transaction().add(instruction),
    [payerKeypair],
  );

  return !!hash;
}

describe('Solana backend tests', () => {
  // avoid jest open handle error
  jest.setTimeout(30000);
  const network = process.env.JEST_ENV_NETWORK ?? 'devnet';
  const keypair = Keypair.generate();
  const address = keypair?.publicKey.toString();
  const secret = JSON.stringify(Array.from(keypair?.secretKey));

  test('Connection step', async () => {
    await expect(connection_step(network)).resolves.toHaveProperty(
      'solana-core',
    );
  });
  test('Fund step', async () => {
    await expect(fund_step(network, address)).resolves.toBeTruthy();
  });
  test('Balance step', async () => {
    await expect(balance_step(network, address)).resolves.toBe(
      LAMPORTS_PER_SOL,
    );
  });
  test('Transfer step', async () => {
    await expect(transfer_step(network, address, secret)).resolves.toBeTruthy();
  });
  test('Deploy step', async () => {
    await expect(deploy_step(network)).resolves.toBeTruthy();
  });
  test('Greeter step', async () => {
    await expect(greeter_step(network, secret)).resolves.toBeTruthy();
  });
  test('Getter step', async () => {
    await expect(getter_step(network, secret)).resolves.toBeGreaterThanOrEqual(
      0,
    );
  });
  test('Setter step', async () => {
    await expect(setter_step(network, secret)).resolves.toBeTruthy();
  });
});

'''
'''--- components/protocols/avalanche/components/index.ts ---
export {default as Account} from '@figment-avalanche/components/Account';
export {default as Connect} from '@figment-avalanche/components/Connect';
export {default as Transfer} from '@figment-avalanche/components/Transfer';
export {default as Balance} from '@figment-avalanche/components/Balance';
export {default as Import} from '@figment-avalanche/components/Import';
export {default as Export} from '@figment-avalanche/components/Export';

'''
'''--- components/protocols/avalanche/lib/index.ts ---
import {Avalanche} from 'avalanche';

const AVALANCHE_NETWORK_ID = 5;
const AVALANCHE_NETWORK_NAME = 'fuji';

export const getNodeURL = (network: string) => {
  if (network === 'Testnet') {
    return 'https://api.avax-test.network';
  } else {
    return `https://${process.env.AVALANCHE_DATAHUB_URL}/apikey/${process.env.DATAHUB_AVALANCHE_API_KEY}`;
  }
};

export const getAvalancheClient = (network: string) => {
  const url = new URL(getNodeURL(network));

  const client = new Avalanche(
    url.hostname,
    parseInt(url.port),
    url.protocol.replace(':', ''),
    AVALANCHE_NETWORK_ID,
    'X',
    'C',
    AVALANCHE_NETWORK_NAME,
  );

  client.setAuthToken(process.env.DATAHUB_AVALANCHE_API_KEY as string);

  return client;
};

export const transactionUrl = (txId: string) => {
  return `https://explorer.avax-test.network/tx/${txId}`;
};

export const accountExplorer = (network: string) => (address: string) => {
  return `https://explorer.avax-test.network/address/${address}`;
};

'''
'''--- components/protocols/celo/components/index.ts ---
export {default as Connect} from '@figment-celo/components/Connect';
export {default as Account} from '@figment-celo/components/Account';
export {default as Balance} from '@figment-celo/components/Balance';
export {default as Transfer} from '@figment-celo/components/Transfer';
export {default as Swap} from '@figment-celo/components/Swap';
export {default as Deploy} from '@figment-celo/components/Deploy';
export {default as Setter} from '@figment-celo/components/Setter';
export {default as Getter} from '@figment-celo/components/Getter';

'''
'''--- components/protocols/celo/lib/index.ts ---
export const getNodeUrl = (network: string) =>
  network === 'Datahub'
    ? `https://celo-alfajores--rpc.datahub.figment.io/apikey/${process.env.DATAHUB_CELO_API_KEY}/`
    : 'https://alfajores-forno.celo-testnet.org';

export const transactionUrl = (hash: string) =>
  `https://alfajores-blockscout.celo-testnet.org/tx/${hash}`;

export const accountExplorer = (network: string) => (address: string) =>
  `https://alfajores-blockscout.celo-testnet.org/address/${address}`;

'''
'''--- components/protocols/ceramic/lib/figmentLearnSchema.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema",
  "title": "FigmentLearn",
  "description": "Web3 learning with Figment Learn",
  "type": "object",
  "properties": {
    "text": {
      "type": "string",
      "maxLength": 300
    },
    "author": {
      "type": "string",
      "maxLength": 150
    }
  }
}

'''
'''--- components/protocols/ceramic/lib/figmentLearnSchemaCompact.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema",
  "title": "FigmentLearn",
  "description": "Web3 learning with Figment Learn",
  "type": "object",
  "properties": {
    "text": {"type": "string", "maxLength": 300},
    "author": {"type": "string", "maxLength": 150}
  }
}

'''
'''--- components/protocols/ceramic/lib/identityStore/LocalStorage.ts ---
import {IdentityKey, IdentityStore} from './';
import {BasicProfile} from '@ceramicstudio/idx-constants';

class LocalStorageIdentityStore implements IdentityStore {
  constructor(private readonly prefix: string) {}

  async setAddress(value: string): Promise<void> {
    localStorage.setItem(this.getKey(IdentityKey.ADDRESS), value);
  }

  async getAddress(): Promise<string | null> {
    return localStorage.getItem(this.getKey(IdentityKey.ADDRESS));
  }

  async setDID(value: string): Promise<void> {
    localStorage.setItem(this.getKey(IdentityKey.DID), value);
  }

  async getDID(): Promise<string | null> {
    return localStorage.getItem(this.getKey(IdentityKey.DID));
  }

  async setBasicProfile(value: BasicProfile): Promise<void> {
    localStorage.setItem(
      this.getKey(IdentityKey.BASIC_PROFILE),
      JSON.stringify(value),
    );
  }

  async getBasicProfile(): Promise<BasicProfile | null> {
    const value = localStorage.getItem(this.getKey(IdentityKey.BASIC_PROFILE));

    if (value) {
      return JSON.parse(value);
    }

    return null;
  }

  async clearAll(): Promise<void> {
    this.clear(IdentityKey.ADDRESS);
    this.clear(IdentityKey.DID);
    this.clear(IdentityKey.BASIC_PROFILE);
  }

  async clear(key: IdentityKey): Promise<void> {
    localStorage.removeItem(this.getKey(key));
  }

  getKey(key: IdentityKey): string {
    return `${this.prefix}:${key}`;
  }
}

export default LocalStorageIdentityStore;

'''
'''--- components/protocols/ceramic/lib/identityStore/index.ts ---
import {BasicProfile} from '@ceramicstudio/idx-constants';

export enum IdentityKey {
  ADDRESS = 'Address',
  DID = 'DID',
  BASIC_PROFILE = 'BasicProfile',
}

export interface IdentityStore {
  setAddress: (value: string) => Promise<void>;
  getAddress: () => Promise<string | null>;
  setDID: (value: string) => Promise<void>;
  getDID: () => Promise<string | null>;
  setBasicProfile: (value: BasicProfile) => Promise<void>;
  getBasicProfile: () => Promise<BasicProfile | null>;
  clear: (key: IdentityKey) => void;
  clearAll: () => void;
}

'''
'''--- components/protocols/ceramic/lib/index.ts ---
export const aliases = {
  figment: '<CUSTOM DEFINITION STREAM ID>',
};

'''
'''--- components/protocols/ceramic/types/index.ts ---
export type EntryT = {
  msg: string;
  display?: (value: string) => string;
  value: string;
};

export type QuoteSchemaT = {
  text: string;
  author: string;
};

export enum IdxSchema {
  BasicProfile = 'basicProfile',
  Figment = 'figment',
}

'''
'''--- components/protocols/near/components/index.ts ---
export {default as Account} from '@figment-near/components/Account';
export {default as Balance} from '@figment-near/components/Balance';
export {default as Connect} from '@figment-near/components/Connect';
export {default as Keypair} from '@figment-near/components/Keypair';
export {default as Transfer} from '@figment-near/components/Transfer';
export {default as Deploy} from '@figment-near/components/Deploy';
export {default as Setter} from '@figment-near/components/Setter';
export {default as Getter} from '@figment-near/components/Getter';

'''
'''--- components/protocols/near/lib/index.ts ---
import {keyStores, ConnectConfig, KeyPair} from 'near-api-js';
import {InMemoryKeyStore} from 'near-api-js/lib/key_stores';

export const configFromNetwork = (network: string): ConnectConfig => {
  const nodeUrl =
    network === 'Datahub'
      ? `${process.env.NEAR_DATAHUB_URL}/apikey/${process.env.DATAHUB_NEAR_API_KEY}`
      : 'https://rpc.testnet.near.org';

  const keyStore: InMemoryKeyStore = new keyStores.InMemoryKeyStore();
  const config = {
    keyStore,
    nodeUrl,
    networkId: 'testnet',
    walletUrl: 'https://wallet.testnet.near.org',
    helperUrl: 'https://helper.testnet.near.org',
    explorerUrl: 'https://explorer.testnet.near.org',
  };
  return config;
};

export const transactionUrl = (hash: string) =>
  `https://explorer.testnet.near.org/transactions/${hash}`;

export const accountExplorer = (network: string) => (address: string) =>
  `https://explorer.testnet.near.org/accounts/${address}`;

export const getPrettyPublicKey = (secretKey: string) =>
  KeyPair.fromString(secretKey).getPublicKey().toString().slice(8);

export const getPublicKey = (secretKey: string) =>
  KeyPair.fromString(secretKey).getPublicKey().toString();

'''
'''--- components/protocols/polkadot/components/index.ts ---
export {default as Connect} from '@figment-polkadot/components/Connect';
export {default as Account} from '@figment-polkadot/components/Account';
export {default as Balance} from '@figment-polkadot/components/Balance';
export {default as Transfer} from '@figment-polkadot/components/Transfer';
export {default as Restore} from '@figment-polkadot/components/Restore';
export {default as Estimate} from '@figment-polkadot/components/Estimate';
export {default as Deposit} from '@figment-polkadot/components/Deposit';

'''
'''--- components/protocols/polkadot/lib/index.ts ---
export const getNodeUrl = (network: string) => {
  if (network === 'Datahub') {
    return `${process.env.POLKADOT_DATAHUB_URL}/apikey/${process.env.DATAHUB_POLKADOT_API_KEY}`;
  } else {
    return 'wss://westend-rpc.polkadot.io';
  }
};

export const accountExplorer = (network: string) => (address: string) =>
  `https://westend.subscan.io/account/${address}`;

export const transactionUrl = (hash: string) =>
  `https://westend.subscan.io/extrinsic/${hash}`;

export const FAUCET_URL = `https://app.element.io/#/room/#westend_faucet:matrix.org`;

'''
'''--- components/protocols/polygon/challenges/balance.ts ---
import {ethers} from 'ethers';

declare let window: {
  ethereum: ethers.providers.ExternalProvider;
};

const getBalance = async (address: string) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);

    const balance = undefined;
    if (!balance) {
      throw new Error('Please complete the code');
    }
    return {
      balance: balance.toString(),
    };
  } catch (error) {
    return {
      error: error.message,
    };
  }
};

export default getBalance;

'''
'''--- components/protocols/polygon/challenges/connect.ts ---
import {ethers} from 'ethers';

declare let window: {
  ethereum: ethers.providers.ExternalProvider;
};

const connect = async () => {
  try {
    const provider = undefined;
    if (provider) {
      await undefined;
      const signer = undefined;
      const address = undefined;
      return {
        address,
      };
    } else {
      return {
        error: 'Please install Metamask at https://metamask.io',
      };
    }
  } catch (error) {
    return {
      error: 'An unexpected error occurs',
    };
  }
};

export default connect;

'''
'''--- components/protocols/polygon/challenges/deploy.ts ---
import {ethers} from 'ethers';

declare let window: {
  ethereum: ethers.providers.ExternalProvider;
};

const deploy = async (contract: string) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.getCode(contract);
    return {
      status: true,
    };
  } catch (error) {
    return {
      error: error.message,
    };
  }
};

export default deploy;

'''
'''--- components/protocols/polygon/challenges/getter.ts ---
import SimpleStorageJson from 'contracts/polygon/SimpleStorage/SimpleStorage.json';
import {ethers} from 'ethers';

declare let window: {
  ethereum: ethers.providers.ExternalProvider;
};

const getValue = async (contractAddress: string) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    // try to figure out the expected parameters
    const contract = new ethers.Contract(undefined);
    // try to figure out the expected method
    const value = undefined;
    return {value};
  } catch (error) {
    return {
      error: error.message,
    };
  }
};

export default getValue;

'''
'''--- components/protocols/polygon/challenges/index.ts ---
export {default as connect} from '@figment-polygon/challenges/connect';
export {default as query} from '@figment-polygon/challenges/query';
export {default as getBalance} from '@figment-polygon/challenges/balance';
export {default as transfer} from '@figment-polygon/challenges/transfer';
export {default as deploy} from '@figment-polygon/challenges/deploy';
export {default as getValue} from '@figment-polygon/challenges/getter';
export {default as setValue} from '@figment-polygon/challenges/setter';
export {default as restore} from '@figment-polygon/challenges/restore';

'''
'''--- components/protocols/polygon/challenges/query.ts ---
import {ethers} from 'ethers';

declare let window: {
  ethereum: ethers.providers.ExternalProvider;
};

const query = async () => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const networkName = await provider.getNetwork().then((res) => {
      return res.name;
    });

    // TODO: Define the variables below
    const chainId = undefined;
    const blockHeight = undefined;
    const gasPriceAsGwei = undefined;
    const blockInfo = undefined;

    if (!chainId || !blockHeight || !gasPriceAsGwei || !blockInfo) {
      throw new Error('Please complete the code');
    }

    return {
      data: {
        networkName,
        chainId,
        blockHeight,
        gasPriceAsGwei,
        blockInfo,
      },
    };
  } catch (error) {
    return {
      error: error.message,
    };
  }
};

export default query;

'''
'''--- components/protocols/polygon/challenges/restore.ts ---
import {ethers} from 'ethers';

const restore = (mnemonic: string, address?: string) => {
  try {
    const wallet = undefined;
    if (wallet.address === address) {
      const restoredAddress = wallet.address;
      return {
        restoredAddress,
      };
    } else {
      return {error: 'Unable to restore account'};
    }
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return {error: errorMessage};
  }
};

export default restore;

'''
'''--- components/protocols/polygon/challenges/setter.ts ---
import SimpleStorageJson from 'contracts/polygon/SimpleStorage/SimpleStorage.json';
import {ethers} from 'ethers';

declare let window: {
  ethereum: ethers.providers.ExternalProvider;
};

const setValue = async (contractAddress: string, value: number) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    // try to figure out the expected parameters
    const contract = new ethers.Contract(undefined);
    // try to figure out the expected method
    const transactionResult = undefined;
    const receipt = await transactionResult.wait();
    return {hash: receipt.transactionHash};
  } catch (error) {
    return {
      error: error.message,
    };
  }
};

export default setValue;

'''
'''--- components/protocols/polygon/challenges/transfer.ts ---
import {ethers} from 'ethers';

declare let window: {
  ethereum: ethers.providers.ExternalProvider;
};

// A random test's address
const RECIPIENT = '0xb11D554F2139d843F5c94a3185d17C4d5762a7c7';
// 0.1 MATIC
const AMOUNT = '0.01';

const transfer = async () => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const send_account = provider.getSigner().getAddress();

    const currentGasPrice = await provider.getGasPrice();
    const gas_price = ethers.utils.hexlify(
      parseInt(currentGasPrice.toString()),
    );

    const transaction = undefined;

    const hash = undefined;
    const receipt = await hash.wait();
    return {hash: receipt.transactionHash};
  } catch (error) {
    return {
      error: error.message,
    };
  }
};

export default transfer;

'''
'''--- components/protocols/polygon/components/index.ts ---
export {default as Connect} from '@figment-polygon/components/Connect';
export {default as Query} from '@figment-polygon/components/Query';
export {default as Restore} from '@figment-polygon/components/Restore';
export {default as Balance} from '@figment-polygon/components/Balance';
export {default as Transfer} from '@figment-polygon/components/Transfer';
export {default as Deploy} from '@figment-polygon/components/Deploy';
export {default as Setter} from '@figment-polygon/components/Setter';
export {default as Getter} from '@figment-polygon/components/Getter';

'''
'''--- components/protocols/polygon/lib/index.ts ---
export const accountExplorer = (network: string) => (address: string) => {
  return `https://mumbai.polygonscan.com/address/${address}`;
};

export const getPolygonBlockExplorerURL = (block: number) => {
  return `https://mumbai.polygonscan.com/block/${block}`;
};

export const getPolygonTxExplorerURL = (txId: string) => {
  return `https://mumbai.polygonscan.com/tx/${txId}`;
};

export const getPolygonTokenExplorerURL = (address: string) => {
  return `https://mumbai.polygonscan.com/token/${address}`;
};

export const getPolygonFaucetURL = () => {
  return `https://faucet.polygon.technology/`;
};

'''
'''--- components/protocols/pyth/components/index.ts ---
export {default as Connect} from '@figment-pyth/components/Connect';
export {default as Wallet} from '@figment-pyth/components/Wallet';
export {default as ChartMock} from '@figment-pyth/components/ChartMock';
export {default as Exchange} from '@figment-pyth/components/Exchange';
export {default as Liquidate} from '@figment-pyth/components/Liquidate';

'''
'''--- components/protocols/pyth/lib/index.ts ---
import {CHAINS, PYTH_NETWORKS, PYTH_PROTOCOLS} from 'types';
import {getNodeURL as getNodeUrl} from 'utils/datahub';

/**
 * Helper for generating an account URL on Solana Explorer
 * @param network - A Solana cluster identifier, one of ['mainnet-beta', 'devnet', 'testnet', 'localnet']
 * @returns URL
 */
export const accountExplorer = (network: string) => (address: string) => {
  if (network === PYTH_NETWORKS.LOCALNET) {
    return `https://explorer.solana.com/address/${address}?cluster=custom&customUrl=http://127.0.0.1:8899`;
  } else if (network === PYTH_NETWORKS.DEVNET) {
    return `https://explorer.solana.com/address/${address}?cluster=devnet`;
  } else if (network === PYTH_NETWORKS.TESTNET) {
    return `https://explorer.solana.com/address/${address}?cluster=testnet`;
  } else {
    return `https://explorer.solana.com/address/${address}`;
  }
};

/**
 * Helper for generating a transaction URL on Solana Explorer
 * @param network - A Solana cluster identifier, one of ['mainnet-beta', 'devnet', 'testnet', 'localnet']
 * @returns URL
 */
export const transactionExplorer = (network: string) => (hash: string) => {
  if (network === PYTH_NETWORKS.LOCALNET) {
    return `https://explorer.solana.com/tx/${hash}?cluster=custom&customUrl=http://127.0.0.1:8899`;
  } else if (network === PYTH_NETWORKS.DEVNET) {
    return `https://explorer.solana.com/tx/${hash}?cluster=devnet`;
  } else if (network === PYTH_NETWORKS.TESTNET) {
    return `https://explorer.solana.com/tx/${hash}?cluster=testnet`;
  } else if (network === PYTH_NETWORKS.MAINNET) {
    return `https://explorer.solana.com/tx/${hash}`;
  }
};

/**
 * Helper for generating an account URL on solscan.io
 * @param network - A Solana cluster identifier, one of ['mainnet-beta', 'devnet', 'testnet'] * `localnet` is not supported.
 * @param pubkey - A valid Solana public key
 * @returns URL
 */
export const accountSolscan = (network: string, pubkey: string) => {
  if (network === PYTH_NETWORKS.DEVNET) {
    return `https://solscan.io/account/${pubkey}?cluster=devnet`;
  } else if (network === PYTH_NETWORKS.TESTNET) {
    return `https://solscan.io/account/${pubkey}?cluster=testnet`;
  } else if (network === PYTH_NETWORKS.MAINNET) {
    return `https://solscan.io/account/${pubkey}`;
  }
};

/**
 * Helper for generating a transaction URL on solscan.io
 * @param network - A Solana cluster identifier, one of ['mainnet-beta', 'devnet', 'testnet'] * `localnet` is not supported.
 * @param hash - A valid Solana transaction hash
 * @returns URL
 */
export const transactionSolscan = (network: string, hash: string) => {
  if (network === PYTH_NETWORKS.DEVNET) {
    return `https://solscan.io/tx/${hash}?cluster=devnet`;
  } else if (network === PYTH_NETWORKS.TESTNET) {
    return `https://solscan.io/tx/${hash}?cluster=testnet`;
  } else if (network === PYTH_NETWORKS.MAINNET) {
    return `https://solscan.io/tx/${hash}`;
  }
};

/**
 * Helper function for showing Pyth market data on pyth.network
 * @param network - A Solana cluster identifier, one of ['mainnet-beta', 'devnet', 'testnet']
 * @param product - A Pyth product name in the format <product_type>.<TokenA>/<TokenB> e.g. 'Crypto.SOL/USD'
 *                - Note: If no network is specified, the URL will not require the product type, so pass the product as the token pair only, e.g. AUD/USD instead of FX.AUD/USD
 * @returns URL
 */
export const pythMarketExplorer = (network: string, product: string) => {
  if (!network) {
    return `https://pyth.network/markets/#${product}`; // Product
  }
  return `https://pyth.network/markets/?cluster=${network}#${product}`;
};

/**
 * Helper function for getting the DataHub endpoint URL
 * @param network A network identifier, one of ['datahub', 'devnet', 'localnet']
 * @returns URL
 *
 * - NOTE: This function, `getNodeURL` prefills chain, network and protocol for the DataHub util function `getNodeUrl`.
 */
export const getNodeURL = (network?: string) =>
  getNodeUrl(CHAINS.PYTH, PYTH_NETWORKS.DEVNET, PYTH_PROTOCOLS.RPC, network);

'''
'''--- components/protocols/pyth/lib/swap.ts ---
import {transactionSolscan} from './index';
import {
  Cluster,
  Connection,
  Keypair,
  PublicKey,
  Transaction,
  SystemProgram,
  TransactionInstruction,
} from '@solana/web3.js';
import {Jupiter, RouteInfo, TOKEN_LIST_URL} from '@jup-ag/core';
import {getOrca, OrcaPoolConfig, Network} from '@orca-so/sdk';
import {
  Token,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
} from '@solana/spl-token';
import Decimal from 'decimal.js';
import {SOL_DECIMAL, USDC_DECIMAL, ORCA_DECIMAL} from './wallet';
// If you want to experiment with the keypair below, uncomment the bs58 import.
// import * as bs58 from 'bs58';

// Set true for additional logging during the swap process.
const logging = false;

/**
 * Logging the Keypair object, you'll notice that the publicKey is a 32-byte UInt8Array & the secretKey is the entire 64-byte UInt8Array
 * The first 32 bytes of the array are the secret key and the last 32 bytes of the array are the public key
 * console.log(_account)
 *
 * This returns the entire UInt8Array of 64 bytes
 * console.log(_account.secretKey)
 *
 * The secret key in base58 encoding: 4WoxErVFHZSaiTyDjUhqd6oWRL7gHZJd8ozvWWKZY9EZEtrqxCiD8CFvak7QRCYpuZHLU8FTGALB9y5yenx8rEq3
 * console.log(bs58.encode(_account.secretKey));
 *
 * The publicKey property is either a UInt8Array or a BigNumber:
 * PublicKey { _bn: <BN: 7dfd7f354726fed61eaa4745502e344c65f622106004a427dc58b8c98ab4b5ee> }
 * console.log(_account.publicKey)
 *
 * The public key is commonly represented as a string when being used as an "address": 9UpA4MYkBw5MGfDm5oCB6hskMt6LdUZ8fUtapG6NioLH
 * console.log(_account.publicKey.toString());
 */
// This keypair is provided for testing & learning purposes only.
// Do NOT use this keypair in any production code.
// const _account = Keypair.fromSecretKey(
//   new Uint8Array([
//     175, 193, 241, 226, 223, 32, 155, 13, 1, 120, 157, 36, 15, 39, 141, 146,
//     197, 180, 138, 112, 167, 209, 70, 94, 103, 202, 166, 62, 81, 18, 143, 49,
//     125, 253, 127, 53, 71, 38, 254, 214, 30, 170, 71, 69, 80, 46, 52, 76, 101,
//     246, 34, 16, 96, 4, 164, 39, 220, 88, 184, 201, 138, 180, 181, 238,
//   ]),
// );

// Token interface for Jupiter SDK
export interface TokenI {
  chainId: number; // 101,
  address: string; // '8f9s1sUmzUbVZMoMh6bufMueYH1u4BJSM57RCEvuVmFp',
  symbol: string; // 'TRUE',
  name: string; // 'TrueSight',
  decimals: number; // 9,
  logoURI: string; // 'https://i.ibb.co/pKTWrwP/true.jpg',
  tags: string[]; // [ 'utility-token', 'capital-token' ]
}

// SwapResult interface
export interface SwapResult {
  inAmount: number;
  outAmount: number;
  txIds: string[];
  error?: any;
  timestamp: number; // Unix timestamp
}

export class OrcaSwapClient {
  constructor(
    public readonly keypair: Keypair,
    public readonly connection: Connection,
  ) {}

  /**
   *  The makeATA, closeATA and wrapSOL functions are included for reference.
   *  These instructions are abstracted away from developers during the Orca swap process.
   *  It is still good to understand how these transactions are constructed.
   */

  /**
   * @param mintPubkey - The mint public key of the token for which you want to make an Associated Token Account
   */
  async makeATA(mintPubkey: PublicKey) {
    let ata = await Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID, // always ASSOCIATED_TOKEN_PROGRAM_ID
      TOKEN_PROGRAM_ID, // always TOKEN_PROGRAM_ID
      mintPubkey, // mint PublicKey
      this.keypair.publicKey, // owner
    );
    console.log(`ATA for ${mintPubkey}: ${ata.toBase58()}`);
    let tx = new Transaction().add(
      Token.createAssociatedTokenAccountInstruction(
        ASSOCIATED_TOKEN_PROGRAM_ID, // always ASSOCIATED_TOKEN_PROGRAM_ID
        TOKEN_PROGRAM_ID, // always TOKEN_PROGRAM_ID
        mintPubkey, // mint
        ata, // ata
        this.keypair.publicKey, // owner of token account
        this.keypair.publicKey, // fee payer
      ),
    );
    const txHash = await this.connection.sendTransaction(tx, [this.keypair]);
    console.log(`makeATA txhash: ${transactionSolscan('devnet', txHash)}`);
  }

  /**
   * @param tokenAcctPubkey - The public key of the Associated Token Account you want to close.
   */
  async closeATA(tokenAcctPubkey: PublicKey) {
    let tx = new Transaction().add(
      Token.createCloseAccountInstruction(
        TOKEN_PROGRAM_ID, // always TOKEN_PROGRAM_ID
        tokenAcctPubkey, // token account that you want to close
        this.keypair.publicKey, // destination
        this.keypair.publicKey, // owner of token account
        [], // for multisig
      ),
    );
    const txHash = await this.connection.sendTransaction(tx, [
      this.keypair,
      this.keypair,
    ]);
    console.log(`closeATA txhash: ${transactionSolscan('devnet', txHash)}`);
  }

  /**
   * @param amount An amount of SOL to wrap
   * @param ata - Public key of the Associated Token Account to transfer the wrapped SOL into
   */
  async wrapSOL(amount: number, ata: PublicKey) {
    let tx = new Transaction().add(
      // Transfer SOL
      SystemProgram.transfer({
        fromPubkey: this.keypair.publicKey,
        toPubkey: ata,
        lamports: amount,
      }),
      // Sync Native instruction. @solana/spl-token will release it soon.
      // Here use the raw instruction temporarily.
      new TransactionInstruction({
        keys: [
          {
            pubkey: ata,
            isSigner: false,
            isWritable: true,
          },
        ],
        data: Buffer.from(new Uint8Array([17])),
        programId: TOKEN_PROGRAM_ID,
      }),
    );
    const txHash = await this.connection.sendTransaction(tx, [
      this.keypair,
      this.keypair,
    ]);
    console.log(`wSOL txhash: ${transactionSolscan('devnet', txHash)}`);
  }

  /**
   * @param size The amount of token to swap;
   * @returns TxIds, inAmount, outAmount
   */
  async buy(size: number): Promise<SwapResult> {
    const orca = getOrca(this.connection, Network.DEVNET);
    const orcaSOLPool = orca.getPool(OrcaPoolConfig.ORCA_SOL);
    const orcaUSDCPool = orca.getPool(OrcaPoolConfig.ORCA_USDC);
    const orcaToken = orcaUSDCPool.getTokenA();
    const usdcToken = orcaUSDCPool.getTokenB();
    const usdcAmount = new Decimal(size);
    // Setting slippage lower is not recommended as it can cause swaps to fail
    const slippage = new Decimal(5.0);

    // Swap from USDC -> ORCA
    const quote1 = await orcaUSDCPool.getQuote(usdcToken, usdcAmount, slippage);
    const usdcQuoteAmount = quote1.getMinOutputAmount();
    console.log(
      `Swap ${usdcAmount.toString()} USDC for at least ${usdcQuoteAmount.toNumber()} ORCA`,
    );
    const swapPayload = await orcaUSDCPool.swap(
      this.keypair,
      usdcToken,
      usdcAmount,
      usdcQuoteAmount,
    );

    const swap1TxId = await swapPayload.execute();

    if (logging) {
      console.log('Signature:', transactionSolscan('devnet', swap1TxId), '\n');
    }

    // Swap from ORCA -> SOL
    const quote2 = await orcaSOLPool.getQuote(
      orcaToken,
      usdcQuoteAmount,
      slippage,
    );
    const solQuoteAmount = quote2.getMinOutputAmount();
    console.log(
      `Swap ${usdcQuoteAmount.toNumber()} ORCA for at least ${solQuoteAmount.toNumber()} SOL`,
    );
    const swap2Payload = await orcaSOLPool.swap(
      this.keypair,
      orcaToken,
      usdcQuoteAmount,
      solQuoteAmount,
    );
    const swap2TxId = await swap2Payload.execute();

    if (logging) {
      console.log('Signature:', transactionSolscan('devnet', swap2TxId), '\n');
    }

    return {
      txIds: [swap1TxId, swap2TxId],
      inAmount: usdcAmount.toNumber() * USDC_DECIMAL,
      outAmount: solQuoteAmount.toNumber() * SOL_DECIMAL,
    } as SwapResult;
  }

  /**
   * @param size The amount of token to swap;
   * @returns TxIds, inAmount, outAmount
   */
  async sell(size: number): Promise<SwapResult> {
    const orca = getOrca(this.connection, Network.DEVNET);
    const orcaSOLPool = orca.getPool(OrcaPoolConfig.ORCA_SOL);
    const solToken = orcaSOLPool.getTokenB();
    const solAmount = new Decimal(size);
    const orcaUSDCPool = orca.getPool(OrcaPoolConfig.ORCA_USDC);
    const orcaToken = orcaSOLPool.getTokenA();
    const usdcToken = orcaUSDCPool.getTokenB();
    // Setting slippage lower is not recommended as it can cause swaps to fail
    const slippage = new Decimal(5.0);

    // Swap SOL -> ORCA
    const quote1 = await orcaSOLPool.getQuote(solToken, solAmount, slippage);
    const orcaQuoteAmount = quote1.getMinOutputAmount();
    console.log(
      `Swap ${solAmount.toString()} SOL for at least ${orcaQuoteAmount.toNumber()} ORCA`,
    );
    const swapPayload = await orcaSOLPool.swap(
      this.keypair,
      solToken,
      solAmount,
      orcaQuoteAmount,
    );
    const swap1TxId = await swapPayload.execute();

    if (logging) {
      console.log('Signature:', transactionSolscan('devnet', swap1TxId), '\n');
    }

    // Swap ORCA -> USDC
    const quote2 = await orcaUSDCPool.getQuote(
      orcaToken,
      orcaQuoteAmount,
      slippage,
    );
    const usdcQuoteAmount = quote2.getMinOutputAmount();
    console.log(
      `Swap ${orcaQuoteAmount.toNumber()} ORCA for at least ${usdcQuoteAmount.toNumber()} USDC`,
    );
    const swap2Payload = await orcaUSDCPool.swap(
      this.keypair,
      orcaToken,
      orcaQuoteAmount,
      usdcQuoteAmount,
    );
    const swap2TxId = await swap2Payload.execute();

    if (logging) {
      console.log('Signature:', transactionSolscan('devnet', swap2TxId), '\n');
    }

    return {
      txIds: [swap1TxId, swap2TxId],
      inAmount: solAmount.toNumber() * SOL_DECIMAL,
      outAmount: usdcQuoteAmount.toNumber() * USDC_DECIMAL,
    } as SwapResult;
  }

  /**
   * @param size The amount of token to swap;
   * @returns TxIds, inAmount, outAmount
   */
  async sell_to_orca(size: number): Promise<SwapResult> {
    const orca = getOrca(this.connection, Network.DEVNET);
    const orcaSOLPool = orca.getPool(OrcaPoolConfig.ORCA_SOL);
    const solToken = orcaSOLPool.getTokenB();
    const solAmount = new Decimal(size);
    // Setting slippage lower is not recommended as it can cause swaps to fail
    const slippage = new Decimal(5.0);

    const quote1 = await orcaSOLPool.getQuote(solToken, solAmount, slippage);
    const orcaQuoteAmount = quote1.getMinOutputAmount();
    console.log(
      `Swap ${solAmount.toString()} SOL for at least ${orcaQuoteAmount.toNumber()} ORCA`,
    );
    const swapPayload = await orcaSOLPool.swap(
      this.keypair,
      solToken,
      solAmount,
      orcaQuoteAmount,
    );
    const swapTxId = await swapPayload.execute();

    if (logging) {
      console.log('Signature:', transactionSolscan('devnet', swapTxId), '\n');
    }

    return {
      txIds: [swapTxId],
      inAmount: solAmount.toNumber() * SOL_DECIMAL,
      outAmount: orcaQuoteAmount.toNumber() * ORCA_DECIMAL,
    } as SwapResult;
  }

  /**
   * @param size The amount of token to swap;
   * @returns TxIds, inAmount, outAmount
   */
  async buy_from_orca(size: number): Promise<SwapResult> {
    const orca = getOrca(this.connection, Network.DEVNET);
    const orcaSOLPool = orca.getPool(OrcaPoolConfig.ORCA_SOL);
    const orcaAmount = new Decimal(size);
    const orcaToken = orcaSOLPool.getTokenA();
    // Setting slippage lower is not recommended as it can cause swaps to fail
    const slippage = new Decimal(5.0);

    const quote1 = await orcaSOLPool.getQuote(orcaToken, orcaAmount, slippage);
    const solQuoteAmount = quote1.getMinOutputAmount();
    console.log(
      `Swap ${orcaAmount.toString()} ORCA for at least ${solQuoteAmount.toNumber()} SOL`,
    );
    const swapPayload = await orcaSOLPool.swap(
      this.keypair,
      orcaToken,
      orcaAmount,
      solQuoteAmount,
    );
    const swapTxId = await swapPayload.execute();

    if (logging) {
      console.log('Signature:', transactionSolscan('devnet', swapTxId), '\n');
    }

    return {
      txIds: [swapTxId],
      inAmount: orcaAmount.toNumber() * ORCA_DECIMAL,
      outAmount: solQuoteAmount.toNumber() * SOL_DECIMAL,
    } as SwapResult;
  }
}

/**
 * Currently, Jupiter aggregation only works with Solana mainnet.
 */
export class JupiterSwapClient {
  private jupiter: Jupiter;

  constructor(
    jupiter: Jupiter,
    public readonly tokenA: TokenI,
    public readonly tokenB: TokenI,
    public readonly keypair: Keypair,
  ) {
    this.jupiter = jupiter;
  }

  static async initialize(
    connection: Connection,
    cluster: Cluster,
    keypair: Keypair,
    tokenAMintAddress: String, // Token to buy
    tokenBMintAddress: String, // token to sell
  ) {
    const jupiter = await Jupiter.load({connection, cluster, user: keypair});
    const tokens: TokenI[] = await (
      await fetch(TOKEN_LIST_URL[cluster])
    ).json(); // Fetch token list from Jupiter API
    const inputToken = tokens.find((t) => t.address == tokenAMintAddress); // Buy token
    const outputToken = tokens.find((t) => t.address == tokenBMintAddress); // Sell token
    console.log('Input token:', inputToken);
    console.log('Output token:', outputToken);
    console.log('Keypair:', keypair);
    console.log(connection, cluster);
    if (!inputToken || !outputToken) {
      throw new Error('Token not found');
    }

    return new JupiterSwapClient(jupiter, inputToken, outputToken, keypair);
  }

  async getRoutes({
    inputToken,
    outputToken,
    inputAmount,
    slippage,
  }: {
    inputToken?: TokenI;
    outputToken?: TokenI;
    inputAmount: number;
    slippage: number;
  }) {
    if (!inputToken || !outputToken) {
      return null;
    }

    console.log('Getting routes');
    const inputAmountLamports = inputToken
      ? Math.round(inputAmount * 10 ** inputToken.decimals)
      : 0; // Lamports based on token decimals
    const routes =
      inputToken && outputToken
        ? await this.jupiter.computeRoutes(
            new PublicKey(inputToken.address),
            new PublicKey(outputToken.address),
            inputAmountLamports,
            slippage,
            true,
          )
        : null;

    if (routes && routes.routesInfos) {
      console.log('Possible number of routes:', routes.routesInfos.length);
      console.log('Best quote: ', routes.routesInfos[0].outAmount);
      return routes;
    } else {
      return null;
    }
  }
  // USDC -> SOL
  async buy(size: number) {
    const routes = await this.getRoutes({
      inputToken: this.tokenB, // USDC
      outputToken: this.tokenA, // SOL
      inputAmount: size, // 1 unit in UI
      slippage: 1, // 1% slippage
    });
    console.log('Routes:', routes);
    if (routes?.routesInfos) {
      console.log('Best Route', routes.routesInfos[0]);
      return this.executeSwap(routes?.routesInfos[0]);
    } else {
      throw new Error('Route not found');
    }
  }
  // SOL -> USDC
  async sell(size: number) {
    const routes = await this.getRoutes({
      inputToken: this.tokenA,
      outputToken: this.tokenB,
      inputAmount: size, // 1 unit in UI
      slippage: 1, // 1% slippage
    });
    if (routes?.routesInfos) {
      console.log('Best Route', routes.routesInfos[0]);
      return this.executeSwap(routes?.routesInfos[0]);
    } else {
      throw new Error('Route not found');
    }
  }

  async executeSwap(route: RouteInfo) {
    // Prepare execute exchange
    const {execute} = await this.jupiter.exchange({
      route,
    });
    // Execute swap
    const swapResult: any = await execute(); // Force any to ignore TS misidentifying SwapResult type

    if (swapResult.error) {
      console.log(swapResult.error);
      return {...swapResult, txIds: [swapResult.txId]}; // fit the swapResult interface
    } else {
      console.log(`https://explorer.solana.com/tx/${swapResult.txid}`);
      console.log(
        `inputAddress=${swapResult.inputAddress.toString()} outputAddress=${swapResult.outputAddress.toString()}`,
      );
      console.log(
        `inputAmount=${swapResult.inputAmount} outputAmount=${swapResult.outputAmount}`,
      );
    }
    return {
      txIds: [swapResult.txid],
      inAmount: swapResult.inputAmount,
      outAmount: swapResult.outputAmount,
    };
  }
}

'''
'''--- components/protocols/secret/components/index.ts ---
export {default as Connect} from '@figment-secret/components/Connect';
export {default as Account} from '@figment-secret/components/Account';
export {default as Balance} from '@figment-secret/components/Balance';
export {default as Transfer} from '@figment-secret/components/Transfer';
export {default as Deploy} from '@figment-secret/components/Deploy';
export {default as Setter} from '@figment-secret/components/Setter';
export {default as Getter} from '@figment-secret/components/Getter';

'''
'''--- components/protocols/secret/lib/index.ts ---
import {SECRET_NETWORKS} from 'types';

export const accountExplorer = (network: string) => (address: string) => {
  if (network === SECRET_NETWORKS.TESTNET) {
    return `https://secretnodes.com/secret/chains/pulsar-2/accounts/${address}`;
  } else {
    return `https://secretnodes.com/secret/chains/pulsar-2/account/${address}`;
  }
};

export const transactionUrl = (hash: string) =>
  `https://secretnodes.com/secret/chains/pulsar-2/transactions/${hash}`;

export const contractsUrl = (hash: string) =>
  `https://secretnodes.com/secret/chains/pulsar-2/contracts/${hash}`;

export const getNodeUrl = () => 'https://api.pulsar.griptapejs.com/';

'''
'''--- components/protocols/solana/components/index.ts ---
export {default as Transfer} from '@figment-solana/components/Transfer';
export {default as Keypair} from '@figment-solana/components/Keypair';
export {default as Balance} from '@figment-solana/components/Balance';
export {default as Connect} from '@figment-solana/components/Connect';
export {default as Greeter} from '@figment-solana/components/Greeter';
export {default as Getter} from '@figment-solana/components/Getter';
export {default as Deploy} from '@figment-solana/components/Deploy';
export {default as Setter} from '@figment-solana/components/Setter';
export {default as Fund} from '@figment-solana/components/Fund';

'''
'''--- components/protocols/solana/lib/index.ts ---
import {CHAINS, SOLANA_NETWORKS, SOLANA_PROTOCOLS} from 'types';
import {getNodeURL as getNodeUrl} from 'utils/datahub';

// Helper for generating an account URL on Solana Explorer
export const accountExplorer = (network: string) => (address: string) => {
  if (network === SOLANA_NETWORKS.LOCALNET) {
    return `https://explorer.solana.com/address/${address}?cluster=custom&customUrl=http://127.0.0.1:8899`;
  } else {
    return `https://explorer.solana.com/address/${address}?cluster=devnet`;
  }
};

// Helper for generating an transaction URL on Solana Explorer
export const transactionExplorer = (network: string) => (hash: string) => {
  if (network === SOLANA_NETWORKS.LOCALNET) {
    return `https://explorer.solana.com/tx/${hash}?cluster=custom&customUrl=http://127.0.0.1:8899`;
  } else {
    return `https://explorer.solana.com/tx/${hash}?cluster=devnet`;
  }
};

export const getNodeURL = (network?: string) =>
  getNodeUrl(
    CHAINS.SOLANA,
    SOLANA_NETWORKS.DEVNET,
    SOLANA_PROTOCOLS.RPC,
    network,
  );

'''
'''--- components/protocols/tezos/components/index.ts ---
export {default as Connect} from '@figment-tezos/components/Connect';
export {default as Account} from '@figment-tezos/components/Account';
export {default as Balance} from '@figment-tezos/components/Balance';
export {default as Transfer} from '@figment-tezos/components/Transfer';
export {default as Deploy} from '@figment-tezos/components/Deploy';
export {default as Getter} from '@figment-tezos/components/Getter';
export {default as Setter} from '@figment-tezos/components/Setter';

'''
'''--- components/protocols/tezos/lib/index.ts ---
export const getNodeUrl = (network: string) => {
  if (network === 'Datahub') {
    return `${process.env.TEZOS_DATAHUB_URL}/apikey/${process.env.DATAHUB_TEZOS_API_KEY}`;
  } else {
    return 'https://hangzhounet.api.tez.ie';
  }
};

export const accountExplorer = (network: string) => (address: string) =>
  `https://hangzhou.tzstats.com/${address}`;

export const transactionUrl = (hash: string) =>
  `https://hangzhou.tzstats.com/${hash}`;

'''
'''--- components/protocols/the_graph/graphql/query.ts ---
import {gql} from '@apollo/client';

const MOST_VALUABLE_PUNKS_QUERY = gql`
  query {
    punks(first: 1) {
      id
    }
  }
`;

export default MOST_VALUABLE_PUNKS_QUERY;

'''
'''--- components/protocols/the_graph_near/graphql/query.ts ---
export const DID_QUERY_MAPPING = `
query{
    accounts{
        id
        log
    }
}
`;

export const DID_QUERY = `
    query{
      logs(first: 5, orderBy: registered, orderDirection: desc, where: {event_in: ["putDID"]}) {
        id
        did
        accountId
        registered
      }
    }
    `;

'''
'''--- components/shared/Button.styles.ts ---
import styled from 'styled-components';
import {Button} from 'antd';

export const StepButton = styled(Button)<{
  primary_color: string;
  secondary_color: string;
}>`
  border: none;
  color: ${({secondary_color}) => secondary_color};
  background: ${({primary_color}) => primary_color};

  &:hover {
    background: ${({primary_color}) => primary_color};
    color: ${({secondary_color}) => secondary_color};
    border: none;
    box-shadow: black 2px 2px 1px;
  }
`;

export const NextButton = styled(Button)<{
  primary_color: string;
  secondary_color: string;
}>`
  border: none;
  color: ${({secondary_color}) => secondary_color};
  background: ${({primary_color}) => primary_color};

  &:hover {
    background: ${({primary_color}) => primary_color};
    color: ${({secondary_color}) => secondary_color};
    border: none;
    box-shadow: black 2px 2px 1px;
  }
`;

export const PrevButton = styled(Button)`
  background: white;
  border: solid #777 1px;
  color: #777;

  &:hover {
    color: black;
    border: solid black 1px;
  }
`;

'''
'''--- components/shared/CustomMarkdown/Markdown.styles.ts ---
import styled, {css} from 'styled-components';
import {Alert, Typography} from 'antd';

const {Text} = Typography;

const headingWithLinkMixin = css`
  margin-left: -20px;
  padding-left: 20px;
  position: relative;

  a {
    visibility: hidden;
  }

  &:hover {
    a {
      visibility: visible;
    }
  }
`;

export const StyledListItem = styled.li`
  padding: 5px 0;
`;

export const StyledAlert = styled(Alert)`
  margin: 1em 0;
  border-radius: 5px;
  align-items: start;

  .ant-typography {
    margin-bottom: 0;
  }

  .ant-alert-icon {
    margin-top: 5px;
    margin-right: 14px;
  }
`;

export const StyledLink = styled.a`
  &&& {
    color: ${({theme}) => theme.colors.yellowDark};

    &:hover {
      text-decoration: underline;
    }
  }
`;

export const StyledH1 = styled.h1`
  margin: 1em 0;

  ${headingWithLinkMixin}
`;

export const StyledH2 = styled.h2`
  margin: 0.75em 0;
  font-size: 24px;

  ${headingWithLinkMixin}
`;

export const StyledH3 = styled.h3`
  margin-top: 0.75em 0;
  font-size: 17px;

  ${headingWithLinkMixin}
`;

export const StyledImage = styled.img`
  max-width: 500px;
  max-height: 600px;
  margin: 30px auto;
  border-radius: 5px;
  box-shadow: rgb(150 150 150) 0 4px 10px;
  display: block;
  margin-top: 60px;
  margin-bottom: 60px;
`;

export const LinkIcon = styled.div`
  position: absolute;
  left: -4px;
  top: 0;

  svg {
    color: #777;
    width: 18px;
  }
`;

export const TextCode = styled(Text)`
  padding: 0.2em 0.4em;
  margin: 0;
  color: #25292e;
  background-color: #dbdbdb;
  font-family: 'Monaco';
  font-size: 85%;
  border-radius: 6px;
`;

'''
'''--- components/shared/CustomMarkdown/VideoPlayer/VideoPlayer.styles.ts ---
import styled from 'styled-components';
import {Card} from 'antd';

export const StyledCard = styled(Card)`
  margin-top: 30px;
  margin-bottom: 30px;
`;

'''
'''--- components/shared/CustomMarkdown/utils/markdown-utils.ts ---
export type GitbookHintType = 'info' | 'danger' | 'working' | 'tip';

export const gitbookHintTypeToAntd = (gitBookType: GitbookHintType): string => {
  let type = 'info';

  if (gitBookType === 'danger') {
    type = 'error';
  } else if (gitBookType === 'working') {
    type = 'success';
  } else if (gitBookType === 'tip') {
    type = 'warning';
  }
  return type;
};

'''
'''--- components/shared/CustomMarkdown/utils/string-utils.ts ---
import unescape from 'lodash.unescape';

export const extractStringFromTree = (props: any): string | null => {
  if (props.children) {
    const firstChild = props.children[0];

    if (typeof firstChild === 'string') {
      return firstChild;
    } else {
      return extractStringFromTree(firstChild.props);
    }
  }
  return null;
};

export const stringToCssId = (string: string): string => {
  return string
    .replace(/\W+/g, ' ')
    .trim()
    .split(/ |\B(?=[A-Z])/)
    .map((word) => word.toLowerCase())
    .join('-');
};

export const cleanupMarkdownHeading = (heading: string): string => {
  heading = heading.replace(/#+/, '').trim();
  heading = heading.replace(/\*{2,}/g, '');
  heading = heading.replace(/\\\(/g, '(');
  heading = heading.replace(/\\\)/g, ')');
  heading = heading.replace(/( |<([^>]+)>)/g, ' ');
  heading = unescape(heading);
  return cleanupStringFromMarkdown(heading);
};

export const cleanupStringFromMarkdown = (string: string): string => {
  string = string.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*$/gm, '');
  return string;
};

'''
'''--- components/shared/ProtocolNav/ProtocolNav.styles.ts ---
import {Space} from 'antd';
import styled from 'styled-components';

const ProtocolNavContainer = styled(Space)`
  display: flex;
  margin-top: -75px;
  flex-direction: row;
  justify-content: space-between;
  align-item: center;
`;

export default ProtocolNavContainer;

'''
'''--- contracts/celo/HelloWorld.json ---
{
  "contractName": "HelloWorld",
  "abi": [
    {
      "constant": true,
      "inputs": [],
      "name": "getName",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "internalType": "string",
          "name": "newName",
          "type": "string"
        }
      ],
      "name": "setName",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "metadata": "{\"compiler\":{\"version\":\"0.5.16+commit.9c3226ce\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"constant\":true,\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"project:/contracts/HelloWorld.sol\":\"HelloWorld\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"project:/contracts/HelloWorld.sol\":{\"keccak256\":\"0xe7ad039be6bdff1d0ac254b398dbb0faf17ddd58b928fef29593aa2851dc8bfc\",\"urls\":[\"bzz-raw://8293c779a463b2c19aaf4ca112615317c0185c2417aac31592b4e285752ffc77\",\"dweb:/ipfs/QmconSQeZWJifqudVAbA4UMCvkNnGHUnJoMbkZtKWx4YeN\"]}},\"version\":1}",
  "bytecode": "0x60806040526040518060400160405280600481526020017f43656c6f000000000000000000000000000000000000000000000000000000008152506000908051906020019061004f929190610062565b5034801561005c57600080fd5b50610107565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100a357805160ff19168380011785556100d1565b828001600101855582156100d1579182015b828111156100d05782518255916020019190600101906100b5565b5b5090506100de91906100e2565b5090565b61010491905b808211156101005760008160009055506001016100e8565b5090565b90565b6102c9806101166000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806317d7de7c1461003b578063c47f0027146100be575b600080fd5b610043610137565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610083578082015181840152602081019050610068565b50505050905090810190601f1680156100b05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b610135600480360360208110156100d457600080fd5b81019080803590602001906401000000008111156100f157600080fd5b82018360208201111561010357600080fd5b8035906020019184600183028401116401000000008311171561012557600080fd5b90919293919293905050506101d9565b005b606060008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101cf5780601f106101a4576101008083540402835291602001916101cf565b820191906000526020600020905b8154815290600101906020018083116101b257829003601f168201915b5050505050905090565b8181600091906101ea9291906101ef565b505050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061023057803560ff191683800117855561025e565b8280016001018555821561025e579182015b8281111561025d578235825591602001919060010190610242565b5b50905061026b919061026f565b5090565b61029191905b8082111561028d576000816000905550600101610275565b5090565b9056fea265627a7a72315820aa1b0f440268d7a45beb0778de9fc3dfa7b7f9b396bc4bc23fa472746e82182e64736f6c63430005100032",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806317d7de7c1461003b578063c47f0027146100be575b600080fd5b610043610137565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610083578082015181840152602081019050610068565b50505050905090810190601f1680156100b05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b610135600480360360208110156100d457600080fd5b81019080803590602001906401000000008111156100f157600080fd5b82018360208201111561010357600080fd5b8035906020019184600183028401116401000000008311171561012557600080fd5b90919293919293905050506101d9565b005b606060008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101cf5780601f106101a4576101008083540402835291602001916101cf565b820191906000526020600020905b8154815290600101906020018083116101b257829003601f168201915b5050505050905090565b8181600091906101ea9291906101ef565b505050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061023057803560ff191683800117855561025e565b8280016001018555821561025e579182015b8281111561025d578235825591602001919060010190610242565b5b50905061026b919061026f565b5090565b61029191905b8082111561028d576000816000905550600101610275565b5090565b9056fea265627a7a72315820aa1b0f440268d7a45beb0778de9fc3dfa7b7f9b396bc4bc23fa472746e82182e64736f6c63430005100032",
  "sourceMap": "66:208:0:-;;;90:20;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;66:208;8:9:-1;5:2;;;30:1;27;20:12;5:2;66:208:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;",
  "deployedSourceMap": "66:208:0:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;66:208:0;;;;;;;;;;;;;;;;;;;;;;;;115:77;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23:1:-1;8:100;33:3;30:1;27:10;8:100;;;99:1;94:3;90:11;84:18;80:1;75:3;71:11;64:39;52:2;49:1;45:10;40:15;;8:100;;;12:14;115:77:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;196:76;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;196:76:0;;;;;;;;;;21:11:-1;8;5:28;2:2;;;46:1;43;36:12;2:2;196:76:0;;35:9:-1;28:4;12:14;8:25;5:40;2:2;;;58:1;55;48:12;2:2;196:76:0;;;;;;100:9:-1;95:1;81:12;77:20;67:8;63:35;60:50;39:11;25:12;22:29;11:107;8:2;;;131:1;128;121:12;8:2;196:76:0;;;;;;;;;;;;:::i;:::-;;115:77;155:13;183:4;176:11;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;115:77;:::o;196:76::-;260:7;;253:4;:14;;;;;;;:::i;:::-;;196:76;;:::o;66:208::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o",
  "source": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract HelloWorld {\n  string name = 'Celo';\n\n  function getName() public view returns (string memory) {\n    return name;\n  }\n\n  function setName(string calldata newName) external {\n    name = newName;\n  }\n}",
  "sourcePath": "/home/zu/project/figment/pathway/hello_contract-truffle/contracts/HelloWorld.sol",
  "ast": {
    "absolutePath": "project:/contracts/HelloWorld.sol",
    "exportedSymbols": {
      "HelloWorld": [23]
    },
    "id": 24,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1,
        "literals": ["solidity", ">=", "0.4", ".22", "<", "0.9", ".0"],
        "nodeType": "PragmaDirective",
        "src": "32:32:0"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 23,
        "linearizedBaseContracts": [23],
        "name": "HelloWorld",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "constant": false,
            "id": 4,
            "name": "name",
            "nodeType": "VariableDeclaration",
            "scope": 23,
            "src": "90:20:0",
            "stateVariable": true,
            "storageLocation": "default",
            "typeDescriptions": {
              "typeIdentifier": "t_string_storage",
              "typeString": "string"
            },
            "typeName": {
              "id": 2,
              "name": "string",
              "nodeType": "ElementaryTypeName",
              "src": "90:6:0",
              "typeDescriptions": {
                "typeIdentifier": "t_string_storage_ptr",
                "typeString": "string"
              }
            },
            "value": {
              "argumentTypes": null,
              "hexValue": "43656c6f",
              "id": 3,
              "isConstant": false,
              "isLValue": false,
              "isPure": true,
              "kind": "string",
              "lValueRequested": false,
              "nodeType": "Literal",
              "src": "104:6:0",
              "subdenomination": null,
              "typeDescriptions": {
                "typeIdentifier": "t_stringliteral_9d2bc54cb1b449a4cf59411d04e3148a0ebb5ba960bffb680f6141d50a7be95c",
                "typeString": "literal_string \"Celo\""
              },
              "value": "Celo"
            },
            "visibility": "internal"
          },
          {
            "body": {
              "id": 11,
              "nodeType": "Block",
              "src": "170:22:0",
              "statements": [
                {
                  "expression": {
                    "argumentTypes": null,
                    "id": 9,
                    "name": "name",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 4,
                    "src": "183:4:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_string_storage",
                      "typeString": "string storage ref"
                    }
                  },
                  "functionReturnParameters": 8,
                  "id": 10,
                  "nodeType": "Return",
                  "src": "176:11:0"
                }
              ]
            },
            "documentation": null,
            "id": 12,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "getName",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 5,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "131:2:0"
            },
            "returnParameters": {
              "id": 8,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 7,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 12,
                  "src": "155:13:0",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_string_memory_ptr",
                    "typeString": "string"
                  },
                  "typeName": {
                    "id": 6,
                    "name": "string",
                    "nodeType": "ElementaryTypeName",
                    "src": "155:6:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_string_storage_ptr",
                      "typeString": "string"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "154:15:0"
            },
            "scope": 23,
            "src": "115:77:0",
            "stateMutability": "view",
            "superFunction": null,
            "visibility": "public"
          },
          {
            "body": {
              "id": 21,
              "nodeType": "Block",
              "src": "247:25:0",
              "statements": [
                {
                  "expression": {
                    "argumentTypes": null,
                    "id": 19,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "argumentTypes": null,
                      "id": 17,
                      "name": "name",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 4,
                      "src": "253:4:0",
                      "typeDescriptions": {
                        "typeIdentifier": "t_string_storage",
                        "typeString": "string storage ref"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "argumentTypes": null,
                      "id": 18,
                      "name": "newName",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 14,
                      "src": "260:7:0",
                      "typeDescriptions": {
                        "typeIdentifier": "t_string_calldata_ptr",
                        "typeString": "string calldata"
                      }
                    },
                    "src": "253:14:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_string_storage",
                      "typeString": "string storage ref"
                    }
                  },
                  "id": 20,
                  "nodeType": "ExpressionStatement",
                  "src": "253:14:0"
                }
              ]
            },
            "documentation": null,
            "id": 22,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "setName",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 15,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 14,
                  "name": "newName",
                  "nodeType": "VariableDeclaration",
                  "scope": 22,
                  "src": "213:23:0",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_string_calldata_ptr",
                    "typeString": "string"
                  },
                  "typeName": {
                    "id": 13,
                    "name": "string",
                    "nodeType": "ElementaryTypeName",
                    "src": "213:6:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_string_storage_ptr",
                      "typeString": "string"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "212:25:0"
            },
            "returnParameters": {
              "id": 16,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "247:0:0"
            },
            "scope": 23,
            "src": "196:76:0",
            "stateMutability": "nonpayable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 24,
        "src": "66:208:0"
      }
    ],
    "src": "32:242:0"
  },
  "legacyAST": {
    "attributes": {
      "absolutePath": "project:/contracts/HelloWorld.sol",
      "exportedSymbols": {
        "HelloWorld": [23]
      }
    },
    "children": [
      {
        "attributes": {
          "literals": ["solidity", ">=", "0.4", ".22", "<", "0.9", ".0"]
        },
        "id": 1,
        "name": "PragmaDirective",
        "src": "32:32:0"
      },
      {
        "attributes": {
          "baseContracts": [null],
          "contractDependencies": [null],
          "contractKind": "contract",
          "documentation": null,
          "fullyImplemented": true,
          "linearizedBaseContracts": [23],
          "name": "HelloWorld",
          "scope": 24
        },
        "children": [
          {
            "attributes": {
              "constant": false,
              "name": "name",
              "scope": 23,
              "stateVariable": true,
              "storageLocation": "default",
              "type": "string",
              "visibility": "internal"
            },
            "children": [
              {
                "attributes": {
                  "name": "string",
                  "type": "string"
                },
                "id": 2,
                "name": "ElementaryTypeName",
                "src": "90:6:0"
              },
              {
                "attributes": {
                  "argumentTypes": null,
                  "hexvalue": "43656c6f",
                  "isConstant": false,
                  "isLValue": false,
                  "isPure": true,
                  "lValueRequested": false,
                  "subdenomination": null,
                  "token": "string",
                  "type": "literal_string \"Celo\"",
                  "value": "Celo"
                },
                "id": 3,
                "name": "Literal",
                "src": "104:6:0"
              }
            ],
            "id": 4,
            "name": "VariableDeclaration",
            "src": "90:20:0"
          },
          {
            "attributes": {
              "documentation": null,
              "implemented": true,
              "isConstructor": false,
              "kind": "function",
              "modifiers": [null],
              "name": "getName",
              "scope": 23,
              "stateMutability": "view",
              "superFunction": null,
              "visibility": "public"
            },
            "children": [
              {
                "attributes": {
                  "parameters": [null]
                },
                "children": [],
                "id": 5,
                "name": "ParameterList",
                "src": "131:2:0"
              },
              {
                "children": [
                  {
                    "attributes": {
                      "constant": false,
                      "name": "",
                      "scope": 12,
                      "stateVariable": false,
                      "storageLocation": "memory",
                      "type": "string",
                      "value": null,
                      "visibility": "internal"
                    },
                    "children": [
                      {
                        "attributes": {
                          "name": "string",
                          "type": "string"
                        },
                        "id": 6,
                        "name": "ElementaryTypeName",
                        "src": "155:6:0"
                      }
                    ],
                    "id": 7,
                    "name": "VariableDeclaration",
                    "src": "155:13:0"
                  }
                ],
                "id": 8,
                "name": "ParameterList",
                "src": "154:15:0"
              },
              {
                "children": [
                  {
                    "attributes": {
                      "functionReturnParameters": 8
                    },
                    "children": [
                      {
                        "attributes": {
                          "argumentTypes": null,
                          "overloadedDeclarations": [null],
                          "referencedDeclaration": 4,
                          "type": "string storage ref",
                          "value": "name"
                        },
                        "id": 9,
                        "name": "Identifier",
                        "src": "183:4:0"
                      }
                    ],
                    "id": 10,
                    "name": "Return",
                    "src": "176:11:0"
                  }
                ],
                "id": 11,
                "name": "Block",
                "src": "170:22:0"
              }
            ],
            "id": 12,
            "name": "FunctionDefinition",
            "src": "115:77:0"
          },
          {
            "attributes": {
              "documentation": null,
              "implemented": true,
              "isConstructor": false,
              "kind": "function",
              "modifiers": [null],
              "name": "setName",
              "scope": 23,
              "stateMutability": "nonpayable",
              "superFunction": null,
              "visibility": "external"
            },
            "children": [
              {
                "children": [
                  {
                    "attributes": {
                      "constant": false,
                      "name": "newName",
                      "scope": 22,
                      "stateVariable": false,
                      "storageLocation": "calldata",
                      "type": "string",
                      "value": null,
                      "visibility": "internal"
                    },
                    "children": [
                      {
                        "attributes": {
                          "name": "string",
                          "type": "string"
                        },
                        "id": 13,
                        "name": "ElementaryTypeName",
                        "src": "213:6:0"
                      }
                    ],
                    "id": 14,
                    "name": "VariableDeclaration",
                    "src": "213:23:0"
                  }
                ],
                "id": 15,
                "name": "ParameterList",
                "src": "212:25:0"
              },
              {
                "attributes": {
                  "parameters": [null]
                },
                "children": [],
                "id": 16,
                "name": "ParameterList",
                "src": "247:0:0"
              },
              {
                "children": [
                  {
                    "children": [
                      {
                        "attributes": {
                          "argumentTypes": null,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "operator": "=",
                          "type": "string storage ref"
                        },
                        "children": [
                          {
                            "attributes": {
                              "argumentTypes": null,
                              "overloadedDeclarations": [null],
                              "referencedDeclaration": 4,
                              "type": "string storage ref",
                              "value": "name"
                            },
                            "id": 17,
                            "name": "Identifier",
                            "src": "253:4:0"
                          },
                          {
                            "attributes": {
                              "argumentTypes": null,
                              "overloadedDeclarations": [null],
                              "referencedDeclaration": 14,
                              "type": "string calldata",
                              "value": "newName"
                            },
                            "id": 18,
                            "name": "Identifier",
                            "src": "260:7:0"
                          }
                        ],
                        "id": 19,
                        "name": "Assignment",
                        "src": "253:14:0"
                      }
                    ],
                    "id": 20,
                    "name": "ExpressionStatement",
                    "src": "253:14:0"
                  }
                ],
                "id": 21,
                "name": "Block",
                "src": "247:25:0"
              }
            ],
            "id": 22,
            "name": "FunctionDefinition",
            "src": "196:76:0"
          }
        ],
        "id": 23,
        "name": "ContractDefinition",
        "src": "66:208:0"
      }
    ],
    "id": 24,
    "name": "SourceUnit",
    "src": "32:242:0"
  },
  "compiler": {
    "name": "solc",
    "version": "0.5.16+commit.9c3226ce.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.4.3",
  "updatedAt": "2021-08-14T19:46:30.843Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}

'''
'''--- contracts/near/Cargo.toml ---
[package]
name = "greeter"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]
doctest = false

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contracts/near/README.md ---
# Pathway Smart Contract

A [smart contract] written in [Rust] for [figment pathway]

# Quick Start

Before you compile this code, you will need to install Rust with [correct target]

# Exploring The Code

1. The main smart contract code lives in `src/lib.rs`. You can compile it with
   the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard Rust tests using [cargo] with a `--nocapture` flag so that you
   can see any debug info you print to the console.

[smart contract]: https://docs.near.org/docs/develop/contracts/overview
[rust]: https://www.rust-lang.org/
[correct target]: https://github.com/near/near-sdk-rs#pre-requisites
[cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contracts/near/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs');

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString();

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname);

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug';

// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release';

// Execute the build command, storing exit code for later use
const {code} = sh.exec(buildCmd);

// Assuming this is compiled from the project root directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/contracts/near/out`;
  const link = `${calledFromDir}/contracts/near/out/main.wasm`;
  const packageName = require('fs')
    .readFileSync(`${__dirname}/Cargo.toml`)
    .toString()
    .match(/name = "([^"]+)"/)[1];
  const outFile = `./target/wasm32-unknown-unknown/${
    debug ? 'debug' : 'release'
  }/${packageName}.wasm`;
  sh.mkdir('-p', linkDir);
  sh.rm('-f', link);
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u', outFile, link);
}

// exit script with the same code as the build command
process.exit(code);

'''
'''--- contracts/near/src/lib.rs ---
/*
 * This is an example of a Rust smart contract with two simple, symmetric functions:
 *
 * 1. set_greeting: accepts a greeting, such as "howdy", and records it for the user (account_id)
 *    who sent the request
 * 2. get_greeting: accepts an account_id and returns the greeting saved for it, defaulting to
 *    "Hello"
 *
 * Learn more about writing NEAR smart contracts with Rust:
 * https://github.com/near/near-sdk-rs
 *
 */

// To conserve gas, efficient serialization is achieved through Borsh (http://borsh.io/)
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, setup_alloc};
use near_sdk::collections::LookupMap;

setup_alloc!();

// Structs in Rust are similar to other languages, and may include impl keyword as shown below
// Note: the names of the structs are not important when calling the smart contract, but the function names are
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Welcome {
    records: LookupMap<String, String>,
}

impl Default for Welcome {
  fn default() -> Self {
    Self {
      records: LookupMap::new(b"a".to_vec()),
    }
  }
}

#[near_bindgen]
impl Welcome {
    pub fn set_greeting(&mut self, message: String) {
        let account_id = env::signer_account_id();

        // Use env::log to record logs permanently to the blockchain!
        env::log(format!("Saving greeting '{}' for account '{}'", message, account_id,).as_bytes());

        self.records.insert(&account_id, &message);
    }

    // `match` is similar to `switch` in other languages; here we use it to default to "Hello" if
    // self.records.get(&account_id) is not yet defined.
    // Learn more: https://doc.rust-lang.org/book/ch06-02-match.html#matching-with-optiont
    pub fn get_greeting(&self, account_id: String) -> String {
        match self.records.get(&account_id) {
            Some(greeting) => greeting,
            None => "Hello".to_string(),
        }
    }
}

/*
 * The rest of this file holds the inline tests for the code above
 * Learn more about Rust tests: https://doc.rust-lang.org/book/ch11-01-writing-tests.html
 *
 * To run from contract directory:
 * cargo test -- --nocapture
 *
 * From project root, to run in combination with frontend tests:
 * yarn near:test
 *
 */
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // mock the context for testing, notice "signer_account_id" that was accessed above from env::
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice_near".to_string(),
            signer_account_id: "bob_near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "carol_near".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn set_then_get_greeting() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let mut contract = Welcome::default();
        contract.set_greeting("howdy".to_string());
        assert_eq!(
            "howdy".to_string(),
            contract.get_greeting("bob_near".to_string())
        );
    }

    #[test]
    fn get_default_greeting() {
        let context = get_context(vec![], true);
        testing_env!(context);
        let contract = Welcome::default();
        // this test did not call set_greeting so should return the default "Hello" greeting
        assert_eq!(
            "Hello".to_string(),
            contract.get_greeting("francis.near".to_string())
        );
    }
}

'''
'''--- contracts/polygon/SimpleStorage/README.md ---
Based on:

MetaCoin tutorial from Truffle docs https://www.trufflesuite.com/docs/truffle/quickstart
SimpleStorage example contract from Solidity docs https://docs.soliditylang.org/en/v0.4.24/introduction-to-smart-contracts.html#storage

1. Install truffle (https://www.trufflesuite.com/docs/truffle/getting-started/installation)
   `npm install -g truffle`

2. Navigate to this directory (/contracts/polygon/SimpleStorage)

3. Install dependencies
   `yarn`

4. Test contract
   `truffle test ./test/TestSimpleStorage.sol`

   **Possible issue:** "Something went wrong while attempting to connect to the network. Check your network configuration. Could not connect to your Ethereum client with the following parameters:"

   **Solution:** run `truffle develop` and make sure port matches the one in truffle-config.js under development and test networks

5. Run locally via `truffle develop`
   $ truffle develop

   ```
   migrate

   let instance = await SimpleStorage.deployed();

   let storedDataBefore = await instance.get();

   storedDataBefore.toNumber() // Should print 0

   instance.set(50);

   let storedDataAfter = await instance.get();

   storedDataAfter.toNumber() // Should print 50
   ```

6. Create Polygon testnet account

   - Install MetaMask (https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en)
   - Add a custom network with the following params:
     Network Name: "Polygon Mumbai"
     RPC URL: https://rpc-mumbai.maticvigil.com/
     Chain ID: 80001
     Currency Symbol: MATIC
     Block Explorer URL: https://mumbai.polygonscan.com

7. Fund your account from the Matic Faucet
   https://faucet.matic.network
   Select MATIC Token, Mumbai Network
   Enter your account address from MetaMask
   Wait until time limit is up, requests tokens 3-4 times so you have enough to deploy your contract

8. Add a `.secret` file in this directory with your account's seed phrase or mnemonic (you should be required to write this down or store it securely when creating your account in MetaMask). In `truffle-config.js`, uncomment the three constant declarations at the top, along with the matic section of the networks section of the configuration object.

9. Deploy contract
   `truffle migrate --network matic`

10. Interact via web3.js

    ```js
    const {ethers} = require('ethers');
    const fs = require('fs');
    const mnemonic = fs.readFileSync('.secret').toString().trim();
    const signer = new ethers.Wallet.fromMnemonic(mnemonic);
    const provider = new ethers.providers.JsonRpcProvider(
      'https://matic-mumbai.chainstacklabs.com',
    );
    const json = JSON.parse(
      fs.readFileSync('build/contracts/SimpleStorage.json').toString(),
    );
    const contract = new ethers.Contract(
      json.networks['80001'].address,
      json.abi,
      signer.connect(provider),
    );

    contract.get().then((val) => console.log(val.toNumber()));
    // should log 0

    contract.set(50).then((receipt) => console.log(receipt));

    contract.get().then((val) => console.log(val.toNumber()));
    // should log 50
    ```

'''
'''--- contracts/polygon/SimpleStorage/SimpleStorage.json ---
{
  "contractName": "SimpleStorage",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "set",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "get",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    }
  ],
  "metadata": "{\"compiler\":{\"version\":\"0.8.0+commit.c7dfd78e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"get\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project:/contracts/SimpleStorage.sol\":\"SimpleStorage\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"project:/contracts/SimpleStorage.sol\":{\"keccak256\":\"0x38804139feb003e950c26e169b75c1a4164146e6cdf412cd98c5c8ef7e4392ce\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2e0e1921a97150191d1377a40b9472103c15aa4f80f6325ad4e04af932d4a536\",\"dweb:/ipfs/QmbFeBSBNJTdJyuRdHprNHxhwzg9cQa1ReqCWMzwotJ4hV\"]}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506000805560c3806100236000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806360fe47b11460375780636d4ce63c146048575b600080fd5b60466042366004606d565b6062565b005b604e6067565b604051605991906084565b60405180910390f35b600055565b60005490565b600060208284031215607d578081fd5b5035919050565b9081526020019056fea26469706673582212201d532ffa3a033930e15166dccfe0e4e9c8f2c76b4cc482ee5aff97847d7c1b7f64736f6c63430008000033",
  "deployedBytecode": "0x6080604052348015600f57600080fd5b506004361060325760003560e01c806360fe47b11460375780636d4ce63c146048575b600080fd5b60466042366004606d565b6062565b005b604e6067565b604051605991906084565b60405180910390f35b600055565b60005490565b600060208284031215607d578081fd5b5035919050565b9081526020019056fea26469706673582212201d532ffa3a033930e15166dccfe0e4e9c8f2c76b4cc482ee5aff97847d7c1b7f64736f6c63430008000033",
  "immutableReferences": {},
  "generatedSources": [],
  "deployedGeneratedSources": [
    {
      "ast": {
        "nodeType": "YulBlock",
        "src": "0:388:2",
        "statements": [
          {
            "nodeType": "YulBlock",
            "src": "6:3:2",
            "statements": []
          },
          {
            "body": {
              "nodeType": "YulBlock",
              "src": "84:120:2",
              "statements": [
                {
                  "body": {
                    "nodeType": "YulBlock",
                    "src": "130:26:2",
                    "statements": [
                      {
                        "expression": {
                          "arguments": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "139:6:2"
                            },
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "147:6:2"
                            }
                          ],
                          "functionName": {
                            "name": "revert",
                            "nodeType": "YulIdentifier",
                            "src": "132:6:2"
                          },
                          "nodeType": "YulFunctionCall",
                          "src": "132:22:2"
                        },
                        "nodeType": "YulExpressionStatement",
                        "src": "132:22:2"
                      }
                    ]
                  },
                  "condition": {
                    "arguments": [
                      {
                        "arguments": [
                          {
                            "name": "dataEnd",
                            "nodeType": "YulIdentifier",
                            "src": "105:7:2"
                          },
                          {
                            "name": "headStart",
                            "nodeType": "YulIdentifier",
                            "src": "114:9:2"
                          }
                        ],
                        "functionName": {
                          "name": "sub",
                          "nodeType": "YulIdentifier",
                          "src": "101:3:2"
                        },
                        "nodeType": "YulFunctionCall",
                        "src": "101:23:2"
                      },
                      {
                        "kind": "number",
                        "nodeType": "YulLiteral",
                        "src": "126:2:2",
                        "type": "",
                        "value": "32"
                      }
                    ],
                    "functionName": {
                      "name": "slt",
                      "nodeType": "YulIdentifier",
                      "src": "97:3:2"
                    },
                    "nodeType": "YulFunctionCall",
                    "src": "97:32:2"
                  },
                  "nodeType": "YulIf",
                  "src": "94:2:2"
                },
                {
                  "nodeType": "YulAssignment",
                  "src": "165:33:2",
                  "value": {
                    "arguments": [
                      {
                        "name": "headStart",
                        "nodeType": "YulIdentifier",
                        "src": "188:9:2"
                      }
                    ],
                    "functionName": {
                      "name": "calldataload",
                      "nodeType": "YulIdentifier",
                      "src": "175:12:2"
                    },
                    "nodeType": "YulFunctionCall",
                    "src": "175:23:2"
                  },
                  "variableNames": [
                    {
                      "name": "value0",
                      "nodeType": "YulIdentifier",
                      "src": "165:6:2"
                    }
                  ]
                }
              ]
            },
            "name": "abi_decode_tuple_t_uint256",
            "nodeType": "YulFunctionDefinition",
            "parameters": [
              {
                "name": "headStart",
                "nodeType": "YulTypedName",
                "src": "50:9:2",
                "type": ""
              },
              {
                "name": "dataEnd",
                "nodeType": "YulTypedName",
                "src": "61:7:2",
                "type": ""
              }
            ],
            "returnVariables": [
              {
                "name": "value0",
                "nodeType": "YulTypedName",
                "src": "73:6:2",
                "type": ""
              }
            ],
            "src": "14:190:2"
          },
          {
            "body": {
              "nodeType": "YulBlock",
              "src": "310:76:2",
              "statements": [
                {
                  "nodeType": "YulAssignment",
                  "src": "320:26:2",
                  "value": {
                    "arguments": [
                      {
                        "name": "headStart",
                        "nodeType": "YulIdentifier",
                        "src": "332:9:2"
                      },
                      {
                        "kind": "number",
                        "nodeType": "YulLiteral",
                        "src": "343:2:2",
                        "type": "",
                        "value": "32"
                      }
                    ],
                    "functionName": {
                      "name": "add",
                      "nodeType": "YulIdentifier",
                      "src": "328:3:2"
                    },
                    "nodeType": "YulFunctionCall",
                    "src": "328:18:2"
                  },
                  "variableNames": [
                    {
                      "name": "tail",
                      "nodeType": "YulIdentifier",
                      "src": "320:4:2"
                    }
                  ]
                },
                {
                  "expression": {
                    "arguments": [
                      {
                        "name": "headStart",
                        "nodeType": "YulIdentifier",
                        "src": "362:9:2"
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulIdentifier",
                        "src": "373:6:2"
                      }
                    ],
                    "functionName": {
                      "name": "mstore",
                      "nodeType": "YulIdentifier",
                      "src": "355:6:2"
                    },
                    "nodeType": "YulFunctionCall",
                    "src": "355:25:2"
                  },
                  "nodeType": "YulExpressionStatement",
                  "src": "355:25:2"
                }
              ]
            },
            "name": "abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed",
            "nodeType": "YulFunctionDefinition",
            "parameters": [
              {
                "name": "headStart",
                "nodeType": "YulTypedName",
                "src": "279:9:2",
                "type": ""
              },
              {
                "name": "value0",
                "nodeType": "YulTypedName",
                "src": "290:6:2",
                "type": ""
              }
            ],
            "returnVariables": [
              {
                "name": "tail",
                "nodeType": "YulTypedName",
                "src": "301:4:2",
                "type": ""
              }
            ],
            "src": "209:177:2"
          }
        ]
      },
      "contents": "{\n    { }\n    function abi_decode_tuple_t_uint256(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(value0, value0) }\n        value0 := calldataload(headStart)\n    }\n    function abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, value0)\n    }\n}",
      "id": 2,
      "language": "Yul",
      "name": "#utility.yul"
    }
  ],
  "sourceMap": "57:242:1:-:0;;;108:42;;;;;;;;;-1:-1:-1;143:1:1;130:14;;57:242;;;;;;",
  "deployedSourceMap": "57:242:1:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;156:59;;;;;;:::i;:::-;;:::i;:::-;;221:76;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;156:59;194:10;:14;156:59::o;221:76::-;257:4;280:10;221:76;:::o;14:190:2:-;;126:2;114:9;105:7;101:23;97:32;94:2;;;147:6;139;132:22;94:2;-1:-1:-1;175:23:2;;84:120;-1:-1:-1;84:120:2:o;209:177::-;355:25;;;343:2;328:18;;310:76::o",
  "source": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleStorage {\n    uint storedData;\n\n    constructor() {\n  \t\t  storedData = 0;\n  \t}\n\n    function set(uint x) public {\n        storedData = x;\n    }\n\n    function get() public view returns (uint) {\n        return storedData;\n    }\n}\n",
  "sourcePath": "/home/zu/testing/polygon/contracts/polygon/SimpleStorage/contracts/SimpleStorage.sol",
  "ast": {
    "absolutePath": "project:/contracts/SimpleStorage.sol",
    "exportedSymbols": {
      "SimpleStorage": [67]
    },
    "id": 68,
    "license": "MIT",
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 38,
        "literals": ["solidity", "^", "0.8", ".0"],
        "nodeType": "PragmaDirective",
        "src": "32:23:1"
      },
      {
        "abstract": false,
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "fullyImplemented": true,
        "id": 67,
        "linearizedBaseContracts": [67],
        "name": "SimpleStorage",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "constant": false,
            "id": 40,
            "mutability": "mutable",
            "name": "storedData",
            "nodeType": "VariableDeclaration",
            "scope": 67,
            "src": "86:15:1",
            "stateVariable": true,
            "storageLocation": "default",
            "typeDescriptions": {
              "typeIdentifier": "t_uint256",
              "typeString": "uint256"
            },
            "typeName": {
              "id": 39,
              "name": "uint",
              "nodeType": "ElementaryTypeName",
              "src": "86:4:1",
              "typeDescriptions": {
                "typeIdentifier": "t_uint256",
                "typeString": "uint256"
              }
            },
            "visibility": "internal"
          },
          {
            "body": {
              "id": 47,
              "nodeType": "Block",
              "src": "122:28:1",
              "statements": [
                {
                  "expression": {
                    "id": 45,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 43,
                      "name": "storedData",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 40,
                      "src": "130:10:1",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "hexValue": "30",
                      "id": 44,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "143:1:1",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_0_by_1",
                        "typeString": "int_const 0"
                      },
                      "value": "0"
                    },
                    "src": "130:14:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 46,
                  "nodeType": "ExpressionStatement",
                  "src": "130:14:1"
                }
              ]
            },
            "id": 48,
            "implemented": true,
            "kind": "constructor",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 41,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "119:2:1"
            },
            "returnParameters": {
              "id": 42,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "122:0:1"
            },
            "scope": 67,
            "src": "108:42:1",
            "stateMutability": "nonpayable",
            "virtual": false,
            "visibility": "public"
          },
          {
            "body": {
              "id": 57,
              "nodeType": "Block",
              "src": "184:31:1",
              "statements": [
                {
                  "expression": {
                    "id": 55,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 53,
                      "name": "storedData",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 40,
                      "src": "194:10:1",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "id": 54,
                      "name": "x",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 50,
                      "src": "207:1:1",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "src": "194:14:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 56,
                  "nodeType": "ExpressionStatement",
                  "src": "194:14:1"
                }
              ]
            },
            "functionSelector": "60fe47b1",
            "id": 58,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "set",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 51,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 50,
                  "mutability": "mutable",
                  "name": "x",
                  "nodeType": "VariableDeclaration",
                  "scope": 58,
                  "src": "169:6:1",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 49,
                    "name": "uint",
                    "nodeType": "ElementaryTypeName",
                    "src": "169:4:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "168:8:1"
            },
            "returnParameters": {
              "id": 52,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "184:0:1"
            },
            "scope": 67,
            "src": "156:59:1",
            "stateMutability": "nonpayable",
            "virtual": false,
            "visibility": "public"
          },
          {
            "body": {
              "id": 65,
              "nodeType": "Block",
              "src": "263:34:1",
              "statements": [
                {
                  "expression": {
                    "id": 63,
                    "name": "storedData",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 40,
                    "src": "280:10:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "functionReturnParameters": 62,
                  "id": 64,
                  "nodeType": "Return",
                  "src": "273:17:1"
                }
              ]
            },
            "functionSelector": "6d4ce63c",
            "id": 66,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "get",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 59,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "233:2:1"
            },
            "returnParameters": {
              "id": 62,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 61,
                  "mutability": "mutable",
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 66,
                  "src": "257:4:1",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 60,
                    "name": "uint",
                    "nodeType": "ElementaryTypeName",
                    "src": "257:4:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "256:6:1"
            },
            "scope": 67,
            "src": "221:76:1",
            "stateMutability": "view",
            "virtual": false,
            "visibility": "public"
          }
        ],
        "scope": 68,
        "src": "57:242:1"
      }
    ],
    "src": "32:268:1"
  },
  "legacyAST": {
    "absolutePath": "project:/contracts/SimpleStorage.sol",
    "exportedSymbols": {
      "SimpleStorage": [67]
    },
    "id": 68,
    "license": "MIT",
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 38,
        "literals": ["solidity", "^", "0.8", ".0"],
        "nodeType": "PragmaDirective",
        "src": "32:23:1"
      },
      {
        "abstract": false,
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "fullyImplemented": true,
        "id": 67,
        "linearizedBaseContracts": [67],
        "name": "SimpleStorage",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "constant": false,
            "id": 40,
            "mutability": "mutable",
            "name": "storedData",
            "nodeType": "VariableDeclaration",
            "scope": 67,
            "src": "86:15:1",
            "stateVariable": true,
            "storageLocation": "default",
            "typeDescriptions": {
              "typeIdentifier": "t_uint256",
              "typeString": "uint256"
            },
            "typeName": {
              "id": 39,
              "name": "uint",
              "nodeType": "ElementaryTypeName",
              "src": "86:4:1",
              "typeDescriptions": {
                "typeIdentifier": "t_uint256",
                "typeString": "uint256"
              }
            },
            "visibility": "internal"
          },
          {
            "body": {
              "id": 47,
              "nodeType": "Block",
              "src": "122:28:1",
              "statements": [
                {
                  "expression": {
                    "id": 45,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 43,
                      "name": "storedData",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 40,
                      "src": "130:10:1",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "hexValue": "30",
                      "id": 44,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "143:1:1",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_0_by_1",
                        "typeString": "int_const 0"
                      },
                      "value": "0"
                    },
                    "src": "130:14:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 46,
                  "nodeType": "ExpressionStatement",
                  "src": "130:14:1"
                }
              ]
            },
            "id": 48,
            "implemented": true,
            "kind": "constructor",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 41,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "119:2:1"
            },
            "returnParameters": {
              "id": 42,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "122:0:1"
            },
            "scope": 67,
            "src": "108:42:1",
            "stateMutability": "nonpayable",
            "virtual": false,
            "visibility": "public"
          },
          {
            "body": {
              "id": 57,
              "nodeType": "Block",
              "src": "184:31:1",
              "statements": [
                {
                  "expression": {
                    "id": 55,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 53,
                      "name": "storedData",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 40,
                      "src": "194:10:1",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "id": 54,
                      "name": "x",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 50,
                      "src": "207:1:1",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "src": "194:14:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 56,
                  "nodeType": "ExpressionStatement",
                  "src": "194:14:1"
                }
              ]
            },
            "functionSelector": "60fe47b1",
            "id": 58,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "set",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 51,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 50,
                  "mutability": "mutable",
                  "name": "x",
                  "nodeType": "VariableDeclaration",
                  "scope": 58,
                  "src": "169:6:1",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 49,
                    "name": "uint",
                    "nodeType": "ElementaryTypeName",
                    "src": "169:4:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "168:8:1"
            },
            "returnParameters": {
              "id": 52,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "184:0:1"
            },
            "scope": 67,
            "src": "156:59:1",
            "stateMutability": "nonpayable",
            "virtual": false,
            "visibility": "public"
          },
          {
            "body": {
              "id": 65,
              "nodeType": "Block",
              "src": "263:34:1",
              "statements": [
                {
                  "expression": {
                    "id": 63,
                    "name": "storedData",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 40,
                    "src": "280:10:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "functionReturnParameters": 62,
                  "id": 64,
                  "nodeType": "Return",
                  "src": "273:17:1"
                }
              ]
            },
            "functionSelector": "6d4ce63c",
            "id": 66,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "get",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 59,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "233:2:1"
            },
            "returnParameters": {
              "id": 62,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 61,
                  "mutability": "mutable",
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 66,
                  "src": "257:4:1",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 60,
                    "name": "uint",
                    "nodeType": "ElementaryTypeName",
                    "src": "257:4:1",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "256:6:1"
            },
            "scope": 67,
            "src": "221:76:1",
            "stateMutability": "view",
            "virtual": false,
            "visibility": "public"
          }
        ],
        "scope": 68,
        "src": "57:242:1"
      }
    ],
    "src": "32:268:1"
  },
  "compiler": {
    "name": "solc",
    "version": "0.8.0+commit.c7dfd78e.Emscripten.clang"
  },
  "networks": {
    "80001": {
      "events": {},
      "links": {},
      "address": "0xD010176260E14689807354f7752580f8D4c6486a",
      "transactionHash": "0x5cb30753e425fd39fea25ca6126fd47866b02bf312575dae750e50c06e301f5f"
    }
  },
  "schemaVersion": "3.4.3",
  "updatedAt": "2021-12-02T22:04:18.442Z",
  "networkType": "ethereum",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  }
}

'''
'''--- contracts/polygon/SimpleStorage/migrations/1_initial_migration.js ---
const Migrations = artifacts.require('Migrations');

module.exports = function (deployer) {
  deployer.deploy(Migrations);
};

'''
'''--- contracts/polygon/SimpleStorage/migrations/2_deploy_contracts.js ---
const SimpleStorage = artifacts.require('SimpleStorage');

module.exports = function (deployer) {
  deployer.deploy(SimpleStorage);
};

'''
'''--- contracts/polygon/SimpleStorage/package.json ---
{
  "dependencies": {
    "@truffle/hdwallet-provider": "^1.4.1",
    "bufferutil": "^4.0.3",
    "ethers": "^5.4.1",
    "truffle": "^5.4.0",
    "utf-8-validate": "^5.0.5",
    "web3": "^1.4.0",
    "minimist": "^1.2.6"
  }
}

'''
'''--- contracts/polygon/SimpleStorage/truffle-config.js ---
const HDWalletProvider = require('@truffle/hdwallet-provider');
const fs = require('fs');
// const mnemonic = fs.readFileSync('.secret').toString().trim();
const privateKey = fs.readFileSync('.secret').toString().trim();

module.exports = {
  // See <http://truffleframework.com/docs/advanced/configuration>
  // for more details on how to specify configuration options!
  compilers: {
    solc: {
      version: '0.8.0',
      parser: 'solcjs', // Leverages solc-js purely for speedy parsing
      settings: {
        optimizer: {
          enabled: true,
          runs: 200, // Optimize for how many times you intend to run the code
        },
        evmVersion: 'istanbul', // Default: "istanbul"
      },
    },
  },
  networks: {
    development: {
      host: '127.0.0.1',
      port: 9545,
      network_id: '*',
    },
    test: {
      host: '127.0.0.1',
      port: 9545,
      network_id: '*',
    },
    matic: {
      provider: () =>
        new HDWalletProvider({
          // As per the documentation at https://github.com/trufflesuite/truffle/tree/develop/packages/hdwallet-provider#general-usage
          // "If both mnemonic and private keys are provided, the mnemonic is used."
          // Therefore, uncomment the following lines to use a mnemonic instead of a private key:
          // mnemonic: {
          //   phrase: mnemonic,
          // },
          privateKeys: [privateKey],
          providerOrUrl: `https://matic-mumbai.chainstacklabs.com`,
          chainId: 80001,
        }),
      network_id: 80001,
      confirmations: 2,
      timeoutBlocks: 200,
      skipDryRun: true,
      chainId: 80001,
    },
  },
};

'''
'''--- contracts/solana/program/Cargo.toml ---

[package]
name = "solana-bpf-helloworld"
version = "0.0.1"
description = "Example template program written in Rust"
authors = ["Solana Maintainers <maintainers@solana.com>"]
repository = "https://github.com/solana-labs/solana"
license = "Apache-2.0"
homepage = "https://solana.com/"
edition = "2018"

[features]
no-entrypoint = []

[dependencies]
borsh = "0.9.1"
borsh-derive = "0.9.1"
solana-program = "=1.7.9"

[dev-dependencies]
solana-program-test = "=1.7.9"
solana-sdk = "=1.7.9"

[lib]
name = "helloworld"
crate-type = ["cdylib", "lib"]

'''
'''--- contracts/solana/program/Xargo.toml ---
[target.bpfel-unknown-unknown.dependencies.std]
features = []
'''
'''--- contracts/solana/program/src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};

/// Define the type of state stored in accounts
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct GreetingAccount {
    /// number of greetings
    pub counter: u32,
}

// Declare and export the program's entrypoint
entrypoint!(process_instruction);

// Program entrypoint's implementation
pub fn process_instruction(
    program_id: &Pubkey, // Public key of the account the hello world program was loaded into
    accounts: &[AccountInfo], // The account to say hello to
    _instruction_data: &[u8], // Ignored, all helloworld instructions are hellos
) -> ProgramResult {
    msg!("Hello World Rust program entrypoint");

    // Iterating accounts is safer than indexing
    let accounts_iter = &mut accounts.iter();

    // Get the account to say hello to
    let account = next_account_info(accounts_iter)?;

    // The account must be owned by the program in order to modify its data
    if account.owner != program_id {
        msg!("Greeted account does not have the correct program id");
        return Err(ProgramError::IncorrectProgramId);
    }

    // Increment and store the number of times the account has been greeted
    let mut greeting_account = GreetingAccount::try_from_slice(&account.data.borrow())?;
    greeting_account.counter += 1;
    greeting_account.serialize(&mut &mut account.data.borrow_mut()[..])?;

    msg!("Greeted {} time(s)!", greeting_account.counter);

    Ok(())
}

// Sanity tests
#[cfg(test)]
mod test {
    use super::*;
    use solana_program::clock::Epoch;
    use std::mem;

    #[test]
    fn test_sanity() {
        let program_id = Pubkey::default();
        let key = Pubkey::default();
        let mut lamports = 0;
        let mut data = vec![0; mem::size_of::<u32>()];
        let owner = Pubkey::default();
        let account = AccountInfo::new(
            &key,
            false,
            true,
            &mut lamports,
            &mut data,
            &owner,
            false,
            Epoch::default(),
        );
        let instruction_data: Vec<u8> = Vec::new();

        let accounts = vec![account];

        assert_eq!(
            GreetingAccount::try_from_slice(&accounts[0].data.borrow())
                .unwrap()
                .counter,
            0
        );
        process_instruction(&program_id, &accounts, &instruction_data).unwrap();
        assert_eq!(
            GreetingAccount::try_from_slice(&accounts[0].data.borrow())
                .unwrap()
                .counter,
            1
        );
        process_instruction(&program_id, &accounts, &instruction_data).unwrap();
        assert_eq!(
            GreetingAccount::try_from_slice(&accounts[0].data.borrow())
                .unwrap()
                .counter,
            2
        );
    }
}

'''
'''--- contracts/solana/program/tests/lib.rs ---
use borsh::BorshDeserialize;
use helloworld::{process_instruction, GreetingAccount};
use solana_program_test::*;
use solana_sdk::{
    account::Account,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::Signer,
    transaction::Transaction,
};
use std::mem;

#[tokio::test]
async fn test_helloworld() {
    let program_id = Pubkey::new_unique();
    let greeted_pubkey = Pubkey::new_unique();

    let mut program_test = ProgramTest::new(
        "helloworld", // Run the BPF version with `cargo test-bpf`
        program_id,
        processor!(process_instruction), // Run the native version with `cargo test`
    );
    program_test.add_account(
        greeted_pubkey,
        Account {
            lamports: 5,
            data: vec![0_u8; mem::size_of::<u32>()],
            owner: program_id,
            ..Account::default()
        },
    );
    let (mut banks_client, payer, recent_blockhash) = program_test.start().await;

    // Verify account has zero greetings
    let greeted_account = banks_client
        .get_account(greeted_pubkey)
        .await
        .expect("get_account")
        .expect("greeted_account not found");
    assert_eq!(
        GreetingAccount::try_from_slice(&greeted_account.data)
            .unwrap()
            .counter,
        0
    );

    // Greet once
    let mut transaction = Transaction::new_with_payer(
        &[Instruction::new_with_bincode(
            program_id,
            &[0], // ignored but makes the instruction unique in the slot
            vec![AccountMeta::new(greeted_pubkey, false)],
        )],
        Some(&payer.pubkey()),
    );
    transaction.sign(&[&payer], recent_blockhash);
    banks_client.process_transaction(transaction).await.unwrap();

    // Verify account has one greeting
    let greeted_account = banks_client
        .get_account(greeted_pubkey)
        .await
        .expect("get_account")
        .expect("greeted_account not found");
    assert_eq!(
        GreetingAccount::try_from_slice(&greeted_account.data)
            .unwrap()
            .counter,
        1
    );

    // Greet again
    let mut transaction = Transaction::new_with_payer(
        &[Instruction::new_with_bincode(
            program_id,
            &[1], // ignored but makes the instruction unique in the slot
            vec![AccountMeta::new(greeted_pubkey, false)],
        )],
        Some(&payer.pubkey()),
    );
    transaction.sign(&[&payer], recent_blockhash);
    banks_client.process_transaction(transaction).await.unwrap();

    // Verify account has two greetings
    let greeted_account = banks_client
        .get_account(greeted_pubkey)
        .await
        .expect("get_account")
        .expect("greeted_account not found");
    assert_eq!(
        GreetingAccount::try_from_slice(&greeted_account.data)
            .unwrap()
            .counter,
        2
    );
}

'''
'''--- contracts/tezos/counter.js ---
export const CONTRACT_JSON = [
  {
    prim: 'parameter',
    args: [
      {
        prim: 'or',
        args: [
          {prim: 'int', annots: ['%decrement']},
          {prim: 'int', annots: ['%increment']},
        ],
      },
    ],
  },
  {prim: 'storage', args: [{prim: 'int'}]},
  {
    prim: 'code',
    args: [
      [
        {prim: 'UNPAIR'},
        {
          prim: 'IF_LEFT',
          args: [[{prim: 'SWAP'}, {prim: 'SUB'}], [{prim: 'ADD'}]],
        },
        {prim: 'NIL', args: [{prim: 'operation'}]},
        {prim: 'PAIR'},
      ],
    ],
  },
];

'''
'''--- contracts/the_graph/CryptopunksData.abi.json ---
[
  {"inputs": [], "stateMutability": "nonpayable", "type": "constructor"},
  {
    "inputs": [
      {"internalType": "uint8", "name": "index", "type": "uint8"},
      {"internalType": "bytes", "name": "encoding", "type": "bytes"},
      {"internalType": "string", "name": "name", "type": "string"}
    ],
    "name": "addAsset",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {"internalType": "uint64", "name": "key1", "type": "uint64"},
      {"internalType": "uint32", "name": "value1", "type": "uint32"},
      {"internalType": "uint64", "name": "key2", "type": "uint64"},
      {"internalType": "uint32", "name": "value2", "type": "uint32"},
      {"internalType": "uint64", "name": "key3", "type": "uint64"},
      {"internalType": "uint32", "name": "value3", "type": "uint32"},
      {"internalType": "uint64", "name": "key4", "type": "uint64"},
      {"internalType": "uint32", "name": "value4", "type": "uint32"}
    ],
    "name": "addComposites",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {"internalType": "uint8", "name": "index", "type": "uint8"},
      {"internalType": "bytes", "name": "_punks", "type": "bytes"}
    ],
    "name": "addPunks",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{"internalType": "uint16", "name": "index", "type": "uint16"}],
    "name": "punkAttributes",
    "outputs": [{"internalType": "string", "name": "text", "type": "string"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{"internalType": "uint16", "name": "index", "type": "uint16"}],
    "name": "punkImage",
    "outputs": [{"internalType": "bytes", "name": "", "type": "bytes"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{"internalType": "uint16", "name": "index", "type": "uint16"}],
    "name": "punkImageSvg",
    "outputs": [{"internalType": "string", "name": "svg", "type": "string"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "sealContract",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{"internalType": "bytes", "name": "_palette", "type": "bytes"}],
    "name": "setPalette",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

'''
'''--- docker/docker-compose-near.yml ---
version: '3'
services:
  graph-node:
    image: graphprotocol/graph-node:v0.24.1
    ports:
      - '8000:8000'
      - '8001:8001'
      - '8020:8020'
      - '8030:8030'
      - '8040:8040'
    depends_on:
      - ipfs
      - postgres
    environment:
      postgres_host: postgres
      postgres_user: graph-node
      postgres_pass: let-me-in
      postgres_db: graph-node
      ipfs: 'ipfs:5001'
      near: '${ETHEREUM_RPC:-mainnet:https://rpc.mainnet.near.org}'
      RUST_LOG: info
      GRAPH_LOG: info
  ipfs:
    image: ipfs/go-ipfs:v0.4.23
    ports:
      - '5001:5001'
    volumes:
      - ./data/ipfs:/data/ipfs
  postgres:
    image: postgres
    ports:
      - '5432'
    command: ['postgres', '-cshared_preload_libraries=pg_stat_statements']
    environment:
      POSTGRES_USER: graph-node
      POSTGRES_PASSWORD: let-me-in
      POSTGRES_DB: graph-node
    volumes:
      - ./data/postgres:/var/lib/postgresql/data

'''
'''--- docker/docker-compose.yml ---
version: '3'
services:
  graph-node:
    image: graphprotocol/graph-node:v0.26.0
    ports:
      - '8000:8000'
      - '8001:8001'
      - '8020:8020'
      - '8030:8030'
      - '8040:8040'
    depends_on:
      - ipfs
      - postgres
    environment:
      postgres_host: postgres
      postgres_user: graph-node
      postgres_pass: let-me-in
      postgres_db: graph-node
      ipfs: 'ipfs:5001'
      ethereum: '${ETHEREUM_RPC:-localhost:http://host.docker.internal:8545}'
      RUST_LOG: info
      GRAPH_LOG: info
  ipfs:
    image: ipfs/go-ipfs:v0.4.23
    ports:
      - '5001:5001'
    volumes:
      - ./data/ipfs:/data/ipfs
  postgres:
    image: postgres
    ports:
      - '5432'
    command: ['postgres', '-cshared_preload_libraries=pg_stat_statements']
    environment:
      POSTGRES_USER: graph-node
      POSTGRES_PASSWORD: let-me-in
      POSTGRES_DB: graph-node
    volumes:
      - ./data/postgres:/var/lib/postgresql/data

'''
'''--- hooks/index.ts ---
export {default as useLocalStorage} from './useLocalStorage';
export {default as useColors} from './useColors';
export {default as useSteps} from './useSteps';

'''
'''--- hooks/useColors.ts ---
import {GlobalStateT} from 'types';
import {getChainColors} from 'utils/colors';
import {getChainId} from 'utils/context';

const useColors = (state: GlobalStateT) => {
  const chainId = getChainId(state);
  const {primaryColor, secondaryColor} = getChainColors(chainId);

  return {
    primaryColor,
    secondaryColor,
  };
};

export default useColors;

'''
'''--- hooks/useLocalStorage.ts ---
import {useState} from 'react';

const useLocalStorage = <StateT>(key: string, initialValue?: StateT) => {
  const [storedValue, setStoredValue] = useState<StateT>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return {};
    }
  });

  const setValue = (value: StateT | ((val: StateT) => StateT)) => {
    try {
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.log(error);
    }
  };

  return [storedValue, setValue] as const;
};

export default useLocalStorage;

'''
'''--- hooks/useSteps.ts ---
import {useCallback} from 'react';
import {GlobalStateT} from 'types';
import {trackTutorialStepViewed} from 'utils/tracking-utils';
import {
  getChainId,
  getStepId,
  getStepTitle,
  getPreviousStepId,
  getNextStepId,
  getPreviousStep,
  getNextStep,
  isCompletedStep,
  isFirstStep,
  isLastStep,
} from 'utils/context';
import {Action} from 'context';

const useSteps = (state: GlobalStateT, dispatch: (value: Action) => void) => {
  const chainId = getChainId(state);
  const stepId = getStepId(state);

  const prev = useCallback(() => {
    const title = getStepTitle(state);
    dispatch({
      type: 'SetSharedState',
      values: [
        {
          currentStepId: getPreviousStepId(state),
        },
      ],
    });
    trackTutorialStepViewed(chainId, title, 'prev');
  }, [chainId, stepId]);

  const next = useCallback(() => {
    const title = getStepTitle(state);
    dispatch({
      type: 'SetSharedState',
      values: [
        {
          currentStepId: getNextStepId(state),
        },
      ],
    });
    trackTutorialStepViewed(chainId, title, 'prev');
  }, [chainId, stepId]);

  let justify: 'start' | 'end' | 'space-between';
  if (isFirstStep(state)) {
    justify = 'end';
  } else if (isLastStep(state)) {
    justify = 'start';
  } else {
    justify = 'space-between';
  }

  return {
    next,
    prev,
    isFirstStep: isFirstStep(state),
    isLastStep: isLastStep(state),
    justify,
    nextStepTitle: getNextStep(state)?.title,
    previousStepTitle: getPreviousStep(state)?.title,
    isCompleted: isCompletedStep(state),
  };
};

export default useSteps;

'''
'''--- jest.config.js ---
module.exports = {
  testPathIgnorePatterns: ['./node_modules/', './.next/'],
  collectCoverageFrom: [
    '**/*.{js,jsx,ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
  ],
  transform: {
    /* Use babel-jest to transpile tests with the next/babel preset
    https://jestjs.io/docs/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object */
    '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', {presets: ['next/babel']}],
  },
  transformIgnorePatterns: [
    '/node_modules/',
    '^.+\\.module\\.(css|sass|scss)$',
  ],
  modulePaths: ['node_modules', '<rootDir>'],
  moduleNameMapper: {
    '^@figment-avalanche/(.*)$': 'components/protocols/avalanche/$1',
    '^@figment-celo/(.*)$': 'components/protocols/celo/$1',
    '^@figment-ceramic/(.*)$': 'components/protocols/ceramic/$1',
    '^@figment-near/(.*)$': 'components/protocols/near/$1',
    '^@figment-polkadot/(.*)$': 'components/protocols/polka/$1',
    '^@figment-polygon/(.*)$': 'components/protocols/polygon/$1',
    '^@figment-pyth/(.*)$': 'components/protocols/pyth/$1',
    '^@figment-secret/(.*)$': 'components/protocols/secret/$1',
    '^@figment-solana/(.*)$': 'components/protocols/solana/$1',
    '^@figment-tezos/(.*)$': 'components/protocols/tezos/$1',
    '^@figment-thegraph/(.*)$': 'components/protocols/the_graph/$1',
  },
};

'''
'''--- lib/constants.ts ---
import {
  ChainsType,
  CHAINS,
  PROTOCOL_STEPS_ID,
  POLYGON_PROTOCOLS,
  AVALANCHE_PROTOCOLS,
  AVALANCHE_NETWORKS,
  CELO_PROTOCOLS,
  CELO_NETWORKS,
  POLYGON_NETWORKS,
  NEAR_NETWORKS,
  NEAR_PROTOCOLS,
  SECRET_PROTOCOLS,
  SECRET_NETWORKS,
  TEZOS_NETWORKS,
  TEZOS_PROTOCOLS,
  SOLANA_PROTOCOLS,
  SOLANA_NETWORKS,
  POLKADOT_NETWORKS,
  CERAMIC_PROTOCOLS,
  CERAMIC_NETWORKS,
  THE_GRAPH_PROTOCOLS,
  THE_GRAPH_NEAR_PROTOCOLS,
  THE_GRAPH_NETWORKS,
  THE_GRAPH_NEAR_NETWORKS,
  ARWEAVE_PROTOCOLS,
  ARWEAVE_NETWORKS,
  PYTH_PROTOCOLS,
  PYTH_NETWORKS,
} from 'types';

export const GRID_LAYOUT = [13, 11];
export const HEADER_HEIGHT = 80;
export const FOOTER_HEIGHT = 90;

export const CHAINS_CONFIG: ChainsType = {
  [CHAINS.AVALANCHE]: {
    id: CHAINS.AVALANCHE,
    label: 'Avalanche',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/avalanche-avax-logo.svg?v=010',
    protocol: AVALANCHE_PROTOCOLS.RPC,
    network: AVALANCHE_NETWORKS.DATAHUB,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Avalanche Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect to Avalanche',
      },
      {
        id: PROTOCOL_STEPS_ID.CREATE_KEYPAIR,
        title: 'Create a keypair',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_BALANCE,
        title: 'Get the balance',
      },
      {
        id: PROTOCOL_STEPS_ID.TRANSFER_TOKEN,
        title: 'Transfer some AVAX',
      },
      {
        id: PROTOCOL_STEPS_ID.EXPORT_TOKEN,
        title: 'Export tokens from X-Chain to C-Chain',
      },
      {
        id: PROTOCOL_STEPS_ID.IMPORT_TOKEN,
        title: 'Import tokens from X-Chain to C-Chain',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.CELO]: {
    id: CHAINS.CELO,
    label: 'Celo',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/celo-celo-logo.svg?v=010',
    protocol: CELO_PROTOCOLS.RPC,
    network: CELO_NETWORKS.TESTNET,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Celo Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect to Celo',
      },
      {
        id: PROTOCOL_STEPS_ID.CREATE_ACCOUNT,
        title: 'Create an account',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_BALANCE,
        title: 'Get the balance',
      },
      {
        id: PROTOCOL_STEPS_ID.TRANSFER_TOKEN,
        title: 'Transfer some tokens',
      },
      {
        id: PROTOCOL_STEPS_ID.SWAP_TOKEN,
        title: 'Swap cUSD to CELO',
      },
      {
        id: PROTOCOL_STEPS_ID.DEPLOY_CONTRACT,
        title: 'Deploy a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_CONTRACT_VALUE,
        title: 'Get the storage of a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.SET_CONTRACT_VALUE,
        title: 'Set the storage of a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.NEAR]: {
    id: CHAINS.NEAR,
    label: 'NEAR',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/near-protocol-near-logo.svg?v=010',
    protocol: NEAR_PROTOCOLS.RPC,
    network: NEAR_NETWORKS.DATAHUB,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the NEAR Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect to NEAR',
      },
      {
        id: PROTOCOL_STEPS_ID.CREATE_KEYPAIR,
        title: 'Generate a keypair',
      },
      {
        id: PROTOCOL_STEPS_ID.CREATE_ACCOUNT,
        title: 'Create an account',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_BALANCE,
        title: 'Get account balance',
      },
      {
        id: PROTOCOL_STEPS_ID.TRANSFER_TOKEN,
        title: 'Transfer some NEAR',
      },
      {
        id: PROTOCOL_STEPS_ID.DEPLOY_CONTRACT,
        title: 'Deploy a contract',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_CONTRACT_VALUE,
        title: 'Get the storage of a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.SET_CONTRACT_VALUE,
        title: 'Set the storage of a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.POLKADOT]: {
    id: CHAINS.POLKADOT,
    label: 'Polkadot',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/polkadot-new-dot-logo.svg?v=010',
    protocol: POLYGON_PROTOCOLS.WS,
    network: POLKADOT_NETWORKS.TESTNET,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Polkadot Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect to Polkadot',
      },
      {
        id: PROTOCOL_STEPS_ID.CREATE_ACCOUNT,
        title: 'Create an account',
      },
      {
        id: PROTOCOL_STEPS_ID.RESTORE_ACCOUNT,
        title: 'Restore an account',
      },
      {
        id: PROTOCOL_STEPS_ID.ESTIMATE_FEES,
        title: 'Estimate transaction fees',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_BALANCE,
        title: 'Get the balance',
      },
      {
        id: PROTOCOL_STEPS_ID.ESTIMATE_DEPOSIT,
        title: 'Existential deposit',
      },
      {
        id: PROTOCOL_STEPS_ID.TRANSFER_TOKEN,
        title: 'Transfer some tokens',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.POLYGON]: {
    id: CHAINS.POLYGON,
    label: 'Polygon',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/polygon-matic-logo.svg?v=010',
    protocol: POLYGON_PROTOCOLS.RPC,
    network: POLYGON_NETWORKS.TESTNET,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Polygon Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect to Polygon',
      },
      {
        id: PROTOCOL_STEPS_ID.QUERY_CHAIN,
        title: 'Query Polygon',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_BALANCE,
        title: 'Fund a Polygon account',
      },
      {
        id: PROTOCOL_STEPS_ID.TRANSFER_TOKEN,
        title: 'Transfer some MATIC',
      },
      {
        id: PROTOCOL_STEPS_ID.DEPLOY_CONTRACT,
        title: 'Deploy a Solidity smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.SET_CONTRACT_VALUE,
        title: 'Set the storage of the contract',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_CONTRACT_VALUE,
        title: 'Get the storage of the contract',
      },
      {
        id: PROTOCOL_STEPS_ID.RESTORE_ACCOUNT,
        title: 'Restore your account',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.PYTH]: {
    id: CHAINS.PYTH,
    label: 'Pyth',
    active: true,
    logoUrl:
      'https://miro.medium.com/fit/c/262/262/1*IJmOPkddaHkuvONbkzCQiQ.jpeg',
    protocol: PYTH_PROTOCOLS.RPC,
    network: PYTH_NETWORKS.DEVNET,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Pyth Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PYTH_CONNECT,
        title: 'Connect to Pyth on Solana',
      },
      {
        id: PROTOCOL_STEPS_ID.PYTH_SOLANA_WALLET,
        title: 'Wallet implementation',
      },
      {
        id: PROTOCOL_STEPS_ID.PYTH_VISUALIZE_DATA,
        title: 'Visualize price data',
      },
      {
        id: PROTOCOL_STEPS_ID.PYTH_EXCHANGE,
        title: 'Token swaps on a DEX',
      },
      {
        id: PROTOCOL_STEPS_ID.PYTH_LIQUIDATE,
        title: 'Liquidation Bot implementation',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.SECRET]: {
    id: CHAINS.SECRET,
    label: 'Secret',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/secret-scrt-logo.svg?v=010',
    protocol: SECRET_PROTOCOLS.RPC,
    network: SECRET_NETWORKS.TESTNET,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Secret Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect to Secret',
      },
      {
        id: PROTOCOL_STEPS_ID.CREATE_ACCOUNT,
        title: 'Create an account',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_BALANCE,
        title: 'Get the balance',
      },
      {
        id: PROTOCOL_STEPS_ID.TRANSFER_TOKEN,
        title: 'Transfer some SCRT',
      },
      {
        id: PROTOCOL_STEPS_ID.DEPLOY_CONTRACT,
        title: 'Deploy a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_CONTRACT_VALUE,
        title: 'Get the storage of a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.SET_CONTRACT_VALUE,
        title: 'Set the storage of a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.SOLANA]: {
    id: CHAINS.SOLANA,
    label: 'Solana',
    logoUrl: 'https://cryptologos.cc/logos/solana-sol-logo.svg?v=010',
    protocol: SOLANA_PROTOCOLS.RPC,
    network: SOLANA_NETWORKS.DEVNET,
    active: true,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Solana Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect to Solana',
      },
      {
        id: PROTOCOL_STEPS_ID.CREATE_ACCOUNT,
        title: 'Create an account',
      },
      {
        id: PROTOCOL_STEPS_ID.FUND_ACCOUNT,
        title: 'Fund the account with SOL',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_BALANCE,
        title: 'Get the balance',
      },
      {
        id: PROTOCOL_STEPS_ID.TRANSFER_TOKEN,
        title: 'Transfer some SOL',
      },
      {
        id: PROTOCOL_STEPS_ID.DEPLOY_CONTRACT,
        title: 'Deploy a program',
      },
      {
        id: PROTOCOL_STEPS_ID.SOLANA_CREATE_GREETER,
        title: 'Create storage for the program',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_CONTRACT_VALUE,
        title: 'Get data from the program',
      },
      {
        id: PROTOCOL_STEPS_ID.SET_CONTRACT_VALUE,
        title: 'Send data to the program',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.TEZOS]: {
    id: CHAINS.TEZOS,
    label: 'Tezos',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=010',
    protocol: TEZOS_PROTOCOLS.RPC,
    network: TEZOS_NETWORKS.TESTNET,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Tezos Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Setup the project',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect to Tezos',
      },
      {
        id: PROTOCOL_STEPS_ID.CREATE_ACCOUNT,
        title: 'Create an account',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_BALANCE,
        title: 'Get the balance',
      },
      {
        id: PROTOCOL_STEPS_ID.TRANSFER_TOKEN,
        title: 'Transfer some TEZ',
      },
      {
        id: PROTOCOL_STEPS_ID.DEPLOY_CONTRACT,
        title: 'Deploy a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.GET_CONTRACT_VALUE,
        title: 'Get the storage of a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.SET_CONTRACT_VALUE,
        title: 'Set the storage of a smart contract',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.CERAMIC]: {
    id: CHAINS.CERAMIC,
    label: 'Ceramic',
    active: false,
    logoUrl: 'https://developers.ceramic.network/images/ceramic-no-shadow.png',
    protocol: CERAMIC_PROTOCOLS.HTTP,
    network: CERAMIC_NETWORKS.TESTNET,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the Ceramic Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Introduction',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.CHAIN_CONNECTION,
        title: 'Connect with MetaMask',
      },
      {
        id: PROTOCOL_STEPS_ID.LOGIN,
        title: 'Login with IDX',
      },
      {
        id: PROTOCOL_STEPS_ID.BASIC_PROFILE,
        title: 'Update and read your profile',
      },
      {
        id: PROTOCOL_STEPS_ID.CUSTOM_DEFINITION,
        title: 'Deploy and use custom definition',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.THE_GRAPH]: {
    id: CHAINS.THE_GRAPH,
    label: 'The Graph',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/the-graph-grt-logo.svg?v=013',
    protocol: THE_GRAPH_PROTOCOLS.GRAPHQL,
    network: THE_GRAPH_NETWORKS.LOCALNET,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the The Graph Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Introduction',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.GRAPH_NODE,
        title: 'Run a local Graph node',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_SCAFFOLD,
        title: 'Create a subgraph scaffold',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_MANIFEST,
        title: 'Tweak the Manifest',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_SCHEMA,
        title: 'Define the schema',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_MAPPINGS,
        title: 'Implement the mappings',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_QUERY,
        title: 'Query the subgraph',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.THE_GRAPH_NEAR]: {
    id: CHAINS.THE_GRAPH_NEAR,
    label: 'NEAR Graph',
    active: true,
    logoUrl: 'https://cryptologos.cc/logos/near-protocol-near-logo.svg?v=010',
    protocol: THE_GRAPH_NEAR_PROTOCOLS.GRAPHQL,
    network: THE_GRAPH_NEAR_NETWORKS.HOSTED,
    steps: [
      {
        id: PROTOCOL_STEPS_ID.PREFACE,
        title: 'Welcome to the The Graph for NEAR Pathway',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.PROJECT_SETUP,
        title: 'Introduction',
        isOneColumn: true,
      },
      {
        id: PROTOCOL_STEPS_ID.GRAPH_NODE,
        title: 'The Graph hosted service',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_SCAFFOLD,
        title: 'Create a subgraph scaffold',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_MANIFEST,
        title: 'Tweak the Manifest',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_SCHEMA,
        title: 'Define the schema',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_MAPPINGS,
        title: 'Implement the mappings',
      },
      {
        id: PROTOCOL_STEPS_ID.SUBGRAPH_QUERY,
        title: 'Query the subgraph',
      },
      {
        id: PROTOCOL_STEPS_ID.FINAL,
        title: '🎓 Pathway complete!',
        isOneColumn: true,
      },
    ],
  },
  [CHAINS.ARWEAVE]: {
    id: CHAINS.ARWEAVE,
    label: 'Arweave',
    active: false,
    logoUrl: 'https://cryptologos.cc/logos/arweave-ar-logo.svg?v=014',
    protocol: ARWEAVE_PROTOCOLS.RPC,
    network: ARWEAVE_NETWORKS.MAINNET,
    steps: [],
  },
};

'''
'''--- markdown/PREFACE.md ---
## 🧑‍🏫 Instructions on the left, 🤝 interaction on the right

Each step in a Pathway covers a different aspect of using a particular blockchain or protocol. The format is easy to follow, with instructions on the left side and the right side for you to interact with your code. Remember that the left side can be scrolled down to show the rest of the content.

## 🏋️ Challenges & hints

After some explanation of each topic, there is a coding challenge for you to complete before you can proceed to the next step, for example:

```js
// path/to/the/file/to/edit.ts - this is only an example!
const provider = undefined; // Create an Ethereum provider using ethers
const selectedAddress = undefined; // then get the address
const balanceToDisplay = undefined; // and format its balance
```

For every challenge, we will give you hints and tips to help you get started. They usually point to the relevant documentation page, for example:

**Need some help?** Check out these links 👇

- Getting a [provider](https://docs.ethers.io/v5/api/providers/#providers) with ethers.js
- Formatting a balance with [formatUnits](https://docs.ethers.io/v5/api/utils/display-logic/#utils-formatUnits)

## 😅 Providing solutions

Don't worry if you can't find the answer, we provide the solution to every challenge. It's just hidden so that we don't spoil anything for you, click "Show Solution" to reveal it:

```js
// solution
// path/to/the/file/to/edit.ts - this is only an example!
const provider = new ethers.providers.Web3Provider(window.ethereum);
const selectedAddress = provider.selectedAddress;
const balanceOfAddress = await provider.getBalance(selectedAddress);
const balanceToDisplay = ethers.utils.formatUnits(balanceOfAddress, 18);
```

When you have completed the code, make sure it works by interacting with the UI on the right side of the page. The button at the bottom right of the screen will be enabled and allow you to move on to the next step!

## 💬 Connect with us on Discord

If you experience any difficulty in using the Pathway or want to talk about Web 3, please join our Developer community on Discord - <https://figment.io/devchat>

## 👣 Next Steps

Click on the **Next** (or **Setup the project**) button below to continue with the Pathway.

'''
'''--- markdown/avalanche/CHAIN_CONNECTION.md ---
[Avalanche.js](https://github.com/ava-labs/avalanchejs) is a client JavaScript package that makes it easy to interact with Avalanche blockchain nodes, query data, submit transactions and offers plenty of other functionality. It's the official package developed by Avalanche, and is a preferred method of communicating with nodes on the private or public networks for development purposes.

In this tutorial, we will learn how to connect to an Avalanche node using DataHub. You will need to complete the code in each tutorial, to make the dApp functional.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/avalanche/connect.ts`, implement the function and try to establish your first connection to the Avalanche network. To verify your connection has been correctly established, try to return the current protocol version. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

```typescript
//...
  try {
    const {network} = req.body;
    const client = undefined;
    const info = undefined;
    const version = undefined;
    if (version === undefined) {
      throw new Error('Connection failed: Complete the code');
    }
    res.status(200).json(version);
  }
//...
```

**Need some help?** Check out these tips 👇

- [**Check out the `AvalancheJS` library**](https://github.com/ava-labs/avalanchejs)
- Use the `getAvalancheClient` helper function.
- Use the `Info` method on the client.
- Use the `getNodeVersion` method on the client info (remember to `await` this call).

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network} = req.body;
    const client = getAvalancheClient(network);
    const info = client.Info();
    const version = await info.getNodeVersion();
    if (version === undefined) {
      throw new Error('Connection failed: Complete the code');
    }
    res.status(200).json(version);
  }
//...
```

**What happened in the code above?**

- We instantiate an `Avalanche` object with `getAvalancheClient` passing to it the selected `network`.
- Calling the `Info` method on the `AvalancheClient` module returns a reference to the Info RPC.
- `getNodeVersion` sends the request and retrieves the current version of Avalanche running on the node.

---

# ✅ Make sure it works

Once the code in `pages/api/avalanche/connect.ts` is complete and the file has been saved, click the blue button to connect to Avalanche and display the current version.

---

# 🏁 Conclusion

Now that we have successfully connected to an Avalanche node using DataHub, we are ready to move on to the next tutorial. We have also created the foundation for the next step, creating an account.

'''
'''--- markdown/avalanche/CREATE_KEYPAIR.md ---
In this tutorial, we will be creating an Avalanche account on the X-Chain using the Avalanche JavaScript API and DataHub.

Unlike other popular blockchains, Avalanche comes with a set of different chains, each with its own purpose:

- Exchange Chain or **X-Chain** which handles asset transfers.
- Platform Chain or **P-Chain** is for network validators and staking.
- Contract Chain or **C-Chain** handles smart contract execution.

## X-Chain

The X-Chain acts as a decentralized platform for creating and trading digital smart assets, a representation of a real-world resource (such as equity or bonds) with a set of rules that govern its behavior, like "can’t be traded until tomorrow" or "can only be sent to US citizens".

One asset traded on the X-Chain is AVAX. When you issue a transaction to a blockchain on Avalanche, you pay a fee denominated in AVAX.

## P-Chain

The P-Chain is the metadata blockchain on Avalanche and coordinates validators, keeps track of active [subnets](https://support.avax.network/en/articles/4064861-what-is-a-subnet), and enables the creation of new subnets. The P-Chain implements the Snowman [consensus protocol](https://docs.avax.network/learn/platform-overview/avalanche-consensus).

## C-Chain

The C-Chain allows for the creation of smart contracts using the C-Chain’s API, and is an instance of the [Ethereum Virtual Machine](https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture/6413#6413) (EVM) powered by Avalanche.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/avalanche/account.ts`, implement the function to create our private key. A private key is used to sign transactions on any Avalanche chain (X/P/C), and for educational purposes we'll use a single private key during the Pathway. To manage the keys we first configure the Keychain, a component for managing private/public key pairs and addresses. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

```typescript
//...
  try {
    const {network} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const keyChain = chain.keyChain();
    const keypair = keyChain.undefined; // There is a useful method to use here
    const secret = undefined;
    const address = undefined;
    res.status(200).json({
      secret,
      address,
    });
  }
//...
```

**Need some help?** Check out these tips

- Using the code completion feature of your favorite code editor, find a method which retrieves a KeyPair object.
- On the keypair instance, call a method to retrieve the `PrivateKey` in string format.
- On the keypair instance, call a method to retrieve the `Address` in string format.
- [**`AvalancheJS` create keypair example**](https://github.com/ava-labs/avalanchejs/blob/master/examples/evm/createKeypair.ts)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const keyChain = chain.keyChain();
    const keypair = keyChain.makeKey();
    const secret = keypair.getPrivateKeyString();
    const address = keypair.getAddressString();
    res.status(200).json({
      secret,
      address,
    });
  }
//...
```

**What happened in the code above?**

- Calling the `makeKey` method will give us a usable keypair.
- `getPrivateKeyString` retrieves the string-formatted private key.
- `getAddressString` retrieves the string-formatted public key.

{% hint style="tip" %}
Do not forget to fund the newly created wallet using the [Avalanche testnet faucet](https://faucet.avax-test.network/) in order to activate it!
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/avalanche/account.ts` is complete, Next.js will rebuild the API route. Now click on **Generate a Keypair** to make your account on Avalanche.

---

# 🏁 Conclusion

Nice! Now that you have an identity, it's time to interact with the blockchain.
You want to know the amount of tokens your account holds? Good, this is exactly what the next challenge is - querying Avalanche for an account balance.

'''
'''--- markdown/avalanche/EXPORT_TOKEN.md ---
Since Avalanche operates on 3 chains (X/P/C), it allows users to transfer tokens in each direction.

AVAX tokens exist on the X-Chain, where they can be traded; on the P-Chain, where they can be provided as a stake when validating the Primary Network; and on the C-Chain, where they can be used in smart contracts or to pay for gas fees. Avalanche supports movement of AVAX between these chains. We'll be concentrating our efforts on X->C swaps, since the C-Chain is used for smart contract deployments.

Inter-chain transfers are performed via a 2-step process:

- Create the X-Chain export transaction -> (this tutorial)
- Create the C-Chain import transaction

Here we will focus on the first part, the **X-Chain export transaction**.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/avalanche/export.ts`, implement the function and try to create an export transaction from X-Chain to C-Chain. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {secret, network} = req.body;
    const client = getAvalancheClient(network);

    // Total amount we're transferring = 0.05 AVAX
    const amount = "50000000";

    // Taking inspiration for xChain do the same for cChain
    const [ xChain   , cChain    ] = [ client.XChain()            , undefined ];
    const [ xKeychain, cKeychain ] = [ xChain.keyChain()          , undefined ];
    const [ xKeypair , cKeypair  ] = [ xKeychain.importKey(secret), undefined ];
    const [ xAddress , cAddress  ] = [ xKeypair.getAddressString(), undefined ];

    // Fetch UTXOs (unspent transaction outputs)
    const { utxos } = await xChain.getUTXOs(xAddress)

    // Get the real ID for the cChain
    const chainId = undefined;

    // Prepare the export transaction from X -> C chain
    const exportTx = await xChain.buildExportTx(undefined)

    // Sign and send the transaction
    const hash = await xChain.issueTx(exportTx.sign(xKeychain))

    res.status(200).json(hash)
  }
//...
```

**Need some help?** Check out these links 👇

- [**Code examples**](https://github.com/ava-labs/avalanchejs/tree/master/examples/avm)
- [**Manage X-Chain Keys**](https://docs.avax.network/build/tools/avalanchejs/manage-x-chain-keys)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {secret, network} = req.body;
    const client = getAvalancheClient(network);
    // Total amount we're transferring = 0.05 AVAX
    const amount = "50000000";

    // Initialize chain components
    const [ xChain   , cChain    ] = [ client.XChain()            , client.CChain()             ];
    const [ xKeychain, cKeychain ] = [ xChain.keyChain()          , cChain.keyChain()           ];
    const [ xKeypair , cKeypair  ] = [ xKeychain.importKey(secret), cKeychain.importKey(secret) ];
    const [ xAddress , cAddress  ] = [ xKeypair.getAddressString(), cKeypair.getAddressString() ];

    // Get the real ID for the destination chain
    const chainId = await client.Info().getBlockchainID("C");

    // Fetch UTXOs (i.e unspent transaction outputs)
    const { utxos } = await xChain.getUTXOs(xAddress);

    // Prepare the export transaction from X -> C chain
    const exportTx = await xChain.buildExportTx(
        utxos, // Unspent transaction outputs
        new BN(amount), // Transfer amount
        chainId, // Target chain ID (for C-Chain)
        [cAddress], // Addresses being used to send the funds from the UTXOs provided
        [xAddress], // Addresses being used to send the funds from the UTXOs provided
        [xAddress], // Addresses that can spend the change remaining from the spent UTXOs
    )

    // Sign and send the transaction
    const hash = await xChain.issueTx(exportTx.sign(xKeychain));

    res.status(200).json(hash);
  }
//...
```

**What happened in the code above?**

- First, we need to build our C-Chain keypair. This works exactly the same way for X-Chain.
- Next, we determine the chainId.
- Next, we build our transaction the same way as for a simple **AVAX** transfer:
  - `cAddress` replacing `sender`.
  - `chainId` replacing `assetId`.
- Finally, we sign and send the transaction and return the transaction hash.

---

# ✅ Make sure it works

Once the code in `pages/api/avalanche/export.ts` is complete, Next.js will rebuild the API route. Click on **Export 0.05 AVAX** and you should see the balance displayed on the page.

---

# 🏁 Conclusion

Our next topic is to process the import of the cross-chain transfer. Time to import the AVAX we just sent to C-Chain. Let's go!

'''
'''--- markdown/avalanche/FINAL.md ---
🥳 **Congratulations**, you have completed the Avalanche Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to Avalanche with a Javascript library
- 🏦 Creating an account by generating a keypair and funding the resulting address by using the AVAX faucet
- 💸 Transferring tokens between accounts
- ♻️ Importing and Exporting tokens between chains

# 🧐 Keep learning with these resources

- 🏗 [Create NFTs with the Avalanche wallet](https://learn.figment.io/tutorials/create-nfts-with-the-avalanche-wallet)
- 🗣 [Create a chat application on Avalanche](https://learn.figment.io/tutorials/create-a-chat-application-using-solidity-and-react)
- 🔍 [Explore the Avalanche ecosystem](https://ecosystem.avax.network/marketplace?tag=)
- 📚 [AvalancheJS examples](https://github.com/ava-labs/avalanchejs/tree/master/examples/avm)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/avalanche/GET_BALANCE.md ---
Now that you have created an account on the Avalanche **Fuji** testnet and funded it using the faucet - We're going to check the balance of the account to make sure everything went alright. The native token of the **Avalanche** blockchain is **AVAX**, so we will want to start on the X-Chain.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/avalanche/balance.ts`, implement the default function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

```typescript
//...
  try {
    const {network, address} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const balance = undefined;
    res.status(200).json(balance.balance);
  }
//...
```

**Need some help?** Check out these tips

- The `getBalance` method of the `AVMAPI` module looks like a good candidate!
- [**Code examples**](https://github.com/ava-labs/avalanchejs/tree/master/examples/avm)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network, address} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const balance = await chain.getBalance(address, "AVAX") as BalanceT;
    res.status(200).json(balance.balance);
  }
//...
```

**What happened in the code above?**

- The `getBalance` method will return the current balance of the specified asset (like AVAX) for the specified address.

{% hint style="tip" %}
The amount returned by is denominated in **nAVAX**, so to convert it to **AVAX** you'll need to divide it by 10\*\*9
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/avalanche/balance.ts` is complete, Next.js will rebuild the API route. Click on **Check Balance**, then you should see the balance displayed on the page.

---

# 🏁 Conclusion

Querying the balance information is fun, but being able to submit transactions and change the state of a blockchain is even better! In the next step, we will dive deeper and submit our first transactions on Avalanche.

'''
'''--- markdown/avalanche/IMPORT_TOKEN.md ---
Since Avalanche operates on 3 chains (X/P/C), it allows users to transfer tokens in each direction.

AVAX tokens exist on the X-Chain, where they can be traded, on the P-Chain, where they can be provided as a stake when validating the Primary Network, and on the C-Chain, where they can be used in smart contracts or to pay for gas fees. Avalanche supports movement of AVAX between these chains. We'll be concentrating our efforts on X->C swaps, with C-Chain being used for smart contract deployments.

Inter-chain transfers are performed via a 2-step process:

- Create the X-Chain export transaction
- Create the C-Chain import transaction -> (this tutorial)

Here we will focus on the second part, the **C-Chain import transaction**.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/avalanche/import.ts`, implement the function and try to import the AVAX sent in the previous tutorial to C-Chain. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {secret, network} = req.body;
    const client = getAvalancheClient(network);

    // Initialize chain components
    const [ xChain   , cChain    ] = [ client.XChain()            , client.CChain()             ];
    const [ xKeychain, cKeychain ] = [ xChain.keyChain()          , cChain.keyChain()           ];
    const [ xKeypair , cKeypair  ] = [ xKeychain.importKey(secret), cKeychain.importKey(secret) ];
    const [ cAddress ] = [ cKeypair.getAddressString() ];

    // Get the real ID for X-Chain
    const xChainId = undefined;

    // Fetch UTXOs (unspent transaction outputs)
    const { utxos } = await cChain.getUTXOs(cAddress, xChainId);

    // Derive Eth-like address from the private key
    const binTools = BinTools.getInstance();
    const keyBuff = binTools.cb58Decode(secret.split('-')[1]);
    const ethAddr = Address.fromPrivateKey(
      Buffer.from(keyBuff.toString('hex'), 'hex'),
    ).toString();
    console.log("Ethereum-style address: ", ethAddr);

    // Generate an unsigned import transaction
    const importTx = await cChain.buildImportTx(undefined);

    // Sign and send import transaction
    const hash = await cChain.issueTx(importTx.sign(cKeychain));

    res.status(200).json(hash)
  }
//...
```

**Need some help?** Check out these links 👇

- [**Code examples**](https://github.com/ava-labs/avalanchejs/tree/master/examples/avm)
- [**Manage X-Chain Keys**](https://docs.avax.network/build/tools/avalanchejs/manage-x-chain-keys)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {secret, network} = req.body;
    const client = getAvalancheClient(network);

    // Initialize chain components
    const [ xChain   , cChain    ] = [ client.XChain()            , client.CChain()             ];
    const [ xKeychain, cKeychain ] = [ xChain.keyChain()          , cChain.keyChain()           ];
    const [ xKeypair , cKeypair  ] = [ xKeychain.importKey(secret), cKeychain.importKey(secret) ];
    const [ cAddress ] = [ cKeypair.getAddressString() ];

    // Get the real ID for X-Chain
    const xChainId = await client.Info().getBlockchainID("X");

    // Fetch UTXOs (i.e unspent transaction outputs)
    const { utxos } = await cChain.getUTXOs(cAddress, xChainId);

    // Derive Eth-like address from the private key
    const binTools = BinTools.getInstance();
    const keyBuff = binTools.cb58Decode(secret.split('-')[1]);
    const ethAddr = Address.fromPrivateKey(
      Buffer.from(keyBuff.toString('hex'), 'hex'),
    ).toString();
    console.log("Ethereum-style address: ", ethAddr);

    // Generate an unsigned import transaction
    const importTx = await cChain.buildImportTx(
        utxos,
        ethAddr,
        [cAddress],
        xChainId,
        [cAddress]
    )

    // Sign and send import transaction
    const hash = await cChain.issueTx(importTx.sign(cKeychain));

    res.status(200).json(hash);
  }
//...
```

**What happened in the code above?**

- First, we need to build our C-Chain keypair. This works exactly the same way for X-Chain.
- Next, we determine the chainId.
- Next, we fetch the latest `UTXOS`.
- Next, as we're working on an EVM compatible blockchain (C-Chain understands Solidity smart contracts), we need to deduce the Ethereum-style address from the private key.
- Next, we build our transaction the same way as for a simple transfer:
  - There is no amount, as we're importing an already existing amount.
  - The destination address is in Ethereum format as we're working on an EVM compatible chain.
- Finally, we sign and send the transaction and return the transaction hash.

---

# ✅ Make sure it works

Once the code in `pages/api/avalanche/import.ts` is complete, Next.js will rebuild the API route. Click on **Import 0.05 AVAX** and you should see the balance displayed on the page.

---

# 🏁 Conclusion

Congratulations, you've made it this far and successfully completed an AVAX transfer from the X-Chain to the C-Chain. The same approach works in reverse (C-Chain -> X-Chain), or for any other inter-chain transfers (X-Chain -> P-Chain or P-Chain -> C-Chain for example).

'''
'''--- markdown/avalanche/PROJECT_SETUP.md ---
# 🧩 DataHub API keys

If you wish to make use of the Pathway content using DataHub, you will need a DataHub account and a valid API key to access Avalanche via DataHub's infrastructure. [Sign up for a DataHub account](https://datahub-beta.figment.io/signup) and verify your email address. Once you have logged in to DataHub, you will need to create a new app and select the Avalanche protocol.

Click "Create New App":

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_1.png?raw=true)

Type in a name for your app, select the **Staging** environment, then click on the **Avalanche** icon in the list of available protocols. \
Click "Create app" when you're finished:

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_2.png?raw=true)

You can now find your API key on the Overview tab of the app on the [**DataHub Dashboard**](https://datahub-beta.figment.io/apps):

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_3.png?raw=true)

To use your API key, you should copy the contents of the `.env.example` file located in the project root directory (`/learn-web3-dapp/.env.example`) into a new file named `.env.local` (`/learn-web3-dapp/.env.local`). Also, since this file will contain your API key, we have already added it to the `.gitignore`.

{% hint style="info" %}
Easily duplicate the file with the terminal command `cp .env.example .env.local`!
{% endhint %}

You can then paste your unique API key into `.env.local`, as the value for the environment variable `DATAHUB_AVALANCHE_API_KEY`. This will authenticate you and enable you to make requests to Avalanche via DataHub. **The API key shown below is only an example and cannot be used to access DataHub**.

```yaml
# DataHub API keys
DATAHUB_AVALANCHE_API_KEY=4c133c840ab69cbf45f948386bde2d6c
DATAHUB_CELO_API_KEY=
DATAHUB_NEAR_API_KEY=
DATAHUB_POLKADOT_API_KEY=
DATAHUB_POLYGON_API_KEY=
DATAHUB_SECRET_API_KEY=
DATAHUB_SOLANA_API_KEY=
DATAHUB_TEZOS_API_KEY=
```

# 👣 Next Steps

Once you have your Avalanche API key saved in `/learn-web3-dapp/.env.local`, you're ready to begin.
Click on the **Next: Connect to Avalanche** button below.

'''
'''--- markdown/avalanche/TRANSFER_TOKEN.md ---
We already know that Avalanche is not your typical blockchain, with P/X/C chains supporting various operations. Each of these chains also has its own set of transaction types, however, we are looking to create a very simple one - a _token transfer_, and specifically on the X-Chain.

In simple terms: We will be sending some AVAX tokens from address A to address B to simulate a payment for goods/services.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/avalanche/transfer.ts`, implement the function and try to make your first transfer on the Avalanche network. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
  try {
    const {secret, navax, recipient, address, network} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const keychain = chain.keyChain();
    // Using keychain, load the private key to sign transactions
    undefined;

    // Fetch UTXOs (unspent transaction outputs)
    const { utxos } = undefined;

    // Determine the real asset ID from its symbol/alias
    const binTools = BinTools.getInstance();
    const assetInfo = await chain.getAssetDescription("AVAX");
    const assetID = binTools.cb58Encode(assetInfo.assetID);

    // Create a new transaction
    const transaction = await chain.buildBaseTx(undefined);

    // Sign the transaction and send it to the network
    undefined;
    undefined;

    res.status(200).json(hash);
  }
//...
```

**Need some help?** Check out these links

- [**Transfer example**](https://github.com/ava-labs/avalanchejs/tree/master/examples/avm)
- [**Manage X-Chain Keys**](https://docs.avax.network/build/tools/avalanchejs/manage-x-chain-keys)
- [**What The Heck is UTXO**](https://medium.com/bitbees/what-the-heck-is-utxo-ca68f2651819)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {secret, navax, recipient, address, network} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const keychain = chain.keyChain();
    keychain.importKey(secret);

    // Fetch UTXO (i.e unspent transaction outputs)
    const { utxos } = await chain.getUTXOs(address);

    // Determine the real asset ID from its symbol/alias
    // We can also get the primary asset ID with chain.getAVAXAssetID() call
    const binTools = BinTools.getInstance();
    const assetInfo = await chain.getAssetDescription("AVAX");
    const assetID = binTools.cb58Encode(assetInfo.assetID);

    // Create a new transaction
    const transaction = await chain.buildBaseTx(
      utxos, // Unspent transaction outputs
      new BN(navax), // Transaction amount, formatted as a BigNumber
      assetID, // AVAX asset
      [recipient], // Addresses we are sending the funds to (receiver)
      [address], // Addresses being used to send the funds from the UTXOs provided (sender)
      [address], // Addresses that can spend the change remaining from the spent UTXOs (payer)
    );

    // Sign the transaction and send it to the network
    const signedTx = transaction.sign(keychain);
    const hash = await chain.issueTx(signedTx);

    res.status(200).json(hash);
  }
//...
```

**What happened in the code above?**

- First, calling `importKey()` we pass the private key (`secret`), this allows the keypair to sign transactions.
- Next, we fetch the latest unspent transaction outputs with `getUTXOs`.
- Next, we determine the **assetID** using `BinTools.cb58Encode` method.
- Next, we build a base transaction using `buildBaseTx` passing:
  - The unspent outputs,
  - The transaction amount formatted as BigNumber,
  - The assetID,
  - The recipient address,
  - The sender address,
  - The payer address. Note that the sender and payer in this example are the same, but this is not required.
- Finally, we sign and send the transaction and return the transaction hash.

{% hint style="success" %}
A UTXO is an unspent transaction output. In an accepted transaction in a valid blockchain payment system, only unspent outputs can be used as inputs to a transaction. When a transaction takes place, inputs are deleted and outputs are created as new UTXOs that may then be consumed in future transactions.
{% endhint %}

{% hint style="tip" %}
Remember, the **AVAX** asset is using a 9-digit denomination and **AVAX** is the primary asset on the X-Chain.
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/avalanche/transfer.ts` is complete, Next.js will rebuild the API route. Now fill in the amount of **nAVAX** you want to send and then click on **Submit Transfer** to send the transaction to Avalanche.

---

# 🏁 Conclusion

We've learned how to prepare, sign and broadcast a simple transaction on Avalanche. With only a few lines of code, you can transfer funds on the network. AvalancheJS provides a range of examples on how to construct a transaction with more complex properties, for different use cases. In the next tutorial, we will examine the topic of cross-chain transfers.

'''
'''--- markdown/celo/CHAIN_CONNECTION.md ---
Celo is an open platform that makes financial tools accessible to anyone with a mobile phone. There are especially useful toolkits and code libraries when it comes to developing [dApps](https://en.wikipedia.org/wiki/Decentralized_application) on the Celo network. [ContractKit](https://github.com/celo-org/celo-monorepo/tree/master/packages/sdk/contractkit), for example - This is a JavaScript package that makes it easy to interact with the Celo network and the core Celo smart contracts as well as custom ones built by the community.

We are now all set up with our application and we can start writing some JavaScript code. The first step here is to connect to the Celo **Alfajores** network using ContractKit.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/celo/connect.ts`, implement the function and try to establish your first connection to the Celo network. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const kit = undefined;
    const version = undefined;
    res.status(200).json(version.slice(5, 11));
  }
//...
```

**Need some help?** Check out these links 👇

- [**ContractKit usage**](https://docs.celo.org/developer-guide/contractkit/usage)
- [**To start working with ContractKit you need a kit instance**](https://docs.celo.org/developer-guide/sdk-code-reference/summary-2/modules/_kit_#functions)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);
    const version = await kit.web3.eth.getNodeInfo();
    res.status(200).json(version.slice(5, 11));
  }
//...
```

**What happened in the code above?**

- First, we create a new `kit` instance. This is our connection to Celo, which we will use throughout the Pathway.
- Next, using `web3.eth` we can access a proxy of the [**web3.js - Ethereum Javascript API**](https://web3js.readthedocs.io/en/v3.0.0-rc.5/)
- Finally, calling the `getNodeInfo` method we can query the node to return a slice of the protocol version.

---

# ✅ Make sure it works

Once the code in `pages/api/celo/connect.ts` is complete, click on the blue button to connect to Celo & display the current version.

---

# 🏁 Conclusion

Congratulations, you have successfully made a function that can connect to the Celo node! This can be applied either on the client-side or server-side, depending on your needs.

In this tutorial you’ve learned how to use the ContractKit package and DataHub to connect to the Celo node. You also had a chance to run one simple query to test that connection.

'''
'''--- markdown/celo/CREATE_ACCOUNT.md ---
Please make sure that you have completed the previous step, Connecting to Celo.

It’s time to create your first Celo account on the **Alfajores** testnet. Without it, you won’t be able to fully take advantage of Celo's features.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/celo/account.ts`, implement the function to first create a **mnemonic**, then produce an **address** from the **public key** belonging to the **mnemonic**. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);
    const account = undefined;
    const address = undefined;
    const secret = undefined;

    res.status(200).json({
      address,
      secret,
    });
}
//...
```

**Need some help?** Check out this link 👇

- [**Account documentation**](https://web3js.readthedocs.io/en/v1.4.0/web3-eth-accounts.html)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);
    const account = kit.web3.eth.accounts.create();
    const address = account.address;
    const secret = account.privateKey;

    res.status(200).json({
      address,
      secret,
    });
}
//...
```

**What happened in the code above?**

- First, we create a new `kit` instance.
- Next, using `web3.eth` we can access a proxy of the [**web3.js - Ethereum Javascript API**](https://web3js.readthedocs.io/en/v3.0.0-rc.5/)
- Next, calling `create` from the `account` module, we can create a new account.
- Finally to access:
  - The address, using the `address` property.
  - The private key, using the `privateKey` property.

{% hint style="tip" %}
Do not forget to fund the newly created wallet using the [Celo developer faucet](https://celo.org/developers/faucet) in order to activate it!
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/celo/account.ts` is complete, Next.js will rebuild the API route. Now click on **Generate a Keypair** to create your Celo keypair.

---

# 🏁 Conclusion

Now that we have a Celo account created and funded with testnet tokens, let’s move on to querying a Celo node to get the current balance of our account!

'''
'''--- markdown/celo/DEPLOY_CONTRACT.md ---
We won't go through the process of reviewing the smart contract code base, compiling it or testing it. We will focus instead on how one can deploy a smart contract using the **ContractKit** library. To do this, we're going to use a pre-compiled smart contract, you can find its Application Binary Interface under `contracts/celo/HelloWorld.json`.

Our contract will be pretty basic. It stores a string on the blockchain and implements two functions:

- The `getName` function returns the name stored on the contract.
- The `setName` function changes the name stored on the contract.

{% hint style="working" %}
If you want to learn more about Celo smart contracts, follow the [**Deploy and Interact with Contracts (Remotely)**](https://learn.figment.io/tutorials/hello-contracts) tutorial.
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/celo/deploy.ts`, implement the default function. Upload your first smart contract on the **Celo** network. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
  try {
    const {secret, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    kit.addAccount(secret);

    // TODO: Create a transaction to deploy the contract

    const receipt = await tx.waitReceipt();

    res.status(200).json({
        address: receipt?.contractAddress as string,
        hash: receipt.transactionHash
    });
  }
//...
```

**Need some help?** Check out this link 👇

- [**Deploy a contract with ContractKit**](https://docs.celo.org/developer-guide/contractkit/usage#deploy-a-contract)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const {secret, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    kit.addAccount(secret);

    let tx = await kit.sendTransaction({
        from: address,
        data: HelloWorld.bytecode
    });
    const receipt = await tx.waitReceipt();

    res.status(200).json({
        address: receipt?.contractAddress as string,
        hash: receipt.transactionHash
    });
  }
//...
```

**What happened in the code above?**

- We send a transaction using the `sendTransaction` method passing:
  - `from`, the address which will pay the fees for the transaction
  - `data`, the bytecode of our compiled contract using the `bytecode` property of the ABI stored in `contracts/celo/HelloWorld.json`.

---

# ✅ Make sure it works

Once the code in `pages/api/celo/deploy.ts` is complete, click on **Deploy Contract** to send the transaction (and the compiled smart contract) to Celo.

---

# 🏁 Conclusion

Now that we have deployed a smart contract, let's learn how to interact with it. In the following tutorials, we will look at how to use both view and change functions.

'''
'''--- markdown/celo/FINAL.md ---
🥳 **Congratulations**, you have completed the Celo Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to Celo with the developer-friendly ContractKit
- 🏦 Creating an account with web3.js & checking the balance
- 💸 Transferring tokens between accounts and swapping for different tokens
- ⛓ Deploying and interacting with a smart contract on Celo

# 🧐 Keep learning with these resources:

- 💻 [Run a Celo full node in a virtual machine](https://learn.figment.io/tutorials/how-to-run-a-celo-full-node-in-a-virtual-machine)
- 🔬 [Testing smart contracts with Truffle](https://learn.figment.io/tutorials/celo-testing-truffle)
- 🏗 [Build a crowdfunding project on Celo](https://learn.figment.io/tutorials/celo-crowd-funding-project)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/celo/GET_BALANCE.md ---
Now that we have our account created, wouldn’t it be nice to keep track of our cUSD and CELO balances? In this step, we will examine how we can do just that!

{% hint style="info" %}
The Celo blockchain has three native assets, **CELO** (CELO), the **Celo Dollar** (cUSD) and the **Celo Euro** (cEUR). These assets implement the `ERC20` token standard from Ethereum. The CELO asset is managed by the CELO smart contract and Celo Dollar or Celo Euro are managed by the cUSD or cEUR contracts.
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/celo/balance.ts`, implement the **balance** function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    const goldtoken = undefined;
    const celoBalance = undefined;

    const stabletokenUSD = undefined;
    const cUSDBalance = undefined;

    const stabletokenEUR = undefined;
    const cEURBalance = undefined;

    res.status(200).json({
      attoCELO: celoBalance.toString(),
      attoUSD: cUSDBalance.toString(),
      attoEUR: cEURBalance.toString(),
    });
  }
//...
```

**Need some help?** Check out these links 👇

- [**We can access the CELO contract via the SDK with kit.contracts.getGoldToken()**](https://docs.celo.org/developer-guide/contractkit/contracts-wrappers-registry#interacting-with-celo-and-cusd)
- [**We can access the cUSD contract with kit.contracts.getStableToken()**](https://docs.celo.org/developer-guide/contractkit/contracts-wrappers-registry#interacting-with-celo-and-cusd)
- [**Reading from Alfajores**](https://docs.celo.org/developer-guide/start/hellocelo#reading-alfajores)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    const goldtoken = await kit.contracts.getGoldToken();
    const celoBalance = await goldtoken.balanceOf(address);

    const stabletokenUSD = await kit.contracts.getStableToken("cUSD");
    const cUSDBalance = await stabletokenUSD.balanceOf(address);

    const stabletokenEUR = await kit.contracts.getStableToken("cEUR");
    const cEURBalance = await stabletokenEUR.balanceOf(address);
    
    res.status(200).json({
      attoCELO: celoBalance.toString(),
      attoUSD: cUSDBalance.toString(),
      attoEUR: cEURBalance.toString(),
    })
  }
//...
```

**What happened in the code above?**

- First, we create a new `kit` instance.
- Next, we call the `getGoldToken` method of the `contracts` module to access CELO contract, then providing the input address to the `balanceOf` method, returning the balance of **CELO** token.
- Next, we call the `getStableToken` method of the `contracts` module to access the cUSD and cEUR contracts, then provide the input address to the `balanceOf` method, returning the balance of **cUSD** and **cEUR** tokens.

{% hint style="tip" %}
The amount returned by these calls is denominated in **aCELO** and **acUSD**, which stands for "attoCELO" and "attocUSD" - representing [eighteen decimal places](https://en.wikipedia.org/wiki/Atto-). So to convert it to **CELO** and **cUSD** you'll need to divide it by 10\*\*18 💪
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/celo/balance.ts` is complete, Next.js will rebuild the API route. Click on **Check Balance** and you should see the balances displayed on the page.

---

# 🏁 Conclusion

Querying the balance information is fun, but being able to submit transactions and change the state of a blockchain is even better! In the next step, we will dive deeper and submit our first transactions on Celo.

'''
'''--- markdown/celo/GET_CONTRACT_VALUE.md ---
Our Contract is on-chain, and we're going to learn how to fetch the data stored on the contract.

{% hint style="working" %}
If you want to learn more about Celo smart contracts, follow the [**Deploy and Interact with Contracts (Remotely)**](https://learn.figment.io/tutorials/hello-contracts) tutorial.
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/celo/getter.ts`, implement the default function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
  try {
    const {contract, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    // Create a new contract instance with the HelloWorld contract info
    const instance = undefined;
    // Call the getName function of the on-chain contract
    const name = undefined;

    res.status(200).json(name);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Interacting with Custom contracts**](https://docs.celo.org/developer-guide/contractkit/usage#interacting-with-custom-contracts)
- [**Web3.js eth contract interface**](https://web3js.readthedocs.io/en/v1.4.0/web3-eth-contract.html)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const {contract, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    const instance = new kit.web3.eth.Contract(
        HelloWorld.abi,
        contract
    );
    const name = await instance.methods.getName().call();

    res.status(200).json(name);
  }
//...
```

**What happened in the code above?**

- First, we create a new instance with the HelloWorld contract info, including the ABI and the `contract` passed in via the request body.
- Then we call the `getName` function of our smart contract, chaining the `call` method, because this requires communication with the blockchain.

---

# ✅ Make sure it works

Once the in `pages/api/celo/getter.ts` is complete, click the button to get the curent value stored in the smart contract. It will be displayed on the page.

---

# 🏁 Conclusion

Now, time for the last challenge! Time to modify the state of the contract and thus the state of the blockchain. Let's go!

'''
'''--- markdown/celo/PROJECT_SETUP.md ---
# 🧩 DataHub API keys

If you wish to make use of the Pathway content using DataHub, you will need a DataHub account and a valid API key to access Celo via DataHub's infrastructure. [Sign up for a DataHub account](https://datahub-beta.figment.io/signup) and verify your email address. Once you have logged in to DataHub, you will need to create a new app and select the Celo protocol.

Click "Create New App":

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_1.png?raw=true)

Type in a name for your app, select the **Staging** environment, then click on the **Celo** icon in the list of available protocols. \
Click "Create app" when you're finished:

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_2.png?raw=true)

You can now find your API key on the Overview tab of the app on the [**DataHub Dashboard**](https://datahub-beta.figment.io/apps):

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_3.png?raw=true)

To use your API key, you should copy the contents of the `.env.example` file located in the project root directory (`/learn-web3-dapp/.env.example`) into a new file named `.env.local` (`/learn-web3-dapp/.env.local`). Also, since this file will contain your API key, we have already added it to the `.gitignore`.

{% hint style="info" %}
Easily duplicate the file with the terminal command `cp .env.example .env.local`!
{% endhint %}

You can then paste your unique API key into `.env.local`, as the value for the environment variable `DATAHUB_CELO_API_KEY`. This will authenticate you and enable you to make requests to Celo via DataHub. **The API key shown below is only an example and cannot be used to access DataHub**.

```yaml
# DataHub API keys
DATAHUB_AVALANCHE_API_KEY=
DATAHUB_CELO_API_KEY=3498ae25f9b1342878cc5baa03bc7243
DATAHUB_NEAR_API_KEY=
DATAHUB_POLKADOT_API_KEY=
DATAHUB_POLYGON_API_KEY=
DATAHUB_SECRET_API_KEY=
DATAHUB_SOLANA_API_KEY=
DATAHUB_TEZOS_API_KEY=
```

# 👣 Next Steps

Once you have your Celo API key saved in `/learn-web3-dapp/.env.local`, you're ready to begin.
Click on the **Next: Connect to Celo** button below.

'''
'''--- markdown/celo/SET_CONTRACT_VALUE.md ---
Our contract is on-chain, and we're going to learn how to modify the value stored in the state of the contract.

{% hint style="working" %}
If you want to learn more about Celo smart contracts, follow the [**Deploy and Interact with Contracts (Remotely)**](https://learn.figment.io/tutorials/hello-contracts) tutorial.
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/celo/setter.ts`, implement the default function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
  try {
    const {secret, newMessage, contract, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);
    kit.addAccount(secret);

    // Create a new contract instance with the HelloWorld contract info
    const instance = undefined;
    // Call the setName function of our contract
    const txObject = undefined;
    // Send a transaction Object to modify the state of our contract
    let tx = undefined;

    let receipt = await tx.waitReceipt();

    res.status(200).json(receipt.transactionHash);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Interacting with Custom contracts**](https://docs.celo.org/developer-guide/contractkit/usage#interacting-with-custom-contracts)
- [**Web3.js eth contract interface**](https://web3js.readthedocs.io/en/v1.4.0/web3-eth-contract.html)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const {secret, newMessage, contract, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);
    kit.addAccount(secret);

    // Create a new contract instance with the HelloWorld contract info
    const instance = new kit.web3.eth.Contract(
        HelloWorld.abi,
        contract
    );

    const txObject = await instance.methods.setName(newMessage);
    let tx = await kit.sendTransactionObject(txObject, { from: address });

    let receipt = await tx.waitReceipt();

    res.status(200).json(receipt.transactionHash);
  }
//...
```

**What happened in the code above?**

- First, we create a new instance with the HelloWorld contract info.
- Next, we call the `setName` function of our smart contract
- Finally, we create a transaction to execute this function with `sendTransactionObject`, passing in:
  - The transaction object (`txObject`) containing the properly formatted call to the contract method.
  - An object with the `from` property, the address which will pay the fees for the transaction.
- Boom! Wait for confirmation with `waitReceipt` and return the transaction hash to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/celo/setter.ts` is complete, enter a value into the textinput and click the button to set the value stored in the smart contract.

---

# Conclusion

You've learned how to deploy and interact with Solidity smart contracts deployed on the Celo blockchain.

'''
'''--- markdown/celo/SWAP_TOKEN.md ---
It’s time to submit another transaction. In this challenge, we will connect to a Celo node hosted by DataHub and we will swap 1 **cUSD** stable token against the expected amount of **CELO** token. As you remember from a previous tutorial, we funded our account on the `Alfajores` testnet with 5 **CELO** and 10 **cUSD**. Now let’s try to swap 1 **cUSD** token to **CELO**.
Celo has a number of core smart contracts that are deployed to the network. In this challenge, we'll use the StableToken and Exchange contract wrappers, which have all the expected functions enabling us to swap tokens.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/celo/swap.ts`, implement the **swap** function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
// Get contract wrappers
// - StableTokenWrapper
// - ExchangeWrapper
const stableToken = undefined;
const exchange = undefined;

// Approve a user to transfer StableToken on behalf of another user.
const approveTx = undefined;

// Exchange cUSD for CELO
const goldAmount = undefined;
const sellTx = undefined;
//...
```

**Need some help?** Check out these links 👇

- [**We can access the cUSD contract with kit.contracts.getStableToken()**](https://docs.celo.org/developer-guide/contractkit/contracts-wrappers-registry#interacting-with-celo-and-cusd)
- [**Code example**](https://docs.celo.org/developer-guide/contractkit/usage#buying-all-the-celo-i-can-with-the-cusd-in-my-account)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
// Get contract wrappers
// - StableTokenWrapper
// - ExchangeWrapper
const stableToken = await kit.contracts.getStableToken();
const exchange = await kit.contracts.getExchange();

await stableToken
  .approve(exchange.address, OneCUSD)
  .send({from: address, feeCurrency: stableToken.address})
  .then((receipt) => receipt.waitReceipt());
// Exchange cUSD for CELO
const goldAmount = await exchange.quoteStableSell(OneCUSD);
const sellReceipt = await exchange
  .sellStable(OneCUSD, goldAmount)
  .send({from: address, feeCurrency: stableToken.address});
await sellReceipt.waitReceipt();
const hash = await sellReceipt.getHash();
//...
```

**What happened in the code above?**

- First, we store into the `stableToken` variable the `StableTokenWrapper` contract interface by calling `getStableToken`.
- Next, we store into the `exchange` variable the `ExchangeWrapper` contract interface by calling `getExchange`.
- Next, we approve the transfer of **cUSD** from our address using the `approve` method of `stableToken` from our `StableTokenWrapper` contract interface.
- Next, we return the calculated the amount of **CELO** token to exchange from the amount of **cUSD** expected to be exchanged as `goldAmount`.
- Finally, we can sell the amount of stable token, in this example 1 **cUSD** against **CELO** token.
- We can get a receipt with the convenient `waitReceipt` method on the transaction. Note that because both of these functions return a Promise, `sellReceipt` will not return before `sellTx` as long as they are both prefaced with `await`. Asynchronous code is awesome!

---

# ✅ Make sure it works

Once the in `pages/api/celo/swap.ts` is complete, click on **Swap 1 cUSD**. When the transaction is complete, you will see how many CELO you got for swapping the stabletoken.

{% hint style="info" %}
Fun fact, if you take the inverse of the returned value you'll find the price quotation displayed on [Coinmarketcap](https://coinmarketcap.com/currencies/celo/)
{% endhint %}

---

# Conclusion

We now know how to query the Celo network and how to submit transactions. So far, we've only used core Celo smart contracts. Now it’s time to learn how to deploy our own smart contract and interact with it!

'''
'''--- markdown/celo/TRANSFER_TOKEN.md ---
It’s time to submit your first transactions. In this challenge, we will connect to a Celo node hosted by DataHub and we will transfer our testnet token. As you remember from previous step, we funded our account on the `Alfajores` testnet with 5 **CELO** and 10 **cUSD**. Now let’s try to transfer some **CELO** tokens to another testnet account.
Celo has a number of core smart contracts that are deployed to the network. In this challenge, we'll use the GoldToken contract wrappers, which have a `transfer` and a `send` function allowing us to build a transfer transaction.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/celo/transfer.ts`, implement the **transfer** function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//..
  try {
    const {secret, amount, recipient, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    // Restore account using your secret
    undefined
    // Access CELO contract wrapper
    const celoToken = undefined;
    // Build the transaction and send
    const celotx = undefined;
    // Wait for confirmation of the transaction
    const celoReceipt = await celotx.waitReceipt();

    res.status(200).json(celoReceipt.transactionHash);
  }
//..
```

**Need some help?** Check out these links 👇

- [**We can access the CELO contract via the SDK with kit.contracts.getGoldToken()**](https://docs.celo.org/developer-guide/contractkit/contracts-wrappers-registry#interacting-with-celo-and-cusd)
- [**Restore an account from private key with `addAccount`**](https://docs.celo.org/developer-guide/sdk-code-reference/summary-17/modules/_rpc_wallet_.rpcwallet#methods)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const {secret, amount, recipient, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    kit.addAccount(secret);
    const celoToken = await kit.contracts.getGoldToken();
    const celotx = await celoToken
      .transfer(recipient, amount)
      .send({from: address});

    const celoReceipt = await celotx.waitReceipt();

    res.status(200).json(celoReceipt.transactionHash);
  }
//..
```

**What happened in the code above?**

- First, we initialize the account using `addAccount` with our private key.
- Next, we store into the `celoToken` variable the `GoldTokenWrapper` contract interface by calling `getGoldToken`.
- Finally, we can interact with the **CELO** token using this interface, chaining the `transfer` and `send` methods with the expected parameters:
  - `recipient` and `amount` for the `transfer`
  - An object containing the key `from` with a value of `address` for the `send`.
- Finally, we will wait for confirmation of the transaction on the blockchain, which is neatly packaged into `waitReceipt`: The resulting `transactionHash` is what we will return to the client side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/celo/transfer.ts` is complete, Next.js will rebuild the API route. Fill in the amount of **CELO** you want to send, then click on **Submit Transfer**.

---

# 🏁 Conclusion

Now that we have funded our account and made a transfer, let's move on to perform a more advanced kind of transfer: a **Swap**.
With ContractKit, you can always exchange your **cUSD** or **cEUR** to **CELO** and the other way around. Let’s learn how we can do that in the next tutorial!

'''
'''--- markdown/ceramic/BASIC_PROFILE.md ---
# How to use IDX?

Now that we have our DID and we know how to authenticate using 3ID Connect, we can look into how to associate data to our DID.
But first let’s talk about what is happening under the hood of IDX.

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/ceramic/idx.png)

Every DID has an index which is a map of `DefinitionID` and `RecordID`.
Record defined by RecordID is the data that you want to store.
But how IDX knows about the format of the data?
That’s where Schema comes in. Schema is a JSON schema that describes the format of the data. This schema then is provided to a `Definition` which holds reference to schema's SteamID as well as name and description of that definition.
So if you want to submit a Record for a particular definition you need to send data that conforms to that schema.
If you want to store something to IDX that is associated to your DID you need to know DefinitionID which tells IDX what data will come in and you need to provide Record with an actual data.
If the data that you are trying to submit does not conform to schema, your request will fail.
Since DefinitionID is just a StreamID which is not very friendly to human eye, IDX has a concept of `aliases` which are just human readable names for Definitions identified by DefinitionIDs.
One of the default definitions provided by IDX is called `BasicProfile`. It is definition used to hold basic profile information like name, description, avatar etc.
Below is the schema describing BasicProfile definition. All schemas must comply with JSON schema draft 07.

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "BasicProfile",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "maxLength": 150
    },
    "image": {
      "$ref": "#/definitions/imageSources"
    },
    "description": {
      "type": "string",
      "maxLength": 420
    },
    "emoji": {
      "type": "string",
      "maxLength": 2
    },
    "background": {
      "$ref": "#/definitions/imageSources"
    },
    "birthDate": {
      "type": "string",
      "format": "date",
      "maxLength": 10
    },
    "url": {
      "type": "string",
      "maxLength": 240
    },
    "gender": {
      "type": "string",
      "maxLength": 42
    },
    "homeLocation": {
      "type": "string",
      "maxLength": 140
    },
    "residenceCountry": {
      "type": "string",
      "pattern": "^[A-Z]{2}$",
      "maxLength": 2
    },
    "nationalities": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "string",
        "pattern": "^[A-Z]{2}$",
        "maxItems": 5
      }
    },
    "affiliations": {
      "type": "array",
      "items": {
        "type": "string",
        "maxLength": 140
      }
    }
  },
  "definitions": {
    "IPFSUrl": {
      "type": "string",
      "pattern": "^ipfs://.+",
      "maxLength": 150
    },
    "positiveInteger": {
      "type": "integer",
      "minimum": 1
    },
    "imageMetadata": {
      "type": "object",
      "properties": {
        "src": {
          "$ref": "#/definitions/IPFSUrl"
        },
        "mimeType": {
          "type": "string",
          "maxLength": 50
        },
        "width": {
          "$ref": "#/definitions/positiveInteger"
        },
        "height": {
          "$ref": "#/definitions/positiveInteger"
        },
        "size": {
          "$ref": "#/definitions/positiveInteger"
        }
      },
      "required": ["src", "mimeType", "width", "height"]
    },
    "imageSources": {
      "type": "object",
      "properties": {
        "original": {
          "$ref": "#/definitions/imageMetadata"
        },
        "alternatives": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/imageMetadata"
          }
        }
      },
      "required": ["original"]
    }
  }
}
```

# 🏋️ Challenge #1

In this tutorial, we will learn how to write data to the BasicProfile and then read it.

{% hint style="tip" %}
In `components/protocols/ceramic/components/steps/BasicProfile.tsx`, implement the `saveBasicProfile` function.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
const saveBasicProfile = async (values: BasicProfile) => {
  setSaving(true);
  setBasicProfile(null);

  const {name} = values;

  try {
    // Set BasicProfile (use IdxSchema.BasicProfile)
    setCurrentUserData(undefined);
    setName(name);
  } catch (error) {
    alert(error.message);
  } finally {
    setSaving(false);
  }
};
```

**Need some help?** Check out these links 👇

- [Create records using IDX](https://developers.idx.xyz/build/writing/)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution for Challenge #1

```typescript
// solution
const saveBasicProfile = async (values: BasicProfile) => {
  setSaving(true);
  setBasicProfile(null);

  const {name} = values;

  try {
    // Set BasicProfile (use IdxSchema.BasicProfile)
    setCurrentUserData(IdxSchema.BasicProfile, {name});
    setName(name);
  } catch (error) {
    alert(error.message);
  } finally {
    setSaving(false);
  }
};
```

**What happened in the code above?**

- Destructure the `name` property from the BasicProfile values passed to the `saveBasicProfile` function.
- Use the `setCurrentUserData` React hook to set the BasicProfile and associate it with the `name` object.
- Use the `setName` React hook to set the BasicProfile's `name` so it can be displayed in the UI.

# 🏋️ Challenge #2

Now that we have our data stored with IDX, it's time to read it in order to validate if what we stored in Challenge #1 worked.

{% hint style="tip" %}
In `components/protocols/ceramic/components/steps/BasicProfile.tsx`, implement the `readBasicProfile` function.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
const readBasicProfile = async () => {
  try {
    setFetching(true);
    // Read BasicProfile (use IdxSchema.BasicProfile enum)
    const resp = undefined;
    setCurrentUserData(IdxSchema.BasicProfile, resp as BasicProfile);
    setBasicProfile(resp);
  } catch (error) {
    alert(error.message);
  } finally {
    setFetching(false);
  }
};
```

**Need some help?** Check out these links 👇

- [Read records using IDX](https://developers.idx.xyz/build/reading/)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution for Challenge #2

```typescript
// solution
const readBasicProfile = async () => {
  try {
    setFetching(true);

    // Read BasicProfile (use IdxSchema.BasicProfile enum)
    const resp = await idx.get<BasicProfile>(IdxSchema.BasicProfile);
    setCurrentUserData(IdxSchema.BasicProfile, resp as BasicProfile);
    setBasicProfile(resp);
  } catch (error) {
    alert(error.message);
  } finally {
    setFetching(false);
  }
};
```

**What happened in the code above?**

- Here we use idx instance to call `get` method on it providing just `basicProfile` as an argument. Since we are authenticated ceramic client is aware of our DID so we do not have to pass it in. However, we can ready basicProfile data about any DID since this data is public. In order to read basicProfile for DID that is not ours we have to explicitly pass that DID as a second parameter.

'''
'''--- markdown/ceramic/CHAIN_CONNECTION.md ---
# 🦊 Make sure you have Metamask

Metamask is a crypto wallet which is available as a browser extension. In order to go through this tutorial you will need to have Metamask installed. You can find out how to do this on [MetaMask - A crypto wallet & gateway to blockchain apps](https://metamask.io/). We will be using Ethereum as a provider for Metamask.

# 🔗 Connect is the new Login

If you’ve played around with Web 3 dApps you're probably familiar with those “Connect” buttons which allow you to connect your wallet like MetaMask to dApp that you currently are view. They're always at the top right of a web page, in the same place where Web 2.0 websites usually put Login/Signup buttons. We're going to get started by allowing users to connect their Ethereum account to the webpage, through Metamask.

Imagine this scenario: You're a fresh Web3 developer who just landed a sweet role at a promising new startup, eager to show off your skills. You've been asked to show users of our dApp which network they are connected to (to avoid any confusion) and store the address of the account currently selected in Metamask (so that we can reference it later).

# 🧑🏼‍💻 Challenge

In `components/protocols/ceramic/context/idx.tsx`, implement the `checkConnection` function.

```typescript
// components/protocols/ceramic/context/idx.tsx

const connect = async (): Promise<string> => {
  const provider = await detectEthereumProvider();
  if (provider) {
    // Connect to Polygon using Web3Provider and Metamask.
    // Find more information at: https://docs.metamask.io/guide/rpc-api.html.
    // NOTE: Be careful not to use a deprecated method!
    // Define address and network
    const addresses = undefined;
    const address = undefined;
    if (setIsConnected) {
      setIsConnected(true);
    }
    if (setCurrentUserAddress) {
      setCurrentUserAddress(address);
    }
    if (identityStore) {
      await identityStore.setAddress(address);
    }
    return address;
  } else {
    throw new Error('Please install Metamask at https://metamask.io');
  }
};
```

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 👉 Solution

```typescript
// solution
// components/protocols/ceramic/context/idx.tsx
const connect = async (): Promise<string> => {
  const provider = await detectEthereumProvider();
  if (provider) {
    // Connect to Polygon using Web3Provider and Metamask.
    // Find more information at: https://docs.metamask.io/guide/rpc-api.html.
    // NOTE: Be careful not to use deprecated method!
    // Define address and network
    const addresses = await provider.request({method: 'eth_requestAccounts'});
    const address = addresses[0];
    if (setIsConnected) {
      setIsConnected(true);
    }
    if (setCurrentUserAddress) {
      setCurrentUserAddress(address);
    }
    if (identityStore) {
      await identityStore.setAddress(address);
    }
    return address;
  } else {
    throw new Error('Please install Metamask at https://metamask.io');
  }
};
//...
```

# 🤔 What happened in the code above?

- By using `window.ethereum.enable()`, Metamask is opened and you can connect your Ethereum account with a dApp. This way dApp can use your account to perform transactions and query the network.

---

# 👣 Next Steps

Now that we performed basic "authentication" of your wallet, we can move on and implement decentralized authentication with Ceramic/IDX.

'''
'''--- markdown/ceramic/CUSTOM_DEFINITION.md ---
# 📋 Creating definitions

Now we know how to store and retrieve data from BasicProfile, which is a definition already provided by IDX. But what if we want to store data that is specific to our application for each user identified by DID? For this reason, let’s assume that we are building an application that stores the favourite quote of a user. How can we do it?

## 💻 IDX CLI

When you create a custom definition, you have to use IDX CLI. To install it run:

```text
npm install --global @ceramicstudio/idx-cli
```

We also recommend installing Ceramic CLI.

```text
npm install --global @ceramicnetwork/cli
```

Read more about IDX CLI [here](https://developers.idx.xyz/guides/cli/).

Once the IDX and Ceramic CLI are installed, you can configure the IDX CLI to use a specific testnet node. The Ceramic testnet is called Clay. Use the command:

```
idx config:set ceramic-url https://ceramic-clay.3boxlabs.com
```

Once this is done, you can create your new DID:

```text
idx did:create --label=figment
```

Here you have an option to provide a label to make later requests easier. Instead of remembering your DID and typing it every time, you will be able to use that label for subsequent requests.

You can check your newly created DID by running:

```text
idx did:list
```

**Why can't we use DID from previous steps?**

Don't know yet.

Ok, now we are ready to create our custom definition! For this purpose, we will use the schema outlined below, which describes a simple structure of a favourite quote with 2 string fields: `text` and `author`.

```json
{
  "$schema": "http://json-schema.org/draft-07/schema",
  "title": "FigmentLearn",
  "description": "Web3 learning with Figment Learn",
  "type": "object",
  "properties": {
    "text": {
      "type": "string",
      "maxLength": 300
    },
    "author": {
      "type": "string",
      "maxLength": 150
    }
  }
}
```

We need to publish our schema to Ceramic first. In order to do that we use:

```text
idx schema:publish figment '{ "$schema": "http://json-schema.org/draft-07/schema", "title": "FigmentLearn", "description": "Web3 learning with Figment Learn", "type": "object", "properties": { "text": { "type": "string", "maxLength": 300 }, "author": { "type": "string", "maxLength": 150 } } }'
```

This should return the URI which looks similar to `ceramic://k3y52l7qbv1fryo5num99f2umi34cae2yn13wyo4hs3o0d4jai1hq1owg1ep04w74`. We can take that URI and use it to create our custom definition:

```text
idx definition:create figment --schema='ceramic://k3y52l7qbv1fryo5num99f2umi34cae2yn13wyo4hs3o0d4jai1hq1owg1ep04w74' --name='Favourite quote' --description='What is your favourite quite?'
```

In the above step, besides schema URI we also provide name and description of our custom definition. This will return StreamID for our definition that looks something similar to: `kjzl6cwe1jw146qq6gh9j04b43jycgypjs8v5gqhtnurtym0q1nma0vr3vd6px3`

Now we can create an alias for that definition’s StreamID the same way we used the BasicProfile alias in step #3.

Go to `components/protocols/ceramic/lib.index.ts` and paste above StreamID to `figment` alias. It should look like:

```js
export const aliases = {
  figment: 'kjzl6cwe1jw146qq6gh9j04b43jycgypjs8v5gqhtnurtym0q1nma0vr3vd6px3',
};
```

Once you have your alias set up, you need to load it to IDX. You can do that by clicking the **Set alias** button on the top right corner of the **Challenge #1** card.

Now we are all set to write and read data from our custom definition.

# 🏋️ Challenge #1

Write quote to Ceramic.

{% hint style="tip" %}
In `components/protocols/ceramic/components/steps/CustomDefinition.tsx`, implement the `saveQuote` function.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
const saveQuote = async (values: QuoteSchemaT) => {
  setSaving(true);
  const {text, author} = values;

  setAlias();

  try {
    // Save quote information to custom schema (use IdxSchema.Figment enum)

    setMyQuote({
      text,
      author,
    });
  } catch (error) {
    alert(error.message);
  } finally {
    setSaving(false);
  }
};
```

**Need some help?** Check out these links 👇

- [Create records using IDX](https://developers.idx.xyz/build/writing/)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution to Challenge #1

```typescript
// solution
const saveQuote = async (values: QuoteSchemaT) => {
  setSaving(true);
  const {text, author} = values;

  setAlias();

  try {
    // Save quote information to custom schema (use IdxSchema.Figment enum)
    await idx.set(IdxSchema.Figment, {text, author});

    setMyQuote({
      text,
      author,
    });
  } catch (error) {
    alert(error.message);
  } finally {
    setSaving(false);
  }
};
```

**What happened in the code above?**

- Here we use the familiar `set` method, but instead of passing `basicProfile` as the first parameter we pass the alias to our custom definition `figment` and as a second parameter we pass the data defined in our custom JSON schema (`text` and `author`).

# 🏋️ Challenge #2

Now we can test if the data about our favourite quote indeed got stored to Ceramic.

{% hint style="tip" %}
In `components/protocols/ceramic/components/steps/BasicProfile.tsx`, implement the `readQuote` function.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
const readQuote = async () => {
  try {
    setFetching(true);

    // Read quote (use IdxSchema.Figment enum)
    const resp = undefined;

    setCustomDefinitionData(resp);
  } catch (error) {
    alert(error.message);
  } finally {
    setFetching(false);
  }
};
```

**Need some help?** Check out these links 👇

- [Read records using IDX](https://developers.idx.xyz/build/reading/)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution for Challenge #2

```typescript
// solution
const readQuote = async () => {
  try {
    setFetching(true);

    // Read quote (use IdxSchema.Figment enum)
    const resp = await idx.get<QuoteSchemaT>(IdxSchema.Figment);

    setCustomDefinitionData(resp);
  } catch (error) {
    alert(error.message);
  } finally {
    setFetching(false);
  }
};
```

**What happened in the code above?**

- Here we use the familiar `get` method, providing our custom alias to retrieve data about our favourite quote.

'''
'''--- markdown/ceramic/FINAL.md ---
🥳 **Congratulations**, you have completed the Ceramic Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to the Ceramic network with Metamask
- 🪵 Logging in to your Ceramic profile with IDX
- 🧑‍🚀 Updating and reading your basic profile
- ⛓ How to deploy and use custom schemas and definitions

# 🧐 Keep learning with these resources:

- TBD
- TBD
- TBD

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/ceramic/LOGIN.md ---
In this tutorial we're going to replace the Connect with Metamask we just implemented with a Connect with IDX. But before we can dive in we need to understand few key terms when it comes to Ceramic and decentralized authentication....

# 🌊 Streams

`Stream` is a basic building block of Ceramic. It is a DAG-based data structure for storing continuous, mutable streams of content on IPFS.
Every stream is identified by an immutable StreamID. When a stream reaches the node, a special function is fired to process it.
This function is called `StreamType`. StreamTypes are responsible for processing data and storing them as commits (which are individual IPFS records).
Every stream needs to specify its StreamType so that Ceramic nodes know how to process them. What is important in terms of authentication is the fact that every `StreamType` implementation is able to specify its own authentication mechanism. For that purpose, most StreamTypes are using DIDs.

# 🆔 You DID what?

DIDs is the W3C standard for decentralized identifiers, which describes the standard URI scheme for creating persistent decentralized identifiers (DID). It also specifies how the metadata for a given DID is resolved. As with every standard there can be several implementations, these are called **DID methods**.
Every **DID method** has a method specific URIs that looks like:

```text
did:<method-name>:<method-specific-identifier>
```

There are over 40 different DID methods on the official DID registry. Ceramic currently supports the `3ID` and `Key` DID methods.
We will be using the `3ID` DID method for this tutorial, as it is a powerful DID method that supports multiple keys, key rotations, and revocations.
The `Key` DID Method on the other hand, is tied only to a single crypto key which is not very convenient.

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/ceramic/DID_standarad.png)

One of the other things that DID methods also describes is a location of where the metadata is stored. This metadata is stored in something that is called `DID document`.
`DID resolver` is a package which is responsible for returning DID document given the URI shown above.
One other missing piece is `DID provider` which is a package that exposes json-rpc interface which allows for the creation and usage of DID.
As an dApp creator you have a choice of using `3id-did-provider` package which is a low-level library. This method is not recommended as it leaves keys management to the application.
On the other had you could use `3ID Connect` which is a DID wallet that makes it easy to creat and use DID without worrying about keys management.
Below picture shows how applications can interact with DID resolvers and DID providers.

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/ceramic/DID_usage.png)

That was a lot of important theory to cover! Now let's write some code.

# 📦 A few new packages

In order to be able to use IDX and 3ID Connect wallet you need to have the following packages installed:

- `@ceramicnetwork/http-client` - An http client for the ceramic network
- `@ceramicstudio/idx` - Javascript implementation of IDX protocol
- `dids` - Library for interacting with DIDs
- `@3id/connect` - 3ID account management service run in iframe.
- `@ceramicnetwork/3id-did-resolver` - DID method that uses the Ceramic network to resolve DID documents

Don't worry, we have you covered! These packages are already installed for you in the `learn-web3-dapp` project.

# 📚 From simple connect to decentralized log in

As you probably know authentication allows you to perform extra actions that are not allowed for regular users. In Ceramic when you are authenticated, you can perform such actions as updating data associated to your identity as well as creating genesis commits, signed commits, or decrypting data.

Connecting your Metamask wallet to dApp allows for easy interaction with smart contracts on a given blockchain ie. Ethereum. You can make transactions, query the network, all from the context of the account connected with Metamask. What if you could associate data like name, avatar, social accounts and also application-specific data to your account? In this challenge we will use Ceramic/IDX to log user in using 3ID Connect wallet.

For keeping information about the authenticated user, we use the React Context API and wrap our application with the exposed provider. This allows us to keep the state of the authenticated user in one place. You can see how it is implemented in `components/protocols/ceramic/context/idx.tsx`. You already touched this file in the last step to implement the connect functionality.

# 🏋️ Challenge

{% hint style="tip" %}
In `components/protocols/ceramic/context/idx.tsx`, implement the `login` function.
{% endhint %}

```typescript
// components/protocols/ceramic/context/idx.tsx

const logIn = useCallback(async (): Promise<string> => {
  const address = await connect();

  // Request authentication using 3IDConnect.
  // Find more information here: https://developers.ceramic.network/authentication/3id-did/3id-connect/#4-request-authentication

  // Create provider instance.
  // Find more information here: https://developers.ceramic.network/authentication/3id-did/3id-connect/#5-create-provider-instance

  // Create a DID instance.
  // Find more information here: https://developers.ceramic.network/build/javascript/http/
  // NOTE: We want to use only ThreeIdResolver here

  // Set DID instance on HTTP client
  // Find more information here: https://developers.ceramic.network/build/javascript/http/#7-set-did-instance-on-http-client

  // Set the provider to Ceramic
  // Find more information here: https://developers.ceramic.network/authentication/3id-did/3id-connect/#6-set-the-provider-to-ceramic

  // Authenticate the 3ID
  // Find more information here: https://developers.ceramic.network/authentication/3id-did/3id-connect/#7-authenticate-the-3id
  const userDID = undefined;

  // Create IDX instance

  // Get current user's basic profile
  const basicProfile = await getBasicProfile(userDID);

  if (setIsAuthenticated) {
    setIsAuthenticated(true);
  }

  if (setCurrentUserDID) {
    setCurrentUserDID(userDID);
  }
  if (identityStore) {
    await identityStore.setDID(userDID);
  }
  if (basicProfile && setUserData) {
    await setUserData(IdxSchema.BasicProfile, basicProfile);
  }

  return userDID;
}, [setIsAuthenticated]);
```

**Need some help?** Check out these links

- [Learn how to use 3ID Connect DID wallet](https://developers.ceramic.network/authentication/3id-did/3id-connect/)
- [Setup HTTP Ceramic Client](https://developers.ceramic.network/build/javascript/http/)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 👉 Solution

```typescript
// solution
// components/protocols/ceramic/context/idx.tsx
const logIn = useCallback(async (): Promise<string> => {
  const address = await connect();

  // Request authentication using 3IDConnect.
  // Find more information here: https://developers.ceramic.network/authentication/3id-did/3id-connect/#4-request-authentication
  const threeIdConnect = new ThreeIdConnect();
  const authProvider = new EthereumAuthProvider(window.ethereum, address);
  await threeIdConnect.connect(authProvider);
  // Create provider instance.
  // Find more information here: https://developers.ceramic.network/authentication/3id-did/3id-connect/#5-create-provider-instance
  const provider = await threeIdConnect.getDidProvider();
  // Create a DID instance.
  // Find more information here: https://developers.ceramic.network/build/javascript/http/
  // NOTE: We want to use only ThreeIdResolver here
  const didInstance = new DID({
    resolver: {
      ...ThreeIdResolver.getResolver(ceramicRef.current),
    },
  });
  // Set DID instance on HTTP client
  // Find more information here: https://developers.ceramic.network/build/javascript/http/#7-set-did-instance-on-http-client
  ceramicRef.current.did = didInstance;
  // Set the provider to Ceramic
  // Find more information here: https://developers.ceramic.network/authentication/3id-did/3id-connect/#6-set-the-provider-to-ceramic
  ceramicRef.current.did.setProvider(provider);
  // Authenticate the 3ID
  // Find more information here: https://developers.ceramic.network/authentication/3id-did/3id-connect/#7-authenticate-the-3id
  const userDID = await ceramicRef.current.did.authenticate();
  // Create IDX instance
  idxRef.current = new IDX({
    ceramic: ceramicRef.current,
    aliases,
  });
  // Get current user's basic profile
  const basicProfile = await getBasicProfile(userDID);
  if (setIsAuthenticated) {
    setIsAuthenticated(true);
  }
  if (setCurrentUserDID) {
    setCurrentUserDID(userDID);
  }
  if (identityStore) {
    await identityStore.setDID(userDID);
  }
  if (basicProfile && setUserData) {
    await setUserData(IdxSchema.BasicProfile, basicProfile);
  }
  return userDID;
}, [setIsAuthenticated]);
```

# 🤔 What happened here?

First, we create an instance of an Ethereum provider and tie it to a specific address that we receive after connecting a wallet to our website.

Then we make `threeIdConnect` to connect to this provider. Once this is done, we create a new instance of DID for which we specify a provider and a resolver. The resolver is responsible for returning a DID document given the DID string. The provider is responsible for providing a JSON-RPC interface that allows us to create and use a DID.

Then we set the DID instance to the Ceramic client.

We then call authenticate, which will start the authentication process. A popup will appear on the top right corner which will prompt you to create or update your existing identity. You will need to sign a transaction using Metamask, then your DID should be associated with your Ethereum account.
Finally, we create an IDX instance with the authenticated Ceramic client instance and any aliases that we want to use.

'''
'''--- markdown/ceramic/PROJECT_SETUP.md ---
# 🏺 What is Ceramic?

Most of the information on today’s internet is stored in **walled garden databases**, not accessible to the outside world. If you don’t have direct access to the database or if there is no API exposed by the application, you might need to go and look around somewhere else. This results in data being duplicated and locked away in many different databases.

What if there was one place where you could get all the relevant content you need? What if content was open sourced the same way code is open-sourced using GitHub? That’s exactly the promise of Ceramic. **Ceramic is a platform for creating, hosting and sharing streams of data in decentralized way.** Open-source content which can be easily shared between applications using just one SDK rather than dozens of different external APIs. But always secured using your private keys.

Read more on the [official Ceramic docs](https://blog.ceramic.network/what-is-ceramic/)

# 🆔 What is IDX?

IDX is a multi-platform **identity protocol** that replaces centralized user tables with a decentralized alternative. It allows to build up a unified digital identity consisting of all their data while enabling developers to break down silos and freely share users' data between applications.

Read more on the [official IDX docs](https://developers.idx.xyz/learn/welcome/). It has some great diagrams and a glossary.

# 🤓 Stream, StreamTypes and DIDs

Two important concepts with Ceramic network are **Streams** and **StreamTypes**. Streams are nothing more than append-only logs of commits stored on IPFS. StreamTypes, on the other hand, are functions applied to those logs.

A critical responsibility of StreamTypes is the authorization of users to perform write operations to a stream. Different StreamTypes might need different levels of authorization. One of the authentication mechanisms that StreamTypes supports is **DIDs**, the W3C standard for decentralized identifiers. DIDs are used to associate globally unique, platform-agnostic string identifiers with a DID document where all the data required for signature verification and encryption is stored.

The DID is essential to IDX. With IDX, there is no more need for juggling API Keys for different external services to access data generated by users on various applications.

'''
'''--- markdown/near/CHAIN_CONNECTION.md ---
The ability to establish a connection is the first step for anyone wanting to discover and travel through web3 space. Fasten your seat belt, it's time to take off 🚀!

Connecting to a node works pretty much the same as for a standard web server. There are two actors: Client & server, with a protocol managing how data is transferred from one to the other.

The main difference here is in the protocol. To connect to NEAR, we'll be using `json-rpc`:

- `json`, stands for **J**ava**S**cript **O**bject **N**otation, which is a [text format for transferring data](https://www.w3schools.com/js/js_json_intro.asp).
- `rpc`, stands for **R**emote **P**rocedure **C**all - a way to [call a server-side function](https://en.wikipedia.org/wiki/Remote_procedure_call) from the client-side.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/near/connect.ts`, implement `connection` by creating a `Connection` instance and getting the API version. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
// Do not forget we're in an "async" world,
// so you may need to "await" some results.
try {
  const config = configFromNetwork(network);
  const near = undefined;
  const provider = undefined
  const status = undefined;
  return res.status(200).json(status.version.version);
}
```

**Need some help?** Check out these links 👇

- [Creating a `Connection` instance](https://near.github.io/near-api-js/modules/connect.html)
- [Provider property of `Connection` Class](https://near.github.io/near-api-js/classes/connection.connection-1.html#provider)
- [Status method of `Provider` class](https://near.github.io/near-api-js/classes/providers_json_rpc_provider.jsonrpcprovider.html#status)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
try {
  const config = configFromNetwork(network);
  const near = await connect(config);
  const provider = near.connection.provider;
  const status = await provider.status();
  return res.status(200).json(status.version.version);
}
```

**What happened in the code above?**

- `configFromNetwork` takes the network identifier such as _mainnet_ or _testnet_ and returns a `config` object containing the correct URLs.
- `connect` takes the `config` object and returns an instance of `Near`, which represents the connection.
- `near.connection.provider` returns a `JsonRpcProvider` object allowing us to make JSON-RPC calls to DataHub.
- The `status` method allows us to retrieve the desired information from the properties of the object that it returns.
- Finally, we can send back the `status.version.version` to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/near/connect.ts` is complete, click the blue button to connect to NEAR & display the current version.

---

# 🏁 Conclusion

Well done! Your fluency in the NEAR dialect of Web 3 is growing. As a newcomer, building an identity is important so you can distinguish yourself from other users on the NEAR network. Ready to take the next step forward?

'''
'''--- markdown/near/CREATE_ACCOUNT.md ---
Unlike many other Web 3 protocols, NEAR uses a human readable account ID instead of a public key hash. You can link as many `keypairs` to a NEAR account as you want. Here, we're going to Learn how to check the availability and to create a NEAR account name. As you might expect, **figment.testnet** is already taken.

---

# 🏋️ Challenge 1 of 2

{% hint style="tip" %}
In `pages/api/near/check-account.ts`, implement the default function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
  try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    // Query the account info of freeAccountId
    const accountInfo = undefined
    try {
        undefined;
        return res.status(200).json(false)
    } catch (error) {
        return res.status(200).json(true)
    }
  }
```

**Need some help?** Check out these links

- [The `Account` class](https://near.github.io/near-api-js/classes/account.account-1.html)
- [An explanation of `NEAR Accounts`](https://docs.near.org/docs/concepts/account)
- [RPC `view_account`](https://docs.near.org/docs/develop/front-end/rpc#view-account)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
  try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    const accountInfo = await near.account(freeAccountId);
    try {
        await accountInfo.state();
        return res.status(200).json(false)
    } catch (error) {
        return res.status(200).json(true)
    }
  }
```

**What happened in the code above?**

- First, we create an `Account` object from the `freeAccountId` being passed in the request body.
- Next, we query the state of this object with the `state` method:
  - If it returns `true`, the account exists and we will return a `false` value to the client-side - indicating that the name is unavailable.
  - If `state` returns `false`, the account doesn't exist - so we pass a `true` value back to the client-side, indicating that the name is available. Phew! Little bit of programming logic there.

---

# 🏋️ Challenge 2 of 2

{% hint style="tip" %}
In `pages/api/near/create-account.ts`, implement the default function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    undefined;
    return res.status(200).json(freeAccountId);
}
```

**Need some help?** Check out this link 👇

- [`createAccount` method](https://near.github.io/near-api-js/classes/near.near-1.html#createaccount)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    await near.createAccount(freeAccountId, publicKey);
    return res.status(200).json(freeAccountId);
}
```

**What happened in the code above?**

- First, we need to [destructure](https://dmitripavlutin.com/javascript-object-destructuring/) the values from the request body so that we can use them in our code. We are also specifying a TypeScript type of `AccountReq` here.
- Then we use `configFromNetwork`, passing the `network` from the request body - now we can create a connection, `near`.
- Next, we call the `createAccount` method passing the `freeAccountId` and the `publicKey` from the request body.
- Finally, we can return the name of the account to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/near/check-account.ts` is complete, Next.js will rebuild the API route. Choose an account ID and enter it into the textinput, then click on **Check it!** to see if it is available.

---

# 🏁 Conclusion

Every new account created on the testnet is given a free **airdrop** of 200 NEAR tokens. So cool!
Ready to move on? Let's check the account balance in the next step.

'''
'''--- markdown/near/CREATE_KEYPAIR.md ---
Like with most Web 3 protocols, transactions on NEAR happen between **accounts**. To create an account, one first need to generate a **keypair** which has a **public key** (or **address**, used to identify and lookup an account) and a **private key** used to sign transactions.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/near/keypair.ts`, implement `keypair` and retrieve the string formatted representation of the keypair into the variable `secret`. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
  try {
    const keypair = undefined;
    const secret = undefined;
    const address = undefined;
    if (!secret || !address) {
      throw new Error('Please complete the code.');
    }
    return res.status(200).json({address, secret});
  }
```

**Need some help?** Check out these links 👇

- [The `KeyPair` class](https://near.github.io/near-api-js/modules/utils_key_pair.html)
- [Retrieve the `secret`](https://near.github.io/near-api-js/classes/utils_key_pair.keypaired25519.html#tostring)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
  try {
    const keypair = KeyPair.fromRandom('ed25519');
    const secret = keypair.toString();
    const address = keypair.getPublicKey().toString();
    if (!secret || !address) {
      throw new Error('Please complete the code.');
    }
    return res.status(200).json({address, secret});
  }
```

**What happened in the code above?**

- First, we create a random `keypair` using the `ed25519` cryptographic curve.
- Next, we retrieve the string formatted representation of the `secret` key.
- Next, we retrieve the string formatted representation of the `address`.

---

# ✅ Make sure it works

Once the code in `pages/api/near/keypair.ts` is complete, Next.js will rebuild the API route. Now click on **Generate a Keypair** to make your first NEAR keypair.

# 🏁 Conclusion

Now that we have a keypair, we're going to associate it to an account name. Unlike other blockchains, support for human-readable addresses "out of the box" is possible with NEAR. Before we register an account name however, we need to find out if the name we want is available. Let's go!

'''
'''--- markdown/near/DEPLOY_CONTRACT.md ---
We won't go through the process of reviewing the smart contract code base, compiling it or testing it. We will focus instead on how one can deploy a smart contract using the `near-js-api`. To do this, we're going to use a pre-compiled smart contract, you can find it under `./contract/near/out/main.wasm`.

Our contract will be pretty basic. It stores a string on the blockchain and implements two functions:

- The `get_greeting` function, which takes an **accountId** and returns the string stored for a specific account.
- The `set_greeting` function, which takes an **accountId** and stores the string for a specific account.

{% hint style="working" %}
If you want to learn more about NEAR smart contracts, you can follow the tutorial [here](https://learn.figment.io/tutorials/write-and-deploy-a-smart-contract-on-near)
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/near/deploy.ts`, implement the default function. Deploy your first smart contract on the **NEAR** testnet. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
  try {
    const config = configFromNetwork(network);
    const keypair = KeyPair.fromString(secret);

    // Again you will need to set your keystore
    config.keyStore?.undefined;

    const near = await connect(config);
    const account = await near.account(accountId);

    // Time to deploy the Smart Contract
    const response = undefined;
    return res.status(200).json(response.transaction.hash)
  }
//...
```

**Need some help?** Check out this link 👇

- [Learn more about `deployContract`](https://near.github.io/near-api-js/classes/account.account-1.html#deploycontract)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const config = configFromNetwork(network);
    const keypair = KeyPair.fromString(secret);
    config.keyStore?.setKey("testnet", accountId, keypair);
    const near = await connect(config);
    const account = await near.account(accountId);
    const response = await account.deployContract(fs.readFileSync(WASM_PATH));
    return res.status(200).json(response.transaction.hash);
  }
//...
```

**What happened in the code above?**

- First, we need to _rehydrate_ our `KeyPair` using our secret.
- Next, we're calling the `deployContract` method with the `WASM_PATH` pointing to the location of the compiled smart contract. In this example we are using the JavaScript `fs` core module and the `[readFileSync](https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options)` method, which is responsible for converting the file into a Buffer so it can be sent to NEAR in the correct format.
- Finally, we can send the transaction hash back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/near/deploy.ts` is complete, click on **Deploy Contract** to send the compiled smart contract to NEAR.

---

# 🏁 Conclusion

Now that we have deployed a smart contract, let's interact with it. In the following tutorials, we will look at how to use both view and change functions.

'''
'''--- markdown/near/FINAL.md ---
🥳 **Congratulations**, you have completed the NEAR Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to NEAR with the Javascript API
- 🏦 Generating a keypair and using it to create an account
- 💸 Transferring NEAR tokens between accounts
- ⛓ Deploying and interacting with a compiled Rust smart contract

# 🧐 Keep learning with these resources:

- 🏋️ [Learn NEAR Club](https://learnnear.club/)
- 🏗 [Write and deploy a smart contract in Rust](https://learn.figment.io/tutorials/write-and-deploy-a-smart-contract-on-near)
- 🥩 [Monetize NEAR smart contracts](https://learn.figment.io/tutorials/monetize-near-smart-contracts)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/near/GET_BALANCE.md ---
After the creation of your account on the **NEAR** testnet, the **NEAR Helper** provides an automatic **airdrop** of 200 **NEAR** tokens. In this tutorial, we're going to check the balance of our account to make sure everything went alright.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/near/balance.ts`, implement the default function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
  try {
      const config = configFromNetwork(network);
      const client = await connect(config);
      const account = undefined;
      const balance = undefined;
      console.log(balance)
      return res.status(200).json(balance.available)
  }
```

**Need some help?** Check out these links 👇

- [Basic `NEAR` economics](https://docs.near.org/docs/concepts/gas)
- [The `Account` class](https://near.github.io/near-api-js/classes/account.account-1.html)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
  try {
      const config = configFromNetwork(network);
      const client = await connect(config);
      const account = await client.account(accountId);
      const balance = await account.getAccountBalance();
      return res.status(200).json(balance.available)
  }
```

**What happened in the code above?**

- First, we create an `account` object, representing our account. Pass the `accountId` as the only argument.
- Next, we call the `getAccountBalance` method, which returns the calculated account balance. The `AccountBalance` type has four properties; `total`, `stateStaked`, `staked` and `available`. A calculated balance might contain some staked NEAR tokens, but right now we haven't got anything staked so don't worry about this.

{% hint style="tip" %}
The amount returned by `getAccountBalance` is denominated in **yoctoNEAR**, so to convert it to **NEAR** you'll need to divide it by 10\*\*24
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/near/balance.ts` is complete, Next.js will rebuild the API route. Click on **Check Balance** and you should see the balance displayed on the page.

---

# 🏁 Conclusion

200 **NEAR** available, hmmm ... More than enough to do our first transfer. In the next tutorial, we're going to buy an imaginary pizza with our testnet NEAR! Transferring tokens is generally done as an exchange for goods or services.

'''
'''--- markdown/near/GET_CONTRACT_VALUE.md ---
Our Contract is on-chain, and we're going to learn how to fetch the message stored on the contract.

{% hint style="working" %}
If you want to learn more about NEAR smart contracts, you can follow the tutorial [here](https://learn.figment.io/tutorials/write-and-deploy-a-smart-contract-on-near)
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/near/getter.ts`, implement the default function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
  try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    const account = await near.account(accountId);
    // Using viewFunction, try to call the contract
    const response = undefined;
    return res.status(200).json(response)
  }
//...
```

**Need some help?** Check out this link 👇

- [Learn about `viewFunction`](https://near.github.io/near-api-js/classes/account.account-1.html#viewfunction)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    const account = await near.account(accountId);
    const response = await account.viewFunction(
        accountId,
        "get_greeting",
        {account_id: accountId}
    );
    return res.status(200).json(response)
  }
//...
```

**What happened in the code above?**

- We're calling the `viewFunction` method of our account, passing to it:
  - The `contractId`, which is the same as our account name. This is because the contract has been deployed to our account!
  - The name of the method we want to call, here `get_greeting`
  - The name of the argument expected by `get_greeting`, which is `account_id`.
- Finally, we can send the `response` back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/near/getter.ts` is complete, click the **Get Message** button to fetch the value stored in the smart contract and display it on the page.

---

# 🏁 Conclusion

Now, time for the last challenge! Time to modify the state of the contract and thus the state of the blockchain. Let's go!

'''
'''--- markdown/near/PROJECT_SETUP.md ---
# 🧩 DataHub API keys

If you wish to make use of the Pathway content using DataHub, you will need a DataHub account and a valid API key to access NEAR via DataHub's infrastructure. [Sign up for a DataHub account](https://datahub-beta.figment.io/signup) and verify your email address. Once you have logged in to DataHub, you will need to create a new app and select the NEAR protocol.

Click "Create New App":

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_1.png?raw=true)

Type in a name for your app, select the **Staging** environment, then click on the **NEAR** icon in the list of available protocols. \
Click "Create app" when you're finished:

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_2.png?raw=true)

You can now find your API key on the Overview tab of the app on the [**DataHub Dashboard**](https://datahub-beta.figment.io/apps):

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_3.png?raw=true)

To use your API key, you should copy the contents of the `.env.example` file located in the project root directory (`/learn-web3-dapp/.env.example`) into a new file named `.env.local` (`/learn-web3-dapp/.env.local`). Also, since this file will contain your API key, we have already added it to the `.gitignore`.

{% hint style="info" %}
Easily duplicate the file with the terminal command `cp .env.example .env.local`!
{% endhint %}

You can then paste your unique API key into `.env.local`, as the value for the environment variable `DATAHUB_NEAR_API_KEY`. This will authenticate you and enable you to make requests to NEAR via DataHub. **The API key shown below is only an example and cannot be used to access DataHub**.

```yaml
# DataHub API keys
DATAHUB_AVALANCHE_API_KEY=
DATAHUB_CELO_API_KEY=
DATAHUB_NEAR_API_KEY=2c8037789efe5cdd041f3fc4f8d9eedf
DATAHUB_POLKADOT_API_KEY=
DATAHUB_POLYGON_API_KEY=
DATAHUB_SECRET_API_KEY=
DATAHUB_SOLANA_API_KEY=
DATAHUB_TEZOS_API_KEY=
```

# 👣 Next Steps

Once you have your NEAR API key saved in `/learn-web3-dapp/.env.local`, you're ready to begin.
Click on the **Next: Connect to NEAR** button below.

'''
'''--- markdown/near/SET_CONTRACT_VALUE.md ---
Our contract is on-chain, and we're going to learn how to modify the message stored in the state of the contract.

{% hint style="working" %}
If you want to learn more about NEAR smart contracts, you can follow the tutorial [here](https://learn.figment.io/tutorials/write-and-deploy-a-smart-contract-on-near)
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/near/setter.ts`, implement the default function. You must replace any instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
  try {
    const config = configFromNetwork(network);
    const keypair = KeyPair.fromString(secret);
    config.keyStore?.setKey('testnet', accountId, keypair);

    const near = await connect(config);
    const account = await near.account(accountId);
    // Look at functionCall and pass the expected args
    // ... fill here
    return res.status(200).json(response.transaction.hash);
  }
//...
```

**Need some help?** Check out this link 👇

- [Learn about `functionCall`](https://near.github.io/near-api-js/classes/account.account-1.html#functioncall)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const config = configFromNetwork(network);
    const keypair = KeyPair.fromString(secret);
    config.keyStore?.setKey('testnet', accountId, keypair);

    const near = await connect(config);
    const account = await near.account(accountId);

    const optionsCall = {
        contractId: accountId,
        methodName: 'set_greeting',
        args: { message: newMessage }
    }
    const response = await account.functionCall(optionsCall);

    return res.status(200).json(response.transaction.hash)
  }
//...
```

**What happened in the code above?**

- We're calling the `functionCall` method of our account, passing to it:
  - The `contractId` which is the same as our account name. This is because the contract has been deployed to our account.
  - The name of the method we want to call, `set_greeting`
  - The name of the argument expected by `get_greeting`, which is `message`.

---

# ✅ Make sure it works

Once the code in `pages/api/near/setter.ts` is complete, enter a value into the textinput then click the **Set greeting** button to send the new value to the smart contract.

---

# 🏁 Conclusion

Congratulations! You have successfully created, deployed, and interacted with a smart contract on the NEAR Testnet using DataHub.

'''
'''--- markdown/near/TRANSFER_TOKEN.md ---
In order to transfer some value to another account, we need to sign a transaction to the **network**. **NEAR** provides an abstract class to help us with this: **KeyStore**.

In this tutorial you are going to learn how to set your keystore in order to sign your transfer of tokens.

---

# 🏋️ Challenge

{% hint style="tip" %}
In`pages/api/near/transfer.ts`, implement the function. You must replace any instances of `undefined` with working code to accomplish this. There is a lot to fill here, so be careful!
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
  try {
    const config = configFromNetwork(network);

    // recreate the keypair from secret
    const keypair = undefined;

    // Set the keystore with the expected method and args
    config.keyStore?.undefined;

    // Here we convert the NEAR into yoctoNEAR using utilities from NEAR lib
    const yoctoAmount = parseNearAmount(txAmount) as string;
    const amount = new BN(yoctoAmount);

    // Fill the Gap: connect, create an Account Object and send some money
    const near = undefined;
    const account = undefined;
    const transaction = undefined;

    return res.status(200).json(transaction.transaction.hash);
  }
//...
```

**Need some help?** Check out these links 👇

- [Manage a `KeyStore` in memory](https://near.github.io/near-api-js/classes/key_stores_in_memory_key_store.inmemorykeystore.html)
- [Check out the `sendMoney()` method](https://near.github.io/near-api-js/classes/account.account-1.html#sendmoney)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const config = configFromNetwork(network)
    const keypair = KeyPair.fromString(secret)
    config.keyStore?.setKey("testnet", txSender, keypair)

    const yoctoAmount = parseNearAmount(txAmount) as string
    const amount = new BN(yoctoAmount)

    const near = await connect(config)
    const account = await near.account(txSender)
    const transaction = await account.sendMoney(txReceiver, amount)
    return res.status(200).json(transaction.transaction.hash)
  }
//...
```

**What happened in the code above?**

- First, we need to _rehydrate_ our `KeyPair` using our secret.
- Next, we convert the **NEAR** into **yoctoNEAR**, the smallest unit of money on the **NEAR** blockchain.
- Next, create our transaction using the `sendMoney` method, with a receiver and an amount as arguments. This submits the signed transaction to the network, and returns the transaction hash, which is accessible as the `transaction.hash` property of the `transaction` variable.

---

# ✅ Make sure it works

Once you have the code above saved:

- Fill in the amount of **NEAR** you want to send to `pizza.testnet`.
- Click on **Submit Transfer**.

---

# 🏁 Conclusion

Now that we have funded our account and made a transfer, let's move on to deploying some code (known as a "smart contract") to the NEAR blockchain! Ready to take the plunge? Let's go...

'''
'''--- markdown/polkadot/CHAIN_CONNECTION.md ---
In this tutorial, we will connect to a Polkadot node hosted by [DataHub](https://docs.figment.io/introduction/what-is-datahub) using a [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) Provider. DataHub lets developers use the most powerful and unique features of a blockchain without having to become protocol experts. WebSockets make it possible to open a two-way interactive communication session between the user's browser and a server.

Polkadot has built a [JavaScript library](https://github.com/polkadot-js/api) to help developers interface easily with its API. The documentation for Polkadot.js can be found at [https://polkadot.js.org/docs/](https://polkadot.js.org/docs/).

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/polkadot/connect.ts`, implement the function and try to establish your first connection to the Polkadot network. You must replace the instances of `undefined` with working code to accomplish this.  
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const provider = new WsProvider(url);
    const api = undefined;
    const rawVersion = undefined;
    const version = rawVersion.toHuman();
    await provider.disconnect();
    res.status(200).json(version);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Basics & Metadata**](https://polkadot.js.org/docs/api/start/basics)
- [**Providers**](https://polkadot.js.org/docs/api/start/create#providers)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });
    const rawVersion = await api.rpc.system.version();
    const version = rawVersion.toHuman();
    res.status(200).json(version);
  }
//...
```

**What happened in the code above?**

- The `getSafeUrl` helper function constructs a DataHub URL for either Mainnet or the Westend testnet using the API key provided in `.env.local` - It can also be used with the `force` option to return the public Westend RPC endpoint as a fallback.
- With the endpoint URL, we can create a new `WsProvider` instance.
- Then we use `ApiPromise.create` to initialize the API, passing the provider as an object.
- Using the `rpc` module, we can then query the `system.version` method.
- To display a human readable string of the version number, we use the `toHuman` method.
- Finally, we send the `version` back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/polkadot/connect.ts` is complete, click the blue button to connect to Polkadot & display the current version.

---

# 🏁 Conclusion

In this tutorial you’ve learned how to use the [Polkadot.js](https://polkadot.js.org/docs/) package and DataHub to connect to a Polkadot node. You also learned how to run a simple query to test that connection.

'''
'''--- markdown/polkadot/CREATE_ACCOUNT.md ---
In this tutorial, we will be creating a Polkadot account on the Westend testnet and funding it with **WND** tokens by connecting to a chatroom which hosts a _faucet_, a means for us to request free tokens.

There are currently a few different ways to create a new account on Polkadot or a testnet like Westend:

- **Programmatically** (with code) using the Polkadot API _(covered in this tutorial)_
- **Through a web browser** by using the [Polkadot Apps Wallet](https://polkadot.js.org/apps/#/accounts) (_in some kind of hurry for a hackathon?_)
- **Through a terminal** by using [SubKey](https://wiki.polkadot.network/docs/en/learn-account-generation#subkey) (_advanced, will not be covered in this tutorial_)

We will be creating an account programmatically using the API, however you might find it useful to explore the other options depending on your needs.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/polkadot/account.ts`, implement the function and try to create your first account on the polkadot network. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const keyring = new Keyring({ type: "sr25519" });

    // Create mnemonic string
    const mnemonic = undefined;

    const isValidMnemonic = mnemonicValidate(mnemonic);
    if (!isValidMnemonic) {
      throw Error('Invalid Mnemonic')
    }

    // Add an account derived from the mnemonic
    const account = undefined;
    const address = undefined;
    const jsonWallet = undefined;
    res.status(200).json({
      address,
      mnemonic,
      jsonWallet,
    });
  }
//...
```

**Need some help?** Check out these links 👇

- [**Keyring Basics**](https://polkadot.js.org/docs/keyring/start/basics)
- [**Using address or publicKey**](https://polkadot.js.org/docs/keyring/start/sign-verify#verify-using-address-or-publickey)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const keyring = new Keyring({ type: "sr25519" });

    // Create mnemonic string
    const mnemonic = mnemonicGenerate();
    console.log(`Generated mnemonic: ${mnemonic}`);

    const isValidMnemonic = mnemonicValidate(mnemonic);
    if (!isValidMnemonic) {
      throw Error('Invalid Mnemonic')
    }

    // Add an account derived from the mnemonic
    const account = keyring.addFromUri(mnemonic);
    const address = account.address;
    const jsonWallet = JSON.stringify(keyring.toJson(account.address), null, 2)
    res.status(200).json({
      address,
      mnemonic,
      jsonWallet,
    });
  }
//...
```

**What happened in the code above?**

- First, we create a new `Keyring` instance of the `sr25519` type - This type parameter only applies to the default type of account created when no type is specified, it does not mean that the keyring can only store that type of account.
- Next, we generate a new BIP39 mnemonic using the `mnemonicGenerate` method.
- Next, we check if the mnemonic is valid using the `mnemonicValidate` method.
- Next we create our account from the mnemonic and add it to the keyring using the `addFromUri` method.
- Then, we return:
  - The address of our account.
  - The mnemonic, so we can restore our account later.
  - A JSON representation of our Wallet.
- Finally, we send this data back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/polkadot/account.ts` is complete, Next.js will rebuild the API route. Now click on **Generate a Keypair** to make a Polkadot account. Remember to fund the the account by visiting the faucet and sending the message `!drip <your address>`.

---

# 🏁 Conclusion

Now that we have created a Polkadot account and funded it with **WND** testnet tokens, let’s move on to querying a Polkadot node to check the current balance of our account!

'''
'''--- markdown/polkadot/ESTIMATE_DEPOSIT.md ---
On Substrate blockchains, an account can stay active only if it maintains a minimal amount known as the **existential deposit**. If an account balance falls below this amount, then the system will erase the account and the remaining token dust will be lost.

In this tutorial, we'll learn how to query the system in order to retrieve the existential deposit.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/polkadot/deposit.ts`, implement the function and try to determine the existential deposit an account needs to have in order to remain active. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });
    const deposit = undefined;
    await provider.disconnect();
    res.status(200).json(deposit);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Polkadot.js documentation**](https://polkadot.js.org/docs/)
- [**Code examples**](https://polkadot.js.org/docs/api/examples/promise/)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });
    const deposit = api.consts.balances.existentialDeposit.toNumber();
    res.status(200).json(deposit);
  }
//...
```

**What happened in the code above?**

- First, we need to instantiate our connection to the Polkadot API.
- Next, we call `existentialDeposit` of the `const.balances` module, converting the property to a number with `toNumber`.
- Finally, we send the `deposit` amount back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/polkadot/deposit.ts` is complete, Next.js will rebuild the API route. Click the **Get Existential Deposit** button to display the amount needed to keep an account active.

---

# 🏁 Conclusion

Now that we've learned about fees, balances and the existential deposit on Polkadot - we can move on to making a token transfer! In the next tutorial, we will learn how to send tokens to other accounts. Ready? Let's go!

'''
'''--- markdown/polkadot/ESTIMATE_FEES.md ---
In this tutorial, we will learn how to make a transfer of tokens on Polkadot. Transferring is a basic and fundamental feature of the Polkadot network. Transfers are not free, as they modify the state of the blockchain. How can we estimate the fees associated with a simple transfer?

We'll explore how to estimate fees in this challenge.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/polkadot/estimate.ts`, implement the function and try to estimate the fees required for a simple transfer. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });

    // A generic address for recipient (//Alice) and an amount to send
    const recipient = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY'
    const transferAmount = '1000000000';

    // Transfer tokens
    const transfer =  undefined;
    const info = undefined;
    const fees = undefined;

    await provider.disconnect();
    res.status(200).json(fees);
  }
//...
```

**Need some help?** Check out this link 👇

- [**How do I estimate the transaction fees?**](https://polkadot.js.org/docs/api/cookbook/tx#how-do-i-estimate-the-transaction-fees)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });

    // A generic address for recipient (//Alice) and an amount to send
    const recipient = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY'
    const transferAmount = '1000000000'; // 1 milli WND

    // Transfer tokens
    const transfer =  api.tx.balances.transfer(recipient, transferAmount);
    const info = await transfer.paymentInfo(address);
    const fees = info.partialFee.toNumber();

    res.status(200).json(fees)
  }
//...
```

**What happened in the code above?**

- First, we create a new transaction for a transfer using the `tx.balances.transfer` method, passing the `recipient` and `transferAmount`.
- Next, we call the `paymentInfo` method on the transaction object.
- Then we convert the `partialFee` property to a number with `toNumber`.
- Finally, we send the information back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/polkadot/estimate.ts` is complete, click on **Estimate Fees** to get the estimated fees to perform a token transfer.

---

# 🏁 Conclusion

Now that we understand how to estimate the fees required to pay for a transaction on Polkadot, let’s move on to querying a Polkadot node to get the current balance of our account!

'''
'''--- markdown/polkadot/FINAL.md ---
🥳 **Congratulations**, you have completed the Polkadot Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to Polkadot using a Javascript library
- 🏦 Creating and funding an account with testnet tokens
- 🌱 Restoring an account with a mnemonic seed phrase
- 🤔 Estimating transaction fees and viewing an account balance
- 😅 The "existential deposit" which keeps accounts from remaining open with a very low balance
- 💸 Transferring tokens between accounts

# 🧐 Keep learning with these resources:

- ♻️ [Learn more about the Parachain lifecycle](https://learn.figment.io/tutorials/parachain-lifecycle)
- 🧰 [How to build custom pallets with Substrate](https://learn.figment.io/tutorials/how-to-build-custom-pallets-with-substrate)
- 🚀 [substrate.io](https://substrate.io/)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/polkadot/GET_BALANCE.md ---
In this tutorial, we will learn how to query an account balance on Polkadot. Account balances are important to keep track of so that users know if they can afford to send a transaction, or to afford the **existential deposit**.

---

# 😅 Challenge

{% hint style="tip" %}
In `pages/api/polkadot/balance.ts`, implement the function and try to query the balance of your account. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });
    const { data: { free } }  = undefined;
    const amount = undefined;
    await provider.disconnect();
    res.status(200).json(amount);
  }
//...
```

**Need some help?** Check out this link 👇

- [**Basic queries**](https://polkadot.js.org/docs/api/start/api.query#basic-queries)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });
    const { data: { free } } = await api.query.system.account(address);
    const amount = free.toNumber();
    res.status(200).json(amount);
  }
//...
```

**What happened in the code above?**

- First, we need instantiate our connection to the Polkadot API.
- Next, we destructure the data returned by the `query.system.account` method as `balance`.
- Then we can access the available balance of our account via the `free` property, converting it into a number with `toNumber`.
- Finally, we send the `amount` back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/polkadot/balance.ts` is complete, Next.js will rebuild the API route. Click on **Check Balance** and you should see the balance displayed on the page.

---

# 🏁 Conclusion

Querying the balance information is fun, but being able to submit transactions and change the state of a blockchain is even better! Soon, we will dive deeper and submit our first transactions on Polkadot. But first, we need to understand the **existential deposit** feature of Polkadot accounts.

'''
'''--- markdown/polkadot/PROJECT_SETUP.md ---
# 🧩 DataHub API keys

If you wish to make use of the Pathway content using DataHub, you will need a DataHub account and a valid API key to access Polkadot via DataHub's infrastructure. [Sign up for a DataHub account](https://datahub-beta.figment.io/signup) and verify your email address. Once you have logged in to DataHub, you will need to create a new app and select the Polkadot protocol.

Click "Create New App":

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_1.png?raw=true)

Type in a name for your app, select the **Staging** environment, then click on the **Polkadot** icon in the list of available protocols. \
Click "Create app" when you're finished:

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_2.png?raw=true)

You can now find your API key on the Overview tab of the app on the [**DataHub Dashboard**](https://datahub-beta.figment.io/apps):

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_3.png?raw=true)

To use your API key, you should copy the contents of the `.env.example` file located in the project root directory (`/learn-web3-dapp/.env.example`) into a new file named `.env.local` (`/learn-web3-dapp/.env.local`). Also, since this file will contain your API key, we have already added it to the `.gitignore`.

{% hint style="info" %}
Easily duplicate the file with the terminal command `cp .env.example .env.local`!
{% endhint %}

You can then paste your unique API key into `.env.local`, as the value for the environment variable `DATAHUB_POLKADOT_API_KEY`. This will authenticate you and enable you to make requests to Polkadot via DataHub. **The API key shown below is only an example and cannot be used to access DataHub**.

```yaml
# DataHub API keys
DATAHUB_AVALANCHE_API_KEY=
DATAHUB_CELO_API_KEY=
DATAHUB_NEAR_API_KEY=
DATAHUB_POLKADOT_API_KEY=9f40361b6a3253e577376495c580b700
DATAHUB_POLYGON_API_KEY=
DATAHUB_SECRET_API_KEY=
DATAHUB_SOLANA_API_KEY=
DATAHUB_TEZOS_API_KEY=
```

---

# 👣 Next Steps

Once you have your Polkadot API key saved in `/learn-web3-dapp/.env.local`, you're ready to begin.
Click on the **Next: Connect to Polkadot** button below.

'''
'''--- markdown/polkadot/RESTORE_ACCOUNT.md ---
In this tutorial, we'll learn how to restore a wallet from a mnemonic and how to derive the address and the private key when the wallet has been restored.

Ready? Let's go!

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/polkadot/restore.ts`, implement the function and try to restore your account using your mnemonic. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const { mnemonic } = req.body;
    const keyring = undefined;
    const account = undefined;
    const address = undefined;
    res.status(200).json(address);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Keyring Basics**](https://polkadot.js.org/docs/keyring/start/basics)
- [**Using address or publicKey**](https://polkadot.js.org/docs/keyring/start/sign-verify#verify-using-address-or-publickey)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const { mnemonic } = req.body;
    const keyring = new Keyring({type: 'sr25519'});
    const account = keyring.addFromUri(mnemonic);
    const address = account.address;
    res.status(200).json(address);
  }
//...
```

**What happened in the code above?**

- First, we create a new `Keyring` instance of the `sr25519` type.
- Then we can use the `addFromUri` method to add the supplied mnemonic to the keyring - this is the account.
- We can now access the public address via the `address` property of the `account`.
- Finally, we send the address of the account back to the client-side as JSON.

---

# ✅ Make sure it works

When the code in `pages/api/polkadot/restore.ts` is complete, click on **Restore Account** to restore your Polkadot address from the mnemonic.

---

# 🏁 Conclusion

The ability to restore an account without requiring a third party is a great feature of **Polkadot**. Now, we're ready to go further and prepare our first transaction. In the next tutorial, we're going to learn how to estimate the fees required to submit a simple transfer.

'''
'''--- markdown/polkadot/TRANSFER_TOKEN.md ---
It’s time to submit your first transaction on Polkadot! In this tutorial, we will connect to a Westend node hosted by DataHub to transfer some testnet tokens. As you remember from previous tutorials, we funded our account on the **Westend** testnet with 1 **WND**. Now let's try to transfer some tokens.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/polkadot/transfer.ts`, implement the function and try to transfer an amount of tokens. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
    // Initialize account from the mnemonic
    const keyring = new Keyring({type: 'sr25519'});
    const account = keyring.addFromUri(mnemonic);

    // Initialize account from the mnemonic
    const recipient = keyring.addFromUri('//Alice');
    const recipientAddr = recipient.address

    // Transfer tokens
    const transfer = undefined;
    const hash = await transfer.signAndSend(account);

    await provider.disconnect();
    res.status(200).json(hash.toString())
  }
//...
```

**Need some help?** Check out these links 👇

- [**Polkadot.js documentation**](https://polkadot.js.org/docs/)
- [**Code examples**](https://polkadot.js.org/docs/api/examples/promise/)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
    // Initialize account from the mnemonic
    const keyring = new Keyring({type: 'sr25519'});
    const account = keyring.addFromUri(mnemonic);

    // Initialize account from the mnemonic
    const recipient = keyring.addFromUri('//Alice');
    const recipientAddr = recipient.address;

    // Transfer tokens
    const transfer = await api.tx.balances.transfer(recipientAddr, txAmount);
    const hash = await transfer.signAndSend(account);

    res.status(200).json(hash.toString());
  }
//...
```

**What happened in the code above?**

- First, we need to instantiate our connection to the Polkadot API.
- Next, we call the `transfer` method of the `tx.balances` module, passing:
  - The recipient's address, from a [dev account](https://polkadot.js.org/docs/keyring/start/suri#dev-accounts) named "Alice".
  - The amount to transfer.
- Then we _sign and send_ the transaction passing our account as an argument to the `signAndSend` method - This specifies our account as the one paying the transfer fee, as well as signing the transaction.

---

# ✅ Make sure it works

Once the code in `pages/api/polkadot/transfer.ts` is complete, Next.js will rebuild the API route. Fill in the amount of **Planck** you want to send, then click on **Submit Transfer**.

---

# 🏁 Conclusion

There are many things that are beyond the scope of this Pathway, but the links provided to expand on some of the concepts contained in the tutorials should at least provide ample starting points for further study. Consider refining and playing with the code from the Pathway, to see what can be built out of these foundational blocks of Polkadot.

'''
'''--- markdown/polygon/CHAIN_CONNECTION.md ---
# 🤔 Ethers.js

To manage our connection with Polygon and interact with smart contracts, we can use a popular and [well-tested](https://docs.ethers.io/v5/testing/) JavaScript library called [**ethers.js**](https://docs.ethers.io/v5/api/). We can connect to and perform operations with Polygon using ethers' API with only a few lines of code.

In ethers, a **provider** is a read-only abstraction to access the blockchain data. A **signer** is an abstraction of an Ethereum Account, which can be used to sign messages and transactions, and send signed transactions to the network.

The ethers library has some helpful functions that will make this a snap! Read the ethers.js[ API documentation](https://docs.ethers.io/v5/api/) to learn more about its various functions.

{% hint style="info" %}
_It is important to note that throughout the Pathway, we will refer to the_ ethers.js _library only as "\_ethers_".\_
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
**Imagine this scenario:** You're a fresh Web3 developer who just landed a sweet role at a promising new startup, eager to show off your skills. You've been asked to show users of our dApp which network they are connected to (to avoid any confusion) and store the address of the account currently selected in Metamask (so that we can reference it later). In **`components/protocols/polygon/challenges/connect.ts`**, implement the`connect` function.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
const connect = async () => {
  try {
    const provider = undefined;
    if (provider) {
      await undefined;
      const signer = undefined;
      const address = undefined;
      return {
        address,
      };
    } else {
      return {
        error: 'Please install Metamask at https://metamask.io',
      };
    }
  } catch (error) {
    return {
      error: 'An unexpected error occurs',
    };
  }
};
```

**Need some help?** Check out these links 👇

- **Connect to Polygon** using ethers' Web3Provider and the Metamask wallet
  - [Ethers' docs for creating a Web3Provider instance](https://docs.ethers.io/v5/api/providers/other/#Web3Provider)
  - [StackOverflow post about connecting Metamask to Ethers](https://stackoverflow.com/questions/60785630/how-to-connect-ethers-js-with-metamask)
- **Display the connected network**
  - [Get the Network from a Ethers provider](https://docs.ethers.io/v5/api/providers/)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
const connect = async () => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    if (provider) {
      await provider.send('eth_requestAccounts', []);
      const signer = provider.getSigner();
      const address = await signer.getAddress();
      return {
        address,
      };
    } else {
      return {
        error: 'Please install Metamask at https://metamask.io',
      };
    }
  } catch (error) {
    return {
      error: 'An unexpected error occurs',
    };
  }
};
```

**What happened in the code above?**

- First, we need to define the provider by calling `Web3Provider` method of `providers`.
- We need to ensure that Metamask connects to the page, and that we can query the currently selected account in Metamask. This is done by using the method `send` on the provider, to send the `eth_requestAccounts` query. This will bring up a Metamask dialog, asking the user to unlock their Metamask if it is locked, or to connect an account to the page if Metamask is unlocked - this account functions as a `signer`.
- As said above the `signer` represents the current connected account. Then, calling the `getAddress` method will do the job of querying the address of the current connected account.

---

# ✅ Make sure it works

## Once the code in `components/protocols/polygon/challenges/connect.ts` is complete, click on **Check Metamask Connection** to open Metamask and connect to Polygon.

# 🔐 Addresses, Wallets, and Mnemonics

Every account on Polygon or Ethereum has a private key, a public key, and a mnemonic associated with it (referred to as a "[Secret Recovery Phrase](https://community.metamask.io/t/what-is-a-secret-recovery-phrase-and-how-to-keep-your-crypto-wallet-secure/3440)" by Metamask as of Q2 2021 - you will likely encounter a lot of documentation which still refers to "mnemonic seed phrase").

The format of all Polygon addresses match those on Ethereum. For example:`0x333314441798b549F0d4F952E61b4A1383F43104` exists on both Polygon and Ethereum. Each address is 42 characters in length - `0x` indicating that the following string is comprised of hexadecimal characters, and then the 40 hexadecimal characters representing the last 20 bytes of the account's public key. Sometimes people refer to an address as a public key, but they are not interchangeable in this case.

A **wallet** refers to either a piece of software used to manage cryptographic keys and the contents of associated addresses, such as Metamask or Trust Wallet, or _the address itself_. You may sometimes hear users refer to their address as their wallet.

Generating a new address in Metamask is not the same as generating a new secret recovery phrase/mnemonic. However, [`ethers.Wallet.createRandom()`](https://docs.ethers.io/v5/api/signer/#Wallet-createRandom) can be used to make new accounts and mnemonics.  
The 12 words of a secret recovery phrase are taken from a specific wordlist. They give control of the entire contents of any address generated with them. For this reason it is vitally important that you protect your private keys and mnemonic seed phrases. _Never share them with anyone_.

{% hint style="info" %}
This is an important topic to be comfortable with as both a user and blockchain developer. Spend some time experimenting with providers, signers and wallets to get acquainted with these fundamental blockchain concepts. There are many good explanations of the workings of [Hierarchical Deterministic](https://weteachblockchain.org/courses/bitcoin-for-developers/3/hd-wallets) (HD) wallets available online, just know that a secret recovery phrase/mnemonic is a critical piece of information which should be kept secret and secure at all times.
{% endhint %}

---

# 🏁 Conclusion

Now that we have a connected to Polygon, we can use ethers to query information from the blockchain. In the next tutorial, we will cover how to query Polygon and display the information.

'''
'''--- markdown/polygon/DEPLOY_CONTRACT.md ---
Solidity is a high level language. It is partly designed after ECMAScript and therefore it is said to be **similar to JavaScript**. The similarity ends there because it gets compiled (not interpreted) and usually deployed on blockchains that understand the Ethereum Virtual Machine (EVM), like Polygon! When a smart contract is deployed, it becomes immutable. This has both benefits and drawbacks, which we will discuss below.

We can use [HardHat](https://hardhat.org) or [Truffle](https://trufflesuite.com) to ease development and deployment of our Solidity code. There are several existing guides for other EVM compatible networks available on Figment Learn (check out the tutorials for [Celo and Truffle](https://learn.figment.io/tutorials/deploying-smart-contracts-on-celo-with-truffle), or [Celo and HardHat](https://learn.figment.io/tutorials/celo-hardhat-deploy-and-nft-app) for example). We will focus on using Truffle in this tutorial.

Run the following commands to get started:

```text
npm install -g truffle
cd contracts/polygon/SimpleStorage
yarn
```

{% hint style="warning" %}
Also be sure to rename the file **`contracts/polygon/SimpleStorage/.secret.example`** to **`.secret`** before continuing. This file is where we will store the secret recovery phrase used later in this step to deploy the smart contract. You will need to replace the text "your recovery phrase goes here" with your Metamask secret recovery phrase.
{% endhint %}

# 📦 The SimpleStorage Solidity contract

One of the most basic, non-trivial, types of smart contract is a **simple storage contract**.  
This example was adapted from the [Solidity documentation](https://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleStorage {
    uint storedData;

    constructor() {
  		  storedData = 0;
  	}

    function set(uint x) public {
        storedData = x;
    }

    function get() public view returns (uint) {
        return storedData;
    }
}
```

The first line of a Solidity file should contain a comment which describes the type of license governing the source code. The `SPDX-License-Identifier` will most commonly be the MIT licence, although a comprehensive list can be found at [https://spdx.org/licenses/](https://spdx.org/licenses/). The Solidity compiler will issue a [warning](https://docs.soliditylang.org/en/v0.8.6/security-considerations.html#take-warnings-seriously) if this line is not present at compilation time.

The next line specifies the version of the Solidity compiler to be used when compiling this contract. Using [semantic versioning](https://semver.org/), it is possible to prevent a Solidity file from being compiled by incompatible versions - most often in the case of breaking changes between major versions. We are using one of the newer versions of the compiler, but not the most recent \([`0.8.6`](https://docs.soliditylang.org/en/v0.8.6/installing-solidity.html) at the time of this writing\).

Next we define our contract name, `SimpleStorage` - The contract name can be anything, but should be descriptive of the functionality. The naming convention for Solidity is that the filename should match the UpperCamelCase contract name, hence `SimpleStorage.sol`.

The `constructor()` is called only once, when the contract is deployed. The constructor is the place to assign default values to any variables, and performs an initial configuration of the app state. We will set the initial value of the `storedData` variable to `0`.

Next we declare a function signature for the `set()` function, which has a [visibility](https://docs.soliditylang.org/en/v0.8.6/contracts.html#visibility-and-getters) of public. `set` takes a single argument `x`, an unsigned integer \([uint](https://docs.soliditylang.org/en/v0.8.6/types.html#integers)\). The function body is a single line, which assigns the value passed via `x` to the `storedData` state variable.

The `get()` function signature is slightly different, in that there is no argument being passed. It also has a visibility of public, is a [view](https://docs.soliditylang.org/en/v0.8.6/types.html?highlight=view#function-types) type of function, and specifies a return type of `uint`. Its function body will simply return the current value of `storedData`.

# 🔧 Test the smart contract

This test uses the Truffle-provided `Assert` and `DeployedAddresses` contracts. These are built in to Truffle and the development blockchain. It is also important that we import the Solidity file we want to test!

Because deployed bytecode is immutable, it is best to work with security and best practices in mind. Prevent accidentally deploying code with errors by always _testing prior to deployment_. We will test our SimpleStorage contract with Truffle.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "truffle/Assert.sol";
import "truffle/DeployedAddresses.sol";
import "../contracts/SimpleStorage.sol";

contract TestSimpleStorage {

  function testInitialStoredDataUsingDeployedContract() public {
    SimpleStorage store = SimpleStorage(DeployedAddresses.SimpleStorage());
    Assert.equal(store.get(), 0, "storedData should be 0 initially");
  }

  function testSettingStoredData() public {
    SimpleStorage store = new SimpleStorage();
    uint expected = 10000;
    store.set(expected);
    Assert.equal(store.get(), expected, "storedData should equal 10000");
  }

}
```

The first test will be run against a freshly deployed version of the SimpleStorage code every time, which is why the initial test for `storedData` should always equal zero.

The second test sets the value of `storedData` to `10000` and then queries it from the blockchain in the same manner as the first test, asserting that it will be equal to `10000`.

Simple functionality, simple tests!  
Before running the tests, we must ensure we are running a local blockchain with Truffle. Open a separate terminal window and run the command:

```text
truffle develop
```

With this local blockchain running, we can test the SimpleStorage contract with the command:

```text
truffle test
```

This will compile the contract before deploying it to the Truffle development chain and performing the tests. You should see similar output in your terminal:

```text
Using network 'development'.

Compiling your contracts...
===========================
> Compiling ./test/TestSimpleStorage.sol
> Artifacts written to /var/folders/xc/jxvcxfc901nd0jmqv594w8sw0000gn/T/test--89605-BscbjjTFIYq2
> Compiled successfully using:
   - solc: 0.8.0+commit.c7dfd78e.Emscripten.clang

  TestSimpleStorage
    ✓ testInitialStoredDataUsingDeployedContract (60ms)
    ✓ testSettingStoredData (56ms)

  2 passing (6s)
```

{% hint style="warning" %}
If there is an error : `Error: Cannot find module '@truffle/hdwallet-provider'`. You need to install the dependencies in this sub-module with `yarn` as mentioned at the beginning of the tutorial.
{% endhint %}

# ⛓ Deploy the smart contract

{% hint style="tip" %}
Before we deploy, there is one last thing to prepare: Paste the private key of your funded Polygon address into **`contracts/polygon/SimpleStorage/.secret`** so that the deployment can be paid for with MATIC tokens from that address. You can also use the secret recovery phrase \(also known as a mnemonic seed phrase\) of the active Metamask account, however this method is not recommended as it could potentially result in your seed phrase being leaked. The private key grants access to only one account, while the seed phrase grants access to all accounts derived from it.  
{% endhint %}

To access the private key of the account you funded with MATIC earlier in the pathway, open Metamask and click on the three dots in the upper right portion of the window. Click on "Account details", and then click the "Export Private Key" button - You'll need to enter your MetaMask password to be able to view the private key. Check the image below for details if you're not sure what this should look like.

![How to get your private key from MetaMask](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/polygon/privatekey.png)

If using a private key in `contracts/polygon/SimpleStorage/.secret` it should look like this, 64 alphanumeric characters on a single line with no quotation marks :

```text
4c247d15a6437be984d6df3a792e74c107a247bd0ad44b685bc3bdcaf183a8fe
```

You will also notice in `contracts/polygon/SimpleStorage/truffle-config.js` that the configuration parameter for using a mnemonic with the `HDWalletProvider` has been commented out by default. Be sure to uncomment it if you intend to use your secret recovery phrase!

If using a secret recovery phrase (mnemonic) in `contracts/polygon/SimpleStorage/.secret` it should look like this, all 12 words on a single line with no quotation marks :

```text
airport battle cargo daughter educate focus green honey immune jelly kick language
```

---

Compiling Solidity with Truffle is a straightforward process, just make sure that your preferred configuration is set in `truffle-config.js` \(paths, compilers, networks, etc.\) and then run the command:

```text
truffle compile
```

Deploying Migrations with Truffle is quite similar to deploying, but provides more flexibility for custom workflows. A full explanation of migrations is beyond the scope of this tutorial, but please do read the Truffle [documentation](https://www.trufflesuite.com/docs/truffle/getting-started/running-migrations) on the subject. To deploy the SimpleStorage contract to Polygon, run this command :

```text
truffle migrate --network matic
```

The flag `--network matic` lets Truffle know which network we want to deploy our migrations to. The configuration for each network is set inside of `truffle-config.js`.

For the deployment to work, make sure there is a valid private key or secret recovery phrase inside of the `.secret` file, and that the account has some MATIC tokens. If you have followed the tutorial steps so far, these conditions should be satisfied.

---

# 🧩 Using the Application Binary Interface (ABI):

[The Solidity Contract ABI Specification](https://docs.soliditylang.org/en/v0.8.6/abi-spec.html) explains that an ABI is a standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction. Data is encoded according to its type, as described in the specification. The encoding is not self describing and thus requires a schema in order to decode.

The ABI is considered an "[artifact](https://trufflesuite.github.io/artifact-updates/background.html#what-are-artifacts)" in relation to a compiled Solidity contract. Most commonly, developers will interact with an ABI in JSON format. Read more about [what this means](https://docs.soliditylang.org/en/v0.8.6/abi-spec.html#json).

---

# ✅ Make sure it works

Once the contract is compiled and deployed, paste the contract address into the textinput on the right side of this page and click to **Check deployment**. This will execute the `getCode` method available to the provider to ensure that there is a deployed contract at the specified address.

---

# 🏁 Conclusion

Truffle is only one of several different ways to deploy smart contracts on Polygon. It is also possible to use the Ethereum [Remix IDE](https://remix.ethereum.org), or another smart contract development tool called [HardHat](https://hardhat.org). Now that we have a deployed and functioning smart contract on Polygon, let's interact with it!

'''
'''--- markdown/polygon/FINAL.md ---
🥳 **Congratulations**, you have completed the Polygon Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to Polygon with Metamask
- ⁉️ Querying Polygon for specific information
- 🏦 Funding a Polygon testnet account with the faucet
- 💸 Transferring tokens between accounts
- ⛓ Deploying and interacting with a Solidity smart contract
- 🌱 Restoring access to an account with a Secret Recovery Phrase (mnemonic)

# 🧐 Keep learning with these resources:

- 🎲 [Using the Chainlink Oracle for randomness](https://learn.figment.io/tutorials/chainlink-vrf-on-polygon)
- 🏗 [Deploying and debugging smart contracts](https://learn.figment.io/tutorials/deploying-and-debugging-smart-contracts-on-polygon)
- 🧱 [Application development on Polygon](https://docs.polygon.technology/docs/develop/getting-started/)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/polygon/GET_BALANCE.md ---
In this tutorial, we will acquire some free **MATIC** on the testnet so that we can deploy a smart contract and interact with it. Before dealing with actual value on the Polygon mainnet, it is wise to practice using the Polygon testnet (called Mumbai).

Click on the icon in the upper-right corner of the page to copy the hexadecimal address of the Metamask account to the clipboard:

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/polygon/click_to_copy.png)

Visit [https://faucet.polygon.technology/](https://faucet.polygon.technology/) and paste the address from your selected account in Metamask into the textinput. It is OK to leave the default options for **MATIC** tokens and the Mumbai network selected. Click the Submit button, then click again on the popup to confirm the transaction.

Once this transaction is confirmed, you will have 1 **MATIC** on the Mumbai testnet!

---

# 🏋️ Challenge

{% hint style="tip" %}
**Imagine this scenario:** You know you have a big balance. You need to show that balance so you can brag about it to all your awesome Web 3 developer friends! In `components/protocols/polygon/challenges/balance.ts`, implement the `getBalance` function :
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
const getBalance = async (address: string) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);

    const balance = undefined;
    if (!balance) {
      throw new Error('Please complete the code');
    }
    return {
      balance: balance.toString(),
    };
  } catch (error) {
    return {
      error: error.message,
    };
  }
};
```

**Need some help?** Check out these links 👇
Get an [**account balance**](https://docs.ethers.io/v5/api/providers/provider/#Provider-getBalance) using ethers  
Format the balance using [**ethers.utils.formatEther**](https://docs.ethers.io/v5/api/utils/display-logic/#unit-conversion)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
const getBalance = async (address: string) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);

    const balance = await provider.getBalance(address);
    if (!balance) {
      throw new Error('Please complete the code');
    }
    return {
      balance: balance.toString(),
    };
  } catch (error) {
    return {
      error: error.message,
    };
  }
};
```

**What happened in the code above?**

- We await `provider.getBalance` because it returns a Promise. That Promise returns a BigNumber, which is a specific data type for handling numbers which fall [outside the range of safe values](https://docs.ethers.io/v5/api/utils/bignumber/#BigNumber--notes-safenumbers) in JavaScript.
- Last but not least, to easy manipulate the returned type we convert it to string using `toString()` method.

---

# ✅ Make sure it works

When you have completed the code in `components/protocols/polygon/challenges/balance.ts`, the **Check Balance** button will function. Click it to view the balance of the connected Polygon account.

---

# 🏁 Conclusion

Now that we have an account that has been funded with **MATIC** tokens, we are ready to make a transfer to another account!

'''
'''--- markdown/polygon/GET_CONTRACT_VALUE.md ---
At this point, we have deployed a smart contract on the Polygon testnet & set the value of its storage. We have a client-side application that's ready to fetch some data from it. We just need to wire up that last part.

---

# 🏋️ Challenge

{% hint style="tip" %}
In the file `components/protocols/polygon/challenges/getter.ts`, implement the `getValue` function.  
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
const getValue = async (contractAddress: string) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    // try to figure out the expected parameters
    const contract = new ethers.Contract(undefined);
    // try to figure out the expected method
    const value = undefined;
    return {value};
  } catch (error) {
    return {
      error: error.message,
    };
  }
};
```

**Need some help?** Check out these links 👇

- [**Create a Contract using ethers**](https://docs.ethers.io/v5/api/contract/contract/#Contract--creating)
- [**How to call a contract's methods on a ethers Contract object**](https://docs.ethers.io/v5/api/contract/contract/#Contract-functionsCall)
- To read from the blockchain you don't need to spend any tokens so you can just use a provider to create a Contract instance. But to write you will need to create and sign a transaction through Metamask. Use a `signer` to create the Contract object!

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
const getValue = async (contractAddress: string) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    const contract = new ethers.Contract(
      contractAddress,
      SimpleStorageJson.abi,
      signer,
    );
    const value = await contract.get();
    return {value};
  } catch (error) {
    return {
      error: error.message,
    };
  }
};
```

**What happened in the code above?**

- We create `Contract` objects using
  - The contract address
  - The contract JSON's ABI
  - A web3 provider
- We then call the functions `get()` on this Contract object to operate our decentralized code. The names of the functions must match the ones we defined in our Solidity smart contract, otherwise how would we know which code to execute?

---

# ✅ Make sure it works

Once the code in `components/protocols/polygon/challenges/getter.ts` is complete, click on the **Get Value** button to fetch the data from the smart contract.

---

# 🏁 Conclusion

Now that we know how to interact with a smart contract we are going to learn how to restore an account from its mnemonic.

'''
'''--- markdown/polygon/PROJECT_SETUP.md ---
# 🦊 Install Metamask

Make sure you have the [Metamask](https://metamask.io/) browser extension installed!

---

# 🦺 Safety disclaimers

{% hint style="info" %}
If you **ALREADY** have Metamask installed and are using it for a hot wallet, we _**strongly recommend**_ creating an entirely new wallet in Metamask for the purposes of these tutorials. Figment Learn wants nothing to do with your personal keys. We do not want any accidents involving anybody's cryptocurrency! Again, you _must not continue_ until you take care of this.  
{% endhint %}

{% hint style="danger" %}
If you **DO NOT** already have Metamask installed, welcome to the wonderful world of Web 3!  
The first piece of advice we will give you is to make _absolutely sure that you write down the_ [**Secret Recovery Phrase**](https://community.metamask.io/t/what-is-a-secret-recovery-phrase-and-how-to-keep-your-crypto-wallet-secure/3440) that is generated during Metamask's initial setup. Do not store it in a digital format. Do not share it with anybody. Please do keep it accessible to yourself because you will be using it during the pathway.
{% endhint %}

---

# ⛓ Add the Mumbai testnet to Metamask

The first task is to connect to the Polygon Mumbai testnet by adding it to the list of RPC endpoints in Metamask. Click on the Fox head icon in your web browser to open the popup, and then follow this workflow to complete the process :

- Click on the current network at the top of the Metamask popup (by default is says "Ethereum Mainnet")
- Scroll down and click on "Custom RPC"
- Fill in the form:
  - Network Name: `Polygon Mumbai`
  - New RPC URL: `https://rpc-mumbai.maticvigil.com/`
  - Chain ID: `80001`
  - Currency Symbol: `MATIC`
  - Block Explorer URL : `https://mumbai.polygonscan.com`
- Double check the information, then click on the Save button.

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/polygon/add_mumbai.png)

We use the testnet for development before moving into production on the main network or "mainnet".

If you experience issues with the maticvigil.com endpoint, use one of the other endpoints listed at [https://docs.polygon.technology/docs/develop/network-details/network/](https://docs.polygon.technology/docs/develop/network-details/network/) - click on Mumbai-Testnet below the Network heading to view them.

---

# 🧩 DataHub API keys

If you wish to make use of the Pathway content using DataHub, you will need a DataHub account and a valid API key to access Polygon via DataHub's infrastructure. [Sign up for a DataHub account](https://datahub-beta.figment.io/signup) and verify your email address. Once you have logged in to DataHub, you will need to create a new app and select the Polygon protocol.

Click "Create New App":

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_1.png?raw=true)

Type in a name for your app, select the **Staging** environment, then click on the **Polygon** icon in the list of available protocols. \
Click "Create app" when you're finished:

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_2.png?raw=true)

You can now find your API key on the Overview tab of the app on the [**DataHub Dashboard**](https://datahub-beta.figment.io/apps):

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_3.png?raw=true)

To use your API key, you should copy the contents of the `.env.example` file located in the project root directory (`/learn-web3-dapp/.env.example`) into a new file named `.env.local` (`/learn-web3-dapp/.env.local`). Also, since this file will contain your API key, we have already added it to the `.gitignore`.

{% hint style="info" %}
Easily duplicate the file with the terminal command `cp .env.example .env.local`!
{% endhint %}

You can then paste your unique API key into `.env.local`, as the value for the environment variable `DATAHUB_POLYGON_API_KEY`. This will authenticate you and enable you to make requests to Polygon via DataHub. **The API key shown below is only an example and cannot be used to access DataHub**.

```yaml
# DataHub API keys
DATAHUB_AVALANCHE_API_KEY=
DATAHUB_CELO_API_KEY=
DATAHUB_NEAR_API_KEY=
DATAHUB_POLKADOT_API_KEY=
DATAHUB_POLYGON_API_KEY=e5f82e4d1e8f7add65aa849bb5313f3f
DATAHUB_SECRET_API_KEY=
DATAHUB_SOLANA_API_KEY=
DATAHUB_TEZOS_API_KEY=
```

---

# 👣 Next Steps

Once you have your Polygon API key saved in `/learn-web3-dapp/.env.local`, you're ready to begin.
Click on the **Next: Connect to Polygon** button below.

'''
'''--- markdown/polygon/QUERY_CHAIN.md ---
# 🧩 Ethers API Queries

In order to gather information from the blockchain, we will use ethers again. For basic interaction with Polygon, the [provider](https://docs.ethers.io/v5/api/providers/provider/) methods are often most useful.

---

# 🏋️ Challenge

{% hint style="tip" %}
**Imagine this scenario:** As the lead developer of a cool new dApp, you need to create a way to query information from the blockchain and then display it on the UI. In **`components/protocols/polygon/challenges/query.ts`**, assign values to the following variables : `chainId` , `blockHeight` , `gasPriceAsGwei` , `blockInfo`.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
//...
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const networkName = await provider.getNetwork().then(res => { return res.name })

    // TODO: Define the variables below
    const chainId = undefined;
    const blockHeight = undefined;
    const gasPriceAsGwei = undefined;
    const blockInfo = undefined;

    if (!chainId || !blockHeight || !gasPriceAsGwei || !blockInfo) {
      throw new Error('Please complete the code');
    }

    return {
      data: {
        networkName,
        chainId,
        blockHeight,
        gasPriceAsGwei,
        blockInfo,
      },
    };
  }
//...
```

**Need some help?** Check out these links 👇

- [Getting the network's chainId](https://ethereum.stackexchange.com/questions/82365/how-get-network-id-with-ethers-js)
- How to get a [block number (or block height) from ethers](https://docs.ethers.io/v5/api/providers/provider/#Provider-getBlockNumber)
- What is [gas price and gwei](https://gwei.io/)? And how to [get it from ethers](https://docs.ethers.io/v5/api/providers/provider/#Provider-getGasPrice)
- [Formatting units](https://docs.ethers.io/v5/api/utils/display-logic/#utils-formatUnits) from BigNumber to gwei

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const networkName = await provider.getNetwork().then((res) => {
      return res.name;
    });

    const chainId = provider.network.chainId;
    const blockHeight = await provider.getBlockNumber();
    const gasPriceAsGwei = await provider.getGasPrice().then((res) => {
      return ethers.utils.formatUnits(res, 'gwei');
    });
    const blockInfo = await provider.getBlockWithTransactions(blockHeight);

    if (!chainId || !blockHeight || !gasPriceAsGwei || !blockInfo) {
      throw new Error('Please complete the code');
    }

    return {
      data: {
        networkName,
        chainId,
        blockHeight,
        gasPriceAsGwei,
        blockInfo,
      },
    };
  }
//...
```

**What happened in the code above?**

- The `networkName` awaits `provider.getNetwork` because it returns a Promise, and then we will return the name property of the response object.
- We can get the `chainId` as a property of `provider.network`.
- `blockHeight` can be taken directly from the returned value of `getBlockNumber`
- `gasPriceAsGwei` gets the current gas price and then formats the value into a human-friendly number with the ethers utility function `formatUnits`.
- `blockInfo` must be a BlockWithTransactions type, which is what the function `getBlockWithTransactions` returns.

---

# ✅ Make sure it works

Once the code in `components/protocols/polygon/challenges/query.ts` is complete, click on **Query Polygon** to send a request to the network and display some important information contained in a recent block on the page.

---

# 🏁 Conclusion

Now that we have queried Polygon and retrieved information from the blockchain, we will want to get **MATIC** tokens into our wallet so we can pay the fees to deploy a smart contract. In the next tutorial, we will cover how to fund an account with **MATIC** through the official faucet.

'''
'''--- markdown/polygon/RESTORE_ACCOUNT.md ---
At the beginning of this journey into Polygon, we generated a mnemonic. Now we're going to learn how to restore a wallet from a mnemonic and how to derive the address and the private key when the wallet has been restored.

---

# 🏋️ Challenge

{% hint style="tip" %}
In the file `components/protocols/polygon/challenges/restore.ts`, implement the `restore` function. Using `ethers`, look for `Wallet`, then when the wallet has been regenerated try to deduce which property we're going to call in order to display the address, finally verify that the generated address matches the existing one.  
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
const restore = (mnemonic: string, address?: string) => {
  try {
    const wallet = undefined;
    if (wallet.address === address) {
      const restoredAddress = wallet.address;
      return {
        restoredAddress,
      };
    } else {
      return {error: 'Unable to restore account'};
    }
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return {error: errorMessage};
  }
};
```

Need some help? Check out these links 👇

- [**Create Wallet using ethers**](https://docs.ethers.io/v5/api/signer/#Wallet)
- [**Properties of a Wallet**](https://docs.ethers.io/v5/api/signer/#Wallet--properties)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```javascript
// solution
const restore = (mnemonic: string, address?: string) => {
  try {
    const wallet = ethers.Wallet.fromMnemonic(mnemonic.trim());
    if (wallet.address === address) {
      const restoredAddress = wallet.address;
      return {
        restoredAddress,
      };
    } else {
      return {error: 'Unable to restore account'};
    }
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return {error: errorMessage};
  }
};
```

**What happened in the code above?**

- First, we need to call `fromMnemonic` method of `Wallet` class.
- Next, we compare if the restored address matches the existing one.
- **IMPORTANT**: If you have selected any address in Metamask other than the first address, the if statement will be false.

---

# ✅ Make sure it works

When you have completed the code in `components/protocols/polygon/challenges/restore.ts`: Copy & paste your **mnemonic** then click on **Restore Account**.

---

# 🏁 Conclusion

Congratulations! We have gone from zero to **Polygon**, covering all the most fundamental concepts needed for developers to succeed in using **Polygon**. From connecting to the network to interacting with smart contracts, you have completed coding challenges and created a functional yet basic dApp.

'''
'''--- markdown/polygon/SET_CONTRACT_VALUE.md ---
At this point we have deployed a smart contract on the Polygon testnet and we have a client side application that's ready to interact with it. We just need to wire up the last part! We built a simple page on the last step to help you interact with the smart contract. Since the contract has only two methods (`set` and `get`) that's all the UI will do: set a number through the smart contract.

As simple as it sounds, what's happening in the background is actually very powerful: we're using the Polygon blockchain to store information (in this example, a number) and we're using a smart contract as an interface to read and write that information to the blockchain. What's crucial is that all this is happening without having to spin up a database and an API... So let's go!

---

# 🏋️ Challenge

{% hint style="tip" %}
In the file `components/protocols/polygon/challenges/setter.ts`, implement the `setValue` function.  
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
const setValue = async (contractAddress: string, value: number) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    // try to figure out the expected parameters
    const contract = new ethers.Contract(undefined);
    // try to figure out the expected method
    const transactionResult = undefined;
    const receipt = await transactionResult.wait();
    return {hash: receipt.transactionHash};
  } catch (error) {
    return {
      error: error.message,
    };
  }
};
```

Need some help? Check out these links 👇

- [**Create a Contract using ethers**](https://docs.ethers.io/v5/api/contract/contract/#Contract--creating)
- [**How to call a contract's methods on an ethers Contract object**](https://docs.ethers.io/v5/api/contract/contract/#Contract-functionsCall)
- To read from the blockchain you don't need to spend any tokens, so you can use a provider to create a Contract instance. Writing to the blockchain, you will need to create and sign a transaction through Metamask. Use a `signer` to create the Contract object!

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
const setValue = async (contractAddress: string, value: number) => {
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    const contract = new ethers.Contract(
      contractAddress,
      SimpleStorageJson.abi,
      signer,
    );
    const transactionResult = await contract.set(value, {gasLimit: 500000});
    const receipt = await transactionResult.wait();
    return {hash: receipt.transactionHash};
  } catch (error) {
    return {
      error: error.message,
    };
  }
};
```

**What happened in the code above?**

- We create Contract objects using
  - The contract address.
  - The contract JSON's ABI.
  - A signer, from the ethers web3 provider.
- We then call the function `set` on this Contract object to operate on our decentralized code. The names of the functions must match the ones we defined in our Solidity smart contract. These are available via the ABI.
- Note: Remember to add an override in the `set` contract call for the `gasLimit` to avoid an issue with transactions reverting!

---

# ✅ Make sure it works

Once the code in `components/protocols/polygon/challenges/setter.ts` is complete, you can enter a value into the textinput then click on **Set Value** to send the transaction and change the data stored in the smart contract.

---

# 🏁 Conclusion

Now that we've set the storage of our contract, we can read it. We're going to learn how to do this in the final tutorial of the pathway.

'''
'''--- markdown/polygon/TRANSFER_TOKEN.md ---
Transferring some token is one of the major feature of Web 3. In this challenge, we're going to learn how to transfer a known amount of **MATIC** to a chosen recipient. Each time a transfer occurs, we're going to re-query the new balance of our account.

---

# 🏋️ Challenge

{% hint style="tip" %}
**Imagine this scenario:** You know you have a big balance and you want to eat some pizza. Then, you need to transfer **0.1** MATIC to buy one! In `components/protocols/polygon/challenges/transfer.ts`, implement the `transfer` function.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
//...
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const send_account = provider.getSigner().getAddress();

    const currentGasPrice = await provider.getGasPrice();
    const gas_price = ethers.utils.hexlify(
      parseInt(currentGasPrice.toString()),
    );

    const transaction = undefined;

    const hash = undefined;
    const receipt = await hash.wait();
    return {hash: receipt.transactionHash};
  }
//...
```

**Need some help?** Check out these links 👇

- [**A short tutorial**](https://ethereum.org/en/developers/tutorials/send-token-etherjs/) on using ethers
- [**Send and sign a transaction**](https://docs.ethers.io/v5/api/signer/#Signer-sendTransaction)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
  try {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const send_account = provider.getSigner().getAddress();

    const currentGasPrice = await provider.getGasPrice();
    const gas_price = ethers.utils.hexlify(
      parseInt(currentGasPrice.toString()),
    );

    const transaction = {
      from: send_account,
      to: RECIPIENT,
      value: ethers.utils.parseEther(AMOUNT),
      nonce: provider.getTransactionCount(send_account, 'latest'),
      gasLimit: ethers.utils.hexlify(100000),
      gasPrice: gas_price,
    };
    const hash = await provider.getSigner().sendTransaction(transaction);
    const receipt = await hash.wait();
    return {hash: receipt.transactionHash};
  }
//...
```

**What happened in the code above?**

- First, we need to fill our transaction object with:
  - An address to send `from` (the sender).
  - An address to send `to` (the recipient).
  - The `value`, an amount which has been converted into a BigNumber (`ethers.utils.parseEther` is perfect for this)
  - A `nonce`, meaning "a number used once". This value is incremented by one for every transaction sent by an address.
  - A default `gasLimit`.
  - The current `gasPrice`.
- Finally we sign and send our transaction and wait for it to be confirmed.

---

# ✅ Make sure it works

Once the code in `components/protocols/polygon/challenges/transfer.ts` is complete, enter an amount to transfer and click **Transfer** to send tokens to another Polygon account.

---

# 🏁 Conclusion

Now that we have a funded Polygon account, we can use our MATIC tokens to deploy a smart contract. In the next tutorial we will cover writing, testing and deploying the Solidity code using Truffle which is a smart contract development suite.

'''
'''--- markdown/pyth/FINAL.md ---
🥳 **Congratulations**, you have completed the Pyth Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to Pyth on Solana
- ⁉️ Subscribing to changes in Pyth's price data
- 🏦 Implementing a wallet display
- 📈 Visualizing market data on a chart
- 💸 Swapping tokens on a DEX
- ⛓ Implementing the liquidation bot

# 🧐 Keep learning with these resources:

- 🏗 [Pyth official documentation](https://docs.pyth.network/)
- 🚀 [Publishing data to Pyth](https://docs.pyth.network/publishers/getting-started)
- 🧱 [Implementing Moving Averages in JavaScript](https://blog.oliverjumpertz.dev/the-moving-average-simple-and-exponential-theory-math-and-implementation-in-javascript)

# 🪢 Mixing price feeds in Rust

Using the [Rust client library](https://github.com/pyth-network/pyth-client-rs#pyth-client), it is possible to merge two existing products that do not already have an associated pair. There are many reasons you might want to do this, and luckily the code to accomplish it within a Solana program is rather simple using the `get_price_in_quote()` function:

```rust
let btc_usd: Price = ...;
let eth_usd: Price = ...;
// -8 is the desired exponent for the result
let btc_eth: PriceConf = btc_usd.get_price_in_quote(&eth_usd, -8);
println!(BTC/ETH price: ({} +- {}) x 10^{}", price.price, price.conf, price.expo)
```

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/pyth/PROJECT_SETUP.md ---
{% hint style="tip" %}
We recommend completing both the [Solana 101 pathway](https://learn.figment.io/protocols/solana) and [Build a Solana Wallet](https://learn.figment.io/pathways/solana-wallet) before continuing. A working knowledge of [React hooks](https://reactjs.org/docs/hooks-intro.html) and [TypeScript/JavaScript](https://www.typescriptlang.org/) is also recommended.
{% endhint %}

# 🦺 Important information for your safety

During this Pathway, we will provide you with an opportunity to use the Solana [mainnet-beta cluster](https://docs.solana.com/clusters#mainnet-beta) (hereafter referred to as "mainnet") to perform token swaps with [Jupiter](https://jup.ag), a liquidity aggregator for Solana - which means that **actual funds may be used**. This is **not** a requirement for completing the Pathway.

Be aware that during step 4 of the Pathway ("Wallet implementation"), we will explain how to identify & use the private keys of Solana keypairs. Solana keypairs can be created using the Solana CLI, or with the JavaScript API, or even by using a browser extension wallet such as [Phantom](https://phantom.app).

You should **never** share your private keys with anyone. The simplest and most secure approach to this issue is to create an keypair entirely for the purpose of the following tutorials. The wallet component used in several steps of the Pathway has a toggle switch between "Mock" and "Live". When the toggle is set to "Live", you will be able to provide a [private key](https://solana-labs.github.io/solana-web3.js/classes/Keypair.html). This private key is then kept in the local storage of your web browser, so that you do not need to enter it multiple times. If you are not already familiar with it, read more about [web browser local storage](https://blog.logrocket.com/localstorage-javascript-complete-guide/) to understand where and how this data is kept.

Before proceeding, it is extremely important for you to understand that **if you provide the private key of a Solana account containing mainnet SOL to the wallet component in the Pathway, you are _potentially_ risking the full amount of SOL in that account**. Essentially, whatever funds the liquidation bot has access to can be swapped at any time while the bot is running, without user intervention. This is the power of private keys.

# ♻️ A word on swaps

Because we are working with some fairly new technology, there are some gaps in functionality between the Solana devnet and mainnet. There is quite a large discrepancy in the price of USDC tokens between devnet and mainnet, which we will explain in more detail when it becomes relevant.

Note that in order to perform _any_ swaps on Solana mainnet using this project, you must:

- Own a funded account on mainnet containing an amount of SOL and the USDC SPL token.
- Be on Step 7, "Liquidation bot implementation".
- Toggle the wallet component from "Mock" to "Live", then copy and paste the private key of your funded account into the textinput of the **live** wallet component.
- Finally you can switch the wallet component from devnet to mainnet. This will present you with an alert, warning you that you're going live on mainnet with real economic exposure.

If this doesn't make sense yet, don't worry. This is just a heads up. It will make more sense in the context of the Pathway implementation 😁

---

# 🧑‍💻 Install the Pyth client

{% hint style="tip" %}
This Pathway will only cover use of `@pythnetwork/client`. There are also Rust-, Python-, and EVM-based clients. Refer to the [list of available client libraries](https://docs.pyth.network/consumers/client-libraries) in the Pyth documentation for more.
{% endhint %}

In order to use Pyth, you will need to install the TypeScript/JavaScript library for off-chain applications. It provides the tools to do things like displaying the Pyth price on a website. Whether you're using Gitpod or a local clone of the repo, the installation procedure is the same. Run the terminal command below inside the root directory of the project (`learn-web3-dapp/`) :

```text
yarn add @pythnetwork/client
```

---

# 👻 Install the Phantom wallet extension

Turn your favorite browser into a Web 3 enabled crypto wallet!

Go to <https://phantom.app> and click on the "Add to ..." button which will auto-detect your browser and redirect you to the appropriate extension page:

- Firefox: https://addons.mozilla.org/en-US/firefox/addon/phantom-app/
- Chrome / Brave / Edge: https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa?hl=en

Optionally, check out <https://phantom.app/security> to learn more about the security features of Phantom.

---

# 🧩 DataHub API keys

If you wish to make use of the Pathway content using DataHub, you will need a DataHub account and a valid API key to access Solana via DataHub's infrastructure. [Sign up for a DataHub account](https://datahub-beta.figment.io/signup) and verify your email address. Once you have logged in to DataHub, you will need to create a new app and select the Solana protocol (because Pyth uses Solana).

Click "Create New App":

![DataHub API keys Image 1](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_1.png?raw=true)

Type in a name for your app, select the **Staging** environment, then click on the **Pyth** icon in the list of available protocols. \
Click "Create app" when you're finished:

![DataHub API keys Image 2](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_2.png?raw=true)

You can now find your API key on the Overview tab of the app on the [**DataHub Dashboard**](https://datahub-beta.figment.io/apps):

![DataHub API keys Image 3](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_3.png?raw=true)

To use your API key, you should copy the contents of the `.env.example` file located in the project root directory (`/learn-web3-dapp/.env.example`) into a new file named `.env.local` (`/learn-web3-dapp/.env.local`). Also, since this file will contain your API key, we have already added it to the `.gitignore`.

{% hint style="info" %}
Easily duplicate the file with the terminal command `cp .env.example .env.local`!
{% endhint %}

You can then paste your unique API key into `.env.local`, as the value for the environment variable `DATAHUB_SOLANA_API_KEY`. This will authenticate you and enable you to make JSON-RPC requests to Solana via DataHub. **The API key shown below is only an example and cannot be used to access DataHub**.

```yaml
# DataHub API keys
DATAHUB_AVALANCHE_API_KEY=
DATAHUB_CELO_API_KEY=
DATAHUB_NEAR_API_KEY=
DATAHUB_POLKADOT_API_KEY=
DATAHUB_POLYGON_API_KEY=
DATAHUB_SECRET_API_KEY=
DATAHUB_SOLANA_API_KEY=81436edcf907b0fbb8493d281cdff5af
DATAHUB_TEZOS_API_KEY=
```

{% hint style="tip" %}
If the Next.js development server was running at the time you changed the environment variable's value, you will need to restart the Next.js server to make it aware of the new value. You can do this by pressing `Ctrl+C` in the terminal where the Next.js server is running, then restart it with the command `yarn dev`.
{% endhint %}

---

# 👣 Next Steps

Once you have your Solana API key saved in `/learn-web3-dapp/.env.local`, you're ready to begin! Click on the **Next: Connect to Pyth on Solana** button below.

'''
'''--- markdown/pyth/PYTH_CONNECT.md ---
# 🤨 What are we building, here?

Using price data from Pyth as the foundation, we are going to build a minimum viable product or "MVP" which supports automating the task of swapping between SOL and USDC tokens using a decentralized exchange or "DEX". The goal is to be able to buy when the price is low and sell when the price is high. There are several ways of referring to this functionality, but for the purposes of this Pathway we will refer to the MVP as a "liquidation bot".

To complete this project, we must implement the following:

- Connect to Pyth by subscribing to changes in the price data on Solana
- Display an account balance with the ability to switch between Solana clusters and accept a private key
- A chart component which accurately depicts the asset price
- Wire up an input for an expected yield and an amount to buy when a specific threshold of buy signals is reached
- The logic to determine when to send a swap transaction
- Wire it all together into a working set of components suitable for use

The purpose of this Pathway is to give you hands-on experience using Pyth by incorporating price data into a useful application. Unrelated to Pyth but still important, the rest of the components will strengthen your understanding of how to visualize market fluctuations on a chart and perform swaps on a DEX.

In essence the "bot" we are building is more like Wall-E than The Terminator. We're focused more on having fun and learning, than on ruthless efficiency.

![Wall-E and The Terminator](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/walle-terminator.jpg)

---

# 🧐 What is Pyth, anyway?

Smart contracts are isolated programs that automate the execution of tasks based on certain inputs. Sometimes those inputs occur off-chain. That means the smart contract needs a trusted way to determine that an input has occurred off-chain in order to execute actions on-chain. That service is provided by oracle protocols. These are a way to connect smart contracts to the outside world.

[Pyth](https://pyth.network) is an oracle protocol which allows publishers to include their price data for various asset pairs or _products_ on the [Solana](https://solana.com) blockchain. There are three sets of participants interacting with the Pyth protocol:

1. **Publishers** are first-party data providers who submit their asset pricing data to Pyth. Publishers are incentivized to publish accurate and timely prices by data staking and reward distribution mechanisms.
2. **Consumers** use the price data being aggregated by Pyth's on-chain program, optionally paying data fees to Delegators to promote accuracy of the price data.
3. **Delegators** stake tokens and earn data fees, and they can potentially lose their stake if the aggregate price data is inaccurate. Delegators are responsible for helping the Publishers to maximize the robustness of the price data.

The Pyth on-chain program maintains accounts on Solana which are responsible for tracking the products and their current price data. Pyth aims to make accurate, high-resolution financial market data easily accessible on Solana.

It is possible for consumers to interact with this data both on- and off-chain, depending on their needs. \
Pyth uses three types of account on Solana:

1. **Product** accounts store the metadata of a product such as its symbol and asset type.
2. **Price** accounts store the current price information of a product, including the symbol and **confidence interval**.
3. **Mapping** accounts maintain a linked list of other accounts - this allows applications to easily enumerate the full list of products served by Pyth.

The goal of Pyth's aggregation algorithm (say _that_ five times fast!) is to combine the prices reported by publishers, giving more weight to prices with a tighter confidence interval.
This helps consumers access more accurate price data, without worrying about a single publisher or even a small number of publishers moving the aggregate price by themselves.
Confidence weighting is necessary because publishers have different degrees of precision in their ability to observe a product. Another factor is that exchanges with more liquidity have tighter spreads than those with less liquidity.

{% hint style="info" %}
A spread can have several meanings in relation to finance. It often refers to the difference between two prices. The most common definition is the gap between the bid price and the ask price of an asset, the "bid-ask spread".
{% endhint %}

---

# ⛓ Consuming on-chain data

Pyth provides a few tools to consume the published data. We will use the [JavaScript client](https://github.com/pyth-network/pyth-client-js) `pyth-client-js` which we installed during the setup for this project. The client fetches the prices and returns JavaScript objects which are much easier to work with. It also enables us to listen for price updates which happen during each [slot](https://docs.solana.com/terminology#slot) on Solana (approximately every 400 _milliseconds_).

As you can probably guess, such a high frequency of updates will require some special handling.

---

# 🤑 Aggregate price

Aggregate means "formed or calculated by the combination of many separate units". When we refer to an "aggregate price" or "aggregate confidence interval" we mean that the information reported by Pyth is a combination of multiple data points. This is a good thing for consumers to be aware of, as it provides a clear opportunity to avoid the pitfall of acting on incorrect data. Don't just rely on the aggregate price as a true price when performing financial calculations, take the confidence interval and related factors into account.

---

# ⏰ Confidence interval

Pyth publishers must supply a confidence interval because in real markets, _there is no single price for a product_ - it is constantly changing based on market activity over time. This is especially true for cryptocurrency exchanges where assets can be trading at very different prices across exchanges.

A confidence **interval** is a range of values with an upper bound and a lower bound, computed at a particular confidence **level**.

Publishers who submit their price data to Pyth do not all use the same methods to determine their confidence in a given price. Because of the potential for a small number of publishers to influence the reported price of an asset, it is therefore important to use an _aggregate_ price. The confidence interval published on Pyth is also an aggregated value, based on the confidence being reported by Publishers. It is best practice for Publishers to provide high quality data. A confidence interval that is too low can lead to problems for consumers.

Pyth calculates the price and confidence intervals for all products on a constant basis. Any Publisher behind by 25 slots (approximately 10 seconds) is considered inactive and their prices are not included in the aggregate until they can catch up, which prevents stale data from being served.

{% hint style="tip" %}
"When consuming Pyth prices, we recommend using the confidence interval to protect your users from these unusual market conditions. The simplest way to do so is to use Pyth's confidence interval to compute a range in which the true price (probably) lies. You obtain this range by adding and subtracting a multiple of the confidence interval to the Pyth price; the bigger the multiple, the more likely the price lies within that range. \
We recommend considering a multiple of 3, which gives you a 99.7% probability that the true price is within the range (assuming normal distribution estimates are correct). Then, select the most conservative price within that range for every action. \
In other words, your protocol should _minimize state changes during times of large price uncertainty_." - Pyth [Best Practices](https://docs.pyth.network/consumers/best-practices)
{% endhint %}

---

# 🧠 Exponents

Not all price accounts maintain their data in floating point format. Sometimes it is necessary to use an exponent to convert price data from fixed-point to floating point. The readable price (including the decimal, i.e. 150.004731628) is calculated by taking the `price` field from a Pyth price account and multiplying it by `10^exponent`. This will be a negative exponent, which will move the decimal to the left. The exponent is included in the price data held within the price account for a given product.

The price, confidence interval and exponent will be displayed in the component on the right side of this page once you have completed the coding challenge and start the price feed.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `components/protocols/pyth/components/Connect.tsx`, implement `getPythData` by creating an instance of the `PythConnection` class and then registering the `onPriceChange` callback. You must replace the instances of `undefined` with working code to accomplish this. \
\
_We don't want you to be overwhelmed by price data for every available product, so we have narrowed it down to SOL/USD for the purposes of this tutorial._
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
const connection = new Connection(clusterApiUrl(SOLANA_NETWORKS.DEVNET));
const pythPublicKey = undefined;
const pythConnection = undefined;

const Connect = () => {
  // ...
  const getPythData = async (checked: boolean) => {
    undefined.onPriceChange((product, price) => {
      if (
        product.symbol === 'Crypto.SOL/USD' &&
        price.price &&
        price.confidence
      ) {
        // ...
    });
    // ...
  };
//...
```

**Need some help?** Check out these links & hints 👇

- [What are callback functions](https://www.freecodecamp.org/news/javascript-callback-functions-what-are-callbacks-in-js-and-how-to-use-them/) in JavaScript?
- There is a function for mapping Solana clusters to the public key of the Pyth program: `getPythProgramKeyForCluster`. \
  You'll need to supply the name of the Solana cluster you want to get Pyth data from (`mainnet-beta`, `devnet` or `testnet`).
  - To connect to Pyth, use the `PythConnection` class from `@pythnetwork/client` - You'll need to supply a JSON-RPC connection and a Pyth program public key. Seasoned developers may wish to [dive into the code](https://github.com/pyth-network/pyth-client-js/blob/3de72323598131d6d14a9dc9f48f5f225b5fbfd2/src/PythConnection.ts#L29) to see what it's doing.

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
const connection = new Connection(clusterApiUrl(SOLANA_NETWORKS.DEVNET));
const pythPublicKey = getPythProgramKeyForCluster(PYTH_NETWORKS.DEVNET);
const pythConnection = new PythConnection(connection, pythPublicKey);

const Connect = () => {
  // ...
  const getPythData = async (checked: boolean) => {
    pythConnection.onPriceChange((product, price) => {
      if (
        product.symbol === 'Crypto.SOL/USD' &&
        price.price &&
        price.confidence
      ) {
        console.log(
          `${product.symbol}: $${price.price} \xB1$${price.confidence}`,
        );
        setPrice(price.price);
        setSymbol('Crypto.SOL/USD');
      } else if (product.symbol === 'Crypto.SOL/USD' && !price.price) {
        console.log(`${product.symbol}: price currently unavailable`);
        setPrice(0);
        setSymbol('Crypto.SOL/USD');
      }
    });

    if (!checked) {
      message.info('Stopping feed!');
      pythConnection.stop();
    } else {
      message.info('Starting feed!');
      pythConnection.start();
    }
  };
};
//...
```

**What happened in the code above?**

- We created a `connection` instance of the `Connection` class using the `new` constructor, and passing the function `clusterApiUrl` which returns the RPC endpoint URL of the given Solana cluster. `SOLANA_NETWORKS.DEVNET` is a constant defined in the file `types/index.ts`. Slightly more verbose than supplying the string "devnet", though it is more readable and in this way we are not hard-coding the value.
- We're passing the `checked` boolean to the `getPythData` function to operate starting/stopping the price feed using the antd toggle component.
- After registering the `onPriceChange` callback on the `pythConnection`, we can perform any actions necessary for our app to function. Using conditional statements to change the behavior of the app depending on the product symbol, price or confidence interval.
- The `onPriceChange` callback will be invoked every time a Pyth price gets updated. This callback gets two arguments:
  - `price` contains the official Pyth price and confidence, along with the component prices that were combined to produce this result.
  - `product` contains metadata about the price feed, such as the symbol (e.g., "Crypto.SOL/USD") and the number of decimal points.
- Once you've set up the connection and the `onPriceChange` callback, you'll be able to tap into the price feed with a simple `pythConnection.start()`! \
  We have set up an easy to use component here to toggle it on and off, but in production you would probably want to handle this a little bit differently.
- `\xB1` is the escaped Hex code for the Unicode character `±`, "plus or minus" - indicating the following value is the confidence interval.
- We need to provide a way to stop listening to the price feed, in this case when the toggle switch component is turned off it will call `pythConnection.stop()`, removing the callback.

{% hint style="info" %}
If you are interested in seeing the breakdown of the aggregated data, it is available on the `priceComponents` property of the `price` object.
{% endhint %}

---

# ✅ Make sure it works

Once you've made the necessary changes to `components/protocols/pyth/components/Connect.tsx` and saved the file, click on the toggle switch labeled "Pyth" on the right side of the screen to connect to Pyth & display the current price of the SOL/USD product! Be aware that the queries are being put through a public endpoint and are therefore subject to rate and data limiting. If you leave this price feed running for a while (~30 minutes), you will run out of requests and the feed will stop updating. **Remember to switch it off before moving to the next step!**

---

# 🏁 Conclusion

We established a connection to the Pyth price feed on Solana using the JavaScript Pyth client. The connection can be regulated by listening to the price feed using a callback function and removing that callback when we want to stop listening.
We also discussed three key concepts involved in price data: Aggregate price, confidence interval, and the exponent used to convert price data from fixed-point to floating point.

If you'd like, take a few minutes to learn more about how Pyth's [account structure](https://docs.pyth.network/how-pyth-works/account-structure) & [price aggregation](https://docs.pyth.network/how-pyth-works/price-aggregation) work by reviewing the official documentation.

If you are interested in the specifics, check out the [Pyth whitepaper](https://s3.us-east-2.amazonaws.com/pyth.whitepaper/whitepaper.pdf) which explains how the protocol operates.

'''
'''--- markdown/pyth/PYTH_EXCHANGE.md ---
Before we start working on making swaps with actual tokens on the Solana devnet, we're going to create a mock implementation as a starting point. For this implementation, we will also link the buy & sell orders to a manual button press for testing.

Then we're going to work with some additional code libraries to perform token swaps on a Solana based DEX. This is where we will be able to swap our SOL for some USDC using the Orca pools on devnet so that we can begin using the liquidation bot (without risking any real funds). We'll go over the `OrcaSwapClient` which will be used to swap SOL for SPL tokens.

On mainnet, we have access to the more powerful Jupiter SDK where we can swap directly without needing to keep track of intermediate pairs. Again, the mainnet enabled code is primarily for illustration and should not be used without proper testing and understanding the inherent risks.

---

# 🧱 Adding orders to the order book

We went over the `addMockOrder` and `addDevnetOrder` functions in `components/protocols/pyth/lib/wallet.tsx` in a previous step. With a mock transaction, we use the Jupiter SDK to ensure the prices we're getting are indicative of mainnet. We are also passing in an `Order` object and getting back a `SwapResult`, but no swap is actually performed. The returned `txIds` array contains the identifier "**mockTransaction\_**" and a 6-digit random number. As part of the `addMockOrder` function, we also update the mock wallet balances.

`addOrder` will use the appropriate function to put the order into the order book.

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
const addOrder = useCallback(
  async (order: Order) => {
    console.log('addOrder', useLive, order, cluster);
    let result: SwapResult;
    switch (true) {
      case useLive && cluster === 'mainnet-beta': {
        result = await addMainnetOrder(order);
        break;
      }
      case useLive && cluster === 'devnet': {
        result = await addDevnetOrder(order);
        break;
      }
      case !useLive:
      default: {
        result = await addMockOrder(order);
      }
    }
    const extendedOrder: Order & SwapResult = {...order, ...result};
    setOrderbook((_orderBook) => [extendedOrder, ..._orderBook]);

    mutate(); // Refresh balance.
  },
  [useLive, cluster, keyPair, devnetToMainnetPriceRatioRef],
);
// ...
```

# 🪂 Getting an airdrop on Solana devnet

If you already know how to fund your wallet with an airdrop, go ahead and get some SOL. More is better, but make sure to have at least 2 SOL for testing the liquidation bot.

At this point you will need to acquire some SOL to perform swaps on devnet. The simplest way to do this is by visiting [solfaucet.com](https://solfaucet.com/). Copy the public key of your keypair, and paste it into the textarea on the faucet site. Click on the "Devnet" button and in a few seconds, you will have some SOL to play with on devnet.

{% hint style="tip" %}
You can airdrop **a maximum of 2 SOL per request** using this method. Larger amounts will simply not work, if you view the transaction on the block explorer, you will see a Memo written to the blockchain that says (for example): `request too large; req: ◎10, cap: ◎2`.
{% endhint %}

![SolFaucet Example](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/sol_faucet.png?raw=true)

---

# 🎠 Playground time

Take a few minutes and get comfortable with the mock swap process. Just switch the wallet over to "Mock", then click "Reset Wallet" to return the balances to their default amounts of 10 SOL and 1,400 USDC. You can then click on the **SOL -> ORCA** button located just above the Order book to perform a single trade, based on the best available route reported by Jupiter. Notice that the Transaction link is displayed as "mockT", and does not link to a valid transaction on solscan.io.

Switch to the Live wallet, then swap some tokens around on devnet! If you don't have some ORCA in your devnet wallet before starting up the bot in the next step, it won't like the fact that you're trying to swap the entire amount of ORCA in your initial swap. Also keep in mind that the token values on the devnet Orca pools are a little out of line with the mainnet values, and you'll notice that some swaps can fail due to an insufficient USDC balance. To prevent this from being an issue, we're catching the errors and displaying failed swaps on the order book.

The way we've tuned the liquidation bot is actually based on the mainnet token values, so don't be alarmed if there are some failed swaps. It's a great way to learn about how the swaps work behind the scenes if you care to dig into it, but we'll leave out those details so that you don't get overwhelmed.

---

# 🧱 Building the Exchange component

Two files to be aware of here: The Exchange component `components/protocols/pyth/components/Exchange.tsx` which is being rendered on the right side of the screen and the helper code for performing swaps on devnet or mainnet, located in `components/protocols/pyth/lib/swap.ts`.

You'll notice that we have only included the wallet and the order book for this step. We've removed the chart component for now, but it will come back in the next step when we bring everything together!

# 🚚 Importing dependencies

We went over imports earlier in the pathway, the only new ones to be aware of here are the Orca and Jupiter SDKs.

- [`@orca-so/sdk`](https://github.com/orca-so/typescript-sdk#orca-typescript-sdk) the Orca SDK enables us to create our `OrcaSwapClient`
- [`@jup-ag/core`](https://docs.jup.ag/jupiter-core/using-jupiter-core#usage) the Jupiter SDK enables us to create our `JupiterSwapClient`

```typescript
// components/protocols/pyth/lib/swap.ts

import {Cluster, Connection, Keypair, PublicKey} from '@solana/web3.js';
import {getOrca, OrcaPoolConfig, Network} from '@orca-so/sdk';
import {Jupiter, RouteInfo, TOKEN_LIST_URL} from '@jup-ag/core';
```

---

# 🏦 Associated Token Accounts

Working with SPL tokens on Solana can be a little intimidating at first, but we'll quickly go over the fundamentals so you're up to speed. You can get more details from the [Solana docs on the topic](https://spl.solana.com/associated-token-account) if you're interested. This process is handled transparently by the Orca and Jupiter SDKs when swapping tokens.

An Associated Token Account ("ATA") is an account owned by the SPL Token Program, associated with your public key. It is where SPL tokens of a specific mint address are stored and the balances can be viewed on most Solana block explorers. [solscan.io](https://solscan.io) has a tab on the account display page which will list your owned token balances.

Without going into too much detail, an ATA is required for Solana users to hold SPL tokens. The address of the Token Account can be derived from a public key and the mint address of the token. All we're doing here is illustrating the process using a couple of `Token` class methods: `getAssociatedTokenAddress` and `createAssociatedTokenAccountInstruction`. You don't need to read the code block below unless you want to see how those functions are being used. The [Solana Cookbook](https://solanacookbook.com) is a useful resource for code snippets related to SPL tokens.

`transactionSolscan` is just a helper function we've provided to easily turn a transaction signature (or "hash") into a usable link to the solscan.io block explorer. You can find it in `components/protocols/pyth/lib/index.ts`.

```typescript
// components/protocols/pyth/lib/swap.ts

// ...
  async makeATA(mintPubkey: PublicKey) {
    let ata = await Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID, // always ASSOCIATED_TOKEN_PROGRAM_ID
      TOKEN_PROGRAM_ID, // always TOKEN_PROGRAM_ID
      mintPubkey, // mint PublicKey
      this.keypair.publicKey, // owner
    );
    let tx = new Transaction().add(
      Token.createAssociatedTokenAccountInstruction(
        ASSOCIATED_TOKEN_PROGRAM_ID, // always ASSOCIATED_TOKEN_PROGRAM_ID
        TOKEN_PROGRAM_ID, // always TOKEN_PROGRAM_ID
        mintPubkey, // mint
        ata, // ata
        this.keypair.publicKey, // owner of token account
        this.keypair.publicKey, // fee payer
      ),
    );
    console.log(`ATA for ${mintPubkey}: ${ata.toBase58()}`);
    const txHash = await this.connection.sendTransaction(tx, [this.keypair]);
    return `${transactionSolscan('devnet', txHash)}` as String;
  }
// ...
```

---

# 🎁 Wrapping SOL

Wrapped SOL ("wSOL") is an SPL token. Sometimes it is necessary to be able to swap between SOL and other SPL tokens. We'll need an ATA for wSOL to be able to send this transaction. In most cases, the creation of this ATA is handled behind the scenes but we're exposing it here for your learning. The "Sync Native" instruction being sent to the SPL Token Program is what keeps the wSOL balance synced with the SOL balance of the ATA. You can pass an amount and the public key of the ATA to send the SOL to as the parameters.

As you can see, we are simply creating a transaction by adding instructions to the System Program and the SPL Token program. The function returns a solscan.io URL for the transaction so that details are at your fingertips.

Also, when sending the transaction you must pass an array containing the signing keypairs. The reason you're seeing `this.keypair` is because the `wrapSOL` method exists inside of the `OrcaSwapClient` class.

```typescript
// components/protocols/pyth/lib/swap.ts

  async wrapSOL(amount: number, ata: PublicKey) {
    let tx = new Transaction().add(
      // Transfer SOL
      SystemProgram.transfer({
        fromPubkey: this.keypair.publicKey,
        toPubkey: ata,
        lamports: amount,
      }),
      new TransactionInstruction({
        keys: [
          {
            pubkey: ata,
            isSigner: false,
            isWritable: true,
          },
        ],
        data: Buffer.from(new Uint8Array([17])),
        programId: TOKEN_PROGRAM_ID,
      }),
    );
    const txHash = await this.connection.sendTransaction(tx, [
      this.keypair,
      this.keypair,
    ]);
    return `${transactionSolscan('mainnet-beta', txHash)}` as String;
  }
```

---

# 📈 Buy & Sell Orders

We need to define what an Order looks like so that we can work with it in code. This is a data type which contains information about an order, including the tokens being swapped and the size of the order. This interface is defined in `components/protocols/pyth/lib/wallet.ts`.

```typescript
// components/protocols/pyth/lib/wallet.ts

// Define the interface for an Order
interface Order {
  side: 'buy' | 'sell';
  size: number;
  price: number;
  fromToken: string;
  toToken: string;
}
```

To tie it together, we need to define the interface for SPL Tokens as well as our own SwapResult. This `TokenI` interface is for mainnet swaps using Jupiter.

```typescript
// components/protocols/pyth/lib/swap.ts

// Token interface
export interface TokenI {
  chainId: number; // 101,
  address: string; // '8f9s1sUmzUbVZMoMh6bufMueYH1u4BJSM57RCEvuVmFp',
  symbol: string; // 'TRUE',
  name: string; // 'TrueSight',
  decimals: number; // 9,
  logoURI: string; // 'https://i.ibb.co/pKTWrwP/true.jpg',
  tags: string[]; // [ 'utility-token', 'capital-token' ]
}

// SwapResult interface
export interface SwapResult {
  inAmount: number;
  outAmount: number;
  txIds: string[];
  error?: any;
  timestamp: number; // Unix timestamp
}
```

We also need to keep track of the total worth of our assets based on the current market price, the React `useState` hook is an natural choice for this. We will also set up some more app state to handle the details of the orders. This is occurring in the `Exchange` component being displayed on the right side of the page:

```typescript
// components/protocols/pyth/components/Exchange.tsx

// State for tracking user worth with current Market Price.
const [worth, setWorth] = useState({initial: 0, current: 0});

// yieldExpectation is the amount of EMA to trigger buy/sell signals
const [yieldExpectation, setYield] = useState<number>(0.001);
const [orderSize, setOrderSize] = useState<number>(20); // USDC
const [price, setPrice] = useState<number | undefined>(undefined);
const [symbol, setSymbol] = useState<string | undefined>(undefined);
const [orderBook, setOrderbook] = useState<Order[]>([]);
```

Take a look at how we can update the current worth:

```typescript
// components/protocols/pyth/components/Exchange.tsx

useEffect(() => {
  // Update the current worth each price update.
  const currentWorth = wallet?.sol_balance * price! + wallet.usdc_balance;
  setWorth({...worth, current: currentWorth});
}, [price, orderSizeUSDC, setPrice]);
```

Let's break down the `OrcaSwapClient` to understand what's actually happening on Solana devnet when an order is executed:

```typescript
// components/protocols/pyth/lib/swap.ts
export class OrcaSwapClient {
  constructor(
    public readonly keypair: Keypair,
    public readonly connection: Connection,
  ) {}
```

The class constructor defines the `Keypair` and `Connection` as both _public_ and _readonly_ - this means we can trust that this data isn't being altered midway through the function. It's a mix of best practices and defensive programming 😉.

```typescript
// components/protocola/pyth/lib/swap.ts

  /**
   * @param size The amount of token to swap;
   * @returns TxIds, inAmount, outAmount
   */
  async sell(size: number): Promise<SwapResult> {
    const orca = getOrca(this.connection, Network.DEVNET);
    const orcaSOLPool = orca.getPool(OrcaPoolConfig.ORCA_SOL);
    const solToken = orcaSOLPool.getTokenB();
    const solAmount = new Decimal(size);
    const orcaUSDCPool = orca.getPool(OrcaPoolConfig.ORCA_USDC);
    const orcaToken = orcaSOLPool.getTokenA();
    const usdcToken = orcaUSDCPool.getTokenB();
    // Setting slippage lower is not recommended as it can cause swaps to fail
    const slippage = new Decimal(5.0);

    // Swap SOL -> ORCA
    const quote1 = await orcaSOLPool.getQuote(solToken, solAmount, slippage);
    const orcaQuoteAmount = quote1.getMinOutputAmount();
    console.log(
      `Swap ${solAmount.toString()} SOL for at least ${orcaQuoteAmount.toNumber()} ORCA`,
    );
    const swapPayload = await orcaSOLPool.swap(
      this.keypair,
      solToken,
      solAmount,
      orcaQuoteAmount,
    );
    const swap1TxId = await swapPayload.execute();

    // Swap ORCA -> USDC
    const quote2 = await orcaUSDCPool.getQuote(
      orcaToken,
      orcaQuoteAmount,
      slippage,
    );
    const usdcQuoteAmount = quote2.getMinOutputAmount();
    console.log(
      `Swap ${orcaQuoteAmount.toNumber()} ORCA for at least ${usdcQuoteAmount.toNumber()} USDC`,
    );
    const swap2Payload = await orcaUSDCPool.swap(
      this.keypair,
      orcaToken,
      orcaQuoteAmount,
      usdcQuoteAmount,
    );
    const swap2TxId = await swap2Payload.execute();

    return {
      txIds: [swap1TxId, swap2TxId],
      inAmount: solAmount.toNumber() * SOL_DECIMAL,
      outAmount: usdcQuoteAmount.toNumber() * USDC_DECIMAL,
    } as SwapResult;
  }
```

The `buy` and `sell` methods are quite similar - taking a `size` parameter. In both cases, we start by getting an instance of the Orca SDK with the `getOrca` method, which gives us access to the `getPool` method. From there, we can use the `getTokenB` method to be sure we're passing the correct mint address for the SOL token to the `getQuote` method (keep in mind that `getQuote` is asynchronous and returns a Promise, so we need to `await` the result).
It's important to get a minimum output amount for the quoted swap. So important in fact, there is a specific method to do just that: `getMinOutputAmount` returns the smallest amount of ORCA tokens that the user will recieve for the quoted swap, and in the case that the swap produces less than this amount the transaction will revert. This protects the user from sudden changes in liquidity and slippage. These are advanced topics we won't dive into here, but this particular pattern is quite easy to implement with the Orca SDK. Just remember to program defensively and keep your users in mind 😀.

We can now supply all the necessary parameters to the `swap` method on the Pool instance. The [type definitions](https://github.com/orca-so/typescript-sdk/blob/d231754ef33d21b6a60858996cd93450807f61f3/src/public/pools/types.ts#L91) tell us what we need to know about this method. It will "Perform a swap from the input type to the other token in the pool. Fee for the transaction will be paid by the owner's wallet." The `swap` returns the transaction signature of the swap instruction. This can be sent to the Solana cluster for processing [via the `execute` method from the Orca SDK's `TransactionPayload` type](https://github.com/orca-so/typescript-sdk/blob/d231754ef33d21b6a60858996cd93450807f61f3/src/public/utils/models/instruction.ts#L25).
Both `buy` and `sell` return the same values: The transaction IDs of both swaps to and from ORCA tokens contained in an array, and the amount of tokens in and out.

Let's also break down the `JupiterSwapClient` to understand what's happening on Solana mainnet when an order is executed:

```typescript
// components/protocols/pyth/lib/swap.ts

export class JupiterSwapClient {
  private jupiter: Jupiter;

  constructor(
    jupiter: Jupiter,
    public readonly tokenA: Token,
    public readonly tokenB: Token,
    public readonly keypair: Keypair,
  ) {
    this.jupiter = jupiter;
  }
```

The class constructor defines the `Token` and `Connection` instances as both _public_ and _readonly_. This means we can trust that this data isn't being altered midway through the function. It's a mix of best practices and defensive programming 😉. The `jupiter` instance is set as private in the upper scope.

```typescript
// components/protocols/pyth/lib/swap.ts

  static async initialize(
    connection: Connection,
    cluster: Cluster,
    keypair: Keypair,
    tokenAMintAddress: String, // Token to buy
    tokenBMintAddress: String, // token to sell
  ) {
    const jupiter = await Jupiter.load({connection, cluster, user: keypair});
    const tokens: Token[] = await (await fetch(TOKEN_LIST_URL[cluster])).json(); // Fetch token list from Jupiter API
    const inputToken = tokens.find((t) => t.address == tokenAMintAddress); // Buy token
    const outputToken = tokens.find((t) => t.address == tokenBMintAddress); // Sell token
    console.log('Input token:', inputToken);
    console.log('Output token:', outputToken);
    console.log('Keypair:', keypair);
    console.log(connection, cluster);
    if (!inputToken || !outputToken) {
      throw new Error('Token not found');
    }

    return new JupiterSwapClient(jupiter, inputToken, outputToken, keypair);
  }
```

The `initialize` function sets up the connection to Jupiter using the `load` method from the Jupiter SDK. It also gets the token list for the Solana cluster we're using (mainnet in this case). We've included the console logging so you can take a look at the public keys and inspect the keypair if you want to. We'll return an instance of the `JupiterSwapClient` containing the initialized values.

Next, let's have a look at the `getRoutes` method, which is responsible for determining the best route across multiple DEXes to perform the token swap for the given amount of the `inputToken`. As you can see we're using the `computeRoutes` method from the Jupiter SDK, passing it the token addresses, the input amount in Lamports, a value for slippage and a boolean value for `shouldFetchRoutes`. The best quote is logged at the end, with the entire `routes` object being returned. The `routesInfos` array contans all of the possible routes aggregated by Jupiter. Pretty awesome 😎!

```typescript
// components/protocols/pyth/lib/swap.ts

  async getRoutes({
    inputToken,
    outputToken,
    inputAmount,
    slippage,
  }: {
    inputToken?: Token;
    outputToken?: Token;
    inputAmount: number;
    slippage: number;
  }) {
    if (!inputToken || !outputToken) {
      return null;
    }

    console.log('Getting routes');
    const inputAmountLamports = inputToken
      ? Math.round(inputAmount * 10 ** inputToken.decimals)
      : 0; // Lamports based on token decimals
    const routes =
      inputToken && outputToken
        ? await this.jupiter.computeRoutes(
            new PublicKey(inputToken.address),
            new PublicKey(outputToken.address),
            inputAmountLamports,
            slippage,
            true,
          )
        : null;

    if (routes && routes.routesInfos) {
      console.log('Possible number of routes:', routes.routesInfos.length);
      console.log('Best quote: ', routes.routesInfos[0].outAmount);
      return routes;
    } else {
      return null;
    }
  }
```

Next we have the `buy` and `sell` methods which leverage `getRoutes` and then return the value of the `executeSwap` method:

```typescript
// components/protocols/pyth/lib/swap.ts

  // USDC -> SOL
  async buy(size: number) {
    const routes = await this.getRoutes({
      inputToken: this.tokenB, // USDC
      outputToken: this.tokenA, // SOL
      inputAmount: size, // 1 unit in UI
      slippage: 1, // 1% slippage
    });
    console.log('Routes:', routes);
    if (routes?.routesInfos) {
      console.log('Best Route', routes.routesInfos[0]);
      return this.executeSwap(routes?.routesInfos[0]);
    } else {
      throw new Error('Route not found');
    }
  }
  // SOL -> USDC
  async sell(size: number) {
    const routes = await this.getRoutes({
      inputToken: this.tokenA,
      outputToken: this.tokenB,
      inputAmount: size, // 1 unit in UI
      slippage: 1, // 1% slippage
    });
    if (routes?.routesInfos) {
      console.log('Best Route', routes.routesInfos[0]);
      return this.executeSwap(routes?.routesInfos[0]);
    } else {
      throw new Error('Route not found');
    }
  }
```

The `executeSwap` method is the last piece of functionality we need to make our swaps. It's essentially just a wrapper for the Jupiter `exchange` method with some additional logging:

```typescript
// components/protocols/pyth/lib/swap.ts
  async executeSwap(route: RouteInfo) {
    // Prepare execute exchange
    const {execute} = await this.jupiter.exchange({
      route,
    });
    // Execute swap
    const swapResult: any = await execute(); // Force any to ignore TS misidentifying SwapResult type

    if (swapResult.error) {
      console.log(swapResult.error);
      return {...swapResult, txIds: [swapResult.txId]}; // fit the swapResult interface
    } else {
      console.log(`https://explorer.solana.com/tx/${swapResult.txid}`);
      console.log(
        `inputAddress=${swapResult.inputAddress.toString()} outputAddress=${swapResult.outputAddress.toString()}`,
      );
      console.log(
        `inputAmount=${swapResult.inputAmount} outputAmount=${swapResult.outputAmount}`,
      );
    }
    return {
      txIds: [swapResult.txid],
      inAmount: swapResult.inputAmount,
      outAmount: swapResult.outputAmount,
    };
  }
```

---

# 🧪 Testing individual buy and sell orders

We've encapsulated the indvidual buy and sell buttons into their own component, which is included in `components/protocols/pyth/components/Exchange.tsx`. This functional component passes the `Order` object to the `addOrder` function in the `onClick` property of each button, and has default placeholder values but will accept the updated values based on the inputs thanks to `onChange`.

{% hint style="tip" %}
Remember to swap some SOL for ORCA before you start the liquidation bot!
{% endhint %}

```tsx
// components/protocols/pyth/components/Exchange.tsx

const BuySellControllers: React.FC<{addOrder: (order: Order) => void}> = ({
  addOrder,
}) => {
  const [buySize, setBuySize] = useState<number>(0.01);
  const [sellSize, setSellSize] = useState<number>(0.1);
  const [sellSOLToOrcaSize, setSellSOLToOrcaSize] = useState<number>(0.1);
  const [sellOrcaToSOLSize, setSellOrcaToSOLSize] = useState<number>(0.1);
  return (
    <Card bordered={false}>
      <Row>
        <Col span={10}>
          <Input.Group compact>
            <InputNumber
              step={0.1}
              min={0}
              value={sellSOLToOrcaSize}
              onChange={(val) => setSellSOLToOrcaSize(val)}
            />
            <Button
              type="primary"
              onClick={() =>
                addOrder({
                  side: 'sell',
                  size: sellSOLToOrcaSize,
                  fromToken: 'SOL',
                  toToken: 'ORCA',
                })
              }
            >
              SOL -&gt; ORCA
            </Button>
          </Input.Group>
        </Col>
      </Row>
      <Row>
        <Col span={10}>
          <br />
          <Input.Group compact>
            <InputNumber
              step={0.1}
              min={0}
              value={sellSize}
              onChange={(val) => setSellSize(val)}
            />
            <Button
              type="primary"
              onClick={() =>
                addOrder({
                  side: 'sell',
                  size: sellSize,
                  fromToken: 'SOL',
                  toToken: 'USDC',
                })
              }
            >
              SOL -&gt; USDC
            </Button>
          </Input.Group>
        </Col>
      </Row>
      <Row>
        <Col span={10}>
          <br />
          <Input.Group compact>
            <InputNumber
              step={0.1}
              min={0}
              value={buySize}
              onChange={(val) => setBuySize(val)}
            />
            <Button
              type="primary"
              onClick={() =>
                addOrder({
                  side: 'buy',
                  size: buySize,
                  fromToken: 'USDC',
                  toToken: 'SOL',
                })
              }
            >
              USDC -&gt; SOL
            </Button>
          </Input.Group>
        </Col>
      </Row>
      <br />
      <Row>
        <Col span={10}>
          <Input.Group compact>
            <InputNumber
              step={0.1}
              min={0}
              value={sellOrcaToSOLSize}
              onChange={(val) => setSellOrcaToSOLSize(val)}
            />
            <Button
              type="primary"
              onClick={() =>
                addOrder({
                  side: 'buy',
                  size: sellOrcaToSOLSize,
                  fromToken: 'ORCA',
                  toToken: 'SOL',
                })
              }
            >
              ORCA -&gt; SOL
            </Button>
          </Input.Group>
        </Col>
      </Row>
    </Card>
  );
};
```

---

# 📖 The order book

The order book is necessary to keep track of the buy and sell orders we're going to be generating. When the liquidation bot is running, orders will be happening frequently. Luckily for us, antd has a flexible table component with built in pagination so we don't even need to program that part ourselves.

Before doing this on devnet, give it a try using the mock wallet! You'll be able to see the details of an order:

- The Transactions column will contain links to view the actual swap transactions on the [solscan.io](https://solscan.io) block explorer
- "Side" indicates whether the order was a buy or sell
- You can easily interpret the outgoing and incoming tokens and amounts

![The Order Book](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/order_book.png?raw=true)

You might notice there's a discrepancy in the devnet token values. This is unfortunately beyond our control. The mock swaps and mainnet swaps use the true values from Jupiter.

Let's take a quick look at the Table in the return value of `components/protocols/pyth/components/Exchange.tsx` to better understand how the order book is being rendered. The antd Table component takes an _array of objects_ for the `columns`, each of these objects has a `title`, `dataIndex` and `key` - optionally we can use the `render` method to add whatever additional React fragments we need, for example: Mapping the transaction IDs to a link pointing to the correct page on solscan.io, or changing the color of the tags we use to display the amounts.

{% hint style="info" %}
Remember to wrap the return values here in [React fragments](https://reactjs.org/docs/fragments.html) (`<> </>`) to avoid trouble with rendering, since they're being rendered within an existing `<div>`!
{% endhint %}

```tsx
// components/protocols/pyth/components/Exchange.tsx

// ...
<Table
  key="book"
  rowKey={(order: Order & SwapResult) =>
    `order-${order.timestamp}-${order?.txIds.join('-')}`
  }
  dataSource={orderBook}
  columns={[
    {
      title: 'Transactions',
      dataIndex: 'txIds',
      key: 'txIds',
      render: (txIds, record) => {
        if (txIds.length === 0) {
          const errorMsg = record?.error.logs
            .find((l: string) => l.startsWith('Program log: Error'))
            .replace('Program log: Error: ', ''); // make the error short.
          return (
            <>
              <Tag color={'red'}>Failed</Tag>
              <span>{errorMsg}</span>
            </>
          );
        }
        return (
          <>
            {txIds.map((txId: string) => (
              <a
                // @ts-ignore
                href={`https://solscan.io/tx/${txId}?cluster=${cluster}`}
                key={txId}
                target={'_blank'}
                rel="noreferrer"
              >
                {txId?.substring(-1, 8)}
                <br />
              </a>
            ))}
          </>
        );
      },
    },
    {
      title: 'Side',
      dataIndex: 'side',
      key: 'side',
    },
    {
      title: 'out Amount',
      dataIndex: 'inAmount',
      key: 'inAmount',
      render: (val, order) => {
        if (order.side === 'buy') {
          return <Tag color="red">{val / USDC_DECIMAL}</Tag>;
        } else {
          return <Tag color="green">{val / SOL_DECIMAL}</Tag>;
        }
      },
    },
    {
      title: 'Out Token',
      dataIndex: 'fromToken',
      key: 'fromToken',
    },
    {
      title: 'in Amount',
      dataIndex: 'outAmount',
      key: 'outAmount',
      render: (val, order) => {
        if (order.side === 'buy') {
          return <Tag color="red">{val / SOL_DECIMAL}</Tag>;
        } else {
          return <Tag color="green">{val / USDC_DECIMAL}</Tag>;
        }
      },
    },
    {
      title: 'In Token',
      dataIndex: 'toToken',
      key: 'toToken',
    },
  ]}
></Table>
// ...
```

---

# 🏋️ Challenge

{% hint style="tip" %}
In `components/protocols/pyth/components/Exchange.tsx`, finish implementing the RxJS `map` **return values** to determine what happens when a buy or sell signal is resolved. You must replace the instances of `undefined` to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
// components/protocols/pyth/components/Exchange.tsx

        //...
        Rx.map((val: number) => {
          if (val > 0) {
            // Buy.
            const orderSizeSupposedTo =
              val *
              (cluster === 'devnet'
                ? orderSizeUSDC.devnet
                : orderSizeUSDC.mainnet);
            const orderSize = Math.min(
              orderSizeSupposedTo,
              balance.usdc_balance,
            );
            return {
              undefined;
            };
          } else if (val <= 0) {
            // Sell.
            const orderSizeSupposedTo =
              Math.abs(val) *
              (cluster === 'devnet'
                ? orderSizeSOL.devnet
                : orderSizeSOL.mainnet);
            const orderSize = Math.min(
              orderSizeSupposedTo,
              balance.sol_balance,
            );
            return {
              undefined;
            };
          }
        }),
        //...
```

**Need some help?** Check out these hints 👇

- Remember the `Order` object and its properties. This is what you'll need to return here.
- You'll definitely want to **sell** SOL _for_ USDC and **buy** SOL _with_ USDC
- `orderSizeSupposedTo` is guarding against placing orders which are too large for the bot to afford, but the `orderSize` itself is what the bot will use

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
// components/protocols/pyth/components/Exchange.tsx

        //...
        Rx.map((val: number) => {
          if (val > 0) {
            // Buy.
            const orderSizeSupposedTo =
              val *
              (cluster === 'devnet'
                ? orderSizeUSDC.devnet
                : orderSizeUSDC.mainnet);
            const orderSize = Math.min(
              orderSizeSupposedTo,
              balance.usdc_balance,
            );
            return {
              side: 'buy',
              size: orderSize,
              fromToken: 'usdc',
              toToken: 'sol',
            };
          } else if (val <= 0) {
            // Sell.
            const orderSizeSupposedTo =
              Math.abs(val) *
              (cluster === 'devnet'
                ? orderSizeSOL.devnet
                : orderSizeSOL.mainnet);
            const orderSize = Math.min(
              orderSizeSupposedTo,
              balance.sol_balance,
            );
            return {
              side: 'sell',
              size: orderSize,
              fromToken: 'sol',
              toToken: 'usdc',
            };
          }
        }),
        //...
```

**What happened in the code above?**

- We use RxJS to `map` the numerical value being passed, then return an `Order` object with the appropriate values set in its properties.
- The property names contained in the returned object need to match the `Order` object: `side`, `size`, `fromToken` & `toToken`.

---

# ✅ Make sure it works

## 🐢 Mock swaps

If you're going to use the **mock wallet**, then all you need to do is specify an amount to buy or sell in the input next to the button and click on the button next to the input to perform the swap. This will generate a mock transaction, which is _not_ sent to the Solana cluster. You can still view the order details on the order book component, however the Transaction link to the block explorer will not work.

## 🐇 Actual swaps

Once you've made the necessary changes to `components/protocols/pyth/components/Exchange.tsx` and saved the file, the Next.js development server will hot module reload the page automatically. Once the page is reloaded, you can switch the wallet over to **live**. Clicking on the swap buttons will send an order of each type on devnet. If you're feeling brave (and if you have actual SOL in your wallet) you might try a swap on mainnet to see how smooth Jupiter can be.

---

# 🏁 Conclusion

We learned about Associated Token Accounts and SPL tokens like Wrapped SOL. We also looked at how to use the Orca and Jupiter SDKs by creating functions for exchanging SPL tokens. Using RxJS we can save a lot of hassle in how we perform the swaps, using an order book to keep track of and process the swaps.

'''
'''--- markdown/pyth/PYTH_LIQUIDATE.md ---
# 🔩 Bolting it all together

Now it's time to bring all the functionality that we've completed together and try out the working liquidation bot with mock swaps and devnet swaps!

As you recall, at the beginning of the pathway we laid out the various topics we would need to touch on to make this project. At every step, we provided you with measured amounts of learning and a chance to solidify that learning by completing a small coding challenge related to the task at hand. Here is a quick recap of how the components fit together:

- We have a component that can toggle our Pyth price feed on and off as needed to start and stop the bot. Without an ongoing price feed, the bot has nothing to act on.
- We've got an account display, the "Wallet" component which shows us how many tokens the bot has access to, real or not. We can supply a private key to give the bot complete authority to swap these tokens on our behalf.
- There's a Chart component to display the price data, so that we know which way the market is moving. Knowledge is power!
- We've got an order book and a way to generate token swap transactions based on the Exponential moving average and execute them on a DEX.

The file `components/protocols/pyth/components/Liquidate.tsx` is being rendered on the right side of the page. You should be familiar with the imports by now. We're bringing in the `pythConnection` that we worked on in the first step to fetch our price data from the Solana cluster. We'll be using the `price` state variable, and the `yieldExpectation` to account for how much the price has to move before the bot will act upon the trend up or down.

Each `useEffect` hook in the `Liquidate.tsx` component is commented, explaining what they're doing and the information they depend on.

---

# 🎠 Playground time

There is no code challenge for this step, at this point you should be familiar with all the components necessary to make use of Pyth price data!

You can try out the complete liquidation bot using the mock wallet and mock swaps right away! Keep in mind that the buy and sell signals are being buffered for 10 seconds before the trend is calculated and the bot decides to buy USDC or sell SOL. The mock swaps are still using the mainnet routes being fetched from Jupiter. There is some latency to be expected, but once you have turned the bot on it will begin to calculate the market trend based on the Exponential moving average and perform swaps according to the yield expectation. A higher value for the yield expectation will mean that the price needs to move up or down more before the calculation considers it a trend.

You'll notice that sometimes swaps can fail, which is typically due to an insufficient balance of USDC. This is typically only an issue on devnet, due to the price ratio.

---

# ✅ Make sure it works

Before turning on the price feed, be sure to have some ORCA tokens. Otherwise, the liquidation bot will fail to perform its assigned task because it will get hung up trying to swap an exact amount of ORCA. Without some extra ORCA to pay for the pool fees, failed swaps will start piling up.

Armed and ready? Now it's time to toggle the price feed on and watch the liquidation bot go to work!

The chart will populate with the ongoing price feed, and the bot will make buy & sell orders depending on the signals being emitted as events by the `eventListener`. This is all going to happen very quickly, but don't be afraid to let it run for a short time before toggling the price feed off to inspect the sequence of events.

For every instance where the order book has been updated, the bot will attempt to make the appropriate trade. If everything is working as it should, you'll see the amounts of SOL & USDC update as the swaps are completed (this might not happen instantly, due to network latency when fetching the balances).

If you want to alter the yield expectation, it's best to turn off the price feed first.

It is also handy to have a peek at the dev tools console in your browser to see a little more information about the swaps. In Firefox, open the Web Developer Tools. In Chrome, they're just called Developer Tools. In both browsers, simply right click on the page and select **Inspect** from the context menu, then click on the **Console** tab in the Developer Tools window. Now you can see the output of the informative `console.log` statements we included in the code 🚀

---

# 🏁 Conclusion

Congratulations, you now have a very basic yet functional liquidation bot which depends on Pyth price data to make token swaps on a DEX! There are many ways in which you might seek to improve on this functionality - whether it's just an improved front-end design or implementing a more stringent algorithm for trading.

'''
'''--- markdown/pyth/PYTH_SOLANA_WALLET.md ---
Now that we are able to get Pyth price data, we need to take a detour away from Pyth for a moment to get our account interface figured out. The liquidation bot is going to need some tokens to trade on our behalf! We want to be able to leverage that data and interact with a DEX to swap tokens. We're going to look at how to implement a display of our token balances on the frontend, so that we can see the changes as the liquidation bot is performing the swaps.

We have two different displays to consider: The **mock wallet** which is not connected to Solana, to be used for testing purposes. And the **live wallet** that pulls data from an existing, funded account on Solana to be used on either devnet or mainnet.

_Remember the safety information about the risks of using real SOL from the introduction_!

---

# 🎠 Playground time

There's a comprehensive explanation of the code we are using in the `Wallet.tsx` component below. For now, just play around with the actual component on the right side of the screen. It's a good opportunity to familiarize yourself with the display. There are default balance values, and you can switch between the **mock wallet** and the **live wallet**.

We assume that **you _will not_ want to use an account containing real SOL on mainnet** with this project as-is. There are no safeguards in this code. Don't be alarmed, we just want to be very clear on that point! It's quite easy to tell the difference between the mock and live wallet displays. Only the mock wallet can be reset, _which is only truly relevant for testing_. There is no way to reset balances on a live account (immutable public ledgers and all 😉).

Once you click the toggle over to the **live wallet**, you'll notice some changes:

- The shortened version of a randomly generated public key is displayed. Hover your cursor over it for a tooltip showing the entire public key.
- You can switch between devnet and mainnet with the toggle switch that replaces the "Reset Wallet" button.
- A textinput is included for you to enter a private key, which will then display the associated public key & any SOL, USDC or ORCA tokens owned by that keypair.

We default to using devnet. You should also notice that the balance values change to zero when switching to the **live wallet** for the first time, since our randomly generated default account has not been funded. We'll explain how to get some devnet SOL in a moment!

---

# 🔐 Getting your private key

{% hint style="tip" %}
Private keys are part of your Solana keypair, such as the one you'll create using the Phantom wallet in just a moment. The [base58 encoded](https://medium.com/nakamo-to/what-is-base58-c6c2db7808f3) secret key is commonly called the "private key". This alphanumeric string of the private key is the preferred form for displaying to users. Don't get confused by the difference between "secret key" and "private key" - there really isn't one, they are just different formats for the same information.
{% endhint %}

Using the method `fromSecretKey` which exists on the `Keypair` class from `@solana/web3.js`, it is possible to convert a `UInt8Array` secret key into a Keypair object with `publicKey` and `secretKey` properties. We'd still need to **base58 encode** the `secretKey` property to arrive at what is commonly called the "private key". A private key allows the holder to sign messages and transactions belonging to the public key. When you get your "private key" from the Phantom wallet for a given wallet, this is _approximately_ what is happening under the hood:

```typescript
// Modified example from components/protocols/pyth/lib/swap.ts

import {Keypair} from '@solana/web3.js';
import {bs58} from 'bs58';

const _account = Keypair.fromSecretKey(
  new Uint8Array([
    175, 193, 241, 226, 223, 32, 155, 13, 1, 120, 157, 36, 15, 39, 141, 146,
    197, 180, 138, 112, 167, 209, 70, 94, 103, 202, 166, 62, 81, 18, 143, 49,
    125, 253, 127, 53, 71, 38, 254, 214, 30, 170, 71, 69, 80, 46, 52, 76, 101,
    246, 34, 16, 96, 4, 164, 39, 220, 88, 184, 201, 138, 180, 181, 238,
  ]),
); // This is given for testing purposes only. Do NOT use this keypair in any production code.

// Logging the Keypair object, you'll notice that the publicKey is a 32-byte UInt8Array
// The secretKey is the entire 64-byte UInt8Array
// The first 32 bytes of the array are the secret key
// and the last 32 bytes of the array are the public key
console.log(_account);

// This returns the entire UInt8Array of 64 bytes
console.log(_account.secretKey);

// The secret key in base58 encoding:
// 4WoxErVFHZSaiTyDjUhqd6oWRL7gHZJd8ozvWWKZY9EZEtrqxCiD8CFvak7QRCYpuZHLU8FTGALB9y5yenx8rEq3
console.log(bs58.encode(_account.secretKey));

// The publicKey property is either a UInt8Array or a BigNumber:
// PublicKey { _bn: <BN: 7dfd7f354726fed61eaa4745502e344c65f622106004a427dc58b8c98ab4b5ee> }
console.log(_account.publicKey);

// The public key is commonly represented as a string when being used as an "address":
// 9UpA4MYkBw5MGfDm5oCB6hskMt6LdUZ8fUtapG6NioLH
console.log(_account.publicKey.toString());
```

It is not required, but you might want to test the **live wallet**, here are the steps to follow in the Phantom wallet to get your private key:

![Phantom Private Key Workflow](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/phantom_secret_key.png)

1. Click the hamburger menu at the top left
2. With the hamburger menu up, click on "Add / Connect Wallet"
3. Then click the option to "Create a new wallet"
4. View the newly created wallet's private key by clicking the gear icon on the bottom of the Phantom window
5. Scroll down inside Phantom and click on "Export Private Key"
6. You'll need to enter the password you've set up to unlock Phantom to reveal your private key
7. You'll now be able to copy and paste the private key into the wallet component on the right. Remember to keep your private keys private! 👻

![Phantom Settings](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/phantom_cluster.png)

---

# 🧱 Building the Wallet component

This component is necessary because we want to display the amount of SOL tokens & the amount of SPL tokens in our wallet (the USDC stablecoin is the SPL token we're referring to here). We'll also want to display the total value ("worth") of the combined amounts, based on the current market price. Keep in mind that the reason this amount is not being updated _on this page_ is because we haven't passed along the price. When we combine the components for the final step, the worth will update along with the token balances.

The final piece of the puzzle will be the percentage of change in the total worth of our wallet which will be used to indicate how our liquidation bot is performing. A positive percentage indicates a profit overall, and a negative percentage indicates a loss.

There are two files to be aware of, one is the React component [`components/protocols/pyth/components/Wallet.tsx`](https://github.com/figment-networks/learn-web3-dapp/main/components/protocols/pyth/components/Wallet.tsx) which is what is being displayed on the right side of this page. The other is a collection of helper code [`components/protocols/pyth/lib/wallet.tsx`](https://github.com/figment-networks/learn-web3-dapp/main/components/protocols/pyth/lib/wallet.tsx). The React component is responsible for displaying the account data, and uses the helper code to fetch and format the data. Let's go ahead and break down the helper code for easier understanding!

---

# 🚚 Importing dependencies

There are [imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) at the top of the component file (`/components/Wallet.tsx`) for the code libraries we'll use to make the Wallet component itself. Click on the name of an import in the lists below to visit the documentation if you'd like to learn more, but _feel free to scroll ahead_ if you're comfortable with the imports.

- [`antd`](https://ant.design/components/overview/) and [`@ant-design/icons`](https://ant.design/components/icon/) provide easy to use components for us to rapidly prototype our UI
- [`@pythnetwork/client`](https://github.com/pyth-network/pyth-client-js#pythnetworkclient) helps us to bring in Pyth data 🚀
- [`lodash`](https://lodash.com/docs/4.17.15) is a popular library which simplifies working with arrays, numbers, objects & strings
- [`rxjs`](https://rxjs.dev/guide/overview) is great for working with asynchronous events

We'll also need to import some other useful tools in the helper file (`/lib/wallet.tsx`) to make our component more flexible:

- [`@solana/web3.js`](https://solana-labs.github.io/solana-web3.js/) is used to connect to Solana clusters and simplifies making RPC calls
- [`axios`](https://axios-http.com/docs/intro) is a promise-based HTTP client which we can use to make requests
- [`bs58`](https://openbase.com/js/bs58/documentation) is a library for computing base 58 encoding, which is commonly used by cryptocurrencies
- [`lodash`](https://lodash.com/docs/4.17.15) is a popular library which simplifies working with arrays, numbers, objects & strings
- [`swr`](https://swr.vercel.app/) provides us with the `useSWR` hook, a powerful tool to fetch and cache data

We're going to use the [Jupiter](https://jup.ag) software development kit (SDK) in this project. As of this writing, Jupiter does not support Solana's devnet so for devnet swaps we'll use the Orca SDK. You'll see the imports in the file [`components/protocols/pyth/lib/swap.tsx`](https://github.com/figment-networks/learn-web3-dapp/main/components/protocols/pyth/lib/swap.tsx), which we will get to in the next step.

- [`@orca-so/sdk`](https://github.com/orca-so/typescript-sdk#orca-typescript-sdk) the Orca SDK enables us to create our `OrcaSwapClient`.
- [`@jup-ag/core`](https://docs.jup.ag/jupiter-core/using-jupiter-core#usage) the Jupiter SDK enables us to create our `JupiterSwapClient`.

---

# 💎 Interfaces and Constants

Next up, we need to define some important interfaces and constants:

- `WalletBalance` relates to our mock wallet implementation. This holds the balances we'll use in our **mock wallet**.
- An `Order` contains the necessary information to carry out a swap: If it is a buy or sell, the size of the swap, and the relevant tokens.
- We'll specify the Serum RPC endpoint as a constant so we can access it elsewhere. This is useful due to the increased rate limit for mainnet swaps.
- We also need to specify the [mint addresses](https://spl.solana.com/token#finding-all-token-accounts-for-a-specific-mint) of the tokens we want to swap. The mint addresses for USDC on devnet and mainnet are different.
- We're specifying the decimals using the `**` [exponentiation operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Exponentiation), to ease our on the fly calculations 😅. Notice that we're `export`ing these so that they can be accessed by our other components. They'll pop up again further ahead in the Pathway, when we're displaying the order book.

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...

interface WalletBalance {
  sol_balance: number;
  usdc_balance: number;
  orca_balance: number;
}

interface Order {
  side: 'buy' | 'sell';
  size: number;
  fromToken: string;
  toToken: string;
}

export const SERUM_RPC_URL = 'https://solana-api.projectserum.com/';

const SOL_MINT_ADDRESS = 'So11111111111111111111111111111111111111112';
const DEVNET_USDC_MINT_ADDRESS = 'EmXq3Ni9gfudTiyNKzzYvpnQqnJEMRw2ttnVXoJXjLo1';
const MAINNET_USDC_MINT_ADDRESS =
  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
const ORCA_MINT_ADDRESS = 'orcarKHSqC5CDDsGbho8GKvwExejWHxTqGzXgcewB9L';

export const SOL_DECIMAL = 10 ** 9;
export const USDC_DECIMAL = 10 ** 6;
export const ORCA_DECIMAL = 10 ** 6;
// ...
```

---

# 🪝 The useExtendedWallet hook

We're making a custom hook to handle our wallet interactions which we will call `useExtendedWallet`. Note that this hook combines the functionality for our mock wallet as well as using a **private key** for an existing keypair. You might expect to use a wallet adapter to tap into a browser extension wallet like Phantom. The frequency of swapping we'll be performing requires that we have an alternate, faster method to sign transactions. Nobody wants to sit in front of a computer clicking all day, do they? 😉

We'll start with the function signature for `useExtendedWallet`. Notice that we're passing a boolean value to determine which display to use (mock or live). We can also specify which Solana cluster to target, devnet or mainnet-beta. Price will default to zero as we still want to be able to use the hook before pulling in any price data from Pyth.

```typescript
// components/protocols/pyth/lib/wallet.tsx

export const useExtendedWallet = (
  useLive = false,
  cluster: Cluster,
  price: number = 0,
) => {
// ...
```

`setSecretKey` is using the browser's local storage to hold on to the private key entered into the textinput of the live wallet. `setKeyPair` works to help us generate the keypair from that input, otherwise it will generate a random keypair for the mock wallet by default. The `useState` hook lets us keep the keypair in our app state.

{% hint style="info" %}
It is a requirement of the Jupiter SDK that we provide a keypair to be able to fetch market data.
{% endhint %}

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
const [secretKey, setSecretKey] = useLocalStorage('secretKey', undefined);
const [keyPair, setKeyPair] = useState<Keypair>(Keypair.generate());
// ...
```

You'll see that `setBalance` is for setting the balance in the app state based on our trades. We also supply default values so that we can reset the mock wallet.

```typescript
// components/protocols/pyth/lib/wallet.tsx

const [balance, setBalance] = useState<WalletBalance>({
  sol_balance: 10 * SOL_DECIMAL,
  usdc_balance: 1400 * USDC_DECIMAL,
  orca_balance: 0 * ORCA_DECIMAL, // ORCA token is only used on devnet.
});
// ...
```

The `orderBook` is maintained in our app state, and keeps track of the buy and sell orders within an array.

The `balanceFetcher` function is a straightforward axios POST request to the Solana cluster which passes the `getBalance` method for the keypair, which returns the SOL balance and `getTokenAccountsByOwner` for the SPL tokens we're using - USDC and ORCA. The `params` array for each request passes the base58 encoded public key and in the case of the SPL tokens, the mint address. The `jsonParsed` encoding is the best choice for displaying balances.

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
const [orderBook, setOrderbook] = useState<Order[]>([]);

const balanceFetcher = (keyPair: Keypair, cluster: Cluster) => () =>
  // @ts-ignore
  axios({
    url: cluster === 'devnet' ? clusterApiUrl(cluster) : SERUM_RPC_URL,
    method: 'post',
    headers: {'Content-Type': 'application/json'},
    data: [
      {
        jsonrpc: '2.0',
        id: 0,
        method: 'getBalance', // SOL balance.
        params: [keyPair?.publicKey.toBase58()],
      },
      {
        jsonrpc: '2.0',
        id: 1,
        method: 'getTokenAccountsByOwner', // https://docs.solana.com/developing/clients/jsonrpc-api#gettokenaccountsbyowner
        params: [
          keyPair?.publicKey.toBase58(),
          {
            mint:
              cluster === 'devnet'
                ? DEVNET_USDC_MINT_ADDRESS
                : MAINNET_USDC_MINT_ADDRESS,
          },
          {
            encoding: 'jsonParsed',
          },
        ],
      },
      {
        jsonrpc: '2.0',
        id: 2,
        method: 'getTokenAccountsByOwner', // https://docs.solana.com/developing/clients/jsonrpc-api#gettokenaccountsbyowner
        params: [
          keyPair?.publicKey.toBase58(),
          {
            mint: ORCA_MINT_ADDRESS, // Required as a midway swap token for devnet swaps using Orca.
          },
          {
            encoding: 'jsonParsed',
          },
        ],
      },
    ],
  });
```

By [leveraging the `useSWR` hook](https://swr.vercel.app/) here, we can make sure that the amounts being displayed for the balance of our tokens on the frontend are accurate. The values are cached for us, and even on a slow connection they'll update reasonabl amount of time. We're also setting a refresh interval of five seconds.

Putting a call to `mutate` in a `useEffect` hook with a dependency of `cluster` means that any time we switch between devnet and mainnet, the balance will be handled by `useSWR`. Clean and simple code, keeps the kids happy 👍

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
const {data, mutate} = useSWR(
  () => `/balance/${keyPair?.publicKey}`, // cache key based on the keypair.
  balanceFetcher(keyPair!, cluster),
  {
    refreshInterval: 5000,
  },
);

useEffect(() => {
  mutate(); // refresh balance
}, [cluster]);
// ...
```

Our next `useEffect` hook is using lodash to simplify drilling down into the `data` object's properties, which we then use to set our balances. The `data` object is destructured from `useSWR` and is populated by the `balanceFetcher` call.

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
useEffect(() => {
  if (data && useLive) {
    /**
     * Documentation for  _.get https://lodash.com/docs/4.17.15#get
     */
    const sol_balance = _.get(data, 'data[0].result.value', 0);
    const usdc_balance = _.get(
      data,
      'data[1].result.value[0]account.data.parsed.info.tokenAmount.amount',
      0,
    );
    const orca_balance = _.get(
      data,
      'data[2].result.value[0]account.data.parsed.info.tokenAmount.amount',
      0,
    );
    setBalance({sol_balance, usdc_balance, orca_balance});
  }
}, [data]);
// ...
```

Now we can define the "swap client" getters and setters. The main thing to notice here is that we're passing the RPC endpoint URL and parameters to a new `Connection` instance if there wasn't already an existing swap client in the app state.

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...

const [orcaSwapClient, setOrcaSwapClient] = useState<OrcaSwapClient | null>(
  null,
);

const getOrcaSwapClient = async () => {
  console.log('setting up Orca client');
  if (orcaSwapClient) return orcaSwapClient;
  const _orcaSwapClient = new OrcaSwapClient(
    keyPair,
    new Connection(clusterApiUrl('devnet'), 'singleGossip'),
  );
  setOrcaSwapClient(_orcaSwapClient);
  return _orcaSwapClient;
};

const [jupiterSwapClient, setJupiterSwapClient] =
  useState<JupiterSwapClient | null>(null);

const getJupiterSwapClient = async () => {
  console.log('setting up Jupiter client');
  if (jupiterSwapClient) return jupiterSwapClient;
  const _jupiterSwapClient = await JupiterSwapClient.initialize(
    // Why not use clusterApiUrl('mainnet') over projectserum? Because mainnet public endpoints have rate limits at the moment.
    new Connection(SERUM_RPC_URL, 'confirmed'),
    SOLANA_NETWORKS.MAINNET,
    keyPair,
    SOL_MINT_ADDRESS,
    MAINNET_USDC_MINT_ADDRESS,
  );
  setJupiterSwapClient((c) => _jupiterSwapClient);
  return _jupiterSwapClient;
};

// ...
```

When we're performing the swap transactions, we want to be able to differentiate between adding mainnet/devnet orders and adding a mock order to the order book. We've split it into separate functions. First, let's look at the `addMockOrder` function:

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
const addMockOrder = async (order: Order): Promise<SwapResult> => {
  const timestamp = +new Date();
  const _jupiterSwapClient = await getJupiterSwapClient();
  const routes = await _jupiterSwapClient?.getRoutes({
    inputToken:
      order.side === 'buy'
        ? _jupiterSwapClient.tokenB // TokenB === USDC
        : _jupiterSwapClient.tokenA, // TokenA === SOL
    outputToken:
      order.side === 'buy'
        ? _jupiterSwapClient.tokenA
        : _jupiterSwapClient.tokenB,
    inputAmount: order.size,
    slippage: 1,
  });
  const bestRoute = routes?.routesInfos[0];
  const result = {
    timestamp,
    inAmount: bestRoute?.inAmount || 0,
    outAmount: bestRoute?.outAmount || 0,
    txIds: [
      `mockTransaction_${Math.abs(Math.random()).toString().slice(2, 8)}`,
    ],
  };

  // Balance change for the mock wallet. This is not an actual transaction.
  setBalance((previousBalance) => ({
    ...previousBalance,
    usdc_balance:
      order.side === 'buy'
        ? previousBalance.usdc_balance - result.inAmount
        : previousBalance.usdc_balance + result.outAmount,
    sol_balance:
      order.side === 'buy'
        ? previousBalance.sol_balance + result.outAmount
        : previousBalance.sol_balance - result.inAmount,
  }));

  return result;
};
// ...
```

This `devnetToMainnetPriceRatioRef` is necessary because the swap ratio from SOL to USDC on devnet is incorrect. It takes about 8 SOL to get 1 USDC 😓

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
const [devnetToMainnetPriceRatioRef, setDevnetToMainnetPriceRatioRef] =
  useState<{
    sol_usdc: number;
    usdc_sol: number;
  }>({
    sol_usdc: 1,
    usdc_sol: 1,
  });
```

Most of what we're doing in `addDevnetOrder` and `addMainnetOrder` is simply conditional, depending on if we are handling buy or sell orders & which Solana cluster we're targeting. Using `switch` statements here also makes it quite simple to add in other tokens for swapping, if you feel so inclined 🤑 We won't go over the `addMainnetOrder` function here, but you can still see it in `wallet.tsx`.

Note that we're using try/catch here to capture errors and passing them in the return value. We'll explain more about this in the next step.

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
const addDevnetOrder = async (order: Order) => {
  const timestamp = +new Date();
  try {
    const _orcaClient = await getOrcaSwapClient();
    if (order.side === 'buy') {
      switch (order.fromToken) {
        case 'ORCA': {
          const result = await _orcaClient?.buy_from_orca(order.size)!;
          return {
            ...result,
            timestamp,
          };
        }
        case 'USDC':
        default: {
          const result = await _orcaClient?.buy(order.size)!;
          const inAmountHumanReadable = result.inAmount / USDC_DECIMAL;
          const outAmountHumanReadable = result.outAmount / SOL_DECIMAL;
          setDevnetToMainnetPriceRatioRef((prev) => ({
            ...prev,
            usdc_sol: inAmountHumanReadable / outAmountHumanReadable,
          }));
          return {
            ...result,
            timestamp,
          };
        }
      }
    } else {
      switch (order.toToken) {
        case 'ORCA': {
          const result = await _orcaClient?.sell_to_orca(order.size)!;
          return {
            ...result,
            timestamp,
          };
        }
        case 'USDC':
        default: {
          const result = await _orcaClient?.sell(order.size)!;
          const inAmountHumanReadable = result.inAmount / SOL_DECIMAL;
          const outAmountHumanReadable = result.outAmount / USDC_DECIMAL;
          setDevnetToMainnetPriceRatioRef((prev) => ({
            ...prev,
            sol_usdc: inAmountHumanReadable / outAmountHumanReadable,
          }));
          return {
            ...result,
            timestamp,
          };
        }
      }
    }
  } catch (error) {
    return Promise.resolve({
      error,
      inAmount: 0,
      outAmount: 0,
      txIds: [],
      timestamp,
    });
  }
};
// ...
```

When we're resetting the mock wallet balance, we can calculate the floating point numbers to display on the fly using our predefined decimal constants. If we're resetting the balance when the live wallet is active, thanks to the `useSWR` hook we can just set the secret key to be an empty string which will trigger a refresh. We also want to update the current worth of the combined tokens.

```typescript
// components/protocols/pyth/lib/wallet.tsx

// ...
const resetWallet = (
  params = {sol_balance: 10, usdc_balance: 1400, orca_balance: 0},
) => {
  if (useLive) {
    setSecretKey('');
  } else {
    setBalance({
      sol_balance: params.sol_balance * SOL_DECIMAL,
      usdc_balance: params.usdc_balance * USDC_DECIMAL,
      orca_balance: params.orca_balance * ORCA_DECIMAL,
    });
    updateCurrentWorth(true);
  }
};
// ...
```

---

# 🏋️ Challenge

{% hint style="tip" %}
In `components/protocols/pyth/lib/wallet.tsx`, finish implementing the `useEffect` to set the keypair in the app state based on the user input of the `secretKey`. The `secretKey` is what is pasted into the text input of the **live wallet**. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
// components/protocols/pyth/lib/wallet.tsx
//...
const [keyPair, setKeyPair] = useState<Keypair>(Keypair.generate());
useEffect(() => {
  if (secretKey) {
    let arr = undefined;
    const key = undefined;
    // setKeyPair(key);
    // The line above must be uncommented for the page to work.
    // We have it commented by default because when the value of
    // key is undefined, the page will break when it loads.
  } else {
    // The mock uses a random keypair to be able to get real market data.
    const temp = Keypair.generate();
    setKeyPair(temp);
  }
}, [secretKey]);
//...
```

**Need some help?** Check out these links & hints 👇

- Check out the [Keypair class](https://solana-labs.github.io/solana-web3.js/classes/Keypair.html)
- Also read up on the [PublicKey](https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html)
- Learn about [UInt8Arrays](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
- [bs58](https://github.com/cryptocoinjs/bs58#api) is very simple base58 library, it only has `encode` and `decode` methods
- You may notice `const [secretKey, setSecretKey] = useLocalStorage('secretKey', undefined);` which is where the key is saved to local storage, however the `undefined` value here is not part of the code challenge. The second parameter of `useLocalStorage` is an initial value, and we want it to be `undefined` 😃

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

# 😅 Solution

```typescript
// solution
// components/protocols/pyth/lib/wallet.tsx

//...
const [keyPair, setKeyPair] = useState<Keypair>(Keypair.generate());
useEffect(() => {
  if (secretKey) {
    let array = Uint8Array.from(bs58.decode(secretKey));
    const key = Keypair.fromSecretKey(array);
    setKeyPair(key);
    // The line above must be uncommented for the page to work.
    // We have it commented by default because when the value of
    // key is undefined, the page will break when it loads.
  } else {
    // The mock uses a random keypair to be able to get real market data.
    const temp = Keypair.generate();
    setKeyPair(temp);
  }
}, [secretKey]);
//...
```

**What happened in the code above?**

- We use a state variable called `keyPair` which defaults to generating a random keypair.
- If the variable `secretKey` is present, we are assuming that the user has pasted in a base58 encoded private key and create a `UInt8Array` by decoding that string with the bs58 `decode` method.
- We then pass the array to the `fromSecretKey` method of the `Keypair` class from `@solana/web3.js`.
- Finally, we set the state variable using `setKeyPair`.

# ✅ Make sure it works

Once you've completed the code in `components/protocols/pyth/lib/wallet.tsx` and saved the file, the Next.js development server will reload the page. Provided that you've correctly set the keypair into the app state by pasting it into the input on the **live wallet**, you will be able to proceed to the next step 🚀

---

# 🏁 Conclusion

We learned how to create a display for our account balances, with a little bit of extended functionality so that we can use it with the Solana mainnet. We also took a look at the specifics of Solana keypairs, and how to use Phantom to create a new account for testing.

'''
'''--- markdown/pyth/PYTH_VISUALIZE_DATA.md ---
To better understand and derive value from the Pyth price data for a given product like SOL/USDC, we'll want to visualize that data in a meaningful format. A line chart is a basic way to display an increase or decrease in a value over time, so we will look at how to effectively represent our price data using a pre-made component library called [recharts](https://recharts.org/).

This helps to illustrate the price data coming from Pyth and also sets the stage for us to be able to to perform buy/sell operations using a DEX. We'll be calculating our buy and sell signals based on the Exponential Moving Average (EMA) which is a naive and un-opinionated method of achieving yield. There are more complex ways of deciding when and how much to trade, which are all beyond the scope of this pathway. Using the EMA, as long as the price trends upwards for the amount of time you are trading, you would expect to see a positive yield. Since this is an exercise in buying low and selling as the price rises, it's simple enough to avoid spending over your target by stopping the liquidation bot.

Slightly separate topics, though worth considering if you wish to build upon the basics of this Pathway: What is a novel and interesting way to calculate when to buy and when to sell? Are there ways in which you might safeguard against a particularly wide confidence interval, or even a sudden shock to the market?

---

# 👀 Charting Pyth data

The **chart** being rendered on the right is defined in `components/protocols/pyth/components/ChartMock.tsx`, which contains some of the price feed component from the Connect step and the Chart component defined in `components/protocols/pyth/components/Chart.tsx`. Toggling on the price feed will populate the chart, by passing the data to the Chart component. You can probably tell where we're going with this 😉

```jsx
// components/protocols/pyth/components/ChartMock.tsx
// ...
<Card>
  <Chart data={data} />
</Card>
// ...
```

---

# 📈 Moving Averages

{% hint style="info" %}
We need to calculate the Simple Moving Average (SMA), to kickstart the EMA with a point of reference. This is why you will not see the green line representing the EMA on the chart right away when starting it up.
{% endhint %}

Because what we are building is effectively a financial application, we want to display the moving average we'll be using to determine our buy & sell signals for the tokens we want to trade.

For the hard-boiled engineers and the truly devoted learners, there is a dry explanation of Exponential Moving Average (EMA) calculations available on [Wikipedia](https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average) but this is likely to be _very_ confusing to most readers. Luckily, there is a much simpler way to visualize this formula and what it will produce!

The EMA formula can be expressed as:

![EMA Formula](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/ema_formula.png)

- `EMAc` is the currently calculated EMA - "c" stands for "current", because we are going to be using a time frame smaller than a single day on our chart. This is the product of our calculation, but don't get too hung up on this.
- `value` is the current value, so in our case the price being reported by Pyth.
- `EMAp` is the previously calculated EMA - "p" stands for "previous".
- `weight` is a multiplier that gives less importance to older values. This can also be referred to as a "smoothing factor". To calculate the `weight` we require a time frame, known as a **window** (this can be an arbitrary number: 10 days, 5 days, 45 minutes, etc.)

We need to define our **smoothing factor** or `weight`, which can be done by dividing 2 by the **window** + 1:

![Weight Formula](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/weight_calculation.png)

```typescript
// solution
// * text example for accessibility *

           2
weight = -----
         w + 1

// components/protocols/pyth/components/Chart.tsx

// Formula: EMAc = (value - EMAp) * weight + EMAp
const ema = (newData.price - previousEma) * smoothingFactor + previousEma;
```

![EMA Chart](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/ema_chart.png)

We can add a `setData` hook to the `getPythData` function that we created in our initial Connect component, so that the `data` is being calculated on the spot, then passed into the Chart component. `newData` is defining the data structure in place, and populating the object with the price, confidence and a timestamp. We're using this `data` in the Chart component. You'll notice that we leave the SMA, EMA and trend as `undefined`. They're being calculated and set inside `setData` 😀

```typescript
// components/protocols/pyth/components/ChartMock.tsx

  const getPythData = async (checked: boolean) => {
    pythConnection.onPriceChange((product, price) => {
      // ...
        const newData: {
          price: number;
          priceConfidenceRange: number[];
          ts: number;
          sma: undefined | number;
          ema: undefined | number;
          trend: undefined | boolean;
        } = {
          price: price.price,
          priceConfidenceRange: [
            price?.price! - price?.confidence!,
            price?.price! + price?.confidence!,
          ],
          ts: +new Date(),
          sma: undefined,
          ema: undefined,
          trend: undefined,
        };

        /**
         * window & smoothingFactor are used to calculate the Exponential moving average.
         */
        const window = 10;
        const smoothingFactor = 2 / (window + 1);

        /**
         * Calculate Simple moving average:
         *   https://en.wikipedia.org/wiki/Moving_average#Simple_moving_average
         * Calculate Exponential moving average:
         *   https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
         * The Exponential moving average has a better reaction to price changes.
         *
         * Ref: https://blog.oliverjumpertz.dev/the-moving-average-simple-and-exponential-theory-math-and-implementation-in-javascript
         */
        setData((data) => {
          if (data.length > window) {
          // ...
```

This next piece of code is how we are defining our buy and sell signals based on the trend of the EMA. Pivoting on the value being entered for the `yieldExpectation`, we can make a simple calculation to emit a **buy** signal if the trend is greater than our expected yield, otherwise emit a **sell** signal. The `signalListener` is an instance of an `EventEmitter` (read more about [the `events` module](https://nodejs.org/api/events.html#events) and [EventEmitters](https://nodejs.org/api/events.html#class-eventemitter) if you need to brush up) - this essentially lets us run any functions listening to the event when it is triggered. We can just emit the event here in our code and know that the relevant functions to add the orders to the order book will be called. We'll touch on this again soon, when we're performing our token swaps.

```typescript
// components/protocols/pyth/components/ChartMock.tsx

// ...
            /**
             * Trend of the price with respect to preview EMA.
             * If the price is higher than the EMA, it is a positive trend.
             * If the price is lower than the EMA, it is a negative trend.
             *
             * The signalListener emits an event carrying the buy or sell signal,
             * which we will manage with RxJS and use to populate the order book
             * used by the liquidation bot.
             */
            const trend = newData.ema / data[data.length - 1].ema;
            if (trend * 100 > 100 + yieldExpectation) {
              signalListener.emit('buy');
            } else if (trend * 100 < 100 - yieldExpectation) {
              signalListener.emit('sell');
            }
          }
          return [...data, newData];
        });
// ...
};
```

The returned `data` is what we are passing to the Chart component.

---

# 🧱 Building the Chart component

There is a concise [getting started guide](https://recharts.org/en-US/guide/getting-started) on the recharts website which should bring you up to speed for reading the contents of `components/protocols/pyth/components/Chart.tsx`. There isn't anything complicated going on with this component, but let's quickly break down the code for better understanding.

We'll import any other code we need at the beginning of the file, including the recharts components. This `Chart` component has a single `useEffect`, which contains `data` in the dependency array - so any time the `data` changes, this component will re-render. All we're doing is making sure that the data exists by checking that the length is greater than zero, and then setting the domain for our chart data. The entire `data` object, as defined in `ChartMock.tsx` will be passed to the rechart `AreaChart` component. The rest of this component is effectively passing properties to the components and defining the style of the chart. No need to focus on this part unless you're very particular about how the information is displayed. You might want to change the colors, or even try a completely different style of chart. The recharts library is fast and quite flexible.

```tsx
// components/protocols/pyth/components/Chart.tsx

import {Select} from 'antd';
import {useEffect, useState} from 'react';
import {Area, AreaChart, Line, Tooltip, XAxis, YAxis} from 'recharts';

export const Chart: React.FC<{data: any}> = ({data}) => {
  const [domain, setDomain] = useState({dataMax: 0, dataMin: 0, price: 10});
  const [selectedTimeRange, setSelectedTimeRange] = useState('LIVE');
  useEffect(() => {
    if (data.length > 0) {
      const lastRange = data[data.length - 1].priceConfidenceRange;
      if (domain.dataMax < lastRange[1]) {
        setDomain({
          ...domain,
          dataMax: lastRange[1],
          dataMin: lastRange[0],
          price: data[data.length - 1].price,
        });
      }
    }
  }, [data]);
  return (
    <>
      <Select
        value={selectedTimeRange}
        defaultValue="LIVE"
        onChange={(value) => setSelectedTimeRange(value)}
      >
        <Select.Option value={'LIVE'}>LIVE</Select.Option>
        <Select.Option value={'1D'}>DAY</Select.Option>
        <Select.Option value={'1W'}>WEEK</Select.Option>
      </Select>
      <AreaChart
        width={730}
        height={250}
        data={data}
        stackOffset="none"
        syncMethod={'index'}
        layout="horizontal"
        barCategoryGap={'10%'}
        barGap={4}
        reverseStackOrder={false}
        margin={{top: 5, right: 30, left: 20, bottom: 5}}
      >
        <Tooltip />

        <YAxis
          stroke={'#222'}
          domain={[domain.dataMin, domain.dataMax || 'auto']}
          tickCount={4}
          scale="linear"
        />
        <XAxis
          stroke={'#222'}
          dataKey="ts"
          height={100}
          interval={'preserveStartEnd'}
          minTickGap={0}
          tickLine={false}
          tick={CustomizedHistoricalHourAxisTick}
        />

        <Area dataKey="priceConfidenceRange" stroke="#8884d8" fill="#8884d8" />
        <Area dataKey="price" stroke="#000" fillOpacity={0} />
        <Area dataKey="sma" stroke="#FF0000" fillOpacity={0} />
        <Area dataKey="ema" stroke="#00FF00" fillOpacity={0} />
      </AreaChart>
    </>
  );
};
```

The `CustomizedHistoricalHourAxisTick` is used to display the vertically oriented timestamps at the bottom of the chart. All we're doing here is rotating the text and adding a timestamp via the JavaScript `Date` class and the `toLocaleTimeString` method.

```typescript
const CustomizedHistoricalHourAxisTick = ({x, y, fill, payload}) =>
  payload.value ? (
    <g transform={`translate(${x},${y})`}>
      <text
        x={0}
        y={0}
        dy={16}
        textAnchor="end"
        fill={fill}
        transform="rotate(-90) translate(0,-9.5)"
      >
        {new Date(payload.value).toLocaleTimeString([], {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
        })}
      </text>
    </g>
  ) : null;
```

---

# 🌱 Bringing the Chart to life

The Chart component is deceptively simple, most of it is setting up how the chart will look. Recharts has a declarative style, which makes it easy to follow the display logic and see where the values are being passed. We already calculated our SMA / EMA in the `ChartMock.tsx` component, and now they'll be displayed alongside the Pyth price data as red and green lines.

Clicking on the price feed toggle switch will begin fetching price data from Pyth and passing it along to the Chart component. The green line indicating the EMA will not appear at first, because an exponential moving average requires a historical value to be calculated against. One thing to notice is how the SMA does not react to changes in the price in the same way that the EMA does. After a few seconds, the green line indicating the EMA will appear and begin tracking along the chart. You will notice that it does not precisely follow Pyth's reported price. In most cases, it will fall within the range of the confidence interval - however there can be cases where it appears to fall outside of the confidence interval. You can coroborate using the Simple moving average if you like. You can inspect the actual values at a given tick by moving your mouse cursor over the chart, which will display the Tooltip.

![EMA Outside Confidence Interval](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/pyth/ema_outside_confidence.png)

---

# 🏋️ Challenge

{% hint style="tip" %}
In `components/protocols/pyth/lib/ChartMock.tsx`, finish the `setData` function by implementing the EMA formula in the `currentEma` and emitting the proper events for the `trend` conditions. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
setData((data) => {
  if (data.length > window) {
    const windowSlice = data.slice(data.length - window, data.length);
    const sum = windowSlice.reduce((prev, curr) => prev + curr.price, 0);
    newData.sma = sum / window;

    const previousEma = newData.ema || newData.sma;
    const currentEma = undefined;
    newData.ema = currentEma;

    const trend = newData.ema / data[data.length - 1].ema;
    if (trend * 100 > 100 + yieldExpectation) {
      undefined;
    } else if (trend * 100 < 100 - yieldExpectation) {
      undefined;
    }
  }
  return [...data, newData];
});
//...
```

**Need some help?** Check out these links & hints 👇

- There's a great article on [implementing moving averages in JavaScript](https://blog.oliverjumpertz.dev/the-moving-average-simple-and-exponential-theory-math-and-implementation-in-javascript)
- [Emitting events](https://nodejs.org/api/events.html#emitteremiteventname-args) in JavaScript is a handy skill

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
setData((data) => {
  if (data.length > window) {
    const windowSlice = data.slice(data.length - window, data.length);
    const sum = windowSlice.reduce((prev, curr) => prev + curr.price, 0);
    newData.sma = sum / window;

    const previousEma = newData.ema || newData.sma;
    const currentEma =
      (newData.price - previousEma) * smoothingFactor + previousEma;
    newData.ema = currentEma;

    const trend = newData.ema / data[data.length - 1].ema;
    if (trend * 100 > 100 + yieldExpectation) {
      signalListener.emit('buy');
    } else if (trend * 100 < 100 - yieldExpectation) {
      signalListener.emit('sell');
    }
  }
  return [...data, newData];
});
//...
```

**What happened in the code above?**

- We're checking that the length of the `data` array is greater than the `window`
- We `slice` off the data we want from the array and store it in the `windowSlice` variable
- The reducer goes through the array using the callback function on every element to arrive at the `sum`
- We set the `sma` property of `newData` to equal the `sum` divided by the `window`
- We can now calculate our EMA, as we have a `previousEMA` from which to start
- Apply the EMA formula to calculate the `currentEMA`, and set the value as the `ema` property of `newData`
- Calculating the `trend` by dividing the current EMA by a previous value from the `data` array
- Finally, we can emit the signals related to the trend being up or down with `signalListener.emit()`

# ✅ Make sure it works

Once you've completed the code and saved the file, the Next.js development server will rebuild the page. Now, turning the price feed on will populate the chart (including the EMA)! Watch it run for a minute or two, observing the way the Pyth data is displayed. This is an un-optimized implementation of the chart and it's possible that it might feel a little choppy. There are ways to smooth it out, but they're beyond the scope of this lesson.

Don't forget to turn the price feed off before moving to the next step 😄.

---

# 🏁 Conclusion

We looked at how to display Pyth price data using the recharts components. We touched on how to calculate an Exponential moving average and how that informs the buy and sell signals for our liquidation bot. We are able to see how the price data is reflected on the chart, along with the plotted lines for the Simple moving average and the Exponential moving average.

'''
'''--- markdown/secret/CHAIN_CONNECTION.md ---
The ability to establish a connection is the first step for anyone wanting to discover and travel through Web 3 space. Fasten your seatbelt, it's time to take off 🚀!

Connecting to a node works pretty much the same as for a standard web server. There are two actors: Client & server, with a protocol managing how data is transferred from one to the other.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/secret/connect.ts`, implement the function and try to establish your first connection to the Secret network. To verify your connection has been correctly established, try to return the current protocol version. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
try {
    const url = getNodeUrl();
    const client = undefined;
    const nodeInfo = undefined;
    const version = undefined;
    res.status(200).json(version);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Connection example**](https://github.com/enigmampc/SecretJS-Templates/tree/master/1_connecting_to_node)
- [**Read the code for `SecretJS` & `cosmwasm`**](https://github.com/enigmampc/SecretNetwork/tree/master/cosmwasm-js/packages/sdk)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
try {
    const url = getNodeUrl();
    const client = new CosmWasmClient(url);
    const nodeInfo = await client.restClient.nodeInfo();
    const version = nodeInfo.application_version.version;
    res.status(200).json(version);
  }
```

**What happened in the code above?**

- First, we instantiate a new `CosmWasmClient` passing the URL of the network we want to use (`getNodeUrl` currently defaults to the `pulsar-2` testnet).
- Next, using the `nodeInfo` method of the rest client returns a `NodeInfoResponse`.
- Inspecting the methods of our object will lead us naturally to reference the `application_version.version` property.
- Finally, we send the `version` back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/secret/connect.ts` is complete, click on the blue button to connect to Secret & display the current version.

---

# 🏁 Conclusion

Well done! Your fluency in the Secret dialect of Web 3 is growing. As a newcomer, creating an account is the next logical step in your exploration. Ready to take the next step forward?

'''
'''--- markdown/secret/CREATE_ACCOUNT.md ---
Like with most Web 3 protocols, transactions on Secret happen between **accounts**. To create an account, a client generates a **mnemonic** from which it can (re)-create a **public key** and a public address for use with a **wallet**. We're going to learn how to achieve all of this in the next challenge.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/secret/account.ts`, implement the function to first create a **mnemonic**, then produce an **address** from the **public key** belonging to the **mnemonic**. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const mnemonic = undefined;
    const signingPen = await undefined;
    const pubkey = undefined;
    const address = undefined;
    res.status(200).json({mnemonic, address})
  }
//...
```

**Need some help?** Check out these links

- [**Documentation for `@iov/crypto`'s BIP39 implementation**](https://iov-one.github.io/iov-core-docs/latest/iov-crypto/classes/bip39.html)
- [**Account example**](https://github.com/enigmampc/SecretJS-Templates/blob/master/2_creating_account/create_account.js)

{% hint style="info" %}
You can [**join us on Discord**](https://discord.gg/fszyM7K), if you have questions or want help completing the tutorial.
{% endhint %}

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
  try {
    const mnemonic = Bip39.encode(Random.getBytes(16)).toString();
    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');
    res.status(200).json({mnemonic, address})
  }
```

**What happened in the code above?**

- First we create a random **mnemonic** using the `fromMnemonic` method of the `Secp256k1Pen` class.
- Next we deduce the public key from it using the `encodeSecp256k1Pubkey` function.
- Then we deduce the wallet address from it using the `pubkeyToAddress` function.
- Finally we send the mnemonic and address back to the client-side as a JSON object.

{% hint style="tip" %}
Do not forget to fund the newly created wallet using the [secret faucet](https://faucet.secrettestnet.io/) in order to activate it!
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/secret/account.ts` is complete, Next.js will rebuild the API route. Click on **Generate a Mnemonic** to create a random seed and generate the mnemonic seed phrase.

---

# 🏁 Conclusion

Before we make our first transfer, let's check that the account is actually funded by querying the network for our balance!

'''
'''--- markdown/secret/DEPLOY_CONTRACT.md ---
We won't go through the process of reviewing the smart contract code base, compiling it or testing it. We will focus instead on how one can deploy a smart contract using the `secretjs` library. To do this, we're going to use a pre-compiled smart contract, you can find it under `./contract/secret/contract.wasm`.

Our contract implements a simple counter. The contract is created with a parameter for the initial count and allows subsequent incrementing:

- The `get_count` function returns the value of the counter stored on the contract.
- The `increment` function increases the value of the counter stored on the contract by 1.

{% hint style="working" %}
If you want to learn more about Secret smart contracts, follow the [**Developing your first secret contract**](https://learn.figment.io/tutorials/creating-a-secret-contract-from-scratch) tutorial.
{% endhint %}

{% hint style="danger" %}
You could experience some issues with the availability of the network [**Click here to check the current status**](https://secretnodes.com/secret/chains/supernova-2)
{% endhint %}

Before focusing on the deployment instructions, let's take a look at some important global variables:

```typescript
const CONTRACT_PATH = './contracts/secret/contract.wasm';

const customFees = {
  upload: {
    amount: [{amount: '2000000', denom: 'uscrt'}],
    gas: '2000000',
  },
  init: {
    amount: [{amount: '500000', denom: 'uscrt'}],
    gas: '500000',
  },
};
```

- `CONTRACT_PATH` is pointing to the location of the optimized **WebAssembly** version of the smart contract.
- The `customFees` object stores the predefined amount of fees to pay in order to **upload** and **initialize** the smart contract. [Click here](https://github.com/enigmampc/SecretNetwork/blob/7adccb9a09579a564fc90173cc9509d88c46d114/cosmwasm-js/packages/sdk/src/signingcosmwasmclient.ts#L48) to check out the default fee table in the `SigningCosmWasmClient` source.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/secret/deploy.ts`, implement the default function. Upload your first smart contract on the **Secret** network. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
// Upload the contract wasm
const wasm = fs.readFileSync(CONTRACT_PATH);
const uploadReceipt = await client.undefined;
if (!uploadReceipt) {
  throw new Error('uploadReceipt error');
}
// Get the code ID from the receipt
const {codeId} = uploadReceipt;

// Create an instance of the Counter contract, providing a starting count
const initMsg = {count: 101};
const receipt = undefined;
//...
```

**Need some help?** Check out these links 👇

- [**Contract example**](https://github.com/enigmampc/SecretJS-Templates/tree/master/5_contracts)
- [**The `upload` function**](https://github.com/enigmampc/SecretNetwork/blob/7adccb9a09579a564fc90173cc9509d88c46d114/cosmwasm-js/packages/sdk/src/signingcosmwasmclient.ts#L208)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
// Upload the contract wasm
const wasm = fs.readFileSync(CONTRACT_PATH);
const uploadReceipt = await client.upload(wasm, {});
if (!uploadReceipt) {
  throw new Error('uploadReceipt error');
}
// Get the code ID from the receipt
const {codeId} = uploadReceipt;

// Create an instance of the Counter contract, providing a starting count
const initMsg = {count: 101};
const receipt = await client.instantiate(codeId, initMsg, address.slice(6));
//...
```

**What happened in the code above?**

- First, we upload the contract using `upload` method of the `SigningCosmWasmClient`.
- Next, we destructure the `uploadReceipt` response object to get the `codeId` of the deployed contract
- Finally, we instantiate the contract using `instantiate` method of the `SigningCosmWasmClient`, passing:
  - The `codeId`.
  - The `initMsg` contract method to instantiate the storage with a value of `101`.
  - A label, which needs to be unique, which is why we use a slice of the address.
  - Optionally, we could also include a memo, a transfer amount, fees, and a code hash. For this example, these arguments are unnecessary.

---

# ✅ Make sure it works

Once the code in `pages/api/secret/deploy.ts` is complete, click on **Deploy Contract** to send the compiled smart contract to the network.

---

# 🏁 Conclusion

Now that we have deployed a smart contract, let's interact with it! In the following tutorials, we will look at how to use both view and change functions.

'''
'''--- markdown/secret/FINAL.md ---
🥳 **Congratulations**, you have completed the Secret Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to the Secret Network with a Javascript library
- 🏦 Creating and funding an account on a testnet
- 💸 Transferring tokens between accounts
- ⛓ Deploying and interacting with a compiled Rust smart contract

# 🧐 Keep learning with these resources:

- 🧱 [Developing your first Secret contract](https://learn.figment.io/tutorials/creating-a-secret-contract-from-scratch)
- 🕵️ [Create your own Secret NFT](https://learn.figment.io/tutorials/create-your-first-secret-nft)
- 🚀 [Awesome Secret](https://github.com/SecretFoundation/awesome-secret)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/secret/GET_BALANCE.md ---
Now that you have created an account on the **Secret** `supernova-2` network, and funded it using the faucet - We're going to check the balance of our account to make sure everything went alright.

{% hint style="info" %}
The native token on the **Secret Network** is **SCRT**
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/secret/balance.ts`, implement the default function. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
  try {
    const url = getNodeUrl();
    const { address }= req.body
    const client = new CosmWasmClient(url)

    // Query the Account object
    const account = undefined;
    // Return the balance
    const balance = undefined;

    res.status(200).json(balance)
  }
```

**Need some help?** Check out these links 👇

- [**Query example**](https://github.com/enigmampc/SecretJS-Templates/blob/master/3_query_node/query.js)
- [**Check out the CosmWasmClient source to understand the `Account` interface**](https://github.com/enigmampc/SecretNetwork/blob/master/cosmwasm-js/packages/sdk/src/cosmwasmclient.ts)
- [**Also, look at `getAccount()` and what it returns**](https://github.com/enigmampc/SecretNetwork/blob/7adccb9a09579a564fc90173cc9509d88c46d114/cosmwasm-js/packages/sdk/src/cosmwasmclient.ts#L231)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

{% hint style="danger" %}
You could experience some issues with the availability of the network. [**Click here to check the current status of `supernova-2`**](https://secretnodes.com/secret/chains/supernova-2)
{% endhint %}

---

# 😅 Solution

```typescript
// solution
  try {
    const url = getNodeUrl();
    const { address }= req.body
    const client = new CosmWasmClient(url);

    const account = await client.getAccount(address);
    const balance = account?.balance[0].amount as string;

    res.status(200).json(balance)
  }
```

**What happened in the code above?**

- First, we return an instance of the `Account` class from the `getAccount()` method.
- Next, we check the balance by accessing the `amount` property of the `Account.balance[0]`. The array attached to `balance` here is because the TypeScript definitions specify a `balance` as being a `ReadOnlyArray<Coin>`. The zero-index refers to the SCRT Coin.
  - Take note of the use of the [optional chaining operator](https://www.codeisbae.com/typescript-optional-chaining-nullish-coalescing/): `?.` This effectively prevents passing an incorrect value back to the client-side, because if there is no balance property present the expression will not evaluate.

{% hint style="info" %}
If you want to see more info, why not inspect the `Account` Object directly in the terminal using `console.log(account)`?
{% endhint %}

{% hint style="tip" %}
The amount returned by is denominated in **μSCRT**, so to convert it to **SCRT** you'll need to divide it by 10\*\*6
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/secret/balance.ts` is complete, Next.js will rebuild the API route. Click on **Check Balance** and you should see the account balance displayed on the page.

---

# 🏁 Conclusion

1000 **SCRT** available, hmmm ... seems it's more than enough to do our first transfer. In the next step, we're going to buy an imaginary pizza which means making a transfer of tokens!

'''
'''--- markdown/secret/GET_CONTRACT_VALUE.md ---
Our contract is on-chain, and we're going to learn how to fetch the count stored on the contract.

{% hint style="working" %}
If you want to learn more about Secret smart contracts, follow the [**Developing your first secret contract**](https://learn.figment.io/tutorials/creating-a-secret-contract-from-scratch) tutorial.
{% endhint %}

{% hint style="danger" %}
You could experience some issues with the availability of the network [**Click here to check the current status**](https://secretnodes.com/secret/chains/supernova-2)
{% endhint %}

Before focusing on retrieving a value from the smart contract, let's take a look at the fees object:

```typescript
const customFees = {
  send: {
    amount: [{amount: '80000', denom: 'uscrt'}],
    gas: '80000',
  },
};
```

- This `customFees` object stores the predefined amount of **uSCRT** to pay in order to **send** a query to the smart contract.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/secret/getter.ts`, complete the code of the default function. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
  // Get the stored value
  console.log('Querying contract for current count');
  let response = undefined.
  let count = response.count as number
//...
```

**Need some help?** Check out these links 👇

- [**Contract example**](https://github.com/enigmampc/SecretJS-Templates/tree/master/5_contracts)
- [**`queryContractSmart()`**](https://github.com/enigmampc/SecretNetwork/blob/7adccb9a09579a564fc90173cc9509d88c46d114/cosmwasm-js/packages/sdk/src/cosmwasmclient.ts#L400)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
// Get the stored value
console.log('Querying contract for current count');
let response = await client.queryContractSmart(contractId, {get_count: {}});
let count = response.count as number;
//...
```

**What happened in the code above?**

- We're calling the `queryContractSmart` method of the client, passing to it:
  - The `contractId`, which is the contract address.
  - The `{ get_count: {} }` object which represents the name of the method we are calling and the parameters we're passing to it. In this case, there are no arguments passed to `get_count`, but we must still pass an empty object: `{}`.

---

# ✅ Make sure it works

Once the code in `pages/api/secret/getter.ts` is complete, click **Get the stored value** to query the smart contract and display the value.

---

# 🏁 Conclusion

Now, time for the last challenge! Time to modify the state of the contract and thus the state of the blockchain. Let's go!

'''
'''--- markdown/secret/PROJECT_SETUP.md ---
# 🧩 API keys

If you wish to make use of the Pathway content using a private infrastructure provider, you will likely need a valid API key and an endpoint URL to access Secret.

To use an API key, you should copy the contents of the `.env.example` file located in the project root directory (`/learn-web3-dapp/.env.example`) into a new file named `.env.local` (`/learn-web3-dapp/.env.local`). Also, since this file will contain your API key, we have already added it to the `.gitignore`.

{% hint style="info" %}
Easily duplicate the file with the terminal command `cp .env.example .env.local`!
{% endhint %}

You can then paste your unique API key into `.env.local`, as the value for the environment variable `SECRET_API_KEY`.

```yaml
# DataHub API keys
DATAHUB_AVALANCHE_API_KEY=
DATAHUB_CELO_API_KEY=
DATAHUB_NEAR_API_KEY=
DATAHUB_POLKADOT_API_KEY=
DATAHUB_POLYGON_API_KEY=
SECRET_API_KEY=dd2c0d53e7c7de0843e23dd30bf4fcc5
DATAHUB_SOLANA_API_KEY=
```

When connecting to Secret, this pathway defaults to using a helper function which returns the Light Client Daemon (LCD) endpoint URL for the `pulsar-2` testnet. The file containing the `getNodeUrl` helper function is located at `components/protocols/secret/lib/index.ts`.

Note that you can always pass an endpoint URL when instantiating the `CosmWasmClient`, for example:

```typescript
const client = new CosmWasmClient('http://testnet.securesecrets.org:1317/');
```

---

# 👣 Next Steps

If you're using a private infractructure provider, remember to have your API key saved in `/learn-web3-dapp/.env.local`, if you require one. If you are using the default public endpoint (`https://api.pulsar.griptapejs.com/`) you do not require an API key, and you can continue by clicking on the **Next: Connect to Secret** button below.

'''
'''--- markdown/secret/SET_CONTRACT_VALUE.md ---
Our contract is on-chain, and we're going to learn how to modify the value stored in the state of the contract.

{% hint style="working" %}
If you want to learn more about Secret smart contracts, follow the [**Developing your first secret contract**](https://learn.figment.io/tutorials/creating-a-secret-contract-from-scratch) tutorial.
{% endhint %}

{% hint style="danger" %}
You could experience some issues with the availability of the network [**Click here to check the current status**](https://secretnodes.com/secret/chains/pulsar-2)
{% endhint %}

Before focusing on altering a value on the smart contract, let's take a look at the fees object:

```typescript
const customFees = {
  exec: {
    amount: [{amount: '500000', denom: 'uscrt'}],
    gas: '500000',
  },
};
```

- This `customFees` object stores the predefined amount of **uSCRT** to pay in order to **execute** a write-access method of the smart contract.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/secret/setter.ts`, implement the default function. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
// Increment the counter
const handleMsg = {increment: {}};
const response = undefined;
//...
```

**Need some help?** Check out these links 👇

- [**Contract example**](https://github.com/enigmampc/SecretJS-Templates/tree/master/5_contracts)
- [**`execute()`**](https://github.com/enigmampc/SecretNetwork/blob/7adccb9a09579a564fc90173cc9509d88c46d114/cosmwasm-js/packages/sdk/src/signingcosmwasmclient.ts#L409)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
// Increment the counter
const handleMsg = {increment: {}};
const response = await client.execute(contractId, handleMsg);
//...
```

**What happened in the code above?**

- We're calling the `execute` method of the `SigningCosmWasmClient`, passing to it:
  - The `contractId`, which is the contract address.
  - The `{ increment: {} }` object which represents the name of the method we are calling and the parameters we're passing to it. Again, we are passing an empty object as there are no arguments.

---

# ✅ Make sure it works

Once the code in `pages/api/secret/setter.ts` is complete, click on **Increment the value** to call the `increment` function of the smart contract and increase the stored value by 1.

---

# 🏁 Conclusion

Nice work, you have successfully deployed and interacted with a smart contract on the Secret Network testnet using DataHub.

'''
'''--- markdown/secret/TRANSFER_TOKEN.md ---
Of course, everyone likes to eat pizza, but among all available pizzas you prefer the pizza you've made for yourself. So to simplify the transfer process we're going to make a transfer _from_ our own account _to_ our own account again.

To do so, you'll need to make an encrypted transaction - in the **Secret** world everything is done with privacy in mind! Let's take a look at how to do this.

{% hint style="danger" %}
You could experience some issues with the availability of the network [**Click here to check the current status**](https://secretnodes.com/secret/chains/pulsar-2)
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/secret/transfer.ts`, implement the default function. There is a lot to fill here, so be careful!
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//..
// 0. A very specific Secret feature (this allows us to make the transaction encrypted)
const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();

// 1. The fees you'll need to pay to complete the transaction
const fees = {
  send: {
    amount: [{amount: '80000', denom: 'uscrt'}],
    gas: '80000',
  },
};

// 2. Initialize a secure Secret client
const client = new SigningCosmWasmClient(undefined);

// 3. Send tokens
const memo = 'sendTokens example'; // Optional memo to identify the transaction
const sent = await client.sendTokens(undefined);

// 4. Query the tx result
const query = {id: sent.transactionHash};
const transaction = await client.searchTx(query);
//..
```

**Need some help?** Check out these links 👇

- [**Transaction example**](https://github.com/enigmampc/SecretJS-Templates/blob/master/4_transactions/send.js)
- [**Documentation of `secrectjs`**](https://github.com/enigmampc/SecretNetwork/tree/master/cosmwasm-js/packages/sdk)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
// 2. Initialize a secure Secret client
const client = new SigningCosmWasmClient(
  url,
  address,
  (signBytes) => signingPen.sign(signBytes),
  txEncryptionSeed,
  fees,
);

// 3. Send tokens
const memo = 'sendTokens example'; // optional memo
const sent = await client.sendTokens(
  address,
  [
    {
      amount: txAmount,
      denom: 'uscrt',
    },
  ],
  memo,
);
//..
```

**What happened in the code above?**

- First, we create a secure connection using `SigningCosmWasmClient`, passing:
  - The `url` of the network.
  - The `address` of our wallet.
  - A closure capturing our `signingPen`, to sign the transaction.
  - A randomized seed, for privacy - this was generated above by `EnigmaUtils.GenerateNewSeed()`
  - Some fees to reward the validator which will process our transaction.
- Next, we send the specified amount of token using `sendTokens`, passing:
  - The recipient `address`.
  - The amount, and `denom` (denomination) of the token - in this case `uscrt`. Note that the format here is an object inside of an array: `[{}]`. This is because the `fees` amount is using the TypeScript definition for the `Coin` interface, which is a `ReadOnlyArray<Coin>` containing both the `denom` and `amount`.
  - An optional `memo` to identify the transaction.

---

# ✅ Make sure it works

Once the code in `pages/api/secret/transfer.ts` is complete, fill in the amount of **SCRT** you want to send to your favorite pizza maker (and as you realize, it was yourself), then click on **Submit Transfer** to send the transaction.

---

# 🏁 Conclusion

Now that we have funded our account and made a transfer, let's move on to deploying some code (known as a "smart contract") to the **Secret** blockchain! Ready to take the plunge? Let's go!

'''
'''--- markdown/solana/CHAIN_CONNECTION.md ---
In the following tutorials, we're going to interact with the Solana blockchain (and in particular its Devnet network) using the `@solana/web3.js` library. It's a convenient way to interface with the RPC API when building a Javascript application. Under the hood it implements Solana's RPC methods and exposes them as Javascript objects. We will explore it together as we add features to our app.

You can choose which Cluster to connect to using the dropdown located in the top right of the UI, as shown below. For the Pathway, we can connect to Datahub or Devnet. If you are using a Test Validator, select the Localnet option.

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/solana/solana-chain-connection.png)

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/solana/connect.ts`, implement `connect` by creating a `Connection` instance and getting the API version. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {network} = req.body;
    const url = getNodeURL(network);
    const connection = undefined;
    const version = undefined;
    res.status(200).json(version["solana-core"]);
  }
 //...
```

**Need some help?** Check out these links 👇

- [Creating a `Connection` instance](https://solana-labs.github.io/solana-web3.js/classes/Connection.html#constructor)
- [Getting the API `version`](https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getVersion)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const version = await connection.getVersion();
    res.status(200).json(version['solana-core']);
  }
//...
```

**What happened in the code above?**

- We created a `connection` instance of the `Connection` class using the `new` constructor.
- We then call `getVersion` on that `connection` instance. The docs state that `connection.getVersion` returns a Promise, so remember to use the `await` syntax.

---

# ✅ Make sure it works

Once you've made the necessary changes to `pages/api/solana/connect.ts` and saved the file, click on the blue 'power icon' button on the right side of the screen to connect & display the current version of the Solana node!

---

# 🏁 Conclusion

We're going to use this `connection` instance every time we need to connect to Solana. Now we're going to want to move some tokens around, but first we need an account to hold tokens! That's what we'll do in the next tutorial, create a keypair on Solana so that we have an account.

'''
'''--- markdown/solana/CREATE_ACCOUNT.md ---
Like with most Web 3 protocols, transactions on Solana happen between **accounts**. To create an account, a client generates a **keypair** which has a **public key** (or **address**, used to identify and lookup an account) and a **secret key** used to sign transactions.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/solana/keypair.ts`, implement `keypair` and parse the keypair to extract the address as a string. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
const keypair = undefined;
const address = undefined;
const secret = JSON.stringify(Array.from(keypair.secretKey));
//...
```

**Need some help?** Check out these links 👇

- [Generate a `Keypair`](https://solana-labs.github.io/solana-web3.js/classes/Keypair.html#constructor)
- [Convert a `PublicKey` to a string](https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html#toString)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
const keypair = Keypair.generate();
const address = keypair?.publicKey.toString();
const secret = JSON.stringify(Array.from(keypair.secretKey));
//...
```

**What happened in the code above?**

- We used the `Keypair` from `@solana/web3.js` to `generate()` a keypair.
- Parse the keypair object to extract the public key (as a string) using `keypair?.publicKey.toString()`.
  - Using the nullish coalescing operator and optional chaining operator `?.` because we don't want to return undefined values to the client-side.
- The secret key is kept in array format, so `Array.from` will be useful. To send it back to the client-side in a usable format, we need to remember to use `JSON.stringify`.

---

# ✅ Make sure it works

Once the code in `pages/api/solana/keypair.ts` is complete and the file is saved, Next.js will rebuild the API route. Now click on **Generate Keypair** to get a keypair and display the public key.

**Click on "Generate Keypair" again. And again. And again!** Each time, it will generate a new one with virtually no risk that someone else creates the same one as you. That's because the domain of possible addresses is so vast that the probability of two identical addresses being generated is ridiculously small.

---

# 🏁 Conclusion

Now that we have an account, we can fund it with an **airdrop** and start playing around with tokens!

'''
'''--- markdown/solana/DEPLOY_CONTRACT.md ---
A **program** is to Solana what a **smart contract** is to other protocols. Once a program has been deployed, any app can interact with it by sending a transaction containing the program instructions to a Solana cluster, which will pass it to the program to be run.

{% hint style="info" %}
[Click here to learn more about Solana's programs](https://docs.solana.com/developing/on-chain-programs/overview).
{% endhint %}

# 🧐 Smart contract review

The Rust source code for the program we will deploy is located in `contracts/solana/program/src/lib.rs`. The `contracts/solana/program/` directory contains some configuration files to help us compile and deploy it.

**It's a simple program, all it does is increment a number every time it's called.**

Let’s dissect what each part does.

```rust
// contracts/solana/program/src/lib.rs
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};
```

In Rust, [`use` declarations](https://doc.rust-lang.org/reference/items/use-declarations.html) are convenient shortcuts to other code. In this case, the serialize and de-serialize functions from the [borsh](https://borsh.io/) crate. borsh stands for _**B**inary **O**bject **R**epresentation **S**erializer for **H**ashing_.  
A [crate](https://learning-rust.github.io/docs/a4.cargo,crates_and_basic_project_structure.html#Crate) is a collection of source code which can be distributed and compiled together. Learn more about [Cargo, Crates and basic project structure](https://learning-rust.github.io/docs/a4.cargo,crates_and_basic_project_structure.html).

We also `use` portions of the `solana_program` crate :

- A function to return the next `AccountInfo` as well as the struct for `AccountInfo`.
- The `entrypoint` macro and related `entrypoint::ProgramResult`.
- The `msg` macro, for low-impact logging on the blockchain.
- `program_error::ProgramError` which allows on-chain programs to implement program-specific error types and see them returned by the Solana runtime. A program-specific error may be any type that is represented as or serialized to a u32 integer.
- The `pubkey::Pubkey` struct.

Next, we will use the `derive` macro to generate all the necessary boilerplate code to wrap our `GreetingAccount` struct. This happens behind the scenes during compile time [with any `#[derive()]` macros](https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros). Rust macros are a rather large topic to take in, but well worth the effort to understand. For now, just know that this is a shortcut for boilerplate code that is inserted at compile time.

The struct declaration itself is simple, we are using the `pub` keyword to declare our struct publicly accessible, meaning other programs and functions can use it. The `struct` keyword is letting the compiler know that we are defining a struct named `GreetingAccount`, which has a single field: `counter` with a type of `u32`, an unsigned 32-bit integer. This means our counter cannot be larger than [`4,294,967,295`](https://en.wikipedia.org/wiki/4,294,967,295).

```rust
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct GreetingAccount {
    pub counter: u32,
}
```

Next, we declare an entry point - the `process_instruction` function :

```rust
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    _instruction_data: &[u8],
) -> ProgramResult {
    msg!("Hello World Rust program entrypoint");
    let accounts_iter = &mut accounts.iter();
    let account = next_account_info(accounts_iter)?;
```

- The return value of the `process_instruction` entrypoint will be a `ProgramResult` .  
  [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html) comes from the `std` crate and is used to express the possibility of error.
- For [debugging](https://docs.solana.com/developing/on-chain-programs/debugging), we can print messages to the Program Log [with the `msg!()` macro](https://docs.rs/solana-program/1.7.3/solana_program/macro.msg.html), rather than use `println!()` which would be prohibitive in terms of computational cost for the network.
- The `let` keyword in Rust binds a value to a variable. By looping through the `accounts` using an [iterator](https://doc.rust-lang.org/book/ch13-02-iterators.html), `accounts_iter` is taking a [mutable reference](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references) of each value in `accounts`. Then `next_account_info(accounts_iter)?`will return the next `AccountInfo` or a `NotEnoughAccountKeys` error. Notice the `?` at the end, this is a [shortcut expression](https://doc.rust-lang.org/std/result/#the-question-mark-operator-) in Rust for [error propagation](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors).

```rust
if account.owner != program_id {
  msg!("Greeted account does not have the correct program id");
  return Err(ProgramError::IncorrectProgramId);
}
```

We will perform a security check to see if the account owner has permission. If the `account.owner` public key does not equal the `program_id` we will return an error.

```rust
let mut greeting_account = GreetingAccount::try_from_slice(&account.data.borrow())?;
greeting_account.counter += 1;
greeting_account.serialize(&mut &mut account.data.borrow_mut()[..])?;

msg!("Greeted {} time(s)!", greeting_account.counter);

Ok(())
```

Finally, we get to the good stuff where we "borrow" the existing account data, increase the value of `counter` by one and write it back to storage.

- The `GreetingAccount` struct has only one field - `counter`. To be able to modify it, we need to borrow the reference to `account.data` with the `&` [borrow operator](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators).
- The `try_from_slice()` function from `BorshDeserialize` will mutably reference and deserialize the `account.data`.
- The `borrow()` function comes from the Rust core library, and exists to immutably borrow the wrapped value.

Taken together, this is saying that we will borrow the account data and pass it to a function that will deserialize it and return an error if one occurs. Recall that `?` is for error propagation.

Next, incrementing the value of `counter` by 1 is simple, using the addition assignment operator : `+=`.

With the `serialize()` function from `BorshSerialize`, the new `counter` value is sent back to Solana in the correct format. The mechanism by which this occurs is the [Write trait](https://doc.rust-lang.org/std/io/trait.Write.html) from the `std::io` crate.

We can then show in the Program Log how many times the count has been incremented by using the `msg!()` macro.

---

# 💻 Set up the Solana CLI

## Install Rust and Solana CLI

So far we've been using Solana's JS API to interact with the blockchain. To deploy a Solana program, we'll use another Solana developer tool: their Command Line Interface (CLI). We'll install it and use it through our terminal.

For simplicity, perform both of these installations inside the project root (`/learn-web3-dapp/`):

{% hint style="info" %}
If you're using Gitpod the Rust toolchain is already installed, but you will still need to install the Solana CLI.
{% endhint %}

[**Install the latest Rust stable**](https://rustup.rs) :

```text
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Developers using macOS may want to use the following commands instead:

```text
curl https://sh.rustup.rs -sSf | bash -s -- -y --no-modify-path
source $HOME/.cargo/env
```

[**Install the Solana CLI**](https://docs.solana.com/cli/install-solana-cli-tools):

```text
sh -c "$(curl -sSfL https://release.solana.com/v1.10.25/install)"
```

---

## Set up Solana CLI

We need to configure the Solana cluster, create an account, request an airdrop and check that everything is functioning properly before we deploy our program.

Set the CLI config URL to the devnet cluster:

```text
solana config set --url https://api.devnet.solana.com
```

Next, we're going to generate a new keypair using the CLI. Run the following command in your terminal:

{% hint style="info" %}
Make sure you're running these commands from the `/learn-web3-dapp/` directory, which is the **root directory** of the repository.
{% endhint %}

```text
mkdir solana-wallet
solana-keygen new --outfile solana-wallet/keypair.json
```

You will need **SOL** available in the account to deploy the program, so get an airdrop with:

```text
solana airdrop 1 $(solana-keygen pubkey solana-wallet/keypair.json)
```

{% hint style="info" %}
In a Windows terminal, the `$( )` syntax does not work, so just paste the public key you want to fund after the airdrop amount - for example: `solana airdrop 1 C1qx2QUZq7EyLZao4U98fRb8HkT3X5fsGWUc25VyCRBn`
{% endhint %}

Verify that everything is configured and the address is now funded with 1 SOL:

```text
solana config get
solana account $(solana-keygen pubkey solana-wallet/keypair.json)
```

---

# 🧩 Deploy a Solana program

The program we're going to deploy keeps track of the number of times an account has sent a greeting instruction to it. This is an effective demonstration of how storage works on Solana.

## 🧱 Building the program

The first thing we're going to do is compile the Rust program to prepare it for the CLI. To do this we're going to use a custom script that's defined in `package.json`. Let's run the script and build the program by running the following command in the terminal (from the project root directory):

{% hint style="tip" %}
This step can take a few minutes!
{% endhint %}

```text
yarn run solana:build:program
```

{% hint style="tip" %}
If you have cloned the repo locally and you are using WSL or Linux, you might get an **error: linker `cc` not found** when compiling the Solana program. You will need to install the **build-essential** package by running `sudo apt install build-essential`, or the install command for your specific Linux distribution.
{% endhint %}

When it's successful, you will see the instructions to execute the deploy command with the path to the compiled program named `helloworld.so`. While this would work, we want to specify the keypair we generated just for this purpose, so read on.

```text
To deploy this program:
  $ solana program deploy /home/zu/project/figment/learn-web3-dapp/dist/solana/program/helloworld.so
Done in 1.39s.
```

{% hint style="info" %}
The `.so` extension does not stand for Solana! It stands for "shared object". You can learn more about Solana Programs in the [developer documentation](https://docs.solana.com/developing/on-chain-programs/overview).
{% endhint %}

---

## ⛓ Deploying the program

Now we're going to deploy the program to the devnet cluster. The CLI provides a simple interface for this, `solana deploy`:

{% hint style="info" %}
Make sure you're running this command from the `/learn-web3-dapp/` directory, which is the **root directory** of the repository (otherwise, you would need to change the paths to the `keypair.json` and the `helloworld.so` file).
{% endhint %}

```text
solana deploy -v --keypair solana-wallet/keypair.json dist/solana/program/helloworld.so
```

The `-v` Verbose flag is optional, but it will show some related information like the RPC URL and path to the default signer keypair, as well as the expected [**Commitment level**](https://docs.solana.com/implemented-proposals/commitment). When the process completes, the Program Id will be displayed :

On success, the CLI will print the **programId** of the deployed contract.

```text
RPC URL: https://api.devnet.solana.com
Default Signer Path: solana-wallet/keypair.json
Commitment: confirmed
Program Id: 7KwpCaaYXRsjfCTvf85eCVuZDW894zZNN38UMxMpQoaQ
```

## ⛓ Deploying the program to a test validator inside Gitpod

First, you will need to change the Solana CLI target cluster with the terminal command:

```text
solana config set --url http://127.0.0.1:8899
```

Next, run a test validator using the terminal command:

```text
solana-test-validator
```

This will have similar output as shown below, and prevent you from entering other commands into the terminal where you run `solana-test-validator` until you stop the process with `Ctrl+C`:

```text
Ledger location: test-ledger
Log: test-ledger/validator.log
 Initializing...
 Initializing...
Identity: HsrXahBfC7ZbxovF78k9SiY7UZ43MmkyiWDsJi6bM7u4
Genesis Hash: 3m667qKgVF3a97rRWWbHLX1U2YbeAEgHqzEDjBiXgPsH
Version: 1.9.5
Shred Version: 44724
Gossip Address: 127.0.0.1:1024
TPU Address: 127.0.0.1:1027
JSON RPC URL: http://127.0.0.1:8899
 00:00:20 | Processed Slot: 46 | Confirmed Slot: 46 |
```

Open a new terminal in Gitpod (or split the one running the test validator). In this new terminal, you will need to add the location of the Solana CLI to your PATH with the command:

```text
export PATH="/home/gitpod/.local/share/solana/install/active_release/bin:$PATH"
```

Make sure your keypair in `/solana-wallet/keypair.json` has a SOL balance to pay for the deployment by airdropping it some SOL (and since it's on a test validator, you can specify a much higher amount of SOL):

```text
solana airdrop 100 $(solana-keygen pubkey solana-wallet/keypair.json)
```

You can now deploy the program to the test validator with the command:

```text
solana deploy -v --keypair solana-wallet/keypair.json dist/solana/program/helloworld.so
```

The last thing to change is the selected cluster in the Pathway UI. Go back to the "Connect to Solana" step using the navigation buttons at the bottom of the screen, there you can pick the **localnet** option from the Network dropdown on the top of the page. Don't forget to repeat the airdrop step, to make sure that the keypair is funded with SOL. You can now proceed with the code challenge and the Pathway will check the test validator for the deployed program instead of devnet, circumventing the issue with Gitpod! 😅

---

# 🏋️ Challenge

{% hint style="tip" %}
Before moving to the next step, we need to check that our program has been correctly deployed! For this, we'll need the `programId` of the program. Copy & paste it into the text input, then try to figure out how to complete the code for `pages/api/solana/deploy.ts`.
{% endhint %}

**Take a few minutes to figure this out.**

```tsx
//...
  try {
    const {network, programId} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    // Get the publicKey of the programId and get its account info
    const publicKey = undefined;
    const programInfo = undefined;

    if (programInfo === null) {
      if (fs.existsSync(PROGRAM_SO_PATH)) {
        throw new Error(
          'Program needs to be deployed with `solana deploy`',
        );
      } else {
        throw new Error('Program needs to be built and deployed');
      }
    } else if (!programInfo.executable) {
      throw new Error(`Program is not executable`);
    }

    res.status(200).json(true);
  }
//...
```

**Need some help?** Check out these links 👇

- [How to get account info](https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getAccountInfo)
- [Is an account executable?](https://solana-labs.github.io/solana-web3.js/modules.html#AccountInfo)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```tsx
// solution
//...
  try {
    const {network, programId} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const publicKey = new PublicKey(programId);
    const programInfo = await connection.getAccountInfo(publicKey);

    if (programInfo === null) {
      if (fs.existsSync(PROGRAM_SO_PATH)) {
        throw new Error(
          'Program needs to be deployed with `solana deploy`',
        );
      } else {
        throw new Error('Program needs to be built and deployed');
      }
    } else if (!programInfo.executable) {
      throw new Error(`Program is not executable`);
    }

    res.status(200).json(true);
  }
//...
```

**What happened in the code above?**

- We create a new `PublicKey` instance from the `programId` string formatted address.
- Once we have it, we call the `getAccountInfo` method to check the info available for this address.
  - If none, then no account is linked to this address, meaning the program has not yet been deployed.
- Then we check if the account's executable property is true. If it is, then the specified account contains a loaded program.
- Finally, we send a value of `true` to the client-side in JSON format.

---

# ✅ Make sure it works

Once the code in `pages/api/solana/deploy.ts` is complete, copy & paste the Program Id from the deployment step into the text input, then click on **Check Deployment**.

---

# 🏁 Conclusion

So at this point, we've deployed our program to Solana's devnet cluster and checked that it went smoothly. Now it's time to create an account that is owned by our program, to store some data on the Solana cluster!

'''
'''--- markdown/solana/FINAL.md ---
🥳 **Congratulations**, you have completed the Solana Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to a Solana cluster using the web3.js library
- 🏦 Generating a new keypair, then funding the resulting address with an airdrop
- 💸 Transferring tokens between accounts
- ⛓ Deploying and interacting with a Solana program, written in Rust

# 🧐 Keep learning with these resources:

- 🏗 [The Solana dapp-scaffold](https://github.com/solana-labs/dapp-scaffold)
- ⚓️ [Project Serum's Anchor framework](https://github.com/project-serum/anchor)
- 📚 [A complete guide to full-stack Solana development](https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/solana/FUND_ACCOUNT.md ---
With some protocols, different networks (testnet, mainnet, etc) have different token names. For example with Polkadot, the mainnet token is **DOT** and the testnet token is **WND**. In the Solana world, the token is always called **SOL**, no matter what network (or **cluster**) you are on. Don't get too excited: the tokens you get for free on the devnet cannot be used on Solana's mainnet. Nice try though 😉

---

# 🪂 Airdropping

To fund an account, we will do what is called an **airdrop** - some tokens will magically fall from the sky into our wallets! The cluster will provide us with some **SOL** so that we can test making transfers as well as view the transaction details on a block explorer.

{% hint style="info" %}
1 **SOL** is equal to 1,000,000,000 **lamports**. The name of **lamports** is in honour of Solana's biggest technical influence, [Leslie Lamport](https://en.wikipedia.org/wiki/Leslie_Lamport).
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/solana/fund.ts`, implement the `fund` function. Convert the address passed in the request body to a public key and use `requestAirdrop` to get 1 **SOL**. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
//..
  try {
    const {network, address} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, "confirmed");
    const publicKey = undefined;
    const hash = undefined;
    await undefined;
    res.status(200).json(hash);
  }
//..
```

**Need some help?** Check out these links 👇

- [Create a publicKey from a string](https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html#constructor)
- [`requestAirdrop` documentation](https://solana-labs.github.io/solana-web3.js/classes/Connection.html#requestAirdrop)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//..
  try {
    const {network, address} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const publicKey = new PublicKey(address);
    const hash = await connection.requestAirdrop(publicKey, LAMPORTS_PER_SOL);
    await connection.confirmTransaction(hash);
    res.status(200).json(hash);
  }
//..
```

**What happened in the code above?**

- We created a `PublicKey` from the string formatted address.
- We pass this to `requestAirdrop`, together with a constant which represents one `SOL`.
- We can then verify that the transaction is confirmed by passing the transaction hash to the `confirmTransaction` method.
- Finally, we return the hash of the transaction to the client-side in JSON format.

---

# ✅ Make sure it works

Once the code in `pages/api/solana/fund.ts` is complete, click on **Fund this address**. The transaction is sent and confirmed - You're now 1 SOL richer on the devnet! There are rate limits in place to prevent abuse of the airdrop function, but for now, 1 SOL is more than enough for testing 😊.

---

# 🧐 Anatomy of an Explorer page

When viewing Transaction details on the Solana Explorer:

1. You can click on the Cluster name in the top right corner to choose which Solana Cluster to view.

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/solana/solana-fund-account.png)

2. The Overview panel displays information such as the transaction signature, which block it was included in and what the fee amount for the transaction was.

3. The Account Input(s) panel displays the accounts involved in the transaction, including the change in their SOL balance and details like which account paid the transaction fee, and the account responsible for signing the transaction.

4. The Instruction(s) panel displays which Program instructions were used in the transaction. Most of the time, this will be the Transfer instruction.

5. The Program Log contains logging output from the execution of the Program. Log output can be useful for developers to assist in debugging their programs.

More information about the terminology used on the Solana Explorer is available in the [terminology](https://docs.solana.com/terminology) section of the Solana docs.

---

# 🏁 Conclusion

Before we make our first transfer, let's check that the account is funded by asking the cluster for the balance of our public key!

'''
'''--- markdown/solana/GET_BALANCE.md ---
Before making a transfer, we need to check our account balance to make sure we have enough **SOL** to perform a transfer. The `getBalance()` function takes a `publicKey` as input and will return the balance associated with that `publicKey`, if there is any.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/solana/balance.ts`, implement `publicKey` & `balance`.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {network, address} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const publicKey = undefined;
    const balance = undefined;
    if (balance === 0 || balance === undefined) {
      throw new Error('Account not funded');
    }
    res.status(200).json(balance);
  }
//...
```

**Need some help?** Check out these links 👇

- [Read about getBalance](https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getBalance)
- [Create a publicKey from a string](https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html#constructor)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network, address} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const publicKey = new PublicKey(address);
    const balance = await connection.getBalance(publicKey);
    if (balance === 0 || balance === undefined) {
      throw new Error('Account not funded');
    }
    res.status(200).json(balance);
  }
//...
```

**What happened in the code above?**

- We created an instance of the `PublicKey` using the string formatted address
- Call `connection.getBalance` with that `publicKey`
- Be aware that the balance is denominated in `LAMPORTS`. Remember, `console.log` is your friend 😁

---

# ✅ Make sure it works

Once the code in `pages/api/solana/balance.ts` is complete, click on **Check Balance** to query the cluster and display the balance of the given public key.

---

# 🏁 Conclusion

Now that we have an account that has been funded with **SOL** tokens, we are ready to make a transfer to another account!

'''
'''--- markdown/solana/GET_CONTRACT_VALUE.md ---
Data is stored into an account as a **buffer**. To access the data, we'll have to first unpack this blob of data into a well defined structure. The code below allows our TypeScript program to achieve this goal: deserializing a greeter's buffer into a TypeScript class.

```typescript
// The state of a greeting account managed by the hello world program
class GreetingAccount {
  counter = 0;
  constructor(fields: {counter: number} | undefined = undefined) {
    if (fields) {
      this.counter = fields.counter;
    }
  }
}

// Borsh schema definition for greeting accounts
const GreetingSchema = new Map([
  [GreetingAccount, {kind: 'struct', fields: [['counter', 'u32']]}],
]);
```

{% hint style="info" %}
[Learn more about the borsh library](https://npm.io/package/borsh)
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/solana/getter.ts`, complete the code for `getter`. First deserialize the greeter data to a TypeScript class, then access the counter value and pass it to the response object using the `.json()` method as in all previous tutorials.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
if (accountInfo === null) {
  throw new Error('Error: cannot find the greeted account');
}

// Find the expected parameters.
const greeting = borsh.deserialize(undefined);

// A little helper
console.log(greeting);

// Pass the counter to the client-side as JSON
res.status(200).json(undefined);
//...
```

**Need some help?** Check out this link 👇

- [Read about the deserialize method](https://npm.io/package/borsh)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
if (accountInfo === null) {
  throw new Error('Error: cannot find the greeted account');
}

const greeting = borsh.deserialize(
  GreetingSchema,
  GreetingAccount,
  accountInfo.data,
);

res.status(200).json(greeting.counter);
//...
```

**What happened in the code above?**

- The `deserialize()` function takes a schema, a class type and a buffer as input.
- The **Schema** and the **Account**'s key (here key refers to the key of a map struct, **not** a public or private key), and then the binary data stored into **greeter**.

- Finally, we just need to call the property `counter` of `greeting` to pass the value as JSON back to the client-side.

---

# ✅ Make sure it works

Once the code in `pages/api/solana/getter.ts` is complete, click on **Get Greeting** to get the data stored in the Greeter account and display it on the page.

---

# 🏁 Conclusion

Simply getting the number of greetings is not enough, we'd like to also _send_ a greeting to our program. We're going to learn how to do that in the next step. Ready?

'''
'''--- markdown/solana/PROJECT_SETUP.md ---
# 💻 Requirements

You will need to [install the Solana CLI](https://docs.solana.com/cli/install-solana-cli-tools) to complete this Pathway.

## 🐑 Local clone

If you cloned the `learn-web3-dapp` repo locally, pay attention to the following:

{% hint style="tip" %}
**Windows Users:** There are known compatibility issues with the Solana BPF toolchain. You will need to use the Windows Subsystem for Linux to compile Solana programs. Please refer to the [installation guide](https://docs.figment.io/network-documentation/extra-guides/solana-setup-for-windows) we have provided.\
**macOS Users:** If you are using any Apple Silicon products (M1 processor), you may need to build the Solana CLI from source. [Refer to this article for more information](https://dev.to/codenjobs/how-to-make-solana-test-validator-work-with-a-macbook-with-m1-chip-5emd).
{% endhint %}

---

# 🧩 DataHub API keys

If you wish to make use of the Pathway content using DataHub, you will need a DataHub account and a valid API key to access Solana via DataHub's infrastructure. [Sign up for a DataHub account](https://datahub-beta.figment.io/signup) and verify your email address. Once you have logged in to DataHub, you will need to create a new app and select the Solana protocol.

Click "Create New App":

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_1.png?raw=true)

Type in a name for your app, select the **Staging** environment, then click on the **Solana** icon in the list of available protocols. \
Click "Create app" when you're finished:

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_2.png?raw=true)

You can now find your API key on the Overview tab of the app on the [**DataHub Dashboard**](https://datahub-beta.figment.io/apps):

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/dh_api_3.png?raw=true)

To use your API key, you should copy the contents of the `.env.example` file located in the project root directory (`/learn-web3-dapp/.env.example`) into a new file named `.env.local` (`/learn-web3-dapp/.env.local`). Also, since this file will contain your API key, we have already added it to the `.gitignore`.

{% hint style="info" %}
Easily duplicate the file with the terminal command `cp .env.example .env.local`!
{% endhint %}

You can then paste your unique API key into `.env.local`, as the value for the environment variable `DATAHUB_SOLANA_API_KEY`. This will authenticate you and enable you to make requests to Solana via DataHub. **The API key shown below is only an example and cannot be used to access DataHub**.

```yaml
# DataHub API keys
DATAHUB_AVALANCHE_API_KEY=
DATAHUB_CELO_API_KEY=
DATAHUB_NEAR_API_KEY=
DATAHUB_POLKADOT_API_KEY=
DATAHUB_POLYGON_API_KEY=
DATAHUB_SECRET_API_KEY=
DATAHUB_SOLANA_API_KEY=81436edcf907b0fbb8493d281cdff5af
DATAHUB_TEZOS_API_KEY=
```

---

# 🤖 Using a Test Validator

At some point it may be necessary to run a Test Validator. For example, if you can't get airdrops because the Devnet faucet is not working. To run a local Test Validator you will need to have the Solana CLI installed. Use this command in its own terminal tab or window :

```text
solana-test-validator
```

Use `solana config set` to target a particular cluster. After setting a cluster target, any future subcommands will send/receive information from that cluster. To target a running Test Validator with the Solana CLI :

```text
solana config set --url http://localhost:8899
```

You can see which cluster the Solana command-line tool (CLI) is currently targeting and the paths to your keypair and configuration file with the command :

```text
solana config get
```

---

# 🔐 Keypair storage

During the "Create an account" step, you will need to generate a keypair for use in the tutorials (by completing the code challenge). This keypair is kept in the localstorage of your web browser, and is distinct from any keypairs generated by the Solana CLI. After the keypair is generated, it will remain visible (and copyable) at the top of the screen.

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/solana/solana-setup-02.png)

---

# 👣 Next Steps

Once you have your Solana API key saved in `/learn-web3-dapp/.env.local`, you're ready to begin.
Click on the **Next: Connect to Solana** button below.

'''
'''--- markdown/solana/SET_CONTRACT_VALUE.md ---
Last but certainly not least, we'll need to modify the data stored into **greeter**. Doing so will change the state of the blockchain, so we'll have to create a transaction. In the challenge below, we're going to show you how to achieve this.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/solana/setter.ts`, complete the `setter` function. First you'll have to create an instruction, then you'll have to send and confirm a transaction to store the data from. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
// this your turn to figure out
// how to create this instruction
const instruction = new TransactionInstruction(undefined);

// this your turn to figure out
// how to create this transaction
const hash = await sendAndConfirmTransaction(undefined);

res.status(200).json(undefined);
//...
```

**Need some help?** Here are a few hints

- [Read about TransactionInstruction](https://solana-labs.github.io/solana-web3.js/classes/TransactionInstruction.html)
- [Read about sendAndConfirmTransaction](https://solana-labs.github.io/solana-web3.js/modules.html#sendAndConfirmTransaction)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
const instruction = new TransactionInstruction({
  keys: [{pubkey: greeterPublicKey, isSigner: false, isWritable: true}],
  programId: programKey,
  data: Buffer.alloc(0), // All instructions are hellos
});

const hash = await sendAndConfirmTransaction(
  connection,
  new Transaction().add(instruction),
  [payerKeypair],
);

res.status(200).json(hash);
//...
```

**What happened in the code above?**

- First, we create a `new` instance of the `TransactionInstruction` class:
  - With the greeter's public key, setting the **isWritable** flag to `true`
  - With the `programId` or address of the program we want to call: `programKey`.
  - With the data we want to pass to the call. In this case, there is only one kind of instruction we can send and `Buffer.alloc(0)` is like referring to the zero-index of an array. If there were multiple instructions, we would alter this value.
- Then we send and await the transaction confirmation. `[payerKeypair]` is the account created during second tutorial, "Create an account".

---

# ✅ Make sure it works

Once the code in `pages/api/solana/setter.ts` is complete, click on **Send Greeting** to perform the transaction and increment the stored number of greetings by 1.

---

# 🏁 Conclusion

From connecting to a cluster to deploying and interacting with programs, you've covered all the basics of using Solana! Proceed to the final step for a quick recap and some links to additional learning resources.

'''
'''--- markdown/solana/SOLANA_CREATE_GREETER.md ---
Solana programs are stateless, which means they don't store the value they act on. Then how can our program keep count of the number of times it has been greeted?

We have to rely on another account to store the data - Which is why we're going to create a new account, the **greeter account** (owned by our program) in order to store the counter info.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/solana/greeter.ts`, implement `greeter`. First, derive the **greeter** address from some values. Then create a transaction which instructs the blockchain to create the **greeter** account. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
// Are there any methods from PublicKey to derive a public key from a seed?
const greetedPubkey = await PublicKey.undefined;

// This function calculates the fees we have to pay to keep the newly
// created account alive on the blockchain. We're naming it lamports because
// that is the denomination of the amount being returned by the function.
const lamports = await connection.getMinimumBalanceForRentExemption(
  GREETING_SIZE,
);

// Find which instructions are expected and complete SystemProgram with
// the required arguments.
const transaction = new Transaction().add(SystemProgram.undefined);

// Complete this function call with the expected arguments.
const hash = await sendAndConfirmTransaction(undefined);
//...
```

**Need some help?** Check out these links 👇

- [Create a publicKey from a seed](https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html#createWithSeed)
- [Create an account from a seed](https://solana-labs.github.io/solana-web3.js/classes/SystemProgram.html#createAccountWithSeed)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
const greetedPubkey = await PublicKey.createWithSeed(
  payer.publicKey,
  GREETING_SEED,
  programId,
);

const lamports = await connection.getMinimumBalanceForRentExemption(
  GREETING_SIZE,
);

const transaction = new Transaction().add(
  SystemProgram.createAccountWithSeed({
    fromPubkey: payer.publicKey,
    basePubkey: payer.publicKey,
    seed: GREETING_SEED,
    newAccountPubkey: greetedPubkey,
    lamports,
    space: GREETING_SIZE,
    programId,
  }),
);
const hash = await sendAndConfirmTransaction(connection, transaction, [payer]);
//...
```

**What happened in the code above?**

- We derive a `PublicKey` from three values: the payer of the transaction, a random seed and the programId.
- Next we call the system program `createAccountWithSeed` to create an account, passing the parameters:
  - `fromPubkey`: The account that will transfer lamports to the created account.
  - `newAccountPubkey`: Public key of the created account. Must be pre-calculated with `PublicKey.createWithSeed()`.
  - `basePubkey`: Base public key to use to derive the address of the created account. Must be the same as the base key used to create `newAccountPubkey`.
  - `seed`: Seed to use to derive the address of the created account. Defined in `GREETING_SEED`.
  - `lamports`: Amount of lamports to transfer to the created account. We calculated the minimum balance for rent exemption based on `GREETING_SIZE`.
  - `space`: Amount of space in bytes to allocate to the created account.
  - `programId`: Public key of the program to assign as the owner of the created account.
- Finally we send and await the transaction confirmation. `[payer]` in this case being the account created during the second tutorial, "Create an account".

Learn more about Solana's [rent exemption](https://docs.solana.com/developing/programming-model/accounts#rent-exemption) and also about the [SystemProgram](https://docs.solana.com/developing/runtime-facilities/programs#system-program).

---

# ✅ Make sure it works

Once the code in `pages/api/solana/greeter.ts` is complete, click on **Create Greeter** to derive the greeter account from the programId and perform the transaction to create it.

---

# 🏁 Conclusion

Now we have an account owned by the program and dedicated to storing the program data. We are ready to go ahead and act on the data. The first natural action is to read the data. Ready?

'''
'''--- markdown/solana/TRANSFER_TOKEN.md ---
In order to transfer some value to another account, we need to create and send a signed transaction to the **cluster**. Once you understand how to do this, you will have a solid foundation on which to interact with other portions of the Solana API.

When a transaction is submitted to the **cluster**, the Solana runtime will execute a program to process each of the instructions contained in the transaction, in order, and atomically. This means that if any of the instructions fail for any reason, the entire transaction will revert.

when you are transferring lamports make sure it begins with **0.**. so for example **0.2** otherwise transaction will give you an error

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/solana/transfer.ts` finish implementing the `transfer()` function.
{% endhint %}

**Take a few minutes to figure this out.**

```typescript
//.. let's skip the beginning as it should be familiar for you by now!
// Find the parameter to pass
const instructions = SystemProgram.transfer;

// How could you construct a signer array?
const signers = undefined;

// Maybe adding someting to a Transaction could be interesting?
const transaction = new Transaction();

// We can send and confirm a transaction in one line of code.
const hash = undefined;
//..
```

**Need some help?** Here are a few hints

- [Read about `sendAndConfirmTransaction`](https://solana-labs.github.io/solana-web3.js/modules.html#sendAndConfirmTransaction)
- [Read about adding instructions to `Transaction`](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html#add)
- [Anatomy of a `Transaction`](https://docs.solana.com/developing/programming-model/transactions)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//... let's skip the beginning as it should be familiar for you by now!
const instructions = SystemProgram.transfer({
  fromPubkey,
  toPubkey,
  lamports,
});

const signers = [
  {
    publicKey: fromPubkey,
    secretKey,
  },
];

const transaction = new Transaction().add(instructions);

const hash = await sendAndConfirmTransaction(connection, transaction, signers);

res.status(200).json(hash);
//..
```

**What happened in the code above:**

- We create `instructions` for the transfer, supplying a **sender** a **receiver** and an **amount**.
- We also need a `signers` array with only one signer: the account sending the transaction. It contains both the signers `publicKey` & `secretKey`.
  - The `secretKey` is used to sign the transaction.
- Create a new `Transaction` object and add the `instructions` to it.
- Send and await the confirmation of the signed transaction using `sendAndConfirmTransaction`.
- Finally, we return the transaction hash to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/solana/transfer.ts` is complete, you can enter an amount to transfer in the form field, click to generate a random address to send the transfer to and then click **Submit Transfer**. Remember that 1 SOL is equal to 1,000,000,000 lamports.

---

# 🧐 Anatomy of an Explorer page

When viewing Account details on the Solana Explorer:

![](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/solana/solana-transfer.png)

1. The Account Overview panel displays information about the account, including its address, balance, and if there is a Program deployed at that address.

2. The History tab displays the Transaction history for the selected account, which is a list of previous transactions that account has been involved in.

3. The Tokens tab displays information regarding any tokens held by the account.

---

# 🏁 Conclusion

Now that you are comfortable with accounts and tokens, we will look at how to deploy a program written in the Rust language to the Solana cluster. Don't worry, this process is not as scary as it sounds 😇

'''
'''--- markdown/tezos/CHAIN_CONNECTION.md ---
In this tutorial we will learn how to connect to a Tezos node via DataHub, using functions from the Taquito JavaScript library.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/tezos/connect.ts`, implement the function and try to establish your first connection to the Tezos network. To verify that the connection has been made, try to return the chainId. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

```typescript
//...
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const toolkit = undefined;
    const chainId = undefined;
    if (validateChain(chainId) != 3) {
      throw Error('invalid chain Id');
    }
    res.status(200).json(chainId);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Class `TezosToolkit`**](https://tezostaquito.io/typedoc/classes/_taquito_taquito.tezostoolkit.html)
- [**Taquito**](https://tezostaquito.io/typedoc/modules.html)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const toolkit = new TezosToolkit(url);
    const chainId = await toolkit.rpc.getChainId();
    if (validateChain(chainId) != 3) {
      throw Error('invalid chain Id');
    }
    res.status(200).json(chainId);
  }
```

**What happened in the code above?**

- `getNodeUrl` is a helper function used to generate a valid endpoint URL.
- The `TezosToolkit` instance manages the connection.
- Unlike other blockchains, Tezos does not expose a software version for nodes. We will instead retrieve the Chain ID with `getChainId`.

---

# ✅ Make sure it works

Once the code in `pages/api/tezos/connect.ts` is complete, click on the blue button to connect to Tezos & display the Chain ID.

---

# 🏁 Conclusion

Congratulations! You have connected to the Tezos blockchain and queried the chain ID with a few lines of JavaScript code. In the next tutorial, we will create an account for use on Florence, the Tezos testnet.

'''
'''--- markdown/tezos/CREATE_ACCOUNT.md ---
A faucet is a way for users to acquire some amount of tokens on a blockchain, typically on a test network, such as the Florence testnet for Tezos. The tokens from the faucet we will be using in this step are not equivalent to the tez on mainnet - there is a difference in how the accounts are derived.

Take all available precautions when dealing with crypto assets. Keeping mnemonic seed phrases and private cryptographic keys safe is an important consideration when dealing with any blockchain, Tezos is no exception.

{% hint style="info" %}
Visit the [faucet](https://teztnets.xyz/hangzhounet-faucet) to generate a mnemonic and get some testnet ꜩ (tez).
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/tezos/account.ts`, implement the function and try to activate your first account on the Tezos network. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {
      mnemonic: mnemonic0,
      email,
      password,
      activation_code: secret,
      network,
    } = req.body;
    const mnemonic = mnemonic0.join(' ');

    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    // call the importKey method
    undefined;
    throw new Error('Please complete the code');

    res.status(200).json(true);
  }
//...
```

**Need some help?** Check out these links 👇

- [**method `importKey`**](https://tezostaquito.io/typedoc/modules/_taquito_signer.html#importkey)
- [**Importing a Faucet Key**](https://tezostaquito.io/docs/quick_start/#importing-a-faucet-key)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {
      mnemonic: mnemonic0,
      email,
      password,
      activation_code: secret,
      network,
    } = req.body;
    const mnemonic = mnemonic0.join(' ');

    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    res.status(200).json(true);
  }
//...
```

**What happened in the code above?**

- First, we create a new `TezosToolkit` instance.
- Next, we call the `importKey` method in order to activate the account.

---

# ✅ Make sure it works

Once the code in `pages/api/tezos/account.ts` is complete, copy & paste the faucet information into the textarea then click on **Create Account**.

---

# 🏁 Conclusion

Nice work! You now have a Tezos account on the testnet. In the next tutorial, we will query a Tezos node using DataHub to determine the current balance of our account.

'''
'''--- markdown/tezos/DEPLOY_CONTRACT.md ---
Although it is beyond the scope of this tutorial to teach the specific syntax of LIGO or Michelson, we will cover the deployment of compiled Michelson code to Tezos. Michelson is a human-readable, stack-based language. It is possible to write smart contracts in Michelson & it can also be compiled directly from LIGO.

{% hint style="info" %}
One of the properties of Michelson is that it has been designed to facilitate formal verification. Further reading on the specifics of formal verification is [available here](https://runtimeverification.com/blog/formal-verification-framework-for-michelson/)
{% endhint %}

We won't go through the process of reviewing the smart contract code base, compiling it or testing it. We will focus instead on how one can deploy a smart contract using the **Taquito** library. To do this, we're going to use a pre-compiled smart contract, you can find the compiled Michelson code under `contracts/tezos/counter.js`.

Our contract will be pretty basic. It stores a counter on the blockchain and implements two functions:

- The `Increment(n)` function which increases by n the counter stored on the contract.
- The `Decrement(n)` function which decreases by n the counter stored on the contract.

{% hint style="info" %}
If you want to learn more about Tezos smart contracts, follow [**The Taco Shop Smart Contract**](https://ligolang.org/docs/tutorials/get-started/tezos-taco-shop-smart-contract) tutorial on the official LIGO site.
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/tezos/deploy.ts`, implement the function and try to deploy the compiled smart contract. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {mnemonic, email, password, secret, network} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    const operation = await undefined;

    const contract = await undefined;

    res.status(200).json({
      contractAddress: contract.address,
      hash: operation.hash
    });
  }
//...
```

**Need some help?** Check out these links 👇

- [**Interface ContractProvider method `originate`**](https://tezostaquito.io/typedoc/interfaces/_taquito_taquito.contractprovider.html#originate)
- [**Class OriginateOperation method `contract`**](https://tezostaquito.io/typedoc/classes/_taquito_taquito.originationoperation.html#contract)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {mnemonic, email, password, secret, network} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    const operation = await tezos.contract.originate({
        code: CONTRACT_JSON,
        storage: 0
      })

    const contract = await operation.contract()

    res.status(200).json({
      contractAddress: contract.address,
      hash: operation.hash
    });
  }
//...
```

**What happened in the code above?**

- First, we create a new `TezosToolkit` instance.
- `importKey` has the side effect of setting the TezosToolkit instance to use the `InMemorySigner` provider.
- Next, we execute the `Tezos.contract.originate` function. This deploys the Michelson contract code to the Tezos blockchain, from the `CONTRACT_JSON` in `counter.js`. The storage property is also set to `0`.
- Next, the resulting operation ([`op`](https://opentezos.com/tezos-basics/operations/)) object is used to provide the contract address of the newly originated contract.

---

# ✅ Make sure it works

Once the code in `pages/api/tezos/deploy.ts` is complete, click on **Deploy the contract** to send the compiled smart contract to the network.

---

# 🏁 Conclusion

Now that we have deployed a smart contract on Tezos, let's interact with it! In the following tutorials, we will look at how to use both view and change functions.

'''
'''--- markdown/tezos/FINAL.md ---
🥳 **Congratulations**, you have completed the Tezos Pathway! \
Here's a quick recap of what we covered:

- 🔌 Connecting to Tezos with the Taquito Javascript library
- 🏦 Creating and funding a testnet account by using the faucet
- 💸 Transferring tokens between accounts
- ⛓ Deploying and interacting with a compiled Michelson smart contract

# 🧐 Keep learning with these resources:

- 🐪 [Learn about migrating from Ethereum to Tezos](https://ligolang.org/docs/tutorials/tz-vs-eth/tz-vs-eth)
- 🚀 [Check out the Tezos Academy](https://tezosacademy.io/)
- 🐍 [Unit testing Python smart contracts](https://learn.figment.io/tutorials/unit-testing-python-smart-contracts-for-tezos-on-smartpy)
- 📚 Continue to explore the [LIGO API documentation](https://ligolang.org/docs/api/cheat-sheet), learn more about [Michelson](https://tezos.gitlab.io/michelson-reference/) or perhaps dive straight into the [JSON/RPC documentation](https://tezos.gitlab.io/developer/rpc.html).

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/tezos/GET_BALANCE.md ---
Now that we have our account created, wouldn’t it be nice to keep track of our **tez** balance? In this step, we will examine how we can do just that!

{% hint style="info" %}
The native token on the **Tezos Blockchain** is **tez** indicated by the **ꜩ** symbol.
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/tezos/balance.ts`, implement the function and try to return the current balance of the account. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    const toolkit = new TezosToolkit(url);
    const balance = undefined;
    res.status(200).json(balance.toString());
  }
//...
```

**Need some help?** Check out these links 👇

- [**method `getBalance`**](https://tezostaquito.io/typedoc/interfaces/_taquito_taquito.tzprovider.html#getbalance)
- [**Get the current Tezos balance for an address`**](https://tezostaquito.io/docs/quick_start/#get-the-current-tezos-balance-for-an-address)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    const toolkit = new TezosToolkit(url);
    const balance = await toolkit.tz.getBalance(address);
    res.status(200).json(balance.toString());
  }
//...
```

**What happened in the code above?**

- First, we create a new `TezosToolkit` instance.
- Next, we call the `getBalance` method of the `tz` module, passing the address of the account we want to know the balance of.

{% hint style="tip" %}
The amount returned by `getBalance` is denominated in **μꜩ** (mutez), so to convert it to **ꜩ** you'll need to divide it by 10\*\*6
{% endhint %}

---

# ✅ Make sure it works

Once the code in `pages/api/tezos/balance.ts` is complete, Next.js will rebuild the API route. Click on **Check Balance** and you should see the balance displayed on the page.

---

# 🏁 Conclusion

Querying the balance information is fun, but being able to submit transactions and change the state of a blockchain is even better! In the next step, we will dive deeper and submit our first transactions on Tezos.

'''
'''--- markdown/tezos/GET_CONTRACT_VALUE.md ---
Our Contract is on-chain, and we're going to learn how to fetch the data stored on the contract.

{% hint style="info" %}
If you want to learn more about Tezos smart contracts, follow [**The Taco Shop Smart Contract**](https://ligolang.org/docs/tutorials/get-started/tezos-taco-shop-smart-contract) tutorial.
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/tezos/getter.ts`, implement the function and try to read the value of the counter stored in the smart contract. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {network, mnemonic, email, password, secret, contract} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    // Use the contract module to get the storage
    const counter = undefined;

    res.status(200).json(counter);
  }
//...
```

**Need some help?** Check out this link 👇

- [**Interface ContractProvider method `getStorage`**](https://tezostaquito.io/typedoc/interfaces/_taquito_taquito.contractprovider.html#getstorage)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network, mnemonic, email, password, secret, contract} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    const counter = await tezos.contract.getStorage(contract);

    res.status(200).json(counter);
  }
//...
```

**What happened in the code above?**

- First, we create a new `TezosToolkit` instance.
- Next, we import our wallet data using `importKey`.
- Then, using the `getStorage` function of the `contract` module, we return the counter stored on the contract.
- Finally, we send the `counter` value converted `toString` back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/tezos/getter.ts` is complete, click the **Get Counter** button to query the current value stored in the smart contract and display it on the page.

---

# 🏁 Conclusion

Nicely done! You learned how to get a value from a smart contract's storage on the Tezos blockchain. Now it is time for the final challenge: Modify the state of the contract and thus the state of the blockchain. Let's go!

'''
'''--- markdown/tezos/PROJECT_SETUP.md ---
# 🧩 DataHub API keys

**DataHub has discontinued support for Tezos**. The Tezos pathway makes use of public RPC endpoints.

---

# 👣 Next Steps

Click on the **Next: Connect to Tezos** button below.

'''
'''--- markdown/tezos/SET_CONTRACT_VALUE.md ---
Our Contract is on-chain, and we're going to learn how to fetch the data stored on the contract.

{% hint style="info" %}
If you want to learn more about Tezos smart contracts, follow [**The Taco Shop Smart Contract**](https://ligolang.org/docs/tutorials/get-started/tezos-taco-shop-smart-contract) tutorial.
{% endhint %}

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/tezos/setter.ts`, implement the function and try to increment the value stored in the smart contract by 1. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {network, mnemonic, email, password, secret, contract} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    const n = 1;
    // Load the interface of the contract
    const counterContract = undefined;
    // Call the increment function of the contract
    const transaction = await undefined;
    // Await confirmations
    await transaction.confirmation(3);

    res.status(200).json(transaction.hash);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Interact with a smart contract**](https://tezostaquito.io/docs/quick_start/#interact-with-a-smart-contract)
- [**Interface ContractProvider method `at`**](https://tezostaquito.io/typedoc/interfaces/_taquito_taquito.contractprovider.html#at)
- [**Class ContractAbstraction `methods`**](https://tezostaquito.io/typedoc/classes/_taquito_taquito.contractabstraction.html#methods)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network, mnemonic, email, password, secret, contract} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    const n = 1;
    // Load the interface of the contract
    const counterContract = await tezos.contract.at(contract);
    // Call the increment function of the contract
    const transaction = await counterContract.methods.increment(n).send();
    // Await confirmations
    await transaction.confirmation(3);

    res.status(200).json(transaction.hash);
  }
//...
```

**What happened in the code above?**

- First, we must supply the address of our newly deployed contract to `tezos.contract.at`.
- Next, using `contract.methods.increment(n).send()` will pass the value of `n` to the `increment` method of the deployed contract. Note: _if the contract functions are not annotated, they are still indexed by number._
- Next, using the instruction `transaction.confirmation(3)` we wait for **3** block confirmations before returning.
- Finally, the transaction hash is then available and we can return it to the client-side as JSON via `transaction.hash`.

---

# ✅ Make sure it works

Once the code in `pages/api/tezos/setter.ts` is complete, click **Increment the value** to send a transaction containing the call to the `increment` function. You will see the updated value on the page once the confirmations are received.

---

# 🏁 Conclusion

You have come all the way from connecting to Tezos to being able to deploy smart contracts. You are now empowered to keep learning and building on Tezos, using the dedicated infrastructure of DataHub.

'''
'''--- markdown/tezos/TRANSFER_TOKEN.md ---
In this tutorial we will learn how to transfer an amount of Tezos tokens from our account to another account. Token transfers are the simplest function on most blockchains, and one of the most common.

The role of TezosToolkit here is to provide a simplified way of dealing with the lifecycle of an RPC request. It would be possible to implement the transfer functionality for ourselves, however it is preferable to utilize the toolkit for the flexible functionality and ease of use that it provides.

---

# 🏋️ Challenge

{% hint style="tip" %}
In `pages/api/tezos/transfer.ts`, implement the function and try to make your first transfer on the Tezos network. You must replace the instances of `undefined` with working code to accomplish this.
{% endhint %}

**Take a few minutes to figure this out**

```typescript
//...
  try {
    const {network, mnemonic, email, password, secret, amount, recipient} =
      req.body;
    const url = getNodeUrl(network);
    const url = getTezosUrl();
    const tezos = new TezosToolkit(url);

    await importKey(undefined);

    // Call the transfer method

    // Await confirmation
    await operation.confirmation(1)

    res.status(200).json(operation.hash);
  }
//...
```

**Need some help?** Check out these links 👇

- [**Transfer with Taquito**](https://tezostaquito.io/docs/quick_start/#transfer)
- [**Check out the `transfer` method's interface**](https://tezostaquito.io/typedoc/interfaces/_taquito_taquito.contractprovider.html#transfer)

Still not sure how to do this? No problem! The solution is below so you don't get stuck.

---

# 😅 Solution

```typescript
// solution
//...
  try {
    const {network, mnemonic, email, password, secret, amount, recipient} =
      req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    const operation = await tezos.contract.transfer({
      to: recipient,
      amount: amount,
      mutez: true
    });

    await operation.confirmation(1);

    res.status(200).json(operation.hash);
  }
//...
```

**What happened in the code above?**

- First, we create a new `TezosToolkit` instance.
- Next, we import our wallet data using `importKey`.
- Next, we create an transaction using the method `transfer` of the `contract` module, passing:
  - The recipient address.
  - The amount in **μꜩ** (**mutez**).
  - An optional boolean flag, **mutez**, to set the base unit of the transferred amount.
- Then, we wait for the confirmation of the transaction.
- Finally, we send the `operation.hash` back to the client-side as JSON.

---

# ✅ Make sure it works

Once the code in `pages/api/tezos/transfer.ts` is complete, fill in the amount of **mutez** you want to send then click on **Submit Transfer**.

---

# 🏁 Conclusion

Now that we have created our account and made a transfer, let's move on to deploying some code (known as a "smart contract") to the blockchain! Ready to take the plunge? Let's go!

'''
'''--- markdown/the_graph/FINAL.md ---
🥳 **Congratulations**, you have completed the Graph Pathway! \
Here's a quick recap of what we covered:

- 🔌 Running a Graph node with Docker
- 🏗 Creating a subgraph scaffold to specify what data we're looking for
- 📜 Tweaking the subgraph manifest to narrow down the search
- 🪢 Defining schemas to support one-to-many data relationships
- 🗺 Implementing mappings to handle indexed events
- 🕵🏻 Querying a subgraph to display the requested and indexed information

# 🧐 Keep learning with these resources:

- 🔬 [Unit testing Subgraphs](https://learn.figment.io/tutorials/unit-testing-subgraphs)
- 📖 [Learn more about the Graph Explorer](https://thegraph.com/docs/explorer)
- 👎 [Deprecating a Subgraph](https://thegraph.com/docs/developer/deprecating-a-subgraph)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/the_graph/GRAPH_NODE.md ---
## 🤔 What's a Graph node?

You're probably familiar with the idea of running a local web server in the early stages of a project, or while developing on it. It allows you to rapidly design, write and test your code. Then when you're ready you can deploy it and in production users will interact with that deployed version of your server.

We're going to follow the same pattern here. Think of our local Graph node as loosely equivalent to a web server: it will run on your machine, listen to Ethereum events and listen to clients' requests and respond with data.

A Graph node comes with the following components:

- An IPFS swarm for storing our subgraphs
- A Postgres database for storing the data output of those processed events
- A GraphQL API to allow clients to query this data

## 👨‍💻 Setting up a local Graph node

We don't need to worry about installing and running them: we'll use Docker for this. We defined a Docker configuration in `docker/docker-compose.yaml` and it will tell Docker what to do for each of those three components. Our Graph node will run inside a Docker container and connect it to Ethereum mainnet using DataHub as a provider (you'll need that DataHub API key soon).

From the root directory of the project, run:

```text
cd docker
ETHEREUM_RPC=mainnet:https://ethereum-mainnet--rpc.datahub.figment.io/apikey/<YOUR_DATAHUB_API_KEY> docker-compose up
```

Remember to add your DataHub API key to the end of the URL displayed above by replacing the text `<YOUR_DATAHUB_API_KEY>` before you run the command. You should see a bunch of white and blue commands and then the following:

```text
Starting docker_ipfs_1     ... done
Starting docker_postgres_1 ... done
Starting docker_graph-node_1 ... done
Attaching to docker_postgres_1, docker_ipfs_1, docker_graph-node_1
```

It should only take a moment to start the IPFS and Postgres containers, and you will want to pay attention to the Graph Node logging output to make sure that there are no errors on startup. When you see the following INFO logging about downloading the latest blocks from Ethereum, it should be running OK:

```text
docker-graph-node-1  | <TIMESTAMP> INFO Downloading latest blocks from Ethereum. This may take a few minutes..., provider: mainnet-rpc-0, component: BlockIngestor
```

> If you encounter the error "FileNotFoundError: [Errno 2] No such file or directory", make sure you have the latest version of Docker Desktop and that it's currently running on your system.

> If you encounter the error "Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?", well... make sure Docker is running ;)

## ✅ Make sure it works

The same way that a local web server usually listens for connections on `localhost:3000`, our local Graph node is listening for connections on `localhost:8020`.

Click on the button **Test local Graph node** to make sure it's running!

## 👣 Next Steps

A Graph node is now running on your computer but it's not doing much at the moment. Let's give it some code to run...

'''
'''--- markdown/the_graph/PROJECT_SETUP.md ---
## 🤔 What's The Graph?

You might have already read about The Graph and want to roll up your sleeves and get started with coding, in which case feel free to skip this suggested reading (don't forget to install Docker and get a DataHub API key, though).

If you want to read more about The Graph we've curated some great resources to help you get started:

- We wrote [this Twitter thread](https://twitter.com/sprngtheory/status/1425137466789486592) to explain The Graph without technical jargon. It's a great place to start!
- Project documentation is not always the best place to start. However, The Graph is an exception. They have very well-written and approachable docs. [Give them a read](https://thegraph.com/docs/about/introduction).
- More of a visual learner? The rock star of blockchain Youtube - Finematics - have the perfect video for you: [Binge it here](https://www.youtube.com/watch?v=7gC7xJ_98r8).
- You're still here?? We have curated more links on [Figment Learn](https://learn.figment.io/protocols/thegraph). Knock yourself out!

---

## 🐳 Docker

In this Pathway, you'll use Docker to run a local Graph node on your machine. [You can install Docker here](https://www.docker.com). Make sure it's installed and running before continuing to the next step.

---

## 🔑 Get a DataHub API key

We'll need to connect to the Ethereum mainnet to be able to listen to new events happening on the network. DataHub is a blockchain development platform that provides access to Ethereum through their hosted nodes.

To get a DataHub API key, [create an account](https://datahub.figment.io/), then create a new application using the Ethereum protocol. On that application's **Overview** tab, locate the App Overview on the left side of the page and click on **View Key** button next to the text "API Key". You can also copy the HTTP endpoint URL including the API key from the Protocols view.

![DataHub](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/datahub-view-api-key.png)

Speaking of API keys, it's important to remember that Next.js reads from the file `.env.local` to determine which environment variables to use!
To be able to complete this Pathway, you must create a new file named `.env.local` in the project root directory: `/learn-web3-dapp/.env.local`, copying the contents of the existing `.env.example` file.

> Easily duplicate the file with the terminal command `cp .env.example .env.local`!

---

## 🎥 Video Walkthrough

Here is a comprehensive video walkthrough of the Pathway to help you understand what is going on at every step!
The beginning of the video is a discussion of Web 3 between Guillaume Galuz, Figment's Head of Education and Nader Dabit, Developer Relations Engineer at Edge & Node. The walkthrough of the Pathway content begins at [10:18](https://www.youtube.com/watch?v=P0sGpnVVVx8?t=621) if you would like to skip ahead and get right into it 😃.

{% embed url="https://www.youtube.com/watch?v=P0sGpnVVVx8" caption="Learn The Graph with Figment's 101 Pathway" %}

- Create a subgraph scaffold @ [13:15](https://youtu.be/P0sGpnVVVx8?t=791)
- Tweaking the manifest @ [22:00](https://youtu.be/P0sGpnVVVx8?t=1320)
- Define the schema @ [27:47](https://youtu.be/P0sGpnVVVx8?t=1667)
- Implement the mappings @ [38:22](https://youtu.be/P0sGpnVVVx8?t=2297)

---

## 👣 Next Steps

Ok, enough of setup. Let's get our hands dirty with the first step: Running a local Graph node to listen to the Ethereum network! Click **Next: Run a local Graph node** to continue.

'''
'''--- markdown/the_graph/SUBGRAPH_MANIFEST.md ---
## 📜 What's a "manifest"?

Like an orchestra, your subgraph is made up of a bunch of pieces that need to play nicely together for the music to sound good. Think of the the manifest as the conductor: it sits in the middle and coordinates everything.

If you open the repository in a code editor like Visual Studio Code, look for the folder called `subgraphs` and its child `punks`. It should look like this below. The manifest is the file called `subgraph.yaml`.

![SG folder](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/manifest-01.png)

## 🔎 Inspecting the scaffolded file

Open the `subgraph.yaml` file and notice that it's already been populated using the information we provided but also with A LOT of things we didn't specify.

![Manifest file](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/manifest-02.png)

Under the `mappings` key we find `entities` and `eventHandlers` - the next steps of this tutorial will be dedicated to understanding them a bit more in depth. For now just notice the information that's below them. Remember the [code](https://etherscan.io/address/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB#code) from the CryptoPunk contract on Etherscan? They correspond to the Events emitted! The `eventHandlers` even have the right signatures already. That's promising.

## 🧑🏼‍💻 Your turn! Edit the manifest

Edit the manifest file to accomplish the 3 following things:

1. **Specify a starting block at `13100000`.** In order to save time when indexing the datasource, we must specify a starting block (or else the node would start indexing from the genesis block, which would take a veeeeery long time).
2. **Define only two entities "Punk" and "Account"** under the dataSources mappings.
3. **Only handle the `PunkBought` event** and name its handler `handlePunkBought`

## 😅 Solution

Replace the existing contents of `subgraph.yaml` with the following code snippet:

```yaml
// solution
specVersion: 0.0.2
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Contract
    network: mainnet
    source:
      address: "0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB"
      abi: Contract
      startBlock: 13100000
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      entities:
        - Account
        - Punk
      abis:
        - name: Contract
          file: ./abis/Contract.json
      eventHandlers:
        - event: PunkBought(indexed uint256,uint256,indexed address,indexed address)
          handler: handlePunkBought
      file: ./src/mapping.ts
```

## 💡 A word about ABIs

When another smart contract or external application wants to call a smart contract function, it needs to know how to interact with the contract's interface. And since in practice an Ethereum smart contract is deployed on the blockchain as byte code, we need a better way to tell consumers how to invoke the contract and what to expect back.

This is what ABIs (Application Binary Interface) are for! They define the methods and structures that can be used to interact with that binary contract and what shape of data you'll get back.

You can read more about ABIs in the [Solidity docs](https://docs.soliditylang.org/en/latest/abi-spec.html), or check out this [Quicknode article](https://www.quicknode.com/guides/solidity/what-is-an-abi) on the topic.

## ✅ Make sure it works

Now, it's time for you to verify if you have followed the instructions carefully, click on the button **Test Manifest** to check that your manifest is well formed.

'''
'''--- markdown/the_graph/SUBGRAPH_MAPPINGS.md ---
## 🗺 Mapping events to entities

Remember in the "Tweak the manifest" step we defined a handler for each event? It looked like this:

```yaml
eventHandlers:
  - event: PunkBought(indexed uint256,uint256,indexed address,indexed address)
    handler: handlePunkBought
```

For each event handler that is defined in `subgraph.yaml` under `mapping.eventHandlers` we will create an exported function of the same name. Each handler must accept a single parameter called event with a type corresponding to the name of the event which is being handled.

This collection of event handlers is what we call "mappings" and they go in `src/mapping.ts`. They will transform the Ethereum event data into entities defined in your schema.

## ✏️ Implement the event handlers

Now we have to implement the `handlePunkBought` eventHandler to be able to process the event data and turn it into an piece of data that can be persisted in our Postgres database.

First, open `src/mapping.ts` and erase its content.

Then we need to import some code and prototype the function:

```typescript
import {BigInt} from '@graphprotocol/graph-ts';

import {PunkBought as PunkBoughtEvent} from '../generated/Contract/Contract';
import {Account, Punk} from '../generated/schema';

export function handlePunkBought(event: PunkBoughtEvent): void {
  // Implement the function here
}
```

`Account` and `Punk` imported objects are the ones we've just defined, and `PunkBoughtEvent` is referencing the definition of an event we made in the `subgraph.yaml`.

```typescript
let account = Account.load(event.params.toAddress.toHexString());
```

To create the `Account` entity, we first need to test if the entity already exists:

```typescript
if (account == null) {
  account = new Account(event.params.toAddress.toHexString());
  account.id = event.params.toAddress.toHexString();
  account.numberOfPunkBought = BigInt.fromI32(1);
}
```

If it does not, we create a new one by filling all the fields. Otherwise, we only need to increment the `numberOfPunkBought`.

```typescript
else {
  account.numberOfPunkBought = account.numberOfPunkBought.plus(
    BigInt.fromI32(1),
  );
}
```

At last and for both cases, we call `save()`.

```typescript
account.save();
```

The creation of a `Punk` entity follows the same logic, as an helper be inform that we can access timestamp of the event using `event.block.timestamp`.

## 🧑🏼‍💻 Your turn! Finish implement the "handlePunkBought" handler

We implemented half of the event handler. Can you finish it?

```typescript
import {BigInt} from '@graphprotocol/graph-ts';

import {PunkBought as PunkBoughtEvent} from '../generated/Contract/Contract';
import {Account, Punk} from '../generated/schema';

export function handlePunkBought(event: PunkBoughtEvent): void {
  let account = Account.load(event.params.toAddress.toHexString());

  if (account == null) {
    account = new Account(event.params.toAddress.toHexString());
    account.id = event.params.toAddress.toHexString();
    account.numberOfPunkBought = BigInt.fromI32(1);
  } else {
    account.numberOfPunkBought = account.numberOfPunkBought.plus(
      BigInt.fromI32(1),
    );
  }

  account.save();

  // Your turn! Write underneath those comments
  // ---------------------------------------------------------------------
  // - find (aka load) the Punk using his HexString found in the event
  // - if there is none, create it and set its "id" and "index" attributes
  // - set the "owner", "value" and "date" attributes
  // - save the punk
}
```

## 😅 Solution

Your `src/mapping.ts` should look like this:

```typescript
// solution
import {BigInt} from '@graphprotocol/graph-ts';

import {PunkBought as PunkBoughtEvent} from '../generated/Contract/Contract';
import {Account, Punk} from '../generated/schema';

export function handlePunkBought(event: PunkBoughtEvent): void {
  let account = Account.load(event.params.toAddress.toHexString());

  if (account == null) {
    account = new Account(event.params.toAddress.toHexString());
    account.id = event.params.toAddress.toHexString();
    account.numberOfPunkBought = BigInt.fromI32(1);
  } else {
    account.numberOfPunkBought = account.numberOfPunkBought.plus(
      BigInt.fromI32(1),
    );
  }

  account.save();

  let punk = Punk.load(event.params.punkIndex.toHexString());

  if (punk == null) {
    punk = new Punk(event.params.punkIndex.toHexString());
    punk.id = event.params.punkIndex.toHexString();
    punk.index = event.params.punkIndex;
  }

  punk.owner = event.params.toAddress.toHexString();
  punk.value = event.params.value;
  punk.date = event.block.timestamp;

  punk.save();
}
```

## 🚀 Deploy your subgraph

Last but not least, run the following command to deploy your subgraph to your local Graph node:

```bash
yarn create-local
yarn deploy-local
```

What do those two commands do?

- `yarn create-local` will create an endpoint for our subgraph (see the environment variable **NEXT_PUBLIC_LOCAL_SUBGRAPH** in your `.env.local`):
  - On `http://localhost:8000/subgraphs/name/punks` if running `learn-web3-dapp` locally
  - On Gitpod, the port number goes in front of the URL like this example: `https://8000-apricot-piranha-iub1loby.ws-us18.gitpod.io/`. Your URL will be different, so you need to copy and paste it from your address bar, then add the port number and hyphen in front of the URL (`8000-`) into `.env.local` as the value of **NEXT_PUBLIC_LOCAL_SUBGRAPH**.
- `yarn deploy-local` will deploy the subgraph to the endpoint specified by **NEXT_PUBLIC_LOCAL_SUBGRAPH**.

As soon as you run `yarn deploy-local`, you will see Docker starting to scan the Ethereum mainnet for CryptoPunks!

![terminal](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/mapping-01.gif)

## ✅ Make sure it works

Now it's time for you to verify that you have followed the instructions carefully. Click on the **Check subgraph deployment** button on the right to check that your mappings are correctly implemented.

'''
'''--- markdown/the_graph/SUBGRAPH_QUERY.md ---
## 🕵🏻 Querying the subgraph

After deploying the subgraph, we need to wait a little in order for it to sync with the Ethereum mainnet. It will scan past blocks to find events and then listen to any new events

We can follow the progression of the sync looking at the logged output by the running docker instance of our local graph node.

> Before running the query, you'll need to make sure you have the [Metamask](https://metamask.io/) extension installed in your browser and that you're connected to the mainnet of Ethereum. Why? We'll decorate the data returned by the GraphQL query with data coming from the [CryptoPunks Data on Etherscan](https://etherscan.io/address/0x16F5A35647D6F03D5D3da7b35409D65ba03aF3B2#readContract) to be able to render the images and other CryptoPunk metadata.

Our Graph node comes with a GraphQL endpoint, available at [http://localhost:8000/subgraphs/name/punks](http://localhost:8000/subgraphs/name/punks/graphql) (Or at your Gitpod Workspace URL). Open this in another tab, and you will see a GraphiQL UI. Consider this a sandbox in which to experiment with GraphQL queries. Open the right sidebar to explore your schema.

If you're running the Pathway using Gitpod, you will need to add the Gitpod Workspace URL to `.env.local` instead of localhost, as mentioned in the previous step. The port number must also be added to the beginning of the URL, rather than at the end. For example: `https://8000-olive-meerkat-mapxxnyp.ws-us18.gitpod.io/`.

## 👨‍💻 Your turn! Write the GraphQL query

In `components/protocols/the_graph/graphql/query.ts`, write a GraphQL query to return the 10 most expensive CryptoPunks.

Some hints to help you:

- Start by just fetching for punks and passing all the fields you want back
- You will want `id`, `index`, `value` and `date`
- Then use `first`, `orderBy` and `orderDirection` to get 10 of highest value

Remember to use **GraphiQL IDE** at [http://localhost:8000/subgraphs/name/punks](http://localhost:8000/subgraphs/name/punks) (or at your Gitpod URL) to play around

## 😅 Solution

In `components/protocols/the_graph/graphql/query.ts` replace the GraphQL query with:

```graphql
// solution
query {
  punks(first: 10, orderBy: value, orderDirection: desc) {
    id
    index
    owner {
      id
    }
    value
    date
  }
}
```

## 🥳 Enjoy the result of your work

Now, it's time to enjoy the result of your work! Click on the button on the right, and say hello to the Punks!

![punks](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/query-01.png)

'''
'''--- markdown/the_graph/SUBGRAPH_SCAFFOLD.md ---
## 🌐 What's a subgraph?

A subgraph defines which data The Graph will index from Ethereum, and how it will store it. It's made up of 3 main pieces: a manifest, a schema of entities and mappings.

![Anatomy](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/subgraph-01.png)

In this Pathway we will go over each of them one by one, understand what they do and how they work.

## 🤝 Picking a smart contract

In practice, a subgraph indexes events emitted by a smart contract. So the first thing we need to do is pick the smart contract our subgraph will be listening to.

For the purpose of this tutorial we have decided to pick a fun and popular smart contract: the Crypto Punk ETH-20 contract.

![punk-variety-2x](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/subgraph-02.png)

You can view it on Etherscan [here](https://etherscan.io/address/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB) and if you click on the "Contract" tab you can also have a look at [its Solidity code](https://etherscan.io/address/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB). The contract's address is `0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB`.

> Looking at the code, can you find its Events? What functions are they calling? What arguments are they passing? Browse around the codebase, we will come back to those events very soon.

## 💻 Install the Graph CLI

In a code editor, a subgraph will be a folder with a few different folders and files. We could create it manually but The Graph provides a CLI tool so we don't have to do it from scratch. Install the CLI by running:

```text
yarn global add @graphprotocol/graph-cli
```

{% hint style="tip" %}
If you're using Gitpod, Yarn won't automatically add the CLI binary to your PATH - use `npm install -g @graphprotocol/graph-cli` instead!
{% endhint %}

Verify the installation was successful by running `graph` in your Terminal. You should see:

```text
Welcome to graph CLI version 0.22.2!
Type graph --help to view common commands.
```

Let's then cd into the `subgraphs` folder:

```text
cd subgraphs
```

We will be using the `init` command of the Graph CLI (see the [docs](https://github.com/graphprotocol/graph-cli) if you need more info). Type in `graph init --help` in your Terminal to view some helpful documentation. The `init` command will create a subgraph scaffold: it will have the right shape but will be incomplete.

## 🧑🏼‍💻 Your turn! Generate a subgraph scaffold

Using the `graph init` command, generate a subgraph scaffold with the following properties:

- Use a subgraph name without a prefix
- Set the contract address to the CryptoPunk contract and fetch its ABI
- Set the Ethereum network to `mainnet`
- Tell the subgraph to index contract events as entities
- Set the Graph node to the local one (hint: it's running on `http://localhost:8020/`)
- Set the subgraph name to `punks`

When you're done, run the command in your terminal to generate a subgraph scaffold. And if you need to start over, simply delete the content of the `subgraphs` folder and run the `graph init ...` command again!

## 😅 The solution

```text
// solution
graph init \
  --allow-simple-name \
  --from-contract 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB \
  --network mainnet \
  --index-events \
  --node http://localhost:8020/ \
  punks
```

That's a mouthful! Let's look at it line by line.

- `graph init` is the CLI command that will initialize an empty subgraph. Everything else are flags and options.
- `--allow-simple-name` simplifies the naming convention of our local graph (no need for a prefix)
- `--from-contract` gets the ABI from an already deployed contract at the specified address (we'll get back to this later!)
- `--network mainnet` tells the Graph CLI to look on Mainnet Ethereum to find the contract ABI
- `--index-events` creates entities from events
- `--node http://localhost:8020/` will prepare our script to deploy to our local graph node
- `punks` is the name of the folder under which the files are created

> **NOTE**: Linux and macOS use the backslash character \ for multi-line input. Windows uses the ^ character. If you paste this command into a Windows terminal (PowerShell, cmd.exe or Windows Terminal), replace the \ with ^

Once you type Enter, you will be prompted to confirm the information: you can just accept the five suggested inputs. The output should look like:

![terminal](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/subgraph-03.gif)

You don't need to run the next steps for now!

## ✅ Make sure it works

Now it's time for you to verify that you have followed the instructions carefully.

Click on the **Check for a subgraph scaffold** button on the right to see if your scaffold exists, and is in the right place.

'''
'''--- markdown/the_graph/SUBGRAPH_SCHEMA.md ---
## 🪢 Entities and relations

We just tweaked the manifest to declare what information we were looking for. We declared two entities called `Punk` (for the actual CryptoPunk NFT) and `Account` (for the owner of the NFT). Now we need to implement those entities: for each of them, define what attributes they have and what are those attribute types.

This is analogous to the process of defining the Models in an MVC framework.

Entities will be defined in the `schema.graphql` file.

![Entities](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/entity-01.png)

## 🧑🏼‍💻 Your turn! Define the Punk and Account entities

Start from the following code below and fill in the two missing fields: `punksBought` on `Account` and `owner` on `Punk`. Have a look at Nader Dabit's tutorial on how to use `@derivedFrom` to specify a one-to-many relationship.

> "For one-to-many relationships, the relationship should always be stored on the 'one' side, and the 'many' side should always be derived."

```graphql
type Account @entity {
  id: ID!
  # Reference the Punk entity to specify the relation between them
  # aka "A owner has multiple Punks"
  punksBought: _______________
  numberOfPunkBought: BigInt!
}

type Punk @entity {
  id: ID!
  index: BigInt!
  # Reference the Account entity to specify the relation between them
  # aka "A punk belongs to an Owner"
  owner: __________
  value: BigInt!
  date: BigInt!
}
```

## 😅 Solution

Replace the existing contents of `schema.graphql` with the following code snippet:

```graphql
// solution
type Account @entity {
  id: ID!
  # Defining the one to many relationship here from the "one" perspective
  # "an Account has many Punks"
  punksBought: [Punk!] @derivedFrom(field: "owner")
  numberOfPunkBought: BigInt!
}

type Punk @entity {
  id: ID!
  index: BigInt!
  # Defining the one to many relationship here from the "many" perspective
  # "a Punk has one Account"
  owner: Account!
  value: BigInt!
  date: BigInt!
}
```

In the above code snippet, there are two points worth mentioning:

- For the purpose of indexing, entities _must have_ an `ID` field to uniquely identify them.
- As an `Account` can be the **owner** of multiple `Punk` we must explicitly define the `1:n` relation on the `Account`'s **punksBought** attribute using `[Punk!] @deriveFrom(field: "owner")` directive:

```text
                               |      ------
                               | --- | Punk |
                               |      ------
                               ...
     ---------                 |      ------
    | Account |  1 : ----- n : | --- | Punk |
     ---------                 |      ------
                               ...
                               |      ------
                               | --- | Punk |
                               |      ------
```

## 🏗️ The "codegen" command

We have now defined the entities that we declared in the manifest!

Run the following command to generate boilerplate code from our **entities**:

```text
cd punks
yarn codegen
```

What does `yarn codegen` do? This command create some boilerplate code under the `generated` folder. This boilerplate code define **typescript** classes for each `entities` (have a look at `generated/schema.ts`). We will use this code in the next step to define the mappings between our entities and the smart-contract events.

![terminal](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/entity-02.gif)

## ✅ Make sure it works

Before going to the next step, click on the **Check for expected entities** button on the right to make sure your entities are properly defined.

'''
'''--- markdown/the_graph_near/FINAL.md ---
🥳 **Congratulations**, you have completed the Graph for NEAR Pathway! \
Here's a quick recap of what we covered:

- 🔌 Overview of Graph nodes and The Graph Hosted Service
- 🏗 Creating a subgraph scaffold to specify what data we're looking for
- 📜 Tweaking the subgraph manifest to narrow down the search
- 🪢 Defining schemas to be the objects for logs from NEAR contracts
- 🗺 Implementing mappings of the JSON log to the entity objects
- 🕵🏻 Querying a subgraph to display the requested and indexed information

# 🧐 Keep learning with these resources:

- 🔬 [Unit testing Subgraphs](https://learn.figment.io/tutorials/unit-testing-subgraphs)
- 📖 [Learn more about the Graph Explorer](https://thegraph.com/docs/explorer)
- 👎 [Deprecating a Subgraph](https://thegraph.com/docs/developer/deprecating-a-subgraph)

# 🗣 Give us your feedback

Please take a couple of minutes to fill out this short **[feedback form](https://docs.google.com/forms/d/1SXg3xo0I1BRN2BAS-ffDbj1P6bfwo0x48trttmJ5xKs/)**.

'''
'''--- markdown/the_graph_near/GRAPH_NODE.md ---
## 🎥 Video Walkthrough of The Graph's Hosted Service

{% embed url="https://www.youtube.com/watch?v=muL4vzqc9nQ" caption="The Graph's Hosted Service" %}

## 📈 A word about The Graph Hosted Service

Using The Graph to index data from the NEAR blockchain currently means you need to use the Hosted Service. It is possible to run a local Graph node but the process for setting it up is currently not documented. The Graph provides the Hosted Service as an alternative to running your own Graph node. The Hosted Service will eventually shut down as The Graph reaches feature parity with its decentralized network of graph nodes.

## 🤔 What's a Graph node?

You're probably familiar with the idea of running a local web server in the early stages of a project, or while developing on it. It allows you to rapidly design, write and test your code. Then when you're ready you can deploy it and in production users will interact with that deployed version of your server.

A Graph node comes with the following components:

- An IPFS swarm for storing our subgraphs
- A Postgres database for storing the data output of those processed events
- A GraphQL API to allow clients to query this data

Normally, for development, we'd want to run a local Graph node to listen for NEAR receipts and blocks while also listening to clients' requests to respond with data. However, setting up a local Graph node for NEAR is currently complex and there is very little/no documentation available, so we're going to rely on The Graph's hosted service. Unfortunately, that means The Graph is acting like a single indexer/single point of failure and you lose the decentralization that comes with The Graph network for now.

## 👨‍💻 Using the Hosted Service

Getting started with [the Hosted Service](https://thegraph.com/hosted-service/) is simply a matter of signing up using your Github login credentials. Once inside, navigate to your dashboard. This is where all the subgraphs you deploy will reside. Inside you will see an access token that is used to authorize you during deployment and the button to **Add a Subgraph**.

![hosted](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph-near/hosted-01.png?raw=true)

The site is simple and intuitive to use and although it's a centralized service, it will speed up your development because you won't need to install or run anything locally.

## ✅ Make sure you have an access token

Let's quickly check to ensure you know where your access token is. Go to your dashboard on the Hosted Service page, locate your access token and carefully count the number of characters it has.

When you find it enter the count in **Your Answer** to ensure you know where it is!

## 👣 Next Steps

Now that we have access to the Hosted Service and know where our access token is, we need to set up our subgraph before deploying it. Let's get to that part now...

'''
'''--- markdown/the_graph_near/PROJECT_SETUP.md ---
## 🎥 Video Introduction of The Graph for NEAR

{% embed url="https://www.youtube.com/watch?v=qlTUkeNKe7g" caption="Learn The Graph for NEAR" %}

## 🤔 What's The Graph for NEAR?

Prior to embarking on this learning pathway we recommend completing both the NEAR and The Graph pathways. They aren't required, but you will probably find the background useful as you move through these lessons.

Also in this pathway you will find reference to Ceramic Network and decentralized identifiers (DIDs). The NEAR contract we will interact with in this pathway is a DID Registry contract that associates a DID with a NEAR account and stores that relationship on NEAR. Our subgraph will listen to and index the NEAR blockchain for this contract. We will then be able to query it and use the DID we get to retrieve information from Ceramic Network that corresponds to that account enabling creation of things like member profile directories.

If you're already familiar with The Graph, NEAR, and Ceramic and are ready to start coding subgraphs for NEAR, feel free to skip the suggested readings.

If you want to read more about The Graph and it's support for NEAR Protocol we've curated some great resources to help you get started:

- We wrote [this Twitter thread](https://twitter.com/sprngtheory/status/1425137466789486592) to explain The Graph without technical jargon. It's a great place to start!
- Project documentation is not always the best place to start. However, The Graph is an exception. They have very well-written and approachable docs. [Give them a read](https://thegraph.com/docs/about/introduction).
- NEAR support for The Graph is in beta and while many of the concepts are similar to what is required on other chains, it does have nuances of its own. The Graph's docs for [NEAR support](https://thegraph.com/docs/supported-networks/near) are recommended.
- Ceramic Network is a decentralized, open source platform for creating, hosting, and sharing streams of data. Recommend reading Ceramic's [overview](https://developers.ceramic.network/learn/advanced/overview/)
- More of a visual learner? The rock star of blockchain Youtube - Finematics - have the perfect video for you: [Binge it here](https://www.youtube.com/watch?v=7gC7xJ_98r8).
- You're still here?? We have curated more links on [Figment Learn](https://learn.figment.io/protocols/thegraph). Knock yourself out!

---

## 🎥 Video Walkthroughs

Each lesson includes a video walkthrough for the information being taught in the lesson as a visual reference.

---

## 👣 Next Steps

Ok, enough of setup. Let's get our hands dirty with the first step: Getting familiar with the Graph's hosted service to unlock the data in your contracts on NEAR Protocol! Click **Next: Connect to The Graph hosted service** to continue.

'''
'''--- markdown/the_graph_near/SUBGRAPH_MANIFEST.md ---
## 🎥 Video Walkthrough of the Subgraph Manifest

{% embed url="https://www.youtube.com/watch?v=ifqhNZmyfD8" caption="The Subgraph Manifest" %}

## 📜 What's a "manifest"?

Like an orchestra, your subgraph is made up of a bunch of pieces that need to play nicely together for the music to sound good. Think of the manifest as the conductor: it sits in the middle and coordinates everything.

Look for the folder called `subgraphs` and its child `near-subgraph`. It should look like this below. The manifest is the file called `subgraph.yaml`.

![SG folder](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph-near/manifest-01.png?raw=true)

## 🔎 Inspecting the scaffolded file

Open the `subgraph.yaml` file and have a read through the comments. Generally speaking, you'll tweak those fields for your situation.

![Manifest file](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph-near/manifest-02.png?raw=true)

Under the `source` key we find `account` and `startBlock`. Account needs to point to the contract account you want to work with. StartBlock tells the Hosted Service to start indexing from a certain block. It's required for NEAR considering how many blocks there are on the NEAR chain.

> Remember NEAR finalizes a new block every second or so.

Under the `mapping` key we find `entities` and `receiptHandlers` - the next steps of this tutorial will be dedicated to understanding them a bit more in depth. For now just notice the information that's below them.

## 🧑🏼‍💻 Your turn! Edit the manifest

Edit the manifest file to accomplish the following:

1. **Specify a starting block at `54395933`.** In order to save time when indexing the datasource, we must specify a starting block (or else the node would start indexing from the genesis block, which would take a veeeeery long time).
2. **Define only two entities "Account" and "Log"** under the dataSources mappings.
3. **Only handle receipts with `receiptHandlers`** and name its handler `handleReceipt`

## 😅 Solution

Replace the existing contents of `subgraph.yaml` with the following code snippet:

```yaml
// solution
specVersion: 0.0.4
description: DID registry
repository: https://github.com/VitalPointAI/near-subgraph.git
schema:
  file: ./schema.graphql
dataSources:
  - kind: near
    name: receipts
    network: near-mainnet
    source:
      account: did.near
      startBlock: 54395933
    mapping:
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      entities:
        - Account
        - Log
      receiptHandlers:
        - handler: handleReceipt
```

## 💡 A word about Handlers

NEAR datasources currently support two types of handlers:

- blockHandlers: run on every new NEAR block. This handler will get you data about a block - good for informational things like block explorers.
- receiptHandlers: run on every receipt where the data source's source account is the recipient. In the template, that is did.near. It has to be an exact match - so subaccounts have to be added as additional data sources.

> receiptHandlers that give you the outcome logs seem to be the most effective way to get specific data off the NEAR chain

## ✅ Make sure you understand the manifest

Now, it's time for you to verify if you have followed the instructions carefully, click on the button **Test Manifest** to check that your manifest is well formed.

'''
'''--- markdown/the_graph_near/SUBGRAPH_MAPPINGS.md ---
## 🎥 Video Walkthrough of Mapping Logs to Entities

{% embed url="https://www.youtube.com/watch?v=9VbsciALVLY" caption="Mapping Logs to Entities" %}

## 🗺 Mapping logs to entities

Remember in the "Tweak the manifest" step we defined a receipt handler? It looked like this:

```yaml
receiptHandlers:
  - handler: handleReceipt
```

> We could also have defined a blockHandler if we are interested in block related data. Currently blockHandler and receiptHandler are the only two handlers available for NEAR.

For each handler that is defined in `subgraph.yaml` under `mapping` we will create an exported function of the same name. Each receipt handler must accept a single parameter called receipt with a type of `near.ReceiptWithOutcome`.

This receipt handler is what we call a "mapping" and it goes in `src/mapping.ts`. It will transform the NEAR logging data into entities defined in your schema.

## ✏️ Implement the receipt handler

Now we have to implement the `handleReceipt` handler to be able to process the log data from an outcome in a receipt and turn it into an piece of data that can be persisted in the Hosted Service's Postgres database.

First, open `src/mapping.ts`.

Then we need to import some code and prototype the function:

```typescript
import {near, log, json, JSONValueKind} from '@graphprotocol/graph-ts';
import {Account, Log} from '../generated/schema';

export function handleReceipt(receipt: near.ReceiptWithOutcome): void {
  // Implement the function here
}
```

`Account` and `Log` are the imported objects (entities) we've just defined, and `receipt` is referencing the `ReceiptWithOutcome` class coming from `near-subgraph/node_modules/@graphprotocol/graph-ts/chain/near.ts`. For reference, the `ReceiptWithOutcome` and `ExecutionOutcome` classes are as follows.

```typescript
class ReceiptWithOutcome {
  outcome: ExecutionOutcome,
  receipt: ActionReceipt,
  block: Block
}
```

and `ExecutionOutcome` is where we get at the logs emmitted, in the form of a string array.

```typescript
class ExecutionOutcome {
      gasBurnt: u64,
      blockHash: Bytes,
      id: Bytes,
      logs: Array<string>,
      receiptIds: Array<Bytes>,
      tokensBurnt: BigInt,
      executorId: string,
}
```

NEAR has two types of receipts: ActionReceipts or DataReceipts. DataReceipts contain data for an ActionReceipt with the same `receiver_id`, but we won't go into detail on them because DataReceipts are not currently handled by The Graph.

ActionReceipts are the result of a transaction execution or another ActionReceipt processing. They'll show up for one of the seven actions that might occur on NEAR: FunctionCall, TransferAction, StakeAction, AddKeyAction, DeleteKeyAction, CreateAccountAction, or DeleteAccountAction.

Probably the most useful to us are the ActionReceipts from FunctionCall actions. That is where we'll typically add our log output in a contract to emit the log on completion of the FunctionCall. Because of that, those FunctionCalls are what we want The Graph to listen for

First, we'll need to grab the actions property from the receipt:

```typescript
const actions = receipt.receipt.actions;
```

Then we'll loop through the actions and call a handleAction function to create the `Account` and `Log` entities we want to make available. The handleAction looks like this:

```typescript
for (let i = 0; i < actions.length; i++) {
  handleAction(
    actions[i],
    receipt.receipt,
    receipt.block.header,
    receipt.outcome,
  );
}
```

As mentioned previously, we want the logs that come from function calls in the contract. So we'll implement this functionality. Notice that we are first checking to see if the `Account` entity exists - if it doesn't, create a new one:

```typescript
function handleAction(
  action: near.ActionValue,
  receipt: near.ActionReceipt,
  blockHeader: near.BlockHeader,
  outcome: near.ExecutionOutcome
): void {

  if (action.kind != near.ActionKind.FUNCTION_CALL) {
    log.info("Early return: {}", ["Not a function call"]);
    return;
  }

  let accounts = new Account(receipt.signerId);
  const functionCall = action.toFunctionCall();
  ...
```

Now we'll have the ability to pick out the logs that correspond to the `functionCall` in the contract, so we simply do the following for the name of each function we want to listen for in the contract. For example, this one is listening for the `putDID` function:

```typescript
if (functionCall.methodName == "putDID") {
   ...
```

When the `putDID` function is called, The Graph processes its ActionReceipt and puts the logs in an array of `outcome.logs`.

We want to create a new Log and then check that the function call actually emitted a log. If it did, we get the receipt's signerId and set it to logs.id:

```typescript
let logs = new Log(`${receiptId}`);
  if(outcome.logs[0]!=null){
    logs.id = receipt.signerId;
```

Knowing there is now a log that we can use, we want to parse the string into a JSON object. We do that like so:

```typescript
let parsed = json.fromString(outcome.logs[0])
  if(parsed.kind == JSONValueKind.OBJECT){
    let entry = parsed.toObject()
```

At this point we have a JSON object stored in `entry`. Let's take another look at the NEP-171 log format

```typescript
logging.log(`{"EVENT_JSON":{
    "standard":"nep171",
    "version":"1.0.0",
    "event":"putDID",
    "data":{
      "accountId":"${accountId}",
      "did":"${did}",
      "registered":${Context.blockTimestamp},
      "owner":"${Context.predecessor}"
    }}}`);
```

In addition to the overall top level object we just parsed, there are two more objects: EVENT_JSON and data. We will need to create objects out of each of those as well. Starting with EVENT_JSON:

```typescript
// EVENT_JSON
let eventJSON = entry.entries[0].value.toObject();
```

Now we will want to loop through each of the object's keys and assign the values to their corresponding entity properties like so:

```typescript
// standard, version, event (these stay the same for a NEP 171 emmitted log)
for (let i = 0; i < eventJSON.entries.length; i++) {
  let key = eventJSON.entries[i].key.toString();
  switch (true) {
    case key == 'standard':
      logs.standard = eventJSON.entries[i].value.toString();
      break;
    case key == 'event':
      logs.event = eventJSON.entries[i].value.toString();
      break;
    case key == 'version':
      logs.version = eventJSON.entries[i].value.toString();
      break;
  }
}
```

> See how the keys in the switch statement match the keys in the log emitted from the contract? Notice how the keys also correspond to the entity property names and types?

We'll also repeat this for the `data` object:

```typescript
// data
let data = eventJSON.entries[0].value.toObject();
for (let i = 0; i < data.entries.length; i++) {
  let key = data.entries[i].key.toString();
  switch (true) {
    case key == 'accountId':
      logs.accountId = data.entries[i].value.toString();
      break;
    case key == 'did':
      logs.did = data.entries[i].value.toString();
      break;
    case key == 'registered':
      logs.registered = data.entries[i].value.toBigInt();
      break;
    case key == 'owner':
      logs.owner = data.entries[i].value.toString();
      break;
  }
}
```

At last, we call `logs.save()` and then push the log onto the account entity with `accounts.log.push(logs.id)`.

## 🧑🏼‍💻 Your turn! Implement the init function of the did.near contract

We implemented part of the receipt handler. Can you finish it, by adding the code for the init function?

```typescript
// ...
  } else {
    log.info('Not processed - FunctionCall is: {}', [functionCall.methodName]);
  }

  // Your turn! Write underneath that code, but before accounts.save();
  // ---------------------------------------------------------------------
  // - implement an if statement to find the appropriate function call
  // - if it is there, set the receiptId
  // - set the signerId
  // - create a new Log
  // - parse the objects and loop through the keys to assign the values to the entity properties (don't forget correct types)
  // - save the log and push in the the accounts log array

  // Here's the init log for reference:
  // logging.log(`{"EVENT_JSON":{
  //  "standard":"nep171",
  //  "version":"1.0.0",
  //  "event":"init",
  //  "data":{
  //    "adminId":"${adminId}",
  //    "adminSet":${Context.blockTimestamp},
  //    "accountId":"${adminId}"
  //  }}}`)
}
```

## 😅 Solution

Make sure that you have added this code to your `subgraphs/near-subgraph/src/mapping.ts` before continuing:

```typescript
// solution

// ...
if (functionCall.methodName == 'init') {
  const receiptId = receipt.id.toHexString();
  accounts.signerId = receipt.signerId;

  let logs = new Log(`${receiptId}`);
  if (outcome.logs[0] != null) {
    logs.id = receipt.signerId;

    let parsed = json.fromString(outcome.logs[0]);
    if (parsed.kind == JSONValueKind.OBJECT) {
      let entry = parsed.toObject();

      //EVENT_JSON
      let eventJSON = entry.entries[0].value.toObject();

      //standard, version, event (these stay the same for a NEP 171 emmitted log)
      for (let i = 0; i < eventJSON.entries.length; i++) {
        let key = eventJSON.entries[i].key.toString();
        switch (true) {
          case key == 'standard':
            logs.standard = eventJSON.entries[i].value.toString();
            break;
          case key == 'event':
            logs.event = eventJSON.entries[i].value.toString();
            break;
          case key == 'version':
            logs.version = eventJSON.entries[i].value.toString();
            break;
        }
      }

      //data
      let data = eventJSON.entries[0].value.toObject();
      for (let i = 0; i < data.entries.length; i++) {
        let key = data.entries[i].key.toString();
        switch (true) {
          case key == 'adminId':
            logs.adminId = data.entries[i].value.toString();
            break;
          case key == 'accountId':
            logs.accountId = data.entries[i].value.toString();
            break;
          case key == 'adminSet':
            logs.adminSet = data.entries[i].value.toBigInt();
            break;
        }
      }
    }
    logs.save();
  }

  accounts.log.push(logs.id);
} else {
  log.info('Not processed - FunctionCall is: {}', [functionCall.methodName]);
}
// ...
```

## 🎥 Video Walkthrough of Generating, Building and Deploying Your NEAR Subgraph

{% embed url="https://www.youtube.com/watch?v=fSBr1IpSOiA" caption="Generating, Building, and Deploying Your NEAR Subgraph" %}

## 🚀 Deploy your subgraph

Before you can deploy to The Hosted Service you'll need to create a place for it.

1. Go to your Hosted Service dashboard and click **Add Subgraph**.

2. Fill out the form. You can select an image for your subgraph, give it a name, subtitle, description, GitHub URL and link it to an account. You can also choose whether it is hidden from others or available to all.

> Once your subgraph is deployed, it needs to have activity on it to remain active. If there are no queries for more than 30 days, you'll need to redeploy it in order for the Hosted Service to start indexing it again.

Next, we'll need to update `near-subgraph/package.json`'s deploy command to include the name of the subgraph you just created on the Hosted Service. Find this line in `near-subgraph/package.json`:

```json
"deploy": "graph deploy <GITHUBNAME/SUBGRAPH> --ipfs https://api.thegraph.com/ipfs/ --node https://api.thegraph.com/deploy/"
```

Replace <GITHUBHAME/SUBGRAPH> with the name of your subgraph. Note that this is the same as the last part of the Queries (HTTP) url in the dashboard. For example:

`https://api.thegraph.com/subgraphs/name/ALuhning/DID-Registry` -> `ALuhning/DID-Registry`

```json
"deploy": "graph deploy ALuhning/DID-Registry --ipfs https://api.thegraph.com/ipfs/ --node https://api.thegraph.com/deploy/"
```

The final step before deploying to the Hosted Service is to authorize with The Graph CLI. For that, you need your access token (available from [your dashboard](https://thegraph.com/hosted-service/dashboard)). Run the following command, remember to replace <ACCESS_TOKEN> with your actual access token:

```bash
graph auth --product hosted-service <ACCESS_TOKEN>
```

We can now deploy our subgraph to the Hosted Service with the following commands:

```text
yarn codegen
yarn build
yarn deploy
```

What do those three commands do?

- `yarn codegen` generates the types for the GraphQL schema.
- `yarn build` compiles the subgraph and organizes the files in the `build` directory.
- `yarn deploy` sends the compiled code to the Hosted Service to make it available for indexing and querying.

Now if you visit your subgraph in your dashboard, you can click on the Logs and see it starting to scan the NEAR mainnet for logs emitted by the functions in the did.near contract.

![terminal](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph-near/mapping-01.gif?raw=true)

## ✅ Make sure it works

Now it's time for you to verify that you have followed the instructions carefully. Copy and paste the endpoint URL from your dashboard (the one under Queries (HTTP)!) then click on the **Check subgraph deployment** button on the right to check that your subgraph has been deployed to the Hosted Service.

'''
'''--- markdown/the_graph_near/SUBGRAPH_QUERY.md ---
## 🎥 Video Walkthrough of Querying the NEAR Subgraph

{% embed url="https://www.youtube.com/watch?v=SnMQjraROOE" caption="Querying the NEAR Subgraph" %}

## 🕵🏻 Querying the subgraph

After deploying the subgraph, we need to wait a little in order for it to sync with the NEAR mainnet. It will scan past blocks starting at the `startBlock` you specified in `subgraph.yaml` to find receipts and then listen for any new receipts.

> Note: the indexing progression indicator in the dashboard for the Hosted Service is not currently functioning for NEAR subgraphs.

In your Hosted Service dashboard, there is a playground area with a GraphiQL UI. Consider this a sandbox in which to experiment with GraphQL queries. Open the right sidebar to explore your schema.

## 👨‍💻 Your turn! Write the GraphQL query

Using the playground, write a GraphQL query that returns the last 5 account DID registrations ordered by registration time (descending).

Some hints to help you:

- Start by just fetching for the "putDID" event function and passing all the fields you want back. Use this as a guide to filter - `where: {event_in: ["putDID"]}`
- You will want `id`, `accountId`, `did` and `registered`
- Then use `first`, `orderBy` and `orderDirection` to get 5 registrations.

## 😅 Solution

Try this query in your playground.

```graphql
// solution
query {
   logs(first: 5, orderBy: registered, orderDirection: desc, where: {event_in: ["putDID"]}) {
    id
    did
    accountId
    registered
  }
}
```

## 🥳 Now see the results of the query

Now, it's time to see the query in action! Click on the button on the right, and say hello to the DIDs!

> Note - if you don't see 5 entries it's because the contract is new and there haven't been more than 5 registrations yet. There should be at least one.

![dids](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph-near/query-01.png?raw=true)

## 🏁 Conclusion

Congratulations, you made it! What did you think?

If you have any feedback, reach out on [Discord](https://figment.io/devchat)!

If you want to keep learning about The Graph, NEAR, or Ceramic, we have more advanced tutorials on [Figment Learn](https://learn.figment.io/protocols/).

'''
'''--- markdown/the_graph_near/SUBGRAPH_SCAFFOLD.md ---
## 🎥 Video Walkthrough of Scaffolding a NEAR Subgraph

{% embed url="https://www.youtube.com/watch?v=CY5BLvcY4TA" caption="Scaffolding a NEAR Subgraph" %}

## 🌐 What's a subgraph?

A subgraph defines which data The Graph will index from NEAR, and how it will store it. It's made up of 3 main pieces: a manifest, a schema of entities and mappings.

![Anatomy](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph/subgraph-01.png?raw=true)

In this Pathway we will go over each of them one by one, understand what they do and how they work.

## 🤝 Picking a contract account

On NEAR we don't have events (at least not yet) like we do on Ethereum. The Graph for NEAR indexes blocks and receipts. The receipts may contain logs if a developer codes them in (ideally in a standard JSON format). So the first thing we need to do is pick the NEAR contract account our subgraph will be listening to.

> Note: you can connect to contract accounts on `near-mainnet` or `near-testnet`.

For the purpose of this tutorial we created and deployed a contract account that we know is emmitting logs in JSON format so we have something to work with. It's a registry contract that enables people to register and associate their NEAR account with a decentralized identifier (DID) created on the Ceramic Network.

The use case we'll explore in the rest of this tutorial is how to make our app query this subgraph to get all the existing registrations (DIDs). Knowing the DID's, we can then bring in corresponding data from Ceramic for each DID to create interesting and useful directories (like a NEAR Guilds directory or a member's directory for a specific app).

## Ethereum vs NEAR "events"

For Ethereum contracts, you can go to Etherscan and lookup the contract address to look at its code and figure out what events are being emitted. For example, you can view the popular Crypto Punk ETH-20 contract [here](https://etherscan.io/address/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB) and if you click on the "Contract" tab you can also have a look at [its Solidity code](https://etherscan.io/address/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB). The contract's address is `0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB`.

Ethereum contracts have ABIs (Application Binary Interface). It defines the methods and structures that can be used to interact with that binary contract and what shape of data you'll get back.

NEAR contracts compile to webAssembly (WASM) and don't have ABIs so it's not as easy to find the data NEAR contracts are emitting. Etherscan support is coming some day, but until then you either know what's being emitted in the logs because you are the developer, you need to go through the code in a Github repo, or go through transactions in the [NEAR block explorer](https://explorer.near.org) to figure it out.

Recently, NEAR enhancement proposal 171 ([NEP-171](https://github.com/near/NEPs/blob/master/specs/Standards/NonFungibleToken/Event.md)) defined an event format primarily aimed at NFTs. However, it's also a useful standard for developers to use in other contracts. So if looking through code, you may come across something like this from a contract coded with AssemblyScript:

```text
logging.log(`{"EVENT_JSON":{
      "standard":"nep171",
      "version":"1.0.0",
      "event":"removeEditor",
      "data":{
        "editor":"${accountId}",
        "time":${Context.blockTimestamp},
        "removedBy":"${Context.predecessor}"
      }}}`)
```

> Looking at that code, can you find the event and data it provides? What function is being called? What arguments are included in the data? We will come back to these logged events very soon.

## 💻 Install the Graph CLI

In a code editor, a subgraph will be a folder with a few different folders and files. Usually we'd use the CLI to initiate a Graph project that sets up those files/folders for us, but the ability to run `graph init` is currently not available for NEAR. So we'll need to scaffold out our project differently.

We will need The Graph Cli installed to generate, build, and deploy the subgraphs to the Hosted Service. Install the CLI by running:

```text
npm install -g @graphprotocol/graph-cli
```

Verify the installation was successful by running `graph` in your Terminal. You should see:

```text
Welcome to graph CLI version 0.23.2!
Type graph --help to view common commands.
```

Let's then cd into the `subgraphs` folder:

```text
cd subgraphs
```

## 🧑🏼‍💻 Your turn! Clone a NEAR subgraph scaffold

We've made it easier to scaffold out a NEAR subgraph project by creating a branch of our [NEAR-Subgraph Template](https://github.com/VitalPointAI/near-subgraph) for you can clone from Github.

```text
git clone --branch near-graph https://github.com/VitalPointAI/near-subgraph.git
```

Once the template has been cloned, change into the `near-subgraph` directory and install the dependencies with npm.

Assuming you're using Gitpod, you can use the terminal command `code <filename>` to open a file, or navigate to the file in the Explorer panel and click on the filename.
You can review the scaffolded files by looking in `subgraph.yaml`, `schema.graphql` and `src/mapping.ts`.

```text
cd near-subgraph
npm install
```

## ✅ Make sure it works

Now it's time for you to verify that you have followed the instructions carefully.

Click on the **Check for a subgraph scaffold** button on the right to see if your scaffold exists, and is in the right place.

'''
'''--- markdown/the_graph_near/SUBGRAPH_SCHEMA.md ---
## 🎥 Video Walkthrough of the Subgraph Schema

{% embed url="https://www.youtube.com/watch?v=cIllX_fFTuc" caption="The Subgraph Schema" %}

## 🪢 Entities and relations

We just tweaked the manifest to declare what information we were looking for. We declared one entity called `Account` and another called `Log`. Now we need to implement them by defining what attributes they have and specifying their types.

This is analogous to the process of defining the Models in an MVC framework.

Entities will be defined in the `schema.graphql` file.

![Entities](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph-near/entity-01.png?raw=true)

## 🧑🏼‍💻 Your turn! Define the Account and Log entities

For our implementation, this is super straightforward: We simply need an entity that stores all the values of the JSON object that we get from the contract log string so we can then use them later on in our application. Remember that you or your developer ensured the contract is emitting logs in NEP 171 (JSON) format.

The Graph support for NEAR provides a handy `json.fromString` function you can use. Unless you're going to pass back the entire JSON string and work with it in the frontend, you'll definitely want to break up the object as it unlocks the power of graphQL queries.

> You can create complex entities and relationships between them. Have a look at [Nader Dabit's tutorial](https://dev.to/dabit3/building-graphql-apis-on-ethereum-4poa) on how to use `@derivedFrom` to specify a one-to-many relationship. "For one-to-many relationships, the relationship should always be stored on the 'one' side, and the 'many' side should always be derived."

The DID Registry contract is outputting logs in the following format for the `init` and `putDID` methods.

```typescript
logging.log(`{"EVENT_JSON":{
    "standard":"nep171",
    "version":"1.0.0",
    "event":"init",
    "data":{
      "adminId":"${adminId}",
      "adminSet":${Context.blockTimestamp},
      "accountId":"${adminId}"
    }}}`);

logging.log(`{"EVENT_JSON":{
    "standard":"nep171",
    "version":"1.0.0",
    "event":"putDID",
    "data":{
      "accountId":"${accountId}",
      "did":"${did}",
      "registered":${Context.blockTimestamp},
      "owner":"${Context.predecessor}"
    }}}`);
```

Try filling in the blanks to build the corresponding entities. (Hint: Context.blockTimestamp is a large number, not a string)

> Note: the `!` means a property is required. The types you can use in entities includes: Bytes, ID, String, Boolean, Int, BigInt, and BigDecimal. See the [docs](https://thegraph.com/docs/developer/create-subgraph-hosted#built-in-scalar-types) for more info.

```graphql
type Account @entity {
  id: ID!
  signerId: String!
  # What type should log be defined as?
  log: __________
}

type Log ________ {
  id: ID!
  standard: String!
  version: String!
  event: _______
  adminId: String
  _______: ______
  accountId: String
  ___: _____
  registered: BigInt
  owner: String
}
```

## 😅 Solution

Replace the existing contents of `schema.graphql` with the following code snippet:

```graphql
// solution
type Account @entity {
  id: ID!
  signerId: String!
  log: [Log!]!
}

type Log @entity {
  id: ID!
  standard: String!
  version: String!
  event: String!
  adminId: String
  adminSet: BigInt
  accountId: String
  did: String
  registered: BigInt
  owner: String
}
```

In the above code snippet, there are two points worth mentioning:

- For the purpose of indexing, entities _must have_ an `ID` field to uniquely identify them.
- Logs emmitted from a NEAR contract are strings. Developers can make it easy to consume them be ensuring they emit properly formed JSON strings. It's possible to have more than one log emmitted from the same function, so we store them in an array.

## 🏗️ The "codegen" command

We have now defined the entity that we declared in the manifest!

Run the following command to generate boilerplate code from our **entities**:

```text
yarn codegen
```

What does `yarn codegen` do? This command creates some boilerplate code under the `generated` folder. This boilerplate code defines **typescript** classes for each `entities` (have a look at `generated/schema.ts`). We will use this code in the next step to define the mappings between our entities and the NEAR contract events.

![terminal](https://raw.githubusercontent.com/figment-networks/learn-web3-dapp/main/markdown/__images__/the-graph-near/entity-02.gif?raw=true)

## ✅ Make sure it's going to work

Before going to the next step, click on the **Check for expected entities** button on the right to make sure your entities are properly defined.

'''
'''--- next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

'''
'''--- next.config.js ---
const withTM = require('next-transpile-modules')([
  '@project-serum/sol-wallet-adapter',
  '@solana/wallet-adapter-base',
  // Uncomment wallets you want to use
  // "@solana/wallet-adapter-bitpie",
  // "@solana/wallet-adapter-coin98",
  // "@solana/wallet-adapter-ledger",
  // "@solana/wallet-adapter-mathwallet",
  '@solana/wallet-adapter-phantom',
  '@solana/wallet-adapter-react',
  '@solana/wallet-adapter-solflare',
  '@solana/wallet-adapter-sollet',
  // "@solana/wallet-adapter-solong",
  // "@solana/wallet-adapter-torus",
  '@solana/wallet-adapter-wallets',
]);

module.exports = withTM({
  reactStrictMode: true,
  typescript: {
    ignoreBuildErrors: true,
  },
  compiler: {
    // Enables the styled-components SWC transform
    styledComponents: true,
  },
  webpack5: true,
  webpack: (config, {isServer}) => {
    if (!isServer) {
      config.resolve.fallback.fs = false;
    }
    return config;
  },
});

'''
'''--- package.json ---
{
  "name": "learn-web3-dapp",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "dev:figment": "APP_ENV=development next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "solana:build:program": "cargo build-bpf --manifest-path=contracts/solana/program/Cargo.toml --bpf-out-dir=dist/solana/program",
    "near:build:contract": "node contracts/near/compile.js",
    "near:build:contract:debug": "node contracts/near/compile.js --debug",
    "near:test": "cd contracts/near && cargo test -- --nocapture && cd -",
    "near:test:verbose": "yarn near:build:contract:debug && cd contracts/near && cargo test -v -- --nocapture && cd -",
    "truffle-polygon": "yarn global add truffle && cd ./contracts/polygon/SimpleStorage && yarn && truffle obtain --solc 0.8.0",
    "prepare": "husky install",
    "test": "[ -f dist/solana/program/helloworld-keypair.json ] && jest || echo 'Run: yarn solana:build:program'"
  },
  "dependencies": {
    "@3id/connect": "^0.2.5",
    "@ant-design/icons": "^4.6.2",
    "@apollo/client": "^3.4.16",
    "@celo/contractkit": "^1.2.4",
    "@ceramicnetwork/3id-did-resolver": "^1.4.3",
    "@ceramicnetwork/http-client": "^1.3.0",
    "@ceramicstudio/idx": "^0.12.2",
    "@iov/crypto": "^2.5.0",
    "@jup-ag/core": "1.0.0-beta.4",
    "@jup-ag/react-hook": "1.0.0-beta.4",
    "@maticnetwork/maticjs": "2.0.46",
    "@metamask/detect-provider": "^1.2.0",
    "@orca-so/sdk": "^1.2.22",
    "@polkadot/api": "^6.4.2",
    "@project-serum/sol-wallet-adapter": "^0.2.6",
    "@pythnetwork/client": "^2.5.1",
    "@raydium-io/raydium-sdk": "^1.0.1-beta.14",
    "@segment/snippet": "^4.14.2",
    "@solana/buffer-layout": "4.0.0",
    "@solana/wallet-adapter-react": "^0.15.1",
    "@solana/wallet-adapter-react-ui": "^0.9.2",
    "@solana/wallet-adapter-wallets": "^0.14.1",
    "@solana/web3.js": "^1.31.0",
    "@taquito/signer": "^10.0.0",
    "@taquito/taquito": "^10.0.0",
    "@types/js-yaml": "^4.0.3",
    "@types/node": "^15.12.4",
    "@types/react": "^17.0.11",
    "@types/react-dom": "^17.0.8",
    "@types/react-no-ssr": "^1.1.3",
    "@types/react-router-dom": "^5.1.7",
    "@types/simple-react-lightbox": "^3.6.1",
    "@types/styled-components": "^5.1.10",
    "antd": "^4.16.1",
    "avalanche": "3.7.0",
    "axios": "^0.21.1",
    "bip39": "^3.0.4",
    "bn.js": "^5.2.0",
    "bs58": "^4.0.1",
    "dids": "^2.4.0",
    "ethereumjs-util": "^7.1.0",
    "graphql": "^15.6.1",
    "js-yaml": "^4.1.0",
    "lodash": "^4.17.21",
    "lodash.unescape": "^4.0.1",
    "mz": "^2.7.0",
    "near-api-js": "^0.41.0",
    "next": "^12.0.4-canary.4",
    "next-transpile-modules": "^9.0.0",
    "nextjs-progressbar": "^0.0.13",
    "react": "^17.0.2",
    "react-confetti": "^6.0.1",
    "react-dom": "^17.0.2",
    "react-feather": "^2.0.9",
    "react-is": ">= 16.8.0",
    "react-json-view": "^1.21.3",
    "react-markdown": "^7.0.1",
    "react-no-ssr": "^1.1.0",
    "react-player": "^2.9.0",
    "react-syntax-highlighter": "^15.4.4",
    "recharts": "^2.1.8",
    "remark-gfm": "^2.0.0",
    "rxjs": "^7.5.2",
    "secretjs": "^0.17.3",
    "simple-react-lightbox": "^3.6.9-0",
    "styled-components": "^5.3.0",
    "swr": "^1.1.2",
    "web3": "^1.5.0",
    "minimist": "^1.2.6"
  },
  "devDependencies": {
    "@babel/core": "^7.15.5",
    "@babel/preset-env": "^7.15.6",
    "@babel/preset-typescript": "^7.15.0",
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^12.1.0",
    "@types/depd": "^1.1.32",
    "@types/jest": "^27.0.1",
    "@types/js-yaml": "^4.0.3",
    "@types/lodash.unescape": "^4.0.6",
    "@types/mz": "^2.7.4",
    "@types/node": "^15.12.4",
    "@types/react": "^17.0.11",
    "@types/react-dom": "^17.0.8",
    "@types/react-router-dom": "^5.1.7",
    "@types/react-syntax-highlighter": "^13.5.2",
    "@types/styled-components": "^5.1.10",
    "@typescript-eslint/eslint-plugin": "^4.31.0",
    "@typescript-eslint/parser": "^4.0.0",
    "babel-jest": "^27.2.0",
    "babel-plugin-styled-components": "^1.13.1",
    "dotenv": "^10.0.0",
    "eslint": "7.29.0",
    "eslint-config-next": "11.0.1",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin": "^1.0.1",
    "eslint-plugin-import": "^2.24.2",
    "eslint-plugin-prettier": "^4.0.0",
    "eslint-plugin-react": "^7.25.1",
    "husky": "^7.0.0",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^27.2.0",
    "prettier": "2.3.2",
    "pretty-quick": "^3.1.1",
    "react-test-renderer": "^17.0.2",
    "shelljs": "^0.8.4",
    "typescript": "^4.4.4"
  },
  "resolutions": {
    "@solana/buffer-layout": "4.0.0"
  }
}

'''
'''--- pages/api/avalanche/account.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getAvalancheClient} from '@figment-avalanche/lib';

type ResponseT = {
  secret: string;
  address: string;
};

export default function account(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>,
) {
  try {
    const {network} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const keyChain = chain.keyChain();
    const keypair = keyChain.undefined; // There is a useful method to use here
    const secret = undefined;
    const address = undefined;
    res.status(200).json({
      secret,
      address,
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/avalanche/balance.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getAvalancheClient} from '@figment-avalanche/lib';

type TransactionT = {
  txID: string;
  outputIndex: number;
};

type BalanceT = {
  balance: string;
  utxoIDs: TransactionT[];
};

export default async function balance(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {address, network} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const balance = undefined;
    res.status(200).json(balance.balance);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/avalanche/connect.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getAvalancheClient} from '@figment-avalanche/lib';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  //...
  try {
    const {network} = req.body;
    const client = undefined;
    const info = undefined;
    const version = undefined;
    if (version === undefined) {
      throw new Error('Connection failed: Complete the code');
    }
    res.status(200).json(version);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/avalanche/export.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getAvalancheClient} from '@figment-avalanche/lib';
import {BN} from 'avalanche';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {secret, network} = req.body;
    const client = getAvalancheClient(network);

    // Total amount we're transferring = 0.05 AVAX
    const amount = '50000000';

    // Taking inspiration for xChain do the same for cChain
    const [xChain, cChain] = [client.XChain(), undefined];
    const [xKeychain, cKeychain] = [xChain.keyChain(), undefined];
    const [xKeypair, cKeypair] = [xKeychain.importKey(secret), undefined];
    const [xAddress, cAddress] = [xKeypair.getAddressString(), undefined];

    // Fetch UTXOs (unspent transaction outputs)
    const {utxos} = await xChain.getUTXOs(xAddress);

    // Get the real ID for the cChain
    const chainId = undefined;

    // Prepare the export transaction from X -> C chain
    const exportTx = await xChain.buildExportTx(undefined);

    // Sign and send the transaction
    const hash = await xChain.issueTx(exportTx.sign(xKeychain));

    res.status(200).json(hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/avalanche/import.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getAvalancheClient} from '@figment-avalanche/lib';
import {BinTools} from 'avalanche';
import {Address} from 'ethereumjs-util';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {secret, network} = req.body;
    const client = getAvalancheClient(network);

    // Initialize chain components
    const [xChain, cChain] = [client.XChain(), client.CChain()];
    const [xKeychain, cKeychain] = [xChain.keyChain(), cChain.keyChain()];
    const [xKeypair, cKeypair] = [
      xKeychain.importKey(secret),
      cKeychain.importKey(secret),
    ];
    const [cAddress] = [cKeypair.getAddressString()];

    // Get the real ID for X-Chain
    const xChainId = undefined;

    // Fetch UTXOs (unspent transaction outputs)
    const {utxos} = await cChain.getUTXOs(cAddress, xChainId);

    // Derive Eth-like address from the private key
    const binTools = BinTools.getInstance();
    const keyBuff = binTools.cb58Decode(secret.split('-')[1]);
    const ethAddr = Address.fromPrivateKey(
      Buffer.from(keyBuff.toString('hex'), 'hex'),
    ).toString();
    console.log('Ethereum-style address: ', ethAddr);

    // Generate an unsigned import transaction
    const importTx = await cChain.buildImportTx(undefined);

    // Sign and send import transaction
    const hash = await cChain.issueTx(importTx.sign(cKeychain));

    res.status(200).json(hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/avalanche/transfer.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getAvalancheClient} from '@figment-avalanche/lib';
import {BinTools, BN} from 'avalanche';

export default async function transfer(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {secret, navax, recipient, address, network} = req.body;
    const client = getAvalancheClient(network);
    const chain = client.XChain();
    const keychain = chain.keyChain();
    // Using keychain, load the private key to sign transactions
    undefined;

    // Fetch UTXOs (unspent transaction outputs)
    const {utxos} = undefined;

    // Determine the real asset ID from its symbol/alias
    const binTools = BinTools.getInstance();
    const assetInfo = await chain.getAssetDescription('AVAX');
    const assetID = binTools.cb58Encode(assetInfo.assetID);

    // Create a new transaction
    const transaction = await chain.buildBaseTx(undefined);

    // Sign the transaction and send it to the network
    undefined;
    undefined;

    res.status(200).json(hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/celo/account.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-celo/lib';
import {newKit} from '@celo/contractkit';

type ResponseT = {
  address: string;
  secret: string;
};
export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>,
) {
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);
    const account = undefined;
    const address = undefined;
    const secret = undefined;

    res.status(200).json({
      address,
      secret,
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/celo/balance.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-celo/lib';
import {newKit} from '@celo/contractkit';

type ResponseT = {
  attoCELO: string;
  attoUSD: string;
  attoEUR: string;
};
export default async function balance(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>,
) {
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    const goldtoken = undefined;
    const celoBalance = undefined;

    const stabletokenUSD = undefined;
    const cUSDBalance = undefined;

    const stabletokenEUR = undefined;
    const cEURBalance = undefined;

    res.status(200).json({
      attoCELO: celoBalance.toString(),
      attoUSD: cUSDBalance.toString(),
      attoEUR: cEURBalance.toString(),
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/celo/connect.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-celo/lib';
import {newKit} from '@celo/contractkit';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const kit = undefined;
    const version = undefined;
    res.status(200).json(version.slice(5, 11));
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/celo/deploy.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-celo/lib';
import {newKit} from '@celo/contractkit';
import HelloWorld from 'contracts/celo/HelloWorld.json';

type ResponseT = {
  address: string;
  hash: string;
};

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>,
) {
  try {
    const {secret, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    kit.addAccount(secret);

    // TODO: Create a transaction to deploy the contract

    const receipt = await tx.waitReceipt();

    res.status(200).json({
      address: receipt?.contractAddress as string,
      hash: receipt.transactionHash,
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/celo/getter.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-celo/lib';
import {newKit} from '@celo/contractkit';
import HelloWorld from 'contracts/celo/HelloWorld.json';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {contract, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    // Create a new contract instance with the HelloWorld contract info
    const instance = undefined;
    // Call the getName function of the on-chain contract
    const name = undefined;

    res.status(200).json(name);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/celo/setter.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-celo/lib';
import {newKit} from '@celo/contractkit';
import HelloWorld from 'contracts/celo/HelloWorld.json';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {secret, newMessage, contract, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);
    kit.addAccount(secret);

    // Create a new contract instance with the HelloWorld contract info
    const instance = undefined;
    // Call the setName function of our contract
    const txObject = undefined;
    // Send a transaction Object to modify the state of our contract
    let tx = undefined;

    let receipt = await tx.waitReceipt();

    res.status(200).json(receipt.transactionHash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/celo/swap.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-celo/lib';
import {newKit} from '@celo/contractkit';

type ResponseT = {
  celo: string;
  hash: string;
};
export default async function swap(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>,
) {
  try {
    const {secret, address, network} = req.body;
    const OneCUSD = '1000000000000000000';

    const url = getNodeUrl(network);
    const kit = newKit(url);
    kit.addAccount(secret);

    // Get contract wrappers
    // - StableTokenWrapper
    // - ExchangeWrapper
    const stableToken = undefined;
    const exchange = undefined;

    // Approve a user to transfer StableToken on behalf of another user.
    const approveTx = undefined;

    // Exchange cUSD for CELO
    const goldAmount = undefined;
    const sellTx = undefined;

    await sellReceipt.waitReceipt();
    const hash = await sellReceipt.getHash();
    res.status(200).json({
      celo: goldAmount.toString(),
      hash,
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/celo/transfer.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-celo/lib';
import {newKit} from '@celo/contractkit';

export default async function transfer(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {secret, amount, recipient, address, network} = req.body;
    const url = getNodeUrl(network);
    const kit = newKit(url);

    // Restore account using your secret
    undefined;
    // Access CELO contract wrapper
    const celoToken = undefined;
    // Build the transaction and send
    const celotx = undefined;
    // Wait for confirmation of the transaction
    const celoReceipt = await celotx.waitReceipt();

    res.status(200).json(celoReceipt.transactionHash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/balance.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {configFromNetwork} from '@figment-near/lib';
import {connect} from 'near-api-js';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  const {network, accountId} = req.body;
  try {
    const config = configFromNetwork(network);
    const client = await connect(config);
    const account = undefined;
    const balance = undefined;
    console.log(balance);
    return res.status(200).json(balance);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/check-account.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {configFromNetwork} from '@figment-near/lib';
import {connect} from 'near-api-js';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<boolean | string>,
) {
  const {freeAccountId, network} = req.body;
  try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    // try to query the account info of the
    const accountInfo = undefined;
    try {
      undefined;
      return res.status(200).json(false);
    } catch (error) {
      return res.status(200).json(true);
    }
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/connect.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {configFromNetwork} from '@figment-near/lib';
import {connect} from 'near-api-js';

export default async function connection(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  const {network} = req.body;
  try {
    const config = configFromNetwork(network);
    const near = undefined;
    const provider = undefined;
    const status = undefined;
    return res.status(200).json(status.version.version);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/create-account.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {configFromNetwork} from '@figment-near/lib';
import {connect} from 'near-api-js';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  const {freeAccountId, publicKey, network} = req.body;
  try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    undefined;
    return res.status(200).json(freeAccountId);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/deploy.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {configFromNetwork} from '@figment-near/lib';
import {connect, KeyPair} from 'near-api-js';
import fs from 'fs';

// The symbolic link /out/main.wasm points to /contracts/near/target/release/wasm32-unknown-unknown/release/greeter.wasm
const WASM_PATH = 'contracts/near/out/main.wasm';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  const {secret, accountId, network} = req.body;
  try {
    const config = configFromNetwork(network);
    const keypair = KeyPair.fromString(secret);

    // Again you will need to set your keystore
    config.keyStore?.undefined;

    const near = await connect(config);
    const account = await near.account(accountId);

    // Time to deploy the Smart Contract
    const response = undefined;
    return res.status(200).json(response.transaction.hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/getter.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {configFromNetwork} from '@figment-near/lib';
import {connect} from 'near-api-js';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  const {network, accountId} = req.body;
  try {
    const config = configFromNetwork(network);
    const near = await connect(config);
    const account = await near.account(accountId);
    // Using ViewFunction try to call the contract
    const response = undefined;
    return res.status(200).json(response);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/keypair.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {KeyPair} from 'near-api-js';

type ReponseT = {
  address: string;
  secret: string;
};

export default function connection(
  _req: NextApiRequest,
  res: NextApiResponse<ReponseT | string>,
) {
  try {
    const keypair = undefined;
    const secret = undefined;
    const address = undefined;
    if (!secret || !address) {
      throw new Error('Please complete the code.');
    }
    return res.status(200).json({address, secret});
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/setter.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {configFromNetwork} from '@figment-near/lib';
import {connect, KeyPair} from 'near-api-js';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  const {network, accountId, secret, newMessage} = req.body;
  try {
    const config = configFromNetwork(network);
    const keypair = KeyPair.fromString(secret);
    config.keyStore?.setKey('testnet', accountId, keypair);

    const near = await connect(config);
    const account = await near.account(accountId);
    // Look at functionCall and pass the expected args
    // ... fill here
    return res.status(200).json(response.transaction.hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/near/transfer.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {configFromNetwork} from '@figment-near/lib';
import {connect, KeyPair} from 'near-api-js';
import {parseNearAmount} from 'near-api-js/lib/utils/format';
import BN from 'bn.js';

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  const {txSender, txAmount, txReceiver, network, secret} = req.body;

  try {
    const config = configFromNetwork(network);

    // recreate the keypair from secret
    const keypair = undefined;

    // Set the keystore with the expected method and args
    config.keyStore?.undefined;

    // Here we convert the NEAR into yoctoNEAR using utilities from NEAR lib
    const yoctoAmount = parseNearAmount(txAmount) as string;
    const amount = new BN(yoctoAmount);

    // Fill the Gap: connect, create an Account Object and send some money
    const near = undefined;
    const account = undefined;
    const transaction = undefined;

    return res.status(200).json(transaction.transaction.hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    return res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/polkadot/account.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';

import {Keyring} from '@polkadot/api';
import {mnemonicGenerate, mnemonicValidate} from '@polkadot/util-crypto';

type PolkadotAccountResponse = {
  address: string;
  mnemonic: string;
  jsonWallet: string;
};

export default async function account(
  _req: NextApiRequest,
  res: NextApiResponse<PolkadotAccountResponse | string>,
) {
  try {
    const keyring = new Keyring({type: 'sr25519'});

    // Create mnemonic string
    const mnemonic = undefined;

    const isValidMnemonic = mnemonicValidate(mnemonic);
    if (!isValidMnemonic) {
      throw Error('Invalid Mnemonic');
    }

    // Add an account derived from the mnemonic
    const account = undefined;
    const address = undefined;
    const jsonWallet = undefined;
    res.status(200).json({
      address,
      mnemonic,
      jsonWallet,
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/polkadot/balance.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';

import {ApiPromise, WsProvider} from '@polkadot/api';
import {getNodeUrl} from '@figment-polkadot/lib';

export default async function balance(
  req: NextApiRequest,
  res: NextApiResponse<number | string>,
) {
  let provider;
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({provider: provider});
    const {
      data: {free},
    } = undefined;
    const amount = undefined;
    await provider.disconnect();
    res.status(200).json(amount);
  } catch (error) {
    if (provider) {
      await provider.disconnect();
    }
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/polkadot/connect.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';

import {ApiPromise, WsProvider} from '@polkadot/api';
import {getNodeUrl} from '@figment-polkadot/lib';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  let provider: any;
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = undefined;
    const rawVersion = undefined;
    const version = rawVersion.toHuman();
    await provider.disconnect();
    res.status(200).json(version);
  } catch (error) {
    if (provider) {
      await provider.disconnect();
    }
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/polkadot/deposit.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';

import {ApiPromise, WsProvider} from '@polkadot/api';
import {getNodeUrl} from '@figment-polkadot/lib';

export default async function deposit(
  req: NextApiRequest,
  res: NextApiResponse<number | string>,
) {
  let provider;
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({provider: provider});
    const deposit = undefined;
    await provider.disconnect();
    res.status(200).json(deposit);
  } catch (error) {
    if (provider) {
      await provider.disconnect();
    }
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/polkadot/estimate.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {ApiPromise, WsProvider} from '@polkadot/api';
import {getNodeUrl} from '@figment-polkadot/lib';

export default async function estimate(
  req: NextApiRequest,
  res: NextApiResponse<number | string>,
) {
  let provider;
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({provider: provider});

    // A generic address for recipient (//Alice) and amount to send
    const recipient = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY';
    const transferAmount = '1000000000';

    // Transfer tokens
    const transfer = undefined;
    const info = undefined;
    const fees = undefined;

    await provider.disconnect();
    res.status(200).json(fees);
  } catch (error) {
    if (provider) {
      await provider.disconnect();
    }
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/polkadot/restore.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {Keyring} from '@polkadot/api';

export default async function restore(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {mnemonic} = req.body;
    const keyring = undefined;
    const account = undefined;
    const address = undefined;
    res.status(200).json(address);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/polkadot/transfer.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';

import {ApiPromise, WsProvider, Keyring} from '@polkadot/api';
import {getNodeUrl} from '@figment-polkadot/lib';

export default async function transfer(
  req: NextApiRequest,
  res: NextApiResponse<number | string>,
) {
  let provider;
  try {
    const {mnemonic, txAmount, network} = req.body;
    const url = getNodeUrl(network);
    provider = new WsProvider(url);
    const api = await ApiPromise.create({provider: provider});

    // Initialize account from the mnemonic
    const keyring = new Keyring({type: 'sr25519'});
    const account = keyring.addFromUri(mnemonic);

    // Initialize account from the mnemonic
    const recipient = keyring.addFromUri('//Alice');
    const recipientAddr = recipient.address;

    // Transfer tokens
    const transfer = undefined;
    const hash = await transfer.signAndSend(account);

    await provider.disconnect();
    res.status(200).json(hash.toString());
  } catch (error) {
    if (provider) {
      await provider.disconnect();
    }
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/pyth/connect.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeURL} from '@figment-solana/lib';
import {Connection} from '@solana/web3.js';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {network} = req.body;
    const url = getNodeURL(network);
    const connection = undefined;
    const version = undefined;
    res.status(200).json(version['solana-core']);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/secret/account.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey} from 'secretjs';
import {Bip39, Random} from '@iov/crypto';

type ResponseT = {
  mnemonic: string;
  address: string;
};
export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>,
) {
  try {
    const mnemonic = undefined;
    const signingPen = await undefined;
    const pubkey = undefined;
    const address = undefined;
    res.status(200).json({mnemonic, address});
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/secret/balance.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-secret/lib';
import {CosmWasmClient} from 'secretjs';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string | string>,
) {
  try {
    const url = getNodeUrl();
    const {address} = req.body;
    const client = new CosmWasmClient(url);

    // Query the Account object
    const account = undefined;
    // Return the balance
    const balance = undefined;

    res.status(200).json(balance);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/secret/connect.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-secret/lib';
import {CosmWasmClient} from 'secretjs';

export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const url = getNodeUrl();
    const client = undefined;
    const nodeInfo = undefined;
    const version = undefined;
    res.status(200).json(version);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/secret/deploy.ts ---
import {
  EnigmaUtils,
  SigningCosmWasmClient,
  Secp256k1Pen,
  pubkeyToAddress,
  encodeSecp256k1Pubkey,
} from 'secretjs';
import {getNodeUrl} from '@figment-secret/lib';
import type {NextApiRequest, NextApiResponse} from 'next';
import fs from 'fs';

const CONTRACT_PATH = './contracts/secret/contract.wasm';

const customFees = {
  upload: {
    amount: [{amount: '2000000', denom: 'uscrt'}],
    gas: '2000000',
  },
  init: {
    amount: [{amount: '500000', denom: 'uscrt'}],
    gas: '500000',
  },
};

type ResponseT = {
  contractAddress: string;
  transactionHash: string;
};
export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>,
) {
  try {
    const url = await getNodeUrl();
    const {mnemonic} = req.body;
    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic);
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');

    // Initialise client
    const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();
    const client = new SigningCosmWasmClient(
      url,
      address,
      (signBytes) => signingPen.sign(signBytes),
      txEncryptionSeed,
      customFees,
    );

    // Upload the contract wasm
    const wasm = fs.readFileSync(CONTRACT_PATH);
    const uploadReceipt = await client.undefined;
    if (!uploadReceipt) {
      throw new Error('uploadReceipt error');
    }
    // Get the code ID from the receipt
    const {codeId} = uploadReceipt;

    // Create an instance of the Counter contract, providing a starting count
    const initMsg = {count: 101};
    const receipt = undefined;

    res.status(200).json({
      contractAddress: receipt.contractAddress,
      transactionHash: receipt.transactionHash,
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/secret/getter.ts ---
import {
  EnigmaUtils,
  SigningCosmWasmClient,
  Secp256k1Pen,
  pubkeyToAddress,
  encodeSecp256k1Pubkey,
} from 'secretjs';
import {getNodeUrl} from '@figment-secret/lib';
import type {NextApiRequest, NextApiResponse} from 'next';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const url = getNodeUrl();
    const {mnemonic, contractId} = req.body;

    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic);
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');

    const customFees = {
      send: {
        amount: [{amount: '80000', denom: 'uscrt'}],
        gas: '80000',
      },
    };

    // Initialise client
    const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();
    const client = new SigningCosmWasmClient(
      url,
      address,
      (signBytes) => signingPen.sign(signBytes),
      txEncryptionSeed,
      customFees,
    );

    // Get the stored value
    console.log('Querying contract for current count');
    let response = undefined;
    let count = response.count as number;

    res.status(200).json(count.toString());
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/secret/setter.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-secret/lib';
import {
  EnigmaUtils,
  SigningCosmWasmClient,
  Secp256k1Pen,
  pubkeyToAddress,
  encodeSecp256k1Pubkey,
} from 'secretjs';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const url = getNodeUrl();
    const {mnemonic, contractId} = req.body;
    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic);
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');

    const customFees = {
      exec: {
        amount: [{amount: '500000', denom: 'uscrt'}],
        gas: '500000',
      },
    };
    // Initialise client
    const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();
    const client = new SigningCosmWasmClient(
      url,
      address,
      (signBytes) => signingPen.sign(signBytes),
      txEncryptionSeed,
      customFees,
    );

    // Increment the counter
    const handleMsg = {increment: {}};
    const response = undefined;

    res.status(200).json(response.transactionHash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/secret/transfer.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeUrl} from '@figment-secret/lib';
import {
  EnigmaUtils,
  SigningCosmWasmClient,
  Secp256k1Pen,
  pubkeyToAddress,
  encodeSecp256k1Pubkey,
} from 'secretjs';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const url = getNodeUrl();
    const {mnemonic, txAmount} = req.body;

    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic);
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');

    // 0. A very specific Secret feature (this allows us to make the transaction encrypted)
    const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();

    // 1. The fees you'll need to pay to complete the transaction
    const fees = {
      send: {
        amount: [{amount: '80000', denom: 'uscrt'}],
        gas: '80000',
      },
    };

    // 2. Initialize a secure Secret client
    const client = new SigningCosmWasmClient(undefined);

    // 3. Send tokens
    const memo = 'sendTokens example'; // Optional memo to identify the transaction
    const sent = await client.sendTokens(undefined);

    // 4. Query the tx result
    const query = {id: sent.transactionHash};
    const transaction = await client.searchTx(query);
    //..
    const hash = transaction[0].hash;

    res.status(200).json(hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/solana/balance.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {Connection, PublicKey} from '@solana/web3.js';
import {getNodeURL} from '@figment-solana/lib';

export default async function balance(
  req: NextApiRequest,
  res: NextApiResponse<string | number>,
) {
  try {
    const {network, address} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const publicKey = new PublicKey(address);
    const balance = await connection.getBalance(publicKey, 'confirmed');
    if (balance === 0 || balance === undefined) {
      throw new Error('Account not funded');
    }
    res.status(200).json(balance);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/solana/connect.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeURL} from '@figment-solana/lib';
import {Connection} from '@solana/web3.js';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {network} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const version = await connection.getVersion();
    res.status(200).json(version['solana-core']);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/solana/deploy.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {Connection, PublicKey} from '@solana/web3.js';
import {getNodeURL} from '@figment-solana/lib';
import path from 'path';
import fs from 'mz/fs';

const PROGRAM_PATH = path.resolve('dist/solana/program');
const PROGRAM_SO_PATH = path.join(PROGRAM_PATH, 'helloworld.so');

export default async function deploy(
  req: NextApiRequest,
  res: NextApiResponse<string | boolean>,
) {
  try {
    const {network, programId} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    // Re-create publicKeys from params
    const publicKey = new PublicKey(programId);
    const programInfo = await connection.getAccountInfo(publicKey);

    if (programInfo === null) {
      if (fs.existsSync(PROGRAM_SO_PATH)) {
        throw new Error(
          'Program needs to be deployed with `solana program deploy`',
        );
      } else {
        throw new Error('Program needs to be built and deployed');
      }
    } else if (!programInfo.executable) {
      throw new Error(`Program is not executable`);
    }

    res.status(200).json(true);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/solana/fund.ts ---
import {Connection, PublicKey, LAMPORTS_PER_SOL} from '@solana/web3.js';
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeURL} from '@figment-solana/lib';

export default async function fund(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {network, address} = req.body;
    console.log('🚀 ~ file: fund.ts ~ line 12 ~ req.body', req.body);
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const publicKey = new PublicKey(address);
    const hash = await connection.requestAirdrop(publicKey, LAMPORTS_PER_SOL);
    await connection.confirmTransaction(hash);
    res.status(200).json(hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/solana/getter.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {Connection, PublicKey} from '@solana/web3.js';
import {getNodeURL} from '@figment-solana/lib';
import * as borsh from 'borsh';

// The state of a greeting account managed by the hello world program
class GreetingAccount {
  counter = 0;
  constructor(fields: {counter: number} | undefined = undefined) {
    if (fields) {
      this.counter = fields.counter;
    }
  }
}

// Borsh schema definition for greeting accounts
const GreetingSchema = new Map([
  [GreetingAccount, {kind: 'struct', fields: [['counter', 'u32']]}],
]);

export default async function getter(
  req: NextApiRequest,
  res: NextApiResponse<string | number>,
) {
  try {
    const {network, greeter} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');
    const greeterPublicKey = new PublicKey(greeter);

    const accountInfo = await connection.getAccountInfo(greeterPublicKey);

    if (accountInfo === null) {
      throw new Error('Error: cannot find the greeted account');
    }

    // Find the expected parameters.
    const greeting = borsh.deserialize(
      GreetingSchema,
      GreetingAccount,
      accountInfo.data,
    );

    // A little helper
    console.log(greeting);

    // Pass the counter to the client-side as JSON
    res.status(200).json(greeting.counter);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    console.log(errorMessage);
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/solana/greeter.ts ---
import {
  Connection,
  PublicKey,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
} from '@solana/web3.js';
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeURL} from '@figment-solana/lib';
import * as borsh from 'borsh';

// The state of a greeting account managed by the hello world program
class GreetingAccount {
  counter = 0;
  constructor(fields: {counter: number} | undefined = undefined) {
    if (fields) {
      this.counter = fields.counter;
    }
  }
}

// Borsh schema definition for greeting accounts
const GreetingSchema = new Map([
  [GreetingAccount, {kind: 'struct', fields: [['counter', 'u32']]}],
]);

// The expected size of each greeting account.
const GREETING_SIZE = borsh.serialize(
  GreetingSchema,
  new GreetingAccount(),
).length;

type ResponseT = {
  hash: string;
  greeter: string;
};
export default async function greeter(
  req: NextApiRequest,
  res: NextApiResponse<string | ResponseT>,
) {
  try {
    const {network, secret, programId: programAddress} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');

    const programId = new PublicKey(programAddress);
    const payer = Keypair.fromSecretKey(new Uint8Array(JSON.parse(secret)));
    const GREETING_SEED = 'hello';

    // Are there any methods from PublicKey to derive a public key from a seed?
    const greetedPubkey = await PublicKey.createWithSeed(
      payer.publicKey,
      GREETING_SEED,
      programId,
    );

    // This function calculates the fees we have to pay to keep the newly
    // created account alive on the blockchain. We're naming it lamports because
    // that is the denomination of the amount being returned by the function.
    const lamports = await connection.getMinimumBalanceForRentExemption(
      GREETING_SIZE,
    );

    // Find which instructions are expected and complete SystemProgram with
    // the required arguments.
    const transaction = new Transaction().add(
      SystemProgram.createAccountWithSeed({
        fromPubkey: payer.publicKey,
        basePubkey: payer.publicKey,
        seed: GREETING_SEED,
        newAccountPubkey: greetedPubkey,
        lamports,
        programId,
        space: GREETING_SIZE,
      }),
    );

    // Complete this function call with the expected arguments.
    const hash = await sendAndConfirmTransaction(connection, transaction, [
      payer,
    ]);
    res.status(200).json({
      hash: hash,
      greeter: greetedPubkey.toBase58(),
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/solana/keypair.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {Keypair} from '@solana/web3.js';

type ResponseT = {
  secret: string;
  address: string;
};
export default function keypair(
  _req: NextApiRequest,
  res: NextApiResponse<string | ResponseT>,
) {
  try {
    const keypair = Keypair.generate();
    console.log('🚀 ~ file: keypair.ts ~ line 14 ~ keypair', keypair);

    const address = keypair.publicKey.toString();
    const secret = JSON.stringify(Array.from(keypair.secretKey));
    res.status(200).json({
      secret,
      address,
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/solana/setter.ts ---
import {
  Connection,
  PublicKey,
  Keypair,
  TransactionInstruction,
  Transaction,
  sendAndConfirmTransaction,
} from '@solana/web3.js';
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeURL} from '@figment-solana/lib';

export default async function setter(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {greeter, secret, programId, network} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');

    const greeterPublicKey = new PublicKey(greeter);
    const programKey = new PublicKey(programId);

    const payerSecretKey = new Uint8Array(JSON.parse(secret));
    const payerKeypair = Keypair.fromSecretKey(payerSecretKey);

    // this your turn to figure out
    // how to create this instruction
    const instruction = new TransactionInstruction({
      keys: [{pubkey: greeterPublicKey, isSigner: false, isWritable: true}],
      programId: programKey,
      data: Buffer.alloc(0),
    });

    // this your turn to figure out
    // how to create this transaction
    const trans = new Transaction().add(instruction);
    const hash = await sendAndConfirmTransaction(connection, trans, [
      payerKeypair,
    ]);

    res.status(200).json(hash);
  } catch (error) {
    console.error(error);
    res.status(500).json('Get balance failed');
  }
}

'''
'''--- pages/api/solana/transfer.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {getNodeURL} from '@figment-solana/lib';
import {
  Connection,
  PublicKey,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Signer,
} from '@solana/web3.js';

export default async function transfer(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {address, secret, recipient, lamports, network} = req.body;
    const url = getNodeURL(network);
    const connection = new Connection(url, 'confirmed');

    const fromPubkey = new PublicKey(address);
    const toPubkey = new PublicKey(recipient);
    // The secret key is stored in our state as a stringified array
    const secretKey = Uint8Array.from(JSON.parse(secret as string));

    //... let's skip the beginning as it should be familiar for you by now!
    // Find the parameter to pass
    const instructions = SystemProgram.transfer({
      fromPubkey,
      toPubkey,
      lamports,
    });

    // How could you construct a signer array's
    const signers: Array<Signer> = [
      {
        publicKey: fromPubkey,
        secretKey,
      },
    ];

    // Maybe adding something to a Transaction could be interesting ?
    const transaction = new Transaction().add(instructions);

    // We can send and confirm a transaction in one row.
    const hash = await sendAndConfirmTransaction(
      connection,
      transaction,
      signers,
    );

    res.status(200).json(hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/tezos/account.ts ---
/* eslint-disable no-unreachable */
import type {NextApiRequest, NextApiResponse} from 'next';
import {TezosToolkit} from '@taquito/taquito';
import {importKey} from '@taquito/signer';
import {getNodeUrl} from '@figment-tezos/lib';

export default async function account(
  req: NextApiRequest,
  res: NextApiResponse<boolean | string>,
) {
  try {
    const {
      mnemonic: mnemonic0,
      email,
      password,
      activation_code: secret,
      network,
    } = req.body;
    const mnemonic = mnemonic0.join(' ');

    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    // call the importKey method
    undefined;
    throw new Error('Please complete the code');

    res.status(200).json(true);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/tezos/balance.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {TezosToolkit} from '@taquito/taquito';
import {getNodeUrl} from '@figment-tezos/lib';

export default async function balance(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {address, network} = req.body;
    const url = getNodeUrl(network);
    const toolkit = new TezosToolkit(url);
    const balance = undefined;
    res.status(200).json(balance.toString());
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/tezos/connect.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {TezosToolkit} from '@taquito/taquito';
import {validateChain} from '@taquito/utils';
import {getNodeUrl} from '@figment-tezos/lib';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string | boolean>,
) {
  try {
    const {network} = req.body;
    const url = getNodeUrl(network);
    const toolkit = undefined;
    const chainId = undefined;
    if (validateChain(chainId) != 3) {
      throw Error('invalid chain Id');
    }
    res.status(200).json(chainId);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/tezos/deploy.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {TezosToolkit} from '@taquito/taquito';
import {getNodeUrl} from '@figment-tezos/lib';
import {importKey} from '@taquito/signer';
import {CONTRACT_JSON} from 'contracts/tezos/counter.js';

type ResponseT = {
  contractAddress: string;
  hash: string;
};
export default async function deploy(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>,
) {
  try {
    const {mnemonic, email, password, secret, network} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    const operation = await undefined;

    const contract = await undefined;

    res.status(200).json({
      contractAddress: contract.address,
      hash: operation.hash
    });
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/tezos/getter.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {TezosToolkit} from '@taquito/taquito';
import {getNodeUrl} from '@figment-tezos/lib';
import {importKey} from '@taquito/signer';

export default async function getter(
  req: NextApiRequest,
  res: NextApiResponse<unknown | string>,
) {
  try {
    const {network, mnemonic, email, password, secret, contract} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(tezos, email, password, mnemonic, secret);

    // use the contract module to get the storage
    const counter = undefined;

    res.status(200).json(counter);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/tezos/setter.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {TezosToolkit} from '@taquito/taquito';
import {getNodeUrl} from '@figment-tezos/lib';
import {importKey} from '@taquito/signer';

export default async function setter(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {network, mnemonic, email, password, secret, contract} = req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);
    await importKey(tezos, email, password, mnemonic, secret);

    const n = 1;
    // load the interface of the contract
    const counterContract = undefined;
    // call the increment function of the contract
    const transaction = await counterContract.methods.increment(n).send();

    // await for confirmation
    await transaction.confirmation(3);

    res.status(200).json(transaction.hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/tezos/transfer.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import {TezosToolkit} from '@taquito/taquito';
import {getNodeUrl} from '@figment-tezos/lib';
import {importKey} from '@taquito/signer';

export default async function transfer(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  try {
    const {network, mnemonic, email, password, secret, amount, recipient} =
      req.body;
    const url = getNodeUrl(network);
    const tezos = new TezosToolkit(url);

    await importKey(undefined);

    // call the transfer method

    // await for confirmation
    await operation.confirmation(1);

    res.status(200).json(operation.hash);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/the-graph-near/entity.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import fs from 'fs';
import {defaultEntityStatus} from '@figment-the-graph-near/lib';
import {EntityStepStatusesT} from '@figment-the-graph-near/types';

const GENERATED_PATH = './subgraphs/near-subgraph/generated/schema.ts';

export default async function entity(
  _req: NextApiRequest,
  res: NextApiResponse<EntityStepStatusesT | {message: string}>,
) {
  try {
    let status = defaultEntityStatus;

    let generatedSchema = fs.readFileSync(GENERATED_PATH, 'utf8');
    // better to use a regex, need some regex expert here!
    // to make the code more robust, but it's working as is.
    let entities = generatedSchema
      .split(/\r?\n/)
      .filter((line) => {
        return line.trim().slice(0, 6) === 'export';
      })
      .map((words) => words.split(' ')[2])
      .sort();

    if (entities.length === 2) {
      status = {
        ...status,
        entities: {
          isValid: true,
          message: 'Two entities defined',
        },
      };
    }

    if (entities.includes('Account')) {
      status = {
        ...status,
        account: {
          isValid: true,
          message: 'Account entity defined',
        },
      };
    }

    if (entities.includes('Log')) {
      status = {
        ...status,
        log: {
          isValid: true,
          message: 'Log entity defined',
        },
      };
    }

    res.status(200).json(status);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json({
      message: errorMessage,
    });
  }
}

'''
'''--- pages/api/the-graph-near/manifest.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import type {ManifestStepStatusesT} from '@figment-the-graph-near/types';
import {manifestT} from '@figment-the-graph-near/types';
import yaml from 'js-yaml';
import fs from 'fs';
import {defaultManifestStatus} from '@figment-the-graph-near/lib';

const START_BLOCK = 54395933;
const MANIFEST_PATH = './subgraphs/near-subgraph/subgraph.yaml';
const HANDLER = 'handleReceipt';

const loadManifest = () => {
  let manifest = fs.readFileSync(MANIFEST_PATH, 'utf8');
  let data = yaml.load(manifest) as manifestT;

  let startBlock = data.dataSources[0].source.startBlock;
  let entities = data.dataSources[0].mapping.entities;
  let receiptHandlers = data.dataSources[0].mapping.receiptHandlers;
  return {
    startBlock,
    entities,
    receiptHandlers,
  };
};
export default async function manifest(
  _req: NextApiRequest,
  res: NextApiResponse<ManifestStepStatusesT | string>,
) {
  try {
    let status = defaultManifestStatus;
    const {startBlock, entities, receiptHandlers} = loadManifest();

    if (startBlock === START_BLOCK) {
      status = {
        ...status,
        block: {
          isValid: true,
          message: 'startBlock is 54395933',
        },
      };
    }

    if (
      entities.includes('Account') &&
      entities.includes('Log') &&
      entities.length == 2
    ) {
      status = {
        ...status,
        entities: {
          isValid: true,
          message: 'Account and Log entities',
        },
      };
    }

    if (
      receiptHandlers.length === 1 &&
      receiptHandlers[0]['handler'] === HANDLER
    ) {
      status = {
        ...status,
        receiptHandlers: {
          isValid: true,
          message: 'Receipt handler with receiptHandler',
        },
      };
    }

    res.status(200).json(status);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/the-graph-near/scaffold.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import fs from 'fs';

export default async function scaffold(
  _req: NextApiRequest,
  res: NextApiResponse<boolean | string>,
) {
  try {
    fs.readFileSync('./subgraphs/near-subgraph/subgraph.yaml', 'utf8');
    res.status(200).json(true);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/the-graph/entity.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import fs from 'fs';
import {defaultEntityStatus} from '@figment-the-graph/lib';
import {EntityStepStatusesT} from '@figment-the-graph/types';

const GENERATED_PATH = './subgraphs/punks/generated/schema.ts';

export default async function entity(
  _req: NextApiRequest,
  res: NextApiResponse<EntityStepStatusesT | {message: string}>,
) {
  try {
    let status = defaultEntityStatus;

    let generatedSchema = fs.readFileSync(GENERATED_PATH, 'utf8');
    // better to use a regex, need some regex expert here!
    // to make the code more robust, but it's working as is.
    let entities = generatedSchema
      .split(/\r?\n/)
      .filter((line) => {
        return line.trim().slice(0, 6) === 'export';
      })
      .map((words) => words.split(' ')[2])
      .sort();

    if (entities.length === 2) {
      status = {
        ...status,
        entities: {
          isValid: true,
          message: 'Two entities defined',
        },
      };
    }

    if (entities.includes('Account')) {
      status = {
        ...status,
        account: {
          isValid: true,
          message: 'Account entity defined',
        },
      };
    }

    if (entities.includes('Punk')) {
      status = {
        ...status,
        punk: {
          isValid: true,
          message: 'Punk entity defined',
        },
      };
    }

    res.status(200).json(status);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json({
      message: errorMessage,
    });
  }
}

'''
'''--- pages/api/the-graph/manifest.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import type {ManifestStepStatusesT} from '@figment-the-graph/types';
import {manifestT} from '@figment-the-graph/types';
import yaml from 'js-yaml';
import fs from 'fs';
import {defaultManifestStatus} from '@figment-the-graph/lib';

const START_BLOCK = 13100000;
const MANIFEST_PATH = './subgraphs/punks/subgraph.yaml';
const EVENT =
  'PunkBought(indexed uint256,uint256,indexed address,indexed address)';
const HANDLER = 'handlePunkBought';

const loadManifest = () => {
  let manifest = fs.readFileSync(MANIFEST_PATH, 'utf8');
  let data = yaml.load(manifest) as manifestT;

  let startBlock = data.dataSources[0].source.startBlock;
  let entities = data.dataSources[0].mapping.entities;
  let eventHandlers = data.dataSources[0].mapping.eventHandlers;
  return {
    startBlock,
    entities,
    eventHandlers,
  };
};
export default async function manifest(
  _req: NextApiRequest,
  res: NextApiResponse<ManifestStepStatusesT | string>,
) {
  try {
    let status = defaultManifestStatus;
    const {startBlock, entities, eventHandlers} = loadManifest();

    if (startBlock === START_BLOCK) {
      status = {
        ...status,
        block: {
          isValid: true,
          message: 'startBlock is 13100000',
        },
      };
    }

    if (
      entities.includes('Punk') &&
      entities.includes('Account') &&
      entities.length == 2
    ) {
      status = {
        ...status,
        entities: {
          isValid: true,
          message: 'Punk and Account entities',
        },
      };
    }

    if (
      eventHandlers.length === 1 &&
      eventHandlers[0]['event'] === EVENT &&
      eventHandlers[0]['handler'] === HANDLER
    ) {
      status = {
        ...status,
        eventHandlers: {
          isValid: true,
          message: 'PunkBought event with handlePunkBought handler',
        },
      };
    }

    res.status(200).json(status);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/the-graph/mapping.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';

const GRAPHQL_URL = process.env.NEXT_PUBLIC_LOCAL_SUBGRAPH as string;

const TEST_QUERY = `
  query {
    punks {
      id
    }
  }
`;

export default async function node(
  _req: NextApiRequest,
  res: NextApiResponse<boolean | string>,
) {
  try {
    const response = await fetch(GRAPHQL_URL, {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: TEST_QUERY,
      }),
    });

    const {errors} = await response.json();
    if (errors) {
      throw new Error('GRAPHQL error: Cannot find the subgraph');
    }
    res.status(200).json(true);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/the-graph/node.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import axios from 'axios';

export default async function node(
  _req: NextApiRequest,
  res: NextApiResponse<boolean | string>,
) {
  try {
    await axios.post(`http://127.0.0.1:8020`, {});
    res.status(200).json(true);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- pages/api/the-graph/scaffold.ts ---
import type {NextApiRequest, NextApiResponse} from 'next';
import fs from 'fs';

export default async function scallfold(
  _req: NextApiRequest,
  res: NextApiResponse<boolean | string>,
) {
  try {
    fs.readFileSync('./subgraphs/punks/subgraph.yaml', 'utf8');
    res.status(200).json(true);
  } catch (error) {
    let errorMessage = error instanceof Error ? error.message : 'Unknown Error';
    res.status(500).json(errorMessage);
  }
}

'''
'''--- public/discord.svg ---
<svg width="292" height="80" viewBox="0 0 292 80" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0)">
<g clip-path="url(#clip1)">
<path d="M61.7958 16.494C57.0736 14.2846 52.0244 12.6789 46.7456 11.7646C46.0973 12.9367 45.3399 14.5132 44.8177 15.7673C39.2062 14.9234 33.6463 14.9234 28.138 15.7673C27.6159 14.5132 26.8413 12.9367 26.1872 11.7646C20.9027 12.6789 15.8477 14.2905 11.1255 16.5057C1.60078 30.8988 -0.981215 44.9344 0.309785 58.7707C6.62708 63.4883 12.7493 66.3541 18.7682 68.2294C20.2543 66.1841 21.5797 64.0099 22.7215 61.7185C20.5469 60.8922 18.4641 59.8725 16.4961 58.6887C17.0182 58.3019 17.5289 57.8975 18.0223 57.4814C30.0257 63.0957 43.0677 63.0957 54.9277 57.4814C55.4269 57.8975 55.9375 58.3019 56.4539 58.6887C54.4801 59.8783 52.3916 60.898 50.217 61.7244C51.3588 64.0099 52.6785 66.19 54.1703 68.2352C60.195 66.3599 66.3229 63.4942 72.6402 58.7707C74.155 42.7309 70.0525 28.8242 61.7958 16.494ZM24.3568 50.2615C20.7535 50.2615 17.7985 46.8976 17.7985 42.8012C17.7985 38.7048 20.6904 35.3351 24.3568 35.3351C28.0233 35.3351 30.9782 38.6989 30.9151 42.8012C30.9208 46.8976 28.0233 50.2615 24.3568 50.2615ZM48.5932 50.2615C44.9899 50.2615 42.0349 46.8976 42.0349 42.8012C42.0349 38.7048 44.9267 35.3351 48.5932 35.3351C52.2596 35.3351 55.2146 38.6989 55.1515 42.8012C55.1515 46.8976 52.2596 50.2615 48.5932 50.2615Z" fill="#5865F2"/>
<path d="M98.0293 26.1707H113.693C117.469 26.1707 120.659 26.7743 123.276 27.9757C125.886 29.177 127.843 30.8531 129.14 32.998C130.436 35.1429 131.09 37.5984 131.09 40.3645C131.09 43.072 130.413 45.5275 129.059 47.7251C127.705 49.9286 125.645 51.6692 122.874 52.9526C120.103 54.236 116.671 54.8806 112.569 54.8806H98.0293V26.1707ZM112.408 47.5845C114.95 47.5845 116.907 46.934 118.272 45.6388C119.638 44.3378 120.321 42.568 120.321 40.3235C120.321 38.243 119.712 36.5845 118.496 35.3421C117.28 34.0997 115.438 33.4727 112.976 33.4727H108.076V47.5845H112.408Z" fill="#5865F2"/>
<path d="M154.541 54.8456C152.372 54.2713 150.415 53.4391 148.677 52.3432V45.5335C149.991 46.5707 151.752 47.4264 153.961 48.1003C156.17 48.7684 158.305 49.1024 160.37 49.1024C161.334 49.1024 162.063 48.9735 162.556 48.7156C163.05 48.4578 163.297 48.1472 163.297 47.7897C163.297 47.3795 163.165 47.0396 162.895 46.7641C162.625 46.4887 162.103 46.2601 161.329 46.0667L156.509 44.9591C153.749 44.3028 151.792 43.3944 150.628 42.2282C149.463 41.0678 148.883 39.5441 148.883 37.6571C148.883 36.0689 149.388 34.6918 150.41 33.5138C151.425 32.3359 152.871 31.4275 154.747 30.7887C156.624 30.1441 158.815 29.8218 161.334 29.8218C163.583 29.8218 165.643 30.0679 167.52 30.5602C169.396 31.0525 170.945 31.6795 172.179 32.4472V38.8878C170.916 38.1201 169.47 37.5165 167.818 37.0593C166.171 36.6081 164.479 36.3854 162.734 36.3854C160.215 36.3854 158.959 36.8249 158.959 37.6981C158.959 38.1084 159.154 38.4131 159.544 38.6182C159.934 38.8233 160.651 39.0343 161.69 39.257L165.706 39.9954C168.329 40.4584 170.285 41.273 171.57 42.4333C172.856 43.5937 173.498 45.3108 173.498 47.5846C173.498 50.0752 172.437 52.0502 170.308 53.5153C168.179 54.9804 165.161 55.7129 161.248 55.7129C158.947 55.7071 156.71 55.4199 154.541 54.8456Z" fill="#5865F2"/>
<path d="M182.978 53.9839C180.678 52.8352 178.939 51.2764 177.78 49.3073C176.621 47.3382 176.036 45.123 176.036 42.6616C176.036 40.2003 176.638 37.9968 177.843 36.057C179.048 34.1172 180.815 32.5935 183.145 31.4859C185.474 30.3783 188.257 29.8274 191.499 29.8274C195.515 29.8274 198.849 30.6889 201.5 32.4118V39.919C200.565 39.2626 199.474 38.7293 198.229 38.3191C196.984 37.9089 195.653 37.7037 194.23 37.7037C191.74 37.7037 189.795 38.1667 188.389 39.0985C186.983 40.0303 186.278 41.2434 186.278 42.7495C186.278 44.2263 186.96 45.4336 188.326 46.383C189.692 47.3265 191.671 47.8012 194.27 47.8012C195.607 47.8012 196.927 47.6019 198.229 47.2093C199.526 46.8108 200.645 46.3244 201.58 45.75V53.011C198.637 54.816 195.223 55.7185 191.338 55.7185C188.068 55.7068 185.279 55.1325 182.978 53.9839Z" fill="#5865F2"/>
<path d="M211.518 53.9841C209.2 52.8355 207.433 51.2649 206.216 49.2665C205 47.2681 204.386 45.0412 204.386 42.5798C204.386 40.1185 204.994 37.9208 206.216 35.9928C207.438 34.0647 209.194 32.5527 211.501 31.4568C213.801 30.3609 216.55 29.8159 219.734 29.8159C222.919 29.8159 225.667 30.3609 227.968 31.4568C230.269 32.5527 232.025 34.053 233.23 35.9693C234.435 37.8857 235.037 40.0833 235.037 42.574C235.037 45.0353 234.435 47.2623 233.23 49.2606C232.025 51.259 230.263 52.8296 227.945 53.9782C225.627 55.1269 222.89 55.7012 219.729 55.7012C216.567 55.7012 213.83 55.1327 211.518 53.9841ZM223.722 46.7055C224.698 45.7093 225.191 44.3907 225.191 42.7498C225.191 41.1089 224.703 39.802 223.722 38.835C222.747 37.8622 221.415 37.3758 219.729 37.3758C218.013 37.3758 216.67 37.8622 215.689 38.835C214.714 39.8079 214.226 41.1089 214.226 42.7498C214.226 44.3907 214.714 45.7093 215.689 46.7055C216.665 47.7018 218.013 48.2058 219.729 48.2058C221.415 48.1999 222.747 47.7018 223.722 46.7055Z" fill="#5865F2"/>
<path d="M259.17 31.3395V40.2004C258.149 39.5147 256.829 39.1748 255.194 39.1748C253.053 39.1748 251.401 39.8371 250.253 41.1615C249.1 42.486 248.526 44.5488 248.526 47.3383V54.8865H238.686V30.8883H248.326V38.5185C248.859 35.7289 249.726 33.672 250.919 32.3416C252.107 31.0172 253.644 30.355 255.515 30.355C256.932 30.355 258.149 30.6832 259.17 31.3395Z" fill="#5865F2"/>
<path d="M291.864 25.3503V54.8866H282.023V49.5127C281.191 51.5345 279.929 53.0758 278.231 54.1306C276.532 55.1797 274.432 55.7071 271.942 55.7071C269.716 55.7071 267.777 55.1562 266.118 54.0486C264.46 52.941 263.181 51.4232 262.28 49.4951C261.385 47.567 260.931 45.387 260.931 42.9491C260.903 40.435 261.379 38.1787 262.36 36.1803C263.336 34.1819 264.718 32.6231 266.497 31.5037C268.276 30.3844 270.307 29.8218 272.585 29.8218C277.273 29.8218 280.417 31.9022 282.023 36.0572V25.3503H291.864ZM280.555 46.5415C281.559 45.5452 282.058 44.2501 282.058 42.6678C282.058 41.1382 281.57 39.8899 280.595 38.9347C279.619 37.9795 278.282 37.4989 276.601 37.4989C274.943 37.4989 273.618 37.9853 272.625 38.9581C271.632 39.931 271.139 41.1909 271.139 42.7498C271.139 44.3087 271.632 45.5804 272.625 46.5649C273.618 47.5494 274.926 48.0417 276.561 48.0417C278.219 48.0359 279.55 47.5377 280.555 46.5415Z" fill="#5865F2"/>
<path d="M139.382 33.4432C142.091 33.4432 144.288 31.4281 144.288 28.9424C144.288 26.4567 142.091 24.4417 139.382 24.4417C136.672 24.4417 134.476 26.4567 134.476 28.9424C134.476 31.4281 136.672 33.4432 139.382 33.4432Z" fill="#5865F2"/>
<path d="M134.472 36.5435C137.478 37.8679 141.208 37.9265 144.283 36.5435V55.0154H134.472V36.5435Z" fill="#5865F2"/>
</g>
</g>
<defs>
<clipPath id="clip0">
<rect width="292" height="56.4706" fill="white" transform="translate(0 11.7646)"/>
</clipPath>
<clipPath id="clip1">
<rect width="292" height="56.4706" fill="white" transform="translate(0 11.7646)"/>
</clipPath>
</defs>
</svg>

'''
'''--- public/figment-learn-compact.svg ---
<svg width="176" height="50" viewBox="0 0 176 50" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M175.276 0H50V50H175.276V0Z" fill="#111111"/>
<path d="M78.91 34.42V14.01H82.62V30.91H92.09V34.42H78.91Z" fill="#FFF29B"/>
<path d="M106.84 27.05C106.82 27.18 106.81 27.31 106.81 27.42V28.05H96.79C96.79 28.63 96.88 29.17 97.06 29.69C97.24 30.21 97.52 30.64 97.88 30.99C98.15 31.24 98.46 31.46 98.82 31.64C99.17 31.82 99.6 31.91 100.1 31.91C100.62 31.91 101.05 31.86 101.38 31.75C101.72 31.64 102.02 31.46 102.29 31.19C102.64 30.85 102.88 30.42 103.01 29.92H106.46C106.42 30.36 106.27 30.85 106.01 31.37C105.75 31.9 105.48 32.33 105.19 32.68C104.56 33.43 103.8 33.97 102.92 34.29C102.04 34.61 101.12 34.78 100.16 34.78C99.12 34.78 98.23 34.61 97.47 34.28C96.71 33.95 96.03 33.5 95.44 32.94C94.69 32.21 94.12 31.34 93.73 30.32C93.34 29.3 93.14 28.18 93.14 26.95C93.14 25.74 93.32 24.62 93.67 23.6C94.02 22.57 94.57 21.7 95.3 20.97C95.86 20.39 96.53 19.93 97.33 19.59C98.13 19.24 99.04 19.07 100.08 19.07C101.19 19.07 102.23 19.3 103.19 19.75C104.15 20.2 104.94 20.9 105.55 21.84C106.11 22.67 106.46 23.51 106.61 24.36C106.76 25.21 106.84 26.11 106.84 27.05ZM103.24 25.44C103.22 24.35 102.91 23.47 102.32 22.82C102.07 22.55 101.76 22.34 101.38 22.19C101.01 22.04 100.56 21.96 100.04 21.96C99.48 21.96 98.99 22.07 98.57 22.28C98.15 22.49 97.8 22.77 97.53 23.11C97.26 23.44 97.07 23.78 96.95 24.15C96.83 24.52 96.77 24.95 96.75 25.44H103.24Z" fill="#FFF29B"/>
<path d="M123.25 34.25C122.94 34.38 122.68 34.49 122.46 34.55C122.24 34.62 121.91 34.65 121.47 34.65C120.68 34.65 120.08 34.44 119.66 34.02C119.24 33.6 119 33.11 118.94 32.55C118.59 33.16 118.02 33.69 117.21 34.13C116.4 34.57 115.46 34.79 114.39 34.79C113.49 34.79 112.7 34.66 112.03 34.4C111.36 34.14 110.8 33.8 110.35 33.36C109.9 32.93 109.56 32.43 109.33 31.86C109.1 31.29 108.98 30.7 108.98 30.09C108.98 29.38 109.11 28.75 109.37 28.19C109.63 27.63 109.99 27.15 110.45 26.75C110.91 26.35 111.45 26.04 112.06 25.81C112.67 25.59 113.34 25.45 114.05 25.39L118.45 25.07V24.15C118.45 23.44 118.28 22.87 117.95 22.44C117.62 22.01 116.94 21.79 115.92 21.79C115.08 21.79 114.42 21.97 113.95 22.34C113.48 22.71 113.23 23.23 113.19 23.92H109.71C109.77 23.08 109.96 22.35 110.3 21.73C110.64 21.12 111.08 20.61 111.64 20.22C112.2 19.83 112.84 19.53 113.57 19.34C114.3 19.15 115.09 19.05 115.93 19.05C117.22 19.05 118.36 19.28 119.37 19.73C120.38 20.18 121.1 20.97 121.54 22.11C121.73 22.59 121.85 23.09 121.9 23.61C121.95 24.13 121.97 24.64 121.97 25.14V30.7C121.97 31.05 122.03 31.29 122.16 31.43C122.28 31.57 122.5 31.65 122.81 31.65C122.96 31.65 123.07 31.64 123.13 31.62C123.19 31.62 123.24 31.61 123.27 31.59V34.25H123.25ZM118.44 27.77L114.64 28.06C114.08 28.1 113.58 28.28 113.14 28.61C112.7 28.94 112.48 29.41 112.48 30.02C112.48 30.6 112.7 31.05 113.13 31.39C113.56 31.73 114.06 31.89 114.61 31.89C115.74 31.89 116.66 31.6 117.37 31.01C118.08 30.42 118.43 29.58 118.43 28.46V27.77H118.44Z" fill="#FFF29B"/>
<path d="M135.11 22.79C134.67 22.69 134.26 22.65 133.87 22.65C132.6 22.65 131.64 23.05 130.99 23.86C130.34 24.67 130.01 25.67 130.01 26.88V34.42H126.38V19.45H129.43L129.75 21.7C130.1 20.84 130.67 20.21 131.46 19.83C132.25 19.45 133.1 19.25 133.98 19.25C134.34 19.25 134.72 19.28 135.1 19.34V22.79H135.11Z" fill="#FFF29B"/>
<path d="M147.05 34.42V25.24C147.05 24.36 146.88 23.67 146.53 23.17C146.18 22.67 145.53 22.42 144.57 22.42C143.94 22.42 143.41 22.6 142.99 22.95C142.57 23.31 142.23 23.76 141.98 24.32C141.73 24.88 141.59 25.52 141.55 26.26C141.51 27 141.49 27.68 141.49 28.32V34.42H137.89V19.45H140.91L141.17 21.38C141.61 20.59 142.24 20.01 143.06 19.64C143.88 19.27 144.72 19.08 145.58 19.08C146.39 19.08 147.1 19.21 147.72 19.48C148.34 19.75 148.87 20.12 149.3 20.59C149.73 21.06 150.06 21.63 150.29 22.29C150.52 22.95 150.64 23.67 150.64 24.44V34.43H147.05V34.42Z" fill="#FFF29B"/>
<path d="M50 0H0V50H50V0Z" fill="#FFF29B"/>
<path d="M21.2781 18.0678V24.057H33.0959V27.7889H21.2781V37.7307H17.0847V14.2657H33.748V18.0578H21.2781V18.0678Z" fill="#111111"/>
</svg>

'''
'''--- public/vercel.svg ---
<svg width="283" height="64" viewBox="0 0 283 64" fill="none" 
    xmlns="http://www.w3.org/2000/svg">
    <path d="M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z" fill="#000"/>
</svg>
'''
'''--- theme/colors.ts ---
export const colors = {
  primary: '#0070f3',
};

'''
'''--- theme/index.ts ---
import {colors} from './colors';
import media, {ThemeMedia, ThemeSizes, sizes} from './media';

export type Theme = {
  colors: any;
  media: ThemeMedia;
  sizes: ThemeSizes;
};

const theme: Theme = {
  colors,
  media,
  sizes,
};

export default theme;

'''
'''--- theme/media.ts ---
import {css} from 'styled-components';

export type ThemeSizes = {
  xxl: number;
  xl: number;
  lg: number;
  md: number;
  sm: number;
  xs: number;
};

export type ThemeMedia = {
  xxl?: string;
  xl?: string;
  lg?: string;
  md?: string;
  sm?: string;
  xs?: string;
};

export const sizes: ThemeSizes = {
  xxl: 1600,
  xl: 1200,
  lg: 992,
  md: 768,
  sm: 576,
  xs: 0,
};

const media: ThemeMedia = Object.keys(sizes).reduce((acc, label) => {
  acc[label] = (...args) => css`
    @media (min-width: ${sizes[label]}px) {
      ${css(...args)};
    }
  `;
  return acc;
}, {});

export default media;

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es6",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "useUnknownInCatchVariables": false,
    "jsx": "preserve",
    "baseUrl": ".",
    "paths": {
      "@figment-avalanche/*": ["components/protocols/avalanche/*"],
      "@figment-celo/*": ["components/protocols/celo/*"],
      "@figment-ceramic/*": ["components/protocols/ceramic/*"],
      "@figment-near/*": ["components/protocols/near/*"],
      "@figment-polkadot/*": ["components/protocols/polkadot/*"],
      "@figment-polygon/*": ["components/protocols/polygon/*"],
      "@figment-pyth/*": ["components/protocols/pyth/*"],
      "@figment-secret/*": ["components/protocols/secret/*"],
      "@figment-solana/*": ["components/protocols/solana/*"],
      "@figment-tezos/*": ["components/protocols/tezos/*"],
      "@figment-the-graph/*": ["components/protocols/the_graph/*"],
      "@figment-the-graph-near/*": ["components/protocols/the_graph_near/*"]
    },
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", "jest.config.js"],
  "exclude": ["node_modules"]
}

'''
'''--- types/index.ts ---
import type {Dispatch, SetStateAction} from 'react';
import {BlockWithTransactions} from '@ethersproject/abstract-provider';

export enum CHAINS {
  ARWEAVE = 'arweave',
  AVALANCHE = 'avalanche',
  CELO = 'celo',
  CERAMIC = 'ceramic',
  NEAR = 'near',
  POLYGON = 'polygon',
  POLKADOT = 'polkadot',
  PYTH = 'pyth',
  SECRET = 'secret',
  SOLANA = 'solana',
  TEZOS = 'tezos',
  THE_GRAPH = 'the_graph',
  THE_GRAPH_NEAR = 'the_graph_near',
}

// Protocols Enum -----------------------
export type PROTOCOLS =
  | ARWEAVE_PROTOCOLS
  | AVALANCHE_PROTOCOLS
  | CELO_PROTOCOLS
  | CERAMIC_PROTOCOLS
  | NEAR_PROTOCOLS
  | POLKADOT_PROTOCOLS
  | POLYGON_PROTOCOLS
  | PYTH_PROTOCOLS
  | SECRET_PROTOCOLS
  | SOLANA_PROTOCOLS
  | TEZOS_PROTOCOLS
  | THE_GRAPH_PROTOCOLS
  | THE_GRAPH_NEAR_PROTOCOLS
  | ARWEAVE_PROTOCOLS;

export enum THE_GRAPH_NEAR_PROTOCOLS {
  GRAPHQL = 'GRAPHQL',
}

export enum THE_GRAPH_PROTOCOLS {
  GRAPHQL = 'GRAPHQL',
}

export enum AVALANCHE_PROTOCOLS {
  RPC = 'RPC',
}

export enum CELO_PROTOCOLS {
  RPC = 'RPC',
}

export enum SECRET_PROTOCOLS {
  RPC = 'RPC',
  LCD = 'LCD',
}

export enum NEAR_PROTOCOLS {
  RPC = 'RPC',
}

export enum TEZOS_PROTOCOLS {
  RPC = 'RPC',
}

export enum POLYGON_PROTOCOLS {
  RPC = 'RPC',
  JSON_RPC = 'JSON_RPC',
  WS = 'WS',
}

export enum POLKADOT_PROTOCOLS {
  RPC = 'RPC',
  WS = 'WS',
}

export enum PYTH_PROTOCOLS {
  RPC = 'RPC',
  WS = 'WS',
}

export enum SOLANA_PROTOCOLS {
  RPC = 'RPC',
  WS = 'WS',
}

export enum ARWEAVE_PROTOCOLS {
  RPC = 'RPC',
}

// BlockChain Providers -----------------------
export enum CHAIN_PROVIDERS {
  DATAHUB = 'DATAHUB',
  ALCHEMY = 'ALCHEMY',
  INFURA = 'INFURA',
  PUBLIC = 'PUBLIC',
  LOCAL = 'LOCAL',
}

// NETWORKS -----------------------
export enum AVALANCHE_NETWORKS {
  TESTNET = 'Testnet',
  DATAHUB = 'Datahub',
}

export enum CELO_NETWORKS {
  TESTNET = 'Alfajores',
  DATAHUB = 'Datahub',
}

export enum SECRET_NETWORKS {
  MAINNET = 'MAINNET',
  TESTNET = 'SUPERNOVA-2',
  DATAHUB = 'datahub',
}

export enum NEAR_NETWORKS {
  TESTNET = 'Testnet',
  DATAHUB = 'Datahub',
}

export enum TEZOS_NETWORKS {
  TESTNET = 'Hangzhounet',
  DATAHUB = 'Datahub',
}

export enum POLKADOT_NETWORKS {
  TESTNET = 'Westend',
  DATAHUB = 'Datahub',
}

export enum POLYGON_NETWORKS {
  TESTNET = 'Mumbai',
  DATAHUB = 'Datahub',
}

export enum PYTH_NETWORKS {
  MAINNET = 'mainnet-beta',
  TESTNET = 'testnet',
  DEVNET = 'devnet',
  LOCALNET = 'localnet',
}

export enum SOLANA_NETWORKS {
  MAINNET = 'mainnet-beta',
  DEVNET = 'devnet',
  DATAHUB = 'datahub',
  LOCALNET = 'localnet',
}

export enum CERAMIC_NETWORKS {
  TESTNET = 'TESTNET',
}

export enum CERAMIC_PROTOCOLS {
  HTTP = 'HTTP',
}

export enum THE_GRAPH_NETWORKS {
  LOCALNET = 'localnet',
  STUDIO = 'studio',
}

export enum THE_GRAPH_NEAR_NETWORKS {
  HOSTED = 'hosted',
}

export enum ARWEAVE_NETWORKS {
  MAINNET = 'mainnet',
  TESTNET = 'TESTNET',
  DATAHUB = 'datahub',
}

// -----------------------------
export type NETWORKS =
  | ARWEAVE_NETWORKS
  | AVALANCHE_NETWORKS
  | CELO_NETWORKS
  | TEZOS_NETWORKS
  | THE_GRAPH_NETWORKS
  | THE_GRAPH_NEAR_NETWORKS
  | CERAMIC_NETWORKS
  | NEAR_NETWORKS
  | POLKADOT_NETWORKS
  | POLYGON_NETWORKS
  | PYTH_NETWORKS
  | SECRET_NETWORKS
  | SOLANA_NETWORKS
  | TEZOS_NETWORKS
  | THE_GRAPH_NETWORKS;

// -----------------------------
export enum NETWORK {
  DATAHUB,
  TESTNET,
  LOCALNET,
  MAINNET,
  DEVNET,
}

// -----------------------------
export type ChainType = {
  id: CHAINS;
  label: string;
  active: boolean;
  logoUrl: string;
  steps: StepType[];
  protocol: PROTOCOLS;
  network: NETWORKS;
};

export type ChainsType = {
  [key in CHAINS]: ChainType;
};

export type ChainPropT = {
  chain: ChainType;
  markdown: MarkdownForChainIdT;
};

export type StepType = {
  id: PROTOCOL_STEPS_ID;
  title: string;
  skippable?: boolean;
  isOneColumn?: boolean;
};

export enum UserActivity {
  PROTOCOL_CLICKED = 'PROTOCOL_CLICKED',
  TUTORIAL_STEP_VIEWED = 'TUTORIAL_STEP_VIEWED',
  STORAGE_CLEARED = 'STORAGE_CLEARED',
}

export type MarkdownForChainIdT = {
  [key in PROTOCOL_STEPS_ID]: string;
};

// Global State -----------------------------
export type GlobalStateT = {
  currentChainId?: CHAINS;
  protocols: ProtocolsStateT;
};

export type ProtocolsStateT = {
  [Key in CHAINS]: ProtocolStateT;
};

export type ProtocolStateT = {
  id: CHAINS;
  label: string;
  logoUrl: string;
  network: NETWORKS;
  protocol: PROTOCOLS;
  isActive: boolean;
  numberOfSteps: number;
  currentStepId: PROTOCOL_STEPS_ID;
  firstStepId: PROTOCOL_STEPS_ID;
  lastStepId: PROTOCOL_STEPS_ID;
  steps: ProtocolStepsT;
  innerState?: InnerStateT;
};

export type ProtocolStepT = {
  id: PROTOCOL_STEPS_ID;
  title: string;
  isSkippable: boolean;
  isOneColumn: boolean;
  isCompleted: boolean;
  previousStepId: PROTOCOL_STEPS_ID | null;
  nextStepId: PROTOCOL_STEPS_ID | null;
  position: number;
};

export type ProtocolStepsT = {
  [Key in PROTOCOL_STEPS_ID]: ProtocolStepT;
};

export type InnerStateT = {
  [Key in PROTOCOL_INNER_STATES_ID]?: string | null;
};

export type LocalStorageStateT = {
  [Key in CHAINS]: LocalStorageProtocolStateT;
};

export type LocalStorageProtocolStateT = {
  currentStepId: PROTOCOL_STEPS_ID;
  steps: {
    [Key in PROTOCOL_STEPS_ID]: {
      isCompleted: boolean;
    };
  };
  innerState?: InnerStateT;
};

export enum PROTOCOL_INNER_STATES_ID {
  SECRET = 'SECRET',
  PRIVATE_KEY = 'PRIVATE_KEY',
  PUBLIC_KEY = 'PUBLIC_KEY',
  ADDRESS = 'ADDRESS',
  CONTRACT_ID = 'CONTRACT_ID',
  MNEMONIC = 'MNEMONIC',
  ACCOUNT_ID = 'ACCOUNT_ID',
  PASSWORD = 'PASSWORD',
  EMAIL = 'EMAIL',
  PROGRAM_ID = 'PROGRAM_ID',
  GREETER = 'GREETER',
  METAMASK_NETWORK_NAME = 'METAMASK_NETWORK_NAME',
  DID = 'DID',
  USER_NAME = 'USER_NAME',
}

export enum PROTOCOL_STEPS_ID {
  PREFACE = 'PREFACE',
  FINAL = 'FINAL',
  EXPORT_TOKEN = 'EXPORT_TOKEN',
  IMPORT_TOKEN = 'IMPORT_TOKEN',
  SWAP_TOKEN = 'SWAP_TOKEN',
  CREATE_KEYPAIR = 'CREATE_KEYPAIR',
  ESTIMATE_FEES = 'ESTIMATE_FEES',
  ESTIMATE_DEPOSIT = 'ESTIMATE_DEPOSIT',
  QUERY_CHAIN = 'QUERY_CHAIN',
  RESTORE_ACCOUNT = 'RESTORE_ACCOUNT',
  FUND_ACCOUNT = 'FUND_ACCOUNT',
  GET_BALANCE = 'GET_BALANCE',
  TRANSFER_TOKEN = 'TRANSFER_TOKEN',
  SOLANA_CREATE_GREETER = 'SOLANA_CREATE_GREETER',
  PROJECT_SETUP = 'PROJECT_SETUP',
  CHAIN_CONNECTION = 'CHAIN_CONNECTION',
  CREATE_ACCOUNT = 'CREATE_ACCOUNT',
  DEPLOY_CONTRACT = 'DEPLOY_CONTRACT',
  GET_CONTRACT_VALUE = 'GET_CONTRACT_VALUE',
  SET_CONTRACT_VALUE = 'SET_CONTRACT_VALUE',
  INTRO = 'INTRO',
  LOGIN = 'LOGIN',
  BASIC_PROFILE = 'BASIC_PROFILE',
  CUSTOM_DEFINITION = 'CUSTOM_DEFINITION',
  GRAPH_NODE = 'GRAPH_NODE',
  HOSTED_SERVICE = 'HOSTED_SERVICE',
  SUBGRAPH_SCAFFOLD = 'SUBGRAPH_SCAFFOLD',
  SUBGRAPH_MANIFEST = 'SUBGRAPH_MANIFEST',
  SUBGRAPH_QUERY = 'SUBGRAPH_QUERY',
  SUBGRAPH_SCHEMA = 'SUBGRAPH_SCHEMA',
  SUBGRAPH_MAPPINGS = 'SUBGRAPH_MAPPINGS',
  PYTH_CONNECT = 'PYTH_CONNECT',
  PYTH_EXCHANGE = 'PYTH_EXCHANGE',
  PYTH_SOLANA_WALLET = 'PYTH_SOLANA_WALLET',
  PYTH_VISUALIZE_DATA = 'PYTH_VISUALIZE_DATA',
  PYTH_LIQUIDATE = 'PYTH_LIQUIDATE',
}

export type AlertT = 'success' | 'info' | 'warning' | 'error' | undefined;

// Polygon type
export type QueryT = {
  networkName: string;
  chainId: number;
  blockHeight: number;
  gasPriceAsGwei: string;
  blockInfo: BlockWithTransactions;
};

// NEAR type
export type CheckAccountIdT = {
  network: string;
  freeAccountId: string;
  setFreeAccountId: Dispatch<SetStateAction<string>>;
  setIsFreeAccountId: Dispatch<SetStateAction<boolean>>;
};

'''
'''--- utils/colors.ts ---
import {CHAINS} from 'types';

export const colors = {
  figmentYellow: '#FFF29B',
  darkBackground: 'rgb(33, 37, 41)',
};

type ChainColorsType = {
  primaryColor: string;
  secondaryColor: string;
};

export const getChainColors = (chainId: CHAINS): ChainColorsType => {
  return {
    primaryColor: getPrimaryColor(chainId),
    secondaryColor: getSecondaryColor(chainId),
  };
};

const getPrimaryColor = (chainId: CHAINS) => {
  if (chainId === CHAINS.SOLANA) {
    return 'linear-gradient(253deg, #00FFA3, #DC1FFF)';
  } else if (chainId === CHAINS.AVALANCHE) {
    return '#e84141';
  } else if (chainId === CHAINS.THE_GRAPH) {
    return 'linear-gradient(130deg, #5943d0, #151324)';
  } else if (chainId === CHAINS.THE_GRAPH_NEAR) {
    return 'linear-gradient(130deg, #5943d0, #151324)';
  } else if (chainId === CHAINS.POLYGON) {
    return '#966ae0';
  } else if (chainId === CHAINS.POLKADOT) {
    return '#e6007a';
  } else if (chainId === CHAINS.PYTH) {
    return '#6633cc';
  } else if (chainId === CHAINS.TEZOS) {
    return '#0f62ff';
  } else if (chainId === CHAINS.CELO) {
    return 'linear-gradient(253deg, rgb(251, 204, 92), rgb(53,208,127))';
  } else if (chainId === CHAINS.NEAR) {
    return 'linear-gradient(253deg, #00c1de, #00c08b)';
  } else if (chainId === CHAINS.SECRET) {
    return 'black';
  } else if (chainId === CHAINS.CERAMIC) {
    return '#f87236';
  }
  return 'rgb(255, 242, 155)';
};

const getSecondaryColor = (chainId: CHAINS) => {
  if (chainId === CHAINS.SOLANA) {
    return 'black';
  } else if (chainId === CHAINS.AVALANCHE) {
    return '#F6F6F6';
  } else if (chainId === CHAINS.THE_GRAPH) {
    return '#F6F6F6';
  } else if (chainId === CHAINS.THE_GRAPH_NEAR) {
    return '#F6F6F6';
  } else if (chainId === CHAINS.POLYGON) {
    return '#F6F6F6';
  } else if (chainId === CHAINS.POLKADOT) {
    return '#F6F6F6';
  } else if (chainId === CHAINS.PYTH) {
    return '#F6F6F6';
  } else if (chainId === CHAINS.TEZOS) {
    return '#F6F6F6';
  } else if (chainId === CHAINS.SECRET) {
    return 'white';
  } else if (chainId === CHAINS.NEAR) {
    return 'white';
  } else if (chainId === CHAINS.CERAMIC) {
    return 'white';
  }
  return 'black';
};

'''
'''--- utils/context.ts ---
import {
  GlobalStateT,
  CHAINS,
  PROTOCOL_STEPS_ID,
  PROTOCOL_INNER_STATES_ID,
  NETWORKS,
  ProtocolStepsT,
  ProtocolStepT,
  LocalStorageStateT,
} from 'types';

export const prepareGlobalStateForStorage = (
  globalState: GlobalStateT,
): LocalStorageStateT => {
  const chains = Object.keys(globalState.protocols) as CHAINS[];

  return chains.reduce((acc: LocalStorageStateT, el: CHAINS) => {
    const stepsId = Object.keys(
      globalState.protocols[el].steps,
    ) as PROTOCOL_STEPS_ID[];
    const newSteps = stepsId.reduce((acc0, stepId) => {
      // @ts-ignore
      acc0[stepId] = {
        isCompleted: globalState.protocols[el].steps[stepId].isCompleted,
      };
      return acc0;
    }, {});
    acc[el] = {
      currentStepId: globalState.protocols[el].currentStepId,
      // @ts-ignore
      steps: newSteps,
      innerState: globalState.protocols[el].innerState,
    };
    return acc;
  }, {} as LocalStorageStateT);
};

export const prepareGlobalState = (
  localStorage: LocalStorageStateT,
  initialGlobalState: GlobalStateT,
  chainId: CHAINS,
): GlobalStateT => {
  const initialLocalStorageState =
    prepareGlobalStateForStorage(initialGlobalState);
  const chains = Object.keys(initialLocalStorageState) as CHAINS[];
  const newProtocols = chains.reduce(
    (protocols: GlobalStateT['protocols'], chain: CHAINS) => {
      const stepsId = Object.keys(
        protocols[chain].steps,
      ) as PROTOCOL_STEPS_ID[];
      const newSteps = stepsId.reduce((steps, stepId) => {
        let newStep;
        try {
          newStep = localStorage[chain]?.steps[stepId];
        } catch (error) {
          newStep = initialLocalStorageState[chain]?.steps[stepId];
        }
        steps[stepId] = {
          ...steps[stepId],
          ...newStep,
        };
        return steps;
      }, protocols[chain].steps);
      protocols[chain] = {
        ...initialGlobalState.protocols[chain],
        ...(localStorage
          ? localStorage[chain]
          : initialLocalStorageState[chain]),
        steps: newSteps,
      };
      return protocols;
    },
    initialGlobalState.protocols,
  );

  return {
    currentChainId: chainId,
    protocols: newProtocols,
  };
};

// Global State function, upmost level
export const getChainId = (state: GlobalStateT): CHAINS => {
  return state.currentChainId as CHAINS;
};

export const getChainLabel = (state: GlobalStateT): string => {
  const chainId = getChainId(state);
  return state.protocols[chainId].label;
};

export const getNetwork = (state: GlobalStateT): NETWORKS => {
  const chainId = getChainId(state);
  return state.protocols[chainId].network;
};

export const getSteps = (state: GlobalStateT): ProtocolStepsT => {
  const chainId = getChainId(state);
  return state.protocols[chainId].steps;
};

export const getStepId = (state: GlobalStateT): PROTOCOL_STEPS_ID => {
  const chainId = getChainId(state);
  return state.protocols[chainId].currentStepId;
};

// Current Step Id function
export const getFirstStepId = (state: GlobalStateT): PROTOCOL_STEPS_ID => {
  const chainId = getChainId(state);
  return state.protocols[chainId].firstStepId;
};

export const getLastStepId = (state: GlobalStateT): PROTOCOL_STEPS_ID => {
  const chainId = getChainId(state);
  return state.protocols[chainId].lastStepId;
};

export const getPreviousStepId = (state: GlobalStateT): PROTOCOL_STEPS_ID => {
  const chainId = getChainId(state);
  const currentStepId = getStepId(state);
  const previousStepId =
    state.protocols[chainId].steps[currentStepId].previousStepId;
  return previousStepId ? previousStepId : getFirstStepId(state);
};

export const getNextStepId = (state: GlobalStateT): PROTOCOL_STEPS_ID => {
  const chainId = getChainId(state);
  const currentStepId = getStepId(state);
  const nextStepId = state.protocols[chainId].steps[currentStepId].nextStepId;
  return nextStepId ? nextStepId : getLastStepId(state);
};

export const getPreviousStep = (state: GlobalStateT): ProtocolStepT | null => {
  const chainId = getChainId(state);
  const previousStep = getPreviousStepId(state);
  return previousStep === null
    ? null
    : state.protocols[chainId].steps[previousStep];
};

export const getNextStep = (state: GlobalStateT): ProtocolStepT | null => {
  const chainId = getChainId(state);
  const nextStepId = getNextStepId(state);
  return nextStepId === null
    ? null
    : state.protocols[chainId].steps[nextStepId];
};

export const getStepIndex = (state: GlobalStateT): number => {
  const chainId = getChainId(state);
  const currentStepId = getStepId(state);
  return state.protocols[chainId].steps[currentStepId].position;
};

export const getStepTitle = (state: GlobalStateT): string => {
  const chainId = getChainId(state);
  const currentStepId = getStepId(state);
  return state.protocols[chainId].steps[currentStepId].title;
};

// Predicat's functions
export const isConnectionStep = (state: GlobalStateT): boolean => {
  return getStepId(state) === PROTOCOL_STEPS_ID.CHAIN_CONNECTION;
};

export const isOneColumnStep = (state: GlobalStateT): boolean => {
  const chainId = getChainId(state);
  const currentStepId = getStepId(state);
  return state.protocols[chainId].steps[currentStepId].isOneColumn;
};

export const isFirstStep = (state: GlobalStateT) => {
  return getStepId(state) === getFirstStepId(state);
};

export const isLastStep = (state: GlobalStateT): boolean => {
  return getStepId(state) === getLastStepId(state);
};

export const isCompletedStep = (state: GlobalStateT): boolean => {
  const chainId = getChainId(state);
  const currentStepId = getStepId(state);

  return (
    isOneColumnStep(state) ||
    isSkippableStep(state) ||
    state.protocols[chainId].steps[currentStepId].isCompleted
  );
};

export const isSkippableStep = (state: GlobalStateT): boolean => {
  const chainId = getChainId(state);
  const currentStepId = getStepId(state);
  return state.protocols[chainId].steps[currentStepId].isSkippable;
};

// Inner state functions
export const getChainInnerState = (
  state: GlobalStateT,
  stateId: PROTOCOL_INNER_STATES_ID,
): string | null => {
  const chainId = getChainId(state);
  return state.protocols[chainId].innerState?.[stateId] as string | null;
};

// This function is temporary
// When all the pathways will be migrate it will rewrite and
// it will take 5 line of code and it will be replace by something like this
// The issue here is link to the case of the enum ...
/*
export const getChainInnerState = (
  state: GlobalStateT,
  stateId: PROTOCOL_INNER_STATES_ID,
) => {
  const chainId = getChainId(state);
  return state.protocols[chainId].innerState?.[stateId] as string | null;
};
*/
export const getInnerState = (state: GlobalStateT) => {
  const innerState: any = {};
  const network = getNetwork(state);
  const secret = getChainInnerState(state, PROTOCOL_INNER_STATES_ID.SECRET);
  if (secret) {
    innerState.secret = secret;
  }
  const privateKey = getChainInnerState(
    state,
    PROTOCOL_INNER_STATES_ID.PRIVATE_KEY,
  );
  if (privateKey) {
    innerState.privateKey = privateKey;
  }
  const publicKey = getChainInnerState(
    state,
    PROTOCOL_INNER_STATES_ID.PUBLIC_KEY,
  );
  if (publicKey) {
    innerState.publicKey = publicKey;
  }
  const address = getChainInnerState(state, PROTOCOL_INNER_STATES_ID.ADDRESS);
  if (address) {
    innerState.address = address;
  }
  const contractId = getChainInnerState(
    state,
    PROTOCOL_INNER_STATES_ID.CONTRACT_ID,
  );
  if (contractId) {
    innerState.contractId = contractId;
  }
  const mnemonic = getChainInnerState(state, PROTOCOL_INNER_STATES_ID.MNEMONIC);
  if (mnemonic) {
    innerState.mnemonic = mnemonic;
  }
  const accountId = getChainInnerState(
    state,
    PROTOCOL_INNER_STATES_ID.ACCOUNT_ID,
  );
  if (accountId) {
    innerState.accountId = accountId;
  }
  const password = getChainInnerState(state, PROTOCOL_INNER_STATES_ID.PASSWORD);
  if (password) {
    innerState.password = password;
  }
  const email = getChainInnerState(state, PROTOCOL_INNER_STATES_ID.EMAIL);
  if (email) {
    innerState.email = email;
  }
  const programId = getChainInnerState(
    state,
    PROTOCOL_INNER_STATES_ID.PROGRAM_ID,
  );
  if (programId) {
    innerState.programId = programId;
  }
  const greeter = getChainInnerState(state, PROTOCOL_INNER_STATES_ID.GREETER);
  if (greeter) {
    innerState.greeter = greeter;
  }
  const metamaskNetworkName = getChainInnerState(
    state,
    PROTOCOL_INNER_STATES_ID.METAMASK_NETWORK_NAME,
  );
  if (metamaskNetworkName) {
    innerState.metamaskNetworkName = metamaskNetworkName;
  }
  const did = getChainInnerState(state, PROTOCOL_INNER_STATES_ID.DID);
  if (did) {
    innerState.did = did;
  }
  const userName = getChainInnerState(
    state,
    PROTOCOL_INNER_STATES_ID.USER_NAME,
  );
  if (userName) {
    innerState.userName = userName;
  }

  return {network, ...innerState};
};

'''
'''--- utils/datahub.ts ---
import {
  NETWORKS,
  PROTOCOLS,
  CHAINS,
  NEAR_NETWORKS,
  CELO_NETWORKS,
  SECRET_NETWORKS,
  POLKADOT_NETWORKS,
  POLKADOT_PROTOCOLS,
  SOLANA_NETWORKS,
} from 'types';

export const getNodeURL = (
  chain: CHAINS,
  network: NETWORKS,
  protocol?: PROTOCOLS,
  node?: string,
): string => {
  if (node === 'datahub') {
    return getDatahubNodeURL(chain, network, protocol);
  }
  if (node === 'devnet') {
    return getTestnetNodeURL(chain);
  }
  if (node === 'localnet') {
    return getLocalNodeURL(chain);
  }
  return getDatahubNodeURL(chain, network, protocol);
};

const getTestnetNodeURL = (chain: CHAINS): string => {
  switch (chain) {
    case CHAINS.SOLANA:
      return 'https://api.devnet.solana.com';
    case CHAINS.AVALANCHE:
      return 'https://api.avax-test.network';
    case CHAINS.NEAR:
      return 'https://rpc.testnet.near.org';
    case CHAINS.CERAMIC:
      return 'https://ceramic-clay.3boxlabs.com';
    default:
      return '';
  }
};

const getLocalNodeURL = (chain: CHAINS): string => {
  switch (chain) {
    case CHAINS.SOLANA:
      return 'http://127.0.0.1:8899';
    case CHAINS.AVALANCHE:
      return 'http://127.0.0.1:9650';
    default:
      return '';
  }
};

export const getDatahubNodeURL = (
  chain: CHAINS,
  network: NETWORKS,
  protocol?: PROTOCOLS,
): string => {
  switch (chain) {
    case CHAINS.AVALANCHE:
      return getDataHubAvalancheNodeUrl();
    case CHAINS.NEAR:
      return getDataHubNearNodeUrl(network as NEAR_NETWORKS);
    case CHAINS.POLKADOT:
      return getDataHubPolkadotNodeUrl(
        network as POLKADOT_NETWORKS,
        protocol as POLKADOT_PROTOCOLS,
      );
    case CHAINS.SOLANA:
      return getDataHubSolanaNodeUrl(network as SOLANA_NETWORKS);
    case CHAINS.CELO:
      return getDataHubCeloNodeUrl(network as CELO_NETWORKS);
    case CHAINS.SECRET:
      return getDataHubSecretNodeUrl(network as SECRET_NETWORKS);
    default:
      return '';
  }
};

const getDataHubAvalancheNodeUrl = (): string =>
  `https://${process.env.AVALANCHE_DATAHUB_URL}/apikey/${process.env.DATAHUB_AVALANCHE_API_KEY}`;

const getDataHubNearNodeUrl = (network: NEAR_NETWORKS): string =>
  network === NEAR_NETWORKS.TESTNET
    ? `https://${process.env.DATAHUB_NEAR_MAINNET_RPC_URL}/apikey/${process.env.DATAHUB_NEAR_API_KEY}`
    : `https://${process.env.DATAHUB_NEAR_TESTNET_RPC_URL}/apikey/${process.env.DATAHUB_NEAR_API_KEY}`;

const getDataHubCeloNodeUrl = (network: CELO_NETWORKS): string =>
  network === CELO_NETWORKS.TESTNET
    ? `https://${process.env.DATAHUB_CELO_MAINNET_RPC_URL}/apikey/${process.env.DATAHUB_CELO_API_KEY}/`
    : `https://${process.env.DATAHUB_CELO_TESTNET_RPC_URL}/apikey/${process.env.DATAHUB_CELO_API_KEY}/`;

const getDataHubSecretNodeUrl = (network?: SECRET_NETWORKS): string =>
  `https://${process.env.DATAHUB_SECRET_TESTNET_URL}/apikey/${process.env.DATAHUB_SECRET_API_KEY}/`;

const getDataHubPolkadotNodeUrl = (
  network: POLKADOT_NETWORKS,
  protocol: POLKADOT_PROTOCOLS,
): string => {
  if (network === POLKADOT_NETWORKS.TESTNET) {
    if (protocol === POLKADOT_PROTOCOLS.RPC) {
      return `https://${process.env.DATAHUB_POLKADOT_WESTEND_RPC_URL}/apikey/${process.env.DATAHUB_POLKADOT_API_KEY}`;
    } else if (protocol === POLKADOT_PROTOCOLS.WS) {
      return `wss://${process.env.DATAHUB_POLKADOT_WESTEND_WS_URL}/apikey/${process.env.DATAHUB_POLKADOT_API_KEY}`;
    }
  } else if (network === POLKADOT_NETWORKS.DATAHUB) {
    if (protocol === POLKADOT_PROTOCOLS.RPC) {
      return `https://${process.env.DATAHUB_POLKADOT_MAINNET_RPC_URL}/apikey/${process.env.DATAHUB_POLKADOT_API_KEY}`;
    } else if (protocol === POLKADOT_PROTOCOLS.WS) {
      return `wss://${process.env.DATAHUB_POLKADOT_MAINNET_WS_URL}/apikey/${process.env.DATAHUB_POLKADOT_API_KEY}`;
    }
  }

  return '';
};

const getDataHubSolanaNodeUrl = (network: SOLANA_NETWORKS): string => {
  if (network === SOLANA_NETWORKS.MAINNET) {
    return `https://${process.env.DATAHUB_SOLANA_MAINNET_URL}/apikey/${process.env.DATAHUB_SOLANA_API_KEY}`;
  } else {
    return `https://${process.env.DATAHUB_SOLANA_DEVNET_URL}/apikey/${process.env.DATAHUB_SOLANA_API_KEY}`;
  }
};

'''
'''--- utils/markdown.ts ---
import {MarkdownForChainIdT, PROTOCOL_STEPS_ID, CHAINS} from 'types';
import {CHAINS_CONFIG} from 'lib/constants';
import path from 'path';
import fs from 'fs';

const MARKDOWN_PATH = path.resolve('markdown');

export function fetchMarkdownForChainId(chainId: CHAINS): MarkdownForChainIdT {
  const steps = CHAINS_CONFIG[chainId].steps.map((step) => step.id);

  return steps.reduce((markdownMap, stepId) => {
    // We have a special case for preface because it's common to every pathway
    const filePath =
      stepId === PROTOCOL_STEPS_ID.PREFACE
        ? path.join(MARKDOWN_PATH, `PREFACE.md`)
        : path.join(MARKDOWN_PATH, chainId, `${stepId}.md`);
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const markdown = fileContent.toString();
    markdownMap[stepId as PROTOCOL_STEPS_ID] = markdown;
    return markdownMap;
  }, {} as MarkdownForChainIdT);
}

export function getMarkdownForStepId(
  chainId: CHAINS,
  stepId: PROTOCOL_STEPS_ID,
): string {
  const filePath =
    stepId === PROTOCOL_STEPS_ID.PREFACE
      ? path.join(MARKDOWN_PATH, `PREFACE.md`)
      : path.join(MARKDOWN_PATH, chainId, `${stepId}.md`);

  const fileContent = fs.readFileSync(filePath, 'utf-8');
  const markdown = fileContent.toString();

  return markdown;
}

'''
'''--- utils/networks.ts ---
import {
  NETWORK,
  CHAINS,
  SOLANA_NETWORKS,
  CELO_NETWORKS,
  AVALANCHE_NETWORKS,
  POLKADOT_NETWORKS,
  POLYGON_NETWORKS,
  PYTH_NETWORKS,
  NEAR_NETWORKS,
  SECRET_NETWORKS,
  TEZOS_NETWORKS,
} from 'types';

export const networksMap = (
  network: NETWORK,
  chain: CHAINS,
): string | undefined => {
  // SOLANA NETWORKS MAP
  if (chain === CHAINS.SOLANA) {
    if (network === NETWORK.DATAHUB) {
      return SOLANA_NETWORKS.DATAHUB;
    }
    if (network === NETWORK.TESTNET) {
      return SOLANA_NETWORKS.DEVNET;
    }
    if (network === NETWORK.LOCALNET) {
      return SOLANA_NETWORKS.LOCALNET;
    }
  }

  // PYTH NETWORKS MAP
  if (chain === CHAINS.PYTH) {
    if (network === NETWORK.DEVNET) {
      return PYTH_NETWORKS.DEVNET;
    }
    if (network === NETWORK.TESTNET) {
      return PYTH_NETWORKS.DEVNET;
    }
    if (network === NETWORK.MAINNET) {
      return PYTH_NETWORKS.MAINNET;
    }
  }

  // AVALANCHE NETWORKS MAP
  if (chain === CHAINS.AVALANCHE) {
    if (network === NETWORK.DATAHUB) {
      return AVALANCHE_NETWORKS.DATAHUB;
    }
    if (network === NETWORK.TESTNET) {
      return AVALANCHE_NETWORKS.TESTNET;
    }
  }

  // CELO NETWORKS MAP
  if (chain === CHAINS.CELO) {
    if (network === NETWORK.DATAHUB) {
      return CELO_NETWORKS.DATAHUB;
    }
    if (network === NETWORK.TESTNET) {
      return CELO_NETWORKS.TESTNET;
    }
  }

  // SECRET NETWORKS MAP
  if (chain === CHAINS.SECRET) {
    if (network === NETWORK.TESTNET) {
      return SECRET_NETWORKS.TESTNET;
    } else {
      return undefined;
    }
  }

  // NEAR NETWORKS MAP
  if (chain === CHAINS.NEAR) {
    if (network === NETWORK.DATAHUB) {
      return NEAR_NETWORKS.DATAHUB;
    }
    if (network === NETWORK.TESTNET) {
      return NEAR_NETWORKS.TESTNET;
    }
  }

  // TEZOS NETWORKS MAP
  if (chain === CHAINS.TEZOS) {
    if (network === NETWORK.TESTNET) {
      return TEZOS_NETWORKS.TESTNET;
    } else {
      return undefined;
    }
  }

  // POLKADOT NETWORKS MAP
  if (chain === CHAINS.POLKADOT) {
    if (network === NETWORK.DATAHUB) {
      return POLKADOT_NETWORKS.DATAHUB;
    }
    if (network === NETWORK.TESTNET) {
      return POLKADOT_NETWORKS.TESTNET;
    }
  }

  // POLYGON NETWORKS MAP
  if (chain === CHAINS.POLYGON) {
    if (network === NETWORK.TESTNET) {
      return POLYGON_NETWORKS.TESTNET;
    } else {
      return undefined;
    }
  }
};

'''
'''--- utils/pages.ts ---
import {CHAINS_CONFIG} from 'lib/constants';
import {ChainPropT, CHAINS} from 'types';
import {fetchMarkdownForChainId} from './markdown';

export function getStaticPropsForChain(chain: CHAINS): {props: ChainPropT} {
  return {
    props: {
      chain: CHAINS_CONFIG[chain],
      markdown: fetchMarkdownForChainId(chain),
    },
  };
}

'''
'''--- utils/string-utils.ts ---
export const slicedAddress = (
  address: string,
  startChar: number = 5,
  endChar: number = 5,
): string => `${address.slice(0, startChar)}...${address.slice(-endChar)}`;

'''
'''--- utils/tracking-utils.ts ---
import {UserActivity} from '../types';

type Analytics = {
  track: (eventName: string, data: Record<string, any>) => void;
  page: (url: string) => void;
};

declare let global: {
  analytics: Analytics;
};
declare let window: {
  analytics: Analytics;
};

export const trackEvent = (
  eventName: string,
  data: Record<string, any>,
): void => {
  if (global?.analytics) {
    global.analytics.track(eventName, data);
  }
};

export const trackTutorialStepViewed = (
  chainId: string,
  stepTitle: string,
  action: 'next' | 'prev',
) => {
  trackEvent(UserActivity.TUTORIAL_STEP_VIEWED, {
    protocol: chainId,
    stepTitle,
    action,
  });
};

export const trackStorageCleared = (chainId: string) => {
  trackEvent(UserActivity.STORAGE_CLEARED, {
    protocol: chainId,
  });
};

export const trackPageView = (url: string): void => {
  if (typeof window !== 'undefined' && window.analytics) {
    window.analytics.page(url);
  }
};

'''