*GitHub Repository "Learn-NEAR/NCD--pokemon"*

'''--- README.md ---
<!-- @format -->

# Near Pokemon

## Set Up

`yarn` : installs all the relevant node modules \
`yarn build` : creates the out/main.wasm file \
`yarn test` : runs the main.spec.ts file in assembly/\_\_tests\_\_

## NEAR

`near dev-deploy out/main.wasm` : deploys the contract

### View Methods

`near view $CONTRACT getAllPokemon` : returns a list of all pokemon\
`near view $CONTRACT getPokemonById '{"id": $POKEMON_ID}'` : gets a pokemon by id\
`near view $CONTRACT getPokemonByOwner '{"owner": $OWNER_NAME}'` : gets all pokemon for a specific account

### Change Methods

`near call $CONTRACT createPokemon '{"name": $POKEMON_NAME}' --account_id $YOUR_ACCOUNT` : creates a pokemon with the specified name and assigns the owner of the pokemon to $YOUR_ACCOUNT\
`near call $CONTRACT deletePokemon '{"id": $POKEMON_ID}' --account_id $YOUR_ACCOUNT` : deletes a pokemon with the specified id\
`near call $CONTRACT transferPokemon '{"newOwner": $OWNER_ACCOUNT, "id": $POKEMON_ID}' --account_id $YOUR_ACCOUNT` : transfers a pokemon from $YOUR_ACCOUNT to $OWNER_ACCOUNT\
`near call $CONTRACT trainPokemon '{"id": $POKEMON_ID, "cpuLevel": $CPU_LEVEL}' --account_id $YOUR_ACCOUNT` : trains a pokemon with id of $POKEMON_ID from $YOUR_ACCOUNT against a random cpu at level $CPU_LEVEL\
`near call $CONTRACT healPokemon '{"id": $POKEMON_ID}' --account_id $YOUR_ACCOUNT` : heals a pokemon with id of $POKEMON_ID from $YOUR_ACCOUNT to full health

'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports');
'''
'''--- asconfig.js ---
/** @format */

const compile = require('near-sdk-as/compiler').compile

compile(
    'assembly/main.ts', // input file
    'out/main.wasm', // output file
    [
        '--debug',
        '--measure', // Shows compiler runtime
        '--validate', // Validate the generated wasm module
    ],
    {
        verbose: true, // Output the cli args passed to asc
    }
)

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__tests__/main.spec.ts ---
/** @format */

import {
    createPokemon,
    getPokemonByOwner,
    getAllPokemon,
    deletePokemon,
    transferPokemon,
    getPokemonById
} from '../main'

describe('Get Pokemon', () => {
    it('Should return an array of 1 pokemon', () => {
        const pokemon = createPokemon('reptar')
        expect(getPokemonByOwner(pokemon.owner).length).toBe(
            1,
            'Should return an array of the pokemon created above.'
        )
    })

    it('Should return a single pokemon', () => {
        const pokemon = createPokemon('reptar')
        expect(getPokemonById(pokemon.id).id).toBe(
            pokemon.id,
            'Should return the same pokemon that was created'
        )
    })

    it('Should return all the pokemon', () => {
        createPokemon('reptar')
        createPokemon('dr. zhivago')
        expect(getAllPokemon().length).toBe(
            2,
            'Should return the same pokemon that was created'
        )
    })
})

describe('Delete pokemon', () => {
    it('Should return no pokemon after deleting the pokemon', () => {
        const pokemon = createPokemon('reptar')
        expect(getAllPokemon().length).toBe(
            1,
            'Should return the same pokemon that was created'
        )
        deletePokemon(pokemon.id)
        expect(getAllPokemon().length).toBe(
            0,
            'Should return no pokemon after deletion'
        )
    })
})

describe('Transfer pokemon', () => {
    it('Should return no pokemon after deleting the pokemon', () => {
        const pokemon = createPokemon('reptar')
        const originalOwner = pokemon.owner
        expect(getPokemonByOwner(originalOwner).length).toBe(
            1,
            'Should return the pokemon just create.'
        )
        const newOwner = 'git'
        transferPokemon(newOwner, pokemon.id)
        expect(getPokemonByOwner(originalOwner).length).toBe(
            0,
            'Should return no pokemon for the original owner because the pokemon has been transferred.'
        )
        expect(getPokemonByOwner(newOwner).length).toBe(
            1,
            'Should return the single pokemon for the new owner.'
        )
    })
})

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/constants.ts ---
/** @format */

import { PokemonValue } from './models'

export const maxLevel = 100
export const maxBaseValue = 32
// chance the cpu will attack in any given turn (percentage)
export const cpuAggression = 50
export const pokemonTypes = ['bulbasaur', 'charmander', 'squirtle']

const bulbasaurValues = new PokemonValue(
    'bulbasaur',
    [210, 274],
    [190, 254],
    [210, 274],
    [200, 264]
)

const charmanderValues = new PokemonValue(
    'charmander',
    [200, 264],
    [210, 274],
    [180, 244],
    [220, 284]
)

const squirtleValues = new PokemonValue(
    'squirtle',
    [200, 264],
    [200, 264],
    [220, 284],
    [190, 254]
)

export const pokemonValues: PokemonValue[] = [
    bulbasaurValues,
    charmanderValues,
    squirtleValues
]

'''
'''--- assembly/helpers.ts ---
/** @format */

import { base64, math } from 'near-sdk-as'
import { maxBaseValue, pokemonTypes } from './constants'
import {
    orderedPokemonList,
    Pokemon,
    pokemonByOwner,
    PokemonIdList,
    pokemonMap
} from './models'

/**
 * Gets all the pokemon ids for a specified owner
 * @param owner
 * @returns
 */
export function getPokemonIdsForOwner(owner: string): Array<string> {
    const pokemonIdList = pokemonByOwner.get(owner)
    return !pokemonIdList ? new Array<string>() : pokemonIdList.id
}

/**
 * Removes a pokemon from an owner
 * @param owner
 * @param id
 */
export function removePokemonFromOwner(owner: string, id: string): void {
    const pokeIds = getPokemonIdsForOwner(owner)
    for (let i = 0; i < pokeIds.length; i++) {
        if (id == pokeIds[i]) {
            pokeIds.splice(i, 1)
            break
        }
    }
    pokemonByOwner.set(owner, new PokemonIdList(pokeIds))
}

/**
 * Adds a pokemon to the pokemonMap (key: uint8arrary, value: pokemon); it adds the id to the owner's pokemonList in the pokemonByOwner map
 * @param pokemon
 * @param owner
 * @param id
 */
export function addPokemon(
    pokemon: Pokemon,
    owner: string,
    addToGlobal: boolean
): void {
    pokemonMap.set(base64.decode(pokemon.id), pokemon)
    if (addToGlobal) {
        updateOrderedPokemonList(pokemon.id)
    }
    const pokemonIds = getPokemonIdsForOwner(owner)
    pokemonIds.push(pokemon.id)
    pokemonByOwner.set(owner, new PokemonIdList(pokemonIds))
}

/**
 * Gets all the ids of the pokemon.
 * @returns
 */
export function getAllPokemonIds(): Array<string> {
    const pokemonIdList = orderedPokemonList.get('all')
    return pokemonIdList ? pokemonIdList.id : new Array<string>()
}

/**
 * Updates the ordered pokemon list
 * @param id
 */
export function updateOrderedPokemonList(id: string): void {
    const allPokemonIds = getAllPokemonIds()
    allPokemonIds.push(id)
    const pokemon = new PokemonIdList(allPokemonIds)
    orderedPokemonList.set('all', pokemon)
}

/**
 * Deletes a pokemon from the ordered pokemon list with the given id.
 * @param id
 */
export function deleteFromOrderedPokemonList(id: string): void {
    const globalIds = getAllPokemonIds()
    for (let i = 0; i < globalIds.length; i++) {
        if (id == globalIds[i]) {
            globalIds.splice(i, 1)
            break
        }
    }
    orderedPokemonList.set('all', new PokemonIdList(globalIds))
}

/**
 * returns a random number between 0 and 99
 * @returns
 */
export function randomNumber(): i32 {
    return math.hash32Bytes(math.randomBuffer(4)) % 100
}

/**
 * Returns list of random numbers of $amount length
 * @param amount
 * @returns
 */
export function randomNumbers(amount: number): i32[] {
    let nums: Array<i32> = []
    for (let i = 0; i < amount; i++) {
        nums.push(randomNumber())
    }
    return nums
}

/**
 * Returns a random integer between 0 and maxBaseValue
 * @returns
 */
export function randomBaseValue(): i32 {
    const num = randomNumber()
    const modifier = 99 / maxBaseValue
    const randomIndex = num / modifier
    return randomIndex < maxBaseValue ? randomIndex : maxBaseValue
}

/**
 * Returns a random pokemon type
 * @returns
 */
export function randomPokemonType(): string {
    const num = randomNumber()
    const modifier = 99 / pokemonTypes.length
    let randomIndex = num / modifier
    if (randomIndex > pokemonTypes.length - 1) {
        randomIndex = pokemonTypes.length
    }
    return pokemonTypes[randomIndex]
}

/**
 * Gets a pokemon by a specified id.
 * @param id
 * @returns
 */
export function pokemonById(id: string): Pokemon {
    return pokemonMap.getSome(base64.decode(id))
}

/**
 * Calculates the damage for a given interaction
 * @param level
 * @param basePower
 * @param attack
 * @param defense
 * @returns
 */
export function calculateDamage(
    level: i32,
    basePower: i32,
    attack: i32,
    defense: i32
): i32 {
    return (((2 * level) / 5 + 2) * basePower * attack) / defense / 50 + 2
}

'''
'''--- assembly/main.ts ---
/** @format */

import { context, base64, math } from 'near-sdk-as'
import { Pokemon, pokemonMap, SerializedPokemon } from './models'
import {
    addPokemon,
    deleteFromOrderedPokemonList,
    getAllPokemonIds,
    getPokemonIdsForOwner,
    randomPokemonType,
    removePokemonFromOwner,
    pokemonById,
    calculateDamage,
    randomNumber
} from './helpers'
import { cpuAggression } from './constants'

/*******************/
/* CHANGE METHODS */
/*****************/

/**
 * Creates a pokemon with a specified nickname and assigns its owner as the transaction sender.
 * @param nickname
 */
export function createPokemon(nickname: string): SerializedPokemon {
    const id = base64.encode(math.randomBuffer(16))
    const pokemon = new Pokemon(id, nickname, randomPokemonType())
    addPokemon(pokemon, context.sender, true)
    return pokemon.serialized
}

/**
 * Deletes a pokemon with a specified id.
 * @param id
 */
export function deletePokemon(id: string): void {
    const pokemon = pokemonById(id)
    assert(
        pokemon.owner == context.sender,
        'This pokemon does not belong to ' + context.sender
    )
    removePokemonFromOwner(pokemon.owner, id)
    deleteFromOrderedPokemonList(id)
    pokemonMap.delete(base64.decode(id))
}

/**
 * Transfers a pokemon with specified id from the sender to a newOwner.
 * @param newOwner
 * @param id
 */
export function transferPokemon(newOwner: string, id: string): void {
    const pokemon = pokemonById(id)
    assert(
        pokemon.owner == context.sender,
        'This pokemon does not belong to ' + context.sender
    )
    removePokemonFromOwner(pokemon.owner, id)
    pokemon.owner = newOwner
    addPokemon(pokemon, newOwner, false)
}

/**
 * Heals a pokemon with a specified id to full health.
 * @param id
 */
export function healPokemon(id: string): void {
    const pokemon = pokemonById(id)
    assert(
        pokemon.owner == context.sender,
        'This pokemon does not belong to ' + context.sender
    )
    pokemon.heal()
    pokemonMap.set(base64.decode(pokemon.id), pokemon)
}

/**
 * Trains a pokemon with specified id against a cpu at specified cpuLevel
 * @param id
 * @param cpuLevel
 */
export function trainPokemon(id: string, cpuLevel: i32): string {
    const pokemon = pokemonById(id)
    assert(
        pokemon.owner == context.sender,
        'This pokemon does not belong to ' + context.sender
    )
    if (pokemon.currentHealth == 0) {
        return 'Cannot fight with a fainted pokemon!'
    }
    const serializedPokemon = pokemon.serialized
    const basePower = 40
    const cpu = new Pokemon('cpu', '', randomPokemonType(), cpuLevel)
    const serializedCpu = cpu.serialized
    let isOver = false
    const userFaster = serializedPokemon.speed >= serializedCpu.speed
    let userWon = false
    while (!isOver) {
        const userToCpuDmg = calculateDamage(
            serializedPokemon.level,
            basePower,
            serializedPokemon.attack,
            serializedCpu.defense
        )
        // damage done to user's pokemon by cpu
        const rand = randomNumber()
        const cpuToUserDmg = calculateDamage(
            serializedCpu.level,
            rand < cpuAggression ? basePower : 0,
            serializedCpu.attack,
            serializedPokemon.defense
        )
        if (userFaster) {
            cpu.currentHealth -= userToCpuDmg
            if (cpu.currentHealth <= 0) {
                isOver = true
                userWon = true
                break
            } else {
                pokemon.currentHealth -= cpuToUserDmg
                if (pokemon.currentHealth <= 0) {
                    pokemon.currentHealth = 0
                    isOver = true
                    break
                }
            }
        } else {
            pokemon.currentHealth -= cpuToUserDmg
            if (pokemon.currentHealth <= 0) {
                pokemon.currentHealth = 0
                isOver = true
                break
            } else {
                cpu.currentHealth -= userToCpuDmg
                if (cpu.currentHealth <= 0) {
                    isOver = true
                    userWon = true
                    break
                }
            }
        }
    }
    if (userWon) {
        pokemon.gainExperience(cpu.experienceGained)
    }
    pokemonMap.set(base64.decode(pokemon.id), pokemon)
    return userWon
        ? 'User won with ' + pokemon.currentHealth.toString() + ' HP left!'
        : 'User lost with ' + cpu.currentHealth.toString() + ' HP left for CPU!'
}

/*****************/
/* VIEW METHODS */
/****************/

/**
 * Gets the list of pokemon for a specified account.
 * @param owner
 * @returns
 */
export function getPokemonByOwner(owner: string): SerializedPokemon[] {
    const pokemonIds = getPokemonIdsForOwner(owner)
    let pokemonList = new Array<SerializedPokemon>()
    for (let i = 0; i < pokemonIds.length; i++) {
        const id = base64.decode(pokemonIds[i])
        if (pokemonMap.contains(id)) {
            pokemonList.push(pokemonMap.getSome(id).serialized)
        }
    }
    return pokemonList
}

/**
 * Gets a pokemon by a specified id.
 * @param id
 * @returns
 */
export function getPokemonById(id: string): SerializedPokemon {
    return pokemonMap.getSome(base64.decode(id)).serialized
}

/**
 * Gets all pokemon.
 * @returns
 */
export function getAllPokemon(): SerializedPokemon[] {
    const allPokemonIds = getAllPokemonIds().reverse()
    const numberOfPokemon = allPokemonIds.length
    const result = new Array<SerializedPokemon>(numberOfPokemon)
    for (let i = 0; i < numberOfPokemon; i++) {
        result[i] = pokemonById(allPokemonIds[i]).serialized
    }
    return result
}

'''
'''--- assembly/models.ts ---
/** @format */

import { context, PersistentMap } from 'near-sdk-as'
import { maxBaseValue, maxLevel, pokemonValues } from './constants'
import { randomBaseValue } from './helpers'

@nearBindgen
export class PokemonIdList {
    constructor(public id: Array<string>) {}
}

@nearBindgen
export class Pokemon {
    owner: string
    baseHealth: i32
    baseAttack: i32
    baseDefense: i32
    baseSpeed: i32
    currentHealth: i32
    experience: i32 = 125
    baseExperienceYield: i32 = 64

    constructor(
        public id: string,
        public nickname: string,
        public type: string,
        public level: i32 = 5
    ) {
        this.owner = context.sender
        this.baseHealth = randomBaseValue()
        this.baseAttack = randomBaseValue()
        this.baseDefense = randomBaseValue()
        this.baseSpeed = randomBaseValue()
        this.currentHealth = this.serialized.health
    }

    get name(): string {
        return this.nickname.length > 0 ? this.nickname : this.type.toString()
    }

    get serialized(): SerializedPokemon {
        return new SerializedPokemon(this)
    }

    get experienceGained(): i32 {
        return (this.level * this.baseExperienceYield) / 7
    }

    get pokemonValue(): PokemonValue {
        const numValues = pokemonValues.length
        for (let i = 0; i < numValues; i++) {
            const value = pokemonValues[i]
            if (value.type == this.type) {
                return value
            }
        }
        return pokemonValues[0]
    }

    public heal(): void {
        this.currentHealth = this.serialized.health
    }

    public gainExperience(experience: i32): void {
        if (this.level < maxLevel) {
            this.experience += experience
            const nextLevel = this.level + 1
            if (this.experience >= nextLevel * nextLevel * nextLevel) {
                const value = this.pokemonValue
                const healthRange = value.healthRange
                const healthDiff = healthRange[1] - healthRange[0]
                const currentMaxHealth =
                    (((healthDiff * this.baseHealth) / maxBaseValue +
                        healthRange[0]) *
                        this.level) /
                    maxLevel
                this.level += 1
                const newMaxHealth =
                    (((healthDiff * this.baseHealth) / maxBaseValue +
                        healthRange[0]) *
                        this.level) /
                    maxLevel
                const extraHealth = newMaxHealth - currentMaxHealth
                this.currentHealth += extraHealth
                this.currentHealth =
                    this.currentHealth < newMaxHealth
                        ? this.currentHealth
                        : newMaxHealth
            }
        }
    }
}

@nearBindgen
export class SerializedPokemon {
    health: i32 = 0
    attack: i32 = 0
    defense: i32 = 0
    speed: i32 = 0
    owner: string
    id: string
    nickname: string
    name: string
    type: string
    baseHealth: i32
    baseAttack: i32
    baseDefense: i32
    baseSpeed: i32
    level: i32
    currentHealth: i32
    experience: i32

    constructor(pokemon: Pokemon) {
        this.owner = pokemon.owner
        this.id = pokemon.id
        this.nickname = pokemon.nickname
        this.name = pokemon.name
        this.type = pokemon.type
        this.level = pokemon.level
        this.baseHealth = pokemon.baseHealth
        this.baseAttack = pokemon.baseAttack
        this.baseDefense = pokemon.baseDefense
        this.baseSpeed = pokemon.baseSpeed
        this.currentHealth = pokemon.currentHealth
        this.experience = pokemon.experience

        const value = pokemon.pokemonValue
        const healthRange = value.healthRange
        const healthDiff = healthRange[1] - healthRange[0]
        this.health =
            (((healthDiff * pokemon.baseHealth) / maxBaseValue +
                healthRange[0]) *
                this.level) /
            maxLevel

        const attackRange = value.attackRange
        const attackDiff = attackRange[1] - attackRange[0]
        this.attack =
            (((attackDiff * pokemon.baseAttack) / maxBaseValue +
                attackRange[0]) *
                this.level) /
            maxLevel

        const defenseRange = value.defenseRange
        const defenseDiff = defenseRange[1] - defenseRange[0]
        this.defense =
            (((defenseDiff * pokemon.baseDefense) / maxBaseValue +
                defenseRange[0]) *
                this.level) /
            maxLevel

        const speedRange = value.speedRange
        const speedDiff = speedRange[1] - speedRange[0]
        this.speed =
            (((speedDiff * pokemon.baseSpeed) / maxBaseValue + speedRange[0]) *
                this.level) /
            maxLevel
    }
}

export class PokemonValue {
    constructor(
        public type: string,
        public healthRange: i32[],
        public attackRange: i32[],
        public defenseRange: i32[],
        public speedRange: i32[]
    ) {}
}

// key => pokemon id in Unit8Array; value => pokemon
export const pokemonMap = new PersistentMap<Uint8Array, Pokemon>('m')

// key => ownerId; value => list of ids of pokemon
export const pokemonByOwner = new PersistentMap<string, PokemonIdList>('o')

// key => 'all'; value => list of all the pokemon ids
export const orderedPokemonList = new PersistentMap<string, PokemonIdList>('l')

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- package.json ---
{
    "name": "blockemon",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "build": "node asconfig.js",
        "test": "asp --nologo"
    },
    "dependencies": {
        "@types/node": "^14.14.36",
        "assemblyscript": "^0.9.4",
        "near-sdk-as": "^0.3.1"
    }
}

'''