*GitHub Repository "jasontduncan/penny-for-your-thoughts"*

'''--- README.md ---
# Penny For Your Thoughts Micro-blog

This is a micro-blogging app that stores author's micro-blogs, or 'thoughts', on the blockchain. The content is, therefore, resistant to tampering and censorship.
### IMPORTANT! This repo is for demonstration purposes only. It is not intended for use in a production environment!!!

## Usage

### Prerequisites for deployment:

`$OWNER` environment variable must be set to an account you control  
`$NEAR_ENV` environment variable must be set to either `testnet` or `mainnet`

### Testnet:

1. clone this repo to a local folder
2. run `yarn`
3. run `yarn test`
4. run `./scripts/1.deploy.sh`

### Scripts:

1. `1.deploy.sh` deletes any existing account under `$CONTRACT.$OWNER` and calls `dev-deploy`.
2. `2.shareThought.sh` posts a new thought to `$CONTRACT` with identity `$OWNER`. Will fail if `$OWNER` doesn't own `$CONTRACT`.
  - eg. `./scripts/2.shareThought.sh "Here's a thought..."`
  - ... or with optional deposit (in NEAR) for storage staking:
      `./scripts/2.shareThought.sh "I was just thinking about cheese." 2`
3. `3.readThoughts.sh` returns thoughts posted to the specified contract. Only 10, by default.
  - eg. `./scripts/3.readThoughts.sh dev-xxxxxxxx-xxxxxxx`
  - ... or with pagination (count, skip):
      `./scripts/3.readThoughts.sh dev-xxxxxxxx-xxxxxx 1 1`
4. `4.givePenny.sh` transfers the specified amount of Near from the `$OWNER` to the `$CONTRACT`
  - eg. `./scripts4.givePenny.sh 2`

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "workspaces": [
    "src/cert_demo"
  ]
}

'''
'''--- package.json ---
{
  "name": "cert_demo",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "asp --nologo",
    "build": "asb --target dev_build",
    "build:release": "asb"
  },
  "author": "jasontduncan@gmail.com",
  "license": "MIT",
  "devDependencies": {
    "@as-pect/cli": "^6.2.4",
    "near-sdk-as": "^3.2.3"
  }
}

'''
'''--- scripts/1.deploy.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "\$CONTRACT environment variable not set"
[ -z "$OWNER" ] && echo "\$OWNER environment variable not set"

echo "Deleting old contract, if it exists..."
near delete $CONTRACT.$OWNER $OWNER
echo "Done."

echo "Rebuilding..."
rm -rf ./neardev
set -e
yarn build:release
near dev-deploy --accountId $CONTRACT.$OWNER --wasmFile ./build/release/cert_demo.wasm --initFunction new --initArgs "{\"thinker\": \"$OWNER\"}"
echo "Done."

echo
echo
echo "Update the \$CONTRACT environment variable:"
echo "export CONTRACT=dev-xxxxxxxxxxx-xxxxxxxxx listed as 'Account id:', above"
echo WINDOWS USERS: Use 'SET' instead of export.
echo
echo "Then try: ./scripts/2.shareThough.sh \"Whatever's on your mind\""
echo
echo

'''
'''--- scripts/2.shareThought.sh ---
#!/usr/bin/env bash
set -e

[ -z "$CONTRACT" ] && echo "\$CONTRACT environment variable not set." && exit 1
[ -z "$OWNER" ] && echo "\$OWNER environment variable not set." && exit 1
[ -z "$1" ] && echo "Thought text can't be blank" && exit 1

deposit=${2:-0}

near call $CONTRACT shareThought "{\"thought\": \"$1\"}" --account-id $OWNER --deposit $deposit

'''
'''--- scripts/3.readThoughts.sh ---
#!/usr/bin/env bash
set -e

[ -z "$OWNER" ] && echo "\$OWNER environment variable not set." && exit 1
[ -z "$1" ] && echo "Contract ID can't be blank." && exit 1

count=${2:-10}
skip=${3:-0}

echo
echo "Fetching thoughts..."
echo
near call $1 readThoughts "{\"count\": $count, \"skip\": $skip}" --account-id=$OWNER
echo
echo "Done."

'''
'''--- scripts/4.givePenny.sh ---
#!/usr/bin/env bash
set -e

[ -z "$CONTRACT" ] && echo "$CONTRACT environment variable not set." && exit 1
[ -z "$OWNER" ] && echo "$OWNER environment variable not set." && exit 1
[ -z "$1" ] && echo "Value can't be blank." && exit 1

near call $CONTRACT givePenny --deposit $1 --account-id $OWNER

'''
'''--- specReporter.js ---

const {VerboseReporter} = require("@as-pect/core");

module.exports = class SpecReporter extends VerboseReporter {

}

'''
'''--- src/cert_demo/assembly/__tests__/index.unit.spec.ts ---
import {VMContext, u128, PersistentVector, Context} from "near-sdk-as"
import {ONE_NEAR, MIN_ACCOUNT_BALANCE} from "../../../utils"
import * as App from "../index"
import * as Models from "../models"

const VALID_THOUGHT = "Here's a thought",
    VALID_DEPOSIT = u128.from(1),
    THINKER = 'thinker',
    JOURNAL = new PersistentVector<Models.Thought>("t")

    let contract: App.Contract

    describe("Contract", () => {
        beforeEach(() => {
            const pb = new Models.PiggyBank(),
            initialDeposit = MIN_ACCOUNT_BALANCE

            VMContext.setAttached_deposit(initialDeposit)
            contract = new App.Contract(THINKER, JOURNAL, pb)
        })
        describe("#shareThought()", () => {
            describe("Invalid call", () => {
                describe("Caller is not the thinker", () => {
                    beforeEach(() => {
                        // Set caller to notThinker
                        VMContext.setSigner_account_id('notTheThinker')
                    })
                    afterEach(() => {
                        // Undo the changes to the context
                        VMContext.setSigner_account_id(THINKER) 
                    })
                    it("should throw", () => {
                        expect(() => {
                            contract.shareThought(VALID_THOUGHT)    
                        }).toThrow()
                    })
                })
                describe("Invalid args", () => {
                    describe("Text is empty", () => {
                        it("should throw", () => {
                            expect(() => {
                                const emptyThought = ""
                                VMContext.setSigner_account_id(THINKER)
                                contract.shareThought(emptyThought)
                            }).toThrow()
                        })
                    })
                })
                describe("Invalid deposit", () => {
                    describe("deposit is too big", () => {
                        it("should throw", () => {
                            expect(() => {
                                // Negative number will wrap to max unsigned
                                VMContext.setAttached_deposit(u128.from(-1))
                                contract.shareThought(VALID_THOUGHT)
                            }).toThrow()
                        })
                    })
                })
            })
            describe("Valid call", () => {
                // Make valid call
                beforeEach(() => {
                    VMContext.setSigner_account_id(THINKER)
                    contract.shareThought(VALID_THOUGHT)
                })
                it("should add the thought to the journal", () => {
                    const firstThought = JOURNAL.first
                    expect(firstThought.text).toBe(VALID_THOUGHT)
                })
                it("should add each thought to the end of the journal", () => {
                    const secondThought = "On second thought..."
                    contract.shareThought(secondThought)
                    expect(JOURNAL.last.text).toBe(secondThought)
                })
            })
        })
        describe("#readThoughts()", () => {
            beforeEach(() => {  
                VMContext.setSigner_account_id(THINKER)
                // Not totally necessary, but empty collections all look alike.
                // Unique values are less prone to false positives.
                contract.shareThought(VALID_THOUGHT)
            })
            it("should return the thoughts in reverse chronological order", () => {
                const secondThought = "On second thought..."
                contract.shareThought(secondThought)

                const thoughts = contract.readThoughts()

                expect(thoughts[0].text).toBe(secondThought)
            })
            describe("Context differences", () => {
                describe("Caller is not the thinker", () =>{
                    beforeEach(() => {
                        // Set the context
                        VMContext.setSigner_account_id('notTheThinker')
                    })
                    afterEach(() => {
                        // Clean up the context
                        VMContext.setSigner_account_id(THINKER)
                    })
                    it("should return the thoughts", () => {
                        const thoughts = contract.readThoughts()
                        expect(thoughts[0].text).toBe(VALID_THOUGHT)
                    })
                })
                describe("Caller is the thinker", () => {
                    it("should return the thoughts", () => {
                        const thoughts = contract.readThoughts()
                        expect(thoughts[0].text).toBe(VALID_THOUGHT)
                    })
                })
            })
            describe("Call arguments", () => {
                beforeEach(() => {
                    //Publish multiple thoughts
                    for(let i=1; i<=20; i++) {
                        // Pay for storage
                        VMContext.setAttached_deposit(u128.from(3))
                        contract.shareThought("Thought"+i.toString())
                    }
                })
                describe("No args", () => {
                    it("should return 10 thoughts", () => {
                        const thoughts = contract.readThoughts()
                        expect(thoughts.length).toBe(10)
                    })
                })
                describe("Optional args", () => {
                    describe("Called with 'count'", () => {
                        it("should return the desired number of thoughts", () => {
                            const desiredCount = 5,
                                thoughts = contract.readThoughts(desiredCount)

                            expect(thoughts.length).toBe(desiredCount)
                        })
                    })
                    describe("Called with 'skip'", () => {
                        it("should skip the desired number of thoughts, returning the next ones", () => {
                            const desiredSkip = 10,
                                thoughts = contract.readThoughts(10, desiredSkip)

                            expect(thoughts[0].text).toBe("Thought10")
                        })
                    })
                })
            })
        })
        describe("#givePenny", () => {
            describe("Invalid deposit", () =>{
                describe("Deposit too big", () => {
                    beforeEach(() => {
                        // Negative values wrap to large unsigned values
                        VMContext.setAttached_deposit(u128.from(-1))
                    })
                    it("should throw", () => {
                        expect(() => {
                            contract.givePenny()
                        }).toThrow()
                    })
                })
            })
            describe("Valid deposit", () => {
                beforeEach(() => {
                    VMContext.setAttached_deposit(VALID_DEPOSIT)
                })
                it("should add the deposit to the piggybank", () => {
                    const initialBalance = contract.piggyBank.amount

                    contract.givePenny()

                    expect(contract.piggyBank.amount).toBe(initialBalance + VALID_DEPOSIT)
                })
            })
        })
        describe("#breakBank", () => {
            describe("Valid caller", () => {
                beforeEach(() => {
                    VMContext.setSigner_account_id(THINKER)
                })
                describe("Balance too low", () => {
                    it("should throw", () => {
                        expect(() => {
                            contract.breakBank()
                        }).toThrow()
                    })
                })
                describe("Valid balance", () => {
                    beforeEach(() => {
                        VMContext.setAttached_deposit(VALID_DEPOSIT)
                        contract.givePenny()
                    })

                    it("should set the piggybank balance to the minimum", () => {
                        contract.breakBank()

                        expect(contract.piggyBank.amount).toBe(u128.Zero)
                    })
                })
                // This test cannot be performed with as-pect, sadly.
                xit("should add the deposited value to the thinker's account balance", () => {
                    VMContext.setSigner_account_id(THINKER)
                    VMContext.setAccount_balance(u128.mul(ONE_NEAR, u128.from(22)))

                    const startBal: u128 = Context.accountBalance

                    contract.breakBank()
                    expect(Context.accountBalance).toBe(startBal)
                })
            })
        })
    })

'''
'''--- src/cert_demo/assembly/__tests__/models.unit.spec.ts ---
import {VMContext, u128} from "near-sdk-as"
import * as Models from "../models"

let bank: Models.PiggyBank,
  thought: Models.Thought,
  thinker: string = 'thinker'

describe("Models", () => {
  describe("Thought", () => {
    describe("#constructor()", () => {
      describe("Invalid params", () => {
        describe("Text empty", () => {
          it("should throw an error", () => {
            const emptyText = ""

            expect(() => {new Models.Thought(emptyText)}).toThrow()
          })
        })
        describe("Text longer than maxLength", () => {
          it("should throw an error", () => {
            expect(() => {
              const tooLongLength: i32 = Models.Thought.maxLength()+1,
                fillerChar: string = "a",
                inputText: string = "".padStart(tooLongLength, fillerChar)

              ;new Models.Thought(inputText)
            }).toThrow()
          })
        })
      })
      it("should set the text to the first parameter", () => {
        const inputText = "I think, therefore..."
        thought = new Models.Thought(inputText)
        expect(thought.text).toBe(inputText)
      })
      it("should set the thinker to the caller", () => {
        const inputText = "something"
        VMContext.setSigner_account_id(thinker)
        thought = new Models.Thought(inputText)

        expect(thought.thinker).toBe(thinker)
      })
    })
  })

  describe("PiggyBank", () => {
    beforeEach(() => {
      bank = new Models.PiggyBank()
    })
    describe("#constructor()", () => {
      it("should initialize the amount to 0", () => {
        expect(bank.amount).toBe(u128.Zero)
      })  
    })
    describe("#deposit()", () => {
      it("should increase the amount by the deposit amount", () => {
        
        bank.deposit(u128.from(5))

        expect(bank.amount).toBe(u128.from(5))
      })
    })
    describe("#refresh()", () => {
      beforeEach(() => {
        bank.amount = u128.from(88)
      })
      it("should set the amount to 0", () => {
        bank.refresh()
        expect(bank.amount).toBe(u128.Zero)
      })
    })
  })
})

'''
'''--- src/cert_demo/assembly/index.ts ---
import {logging, Context, u128, PersistentVector, ContractPromiseBatch} from "near-sdk-core"
import { AccountId, ONE_NEAR, XCC_GAS, MIN_ACCOUNT_BALANCE, assert_self, assert_single_promise_success} from "../../utils"
import {Thought, PiggyBank} from "./models"

const MAX_PENNY_VALUE: u128 = u128.mul(ONE_NEAR, u128.from(15))

@nearBindgen
export class Contract {
    private thinker: AccountId
    private journal: PersistentVector<Thought>
    private piggyBank: PiggyBank// = new PiggyBank()

    constructor(thinker: AccountId, journal: PersistentVector<Thought> = new PersistentVector<Thought>("t"), piggyBank: PiggyBank = new PiggyBank()) {
        this.thinker = thinker
        this.journal = journal
        this.piggyBank = piggyBank
    }

    @mutateState()
    shareThought(thought: string): bool {
        // Only the thinker may share a thought
        this.assertThinker()

        const deposit = Context.attachedDeposit
        this.assertPennyLimit(deposit)

        assert(thought.length > 0, "Thought can't be blank.")
        assert(thought.length <= Thought.maxLength(), "Thought can't be longer than "+ Thought.maxLength().toString() +"characters.")

        //Put deposit in the piggyBank
        this.piggyBank.deposit(deposit)
        //Add the thought to the journal
        this.journal.push(new Thought(thought))

        return true
    }

    @mutateState
    breakBank(): void {
        this.assertThinker()

        // Have to leave something in the bank for storage staking
        assert(this.piggyBank.amount > u128.Zero, "There's nothing in the bank.")
        
        const theContract = Context.contractName,
            theThinker = ContractPromiseBatch.create(this.thinker)
        
        // Do the thing
        theThinker.transfer(this.piggyBank.amount)
        .then(theContract).function_call("onTransferComplete", "{}", u128.Zero, XCC_GAS)

        this.piggyBank.refresh()
    }

    @mutateState()
    onTransferComplete(): void {
        assert_self()
        assert_single_promise_success()

        logging.log("Transfer completed")
        //this.piggyBank.refresh()
    }

    /*
     * I wouldn't normally use signed ints for args that have no meaningful negative values, but PersistentVector.length returns i32.
     * When in Rome...
     */
    readThoughts(count: i32=10, skip: i32=0): Thought[] {
        const thoughts: Thought[] = [],
            fetchLimit: i32 = this.journal.length < count ? this.journal.length : count

        for(let i=(this.journal.length-1)-skip; i>=(this.journal.length-skip)-fetchLimit; i--) {
            thoughts.push(this.journal[i])
        }

        return thoughts
    }

    @mutateState
    givePenny(): void {
        const pennies = Context.attachedDeposit

        this.assertPennyLimit(pennies)

        this.piggyBank.deposit(pennies)        
    }

    //Internal
    private assertPennyLimit(amount: u128): void {
        const total = u128.add(amount, this.piggyBank.amount)
        assert(u128.le(amount, MAX_PENNY_VALUE), "Too many pennies for this piggy bank. Try a lower amount")
        assert(u128.le(total, MAX_PENNY_VALUE), "No more room in the piggy bank.")
        assert(u128.ge(amount, u128.Zero), "Negative penny amounts not allowed.")
    }

    private assertThinker(): void {
        const caller = Context.sender
        assert(this.thinker == caller, "You don't appear to be the owner of this journal. Owner: "+ this.thinker +", You: "+ caller)
    }
}

'''
'''--- src/cert_demo/assembly/models.ts ---
import {u128, Context} from "near-sdk-core"
import {AccountId} from "../../utils"

const TEXT_EMPTY_ERR_MSG = "Text can't be empty",
    TEXT_TOO_LONG_ERR_MSG = "Text can't be longer than "+ Thought.maxLength().toString()

@nearBindgen
export class Thought {
    public static maxLength(): i32 {return 200 as i32}

    public thinker: AccountId
    public text: string

    constructor(text: string) {
        assert(text.length > 0, TEXT_EMPTY_ERR_MSG)
        assert(text.length <= Thought.maxLength(), TEXT_TOO_LONG_ERR_MSG)

        this.text = text
        this.thinker = Context.sender
    }
}

@nearBindgen
export class PiggyBank {
    public amount: u128

    constructor(){
        this.amount = u128.Zero
    }

    deposit(amount: u128): void { 
        this.amount = u128.add(this.amount, amount)
    }

    refresh(): void {
        this.amount = u128.Zero
    }
}

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME ||'cert_demo.jasontduncan.testnet'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/** DISCLAIMER **/
/* I didn't write the code herein, and make no claim to the contrary
* I copied this file, wholesale, from https://raw.githubusercontent.com/Learn-NEAR/NCD.L1.sample--thanks/main/src/utils.ts
* Since this project is a demonstration of coding for the Near platform, and since I'd have to duplicate, verbatim, the parts I've
* reused, I feel justified in having copied this file. Even though I didn't use all of the functionality included, I left the code
* untouched to further make it clear that it is a direct copy, and I wrote none of it.
** END DISCLAIMER **
*/

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''