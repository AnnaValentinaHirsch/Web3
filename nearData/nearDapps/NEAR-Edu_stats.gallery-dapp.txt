*GitHub Repository "NEAR-Edu/stats.gallery-dapp"*

'''--- Cargo.toml ---
[package]
name = "stats-gallery-contract"
version = "0.1.0"
edition = "2021"
authors = ["Jacob Lindahl <jacob@near.foundation>"]

[dependencies]
near-sdk = "4.0.0-pre.4"
near-contract-standards = "4.0.0-pre.4"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# stats.gallery Sponsored Badges Smart Contract

This smart contract allows anyone to submit a proposal for a certain action with an attached deposit. These are called "sponsorship proposals," and the attached action is called an "action request." The owner of the smart contract has the ability to accept or reject a proposal within its designated validity period ("duration"). Until the proposal is accepted or rejected ("resolved"), the original author of the proposal may rescind it, receiving their deposit back as well.

The sponsorship and ownership parts of the contract are cleanly separated from the stats.gallery-specific implementation, allowing for easy reuse of these features in other smart contracts.

# Required Software

* Rust 1.56
* Cargo 1.56
* Node.js 14
* NPM 8
* NEAR CLI 3.1.0

# Build

```txt
$ ./build.sh
```

# Deploy

Set the `OWNER_ID` environment variable to the ID of the account to which you wish to assign ownership of the contract deployment.

## Testnet

```txt
$ OWNER_ID=your-account-id.testnet ./dev-deploy.sh
```

## Mainnet

```txt
$ OWNER_ID=your-account-id.near ./deploy.sh
```

# Usage

See [`/example-proposals`](/example-proposals) for example argument JSON.

Sponsorship-related methods are prefixed with `spo_`, and ownership-related methods with `own_`.

* An author wants to propose a badge, so they call `spo_submit(submission)` to submit a proposal.
* An author wants to rescind a badge proposal, so they call `spo_rescind(id)` with the ID of the proposal they wish to rescind.
* Someone wants to view a proposal, so they call `spo_get_proposal(id)` with the ID of the proposal they wish to view.
* The owner wants to reject a proposal, so they call `spo_reject(id)` with the ID of the proposal they wish to reject.
* The owner wants to accept a proposal, so they call `spo_accept(id)` with the ID of the proposal they wish to accept.
* The owner wants to transfer ownership of the contract, so they call `own_propose_owner(account_id)` with the ID of the account they wish to nominate for owner.
* A proposed owner wishes to accept ownership of a contract, so they call `own_accept_owner()` and ownership is transferred to the proposed account.

If you wish to explore and easily interact with this contract, I recommend you deploy it to testnet, and then visit the [stats.gallery contract page](https://stats.gallery/testnet/dev-1642129686546-74039727190323/contract) for it (be sure to input the account ID of *your* deployment, not the sample).

# Authors

* Jacob Lindahl <jacob@near.foundation> [@sudo_build](https://twitter.com/sudo_build)

# License

GPL-3.0-only

'''
'''--- build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release

'''
'''--- deploy.sh ---
#!/usr/bin/env bash

wasm_path="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $wasm_path \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- dev-deploy.sh ---
#!/usr/bin/env bash

wasm_path="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near dev-deploy \
  --wasmFile $wasm_path \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" --accountId "$(<./neardev/dev-account)"

'''
'''--- example-proposals/badge-create.json ---
{
  "description": "This is a sponsorship proposal",
  "tag": "badge_create",
  "msg": {
    "Create": {
      "id": "my-badge-01",
      "group_id": "my-badge",
      "name": "Cool Badge",
      "description": "This is a badge you earn from doing cool stuff",
      "start_at": null,
      "duration": 3888000000000000
    }
  },
  "duration": "3888000000000000",
  "deposit": "4500000000000000000000000"
}

'''
'''--- example-proposals/badge-extend.json ---
{
  "description": "This is a sponsorship proposal",
  "tag": "badge_extend",
  "msg": {
    "Extend": {
      "id": "my-badge-01",
      "duration": 1036800000000000
    }
  },
  "duration": "3888000000000000",
  "deposit": "1200000000000000000000000"
}

'''
'''--- init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

const owner_id = process.env['OWNER_ID'];

console.log(
  JSON.stringify({
    owner_id,
    proposal_duration: ONE_DAY * 7 + '', // 7 days
    badge_rate_per_day: ONE_NEAR / 10n + '', // 0.1 NEAR
    badge_max_active_duration: ONE_DAY * 90 + '', // 90 days
    badge_min_creation_deposit: (ONE_NEAR * 5n) / 2n + '', // 2.5 NEAR
  }),
);

'''
'''--- near-verify.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm" | head -1)"

cp $WASM_PATH "$1"

'''
'''--- src/contract.rs ---
use crate::impl_ownership;
use crate::*;

pub const TAG_BADGE_CREATE: &'static str = "badge_create";
pub const TAG_BADGE_EXTEND: &'static str = "badge_extend";

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    OWNERSHIP,
    SPONSORSHIP,
    BADGES,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Badge {
    pub id: String,
    pub group_id: String,
    pub name: String,
    pub description: String,
    pub is_enabled: bool,
    pub created_at: u64,
    pub start_at: u64,
    pub duration: Option<u64>,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum BadgeAction {
    Create(BadgeCreate),
    Extend(BadgeExtend),
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct BadgeCreate {
    pub id: String,
    pub group_id: String,
    pub name: String,
    pub description: String,
    pub start_at: Option<u64>,
    pub duration: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct BadgeExtend {
    pub id: String,
    pub duration: u64,
}

impl Badge {
    pub fn is_expired(&self, now: u64) -> bool {
        match self.duration {
            Some(duration) => self.created_at + duration < now,
            _ => false, // No duration = never expires
        }
    }
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct StatsGallery {
    ownership: Ownership,
    sponsorship: Sponsorship<BadgeAction>,
    badges: UnorderedMap<String, Badge>,
    badge_rate_per_day: Balance,
    badge_max_active_duration: u64,
    badge_min_creation_deposit: Balance,
}

const DAY: u64 = 1_000_000_000 * 60 * 60 * 24;

// Basically unstable_div_ceil
pub fn billable_days_in_duration(duration: u64) -> u64 {
    duration / DAY + if duration % DAY > 0 { 1 } else { 0 }
}

macro_rules! extract_msg {
    ($proposal: ident, $enum: ident, $variant: ident) => {
        match &$proposal.msg {
            Some($enum::$variant(value)) => value,
            Some(..) => env::panic_str("tag mismatch"),
            _ => env::panic_str("msg value required"),
        }
    };
}

#[near_bindgen]
impl StatsGallery {
    #[init]
    pub fn new(
        owner_id: AccountId,
        proposal_duration: U64,
        badge_rate_per_day: U128,
        badge_max_active_duration: U64,
        badge_min_creation_deposit: U128,
    ) -> Self {
        Self {
            ownership: Ownership::new(StorageKey::OWNERSHIP, owner_id),
            sponsorship: Sponsorship::new(
                StorageKey::SPONSORSHIP,
                vec![TAG_BADGE_CREATE.to_string(), TAG_BADGE_EXTEND.to_string()],
                Some(proposal_duration.into()),
            ),
            badges: UnorderedMap::new(StorageKey::BADGES),
            badge_rate_per_day: badge_rate_per_day.into(),
            badge_max_active_duration: badge_max_active_duration.into(),
            badge_min_creation_deposit: badge_min_creation_deposit.into(),
        }
    }

    pub fn get_badges(&self) -> Vec<Badge> {
        let now = env::block_timestamp();

        self.badges
            .values()
            .filter(|b| b.is_enabled && !b.is_expired(now))
            .collect()
    }

    pub fn get_badge(&self, badge_id: String) -> Option<Badge> {
        self.badges.get(&badge_id)
    }

    #[payable]
    pub fn set_badge_is_enabled(&mut self, badge_id: String, is_enabled: bool) -> Badge {
        assert_one_yocto();
        self.ownership.assert_owner();

        let badge = self
            .badges
            .get(&badge_id)
            .unwrap_or_else(|| env::panic_str("Badge does not exist"));

        let new_badge = Badge {
            is_enabled,
            ..badge
        };

        self.badges.insert(&badge_id, &new_badge);

        new_badge
    }

    #[payable]
    pub fn insert_badge(&mut self, badge: Badge) {
        assert_one_yocto();
        self.ownership.assert_owner();

        self.badges.insert(&badge.id, &badge);
    }

    #[payable]
    pub fn remove_badge(&mut self, badge_id: &String) {
        assert_one_yocto();
        self.ownership.assert_owner();

        self.badges.remove(&badge_id);
    }

    pub fn get_badge_rate_per_day(&self) -> U128 {
        self.badge_rate_per_day.into()
    }

    #[payable]
    pub fn set_badge_rate_per_day(&mut self, badge_rate_per_day: U128) {
        assert_one_yocto();
        self.ownership.assert_owner();
        let badge_rate_per_day = badge_rate_per_day.into();
        require!(badge_rate_per_day > 0, "Badge rate must be greater than 0");

        self.badge_rate_per_day = badge_rate_per_day;
    }

    pub fn get_badge_max_active_duration(&self) -> U64 {
        self.badge_max_active_duration.into()
    }

    #[payable]
    pub fn set_badge_max_active_duration(&mut self, badge_max_active_duration: U64) {
        assert_one_yocto();
        self.ownership.assert_owner();
        let badge_max_active_duration = badge_max_active_duration.into();
        require!(
            badge_max_active_duration > 0,
            "Badge max active duration must be greater than 0"
        );

        self.badge_max_active_duration = badge_max_active_duration;
    }

    pub fn get_badge_min_creation_deposit(&self) -> U128 {
        self.badge_min_creation_deposit.into()
    }

    #[payable]
    pub fn set_badge_min_creation_deposit(&mut self, badge_min_creation_deposit: U128) {
        assert_one_yocto();
        self.ownership.assert_owner();

        self.badge_min_creation_deposit = badge_min_creation_deposit.into();
    }

    #[payable]
    pub fn withdraw_owner(&mut self, amount: U128) -> Promise {
        assert_one_yocto();
        self.ownership.assert_owner();

        // .unwrap() is safe because of assert_owner() call
        let owner = self.ownership.owner.as_ref().unwrap().clone();

        Promise::new(owner).transfer(amount.into())
    }

    fn validate_create_proposal(
        &self,
        proposal: &Proposal<BadgeAction>,
        create_request: &BadgeCreate,
    ) {
        // Ensure unique ID
        require!(
            self.badges.get(&create_request.id).is_none(),
            "Badge ID already exists"
        );

        let now = env::block_timestamp();

        // Validate start_at
        require!(
            create_request.start_at.unwrap_or(now) + create_request.duration > now,
            "Badge active period has already ended",
        );

        // Validate duration
        require!(
            create_request.duration <= self.badge_max_active_duration,
            "Exceeded maximum active duration",
        );

        // Validate deposit
        require!(
            proposal.deposit >= self.badge_min_creation_deposit,
            "Deposit does not meet minimum creation deposit requirement",
        );
        require!(
            proposal.deposit
                >= u128::from(billable_days_in_duration(create_request.duration))
                    * self.badge_rate_per_day,
            "Insufficient deposit for specified duration",
        );
    }

    fn validate_extend_proposal(
        &self,
        proposal: &Proposal<BadgeAction>,
        extend_request: &BadgeExtend,
    ) -> Badge {
        let existing_badge = self
            .badges
            .get(&extend_request.id)
            .unwrap_or_else(|| env::panic_str("Badge ID does not exist"));

        require!(
            existing_badge.duration.is_some(),
            "Cannot extend: Existing badge has no duration (indefinite)"
        );

        let now = env::block_timestamp();

        // Validate duration
        require!(
            u64::saturating_sub(
                existing_badge.start_at
                    + existing_badge.duration.unwrap()
                    + extend_request.duration,
                now
            ) <= self.badge_max_active_duration,
            "Exceeded maximum active duration",
        );

        // Validate deposit
        require!(
            proposal.deposit
                >= u128::from(billable_days_in_duration(extend_request.duration))
                    * self.badge_rate_per_day,
            "Insufficient deposit for specified duration",
        );

        existing_badge
    }

    fn on_proposal_change(&mut self, proposal: &Proposal<BadgeAction>) {
        match (&proposal.status, proposal.tag.as_str()) {
            (ProposalStatus::PENDING, TAG_BADGE_CREATE) => {
                let create_request = extract_msg!(proposal, BadgeAction, Create);
                self.validate_create_proposal(proposal, create_request);
            }
            (ProposalStatus::PENDING, TAG_BADGE_EXTEND) => {
                let extend_request = extract_msg!(proposal, BadgeAction, Extend);
                self.validate_extend_proposal(proposal, extend_request);
            }
            (ProposalStatus::ACCEPTED, TAG_BADGE_CREATE) => {
                let create_request = extract_msg!(proposal, BadgeAction, Create);

                self.validate_create_proposal(proposal, create_request);

                let now = env::block_timestamp();

                self.badges.insert(
                    &create_request.id.clone(),
                    &Badge {
                        id: create_request.id.clone(),
                        group_id: create_request.group_id.clone(),
                        name: create_request.name.clone(),
                        description: create_request.description.clone(),
                        created_at: now,
                        start_at: create_request.start_at.unwrap_or(now),
                        duration: Some(create_request.duration),
                        is_enabled: true,
                    },
                );
            }
            (ProposalStatus::ACCEPTED, TAG_BADGE_EXTEND) => {
                let extend_request = extract_msg!(proposal, BadgeAction, Extend);
                let existing_badge = self.validate_extend_proposal(proposal, extend_request);

                self.badges.insert(
                    &existing_badge.id.clone(),
                    &Badge {
                        duration: Some(existing_badge.duration.unwrap() + extend_request.duration),
                        ..existing_badge
                    },
                );
            }
            _ => {}
        }
    }
}

impl_ownership!(StatsGallery, ownership);
impl_sponsorship!(
    StatsGallery,
    sponsorship,
    BadgeAction,
    ownership,
    on_proposal_change
);

'''
'''--- src/lib.rs ---
use near_sdk::{
    borsh::{self, *},
    collections::*,
    json_types::*,
    serde::{self, *},
    *,
};

mod utils;
use utils::*;

mod ownership;
use ownership::*;

mod sponsorship;
use sponsorship::*;

mod contract;
pub use contract::*;

#[cfg(test)]
mod tests {
    use crate::*;
    use near_sdk::{test_utils::*, testing_env};

    fn contract_account() -> AccountId {
        "contract".parse::<AccountId>().unwrap()
    }

    fn owner_account() -> AccountId {
        "owner".parse::<AccountId>().unwrap()
    }

    fn proposed_owner_account() -> AccountId {
        "proposed_owner".parse::<AccountId>().unwrap()
    }

    fn sponsorship_tags() -> Vec<String> {
        vec![contract::TAG_BADGE_CREATE, contract::TAG_BADGE_EXTEND]
            .iter()
            .map(|x| x.to_string())
            .collect()
    }

    const ONE_DAY: u64 = 1_000_000_000 * 60 * 60 * 24; // nanoseconds
    const BADGE_MAX_ACTIVE_DURATION: u64 = ONE_DAY * 180;
    const PROPOSAL_DURATION: u64 = ONE_DAY * 7;

    const ONE_NEAR: u128 = u128::pow(10, 24);
    const BADGE_RATE_PER_DAY: u128 = ONE_NEAR / 10; // 0.1 NEAR
    const BADGE_MIN_CREATION_DEPOSIT: u128 = ONE_NEAR * 3 / 2; // 1.5 NEAR

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(contract_account())
            .account_balance(15 * ONE_NEAR)
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn create_instance() -> StatsGallery {
        StatsGallery::new(
            owner_account(),
            PROPOSAL_DURATION.into(),
            BADGE_RATE_PER_DAY.into(),
            BADGE_MAX_ACTIVE_DURATION.into(),
            BADGE_MIN_CREATION_DEPOSIT.into(),
        )
    }

    fn calculate_deposit(action: &BadgeAction) -> Balance {
        match action {
            BadgeAction::Create(create_request) => Balance::max(
                BADGE_MIN_CREATION_DEPOSIT,
                Balance::from(billable_days_in_duration(create_request.duration))
                    * BADGE_RATE_PER_DAY,
            ),
            BadgeAction::Extend(extend_request) => {
                Balance::from(billable_days_in_duration(extend_request.duration))
                    * BADGE_RATE_PER_DAY
            }
        }
    }

    fn badge_create() -> BadgeCreate {
        BadgeCreate {
            id: String::from("my-badge-01"),
            group_id: String::from("my-badge"),
            name: String::from("Cool Badge"),
            description: String::from("This is a badge you earn from doing cool stuff"),
            duration: ONE_DAY * 45,
            start_at: None,
        }
    }

    fn badge_extend() -> BadgeExtend {
        BadgeExtend {
            id: String::from("my-badge-01"),
            duration: ONE_DAY * 12,
        }
    }

    fn proposal_submission(action: BadgeAction, tag: String) -> ProposalSubmission<BadgeAction> {
        ProposalSubmission {
            description: "This is a sponsorship proposal".to_string(),
            deposit: U128(calculate_deposit(&action)),
            duration: Some(U64(ONE_DAY * 45)),
            msg: Some(action),
            tag,
        }
    }

    #[test]
    fn instantiate() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let c = create_instance();
        assert_eq!(
            owner_account(),
            c.own_get_owner().unwrap(),
            "Owner should be owner account after instantiation",
        );
        assert_eq!(
            None,
            c.own_get_proposed_owner(),
            "There should be no proposed owner after instantiation",
        );
        assert_eq!(
            0,
            c.spo_get_all_proposals().len(),
            "There should be no sponsorship proposals after instantiation",
        );
        assert_eq!(
            sponsorship_tags(),
            c.spo_get_tags(),
            "Sponsorship tags should be correctly initialized",
        );
        assert_eq!(
            Some(PROPOSAL_DURATION),
            c.spo_get_duration().map(|x| x.into()),
            "Proposal duration should be properly initialized",
        );
        assert_eq!(
            BADGE_MAX_ACTIVE_DURATION,
            u64::from(c.get_badge_max_active_duration()),
            "Badge max active duration should be properly initialized",
        );
        assert_eq!(
            BADGE_MIN_CREATION_DEPOSIT,
            u128::from(c.get_badge_min_creation_deposit()),
            "Badge min creation deposit should be properly initialized",
        );
    }

    #[test]
    #[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
    fn renounce_owner_no_deposit() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_renounce_owner();
    }

    #[test]
    #[should_panic(expected = "Owner only")]
    fn renounce_owner_not_owner() {
        let mut context = get_context(accounts(1));
        context.attached_deposit(1);
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_renounce_owner();
    }

    #[test]
    fn renounce_owner() {
        let mut context = get_context(owner_account());
        context.attached_deposit(1u128.into());
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_renounce_owner();
        assert_eq!(
            None,
            c.own_get_owner(),
            "There should be no owner after renounce"
        );
        assert_eq!(
            None,
            c.own_get_proposed_owner(),
            "There should be no proposed owner after renounce"
        );
    }

    #[test]
    #[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
    fn propose_owner_no_deposit() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_propose_owner(Some(proposed_owner_account()));
    }

    #[test]
    #[should_panic(expected = "Owner only")]
    fn propose_owner_not_owner() {
        let mut context = get_context(accounts(1));
        context.attached_deposit(1);
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_propose_owner(Some(proposed_owner_account()));
    }

    #[test]
    fn propose_owner() {
        let mut context = get_context(owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_propose_owner(Some(proposed_owner_account()));
        assert_eq!(
            owner_account(),
            c.own_get_owner().unwrap(),
            "Owner should not change after proposing new owner"
        );
        assert_eq!(
            proposed_owner_account(),
            c.own_get_proposed_owner().unwrap(),
            "Proposed owner should update after proposing new owner"
        );
    }

    #[test]
    #[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
    fn accept_owner_no_deposit() {
        let mut context = get_context(owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_propose_owner(Some(proposed_owner_account()));

        let context = get_context(proposed_owner_account());
        testing_env!(context.build());
        c.own_accept_owner();
    }

    #[test]
    #[should_panic(expected = "Proposed owner only")]
    fn accept_owner_not_proposed() {
        let mut context = get_context(owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_propose_owner(Some(proposed_owner_account()));

        let mut context = get_context(accounts(2));
        context.attached_deposit(1);
        testing_env!(context.build());
        c.own_accept_owner();
    }

    #[test]
    fn accept_owner() {
        let mut context = get_context(owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());
        let mut c = create_instance();
        c.own_propose_owner(Some(proposed_owner_account()));

        let mut context = get_context(proposed_owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());
        c.own_accept_owner();
        assert_eq!(
            proposed_owner_account(),
            c.own_get_owner().unwrap(),
            "Owner should be proposed owner after accepting change",
        );
        assert_eq!(
            None,
            c.own_get_proposed_owner(),
            "There should be no proposed owner after accepting proposal",
        );
    }

    #[test]
    fn serialize_actions() {
        let submission = proposal_submission(
            BadgeAction::Extend(badge_extend()),
            TAG_BADGE_EXTEND.to_string(),
        );

        log!("{}", serde_json::to_string(&submission).unwrap());
    }

    #[test]
    fn submit_proposal() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context.attached_deposit(u128::from(submission.deposit) + 10u128.pow(22));
        let submission_deposit: u128 = submission.deposit.into();
        testing_env!(context.build());
        let proposal = c.spo_submit(submission);

        assert_eq!(0, proposal.id, "Should be first proposal",);
        assert_eq!(
            "This is a sponsorship proposal".to_string(),
            proposal.description,
            "Should be first proposal",
        );
        assert_eq!(
            submission_deposit, proposal.deposit,
            "Should have attached correct deposit",
        );
        assert_eq!(
            true,
            c.spo_get_all_proposals().contains(&proposal),
            "Should be a member of all proposals",
        );
        assert_eq!(
            true,
            c.spo_get_pending_proposals().contains(&proposal),
            "Should be a member of pending proposals",
        );
        assert_eq!(
            ProposalStatus::PENDING,
            proposal.status,
            "Proposal status should be pending after submission",
        );
        assert_eq!(
            accounts(1),
            proposal.author_id,
            "Proposal author account ID should be that of submitter",
        );
        assert_eq!(
            proposal,
            c.spo_get_proposal(proposal.id.into()).unwrap(),
            "Proposal should be indexed by ID",
        );
    }

    #[test]
    #[should_panic(expected = "Deposit required")]
    fn submit_proposal_no_deposit() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        let context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );

        testing_env!(context.build());
        c.spo_submit(submission);
    }

    #[test]
    #[should_panic(expected = "Insufficient deposit.")]
    fn submit_proposal_insufficient_deposit() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        // Missing deposit for storage
        context.attached_deposit(u128::from(submission.deposit) /* + 10u128.pow(22) */);

        testing_env!(context.build());
        c.spo_submit(submission);
    }

    #[test]
    fn rescind_proposal() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context.attached_deposit(u128::from(submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        let proposal = c.spo_submit(submission);

        let mut context = get_context(accounts(1));
        context.attached_deposit(1);
        testing_env!(context.build());

        let balance_before_rescind = env::account_balance();

        let proposal = c.spo_rescind(proposal.id.into());

        let balance_after_rescind = env::account_balance();

        assert_eq!(
            proposal.deposit,
            balance_before_rescind - balance_after_rescind,
            "Deposit should be returned",
        );
        assert_eq!(
            true,
            c.spo_get_all_proposals().contains(&proposal),
            "Should be a member of all proposals",
        );
        assert_eq!(
            true,
            c.spo_get_rescinded_proposals().contains(&proposal),
            "Should be a member of rescinded proposals",
        );
        assert_eq!(
            ProposalStatus::RESCINDED,
            proposal.status,
            "Proposal status should be rescinded",
        );
    }

    #[test]
    #[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
    fn rescind_proposal_no_deposit() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context.attached_deposit(u128::from(submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        let proposal = c.spo_submit(submission);

        let context = get_context(accounts(1));
        // context.attached_deposit(1);
        testing_env!(context.build());

        c.spo_rescind(proposal.id.into());
    }

    #[test]
    #[should_panic(expected = "Proposal can only be rescinded by original author")]
    fn rescind_proposal_not_author() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context.attached_deposit(u128::from(submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        let proposal = c.spo_submit(submission);

        let mut context = get_context(accounts(2));
        context.attached_deposit(1);
        testing_env!(context.build());

        c.spo_rescind(proposal.id.into());
    }

    #[test]
    fn rescind_proposal_expired() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context
            .attached_deposit(u128::from(submission.deposit) + 10u128.pow(22))
            .block_timestamp(1_000_000_000);

        testing_env!(context.build());
        let proposal = c.spo_submit(submission);

        let mut context = get_context(accounts(1));
        context
            .attached_deposit(1)
            .block_timestamp(1_000_000_000 + PROPOSAL_DURATION + 1);
        testing_env!(context.build());

        c.spo_rescind(proposal.id.into());
    }

    #[test]
    #[should_panic(expected = "Proposal cannot be rescinded")]
    fn rescind_proposal_already_resolved() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context.attached_deposit(u128::from(submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        let proposal = c.spo_submit(submission);

        let mut context = get_context(accounts(1));
        context.attached_deposit(1);
        testing_env!(context.build());

        c.spo_rescind(proposal.id.into());
        // Cannot rescind twice
        c.spo_rescind(proposal.id.into());
    }

    #[test]
    fn create_badge() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        // Submit badge creation request
        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context.attached_deposit(u128::from(submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        let proposal = c.spo_submit(submission);

        // Accept badge creation request
        let mut context = get_context(owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());

        c.spo_accept(proposal.id.into());

        require!(c.get_badges().len() == 1, "There should be one badge",);

        let expected = badge_create();
        let actual = c.get_badge(expected.id.clone());
        require!(
            actual.is_some(),
            "Badge is activated and accessible by its ID",
        );

        let actual = actual.unwrap();

        require!(actual.id == expected.id, "IDs match",);
        require!(
            actual.name == expected.name
                && actual.description == expected.description
                && actual.duration.unwrap() == expected.duration
                && actual.group_id == expected.group_id,
            "Metadata match",
        );
    }

    #[test]
    #[should_panic(expected = "tag mismatch")]
    fn create_badge_tag_mismatch() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        // Submit badge creation request
        let mut context = get_context(accounts(1));
        let submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_EXTEND.to_string(),
        );
        context.attached_deposit(u128::from(submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        c.spo_submit(submission);
    }

    #[test]
    fn extend_badge() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        // Submit badge creation request
        let mut context = get_context(accounts(1));
        let create_submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context.attached_deposit(u128::from(create_submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        let create_proposal = c.spo_submit(create_submission);

        // Accept badge creation request
        let mut context = get_context(owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());

        c.spo_accept(create_proposal.id.into());

        // Submit badge extension request
        let mut context = get_context(accounts(1));
        let extend_submission = proposal_submission(
            BadgeAction::Extend(badge_extend()),
            TAG_BADGE_EXTEND.to_string(),
        );

        context.attached_deposit(u128::from(extend_submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        let extend_proposal = c.spo_submit(extend_submission);

        // Accept badge extension request
        let mut context = get_context(owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());

        c.spo_accept(extend_proposal.id.into());

        let expected_create = badge_create();
        let expected = badge_extend();
        let actual = c.get_badge(expected.id.clone());

        require!(actual.is_some(), "Badge exists after extend",);

        let actual = actual.unwrap();

        require!(expected.id == actual.id, "IDs match",);
        require!(
            actual.duration.unwrap() == expected.duration + expected_create.duration,
            "Duration after extend should be sum of original and extend request"
        );
    }

    #[test]
    #[should_panic(expected = "Exceeded maximum active duration")]
    fn extend_badge_exceeds_max_duration() {
        let context = get_context(owner_account());
        testing_env!(context.build());
        let mut c = create_instance();

        // Submit badge creation request
        let mut context = get_context(accounts(1));
        let create_submission = proposal_submission(
            BadgeAction::Create(badge_create()),
            TAG_BADGE_CREATE.to_string(),
        );
        context.attached_deposit(u128::from(create_submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        let create_proposal = c.spo_submit(create_submission);

        // Accept badge creation request
        let mut context = get_context(owner_account());
        context.attached_deposit(1);
        testing_env!(context.build());

        c.spo_accept(create_proposal.id.into());

        // Submit badge extension request
        let mut context = get_context(accounts(1));
        let original = BadgeExtend {
            duration: BADGE_MAX_ACTIVE_DURATION - badge_create().duration + 1, // should exceed max duration by 1
            ..badge_extend()
        };
        let extend_submission =
            proposal_submission(BadgeAction::Extend(original), TAG_BADGE_EXTEND.to_string());

        context.attached_deposit(u128::from(extend_submission.deposit) + 10u128.pow(22));
        testing_env!(context.build());
        c.spo_submit(extend_submission);
    }
}

'''
'''--- src/ownership.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Ownership {
    pub owner: Option<AccountId>,
    pub proposed_owner: LazyOption<AccountId>,
}

impl Ownership {
    pub fn new<S>(storage_key_prefix: S, owner_id: AccountId) -> Self
    where
        S: IntoStorageKey,
    {
        let k = storage_key_prefix.into_storage_key();

        Self {
            owner: Some(owner_id),
            proposed_owner: LazyOption::new(prefix_key(&k, b"p"), None),
        }
    }

    pub fn assert_owner(&self) {
        require!(
            &env::predecessor_account_id()
                == self
                    .owner
                    .as_ref()
                    .unwrap_or_else(|| env::panic_str("No owner")),
            "Owner only"
        );
    }

    pub fn renounce_owner(&mut self) {
        self.assert_owner();
        self.owner = None;
        self.proposed_owner.remove();
    }

    pub fn propose_owner(&mut self, account_id: Option<AccountId>) {
        self.assert_owner();
        if let Some(a) = account_id {
            self.proposed_owner.set(&a);
        } else {
            self.proposed_owner.remove();
        }
    }

    pub fn accept_owner(&mut self) {
        let proposed_owner = self
            .proposed_owner
            .take()
            .unwrap_or_else(|| env::panic_str("No proposed owner"));
        require!(
            &env::predecessor_account_id() == &proposed_owner,
            "Proposed owner only"
        );
        self.owner = Some(proposed_owner);
    }
}

pub trait Ownable {
    fn own_get_owner(&self) -> Option<AccountId>;
    fn own_get_proposed_owner(&self) -> Option<AccountId>;
    fn own_renounce_owner(&mut self);
    fn own_propose_owner(&mut self, account_id: Option<AccountId>);
    fn own_accept_owner(&mut self);
}

#[macro_export]
macro_rules! impl_ownership {
    ($contract: ident, $ownership: ident) => {
        #[near_bindgen]
        impl Ownable for $contract {
            fn own_get_owner(&self) -> Option<AccountId> {
                self.$ownership.owner.clone()
            }

            fn own_get_proposed_owner(&self) -> Option<AccountId> {
                self.$ownership.proposed_owner.get()
            }

            #[payable]
            fn own_renounce_owner(&mut self) {
                assert_one_yocto();
                self.$ownership.renounce_owner()
            }

            #[payable]
            fn own_propose_owner(&mut self, account_id: Option<AccountId>) {
                assert_one_yocto();
                self.$ownership.propose_owner(account_id);
            }

            #[payable]
            fn own_accept_owner(&mut self) {
                assert_one_yocto();
                self.$ownership.accept_owner();
            }
        }
    };
}

'''
'''--- src/sponsorship.rs ---
use crate::*;

#[derive(
    BorshStorageKey, BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Debug,
)]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalStatus {
    PENDING,
    REJECTED,
    ACCEPTED,
    RESCINDED,
}

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalSubmission<T> {
    pub description: String,
    pub tag: String,
    pub msg: Option<T>,
    pub duration: Option<U64>,
    pub deposit: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Proposal<T>
where
    T: BorshDeserialize + BorshSerialize,
{
    pub id: u64,
    pub description: String,
    pub tag: String,
    pub msg: Option<T>,
    pub author_id: AccountId,
    pub deposit: Balance,
    pub status: ProposalStatus,
    pub created_at: u64,
    pub duration: Option<u64>,
    pub resolved_at: Option<u64>,
}

impl<T> Proposal<T>
where
    T: BorshDeserialize + BorshSerialize,
{
    pub fn is_expired(&self, now: u64) -> bool {
        match self.duration {
            Some(duration) => self.created_at + duration < now,
            None => false,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Sponsorship<T>
where
    T: BorshDeserialize + BorshSerialize,
{
    tags: UnorderedSet<String>,
    proposals: Vector<Proposal<T>>,
    proposal_duration: LazyOption<u64>,
    total_deposits: Balance,
    total_accepted_deposits: Balance,
}

impl<T> Sponsorship<T>
where
    T: BorshDeserialize + BorshSerialize,
{
    pub fn new<S>(storage_key_prefix: S, tags: Vec<String>, proposal_duration: Option<u64>) -> Self
    where
        S: IntoStorageKey,
    {
        let k = storage_key_prefix.into_storage_key();

        let mut tags_set = UnorderedSet::new(prefix_key(&k, b"t"));

        tags_set.extend(tags);

        Self {
            tags: tags_set,
            proposals: Vector::new(prefix_key(&k, b"p")),
            proposal_duration: LazyOption::new(prefix_key(&k, b"d"), proposal_duration.as_ref()),
            total_deposits: 0,
            total_accepted_deposits: 0,
        }
    }

    pub fn get_tags(&self) -> Vec<String> {
        self.tags.to_vec()
    }

    pub fn add_tags(&mut self, tags: Vec<String>) {
        self.tags.extend(tags)
    }

    pub fn remove_tags(&mut self, tags: Vec<String>) {
        for tag in tags {
            self.tags.remove(&tag);
        }
    }

    pub fn get_total_deposits(&self) -> U128 {
        self.total_deposits.into()
    }

    pub fn get_total_accepted_deposits(&self) -> U128 {
        self.total_accepted_deposits.into()
    }

    pub fn get_all(&self) -> Vec<Proposal<T>> {
        self.proposals.to_vec()
    }

    pub fn get_accepted(&self) -> Vec<Proposal<T>> {
        self.proposals
            .iter()
            .filter(|x| x.status == ProposalStatus::ACCEPTED)
            .collect()
    }

    pub fn get_rejected(&self) -> Vec<Proposal<T>> {
        self.proposals
            .iter()
            .filter(|x| x.status == ProposalStatus::REJECTED)
            .collect()
    }

    pub fn get_rescinded(&self) -> Vec<Proposal<T>> {
        self.proposals
            .iter()
            .filter(|x| x.status == ProposalStatus::RESCINDED)
            .collect()
    }

    pub fn get_pending(&self) -> Vec<Proposal<T>> {
        let now = env::block_timestamp();
        self.proposals
            .iter()
            .filter(|x| x.status == ProposalStatus::PENDING && !x.is_expired(now))
            .collect()
    }

    pub fn get_expired(&self) -> Vec<Proposal<T>> {
        let now = env::block_timestamp();
        self.proposals
            .iter()
            .filter(|x| x.status == ProposalStatus::PENDING && x.is_expired(now))
            .collect()
    }

    pub fn get_proposal(&self, id: u64) -> Option<Proposal<T>> {
        self.proposals.get(id)
    }

    pub fn set_duration(&mut self, duration: Option<u64>) {
        if let Some(duration) = duration {
            self.proposal_duration.set(&duration);
        } else {
            self.proposal_duration.remove();
        }
    }

    pub fn get_duration(&self) -> Option<u64> {
        self.proposal_duration.get()
    }

    pub fn rescind(&mut self, id: u64) -> Proposal<T> {
        let proposal = self.proposals.get(id);
        require!(proposal.is_some(), "Proposal does not exist");
        let proposal = proposal.unwrap();
        require!(
            proposal.status == ProposalStatus::PENDING
                || proposal.status == ProposalStatus::REJECTED,
            "Proposal cannot be rescinded"
        );
        require!(
            proposal.author_id == env::predecessor_account_id(),
            "Proposal can only be rescinded by original author"
        );
        let now = env::block_timestamp();

        let resolved = Proposal {
            resolved_at: Some(now),
            status: ProposalStatus::RESCINDED,
            ..proposal
        };

        self.proposals.replace(id, &resolved);

        self.total_deposits -= proposal.deposit;

        let author_id = resolved.author_id.clone();
        log!(
            "Refunding rescinded deposit to {}: {}",
            &author_id,
            &resolved.deposit
        );
        Promise::new(author_id).transfer(resolved.deposit);

        resolved
    }

    fn resolve(&mut self, id: u64, accepted: bool) -> Proposal<T> {
        let proposal = self.proposals.get(id);
        require!(proposal.is_some(), "Proposal does not exist");
        let proposal = proposal.unwrap();
        require!(
            proposal.status == ProposalStatus::PENDING,
            "Proposal has already been resolved"
        );
        let now = env::block_timestamp();
        require!(!proposal.is_expired(now), "Proposal is expired");

        let resolved = Proposal {
            resolved_at: Some(now),
            status: if accepted {
                ProposalStatus::ACCEPTED
            } else {
                ProposalStatus::REJECTED
            },
            ..proposal
        };

        self.proposals.replace(id, &resolved);

        if accepted {
            self.total_accepted_deposits += proposal.deposit;
        }

        resolved
    }

    pub fn accept(&mut self, id: u64) -> Proposal<T> {
        self.resolve(id, true)
    }

    pub fn reject(&mut self, id: u64) -> Proposal<T> {
        self.resolve(id, false)
    }

    pub fn submit(&mut self, submission: ProposalSubmission<T>) -> Proposal<T> {
        let attached_deposit = env::attached_deposit();
        require!(attached_deposit >= 1, "Deposit required");

        let storage_usage_start = env::storage_usage();

        require!(self.tags.contains(&submission.tag), "Tag does not exist");

        let id = self.proposals.len();

        let duration = match (
            self.proposal_duration.get(),
            submission.duration.map(|x| x.into()),
        ) {
            (Some(contract_duration), Some(submission_duration)) => {
                Some(u64::min(contract_duration, submission_duration))
            }
            (Some(d), _) | (_, Some(d)) => Some(d),
            _ => None,
        };

        let submission_deposit = submission.deposit.into();

        let proposal = Proposal {
            id,
            author_id: env::predecessor_account_id(),
            description: submission.description,
            tag: submission.tag,
            msg: submission.msg,
            deposit: submission_deposit,
            created_at: env::block_timestamp(),
            duration,
            resolved_at: None,
            status: ProposalStatus::PENDING,
        };

        self.proposals.push(&proposal);

        let storage_usage_end = env::storage_usage();
        let storage_fee = Balance::from(storage_usage_end.saturating_sub(storage_usage_start))
            * env::storage_byte_cost();
        let total_required_deposit = storage_fee + submission_deposit;
        require!(
            attached_deposit >= total_required_deposit,
            format!(
                "Insufficient deposit. Required: {} yoctoNEAR Received: {} yoctoNEAR",
                &total_required_deposit, &attached_deposit
            )
        );

        let refund = attached_deposit - total_required_deposit;

        log!("Storage fee: {} Refund: {}", &storage_fee, &refund);

        if refund > 0 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }

        self.total_deposits += proposal.deposit;

        proposal
    }
}

pub trait Sponsorable<T>
where
    T: BorshDeserialize + BorshSerialize,
{
    fn spo_get_tags(&self) -> Vec<String>;
    fn spo_add_tags(&mut self, tags: Vec<String>);
    fn spo_remove_tags(&mut self, tags: Vec<String>);
    fn spo_get_total_deposits(&self) -> U128;
    fn spo_get_total_accepted_deposits(&self) -> U128;
    fn spo_get_all_proposals(&self) -> Vec<Proposal<T>>;
    fn spo_get_pending_proposals(&self) -> Vec<Proposal<T>>;
    fn spo_get_accepted_proposals(&self) -> Vec<Proposal<T>>;
    fn spo_get_rejected_proposals(&self) -> Vec<Proposal<T>>;
    fn spo_get_rescinded_proposals(&self) -> Vec<Proposal<T>>;
    fn spo_get_expired_proposals(&self) -> Vec<Proposal<T>>;
    fn spo_get_proposal(&self, id: U64) -> Option<Proposal<T>>;
    fn spo_get_duration(&self) -> Option<U64>;
    fn spo_set_duration(&mut self, duration: Option<U64>);
    fn spo_submit(&mut self, submission: ProposalSubmission<T>) -> Proposal<T>;
    fn spo_accept(&mut self, id: U64) -> Proposal<T>;
    fn spo_reject(&mut self, id: U64) -> Proposal<T>;
    fn spo_rescind(&mut self, id: U64) -> Proposal<T>;
}

#[macro_export]
macro_rules! impl_sponsorship {
    ($contract: ident, $sponsorship: ident, $sponsorship_type: ident, $ownership: ident $(, $on_status_change: ident)? $(,)?) => {
        #[near_bindgen]
        impl Sponsorable<$sponsorship_type> for $contract {
            fn spo_get_tags(&self) -> Vec<String> {
                self.$sponsorship.get_tags()
            }

            #[payable]
            fn spo_add_tags(&mut self, tags: Vec<String>) {
                assert_one_yocto();
                self.$ownership.assert_owner();
                self.$sponsorship.add_tags(tags)
            }

            #[payable]
            fn spo_remove_tags(&mut self, tags: Vec<String>) {
                assert_one_yocto();
                self.$ownership.assert_owner();
                self.$sponsorship.remove_tags(tags)
            }

            fn spo_get_total_deposits(&self) -> U128 {
                self.$sponsorship.get_total_deposits()
            }

            fn spo_get_total_accepted_deposits(&self) -> U128 {
                self.$sponsorship.get_total_accepted_deposits()
            }

            fn spo_get_all_proposals(&self) -> Vec<Proposal<$sponsorship_type>> {
                self.$sponsorship.get_all()
            }

            fn spo_get_pending_proposals(&self) -> Vec<Proposal<$sponsorship_type>> {
                self.$sponsorship.get_pending()
            }

            fn spo_get_accepted_proposals(&self) -> Vec<Proposal<$sponsorship_type>> {
                self.$sponsorship.get_accepted()
            }

            fn spo_get_rejected_proposals(&self) -> Vec<Proposal<$sponsorship_type>> {
                self.$sponsorship.get_rejected()
            }

            fn spo_get_rescinded_proposals(&self) -> Vec<Proposal<$sponsorship_type>> {
                self.$sponsorship.get_rescinded()
            }

            fn spo_get_expired_proposals(&self) -> Vec<Proposal<$sponsorship_type>> {
                self.$sponsorship.get_expired()
            }

            fn spo_get_proposal(&self, id: U64) -> Option<Proposal<$sponsorship_type>> {
                self.$sponsorship.get_proposal(id.into())
            }

            fn spo_get_duration(&self) -> Option<U64> {
                self.$sponsorship.get_duration().map(|x| x.into())
            }

            #[payable]
            fn spo_set_duration(&mut self, duration: Option<U64>) {
                assert_one_yocto();
                self.$sponsorship.set_duration(duration.map(|x| x.into()))
            }

            #[payable]
            fn spo_submit(&mut self, submission: ProposalSubmission<$sponsorship_type>) -> Proposal<$sponsorship_type> {
                // submit manages its own deposit requirements
                let proposal = self.$sponsorship.submit(submission);
                $(self.$on_status_change(&proposal);)?
                proposal
            }

            #[payable]
            fn spo_accept(&mut self, id: U64) -> Proposal<$sponsorship_type> {
                assert_one_yocto();
                self.$ownership.assert_owner();
                let proposal = self.$sponsorship.accept(id.into());
                $(self.$on_status_change(&proposal);)?
                proposal
            }

            #[payable]
            fn spo_reject(&mut self, id: U64) -> Proposal<$sponsorship_type> {
                assert_one_yocto();
                self.$ownership.assert_owner();
                let proposal = self.$sponsorship.reject(id.into());
                $(self.$on_status_change(&proposal);)?
                proposal
            }

            #[payable]
            fn spo_rescind(&mut self, id: U64) -> Proposal<$sponsorship_type> {
                assert_one_yocto();
                let proposal = self.$sponsorship.rescind(id.into());
                $(self.$on_status_change(&proposal);)?
                proposal
            }
        }
    };
}

'''
'''--- src/utils.rs ---
pub(crate) fn prefix_key(prefix: &Vec<u8>, key: &[u8]) -> Vec<u8> {
  [prefix as &[u8], key].concat()
}

'''