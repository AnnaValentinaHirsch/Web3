*GitHub Repository "here-wallet/ipfs-cache-server"*

'''--- README.md ---
# Cache server for IPFS images
This server provides caching functionality for IPFS images using FastAPI and Docker.

**Tutorial:** https://dev.to/pvolnov/setup-ipfs-images-cache-server-in-5-min-4n8f

## Prerequisites
Before deploying the service, ensure that you have the following prerequisites installed:

- Docker
- Docker Compose
- `sudo apt install -y pngquant`

## Getting started
Setup configuration config.yml:

Open the config.yml file and update the following configuration parameters:
- `folder_size:` The maximum cache size in MB.
- `cache_folder:` The path to the cache folder (default is ./cache).
- `image_server_prefix:` web link to ngnix server to share images from cache folder
- `max_size:` The maximum number of images in the cache folder.
Set cache folder path in `docker-compose.yml:`

Open the docker-compose.yml file and update the volume mapping to your desired cache folder path:
yaml

```
volumes:
  - /var/www/here-storage/cache:/workdir/cache
```
Set up Nginx to publish images from the cache folder.

## Run the server:

`docker-compose up`

##  Verify that the service is running:

The service will be accessible at http://0.0.0.0:7001.

##  How to use

1. Make all requests via cache server, create url `https://<image server>/url?sz=XXX`

**Example**
- `server-url:` https://image.herewallet.app
- `ipfs url:` https://nftstorage.link/ipfs/bafybeieboqph4qqf2n7lasq4ehn6snke2nhdqzde4i4hlywwd3dd7mcjma/U1307.png
- `ipfs id:` nftstorage.link/ipfs/bafybeieboqph4qqf2n7lasq4ehn6snke2nhdqzde4i4hlywwd3dd7mcjma/U1307.png
- `size:` 512*512

Result: https://image.herewallet.app/nftstorage.link/ipfs/bafybeieboqph4qqf2n7lasq4ehn6snke2nhdqzde4i4hlywwd3dd7mcjma/U1307.png?sz=512

## Contributing

Contributions are welcome! If you find any issues or want to contribute new features, feel
'''
'''--- config.yml ---
folder_size: 10240
cache_folder: ./cache
upload: ./upload
max_size: 10000
image_server_prefix: https://storage.herewallet.app/cache/
upload_server_prefix: https://storage.herewallet.app/upload/
'''
'''--- docker-compose.yml ---
version: '3.7'
volumes:
  pg-data:

services:
  web:
    build:
      context: .
    volumes:
      - /var/www/here/storage/cache:/workdir/cache
      - /var/www/here/storage/upload:/workdir/upload
    command: "python3 src/run_web.py"
    restart: always
    ports:
      - "7001:7001"
'''
'''--- requirements.txt ---
aiofiles==23.2.1
aiohttp==3.9.1
aiosignal==1.3.1
annotated-types==0.6.0
anyio==3.6.2
attrs==23.2.0
base58==2.1.1
click==8.1.7
fastapi==0.108.0
frozenlist==1.4.1
h11==0.14.0
idna==3.6
loguru==0.7.2
multidict==6.0.4
Pillow==9.5.0
pngquant==1.0.7
pydantic==2.5.3
pydantic_core==2.14.6
python-multipart==0.0.6
PyYAML==6.0.1
sniffio==1.3.0
sse-starlette==1.2.1
starlette==0.32.0.post1
typing_extensions==4.9.0
uvicorn==0.25.0
yarl==1.9.4
'''
'''--- src/routes.py ---
import datetime
import os
import shutil
import uuid
from io import BytesIO
from typing import Optional
from urllib.parse import quote

import aiofiles as aiofiles
import aiohttp
import yaml
from fastapi import APIRouter, HTTPException
from loguru import logger
from fastapi import UploadFile, File
from starlette.requests import Request
from starlette.responses import RedirectResponse, JSONResponse, HTMLResponse
from PIL import Image
import pngquant

router = APIRouter()

with open("config.yml", "r") as config_file:
    CONFIG = yaml.safe_load(config_file)

with open("upload_form.html", "r") as f:
    UPLOAD_PAGE = f.read()

@router.post("/upload-h9efy921h92")
async def upload_file(photo: UploadFile = File(...)):
    file_extension = os.path.splitext(photo.filename)[1]
    random_filename = f"{uuid.uuid4()}{file_extension}"
    file_location = CONFIG["upload"] + f"/{random_filename}"

    # Ensure the upload directory exists
    os.makedirs(os.path.dirname(file_location), exist_ok=True)

    async with aiofiles.open(file_location, "wb") as out_file:
        while content := await photo.read(1024):  # Read chunks of 1024 bytes
            await out_file.write(content)

    await photo.close()
    return JSONResponse(
        status_code=200,
        content={
            "message": f"Photo uploaded successfully to: {CONFIG['upload_server_prefix']}{random_filename}",
            "url": f"{CONFIG['upload_server_prefix']}{random_filename}",
        },
    )

def get_folder_size(folder_path):
    """
    Calculates the total size of a folder in megabytes.

    Args:
        folder_path (str): The path to the folder.

    Returns:
        float: The size of the folder in megabytes.
    """
    total_size = 0
    for path, dirs, files in os.walk(folder_path):
        for file in files:
            file_path = os.path.join(path, file)
            total_size += os.path.getsize(file_path)
    return total_size / 1024 / 1024

def resize_image_async(image_data, target_width):
    image = Image.open(BytesIO(image_data))
    original_width, original_height = image.size
    aspect_ratio = original_width / original_height

    resized_image = image.resize((int(target_width), int(target_width / aspect_ratio)))
    output_buffer = BytesIO()
    resized_image.save(output_buffer, format="PNG")
    resized_image_data = output_buffer.getvalue()
    return resized_image_data

def clean_storage(storage, max_size=10000):
    """
    Cleans up the storage by removing items if the maximum size is exceeded.

    Args:
        storage (dict): The storage dictionary.
        max_size (int): The maximum size of the storage.

    Returns:
        None
    """
    if len(storage) < max_size:
        return

    items = sorted(storage.items(), key=lambda x: x[1])
    for name, _ in items:
        if len(storage) < max_size:
            storage["folder_size"] = get_folder_size(CONFIG["cache_folder"])
            logger.info(f'folder_size: {storage["folder_size"]}')
            return

        cache_path = os.path.join(CONFIG["cache_folder"], name)
        if os.path.exists(cache_path):
            logger.info(f"Removing {name}")
            os.remove(cache_path)
        storage.pop(name, None)

@router.get("/{path:path}")
async def redirect_to_cache(r: Request, path: str, sz: Optional[int] = None):
    """
    Endpoint to redirect requests to cached images.
    Args:
        r (Request): The incoming request.
        path (str): The path to the image.
    Returns:
        RedirectResponse: The redirect response.
    """
    if "upload-h9efy921h92" in path:
        return HTMLResponse(UPLOAD_PAGE)

    url_path = quote(path)
    folder_size = r.app.extra["storage"].get("folder_size", 0)
    if folder_size > CONFIG["folder_size"]:
        logger.error("Not enough memory to cache images")
        return RedirectResponse(url=f"https://{path}")

    name = path.replace("/", "-")
    url_name = url_path.replace("/", "-")
    cache_path = os.path.join(CONFIG["cache_folder"], name)

    if not os.path.exists(cache_path):
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(f"https://{url_path}") as response:
                    if response.status == 200:
                        with open(cache_path, "wb") as f:
                            image = await response.read()
                            f.write(image)
                            pngquant.quant_image(cache_path, cache_path, 50)

                        logger.info(
                            f"Image {path} downloaded and saved to the cache folder."
                        )
                    else:
                        logger.info(f"Failed to download image from {path}")
                        return RedirectResponse(url=f"https://{url_path}")
            except Exception as e:
                logger.exception(e)
                logger.error(f"{e} {url_path}")
                return RedirectResponse(url=f"https://{url_path}")

    if sz:
        name = f"{sz}-" + name
        url_name = f"{sz}-" + url_name

        rs_cache_path = os.path.join(CONFIG["cache_folder"], name)
        if not os.path.exists(rs_cache_path):
            with open(cache_path, "rb") as f:
                image = resize_image_async(f.read(), int(sz))
            with open(rs_cache_path, "wb") as f:
                f.write(image)

    r.app.extra["storage"][name] = datetime.datetime.utcnow().timestamp()
    clean_storage(r.app.extra["storage"], max_size=CONFIG["max_size"])
    return RedirectResponse(url=f"{CONFIG['image_server_prefix']}{url_name}")

'''
'''--- src/run_web.py ---
#!/usr/bin/env python3

"""Main app file."""
import json
import os

import uvicorn
from fastapi import FastAPI
from loguru import logger
from starlette.middleware.cors import CORSMiddleware

from routes import router

logger.add(
    "logs/info.log",
    level="INFO",
    rotation="3 days",
    retention="15 days",
    compression="zip",
    enqueue=True,
)

logger.add(
    "logs/debug.log",
    level="DEBUG",
    rotation="3 days",
    retention="15 days",
    compression="zip",
    enqueue=True,
)

logger.add(
    "logs/error.log",
    level="ERROR",
    rotation="3 days",
    retention="15 days",
    compression="zip",
    enqueue=True,
)

if __name__ == "__main__":

    app = FastAPI(title="Cache server")

    async def on_startup(*args):
        logger.info("Backend init")
        storage = {}
        try:
            with open("./cache/.overview.json", "r") as f:
                storage = json.load(f)
        except:
            pass
        app.extra["storage"] = storage

    async def on_shutdown(*args):
        with open("./cache/.overview.json", "w") as f:
            json.dump(app.extra.get("storage"), f)
        logger.info("overview.json saved")

    app.include_router(router, prefix=f"", tags=["web"])
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    app.add_event_handler("startup", on_startup)
    app.add_event_handler("shutdown", on_shutdown)

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=os.getenv("PORT", 7001),
    )

'''
'''--- upload_form.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Photo Upload</title>
    <script>
        function uploadFile() {
            var form = document.getElementById('uploadForm');
            var imageUrl = document.getElementById('imageUrl');
            var formData = new FormData(form);

            fetch('/upload-h9efy921h92', { // Specify your server script URL here
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.ok) {
                    return response.json();
                }
                throw new Error('Network error occurred during data submission!');
            })
            .then(data => {
                imageUrl.textContent = data.url;
                imageUrl.href = data.url;
            })
            .catch((error) => {
                console.error('Error:', error);
                alert('Error uploading file: ' + error.message);
            });
        }
    </script>
</head>
<body>

<form id="uploadForm" enctype="multipart/form-data">
    <input type="file" name="photo" accept="image/*">
    <input type="button" value="Upload" onclick="uploadFile()"><br>
</form>
<a id="imageUrl"></a>
</body>
</html>

'''