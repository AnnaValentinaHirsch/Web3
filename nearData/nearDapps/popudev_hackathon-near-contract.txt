*GitHub Repository "popudev/hackathon-near-contract"*

'''--- Cargo.toml ---
[package]
name = "vbiacademy"
version = "0.1.0"
edition = "2021"
authors = ["Dang Quang Vu <eamondang@gmail.com>"]
repository = "https://gitlab.com/vbi-academy/contract"
description = "The Contract For E-Learning platform - VBI Academy"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.1.1"
unidecode = "0.3.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- Makefile.toml ---
[tasks.clean]
clear = true
script = """
cargo clean
rm -rf ./neardev/
rm -rf ./target/
"""

[tasks.prepare]
script = """
#!/bin/bash
rustup target add wasm32-unknown-unknown && rustup install 1.69 && rustup default 1.69 && cargo --version
"""

[tasks.build]
command = "cargo"
args = ["build", "--target", "wasm32-unknown-unknown", "--release"]

[tasks.dev-deploy]
dependencies = ["build"]
script = """
#!/bin/bash

set -e
WASM_PATH="$(find ./target/wasm32-unknown-unknown/release -maxdepth 1 -name "*.wasm")"

near dev-deploy --wasmFile $WASM_PATH
"""

[tasks.call]
script = """
#!/bin/bash

set -e
[ -f ./neardev/dev-account ] || (echo "Contract must be deployed"; false)
near call "$(<./neardev/dev-account)" "$@"
"""

[tasks.call-self]
script = """
#!/bin/bash

set -e
[ -f ./neardev/dev-account ] || (echo "Contract must be deployed"; false)
near call "$(<./neardev/dev-account)" "$@" --accountId "$(<./neardev/dev-account)"
"""

[tasks.view]
script = """
#!/bin/bash

set -e
[ -f ./neardev/dev-account ] || (echo "Contract must be deployed"; false)
near view "$(<./neardev/dev-account)" "$@"
"""
'''
'''--- rust-toolchain.toml ---
[toolchain]
channel = "1.69.0"
profile = "default"
targets = ["wasm32-unknown-unknown"]
'''
'''--- rustfmt.toml ---
# Rust edition 2021
use_small_heuristics = "Max"
reorder_imports = true
edition = "2021"
version = "Two"

# Use Unix style newlines, with 2 spaces tabulation.
newline_style = "Unix"
tab_spaces = 2
hard_tabs = false

# Make one line functions in a single line
fn_single_line = true

# Format strings
format_strings = true

# Increase the max line width
max_width = 100
comment_width = 100

# Merge nested imports
merge_imports = true

# Enum and Struct alignement
enum_discrim_align_threshold = 20
struct_field_align_threshold = 20

# Reorder impl items: type > const > macros > methods.
reorder_impl_items = true

# Comments and documentation formating
format_code_in_doc_comments = true
match_block_trailing_comma = true
normalize_doc_attributes = true
error_on_line_overflow = true
normalize_comments = true
report_fixme = "Always"
wrap_comments = true
todo = "Always"

'''
'''--- src/application/mod.rs ---
pub mod repository;
pub mod services;

'''
'''--- src/application/repository/internal_major.rs ---
use near_sdk::{borsh::BorshSerialize, collections::UnorderedSet, AccountId};

use crate::models::{
  contract::{ContractStorageKey, SuperSchoolContract},
  major::MajorId,
  subject::SubjectId,
  user::UserId,
};

use super::hash_string;

impl SuperSchoolContract {
  pub(crate) fn internal_add_student_to_major(&mut self, major_id: &String, user_id: &AccountId) {
    let major_student_id = format!("{}{}", &major_id, &user_id);
    let mut users_set = self.students_per_major.get(&major_id).unwrap_or_else(|| {
      UnorderedSet::new(
        ContractStorageKey::StudentsPerMajorInter {
          major_student_id_hash: hash_string(&major_student_id),
        }
        .try_to_vec()
        .unwrap(),
      )
    });

    users_set.insert(user_id);

    self.students_per_major.insert(major_id, &users_set);
  }

  pub(crate) fn internal_add_subject_to_major(
    &mut self,
    subject_id: &SubjectId,
    major_id: &MajorId,
  ) {
    let subject_major_id_hash = hash_string(&format!("{}{}", &subject_id, &major_id));
    let mut set = self.subjects_per_major.get(&major_id).unwrap_or_else(|| {
      UnorderedSet::new(
        ContractStorageKey::SubjectsPerMajorInter { subject_major_id_hash }.try_to_vec().unwrap(),
      )
    });

    set.insert(subject_id);

    self.subjects_per_major.insert(major_id, &set);
  }
}

'''
'''--- src/application/repository/internal_score.rs ---
use near_sdk::{borsh::BorshSerialize, collections::UnorderedSet, AccountId};

use crate::models::{
  contract::{ContractStorageKey, SuperSchoolContract},
  score::ScoreId,
  subject::{self, SubjectId},
  user::UserId,
};

use super::hash_string;

impl SuperSchoolContract {
  pub(crate) fn internal_add_score_to_user(&mut self, user_id: &AccountId, score_id: &ScoreId) {
    let score_student_id = format!("{}{}", &score_id, &user_id);
    let mut set = self.scores_per_user.get(&user_id).unwrap_or_else(|| {
      UnorderedSet::new(
        ContractStorageKey::ScoresPerUserInter {
          score_student_id_hash: hash_string(&score_student_id),
        }
        .try_to_vec()
        .unwrap(),
      )
    });

    set.insert(score_id);

    self.scores_per_user.insert(user_id, &set);
  }

  pub(crate) fn internal_add_score_to_subject(
    &mut self,
    score_id: &ScoreId,
    subject_id: &SubjectId,
  ) {
    let score_subject_id_hash = hash_string(&format!("{}{}", &score_id, &subject_id));
    let mut set = self.scores_per_subject.get(&subject_id).unwrap_or_else(|| {
      UnorderedSet::new(
        ContractStorageKey::ScoresPerSubjectInter { score_subject_id_hash }.try_to_vec().unwrap(),
      )
    });

    set.insert(score_id);

    self.scores_per_subject.insert(subject_id, &set);
  }
}

'''
'''--- src/application/repository/internal_subject.rs ---
use near_sdk::{borsh::BorshSerialize, collections::UnorderedSet, AccountId};

use crate::models::{
  contract::{ContractStorageKey, SuperSchoolContract},
  subject::SubjectId,
  user::UserId,
};

use super::hash_string;

impl SuperSchoolContract {
  pub(crate) fn internal_add_student_to_subject(
    &mut self,
    student_id: &UserId,
    subject_id: &SubjectId,
  ) {
    let student_subject_id = format!("{}{}", &student_id, &subject_id);
    let mut set = self.students_per_subject.get(&subject_id).unwrap_or_else(|| {
      UnorderedSet::new(
        ContractStorageKey::StudentsPerSubjectInter {
          student_subject_id_hash: hash_string(&student_subject_id),
        }
        .try_to_vec()
        .unwrap(),
      )
    });

    set.insert(student_id);

    self.students_per_subject.insert(subject_id, &set);
  }
}

'''
'''--- src/application/repository/internal_user.rs ---
use near_sdk::{borsh::BorshSerialize, collections::UnorderedSet, AccountId};

use crate::models::{
  contract::{ContractStorageKey, SuperSchoolContract},
  subject::SubjectId,
  user::UserId,
};

use super::hash_string;

impl SuperSchoolContract {
  pub(crate) fn internal_add_subject_to_user(&mut self, subject_id: &SubjectId, user_id: &UserId) {
    let subject_user_id = format!("{}{}", &subject_id, &user_id);
    let mut set = self.subjects_per_user.get(&user_id).unwrap_or_else(|| {
      UnorderedSet::new(
        ContractStorageKey::SubjectsPerUserInter {
          subject_student_id_hash: hash_string(&subject_user_id),
        }
        .try_to_vec()
        .unwrap(),
      )
    });

    set.insert(subject_id);

    self.subjects_per_user.insert(user_id, &set);
  }
}

'''
'''--- src/application/repository/mod.rs ---
#![allow(unused)]

use near_sdk::{env, AccountId, CryptoHash};
use unidecode::unidecode;

use crate::models::{
  major::{self, MajorId},
  subject::SubjectId,
  user::UserId,
};

pub mod internal_major;
pub mod internal_score;
pub mod internal_subject;
pub mod internal_user;

pub(crate) fn hash_string(string: &String) -> CryptoHash {
  let mut hash = CryptoHash::default();
  hash.copy_from_slice(&env::sha256(string.as_bytes()));
  hash
}

pub(crate) fn convert_to_score_id(subject_id: &SubjectId, student_id: &UserId) -> String {
  let cert = "score ".to_ascii_lowercase();
  let student_convert = student_id.to_string().to_ascii_lowercase();
  let lowercased = subject_id.to_string().to_ascii_lowercase();
  let result = cert + &lowercased + " " + &student_convert;
  result.replace(' ', "_")
}

pub(crate) fn convert_to_degree_id(student_id: &UserId, major_id: &MajorId) -> String {
  let cert = "degree ".to_ascii_lowercase();
  let student_convert = student_id.to_string().to_ascii_lowercase();
  let lowercased = major_id.to_string().to_ascii_lowercase();
  let result = cert + &lowercased + " " + &student_convert;
  result.replace(' ', "_")
}

'''
'''--- src/application/services/impl_degree.rs ---
use crate::application::repository::convert_to_degree_id;
use crate::models::contract::{SuperSchoolContract, SuperSchoolContractExt};
use crate::models::degree::{DegreeFeatures, DegreeMetadata, DegreeType};
use crate::models::user::{Roles, UserId};
use near_sdk::{env, near_bindgen, Promise, ONE_NEAR};

#[near_bindgen]
impl DegreeFeatures for SuperSchoolContract {
  #[payable]
  fn receive_degree(&mut self) -> Promise {
    let user_id = env::signer_account_id();
    let deposit = env::account_balance();
    assert!(deposit >= 10 * ONE_NEAR, "Bạn chuyển không đủ NEAR");
    assert!(self.user_metadata_by_id.contains_key(&user_id), "Người dùng không tồn tại");

    let student = self.user_metadata_by_id.get(&user_id).unwrap();

    assert!(student.role == Roles::Student, "Người dùng không phải là sinh viên");

    let major_id = student.major_id.unwrap();
    assert!(self.major_metadata_by_id.contains_key(&major_id), "Ngành học không tồn tại");

    let major = self.major_metadata_by_id.get(&major_id).unwrap();

    assert!(
      student.total_credit >= major.number_of_credits_required,
      "Bạn chưa đủ điều kiện để lấy bằng cấp"
    );

    assert!(self.scores_per_user.contains_key(&user_id), "Sinh viên không có bảng điểm");

    let score_ids = self.scores_per_user.get(&user_id).unwrap();
    let mut total_score = 0;

    for score_id in score_ids.iter() {
      let score = self.scores_metadata_by_id.get(&score_id).unwrap();
      total_score += score.score;
    }

    let gpa = (total_score as f64 / score_ids.len() as f64) as u64;
    let mut degree_type = DegreeType::Average;

    if gpa >= 7 {
      degree_type = DegreeType::AboveAverage;
    } else if gpa >= 8 {
      degree_type = DegreeType::Good;
    } else if gpa >= 9 {
      degree_type = DegreeType::Excellent;
    }

    let degree = DegreeMetadata {
      degree_id: convert_to_degree_id(&user_id, &major.major_id),
      school_name: self.metadata_contract.get().unwrap().name,
      degree_type,
      gpa,
      thumbnail: None,
      major_id: major.major_id,
      student_id: user_id.clone(),
      created_at: env::block_timestamp(),
    };

    self.degree_metadata_by_id.insert(&user_id, &degree);

    Promise::new(self.owner_id.clone()).transfer(10 * ONE_NEAR)
  }

  fn get_degree_metadata(&self) -> DegreeMetadata {
    let user_id = env::current_account_id();
    assert!(self.degree_metadata_by_id.contains_key(&user_id), "Người dùng chưa được cấp băng cấp");

    self.degree_metadata_by_id.get(&user_id).unwrap()
  }
}

'''
'''--- src/application/services/impl_major.rs ---
use crate::models::contract::{SuperSchoolContract, SuperSchoolContractExt};
use crate::models::major::{MajorFeatures, MajorMetadata};
use near_sdk::{env, near_bindgen};

#[near_bindgen]
impl MajorFeatures for SuperSchoolContract {
  fn create_major(
    &mut self,
    major_id: String,
    thumbnail: Option<String>,
    name: String,
    description: String,
    number_of_credits_required: u64,
  ) {
    assert!(!self.major_metadata_by_id.contains_key(&major_id), "Ngành học đã tồn tại");

    let major_metadata = MajorMetadata {
      major_id: major_id.clone(),
      name,
      thumbnail,
      description,
      number_of_credits_required,
      number_students_register: 0,
      number_students_studing: 0,
      created_at: env::block_timestamp_ms(),
      updated_at: env::block_timestamp_ms(),
    };

    self.major_ids.insert(&major_id);

    self.major_metadata_by_id.insert(&major_id, &major_metadata);
  }

  fn update_major(
    &mut self,
    major_id: String,
    thumbnail: Option<String>,
    name: Option<String>,
    description: Option<String>,
    number_of_credits_required: Option<u64>,
  ) {
    // let signer_account_id = env::signer_account_id();
    // assert!(self.owner_id == signer_account_id, "Bạn không có quyền chỉnh sửa thông tin");
    assert!(self.major_metadata_by_id.contains_key(&major_id), "Người dùng không tồn tại");

    let mut major = self.major_metadata_by_id.get(&major_id).unwrap();

    major.thumbnail = thumbnail;

    if let Some(name) = name {
      major.name = name;
    }

    if let Some(description) = description {
      major.description = description;
    }

    if let Some(number_of_credits_required) = number_of_credits_required {
      major.number_of_credits_required = number_of_credits_required;
    }

    self.major_metadata_by_id.insert(&major_id, &major);
  }

  fn get_all_major_metadata(&self) -> Vec<MajorMetadata> {
    let mut all_major = Vec::new();

    for major_id in self.major_ids.iter() {
      all_major.push(self.major_metadata_by_id.get(&major_id).unwrap());
    }

    all_major
  }
}

'''
'''--- src/application/services/impl_score.rs ---
use crate::application::repository::convert_to_score_id;
use crate::models::contract::{SuperSchoolContract, SuperSchoolContractExt};
use crate::models::score::{ScoreFeatures, ScoreMetadata};
use crate::models::subject::SubjectId;
use crate::models::user::{UserFeatures, UserId};
use near_sdk::{env, near_bindgen};

#[near_bindgen]
impl ScoreFeatures for SuperSchoolContract {
  fn create_score(
    &mut self,
    instructor_id: UserId,
    student_id: UserId,
    subject_id: SubjectId,
    score: u64,
  ) {
    let signer_account_id = env::signer_account_id();
    assert!(self.owner_id == signer_account_id, "Bạn không phải là Admin");
    assert!(self.user_metadata_by_id.contains_key(&student_id), "Sinh viên không tồn tại");
    assert!(self.user_metadata_by_id.contains_key(&instructor_id), "Giảng viên không tồn tại");
    assert!(self.subject_metadata_by_id.contains_key(&subject_id), "Môn học không tồn tại");

    let mut student = self.user_metadata_by_id.get(&student_id).unwrap();
    assert!(student.active == true, "Sinh viên chưa được duyệt");

    let instructor = self.user_metadata_by_id.get(&instructor_id).unwrap();
    assert!(instructor.active == true, "Giảng viên chưa được duyệt");

    let subject = self.subject_metadata_by_id.get(&subject_id).unwrap();

    let score_metadata = ScoreMetadata {
      score_id: convert_to_score_id(&subject_id, &student_id),
      subject_id,
      student_id,
      instructor_id,
      score,
      created_at: env::block_timestamp_ms(),
      updated_at: env::block_timestamp_ms(),
    };

    if score >= 5 {
      student.subject_ids_studied.push(score_metadata.subject_id.clone());
      student.total_credit += subject.number_of_credits;
      self.update_user_metadate(&student);
    }

    self.scores_metadata_by_id.insert(&score_metadata.score_id, &score_metadata);
    self.internal_add_score_to_user(&score_metadata.student_id, &score_metadata.score_id);
    self.internal_add_score_to_subject(&score_metadata.score_id, &score_metadata.subject_id);
  }

  fn update_score(
    &mut self,
    instructor_id: UserId,
    student_id: UserId,
    subject_id: SubjectId,
    score: u64,
  ) {
    let signer_account_id = env::signer_account_id();
    assert!(self.owner_id == signer_account_id, "Bạn không phải là Admin");
    assert!(self.user_metadata_by_id.contains_key(&student_id), "Sinh viên không tồn tại");
    assert!(self.user_metadata_by_id.contains_key(&instructor_id), "Giảng viên không tồn tại");
    assert!(self.subject_metadata_by_id.contains_key(&subject_id), "Môn học không tồn tại");

    let mut student = self.user_metadata_by_id.get(&student_id).unwrap();
    assert!(student.active == true, "Sinh viên chưa được duyệt");

    let instructor = self.user_metadata_by_id.get(&instructor_id).unwrap();
    assert!(instructor.active == true, "Giảng viên chưa được duyệt");

    let score_metadata = ScoreMetadata {
      score_id: convert_to_score_id(&subject_id, &student_id),
      subject_id,
      student_id,
      instructor_id,
      score,
      created_at: env::block_timestamp_ms(),
      updated_at: env::block_timestamp_ms(),
    };

    if score >= 5 {
      student.subject_ids_studied.push(score_metadata.subject_id.clone());
      self.update_user_metadate(&student);
    }

    self.scores_metadata_by_id.insert(&score_metadata.score_id, &score_metadata);
    self.internal_add_score_to_user(&score_metadata.student_id, &score_metadata.score_id);
  }

  fn get_all_score_metadata_by_user_id(&self, user_id: UserId) -> Vec<ScoreMetadata> {
    let mut all_score = Vec::new();

    if let Some(score_ids) = self.scores_per_user.get(&user_id) {
      for score_id in score_ids.iter() {
        all_score.push(self.scores_metadata_by_id.get(&score_id).unwrap());
      }
    }

    all_score
  }

  fn get_all_score_metadata_by_subject_id(&self, subject_id: SubjectId) -> Vec<ScoreMetadata> {
    let mut all_score = Vec::new();

    if let Some(score_ids) = self.scores_per_subject.get(&subject_id) {
      for score_id in score_ids.iter() {
        all_score.push(self.scores_metadata_by_id.get(&score_id).unwrap());
      }
    }

    all_score
  }
}

'''
'''--- src/application/services/impl_subject.rs ---
use crate::models::contract::{SuperSchoolContract, SuperSchoolContractExt};
use crate::models::major::MajorId;
use crate::models::subject::{SubjectFeatures, SubjectId, SubjectMetadata};
use crate::models::user::{Roles, UserId};
use near_sdk::{env, near_bindgen, Balance, Promise, ONE_NEAR};

#[near_bindgen]
impl SubjectFeatures for SuperSchoolContract {
  fn create_subject(
    &mut self,
    subject_id: SubjectId,
    major_id: MajorId,
    thumbnail: Option<String>,
    prerequisite_subject_id: Option<SubjectId>,
    title: String,
    description: String,
    price: Balance,
    number_of_credits: u64,
  ) {
    let signer_account_id = env::signer_account_id();
    assert!(self.owner_id == signer_account_id, "Bạn không có quyền chỉnh sửa thông tin");
    assert!(self.major_metadata_by_id.contains_key(&major_id), "Ngành học không tồn tại");
    assert!(!self.subject_metadata_by_id.contains_key(&subject_id), "Môn học đã tồn tại");

    let subject_metadata = SubjectMetadata {
      subject_id: subject_id.clone(),
      major_id: major_id.clone(),
      title,
      thumbnail,
      description,
      number_of_credits,
      price,
      balance: None,
      number_students_studying: 0,
      instructor_id: None,
      prerequisite_subject_id,
      created_at: env::block_timestamp_ms(),
      updated_at: env::block_timestamp_ms(),
    };
    self.internal_add_subject_to_major(&subject_id, &major_id);
    self.subject_ids.insert(&subject_id);
    self.subject_metadata_by_id.insert(&subject_id, &subject_metadata);
  }

  fn update_subject(
    &mut self,
    subject_id: SubjectId,
    major_id: Option<MajorId>,
    thumbnail: Option<String>,
    prerequisite_subject_id: Option<SubjectId>,
    title: Option<String>,
    description: Option<String>,
    price: Option<Balance>,
    number_of_credits: Option<u64>,
  ) {
    let signer_account_id = env::signer_account_id();
    assert!(self.owner_id == signer_account_id, "Bạn không có quyền chỉnh sửa thông tin");
    assert!(self.subject_metadata_by_id.contains_key(&subject_id), "Môn học không tồn tại");

    let mut subject = self.subject_metadata_by_id.get(&subject_id).unwrap();

    subject.thumbnail = thumbnail;
    subject.prerequisite_subject_id = prerequisite_subject_id;

    if let Some(major_id) = major_id {
      assert!(self.major_metadata_by_id.contains_key(&major_id), "Ngành học không tồn tại");
      subject.major_id = major_id;
    }

    if let Some(title) = title {
      subject.title = title;
    }

    if let Some(description) = description {
      subject.description = description;
    }

    if let Some(price) = price {
      subject.price = price;
    }

    if let Some(number_of_credits) = number_of_credits {
      subject.number_of_credits = number_of_credits;
    }

    self.subject_metadata_by_id.insert(&subject_id, &subject);
  }

  #[payable]
  fn register_subject(&mut self, subject_id: SubjectId) {
    let user_id = env::signer_account_id();
    assert!(self.user_metadata_by_id.contains_key(&user_id), "Người dùng không tồn tại");
    assert!(self.subject_metadata_by_id.contains_key(&subject_id), "Môn học không tồn tại");

    let student = self.user_metadata_by_id.get(&user_id).unwrap();
    assert!(student.active == true, "Bạn chưa được phép đăng ký môn học");
    assert!(student.role == Roles::Student, "Bạn không phải là sinh viên");

    let deposit = env::account_balance();
    let mut subject = self.subject_metadata_by_id.get(&subject_id).unwrap();
    assert!(deposit >= subject.price * ONE_NEAR, "Bạn chuyển không đủ NEAR");

    if let Some(prerequisite_subject_id) = subject.prerequisite_subject_id.clone() {
      assert!(
        student.subject_ids_studied.contains(&prerequisite_subject_id),
        "Yêu cầu học môn tiên quyết của môn học này"
      );
    }

    let price = subject.price;
    let salary = (subject.price as f64 * 0.5) as u128;

    if let Some(instructor_id) = subject.instructor_id.clone() {
      Promise::new(self.owner_id.clone()).transfer((price - salary) * ONE_NEAR);
      Promise::new(instructor_id).transfer(salary * ONE_NEAR);
    } else {
      Promise::new(self.owner_id.clone()).transfer(price * ONE_NEAR);
      subject.balance = Some(salary);
    }

    subject.number_students_studying += 1;

    self.subject_metadata_by_id.insert(&subject.subject_id, &subject);
    self.internal_add_subject_to_user(&subject_id, &user_id);
    self.internal_add_student_to_subject(&user_id, &subject_id);
  }

  #[payable]
  fn assignment(&mut self, instructor_id: UserId, subject_id: SubjectId) {
    let signer_account_id = env::signer_account_id();
    assert!(self.owner_id == signer_account_id, "Bạn không có quyền chỉnh sửa thông tin");
    assert!(self.user_metadata_by_id.contains_key(&instructor_id), "Người dùng không tồn tại");
    assert!(self.subject_metadata_by_id.contains_key(&subject_id), "Khóa học không tồn tại");

    let instructor = self.user_metadata_by_id.get(&instructor_id).unwrap();
    assert!(instructor.role == Roles::Instructor, "Người dùng này không phải giảng viên");
    assert!(instructor.active == true, "Người dùng này chưa được duyệt");

    let mut subject = self.subject_metadata_by_id.get(&subject_id).unwrap();

    if let Some(balance) = subject.balance.clone() {
      Promise::new(instructor.user_id).transfer(balance * ONE_NEAR);
    }

    subject.balance = None;

    self.internal_add_subject_to_user(&subject_id, &instructor_id);
    subject.instructor_id = Some(instructor_id);
    self.subject_metadata_by_id.insert(&subject_id, &subject);
  }

  fn get_all_subject_metadata(&self) -> Vec<SubjectMetadata> {
    let mut all_subject = Vec::new();

    for subject_id in self.subject_ids.iter() {
      all_subject.push(self.subject_metadata_by_id.get(&subject_id).unwrap());
    }

    all_subject
  }

  fn get_all_subject_metadata_by_user_id(&self, user_id: UserId) -> Vec<SubjectMetadata> {
    let mut all_subject = Vec::new();

    if let Some(subject_ids) = self.subjects_per_user.get(&user_id) {
      for subject_id in subject_ids.iter() {
        all_subject.push(self.subject_metadata_by_id.get(&subject_id).unwrap());
      }
    }

    all_subject
  }

  fn get_all_subject_metadata_by_major_id(&self, major_id: MajorId) -> Vec<SubjectMetadata> {
    let mut all_subject = Vec::new();

    if let Some(subject_ids) = self.subjects_per_major.get(&major_id) {
      for subject_id in subject_ids.iter() {
        if let Some(subject_metadata)  = self.subject_metadata_by_id.get(&subject_id) {
          all_subject.push(subject_metadata);
        }
      }
    }

    all_subject
  }
  fn clean_subject(&mut self) {
    for subject_id in self.subject_ids.iter() {
      self.subject_metadata_by_id.remove(&subject_id);
    }
    self.subject_ids.clear();
  }
}

'''
'''--- src/application/services/impl_user.rs ---
use crate::models::contract::{SuperSchoolContract, SuperSchoolContractExt};
use crate::models::subject::SubjectId;
use crate::models::user::{Roles, UserFeatures, UserId, UserMetadata};
use near_sdk::{env, near_bindgen, Promise, ONE_NEAR};

#[near_bindgen]
impl UserFeatures for SuperSchoolContract {
  fn create_admin_user(
    &mut self,
    username: String,
    password: String,
    full_name: String,
    date_of_birth: String,
    email: String,
    phone: String,
    national_identity_card: String,
    national_identity_card_date: String,
  ) {
    let signer_account_id = env::signer_account_id();
    assert!(self.owner_id == signer_account_id, "Bạn không có quyền tạo quản trị viên");

    let user_metadata = UserMetadata {
      user_id: signer_account_id.clone(),
      username: Some(username.clone()),
      password: Some(password),
      full_name,
      date_of_birth,
      email,
      phone,
      national_identity_card,
      national_identity_card_date,
      active: true,
      total_credit: 99999,
      avatar: None,
      major_id: None,
      balance: 9999,
      role: Roles::Admin,
      subject_ids_studied: Vec::new(),
      created_at: env::block_timestamp_ms(),
      updated_at: env::block_timestamp_ms(),
    };

    self.user_ids.insert(&signer_account_id);

    self.user_metadata_by_id.insert(&signer_account_id, &user_metadata);
    self.user_metadata_by_username.insert(&username, &user_metadata);
  }

  fn create_student_user(
    &mut self,
    user_id: UserId,
    full_name: String,
    date_of_birth: String,
    email: String,
    phone: String,
    national_identity_card: String,
    national_identity_card_date: String,
  ) {
    // let signer_account_id = env::signer_account_id();
    // assert!(self.owner_id == signer_account_id, "Bạn không có quyền thêm người dùng");
    assert!(!self.user_metadata_by_id.contains_key(&user_id), "User has already exists");

    let user_metadata = UserMetadata {
      user_id: user_id.clone(),
      username: None,
      password: None,
      full_name,
      date_of_birth,
      email,
      phone,
      national_identity_card,
      national_identity_card_date,
      active: false,
      total_credit: 0,
      avatar: None,
      major_id: None,
      subject_ids_studied: Vec::new(),
      balance: 0,
      role: Roles::Student,
      created_at: env::block_timestamp_ms(),
      updated_at: env::block_timestamp_ms(),
    };

    self.user_ids.insert(&user_id);

    self.user_metadata_by_id.insert(&user_id, &user_metadata);
  }

  fn create_instructor_user(
    &mut self,
    user_id: UserId,
    full_name: String,
    date_of_birth: String,
    email: String,
    phone: String,
    national_identity_card: String,
    national_identity_card_date: String,
  ) {
    // let signer_account_id = env::signer_account_id();
    // assert!(self.owner_id == signer_account_id, "Bạn không có quyền thêm người dùng");
    assert!(!self.user_metadata_by_id.contains_key(&user_id), "User has already exists");

    let user_metadata = UserMetadata {
      user_id: user_id.clone(),
      username: None,
      password: None,
      full_name,
      date_of_birth,
      email,
      phone,
      national_identity_card,
      national_identity_card_date,
      active: false,
      total_credit: 0,
      avatar: None,
      balance: 0,
      major_id: None,
      subject_ids_studied: Vec::new(),
      role: Roles::Instructor,
      created_at: env::block_timestamp_ms(),
      updated_at: env::block_timestamp_ms(),
    };

    self.user_ids.insert(&user_id);

    self.user_metadata_by_id.insert(&user_id, &user_metadata);
  }

  fn update_user(
    &mut self,
    user_id: UserId,
    full_name: Option<String>,
    date_of_birth: Option<String>,
    email: Option<String>,
    phone: Option<String>,
    national_identity_card: Option<String>,
    national_identity_card_date: Option<String>,
  ) {
    // let signer_account_id = env::signer_account_id();
    // assert!(self.owner_id == signer_account_id, "Bạn không có quyền chỉnh sửa thông tin");
    assert!(self.user_metadata_by_id.contains_key(&user_id), "Người dùng không tồn tại");

    let mut user = self.user_metadata_by_id.get(&user_id).unwrap();

    if let Some(full_name) = full_name {
      user.full_name = full_name;
    }

    if let Some(date_of_birth) = date_of_birth {
      user.date_of_birth = date_of_birth;
    }

    if let Some(email) = email {
      user.email = email;
    }

    if let Some(phone) = phone {
      user.phone = phone;
    }

    if let Some(national_identity_card) = national_identity_card {
      user.national_identity_card = national_identity_card;
    }

    if let Some(national_identity_card_date) = national_identity_card_date {
      user.national_identity_card_date = national_identity_card_date;
    }

    self.update_user_metadate(&user);
  }

  #[private]
  fn update_user_metadate(&mut self, user_metadate: &UserMetadata) {
    self.user_metadata_by_id.insert(&user_metadate.user_id, &user_metadate);

    if let Some(username) = user_metadate.username.clone() {
      self.user_metadata_by_username.insert(&username, &user_metadate);
    }
  }

  #[payable]
  fn register_student_user(&mut self, major_id: String) -> Promise {
    let user_id = env::signer_account_id();
    let deposit = env::account_balance();
    assert!(self.user_metadata_by_id.contains_key(&user_id), "Người dùng không tồn tại");
    assert!(self.major_metadata_by_id.contains_key(&major_id), "Ngành học không tồn tại");
    assert!(self.user_metadata_by_id.contains_key(&user_id), "Người dùng không tồn tại");
    assert!(deposit >= 5 * ONE_NEAR, "Bạn chuyển không đủ NEAR");

    let mut student = self.user_metadata_by_id.get(&user_id).unwrap();
    assert!(student.major_id.is_none(), "Bạn đã đăng ký ngành học");

    student.balance = 5;
    student.major_id = Some(major_id.clone());
    self.update_user_metadate(&student);

    let mut major = self.major_metadata_by_id.get(&major_id).unwrap();
    major.number_students_register += 1;
    self.major_metadata_by_id.insert(&major_id, &major);

    self.internal_add_student_to_major(&major_id, &user_id);

    // Phí đăng ký nhập học
    Promise::new(self.owner_id.clone()).transfer(5 * ONE_NEAR)
  }

  #[payable]
  fn register_instructor_user(&mut self) -> Promise {
    let user_id = env::signer_account_id();
    let deposit = env::account_balance();
    assert!(self.user_metadata_by_id.contains_key(&user_id), "Người dùng không tồn tại");
    assert!(deposit >= 10 * ONE_NEAR, "Bạn chuyển không đủ NEAR");

    let mut instructor = self.user_metadata_by_id.get(&user_id).unwrap();

    instructor.balance = 10;

    self.update_user_metadate(&instructor);

    // Phí đăng ký làm giảng viên
    Promise::new(self.owner_id.clone()).transfer(10)
  }

  fn active_student_user(&mut self, user_id: UserId, username: String, password: String) {
    let signer_account_id = env::signer_account_id();

    assert!(self.owner_id == signer_account_id, "Bạn không có quyền");
    assert!(self.user_metadata_by_id.contains_key(&user_id), "Người dùng không tồn tại");

    let mut student = self.user_metadata_by_id.get(&user_id).unwrap();

    assert!(student.balance == 5, "Sinh viên chưa nộp phí đăng ký");

    student.active = true;
    student.balance = 0;
    student.username = Some(username.clone());
    student.password = Some(password);

    self.user_metadata_by_id.insert(&user_id, &student);
    self.user_metadata_by_username.insert(&username, &student);
  }

  fn active_instructor_user(&mut self, user_id: UserId, username: String, password: String) {
    let signer_account_id = env::signer_account_id();

    assert!(self.owner_id == signer_account_id, "Bạn không có quyền");
    assert!(self.user_metadata_by_id.contains_key(&user_id), "Người dùng không tồn tại");

    let mut instructor = self.user_metadata_by_id.get(&user_id).unwrap();

    assert!(instructor.balance == 10, "Giảng viên này chưa nộp phí đăng ký");

    instructor.active = true;
    instructor.balance = 0;
    instructor.username = Some(username.clone());
    instructor.password = Some(password);

    self.user_metadata_by_id.insert(&user_id, &instructor);
    self.user_metadata_by_username.insert(&username, &instructor);
  }

  fn get_all_user_metadata(&self) -> Vec<UserMetadata> {
    let mut all_user = Vec::new();

    for user_id in self.user_ids.iter() {
      all_user.push(self.user_metadata_by_id.get(&user_id).unwrap());
    }

    all_user
  }

  fn get_user_metadata_by_id(&self, user_id: UserId) -> Option<UserMetadata> {
    if let Some(metadata) = self.user_metadata_by_id.get(&user_id) {
      Some(metadata)
    } else {
      None
    }
  }

  fn get_user_metadata_by_username(&self, username: String) -> Option<UserMetadata> {
    if let Some(metadata) = self.user_metadata_by_username.get(&username) {
      Some(metadata)
    } else {
      None
    }
  }

  fn get_all_student_user_metadata_by_subject_id(
    &self,
    subject_id: SubjectId,
  ) -> Vec<UserMetadata> {
    let mut all_user = Vec::new();

    if let Some(user_ids) = self.students_per_subject.get(&subject_id) {
      for user_id in user_ids.iter() {
        all_user.push(self.user_metadata_by_id.get(&user_id).unwrap());
      }
    }

    all_user
  }

  fn clean_user(&mut self) {
    for user_id in self.user_ids.iter() {
      self.user_metadata_by_id.remove(&user_id);
    }
    self.user_ids.clear();
  }
}

'''
'''--- src/application/services/mod.rs ---
pub mod impl_degree;
pub mod impl_major;
pub mod impl_score;
pub mod impl_subject;
pub mod impl_user;

'''
'''--- src/lib.rs ---
pub mod application;
pub mod models;

use models::contract::{
  ContractStorageKey, SuperSchoolContract, SuperSchoolContractExt, SuperSchoolContractMetadata,
};
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedSet};
use near_sdk::{env, near_bindgen, AccountId};

#[near_bindgen]
impl SuperSchoolContract {
  #[init]
  pub fn init() -> Self {
    let owner_id = env::signer_account_id();
    Self::new(
      owner_id,
      SuperSchoolContractMetadata {
        spec: "Super School v1.0.0".to_string(),
        name: "SaiGon University".to_string(),
        symbol: "SGU".to_string(),
        icon: None,
        base_uri: None,
        reference: None,
        reference_hash: None,
      },
    )
  }

  #[init]
  pub fn new(owner_id: AccountId, metadata: SuperSchoolContractMetadata) -> Self {
    Self {
      owner_id,
      metadata_contract: LazyOption::new(
        ContractStorageKey::ContractMetadata.try_to_vec().unwrap(),
        Some(&metadata),
      ),

      user_ids: UnorderedSet::new(ContractStorageKey::UserIds.try_to_vec().unwrap()),
      user_metadata_by_id: LookupMap::new(
        ContractStorageKey::UserMetadataById.try_to_vec().unwrap(),
      ),
      user_metadata_by_username: LookupMap::new(
        ContractStorageKey::UserMetadataByUsername.try_to_vec().unwrap(),
      ),
      subjects_per_user: LookupMap::new(ContractStorageKey::SubjectsPerUser.try_to_vec().unwrap()),

      major_ids: UnorderedSet::new(ContractStorageKey::MajorIds.try_to_vec().unwrap()),
      major_metadata_by_id: LookupMap::new(
        ContractStorageKey::MajorMetadataById.try_to_vec().unwrap(),
      ),
      subjects_per_major: LookupMap::new(
        ContractStorageKey::SubjectsPerMajor.try_to_vec().unwrap(),
      ),
      students_per_major: LookupMap::new(
        ContractStorageKey::StudentsPerMajor.try_to_vec().unwrap(),
      ),

      subject_ids: UnorderedSet::new(ContractStorageKey::SubjectIds.try_to_vec().unwrap()),
      subject_metadata_by_id: LookupMap::new(
        ContractStorageKey::SubjectMetadataById.try_to_vec().unwrap(),
      ),
      students_per_subject: LookupMap::new(
        ContractStorageKey::StudentsPerSubject.try_to_vec().unwrap(),
      ),
      scores_per_subject: LookupMap::new(
        ContractStorageKey::ScoresPerSubject.try_to_vec().unwrap(),
      ),

      score_ids: UnorderedSet::new(ContractStorageKey::SubjectIds.try_to_vec().unwrap()),
      scores_metadata_by_id: LookupMap::new(
        ContractStorageKey::ScoreMetadataById.try_to_vec().unwrap(),
      ),
      scores_per_user: LookupMap::new(ContractStorageKey::ScoresPerUser.try_to_vec().unwrap()),

      degree_metadata_by_id: LookupMap::new(
        ContractStorageKey::DegreeMetadata.try_to_vec().unwrap(),
      ),
    }
  }
}

'''
'''--- src/models/contract.rs ---
use near_sdk::{
  collections::{LazyOption, LookupMap, UnorderedSet},
  json_types::Base64VecU8,
  near_bindgen,
  serde::{Deserialize, Serialize},
  AccountId, CryptoHash, PanicOnDefault,
};

use crate::borsh::{self, BorshDeserialize, BorshSerialize};

use super::{
  degree::DegreeMetadata,
  major::{MajorId, MajorMetadata},
  score::{ScoreId, ScoreMetadata},
  subject::{SubjectId, SubjectMetadata},
  user::{UserId, UserMetadata},
};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SuperSchoolContractMetadata {
  pub spec: String,
  pub name: String,
  pub symbol: String,
  pub icon: Option<String>,
  pub base_uri: Option<String>,
  pub reference: Option<String>,
  pub reference_hash: Option<Base64VecU8>,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct SuperSchoolContract {
  pub owner_id: AccountId,
  pub metadata_contract: LazyOption<SuperSchoolContractMetadata>,

  pub user_ids: UnorderedSet<UserId>,
  pub user_metadata_by_id: LookupMap<UserId, UserMetadata>,
  pub user_metadata_by_username: LookupMap<String, UserMetadata>,
  pub subjects_per_user: LookupMap<UserId, UnorderedSet<SubjectId>>,
  pub scores_per_user: LookupMap<UserId, UnorderedSet<ScoreId>>,

  pub major_ids: UnorderedSet<MajorId>,
  pub major_metadata_by_id: LookupMap<MajorId, MajorMetadata>,
  pub students_per_major: LookupMap<MajorId, UnorderedSet<UserId>>,
  pub subjects_per_major: LookupMap<MajorId, UnorderedSet<SubjectId>>,

  pub subject_ids: UnorderedSet<SubjectId>,
  pub subject_metadata_by_id: LookupMap<SubjectId, SubjectMetadata>,
  pub students_per_subject: LookupMap<SubjectId, UnorderedSet<UserId>>,
  pub scores_per_subject: LookupMap<SubjectId, UnorderedSet<ScoreId>>,

  pub score_ids: UnorderedSet<ScoreId>,
  pub scores_metadata_by_id: LookupMap<ScoreId, ScoreMetadata>,

  pub degree_metadata_by_id: LookupMap<UserId, DegreeMetadata>,
}

#[derive(BorshSerialize)]
pub enum ContractStorageKey {
  ContractMetadata,
  UserIds,
  UserMetadataById,
  UserMetadataByUsername,
  SubjectsPerUser,
  SubjectsPerUserInter { subject_student_id_hash: CryptoHash },

  MajorIds,
  MajorMetadataById,
  StudentsPerMajor,
  StudentsPerMajorInter { major_student_id_hash: CryptoHash },
  InstructorPerMajor,

  SubjectIds,
  SubjectMetadataById,
  SubjectsPerMajor,
  SubjectsPerMajorInter { subject_major_id_hash: CryptoHash },
  StudentsPerSubject,
  StudentsPerSubjectInter { student_subject_id_hash: CryptoHash },
  ScoresPerSubject,
  ScoresPerSubjectInter { score_subject_id_hash: CryptoHash },

  ScoreIds,
  ScoreMetadataById,
  ScoresPerUser,
  ScoresPerUserInter { score_student_id_hash: CryptoHash },

  DegreeMetadata,
}

'''
'''--- src/models/degree.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::Promise;

use super::user::UserId;

pub type DegreeId = String;

#[derive(Deserialize, BorshDeserialize, BorshSerialize, Serialize, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum DegreeType {
  Average,
  AboveAverage,
  Good,
  Excellent,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct DegreeMetadata {
  pub degree_id: String,
  pub degree_type: DegreeType,
  pub gpa: u64,
  pub thumbnail: Option<String>,
  pub school_name: String,
  pub major_id: String,
  pub student_id: UserId,
  pub created_at: u64,
}

pub trait DegreeFeatures {
  fn receive_degree(&mut self) -> Promise;
  fn get_degree_metadata(&self) -> DegreeMetadata;
}

'''
'''--- src/models/major.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

pub type MajorId = String;

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct MajorMetadata {
  pub major_id: MajorId,
  pub thumbnail: Option<String>,
  pub name: String,
  pub description: String,
  pub number_of_credits_required: u64,
  pub number_students_register: u64,
  pub number_students_studing: u64,
  pub created_at: u64,
  pub updated_at: u64,
}

pub trait MajorFeatures {
  fn create_major(
    &mut self,
    major_id: String,
    thumbnail: Option<String>,
    name: String,
    description: String,
    number_of_credits_required: u64,
  );

  fn update_major(
    &mut self,
    major_id: String,
    thumbnail: Option<String>,
    name: Option<String>,
    description: Option<String>,
    number_of_credits_required: Option<u64>,
  );

  fn get_all_major_metadata(&self) -> Vec<MajorMetadata>;
}

'''
'''--- src/models/mod.rs ---
pub mod contract;
pub mod degree;
pub mod major;
pub mod score;
pub mod subject;
pub mod user;

'''
'''--- src/models/score.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use super::subject::SubjectId;
use super::user::UserId;

pub type ScoreId = String;

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ScoreMetadata {
  pub score_id: ScoreId,
  pub subject_id: SubjectId,
  pub student_id: UserId,
  pub instructor_id: UserId,
  pub score: u64,
  pub created_at: u64,
  pub updated_at: u64,
}

pub trait ScoreFeatures {
  fn create_score(
    &mut self,
    instructor_id: UserId,
    student_id: UserId,
    subject_id: SubjectId,
    score: u64,
  );

  fn update_score(
    &mut self,
    instructor_id: UserId,
    student_id: UserId,
    subject_id: SubjectId,
    score: u64,
  );

  fn get_all_score_metadata_by_user_id(&self, user_id: UserId) -> Vec<ScoreMetadata>;

  fn get_all_score_metadata_by_subject_id(&self, subject_id: SubjectId) -> Vec<ScoreMetadata>;
}

'''
'''--- src/models/subject.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::Balance;

use super::major::MajorId;
use super::user::UserId;

pub type SubjectId = String;

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct SubjectMetadata {
  pub subject_id: SubjectId,
  pub major_id: MajorId,
  pub instructor_id: Option<UserId>,
  pub prerequisite_subject_id: Option<SubjectId>,
  pub thumbnail: Option<String>,
  pub title: String,
  pub description: String,
  pub number_of_credits: u64,
  pub price: Balance,
  pub balance: Option<Balance>,
  pub number_students_studying: u64,
  pub created_at: u64,
  pub updated_at: u64,
}

pub trait SubjectFeatures {
  fn create_subject(
    &mut self,
    subject_id: SubjectId,
    major_id: MajorId,
    thumbnail: Option<String>,
    prerequisite_subject_id: Option<SubjectId>,
    title: String,
    description: String,
    price: Balance,
    number_of_credits: u64,
  );

  fn update_subject(
    &mut self,
    subject_id: SubjectId,
    major_id: Option<MajorId>,
    thumbnail: Option<String>,
    prerequisite_subject_id: Option<SubjectId>,
    title: Option<String>,
    description: Option<String>,
    price: Option<Balance>,
    number_of_credits: Option<u64>,
  );

  fn register_subject(&mut self, subject_id: SubjectId);

  fn assignment(&mut self, instructor_id: UserId, subject_id: SubjectId);

  fn get_all_subject_metadata(&self) -> Vec<SubjectMetadata>;

  fn get_all_subject_metadata_by_major_id(&self, major_id: MajorId) -> Vec<SubjectMetadata>;

  fn get_all_subject_metadata_by_user_id(&self, user_id: UserId) -> Vec<SubjectMetadata>;

  fn clean_subject(&mut self);
}

'''
'''--- src/models/user.rs ---
#![allow(clippy::too_many_arguments)]

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, Promise};

use super::major::MajorId;
use super::subject::SubjectId;

#[derive(Deserialize, BorshDeserialize, BorshSerialize, Serialize, Default, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum Roles {
  #[default]
  Student,
  Instructor,
  Admin,
}

pub type UserId = AccountId;

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct UserMetadata {
  pub user_id: UserId,
  pub username: Option<String>,
  pub password: Option<String>,

  pub avatar: Option<String>,
  pub active: bool,
  pub full_name: String,
  pub date_of_birth: String,
  pub email: String,
  pub phone: String,
  pub national_identity_card: String,
  pub national_identity_card_date: String,

  pub major_id: Option<MajorId>,
  pub subject_ids_studied: Vec<SubjectId>,

  pub role: Roles,
  pub total_credit: u64,
  pub balance: Balance,
  pub created_at: u64,
  pub updated_at: u64,
}

pub trait UserFeatures {
  fn create_admin_user(
    &mut self,
    username: String,
    password: String,
    full_name: String,
    date_of_birth: String,
    email: String,
    phone: String,
    national_identity_card: String,
    national_identity_card_date: String,
  );

  fn create_student_user(
    &mut self,
    user_id: UserId,
    full_name: String,
    date_of_birth: String,
    emai: String,
    phone: String,
    national_identity_card: String,
    national_identity_card_date: String,
  );

  fn create_instructor_user(
    &mut self,
    user_id: UserId,
    full_name: String,
    date_of_birth: String,
    emai: String,
    phone: String,
    national_identity_card: String,
    national_identity_card_date: String,
  );

  fn update_user(
    &mut self,
    user_id: UserId,
    full_name: Option<String>,
    date_of_birth: Option<String>,
    email: Option<String>,
    phone: Option<String>,
    national_identity_card: Option<String>,
    national_identity_card_date: Option<String>,
  );

  fn update_user_metadate(&mut self, user_metadate: &UserMetadata);

  fn register_student_user(&mut self, major_id: String) -> Promise;

  fn register_instructor_user(&mut self) -> Promise;

  fn get_all_user_metadata(&self) -> Vec<UserMetadata>;

  fn active_student_user(&mut self, user_id: UserId, username: String, password: String);

  fn active_instructor_user(&mut self, user_id: UserId, username: String, password: String);

  fn get_user_metadata_by_id(&self, id: UserId) -> Option<UserMetadata>;

  fn get_user_metadata_by_username(&self, username: String) -> Option<UserMetadata>;

  fn get_all_student_user_metadata_by_subject_id(&self, subject_id: SubjectId)
    -> Vec<UserMetadata>;

  fn clean_user(&mut self);
}

'''