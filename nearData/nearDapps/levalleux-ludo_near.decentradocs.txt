*GitHub Repository "levalleux-ludo/near.decentradocs"*

'''--- .eslintrc.js ---
module.exports = {
  env: {
    browser: true,
    es6: true,
    node: true
  },
  extends: [
    'plugin:jest/recommended',
    'plugin:react/recommended',
    'standard'
  ],
  globals: {
    Atomics: 'readonly',
    SharedArrayBuffer: 'readonly'
  },
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: {
      jsx: true
    },
    ecmaVersion: 2018,
    sourceType: 'module'
  },
  plugins: [
    'jest',
    'react',
    '@typescript-eslint'
  ],
  rules: {
  },
  settings: {
    react: {
      version: 'detect'
    }
  }
}

'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# Options to prebuild the image after github events and set notifications/badges
github:
  prebuilds:
    # enable for the master/default branch (defaults to true)
    master: true
    # enable for pull requests coming from this repo (defaults to true)
    pullRequests: true
    # enable for pull requests coming from forks (defaults to false)
    pullRequestsFromForks: true
    # add a check to pull requests (defaults to true)
    addCheck: true
    # add a "Review in Gitpod" button as a comment to pull requests (defaults to false)
    addComment: true
    # add a "Review in Gitpod" button to the pull request's description (defaults to false)
    addBadge: false
    # add a label once the prebuild is ready to pull requests (defaults to false)
    addLabel: false

# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: nvm use default
    init: yarn
    command: yarn asp && yarn dev

ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- .travis.yml ---
language: node_js
node_js:
  - 12
env:
  - NODE_ENV=ci
  - NODE_ENV=ci-staging
cache: yarn
script:
  - yarn test

'''
'''--- README.md ---
Guest Book
==========

[![Build Status](https://travis-ci.com/near-examples/guest-book.svg?branch=master)](https://travis-ci.com/near-examples/guest-book)

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/guest-book)

<!-- MAGIC COMMENT: DO NOT DELETE! Everything above this line is hidden on NEAR Examples page -->

Sign in with [NEAR] and add a message to the guest book! A starter app built with an [AssemblyScript] backend and a [React] frontend.

Quick Start
===========

To run this project locally:

1. Prerequisites: Make sure you have node.js installed (we like [asdf] for
   this), then use it to install [yarn]: `npm install --global yarn` (or just
   `npm i -g yarn`)
2. Install dependencies: `yarn install` (or just `yarn`)
3. Run the local development server: `yarn dev` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Now you'll have a local development environment backed by the NEAR TestNet! Running `yarn dev` will tell you the URL you can visit in your browser to see the app.

Exploring The Code
==================

1. The backend code lives in the `/assembly` folder. This code gets deployed to
   the NEAR blockchain when you run `yarn deploy:contract`. This sort of
   code-that-runs-on-a-blockchain is called a "smart contract" â€“ [learn more
   about NEAR smart contracts][smart contract docs].
2. The frontend code lives in the `/src` folder. [/src/index.html] is a great
   place to start exploring. Note that it loads in `/src/index.js`, where you
   can learn how the frontend connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and backend. The
   backend code gets tested with the [asp] command for running the backend
   AssemblyScript tests, and [jest] for running frontend tests. You can run
   both of these at once with `yarn test`.

Both contract and client-side code will auto-reload as you change source files.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `yarn dev`, your smart contracts get deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

Step 0: Install near-shell
--------------------------

You need near-shell installed globally. Here's how:

    npm install --global near-shell

This will give you the `near` [CLI] tool. Ensure that it's installed with:

    near --version

Step 1: Create an account for the contract
------------------------------------------

Visit [NEAR Wallet] and make a new account. You'll be deploying these smart contracts to this new account.

Now authorize NEAR shell for this new account, and follow the instructions it gives you:

    near login

Step 2: set contract name in code
---------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'your-account-here!'

Step 3: deploy!
---------------

One command:

    yarn deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contracts to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

  [NEAR]: https://nearprotocol.com/
  [asdf]: https://github.com/asdf-vm/asdf
  [yarn]: https://yarnpkg.com/
  [AssemblyScript]: https://docs.assemblyscript.org/
  [React]: https://reactjs.org
  [smart contract docs]: https://docs.nearprotocol.com/docs/roles/developer/contracts/assemblyscript
  [asp]: https://www.npmjs.com/package/@as-pect/cli
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.nearprotocol.com/docs/concepts/account
  [NEAR Wallet]: https://wallet.nearprotocol.com
  [near-shell]: https://github.com/nearprotocol/near-shell
  [CLI]: https://www.w3schools.com/whatis/whatis_cli.asp
  [create-near-app]: https://github.com/nearprotocol/create-near-app
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- as-pect.config.js ---
module.exports = require('wasm-mock-vm/imports')

'''
'''--- asconfig.js ---
const compile = require('near-bindgen-as/compiler').compile

compile('assembly/main.ts', // input file
  'out/main.wasm', // output file
  [
    //   "-O1",          // Optional arguments
    '--debug',
    '--measure', // Shows compiler runtime
    '--validate' // Validate the generated wasm module
  ], {
    verbose: true // Output the cli args passed to asc
  })

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- assembly/__tests__/dvsRegistry.spec.ts ---
import { docExists, registerDoc, getAuthorizedAccounts, getAuthor, init, getDocumentKey, setAccess, subscribe, getSubscriptionFee, setSubscriptionFee } from '../main'
import { PersistentVector, context, Context } from 'near-sdk-as'

// import { v4 as uuid } from 'uuid';

// const doc1 = {
//   docId: '11111',
//   encryptedKey: 'xxxxx',
//   subscriptionFee: 123456,
//   authorized: new PersistentVector<string>("authorized_doc1:")
// };
const account0 = 'account0';
const account1 = 'account1';
const account2 = 'account2';
const account3 = 'account3';
const account4 = 'account4';
const PUBLIC_KEY = '00000-00000-00000-00000-00000';

const docId1: string = '1111';
const encryptedKey1: string = 'xxxxx';
const subscriptionFee1: u64 = 123456;
const authorized1: string[] = [];
const docId2: string = '2222';
const encryptedKey2: string = 'yyyyy';
const subscriptionFee2: u64 = 0;
const authorized2: string[] = [account1, account2];
const docId3: string = '3333';
const encryptedKey3: string = PUBLIC_KEY;
const subscriptionFee3: u64 = 0;
const authorized3: string[] = [];

const ERROR_DOC_ALREADY_EXISTS = 'a document with this id already exists';

describe('Test DVSRegistry contract', () => {
  beforeAll(() => {
    init(account0);
  });

  it('be able to register a protected document', () => {
    Context.setSigner_account_id(account0);
    expect(docExists(docId1)).toBe(false);
    expect(docExists(docId2)).toBe(false);
    registerDoc(docId1, encryptedKey1, subscriptionFee1, authorized1);
    expect(docExists(docId1)).toBe(true);
    expect(docExists(docId2)).toBe(false);
    let authorized = getAuthorizedAccounts(docId1);
    expect(authorized.length).toBe(authorized1.length);
    expect(getAuthor(docId1)).toBe(account0);
  })
  // it('not be able to regsiter the same document again', () => {
  //   Context.setSigner_account_id(account0);
  //   registerDoc(docId1, encryptedKey1, subscriptionFee1, authorized1);
  //   // -> expected to throw 'a document with this id already exists'
  // })
  it('be able to get encryption key if author', () => {
    Context.setSigner_account_id(account0);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
    Context.setSigner_account_id(account1);
    expect(getDocumentKey(docId1)).toBe('');
  })
  it('be able to get encryption key if authorized', () => {
    Context.setSigner_account_id(account0);
    registerDoc(docId2, encryptedKey2, subscriptionFee2, authorized2);
    expect(docExists(docId2)).toBeTruthy();
    expect(getDocumentKey(docId2)).toBe(encryptedKey2);
    Context.setSigner_account_id(account1);
    expect(getDocumentKey(docId2)).toBe(encryptedKey2);
    Context.setSigner_account_id(account2);
    expect(getDocumentKey(docId2)).toBe(encryptedKey2);
    Context.setSigner_account_id(account3);
    expect(getDocumentKey(docId2)).toBe('');
    let authorized = getAuthorizedAccounts(docId2);
    expect(authorized.length).toBe(authorized2.length);
    expect(getAuthor(docId2)).toBe(account0);
  })
  it('be able to get encryption key if key is public_key', () => {
    Context.setSigner_account_id(account0);
    registerDoc(docId3, encryptedKey3, subscriptionFee3, authorized3);
    expect(docExists(docId3)).toBeTruthy();
    expect(getDocumentKey(docId3)).toBe(PUBLIC_KEY);
    Context.setSigner_account_id(account1);
    expect(getDocumentKey(docId3)).toBe(PUBLIC_KEY);
    Context.setSigner_account_id(account2);
    expect(getDocumentKey(docId3)).toBe(PUBLIC_KEY);
    Context.setSigner_account_id(account3);
    expect(getDocumentKey(docId3)).toBe(PUBLIC_KEY);
  })
  it('be able to add authorized address to a document if author', () => {
    Context.setSigner_account_id(account0);
    let authorized = getAuthorizedAccounts(docId1);
    expect(authorized.includes(account1)).toBe(false);
    expect(authorized.includes(account3)).toBe(false);
    setAccess(docId1, [account1, account3], []);
    authorized = getAuthorizedAccounts(docId1);
    expect(authorized.length).toBe(authorized1.length + 2);
    expect(authorized.includes(account1)).toBe(true);
    expect(authorized.includes(account2)).toBe(false);
    expect(authorized.includes(account3)).toBe(true);
    Context.setSigner_account_id(account0);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
    Context.setSigner_account_id(account1);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
    Context.setSigner_account_id(account2);
    expect(getDocumentKey(docId1)).toBe('');
    Context.setSigner_account_id(account3);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
  })
  // it('not be able to add authorized address if not author', () => {
  //   Context.setSigner_account_id(account1);
  //   setAccess(docId1, [account2], []);
  //   // -> expected to throw 'only the author of the document can change authorisations'
  // })
  it('be able to deny address if author', () => {
    Context.setSigner_account_id(account0);
    setAccess(docId1, [], [account1, account2]);
    let authorized = getAuthorizedAccounts(docId1);
    expect(authorized.length).toBe(1);
    expect(authorized.includes(account1)).toBe(false);
    expect(authorized.includes(account2)).toBe(false);
    expect(authorized.includes(account3)).toBe(true);
    Context.setSigner_account_id(account0);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
    Context.setSigner_account_id(account1);
    expect(getDocumentKey(docId1)).toBe('');
    Context.setSigner_account_id(account2);
    expect(getDocumentKey(docId1)).toBe('');
    Context.setSigner_account_id(account3);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
  })
  it('be able to mix authorized/denied address to a document if author', () => {
    Context.setSigner_account_id(account0);
    setAccess(docId1, [account1, account2, account4], [account3, account4]);
    let authorized = getAuthorizedAccounts(docId1);
    expect(authorized.length).toBe(2);
    expect(authorized.includes(account1)).toBe(true);
    expect(authorized.includes(account2)).toBe(true);
    expect(authorized.includes(account3)).toBe(false);
    expect(authorized.includes(account4)).toBe(false);

    Context.setSigner_account_id(account0);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
    Context.setSigner_account_id(account1);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
    Context.setSigner_account_id(account2);
    expect(getDocumentKey(docId1)).toBe(encryptedKey1);
    Context.setSigner_account_id(account3);
    expect(getDocumentKey(docId1)).toBe('');
    Context.setSigner_account_id(account4);
    expect(getDocumentKey(docId1)).toBe('');

    Context.setSigner_account_id(account0);
    setAccess(docId1, [account3, account4], [account1, account2]);
    authorized = getAuthorizedAccounts(docId1);
    expect(authorized.length).toBe(2);
    expect(authorized.includes(account1)).toBe(false);
    expect(authorized.includes(account2)).toBe(false);
    expect(authorized.includes(account3)).toBe(true);
    expect(authorized.includes(account4)).toBe(true);
  })
  // it('not be able to add authorized address if not author', () => {
  //   Context.setSigner_account_id(account3);
  //   setAccess(docId1, [], [account2]);
  //   // -> expected to throw 'only the author of the document can change authorisations'
  // })
  it('be able to subscribe to a free document', () => {
    Context.setSigner_account_id(account3);
    expect(getDocumentKey(docId2)).toBe('');
    let authorized = getAuthorizedAccounts(docId2);
    expect(authorized.includes(account3)).toBe(false);
    subscribe(docId2);
    expect(getDocumentKey(docId2)).toBe(encryptedKey2);
    authorized = getAuthorizedAccounts(docId2);
    expect(authorized.includes(account3)).toBe(true);
    // expect(await dVSRegistry.getDocumentKey(doc2.docId, { from: accounts[3] })).to.eq('');
    // let authorized = await dVSRegistry.getAuthorizedAccounts(doc2.docId);
    // expect(authorized.includes(accounts[3])).to.be.false;
    // await dVSRegistry.subscribe(doc2.docId, { from: accounts[3] });
    // expect(await dVSRegistry.getDocumentKey(doc2.docId, { from: accounts[3] })).to.eq(doc2.encryptedKey);
    // authorized = await dVSRegistry.getAuthorizedAccounts(doc2.docId);
    // expect(authorized.includes(accounts[3])).to.be.true;
  })
  // it('not be able to subscribe twice to a document', () => {
  //   let authorized = getAuthorizedAccounts(docId2);
  //   expect(authorized.includes(account3)).toBe(true);
  //   Context.setSigner_account_id(account3);
  //   subscribe(docId2);
  //   // -> expected to throw 'account has already subscribed to this document'
  // })
  // it('not be able to subscribe if already authorized', () => {
  //   let authorized = getAuthorizedAccounts(docId2);
  //   expect(authorized.includes(account2)).toBe(true);
  //   Context.setSigner_account_id(account2);
  //   subscribe(docId2);
  //   // -> expected to throw 'account has already subscribed to this document'
  // })
  // it('not be able to subscribe if author', () => {
  //   expect(getAuthor(docId2)).toBe(account0);
  //   Context.setSigner_account_id(account0);
  //   subscribe(docId2);
  //   // -> expected to throw 'document author does not need to subscribe'
  // })
  it('be able to consult subscription fee', () => {
    let fee1 = getSubscriptionFee(docId1);
    expect(fee1).toBe(subscriptionFee1);
    let fee2 = getSubscriptionFee(docId2);
    expect(fee2).toBe(subscriptionFee2);
  })
  it('be able to change subscription fee if author', () => {
    let fee1 = getSubscriptionFee(docId1);
    expect(fee1).toBe(subscriptionFee1);
    Context.setSigner_account_id(account0);
    setSubscriptionFee(docId1, 654321);
    fee1 = getSubscriptionFee(docId1);
    expect(fee1).toBe(654321);
  })
  // it('not be able to change subscription fee if not author', () => {
  //   let fee1 = getSubscriptionFee(docId1);
  //   expect(fee1).toBe(654321);
  //   Context.setSigner_account_id(account1);
  //   setSubscriptionFee(docId1, 654321);
  //   //  -> expected to throw 'only the author of the document can change authorisations'
  // })
})

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/main.ts ---
// @nearfile

import { PersistentVector, PersistentMap, context, logging, storage, ContractPromise, ContractPromiseResult } from "near-sdk-as";
import { OnDDoxGetOwnerArgs, GetOwnerArgs , GetOwnerResult, AddItemArgs } from './model';

// --- contract code goes below
let _initialOwner: string;
const PUBLIC_KEY = '00000-00000-00000-00000-00000';
const DDOX_CONTRACT='ddox-token';
const _authorPerDocId = new PersistentMap<string, string>("authors:");
// const _authorizedAddressPerDocId = new PersistentMap<string, PersistentVector<string>>("authorizedVector:");
const _authorizedAddressPerDocId = new PersistentMap<string, Array<string>>("authorizedVector:");
const _subscriptionFeePerDocId = new PersistentMap<string, u64>("subscriptionFee:");
const _encryptedKeyPerDocId = new PersistentMap<string, string>("encryptedKey:");

let lastResult: string = '';

export function init(initialOwner: string): void {
  logging.log("initialOwner: " + initialOwner);
  assert(storage.get<string>("init") == null, "Already initialized token supply");
  _initialOwner = initialOwner;
  storage.set("init", "done");
}

export function docExists(docId: string): bool {
  return _authorPerDocId.contains(docId);
}

export function registerDoc(
  docId: string,
  encryptedKey: string,
  subscriptionFee: u64,
  authorizedAddresses: Array<string> ): void {
    assert(!docExists(docId), 'a document with this id already exists');
    const author: string = context.sender;
    _authorPerDocId.set(docId, author);
    _encryptedKeyPerDocId.set(docId, encryptedKey);
    _subscriptionFeePerDocId.set(docId, subscriptionFee);
    // const authorizedVector = new PersistentVector<string>("authorized:");
    // for (let i = 0; i < authorizedAddresses.length; i++) {
    //   authorizedVector.push(authorizedAddresses[i]);
    // }
    // _authorizedAddressPerDocId.set(docId, authorizedVector);
    _authorizedAddressPerDocId.set(docId, authorizedAddresses);
}

export function getAuthorizedAccounts(docId: string): Array<string> {
  const authorized = _authorizedAddressPerDocId.get(docId);
  if (!authorized) {
    return [];
  }
  const result = new Array<string>(authorized.length);
  for (let i = 0; i < authorized.length; i++) {
    result[i] = authorized[i];
  }
  return result;
}

export function isAuthorized(docId: string, account: string): bool {
  const authorized = _authorizedAddressPerDocId.get(docId);
  if (authorized) {
    return authorized.includes(account);
  }
  return false;
}

export function getAuthor(docId: string): string | null {
  assert(docExists(docId), "this document has not been registered");
  return _authorPerDocId.get(docId);
}

function isAuthor(docId: string, account: string): bool {
  return (account == _authorPerDocId.get(docId));
}

export function getDocumentKey(docId: string, account: string = context.sender): string | null {
if (isAuthor(docId, account) ||
    isAuthorized(docId, account) ||
    (PUBLIC_KEY == _encryptedKeyPerDocId.get(docId)) ) {
    let key =_encryptedKeyPerDocId.get(docId);
    if (key != null) {
      return key;
    }
  }
  return '';
}

function removeFromArrayIfIncluded<T>(theArray: Array<T>, item: T): void {
  const index = theArray.indexOf(item);
  if (index > -1) {
    theArray.splice(index, 1);
  }
}

export function setAccess(docId: string, authorizedAddresses: Array<string> , deniedAddresses: Array<string> ): void {
  assert(docExists(docId), "this document has not been registered");
  assert(isAuthor(docId, context.sender), "only the author of the document can change authorisations");
  const authorized = _authorizedAddressPerDocId.get(docId);
  if (authorized) {
    for (let i = 0; i < authorizedAddresses.length; i++) {
      const account: string = authorizedAddresses[i];
      if (!authorized.includes(account)) {
        authorized.push(account);
      }
    }
    for (let i = 0; i < deniedAddresses.length; i++) {
      const account: string = deniedAddresses[i];
      removeFromArrayIfIncluded(authorized, account);
    }
    _authorizedAddressPerDocId.set(docId, authorized);
  }
}

export function subscribe(docId: string): void {
  assert(!isAuthor(docId, context.sender), "document author does not need to subscribe");
  assert(!isAuthorized(docId, context.sender), "account has already subscribed to this document");
  // assert(context.receivedAmount >= _subscriptionFeePerDocId(docId), 'not enough fee to subscribe to this document');
  // assert(context.attachedDeposit >= _subscriptionFeePerDocId(docId), 'not enough fee to subscribe to this document');
  // let author = getAuthor(docId);
  // let fee = _subscriptionFeePerDocId(docId);

  const authorized = _authorizedAddressPerDocId.get(docId);
  if (authorized) {
    authorized.push(context.sender);
    _authorizedAddressPerDocId.set(docId, authorized);
  }
}

export function getSubscriptionFee(docId: string): u64 {
  assert(docExists(docId), "this document has not been registered");
  if (!_subscriptionFeePerDocId.contains(docId)) {
    return 0;
  }
  const fee = _subscriptionFeePerDocId.getSome(docId);
  return fee;
}

export function setSubscriptionFee(docId: string, subscriptionFee: u64): void {
  assert(docExists(docId), "this document has not been registered");
  assert(isAuthor(docId, context.sender), "only the author of the document can change authorisations");
  _subscriptionFeePerDocId.set(docId, subscriptionFee);
}

export function dDox_getOwner(): void {
  const get_Owner_args: GetOwnerArgs = {}; // call the contract method with these args
  const _on_dDox_getOwner_args: OnDDoxGetOwnerArgs = {}; // when the callback is called (back), give him this data
  // let itemArgs: AddItemArgs = {
  //        accountId: "alice.near",
  //        itemId: "Sword +9000",
  //      };
  // let promise = ContractPromise.create(
  //        "metanear",
  //        "addItem",
  //        itemArgs.encode(),
  //        0,
  //      );
  ContractPromise.create(DDOX_CONTRACT, 'getOwner', get_Owner_args.encode(), 0);
  // .then(context.contractName, '_on_dDox_getOwner', _on_dDox_getOwner_args.encode(), 0)
  // .returnAsResult();
}

// This function is prefixed with `_`, so other contracts or people can't call it directly.
export function _on_dDox_getOwner(): void {
  // Get all results
//  let results = ContractPromise.getResults();
//  let getOwnerResult = results[0];
//  // Verifying the remote contract call succeeded.
//  if (getOwnerResult.status) {
//     // Decoding data from the bytes buffer into the local object.
//     let data: GetOwnerResult = GetOwnerResult.decode(getOwnerResult.buffer);
//     return data.owner;
//   }
  lastResult = 'NOK';
}

export function getGreetings(): string {
  return "Hello Mister X !";
}

'''
'''--- assembly/model.ts ---
// @nearfile

import { context, u128 } from "near-sdk-as";

// Exporting a new class PostedMessage so it can be used outside of this file.
export class PostedMessage {
  premium: boolean;
  sender: string;
  constructor(public text: string) {
    this.premium = context.attachedDeposit >= u128.from('10000000000000000000000');
    this.sender = context.sender;
  }
}

export class OnDDoxGetOwnerArgs {

}

export class GetOwnerArgs {

}

export class GetOwnerResult {
  owner: string
}

export class AddItemArgs {
  accountId: string;
  itemId: string;
};
'''
'''--- assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react']
}

'''
'''--- gulpfile.js ---
const gulp = require('gulp')
const nearUtils = require('near-bindgen-as/compiler')

function buildWasm (done) {
  nearUtils.compile('./assembly/main.ts', './out/main.wasm', done)
};

const build = gulp.series(buildWasm)

exports.default = build

'''
'''--- neardev/default/dev-1582817300252.json ---
{"account_id":"dev-1582817300252","private_key":"ed25519:2MpYmwAnKum3qGR6ggwgXozSR6Er5Z9bzD72LsT8DgrgUuYA37aQ4uPj1oHZdRxbNpuwnGxRcGBk9CsCrDEcG1ki"}
'''
'''--- neardev/shared-test-staging/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- package.json ---
{
    "name": "guest-book",
    "version": "0.1.0",
    "license": "MIT",
    "scripts": {
        "build": "yarn build:contract && yarn build:web",
        "build:contract": "mkdir -p out/ && gulp",
        "build:web": "parcel build src/index.html --public-url ./",
        "deploy": "yarn build && near deploy",
        "dev": "yarn build:contract && near dev-deploy && nodemon --watch assembly -e ts --exec 'yarn dev:start'",
        "lint": "eslint .",
        "start": "yarn deploy && parcel src/index.html",
        "dev:start": "env CONTRACT_NAME=$(cat neardev/dev-account) parcel src/index.html",
        "test": "yarn build:contract && asp"
    },
    "devDependencies": {
        "@babel/core": "^7.8.7",
        "@babel/preset-env": "^7.9.0",
        "@babel/preset-react": "^7.9.4",
        "@typescript-eslint/eslint-plugin": "^2.25.0",
        "@typescript-eslint/parser": "^2.24.0",
        "as-bignum": "^0.1.5",
        "assemblyscript": "^0.9.4",
        "babel-jest": "^25.1.0",
        "eslint": "^6.8.0",
        "eslint-config-standard": "^14.1.1",
        "eslint-plugin-import": "^2.20.1",
        "eslint-plugin-jest": "^23.8.2",
        "eslint-plugin-node": "^11.0.0",
        "eslint-plugin-promise": "^4.2.1",
        "eslint-plugin-react": "^7.19.0",
        "eslint-plugin-standard": "^4.0.1",
        "gh-pages": "^2.2.0",
        "gulp": "^4.0.2",
        "jest": "^25.1.0",
        "jest-environment-node": "^25.1.0",
        "near-sdk-as": "^0.1.2",
        "near-shell": "^0.20.1",
        "nodemon": "^2.0.2",
        "parcel-bundler": "^1.12.4",
        "react-test-renderer": "^16.13.0",
        "sass": "^1.26.3",
        "typescript": "^3.8.3"
    },
    "dependencies": {
        "nearlib": "^0.22.0",
        "react": "^16.13.1",
        "react-dom": "^16.13.0",
        "regenerator-runtime": "^0.13.5"
    },
    "jest": {
        "projects": [{
                "displayName": "User interface tests",
                "testEnvironment": "jsdom",
                "testMatch": [
                    "<rootDir>/src/tests/ui/*.js"
                ]
            },
            {
                "displayName": "Integration tests",
                "testEnvironment": "near-shell/test_environment",
                "testMatch": [
                    "<rootDir>/src/tests/integration/*.js"
                ]
            }
        ],
        "testPathIgnorePatterns": [
            "assembly/*"
        ]
    },
    "browserslist": {
        "production": [
            ">0.2%",
            "not dead",
            "not op_mini all"
        ],
        "development": [
            "last 1 chrome version",
            "last 1 firefox version",
            "last 1 safari version"
        ]
    }
}
'''
'''--- src/App.js ---
import React, { useCallback, useEffect, useState } from 'react'
import PropTypes from 'prop-types'

const App = ({ contract, nearConfig, wallet }) => {
  const [messages, setMessages] = useState([])
  const [accountId, setAccountId] = useState(wallet.getAccountId())
  const [inputText, setInputText] = useState('')
  const [inputReadOnly, setinputReadOnly] = useState(false)

  useEffect(() => {
    // TODO: don't just fetch once; subscribe!
    contract.getMessages().then(setMessages)
  }, [])

  const signIn = useCallback(() => {
    wallet.requestSignIn(
      nearConfig.contractName,
      'NEAR Guest Book'
    )
  }, [])

  const signOut = useCallback(() => {
    wallet.signOut()
    setAccountId(null)
  }, [])

  const addMessage = useCallback(async (text, isPremium) => {
    setinputReadOnly(true)
    const BOATLOAD_OF_GAS = '10000000000000000'
    const PREMIUM_COST = '10000000000000000000000'
    await contract.addMessage({ text }, BOATLOAD_OF_GAS, isPremium ? PREMIUM_COST.toString() : '0')
    setInputText('')
    const messages = await contract.getMessages()
    setMessages(messages)
    setinputReadOnly(false)
  })

  return (
    <main>
      <header style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between'
      }}>
        <h1>NEAR Guest Book</h1>
        {accountId
          ? <button onClick={signOut}>Log out</button>
          : <button onClick={signIn}>Log in</button>
        }
      </header>
      {accountId && (
        <form onSubmit={e => { e.preventDefault() }}>
          <label htmlFor="message">
            Sign the guest book, { accountId }!
          </label>
          <div style={{ display: 'flex' }}>
            <input
              autoComplete="off"
              autoFocus
              value={ inputText }
              onChange={(e) => { setInputText(e.target.value) }}
              id="message"
              required
              style={{ flex: 1 }}
              readOnly={ inputReadOnly }
              className={ 'message-input' }
            />
            <button type="submit" style={{ marginLeft: '0.5em' }} onClick={(e) => {
              addMessage(inputText, false)
            }}>
              Save
            </button>
            <button className="primary" type="submit" style={{ marginLeft: '0.5em' }} onClick={(e) => {
              addMessage(inputText, true)
            }}>
              Save & Donate
            </button>
          </div>
        </form>
      )}
      {!!messages.length && (
        <>
          <h2>Messages</h2>
          {messages.map((message, i) =>
            // TODO: format as cards, add timestamp
            <p key={i} className={message.premium ? 'is-premium' : ''}>
              <strong>{message.sender}</strong>:<br/>
              {message.text}
            </p>
          )}
        </>
      )}
    </main>
  )
}

App.propTypes = {
  contract: PropTypes.shape({
    addMessage: PropTypes.func.isRequired,
    getMessages: PropTypes.func.isRequired
  }).isRequired,
  nearConfig: PropTypes.shape({
    contractName: PropTypes.string.isRequired
  }).isRequired,
  wallet: PropTypes.shape({
    getAccountId: PropTypes.func.isRequired,
    isSignedIn: PropTypes.func.isRequired,
    requestSignIn: PropTypes.func.isRequired,
    signOut: PropTypes.func.isRequired
  }).isRequired
}

export default App

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'decentradocs'

function getConfig(env) {
    switch (env) {
        case 'production':
        case 'development':
            return {
                networkId: 'default',
                nodeUrl: 'https://rpc.nearprotocol.com',
                contractName: CONTRACT_NAME,
                walletUrl: 'https://wallet.nearprotocol.com',
                helperUrl: 'https://near-contract-helper.onrender.com'
            }
        case 'staging':
            return {
                networkId: 'staging',
                nodeUrl: 'https://staging-rpc.nearprotocol.com/',
                contractName: CONTRACT_NAME,
                walletUrl: 'https://near-wallet-staging.onrender.com',
                helperUrl: 'https://near-contract-helper-staging.onrender.com'
            }
        case 'local':
            return {
                networkId: 'local',
                nodeUrl: 'http://localhost:3030',
                keyPath: `${process.env.HOME}/.near/validator_key.json`,
                walletUrl: 'http://localhost:4000/wallet',
                contractName: CONTRACT_NAME
            }
        case 'test':
        case 'ci':
            return {
                networkId: 'shared-test',
                nodeUrl: 'http://shared-test.nearprotocol.com:3030',
                contractName: CONTRACT_NAME,
                masterAccount: 'test.near'
            }
        case 'ci-staging':
            return {
                networkId: 'shared-test-staging',
                nodeUrl: 'http://staging-shared-test.nearprotocol.com:3030',
                contractName: CONTRACT_NAME,
                masterAccount: 'test.near'
            }
        case 'tatooine':
            return {
                networkId: 'tatooine',
                nodeUrl: 'https://rpc.tatooine.nearprotocol.com',
                contractName: CONTRACT_NAME,
                walletUrl: 'https://wallet.tatooine.nearprotocol.com'
            }
        default:
            throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
    }
}

module.exports = getConfig
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <link rel="apple-touch-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="global.scss">
    <title>NEAR Guest Book</title>
    <meta property="og:title" content="NEAR Guest Book">
    <meta property="og:description" content="A guest book with comments stored on the NEAR blockchain">
    <!-- <meta property="og:image" content=""> -->
    <!-- <meta property="og:url" content=""> -->
    <!-- <meta name="twitter:card" content="summary_large_image"> -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `yarn dev`.
      To create a production bundle, use `yarn build`.
    -->
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import getConfig from './config.js'
import * as nearlib from 'nearlib'

// Initializing contract
async function initContract () {
  const nearConfig = getConfig(process.env.NODE_ENV || 'development')

  // Initializing connection to the NEAR DevNet
  const near = await nearlib.connect({
    deps: {
      keyStore: new nearlib.keyStores.BrowserLocalStorageKeyStore()
    },
    ...nearConfig
  })

  // Needed to access wallet
  const walletConnection = new nearlib.WalletConnection(near)

  // Get Account ID â€“ if still unauthorized, it's an empty string
  const accountId = walletConnection.getAccountId()

  // Initializing our contract APIs by contract name and configuration
  const contract = await new nearlib.Contract(walletConnection.account(), nearConfig.contractName, {
    // View methods are read-only â€“ they don't modify the state, but usually return some value
    viewMethods: ['getMessages'],
    // Change methods can modify the state, but you don't receive the returned value when called
    changeMethods: ['addMessage'],
    // Sender is the account ID to initialize transactions.
    sender: accountId
  })

  return { contract, nearConfig, walletConnection }
}

window.nearInitPromise = initContract()
  .then(({ contract, nearConfig, walletConnection }) => {
    ReactDOM.render(
      <App contract={contract} nearConfig={nearConfig} wallet={walletConnection} />,
      document.getElementById('root')
    )
  })

'''
'''--- src/tests/integration/App-integration.test.js ---
// these are made available by near-shell/test_environment
// note: do not remove the line below as it is needed for these tests
/* global nearlib, nearConfig */

import 'regenerator-runtime/runtime'

let near
let contract
let accountId

beforeAll(async function () {
  near = await nearlib.connect(nearConfig)
  accountId = nearConfig.contractName
  contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['getMessages'],
    changeMethods: ['addMessage'],
    sender: accountId
  })
})

it('send one message and retrieve it', async () => {
  await contract.addMessage({ text: 'aloha' })
  const msgs = await contract.getMessages()
  const expectedMessagesResult = [{
    premium: false,
    sender: accountId,
    text: 'aloha'
  }]
  expect(msgs).toEqual(expectedMessagesResult)
})

it('send two more messages and expect three total', async () => {
  await contract.addMessage({ text: 'foo' })
  await contract.addMessage({ text: 'bar' })
  const msgs = await contract.getMessages()
  expect(msgs.length).toEqual(3)
})

'''
'''--- src/tests/ui/App-ui.test.js ---
import 'regenerator-runtime/runtime'
import React from 'react'
import TestRenderer from 'react-test-renderer'
import App from '../../App'
const { act } = TestRenderer

// Declare stubs for contract, walletConnection, and nearConfig
const contract = {
  account: {
    connection: {},
    accountId: 'test.near'
  },
  contractId: 'test.near',
  getMessages: () => new Promise(() => {}),
  addMessage: () => ''
}
const walletConnection = {
  requestSignIn: () => null,
  signOut: () => null,
  isSignedIn: () => false,
  getAccountId: () => 'test.near'
}
const nearConfig = {
  networkId: 'default',
  nodeUrl: 'https://rpc.nearprotocol.com',
  contractName: 'test.near',
  walletUrl: 'https://wallet.nearprotocol.com',
  helperUrl: 'https://near-contract-helper.onrender.com'
}

// For UI tests, use pattern from: https://reactjs.org/docs/test-renderer.html
let container

beforeEach(() => {
  container = document.createElement('div')
  document.body.appendChild(container)
})

afterEach(() => {
  document.body.removeChild(container)
  container = null
})

it('renders with proper title', () => {
  let testRenderer

  act(() => {
    testRenderer = TestRenderer.create(
      <App contract={contract} wallet={walletConnection} nearConfig={nearConfig} />
    )
  })

  const testInstance = testRenderer.root

  expect(testInstance.findByType('h1').children).toEqual(['NEAR Guest Book'])
})

'''
'''--- ubuntu/Launch.cmd ---
docker network create -d bridge --subnet 10.0.75.0/24 --gateway 10.0.75.1 net1

docker run -i -p 1234:1234 -p 35607:35607 ^
 -v %CD%%:/home/developer/Project ^
 -t local/rskj/ubuntu /bin/bash

'''
'''--- ubuntu/build.cmd ---
pushd "%~dp0"
docker build -t local/rskj/ubuntu .
pause
popd
'''