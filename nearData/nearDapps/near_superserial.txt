*GitHub Repository "near/superserial"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/workflows/test.yml ---
name: Deno Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        deno-version: [v1.x]
    steps:
      - name: Git Checkout Deno Module
        uses: actions/checkout@v2
      - name: Use Deno Version ${{ matrix.deno-version }}
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ matrix.deno-version }}
      - name: Format Deno Module
        run: deno fmt --check
      - name: Lint Deno Module
        run: deno lint
      - name: Build Deno Module
        run: deno run --reload mod.ts
      - name: Test Deno Module
        run: deno test --allow-none

'''
'''--- .vscode/settings.json ---
{
  "deno.enable": true,
  "deno.lint": true,
  "deno.unstable": true,
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "denoland.vscode-deno"
}

'''
'''--- README.md ---
# superserial

<p>
  <a href="https://npmcharts.com/compare/superserial?minimal=true"><img alt="Downloads" src="https://img.shields.io/npm/dt/superserial.svg?style=flat-square" /></a>
  <a href="https://www.npmjs.com/package/superserial"><img alt="Version" src="https://img.shields.io/npm/v/superserial.svg?style=flat-square" /></a>
  <a href="https://www.npmjs.com/package/superserial"><img alt="License" src="https://img.shields.io/npm/l/superserial.svg?style=flat-square" /></a>
  <img alt="Language Typescript" src="https://img.shields.io/badge/language-Typescript-007acc.svg?style=flat-square" />
</p>

After data transfer, when the object needs to be restored, `JSON` has many
limitations. It does not support values such as `Infinity` and `NaN`, and does
not provide circular references.

**superserial** provides serialization in any way you can imagine.

## Usage

### with Deno

```ts
import { Serializer } from "https://deno.land/x/superserial/mod.ts";

const serializer = new Serializer();

const nodes = [{ self: null as any, siblings: [] as any[] }, {
  self: null as any,
  siblings: [] as any[],
}];
nodes[0].self = nodes[0];
nodes[0].siblings = nodes;
nodes[1].self = nodes[1];
nodes[1].siblings = nodes;

const serialized = serializer.serialize(nodes);

console.log(serialized);
// [$1,$2];{"self":$1,"siblings":$0};{"self":$2,"siblings":$0}
```

### with Node.js & Browser

**Install**

```bash
npm install superserial
```

```ts
import { Serializer } from "superserial";

// Usage is as above :-)
```

## Index

- [Built-in Objects](#built-in-objects)
- [Circular Reference](#circular-reference)
- [Class Support](#class-support)

### Built-in Objects

**Value Properties**

- `NaN`
- `Infinity`, `-Infinity`
- `undefined`

```ts
serializer.serialize({
  und: undefined,
  nan: NaN,
  inf: Infinity,
  ninf: -Infinity,
}); // {"und":undefined,"nan":NaN,"inf":Infinity,"ninf":-Infinity}
```

**Fundamental Objects**

- `Symbol`

**ETC**

- `BigInt`
- `Date`
- `RegExp`
- `Map`
- `Set`

```ts
const symbol = Symbol();
serializer.serialize({
  sym: symbol,
  bigint: 100n,
  date: new Date(),
  regex: /abc/gmi,
  map: new Map([["key1", "value1"], ["key2", "value2"]]),
  set: new Set([1, 2, 3, 4]),
});
// {"sym":$1,"bigint":100n,"date":$2,"regex":$3,"map":$4,"set":$5};Symbol();Date(1648740167514);/abc/gim;Map("key1"=>"value1","key2"=>"value2");Set(1,2,3,4)
```

### Circular Reference

Existing JSON functions do not support circular references, but **superserial**
has solved this problem.

```ts
const nodes = [{ self: null as any, siblings: [] as any[] }, {
  self: null as any,
  siblings: [] as any[],
}];
nodes[0].self = nodes[0];
nodes[0].siblings = nodes;
nodes[1].self = nodes[1];
nodes[1].siblings = nodes;

const serialized = serializer.serialize(nodes);

console.log(serialized);
// [$1,$2];{"self":$1,"siblings":$0};{"self":$2,"siblings":$0}

const deserialized = serializer.deserialize(serialized) as typeof nodes;

console.log(deserialized === deserialized[0].siblings); // true
console.log(deserialized[0] === deserialized[0].self); // true
console.log(deserialized === deserialized[1].siblings); // true
console.log(deserialized[1] === deserialized[1].self); // true
```

**Circular Set & Map**

```ts
const set = new Set();
set.add(set);

serializer.serialize(set); // Set($0)

const map = new Map();
map.set(map, map);

serializer.serialize(map); // Map($0=>$0)
```

Deserialization also works perfectly!

```ts
const set = serializer.deserialize("Set($0)");

console.log(set === [...set][0]); // true

const map = serializer.deserialize("Map($0=>$0)");

console.log(map === [...map.keys()][0]); // true
console.log(map === map.get([...map.keys()][0])); // true
```

### Class Support

Classes contain methods, getters, etc., but JSON doesn't fully support them.
**superserial** includes features that make it easy to use.

The class to be used for `deserialize` is defined when the Serializer is
created.

```ts
class TestUser {
  constructor(
    public name?: string,
    public age?: number,
  ) {
  }
}

const serializer = new Serializer({ classes: { TestUser } });
```

Serializes the object and then deserializes it again. Since the original class
object is converted as it is, all getters and methods can be used as they are.

```ts
const serialized = serializer.serialize(new TestUser("wan2land", 20));
console.log(serialized);
// TestUser{"name":"wan2land","age":20}

const user = serializer.deserialize(serialized);
console.log(user); // TestUser { name: "wan2land", age: 20 }
```

#### toSerialize / toDeserialize

Private variables can be converted using two special symbols (`toSerialize`,
`toDeserialize`).

When serializing(`serialize`), the object's data is created based on the
`toSerialize` method. You can check the result of `toSerialize` by looking at
the serialized string.

When deserializing(`deserialize`), it is impossible to create an object without
a constructor call. (ref.
[No backdoor to access private](https://github.com/tc39/proposal-class-fields#no-backdoor-to-access-private))
If the `toDeserialize` method is included, a value can be injected through
`toDeserialize` after calling the constructor.

```ts
import {
  Serializer,
  toDeserialize,
  toSerialize,
} from "https://deno.land/x/superserial/mod.ts";

class TestUser {
  #_age = 0;
  constructor(public name: string) {
    this.#_age = 0;
  }

  setAge(age: number) {
    this.#_age = age;
  }

  getAge() {
    return this.#_age;
  }

  [toSerialize]() {
    return {
      name: this.name,
      age: this.#_age,
    };
  }

  [toDeserialize](
    value: {
      name: string;
      age: number;
    },
  ) {
    this.name = value.name;
    this.#_age = value.age;
  }
}

const serializer = new Serializer({ classes: { TestUser } });

{
  const user = new TestUser("wan2land");
  user.setAge(20);

  console.log(serializer.serialize(user)); // TestUser{"name":"wan2land","age":20}
}
{
  const user = serializer.deserialize<TestUser>(
    'TestUser{"name":"wan2land","age":20}',
  );
  console.log(user); // TestUser { name: "wan2land" }
  console.log(user.getAge()); // 20
}
```

'''
'''--- deserialize.test.ts ---
// deno-lint-ignore-file no-explicit-any

import {
  assertEquals,
  assertInstanceOf,
  assertNotStrictEquals,
  assertStrictEquals,
} from "https://deno.land/std@0.131.0/testing/asserts.ts";
import { assertSpyCall, spy } from "https://deno.land/x/mock@0.15.0/mod.ts";

import { deserialize } from "./deserialize.ts";
import { toDeserialize } from "./symbol.ts";

Deno.test("deserialize scalar", () => {
  assertEquals(deserialize("null"), null);
  assertEquals(deserialize("undefined"), undefined);

  assertEquals(deserialize("true"), true);
  assertEquals(deserialize("false"), false);

  assertEquals(deserialize("30"), 30);
  assertEquals(deserialize("30.1"), 30.1);

  assertEquals(deserialize("30n"), 30n);
  assertEquals(deserialize("-30n"), -30n);
  assertEquals(deserialize("9007199254740991000000n"), 9007199254740991000000n);
  assertEquals(
    deserialize("-9007199254740991000000n"),
    -9007199254740991000000n,
  );

  assertEquals(deserialize('"string"'), "string");
});

Deno.test("deserialize extend scalar", () => {
  assertEquals(deserialize("NaN"), NaN);
  assertEquals(deserialize("Infinity"), Infinity);
  assertEquals(deserialize("-Infinity"), -Infinity);
});

Deno.test("deserialize symbol", () => {
  const symbol1 = deserialize("Symbol()");
  assertEquals(typeof symbol1, "symbol");
  assertEquals(symbol1.description, undefined);

  const symbol2 = deserialize('Symbol("desc1")');
  assertEquals(typeof symbol2, "symbol");
  assertEquals(symbol2.description, "desc1");

  const deserialized = deserialize(
    '[$1,$2,$3,$4];Symbol("sym1");Symbol("sym2");Symbol("sym1");[$2]',
  );
  assertEquals(deserialized[0].description, "sym1");
  assertEquals(deserialized[1].description, "sym2");
  assertEquals(deserialized[2].description, "sym1");

  assertNotStrictEquals(deserialized[0], deserialized[2]);
  assertStrictEquals(
    deserialized[1],
    deserialized[3][0],
  );
});

Deno.test("deserialize built-in Set", () => {
  assertEquals(
    deserialize("Set(1,2,3,4,5)"),
    new Set([1, 2, 3, 4, 5]),
  );
});

Deno.test("deserialize built-in Set circular", () => {
  const deserialized = deserialize("Set($0)");
  assertStrictEquals(
    deserialized,
    [...deserialized][0],
  );
});

Deno.test("deserialize built-in Map", () => {
  assertEquals(
    deserialize(
      'Map("string"=>"this is string",true=>"boolean",null=>"null",$1=>"object");{}',
    ),
    new Map<any, any>([
      ["string", "this is string"],
      [true, "boolean"],
      [null, "null"],
      [{}, "object"],
    ]),
  );
});

Deno.test("deserialize build-in Map deep", () => {
  const map1 = new Map([["key1_1", "value1_1"], ["key1_2", "value1_2"]]);
  const map2 = new Map([["key2_1", "value2_1"], ["key2_2", "value2_2"]]);

  assertEquals(
    deserialize(
      'Map("key1"=>$1,$2=>"val2");Map("key1_1"=>"value1_1","key1_2"=>"value1_2");Map("key2_1"=>"value2_1","key2_2"=>"value2_2")',
    ),
    new Map<any, any>([["key1", map1] as const, [map2, "val2"] as const]),
  );
});

Deno.test("deserialize build-in Map circular", () => {
  const map1 = deserialize("Map($0=>$0)") as Map<any, any>;
  const keys1 = [...map1.keys()];
  assertEquals(keys1.length, 1);

  assertStrictEquals(keys1[0], map1);
  assertStrictEquals(map1.get(map1), map1);

  const map2 = deserialize('Map($0=>"val","key"=>$0)') as Map<any, any>;
  const keys2 = [...map2.keys()];
  assertEquals(keys2.length, 2);
  assertStrictEquals(map2.get(map2), "val");
  assertStrictEquals(map2.get("key"), map2);
});

Deno.test("deserialize array", () => {
  assertEquals(deserialize("[]"), []);

  assertEquals(
    deserialize(
      '[$1,$2,$3];[$4,$5];[1,2];[1];[$6,2,"",false,$7];[$8];{};[];[]',
    ),
    [[[{}, 2, "", false, []], [[]]], [1, 2], [1]],
  );

  assertEquals(
    deserialize('[$1,$2];{"name":"wan2land"};{"name":"wan3land"}'),
    [{ name: "wan2land" }, { name: "wan3land" }],
  );

  assertEquals(
    deserialize('{"users":$1};[$2,$3];{"name":"wan2land"};{"name":"wan3land"}'),
    { users: [{ name: "wan2land" }, { name: "wan3land" }] },
  );

  // also support json
  assertEquals(
    deserialize('[{"name":"wan2land"},{"name":"wan3land"}]'),
    [{ name: "wan2land" }, { name: "wan3land" }],
  );
});

Deno.test("deserialize object", () => {
  assertEquals(deserialize("{}"), {});

  assertEquals(deserialize('{"foo":"foo string","und":undefined}'), {
    foo: "foo string",
    und: undefined,
  });

  assertEquals(
    deserialize('{"string":$1,"true":$2,"false":$3};"string";true;false'),
    { string: "string", true: true, false: false },
  );
});

Deno.test("deserialize object self circular", () => {
  const result = deserialize('{"boolean":false,"self":$0}');

  assertEquals(result.boolean, false);
  assertStrictEquals(result.self, result);
});

Deno.test("deserialize object circular", () => {
  const result = deserialize(
    '{"children":[$1,$2]};{"parent":$0,"sibling":$2};{"parent":$0,"sibling":$1}',
  );

  assertStrictEquals(result.children[0].parent, result);
  assertStrictEquals(result.children[1].parent, result);

  assertStrictEquals(result.children[0].sibling, result.children[1]);
  assertStrictEquals(result.children[1].sibling, result.children[0]);
});

Deno.test("deserialize class object", () => {
  class TestUser {
    age = 0;
    constructor(public name: string) {
    }
  }

  const spyConsole = spy(console, "warn");

  const deserialized = deserialize(
    'TestUser{"name":"wan2land","age":20}',
    { classes: { TestUser } },
  ) as TestUser;

  assertInstanceOf(deserialized, TestUser);

  assertEquals(deserialized.name, "wan2land");
  assertEquals(deserialized.age, 20);

  assertEquals(spyConsole.calls.length, 0);
  spyConsole.restore();
});

Deno.test("deserialize class object undefined", () => {
  const spyConsole = spy(console, "warn");

  assertEquals(
    deserialize(
      'TestUser{"name":"wan2land","age":20}',
    ),
    {
      name: "wan2land",
      age: 20,
    },
  );

  assertSpyCall(
    spyConsole,
    0,
    {
      args: [
        "Class TestUser is not defined. It will be ignored.",
      ],
    },
  );

  spyConsole.restore();
});

Deno.test("deserialize class with private", () => {
  class TestUser {
    #_age = 0;
    constructor(public name: string) {
      this.#_age = 0;
    }

    setAge(age: number) {
      this.#_age = age;
    }

    getAge() {
      return this.#_age;
    }

    [toDeserialize](
      value: {
        name: string;
        age: number;
      },
    ) {
      this.name = value.name;
      this.#_age = value.age;
    }
  }

  const spyConsole = spy(console, "warn");

  const deserialized = deserialize(
    'TestUser{"name":"wan2land","age":20}',
    { classes: { TestUser } },
  ) as TestUser;

  assertInstanceOf(deserialized, TestUser);

  assertEquals(deserialized.name, "wan2land");
  assertEquals(deserialized.getAge(), 20);

  assertEquals(spyConsole.calls.length, 0);

  spyConsole.restore();
});

Deno.test("deserialize class with private", () => {
  class User {
    #comments: Comment[] = [];

    constructor(public name: string) {
    }

    [toDeserialize](
      value: {
        name: string;
        comments: Comment[];
      },
    ) {
      this.name = value.name;
      this.#comments = value.comments;
    }

    writeComment(text: string) {
      this.#comments.push(new Comment(text));
    }

    getComments() {
      return this.#comments;
    }
  }

  class Comment {
    constructor(public text: string) {}
  }

  const deserialized = deserialize(
    'User{"name":"wan2land","comments":$1};[$2,$3];Comment{"text":"hello world 1"};Comment{"text":"hello world 2"}',
    {
      classes: {
        User,
        Comment,
      },
    },
  ) as User;

  assertInstanceOf(deserialized, User);

  assertEquals(deserialized.name, "wan2land");

  const comments = deserialized.getComments();
  assertEquals(comments.length, 2);

  assertInstanceOf(comments[0], Comment);
  assertInstanceOf(comments[1], Comment);
  assertEquals(comments[0].text, "hello world 1");
  assertEquals(comments[1].text, "hello world 2");
});

'''
'''--- deserialize.ts ---
// deno-lint-ignore-file no-explicit-any

import { AstAny, AstRoot, parse } from "./parse.ts";
import { toDeserialize } from "./symbol.ts";

export interface DeserializeOptions {
  // deno-lint-ignore ban-types
  classes?: { [className: string]: ((new (...args: any[]) => any) | Function) };
}

export function deserialize(
  ctx: string,
  options: DeserializeOptions = {},
): any {
  const mapClasses = options.classes ?? {};

  const refs = [] as any[];
  const valueMap = new Map<AstAny, any>();
  const resolvers = [] as (() => void)[];

  function transformAstAny(ast: AstAny) {
    if (ast[0] === 64) {
      const index = ast[1];
      if (index in refs) {
        return refs[index];
      }
      throw new Error(`not found ref $${index}`);
    }
    return transformAstRoot(ast);
  }

  function transformAstRoot(ast: AstRoot) {
    const value = valueMap.get(ast);
    if (value) {
      return value;
    }
    switch (ast[0]) {
      case 0:
        return undefined;
      case 1:
        return null;
      case 2: // boolean
      case 3: // number
      case 4: // bigint
      case 5: // string
        return ast[1];
      case 6: {
        const value = typeof ast[1] === "string" ? Symbol(ast[1]) : Symbol();
        valueMap.set(ast, value);
        return value;
      }
      case 16: {
        const value = [] as any[];
        valueMap.set(ast, value);
        const items = ast[1];
        resolvers.push(() => {
          value.push(...items.map(transformAstAny));
        });
        return value;
      }
      case 17: {
        const name = ast[1];
        const entries = ast[2];

        const baseClass = name ? mapClasses[name] ?? null : null;
        if (name && !baseClass) {
          console.warn(`Class ${name} is not defined. It will be ignored.`);
        }

        const value = baseClass ? Reflect.construct(baseClass, []) : {};
        valueMap.set(ast, value);
        resolvers.push(() => {
          const merged = Object.fromEntries(
            entries.map(([k, v]) => [k[1], transformAstAny(v)]),
          );
          if (typeof value[toDeserialize] === "function") {
            value[toDeserialize](merged);
          } else {
            Object.assign(value, merged);
          }
        });
        return value;
      }
      case 32: {
        const value = ast[2] ? new RegExp(ast[1], ast[2]) : new RegExp(ast[1]);
        valueMap.set(ast, value);
        return value;
      }
      case 33: {
        const value = new Date(ast[1]);
        valueMap.set(ast, value);
        return value;
      }
      case 34: {
        const value = new Set();
        valueMap.set(ast, value);
        const items = ast[1];
        resolvers.push(() => {
          for (const item of items) {
            value.add(transformAstAny(item));
          }
        });
        return value;
      }
      case 35: {
        const value = new Map();
        valueMap.set(ast, value);
        const entries = ast[1];
        resolvers.push(() => {
          for (const [k, v] of entries) {
            value.set(transformAstAny(k), transformAstAny(v));
          }
        });
        return value;
      }
    }
    throw new Error(`wrong ast type(${ast[0]})`);
  }

  for (const [rootIndex, root] of parse(ctx).entries()) {
    refs[rootIndex] = transformAstRoot(root);
  }

  let resolver: (() => void) | undefined;
  while ((resolver = resolvers.shift())) {
    resolver();
  }

  return refs[0];
}

'''
'''--- mod.ts ---
export { Serializer } from "./serializer.ts";

export { serialize } from "./serialize.ts";
export { deserialize } from "./deserialize.ts";

export { toDeserialize, toSerialize } from "./symbol.ts";

'''
'''--- parse.test.ts ---
import { assertEquals } from "https://deno.land/std@0.131.0/testing/asserts.ts";

import { parse } from "./parse.ts";

Deno.test("parse undefined", () => {
  assertEquals(parse("undefined"), [[0]]);
  assertEquals(parse("  undefined  "), [[0]]);
});

Deno.test("parse null", () => {
  assertEquals(parse("null"), [[1]]);
  assertEquals(parse("  null  "), [[1]]);
});

Deno.test("parse boolean", () => {
  assertEquals(parse("true"), [[2, true]]);
  assertEquals(parse("false"), [[2, false]]);

  assertEquals(parse("  true  "), [[2, true]]);
  assertEquals(parse("  false  "), [[2, false]]);
});

Deno.test("parse number", () => {
  assertEquals(parse("30"), [[3, 30]]);
  assertEquals(parse("30."), [[3, 30]]);
  assertEquals(parse("30.1"), [[3, 30.1]]);
  assertEquals(parse("30.1e+5"), [[3, 3010000]]);
  assertEquals(parse("30.1e-5"), [[3, 0.000301]]);
  assertEquals(parse("-30"), [[3, -30]]);
  assertEquals(parse("-30."), [[3, -30]]);
  assertEquals(parse("-30.1"), [[3, -30.1]]);
  assertEquals(parse("-30.1e+5"), [[3, -3010000]]);
  assertEquals(parse("-30.1e-5"), [[3, -0.000301]]);

  assertEquals(parse("  30  "), [[3, 30]]);
  assertEquals(parse("  30.  "), [[3, 30]]);
  assertEquals(parse("  30.1  "), [[3, 30.1]]);
  assertEquals(parse("  30.1e+5  "), [[3, 3010000]]);
  assertEquals(parse("  30.1e-5  "), [[3, 0.000301]]);
  assertEquals(parse("  -30  "), [[3, -30]]);
  assertEquals(parse("  -30.  "), [[3, -30]]);
  assertEquals(parse("  -30.1  "), [[3, -30.1]]);
  assertEquals(parse("  -30.1e+5  "), [[3, -3010000]]);
  assertEquals(parse("  -30.1e-5  "), [[3, -0.000301]]);
});

Deno.test("parse bigint", () => {
  assertEquals(parse("30n"), [[4, 30n]]);
  assertEquals(parse("-30n"), [[4, -30n]]);
  assertEquals(parse("9007199254740991000000n"), [[
    4,
    9007199254740991000000n,
  ]]);
  assertEquals(parse("-9007199254740991000000n"), [[
    4,
    -9007199254740991000000n,
  ]]);

  assertEquals(parse("  30n  "), [[4, 30n]]);
  assertEquals(parse("  -30n  "), [[4, -30n]]);
  assertEquals(parse("  9007199254740991000000n  "), [[
    4,
    9007199254740991000000n,
  ]]);
  assertEquals(parse("  -9007199254740991000000n  "), [[
    4,
    -9007199254740991000000n,
  ]]);
});

Deno.test("parse NaN & Infinity", () => {
  assertEquals(parse("NaN"), [[3, NaN]]);
  assertEquals(parse("Infinity"), [[3, Infinity]]);
  assertEquals(parse("-Infinity"), [[3, -Infinity]]);
});

Deno.test("parse string", () => {
  assertEquals(parse('"string"'), [[5, "string"]]);
  assertEquals(parse('"str\\nin\\\\g"'), [[5, "str\nin\\g"]]);

  assertEquals(parse('   "string"   '), [[5, "string"]]);
  assertEquals(parse('  "str\\nin\\\\g"  '), [[5, "str\nin\\g"]]);
});

Deno.test("parse array", () => {
  assertEquals(parse("[]"), [[16, []]]);
  assertEquals(parse('[null,true,false,1,10n,"..."]'), [[16, [
    [1],
    [2, true],
    [2, false],
    [3, 1],
    [4, 10n],
    [5, "..."],
  ]]]);

  assertEquals(parse("  [  ]  "), [[16, []]]);
  assertEquals(
    parse('  [  null  ,  true  ,  false  ,  1  ,  10n  ,  "..."  ]  '),
    [[
      16,
      [
        [1],
        [2, true],
        [2, false],
        [3, 1],
        [4, 10n],
        [5, "..."],
      ],
    ]],
  );
});

Deno.test("parse object", () => {
  assertEquals(parse("{}"), [[17, null, []]]);
  assertEquals(parse('{"name":"wan2land","age":20}'), [[17, null, [
    [[5, "name"], [5, "wan2land"]],
    [[5, "age"], [3, 20]],
  ]]]);
  assertEquals(parse("Something{}"), [[17, "Something", []]]);
  assertEquals(parse("something{}"), [[17, "something", []]]);

  assertEquals(parse("  {  }  "), [[17, null, []]]);
  assertEquals(parse('  {  "name"  :  "wan2land"  ,  "age"  :  20  }  '), [[
    17,
    null,
    [
      [[5, "name"], [5, "wan2land"]],
      [[5, "age"], [3, 20]],
    ],
  ]]);
  assertEquals(parse("  Something  {  }  "), [[17, "Something", []]]);
  assertEquals(parse("  something  {  }  "), [[17, "something", []]]);
});

Deno.test("parse regexp", () => {
  assertEquals(parse("/a/"), [[32, "a", null]]);
  assertEquals(parse("/a\\\\/gmi"), [[32, "a\\\\", "gmi"]]);
  assertEquals(parse("/a/img"), [[32, "a", "img"]]);

  assertEquals(parse("  /a/  "), [[32, "a", null]]);
  assertEquals(parse("  /a\\\\/gmi  "), [[32, "a\\\\", "gmi"]]);
  assertEquals(parse("  /a/img  "), [[32, "a", "img"]]);
});

Deno.test("parse symbol", () => {
  assertEquals(parse("Symbol()"), [[6, null]]);
  assertEquals(parse('Symbol("description")'), [[6, "description"]]);

  assertEquals(parse("  Symbol  (  )  "), [[6, null]]);
  assertEquals(parse('  Symbol  (  "description"  )  '), [[6, "description"]]);
});

Deno.test("parse built-in Date", () => {
  assertEquals(parse("Date(123456)"), [[33, 123456]]);
  assertEquals(parse("Date(-123456)"), [[33, -123456]]);

  assertEquals(parse("  Date  (  123456  )  "), [[33, 123456]]);
  assertEquals(parse("  Date  (  -123456  )  "), [[33, -123456]]);
});

Deno.test("parse built-in Set", () => {
  assertEquals(
    parse("Set(1,2,3,4,5)"),
    [[34, [[3, 1], [3, 2], [3, 3], [3, 4], [3, 5]]]],
  );

  assertEquals(
    parse("  Set ( 1 , 2 , 3 , 4 , 5 )  "),
    [[34, [[3, 1], [3, 2], [3, 3], [3, 4], [3, 5]]]],
  );
});

Deno.test("parse built-in Map", () => {
  assertEquals(
    parse(
      'Map("string"=>"this is string",true=>"boolean",null=>"null",$1=>"object")',
    ),
    [[35, [
      [
        [5, "string"],
        [5, "this is string"],
      ],
      [
        [2, true],
        [5, "boolean"],
      ],
      [
        [1],
        [5, "null"],
      ],
      [
        [64, 1],
        [5, "object"],
      ],
    ]]],
  );

  assertEquals(
    parse(
      '  Map  (  "string"  =>  "this is string"  ,  true  =>  "boolean"  ,  null  =>  "null"  ,  $1  =>  "object"  )  ',
    ),
    [[35, [
      [
        [5, "string"],
        [5, "this is string"],
      ],
      [
        [2, true],
        [5, "boolean"],
      ],
      [
        [1],
        [5, "null"],
      ],
      [
        [64, 1],
        [5, "object"],
      ],
    ]]],
  );
});

Deno.test("parse ref", () => {
  assertEquals(parse("[$0]"), [[16, [[64, 0]]]]);
  assertEquals(parse('{"a":$2}'), [[17, null, [[[5, "a"], [64, 2]]]]]);

  assertEquals(parse("  [  $0  ]  "), [[16, [[64, 0]]]]);
  assertEquals(parse('  {  "a"  :  $2  }  '), [[17, null, [[[5, "a"], [
    64,
    2,
  ]]]]]);
});

Deno.test("parse multiple roots", () => {
  assertEquals(parse("1;2;3"), [[3, 1], [3, 2], [3, 3]]);
  assertEquals(parse(" 1  ;  2  ;  3  "), [[3, 1], [3, 2], [3, 3]]);
});

'''
'''--- parse.ts ---
const NUM_CHARS = new Set(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]);

export type AstRoot =
  | AstUndefined
  | AstNull
  | AstBool
  | AstNumber
  | AstBigInt
  | AstString
  | AstSymbol
  | AstArray
  | AstObject
  | AstRegExp
  | AstDate
  | AstSet
  | AstMap;

export type AstAny = AstRoot | AstRef;

export type AstUndefined = [type: 0];
export type AstNull = [type: 1];
export type AstBool = [type: 2, value: boolean];
export type AstNumber = [type: 3, value: number];
export type AstBigInt = [type: 4, value: bigint];
export type AstString = [type: 5, value: string];
export type AstSymbol = [type: 6, description: string | null];

export type AstArray = [type: 16, items: AstAny[]];
export type AstObject = [
  type: 17,
  name: string | null,
  entries: [AstString, AstAny][],
];

export type AstRegExp = [type: 32, pattern: string, flags: string | null];
export type AstDate = [type: 33, timestamp: number];
export type AstSet = [type: 34, items: AstAny[]];
export type AstMap = [type: 35, entries: [AstAny, AstAny][]];

export type AstRef = [type: 64, index: number];

let buf = "";
let pos = 0;

function consume(s: string) {
  for (const c of s) {
    if (buf[pos] !== c) {
      throw error();
    }
    pos++;
  }
}

function white() {
  while (1) {
    switch (buf[pos]) {
      case "\t":
      case "\v":
      case "\f":
      case " ":
      case "\u00A0":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        pos++;
        break;
      default:
        return;
    }
  }
}

function error() {
  return new SyntaxError(
    `Unexpected ${
      buf[pos] ? `token ${buf[pos]}` : "end"
    } in SuperSerial at position ${pos}`,
  );
}

function parseAny(): AstAny {
  white();
  if (buf[pos] === "$") {
    pos++;
    let result = "";
    while (NUM_CHARS.has(buf[pos])) {
      result += buf[pos++];
    }
    return [64, +result];
  }
  return parseRoot();
}

function parseRoot(): AstRoot {
  white();
  switch (buf[pos]) {
    case "-":
    case "0":
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9": {
      return parseNumber();
    }
    case '"':
      return parseString();
    case "[":
      return parseArray();
    case "/":
      return parseRegExp();
    default: {
      const name = keyword();
      switch (name) {
        case "null":
          return [1];
        case "true":
          return [2, true];
        case "false":
          return [2, false];
      }
      if (buf[pos] === "{") {
        return parseObject(name);
      }
      switch (name) {
        case "undefined":
          return [0];
        case "NaN":
          return [3, NaN];
        case "Infinity":
          return [3, Infinity];
      }
      if (buf[pos] === "(") {
        switch (name) {
          case "Map":
            return parseMap();
          case "Set":
            return parseSet();
          case "Date":
            return parseDate();
          case "Symbol":
            return parseSymbol();
          default:
            throw error();
        }
      }
    }
  }

  throw error();
}

function parseNumber(): AstNumber | AstBigInt {
  let result = "";
  let mult = 1;

  if (buf[pos] === "-") {
    pos++;
    mult = -1;
  }
  if (buf[pos] === "I") {
    pos++;
    consume("nfinity");
    return [3, mult * Infinity];
  }
  if (NUM_CHARS.has(buf[pos])) {
    result += buf[pos++];
  } else {
    throw error();
  }
  while (NUM_CHARS.has(buf[pos])) {
    result += buf[pos++];
  }
  if (buf[pos] === "n") {
    pos++;
    return [4, BigInt(result) * BigInt(mult)];
  } else {
    if (buf[pos] === ".") {
      result += buf[pos++];
      while (NUM_CHARS.has(buf[pos])) {
        result += buf[pos++];
      }
    }
    if (buf[pos] === "e" || buf[pos] === "E") {
      result += buf[pos++];
      if (buf[pos] === "-" || buf[pos] === "+") {
        result += buf[pos++];
      }
      if (NUM_CHARS.has(buf[pos])) {
        result += buf[pos++];
      } else {
        throw error();
      }
      while (NUM_CHARS.has(buf[pos])) {
        result += buf[pos++];
      }
    }
  }
  return [3, +result * mult];
}

function parseString(): AstString {
  let result = "";
  pos++;
  while (1) {
    switch (buf[pos]) {
      case '"':
        pos++;
        return [5, result];
      case "\\":
        pos++;
        switch (buf[pos]) {
          case "u": {
            pos++;
            let uffff = 0;
            for (let i = 0; i < 4; i++) {
              const hex = parseInt(buf[pos], 16);
              if (!isFinite(hex)) {
                throw error();
              }
              pos++;
              uffff = uffff * 16 + hex;
            }
            result += String.fromCharCode(uffff);
            continue;
          }
          case '"':
            pos++;
            result += '"';
            continue;
          case "\\":
            pos++;
            result += "\\";
            continue;
          case "b":
            pos++;
            result += "\b";
            continue;
          case "f":
            pos++;
            result += "\f";
            continue;
          case "n":
            pos++;
            result += "\n";
            continue;
          case "r":
            pos++;
            result += "\r";
            continue;
          case "t":
            pos++;
            result += "\t";
            continue;
        }
        break;
      default:
        result += buf[pos++];
        continue;
    }
    break;
  }
  throw error();
}

function parseArray(): AstArray {
  pos++;
  white();
  if (buf[pos] === "]") {
    pos++;
    return [16, []];
  }

  const result = [] as AstAny[];
  result.push(parseAny());

  white();
  while (buf[pos] === ",") {
    pos++;
    result.push(parseAny());
    white();
  }
  if (buf[pos] === "]") {
    pos++;
    return [16, result];
  }
  throw error();
}

function parseObject(name: string | null = null): AstObject {
  pos++;
  white();
  if (buf[pos] === "}") {
    pos++;
    return [17, name, []];
  }
  const result = [] as [AstString, AstAny][];
  while (1) {
    const key = parseString(); // TODO Symbol
    white();
    if (buf[pos] !== ":") {
      throw error();
    }
    pos++;
    result.push([key, parseAny()]);
    white();
    if (buf[pos] === ",") {
      pos++;
      white();
      continue;
    }
    if (buf[pos] === "}") {
      pos++;
      return [17, name, result];
    }
    break;
  }
  throw error();
}

function parseRegExp(): AstRegExp {
  pos++;
  let pattern = "";
  if (buf[pos] === "/") {
    throw error();
  }
  while (buf[pos]) {
    if (buf[pos] === "/") {
      pos++;
      switch (buf[pos]) {
        case "i": {
          pos++;
          switch (buf[pos]) {
            case "m": {
              pos++;
              if (buf[pos] === "g") {
                pos++;
                return [32, pattern, "img"];
              } else {
                return [32, pattern, "im"];
              }
            }
            case "g": {
              pos++;
              if (buf[pos] === "m") {
                pos++;
                return [32, pattern, "igm"];
              } else {
                return [32, pattern, "ig"];
              }
            }
            default: {
              return [32, pattern, "i"];
            }
          }
        }
        case "m": {
          pos++;
          switch (buf[pos]) {
            case "i": {
              pos++;
              if (buf[pos] === "g") {
                pos++;
                return [32, pattern, "mig"];
              } else {
                return [32, pattern, "mi"];
              }
            }
            case "g": {
              pos++;
              if (buf[pos] === "i") {
                pos++;
                return [32, pattern, "mgi"];
              } else {
                return [32, pattern, "mg"];
              }
            }
            default: {
              return [32, pattern, "m"];
            }
          }
        }
        case "g": {
          pos++;
          switch (buf[pos]) {
            case "m": {
              pos++;
              if (buf[pos] === "i") {
                pos++;
                return [32, pattern, "gmi"];
              } else {
                return [32, pattern, "gm"];
              }
            }
            case "i": {
              pos++;
              if (buf[pos] === "m") {
                pos++;
                return [32, pattern, "gim"];
              } else {
                return [32, pattern, "gi"];
              }
            }
            default: {
              return [32, pattern, "g"];
            }
          }
        }
      }
      return [32, pattern, null];
    } else if (buf[pos] === "\\") {
      pattern += buf[pos++];
      pattern += buf[pos++];
    } else {
      pattern += buf[pos++];
    }
  }
  throw error();
}

function parseSet(): AstSet {
  pos++;
  white();
  if (buf[pos] === ")") {
    pos++;
    return [34, []];
  }

  const items = [] as AstAny[];
  items.push(parseAny());

  white();
  while (buf[pos] === ",") {
    pos++;
    items.push(parseAny());
    white();
  }
  if (buf[pos] === ")") {
    pos++;
    return [34, items];
  }
  throw error();
}

function parseMap(): AstMap {
  pos++;
  white();
  if (buf[pos] === ")") {
    pos++;
    return [35, []];
  }
  const entries = [] as [AstAny, AstAny][];
  while (1) {
    const key = parseAny();
    white();
    consume("=>");
    white();
    const value = parseAny();
    entries.push([key, value]);
    white();
    if (buf[pos] === ",") {
      pos++;
      white();
      continue;
    }
    if (buf[pos] === ")") {
      pos++;
      break;
    }
    throw error();
  }
  return [35, entries];
}

function parseSymbol(): AstSymbol {
  pos++;
  white();
  if (buf[pos] === ")") {
    pos++;
    return [6, null];
  }
  if (buf[pos] === '"') {
    const valueString = parseString();
    white();
    if (buf[pos] === ")") {
      pos++;
      return [6, valueString[1]];
    }
  }
  throw error();
}

function parseDate(): AstDate {
  pos++;
  white();
  let value = "";
  let mult = 1;
  if (buf[pos] === "-") {
    pos++;
    mult = -1;
  }
  if (NUM_CHARS.has(buf[pos])) {
    value += buf[pos++];
  } else {
    throw error();
  }
  while (NUM_CHARS.has(buf[pos])) {
    value += buf[pos++];
  }
  if (buf[pos] === ".") {
    value += buf[pos++];
    while (NUM_CHARS.has(buf[pos])) {
      value += buf[pos++];
    }
  }
  if (buf[pos] === "e" || buf[pos] === "E") {
    value += buf[pos++];
    if (buf[pos] === "-" || buf[pos] === "+") {
      value += buf[pos++];
    }
    if (NUM_CHARS.has(buf[pos])) {
      value += buf[pos++];
    } else {
      throw error();
    }
    while (NUM_CHARS.has(buf[pos])) {
      value += buf[pos++];
    }
  }
  white();
  if (buf[pos] === ")") {
    pos++;
    return [33, +value * mult];
  }
  throw error();
}

function keyword(): string | null {
  let chartCode = buf.charCodeAt(pos);
  let result = "";
  if (
    chartCode >= 65 && chartCode <= 90 || // UPPERCASE
    chartCode >= 97 && chartCode <= 122 || // lowercase
    chartCode === 95 // _
  ) {
    result += buf[pos++];
  } else {
    return null;
  }
  while ((chartCode = buf.charCodeAt(pos))) {
    if (
      chartCode >= 65 && chartCode <= 90 || // UPPERCASE
      chartCode >= 97 && chartCode <= 122 || // lowercase
      chartCode >= 48 && chartCode <= 57 || // number
      chartCode === 95 // _
    ) {
      result += buf[pos++];
    } else {
      break;
    }
  }
  white();
  return result;
}

export function parse(
  ctx: string,
): AstRoot[] {
  buf = ctx;
  pos = 0;

  const roots = [] as AstRoot[];
  roots.push(parseRoot());
  white();
  while (buf[pos] === ";") {
    pos++;
    roots.push(parseRoot());
    white();
  }

  if (buf.length !== pos) {
    throw error();
  }

  return roots;
}

'''
'''--- scripts/build_npm.ts ---
import { build, emptyDir } from "https://deno.land/x/dnt@0.22.0/mod.ts";

const cmd = Deno.run({ cmd: ["git", "describe", "--tags"], stdout: "piped" });
const version = new TextDecoder().decode(await cmd.output()).trim();
cmd.close();

await emptyDir("./.npm");

await build({
  entryPoints: ["./mod.ts"],
  outDir: "./.npm",
  shims: {
    deno: false,
  },
  test: false,
  package: {
    name: "superserial",
    version,
    description:
      "superserial provides serialization in any way you can imagine",
    keywords: ["serialize", "JSON", "flatted", "circular"],
    license: "MIT",
    repository: {
      type: "git",
      url: "git+https://github.com/denostack/superserial.git",
    },
    bugs: {
      url: "https://github.com/denostack/superserial/issues",
    },
  },
});

// post build steps
Deno.copyFileSync("README.md", ".npm/README.md");

'''
'''--- serialize.test.ts ---
// deno-lint-ignore-file no-explicit-any

import { assertEquals } from "https://deno.land/std@0.131.0/testing/asserts.ts";
import { serialize } from "./serialize.ts";
import { toSerialize } from "./symbol.ts";

Deno.test("serialize scalar", () => {
  assertEquals(serialize(null), "null");
  assertEquals(serialize(undefined), "undefined");

  assertEquals(serialize(true), "true");
  assertEquals(serialize(false), "false");

  assertEquals(serialize(30), "30");
  assertEquals(serialize(30.1), "30.1");

  assertEquals(serialize(30n), "30n");
  assertEquals(serialize(-30n), "-30n");
  assertEquals(
    serialize(9007199254740991000000n),
    "9007199254740991000000n",
  );
  assertEquals(
    serialize(-9007199254740991000000n),
    "-9007199254740991000000n",
  );

  assertEquals(serialize("string"), '"string"');
});

Deno.test("serialize extend scalar", () => {
  assertEquals(serialize(NaN), "NaN");
  assertEquals(serialize(Infinity), "Infinity");
  assertEquals(serialize(-Infinity), "-Infinity");
});

Deno.test("serialize symbol", () => {
  assertEquals(serialize(Symbol()), "Symbol()");
  assertEquals(serialize(Symbol("desc1")), 'Symbol("desc1")');

  const symbol1 = Symbol("sym1");
  const symbol2 = Symbol("sym2");
  assertEquals(
    serialize([symbol1, symbol2, Symbol("sym1"), [symbol2]]),
    '[$1,$2,$3,$4];Symbol("sym1");Symbol("sym2");Symbol("sym1");[$2]',
  );
});

Deno.test("serialize built-in Set", () => {
  assertEquals(serialize(new Set([1, 2, 3, 4, 5])), "Set(1,2,3,4,5)");
});

Deno.test("serialize built-in Set circular", () => {
  const set = new Set();
  set.add(set);
  assertEquals(serialize(set), "Set($0)");
});

Deno.test("serialize built-in Map", () => {
  assertEquals(
    serialize(
      new Map<any, any>([
        ["string", "this is string"],
        [true, "boolean"],
        [null, "null"],
        [{}, "object"],
      ]),
    ),
    'Map("string"=>"this is string",true=>"boolean",null=>"null",$1=>"object");{}',
  );
});

Deno.test("serialize build-in Map deep", () => {
  const map1 = new Map([["key1_1", "value1_1"], ["key1_2", "value1_2"]]);
  const map2 = new Map([["key2_1", "value2_1"], ["key2_2", "value2_2"]]);

  assertEquals(
    serialize(
      new Map<any, any>([["key1", map1] as const, [map2, "val2"] as const]),
    ),
    'Map("key1"=>$1,$2=>"val2");Map("key1_1"=>"value1_1","key1_2"=>"value1_2");Map("key2_1"=>"value2_1","key2_2"=>"value2_2")',
  );
});

Deno.test("serialize build-in Map circular", () => {
  const map1 = new Map<any, any>();
  map1.set(map1, map1);

  assertEquals(
    serialize(map1),
    "Map($0=>$0)",
  );

  const map2 = new Map<any, any>();
  map2.set(map2, "val");
  map2.set("key", map2);

  assertEquals(
    serialize(map2),
    'Map($0=>"val","key"=>$0)',
  );
});

Deno.test("serialize built-in Date", () => {
  assertEquals(serialize(new Date(1640962800000)), "Date(1640962800000)");
});

Deno.test("serialize regex", () => {
  assertEquals(serialize(/abc/), "/abc/");

  assertEquals(serialize(/abc/gmi), "/abc/gim");
});

Deno.test("serialize array", () => {
  assertEquals(serialize([]), "[]");

  assertEquals(
    serialize([[[{}, 2, "", false, []], [[]]], [1, 2], [1]]),
    '[$1,$2,$3];[$4,$5];[1,2];[1];[$6,2,"",false,$7];[$8];{};[];[]',
  );

  assertEquals(
    serialize([{ name: "wan2land" }, { name: "wan3land" }]),
    '[$1,$2];{"name":"wan2land"};{"name":"wan3land"}',
  );

  assertEquals(
    serialize({ users: [{ name: "wan2land" }, { name: "wan3land" }] }),
    '{"users":$1};[$2,$3];{"name":"wan2land"};{"name":"wan3land"}',
  );
});

Deno.test("serialize object", () => {
  assertEquals(serialize({}), "{}");

  assertEquals(
    serialize({ foo: "foo string", und: undefined }),
    '{"foo":"foo string","und":undefined}',
  );
  assertEquals(
    serialize({ foo: { bar: "bar string" } }),
    '{"foo":$1};{"bar":"bar string"}',
  );
});

Deno.test("serialize object self circular", () => {
  const selfCircular = {} as any;
  selfCircular.selfCircular = selfCircular;
  assertEquals(serialize(selfCircular), '{"selfCircular":$0}');
});

Deno.test("serialize object circular", () => {
  const parent = {} as any;
  const child1 = { parent } as any;
  const child2 = { parent } as any;
  const children = [child1, child2];
  child1.next = child2;
  child1.siblings = children;
  child2.next = child1;
  child2.siblings = children;
  parent.children = children;

  assertEquals(
    serialize(parent),
    '{"children":$1};[$2,$3];{"parent":$0,"next":$3,"siblings":$1};{"parent":$0,"next":$2,"siblings":$1}',
  );
});

Deno.test("serialize function (not support)", () => {
  assertEquals(serialize(function () {}), "{}");
});

Deno.test("serialize class", () => {
  class TestUser {
    #_privateSomething = 1;
    publicSomething = 2;
    constructor(public name: string, public age: number) {
    }
  }

  const user = new TestUser("wan2land", 20);

  assertEquals(
    serialize(user),
    'TestUser{"name":"wan2land","age":20,"publicSomething":2}',
  );
});

Deno.test("serialize class with private", () => {
  class TestUser {
    #_privateSomething = 1;
    publicSomething = 2;
    constructor(public name: string, public age: number) {
    }

    [toSerialize]() {
      return {
        name: this.name,
        age: this.age,
        publicSomething: this.publicSomething,
        privateSomething: this.#_privateSomething,
      };
    }
  }

  const user = new TestUser("wan2land", 20);

  assertEquals(
    serialize(user),
    'TestUser{"name":"wan2land","age":20,"publicSomething":2,"privateSomething":1}',
  );
});

'''
'''--- serialize.ts ---
// deno-lint-ignore-file no-explicit-any
import { toSerialize } from "./symbol.ts";

export interface SerializeOptions {
  prettify?: boolean;
}

export function serialize(value: any, options: SerializeOptions = {}): string {
  let output = "";

  let inc = 0;
  const prettify = options.prettify ?? false;
  let depth = 0;

  const objectMap = new Map<number, any>();
  const objectIndexMap = new Map<any, number>();

  function _stringifyString(value: string): boolean {
    output += `"${value.replace('"', '\\"')}"`; // " 문자는 escape 해야합니다.
    return true;
  }
  function _stringifyScalar(value: any): boolean {
    if (value === null) {
      output += "null";
      return true;
    }
    const typeofValue = typeof value;
    if (typeofValue === "undefined") {
      output += "undefined";
      return true;
    }
    if (typeofValue === "number") {
      if (Number.isNaN(value)) {
        output += "NaN";
        return true;
      }
      if (!Number.isFinite(value)) {
        output += value > 0 ? "Infinity" : "-Infinity";
        return true;
      }
      output += `${value}`;
      return true;
    }
    if (typeofValue === "bigint") {
      output += `${value}n`;
      return true;
    }
    if (typeofValue === "boolean") {
      output += value ? "true" : "false";
      return true;
    }
    if (typeofValue === "string") {
      return _stringifyString(value);
    }
    return false;
  }

  function _stringifyRoot(value: any): boolean {
    if (_stringifyScalar(value)) {
      return true;
    }
    return _stringifyRef(value);
  }

  function _stringifyAny(value: any): boolean {
    if (_stringifyScalar(value)) {
      return true;
    }

    let oIdx = objectIndexMap.get(value);
    if (typeof oIdx !== "number") {
      oIdx = inc++;
      objectIndexMap.set(value, oIdx);
      objectMap.set(oIdx, value);
    }
    output += `$${oIdx}`;
    return true;
  }

  function _stringifyRef(value: any): boolean {
    // simple :-)
    if (typeof value === "symbol") {
      output += "Symbol(";
      if (value.description) {
        _stringifyString(value.description);
      }
      output += ")";
      return true;
    }

    if (value instanceof RegExp) {
      output += value.toString();
      return true;
    }

    if (value instanceof Date) {
      output += "Date(";
      _stringifyAny(value.getTime());
      output += ")";
      return true;
    }

    // complex :D
    if (prettify) {
      output += "  ".repeat(depth);
    }

    if (Array.isArray(value)) {
      _stringifyListStart("[");
      _stringifyList(value);
      _stringifyListEnd("]");
      return true;
    }

    if (value instanceof Map) {
      _stringifyListStart("Map(");
      _stringifyMap([...value.entries()]);
      _stringifyListEnd(")");
      return true;
    }
    if (value instanceof Set) {
      _stringifyListStart("Set(");
      _stringifyList([...value]);
      _stringifyListEnd(")");
      return true;
    }

    const name = value.constructor !== Object && value.constructor !== Function
      ? value.constructor.name
      : "";

    _stringifyListStart(prettify && name ? `${name} {` : `${name}{`);
    _stringifyKv(
      Object.entries(
        typeof value[toSerialize] === "function" ? value[toSerialize]() : value,
      ),
    );
    _stringifyListEnd("}");
    return true;
  }

  const _stringifyListStart = prettify
    ? (name: string) => {
      output += name;
      output += "\n";
      depth++;
    }
    : (name: string) => {
      output += name;
      depth++;
    };

  const _stringifyListEnd = prettify
    ? (name: string) => {
      depth--;
      output += "\n";
      output += "  ".repeat(depth);
      output += name;
    }
    : (name: string) => {
      depth--;
      output += name;
    };

  const _stringifyList = prettify
    ? (value: any[]) => {
      for (let i = 0; i < value.length; i++) {
        if (i > 0) {
          output += ",\n";
        }
        output += "  ".repeat(depth);
        _stringifyAny(value[i]);
      }
    }
    : (value: any[]) => {
      for (let i = 0; i < value.length; i++) {
        if (i > 0) {
          output += ",";
        }
        _stringifyAny(value[i]);
      }
    };
  const _stringifyMap = prettify
    ? (value: [string, any][]) => {
      for (let i = 0; i < value.length; i++) {
        if (i > 0) {
          output += ",\n";
        }
        output += "  ".repeat(depth);
        _stringifyAny(value[i][0]);
        output += " => ";
        _stringifyAny(value[i][1]);
      }
    }
    : (value: [string, any][]) => {
      for (let i = 0; i < value.length; i++) {
        if (i > 0) {
          output += ",";
        }
        _stringifyAny(value[i][0]);
        output += "=>";
        _stringifyAny(value[i][1]);
      }
    };
  const _stringifyKv = prettify
    ? (value: [string, any][]) => {
      for (let i = 0; i < value.length; i++) {
        if (i > 0) {
          output += ",\n";
        }
        output += "  ".repeat(depth);
        _stringifyString(value[i][0]);
        output += ": ";
        _stringifyAny(value[i][1]);
      }
    }
    : (value: [string, any][]) => {
      for (let i = 0; i < value.length; i++) {
        if (i > 0) {
          output += ",";
        }
        _stringifyString(value[i][0]);
        output += ":";
        _stringifyAny(value[i][1]);
      }
    };

  inc++;
  objectIndexMap.set(value, 0);
  objectMap.set(0, value);

  _stringifyRoot(value);
  for (let i = 1; i < inc; i++) {
    output += ";";
    if (prettify) {
      output += "\n";
    }
    _stringifyRoot(objectMap.get(i));
  }
  return output;
}

'''
'''--- serializer.bench.ts ---
import { Serializer } from "./serializer.ts";

const serializer = new Serializer();

Deno.bench("serialize #Serializer.serialize", () => {
  serializer.serialize({
    string: "String",
    number: 1000.0,
    true: true,
    false: false,
    null: null,
    array: [1, 2, 3, 4, 5],
    object: {
      itesm: [{ name: 1 }, { name: 2 }, { name: 3 }],
    },
  });
});

Deno.bench("serialize #JSON.stringify", () => {
  JSON.stringify({
    string: "String",
    number: 1000.0,
    true: true,
    false: false,
    null: null,
    array: [1, 2, 3, 4, 5],
    object: {
      itesm: [{ name: 1 }, { name: 2 }, { name: 3 }],
    },
  });
});

const serialized1 = serializer.serialize({
  string: "String",
  number: 1000.0,
  true: true,
  false: false,
  null: null,
  array: [1, 2, 3, 4, 5],
  object: {
    itesm: [{ name: 1 }, { name: 2 }, { name: 3 }],
  },
});
Deno.bench("serialize #Serializer.deserialize", () => {
  serializer.deserialize(serialized1);
});

const serialized2 = JSON.stringify({
  string: "String",
  number: 1000.0,
  true: true,
  false: false,
  null: null,
  array: [1, 2, 3, 4, 5],
  object: {
    itesm: [{ name: 1 }, { name: 2 }, { name: 3 }],
  },
});
Deno.bench("serialize #JSON.parse", () => {
  JSON.parse(serialized2);
});

'''
'''--- serializer.ts ---
// deno-lint-ignore-file no-explicit-any

import { serialize, SerializeOptions } from "./serialize.ts";
import { deserialize } from "./deserialize.ts";

export interface SerializerOptions {
  // deno-lint-ignore ban-types
  classes?: { [className: string]: ((new (...args: any[]) => any) | Function) };
}

export class Serializer {
  constructor(public options?: SerializerOptions) {
  }

  serialize(value: any, options?: SerializeOptions): string {
    return serialize(value, options);
  }

  deserialize<T = any>(code: string): T {
    return deserialize(code, this.options);
  }
}

'''
'''--- symbol.ts ---
export const toSerialize = Symbol("serialize");
export const toDeserialize = Symbol("deserialize");

'''