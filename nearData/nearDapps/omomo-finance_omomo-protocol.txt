*GitHub Repository "omomo-finance/omomo-protocol"*

'''--- .gitbook/assets/mountains_bg (1).svg ---
<svg width="1920" height="343" viewBox="0 0 1920 343" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect opacity="0.1" width="1920" height="343" fill="#6CD78F"/>
<g opacity="0.2">
<mask id="mask0_103_327" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="1920" height="343">
<rect width="1920" height="343" fill="#C4C4C4"/>
</mask>
<g mask="url(#mask0_103_327)">
<path d="M1943.73 -25.6372C1943.73 -25.6372 1857.17 13.9569 1831.39 24.1667C1805.61 34.3765 1746.65 33.1122 1746.65 33.1122H1719.03L1689.54 19.0522L1632.46 45.8697L1556.93 84.1803L1479.56 43.322L1466.69 27.9977L1437.21 31.8288L1286.16 91.8425L1262.23 104.619H1219.85L1170.12 96.9569L1022.77 169.747L839.511 247.652V372.794H1956.63L1943.73 -25.6372Z" fill="url(#paint0_linear_103_327)"/>
<g style="mix-blend-mode:darken">
<path d="M1438.76 102.239L1402.53 122.301L1373.01 159.559V190.245L1335.44 235.987L1310.83 266.882L1402.53 202.55L1459.96 140.777L1556.52 84.3103L1479.8 43.4585C1484.74 69.2527 1438.76 102.239 1438.76 102.239Z" fill="#2C5E5F"/>
</g>
<g style="mix-blend-mode:darken">
<path d="M1837.26 22.0237C1835.04 22.8948 1832.74 23.6546 1830.37 24.2974C1830.37 24.2974 1796.43 54.5053 1771.93 67.8801C1747.43 81.2549 1673.93 118.513 1673.93 118.513C1673.93 118.513 1629.02 171.057 1599.08 183.477C1569.13 195.896 1476.58 244.943 1476.58 244.943L1345.93 369.768H1960.65L1944.6 -30.1758C1944.6 -30.1758 1862.65 11.8398 1837.26 22.0237Z" fill="#33696C"/>
</g>
<path d="M374.612 19.3852H405.041L479.857 9.19092L512.815 19.3852L636.774 113.754L699.533 140.531L881.326 250.182L1099.84 306.049L1290.02 357.288V470.764H-15.8828V178.783C-15.8828 178.783 76.6774 126.492 107.106 121.405C137.535 116.317 228.821 95.8902 228.821 95.8902L345.458 46.1619L374.612 19.3852Z" fill="url(#paint1_linear_103_327)"/>
<g style="mix-blend-mode:overlay" opacity="0.37">
<path d="M27.8584 164.744L197.118 134.142L294.737 89.5207L369.553 39.7925L405.041 19.3848H374.612L345.458 46.1615L228.821 95.8897C228.821 95.8897 137.535 116.297 107.106 121.404C76.6774 126.511 -15.8828 178.783 -15.8828 178.783V203.991L27.8584 164.744Z" fill="#FFFEF7"/>
</g>
<g style="mix-blend-mode:overlay" opacity="0.32">
<path d="M1099.84 306.049L881.328 250.181L699.535 140.53L636.776 113.754L574.283 66.1675L624.072 134.142L759.347 218.298C759.347 218.298 833.802 281.644 836.198 285.048C838.594 288.453 1128.9 313.91 1128.92 313.91L1099.84 306.049Z" fill="#201352"/>
</g>
<path d="M894.664 345.37L683.47 321.466L521.258 285.133L468.234 235.413L424.875 219.158L362.187 163.07L288.814 133.735H234.13C234.13 133.735 138.728 174.85 112.736 178.369C86.7444 181.887 41.4643 201.947 41.4643 201.947L-58 235.413L-17.3219 294.369V568.479H857.328L894.664 345.37Z" fill="url(#paint2_linear_103_327)"/>
<g style="mix-blend-mode:overlay" opacity="0.08">
<path d="M428.509 325.729L388.571 341.986L236.428 435.705V568.957H859.189L894.676 345.812L691.595 322.864L521.62 285.038L466.967 234.604L457.986 266.763L428.509 325.729Z" fill="#201352"/>
</g>
<g style="mix-blend-mode:overlay" opacity="0.08">
<path d="M630.46 332.424L584.456 351.55C584.456 351.55 568.291 386.933 551.174 401.278C534.058 415.623 468.446 443.356 468.446 443.356L418.049 497.866L334.37 612.336L300.651 706.667H437.143L536.036 499.778L612.108 436.662C612.108 436.662 646.34 393.628 664.864 386.933C683.387 380.239 701.739 374.501 715.394 366.851C729.049 359.2 736.618 345.812 759.953 348.681C759.953 348.681 770.109 338.162 796.182 341.03C822.256 343.899 829.464 334.336 829.464 334.336L802.591 316.492L757.279 300.673L740.232 305.212L718.671 310.76L700.621 313.786L661.01 320.343L630.46 332.424Z" fill="#201352"/>
</g>
<g style="mix-blend-mode:overlay" opacity="0.08">
<path d="M990.393 306.048L954.354 329.554L931.533 369.72L901.104 420.404L829.502 454.506L752.422 530.38L729.848 588.715L801.412 505.497L894.676 456.744L975.274 413.71L1027.57 364.938L1094.76 320.317H1059.26L990.393 306.048Z" fill="#201352"/>
</g>
<g style="mix-blend-mode:overlay" opacity="0.08">
<path d="M1311.83 316.308L1280.62 329.728L1257.8 369.893L1227.37 420.577L1155.77 454.679L1078.69 530.553L1056.12 588.888L1127.68 505.67L1220.94 456.917L1301.54 413.883L1353.84 365.111L1420.64 304.204L1376.51 320.49H1330.88L1311.83 316.308Z" fill="#201352"/>
</g>
</g>
</g>
<defs>
<linearGradient id="paint0_linear_103_327" x1="3468.36" y1="-89.1845" x2="1271.97" y2="291.784" gradientUnits="userSpaceOnUse">
<stop offset="0.042546" stop-color="#E1F6C1"/>
<stop offset="0.27" stop-color="#C5E9B5"/>
<stop offset="0.864959" stop-color="#3B777E"/>
<stop offset="1" stop-color="#3B777E"/>
</linearGradient>
<linearGradient id="paint1_linear_103_327" x1="637.059" y1="604.017" x2="637.059" y2="127.774" gradientUnits="userSpaceOnUse">
<stop stop-color="#E1F6C1"/>
<stop offset="0.22" stop-color="#C5E2B4"/>
<stop offset="0.7" stop-color="#77C49B"/>
<stop offset="1" stop-color="#599575"/>
</linearGradient>
<linearGradient id="paint2_linear_103_327" x1="418.332" y1="758.428" x2="418.332" y2="321.352" gradientUnits="userSpaceOnUse">
<stop stop-color="#ABCDAC"/>
<stop offset="0.66" stop-color="#62958E"/>
<stop offset="1" stop-color="#3A767D"/>
</linearGradient>
</defs>
</svg>

'''
'''--- .gitbook/assets/mountains_bg.svg ---
<svg width="1920" height="343" viewBox="0 0 1920 343" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect opacity="0.1" width="1920" height="343" fill="#6CD78F"/>
<g opacity="0.2">
<mask id="mask0_103_327" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="1920" height="343">
<rect width="1920" height="343" fill="#C4C4C4"/>
</mask>
<g mask="url(#mask0_103_327)">
<path d="M1943.73 -25.6372C1943.73 -25.6372 1857.17 13.9569 1831.39 24.1667C1805.61 34.3765 1746.65 33.1122 1746.65 33.1122H1719.03L1689.54 19.0522L1632.46 45.8697L1556.93 84.1803L1479.56 43.322L1466.69 27.9977L1437.21 31.8288L1286.16 91.8425L1262.23 104.619H1219.85L1170.12 96.9569L1022.77 169.747L839.511 247.652V372.794H1956.63L1943.73 -25.6372Z" fill="url(#paint0_linear_103_327)"/>
<g style="mix-blend-mode:darken">
<path d="M1438.76 102.239L1402.53 122.301L1373.01 159.559V190.245L1335.44 235.987L1310.83 266.882L1402.53 202.55L1459.96 140.777L1556.52 84.3103L1479.8 43.4585C1484.74 69.2527 1438.76 102.239 1438.76 102.239Z" fill="#2C5E5F"/>
</g>
<g style="mix-blend-mode:darken">
<path d="M1837.26 22.0237C1835.04 22.8948 1832.74 23.6546 1830.37 24.2974C1830.37 24.2974 1796.43 54.5053 1771.93 67.8801C1747.43 81.2549 1673.93 118.513 1673.93 118.513C1673.93 118.513 1629.02 171.057 1599.08 183.477C1569.13 195.896 1476.58 244.943 1476.58 244.943L1345.93 369.768H1960.65L1944.6 -30.1758C1944.6 -30.1758 1862.65 11.8398 1837.26 22.0237Z" fill="#33696C"/>
</g>
<path d="M374.612 19.3852H405.041L479.857 9.19092L512.815 19.3852L636.774 113.754L699.533 140.531L881.326 250.182L1099.84 306.049L1290.02 357.288V470.764H-15.8828V178.783C-15.8828 178.783 76.6774 126.492 107.106 121.405C137.535 116.317 228.821 95.8902 228.821 95.8902L345.458 46.1619L374.612 19.3852Z" fill="url(#paint1_linear_103_327)"/>
<g style="mix-blend-mode:overlay" opacity="0.37">
<path d="M27.8584 164.744L197.118 134.142L294.737 89.5207L369.553 39.7925L405.041 19.3848H374.612L345.458 46.1615L228.821 95.8897C228.821 95.8897 137.535 116.297 107.106 121.404C76.6774 126.511 -15.8828 178.783 -15.8828 178.783V203.991L27.8584 164.744Z" fill="#FFFEF7"/>
</g>
<g style="mix-blend-mode:overlay" opacity="0.32">
<path d="M1099.84 306.049L881.328 250.181L699.535 140.53L636.776 113.754L574.283 66.1675L624.072 134.142L759.347 218.298C759.347 218.298 833.802 281.644 836.198 285.048C838.594 288.453 1128.9 313.91 1128.92 313.91L1099.84 306.049Z" fill="#201352"/>
</g>
<path d="M894.664 345.37L683.47 321.466L521.258 285.133L468.234 235.413L424.875 219.158L362.187 163.07L288.814 133.735H234.13C234.13 133.735 138.728 174.85 112.736 178.369C86.7444 181.887 41.4643 201.947 41.4643 201.947L-58 235.413L-17.3219 294.369V568.479H857.328L894.664 345.37Z" fill="url(#paint2_linear_103_327)"/>
<g style="mix-blend-mode:overlay" opacity="0.08">
<path d="M428.509 325.729L388.571 341.986L236.428 435.705V568.957H859.189L894.676 345.812L691.595 322.864L521.62 285.038L466.967 234.604L457.986 266.763L428.509 325.729Z" fill="#201352"/>
</g>
<g style="mix-blend-mode:overlay" opacity="0.08">
<path d="M630.46 332.424L584.456 351.55C584.456 351.55 568.291 386.933 551.174 401.278C534.058 415.623 468.446 443.356 468.446 443.356L418.049 497.866L334.37 612.336L300.651 706.667H437.143L536.036 499.778L612.108 436.662C612.108 436.662 646.34 393.628 664.864 386.933C683.387 380.239 701.739 374.501 715.394 366.851C729.049 359.2 736.618 345.812 759.953 348.681C759.953 348.681 770.109 338.162 796.182 341.03C822.256 343.899 829.464 334.336 829.464 334.336L802.591 316.492L757.279 300.673L740.232 305.212L718.671 310.76L700.621 313.786L661.01 320.343L630.46 332.424Z" fill="#201352"/>
</g>
<g style="mix-blend-mode:overlay" opacity="0.08">
<path d="M990.393 306.048L954.354 329.554L931.533 369.72L901.104 420.404L829.502 454.506L752.422 530.38L729.848 588.715L801.412 505.497L894.676 456.744L975.274 413.71L1027.57 364.938L1094.76 320.317H1059.26L990.393 306.048Z" fill="#201352"/>
</g>
<g style="mix-blend-mode:overlay" opacity="0.08">
<path d="M1311.83 316.308L1280.62 329.728L1257.8 369.893L1227.37 420.577L1155.77 454.679L1078.69 530.553L1056.12 588.888L1127.68 505.67L1220.94 456.917L1301.54 413.883L1353.84 365.111L1420.64 304.204L1376.51 320.49H1330.88L1311.83 316.308Z" fill="#201352"/>
</g>
</g>
</g>
<defs>
<linearGradient id="paint0_linear_103_327" x1="3468.36" y1="-89.1845" x2="1271.97" y2="291.784" gradientUnits="userSpaceOnUse">
<stop offset="0.042546" stop-color="#E1F6C1"/>
<stop offset="0.27" stop-color="#C5E9B5"/>
<stop offset="0.864959" stop-color="#3B777E"/>
<stop offset="1" stop-color="#3B777E"/>
</linearGradient>
<linearGradient id="paint1_linear_103_327" x1="637.059" y1="604.017" x2="637.059" y2="127.774" gradientUnits="userSpaceOnUse">
<stop stop-color="#E1F6C1"/>
<stop offset="0.22" stop-color="#C5E2B4"/>
<stop offset="0.7" stop-color="#77C49B"/>
<stop offset="1" stop-color="#599575"/>
</linearGradient>
<linearGradient id="paint2_linear_103_327" x1="418.332" y1="758.428" x2="418.332" y2="321.352" gradientUnits="userSpaceOnUse">
<stop stop-color="#ABCDAC"/>
<stop offset="0.66" stop-color="#62958E"/>
<stop offset="1" stop-color="#3A767D"/>
</linearGradient>
</defs>
</svg>

'''
'''--- .github/workflows/test.yml ---
name: nearlend-protocol test automatically

on:
  push:
    branches: [master]
  pull_request:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: deepakputhraya/action-branch-name@master
        with:
          regex: '^CU-[a-zA-Z0-9]{7,9}_[\-\_a-zA-Z0-9]*' # Branch name should match CU-${task_id}_${branch_name} 
                                                         # ${task_id} is ticket id from clickup, 
                                                         # ${branch_name} any meaningful name for the branch 
          allowed_prefixes: '' # No prefixes allowed
          ignore: master,develop # Ignore exactly matching branch names from convention
          min_length: 0 # Min length of the branch name
          max_length: 255 # Max length of the branch name

      - uses: actions/checkout@v3
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
          components: rustfmt, clippy
      # cache for dependencies
      #- uses: actions/cache@v3
      #  with:
      #    path: |
      #      ~/.cargo/bin
      #      ~/.cargo/registry/index
      #      ~/.cargo/registry/cache
      #      ~/.cargo/git
      #      ~/.cargo/.crates.toml
      #      ~/.cargo/.crates2.json
      #      contracts/target
      #    key: ${{ runner.os }}-cargo-${{ hashFiles('**/contracts/Cargo.lock') }}
      # linter checks omomo
      #- uses: actions-rs/cargo@v1
      #  with:
      #    command: fmt
      #    args:  --manifest-path ./contracts/Cargo.toml --all -- --check
      #- uses: actions-rs/cargo@v1
      #  with:
      #    command: clippy
      #    args:  --manifest-path ./contracts/Cargo.toml -- -A clippy::too-many-arguments -A clippy::ptr-offset-with-cast -A clippy::assign-op-pattern -A clippy::manual-range-contains -D warnings

      - run: ./build.sh
      #- run: ./test.sh

      # linter checks leverage trading
      - uses: actions-rs/cargo@v1
        with:
          command: fmt
          args: --manifest-path ./contracts/leverage_trading/Cargo.toml --all -- --check
      - uses: actions-rs/cargo@v1
        with:
          command: clippy
          args: --manifest-path ./contracts/leverage_trading/Cargo.toml -- -A clippy::too-many-arguments -A clippy::too-many-arguments -A clippy::ptr-offset-with-cast -A clippy::assign-op-pattern -A clippy::manual-range-contains -A clippy::manual-clamp -D warnings

      - run: cd ./contracts/leverage_trading/ && ./build.sh
      - run: cd ./contracts/leverage_trading/ && ./test.sh

  # deployment:
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 150
  #   steps:
  #     - uses: actions/checkout@v3
  #     - uses: actions-rs/toolchain@v1
  #       with:
  #         toolchain: stable
  #         target: wasm32-unknown-unknown
  #     - uses: actions/setup-node@v3
  #       with:
  #         node-version: 14
  #     - name: use near
  #       run: npm install -g near-cli
  #     - name: deploy
  #       run: |
  #         echo "${{secrets.MAIN_NEAR_CLI_PRIVATE_KEY}}" > ${{secrets.MAIN_NEAR_CLI_PRIVATE_KEY_PATH}}
  #         ./deploy.sh --keyPath=${{secrets.MAIN_NEAR_CLI_PRIVATE_KEY_PATH}}

'''
'''--- README.md ---
---
description: Welcome to the Nearlend guide documentation site.
cover: .gitbook/assets/mountains_bg.svg
coverY: 0
---

# Overview

## What is Nearlend?

NEARLEND is non-custodial lending and borrowing liquidity protocol on the NEAR blockchain.\
The idea of the protocol was firstly implemented on the [Near Hackathon](./) on November 2021. The team presented the initial solution of the decentralized non-custodial lending protocol with multi-collaterallized loans.\
The protocol is aimed to resolve several problems:

* provide non-custodial loans service
* provide support of multi-collaterization of loans for the Near ecosystem - more flexible mechanism than isolated pairs
* provide flexible liquidation mechanism
* provide reliable price feeds update for correct collaterization calculation
* provide moduled structure for the protocol to support DeFi strategies building upon existing markets
* provide support for the interaction with 3rd-party protocol within complex DeFi strategies
* provide foundation for the support of fixed rate loans\
  \
  The main goal of the Nearland is to correspond requirements of DeFi2.0 protocol:
* become modular
* have active management of the liqudity (by user and by the platform in the decentralized way)
* have liquidity actively working
* follow up automatization road for most of operations
* become trully decentralized
*   allow user-based operations, including the registration of the user based markets and including them into the collaterization calculations\
    \

    ### What makes Nearland different?

    NEARLAND aims to bring several DeFi2.0 usecases into the existing NEAR ecosystem:

    * use all liquidity - no isolated pairs, the whole liquidity participates in the collaterisation
    * modularity - the protocol provides building blocks which can and should be included into DeFi strategies built upon opend markets
    * all liquidity should work - provide active management of the locked liquidity and leave the control for the user
    * support customization at the higher level - allow custom markets creation and custom interest rate models and allow users to utilize this functionality

    ### Core contracts

    The protocol has gone through several development iterations in order to correspond to the Near requirements for smart-contracts development. Thus, the architecture of the protocol now relies on the minimal number of independant contracts:
* Controller as an entry point for the user and the central entity of the protocol
* DToken contracs which represent markets and provide the token ready to be included into DeFi strategies
* Oracles connector\
  Check further documentation to get more info !\[Overal look]\(.gitbook/assets/general.png)

'''
'''--- SUMMARY.md ---
# Table of contents

## GENERAL

* [Overview](README.md)
* [Roadmap](general/roadmap.md)

## Product

* [Deposit & Earning](product/supply\_withdraw.md)
* [Borrow](product/borrow.md)
* [Repay](product/repay.md)
* [Liquidation](product/liquidation.md)
* [Interest rate model](product/interest\_rate\_model.md)
* [Tokenomics](product/tokenomics.md)

## Developers

* [Contracts](developers/contracts.md)
* [Contact us](developers/contact.md)

'''
'''--- build.bat ---
cargo build --manifest-path ./contracts/Cargo.toml --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\*.wasm res
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --manifest-path ./contracts/Cargo.toml --target wasm32-unknown-unknown --release

'''
'''--- build_clean.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo clean --manifest-path ./contracts/Cargo.toml
'''
'''--- contracts/Cargo.toml ---
[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = [
    "general",
    "controller",
    "market",
    "mock-token",
    "token",
]
exclude = [
    "leverage_trading"
]

'''
'''--- contracts/controller/Cargo.toml ---
[package]
name = "controller"
version = "0.0.1"
authors = ["mark.ts@blaize.tech", "tymofii.s@blaize.tech", "vladyslav.v@blaize.tech", "orest.o@blaize.tech", "sergii.p@blaize.tech"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.6"
percentage = "0.1.0"
assert_matches = "1.5.0"
general = { path = "../general" }
partial-min-max = "0.4.0"
near-sys = "0.2.0"

'''
'''--- contracts/controller/src/admin.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, require, AccountId};
use std::collections::HashMap;

use general::ratio::Ratio;

use crate::*;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum MethodType {
    Withdraw,
    Repay,
    Supply,
    Liquidate,
    Borrow,
    Deposit,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub struct Market {
    pub asset_id: AccountId,
    pub dtoken: AccountId,
    pub ticker_id: String,
}

#[near_bindgen]
impl Contract {
    pub fn get_admin(&self) -> AccountId {
        self.admin.clone()
    }

    pub fn set_admin(&mut self, account: AccountId) {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );
        self.admin = account;
    }

    pub fn get_eligible_to_borrow_uncollateralized_account(&self) -> AccountId {
        self.eligible_to_borrow_uncollateralized.clone()
    }

    pub fn set_eligible_to_borrow_uncollateralized_account(&mut self, account: AccountId) {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );
        self.eligible_to_borrow_uncollateralized = account;
    }

    pub fn is_allowed_to_borrow_uncollateralized(&self, account: AccountId) -> bool {
        account == self.eligible_to_borrow_uncollateralized
    }

    #[private]
    pub fn is_valid_admin_call(&self) -> bool {
        env::signer_account_id() == self.admin
            || env::signer_account_id() == env::current_account_id()
    }

    #[private]
    pub fn is_dtoken_caller(&self) -> bool {
        self.markets
            .values()
            .any(|profile| profile.dtoken == env::predecessor_account_id())
    }

    pub fn get_markets_list(&self) -> Vec<Market> {
        return self
            .markets
            .iter()
            .map(|(asset_id, market)| Market {
                asset_id,
                dtoken: market.dtoken,
                ticker_id: market.ticker_id,
            })
            .collect::<Vec<Market>>();
    }

    pub fn get_tickers_dtoken_hash(&self) -> HashMap<String, AccountId> {
        let mut result: HashMap<String, AccountId> = HashMap::new();
        self.markets.iter().for_each(|(_, market)| {
            result.insert(market.ticker_id, market.dtoken);
        });
        result
    }

    pub fn get_utoken_tickers_hash(&self) -> HashMap<AccountId, String> {
        let mut result: HashMap<AccountId, String> = HashMap::new();
        self.markets.iter().for_each(|(asset_id, market)| {
            result.insert(asset_id, market.ticker_id);
        });
        result
    }

    pub fn add_market(
        &mut self,
        asset_id: AccountId,
        dtoken: AccountId,
        ticker_id: String,
        ltv: Ratio,
        lth: Ratio,
    ) {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );

        let market = MarketProfile {
            dtoken,
            ticker_id,
            ltv,
            lth,
        };

        self.markets.insert(&asset_id, &market);
    }

    pub fn remove_market(&mut self, key: AccountId) {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );

        require!(
            self.markets.get(&key).is_some(),
            "Asset by this key doesnt exist"
        );

        self.markets.remove(&key);
    }

    pub fn get_liquidation_incentive(&self) -> Ratio {
        // TODO: Move this kind of getter that don't require admin rights somewhere else
        // incentive % + 100 %
        self.liquidation_incentive + Ratio::one()
    }

    pub fn get_liquidation_threshold(&self) -> Ratio {
        Ratio::one()
    }

    pub fn set_liquidation_incentive(mut self, value: Ratio) {
        require!(
            self.is_valid_admin_call(),
            "this functionality is allowed to be called by admin or contract only"
        );

        self.liquidation_incentive = value;
    }

    pub fn pause_method(mut self, method: MethodType) {
        require!(
            self.is_valid_admin_call(),
            "this functionality is allowed to be called by admin or contract only"
        );

        match method {
            MethodType::Withdraw => self.is_action_paused.withdraw = true,
            MethodType::Repay => self.is_action_paused.repay = true,
            MethodType::Supply => self.is_action_paused.supply = true,
            MethodType::Liquidate => self.is_action_paused.liquidate = true,
            MethodType::Borrow => self.is_action_paused.borrow = true,
            MethodType::Deposit => self.is_action_paused.deposit = true,
        }
    }

    pub fn proceed_method(mut self, method: MethodType) {
        require!(
            self.is_valid_admin_call(),
            "this functionality is allowed to be called by admin or contract only"
        );

        match method {
            MethodType::Withdraw => self.is_action_paused.withdraw = false,
            MethodType::Repay => self.is_action_paused.repay = false,
            MethodType::Supply => self.is_action_paused.supply = false,
            MethodType::Liquidate => self.is_action_paused.liquidate = false,
            MethodType::Borrow => self.is_action_paused.borrow = false,
            MethodType::Deposit => self.is_action_paused.deposit = false,
        }
    }

    pub fn get_user_profile(&self, user_id: AccountId) -> UserProfile {
        self.user_profiles.get(&user_id).unwrap_or_default()
    }
}

#[cfg(test)]
mod tests {
    use crate::Config;

    use super::*;

    pub fn init_() -> (Contract, AccountId, AccountId) {
        let owner_account: AccountId = "contract.near".parse().unwrap();
        let oracle_account: AccountId = "oracle.near".parse().unwrap();
        let user_account: AccountId = "user.near".parse().unwrap();

        let near_contract = Contract::new(Config {
            owner_id: owner_account,
            oracle_account_id: oracle_account,
        });

        let token_address: AccountId = "near".parse().unwrap();

        (near_contract, token_address, user_account)
    }

    #[test]
    fn get_set_admin() {
        let (near_contract, _, _) = init_();
        assert_eq!(near_contract.admin, near_contract.get_admin());
    }
}

'''
'''--- contracts/controller/src/borrows_supplies.rs ---
use near_sdk::require;
use near_sdk::BlockHeight;
use std::collections::HashMap;

use crate::borrows_supplies::ActionType::{Borrow, Supply};
use crate::*;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum ActionType {
    Supply,
    Borrow,
}

#[near_bindgen]
impl Contract {
    pub fn make_borrow(
        &mut self,
        account_id: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
        borrow_block: BlockHeight,
        borrow_rate: WRatio,
    ) {
        if !self.is_allowed_to_borrow_uncollateralized(account_id.clone()) {
            assert!(
                self.is_borrow_allowed(account_id.clone(), token_address.clone(), token_amount),
                "Borrow operation is not allowed for account {} token_address {} token_amount {}",
                account_id,
                token_address,
                Balance::from(token_amount)
            );
        }

        self.increase_borrows(
            account_id,
            token_address,
            token_amount,
            borrow_block,
            Ratio::from(borrow_rate.0),
        );
    }

    pub fn withdraw_supplies(
        &mut self,
        account_id: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
    ) -> Balance {
        assert!(
            self.is_withdraw_allowed(account_id.clone(), token_address.clone(), token_amount),
            "Withdrawal operation is not allowed for account {} token_address {} token_amount` {}",
            account_id,
            token_address,
            Balance::from(token_amount)
        );

        self.decrease_supplies(account_id, token_address, token_amount)
    }

    pub fn get_entity_by_token(
        &self,
        action: ActionType,
        user_id: AccountId,
        token_address: AccountId,
    ) -> Balance {
        let user = self.user_profiles.get(&user_id).unwrap_or_default();

        user.get(action, token_address)
    }

    pub fn increase_supplies(
        &mut self,
        account: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
    ) {
        let existing_supplies =
            self.get_entity_by_token(Supply, account.clone(), token_address.clone());
        let increased_supplies: Balance = existing_supplies + Balance::from(token_amount);

        self.set_entity_by_token(Supply, account, token_address, increased_supplies);
    }

    pub fn increase_borrows(
        &mut self,
        account: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
        borrow_block: BlockHeight,
        borrow_rate: Ratio,
    ) {
        let existing_borrows: Balance =
            self.get_entity_by_token(Borrow, account.clone(), token_address.clone());
        let increased_borrows: Balance = existing_borrows + Balance::from(token_amount);

        let mut borrow_block = borrow_block;
        if existing_borrows != 0 {
            borrow_block = self
                .user_profiles
                .get(&account)
                .unwrap_or_default()
                .get_borrow_data(token_address.clone())
                .borrow_block;
        }
        let borrow_data = BorrowData {
            borrow_block,
            borrow_rate,
        };

        self.user_profiles
            .get(&account)
            .unwrap_or_default()
            .insert_borrow_data(token_address.clone(), borrow_data);
        self.set_entity_by_token(Borrow, account, token_address, increased_borrows);
    }

    pub fn decrease_borrows(
        &mut self,
        account: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
        borrow_block: BlockHeight,
        borrow_rate: WRatio,
    ) -> Balance {
        let existing_borrows: Balance =
            self.get_entity_by_token(Borrow, account.clone(), token_address.clone());

        let decreased_borrows: Balance = existing_borrows - Balance::from(token_amount);

        let mut borrow_rate = borrow_rate.0;
        if decreased_borrows == 0 {
            borrow_rate = 0;
        }
        let borrow_data = BorrowData {
            borrow_block,
            borrow_rate: Ratio::from(borrow_rate),
        };
        self.user_profiles
            .get(&account)
            .unwrap_or_default()
            .insert_borrow_data(token_address.clone(), borrow_data);

        self.set_entity_by_token(Borrow, account, token_address, decreased_borrows)
    }

    pub fn decrease_supplies(
        &mut self,
        account: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
    ) -> Balance {
        let existing_supplies =
            self.get_entity_by_token(Supply, account.clone(), token_address.clone());

        assert!(
            Balance::from(token_amount) <= existing_supplies,
            "Not enough existing supplies for {} with supplies {} {} {}",
            account,
            existing_supplies,
            token_address,
            Balance::from(token_amount)
        );
        let decreased_supplies: Balance = existing_supplies - Balance::from(token_amount);

        self.set_entity_by_token(Supply, account, token_address, decreased_supplies)
    }
}

impl Contract {
    pub fn set_entity_by_token(
        &mut self,
        action: ActionType,
        user_id: AccountId,
        token_address: AccountId,
        token_amount: Balance,
    ) -> Balance {
        let mut user = self.user_profiles.get(&user_id).unwrap_or_default();
        user.set(action, token_address, token_amount);
        self.user_profiles.insert(&user_id, &user);

        token_amount
    }

    fn is_withdraw_allowed(
        &self,
        account: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
    ) -> bool {
        require!(!self.is_action_paused.withdraw, "withdrawing is paused");
        let existing_supplies =
            self.get_entity_by_token(Supply, account.clone(), token_address.clone());
        assert!(
            Balance::from(token_amount) <= existing_supplies,
            "{}",
            "Not enough existing supplies for {account}"
        );
        self.get_potential_health_factor(account, token_address, token_amount, Supply)
            >= self.get_liquidation_threshold()
    }

    #[warn(dead_code)]
    fn is_borrow_allowed(
        &self,
        account: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
    ) -> bool {
        require!(!self.is_action_paused.borrow, "borrowing is paused");

        self.get_potential_health_factor(account, token_address, token_amount, Borrow)
            >= self.get_liquidation_threshold()
    }

    pub fn calculate_assets_price(&self, map: &HashMap<AccountId, Balance>) -> Balance {
        map.iter()
            .map(|(asset, balance)| {
                let price = self.get_price(asset).unwrap_or_default();

                (BigBalance::from(price.value) * BigBalance::from(balance.to_owned())
                    / BigBalance::from(U128(ONE_TOKEN)))
                .round_u128()
            })
            .sum()
    }

    pub fn get_total_supplies(&self, user_id: &AccountId) -> USD {
        let supplies = self
            .user_profiles
            .get(user_id)
            .unwrap_or_default()
            .account_supplies;

        self.calculate_assets_price(&supplies).into()
    }

    pub fn get_total_borrows(&self, user_id: &AccountId) -> USD {
        let borrows = self
            .user_profiles
            .get(user_id)
            .unwrap_or_default()
            .account_borrows;

        self.calculate_assets_price(&borrows).into()
    }

    pub fn get_total_borrows_by_dtoken(&self, user_id: &AccountId, dtoken: &AccountId) -> USD {
        let borrows = self
            .user_profiles
            .get(user_id)
            .unwrap_or_default()
            .account_borrows;

        if let Some(balance) = borrows.get(dtoken) {
            let price = self.get_price(dtoken).unwrap_or_default();
            (BigBalance::from(price.value) * BigBalance::from(balance.to_owned())
                / BigBalance::from(U128(ONE_TOKEN)))
            .round_u128()
            .into()
        } else {
            0.into()
        }
    }
}

#[cfg(test)]
mod tests {
    use general::ratio::Ratio;
    use general::{Price, WRatio, ONE_TOKEN};
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::AccountId;

    use crate::borrows_supplies::ActionType::{Borrow, Supply};
    use crate::{Config, Contract};

    pub fn init_test_env() -> (Contract, AccountId, AccountId) {
        let (owner_account, oracle_account, user_account) = (alice(), bob(), carol());

        let near_contract = Contract::new(Config {
            owner_id: owner_account,
            oracle_account_id: oracle_account,
        });

        let token_address: AccountId = "near".parse().unwrap();

        (near_contract, token_address, user_account)
    }

    #[test]
    fn test_for_supply_and_borrow_getters() {
        let (near_contract, token_address, user_account) = init_test_env();
        assert_eq!(
            near_contract.get_entity_by_token(Supply, user_account.clone(), token_address.clone()),
            0
        );
        assert_eq!(
            near_contract.get_entity_by_token(Borrow, user_account, token_address),
            0
        );
    }

    #[test]
    fn test_for_supply_and_borrow_setters() {
        let (mut near_contract, token_address, user_account) = init_test_env();
        near_contract.set_entity_by_token(Supply, user_account.clone(), token_address.clone(), 100);
        assert_eq!(
            near_contract.get_entity_by_token(Supply, user_account.clone(), token_address.clone()),
            100
        );

        near_contract.set_entity_by_token(Borrow, user_account.clone(), token_address.clone(), 50);
        assert_eq!(
            near_contract.get_entity_by_token(Borrow, user_account, token_address),
            50
        );
    }

    #[test]
    fn success_increase_n_decrease_borrows() {
        let (mut near_contract, token_address, user_account) = init_test_env();

        near_contract.increase_borrows(
            user_account.clone(),
            token_address.clone(),
            U128(10),
            0,
            Ratio::zero(),
        );
        near_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("test.nearlend".to_string()),
            U128(100),
            0,
            Ratio::zero(),
        );

        assert_eq!(
            near_contract.get_entity_by_token(Borrow, user_account.clone(), token_address.clone()),
            10
        );
        assert_eq!(
            near_contract.get_entity_by_token(
                Borrow,
                user_account.clone(),
                AccountId::new_unchecked("test.nearlend".to_string()),
            ),
            100
        );

        near_contract.decrease_borrows(
            user_account.clone(),
            token_address.clone(),
            U128(2),
            0,
            WRatio::from(0),
        );
        near_contract.decrease_borrows(
            user_account.clone(),
            AccountId::new_unchecked("test.nearlend".to_string()),
            U128(2),
            0,
            WRatio::from(0),
        );

        assert_eq!(
            near_contract.get_entity_by_token(Borrow, user_account.clone(), token_address),
            8
        );
        assert_eq!(
            near_contract.get_entity_by_token(
                Borrow,
                user_account,
                AccountId::new_unchecked("test.nearlend".to_string()),
            ),
            98
        );
    }

    #[test]
    fn success_increase_n_decrease_supplies() {
        let (mut near_contract, token_address, user_account) = init_test_env();

        near_contract.increase_supplies(user_account.clone(), token_address.clone(), U128(10));
        near_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("test.nearlend".to_string()),
            U128(20),
        );

        assert_eq!(
            near_contract.get_entity_by_token(Supply, user_account.clone(), token_address.clone()),
            10
        );
        assert_eq!(
            near_contract.get_entity_by_token(
                Supply,
                user_account.clone(),
                AccountId::new_unchecked("test.nearlend".to_string()),
            ),
            20
        );

        near_contract.decrease_supplies(user_account.clone(), token_address.clone(), U128(2));
        near_contract.decrease_supplies(
            user_account.clone(),
            AccountId::new_unchecked("test.nearlend".to_string()),
            U128(2),
        );

        assert_eq!(
            near_contract.get_entity_by_token(Supply, user_account.clone(), token_address),
            8
        );
        assert_eq!(
            near_contract.get_entity_by_token(
                Supply,
                user_account,
                AccountId::new_unchecked("test.nearlend".to_string()),
            ),
            18
        );
    }

    #[test]
    #[should_panic]
    fn failed_decrease_borrows() {
        /*
        Test for decrease flow behavior computation
        */
        let (mut near_contract, token_address, user_account) = init_test_env();

        near_contract.increase_borrows(
            user_account.clone(),
            token_address.clone(),
            U128(10),
            0,
            Ratio::zero(),
        );

        near_contract.decrease_borrows(user_account, token_address, U128(20), 0, WRatio::from(0));
    }

    #[test]
    fn get_total_supplies() {
        let (mut near_contract, token_address, user_account) = init_test_env();

        let price = Price {
            ticker_id: "wnear".to_string(),
            value: U128(100 * ONE_TOKEN),
            volatility: U128(1),
            fraction_digits: 4u32,
        };
        near_contract.upsert_price(token_address.clone(), &price);
        near_contract.increase_supplies(user_account.clone(), token_address, U128(10));

        assert_eq!(near_contract.get_total_supplies(&user_account), U128(1000));
    }

    #[test]
    fn get_total_borrows() {
        let (mut near_contract, token_address, user_account) = init_test_env();

        let price = Price {
            ticker_id: "wnear".to_string(),
            value: U128(100 * ONE_TOKEN),
            volatility: U128(1),
            fraction_digits: 4u32,
        };
        near_contract.upsert_price(token_address.clone(), &price);
        near_contract.increase_borrows(
            user_account.clone(),
            token_address,
            U128(10),
            0,
            Ratio::zero(),
        );

        assert_eq!(near_contract.get_total_borrows(&user_account), U128(1000));
    }
}

'''
'''--- contracts/controller/src/config.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The account ID of the contract owner that allows to modify config
    pub owner_id: AccountId,

    /// The account ID of the controller contract
    pub oracle_account_id: AccountId,
}

impl Contract {
    pub fn get_contract_config(&self) -> Config {
        self.config.get().unwrap()
    }
}

'''
'''--- contracts/controller/src/healthfactor.rs ---
use crate::*;

use general::ratio::Ratio;
use near_sdk::env::block_height;
use std::collections::HashMap;
use std::ops::Add;

impl Contract {
    pub fn calculate_supplies_weighted_price_and_lth(&self, user_id: AccountId) -> Balance {
        let supplies = self
            .user_profiles
            .get(&user_id)
            .unwrap_or_default()
            .account_supplies;

        supplies
            .iter()
            .map(|(dtoken, balance)| {
                let price = self.get_price(dtoken).unwrap();
                let market = self.get_market_by_dtoken(dtoken.clone());

                ((BigBalance::from(price.value)
                    * BigBalance::from(balance.to_owned())
                    * market.lth)
                    / Ratio::from(10u128.pow(price.fraction_digits)))
                .0
                .low_u128()
            })
            .sum()
    }

    pub fn get_collaterals_by_borrows(&self, user_id: AccountId) -> USD {
        let borrows = self
            .user_profiles
            .get(&user_id)
            .unwrap_or_default()
            .account_borrows;

        let collaterals: Balance = borrows
            .iter()
            .map(|(dtoken, balance)| {
                let price = self.get_price(dtoken).unwrap();
                let market = self.get_market_by_dtoken(dtoken.clone());

                ((BigBalance::from(price.value) * BigBalance::from(balance.to_owned())
                    / Ratio::from(10u128.pow(price.fraction_digits)))
                    / market.ltv)
                    .0
                    .low_u128()
            })
            .sum();

        USD::from(collaterals)
    }

    pub fn get_average_hf_by_markets_ltv(&self) -> Ratio {
        let mut avg_hf: Ratio = Ratio::zero();
        self.markets.iter().for_each(|(_, market)| {
            avg_hf = avg_hf.add(market.ltv);
        });
        avg_hf / Ratio::from(self.markets.len())
    }

    pub fn get_market_by_dtoken(&self, dtoken: AccountId) -> MarketProfile {
        let markets = self
            .markets
            .iter()
            .filter(|(_, market)| market.dtoken == dtoken)
            .map(|(_, market)| market)
            .collect::<Vec<MarketProfile>>();

        let market = markets.first().unwrap();

        market.clone()
    }

    pub fn get_theoretical_borrows_max(&self, user_id: AccountId) -> USD {
        let supplies = self
            .user_profiles
            .get(&user_id)
            .unwrap_or_default()
            .account_supplies;

        let borrow_max: Balance = supplies
            .iter()
            .map(|(dtoken, balance)| {
                let price = self.get_price(dtoken).unwrap();
                let market = self.get_market_by_dtoken(dtoken.clone());

                ((BigBalance::from(price.value)
                    * BigBalance::from(balance.to_owned())
                    * market.ltv)
                    / Ratio::from(10u128.pow(price.fraction_digits)))
                .0
                .low_u128()
            })
            .sum();

        USD::from(borrow_max)
    }

    pub fn calculate_assets_weighted_price(&self, map: &HashMap<AccountId, Balance>) -> Balance {
        map.iter()
            .map(|(asset, balance)| {
                let price = self.get_price(asset).unwrap();

                Percentage::from(price.volatility.0).apply_to(
                    ((BigBalance::from(balance.to_owned()) * BigBalance::from(price.value))
                        / Ratio::from(10u128.pow(price.fraction_digits)))
                    .0
                    .as_u128(),
                )
            })
            .sum()
    }

    fn get_account_sum_per_action(&self, user_account: AccountId, action: ActionType) -> Balance {
        let map_raw: HashMap<AccountId, Balance> = match action {
            ActionType::Supply => {
                self.user_profiles
                    .get(&user_account)
                    .unwrap_or_default()
                    .account_supplies
            }
            ActionType::Borrow => {
                self.user_profiles
                    .get(&user_account)
                    .unwrap_or_default()
                    .account_borrows
            }
        };

        self.calculate_assets_weighted_price(&map_raw)
    }

    pub fn calculate_accrued_borrow_interest(&self, account_id: AccountId) -> Balance {
        let mut total_accrued_interest = 0;
        let user_profile = self.user_profiles.get(&account_id).unwrap_or_default();
        let total_borrows: Balance = user_profile.account_borrows.values().sum();

        for (token_address, borrow_data) in user_profile.borrow_data.iter() {
            let accrued_interest = Ratio::from(total_borrows)
                * borrow_data.borrow_rate
                * Ratio::from(block_height() - borrow_data.borrow_block);

            let price = self.get_price(token_address).unwrap();
            let accrued_interest_amount = Percentage::from(price.volatility.0).apply_to(
                (BigBalance::from(price.value) * accrued_interest
                    / Ratio::from(10u128.pow(price.fraction_digits)))
                .0
                .low_u128(),
            );

            total_accrued_interest += accrued_interest_amount;
        }
        total_accrued_interest
    }

    pub fn get_hf_with_supply_and_no_borrow(&self, user_account: AccountId) -> Ratio {
        let supplies_weighted_lth =
            self.calculate_supplies_weighted_price_and_lth(user_account.clone());
        let max_borrows = self.get_theoretical_borrows_max(user_account);

        Ratio::from(supplies_weighted_lth) / Ratio::from(max_borrows.0)
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_health_factor(&self, user_account: AccountId) -> Ratio {
        let supplies_weighted_lth =
            self.calculate_supplies_weighted_price_and_lth(user_account.clone());
        let mut borrows = self.get_account_sum_per_action(user_account.clone(), ActionType::Borrow);

        borrows += self.calculate_accrued_borrow_interest(user_account.clone());

        if borrows != 0 {
            Ratio::from(supplies_weighted_lth) / Ratio::from(borrows)
        } else if supplies_weighted_lth > 0 {
            self.get_hf_with_supply_and_no_borrow(user_account)
        } else {
            self.get_average_hf_by_markets_ltv()
        }
    }

    pub fn get_potential_health_factor(
        &self,
        user_account: AccountId,
        token_address: AccountId,
        amount: WBalance,
        action: ActionType,
    ) -> Ratio {
        let mut collaterals = self.calculate_supplies_weighted_price_and_lth(user_account.clone());
        let max_borrows = self.get_theoretical_borrows_max(user_account.clone());
        let mut borrows = self.get_account_sum_per_action(user_account.clone(), ActionType::Borrow);
        borrows += self.calculate_accrued_borrow_interest(user_account);

        let price = self.get_price(&token_address).unwrap();
        let usd_amount = Percentage::from(price.volatility.0).apply_to(
            (BigBalance::from(price.value) * BigBalance::from(amount.0)
                / Ratio::from(10u128.pow(price.fraction_digits)))
            .0
            .low_u128(),
        );
        match action {
            ActionType::Supply => {
                if borrows != 0 {
                    collaterals -= usd_amount
                }
            }
            ActionType::Borrow => {
                borrows += usd_amount;
            }
        }

        if borrows != 0 {
            Ratio::from(collaterals) / Ratio::from(borrows)
        } else {
            Ratio::from(collaterals) / Ratio::from(max_borrows.0)
        }
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::test_env::{alice, bob};

    use super::*;

    // use crate::borrows_supplies::ActionType::{Borrow, Supply};

    fn init_price_volatility(
        near_price: u128,
        near_volatility: u128,
        eth_price: u128,
        eth_volatility: u128,
    ) -> (Contract, AccountId, AccountId) {
        let (_owner_account, user_account) = (alice(), bob());

        let mut controller_contract = Contract::new(Config {
            owner_id: user_account.clone(),
            oracle_account_id: user_account.clone(),
        });

        let utoken_address_near = AccountId::new_unchecked("wnear.near".to_string());
        let dtoken_address_near = AccountId::new_unchecked("wnear_market.near".to_string());
        let ticker_id_near = "wnear".to_string();

        controller_contract.add_market(
            utoken_address_near,
            dtoken_address_near,
            ticker_id_near.clone(),
            Ratio::from_str("0.6").unwrap(),
            Ratio::from_str("0.8").unwrap(),
        );

        let utoken_address_eth = AccountId::new_unchecked("weth.near".to_string());
        let dtoken_address_eth = AccountId::new_unchecked("weth_market.near".to_string());
        let ticker_id_eth = "weth".to_string();

        controller_contract.add_market(
            utoken_address_eth,
            dtoken_address_eth,
            ticker_id_eth.clone(),
            Ratio::from_str("0.6").unwrap(),
            Ratio::from_str("0.8").unwrap(),
        );

        let prices: Vec<Price> = vec![
            Price {
                ticker_id: ticker_id_near,
                value: U128(near_price),
                volatility: U128(near_volatility),
                fraction_digits: 4,
            },
            Price {
                ticker_id: ticker_id_eth,
                value: U128(eth_price),
                volatility: U128(eth_volatility),
                fraction_digits: 4,
            },
        ];

        controller_contract.oracle_on_data(PriceJsonList {
            block_height: 83452949,
            price_list: prices,
        });

        let token_address: AccountId = AccountId::new_unchecked("near".to_string());

        (controller_contract, token_address, user_account)
    }

    fn init() -> (Contract, AccountId, AccountId) {
        let (_owner_account, user_account) = (alice(), bob());

        let mut controller_contract = Contract::new(Config {
            owner_id: user_account.clone(),
            oracle_account_id: user_account.clone(),
        });

        let utoken_address_near = AccountId::new_unchecked("wnear.near".to_string());
        let dtoken_address_near = AccountId::new_unchecked("wnear_market.near".to_string());
        let ticker_id_near = "wnear".to_string();

        controller_contract.add_market(
            utoken_address_near,
            dtoken_address_near,
            ticker_id_near.clone(),
            Ratio::from_str("0.6").unwrap(),
            Ratio::from_str("0.8").unwrap(),
        );

        let utoken_address_eth = AccountId::new_unchecked("weth.near".to_string());
        let dtoken_address_eth = AccountId::new_unchecked("weth_market.near".to_string());
        let ticker_id_eth = "weth".to_string();

        controller_contract.add_market(
            utoken_address_eth,
            dtoken_address_eth,
            ticker_id_eth.clone(),
            Ratio::from_str("0.6").unwrap(),
            Ratio::from_str("0.8").unwrap(),
        );

        let prices: Vec<Price> = vec![
            Price {
                ticker_id: ticker_id_near,
                value: U128(20000),
                volatility: U128(80),
                fraction_digits: 4,
            },
            Price {
                ticker_id: ticker_id_eth,
                value: U128(20000),
                volatility: U128(100),
                fraction_digits: 4,
            },
        ];

        controller_contract.oracle_on_data(PriceJsonList {
            block_height: 83452949,
            price_list: prices,
        });

        let token_address: AccountId = AccountId::new_unchecked("near".to_string());

        (controller_contract, token_address, user_account)
    }

    #[test]
    fn test_calculate_assets_weighted_price_sum_empty_map() {
        let (controller_contract, _token_address, _user_account) = init();

        let raw_map_empty: HashMap<AccountId, Balance> = HashMap::new();
        assert_eq!(
            controller_contract.calculate_assets_weighted_price(&raw_map_empty),
            0,
            "Test for None Option has been failed"
        );
    }

    #[test]
    fn test_for_calculate_assets_weighted_price() {
        let (controller_contract, _token_address, _user_account) = init();

        let mut raw_map: HashMap<AccountId, Balance> = HashMap::new();
        raw_map.insert(
            AccountId::new_unchecked("wnear_market.near".to_string()),
            100,
        );

        assert_eq!(
            controller_contract.calculate_assets_weighted_price(&raw_map),
            160,
            "Test for None Option has been failed"
        );
    }

    #[test]
    fn test_for_get_health_factor_threshold() {
        let (mut controller_contract, _token_address, user_account) = init();

        let balance: Balance = 50;

        assert_eq!(
            controller_contract.get_health_factor(user_account.clone()),
            controller_contract.get_average_hf_by_markets_ltv(),
            "Test for account w/o collaterals and borrows has been failed"
        );

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("wnear_market.near".to_string()),
            WBalance::from(balance),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(0),
            0,
            Ratio::zero(),
        );

        assert_eq!(
            controller_contract.get_health_factor(user_account.clone()),
            controller_contract.get_hf_with_supply_and_no_borrow(user_account),
            "Health factor calculation has been failed"
        );
    }

    #[test]
    fn test_health_factor_without_supply_or_borrow() {
        let (mut controller_contract, _token_address, user_account) =
            init_price_volatility(0, 0, 10000, 100);

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(0),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(0),
            0,
            Ratio::zero(),
        );

        assert_eq!(
            controller_contract.get_health_factor(user_account),
            controller_contract.get_average_hf_by_markets_ltv(),
            "Test for account w/o collaterals and borrows has been failed"
        );
    }

    #[test]
    fn test_health_factor_with_supply() {
        let (mut controller_contract, _token_address, user_account) =
            init_price_volatility(0, 0, 10000, 100);

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(100),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(0),
            0,
            Ratio::zero(),
        );

        // Ratio that represents standart_hf_with_supply_and_no_borrow
        assert_eq!(
            controller_contract.get_health_factor(user_account.clone()),
            controller_contract.get_hf_with_supply_and_no_borrow(user_account)
        );
    }

    #[test]
    fn test_health_factor_with_supply_and_borrow() {
        let (mut controller_contract, _token_address, user_account) =
            init_price_volatility(0, 0, 10000, 100);

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(100),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(70),
            0,
            Ratio::zero(),
        );

        // Ratio that represents (100 * 1 * LTH(0.8) / 70)  = 1.142857142857142857142857%
        assert_eq!(
            controller_contract.get_health_factor(user_account),
            Ratio::from_str("1.142857142857142857142857").unwrap()
        );
    }

    #[test]
    fn test_health_factor_increasing_supply() {
        let (mut controller_contract, _token_address, user_account) =
            init_price_volatility(10000, 100, 10000, 100);

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(100),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("wnear_market.near".to_string()),
            WBalance::from(100),
            0,
            Ratio::zero(),
        );

        // Ratio that represents (100 * 1 * LTH(0.8) / 100) 80%
        assert_eq!(
            controller_contract.get_health_factor(user_account.clone()),
            Ratio::from_str("0.8").unwrap()
        );

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(100),
        );

        // Ratio that represents (200 * 1 * LTH(0.8) / 100) 80%
        assert_eq!(
            controller_contract.get_health_factor(user_account),
            Ratio::from_str("1.6").unwrap()
        );
    }

    #[test]
    fn test_health_factor_updating_price() {
        let (mut controller_contract, _token_address, user_account) =
            init_price_volatility(10000, 100, 10000, 100);

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(200),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("wnear_market.near".to_string()),
            WBalance::from(100),
            0,
            Ratio::zero(),
        );

        // Ratio that represents 160% = (200 * LTH(80%) / 100)
        assert_eq!(
            controller_contract.get_health_factor(user_account.clone()),
            Ratio::from_str("1.6").unwrap()
        );

        controller_contract.oracle_on_data(PriceJsonList {
            block_height: 83452949,
            price_list: vec![
                Price {
                    ticker_id: "wnear".to_string(),
                    value: U128(20000),
                    volatility: U128(100),
                    fraction_digits: 4,
                },
                Price {
                    ticker_id: "weth".to_string(),
                    value: U128(5000),
                    volatility: U128(100),
                    fraction_digits: 4,
                },
            ],
        });

        // Ratio that represents 40% = (200 * 0.5 * LTH(80%) / 100 * 2)
        assert_eq!(
            controller_contract.get_health_factor(user_account),
            Ratio::from_str("0.4").unwrap()
        );
    }

    #[test]
    fn test_health_factor_updating_volatility() {
        let (mut controller_contract, _token_address, user_account) =
            init_price_volatility(10000, 100, 10000, 100);

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(200),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("wnear_market.near".to_string()),
            WBalance::from(100),
            0,
            Ratio::zero(),
        );

        // Ratio that represents (200 * 1 * LTH(0.8) / 100) = 160%
        assert_eq!(
            controller_contract.get_health_factor(user_account.clone()),
            Ratio::from_str("1.6").unwrap()
        );

        controller_contract.oracle_on_data(PriceJsonList {
            block_height: 83452949,
            price_list: vec![
                Price {
                    ticker_id: "wnear".to_string(),
                    value: U128(10000),
                    volatility: U128(80),
                    fraction_digits: 4,
                },
                Price {
                    ticker_id: "weth".to_string(),
                    value: U128(10000),
                    volatility: U128(90),
                    fraction_digits: 4,
                },
            ],
        });

        // Ratio that represents (200 * 1 * LTH(0.8) / 100 * Volatility (0.8)) = 200%
        assert_eq!(
            controller_contract.get_health_factor(user_account),
            Ratio::from_str("2").unwrap()
        );
    }

    #[test]
    fn test_get_potential_health_factor() {
        let (mut controller_contract, _token_address, user_account) =
            init_price_volatility(300, 59, 400, 36);

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(200),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(50),
            0,
            Ratio::zero(),
        );

        let result = controller_contract.get_potential_health_factor(
            user_account,
            AccountId::new_unchecked("weth_market.near".to_string()),
            U128(1000),
            ActionType::Borrow,
        );

        assert_eq!(result, Ratio::from(6u128) / Ratio::from(14u128));
    }

    #[test]
    fn test_health_factor_with_supply_and_multi_borrow() {
        let (mut controller_contract, _token_address, user_account) =
            init_price_volatility(10000, 80, 11000, 90);

        controller_contract.increase_supplies(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(200),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("weth_market.near".to_string()),
            WBalance::from(50),
            0,
            Ratio::zero(),
        );

        controller_contract.increase_borrows(
            user_account.clone(),
            AccountId::new_unchecked("wnear_market.near".to_string()),
            WBalance::from(100),
            0,
            Ratio::zero(),
        );

        // Ratio that represents (200 * 1.1 * LTH(0.8) / 50 * 1.1 * 0.9 + 100 * 1 * 0.8)
        // Ratio that represents 1.364341085271317829457364%
        assert_eq!(
            controller_contract.get_health_factor(user_account),
            Ratio::from_str("1.364341085271317829457364").unwrap()
        );
    }
}

'''
'''--- contracts/controller/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap};
use near_sdk::{env, ext_contract, near_bindgen, require, AccountId, Balance, BorshStorageKey};

#[allow(unused_imports)]
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use percentage::Percentage;

use general::ratio::{BigBalance, Ratio};
use general::*;
use std::str::FromStr;

pub use crate::borrows_supplies::*;
pub use crate::config::*;
pub use crate::healthfactor::*;
pub use crate::liquidation::*;
pub use crate::oraclehook::*;
pub use crate::prices::*;
pub use crate::repay::*;
pub use crate::user_flow_protection::*;
pub use crate::user_profile::*;
pub use crate::views::*;

mod admin;
pub mod borrows_supplies;
#[allow(unused_imports)]
mod config;
mod healthfactor;
mod liquidation;
mod oraclehook;
mod prices;
pub mod repay;
mod upgrade;
pub mod user_flow_protection;
pub mod user_profile;
mod views;

pub fn get_default_liquidation_incentive() -> Ratio {
    Ratio::from_str("0.05").unwrap()
}

pub fn get_default_liquidation_health_factor_threshold() -> Ratio {
    Ratio::from_str("1.0").unwrap()
}

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKeys {
    Markets,
    Supplies,
    Prices,
    Config,
    Borrows,
    UserProfiles,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    /// Utoken Id [Underlying asset name] -> Dtoken address
    /// Utoken Id [Underlying asset name] -> Ticker Id
    /// Utoken Id [Underlying asset name] -> LTV
    /// Utoken Id [Underlying asset name] -> LTH
    pub markets: UnorderedMap<AccountId, MarketProfile>,

    /// User Account ID -> Dtoken address -> Supplies balance
    /// User Account ID -> Dtoken address -> Borrow balance
    user_profiles: UnorderedMap<AccountId, UserProfile>,

    /// Dtoken ID -> Price
    pub prices: LookupMap<AccountId, Price>,

    /// Contract configuration object
    pub config: LazyOption<Config>,

    /// Contract admin account (controller itself by default)
    pub admin: AccountId,

    /// Contracts that are allowed to do uncollateralized borrow from market
    /// contract itself by default, can be set to different account
    eligible_to_borrow_uncollateralized: AccountId,

    /// Configuration for pausing/proceeding controller processes (false by default)
    pub is_action_paused: ActionStatus,

    /// Liquidation Incentive
    pub liquidation_incentive: Ratio,

    /// Liquidation Health Factor
    pub liquidation_health_factor_threshold: Ratio,

    ///User action protection
    mutex: ActionMutex,
}

impl Default for Contract {
    fn default() -> Self {
        env::panic_str("Controller contract should be initialized before usage")
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceJsonList {
    /// Block number
    pub block_height: u64,

    /// Vector of asset prices
    pub price_list: Vec<Price>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketProfile {
    /// Dtoken address
    pub dtoken: AccountId,

    /// Ticker name
    pub ticker_id: String,

    /// Loan to value for the market
    pub ltv: Ratio,

    /// Liquidation threshold for the market
    pub lth: Ratio,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ActionStatus {
    supply: bool,
    withdraw: bool,
    borrow: bool,
    repay: bool,
    liquidate: bool,
    deposit: bool,
}

pub trait OraclePriceHandlerHook {
    fn oracle_on_data(&mut self, price_data: PriceJsonList);
}

#[ext_contract(market)]
trait MarketInterface {
    fn swap_supplies(
        &mut self,
        borrower: AccountId,
        liquidator: AccountId,
        liquidation_revenue_amount: WBalance,
    ) -> PromiseOrValue<U128>;

    fn increase_borrows(&mut self, account: AccountId, token_amount: WBalance) -> Balance;
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new_with_config(owner_id: AccountId, oracle_account_id: AccountId) -> Self {
        Self::new(Config {
            owner_id,
            oracle_account_id,
        })
    }

    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new(config: Config) -> Self {
        require!(!env::state_exists(), "Already initialized");

        Self {
            markets: UnorderedMap::new(StorageKeys::Markets),
            user_profiles: UnorderedMap::new(StorageKeys::UserProfiles),
            prices: LookupMap::new(StorageKeys::Prices),
            config: LazyOption::new(StorageKeys::Config, Some(&config)),
            admin: config.owner_id.clone(),
            eligible_to_borrow_uncollateralized: config.owner_id.clone(),
            is_action_paused: ActionStatus {
                withdraw: false,
                repay: false,
                supply: false,
                liquidate: false,
                borrow: false,
                deposit: false,
            },
            liquidation_incentive: get_default_liquidation_incentive(),
            liquidation_health_factor_threshold: get_default_liquidation_health_factor_threshold(),
            mutex: ActionMutex::default(),
        }
    }
}

'''
'''--- contracts/controller/src/liquidation.rs ---
use crate::*;
use near_sdk::{env::block_height, PromiseOrValue};

#[near_bindgen]
impl Contract {
    pub fn liquidation(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        liquidator: AccountId,
        collateral_dtoken: AccountId,
        liquidation_amount: WBalance,
    ) -> PromiseOrValue<WBalance> {
        require!(
            self.is_dtoken_caller(),
            "This functionality is allowed to be called by admin, contract or dtoken's contract only"
        );

        let half_of_borrower_total_supplies =
            Percentage::from(50).apply_to(self.get_total_supplies(&borrower).0);

        require!(
            liquidation_amount.0 <= half_of_borrower_total_supplies,
            "Liquidation amount must be less than half of the borrower`s total supplies"
        );

        let total_borrows_by_dtoken = self
            .get_total_borrows_by_dtoken(&borrower, &borrowing_dtoken)
            .0;

        require!(
            liquidation_amount.0 <= total_borrows_by_dtoken,
            "Liquidation amount must be less than half of the borrower`s total borrows of dtoken"
        );

        let res = self.calculate_liquidation_revenue(
            borrower,
            borrowing_dtoken,
            liquidator,
            collateral_dtoken,
            liquidation_amount,
        );

        if res.is_err() {
            panic!("Liquidation failed on controller, {:?}", res.unwrap_err());
        }

        let liquidation_revenue_amount = res.unwrap();
        PromiseOrValue::Value(liquidation_revenue_amount)
    }

    pub fn liquidation_repay_and_swap(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        collateral_dtoken: AccountId,
        liquidator: AccountId,
        liquidation_amount: WBalance,
        liquidation_revenue_amount: WBalance,
        borrow_rate: WRatio,
    ) -> PromiseOrValue<U128> {
        require!(
            self.is_dtoken_caller(),
            "This method is allowed to be called by dtoken contract only"
        );
        self.repay_borrows(
            borrower.clone(),
            borrowing_dtoken,
            liquidation_amount,
            block_height(),
            borrow_rate,
        );
        self.decrease_supplies(
            borrower.clone(),
            collateral_dtoken.clone(),
            liquidation_revenue_amount,
        );
        self.increase_supplies(
            liquidator.clone(),
            collateral_dtoken.clone(),
            liquidation_revenue_amount,
        );

        market::swap_supplies(
            borrower,
            liquidator,
            liquidation_revenue_amount,
            collateral_dtoken,
            NO_DEPOSIT,
            near_sdk::Gas::ONE_TERA * 8_u64,
        )
        .into()
    }
}

impl Contract {
    pub fn get_liquidation_revenue(
        &self,
        borrowing_dtoken: AccountId,
        collateral_dtoken: AccountId,
        liquidation_amount: WBalance,
    ) -> WBalance {
        WBalance::from(
            (self.get_liquidation_incentive()
                * Ratio::from(liquidation_amount.0)
                * Ratio::from(self.prices.get(&borrowing_dtoken).unwrap().value.0)
                / (Ratio::from(self.prices.get(&collateral_dtoken).unwrap().value.0)))
            .round_u128(),
        )
    }

    pub fn calculate_liquidation_revenue(
        &self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        liquidator: AccountId,
        collateral_dtoken: AccountId,
        liquidation_amount: WBalance,
    ) -> Result<WBalance, String> {
        if liquidator == borrower {
            return Err(String::from("cannot liquidate themselves"));
        }

        if self.get_health_factor(borrower) > self.get_liquidation_threshold() {
            return Err(String::from("health factor is above liquidation threshold"));
        }

        let revenue_amount =
            self.get_liquidation_revenue(borrowing_dtoken, collateral_dtoken, liquidation_amount);
        Ok(revenue_amount)
    }
}

'''
'''--- contracts/controller/src/oraclehook.rs ---
use crate::*;

#[near_bindgen]
impl OraclePriceHandlerHook for Contract {
    fn oracle_on_data(&mut self, price_data: PriceJsonList) {
        let config: Config = self.get_contract_config();

        assert_eq!(
            env::predecessor_account_id(),
            config.oracle_account_id,
            "Oracle account {} doesn't match to the signer {}",
            config.oracle_account_id,
            env::predecessor_account_id()
        );

        let tickers_map = self.get_tickers_dtoken_hash();
        for price in price_data.price_list {
            if let Some(dtoken) = tickers_map.get(&price.ticker_id) {
                self.upsert_price(dtoken.clone(), &price);
            }
        }
    }
}

'''
'''--- contracts/controller/src/prices.rs ---
use crate::*;

use std::collections::HashMap;

impl Contract {
    pub fn is_market_registered(&self, dtoken: AccountId) -> bool {
        self.get_markets_list()
            .iter()
            .any(|market| market.dtoken == dtoken)
    }

    pub fn get_prices_for_dtokens(&self, dtokens: Vec<AccountId>) -> HashMap<AccountId, Price> {
        let mut result = HashMap::new();
        for dtoken in dtokens {
            if let Some(price) = self.get_price(&dtoken) {
                result.insert(dtoken, price);
            }
        }
        result
    }

    pub fn get_price(&self, dtoken_id: &AccountId) -> Option<Price> {
        self.prices.get(dtoken_id)
    }
}

#[near_bindgen]
impl Contract {
    // TODO Do we really need to expose this via near_bindgen
    #[private]
    pub fn upsert_price(&mut self, dtoken_id: AccountId, price: &Price) {
        self.prices.insert(&dtoken_id, price);
    }
}

#[cfg(test)]
mod tests {
    use assert_matches::assert_matches;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::AccountId;

    use crate::{Config, Contract};

    pub fn init_test_env() -> (Contract, AccountId, AccountId) {
        let (owner_account, oracle_account, user_account) = (alice(), bob(), carol());

        let eth_contract = Contract::new(Config {
            owner_id: owner_account,
            oracle_account_id: oracle_account,
        });

        let token_address: AccountId = "near".parse().unwrap();

        (eth_contract, token_address, user_account)
    }

    use super::*;

    #[test]
    fn test_add_get_price() {
        let (mut near_contract, token_address, _user_account) = init_test_env();

        let price = Price {
            // adding price of Near
            ticker_id: "wnear".to_string(),
            value: U128(20),
            volatility: U128(100),
            fraction_digits: 4,
        };

        near_contract.upsert_price(token_address.clone(), &price);

        let gotten_price = near_contract.get_price(&token_address).unwrap();
        assert_matches!(
            &gotten_price,
            _price,
            "Get price format check has been failed"
        );
        assert_eq!(
            &gotten_price.value, &price.value,
            "Get price values check has been failed"
        );
        assert_eq!(
            &gotten_price.volatility, &price.volatility,
            "Get price volatility check has been failed"
        );
        assert_eq!(
            &gotten_price.ticker_id, &price.ticker_id,
            "Get price asset_id check has been failed"
        );
        assert_eq!(
            &gotten_price.fraction_digits, &price.fraction_digits,
            "Get fraction digits check has been failed"
        );
    }
}

'''
'''--- contracts/controller/src/repay.rs ---
use crate::*;
use near_sdk::BlockHeight;

#[near_bindgen]
impl Contract {
    fn is_repay_allowed(
        &self,
        _account: AccountId,
        _token_address: AccountId,
        _token_amount: WBalance,
    ) -> bool {
        assert!(
            !self.is_action_paused.repay,
            "Withdraw is paused, cant perform action"
        );

        true
    }

    pub fn repay_borrows(
        &mut self,
        account_id: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
        borrow_block: BlockHeight,
        borrow_rate: WRatio,
    ) -> Balance {
        assert!(
            self.is_repay_allowed(account_id.clone(), token_address.clone(), token_amount),
            "repay operation is not allowed for account {} on market {}, repay amount {}",
            account_id,
            token_address,
            Balance::from(token_amount)
        );

        self.decrease_borrows(
            account_id,
            token_address,
            token_amount,
            borrow_block,
            borrow_rate,
        )
    }
}

'''
'''--- contracts/controller/src/upgrade.rs ---
use crate::*;

pub trait Upgradable {
    /// function to migrate state with or without new field.
    /// make sure you are using the same method name in upgrade function
    fn migrate() -> Self;

    /// contract versioning
    fn get_version(&self) -> String;

    /// upgrade feature to be called on new deployed contract and read the state of previous contract
    /// using migrate function
    #[cfg(target_arch = "wasm32")]
    fn upgrade(self);
}

#[near_bindgen]
impl Upgradable for Contract {
    #[init(ignore_state)]
    #[private]
    fn migrate() -> Self {
        let contract: Contract = env::state_read().expect("Contract is not initialized");
        contract
    }

    fn get_version(&self) -> String {
        env!("CARGO_PKG_VERSION").to_string()
    }

    #[cfg(target_arch = "wasm32")]
    fn upgrade(self) {
        const GAS_FOR_UPGRADE: u64 = 20 * TGAS.0; //gas occupied by this fn

        //after upgrade we call *pub fn migrate()* on the NEW CODE
        let current_id = env::current_account_id();

        let migrate_method_name = "migrate".as_bytes().to_vec();
        let attached_gas = env::prepaid_gas().0 - env::used_gas().0 - GAS_FOR_UPGRADE;
        unsafe {
            // Load input (new contract code) into register 0
            near_sys::input(0);

            // prepare self-call promise
            let promise_id = near_sys::promise_batch_create(
                current_id.as_bytes().len() as _,
                current_id.as_bytes().as_ptr() as _,
            );

            //1st action, deploy/upgrade code (takes code from register 0)
            near_sys::promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);

            // 2nd action, schedule a call to "migrate()".
            // Will execute on the **new code**
            near_sys::promise_batch_action_function_call(
                promise_id,
                migrate_method_name.len() as _,
                migrate_method_name.as_ptr() as _,
                0 as _,
                0 as _,
                0 as _,
                attached_gas,
            );
        }
    }
}

'''
'''--- contracts/controller/src/user_flow_protection.rs ---
use crate::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::env::block_height;
use near_sdk::{log, AccountId, BlockHeight};

// TODO Find out some good default
const BLOCKS_TO_NEXT_OPERATION: BlockHeight = 10;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct ActionMutex {
    blocked_accounts: LookupMap<AccountId, BlockHeight>,
}

#[near_bindgen]
impl Contract {
    pub fn mutex_lock(&mut self, action: Actions) {
        let user = self
            .user_profiles
            .get(&env::signer_account_id())
            .unwrap_or_default();

        require!(
            self.is_market_registered(env::predecessor_account_id()),
            format!("Market {} is not registered", env::predecessor_account_id())
        );

        require!(
            user.is_consistent(),
            format!("Account {} is inconsistent", env::signer_account_id())
        );

        if !self.mutex.try_lock(&env::signer_account_id()) {
            panic!(
                "failed to acquire {} action mutex for account {account}",
                action,
                account = env::current_account_id()
            );
        }
    }

    pub fn mutex_unlock(&mut self) {
        self.mutex.unlock(&env::signer_account_id());
    }
}

impl Default for ActionMutex {
    fn default() -> Self {
        Self {
            blocked_accounts: LookupMap::new(b"s".to_vec()),
        }
    }
}

impl ActionMutex {
    pub fn lock(&mut self, account_id: &AccountId) {
        let block_height = block_height();
        log!("Lock account: {}", account_id);
        self.blocked_accounts.insert(account_id, &block_height);
    }

    pub fn unlock(&mut self, account_id: &AccountId) {
        log!("Unlock operation for account: {}", account_id);
        self.blocked_accounts.remove(account_id);
    }

    pub fn get_last_block_index(&self, account_id: &AccountId) -> BlockHeight {
        self.blocked_accounts.get(account_id).unwrap_or(0)
    }

    pub fn try_lock(&mut self, account_id: &AccountId) -> bool {
        log!("Try lock account: {}", account_id);
        let mut is_locked: bool = true;
        let current_block_height = block_height();
        let blocked_index = self.get_last_block_index(account_id);
        if blocked_index > 0 && current_block_height - blocked_index <= BLOCKS_TO_NEXT_OPERATION {
            is_locked = false;
        } else {
            self.blocked_accounts
                .insert(account_id, &current_block_height);
        }
        is_locked
    }

    pub fn is_user_can_perform_operation(&mut self, account_id: &AccountId) -> bool {
        log!("Account: {}  can do action", account_id);
        let mut access: bool = false;
        let current_block_height = block_height();
        let blocked_index = self.get_last_block_index(account_id);
        if current_block_height - blocked_index >= BLOCKS_TO_NEXT_OPERATION {
            if blocked_index > 0 {
                self.unlock(account_id);
            }
            access = true;
        }
        access
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::test_utils::test_env::alice;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    use super::*;

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(AccountId::try_from("alice_near".to_string()).unwrap())
            .signer_account_id(AccountId::try_from("bob_near".to_string()).unwrap())
            .predecessor_account_id(AccountId::try_from("carol_near".to_string()).unwrap())
            .block_index(101)
            .block_timestamp(0)
            .is_view(is_view)
            .build()
    }

    #[test]
    fn lock_account() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = ActionMutex::default();
        contract.lock(&AccountId::try_from("alice_near".to_string()).unwrap());
        assert_eq!(
            101,
            contract.get_last_block_index(&AccountId::try_from("alice_near".to_string()).unwrap())
        );
    }

    #[test]
    fn try_lock_after_unlock() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = ActionMutex::default();

        let alice = alice();

        // has to be present in blocked_account
        contract.lock(&alice);
        assert!(contract.blocked_accounts.get(&alice).is_some());

        // as the account is already blocked, but there no more blocks produced it has to fail
        assert!(!contract.try_lock(&alice));
        assert!(contract.blocked_accounts.get(&alice).is_some());

        // as we unlock account it should be absent in blocked_accounts
        (contract.unlock(&alice));
        assert!(contract.blocked_accounts.get(&alice).is_none());

        // should be added in blocked_accounts again
        assert!(contract.try_lock(&alice));
        assert!(contract.blocked_accounts.get(&alice).is_some());
    }

    #[test]
    fn unlock_account() {
        let context = get_context(false);
        testing_env!(context);
        let contract = ActionMutex::default();
        let account = AccountId::try_from("alice_near".to_string()).unwrap();
        assert_eq!(0, contract.get_last_block_index(&account));
    }

    #[test]
    fn is_user_can_perform_operation() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = ActionMutex::default();
        let account = AccountId::try_from("alice_near".to_string()).unwrap();
        contract.lock(&AccountId::try_from("alice_near".to_string()).unwrap());
        assert!(!contract.is_user_can_perform_operation(&account));
    }
}

'''
'''--- contracts/controller/src/user_profile.rs ---
use crate::*;
use near_sdk::BlockHeight;
use std::collections::HashMap;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Default)]
pub struct UserProfile {
    /// Dtoken address -> Supplies balance
    pub account_supplies: HashMap<AccountId, Balance>,

    /// Dtoken address -> Borrow balance
    pub account_borrows: HashMap<AccountId, Balance>,

    /// User consistency
    pub consistency: Consistency,

    /// Borrow data with block height and APY
    pub borrow_data: HashMap<AccountId, BorrowData>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug, Default)]
pub struct WrappedUserProfile {
    /// Dtoken address -> Supplies balance
    pub account_supplies: HashMap<AccountId, WBalance>,

    /// Dtoken address -> Borrow balance
    pub account_borrows: HashMap<AccountId, WBalance>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug, Default)]
pub struct Consistency {
    /// User consistency flag
    pub is_inconsistent: bool,

    /// Block that represents the time when consistency was affected
    pub block_height: BlockHeight,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[derive(Default)]
pub struct BorrowData {
    /// Borrow block height
    pub borrow_block: BlockHeight,

    /// Borrow APY
    pub borrow_rate: Ratio,
}

impl UserProfile {
    pub fn set(&mut self, action: ActionType, token_address: AccountId, token_amount: Balance) {
        if let ActionType::Supply = action {
            *self.account_supplies.entry(token_address).or_default() = token_amount;
        } else {
            *self.account_borrows.entry(token_address).or_default() = token_amount;
        }
    }

    pub fn get(&self, action: ActionType, token_address: AccountId) -> Balance {
        match action {
            ActionType::Supply => *self.account_supplies.get(&token_address).unwrap_or(&0u128),
            ActionType::Borrow => *self.account_borrows.get(&token_address).unwrap_or(&0u128),
        }
    }

    pub fn get_wrapped(&self) -> WrappedUserProfile {
        let mut result = WrappedUserProfile::default();
        for (key, value) in &self.account_supplies {
            result
                .account_supplies
                .insert(key.clone(), WBalance::from(*value));
        }
        for (key, value) in &self.account_borrows {
            result
                .account_borrows
                .insert(key.clone(), WBalance::from(*value));
        }
        result
    }

    pub fn is_consistent(&self) -> bool {
        !self.consistency.is_inconsistent
    }

    pub fn set_consistency(&mut self, consistency: bool, block: BlockHeight) {
        self.consistency.is_inconsistent = !consistency;
        self.consistency.block_height = block;
    }

    pub fn insert_borrow_data(&mut self, token_address: AccountId, borrow_data: BorrowData) {
        self.borrow_data.insert(token_address, borrow_data);
    }

    pub fn get_borrow_data(&mut self, token_address: AccountId) -> BorrowData {
        self.borrow_data
            .get(&token_address)
            .unwrap_or(&BorrowData::default())
            .clone()
    }
}

#[near_bindgen]
impl Contract {
    /// The method can be called only by Admin, Controller, Dtoken contracts
    pub fn set_account_consistency(
        &mut self,
        account: AccountId,
        consistency: bool,
        block: BlockHeight,
    ) {
        require!(
            self.is_valid_admin_call() || self.is_dtoken_caller(),
            "This functionality is allowed to be called by admin, contract or dtoken's contract only"
        );

        self.user_profiles
            .get(&account)
            .unwrap_or_default()
            .set_consistency(consistency, block);
    }
}

#[cfg(test)]
mod tests {
    use crate::UserProfile;
    use general::ONE_TOKEN;
    use near_sdk::{AccountId, Balance};

    #[test]
    fn test_userprofile_get_wrapped() {
        let balance: Balance = 100 * ONE_TOKEN;
        let account = AccountId::new_unchecked("bob.near".to_string());
        let mut profile = UserProfile::default();
        profile.account_supplies.insert(account.clone(), balance);

        let wprofile = profile.get_wrapped();
        let supply_balance = wprofile.account_supplies.get(&account).unwrap();

        assert_eq!(
            profile.account_borrows.len(),
            wprofile.account_borrows.len(),
            "Structures has not similar length"
        );
        assert_eq!(
            profile.account_supplies.len(),
            wprofile.account_supplies.len(),
            "Structures has not similar length"
        );
        assert_eq!(
            Balance::from(*supply_balance),
            balance.clone(),
            "Wrapped structure doesn't match to expected value"
        );
    }
}

'''
'''--- contracts/controller/src/views.rs ---
use crate::borrows_supplies::ActionType::Supply;
use crate::*;
use std::cmp::min;
use std::collections::HashMap;

use crate::admin::Market;
use general::ratio::{BigBalance, BigDecimal, Ratio};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub struct AccountData {
    pub account_id: AccountId,
    pub total_borrows_usd: USD,
    pub total_supplies_usd: USD,
    pub total_available_borrows_usd: USD,
    pub blocked: bool,
    pub health_factor_ratio: WRatio,
    pub user_profile: WrappedUserProfile,
}

impl Default for AccountData {
    fn default() -> Self {
        AccountData {
            account_id: AccountId::new_unchecked("".to_string()),
            total_borrows_usd: U128(0),
            total_supplies_usd: U128(0),
            total_available_borrows_usd: U128(0),
            blocked: false,
            health_factor_ratio: WRatio::from(Ratio::one()),
            user_profile: Default::default(),
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn view_total_borrows_usd(&self, user_id: AccountId) -> USD {
        self.get_total_borrows(&user_id)
    }

    pub fn view_total_supplies_usd(&self, user_id: AccountId) -> USD {
        self.get_total_supplies(&user_id)
    }

    pub fn view_markets(&self) -> Vec<Market> {
        self.get_markets_list()
    }

    pub fn view_accounts_with_borrows(&self) -> Vec<AccountData> {
        let users = self
            .user_profiles
            .iter()
            .filter(|(_, user_profile)| !user_profile.account_borrows.is_empty())
            .map(|(account_id, _)| account_id)
            .collect::<Vec<AccountId>>();

        self.view_accounts(users)
    }

    pub fn view_accounts(&self, user_ids: Vec<AccountId>) -> Vec<AccountData> {
        return user_ids
            .iter()
            .filter(|user_id| self.user_profiles.get(user_id).is_some())
            .map(|user_id| {
                let total_borrows = self.get_total_borrows(user_id);
                let total_supplies = self.get_total_supplies(user_id);

                let total_available_borrows_usd = self.get_theoretical_borrows_max(user_id.clone());

                let health_factor = self.get_health_factor(user_id.clone());
                let user_profile = self.user_profiles.get(user_id).unwrap().get_wrapped();
                AccountData {
                    account_id: user_id.clone(),
                    total_borrows_usd: total_borrows,
                    total_available_borrows_usd,
                    total_supplies_usd: total_supplies,
                    blocked: false,
                    health_factor_ratio: WRatio::from(health_factor),
                    user_profile,
                }
            })
            .collect::<Vec<AccountData>>();
    }

    pub fn view_prices(&self, dtokens: Vec<AccountId>) -> HashMap<AccountId, Price> {
        self.get_prices_for_dtokens(dtokens)
    }

    pub fn view_borrow_max(&self, user_id: AccountId, dtoken_id: AccountId) -> WBalance {
        let borrows = self.get_total_borrows(&user_id).0;
        let accrued_interest = self.calculate_accrued_borrow_interest(user_id.clone());
        let theoretical_max_borrow = self.get_theoretical_borrows_max(user_id);

        let max_borrow = if theoretical_max_borrow.0 > (borrows + accrued_interest) {
            BigDecimal::from(theoretical_max_borrow.0 - (borrows + accrued_interest))
        } else {
            BigBalance::zero()
        };

        let price = Ratio::from(self.get_price(&dtoken_id).unwrap().value.0);
        let max_borrow_in_token = max_borrow / price;

        max_borrow_in_token.into()
    }

    pub fn view_withdraw_max(&self, user_id: AccountId, dtoken_id: AccountId) -> WBalance {
        let supplies = self.get_total_supplies(&user_id);
        let collaterals = self.get_collaterals_by_borrows(user_id.clone());
        let accrued_interest = self.calculate_accrued_borrow_interest(user_id.clone());

        let max_withdraw_limit = if supplies.0 > (accrued_interest + collaterals.0) {
            BigBalance::from(supplies.0 - (accrued_interest + collaterals.0))
        } else {
            BigBalance::zero()
        };

        let price = self.get_price(&dtoken_id).unwrap();
        let max_withdraw_in_token = max_withdraw_limit / BigBalance::from(price.value.0);
        let supply_by_token = self.get_entity_by_token(Supply, user_id, dtoken_id);

        min(supply_by_token, max_withdraw_in_token.0.as_u128()).into()
    }
}

#[cfg(test)]
mod tests {
    use crate::ActionType::{Borrow, Supply};
    use crate::{Config, Contract, OraclePriceHandlerHook, PriceJsonList};
    use general::ratio::Ratio;
    use general::{Price, WRatio, ONE_TOKEN};
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, AccountId};
    use std::str::FromStr;

    pub fn init_test_env() -> (Contract, AccountId, AccountId, AccountId) {
        let (owner_account, _oracle_account, user_account) = (alice(), bob(), carol());

        let mut controller_contract = Contract::new(Config {
            owner_id: owner_account.clone(),
            oracle_account_id: owner_account.clone(),
        });

        let context = VMContextBuilder::new()
            .signer_account_id(owner_account.clone())
            .predecessor_account_id(owner_account)
            .build();

        testing_env!(context);

        let ticker_id_1 = "weth".to_string();
        let asset_id_1 = AccountId::new_unchecked("token.weth".to_string());
        let dtoken_id_1 = AccountId::new_unchecked("dtoken.weth".to_string());

        let ticker_id_2 = "wnear".to_string();
        let asset_id_2 = AccountId::new_unchecked("token.wnear".to_string());
        let dtoken_id_2 = AccountId::new_unchecked("dtoken.wnear".to_string());

        controller_contract.add_market(
            asset_id_1,
            dtoken_id_1,
            ticker_id_1.clone(),
            Ratio::from_str("0.6").unwrap(),
            Ratio::from_str("0.8").unwrap(),
        );
        controller_contract.add_market(
            asset_id_2,
            dtoken_id_2,
            ticker_id_2.clone(),
            Ratio::from_str("0.6").unwrap(),
            Ratio::from_str("0.8").unwrap(),
        );

        let prices: Vec<Price> = vec![
            Price {
                ticker_id: ticker_id_2,
                value: U128(20000),
                volatility: U128(80),
                fraction_digits: 24,
            },
            Price {
                ticker_id: ticker_id_1,
                value: U128(20000),
                volatility: U128(100),
                fraction_digits: 24,
            },
        ];

        controller_contract.oracle_on_data(PriceJsonList {
            block_height: 83456999,
            price_list: prices,
        });

        let wnear_market: AccountId = "dtoken.wnear".parse().unwrap();
        let weth_market: AccountId = "dtoken.weth".parse().unwrap();
        (controller_contract, wnear_market, weth_market, user_account)
    }

    #[test]
    fn test_view_markets() {
        let (near_contract, _, _, _) = init_test_env();

        let ticker_id_1 = "weth".to_string();
        let asset_id_1 = AccountId::new_unchecked("token.weth".to_string());
        let dtoken_id_1 = AccountId::new_unchecked("dtoken.weth".to_string());

        let ticker_id_2 = "wnear".to_string();
        let asset_id_2 = AccountId::new_unchecked("token.wnear".to_string());
        let dtoken_id_2 = AccountId::new_unchecked("dtoken.wnear".to_string());

        let accounts = near_contract.view_markets();

        assert_eq!(accounts.len(), 2, "View market response doesn't match");
        assert_eq!(
            accounts[0].asset_id, asset_id_1,
            "View market AssetId check has been failed"
        );
        assert_eq!(
            accounts[0].dtoken, dtoken_id_1,
            "View market Dtoken check has been failed"
        );
        assert_eq!(
            accounts[0].ticker_id, ticker_id_1,
            "View market Ticker check has been failed"
        );
        assert_eq!(
            accounts[1].asset_id, asset_id_2,
            "View market AssetId check has been failed"
        );
        assert_eq!(
            accounts[1].dtoken, dtoken_id_2,
            "View market Dtoken check has been failed"
        );
        assert_eq!(
            accounts[1].ticker_id, ticker_id_2,
            "View market Ticker check has been failed"
        );
    }

    #[test]
    fn test_view_accounts() {
        let (mut near_contract, token_address, _, _) = init_test_env();
        let accounts = vec![alice(), bob()];

        near_contract.set_entity_by_token(
            Supply,
            accounts[0].clone(),
            token_address,
            100 * ONE_TOKEN,
        );
        let result = near_contract.view_accounts(accounts.clone());

        assert_eq!(result.len(), 1, "View accounts response doesn't match");
        assert_eq!(
            result[0].account_id,
            alice(),
            "View accounts account_id check has been failed"
        );
        assert_eq!(
            result[0].total_borrows_usd,
            U128(0),
            "View accounts total borrows check has been failed"
        );
        assert_eq!(
            result[0].total_supplies_usd,
            U128(100 * 20000),
            "View accounts total supplies check has been failed"
        );

        assert_eq!(
            result[0].total_available_borrows_usd,
            // total_supplies_usd * Ratio::one() / self.liquidation_threshold
            U128(100 * 20000 * 6 / 10),
            "View accounts total supplies check has been failed"
        );

        assert_eq!(
            result[0].health_factor_ratio,
            WRatio::from(near_contract.get_hf_with_supply_and_no_borrow(accounts[0].clone())),
            "View accounts health factor check has been failed"
        );
    }

    #[test]
    fn test_view_withdraw_max_without_borrows() {
        let (mut near_contract, wnear_market, weth_market, user) = init_test_env();

        let wnear_market_supply = 100000000000000000000000000u128; // in yocto == 100 Near
        near_contract.set_entity_by_token(
            Supply,
            user.clone(),
            wnear_market.clone(),
            wnear_market_supply,
        );

        let weth_market_supply = 3141592653589793238462643u128; // Pi in yocto == 3141592653589793238462643
        near_contract.set_entity_by_token(
            Supply,
            user.clone(),
            weth_market.clone(),
            weth_market_supply,
        );

        assert_eq!(
            U128::from(wnear_market_supply),
            near_contract.view_withdraw_max(user.clone(), wnear_market)
        );

        assert_eq!(
            U128::from(weth_market_supply),
            near_contract.view_withdraw_max(user, weth_market)
        );
    }

    #[test]
    fn test_view_withdraw_max_with_borrows() {
        let (mut near_contract, wnear_market, _, user) = init_test_env();

        near_contract.set_entity_by_token(
            Supply,
            user.clone(),
            wnear_market.clone(),
            10000000000000000000000000u128, // in yocto == 10 Near
        );

        near_contract.set_entity_by_token(
            Borrow,
            user.clone(),
            wnear_market.clone(),
            3141592653589793238462643u128, // Pi in yocto == 3141592653589793238462643
        );

        // collaterals = SUM(borrows / market.ltv )
        // max_withdraw = supplies - (accrued_interest + collaterals)
        // max_withdraw = 10.0 - (3.141592653589793238462643u128 / 0.6) = 4.764050000000000000000000 Near
        assert_eq!(
            U128(4764050000000000000000000),
            near_contract.view_withdraw_max(user, wnear_market)
        );
    }

    #[test]
    fn test_view_borrow_max() {
        let (mut near_contract, token_address, _, user) = init_test_env();

        near_contract.set_entity_by_token(
            Supply,
            user.clone(),
            token_address.clone(),
            10000000000000000000000000, // in yocto == 10 Near
        );

        near_contract.set_entity_by_token(
            Borrow,
            user.clone(),
            token_address.clone(),
            5000000000000000000000000, // in yocto == 5 Near
        );

        // max_borrow = theoretical_borrows_max - borrows - accrued
        // max_borrow = 10.0 * 0.6 - 5.0
        assert_eq!(
            U128(ONE_TOKEN),
            near_contract.view_borrow_max(user, token_address)
        );
    }
}

'''
'''--- contracts/general/Cargo.toml ---
[package]
name = "general"
version = "0.0.1"
authors = ["sergii.p@blaize.tech"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.6"
uint = { version = "=0.9.0", default-features = false }
'''
'''--- contracts/general/src/lib.rs ---
pub mod percent;
pub mod ratio;

use crate::percent::WPercent;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId};
use near_sdk::{Balance, Gas};
use std::fmt;

pub const NO_DEPOSIT: Balance = 0;
pub const ONE_YOCTO: Balance = 1;
pub const TGAS: Gas = near_sdk::Gas::ONE_TERA;
pub const ONE_TOKEN: u128 = 10u128.pow(24);

pub type WBalance = U128;

pub type USD = U128;

pub type WRatio = U128;

pub type Digits = u32;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub struct Price {
    /// Ticker Id
    pub ticker_id: String,

    /// Ticker price value
    pub value: WBalance,

    /// Ticker volatility value
    pub volatility: WPercent, // 0..100%

    /// Ticker precision digits number
    pub fraction_digits: Digits,
}

impl Default for Price {
    fn default() -> Self {
        Price {
            ticker_id: "NULL".to_string(),
            value: U128(0),
            volatility: U128(0),
            fraction_digits: 0,
        }
    }
}

#[derive(Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub enum Actions {
    Supply,
    Withdraw,
    Borrow {
        account_to_borrow: AccountId,
    },
    Repay,
    Liquidate {
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        collateral_dtoken: AccountId,
    },
    Reserve,
    Deposit,
}

impl fmt::Display for Actions {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

'''
'''--- contracts/general/src/percent.rs ---
use crate::ratio::BigDecimal;
use near_sdk::json_types::U128;

pub type WPercent = U128;
pub type Percent = BigDecimal;

'''
'''--- contracts/general/src/ratio.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::Serializer;
use std::cmp::{max_by, min_by, Ordering};
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};
use std::str::FromStr;

uint::construct_uint!(
    pub struct U384(6);
);

pub(crate) const MAX_RATIO: u32 = 10000;

const NUM_DECIMALS: u8 = 24;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;
pub type Ratio = BigDecimal;
pub type BigBalance = BigDecimal;

#[derive(Copy, Clone)]
pub struct BigDecimal(pub U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{a}.{b:024}").trim_end_matches('0'))
        } else {
            write!(f, "{a}.0")
        }
    }
}

impl std::fmt::Debug for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self}")
    }
}

const PARSE_INT_ERROR: &str = "Parse int error";

impl FromStr for BigDecimal {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let dot_pos = s.find('.');
        let (int, dec) = if let Some(dot_pos) = dot_pos {
            (
                &s[..dot_pos],
                format!("{:0<24}", &s[dot_pos + 1..])
                    .parse()
                    .map_err(|_| PARSE_INT_ERROR)?,
            )
        } else {
            (s, 0u128)
        };
        let int = U384::from_str(int).map_err(|_| PARSE_INT_ERROR)?;
        if dec >= BIG_DIVISOR {
            return Err(String::from("The decimal part is too large"));
        }
        Ok(Self(int * U384::from(BIG_DIVISOR) + U384::from(dec)))
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for BigDecimal {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, <D as near_sdk::serde::Deserializer<'de>>::Error>
    where
        D: near_sdk::serde::Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        Self::from_str(&s).map_err(near_sdk::serde::de::Error::custom)
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn f64(&self) -> f64 {
        let base = (self.0 / U384::from(BIG_DIVISOR)).as_u128();
        let fract = (self.0 - U384::from(base)).as_u128() as f64;
        base as f64 + fract / (BIG_DIVISOR as f64)
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl Eq for BigDecimal {}

impl Ord for BigDecimal {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.cmp(&other.0)
    }

    fn max(self, other: Self) -> Self
    where
        Self: Sized,
    {
        max_by(self, other, Ord::cmp)
    }

    fn min(self, other: Self) -> Self
    where
        Self: Sized,
    {
        min_by(self, other, Ord::cmp)
    }

    #[allow(clippy::manual_clamp)]
    fn clamp(self, min: Self, max: Self) -> Self
    where
        Self: Sized,
    {
        assert!(min <= max);
        if self < min {
            min
        } else if self > max {
            max
        } else {
            self
        }
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use crate::ratio::LowU128;
    use crate::ratio::Ratio;

    #[test]
    fn should_be_one_percent() {
        let one_percent = LowU128::from(10000000000000000000000u128);

        assert_eq!(
            Ratio::from(one_percent),
            Ratio::one() / Ratio::from(100u128)
        );
    }

    #[test]
    fn should_be_ten() {
        let ten = Ratio::from(10u128) * Ratio::one();

        assert_eq!(ten, Ratio::from(10u128));
    }

    #[test]
    fn should_be_0_0000000628() {
        assert_eq!(
            Ratio::from(LowU128::from(62800000000000000u128)),
            Ratio::from_str("0.0000000628").unwrap()
        );
    }
}

'''
'''--- contracts/leverage_trading/Cargo.toml ---
[package]
name = "leverage-trading"
version = "0.0.2"
authors = ["mark.ts@blaize.tech", "tymofii.s@blaize.tech", "dmytro.sh@blaize.tech"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "=0.9.0", default-features = false }
borsh = "0.9.3"

[dev-dependencies]
workspaces = "0.6.0"
tokio = "1.21.1"
anyhow = "1.0.65"
'''
'''--- contracts/leverage_trading/README.md ---
# Leverage trading over concentrated liquidity

Omomo leverage trading is a leverage trading protocol which utilizes feature of [concentrated liquidty](https://docs.uniswap.org/protocol/concepts/V3-overview/concentrated-liquidity) from [ref.finance](https://ref-finance.medium.com/ref-v2-unlock-concentrated-liquidity-for-better-capital-efficiency-8a63e3c33f5b) and lending borrowing feature of [Omomo lending](https://omomo.gitbook.io/omomo/product/borrow).

## Demo
* Faucet [here](https://qa.d32fiqfhpe57s4.amplifyapp.com/faucet)
* Omomo leverage trading [here](https://main.doa1qum5oc2tn.amplifyapp.com/pairs)
* Corresponding ref.finance V2 liqudity pool [here](https://testnet.ref-finance.com/poolV2/usdt.qa.v1.nearlend.testnet@wnear.qa.v1.nearlend.testnet@2000)

## How it works

### Buy/sell order
First step is Deposit
<details>
<summary>Diagramm</summary>
  
![Omomo - Deposit flow](https://user-images.githubusercontent.com/91728093/202552957-18ba9937-84ea-4e12-a034-202520461b9b.jpg)

</details>
  
Once user have deposited `Sell token` it may borrow required assets, if it chooses to trade with leverage, and create limit order to buy exact amount of `Buy token` at current market price. That where we interact with ref.finance V2 concentrated liquidity feature. It allow us to provide liquidity to the pool at concrete range and wait until market croses that range so whole liquidity is converted from `Sell token` to `Buy token` without paying `Swap fee` and rely on `Slippage tolerance`. Furthermore any operations over our liquidity provides us with additional income equal to pool fee.
<details>
<summary>NOTE</summary>

Right now everything done in one call executed by `open position`

</details>

Once order is created you should see it listed under trading view

<details>
<summary>Diagramm</summary>
  
![Omomo - Create order flow](https://user-images.githubusercontent.com/91728093/202553444-06ac762c-47db-4c7a-8f8f-fb8e33c566f4.jpg)

</details>

### Execute position & Close position

Once order is created it coud be automatically handled by `Executor` when the order is fulfilled. Once order is executed you now may either create `Take profit order` or `Cancel` the position. 

* [not yet implemented] `Take profit order` is counterpart action to opening position, Leverage trading will create limit order at desired price which will be fulfilled once market hit this price and proccessed by executor the same way as open position
* `Cancel` position allows you to immediately swap your `Sell token` at the current market price and could by used to prevent loss or take profit once you satisfied with the PnL

<details>
<summary>Diagramm</summary>
  
![Omomo - Execute order flow](https://user-images.githubusercontent.com/91728093/202554598-6102cc9b-f059-4f9e-b57d-4dd37efa196d.jpg)
![Omomo - Cancel order flow](https://user-images.githubusercontent.com/91728093/202560845-6a3e2781-56a3-4192-946c-45eb7d0bb06a.jpg)
![Omomo - Take profit order flow](https://user-images.githubusercontent.com/91728093/202560868-34de50da-3ea2-42e9-8057-acc834c9caed.jpg)

  
</details>

### Liquidate position 

<details>
<summary>Diagramm</summary>

![Omomo - Liquidate order flow](https://user-images.githubusercontent.com/91728093/202560985-05edd4f9-3c30-44de-97be-e00a22a80d48.jpg)
  
</details>

# Roadmap

'''
'''--- contracts/leverage_trading/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --manifest-path ./Cargo.toml --target wasm32-unknown-unknown --release

'''
'''--- contracts/leverage_trading/deploy_dev.sh ---
# login
#near login

# build & test
./build.sh && ./test.sh

ROOT_ACCOUNT=develop.v1.omomo-finance.testnet
CONTRACT_ID=leverage.develop.v1.omomo-finance.testnet

# latest address version
ETH_TOKEN=weth.develop.v1.omomo-finance.testnet
ETH_MARKET=weth_market.develop.v1.omomo-finance.testnet
ETH_TOKEN_DECIMALS=18

NEAR_TOKEN=wnear.develop.v1.omomo-finance.testnet
NEAR_MARKET=wnear_market.develop.v1.omomo-finance.testnet
NEAR_TOKEN_DECIMALS=24

USDT_TOKEN=usdt.develop.v1.omomo-finance.testnet
USDT_MARKET=usdt_market.develop.v1.omomo-finance.testnet
USDT_TOKEN_DECIMALS=24

USDC_TOKEN=usdc.develop.v1.omomo-finance.testnet
USDC_MARKET=usdc_market.develop.v1.omomo-finance.testnet
USDC_TOKEN_DECIMALS=6

ORACLE_ID=oracle.omomo-finance.testnet
DEX_ACCOUNT=dclv2-dev.ref-dev.testnet

# clean up previuos deployment
echo 'y' | near delete ${CONTRACT_ID} $ROOT_ACCOUNT

# create corresponding accoutns
near create-account ${CONTRACT_ID} --masterAccount $ROOT_ACCOUNT --initialBalance 10

# init contract
near deploy ${CONTRACT_ID} \
  --wasmFile  ./target/wasm32-unknown-unknown/release/leverage_trading.wasm \
  --initFunction 'new_with_config' \
  --initArgs '{
        "owner_id":"'${CONTRACT_ID}'",
        "oracle_account_id":"'$ORACLE_ID'"
    }'

# register limit orders on tokens
near call $NEAR_TOKEN storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --accountId $CONTRACT_ID --amount 0.25 &
near call $USDT_TOKEN storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --accountId $CONTRACT_ID --amount 0.25 &
wait

near call $NEAR_TOKEN storage_deposit '{"account_id": "'$DEX_ACCOUNT'"}' --accountId $CONTRACT_ID --amount 0.25 &
near call $USDT_TOKEN storage_deposit '{"account_id": "'$DEX_ACCOUNT'"}' --accountId $CONTRACT_ID --amount 0.25 &
wait

# add supported pairs
near call $CONTRACT_ID add_pair '{
        "pair_data": {
            "sell_ticker_id": "USDt",
            "sell_token": "'$USDT_TOKEN'",
            "sell_token_decimals": '$USDT_TOKEN_DECIMALS',
            "sell_token_market": "'$USDT_MARKET'",
            "buy_ticker_id": "near",
            "buy_token": "'$NEAR_TOKEN'",
            "buy_token_decimals": '$NEAR_TOKEN_DECIMALS',
            "buy_token_market": "'$NEAR_MARKET'",
            "pool_id": "'$USDT_TOKEN'|'$NEAR_TOKEN'|2000",
            "max_leverage": "25000000000000000000000000",
            "swap_fee": "200000000000000000000"
        }
    }' --accountId $CONTRACT_ID &

#near call $CONTRACT_ID add_pair '{
#        "pair_data": {
#            "sell_ticker_id": "USDt",
#            "sell_token": "'$USDT_TOKEN'",
#            "sell_token_decimals": '$USDT_TOKEN_DECIMALS',
#            "sell_token_market": "'$USDT_MARKET'",
#            "buy_ticker_id": "nWETH",
#            "buy_token": "'$ETH_TOKEN'",
#           "buy_token_decimals": '$ETH_TOKEN_DECIMALS',
#            "buy_token_market": "'$ETH_MARKET'",
#            "pool_id": "'$USDT_TOKEN'|'$ETH_TOKEN'|2000",
#            "max_leverage": "25000000000000000000000000",
#            "swap_fee": "200000000000000000000"
#        }
#    }' --accountId $CONTRACT_ID &

wait
near view $CONTRACT_ID view_supported_pairs '{}'

wait
near view $CONTRACT_ID view_pair_tokens_decimals '{
    "sell_token": "'$USDT_TOKEN'",
    "buy_token": "'$NEAR_TOKEN'"
}'

wait
near view $CONTRACT_ID view_pair_tokens_decimals '{
    "sell_token": "'$USDT_TOKEN'",
    "buy_token": "'$ETH_TOKEN'"
}'

# add mock prices
near call $CONTRACT_ID update_or_insert_price '{
    "token_id":"'$USDT_TOKEN'",
    "price":{
        "ticker_id":"USDt",
        "value":"1010000000000000000000000"
    }
}' --accountId $CONTRACT_ID &

near call $CONTRACT_ID update_or_insert_price '{
    "token_id":"'$NEAR_TOKEN'",
    "price":{
        "ticker_id":"near",
        "value":"2570000000000000000000000"
    }
}' --accountId $CONTRACT_ID &

near call $CONTRACT_ID update_or_insert_price '{
    "token_id":"'$ETH_TOKEN'",
    "price":{
        "ticker_id":"nWETH",
        "value":"1623670000000000000000000000"
    }
}' --accountId $CONTRACT_ID &

wait
near view $CONTRACT_ID view_price '{"token_id":"'$USDT_TOKEN'"}'
near view $CONTRACT_ID view_price '{"token_id":"'$NEAR_TOKEN'"}'
near view $CONTRACT_ID view_price '{"token_id":"'$ETH_TOKEN'"}'

# add mock orders
near call $CONTRACT_ID add_order_from_string '{
        "account_id":"'$CONTRACT_ID'",
        "order":"{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":1000000100000000000000000000,\"sell_token\":\"'$USDT_TOKEN'\",\"buy_token\":\"'$NEAR_TOKEN'\",\"leverage\":\"2.5\",\"sell_token_price\":{\"ticker_id\":\"USDt\",\"value\":\"1.01\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"4.22\"},\"open_or_close_price\":\"2.5\",\"block\":103930916,\"timestamp_ms\":86400000,\"lpt_id\":\"1\"}"
    }' --accountId $CONTRACT_ID &

near call $CONTRACT_ID add_order_from_string '{
        "account_id":"'$CONTRACT_ID'",
        "order":"{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000001100000000000000000000,\"sell_token\":\"'$USDT_TOKEN'\",\"buy_token\":\"'$NEAR_TOKEN'\",\"leverage\":\"1.5\",\"sell_token_price\":{\"ticker_id\":\"USDt\",\"value\":\"1.01\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3.01\"},\"open_or_close_price\":\"2.5\",\"block\":103930917,\"timestamp_ms\":86400000,\"lpt_id\":\"2\"}"
    }' --accountId $CONTRACT_ID &

near call $CONTRACT_ID add_order_from_string '{
        "account_id":"'$CONTRACT_ID'",
        "order":"{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000001100000000000000000000,\"sell_token\":\"'$USDT_TOKEN'\",\"buy_token\":\"'$NEAR_TOKEN'\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDt\",\"value\":\"0.99\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3.99\"},\"open_or_close_price\":\"2.5\",\"block\":103930918,\"timestamp_ms\":86400000,\"lpt_id\":\"3\"}"
    }' --accountId $CONTRACT_ID &

wait

near view $CONTRACT_ID view_orders '{
    "account_id":"'$CONTRACT_ID'",
    "buy_token":"'$NEAR_TOKEN'",
    "sell_token":"'$USDT_TOKEN'",
    "borrow_rate_ratio": "1000"
}'

near view dclv2-dev.ref-dev.testnet get_pool '{"pool_id": "'$USDT_TOKEN'|'$NEAR_TOKEN'|2000"}'

# mint 30000
near call $NEAR_TOKEN mint '{
        "account_id": "'$CONTRACT_ID'",
        "amount": "30000000000000000000000000000"
    }' --accountId $CONTRACT_ID &

# mint 30000
near call $USDT_TOKEN mint '{
        "account_id": "'$CONTRACT_ID'",
        "amount": "30000000000000000000000000000"
    }' --accountId $CONTRACT_ID

near call $CONTRACT_ID add_token_market '{"token_id": "'$USDT_TOKEN'", "market_id": "'$USDT_MARKET'"}' --accountId $CONTRACT_ID
near call $CONTRACT_ID add_token_market '{"token_id": "'$NEAR_TOKEN'", "market_id": "'$NEAR_MARKET'"}' --accountId $CONTRACT_ID

near call $USDT_MARKET set_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ID}'" }' --accountId shared_admin.testnet
near view $USDT_MARKET get_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ID}'" }'

near call controller.$ROOT_ACCOUNT set_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ID}'" }' --accountId controller.$ROOT_ACCOUNT
near view controller.$ROOT_ACCOUNT get_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ID}'" }'

'''
'''--- contracts/leverage_trading/deploy_stage.sh ---
# login
#near login

# build & test
./build.sh && ./test.sh

ROOT_ACCOUNT=v1.omomo-finance.testnet
CONTROLLER_ACCOUNT=controller
ORACLE_ACCOUNT=oracle.omomo-finance.testnet
ETH_TOKEN=eth.fakes.testnet
ETH_TOKEN_DECIMALS=18

NEAR_TOKEN=wrap.testnet
NEAR_TOKEN_DECIMALS=24

USDT_TOKEN=usdt.fakes.testnet
USDT_TOKEN_DECIMALS=24

USDC_TOKEN=usdc.fakes.testnet
USDC_TOKEN_DECIMALS=6

CONTRACT_ADDRESS=leverage.$ROOT_ACCOUNT
DEX_ACCOUNT=dclv2-dev.ref-dev.testnet

# clean up previuos deployment
echo 'y' | near delete ${CONTRACT_ADDRESS} $ROOT_ACCOUNT

# create corresponding accoutns
near create-account ${CONTRACT_ADDRESS} --masterAccount $ROOT_ACCOUNT --initialBalance 10

# redeploy contracts
# --wasmFile  ./target/wasm32-unknown-unknown/release/leverage_trading.wasm
near deploy ${CONTRACT_ADDRESS} \
  --wasmFile  ./target/wasm32-unknown-unknown/release/leverage_trading.wasm \
  --initFunction 'new_with_config' \
  --initArgs '{
        "owner_id":"'${CONTRACT_ADDRESS}'",
        "oracle_account_id":"oracle.omomo-finance.testnet.'$ROOT_ACCOUNT'"
    }'

# register limit orders on tokens
near call $NEAR_TOKEN storage_deposit '{"account_id": "'${CONTRACT_ADDRESS}'"}' --accountId ${CONTRACT_ADDRESS} --amount 0.25 &
near call $USDT_TOKEN storage_deposit '{"account_id": "'${CONTRACT_ADDRESS}'"}' --accountId ${CONTRACT_ADDRESS} --amount 0.25 &
wait

# add supported pairs
near call ${CONTRACT_ADDRESS} add_pair '{
        "pair_data": {
            "sell_ticker_id": "USDt",
            "sell_token": "'$USDT_TOKEN'",
            "sell_token_decimals": 24,
            "sell_token_market": "usdt_market.'$ROOT_ACCOUNT'",
            "buy_ticker_id": "near",
            "buy_token": "'$NEAR_TOKEN'",
            "buy_token_decimals": 24,
            "buy_token_market": "'$NEAR_MARKET'",
            "pool_id": "'$USDT_TOKEN'|'$NEAR_TOKEN'|2000",
            "max_leverage": "25000000000000000000000000",
            "swap_fee": "300000000000000000000"
        }
    }' --accountId ${CONTRACT_ADDRESS} &

near call ${CONTRACT_ADDRESS} add_pair '{
        "pair_data": {
            "sell_ticker_id": "near",
            "sell_token": "'$NEAR_TOKEN'",
            "sell_token_decimals": 24,
            "sell_token_market": "wnear_market.'$ROOT_ACCOUNT'",
            "buy_ticker_id": "USDt",
            "buy_token": "'$USDT_TOKEN'",
            "buy_token_decimals": 24,
            "buy_token_market": "'$USDT_MARKET'",
            "pool_id": "'$USDT_TOKEN'|'$NEAR_TOKEN'|2000",
            "max_leverage": "25000000000000000000000000",
            "swap_fee": "300000000000000000000"
        }
    }' --accountId ${CONTRACT_ADDRESS} &

near call ${CONTRACT_ADDRESS} set_max_order_amount '{
    "value": "10000000000000000000000000000"
}' --accountId ${CONTRACT_ADDRESS} &

wait
# near view ${CONTRACT_ADDRESS} view_supported_pairs '{}'

wait
near view $CONTRACT_ID view_pair_tokens_decimals '{
    "sell_token": "'$USDT_TOKEN'",
    "buy_token": "'$NEAR_TOKEN'"
}'

wait
near view $CONTRACT_ID view_pair_tokens_decimals '{
    "sell_token": "'$NEAR_TOKEN'",
    "buy_token": "'$USDT_TOKEN'"
}'

# add mock prices
near call ${CONTRACT_ADDRESS} update_or_insert_price '{
    "token_id":"'$USDT_TOKEN'",
    "price":{
        "ticker_id":"USDt",
        "value":"1.01"
    }
}' --accountId ${CONTRACT_ADDRESS} &

near call ${CONTRACT_ADDRESS} update_or_insert_price '{
    "token_id":"'$NEAR_TOKEN'",
    "price":{
        "ticker_id":"near",
        "value":"1.83"
    }
}' --accountId ${CONTRACT_ADDRESS} &

wait

near view ${CONTRACT_ADDRESS} view_price '{"token_id":"'$USDT_TOKEN'"}'
near view ${CONTRACT_ADDRESS} view_price '{"token_id":"'$NEAR_TOKEN'"}'

wait

# setup pool
near call $DEX_ACCOUNT storage_deposit '{"account_id": "'${CONTRACT_ADDRESS}'"}' --accountId nearlend.testnet --amount 1 &

near call ${CONTRACT_ADDRESS} add_token_market '{"token_id": "'$NEAR_TOKEN'", "market_id": "wnear_market.'$ROOT_ACCOUNT'"}' --account_id ${CONTRACT_ADDRESS} &
near call ${CONTRACT_ADDRESS} add_token_market '{"token_id": "'$USDT_TOKEN'", "market_id": "usdt_market.'$ROOT_ACCOUNT'"}' --account_id ${CONTRACT_ADDRESS} &

near call usdt_market.$ROOT_ACCOUNT set_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ADDRESS}'" }' --accountId shared_admin.testnet
near view usdt_market.$ROOT_ACCOUNT get_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ADDRESS}'" }'

near call controller.$ROOT_ACCOUNT set_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ADDRESS}'" }' --accountId controller.$ROOT_ACCOUNT
near view controller.$ROOT_ACCOUNT get_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ADDRESS}'" }'

wait

'''
'''--- contracts/leverage_trading/dev_deploy.sh ---
# login
#near login

# build & test
./build.sh && ./test.sh

near dev-deploy -f ./target/wasm32-unknown-unknown/release/leverage_trading.wasm
CONTRACT_ID="$(cat neardev/dev-account)"
# latest address version
NEAR_TOKEN=wnear.develop.v1.omomo-finance.testnet
NEAR_MARKET=wnear_market.develop.v1.omomo-finance.testnet
NEAR_TOKEN_DECIMALS=24

USDT_TOKEN=usdt.develop.v1.omomo-finance.testnet
USDT_MARKET=usdt_market.develop.v1.omomo-finance.testnet
USDT_TOKEN_DECIMALS=24
DEX_ACCOUNT=dclv2-dev.ref-dev.testnet
ORACLE_ACCOUNT=oracle.omomo-finance.testnet

# init contract
near call $CONTRACT_ID --accountId=$CONTRACT_ID new_with_config '{
       "owner_id":"'$CONTRACT_ID'",
       "oracle_account_id":"'$ORACLE_ACCOUNT'"
   }'

# register limit orders on tokens
near call $NEAR_TOKEN storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --accountId $CONTRACT_ID --amount 0.25 &
near call $USDT_TOKEN storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --accountId $CONTRACT_ID --amount 0.25 &
wait

# add supported pairs
near call $CONTRACT_ID add_pair '{
        "pair_data": {
            "sell_ticker_id": "USDT",
            "sell_token": "'$USDT_TOKEN'",
            "sell_token_decimals": '$USDT_TOKEN_DECIMALS',
            "sell_token_market": "'$USDT_MARKET'",
            "buy_ticker_id": "near",
            "buy_token": "'$NEAR_TOKEN'",
            "buy_token_decimals": '$NEAR_TOKEN_DECIMALS',
            "buy_token_market": "'$NEAR_MARKET'",
            "pool_id": "'$USDT_TOKEN'|'$NEAR_TOKEN'|2000",
            "max_leverage": "25000000000000000000000000",
            "swap_fee": "200000000000000000000"
        }
    }' --accountId $CONTRACT_ID &

near call $CONTRACT_ID add_pair '{
        "pair_data": {
            "sell_ticker_id": "near",
            "sell_token": "'$NEAR_TOKEN'",
            "sell_token_decimals": '$NEAR_TOKEN_DECIMALS',
            "sell_token_market": "'$NEAR_MARKET'",
            "buy_ticker_id": "USDT",
            "buy_token": "'$USDT_TOKEN'",
            "buy_token_decimals": '$USDT_TOKEN_DECIMALS',
            "buy_token_market": "'$USDT_MARKET'",
            "pool_id": "'$USDT_TOKEN'|'$NEAR_TOKEN'|2000",
            "max_leverage": "25000000000000000000000000",
            "swap_fee": "200000000000000000000"
        }
    }' --accountId $CONTRACT_ID &

wait
near view $CONTRACT_ID view_supported_pairs '{}'

wait
near view $CONTRACT_ID view_pair_tokens_decimals '{
    "sell_token": "'$USDT_TOKEN'",
    "buy_token": "'$NEAR_TOKEN'"
}'

wait
near view $CONTRACT_ID view_pair_tokens_decimals '{
    "sell_token": "'$NEAR_TOKEN'",
    "buy_token": "'$USDT_TOKEN'"
}'

# add mock prices
near call $CONTRACT_ID update_or_insert_price '{
    "token_id":"'$USDT_TOKEN'",
    "price":{
        "ticker_id":"USDT",
        "value":"1010000000000000000000000"
    }
}' --accountId $CONTRACT_ID

near call $CONTRACT_ID update_or_insert_price '{
    "token_id":"'$NEAR_TOKEN'",
    "price":{
        "ticker_id":"near",
        "value":"2570000000000000000000000"
    }
}' --accountId $CONTRACT_ID &

wait
near view $CONTRACT_ID view_price '{"token_id":"'$USDT_TOKEN'"}'
near view $CONTRACT_ID view_price '{"token_id":"'$NEAR_TOKEN'"}'

# add mock orders
near call $CONTRACT_ID add_order_from_string '{
        "account_id":"'$CONTRACT_ID'",
        "order":"{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":1000000100000000000000000000,\"sell_token\":\"'$USDT_TOKEN'\",\"buy_token\":\"'$NEAR_TOKEN'\",\"leverage\":\"2.5\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"NEAR\",\"value\":\"4220000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930916,\"timestamp_ms\":86400000,\"lpt_id\":\"1\"}"
    }' --accountId $CONTRACT_ID &

near call $CONTRACT_ID add_order_from_string '{
        "account_id":"'$CONTRACT_ID'",
        "order":"{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000001100000000000000000000,\"sell_token\":\"'$USDT_TOKEN'\",\"buy_token\":\"'$NEAR_TOKEN'\",\"leverage\":\"1.5\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"NEAR\",\"value\":\"3010000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930917,\"timestamp_ms\":86400000,\"lpt_id\":\"2\"}"
    }' --accountId $CONTRACT_ID &

near call $CONTRACT_ID add_order_from_string '{
        "account_id":"'$CONTRACT_ID'",
        "order":"{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000001100000000000000000000,\"sell_token\":\"'$USDT_TOKEN'\",\"buy_token\":\"'$NEAR_TOKEN'\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"990000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"NEAR\",\"value\":\"3990000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930918,\"timestamp_ms\":86400000,\"lpt_id\":\"3\"}"
    }' --accountId $CONTRACT_ID &

wait

near view $CONTRACT_ID view_orders '{
    "account_id":"'$CONTRACT_ID'",
    "buy_token":"'$NEAR_TOKEN'",
    "sell_token":"'$USDT_TOKEN'",
    "borrow_rate_ratio": "1000"
}'

near view $DEX_ACCOUNT get_pool '{"pool_id": "'$USDT_TOKEN'|'$NEAR_TOKEN'|2000"}'

# mint 10000
near call $NEAR_TOKEN mint '{
        "account_id": "'$CONTRACT_ID'",
        "amount": "30000000000000000000000000000"
    }' --accountId $CONTRACT_ID &

# mint 10000
near call $USDT_TOKEN mint '{
        "account_id": "'$CONTRACT_ID'",
        "amount": "30000000000000000000000000000"
    }' --accountId $CONTRACT_ID

near call $CONTRACT_ID add_token_market '{"token_id": "'$USDT_TOKEN'", "market_id": "'$USDT_MARKET'"}' --accountId $CONTRACT_ID
near call $CONTRACT_ID add_token_market '{"token_id": "'$NEAR_TOKEN'", "market_id": "'$NEAR_MARKET'"}' --accountId $CONTRACT_ID

'''
'''--- contracts/leverage_trading/dev_user_flow.sh ---
CONTRACT_ID="$(cat neardev/dev-account)"
# latest address version
NEAR_TOKEN=wnear.develop.v1.omomo-finance.testnet
NEAR_MARKET=wnear_market.develop.v1.omomo-finance.testnet
NEAR_TOKEN_DECIMALS=24

USDT_TOKEN=usdt.develop.v1.omomo-finance.testnet
USDT_MARKET=usdt_market.develop.v1.omomo-finance.testnet
USDT_TOKEN_DECIMALS=24
DEX_ACCOUNT=dclv2-dev.ref-dev.testnet

# User account for work with leverage trading
USER_ACCOUNT=...

near call $DEX_ACCOUNT storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --accountId $CONTRACT_ID --amount 1

near call $USDT_TOKEN mint '{
    "account_id": "'$USER_ACCOUNT'",
    "amount": "4000000000000000000000000000000000"
}' --accountId $USER_ACCOUNT

near call $NEAR_TOKEN mint '{
    "account_id": "'$USER_ACCOUNT'",
    "amount": "4000000000000000000000000000000000"
}' --accountId $USER_ACCOUNT

near call $USDT_TOKEN mint '{
    "account_id": "'$CONTRACT_ID'",
    "amount": "4000000000000000000000000000000000"
}' --accountId $USER_ACCOUNT

near call $NEAR_TOKEN mint '{
    "account_id": "'$CONTRACT_ID'",
    "amount": "4000000000000000000000000000000000"
}' --accountId $USER_ACCOUNT

# Deposit
near call $USDT_TOKEN ft_transfer_call '{"receiver_id": "'$CONTRACT_ID'", "amount": "1000000000000000000000000000", "msg": "{\"Deposit\": {\"token\": \"'$USDT_TOKEN'\"}}"}' --accountId $USER_ACCOUNT --depositYocto 1 --gas 300000000000000
near view $CONTRACT_ID balance_of '{"account_id": "'$USER_ACCOUNT'", "token": "'$USDT_TOKEN'" }'

# Create order
# amount = 1000.0
# leverage = 1.0
# open_or_close_price = 1.0
# current_point = -7000
near call $CONTRACT_ID create_order '{
    "order_type": "Buy",
    "left_point": -6960,
    "right_point": -6920,
    "amount": "1000000000000000000000000000",
    "sell_token": "'$USDT_TOKEN'",
    "buy_token": "'$NEAR_TOKEN'",
    "leverage": "1000000000000000000000000",
    "entry_price": "1000000000000000000000000"
}' --accountId $USER_ACCOUNT --gas 300000000000000 --depositYocto 100000000000000

# View new order
near view $CONTRACT_ID view_orders '{
    "account_id":"'$USER_ACCOUNT'",
    "buy_token":"'$NEAR_TOKEN'",
    "sell_token":"'$USDT_TOKEN'",
    "borrow_rate_ratio": "1000"
}'

# Cancel order
near call $CONTRACT_ID cancel_order '{"order_id": "4", "price_impact": "1"}' --accountId $USER_ACCOUNT --gas 160000000000000
# Deposit balance should be returned after cancel order
near view $CONTRACT_ID balance_of '{"account_id": "'$USER_ACCOUNT'", "token": "'$USDT_TOKEN'" }'

# View orders
near view $CONTRACT_ID view_orders '{
    "account_id":"'$USER_ACCOUNT'",
    "buy_token":"'$NEAR_TOKEN'",
    "sell_token":"'$USDT_TOKEN'",
    "borrow_rate_ratio": "1000"
}'
'''
'''--- contracts/leverage_trading/src/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize, Serializer};
use std::cmp::{max_by, min_by, Ordering};
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};
use std::str::FromStr;

uint::construct_uint!(
    pub struct U384(6);
);

pub type WBigDecimal = U128;
pub type WBalance = U128;
pub type WRatio = U128;

pub(crate) const MAX_RATIO: u32 = 10000;

pub const NUM_DECIMALS: u8 = 24;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(pub U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{a}.{b:024}").trim_end_matches('0'))
        } else {
            write!(f, "{a}.0")
        }
    }
}

impl std::fmt::Debug for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self}")
    }
}

const PARSE_INT_ERROR: &str = "Parse int error";

impl FromStr for BigDecimal {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let dot_pos = s.find('.');
        let (int, dec) = if let Some(dot_pos) = dot_pos {
            (
                &s[..dot_pos],
                format!("{:0<24}", &s[dot_pos + 1..])
                    .parse()
                    .map_err(|_| PARSE_INT_ERROR)?,
            )
        } else {
            (s, 0u128)
        };
        let int = U384::from(int.parse::<u128>().unwrap());
        if dec >= BIG_DIVISOR {
            return Err(String::from("The decimal part is too large"));
        }
        Ok(Self(int * U384::from(BIG_DIVISOR) + U384::from(dec)))
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for BigDecimal {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, <D as near_sdk::serde::Deserializer<'de>>::Error>
    where
        D: near_sdk::serde::Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        Self::from_str(&s).map_err(near_sdk::serde::de::Error::custom)
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<i32> for BigDecimal {
    fn from(a: i32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn f64(&self) -> f64 {
        let base = (self.0 / U384::from(BIG_DIVISOR)).as_u128();
        let fract = (self.0 - U384::from(base)).as_u128() as f64;
        base as f64 + fract / (BIG_DIVISOR as f64)
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl Eq for BigDecimal {}

impl Ord for BigDecimal {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.cmp(&other.0)
    }

    fn max(self, other: Self) -> Self
    where
        Self: Sized,
    {
        max_by(self, other, Ord::cmp)
    }

    fn min(self, other: Self) -> Self
    where
        Self: Sized,
    {
        min_by(self, other, Ord::cmp)
    }

    #[allow(clippy::manual_clamp)]
    fn clamp(self, min: Self, max: Self) -> Self
    where
        Self: Sized,
    {
        assert!(min <= max);
        if self < min {
            min
        } else if self > max {
            max
        } else {
            self
        }
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use crate::big_decimal::BigDecimal;
    use crate::big_decimal::LowU128;

    #[test]
    fn should_be_one_percent() {
        let one_percent = LowU128::from(10000000000000000000000u128);

        assert_eq!(
            BigDecimal::from(one_percent),
            BigDecimal::one() / BigDecimal::from(100u128)
        );
    }

    #[test]
    fn should_be_ten() {
        let ten = BigDecimal::from(10u128) * BigDecimal::one();

        assert_eq!(ten, BigDecimal::from(10u128));
    }

    #[test]
    fn should_be_0_0000000628() {
        assert_eq!(
            BigDecimal::from(LowU128::from(62800000000000000u128)),
            BigDecimal::from_str("0.0000000628").unwrap()
        );
    }
}

'''
'''--- contracts/leverage_trading/src/cancel_limit_order.rs ---
use crate::metadata::{Order, OrderStatus};
use crate::ref_finance::{ext_ref_finance, ShortLiquidityInfo};
use crate::{common::Event, HistoryData, OrderType, PendingOrderData, PnLView};
use crate::{Contract, ContractExt};

use near_sdk::env::{self, current_account_id, signer_account_id};
use near_sdk::json_types::U128;
use near_sdk::{ext_contract, near_bindgen, require, Gas, PromiseResult};

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn get_limit_order_liquidity_callback(&self, order_id: U128, order: Order);
    fn remove_limit_order_liquidity_callback(&mut self, order_id: U128, order: Order);
}

#[near_bindgen]
impl Contract {
    pub fn cancel_limit_order(&mut self, order_id: U128, order: Order) {
        require!(
            order.status == OrderStatus::Pending,
            "To cancel a limit order, its status must be Pending."
        );

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 5_u64)
            .get_liquidity(order.lpt_id.clone())
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 270_u64)
                    .with_unused_gas_weight(2_u64)
                    .get_limit_order_liquidity_callback(order_id, order),
            );
    }

    #[private]
    pub fn get_limit_order_liquidity_callback(&self, order_id: U128, order: Order) {
        let liquidity_info: ShortLiquidityInfo = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(liquidity) = near_sdk::serde_json::from_slice::<ShortLiquidityInfo>(&val)
                {
                    liquidity
                } else {
                    panic!("Some problem with liquidity parsing.")
                }
            }
            PromiseResult::Failed => panic!("Ref finance not found liquidity."),
        };

        // We need return partial execute amounts for pair tokens => min (0, 0)
        let (min_amount_x, min_amount_y) = (U128::from(0), U128::from(0));

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 90_u64)
            .remove_liquidity(
                order.lpt_id.clone(),
                liquidity_info.amount,
                min_amount_x,
                min_amount_y,
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 170_u64)
                    .with_unused_gas_weight(2_u64)
                    .remove_limit_order_liquidity_callback(order_id, order),
            );
    }

    #[private]
    pub fn remove_limit_order_liquidity_callback(&mut self, order_id: U128, order: Order) {
        let return_amounts = self.get_return_amounts_after_remove_liquidity(order.clone());

        let mut order = order;
        order.status = OrderStatus::Canceled;

        let executed = if order.order_type == OrderType::Buy {
            return_amounts.amount_sell_token
        } else {
            return_amounts.amount_buy_token
        };

        order.history_data = Some(HistoryData {
            fee: U128(0),
            pnl: PnLView {
                is_profit: false,
                amount: U128(0),
            },
            executed,
        });

        self.add_or_update_order(&signer_account_id(), order.clone(), order_id.0 as u64);
        Event::CancelLimitOrderEvent { order_id }.emit();

        self.remove_pending_order_data(PendingOrderData {
            order_id,
            order_type: order.order_type,
        });

        self.increase_balance(
            &signer_account_id(),
            &order.sell_token,
            return_amounts.amount_sell_token.0,
        );

        self.increase_balance(
            &signer_account_id(),
            &order.buy_token,
            return_amounts.amount_buy_token.0,
        );

        self.withdraw(order.sell_token, return_amounts.amount_sell_token, None);
        self.withdraw(order.buy_token, return_amounts.amount_buy_token, None);
    }
}

'''
'''--- contracts/leverage_trading/src/cancel_order.rs ---
use crate::big_decimal::BigDecimal;
use crate::common::Event;
use crate::execute_order::INACCURACY_RATE;
use crate::ref_finance::ext_ref_finance;
use crate::ref_finance::{Action, Swap};
use crate::utils::{ext_market, ext_token};
use crate::utils::{DAYS_PER_YEAR, MILLISECONDS_PER_DAY};
use crate::*;
use near_sdk::env::{current_account_id, prepaid_gas, signer_account_id};
use near_sdk::{ext_contract, is_promise_success, Gas, PromiseResult, ONE_YOCTO};

const CANCEL_ORDER_GAS: Gas = Gas(160_000_000_000_000);
const GAS_FOR_BORROW: Gas = Gas(200_000_000_000_000);

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn remove_liquidity_callback(&self, order_id: U128, order: Order);
    fn remove_liquidity_for_cancel_leverage_order_callback(
        &mut self,
        order_id: U128,
        order: Order,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    );
    fn close_order_swap_callback(
        &self,
        order_id: U128,
        order: Order,
        token_amount: U128,
        protocol_profit_amount: Option<BigDecimal>,
        history_data: Option<HistoryData>,
    );
    fn cancel_order_swap_callback(
        &self,
        order_id: U128,
        order: Order,
        token_amount: U128,
        protocol_profit_amount: Option<BigDecimal>,
        history_data: Option<HistoryData>,
    );
    fn liquidate_order_swap_callback(
        &self,
        order_id: U128,
        order: Order,
        price_impact: U128,
        order_action: OrderAction,
    );
    fn market_data_callback(
        &self,
        order_id: U128,
        order: Order,
        amount_x: Option<U128>,
        amount_y: Option<U128>,
        current_buy_token_price: Option<U128>,
        slippage_price_impact: Option<U128>,
        reward_executor: bool,
    );
    fn get_pool_callback(
        &self,
        order_id: U128,
        order: Order,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    );
    fn get_liquidity_callback(
        &self,
        order_id: U128,
        order: Order,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    );
    fn repay_callback(
        &self,
        token_borrow: AccountId,
        token_market: AccountId,
        repay_amount: U128,
    ) -> PromiseOrValue<U128>;
    fn withdraw_callback(
        &mut self,
        account_id: AccountId,
        token: AccountId,
        amount: U128,
        reward_executor: Option<bool>,
    );
}

#[near_bindgen]
impl Contract {
    pub fn cancel_order(
        &mut self,
        order_id: U128,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    ) {
        require!(
            prepaid_gas() >= CANCEL_ORDER_GAS,
            "Not enough gas for method: 'Cancel order'"
        );

        let orders = self.orders.get(&signer_account_id()).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", signer_account_id());
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();

        match order.order_type {
            OrderType::Buy | OrderType::Sell => {
                self.cancel_limit_order(order_id, order);
            }
            OrderType::Long | OrderType::Short => {
                self.cancel_leverage_order_or_close_leverage_position(
                    order_id,
                    order,
                    current_buy_token_price,
                    slippage_price_impact,
                );
            }
            OrderType::TakeProfit => {}
        }
    }

    #[private]
    pub fn get_liquidity_callback(
        &mut self,
        order_id: U128,
        order: Order,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    ) {
        let liquidity_info: Liquidity = match env::promise_result(0) {
            PromiseResult::Successful(val) => {
                if let Ok(pool) = near_sdk::serde_json::from_slice::<Liquidity>(&val) {
                    pool
                } else {
                    panic!("Some problem with liquidity parsing")
                }
            }
            _ => panic!("DEX not found liquidity or some problem with pool, please contact with DEX to support"),
        };

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 90_u64)
            .remove_liquidity(
                order.lpt_id.to_string(),
                liquidity_info.amount,
                U128(0_u128),
                U128(0_u128),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 165_u64)
                    .with_unused_gas_weight(2_u64)
                    .remove_liquidity_for_cancel_leverage_order_callback(
                        order_id,
                        order,
                        current_buy_token_price,
                        slippage_price_impact,
                    ),
            );
    }

    #[private]
    pub fn remove_liquidity_for_cancel_leverage_order_callback(
        &mut self,
        order_id: U128,
        order: Order,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    ) {
        let return_amounts = self.get_return_amounts_after_remove_liquidity(order.clone());

        let token_market = if order.order_type == OrderType::Long {
            self.get_market_by(&order.sell_token)
        } else {
            self.get_market_by(&order.buy_token)
        };

        ext_market::ext(token_market)
            .with_static_gas(Gas::ONE_TERA * 10_u64)
            .view_market_data()
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 135_u64)
                    .with_unused_gas_weight(4_u64)
                    .market_data_callback(
                        order_id,
                        order,
                        Some(return_amounts.amount_sell_token),
                        Some(return_amounts.amount_buy_token),
                        Some(current_buy_token_price),
                        Some(slippage_price_impact),
                        false,
                    ),
            );
    }

    #[private]
    pub fn close_order_swap_callback(
        &mut self,
        order_id: U128,
        order: Order,
        token_amount: U128,
        protocol_profit_amount: Option<BigDecimal>,
        history_data: Option<HistoryData>,
    ) {
        require!(is_promise_success(), "Some problem with swap");

        self.final_close_order(
            order_id,
            order,
            token_amount,
            protocol_profit_amount,
            history_data,
            false,
        );
    }

    #[private]
    pub fn cancel_order_swap_callback(
        &mut self,
        order_id: U128,
        order: Order,
        token_amount: U128,
        protocol_profit_amount: Option<BigDecimal>,
        history_data: Option<HistoryData>,
    ) {
        require!(is_promise_success(), "Some problem with swap");
        self.final_cancel_order(
            order_id,
            order,
            token_amount,
            protocol_profit_amount,
            history_data,
        );
    }

    #[private]
    pub fn market_data_callback(
        &mut self,
        order_id: U128,
        order: Order,
        amount_x: Option<U128>,
        amount_y: Option<U128>,
        current_buy_token_price: Option<U128>,
        slippage_price_impact: Option<U128>,
        reward_executor: bool,
    ) {
        let market_data = match env::promise_result(0) {
            PromiseResult::Successful(val) => {
                if let Ok(data) = near_sdk::serde_json::from_slice::<MarketData>(&val) {
                    data
                } else {
                    panic!("Failed parse market data")
                }
            }
            _ => panic!("Failed to get market data"),
        };

        if order.status == OrderStatus::Pending {
            if order.order_type == OrderType::Long && amount_y.unwrap() == U128(0_u128) {
                let borrow_fee_amount = BigDecimal::from(
                    self.get_borrow_fee_amount(order.clone(), market_data.clone()),
                );

                let amount_increase_balance =
                    U128::from(BigDecimal::from(U128(order.amount)) - borrow_fee_amount);

                let history_data = Some(HistoryData {
                    fee: U128::from(self.get_borrow_fee(order.clone(), market_data)),
                    pnl: PnLView {
                        is_profit: false,
                        amount: U128::from(borrow_fee_amount),
                    },
                    executed: U128(0_u128),
                });

                self.final_cancel_order(
                    order_id,
                    order,
                    amount_increase_balance,
                    None,
                    history_data,
                );
            } else {
                self.swap_to_cancel_leverage_order(
                    order_id,
                    order,
                    amount_x,
                    amount_y,
                    current_buy_token_price.unwrap(),
                    slippage_price_impact.unwrap(),
                    market_data,
                );
            };
        } else if let Some((_, tp_order, return_amounts)) =
            self.take_profit_orders.get(&(order_id.0 as u64))
        {
            if tp_order.status == OrderStatus::Executed {
                let borrow_fee_amount = BigDecimal::from(
                    self.get_borrow_fee_amount(order.clone(), market_data.clone()),
                );

                let protocol_fee = BigDecimal::from(self.get_protocol_fee());

                let fee = U128::from(
                    self.get_borrow_fee(order.clone(), market_data)
                        + BigDecimal::from(self.get_swap_fee(&order))
                        + protocol_fee,
                );

                let (pnl, protocol_profit_amount) = if order.order_type == OrderType::Long {
                    // flow for 'Long'
                    let collateral_amount = BigDecimal::from(U128(order.amount));
                    let borrow_amount = collateral_amount * (order.leverage - BigDecimal::one());
                    let open_amount = collateral_amount + borrow_amount;

                    let protocol_profit_amount =
                        (BigDecimal::from(return_amounts.amount_sell_token)
                            - collateral_amount
                            - borrow_amount
                            - borrow_fee_amount)
                            * protocol_fee;

                    let close_amount = BigDecimal::from(return_amounts.amount_sell_token)
                        - borrow_fee_amount
                        - protocol_profit_amount;

                    let pnl = PnLView {
                        is_profit: true,
                        amount: U128::from(close_amount - open_amount),
                    };

                    (pnl, protocol_profit_amount)
                // flow for 'Short'
                } else {
                    let collateral_amount = BigDecimal::from(U128(order.amount));

                    let borrow_amount = collateral_amount * (order.leverage - BigDecimal::one())
                        / order.open_or_close_price;

                    let position_amount = borrow_amount * order.open_or_close_price;

                    let protocol_profit_amount =
                        (position_amount - BigDecimal::from(U128(tp_order.amount))) * protocol_fee;

                    let close_amount = (position_amount - BigDecimal::from(U128(tp_order.amount)))
                        - protocol_profit_amount;

                    let pnl = PnLView {
                        is_profit: true,
                        amount: U128::from(close_amount),
                    };

                    (pnl, protocol_profit_amount)
                };

                let amount_increase_balance =
                    U128::from(BigDecimal::from(U128(order.amount)) + BigDecimal::from(pnl.amount));

                let history_data = Some(HistoryData {
                    fee,
                    pnl,
                    executed: U128(0_u128),
                });

                self.final_close_order(
                    order_id,
                    order,
                    amount_increase_balance,
                    Some(protocol_profit_amount),
                    history_data,
                    reward_executor,
                );
            };
        } else {
            self.swap_to_close_leverage_order(
                order_id,
                order,
                amount_x,
                amount_y,
                current_buy_token_price.unwrap(),
                slippage_price_impact.unwrap(),
                market_data,
            )
        }
    }

    /// Called by a separate transaction with UI
    pub fn repay(&self, order_id: U128, market_data: MarketData) {
        let orders = self.orders.get(&signer_account_id()).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", signer_account_id());
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();

        require!(
            order.status == OrderStatus::Canceled || order.status == OrderStatus::Closed,
            "Error. The order must be in the status 'Canceled' or 'Closed'"
        );

        let (token_borrow, token_market) = if order.order_type == OrderType::Long {
            (
                order.sell_token.clone(),
                self.get_market_by(&order.sell_token),
            )
        } else {
            (
                order.buy_token.clone(),
                self.get_market_by(&order.buy_token),
            )
        };

        let repay_amount = self.get_amount_to_repay(order, market_data);

        ext_token::ext(token_borrow.clone())
            .with_static_gas(GAS_FOR_BORROW)
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer_call(
                token_market.clone(),
                repay_amount,
                None,
                "\"Repay\"".to_string(),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 3_u64)
                    .repay_callback(token_borrow, token_market, repay_amount),
            );
    }

    #[private]
    pub fn repay_callback(
        &self,
        token_borrow: AccountId,
        token_market: AccountId,
        repay_amount: U128,
    ) -> PromiseOrValue<U128> {
        require!(is_promise_success(), "Failed to repay assets");

        Event::RepayEvent {
            token_borrow,
            token_market,
            repay_amount,
        }
        .emit();

        PromiseOrValue::Value(repay_amount)
    }
}

impl Contract {
    pub fn cancel_leverage_order_or_close_leverage_position(
        &mut self,
        order_id: U128,
        order: Order,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    ) {
        match order.status {
            OrderStatus::Pending => self.cancel_leverage_order(
                order_id,
                order,
                current_buy_token_price,
                slippage_price_impact,
            ),
            OrderStatus::Executed => self.close_leverage_position(
                order_id,
                order,
                Some(current_buy_token_price),
                Some(slippage_price_impact),
                false,
            ),
            _ => panic!("Error. Order status has to be 'Pending' or 'Executed'"),
        }
    }

    pub fn cancel_leverage_order(
        &mut self,
        order_id: U128,
        order: Order,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    ) {
        if self.take_profit_orders.get(&(order_id.0 as u64)).is_some() {
            self.take_profit_orders.remove(&(order_id.0 as u64));
            Event::CancelTakeProfitOrderEvent { order_id }.emit();
        };

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 5_u64)
            .get_liquidity(order.lpt_id.clone())
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 275_u64)
                    .with_unused_gas_weight(2_u64)
                    .get_liquidity_callback(
                        order_id,
                        order,
                        current_buy_token_price,
                        slippage_price_impact,
                    ),
            );
    }

    pub fn close_leverage_position(
        &mut self,
        order_id: U128,
        order: Order,
        current_buy_token_price: Option<U128>,
        slippage_price_impact: Option<U128>,
        reward_executor: bool,
    ) {
        let token_market = if order.order_type == OrderType::Long {
            self.get_market_by(&order.sell_token)
        } else {
            self.get_market_by(&order.buy_token)
        };

        if let Some((_, tp_order, _)) = self.take_profit_orders.get(&(order_id.0 as u64)) {
            if tp_order.status == OrderStatus::Pending {
                self.cancel_take_profit_order(
                    order_id,
                    Some((
                        order_id,
                        order,
                        current_buy_token_price.unwrap(),
                        slippage_price_impact.unwrap(),
                    )),
                );
            } else {
                ext_market::ext(token_market)
                    .with_static_gas(Gas::ONE_TERA * 10_u64)
                    .view_market_data()
                    .then(
                        ext_self::ext(current_account_id())
                            .with_static_gas(Gas::ONE_TERA * 135_u64)
                            .with_unused_gas_weight(4_u64)
                            .market_data_callback(
                                order_id,
                                order,
                                None,
                                None,
                                current_buy_token_price,
                                slippage_price_impact,
                                reward_executor,
                            ),
                    );
            }
        } else {
            ext_market::ext(token_market)
                .with_static_gas(Gas::ONE_TERA * 10_u64)
                .view_market_data()
                .then(
                    ext_self::ext(current_account_id())
                        .with_static_gas(Gas::ONE_TERA * 135_u64)
                        .with_unused_gas_weight(4_u64)
                        .market_data_callback(
                            order_id,
                            order,
                            None,
                            None,
                            current_buy_token_price,
                            slippage_price_impact,
                            reward_executor,
                        ),
                );
        }
    }

    pub fn swap_to_close_leverage_order(
        &mut self,
        order_id: U128,
        order: Order,
        amount_x: Option<U128>,
        amount_y: Option<U128>,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
        market_data: MarketData,
    ) {
        let (swap_amount, input_token, output_token) = if order.order_type == OrderType::Long {
            self.get_data_to_swap_for_long(order_id, order.clone(), amount_y)
        } else {
            self.get_data_to_swap_for_short(
                order_id,
                order.clone(),
                amount_x,
                current_buy_token_price,
                slippage_price_impact,
                market_data.clone(),
            )
        };

        let borrow_fee_amount =
            BigDecimal::from(self.get_borrow_fee_amount(order.clone(), market_data.clone()));

        let mut fee = self.get_borrow_fee(order.clone(), market_data)
            + BigDecimal::from(self.get_swap_fee(&order));
        let mut protocol_profit_amount: Option<BigDecimal> = None;

        let (fee, pnl, protocol_profit_amount) = if order.order_type == OrderType::Long {
            // flow for 'Long'
            let open_amount = BigDecimal::from(U128(order.amount)) * order.leverage;

            let amount_after_swap = BigDecimal::from(swap_amount)
                * BigDecimal::from(current_buy_token_price)
                * (BigDecimal::one() - BigDecimal::from(slippage_price_impact));

            let close_amount = if let Some((_, _, return_amounts)) =
                self.take_profit_orders.get(&(order_id.0 as u64))
            {
                BigDecimal::from(return_amounts.amount_sell_token)
                    + amount_after_swap
                    + BigDecimal::from(amount_x.unwrap())
                    - borrow_fee_amount
            } else {
                amount_after_swap + BigDecimal::from(amount_x.unwrap()) - borrow_fee_amount
            };

            let pnl = if open_amount > close_amount {
                PnLView {
                    is_profit: false,
                    amount: U128::from(open_amount - close_amount),
                }
            } else {
                let protocol_fee = BigDecimal::from(self.get_protocol_fee());
                fee = fee + protocol_fee;

                protocol_profit_amount = Some((close_amount - open_amount) * protocol_fee);

                PnLView {
                    is_profit: true,
                    amount: U128::from(
                        close_amount - open_amount - protocol_profit_amount.unwrap(),
                    ),
                }
            };

            (U128::from(fee), pnl, protocol_profit_amount)
        // flow for 'Short'
        } else {
            let borrow_amount = BigDecimal::from(U128(order.amount))
                * (order.leverage - BigDecimal::one())
                / order.open_or_close_price;

            let position_amount = BigDecimal::from(U128(order.amount)) * order.leverage;

            let close_amount = if let Some((_, order, return_amounts)) =
                self.take_profit_orders.get(&(order_id.0 as u64))
            {
                position_amount
                    - (borrow_amount * order.open_or_close_price
                        - BigDecimal::from(return_amounts.amount_sell_token))
                    - BigDecimal::from(swap_amount)
            } else {
                position_amount - BigDecimal::from(swap_amount)
            };

            let pnl = if BigDecimal::from(U128(order.amount)) > close_amount {
                PnLView {
                    is_profit: false,
                    amount: U128::from(BigDecimal::from(U128(order.amount)) - close_amount),
                }
            } else {
                let protocol_fee = BigDecimal::from(self.get_protocol_fee());
                fee = fee + protocol_fee;

                protocol_profit_amount =
                    Some((close_amount - BigDecimal::from(U128(order.amount))) * protocol_fee);

                PnLView {
                    is_profit: true,
                    amount: U128::from(
                        close_amount
                            - BigDecimal::from(U128(order.amount))
                            - protocol_profit_amount.unwrap(),
                    ),
                }
            };

            (U128::from(fee), pnl, protocol_profit_amount)
        };
        let amount_increase_balance = if pnl.is_profit {
            U128::from(BigDecimal::from(U128(order.amount)) + BigDecimal::from(pnl.amount))
        } else {
            U128::from(BigDecimal::from(U128(order.amount)) - BigDecimal::from(pnl.amount))
        };

        let history_data = Some(HistoryData {
            fee,
            pnl,
            executed: U128(0_u128),
        });

        let action = Action::SwapAction {
            Swap: Swap {
                pool_ids: vec![
                    self.get_trade_pair(&order.sell_token, &order.buy_token)
                        .pool_id,
                ],
                output_token,
                min_output_amount: WBalance::from(0),
            },
        };

        let token_decimals = if input_token == order.sell_token {
            self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token)
                .0
        } else {
            self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token)
                .1
        };

        let swap_amount = self.from_protocol_to_token_decimals(swap_amount, token_decimals);

        ext_token::ext(input_token)
            .with_static_gas(Gas::ONE_TERA * 90_u64)
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer_call(
                self.ref_finance_account.clone(),
                swap_amount,
                Some("Swap".to_string()),
                near_sdk::serde_json::to_string(&action).unwrap(),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 30_u64)
                    .with_unused_gas_weight(4_u64)
                    .close_order_swap_callback(
                        order_id,
                        order,
                        amount_increase_balance,
                        protocol_profit_amount,
                        history_data,
                    ),
            );
    }

    pub fn swap_to_cancel_leverage_order(
        &mut self,
        order_id: U128,
        order: Order,
        amount_x: Option<U128>,
        amount_y: Option<U128>,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
        market_data: MarketData,
    ) {
        let (swap_amount, input_token, output_token) = if order.order_type == OrderType::Long {
            self.get_data_to_swap_for_long(order_id, order.clone(), amount_y)
        } else {
            self.get_data_to_swap_for_short(
                order_id,
                order.clone(),
                amount_x,
                current_buy_token_price,
                slippage_price_impact,
                market_data.clone(),
            )
        };

        let borrow_fee_amount =
            BigDecimal::from(self.get_borrow_fee_amount(order.clone(), market_data));

        let mut fee = borrow_fee_amount + BigDecimal::from(self.get_swap_fee(&order));
        let mut protocol_profit_amount: Option<BigDecimal> = None;

        let (fee, pnl, protocol_profit_amount) = if order.order_type == OrderType::Long {
            // flow for 'Long'
            let open_amount = BigDecimal::from(U128(order.amount)) * order.leverage;

            let amount_after_swap = BigDecimal::from(swap_amount)
                * BigDecimal::from(current_buy_token_price)
                * (BigDecimal::one() - BigDecimal::from(slippage_price_impact));

            let cancel_amount =
                amount_after_swap + BigDecimal::from(amount_x.unwrap()) - borrow_fee_amount;

            let pnl = if open_amount > cancel_amount {
                PnLView {
                    is_profit: false,
                    amount: U128::from(open_amount - cancel_amount),
                }
            } else {
                let protocol_fee = BigDecimal::from(self.get_protocol_fee());
                fee = fee + protocol_fee;

                protocol_profit_amount = Some((cancel_amount - open_amount) * protocol_fee);

                PnLView {
                    is_profit: true,
                    amount: U128::from(
                        cancel_amount - open_amount - protocol_profit_amount.unwrap(),
                    ),
                }
            };

            (U128::from(fee), pnl, protocol_profit_amount)
        // flow for 'Short'
        } else {
            let collateral_amount = BigDecimal::from(U128(order.amount));

            let cancel_amount = (BigDecimal::from(U128(order.amount))
                + BigDecimal::from(amount_x.unwrap()))
                - BigDecimal::from(swap_amount);

            let pnl = if collateral_amount > cancel_amount {
                PnLView {
                    is_profit: false,
                    amount: U128::from(collateral_amount - cancel_amount),
                }
            } else {
                let protocol_fee = BigDecimal::from(self.get_protocol_fee());
                fee = fee + protocol_fee;

                protocol_profit_amount = Some((cancel_amount - collateral_amount) * protocol_fee);

                PnLView {
                    is_profit: true,
                    amount: U128::from(
                        cancel_amount - collateral_amount - protocol_profit_amount.unwrap(),
                    ),
                }
            };

            (U128::from(fee), pnl, protocol_profit_amount)
        };
        let amount_increase_balance = if pnl.is_profit {
            U128::from(BigDecimal::from(U128(order.amount)) + BigDecimal::from(pnl.amount))
        } else {
            U128::from(BigDecimal::from(U128(order.amount)) - BigDecimal::from(pnl.amount))
        };

        let history_data = Some(HistoryData {
            fee,
            pnl,
            executed: U128(0_u128),
        });

        let action = Action::SwapAction {
            Swap: Swap {
                pool_ids: vec![
                    self.get_trade_pair(&order.sell_token, &order.buy_token)
                        .pool_id,
                ],
                output_token,
                min_output_amount: WBalance::from(0),
            },
        };

        let token_decimals = if input_token == order.sell_token {
            self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token)
                .0
        } else {
            self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token)
                .1
        };

        let swap_amount = self.from_protocol_to_token_decimals(swap_amount, token_decimals);

        ext_token::ext(input_token)
            .with_static_gas(Gas::ONE_TERA * 90_u64)
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer_call(
                self.ref_finance_account.clone(),
                swap_amount,
                Some("Swap".to_string()),
                near_sdk::serde_json::to_string(&action).unwrap(),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 30_u64)
                    .with_unused_gas_weight(4_u64)
                    .cancel_order_swap_callback(
                        order_id,
                        order,
                        amount_increase_balance,
                        protocol_profit_amount,
                        history_data,
                    ),
            );
    }

    pub fn get_amounts_to_cancel(
        &self,
        order: Order,
        liquidity_info: Liquidity,
    ) -> [U128; 3_usize] {
        if order.order_type == OrderType::Long {
            let min_amount_x = U128::from(
                BigDecimal::from(U128::from(order.amount))
                    * order.leverage
                    * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
            );
            let min_amount_y = U128::from(0);

            let (sell_token_decimals, _) =
                self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
            let min_amount_x =
                self.from_protocol_to_token_decimals(min_amount_x, sell_token_decimals);

            [liquidity_info.amount, min_amount_x, min_amount_y]
        } else {
            let min_amount_x = U128::from(0);
            let min_amount_y = U128::from(
                BigDecimal::from(U128::from(order.amount))
                    * (order.leverage - BigDecimal::one())
                    * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE))
                    / order.open_or_close_price,
            );

            let (_, buy_token_decimals) =
                self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
            let min_amount_y =
                self.from_protocol_to_token_decimals(min_amount_y, buy_token_decimals);

            [liquidity_info.amount, min_amount_x, min_amount_y]
        }
    }

    pub fn get_data_to_swap_for_long(
        &self,
        order_id: U128,
        order: Order,
        amount_y: Option<U128>,
    ) -> (U128, AccountId, AccountId) {
        require!(
            order.order_type == OrderType::Long,
            "Only for order type`Long`"
        );

        let swap_amount = if order.status == OrderStatus::Pending {
            amount_y.unwrap()
        } else if let Some((_, _, return_amounts)) =
            self.take_profit_orders.get(&(order_id.0 as u64))
        {
            return_amounts.amount_buy_token
        } else {
            U128::from(
                BigDecimal::from(U128::from(order.amount)) * order.leverage
                    / order.open_or_close_price,
            )
        };
        // amount, input_token, output_token
        (swap_amount, order.buy_token, order.sell_token)
    }

    pub fn get_data_to_swap_for_short(
        &self,
        order_id: U128,
        order: Order,
        amount_x: Option<U128>,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
        market_data: MarketData,
    ) -> (U128, AccountId, AccountId) {
        require!(
            order.order_type == OrderType::Short,
            "Only for order type`Short`"
        );

        let require_amount = if order.status == OrderStatus::Pending {
            let borrow_fee_amount =
                BigDecimal::from(self.get_borrow_fee_amount(order.clone(), market_data));

            (borrow_fee_amount * BigDecimal::from(current_buy_token_price)
                + BigDecimal::from(amount_x.unwrap()))
                * (BigDecimal::one() + BigDecimal::from(slippage_price_impact))
        } else {
            let borrow_amount = BigDecimal::from(U128(order.amount))
                * (order.leverage - BigDecimal::one())
                / order.open_or_close_price;

            let borrow_fee_amount =
                BigDecimal::from(self.get_borrow_fee_amount(order.clone(), market_data));

            if let Some((_, _, return_amounts)) = self.take_profit_orders.get(&(order_id.0 as u64))
            {
                (borrow_fee_amount + borrow_amount
                    - BigDecimal::from(return_amounts.amount_buy_token))
                    * BigDecimal::from(current_buy_token_price)
                    * (BigDecimal::one() + BigDecimal::from(slippage_price_impact))
            } else {
                (borrow_fee_amount + borrow_amount)
                    * BigDecimal::from(current_buy_token_price)
                    * (BigDecimal::one() + BigDecimal::from(slippage_price_impact))
            }
        };

        let swap_fee = BigDecimal::from(self.get_swap_fee(&order));
        let swap_fee_amount = require_amount * swap_fee;
        let swap_amount = U128::from(require_amount + swap_fee_amount);
        // amount, input_token, output_token
        (swap_amount, order.sell_token, order.buy_token)
    }

    pub fn final_cancel_order(
        &mut self,
        order_id: U128,
        order: Order,
        token_amount: U128,
        protocol_profit_amount: Option<BigDecimal>,
        history_data: Option<HistoryData>,
    ) {
        let order = Order {
            status: OrderStatus::Canceled,
            history_data,
            ..order
        };

        self.add_or_update_order(&signer_account_id(), order.clone(), order_id.0 as u64);

        self.remove_pending_order_data(PendingOrderData {
            order_id,
            order_type: order.order_type,
        });

        if let Some(amount) = protocol_profit_amount {
            self.increase_protocol_profit_balance(&order.sell_token, amount)
        }

        Event::CancelLeverageOrderEvent { order_id }.emit();

        self.increase_balance(&signer_account_id(), &order.sell_token, token_amount.0);

        self.withdraw(order.sell_token, token_amount, None);
    }

    pub fn final_close_order(
        &mut self,
        order_id: U128,
        order: Order,
        token_amount: U128,
        protocol_profit_amount: Option<BigDecimal>,
        history_data: Option<HistoryData>,
        reward_executor: bool,
    ) {
        let order = Order {
            status: OrderStatus::Closed,
            history_data,
            ..order
        };

        if self.take_profit_orders.get(&(order_id.0 as u64)).is_some() {
            self.take_profit_orders.remove(&(order_id.0 as u64));
        };

        self.add_or_update_order(&signer_account_id(), order.clone(), order_id.0 as u64);

        self.remove_pending_order_data(PendingOrderData {
            order_id,
            order_type: order.order_type,
        });

        if let Some(amount) = protocol_profit_amount {
            self.increase_protocol_profit_balance(&order.sell_token, amount)
        }

        Event::CloseLeveragePositionEvent { order_id }.emit();

        self.increase_balance(&signer_account_id(), &order.sell_token, token_amount.0);

        self.withdraw(order.sell_token, token_amount, Some(reward_executor));
    }

    pub fn get_borrow_fee(&self, order: Order, market_data: MarketData) -> BigDecimal {
        let current_timestamp_ms = env::block_timestamp_ms();

        let borrow_period = ((current_timestamp_ms - order.timestamp_ms) as f64
            / MILLISECONDS_PER_DAY as f64)
            .ceil();

        BigDecimal::from(market_data.borrow_rate_ratio)
            / BigDecimal::from(U128(DAYS_PER_YEAR as u128))
            * BigDecimal::from(U128(borrow_period as u128))
    }

    pub fn get_borrow_fee_amount(&self, order: Order, market_data: MarketData) -> U128 {
        let borrow_fee = self.get_borrow_fee(order.clone(), market_data);

        let borrow_amount = if order.order_type == OrderType::Long {
            BigDecimal::from(U128(order.amount)) * (order.leverage - BigDecimal::one())
        } else {
            BigDecimal::from(U128(order.amount)) * (order.leverage - BigDecimal::one())
                / order.open_or_close_price
        };

        let borrow_fee_amount = borrow_amount * borrow_fee;

        U128::from(borrow_fee_amount)
    }

    pub fn get_amount_to_repay(&self, order: Order, market_data: MarketData) -> U128 {
        let borrow_amount = if order.order_type == OrderType::Long {
            BigDecimal::from(U128(order.amount)) * (order.leverage - BigDecimal::one())
        } else {
            BigDecimal::from(U128(order.amount)) * (order.leverage - BigDecimal::one())
                / order.open_or_close_price
        };

        let borrow_fee_amount = BigDecimal::from(self.get_borrow_fee_amount(order, market_data));
        let repay_amount = borrow_amount + borrow_fee_amount;
        U128::from(repay_amount)
    }

    pub fn increase_protocol_profit_balance(&mut self, token_id: &AccountId, amount: BigDecimal) {
        let current_profit = self.protocol_profit.get(token_id).unwrap_or_default();

        self.protocol_profit
            .insert(token_id, &(current_profit + amount));
    }
}

#[cfg(test)]
mod tests {
    use crate::utils::MILLISECONDS_PER_DAY;

    use super::*;

    use near_sdk::test_utils::test_env::alice;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool, block_timestamp: Option<u64>) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("leverage.develop.v1.omomo-finance.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("alice.testnet".parse().unwrap())
            .block_index(103930920)
            .block_timestamp(block_timestamp.unwrap_or(1))
            .is_view(is_view)
            .build()
    }

    fn get_current_day_in_nanoseconds(day: u64) -> Option<u64> {
        let nanoseconds_in_one_millisecond = 1_000_000;
        Some(MILLISECONDS_PER_DAY * day * nanoseconds_in_one_millisecond)
    }

    #[test]
    fn test_order_was_canceled() {
        let current_day = get_current_day_in_nanoseconds(2); // borrow period 1 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        contract.update_or_insert_price(
            "usdt.fakes.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDt".to_string(),
                value: U128::from(2000000000000000000000000),
            },
        );
        contract.update_or_insert_price(
            "wrap.testnet".parse().unwrap(),
            Price {
                ticker_id: "near".to_string(),
                value: U128::from(4220000000000000000000000),
            },
        );

        let order1 = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":10000000000000000000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3070000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930916,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#543\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order1);

        let order_id = U128(1);
        let order = Order {
            status: OrderStatus::Pending,
            order_type: OrderType::Long,
            amount: 10_u128.pow(25),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            buy_token: "wrap.testnet".parse().unwrap(),
            leverage: BigDecimal::from(U128(2 * 10_u128.pow(24))),
            sell_token_price: Price {
                ticker_id: "USDt".to_string(),
                value: U128::from(101 * 10_u128.pow(22)),
            },
            buy_token_price: Price {
                ticker_id: "near".to_string(),
                value: U128::from(307 * 10_u128.pow(22)),
            },
            open_or_close_price: BigDecimal::from(U128(1)),
            block: 105210654,
            timestamp_ms: 86400000,
            lpt_id: "usdt.fakes.testnet|wrap.testnet|2000#238".to_string(),
            history_data: Default::default(),
        };

        let pair_id = PairId {
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            buy_token: "wrap.testnet".parse().unwrap(),
        };

        let amount = U128::from(
            BigDecimal::from(U128(2 * 10_u128.pow(25)))
                * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
        );

        contract.final_cancel_order(order_id, order, amount, None, None);

        let orders = contract.orders.get(&alice()).unwrap();
        let order = orders.get(&1).unwrap();

        let orders_from_pair = contract.orders_per_pair_view.get(&pair_id).unwrap();
        let order_from_pair = orders_from_pair.get(&1).unwrap();

        assert_eq!(order.status, OrderStatus::Canceled);
        assert_eq!(order_from_pair.status, order.status);
    }
}

'''
'''--- contracts/leverage_trading/src/cancel_take_profit_order.rs ---
use crate::common::Event;

use crate::ref_finance::ext_ref_finance;
use crate::utils::ext_market;
use crate::*;
use near_sdk::env::current_account_id;
use near_sdk::{ext_contract, is_promise_success, serde_json, Gas, PromiseResult};

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn get_take_profit_liquidity_info_callback(
        &self,
        order_id: U128,
        take_profit_info: (PricePoints, Order, ReturnAmounts),
        data_to_close_position: Option<(U128, Order, U128, U128)>,
    );
    fn remove_liquidity_from_take_profit_callback(
        &self,
        order_id: U128,
        data_to_close_position: Option<(U128, Order, U128, U128)>,
    );
    fn market_data_callback(
        &self,
        order_id: U128,
        order: Order,
        amount_x: Option<U128>,
        amount_y: Option<U128>,
        current_buy_token_price: U128,
        slippage_price_impact: U128,
    );
}

#[near_bindgen]
impl Contract {
    pub fn cancel_take_profit_order(
        &mut self,
        order_id: U128,
        data_to_close_position: Option<(U128, Order, U128, U128)>,
    ) {
        let take_profit_order = self.take_profit_orders.get(&(order_id.0 as u64));
        require!(take_profit_order.is_some(), "Take profit order not found.");

        let take_profit_order_pair = take_profit_order.unwrap();
        let tpo = take_profit_order_pair.1.clone();
        match tpo.status {
            OrderStatus::PendingOrderExecute => {
                self.take_profit_orders.remove(&(order_id.0 as u64));

                Event::CancelTakeProfitOrderEvent { order_id }.emit();
            }
            OrderStatus::Pending => {
                if data_to_close_position.is_some() {
                    ext_ref_finance::ext(self.ref_finance_account.clone())
                        .with_static_gas(Gas::ONE_TERA * 5_u64)
                        .get_liquidity(take_profit_order_pair.1.lpt_id.clone())
                        .then(
                            ext_self::ext(current_account_id())
                                .with_static_gas(Gas::ONE_TERA * 245_u64)
                                .get_take_profit_liquidity_info_callback(
                                    order_id,
                                    take_profit_order_pair,
                                    data_to_close_position,
                                ),
                        );
                } else {
                    panic!("Canceling a 'Take Profit' order is impossible when a position is already open")
                }
            }
            _ => {}
        }
    }

    #[private]
    pub fn get_take_profit_liquidity_info_callback(
        &self,
        order_id: U128,
        take_profit_info: (PricePoints, Order, ReturnAmounts),
        data_to_close_position: Option<(U128, Order, U128, U128)>,
    ) {
        require!(is_promise_success(), "Some problem with getting liquidity.");

        let liquidity_info: Liquidity = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(liquidity) = near_sdk::serde_json::from_slice::<Liquidity>(&val) {
                    liquidity
                } else {
                    panic!("Some problem with liquidity parsing.")
                }
            }
            PromiseResult::Failed => panic!("Ref finance not found liquidity."),
        };

        let (min_amount_x, min_amount_y) = (U128::from(0), U128::from(0));

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 90_u64)
            .remove_liquidity(
                take_profit_info.1.lpt_id,
                liquidity_info.amount,
                min_amount_x,
                min_amount_y,
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 150_u64)
                    .remove_liquidity_from_take_profit_callback(order_id, data_to_close_position),
            );
    }

    #[private]
    pub fn remove_liquidity_from_take_profit_callback(
        &mut self,
        order_id: U128,
        data_to_close_position: Option<(U128, Order, U128, U128)>,
    ) {
        let parent_order = self.get_order_by(order_id.0).unwrap();

        let return_amounts = self.get_return_amounts_after_remove_liquidity(parent_order.clone());

        if parent_order.order_type == OrderType::Long
            && return_amounts.amount_sell_token != U128(0_u128)
            || parent_order.order_type == OrderType::Short
                && return_amounts.amount_buy_token != U128(0_u128)
        {
            self.mark_take_profit_order_as_partly_executed(order_id, return_amounts);
        }

        Event::CancelTakeProfitOrderEvent { order_id }.emit();

        self.remove_pending_order_data(PendingOrderData {
            order_id,
            order_type: OrderType::TakeProfit,
        });

        if let Some((order_id, order, current_buy_token_price, slippage_price_impact)) =
            data_to_close_position
        {
            let token_market = if order.order_type == OrderType::Long {
                self.get_market_by(&order.sell_token)
            } else {
                self.get_market_by(&order.buy_token)
            };

            ext_market::ext(token_market)
                .with_static_gas(Gas::ONE_TERA * 10_u64)
                .view_market_data()
                .then(
                    ext_self::ext(current_account_id())
                        .with_static_gas(Gas::ONE_TERA * 135_u64)
                        .with_unused_gas_weight(4_u64)
                        .market_data_callback(
                            order_id,
                            order,
                            None,
                            None,
                            current_buy_token_price,
                            slippage_price_impact,
                        ),
                );
        }
    }
}

impl Contract {
    pub fn mark_take_profit_order_as_partly_executed(
        &mut self,
        order_id: U128,
        return_amounts: ReturnAmounts,
    ) {
        let tpo = self.take_profit_orders.get(&(order_id.0 as u64)).unwrap();
        let mut order = tpo.1;
        order.status = OrderStatus::PartlyExecuted;

        self.take_profit_orders
            .insert(&(order_id.0 as u64), &(tpo.0, order, return_amounts));
    }
    /// this method is used only to process the result of a call 'remove_liquidity'
    pub fn get_return_amounts_after_remove_liquidity(&self, order: Order) -> ReturnAmounts {
        match env::promise_result(0) {
            PromiseResult::Successful(amounts) => {
                if let Ok((amount_x, amount_y)) = serde_json::from_slice::<(U128, U128)>(&amounts) {
                    let (sell_token_decimals, buy_token_decimals) =
                        self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);

                    let amount_x =
                        self.from_token_to_protocol_decimals(amount_x.0, sell_token_decimals);

                    let amount_y =
                        self.from_token_to_protocol_decimals(amount_y.0, buy_token_decimals);

                    ReturnAmounts {
                        amount_sell_token: amount_x,
                        amount_buy_token: amount_y,
                    }
                } else {
                    panic!("Some problems with the parsing result return amount from Dex")
                }
            }
            _ => panic!("Some problem with return amount from Dex"),
        }
    }
}

'''
'''--- contracts/leverage_trading/src/common.rs ---
use crate::metadata::Price;
use crate::{OrderStatus, OrderType};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::json;
use near_sdk::{log, serde_json, AccountId};
use std::fmt;

pub const STANDARD: &str = "nep297";
pub const VERSION: &str = "1.0.0";
pub const EVENT_JSON_STR: &str = "EVENT_JSON:";

#[derive(Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub enum Actions {
    Deposit { token: AccountId },
}

impl fmt::Display for Actions {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
#[allow(dead_code)]
pub enum Event {
    CreateOrderEvent {
        order_id: u64,
        order_type: OrderType,
        lpt_id: String,
        sell_token_price: Price,
        buy_token_price: Price,
        pool_id: String,
    },
    CreateTakeProfitOrderEvent {
        order_id: U128,
        order_type: OrderType,
        lpt_id: String,
        close_price: U128,
        parent_order_type: OrderType,
        pool_id: String,
    },
    UpdateTakeProfitOrderEvent {
        order_id: U128,
        parent_order_type: OrderType,
        order_type: OrderType,
        order_status: OrderStatus,
        lpt_id: String,
        close_price: U128,
        sell_token: String,
        buy_token: String,
        sell_token_price: U128,
        buy_token_price: U128,
        pool_id: String,
    },
    CancelTakeProfitOrderEvent {
        order_id: U128,
    },
    CancelLimitOrderEvent {
        order_id: U128,
    },
    CancelLeverageOrderEvent {
        order_id: U128,
    },
    CloseLeveragePositionEvent {
        order_id: U128,
    },
    ExecuteOrderEvent {
        order_id: U128,
        order_type: OrderType,
    },
    RepayEvent {
        token_borrow: AccountId,
        token_market: AccountId,
        repay_amount: U128,
    },
    WithdrawEvent {
        token: AccountId,
        amount: U128,
    },
}

impl Event {
    #[allow(dead_code)]
    pub fn emit(&self) {
        emit_event(&self);
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventMessage {
    pub standard: String,
    pub version: String,
    pub event: serde_json::Value,
    pub data: serde_json::Value,
}

#[allow(dead_code)]
pub(crate) fn emit_event<T: ?Sized + Serialize>(data: &T) {
    let result = json!(data);
    let event_json = json!(EventMessage {
        standard: STANDARD.to_string(),
        version: VERSION.to_string(),
        event: result["event"].clone(),
        data: result["data"].clone()
    })
    .to_string();
    log!(format!("{EVENT_JSON_STR}{event_json}"));
}

'''
'''--- contracts/leverage_trading/src/config.rs ---
use crate::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The account ID of the contract owner that allows to modify config
    pub owner_id: AccountId,

    /// The account ID of the controller contract
    pub oracle_account_id: AccountId,
}

impl Contract {
    pub fn get_contract_config(&self) -> Config {
        self.config.clone()
    }
}

'''
'''--- contracts/leverage_trading/src/create_order.rs ---
use crate::big_decimal::{BigDecimal, WBalance};
use crate::common::Event;
use crate::ref_finance::ext_ref_finance;
use crate::utils::{ext_market, ext_token, MILLISECONDS_PER_DAY, NO_DEPOSIT};
use crate::*;

use near_sdk::env::{block_height, block_timestamp_ms, current_account_id, signer_account_id};
use near_sdk::{ext_contract, is_promise_success, serde_json, Gas, Promise, PromiseResult};

const GAS_FOR_BORROW: Gas = Gas(200_000_000_000_000);

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn borrow_callback(&mut self, borrow_amount: U128) -> PromiseOrValue<WBalance>;
    fn add_liquidity_callback(&mut self, order: Order, amount: U128) -> PromiseOrValue<Balance>;
    fn take_profit_liquidity_callback(
        &mut self,
        order_id: U128,
        amount: U128,
        parent_order: Order,
        reward_executor: bool,
    );
    fn withdraw_asset_callback(token_id: AccountId, amount: U128);
}

#[near_bindgen]
impl Contract {
    /// Creates an order with given order_type, left_point, right_point, amount, sell_token, buy_token & leverage.
    ///
    /// As far as we surpassed gas limit for contract call,
    /// borrow call was separated & made within batch of transaction alongside with Deposit & Add_Liquidity function
    ///
    /// Accepts deposit only two times greater than gas for execution in order to cover the execution gas fees and reward an executor
    #[payable]
    pub fn create_order(
        &mut self,
        order_type: OrderType,
        // left point for add_liquidity acquired via getPointByPrice
        left_point: i32,
        // right point for add_liquidity acquired via getPointByPrice
        right_point: i32,
        amount: WBalance,
        sell_token: AccountId,
        buy_token: AccountId,
        leverage: U128,
        entry_price: U128,
    ) -> PromiseOrValue<WBalance> {
        require!(
            env::attached_deposit() >= self.view_gas_for_execution() * 2,
            "Create order should accept deposits two times greater than gas for execution"
        );

        let user = env::signer_account_id();
        require!(
            amount.0 <= self.max_order_amount,
            "Amount more than allowed value"
        );

        if order_type == OrderType::Sell {
            require!(
                self.balance_of(user, buy_token.clone()) >= amount,
                "User doesn't have enough deposit to proceed this action"
            )
        } else {
            require!(
                self.balance_of(user, sell_token.clone()) >= amount,
                "User doesn't have enough deposit to proceed this action"
            )
        }

        let sell_token_price = self.view_price(sell_token.clone());
        require!(
            BigDecimal::from(sell_token_price.value) != BigDecimal::zero(),
            "Sell token price cannot be zero"
        );

        let buy_token_price = self.view_price(buy_token.clone());
        require!(
            BigDecimal::from(buy_token_price.value) != BigDecimal::zero(),
            "Buy token price cannot be zero"
        );

        match order_type {
            OrderType::Buy | OrderType::Sell => self.create_limit_order(
                order_type,
                left_point,
                right_point,
                amount,
                sell_token,
                sell_token_price,
                buy_token,
                buy_token_price,
                entry_price,
            ),
            OrderType::Long | OrderType::Short => self.create_leverage_order(
                order_type,
                left_point,
                right_point,
                amount,
                sell_token,
                sell_token_price,
                buy_token,
                buy_token_price,
                leverage,
                entry_price,
            ),
            OrderType::TakeProfit => panic!(
                "Incorrect type of order 'TP'. Expected one of 'Buy', 'Sell', 'Long', 'Short'"
            ),
        }
    }

    /// Makes batch of transaction consist of Deposit & Add_Liquidity
    fn add_liquidity(
        &mut self,
        order: Order,
        token_id: AccountId,
        amount: U128,
        left_point: i32,
        right_point: i32,
        amount_x: U128,
        amount_y: U128,
    ) -> PromiseOrValue<WBalance> {
        let min_amount_x = U128::from(0);
        let min_amount_y = U128::from(0);

        ext_token::ext(token_id)
            .with_static_gas(Gas::ONE_TERA * 35u64)
            .with_attached_deposit(near_sdk::ONE_YOCTO)
            .ft_transfer_call(
                self.ref_finance_account.clone(),
                amount,
                None,
                "\"Deposit\"".to_string(),
            )
            .then(
                ext_ref_finance::ext(self.ref_finance_account.clone())
                    .with_static_gas(Gas::ONE_TERA * 15_u64)
                    .add_liquidity(
                        self.get_trade_pair(&order.sell_token, &order.buy_token)
                            .pool_id,
                        left_point,
                        right_point,
                        amount_x,
                        amount_y,
                        min_amount_x,
                        min_amount_y,
                    ),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 2u64)
                    .with_attached_deposit(NO_DEPOSIT)
                    .add_liquidity_callback(order.clone(), amount),
            )
            .into()
    }

    #[private]
    pub fn add_liquidity_callback(
        &mut self,
        order: Order,
        amount: U128,
    ) -> PromiseOrValue<WBalance> {
        match env::promise_result(0) {
            PromiseResult::Successful(result) => {
                let lpt_id = serde_json::from_slice::<String>(&result).unwrap();

                if order.order_type == OrderType::Sell {
                    self.decrease_balance(
                        &env::signer_account_id(),
                        &order.buy_token,
                        order.amount,
                    );
                } else {
                    self.decrease_balance(
                        &env::signer_account_id(),
                        &order.sell_token,
                        order.amount,
                    );
                }

                let mut order = order;
                order.lpt_id = lpt_id.clone();

                self.order_nonce += 1;
                let order_id = self.order_nonce;

                self.add_or_update_order(&env::signer_account_id(), order.clone(), order_id);

                Event::CreateOrderEvent {
                    order_id,
                    order_type: order.order_type.clone(),
                    lpt_id,
                    sell_token_price: order.sell_token_price,
                    buy_token_price: order.buy_token_price,
                    pool_id: self
                        .get_trade_pair(&order.sell_token, &order.buy_token)
                        .pool_id,
                }
                .emit();

                let order_id = U128::from(order_id as u128);

                self.pending_orders_data.push_back(PendingOrderData {
                    order_id,
                    order_type: order.order_type,
                });

                PromiseOrValue::Value(order_id)
            }
            _ => {
                let token_id =
                    if order.order_type == OrderType::Buy || order.order_type == OrderType::Long {
                        order.sell_token
                    } else {
                        order.buy_token
                    };

                near_sdk::log!("No liquidity was added. We return deposits from DEX");

                ext_ref_finance::ext(self.ref_finance_account.clone())
                    .with_static_gas(Gas::ONE_TERA * 45_u64)
                    .with_attached_deposit(NO_DEPOSIT)
                    .withdraw_asset(token_id.clone(), amount)
                    .then(
                        ext_self::ext(current_account_id())
                            .with_static_gas(Gas::ONE_TERA * 2u64)
                            .with_attached_deposit(NO_DEPOSIT)
                            .withdraw_asset_callback(token_id, amount),
                    )
                    .into()
            }
        }
    }

    #[private]
    pub fn withdraw_asset_callback(token_id: AccountId, amount: U128) {
        if is_promise_success() {
            panic!(
                "Failed to add liquidity. The token '{token_id}' in the amount of '{amount}', was returned from the deposit DEX to the protocol balance", amount = amount.0)
        } else {
            panic!(
                "Failed to add liquidity and returned from the deposit DEX to the protocol balance"
            )
        };
    }
    /// Borrow step made within batch of transaction
    /// Doesn't borrow when leverage is less or equal to 1.0
    pub fn borrow(
        &mut self,
        order_type: OrderType,
        sell_token: AccountId,
        buy_token: AccountId,
        amount: U128,
        leverage: U128,
        open_price: U128,
    ) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_BORROW,
            "Prepaid gas is not enough for borrow flow"
        );

        require!(
            self.balance_of(env::signer_account_id(), sell_token.clone()) >= amount,
            "Failed to borrow. User doesn't have enough deposit to proceed this action"
        );

        require!(
            BigDecimal::from(leverage) > BigDecimal::one(),
            "Failed to borrow. Incorrect leverage amount. The leverage should be greater than one"
        );

        let (token_market, borrow_amount) = match order_type {
            OrderType::Long => {
                let borrow_amount = U128::from(
                    BigDecimal::from(amount) * (BigDecimal::from(leverage) - BigDecimal::one()),
                );

                let token_market = self.get_market_by(&sell_token);
                (token_market, borrow_amount)
            }
            OrderType::Short => {
                let borrow_amount = U128::from(
                    BigDecimal::from(amount) * (BigDecimal::from(leverage) - BigDecimal::one())
                        / BigDecimal::from(open_price),
                );

                let token_market = self.get_market_by(&buy_token);
                (token_market, borrow_amount)
            }
            _ => panic!("Borrow amount calculation only for the 'Long' and 'Short' order types"),
        };

        ext_market::ext(token_market)
            .with_static_gas(GAS_FOR_BORROW)
            .borrow(borrow_amount)
            .then(
                ext_self::ext(env::current_account_id())
                    .with_unused_gas_weight(100)
                    .borrow_callback(borrow_amount),
            )
            .into()
    }

    #[private]
    pub fn borrow_callback(&mut self, borrow_amount: U128) -> PromiseOrValue<WBalance> {
        require!(is_promise_success(), "Contract failed to borrow assets");
        PromiseOrValue::Value(borrow_amount)
    }
    #[private]
    pub fn add_order_from_string(&mut self, account_id: AccountId, order: String) {
        self.order_nonce += 1;
        let order_id = self.order_nonce;
        let order: Order = serde_json::from_str(order.as_str()).unwrap();
        self.add_or_update_order(&account_id, order, order_id);
    }

    #[payable]
    pub fn create_take_profit_order(
        &mut self,
        order_id: U128,
        close_price: U128,
        left_point: i32,
        right_point: i32,
        market_data: MarketData,
    ) -> PromiseOrValue<bool> {
        require!(
            Some(signer_account_id()) == self.get_account_by(order_id.0),
            "You do not have permission for this action."
        );

        let parent_order = self.get_order_by(order_id.0).unwrap();
        require!(
            parent_order.order_type == OrderType::Long
                || parent_order.order_type == OrderType::Short,
            "Invalid parent order type."
        );

        let sell_token_price = self.view_price(parent_order.sell_token.clone());
        require!(
            BigDecimal::from(sell_token_price.value) != BigDecimal::zero(),
            "Sell token price cannot be zero"
        );

        let buy_token_price = self.view_price(parent_order.buy_token.clone());
        require!(
            BigDecimal::from(buy_token_price.value) != BigDecimal::zero(),
            "Buy token price cannot be zero"
        );

        let price_points = (left_point, right_point);
        match parent_order.status {
            OrderStatus::Pending => self.create_take_profit_order_when_parent_pending(
                order_id,
                price_points,
                parent_order,
                close_price,
                sell_token_price,
                buy_token_price,
                market_data,
            ),
            OrderStatus::Executed => self.create_take_profit_order_when_parent_executed(
                order_id,
                price_points,
                parent_order,
                close_price,
                sell_token_price,
                buy_token_price,
                market_data,
            ),
            _ => {
                panic!("Take profit order can't be created at the current moment.");
            }
        }
    }

    #[private]
    pub fn take_profit_liquidity_callback(
        &mut self,
        order_id: U128,
        amount: U128,
        parent_order: Order,
        reward_executor: bool,
    ) {
        require!(is_promise_success(), "Some problems with liquidity adding.");

        match env::promise_result(0) {
            PromiseResult::Successful(result) => {
                let lpt_id = serde_json::from_slice::<String>(&result).unwrap();
                if let Some(current_tpo) = self.take_profit_orders.get(&(order_id.0 as u64)) {
                    let mut order = current_tpo.1;
                    order.lpt_id = lpt_id.clone();
                    order.status = OrderStatus::Pending;

                    let return_amounts = ReturnAmounts {
                        amount_buy_token: U128(0_u128),
                        amount_sell_token: U128(0_u128),
                    };

                    self.take_profit_orders.insert(
                        &(order_id.0 as u64),
                        &(current_tpo.0, order.clone(), return_amounts),
                    );

                    Event::UpdateTakeProfitOrderEvent {
                        order_id,
                        parent_order_type: parent_order.order_type,
                        order_type: order.order_type.clone(),
                        order_status: order.status,
                        lpt_id,
                        close_price: WRatio::from(order.open_or_close_price),
                        sell_token: order.sell_token.to_string(),
                        buy_token: order.sell_token.to_string(),
                        sell_token_price: order.sell_token_price.value,
                        buy_token_price: order.buy_token_price.value,
                        pool_id: self
                            .get_trade_pair(&order.sell_token, &order.buy_token)
                            .pool_id,
                    }
                    .emit();

                    self.pending_orders_data.push_back(PendingOrderData {
                        order_id,
                        order_type: order.order_type,
                    });
                }

                if reward_executor {
                    let executor_reward_in_near = env::used_gas().0 as Balance * 2_u128;
                    Promise::new(env::signer_account_id()).transfer(executor_reward_in_near);
                }
            }
            _ => {
                let order = self.get_order_by(order_id.0).unwrap();
                let token_id = if order.order_type == OrderType::Long {
                    order.buy_token
                } else {
                    order.sell_token
                };

                near_sdk::log!("No liquidity was added. We return deposits from DEX");

                ext_ref_finance::ext(self.ref_finance_account.clone())
                    .with_static_gas(Gas::ONE_TERA * 45_u64)
                    .with_attached_deposit(NO_DEPOSIT)
                    .withdraw_asset(token_id.clone(), amount)
                    .then(
                        ext_self::ext(current_account_id())
                            .with_static_gas(Gas::ONE_TERA * 2u64)
                            .with_attached_deposit(NO_DEPOSIT)
                            .withdraw_asset_callback(token_id, amount),
                    );
            }
        };
    }
}

impl Contract {
    pub fn create_limit_order(
        &mut self,
        order_type: OrderType,
        // left point for add_liquidity acquired via getPointByPrice
        left_point: i32,
        // right point for add_liquidity acquired via getPointByPrice
        right_point: i32,
        amount: WBalance,
        sell_token: AccountId,
        sell_token_price: Price,
        buy_token: AccountId,
        buy_token_price: Price,
        buy_or_sell_price: U128,
    ) -> PromiseOrValue<WBalance> {
        let order = Order {
            status: OrderStatus::Pending,
            order_type,
            amount: Balance::from(amount),
            sell_token,
            buy_token,
            leverage: BigDecimal::one(),
            sell_token_price,
            buy_token_price,
            open_or_close_price: BigDecimal::from(buy_or_sell_price),
            block: env::block_height(),
            timestamp_ms: env::block_timestamp_ms(),
            lpt_id: "".to_string(),
            history_data: Default::default(),
        };
        // calculating the range for the liquidity to be added into
        // consider the smallest gap is point_delta for given pool
        let (amount_x, amount_y, token_to_add_liquidity) = if order.order_type == OrderType::Buy {
            let (sell_token_decimals, _) =
                self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);

            let amount_x = self.from_protocol_to_token_decimals(amount, sell_token_decimals);
            // (amount_x, amount_y, token_id)
            (amount_x, U128::from(0), order.sell_token.clone())
        } else {
            let (_, buy_token_decimals) =
                self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);

            let amount_y = self.from_protocol_to_token_decimals(amount, buy_token_decimals);
            // (amount_x, amount_y, token_id)
            (U128::from(0), amount_y, order.buy_token.clone())
        };

        self.add_liquidity(
            order,
            token_to_add_liquidity,
            amount,
            left_point,
            right_point,
            amount_x,
            amount_y,
        )
    }

    pub fn create_leverage_order(
        &mut self,
        order_type: OrderType,
        // left point for add_liquidity acquired via getPointByPrice
        left_point: i32,
        // right point for add_liquidity acquired via getPointByPrice
        right_point: i32,
        amount: WBalance,
        sell_token: AccountId,
        sell_token_price: Price,
        buy_token: AccountId,
        buy_token_price: Price,
        leverage: U128,
        open_price: U128,
    ) -> PromiseOrValue<WBalance> {
        require!(
            BigDecimal::from(leverage) > BigDecimal::one(),
            "Incorrect leverage for order type 'Long' and 'Short'"
        );

        let order = Order {
            status: OrderStatus::Pending,
            order_type,
            amount: Balance::from(amount),
            sell_token,
            buy_token,
            leverage: BigDecimal::from(leverage),
            sell_token_price,
            buy_token_price,
            open_or_close_price: BigDecimal::from(open_price),
            block: env::block_height(),
            timestamp_ms: env::block_timestamp_ms(),
            lpt_id: "".to_string(),
            history_data: Default::default(),
        };
        // calculating the range for the liquidity to be added into
        // consider the smallest gap is point_delta for given pool
        let (deposit_amount, amount_x, amount_y, token_to_add_liquidity) = if order.order_type
            == OrderType::Long
        {
            let total_amount =
                U128::from(BigDecimal::from(U128::from(order.amount)) * order.leverage);

            let (sell_token_decimals, _) =
                self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);

            let amount_x = self.from_protocol_to_token_decimals(total_amount, sell_token_decimals);
            // (deposit_amount, amount_x, amount_y, token_id)
            (amount_x, amount_x, U128::from(0), order.sell_token.clone())
        } else {
            let total_amount = U128::from(
                BigDecimal::from(U128::from(order.amount)) * (order.leverage - BigDecimal::one())
                    / order.open_or_close_price,
            );

            let (_, buy_token_decimals) =
                self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);

            let amount_y = self.from_protocol_to_token_decimals(total_amount, buy_token_decimals);
            // (deposit_amount, amount_x, amount_y, token_id)
            (amount_y, U128::from(0), amount_y, order.buy_token.clone())
        };

        self.add_liquidity(
            order,
            token_to_add_liquidity,
            deposit_amount,
            left_point,
            right_point,
            amount_x,
            amount_y,
        )
    }

    pub fn add_or_update_order(&mut self, account_id: &AccountId, order: Order, order_id: u64) {
        let pair_id = PairId {
            sell_token: order.sell_token.clone(),
            buy_token: order.buy_token.clone(),
        };

        let mut user_orders_by_id = self.orders.get(account_id).unwrap_or_default();
        user_orders_by_id.insert(order_id, order.clone());
        self.orders.insert(account_id, &user_orders_by_id);

        let mut pair_orders_by_id = self.orders_per_pair_view.get(&pair_id).unwrap_or_default();
        pair_orders_by_id.insert(order_id, order);
        self.orders_per_pair_view
            .insert(&pair_id, &pair_orders_by_id);
    }

    pub fn create_take_profit_order_when_parent_pending(
        &mut self,
        order_id: U128,
        price_points: PricePoints,
        parent_order: Order,
        price: U128,
        sell_token_price: Price,
        buy_token_price: Price,
        market_data: MarketData,
    ) -> PromiseOrValue<bool> {
        let take_profit_order_amount = if parent_order.order_type == OrderType::Long {
            // full amount (buy token) open 'long' position
            U128::from(
                BigDecimal::from(U128::from(parent_order.amount)) * parent_order.leverage
                    / parent_order.open_or_close_price,
            )
        } else {
            // part amount (sell token) open "short" position
            let borrow_amount = BigDecimal::from(U128::from(parent_order.amount))
                * (parent_order.leverage - BigDecimal::one())
                / parent_order.open_or_close_price;

            let borrow_fee_amount =
                BigDecimal::from(self.get_borrow_fee_amount(parent_order.clone(), market_data));

            U128::from((borrow_amount + borrow_fee_amount) * BigDecimal::from(price))
        };

        let order = Order {
            status: OrderStatus::PendingOrderExecute,
            order_type: OrderType::TakeProfit,
            amount: take_profit_order_amount.0,
            sell_token: parent_order.sell_token.clone(),
            buy_token: parent_order.buy_token.clone(),
            leverage: BigDecimal::one(),
            sell_token_price,
            buy_token_price,
            open_or_close_price: BigDecimal::from(price),
            block: block_height(),
            timestamp_ms: block_timestamp_ms(),
            lpt_id: "".to_string(),
            history_data: Default::default(),
        };

        let return_amounts = ReturnAmounts {
            amount_buy_token: U128(0_u128),
            amount_sell_token: U128(0_u128),
        };

        self.take_profit_orders
            .insert(&(order_id.0 as u64), &(price_points, order, return_amounts));

        Event::CreateTakeProfitOrderEvent {
            order_id,
            order_type: OrderType::TakeProfit,
            lpt_id: "".to_string(),
            close_price: price,
            parent_order_type: parent_order.order_type,
            pool_id: self
                .get_trade_pair(&parent_order.sell_token, &parent_order.buy_token)
                .pool_id,
        }
        .emit();
        PromiseOrValue::Value(true)
    }

    pub fn create_take_profit_order_when_parent_executed(
        &mut self,
        order_id: U128,
        price_points: PricePoints,
        parent_order: Order,
        price: U128,
        sell_token_price: Price,
        buy_token_price: Price,
        market_data: MarketData,
    ) -> PromiseOrValue<bool> {
        if self.take_profit_orders.get(&(order_id.0 as u64)).is_some() {
            panic!(
                "The 'Take Profit' order has already been created. You cannot modify an existing 'Take Profit' order if the position is already open"
            )
        } else {
            let pv = self.create_take_profit_order_when_parent_pending(
                order_id,
                price_points,
                parent_order.clone(),
                price,
                sell_token_price,
                buy_token_price,
                market_data,
            );
            let tpo_info = self.take_profit_orders.get(&(order_id.0 as u64)).unwrap();
            self.set_take_profit_order_pending(order_id, parent_order, tpo_info, false);
            pv
        }
    }

    pub fn set_take_profit_order_pending(
        &mut self,
        order_id: U128,
        parent_order: Order,
        take_profit_order: (PricePoints, Order, ReturnAmounts),
        reward_executor: bool,
    ) {
        // if the 'Take Profit' order is created when the parental order has not yet been executed
        // and if the parent order type is 'Short' we are updating the amount in 'Take Profit' order
        let order = if reward_executor && parent_order.order_type == OrderType::Short {
            let current_timestamp_ms = env::block_timestamp_ms();

            let borrow_amount = BigDecimal::from(U128::from(parent_order.amount))
                * (parent_order.leverage - BigDecimal::one())
                / parent_order.open_or_close_price;

            let previous_borrow_fee_amount = BigDecimal::from(U128(take_profit_order.1.amount))
                / take_profit_order.1.open_or_close_price
                - borrow_amount;

            let previous_borrow_period = ((take_profit_order.1.timestamp_ms
                - parent_order.timestamp_ms) as f64
                / MILLISECONDS_PER_DAY as f64)
                .ceil();

            let current_borrow_period = ((current_timestamp_ms - parent_order.timestamp_ms) as f64
                / MILLISECONDS_PER_DAY as f64)
                .ceil();

            let current_borrow_fee_amount = previous_borrow_fee_amount
                / BigDecimal::from(U128(previous_borrow_period as u128))
                * BigDecimal::from(U128(current_borrow_period as u128));

            Order {
                amount: U128::from(
                    (borrow_amount + current_borrow_fee_amount)
                        * take_profit_order.1.open_or_close_price,
                )
                .0,
                ..take_profit_order.1
            }
        } else {
            take_profit_order.1
        };

        let (amount_x, amount_y, token_to_add_liquidity) =
            if parent_order.order_type == OrderType::Long {
                let (_, buy_token_decimals) =
                    self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);

                let amount_y =
                    self.from_protocol_to_token_decimals(U128(order.amount), buy_token_decimals);
                // (amount_x, amount_y, token_id)
                (U128::from(0), amount_y, order.buy_token.clone())
            } else {
                let (sell_token_decimals, _) =
                    self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);

                let amount_x =
                    self.from_protocol_to_token_decimals(U128(order.amount), sell_token_decimals);
                // (amount_x, amount_y, token_id)
                (amount_x, U128::from(0), order.sell_token.clone())
            };

        let min_amount_x = U128::from(0);
        let min_amount_y = U128::from(0);

        ext_token::ext(token_to_add_liquidity)
            .with_static_gas(Gas::ONE_TERA * 35u64)
            .with_attached_deposit(near_sdk::ONE_YOCTO)
            .ft_transfer_call(
                self.ref_finance_account.clone(),
                U128(order.amount),
                None,
                "\"Deposit\"".to_string(),
            )
            .then(
                ext_ref_finance::ext(self.ref_finance_account.clone())
                    .with_static_gas(Gas::ONE_TERA * 50_u64)
                    .with_unused_gas_weight(2_u64)
                    .add_liquidity(
                        self.get_trade_pair(&order.sell_token, &order.buy_token)
                            .pool_id,
                        take_profit_order.0 .0,
                        take_profit_order.0 .1,
                        amount_x,
                        amount_y,
                        min_amount_x,
                        min_amount_y,
                    ),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 50_u64)
                    .take_profit_liquidity_callback(
                        order_id,
                        U128(order.amount),
                        parent_order,
                        reward_executor,
                    ),
            );
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::test_utils::test_env::alice;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool, block_timestamp: Option<u64>) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(103930916)
            .block_timestamp(block_timestamp.unwrap_or(1))
            .is_view(is_view)
            .build()
    }
    // lend land
    fn get_current_day_in_nanoseconds(day: u64) -> Option<u64> {
        let nanoseconds_in_one_millisecond = 1_000_000;
        Some(MILLISECONDS_PER_DAY * day * nanoseconds_in_one_millisecond)
    }

    fn get_market_data() -> MarketData {
        MarketData {
            underlying_token: AccountId::new_unchecked("usdt.qa.v1.nearlend.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        }
    }

    impl Contract {
        pub fn imitation_add_liquidity_callback(&mut self, order: Order) {
            self.decrease_balance(&env::signer_account_id(), &order.sell_token, order.amount);

            let mut lpt_id = order.sell_token.to_string();
            lpt_id.push('|');
            lpt_id.push_str(order.buy_token.as_str());
            lpt_id.push_str("|0000#0000");

            let mut order = order;
            order.lpt_id = lpt_id;

            self.order_nonce += 1;

            let order_id = self.order_nonce;

            self.add_or_update_order(&env::signer_account_id(), order, order_id);
        }
    }

    #[test]
    fn test_add_order_in_create_order() {
        let context = get_context(false, None);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_id = PairId {
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        contract.set_balance(&alice(), &pair_id.sell_token, 10_u128.pow(30));

        assert_eq!(
            contract.orders.get(&alice()).unwrap_or_default().len(),
            0_usize
        );
        assert_eq!(
            contract
                .orders_per_pair_view
                .get(&pair_id)
                .unwrap_or_default()
                .len(),
            0_usize
        );

        for _ in 0..5 {
            let order = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930910, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#540\",\"history_data\":null}".to_string();
            contract.imitation_add_liquidity_callback(
                near_sdk::serde_json::from_str(order.as_str()).unwrap(),
            );
        }

        assert_eq!(
            contract.orders.get(&alice()).unwrap_or_default().len(),
            5_usize
        );
        assert_eq!(
            contract
                .orders_per_pair_view
                .get(&pair_id)
                .unwrap_or_default()
                .len(),
            5_usize
        );
    }

    #[test]
    fn test_create_take_profit_order() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let market_data = get_market_data();

        let pair_data = TradePair {
            sell_ticker_id: "usdt".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "wnear".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 18,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDt".to_string(),
                value: U128(10_u128.pow(24)), // current price token
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "near".to_string(),
                value: U128(3 * 10_u128.pow(24)), // current price token
            },
        );

        let order_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2500000000000000000000000\",\"block\":103930910, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#540\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_string);

        let new_price = U128(24500000000000000000000000);
        let left_point = -9860;
        let right_point = -9820;
        contract.create_take_profit_order(U128(1), new_price, left_point, right_point, market_data);

        let tpo = contract.take_profit_orders.get(&1).unwrap();
        assert_eq!(tpo.1.status, OrderStatus::PendingOrderExecute);
        assert_eq!(WBigDecimal::from(tpo.1.open_or_close_price), new_price);
    }

    #[test]
    #[should_panic(expected = "You do not have permission for this action")]
    fn test_create_take_profit_order_without_order() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let market_data = get_market_data();

        let order_id: u128 = 33;
        assert_eq!(contract.get_order_by(order_id), None);

        let new_price = U128(30500000000000000000000000);
        let left_point = -9860;
        let right_point = -9820;
        contract.create_take_profit_order(
            U128(order_id),
            new_price,
            left_point,
            right_point,
            market_data,
        );
    }

    #[test]
    fn test_update_take_profit_order_price_when_parent_pending() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let market_data = get_market_data();

        let pair_data = TradePair {
            sell_ticker_id: "usdt".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "wnear".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 18,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDt".to_string(),
                value: U128(10_u128.pow(24)), // current price token
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "near".to_string(),
                value: U128(3 * 10_u128.pow(24)), // current price token
            },
        );

        let order_string = "{\"status\":\"Pending\",\"order_type\":\"Short\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2500000000000000000000000\",\"block\":103930910, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#540\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_string);

        let order_id: u128 = 1;
        let new_price = U128(2450000000000000000000000);
        let left_point = -9860;
        let right_point = -9820;
        contract.create_take_profit_order(
            U128(order_id),
            new_price,
            left_point,
            right_point,
            market_data.clone(),
        );

        let tpo = contract.take_profit_orders.get(&(order_id as u64)).unwrap();
        assert_eq!(tpo.1.status, OrderStatus::PendingOrderExecute);
        assert_eq!(WBigDecimal::from(tpo.1.open_or_close_price), new_price);

        let new_price = U128(2350000000000000000000000);
        let left_point = -8040;
        let right_point = -8000;

        contract.create_take_profit_order(
            U128(order_id),
            new_price,
            left_point,
            right_point,
            market_data,
        );

        let tpo = contract.take_profit_orders.get(&(order_id as u64)).unwrap();
        assert_eq!(WBigDecimal::from(tpo.1.open_or_close_price), new_price);
        assert_eq!(tpo.0 .0, left_point);
        assert_eq!(tpo.0 .1, right_point);
    }

    #[test]
    #[should_panic(
        expected = "The 'Take Profit' order has already been created. You cannot modify an existing 'Take Profit' order if the position is already open"
    )]
    fn test_update_take_profit_order_price_when_parent_executed() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let market_data = get_market_data();

        let pair_data = TradePair {
            sell_ticker_id: "usdt".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "wnear".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 18,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDt".to_string(),
                value: U128(10_u128.pow(24)), // current price token
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "near".to_string(),
                value: U128(3 * 10_u128.pow(24)), // current price token
            },
        );

        let order_string = "{\"status\":\"Executed\",\"order_type\":\"Short\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2500000000000000000000000\",\"block\":103930910, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#540\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_string);

        let order_id: u128 = 1;
        let new_price = U128(2450000000000000000000000);
        let left_point = -9860;
        let right_point = -9820;

        contract.create_take_profit_order(
            U128(order_id),
            new_price,
            left_point,
            right_point,
            market_data.clone(),
        );

        let (price_points, mut tp_order, return_amounts) =
            contract.take_profit_orders.get(&(order_id as u64)).unwrap();

        tp_order.status = OrderStatus::Pending;

        contract.take_profit_orders.insert(
            &(order_id as u64),
            &(price_points, tp_order, return_amounts),
        );

        let (_, tp_order, _) = contract.take_profit_orders.get(&(order_id as u64)).unwrap();

        assert_eq!(tp_order.status, OrderStatus::Pending);

        let new_price = U128(2350000000000000000000000);
        let left_point = -8040;
        let right_point = -8000;

        contract.create_take_profit_order(
            U128(order_id),
            new_price,
            left_point,
            right_point,
            market_data,
        );
    }
}

'''
'''--- contracts/leverage_trading/src/deposit.rs ---
use crate::big_decimal::WBalance;
use crate::*;
use near_sdk::{Gas, PromiseOrValue};

const GAS_FOR_DEPOSIT: Gas = Gas(2_000_000_000_000);

impl Contract {
    /// Accepts tokens.
    /// Updates user balance
    pub fn deposit(
        &mut self,
        token_amount: WBalance,
        token: AccountId,
    ) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_DEPOSIT,
            "Prepaid gas is not enough for deposit flow"
        );

        let is_token_supported = self
            .supported_markets
            .keys()
            .any(|pair| pair.sell_token == token || pair.buy_token == token);

        require!(
            is_token_supported,
            "Deposit was done by token, that are not currently supported"
        );

        let token_decimals = self.view_token_decimals(&token);
        let token_amount = self.from_token_to_protocol_decimals(token_amount.0, token_decimals);

        self.increase_balance(&env::signer_account_id(), &token, token_amount.0);

        PromiseOrValue::Value(U128(0))
    }

    pub fn increase_balance(
        &mut self,
        account_id: &AccountId,
        token: &AccountId,
        token_amount: Balance,
    ) {
        let increased_balance = self.balance_of(account_id.clone(), token.clone()).0 + token_amount;
        self.set_balance(account_id, token, increased_balance)
    }

    pub fn decrease_balance(
        &mut self,
        account_id: &AccountId,
        token: &AccountId,
        token_amount: Balance,
    ) {
        require!(
            self.balance_of(account_id.clone(), token.clone()) >= U128(token_amount),
            "Decreased balance must be greater than 0"
        );
        self.set_balance(
            &account_id.clone(),
            &token.clone(),
            self.balance_of(account_id.clone(), token.clone()).0 - token_amount,
        )
    }

    pub fn set_balance(
        &mut self,
        account_id: &AccountId,
        token: &AccountId,
        token_amount: Balance,
    ) {
        let mut user_balance_by_token = self.balances.get(account_id).unwrap_or_default();
        user_balance_by_token.insert(token.clone(), token_amount);
        self.balances.insert(account_id, &user_balance_by_token);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    pub const INITIAL_BALANCE: Balance = 10_000;
    pub const AMOUNT_TO_INCREASE: Balance = 20_000;
    pub const AMOUNT_TO_DECREASE: Balance = 5_000;

    pub fn get_contract() -> (Contract, AccountId, AccountId) {
        let owner_id: AccountId = "contract.testnet".parse().unwrap();
        let oracle_account_id: AccountId = "oracle.testnet".parse().unwrap();

        let mut contract = Contract::new_with_config(owner_id, oracle_account_id);

        let user: AccountId = AccountId::from_str("some_example_user.testnet").unwrap();
        let token: AccountId = AccountId::from_str("some_example_token.testnet").unwrap();

        contract.set_balance(&user, &token, INITIAL_BALANCE);

        assert_eq!(
            contract.balance_of(user.clone(), token.clone()),
            WBalance::from(INITIAL_BALANCE)
        );

        (contract, user, token)
    }

    #[test]
    fn test_successful_increase_decrease_balance() {
        let (mut contract, user, token) = get_contract();

        contract.increase_balance(&user.clone(), &token.clone(), AMOUNT_TO_INCREASE);

        assert_eq!(
            contract.balance_of(user.clone(), token.clone()),
            WBalance::from(AMOUNT_TO_INCREASE + INITIAL_BALANCE)
        );

        contract.decrease_balance(&user, &token, AMOUNT_TO_DECREASE);

        assert_eq!(
            contract.balance_of(user.clone(), token.clone()),
            WBalance::from(AMOUNT_TO_INCREASE + INITIAL_BALANCE - AMOUNT_TO_DECREASE)
        );
    }

    #[test]
    #[should_panic]
    fn test_fail_decrease_balance() {
        let (mut contract, user, token) = get_contract();

        assert_eq!(
            contract.balance_of(user.clone(), token.clone()),
            WBalance::from(INITIAL_BALANCE)
        );

        contract.decrease_balance(&user, &token, 10000 * AMOUNT_TO_DECREASE);
    }
}

'''
'''--- contracts/leverage_trading/src/execute_order.rs ---
use crate::common::Event;
use crate::ref_finance::{ext_ref_finance, Action, LiquidityInfo, Swap};
use crate::utils::ext_token;
use crate::*;
use near_sdk::env::current_account_id;
use near_sdk::{ext_contract, is_promise_success, log, Gas, Promise, PromiseResult};

/// DEX underutilization ratio of the transferred deposit
pub const INACCURACY_RATE: U128 = U128(3300000000000000000000_u128); //0.0033 -> 0.33% -> 33*10^-4

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn remove_liquidity_for_execute_order_callback(&self, order: Order, order_id: U128);
    fn execute_order_callback(&self, order: Order, order_id: U128);
}

#[near_bindgen]
impl Contract {
    /// Executes order by inner order_id set on ref finance once the price range was crossed.
    /// Gets pool info, removes liquidity presented by one asset and marks order as executed.
    pub fn execute_order(&self, order_id: U128) -> PromiseOrValue<U128> {
        let order = self.get_order_by(order_id.0);
        require!(order.is_some(), "There is no such order to be executed");

        let mut order = order.unwrap();

        if order.status == OrderStatus::Executed {
            if let Some((_, tp_order, _)) = self.take_profit_orders.get(&(order_id.0 as u64)) {
                order = tp_order
            } else {
                panic!(
                    "Order 'order_id:{}' already executed and has no created 'Take Profit' order",
                    order_id.0
                )
            }
        }

        require!(
            order.status == OrderStatus::Pending,
            "Error. Order has to be Pending to be executed"
        );

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 5_u64)
            .get_liquidity(order.lpt_id.clone())
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 270_u64)
                    .with_unused_gas_weight(2_u64)
                    .execute_order_callback(order, order_id),
            )
            .into()
    }

    #[private]
    pub fn execute_order_callback(&self, order: Order, order_id: U128) -> PromiseOrValue<U128> {
        require!(is_promise_success(), "Failed to get_liquidity");

        let liquidity_info = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                near_sdk::serde_json::from_slice::<ref_finance::LiquidityInfo>(&val).unwrap()
            }
            PromiseResult::Failed => panic!("Ref finance not found pool"),
        };

        let [amount, min_amount_x, min_amount_y] =
            self.get_amounts_to_execute(order_id, order.clone(), liquidity_info);

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 90_u64)
            .remove_liquidity(order.lpt_id.clone(), amount, min_amount_x, min_amount_y)
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 170_u64)
                    .with_unused_gas_weight(2_u64)
                    .remove_liquidity_for_execute_order_callback(order, order_id),
            )
            .into()
    }

    #[private]
    pub fn remove_liquidity_for_execute_order_callback(&mut self, order: Order, order_id: U128) {
        let return_amounts = self.get_return_amounts_after_remove_liquidity(order.clone());
        let account_id = self.get_account_by(order_id.0).unwrap();

        match order.order_type {
            OrderType::Buy | OrderType::Sell => {
                let (token, amount_increase_balance) = if order.order_type == OrderType::Buy {
                    (
                        order.buy_token.clone(),
                        U128::from(
                            BigDecimal::from(U128(order.amount)) / order.open_or_close_price,
                        ),
                    )
                } else {
                    (
                        order.sell_token.clone(),
                        U128::from(
                            BigDecimal::from(U128(order.amount)) * order.open_or_close_price,
                        ),
                    )
                };

                self.mark_order_as_executed(order.clone(), order_id);

                self.remove_pending_order_data(PendingOrderData {
                    order_id,
                    order_type: order.order_type,
                });

                self.increase_balance(&account_id, &token, amount_increase_balance.0);
                self.withdraw(token, amount_increase_balance, Some(true));
            }
            OrderType::Long | OrderType::Short => {
                self.mark_order_as_executed(order.clone(), order_id);

                self.remove_pending_order_data(PendingOrderData {
                    order_id,
                    order_type: order.order_type.clone(),
                });

                if let Some(tpo) = self.take_profit_orders.get(&(order_id.0 as u64)) {
                    self.set_take_profit_order_pending(order_id, order, tpo, true);
                } else {
                    let executor_reward_in_near = env::used_gas().0 as Balance * 2_u128;
                    Promise::new(env::signer_account_id()).transfer(executor_reward_in_near);
                }
            }
            OrderType::TakeProfit => {
                let parent_order = self.get_order_by(order_id.0).unwrap();
                self.mark_take_profit_order_as_executed(order_id, return_amounts);
                self.close_leverage_position(order_id, parent_order, None, None, true);
            }
        }
    }

    pub fn manual_swap(
        &self,
        pool_id: String,
        sell_token: AccountId,
        buy_token: AccountId,
        buy_token_amount: U128,
    ) {
        let action = Action::SwapAction {
            Swap: Swap {
                pool_ids: vec![pool_id],
                output_token: sell_token,
                min_output_amount: WBalance::from(0),
            },
        };

        log!(
            "Action {}",
            near_sdk::serde_json::to_string(&action).unwrap()
        );

        ext_token::ext(buy_token)
            .with_attached_deposit(1)
            .ft_transfer_call(
                self.ref_finance_account.clone(),
                buy_token_amount,
                Some("Swap".to_string()),
                near_sdk::serde_json::to_string(&action).unwrap(),
            );
    }
}

impl Contract {
    pub fn get_amounts_to_execute(
        &self,
        order_id: U128,
        order: Order,
        liquidity_info: LiquidityInfo,
    ) -> [U128; 3_usize] {
        match order.order_type {
            OrderType::Long => {
                let min_amount_x = U128::from(0);
                let min_amount_y = U128::from(
                    BigDecimal::from(U128::from(order.amount))
                        * order.leverage
                        * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE))
                        / order.open_or_close_price,
                );

                let (_, buy_token_decimals) =
                    self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
                let min_amount_y =
                    self.from_protocol_to_token_decimals(min_amount_y, buy_token_decimals);

                [liquidity_info.amount, min_amount_x, min_amount_y]
            }
            OrderType::Short => {
                let min_amount_x = U128::from(
                    BigDecimal::from(U128::from(order.amount))
                        * (order.leverage - BigDecimal::one())
                        * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
                );
                let min_amount_y = U128::from(0);

                let (sell_token_decimals, _) =
                    self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
                let min_amount_x =
                    self.from_protocol_to_token_decimals(min_amount_x, sell_token_decimals);

                [liquidity_info.amount, min_amount_x, min_amount_y]
            }
            OrderType::Buy => {
                let min_amount_x = U128::from(0);
                let min_amount_y = U128::from(
                    BigDecimal::from(U128::from(order.amount)) / order.open_or_close_price
                        * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
                );

                let (_, buy_token_decimals) =
                    self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
                let min_amount_y =
                    self.from_protocol_to_token_decimals(min_amount_y, buy_token_decimals);

                [liquidity_info.amount, min_amount_x, min_amount_y]
            }

            OrderType::Sell => {
                let min_amount_x = U128::from(
                    BigDecimal::from(U128::from(order.amount))
                        * order.open_or_close_price
                        * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
                );
                let min_amount_y = U128::from(0);

                let (sell_token_decimals, _) =
                    self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
                let min_amount_x =
                    self.from_protocol_to_token_decimals(min_amount_x, sell_token_decimals);

                [liquidity_info.amount, min_amount_x, min_amount_y]
            }
            OrderType::TakeProfit => {
                let parent_order = self.get_order_by(order_id.0).unwrap();
                if parent_order.order_type == OrderType::Long {
                    let min_amount_x = U128::from(
                        BigDecimal::from(U128::from(order.amount))
                            * order.open_or_close_price
                            * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
                    );

                    let min_amount_y = U128::from(0);

                    let (sell_token_decimals, _) =
                        self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
                    let min_amount_x =
                        self.from_protocol_to_token_decimals(min_amount_x, sell_token_decimals);

                    [liquidity_info.amount, min_amount_x, min_amount_y]
                } else {
                    let min_amount_x = U128::from(0);
                    let min_amount_y = U128::from(
                        BigDecimal::from(U128::from(order.amount)) / order.open_or_close_price
                            * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
                    );

                    let (_, buy_token_decimals) =
                        self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
                    let min_amount_y =
                        self.from_protocol_to_token_decimals(min_amount_y, buy_token_decimals);

                    [liquidity_info.amount, min_amount_x, min_amount_y]
                }
            }
        }
    }

    pub fn mark_order_as_executed(&mut self, order: Order, order_id: U128) {
        let mut order = order;
        order.status = OrderStatus::Executed;

        self.add_or_update_order(
            &self.get_account_by(order_id.0).unwrap(), // assert there is always some user
            order.clone(),
            order_id.0 as u64,
        );

        Event::ExecuteOrderEvent {
            order_id,
            order_type: order.order_type,
        }
        .emit();
    }

    pub fn mark_take_profit_order_as_executed(
        &mut self,
        order_id: U128,
        return_amounts: ReturnAmounts,
    ) {
        let tpo = self.take_profit_orders.get(&(order_id.0 as u64)).unwrap();
        let mut order = tpo.1;
        order.status = OrderStatus::Executed;
        self.take_profit_orders.insert(
            &(order_id.0 as u64),
            &(tpo.0, order.clone(), return_amounts),
        );

        Event::ExecuteOrderEvent {
            order_id,
            order_type: order.order_type,
        }
        .emit();
    }

    pub fn get_account_by(&self, order_id: u128) -> Option<AccountId> {
        let mut account: Option<AccountId> = None;

        for (account_id, users_order) in self.orders.iter() {
            if users_order.contains_key(&(order_id as u64)) {
                account = Some(account_id);
                break;
            }
        }
        account
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::test_utils::test_env::alice;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(103930920)
            .block_timestamp(1)
            .is_view(is_view)
            .build()
    }

    #[test]
    fn test_get_account_by() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let order = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1000000000000000000000000\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"4220000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930916, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#543\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order);

        let account_id = contract.orders.get(&alice()).unwrap().contains_key(&1);

        assert!(account_id);
        assert_eq!(contract.get_account_by(1), Some(alice()));
    }

    #[test]
    fn test_order_was_execute() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_id = PairId {
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1000000000000000000000000\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"4220000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930916,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#543\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_as_string.clone());

        let order_id = U128(1);
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();
        contract.mark_order_as_executed(order, order_id);

        let orders = contract.orders.get(&alice()).unwrap();
        let order = orders.get(&1).unwrap();

        let orders_from_pair = contract.orders_per_pair_view.get(&pair_id).unwrap();
        let order_from_pair = orders_from_pair.get(&1).unwrap();

        assert_eq!(order.status, OrderStatus::Executed);
        assert_eq!(order_from_pair.status, order.status);
    }

    #[test]
    fn test_get_amounts_to_remove_liquidity_for_long() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data);

        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":2500000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.3\",\"block\":1, \"timestamp_ms\":86400050,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#100\",\"history_data\":null}".to_string();
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let liquidity_info = LiquidityInfo {
            lpt_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#100".to_string(),
            owner_id: "owner_id.testnet".parse().unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            left_point: -7040,
            right_point: -7000,
            amount: U128(35 * 10_u128.pow(24)),
            unclaimed_fee_x: U128(0),
            unclaimed_fee_y: U128(3 * 10_u128.pow(24)),
        };

        let expect_amount = U128::from(
            BigDecimal::from(U128::from(order.amount)) * order.leverage / order.open_or_close_price,
        );
        let expect_amount_with_inaccuracy_rate = U128::from(
            BigDecimal::from(expect_amount)
                * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
        );

        let order_id = U128(1);
        let result = contract.get_amounts_to_execute(order_id, order, liquidity_info);

        assert_eq!(
            [
                U128(35 * 10_u128.pow(24)),
                U128(0),
                expect_amount_with_inaccuracy_rate
            ],
            result
        );
    }

    #[test]
    fn test_get_amounts_to_remove_liquidity_for_short() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data);

        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Short\",\"amount\":2500000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.3\",\"block\":1, \"timestamp_ms\":86400050,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#100\",\"history_data\":null}".to_string();
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let liquidity_info = LiquidityInfo {
            lpt_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#100".to_string(),
            owner_id: "owner_id.testnet".parse().unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            left_point: -7040,
            right_point: -7000,
            amount: U128(35 * 10_u128.pow(24)),
            unclaimed_fee_x: U128(3 * 10_u128.pow(24)),
            unclaimed_fee_y: U128(0),
        };

        let expect_amount = U128::from(
            BigDecimal::from(U128::from(order.amount)) * (order.leverage - BigDecimal::one()),
        );
        let expect_amount_with_inaccuracy_rate = U128::from(
            BigDecimal::from(expect_amount)
                * (BigDecimal::one() - BigDecimal::from(INACCURACY_RATE)),
        );

        let order_id = U128(1);
        let result = contract.get_amounts_to_execute(order_id, order, liquidity_info);

        assert_eq!(
            [
                U128(35 * 10_u128.pow(24)),
                expect_amount_with_inaccuracy_rate,
                U128(0)
            ],
            result
        );
    }
}

'''
'''--- contracts/leverage_trading/src/ft.rs ---
use crate::*;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk::{log, serde_json, Balance, PromiseOrValue};

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Accepts token to be deposited by user.
    ///
    /// msg format for deposit "{"Deposit": {"token": "<token_to_be_deposited>"}}"
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert!(
            Balance::from(amount) > 0,
            "Amount should be a positive number"
        );

        log!(format!("sender_id {sender_id}, msg {msg}"));

        let action: Actions = serde_json::from_str(&msg).expect("Incorrect command in transfer");

        match action {
            Actions::Deposit { token } => self.deposit(amount, token),
            #[allow(unreachable_patterns)]
            _ => {
                panic!("Incorrect action in transfer")
            }
        }
    }
}

'''
'''--- contracts/leverage_trading/src/lib.rs ---
extern crate core;

#[allow(
    clippy::manual_range_contains,
    clippy::assign_op_pattern,
    clippy::ptr_offset_with_cast
)]
mod big_decimal;
mod cancel_limit_order;
mod cancel_order;
mod cancel_take_profit_order;
mod common;
mod config;
#[allow(clippy::too_many_arguments)]
mod create_order;
mod deposit;
mod execute_order;
mod ft;
mod limit_trade_history;
mod liquidate_order;
mod liquidity_slot;
mod margin_trade_history;
mod market;
mod metadata;
mod oraclehook;
mod pnl;
mod price;
#[allow(clippy::too_many_arguments)]
mod ref_finance;
mod utils;
#[allow(clippy::too_many_arguments)]
mod view;
mod withdraw;

pub use crate::metadata::*;

use crate::big_decimal::*;
use crate::config::Config;
use crate::metadata::PairId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, require, AccountId, Balance, PromiseOrValue};
use std::collections::{HashMap, VecDeque};
use utils::PROTOCOL_DECIMALS;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    /// Protocol fee
    protocol_fee: u128,

    /// token ➝ Price
    prices: UnorderedMap<AccountId, Price>,

    /// total orders created on contract
    order_nonce: u64,

    /// user ➝ order_id ➝ Order
    orders: UnorderedMap<AccountId, HashMap<u64, Order>>,

    /// take profit orders, order_id ➝ Order
    take_profit_orders: LookupMap<u64, (PricePoints, Order, ReturnAmounts)>,

    /// (sell token, buy token) ➝ TradePair
    supported_markets: UnorderedMap<PairId, TradePair>,

    /// User ➝ Token ➝ Balance
    balances: UnorderedMap<AccountId, HashMap<AccountId, Balance>>,

    config: Config,

    /// token id -> market id
    tokens_markets: LookupMap<AccountId, AccountId>,

    /// Protocol profit token_id -> amount
    protocol_profit: LookupMap<AccountId, BigDecimal>,

    /// Ref finance accountId [ as default "dclv2-dev.ref-dev.testnet" ]
    ref_finance_account: AccountId,

    /// Liquidation threshold
    liquidation_threshold: u128,

    /// Volatility rate
    volatility_rate: BigDecimal,

    /// Max value for order amount
    max_order_amount: u128,

    /// PairId ➝ order id ➝ Order
    orders_per_pair_view: UnorderedMap<PairId, HashMap<u64, Order>>,

    /// Pending orders data - for tracking info about oldest pending order
    pending_orders_data: VecDeque<PendingOrderData>,
}

impl Default for Contract {
    fn default() -> Self {
        env::panic_str("Margin trading contract should be initialized before usage")
    }
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new_with_config(owner_id: AccountId, oracle_account_id: AccountId) -> Self {
        Self::new(Config {
            owner_id,
            oracle_account_id,
        })
    }

    #[init]
    #[private]
    pub fn new(config: Config) -> Self {
        require!(!env::state_exists(), "Already initialized");

        Self {
            protocol_fee: 10u128.pow(23),
            prices: UnorderedMap::new(StorageKeys::Prices),
            order_nonce: 0,
            orders: UnorderedMap::new(StorageKeys::Orders),
            take_profit_orders: LookupMap::new(StorageKeys::TakeProfitOrders),
            supported_markets: UnorderedMap::new(StorageKeys::SupportedMarkets),
            config,
            balances: UnorderedMap::new(StorageKeys::Balances),
            tokens_markets: LookupMap::new(StorageKeys::TokenMarkets),
            protocol_profit: LookupMap::new(StorageKeys::ProtocolProfit),
            ref_finance_account: "dclv2-dev.ref-dev.testnet".parse().unwrap(),
            liquidation_threshold: 10_u128.pow(23),
            volatility_rate: BigDecimal::from(U128(95 * 10_u128.pow(22))),
            max_order_amount: 10_u128.pow(30),
            orders_per_pair_view: UnorderedMap::new(StorageKeys::OrdersPerPair),
            pending_orders_data: VecDeque::new(),
        }
    }

    #[private]
    pub fn set_protocol_fee(&mut self, fee: U128) {
        self.protocol_fee = fee.0
    }

    #[private]
    pub fn add_token_market(&mut self, token_id: AccountId, market_id: AccountId) {
        self.tokens_markets.insert(&token_id, &market_id);
    }

    #[private]
    pub fn set_liquidation_threshold(&mut self, threshold: U128) {
        self.liquidation_threshold = threshold.0;
    }

    #[private]
    pub fn set_volatility_rate(&mut self, rate: U128) {
        self.volatility_rate = BigDecimal::from(rate)
    }

    #[private]
    pub fn set_max_order_amount(&mut self, value: U128) {
        self.max_order_amount = value.0
    }

    #[private]
    pub fn set_max_leverage(&mut self, pair: &PairId, leverage: U128) {
        let mut traid_pair = self.supported_markets.get(pair).unwrap_or_else(|| {
            panic!(
                "Max leverage for pair {}|{} not found",
                pair.sell_token, pair.buy_token
            )
        });

        traid_pair.max_leverage = leverage;
        self.supported_markets.insert(pair, &traid_pair);
    }

    pub fn get_max_leverage(&self, pair: &PairId) -> U128 {
        self.supported_markets
            .get(pair)
            .unwrap_or_else(|| {
                panic!(
                    "Max leverage for pair {}|{} not found",
                    pair.sell_token, pair.buy_token
                )
            })
            .max_leverage
    }

    pub fn get_protocol_fee(&self) -> U128 {
        U128(self.protocol_fee)
    }

    pub fn get_pending_orders_data(&self) -> VecDeque<PendingOrderData> {
        self.pending_orders_data.clone()
    }

    pub fn get_pending_orders_count(&self) -> usize {
        self.pending_orders_data.len()
    }

    pub fn get_oldest_pending_order_data(&self) -> PendingOrderData {
        self.pending_orders_data
            .front()
            .unwrap_or_else(|| panic!("No pending orders to remove liquidity."))
            .clone()
    }
}

impl Contract {
    pub fn get_swap_fee(&self, order: &Order) -> U128 {
        let pair = PairId {
            sell_token: order.sell_token.clone(),
            buy_token: order.buy_token.clone(),
        };
        self.supported_markets
            .get(&pair)
            .unwrap_or_else(|| {
                panic!(
                    "Swap fee for pair {}|{} not found",
                    pair.sell_token, pair.buy_token
                )
            })
            .swap_fee
    }

    pub fn from_token_to_protocol_decimals(&self, token_amount: u128, token_decimals: u8) -> U128 {
        if token_decimals != PROTOCOL_DECIMALS {
            U128::from(
                BigDecimal::from(token_amount)
                    / BigDecimal::from(10u128.pow(token_decimals.into())),
            )
        } else {
            U128::from(token_amount)
        }
    }

    pub fn from_protocol_to_token_decimals(&self, token_amount: U128, token_decimals: u8) -> U128 {
        U128::from(
            BigDecimal::from(token_amount)
                * BigDecimal::from(U128::from(10u128.pow(token_decimals.into()))),
        )
    }

    pub fn remove_pending_order_data(&mut self, pending_order_data: PendingOrderData) {
        self.pending_orders_data.remove(
            self.pending_orders_data
                .iter()
                .position(|order_data| *order_data == pending_order_data)
                .unwrap_or_default(),
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    #[test]
    fn test_get_max_leverage() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair = PairId {
            sell_token: AccountId::from_str("usdt.fakes.testnet").unwrap(),
            buy_token: AccountId::from_str("wrap.testnet").unwrap(),
        };

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(10u128.pow(20)),
        };
        contract.add_pair(pair_data.clone());

        let result = pair_data.max_leverage;
        let max_leverage = contract.get_max_leverage(&pair);
        assert_eq!(max_leverage, result);
    }

    #[test]
    fn test_set_max_leverage() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair = PairId {
            sell_token: AccountId::from_str("usdt.fakes.testnet").unwrap(),
            buy_token: AccountId::from_str("wrap.testnet").unwrap(),
        };

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(10u128.pow(20)),
        };
        contract.add_pair(pair_data);

        contract.set_max_leverage(&pair, U128(10 * 10_u128.pow(24)));
        let max_leverage = contract.get_max_leverage(&pair);
        assert_eq!(max_leverage, U128(10 * 10_u128.pow(24)));
    }

    #[test]
    fn test_get_swap_fee() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10u128.pow(20)),
        };
        contract.add_pair(pair_data.clone());

        let order = Order {
            status: OrderStatus::Pending,
            order_type: OrderType::Buy,
            amount: 1000000000000000000000000000,
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            buy_token: "wrap.testnet".parse().unwrap(),
            leverage: BigDecimal::from(1.0),
            sell_token_price: Price {
                ticker_id: "USDT".to_string(),
                value: U128::from(1010000000000000000000000),
            },
            buy_token_price: Price {
                ticker_id: "near".to_string(),
                value: U128::from(3070000000000000000000000),
            },
            open_or_close_price: BigDecimal::from(U128(1)),
            block: 105210654,
            timestamp_ms: 1675423354862,
            lpt_id: "usdt.fakes.testnet|wrap.testnet|2000#238".to_string(),
            history_data: Default::default(),
        };

        let swap_fee = contract.get_swap_fee(&order);

        assert_eq!(swap_fee, pair_data.swap_fee);
    }

    #[test]
    fn from_token_to_protocol_decimals_test() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        let token: AccountId = "usdt.fakes.testnet".parse().unwrap();
        let token_amount = U128::from(1_000_000_000);
        let token_decimals = contract.view_token_decimals(&token);

        let result = contract.from_token_to_protocol_decimals(token_amount.0, token_decimals);
        let expected_result = U128::from(1_000_000_000_000_000_000_000_000_000);

        assert_eq!(result, expected_result);

        assert_eq!(
            BigDecimal::from(result),          // 1000.0
            BigDecimal::from(expected_result)  // 1000.0
        );
    }

    #[test]
    fn from_protocol_to_token_decimals_test() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        let token: AccountId = "usdt.fakes.testnet".parse().unwrap();
        let token_amount_with_protocol_decimals = U128::from(1_000_000_000_000_000_000_000_000_000);
        let token_decimals = contract.view_token_decimals(&token);

        let result = contract
            .from_protocol_to_token_decimals(token_amount_with_protocol_decimals, token_decimals);
        let expected_result = U128::from(1_000_000_000);

        assert_eq!(result, expected_result);

        assert_eq!(
            BigDecimal::from(result),          // 1000.0
            BigDecimal::from(expected_result)  // 1000.0
        );
    }
}

'''
'''--- contracts/leverage_trading/src/limit_trade_history.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn view_non_pending_limit_orders_by_user(
        &self,
        account_id: AccountId,
        orders_per_page: U128,
        page: U128,
    ) -> LimitTradeHistory {
        let orders = self.orders.get(&account_id).unwrap_or_default();

        let mut non_pending_limit_orders = orders
            .iter()
            .filter_map(|(order_id, order)| {
                if order.leverage == BigDecimal::one() {
                    self.get_non_pending_limit_order(U128::from(*order_id as u128), order)
                } else {
                    None
                }
            })
            .collect::<Vec<LimitOrderTradeHistory>>();

        non_pending_limit_orders.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));

        let total_orders = U128::from(non_pending_limit_orders.len() as u128);

        let sorted_non_pending_limit_orders = non_pending_limit_orders
            .into_iter()
            .skip((orders_per_page.0 * page.0 - orders_per_page.0) as usize)
            .take(orders_per_page.0 as usize)
            .collect();

        LimitTradeHistory {
            data: sorted_non_pending_limit_orders,
            page,
            total_orders,
        }
    }

    pub fn view_non_pending_limit_orders_by_user_by_pair(
        &self,
        account_id: AccountId,
        sell_token: AccountId,
        buy_token: AccountId,
        orders_per_page: U128,
        page: U128,
    ) -> LimitTradeHistory {
        let orders = self.orders.get(&account_id).unwrap_or_default();

        let mut non_pending_limit_orders = orders
            .iter()
            .filter_map(|(order_id, order)| {
                if order.leverage == BigDecimal::one()
                    && order.sell_token == sell_token
                    && order.buy_token == buy_token
                {
                    self.get_non_pending_limit_order(U128::from(*order_id as u128), order)
                } else {
                    None
                }
            })
            .collect::<Vec<LimitOrderTradeHistory>>();

        non_pending_limit_orders.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));

        let total_orders = U128::from(non_pending_limit_orders.len() as u128);

        let sorted_non_pending_limit_orders = non_pending_limit_orders
            .into_iter()
            .skip((orders_per_page.0 * page.0 - orders_per_page.0) as usize)
            .take(orders_per_page.0 as usize)
            .collect();

        LimitTradeHistory {
            data: sorted_non_pending_limit_orders,
            page,
            total_orders,
        }
    }
}

impl Contract {
    pub fn get_non_pending_limit_order(
        &self,
        order_id: U128,
        order: &Order,
    ) -> Option<LimitOrderTradeHistory> {
        match order.status {
            OrderStatus::Canceled | OrderStatus::Executed => {
                let timestamp = order.timestamp_ms;

                let pair = self.get_trade_pair(&order.sell_token, &order.buy_token);
                let pair = format!("{}/{}", pair.sell_ticker_id, pair.buy_ticker_id);

                let side = order.order_type.clone();

                let status = order.status.clone();

                let price = U128::from(order.open_or_close_price);

                let (fee, executed) = if let Some(history_data) = &order.history_data {
                    (history_data.fee, history_data.executed)
                } else {
                    (
                        U128::from(0),
                        match order.order_type {
                            OrderType::Buy => U128::from(
                                BigDecimal::from(U128::from(order.amount))
                                    / order.open_or_close_price,
                            ),
                            OrderType::Sell => U128::from(order.amount),
                            _ => U128::from(0),
                        },
                    )
                };

                let total = match order.order_type {
                    OrderType::Buy => U128::from(order.amount),
                    OrderType::Sell => U128::from(
                        BigDecimal::from(U128::from(order.amount)) * order.open_or_close_price,
                    ),
                    _ => U128::from(0),
                };

                Some(LimitOrderTradeHistory {
                    order_id,
                    timestamp,
                    pair,
                    side,
                    status,
                    price,
                    executed,
                    fee,
                    total,
                })
            }
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::test_env::alice;

    #[test]
    fn view_non_pending_limit_orders_by_user_test() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data);

        for count in 0..6 {
            if count < 1 {
                // order with status of "Canceled" on leverage "1.0" and with timestamp "86400000"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Pending" on leverage "1.0"and with timestamp "86400001"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 4 {
                // order with status of "Pending" on leverage "2.0"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Executed" on leverage "1.0" and with timestamp "86400003"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400003,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let first_limit_order_trade_history = LimitOrderTradeHistory {
            order_id: U128::from(1),
            timestamp: 86400000,
            pair: "USDT/WNEAR".to_string(),
            side: OrderType::Buy,
            status: OrderStatus::Canceled,
            price: U128(25 * 10_u128.pow(23)),
            executed: U128::from(
                BigDecimal::from(U128::from(2000000000000000000000000000))
                    / BigDecimal::from(U128::from(2500000000000000000000000)),
            ),
            fee: U128::from(0),
            total: U128(2 * 10_u128.pow(27)),
        };

        let limit_trade_history_by_user =
            contract.view_non_pending_limit_orders_by_user(alice(), U128(10), U128(1));

        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 6_usize);
        assert_eq!(limit_trade_history_by_user.data.len(), 3_usize);
        assert_eq!(limit_trade_history_by_user.total_orders, U128(3));
        assert_eq!(
            limit_trade_history_by_user.data.get(0).unwrap(),
            &first_limit_order_trade_history
        );
    }

    #[test]
    fn view_non_pending_limit_orders_by_user_by_pair_test() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_id = PairId {
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        let pair_data1 = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        let pair_data2 = TradePair {
            sell_ticker_id: "WNEAR".to_string(),
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "USDT".to_string(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 6,
            buy_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "wnear.qa.v1.nearlend.testnet|usdt.qa.v1.nearlend.testnet|2001".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data1);
        contract.add_pair(pair_data2);

        for count in 0..6 {
            if count < 1 {
                // order with status of "Executed" on leverage "1.0" and in pair "USDT/WNEAR" with timestamp "86400000"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Pending" on leverage "1.0" and in pair "USDT/WNEAR" with timestamp "86400001"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Sell\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 3 {
                // order with status of "Executed" on leverage "1.0" and in pair "WNEAR/USDT"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"wnear.qa.v1.nearlend.testnet\",\"buy_token\":\"usdt.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 4 {
                // order with status of "Canceled" on leverage "2.0" and in pair "USDT/WNEAR"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Canceled" on leverage "1.0" and in pair "USDT/WNEAR" with timestamp "86400003"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400003,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let first_limit_order_trade_history = LimitOrderTradeHistory {
            order_id: U128::from(1),
            timestamp: 86400000,
            pair: "USDT/WNEAR".to_string(),
            side: OrderType::Buy,
            status: OrderStatus::Executed,
            price: U128(25 * 10_u128.pow(23)),
            executed: U128::from(
                BigDecimal::from(U128::from(2000000000000000000000000000))
                    / BigDecimal::from(U128::from(2500000000000000000000000)),
            ),
            fee: U128::from(0),
            total: U128(2 * 10_u128.pow(27)),
        };

        let limit_trade_history_by_user_by_pair = contract
            .view_non_pending_limit_orders_by_user_by_pair(
                alice(),
                pair_id.sell_token,
                pair_id.buy_token,
                U128(10),
                U128(1),
            );

        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 6_usize);
        assert_eq!(
            contract
                .view_non_pending_limit_orders_by_user(alice(), U128(10), U128(1))
                .total_orders,
            U128(4)
        );
        assert_eq!(limit_trade_history_by_user_by_pair.data.len(), 3_usize);
        assert_eq!(limit_trade_history_by_user_by_pair.total_orders, U128(3));
        assert_eq!(
            limit_trade_history_by_user_by_pair.data.get(0).unwrap(),
            &first_limit_order_trade_history
        );
    }
}

'''
'''--- contracts/leverage_trading/src/liquidate_order.rs ---
use crate::big_decimal::BigDecimal;
use crate::cancel_order::ext_self;
use crate::ref_finance::{ext_ref_finance, Action, Swap};
use crate::utils::{ext_token, NO_DEPOSIT};
use crate::*;
use near_sdk::env::{block_height, current_account_id};
use near_sdk::{is_promise_success, log, Gas};

#[near_bindgen]
impl Contract {
    pub fn liquidate_order(&mut self, order_id: U128, price_impact: U128) {
        let account_op = self.get_account_by(order_id.0);
        require!(
            account_op.is_some(),
            format!("Not found account for order with id: {}", order_id.0)
        );
        let account = account_op.unwrap();

        let orders = self.orders.get(&account).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", account.clone());
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();

        require!(
            order.status != OrderStatus::Canceled && order.status != OrderStatus::Executed,
            "Order can't be liquidate."
        );

        //TODO: set real min_amount_x/min_amount_y
        let amount = 1;
        let min_amount_x = order.amount;
        let min_amount_y = 0;

        let (sell_token_decimals, _) =
            self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
        let min_amount_x =
            self.from_protocol_to_token_decimals(U128::from(min_amount_x), sell_token_decimals);

        if order.status == OrderStatus::Pending {
            ext_ref_finance::ext(self.ref_finance_account.clone())
                .with_static_gas(Gas(10))
                .with_attached_deposit(1)
                .remove_liquidity(
                    order.lpt_id.clone(),
                    U128(amount),
                    min_amount_x,
                    U128(min_amount_y),
                )
                .then(
                    ext_self::ext(current_account_id())
                        .with_static_gas(Gas(5))
                        .with_attached_deposit(NO_DEPOSIT)
                        .remove_liquidity_callback(order_id, order),
                );
        } else {
            self.swap(order_id, order, price_impact, OrderAction::Liquidate);
        }
    }

    #[private]
    pub fn remove_liquidity_callback(&mut self, order_id: U128, order: Order) {
        require!(is_promise_success(), "Some problem with remove liquidity");
        self.final_liquidate(order_id, order, None);
    }

    #[private]
    pub fn final_liquidate(
        &mut self,
        order_id: U128,
        order: Order,
        market_data: Option<MarketData>,
    ) {
        #[allow(clippy::unnecessary_unwrap)]
        let borrow_fee = if market_data.is_some() {
            BigDecimal::from(
                market_data.unwrap().borrow_rate_ratio.0 * (block_height() - order.block) as u128,
            )
        } else {
            BigDecimal::one()
        };

        let buy_token_amount = BigDecimal::from(order.amount)
            * BigDecimal::from(order.sell_token_price.value)
            * order.leverage
            / BigDecimal::from(order.buy_token_price.value);
        let loss = borrow_fee + buy_token_amount * BigDecimal::from(order.buy_token_price.value)
            - BigDecimal::from(order.amount);

        let is_liquidation_possible = loss
            >= BigDecimal::from(order.amount)
                * BigDecimal::from(order.buy_token_price.value)
                * BigDecimal::from(10_u128.pow(24) - self.liquidation_threshold);

        require!(is_liquidation_possible, "This order can't be liquidated");

        let liquidation_incentive = order.amount * self.liquidation_threshold;
        self.increase_balance(
            &env::signer_account_id(),
            &order.buy_token,
            liquidation_incentive,
        );

        let mut order = order;
        order.status = OrderStatus::Liquidated;

        self.add_or_update_order(
            &self.get_account_by(order_id.0).unwrap(),
            order,
            order_id.0 as u64,
        );
    }
}

impl Contract {
    pub fn swap(
        &self,
        order_id: U128,
        order: Order,
        price_impact: U128,
        order_action: OrderAction,
    ) {
        let buy_amount = BigDecimal::from(U128::from(order.amount))
            * order.leverage
            * BigDecimal::from(order.sell_token_price.value)
            * self.get_price(order.buy_token.clone())
            / BigDecimal::from(order.buy_token_price.value);

        let (_, buy_token_decimals) =
            self.view_pair_tokens_decimals(&order.sell_token, &order.buy_token);
        let buy_amount =
            self.from_protocol_to_token_decimals(U128::from(buy_amount), buy_token_decimals);

        let action = Action::SwapAction {
            Swap: Swap {
                pool_ids: vec![
                    self.get_trade_pair(&order.sell_token, &order.buy_token)
                        .pool_id,
                ],
                output_token: order.sell_token.clone(),
                min_output_amount: WBalance::from(0),
            },
        };

        log!(
            "action {}",
            near_sdk::serde_json::to_string(&action).unwrap()
        );

        ext_token::ext(order.buy_token.clone())
            .with_attached_deposit(1)
            .ft_transfer_call(
                self.ref_finance_account.clone(),
                buy_amount,
                Some("Swap".to_string()),
                near_sdk::serde_json::to_string(&action).unwrap(),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .liquidate_order_swap_callback(order_id, order, price_impact, order_action),
            );
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::test_utils::test_env::alice;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(103931930)
            .block_timestamp(1)
            .is_view(is_view)
            .build()
    }

    //there are questions about the method calculations "final_liquidate"
    #[test]
    #[should_panic]
    fn test_order_was_liquidate() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_id = PairId {
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDT".to_string(),
                value: U128::from(1000000000000000000000000),
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "WNEAR".to_string(),
                value: U128::from(4220000000000000000000000),
            },
        );

        contract.set_balance(&alice(), &pair_id.sell_token, 10_u128.pow(30));

        let order1 = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"4220000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930900,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#543\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order1);

        let order_id = U128(1);
        let order = Order {
            status: OrderStatus::Pending,
            order_type: OrderType::Buy,
            amount: 1000000000000000000000000000,
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            leverage: BigDecimal::from(1.0),
            sell_token_price: Price {
                ticker_id: "USDT".to_string(),
                value: U128::from(1010000000000000000000000),
            },
            buy_token_price: Price {
                ticker_id: "near".to_string(),
                value: U128::from(3070000000000000000000000),
            },
            open_or_close_price: BigDecimal::from(U128(1)),
            block: 103930900,
            timestamp_ms: 1675423354862,
            lpt_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#238".to_string(),
            history_data: Default::default(),
        };

        let market_data = MarketData {
            underlying_token: AccountId::new_unchecked("usdt.fakes.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(60000000000000000000000000000),
            total_borrows: U128(25010000000000000000000000000),
            total_reserves: U128(1000176731435219096024128768),
            exchange_rate_ratio: U128(1000277139994639276176632),
            interest_rate_ratio: U128(261670051778601),
            borrow_rate_ratio: U128(634273735391536),
        };

        contract.final_liquidate(order_id, order, Some(market_data));

        let orders = contract.orders.get(&alice()).unwrap();
        let order = orders.get(&1).unwrap();

        let orders_from_pair = contract.orders_per_pair_view.get(&pair_id).unwrap();
        let order_from_pair = orders_from_pair.get(&1).unwrap();

        assert_eq!(order.status, OrderStatus::Liquidated);
        assert_eq!(order_from_pair.status, order.status);
    }
}

'''
'''--- contracts/leverage_trading/src/liquidity_slot.rs ---
use near_sdk::{
    env::{current_account_id, signer_account_id},
    ext_contract, is_promise_success, Gas, PromiseResult,
};

use crate::{
    ref_finance::{ext_ref_finance, LptId, ShortLiquidityInfo},
    utils::NO_DEPOSIT,
    *,
};

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn get_liquidity_info_callback(
        &self,
        lpt_id: LptId,
        user: Option<AccountId>,
        oldest_pending_order_data: PendingOrderData,
    );
    fn remove_oldest_liquidity_callback(
        &mut self,
        user: Option<AccountId>,
        oldest_pending_order_data: PendingOrderData,
    );
}

#[near_bindgen]
impl Contract {
    pub fn free_up_liquidity_slot(&mut self) {
        require!(
            signer_account_id() == self.config.oracle_account_id
                || signer_account_id() == current_account_id(),
            "You do not have access to call this method."
        );

        let oldest_pending_order_data = self.get_oldest_pending_order_data();

        match oldest_pending_order_data.order_type {
            OrderType::Buy | OrderType::Sell | OrderType::Long | OrderType::Short => {
                if let Some((user, order)) =
                    self.get_order_by_id(oldest_pending_order_data.order_id)
                {
                    if let OrderStatus::Pending = order.status {
                        self.get_liquidity_info(
                            order.lpt_id,
                            Some(user),
                            oldest_pending_order_data,
                        );
                    }
                }
            }
            OrderType::TakeProfit => {
                if let Some(order) =
                    self.get_take_profit_order_by_id(oldest_pending_order_data.order_id)
                {
                    if let OrderStatus::Pending = order.status {
                        self.get_liquidity_info(order.lpt_id, None, oldest_pending_order_data);
                    }
                }
            }
        }
    }

    #[private]
    pub fn get_liquidity_info(
        &self,
        lpt_id: LptId,
        user: Option<AccountId>,
        oldest_pending_order_data: PendingOrderData,
    ) {
        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_unused_gas_weight(2)
            .with_attached_deposit(NO_DEPOSIT)
            .get_liquidity(lpt_id.clone())
            .then(
                ext_self::ext(current_account_id())
                    .with_unused_gas_weight(98)
                    .with_attached_deposit(NO_DEPOSIT)
                    .get_liquidity_info_callback(lpt_id, user, oldest_pending_order_data),
            );
    }

    #[private]
    pub fn get_liquidity_info_callback(
        &self,
        lpt_id: LptId,
        user: Option<AccountId>,
        oldest_pending_order_data: PendingOrderData,
    ) {
        require!(is_promise_success(), "Some problem with getting liquidity.");

        let liquidity_info: ShortLiquidityInfo = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(liquidity) = near_sdk::serde_json::from_slice::<ShortLiquidityInfo>(&val)
                {
                    liquidity
                } else {
                    panic!("Some problem with liquidity parsing.")
                }
            }
            PromiseResult::Failed => panic!("Ref finance not found liquidity."),
        };

        let min_amount_x = U128::from(0);
        let min_amount_y = U128::from(0);

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 70)
            .with_attached_deposit(NO_DEPOSIT)
            .remove_liquidity(lpt_id, liquidity_info.amount, min_amount_x, min_amount_y)
            .then(
                ext_self::ext(current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .remove_oldest_liquidity_callback(user, oldest_pending_order_data),
            );
    }

    #[private]
    pub fn remove_oldest_liquidity_callback(
        &mut self,
        user: Option<AccountId>,
        oldest_pending_order_data: PendingOrderData,
    ) {
        require!(
            is_promise_success(),
            "Some problem with removing liquidity."
        );

        match oldest_pending_order_data.order_type {
            OrderType::Buy | OrderType::Sell => {
                self.remove_order_by_ids(user.unwrap(), oldest_pending_order_data.order_id);
            }
            OrderType::Long | OrderType::Short => {
                self.remove_order_by_ids(user.unwrap(), oldest_pending_order_data.order_id);
                self.remove_take_profit_order_by_id(oldest_pending_order_data.order_id);
            }
            OrderType::TakeProfit => {
                self.remove_take_profit_order_by_id(oldest_pending_order_data.order_id);
            }
        }

        if let Some((pair_id, _)) =
            self.get_order_per_pair_view_by_id(oldest_pending_order_data.order_id)
        {
            self.remove_order_per_pair_view_by_ids(pair_id, oldest_pending_order_data.order_id);
        }

        self.pending_orders_data.pop_front();
    }
}

impl Contract {
    pub fn get_order_by_id(&self, order_id: U128) -> Option<(AccountId, Order)> {
        for user in self.orders.keys().collect::<Vec<_>>() {
            if let Some(order) = self
                .orders
                .get(&user)
                .unwrap()
                .get(&(order_id.0 as u64))
                .cloned()
            {
                return Some((user, order));
            }
        }
        None
    }

    pub fn get_take_profit_order_by_id(&self, order_id: U128) -> Option<Order> {
        if let Some((_, order, _)) = self.take_profit_orders.get(&(order_id.0 as u64)) {
            return Some(order);
        }
        None
    }

    pub fn get_order_per_pair_view_by_id(&self, order_id: U128) -> Option<(PairId, Order)> {
        for pair_id in self.orders_per_pair_view.keys().collect::<Vec<_>>() {
            if let Some(order) = self
                .orders_per_pair_view
                .get(&pair_id)
                .unwrap()
                .get(&(order_id.0 as u64))
                .cloned()
            {
                return Some((pair_id, order));
            }
        }
        None
    }

    fn remove_order_by_ids(&mut self, account_id: AccountId, order_id: U128) {
        let mut orders = self.orders.get(&account_id).unwrap();
        orders.remove(&(order_id.0 as u64));
        self.orders.remove(&account_id);
        self.orders.insert(&account_id, &orders);
    }

    fn remove_take_profit_order_by_id(&mut self, order_id: U128) {
        self.take_profit_orders.remove(&(order_id.0 as u64));
    }

    fn remove_order_per_pair_view_by_ids(&mut self, pair_id: PairId, order_id: U128) {
        let mut orders = self.orders_per_pair_view.get(&pair_id).unwrap();
        orders.remove(&(order_id.0 as u64));
        self.orders_per_pair_view.remove(&pair_id);
        self.orders_per_pair_view.insert(&pair_id, &orders);
    }
}

'''
'''--- contracts/leverage_trading/src/margin_trade_history.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn view_non_pending_margin_orders_by_user(
        &self,
        account_id: AccountId,
        orders_per_page: U128,
        page: U128,
    ) -> MarginTradeHistory {
        let orders = self.orders.get(&account_id).unwrap_or_default();

        let mut non_pending_margin_order = orders
            .iter()
            .filter_map(|(order_id, order)| {
                if order.leverage != BigDecimal::one() {
                    self.get_non_pending_margin_order(U128::from(*order_id as u128), order)
                } else {
                    None
                }
            })
            .collect::<Vec<MarginOrderTradeHistory>>();

        non_pending_margin_order.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));

        let total_orders = U128::from(non_pending_margin_order.len() as u128);

        let sorted_non_pending_margin_order = non_pending_margin_order
            .into_iter()
            .skip((orders_per_page.0 * page.0 - orders_per_page.0) as usize)
            .take(orders_per_page.0 as usize)
            .collect();

        MarginTradeHistory {
            data: sorted_non_pending_margin_order,
            page,
            total_orders,
        }
    }

    pub fn view_non_pending_margin_orders_by_user_by_pair(
        &self,
        account_id: AccountId,
        sell_token: AccountId,
        buy_token: AccountId,
        orders_per_page: U128,
        page: U128,
    ) -> MarginTradeHistory {
        let orders = self.orders.get(&account_id).unwrap_or_default();

        let mut non_pending_margin_order = orders
            .iter()
            .filter_map(|(order_id, order)| {
                if order.leverage != BigDecimal::one()
                    && order.sell_token == sell_token
                    && order.buy_token == buy_token
                {
                    self.get_non_pending_margin_order(U128::from(*order_id as u128), order)
                } else {
                    None
                }
            })
            .collect::<Vec<MarginOrderTradeHistory>>();

        non_pending_margin_order.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));

        let total_orders = U128::from(non_pending_margin_order.len() as u128);

        let sorted_non_pending_margin_order = non_pending_margin_order
            .into_iter()
            .skip((orders_per_page.0 * page.0 - orders_per_page.0) as usize)
            .take(orders_per_page.0 as usize)
            .collect();

        MarginTradeHistory {
            data: sorted_non_pending_margin_order,
            page,
            total_orders,
        }
    }
}

impl Contract {
    pub fn get_non_pending_margin_order(
        &self,
        order_id: U128,
        order: &Order,
    ) -> Option<MarginOrderTradeHistory> {
        match order.status {
            OrderStatus::Canceled | OrderStatus::Closed | OrderStatus::Liquidated => {
                let timestamp = order.timestamp_ms;

                let pair = self.get_trade_pair(&order.sell_token, &order.buy_token);
                let pair = format!("{}/{}", pair.sell_ticker_id, pair.buy_ticker_id);

                let side = order.order_type.clone();

                let status = order.status.clone();

                let leverage = U128::from(order.leverage);

                let price = U128::from(order.open_or_close_price);

                let (fee, pnl, executed) = if let Some(history_data) = &order.history_data {
                    (
                        history_data.fee,
                        history_data.pnl.clone(),
                        history_data.executed,
                    )
                } else {
                    (
                        U128::from(0),
                        PnLView {
                            is_profit: false,
                            amount: U128::from(0),
                        },
                        U128::from(0),
                    )
                };

                let total = match order.order_type {
                    OrderType::Long | OrderType::Short => {
                        U128::from(BigDecimal::from(U128::from(order.amount)) * order.leverage)
                    }
                    _ => U128::from(0),
                };

                Some(MarginOrderTradeHistory {
                    order_id,
                    timestamp,
                    pair,
                    side,
                    status,
                    leverage,
                    price,
                    executed,
                    fee,
                    pnl,
                    total,
                })
            }
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::MILLISECONDS_PER_DAY;
    use near_sdk::{
        test_utils::{test_env::alice, VMContextBuilder},
        testing_env, VMContext,
    };

    fn get_context(is_view: bool, block_timestamp: Option<u64>) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(103930916)
            .block_timestamp(block_timestamp.unwrap_or(1))
            .is_view(is_view)
            .build()
    }

    fn get_current_day_in_nanoseconds(day: u64) -> Option<u64> {
        let nanoseconds_in_one_millisecond = 1_000_000;
        Some(MILLISECONDS_PER_DAY * day * nanoseconds_in_one_millisecond)
    }

    #[test]
    fn view_non_pending_margin_orders_by_user_test() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // pair data for "USDT/WNEAR"
        let pair_data1 = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        // pair data for "WNEAR/USDT"
        let pair_data2 = TradePair {
            sell_ticker_id: "WNEAR".to_string(),
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "USDT".to_string(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 6,
            buy_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "wnear.qa.v1.nearlend.testnet|usdt.qa.v1.nearlend.testnet|2001".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data1);
        contract.add_pair(pair_data2);

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDT".to_string(),
                value: U128::from(10_u128.pow(24)), // current price token
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "WNEAR".to_string(),
                value: U128::from(3 * 10_u128.pow(24)), // current price token
            },
        );

        for count in 0..6 {
            if count < 1 {
                // order with status of "Pending" on leverage "3.0" and with timestamp "86400000"
                let order_as_string = "{\"status\":\"Closed\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Executed" on leverage "3.0" and with timestamp "86400001"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Short\",\"amount\":2000000000000000000000000000,\"sell_token\":\"wnear.qa.v1.nearlend.testnet\",\"buy_token\":\"usdt.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 4 {
                // order with status of "Pending" on leverage "1.0"
                let order_as_string = "{\"status\":\"Liquidated\",\"order_type\":\"Short\",\"amount\":3000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400002,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Executed" on leverage "1.0"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":4000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400003,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let non_pending_margin_orders_by_user =
            contract.view_non_pending_margin_orders_by_user(alice(), U128(10), U128(1));

        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 6_usize);
        assert_eq!(non_pending_margin_orders_by_user.data.len(), 2_usize);
        assert_eq!(non_pending_margin_orders_by_user.total_orders, U128(2));
    }

    #[test]
    fn view_non_pending_margin_orders_by_user_by_pair_test() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_id = PairId {
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        // pair data for "USDT/WNEAR"
        let pair_data1 = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        // pair data for "WNEAR/USDT"
        let pair_data2 = TradePair {
            sell_ticker_id: "WNEAR".to_string(),
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "USDT".to_string(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 6,
            buy_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "wnear.qa.v1.nearlend.testnet|usdt.qa.v1.nearlend.testnet|2001".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data1);
        contract.add_pair(pair_data2);

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDT".to_string(),
                value: U128::from(10_u128.pow(24)), // current price token
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "WNEAR".to_string(),
                value: U128::from(3 * 10_u128.pow(24)), // current price token
            },
        );

        for count in 0..6 {
            if count < 1 {
                // order with status of "Pending" on leverage "3.0" and with timestamp "86400000"
                let order_as_string = "{\"status\":\"Closed\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Executed" on leverage "3.0" and with timestamp "86400001"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Short\",\"amount\":2000000000000000000000000000,\"sell_token\":\"wnear.qa.v1.nearlend.testnet\",\"buy_token\":\"usdt.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 4 {
                // order with status of "Pending" on leverage "1.0"
                let order_as_string = "{\"status\":\"Liquidated\",\"order_type\":\"Short\",\"amount\":3000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400002,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Executed" on leverage "1.0"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":4000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400003,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let non_pending_margin_orders_by_user = contract
            .view_non_pending_margin_orders_by_user_by_pair(
                alice(),
                pair_id.sell_token,
                pair_id.buy_token,
                U128(10),
                U128(1),
            );

        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 6_usize);
        assert_eq!(non_pending_margin_orders_by_user.data.len(), 1_usize);
        assert_eq!(non_pending_margin_orders_by_user.total_orders, U128(1));
    }
}

'''
'''--- contracts/leverage_trading/src/market.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    #[private]
    pub fn add_pair(&mut self, pair_data: TradePair) {
        let pair = PairId {
            sell_token: pair_data.sell_token.clone(),
            buy_token: pair_data.buy_token.clone(),
        };

        self.supported_markets.insert(&pair, &pair_data);
    }

    #[private]
    pub fn remove_pair(&mut self, pair_data: TradePair) {
        let pair = PairId {
            sell_token: pair_data.sell_token.clone(),
            buy_token: pair_data.buy_token,
        };

        self.supported_markets.remove(&pair);
    }
}

'''
'''--- contracts/leverage_trading/src/metadata.rs ---
use crate::big_decimal::{BigDecimal, WBalance, WRatio};
use crate::*;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, BlockHeight, BorshStorageKey, Timestamp};
use std::fmt;

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKeys {
    Markets,
    Prices,
    Orders,
    OrdersPerPair,
    SupportedMarkets,
    Balances,
    TokenMarkets,
    ProtocolProfit,
    TakeProfitOrders,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketData {
    pub underlying_token: AccountId,
    /// WARN: should be the same as `underlying_token.ft_metadata.decimals`
    pub underlying_token_decimals: u8,

    /// Total supplies with precision 10^24
    pub total_supplies: WBalance,
    /// Total borrows with precision 10^24
    pub total_borrows: WBalance,
    /// Total reserves with precision 10^24
    pub total_reserves: WBalance,

    pub exchange_rate_ratio: WRatio,
    pub interest_rate_ratio: WRatio,
    pub borrow_rate_ratio: WRatio,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PnLView {
    pub is_profit: bool,
    pub amount: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    pub ticker_id: String,
    pub value: U128,
}

/// left і right points for work with liquidity from ref-finance
pub type PricePoints = (i32, i32);

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ReturnAmounts {
    /// amount_x
    pub amount_sell_token: U128,
    /// amount_y
    pub amount_buy_token: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum OrderStatus {
    Pending,
    Executed,
    Canceled,
    Closed,
    Liquidated,
    PendingOrderExecute,
    PartlyExecuted,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, PartialEq, Eq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum OrderType {
    Buy,
    Sell,
    Long,
    Short,
    TakeProfit,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Order {
    pub status: OrderStatus,
    pub order_type: OrderType,
    pub amount: Balance,
    pub sell_token: AccountId,
    pub buy_token: AccountId,
    pub leverage: BigDecimal,
    pub sell_token_price: Price,
    pub buy_token_price: Price,
    /// position opening or closing price (xrate)
    pub open_or_close_price: BigDecimal,
    pub block: BlockHeight,
    pub timestamp_ms: Timestamp,
    pub lpt_id: String,
    /// data after closed position for trade history -> (Fee, PnL)
    pub history_data: Option<HistoryData>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct OrderView {
    pub order_id: U128,
    pub status: OrderStatus,
    pub order_type: OrderType,
    pub amount: U128,
    pub sell_token: AccountId,
    pub sell_token_price: WBalance,
    pub buy_token: AccountId,
    pub buy_token_price: WBalance,
    pub leverage: WBigDecimal,
    pub borrow_fee: WBalance,
    pub liquidation_price: WBalance,
    pub lpt_id: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct TradePair {
    pub sell_ticker_id: String,
    pub sell_token: AccountId,
    pub sell_token_decimals: u8,
    pub sell_token_market: AccountId,
    pub buy_ticker_id: String,
    pub buy_token: AccountId,
    pub buy_token_decimals: u8,
    pub buy_token_market: AccountId,
    pub pool_id: String,
    pub max_leverage: U128,
    pub swap_fee: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct TradePairView {
    pub pair_id: PairId,
    pub pair_tickers_id: String,
    pub sell_ticker_id: String,
    pub sell_token: AccountId,
    pub sell_token_decimals: u8,
    pub sell_token_market: AccountId,
    pub buy_ticker_id: String,
    pub buy_token: AccountId,
    pub buy_token_decimals: u8,
    pub buy_token_market: AccountId,
    pub pool_id: String,
    pub max_leverage: U128,
    pub swap_fee: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct PairId {
    pub sell_token: AccountId,
    pub buy_token: AccountId,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CancelOrderView {
    pub buy_token_amount: WRatio,
    pub sell_token_amount: WRatio,
    pub open_or_close_price: WRatio,
    pub close_price: WRatio,
    pub pnl: PnLView,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub enum OrderAction {
    Create,
    Cancel,
    Liquidate,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolInfo {
    pub pool_id: String,
    pub token_x: AccountId,
    pub token_y: AccountId,
    pub fee: u64,
    pub point_delta: u64,
    pub current_point: i64,
    pub liquidity: U128,
    pub liquidity_x: U128,
    pub max_liquidity_per_point: U128,
    pub total_fee_x_charged: U128,
    pub total_fee_y_charged: U128,
    pub volume_x_in: U128,
    pub volume_y_in: U128,
    pub volume_x_out: U128,
    pub volume_y_out: U128,
    pub total_liquidity: U128,
    pub total_order_x: U128,
    pub total_order_y: U128,
    pub total_x: U128,
    pub total_y: U128,
    pub state: PoolState,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub enum PoolState {
    Running,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct Liquidity {
    pub lpt_id: String,
    pub owner_id: AccountId,
    pub pool_id: String,
    pub left_point: i64,
    pub right_point: i64,
    pub amount: U128,
    pub unclaimed_fee_x: U128,
    pub unclaimed_fee_y: U128,
}

#[derive(Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub enum Actions {
    Deposit { token: AccountId },
}

impl fmt::Display for Actions {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PendingOrders {
    pub data: Vec<(u64, Order)>,
    pub page: U128,
    pub total: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct LimitOrderView {
    pub order_id: U128,
    pub timestamp: Timestamp,
    pub pair: String,
    pub order_type: String,
    pub side: OrderType,
    /// position opening price (xrate)
    pub price: WBalance,
    pub amount: U128,
    /// (0% if an order is pending, 100% if an order is executed)
    pub filled: u8,
    /// (amount * sell_token_price)
    pub total: WBalance,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct LimitOrders {
    pub data: Vec<LimitOrderView>,
    pub page: U128,
    pub total_orders: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct LeveragedPositionView {
    pub order_id: U128,
    pub timestamp: Timestamp,
    pub pair: String,
    pub order_type: OrderType,
    /// (buy_token_price / sell_token_price from order)
    pub price: WBalance,
    pub leverage: U128,
    pub amount: U128,
    /// (0% if an order is pending, 100% if an order is executed)
    pub filled: u8,
    /// (amount * sell_token_price)
    pub total: WBalance,
    pub pnl: PnLView,
    /// Optional field with Take profit order related to the position
    pub take_profit_order: Option<TakeProfitOrderView>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct LeveragedPositions {
    pub data: Vec<LeveragedPositionView>,
    pub page: U128,
    pub total_positions: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct TakeProfitOrderView {
    pub timestamp: Timestamp,
    pub pair: String,
    pub order_type: OrderType,
    /// position opening price (xrate)
    pub price: WBalance,
    pub amount: U128,
    /// (0% if an order is pending, 100% if an order is executed)
    pub filled: u8,
    /// (amount * sell_token_price)
    pub total: WBalance,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct LimitOrderTradeHistory {
    pub order_id: U128,
    pub timestamp: Timestamp,
    pub pair: String,
    pub side: OrderType,
    pub status: OrderStatus,
    pub price: U128,
    pub executed: U128,
    pub fee: U128,
    pub total: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct LimitTradeHistory {
    pub data: Vec<LimitOrderTradeHistory>,
    pub page: U128,
    pub total_orders: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, PartialEq, Eq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct HistoryData {
    pub fee: U128,
    pub pnl: PnLView,
    pub executed: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct MarginOrderTradeHistory {
    pub order_id: U128,
    pub timestamp: Timestamp,
    pub pair: String,
    pub side: OrderType,
    pub status: OrderStatus,
    pub leverage: U128,
    pub price: U128,
    pub executed: U128,
    pub fee: U128,
    pub pnl: PnLView,
    pub total: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct MarginTradeHistory {
    pub data: Vec<MarginOrderTradeHistory>,
    pub page: U128,
    pub total_orders: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PendingOrderData {
    pub order_id: U128,
    pub order_type: OrderType,
}

'''
'''--- contracts/leverage_trading/src/oraclehook.rs ---
use crate::*;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceJsonList {
    /// Block number
    pub block_height: u64,

    /// Vector of asset prices
    pub price_list: Vec<Price>,
}

pub trait OraclePriceHandlerHook {
    fn oracle_on_data(&mut self, price_data: PriceJsonList);
}

#[near_bindgen]
impl OraclePriceHandlerHook for Contract {
    fn oracle_on_data(&mut self, price_data: PriceJsonList) {
        let config: Config = self.get_contract_config();

        assert_eq!(
            env::predecessor_account_id(),
            config.oracle_account_id,
            "Oracle account {} doesn't match to the signer {}",
            config.oracle_account_id,
            env::predecessor_account_id()
        );

        let ticker_map = self.get_ticker_map();

        for price in price_data.price_list {
            if let Some(token) = ticker_map.get(&price.ticker_id) {
                self.update_or_insert_price(token.clone(), price.clone())
            }
        }
    }
}

impl Contract {
    pub fn get_ticker_map(&mut self) -> HashMap<String, AccountId> {
        let mut ticker_map = HashMap::new();
        self.supported_markets.values().for_each(|trade_pair| {
            ticker_map.insert(trade_pair.sell_ticker_id, trade_pair.sell_token);
            ticker_map.insert(trade_pair.buy_ticker_id, trade_pair.buy_token);
        });
        ticker_map
    }
}

'''
'''--- contracts/leverage_trading/src/pnl.rs ---
use crate::big_decimal::BigDecimal;
use crate::metadata::{MarketData, Order, PnLView};
use crate::{Contract, OrderStatus};

use near_sdk::json_types::U128;

impl Contract {
    pub fn calculate_pnl_long_order(
        &self,
        order: Order,
        current_buy_token_price: U128,
        market_data: Option<MarketData>,
    ) -> PnLView {
        match order.status {
            OrderStatus::Executed => {
                let borrow_amount =
                    BigDecimal::from(U128(order.amount)) * (order.leverage - BigDecimal::one());

                let amount_before_open = BigDecimal::from(U128(order.amount)) * order.leverage;

                let position_amount = amount_before_open / order.open_or_close_price;

                let swap_fee = BigDecimal::from(self.get_swap_fee(&order));

                let swap_fee_amount =
                    position_amount * BigDecimal::from(current_buy_token_price) * swap_fee;

                let borrow_fee_amount = BigDecimal::from(
                    self.get_borrow_fee_amount(order.clone(), market_data.unwrap()),
                );

                let amount_after_close =
                    position_amount * BigDecimal::from(current_buy_token_price);

                let borrow_and_fees_amounts = borrow_fee_amount + swap_fee_amount + borrow_amount;

                let expect_amount = if amount_after_close > borrow_and_fees_amounts {
                    amount_after_close - borrow_and_fees_amounts
                } else {
                    return PnLView {
                        is_profit: Default::default(),
                        amount: U128(0_u128),
                    };
                };

                let pnl: PnLView = if expect_amount > BigDecimal::from(U128(order.amount)) {
                    let profit = U128::from(expect_amount - BigDecimal::from(U128(order.amount)));

                    PnLView {
                        is_profit: true,
                        amount: profit,
                    }
                } else {
                    let loss = U128::from(BigDecimal::from(U128(order.amount)) - expect_amount);

                    PnLView {
                        is_profit: false,
                        amount: loss,
                    }
                };

                pnl
            }
            _ => PnLView {
                is_profit: true,
                amount: U128(0_u128),
            },
        }
    }

    pub fn calculate_pnl_short_order(
        &self,
        order: Order,
        current_buy_token_price: U128,
        market_data: Option<MarketData>,
    ) -> PnLView {
        match order.status {
            OrderStatus::Executed => {
                let borrow_amount = BigDecimal::from(U128(order.amount))
                    * (order.leverage - BigDecimal::one())
                    / order.open_or_close_price;

                let amount_before_open = borrow_amount;

                let position_amount = amount_before_open * order.open_or_close_price;

                let swap_fee = BigDecimal::from(self.get_swap_fee(&order));

                let swap_fee_amount =
                    position_amount / BigDecimal::from(current_buy_token_price) * swap_fee;

                let borrow_fee_amount =
                    BigDecimal::from(self.get_borrow_fee_amount(order, market_data.unwrap()));

                let amount_after_close =
                    position_amount / BigDecimal::from(current_buy_token_price);

                let fees_amounts = borrow_fee_amount + swap_fee_amount;

                let expect_amount = if amount_after_close > fees_amounts {
                    amount_after_close - fees_amounts
                } else {
                    return PnLView {
                        is_profit: Default::default(),
                        amount: U128(0_u128),
                    };
                };

                let pnl: PnLView = if expect_amount > borrow_amount {
                    let profit = U128::from(
                        (expect_amount - borrow_amount) * BigDecimal::from(current_buy_token_price),
                    );

                    PnLView {
                        is_profit: true,
                        amount: profit,
                    }
                } else {
                    let loss = U128::from(
                        (borrow_amount - expect_amount) * BigDecimal::from(current_buy_token_price),
                    );

                    PnLView {
                        is_profit: false,
                        amount: loss,
                    }
                };

                pnl
            }
            _ => PnLView {
                is_profit: true,
                amount: U128(0_u128),
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::metadata::TradePair;
    use crate::utils::MILLISECONDS_PER_DAY;

    use near_sdk::test_utils::test_env::alice;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, AccountId, VMContext};

    fn get_context(is_view: bool, block_timestamp: Option<u64>) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(103930916)
            .block_timestamp(block_timestamp.unwrap_or(1))
            .is_view(is_view)
            .build()
    }

    fn get_market_data() -> MarketData {
        MarketData {
            underlying_token: AccountId::new_unchecked("usdt.fakes.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        }
    }

    fn get_pair_data() -> TradePair {
        TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(2 * 10_u128.pow(21)),
        }
    }

    fn get_current_day_in_nanoseconds(day: u64) -> Option<u64> {
        let nanoseconds_in_one_millisecond = 1_000_000;
        Some(MILLISECONDS_PER_DAY * day * nanoseconds_in_one_millisecond)
    }

    #[test]
    fn test_calculate_pnl_long_position_with_profit() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = get_pair_data();
        contract.add_pair(pair_data);

        let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_as_string.clone());
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        let market_data = get_market_data();
        let pnl =
            contract.calculate_pnl_long_order(order, current_buy_token_price, Some(market_data));
        assert!(pnl.is_profit);
        assert_eq!(pnl.amount, U128(7654 * 10_u128.pow(23)));
    }

    #[test]
    fn test_calculate_pnl_short_position_with_profit() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = get_pair_data();
        contract.add_pair(pair_data);

        let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Short\",\"amount\":3000000000000000000000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_as_string.clone());
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let current_buy_token_price = U128::from(2 * 10_u128.pow(24)); // current price token

        let market_data = get_market_data();
        let pnl =
            contract.calculate_pnl_short_order(order, current_buy_token_price, Some(market_data));
        assert!(pnl.is_profit);
        assert_eq!(pnl.amount, U128(1128 * 10_u128.pow(24)));
    }

    #[test]
    fn test_calculate_pnl_long_position_without_profit() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = get_pair_data();
        contract.add_pair(pair_data);

        let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_as_string.clone());
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let current_buy_token_price = U128::from(2 * 10_u128.pow(24)); // current price token

        let market_data = get_market_data();
        let pnl =
            contract.calculate_pnl_long_order(order, current_buy_token_price, Some(market_data));
        assert!(!pnl.is_profit);
        assert_eq!(pnl.amount, U128(8314 * 10_u128.pow(23)));
    }

    #[test]
    fn test_calculate_pnl_short_position_without_profit() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = get_pair_data();
        contract.add_pair(pair_data);

        let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Short\",\"amount\":3000000000000000000000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_as_string.clone());
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        let market_data = get_market_data();
        let pnl =
            contract.calculate_pnl_short_order(order, current_buy_token_price, Some(market_data));
        assert!(!pnl.is_profit);
        assert_eq!(pnl.amount, U128(651 * 10_u128.pow(24)));
    }

    #[test]
    fn test_calculate_pnl_not_opened_long_position() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = get_pair_data();
        contract.add_pair(pair_data);

        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
        contract.add_order_from_string(alice(), order_as_string.clone());
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        let market_data = get_market_data();
        let pnl =
            contract.calculate_pnl_long_order(order, current_buy_token_price, Some(market_data));
        assert!(pnl.is_profit);
        assert_eq!(pnl.amount, U128(0_u128));
    }

    #[test]
    fn test_calculate_pnl_not_opened_short_position() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = get_pair_data();
        contract.add_pair(pair_data);

        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Short\",\"amount\":2500000000000000000000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"3.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\"}".to_string();
        contract.add_order_from_string(alice(), order_as_string.clone());
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        let market_data = get_market_data();
        let pnl =
            contract.calculate_pnl_short_order(order, current_buy_token_price, Some(market_data));
        assert!(pnl.is_profit);
        assert_eq!(pnl.amount, U128(0_u128));
    }
}

'''
'''--- contracts/leverage_trading/src/price.rs ---
use crate::big_decimal::BigDecimal;
use crate::*;

#[near_bindgen]
impl Contract {
    #[private]
    pub fn update_or_insert_price(&mut self, token_id: AccountId, price: Price) {
        require!(
            BigDecimal::from(price.value) != BigDecimal::zero(),
            "Token price cannot be zero"
        );

        self.prices.insert(&token_id, &price);
    }

    pub fn get_price(&self, token_id: AccountId) -> BigDecimal {
        BigDecimal::from(
            self.prices
                .get(&token_id)
                .unwrap_or_else(|| {
                    panic!("Price for token: {token_id} not found");
                })
                .value,
        )
    }

    pub fn calculate_xrate(&self, token_id_1: AccountId, token_id_2: AccountId) -> BigDecimal {
        BigDecimal::from(self.view_price(token_id_1).value)
            / BigDecimal::from(self.view_price(token_id_2).value)
    }

    pub fn get_market_by(&self, token: &AccountId) -> AccountId {
        self.tokens_markets.get(token).unwrap_or_else(|| {
            panic!("Market for token: {token} was not found");
        })
    }
}

'''
'''--- contracts/leverage_trading/src/ref_finance.rs ---
use crate::*;
use near_sdk::ext_contract;
use near_sdk::serde::{Deserialize, Serialize};

pub type PoolId = String;
pub type LptId = String;

#[ext_contract(ext_ref_finance)]
trait RefFinanceInterface {
    fn add_liquidity(
        &mut self,
        pool_id: String,
        left_point: i32,
        right_point: i32,
        amount_x: U128,
        amount_y: U128,
        min_amount_x: U128,
        min_amount_y: U128,
    );

    fn remove_liquidity(
        &self,
        lpt_id: LptId,
        amount: U128,
        min_amount_x: U128,
        min_amount_y: U128,
    ) -> (U128, U128);

    fn get_pool(&self, pool_id: PoolId);

    fn get_liquidity(&self, lpt_id: LptId);

    fn withdraw_asset(&mut self, token_id: AccountId, amount: U128);
}

/// Single swap action.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Swap {
    /// Pool which should be used for swapping.
    pub pool_ids: Vec<String>,
    /// Token to swap into.
    pub output_token: AccountId,
    /// Required minimum amount of token_out.
    pub min_output_amount: U128,
}

/// Single action. Allows to execute sequence of various actions initiated by an account.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Action {
    #[allow(non_snake_case)]
    SwapAction { Swap: Swap },
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LiquidityInfo {
    pub lpt_id: LptId,
    pub owner_id: AccountId,
    pub pool_id: String,
    pub left_point: i32,
    pub right_point: i32,
    pub amount: U128,
    pub unclaimed_fee_x: U128,
    pub unclaimed_fee_y: U128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ShortLiquidityInfo {
    pub lpt_id: LptId,
    pub amount: U128,
}

'''
'''--- contracts/leverage_trading/src/utils.rs ---
use crate::*;
use near_sdk::ext_contract;

pub const NO_DEPOSIT: Balance = 0;
pub const PROTOCOL_DECIMALS: u8 = 24;
pub const DAYS_PER_YEAR: u16 = 360;
pub const MILLISECONDS_PER_DAY: u64 = 86400000;

#[ext_contract(ext_token)]
pub trait NEP141Token {
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: WBalance,
        memo: Option<String>,
        msg: String,
    );

    fn ft_transfer(&mut self, receiver_id: AccountId, amount: WBalance, memo: Option<String>);
}

impl Contract {
    pub fn get_order_by(&self, order_id: u128) -> Option<Order> {
        if let Some(account) = self.get_account_by(order_id) {
            self.orders
                .get(&account)
                .unwrap()
                .get(&(order_id as u64))
                .cloned()
        } else {
            None
        }
    }
}

#[ext_contract(ext_market)]
pub trait MarketInterface {
    fn borrow(&mut self, amount: WBalance) -> PromiseOrValue<U128>;
    fn view_market_data(&self) -> MarketData;
}

'''
'''--- contracts/leverage_trading/src/view.rs ---
use crate::big_decimal::{BigDecimal, WRatio};
use crate::utils::{DAYS_PER_YEAR, MILLISECONDS_PER_DAY};
use crate::*;
use near_sdk::env::signer_account_id;
use near_sdk::Gas;

#[near_bindgen]
impl Contract {
    pub fn view_order(
        &self,
        account_id: AccountId,
        order_id: U128,
        borrow_rate_ratio: WRatio,
    ) -> OrderView {
        let orders = self.orders.get(&account_id).unwrap_or_else(|| {
            panic!("Orders for account: {account_id} not found");
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();

        let swap_fee = self.get_swap_fee(&order);

        let borrow_fee = WBigDecimal::from(
            BigDecimal::from(borrow_rate_ratio)
                * BigDecimal::from(U128(env::block_height() as u128 - order.block as u128)),
        );

        OrderView {
            order_id,
            status: order.status,
            order_type: order.order_type,
            amount: U128(order.amount),
            sell_token: order.sell_token,
            sell_token_price: order.sell_token_price.value,
            buy_token: order.buy_token,
            buy_token_price: order.buy_token_price.value,
            leverage: WBigDecimal::from(order.leverage),
            borrow_fee,
            liquidation_price: self.calculate_liquidation_price(
                U128(order.amount),
                order.sell_token_price.value,
                order.buy_token_price.value,
                WBigDecimal::from(order.leverage),
                borrow_fee,
                swap_fee,
            ),
            lpt_id: order.lpt_id,
        }
    }

    pub fn calculate_pnl(
        &self,
        account_id: AccountId,
        order_id: U128,
        current_buy_token_price: U128,
        market_data: Option<MarketData>,
    ) -> PnLView {
        let orders = self.orders.get(&account_id).unwrap_or_else(|| {
            panic!("Orders for account: {account_id} not found");
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();

        match order.order_type {
            OrderType::Long => {
                self.calculate_pnl_long_order(order, current_buy_token_price, market_data)
            }
            OrderType::Short => {
                self.calculate_pnl_short_order(order, current_buy_token_price, market_data)
            }
            _ => panic!("PnL calculation only for 'Long' and 'Short' order types"),
        }
    }

    pub fn view_orders(
        &self,
        account_id: AccountId,
        sell_token: AccountId,
        buy_token: AccountId,
        borrow_rate_ratio: WRatio,
    ) -> Vec<OrderView> {
        let orders = self.orders.get(&account_id).unwrap_or_default();
        let result = orders
            .iter()
            .filter_map(|(id, order)| {
                match order.sell_token == sell_token && order.buy_token == buy_token {
                    true => {
                        let swap_fee = self.get_swap_fee(order);

                        let borrow_fee = WBigDecimal::from(
                            BigDecimal::from(borrow_rate_ratio)
                                * BigDecimal::from(U128(
                                    env::block_height() as u128 - order.block as u128,
                                )),
                        );

                        Some(OrderView {
                            order_id: U128(*id as u128),
                            status: order.status.clone(),
                            order_type: order.order_type.clone(),
                            amount: U128(order.amount),
                            sell_token: order.sell_token.clone(),
                            sell_token_price: order.sell_token_price.value,
                            buy_token: order.buy_token.clone(),
                            buy_token_price: order.buy_token_price.value,
                            leverage: WBigDecimal::from(order.leverage),
                            borrow_fee,
                            liquidation_price: self.calculate_liquidation_price(
                                U128(order.amount),
                                order.sell_token_price.value,
                                order.buy_token_price.value,
                                WBigDecimal::from(order.leverage),
                                borrow_fee,
                                swap_fee,
                            ),
                            lpt_id: order.lpt_id.clone(),
                        })
                    }
                    false => None,
                }
            })
            .collect::<Vec<OrderView>>();
        result
    }

    pub fn get_trade_pair(&self, sell_token: &AccountId, buy_token: &AccountId) -> TradePair {
        let pair = PairId {
            sell_token: sell_token.clone(),
            buy_token: buy_token.clone(),
        };
        self.supported_markets
            .get(&pair)
            .unwrap_or_else(|| panic!("Pair {sell_token}|{buy_token} not found"))
    }

    pub fn view_pairs(&self) -> Vec<PairId> {
        let pairs = self
            .supported_markets
            .iter()
            .map(|(pair_id, _)| pair_id)
            .collect::<Vec<PairId>>();

        pairs
    }

    pub fn view_supported_pairs(&self) -> Vec<TradePairView> {
        let pairs = self
            .supported_markets
            .iter()
            .map(|(pair_id, trade_pair)| TradePairView {
                pair_id,
                pair_tickers_id: format!(
                    "{}-{}",
                    trade_pair.sell_ticker_id, trade_pair.buy_ticker_id
                ),
                sell_ticker_id: trade_pair.sell_ticker_id,
                sell_token: trade_pair.sell_token,
                sell_token_decimals: trade_pair.sell_token_decimals,
                sell_token_market: trade_pair.sell_token_market,
                buy_ticker_id: trade_pair.buy_ticker_id,
                buy_token: trade_pair.buy_token,
                buy_token_decimals: trade_pair.buy_token_decimals,
                buy_token_market: trade_pair.buy_token_market,
                pool_id: trade_pair.pool_id,
                max_leverage: trade_pair.max_leverage,
                swap_fee: trade_pair.swap_fee,
            })
            .collect::<Vec<TradePairView>>();

        pairs
    }

    /// Returns the balance of the given account on certain token. If the account doesn't exist will return `"0"`.
    pub fn balance_of(&self, account_id: AccountId, token: AccountId) -> WBalance {
        match self.balances.get(&account_id) {
            None => WBalance::from(0_u128),
            Some(user_balance_per_token) => {
                WBalance::from(*user_balance_per_token.get(&token).unwrap_or(&0_u128))
            }
        }
    }

    /// Returns price of the given token. If the token is not registered, will return `"0"`.
    pub fn view_price(&self, token_id: AccountId) -> Price {
        self.prices.get(&token_id).unwrap_or_else(|| {
            panic!("Price for token: {token_id} not found");
        })
    }

    pub fn cancel_order_view(
        &self,
        account_id: AccountId,
        order_id: U128,
        current_buy_token_price: U128,
        market_data: MarketData,
    ) -> CancelOrderView {
        let orders = self.orders.get(&account_id).unwrap_or_else(|| {
            panic!("Orders for account: {account_id} not found");
        });

        let order = orders.get(&(order_id.0 as u64)).unwrap_or_else(|| {
            panic!("Order with id: {} not found", order_id.0);
        });

        let buy_token = BigDecimal::from(U128(order.amount))
            * order.leverage
            * BigDecimal::from(order.sell_token_price.value)
            / BigDecimal::from(order.buy_token_price.value);

        let sell_token = BigDecimal::from(U128(order.amount)) * order.leverage;

        let open_or_close_price = order.buy_token_price.clone();

        let close_price = self.get_price(order.buy_token.clone());

        let calc_pnl = self.calculate_pnl(
            account_id,
            order_id,
            current_buy_token_price,
            Some(market_data),
        );

        CancelOrderView {
            buy_token_amount: WRatio::from(buy_token),
            sell_token_amount: WRatio::from(sell_token),
            open_or_close_price: open_or_close_price.value,
            close_price: WRatio::from(close_price),
            pnl: calc_pnl,
        }
    }

    pub fn view_liquidation_threshold(&self) -> U128 {
        U128(self.liquidation_threshold)
    }

    pub fn calculate_liquidation_price(
        &self,
        sell_token_amount: U128,
        sell_token_price: U128,
        buy_token_price: U128,
        leverage: U128,
        borrow_fee: U128,
        swap_fee: U128,
    ) -> WBigDecimal {
        require!(
            sell_token_price != U128::from(0),
            "Sell token price cannot be zero"
        );

        require!(
            buy_token_price != U128::from(0),
            "Buy token price cannot be zero"
        );

        let collateral_usd =
            BigDecimal::from(sell_token_amount) * BigDecimal::from(sell_token_price);
        let position_amount_usd = collateral_usd * BigDecimal::from(leverage);
        let borrow_amount = collateral_usd * (BigDecimal::from(leverage) - BigDecimal::one());
        let buy_amount = position_amount_usd / BigDecimal::from(buy_token_price);

        let liquidation_price = (position_amount_usd - self.volatility_rate * collateral_usd
            + borrow_amount * BigDecimal::from(borrow_fee)
            + position_amount_usd * BigDecimal::from(swap_fee))
            / buy_amount;

        liquidation_price.into()
    }

    /// returns const gas amount required for executing orders: 50 TGas
    pub fn view_gas_for_execution(&self) -> Balance {
        Gas::ONE_TERA.0 as Balance * 50u128
    }

    pub fn view_max_position_amount(&self) -> U128 {
        U128(self.max_order_amount)
    }

    pub fn get_total_pending_orders_per_pair(&self, pair_id: &PairId) -> U128 {
        self.get_trade_pair(&pair_id.sell_token, &pair_id.buy_token);

        let orders = self.orders_per_pair_view.get(pair_id).unwrap_or_default();

        let pending_orders = orders
            .iter()
            .filter_map(|(id, order)| match order.status == OrderStatus::Pending {
                true => Some((*id, order.clone())),
                false => match self.take_profit_orders.get(id) {
                    Some((_, tp_order, _)) => {
                        if tp_order.status == OrderStatus::Pending {
                            Some((*id, tp_order))
                        } else {
                            None
                        }
                    }
                    None => None,
                },
            })
            .collect::<HashMap<u64, Order>>();

        let total = pending_orders.len();
        U128(total as u128)
    }

    pub fn get_pending_orders(
        &self,
        pair_id: &PairId,
        orders_per_page: U128,
        page: U128,
    ) -> PendingOrders {
        self.get_trade_pair(&pair_id.sell_token, &pair_id.buy_token);

        let orders = self.orders_per_pair_view.get(pair_id).unwrap_or_default();
        let mut pending_orders = orders
            .iter()
            .filter_map(|(id, order)| match order.status == OrderStatus::Pending {
                true => Some((*id, order.clone())),
                false => match self.take_profit_orders.get(id) {
                    Some((_, tp_order, _)) => {
                        if tp_order.status == OrderStatus::Pending {
                            Some((*id, tp_order))
                        } else {
                            None
                        }
                    }
                    None => None,
                },
            })
            .collect::<Vec<(u64, Order)>>();

        pending_orders.sort_by(|a, b| a.0.cmp(&b.0));

        let total = U128(pending_orders.len() as u128);

        let sort_pending_orders = pending_orders
            .into_iter()
            .skip((orders_per_page.0 * page.0 - orders_per_page.0) as usize)
            .take(orders_per_page.0 as usize)
            .collect();

        PendingOrders {
            data: sort_pending_orders,
            page,
            total,
        }
    }

    pub fn view_pair_tokens_decimals(
        &self,
        sell_token: &AccountId,
        buy_token: &AccountId,
    ) -> (u8, u8) {
        let pair_id = PairId {
            sell_token: sell_token.clone(),
            buy_token: buy_token.clone(),
        };

        let pair = self.supported_markets.get(&pair_id).unwrap_or_else(|| {
            panic!("Sell and Buy token decimals for pair {sell_token}|{buy_token} not found",)
        });

        (pair.sell_token_decimals, pair.buy_token_decimals)
    }

    pub fn view_token_decimals(&self, token: &AccountId) -> u8 {
        let pair_id = self
            .supported_markets
            .keys()
            .find(|pair| pair.sell_token == token.clone() || pair.buy_token == token.clone());
        if let Some(PairId {
            sell_token,
            buy_token,
        }) = pair_id
        {
            let (sell_token_decimals, buy_token_decimals) =
                self.view_pair_tokens_decimals(&sell_token, &buy_token);
            if token == &sell_token {
                sell_token_decimals
            } else {
                buy_token_decimals
            }
        } else {
            panic!("Token is not supported");
        }
    }

    pub fn view_pending_limit_orders_by_user(
        &self,
        account_id: AccountId,
        orders_per_page: U128,
        page: U128,
    ) -> LimitOrders {
        let orders = self.orders.get(&account_id).unwrap_or_default();

        let mut pending_limit_orders = orders
            .iter()
            .filter_map(|(id, order)| {
                match order.status == OrderStatus::Pending && order.leverage == BigDecimal::one() {
                    true => self.get_pending_limit_order(id, order),
                    false => None,
                }
            })
            .collect::<Vec<LimitOrderView>>();

        pending_limit_orders.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));

        let total_orders = U128(pending_limit_orders.len() as u128);

        let sort_pending_orders = pending_limit_orders
            .into_iter()
            .skip((orders_per_page.0 * page.0 - orders_per_page.0) as usize)
            .take(orders_per_page.0 as usize)
            .collect();

        LimitOrders {
            data: sort_pending_orders,
            page,
            total_orders,
        }
    }

    pub fn view_pending_limit_orders_by_user_by_pair(
        &self,
        account_id: AccountId,
        sell_token: AccountId,
        buy_token: AccountId,
        orders_per_page: U128,
        page: U128,
    ) -> LimitOrders {
        let orders = self.orders.get(&account_id).unwrap_or_default();

        let mut pending_limit_orders = orders
            .iter()
            .filter_map(|(id, order)| {
                match order.status == OrderStatus::Pending
                    && order.leverage == BigDecimal::one()
                    && order.sell_token == sell_token
                    && order.buy_token == buy_token
                {
                    true => self.get_pending_limit_order(id, order),
                    false => None,
                }
            })
            .collect::<Vec<LimitOrderView>>();

        pending_limit_orders.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));

        let total_orders = U128(pending_limit_orders.len() as u128);

        let sort_pending_limit_orders = pending_limit_orders
            .into_iter()
            .skip((orders_per_page.0 * page.0 - orders_per_page.0) as usize)
            .take(orders_per_page.0 as usize)
            .collect();

        LimitOrders {
            data: sort_pending_limit_orders,
            page,
            total_orders,
        }
    }

    pub fn view_opened_leverage_positions_by_user(
        &self,
        account_id: AccountId,
        current_buy_token_price: U128,
        market_data: Option<MarketData>,
        positions_per_page: U128,
        page: U128,
    ) -> LeveragedPositions {
        let orders = self.orders.get(&account_id).unwrap_or_default();

        let mut pending_limit_orders = orders
            .iter()
            .filter_map(|(id, order)| {
                match order.status == OrderStatus::Pending && order.leverage != BigDecimal::one()
                    || order.status == OrderStatus::Executed && order.leverage != BigDecimal::one()
                {
                    true => self.get_opened_leverage_position(
                        account_id.clone(),
                        id,
                        order,
                        current_buy_token_price,
                        market_data.clone(),
                    ),
                    false => None,
                }
            })
            .collect::<Vec<LeveragedPositionView>>();

        pending_limit_orders.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));

        let total_positions = U128(pending_limit_orders.len() as u128);

        let sort_pending_orders = pending_limit_orders
            .into_iter()
            .skip((positions_per_page.0 * page.0 - positions_per_page.0) as usize)
            .take(positions_per_page.0 as usize)
            .collect();

        LeveragedPositions {
            data: sort_pending_orders,
            page,
            total_positions,
        }
    }

    pub fn view_opened_leverage_positions_by_user_by_pair(
        &self,
        account_id: AccountId,
        sell_token: AccountId,
        buy_token: AccountId,
        current_buy_token_price: U128,
        market_data: Option<MarketData>,
        positions_per_page: U128,
        page: U128,
    ) -> LeveragedPositions {
        let orders = self.orders.get(&account_id).unwrap_or_default();

        let mut pending_limit_orders = orders
            .iter()
            .filter_map(|(id, order)| {
                match order.status == OrderStatus::Pending
                    && order.leverage != BigDecimal::one()
                    && order.sell_token == sell_token
                    && order.buy_token == buy_token
                    || order.status == OrderStatus::Executed
                        && order.leverage != BigDecimal::one()
                        && order.sell_token == sell_token
                        && order.buy_token == buy_token
                {
                    true => self.get_opened_leverage_position(
                        account_id.clone(),
                        id,
                        order,
                        current_buy_token_price,
                        market_data.clone(),
                    ),
                    false => None,
                }
            })
            .collect::<Vec<LeveragedPositionView>>();

        pending_limit_orders.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));

        let total_positions = U128(pending_limit_orders.len() as u128);

        let sort_pending_orders = pending_limit_orders
            .into_iter()
            .skip((positions_per_page.0 * page.0 - positions_per_page.0) as usize)
            .take(positions_per_page.0 as usize)
            .collect();

        LeveragedPositions {
            data: sort_pending_orders,
            page,
            total_positions,
        }
    }

    pub fn take_profit_order_view(&self, order_id: U128) -> Option<TakeProfitOrderView> {
        require!(
            Some(signer_account_id()) == self.get_account_by(order_id.0),
            "You have no access for this order."
        );

        if let Some((_, order, _)) = self.take_profit_orders.get(&(order_id.0 as u64)) {
            let trade_pair = self.get_trade_pair(&order.sell_token, &order.buy_token);

            let pair = format!("{}/{}", trade_pair.sell_ticker_id, trade_pair.buy_ticker_id);

            let leverage_positions = self
                .orders_per_pair_view
                .get(&PairId {
                    sell_token: trade_pair.sell_token,
                    buy_token: trade_pair.buy_token,
                })
                .unwrap();

            let leverage_position = leverage_positions.get(&(order_id.0 as u64)).unwrap();

            let total = if order.order_type == OrderType::Long {
                BigDecimal::from(U128(leverage_position.amount)) * leverage_position.leverage
            } else {
                BigDecimal::from(U128(leverage_position.amount))
                    * (leverage_position.leverage - BigDecimal::one())
            };

            Some(TakeProfitOrderView {
                timestamp: order.timestamp_ms,
                pair,
                order_type: order.order_type.clone(),
                price: WBigDecimal::from(order.open_or_close_price),
                amount: U128(order.amount),
                filled: (order.status == OrderStatus::Executed).into(),
                total: LowU128::from(total),
            })
        } else {
            None
        }
    }

    pub fn calculate_short_liquidation_price(
        &self,
        sell_token_amount: U128,
        buy_token_amount: U128,
        open_price: U128,
        leverage: U128,
        borrow_fee: U128,
        swap_fee: U128,
    ) -> U128 {
        let sell_token_amount = BigDecimal::from(sell_token_amount);
        let buy_token_amount = BigDecimal::from(buy_token_amount);
        let open_price = BigDecimal::from(open_price);
        let leverage = BigDecimal::from(leverage);
        let borrow_fee = BigDecimal::from(borrow_fee);
        let swap_fee = BigDecimal::from(swap_fee);

        let borrow_amount = sell_token_amount * (leverage - BigDecimal::one()) / open_price;
        let borrow_period = BigDecimal::one();

        let liquidation_price = (sell_token_amount
            + self.volatility_rate * buy_token_amount * open_price
            - borrow_amount * borrow_period * borrow_fee
            - borrow_amount * swap_fee)
            / buy_token_amount;

        U128::from(liquidation_price)
    }

    pub fn calculate_long_liquidation_price(
        &self,
        sell_token_amount: U128,
        open_price: U128,
        leverage: U128,
        borrow_fee: U128,
        swap_fee: U128,
    ) -> U128 {
        let sell_token_amount = BigDecimal::from(sell_token_amount);
        let open_price = BigDecimal::from(open_price);
        let leverage = BigDecimal::from(leverage);
        let borrow_fee = BigDecimal::from(borrow_fee);
        let swap_fee = BigDecimal::from(swap_fee);

        let borrow_amount = sell_token_amount * (leverage - BigDecimal::one());
        let borrow_period = BigDecimal::one();
        let days_per_year = BigDecimal::from(U128::from(
            DAYS_PER_YEAR as u128 * 10u128.pow(PROTOCOL_DECIMALS.into()),
        ));
        let buy_token_amount = (sell_token_amount + borrow_amount) / open_price;

        let liquidation_price = open_price
            - self.volatility_rate
                * (sell_token_amount
                    - borrow_amount * (borrow_period * borrow_fee / days_per_year)
                    - borrow_amount * swap_fee)
                / buy_token_amount;

        U128::from(liquidation_price)
    }

    pub fn view_order_by_id(&self, order_id: U128, borrow_rate_ratio: U128) -> Option<OrderView> {
        if let Some((_, order)) = self.get_order_by_id(order_id) {
            return Some(self.get_order_view(order_id, order, borrow_rate_ratio));
        }
        None
    }

    pub fn view_take_profit_order_by_id(
        &self,
        order_id: U128,
        borrow_rate_ratio: U128,
    ) -> Option<OrderView> {
        if let Some(order) = self.get_take_profit_order_by_id(order_id) {
            return Some(self.get_order_view(order_id, order, borrow_rate_ratio));
        }
        None
    }
}

impl Contract {
    pub fn get_order_view(
        &self,
        order_id: U128,
        order: Order,
        borrow_rate_ratio: U128,
    ) -> OrderView {
        let borrow_fee = self.calculate_borrow_fee(order.timestamp_ms, borrow_rate_ratio);
        let swap_fee = self.get_swap_fee(&order);

        let liquidation_price = match order.order_type {
            OrderType::Long => self.calculate_long_liquidation_price(
                U128::from(order.amount),
                U128::from(order.open_or_close_price),
                U128::from(order.leverage),
                borrow_fee,
                swap_fee,
            ),
            OrderType::Short => {
                let borrow_amount = BigDecimal::from(U128::from(order.amount))
                    * (order.leverage - BigDecimal::one())
                    / order.open_or_close_price;
                let buy_token_amount = BigDecimal::from(U128::from(order.amount)) * borrow_amount;

                self.calculate_short_liquidation_price(
                    U128::from(order.amount),
                    U128::from(buy_token_amount),
                    U128::from(order.open_or_close_price),
                    U128::from(order.leverage),
                    borrow_fee,
                    swap_fee,
                )
            }
            _ => U128::from(0),
        };

        OrderView {
            order_id,
            status: order.status,
            order_type: order.order_type,
            amount: U128::from(order.amount),
            sell_token: order.sell_token,
            sell_token_price: order.sell_token_price.value,
            buy_token: order.buy_token,
            buy_token_price: order.buy_token_price.value,
            leverage: U128::from(order.leverage),
            borrow_fee,
            liquidation_price,
            lpt_id: order.lpt_id,
        }
    }

    pub fn calculate_borrow_fee(&self, order_timestamp_ms: u64, borrow_rate_ratio: U128) -> U128 {
        let current_timestamp_ms = env::block_timestamp_ms();

        let borrow_period = ((current_timestamp_ms - order_timestamp_ms) as f64
            / MILLISECONDS_PER_DAY as f64)
            .ceil();

        U128::from(
            BigDecimal::from(borrow_rate_ratio)
                / BigDecimal::from(U128::from(DAYS_PER_YEAR as u128))
                * BigDecimal::from(U128::from(borrow_period as u128)),
        )
    }

    pub fn get_pending_limit_order(&self, order_id: &u64, order: &Order) -> Option<LimitOrderView> {
        let trade_pair = self.get_trade_pair(&order.sell_token, &order.buy_token);

        let pair = format!("{}/{}", trade_pair.sell_ticker_id, trade_pair.buy_ticker_id);

        let total = if order.order_type == OrderType::Buy {
            BigDecimal::from(U128(order.amount))
        } else {
            BigDecimal::from(U128(order.amount)) * order.open_or_close_price
        };

        Some(LimitOrderView {
            order_id: U128(*order_id as u128),
            timestamp: order.timestamp_ms,
            pair,
            order_type: "Limit".to_string(),
            side: order.order_type.clone(),
            price: WBigDecimal::from(order.open_or_close_price),
            amount: U128(order.amount),
            filled: (order.status == OrderStatus::Executed).into(),
            total: LowU128::from(total),
        })
    }

    pub fn get_opened_leverage_position(
        &self,
        account_id: AccountId,
        order_id: &u64,
        order: &Order,
        current_buy_token_price: U128,
        market_data: Option<MarketData>,
    ) -> Option<LeveragedPositionView> {
        let trade_pair = self.get_trade_pair(&order.sell_token, &order.buy_token);

        let pair = format!("{}/{}", trade_pair.sell_ticker_id, trade_pair.buy_ticker_id);

        let total = if order.order_type == OrderType::Long {
            BigDecimal::from(U128(order.amount)) * order.leverage
        } else {
            BigDecimal::from(U128(order.amount)) * (order.leverage - BigDecimal::one())
        };

        let pnl = self.calculate_pnl(
            account_id,
            U128(*order_id as u128),
            current_buy_token_price,
            market_data,
        );

        let take_profit_order = self.get_take_profit_order(order_id, order);

        Some(LeveragedPositionView {
            order_id: U128(*order_id as u128),
            timestamp: order.timestamp_ms,
            pair,
            order_type: order.order_type.clone(),
            price: WBigDecimal::from(order.open_or_close_price),
            leverage: WBigDecimal::from(order.leverage),
            amount: U128(order.amount),
            filled: (order.status == OrderStatus::Executed).into(),
            total: LowU128::from(total),
            pnl,
            take_profit_order,
        })
    }

    pub fn get_take_profit_order(
        &self,
        order_id: &u64,
        leverage_position: &Order,
    ) -> Option<TakeProfitOrderView> {
        match self.take_profit_orders.get(order_id) {
            Some((_, order, _)) => {
                if order.status == OrderStatus::Pending
                    || order.status == OrderStatus::PendingOrderExecute
                {
                    let trade_pair = self.get_trade_pair(&order.sell_token, &order.buy_token);

                    let pair =
                        format!("{}/{}", trade_pair.sell_ticker_id, trade_pair.buy_ticker_id);

                    let total = if leverage_position.order_type == OrderType::Long {
                        BigDecimal::from(U128(leverage_position.amount))
                            * leverage_position.leverage
                    } else {
                        BigDecimal::from(U128(leverage_position.amount))
                            * (leverage_position.leverage - BigDecimal::one())
                    };

                    Some(TakeProfitOrderView {
                        timestamp: order.timestamp_ms,
                        pair,
                        order_type: order.order_type.clone(),
                        price: WBigDecimal::from(order.open_or_close_price),
                        amount: U128(order.amount),
                        filled: (order.status == OrderStatus::Executed).into(),
                        total: LowU128::from(total),
                    })
                } else {
                    None
                }
            }
            None => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::utils::MILLISECONDS_PER_DAY;

    use super::*;

    use near_sdk::test_utils::test_env::{alice, bob};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool, block_timestamp: Option<u64>) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(103930916)
            .block_timestamp(block_timestamp.unwrap_or(1))
            .is_view(is_view)
            .build()
    }

    fn get_current_day_in_nanoseconds(day: u64) -> Option<u64> {
        let nanoseconds_in_one_millisecond = 1_000_000;
        Some(MILLISECONDS_PER_DAY * day * nanoseconds_in_one_millisecond)
    }

    fn get_market_data() -> MarketData {
        MarketData {
            underlying_token: AccountId::new_unchecked("usdt.qa.v1.nearlend.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        }
    }

    #[test]
    fn test_get_total_pending_orders_per_pair() {
        let current_day = get_current_day_in_nanoseconds(6); // borrow period 5 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_id = PairId {
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        let market_data = get_market_data();

        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDT".to_string(),
                value: U128::from(101 * 10_u128.pow(22)),
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "WNEAR".to_string(),
                value: U128::from(305 * 10_u128.pow(22)),
            },
        );

        contract.add_pair(pair_data);

        contract.set_balance(&alice(), &pair_id.sell_token, 10_u128.pow(30));

        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930910,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#540\"}".to_string();
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        assert_eq!(
            contract.get_total_pending_orders_per_pair(&pair_id),
            U128(0_u128)
        );

        for count in 1..10 {
            if count <= 6 {
                contract.imitation_add_liquidity_callback(order.clone());

                if count < 3 {
                    contract.create_take_profit_order(
                        U128(count),
                        U128(3 * 10_u128.pow(24)),
                        -9860,
                        -9820,
                        market_data.clone(),
                    );
                }
            } else {
                let order_id = count - 6;
                contract.mark_order_as_executed(order.clone(), U128(order_id));

                if count < 8 {
                    let (price_points, mut tp_order, return_amounts) =
                        contract.take_profit_orders.get(&(order_id as u64)).unwrap();

                    tp_order.status = OrderStatus::Pending;

                    contract.take_profit_orders.insert(
                        &(order_id as u64),
                        &(price_points, tp_order, return_amounts),
                    );
                };
            }
        }
        // total pending orders after creating orders
        assert_eq!(
            contract.get_total_pending_orders_per_pair(&pair_id),
            U128(4_u128)
        );
    }

    #[test]
    fn test_get_pending_orders() {
        let current_day = get_current_day_in_nanoseconds(6); // borrow period 5 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_id = PairId {
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        let market_data = get_market_data();

        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDT".to_string(),
                value: U128::from(1010000000000000000000000),
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "WNEAR".to_string(),
                value: U128::from(3050000000000000000000000),
            },
        );

        contract.add_pair(pair_data);

        contract.set_balance(&alice(), &pair_id.sell_token, 10_u128.pow(30));

        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930910,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#540\",\"history_data\":null}".to_string();
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        for count in 1..10 {
            if count <= 6 {
                contract.imitation_add_liquidity_callback(order.clone());

                if count < 3 {
                    contract.create_take_profit_order(
                        U128(count),
                        U128(3 * 10_u128.pow(24)),
                        -9860,
                        -9820,
                        market_data.clone(),
                    );
                }
            } else {
                let order_id = count - 6;
                contract.mark_order_as_executed(order.clone(), U128(order_id));

                if count < 8 {
                    let (price_points, mut tp_order, return_amounts) =
                        contract.take_profit_orders.get(&(order_id as u64)).unwrap();

                    tp_order.status = OrderStatus::Pending;

                    contract.take_profit_orders.insert(
                        &(order_id as u64),
                        &(price_points, tp_order, return_amounts),
                    );
                };
            }
        }

        let pending_orders_par_1st_page = contract.get_pending_orders(&pair_id, U128(10), U128(1));
        let order_id_with_pending_status = pending_orders_par_1st_page
            .data
            .iter()
            .map(|(order_id, _)| *order_id)
            .collect::<Vec<u64>>();

        assert_eq!(
            contract.orders_per_pair_view.get(&pair_id).unwrap().len(),
            6_usize
        );
        assert_eq!(pending_orders_par_1st_page.data.len(), 4_usize);
        assert_eq!(
            pending_orders_par_1st_page.data.get(0).unwrap().1.status,
            OrderStatus::Pending
        );
        assert_eq!(
            pending_orders_par_1st_page
                .data
                .get(0)
                .unwrap()
                .1
                .order_type,
            OrderType::TakeProfit
        );
        assert_eq!(
            pending_orders_par_1st_page
                .data
                .get(2)
                .unwrap()
                .1
                .order_type,
            OrderType::Long
        );
        assert_eq!(pending_orders_par_1st_page.total, U128(4));
        assert_eq!(order_id_with_pending_status, vec![1, 4, 5, 6]);

        let pending_orders_par_2nd_page = contract.get_pending_orders(&pair_id, U128(10), U128(2));

        assert_eq!(pending_orders_par_2nd_page.data.len(), 0_usize);
    }

    #[test]
    fn view_supported_pairs_test() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );
        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        let pair_data2 = TradePair {
            sell_ticker_id: "near".to_string(),
            sell_token: "wrap.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "USDt".to_string(),
            buy_token: "usdt.fakes.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data2.clone());

        let pair_data_view = TradePairView {
            pair_id: PairId {
                sell_token: "usdt.fakes.testnet".parse().unwrap(),
                buy_token: "wrap.testnet".parse().unwrap(),
            },
            pair_tickers_id: "USDt-near".to_string(),
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        let pair_data2_view = TradePairView {
            pair_id: PairId {
                sell_token: "wrap.testnet".parse().unwrap(),
                buy_token: "usdt.fakes.testnet".parse().unwrap(),
            },
            pair_tickers_id: "near-USDt".to_string(),
            sell_ticker_id: "near".to_string(),
            sell_token: "wrap.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "USDt".to_string(),
            buy_token: "usdt.fakes.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data2);

        let result = vec![pair_data_view, pair_data2_view];
        let pairs = contract.view_supported_pairs();
        assert_eq!(result, pairs);
    }

    #[test]
    fn test_calculate_pnl() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(2 * 10_u128.pow(21)),
        };
        contract.add_pair(pair_data);

        let order = "{\"status\":\"Executed\",\"order_type\":\"Long\",\"amount\":1500000000000000000000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order);

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        let market_data = MarketData {
            underlying_token: AccountId::new_unchecked("usdt.fakes.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        };

        let pnl =
            contract.calculate_pnl(alice(), U128(1), current_buy_token_price, Some(market_data));
        assert!(pnl.is_profit);
        assert_eq!(pnl.amount, U128(8517 * 10_u128.pow(23)));
    }

    #[test]
    fn test_calculate_liquidation_leverage_3() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        let result = contract.calculate_liquidation_price(
            U128(10_u128.pow(27)),
            U128(10_u128.pow(24)),
            U128(10_u128.pow(25)),
            U128(3 * 10_u128.pow(24)),
            U128(5 * 10_u128.pow(22)),
            U128(3 * 10_u128.pow(20)),
        );

        assert_eq!(result, U128(7169666666666666666666666));
    }

    #[test]
    fn test_calculate_liquidation_leverage_1_5() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        let result = contract.calculate_liquidation_price(
            U128(10_u128.pow(27)),
            U128(10_u128.pow(24)),
            U128(10_u128.pow(25)),
            U128(15 * 10_u128.pow(23)),
            U128(5 * 10_u128.pow(22)),
            U128(3 * 10_u128.pow(20)),
        );

        assert_eq!(result, U128(3836333333333333333333333));
    }

    #[test]
    fn test_view_order() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(10u128.pow(23)),
        };
        contract.add_pair(pair_data.clone());

        let borrow_rate_ratio = U128(634273735391536);

        let order1 = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930910,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#540\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order1);

        let order2 = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930910,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#541\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order2);

        let order_id = U128(1); //order_id for order1

        let block_order = 103930910_u64;

        let borrow_fee = WBigDecimal::from(
            BigDecimal::from(borrow_rate_ratio)
                * BigDecimal::from(U128(env::block_height() as u128 - block_order as u128)),
        );

        let liquidation_price = contract.calculate_liquidation_price(
            U128(10_u128.pow(9)),
            U128(101 * 10_u128.pow(22)),
            U128(305 * 10_u128.pow(22)),
            U128(10_u128.pow(24)),
            borrow_fee,
            pair_data.swap_fee, // hardcore of swap_fee 0.1 % with 10^24 precision
        );

        let result_view_order1 = OrderView {
            order_id: U128(1),
            status: OrderStatus::Pending,
            order_type: OrderType::Buy,
            amount: U128(10_u128.pow(9)),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_price: U128(101 * 10_u128.pow(22)), // 1.01 with 10^24 precision
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_price: U128(305 * 10_u128.pow(22)), // 3.05 with 10^24 precision
            leverage: U128(10_u128.pow(24)),              // 1 with 10^24 precision
            borrow_fee,
            liquidation_price,
            lpt_id: "usdt.fakes.testnet|wrap.testnet|2000#540".to_string(),
        };

        assert_eq!(
            contract.view_order(alice(), order_id, borrow_rate_ratio),
            result_view_order1
        );
    }

    #[test]
    fn test_view_orders() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "USDt".to_string(),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            buy_ticker_id: "near".to_string(),
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.fakes.testnet|wrap.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(10u128.pow(23)),
        };
        contract.add_pair(pair_data.clone());

        let borrow_rate_ratio = U128(634273735391536);

        let order1 = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930910,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#540\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order1);

        let order2 = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930911,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#541\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order2);

        let order3 = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000,\"sell_token\":\"usdt.fakes.testnet\",\"buy_token\":\"wrap.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3050000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930912,\"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#542\",\"history_data\":null}".to_string();
        contract.add_order_from_string(bob(), order3);

        let block_order1 = 103930910_u64;
        let block_order2 = 103930911_u64;
        let block_order3 = 103930912_u64;

        let borrow_fee_order1 = WBigDecimal::from(
            BigDecimal::from(borrow_rate_ratio)
                * BigDecimal::from(U128(env::block_height() as u128 - block_order1 as u128)),
        );

        let borrow_fee_order2 = WBigDecimal::from(
            BigDecimal::from(borrow_rate_ratio)
                * BigDecimal::from(U128(env::block_height() as u128 - block_order2 as u128)),
        );

        let borrow_fee_order3 = WBigDecimal::from(
            BigDecimal::from(borrow_rate_ratio)
                * BigDecimal::from(U128(env::block_height() as u128 - block_order3 as u128)),
        );

        let liquidation_price_order1 = contract.calculate_liquidation_price(
            U128(10_u128.pow(9)),
            U128(101 * 10_u128.pow(22)),
            U128(305 * 10_u128.pow(22)),
            U128(10_u128.pow(24)),
            borrow_fee_order1,
            pair_data.swap_fee, // hardcore of swap_fee 0.1 % with 10^24 precision
        );

        let liquidation_price_order2 = contract.calculate_liquidation_price(
            U128(2 * 10_u128.pow(9)),
            U128(101 * 10_u128.pow(22)),
            U128(305 * 10_u128.pow(22)),
            U128(10_u128.pow(24)),
            borrow_fee_order2,
            pair_data.swap_fee, // hardcore of swap_fee 0.1 % with 10^24 precision
        );

        let liquidation_price_order3 = contract.calculate_liquidation_price(
            U128(2 * 10_u128.pow(9)),
            U128(101 * 10_u128.pow(22)),
            U128(305 * 10_u128.pow(22)),
            U128(10_u128.pow(24)),
            borrow_fee_order3,
            pair_data.swap_fee, // hardcore of swap_fee 0.1 % with 10^24 precision
        );

        let result_view_orders_alice = vec![
            OrderView {
                order_id: U128(1),
                status: OrderStatus::Pending,
                order_type: OrderType::Buy,
                amount: U128(10_u128.pow(9)),
                sell_token: "usdt.fakes.testnet".parse().unwrap(),
                sell_token_price: U128(101 * 10_u128.pow(22)), // 1.01 with 10^24 precision
                buy_token: "wrap.testnet".parse().unwrap(),
                buy_token_price: U128(305 * 10_u128.pow(22)), // 3.05 with 10^24 precision
                leverage: U128(10_u128.pow(24)),              // 1 with 10^24 precision
                borrow_fee: borrow_fee_order1,
                liquidation_price: liquidation_price_order1,
                lpt_id: "usdt.fakes.testnet|wrap.testnet|2000#540".to_string(),
            },
            OrderView {
                order_id: U128(2),
                status: OrderStatus::Pending,
                order_type: OrderType::Buy,
                amount: U128(2 * 10_u128.pow(9)),
                sell_token: "usdt.fakes.testnet".parse().unwrap(),
                sell_token_price: U128(101 * 10_u128.pow(22)), // 1.01 with 10^24 precision
                buy_token: "wrap.testnet".parse().unwrap(),
                buy_token_price: U128(305 * 10_u128.pow(22)), // 3.05 with 10^24 precision
                leverage: U128(10_u128.pow(24)),              // 1 with 10^24 precision
                borrow_fee: borrow_fee_order2,
                liquidation_price: liquidation_price_order2,
                lpt_id: "usdt.fakes.testnet|wrap.testnet|2000#541".to_string(),
            },
        ];

        let result_view_orders_bob = vec![OrderView {
            order_id: U128(3),
            status: OrderStatus::Pending,
            order_type: OrderType::Buy,
            amount: U128(2 * 10_u128.pow(9)),
            sell_token: "usdt.fakes.testnet".parse().unwrap(),
            sell_token_price: U128(101 * 10_u128.pow(22)), // 1.01 with 10^24 precision
            buy_token: "wrap.testnet".parse().unwrap(),
            buy_token_price: U128(305 * 10_u128.pow(22)), // 3.05 with 10^24 precision
            leverage: U128(10_u128.pow(24)),              // 1 with 10^24 precision
            borrow_fee: borrow_fee_order3,
            liquidation_price: liquidation_price_order3,
            lpt_id: "usdt.fakes.testnet|wrap.testnet|2000#542".to_string(),
        }];

        let mut view_orders_alice = contract.view_orders(
            alice(),
            pair_data.sell_token.clone(),
            pair_data.buy_token.clone(),
            borrow_rate_ratio,
        );
        view_orders_alice.sort_by(|a, b| a.order_id.cmp(&b.order_id));

        let view_orders_bob = contract.view_orders(
            bob(),
            pair_data.sell_token,
            pair_data.buy_token,
            borrow_rate_ratio,
        );

        assert_eq!(view_orders_alice, result_view_orders_alice);
        assert_eq!(view_orders_bob, result_view_orders_bob);
    }

    #[test]
    fn test_view_pair_tokens_decimals() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "usdt".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "wnear".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data.clone());

        let sell_and_buy_tokens_decimals =
            contract.view_pair_tokens_decimals(&pair_data.sell_token, &pair_data.buy_token);

        assert_eq!(
            sell_and_buy_tokens_decimals,
            (pair_data.sell_token_decimals, pair_data.buy_token_decimals)
        );
    }

    #[test]
    fn view_token_decimals_test() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "usdt".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "wnear".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 18,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data.clone());

        let sell_token_decimals = contract.view_token_decimals(&pair_data.sell_token);
        let buy_token_decimals = contract.view_token_decimals(&pair_data.buy_token);

        assert_eq!(sell_token_decimals, 24);
        assert_eq!(buy_token_decimals, 18)
    }

    #[test]
    fn test_view_pending_limit_orders_by_user() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // pair data for "USDT/WNEAR"
        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data);

        for count in 0..6 {
            if count < 1 {
                // order with status of "Pending" on leverage "1.0" and with timestamp "86400000"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Pending" on leverage "1.0"and with timestamp "86400001"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 4 {
                // order with status of "Pending" on leverage "2.0"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Executed" on leverage "1.0"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let true_2nd_limit_order = LimitOrderView {
            order_id: U128(2),
            timestamp: 86400001,
            pair: "USDT/WNEAR".to_string(),
            order_type: "Limit".to_string(),
            side: OrderType::Buy,
            price: U128(25 * 10_u128.pow(23)),
            amount: U128(2 * 10_u128.pow(27)),
            filled: 0,
            total: U128(2 * 10_u128.pow(27)),
        };

        let limit_orders = contract.view_pending_limit_orders_by_user(alice(), U128(10), U128(1));
        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 6_usize);
        assert_eq!(limit_orders.data.len(), 2_usize);
        assert_eq!(limit_orders.total_orders, U128(2));
        assert_eq!(limit_orders.data.get(1).unwrap(), &true_2nd_limit_order);
    }

    #[test]
    fn test_view_pending_limit_orders_by_user_by_pair() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // pair id "USDT/WNEAR"
        let pair_id = PairId {
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        // pair data for "USDT/WNEAR"
        let pair_data1 = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        // pair data for "WNEAR/USDT"
        let pair_data2 = TradePair {
            sell_ticker_id: "WNEAR".to_string(),
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "USDT".to_string(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 6,
            buy_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "wnear.qa.v1.nearlend.testnet|usdt.qa.v1.nearlend.testnet|2001".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data1);
        contract.add_pair(pair_data2);

        for count in 0..6 {
            if count < 1 {
                // order with status of "Pending" on leverage "1.0" and in pair "USDT/WNEAR" with timestamp "86400000"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Pending" on leverage "1.0" and in pair "USDT/WNEAR" with timestamp "86400001"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Sell\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 3 {
                // order with status of "Pending" on leverage "1.0" and in pair "WNEAR/USDT"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"wnear.qa.v1.nearlend.testnet\",\"buy_token\":\"usdt.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 4 {
                // order with status of "Pending" on leverage "2.0" and in pair "USDT/WNEAR"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Executed" on leverage "1.0" and in pair "USDT/WNEAR"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let true_2nd_limit_order = LimitOrderView {
            order_id: U128(2),
            timestamp: 86400001,
            pair: "USDT/WNEAR".to_string(),
            order_type: "Limit".to_string(),
            side: OrderType::Sell,
            price: U128(25 * 10_u128.pow(23)),
            amount: U128(2 * 10_u128.pow(27)),
            filled: 0,
            total: U128(5 * 10_u128.pow(27)),
        };

        // view pending limit orders by pair "USDT/WNEAR"
        let limit_orders = contract.view_pending_limit_orders_by_user_by_pair(
            alice(),
            pair_id.sell_token,
            pair_id.buy_token,
            U128(10),
            U128(1),
        );

        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 6_usize);
        assert_eq!(
            contract
                .view_pending_limit_orders_by_user(alice(), U128(10), U128(1))
                .total_orders,
            U128(3)
        );
        assert_eq!(limit_orders.data.len(), 2_usize);
        assert_eq!(limit_orders.total_orders, U128(2));
        assert_eq!(limit_orders.data.get(1).unwrap(), &true_2nd_limit_order);
    }

    #[test]
    fn test_view_pending_limit_orders_when_user_has_no_pending_orders() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        for count in 0..3 {
            if count < 1 {
                // order with status of "Liquidated" on leverage "1.0"
                let order_as_string = "{\"status\":\"Liquidated\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Canceled" on leverage "1.0"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Executed" on leverage "1.0"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400002,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let limit_orders = contract.view_pending_limit_orders_by_user(alice(), U128(10), U128(1));
        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 3_usize);
        assert_eq!(limit_orders.data.len(), 0_usize);
        assert_eq!(limit_orders.total_orders, U128(0));
    }

    #[test]
    fn test_view_pending_limit_orders_when_user_has_no_pending_orders_by_pair() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // pair id "WNEAR/USDT"
        let pair_id = PairId {
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        // pair data for "USDT/WNEAR"
        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data);

        for count in 0..4 {
            if count < 1 {
                // order with status of "Liquidated" on leverage "1.0"
                let order_as_string = "{\"status\":\"Liquidated\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Canceled" on leverage "1.0"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 3 {
                // order with status of "Executed" on leverage "1.0"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400002,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Pending" on leverage "1.0" and in pair "USDT/WNEAR"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        // view pending limit orders by pair "WNEAR/USDT"
        let limit_orders = contract.view_pending_limit_orders_by_user_by_pair(
            alice(),
            pair_id.sell_token,
            pair_id.buy_token,
            U128(10),
            U128(1),
        );

        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 4_usize);
        assert_eq!(
            contract
                .view_pending_limit_orders_by_user(alice(), U128(10), U128(1))
                .total_orders,
            U128(1)
        );
        assert_eq!(limit_orders.data.len(), 0_usize);
        assert_eq!(limit_orders.total_orders, U128(0));
    }

    #[test]
    fn test_view_opened_leverage_positions_by_user() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // pair data for "USDT/WNEAR"
        let pair_data1 = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        // pair data for "WNEAR/USDT"
        let pair_data2 = TradePair {
            sell_ticker_id: "WNEAR".to_string(),
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "USDT".to_string(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 6,
            buy_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "wnear.qa.v1.nearlend.testnet|usdt.qa.v1.nearlend.testnet|2001".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data1);
        contract.add_pair(pair_data2);

        let market_data = Some(MarketData {
            underlying_token: AccountId::new_unchecked("usdt.qa.v1.nearlend.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        });

        for count in 0..6 {
            if count < 1 {
                // order with status of "Pending" on leverage "3.0" and with timestamp "86400000"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Executed" on leverage "3.0" and with timestamp "86400001"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Short\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 4 {
                // order with status of "Pending" on leverage "1.0"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":3000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400002,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Executed" on leverage "1.0"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":4000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400003,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }
        // take-profit order for order with timestamp "86400001"
        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"TakeProfit\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400050,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let return_amounts = ReturnAmounts {
            amount_buy_token: U128(0_u128),
            amount_sell_token: U128(0_u128),
        };

        contract
            .take_profit_orders
            .insert(&2, &((0, 40), order, return_amounts));

        // opened position without take-profit order
        let true_1st_opened_position = LeveragedPositionView {
            order_id: U128(1),
            timestamp: 86400000,
            pair: "USDT/WNEAR".to_string(),
            order_type: OrderType::Long,
            price: U128(25 * 10_u128.pow(23)),
            leverage: U128(3 * 10_u128.pow(24)),
            amount: U128(2 * 10_u128.pow(27)),
            filled: 0,
            total: U128(6 * 10_u128.pow(27)),
            pnl: PnLView {
                is_profit: true,
                amount: U128(0_u128),
            },
            take_profit_order: None,
        };

        // opened position with take-profit order
        let true_2nd_opened_position = LeveragedPositionView {
            order_id: U128(2),
            timestamp: 86400001,
            pair: "USDT/WNEAR".to_string(),
            order_type: OrderType::Short,
            price: U128(25 * 10_u128.pow(23)),
            leverage: U128(3 * 10_u128.pow(24)),
            amount: U128(2 * 10_u128.pow(27)),
            filled: 1,
            total: U128(4 * 10_u128.pow(27)),
            pnl: PnLView {
                is_profit: false,
                amount: U128(861200000000000000000000001),
            },
            take_profit_order: Some(TakeProfitOrderView {
                timestamp: 86400050,
                pair: "USDT/WNEAR".to_string(),
                order_type: OrderType::TakeProfit,
                price: U128(25 * 10_u128.pow(23)),
                amount: U128(2 * 10_u128.pow(27)),
                filled: 0,
                total: U128(4 * 10_u128.pow(27)),
            }),
        };

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        let opened_positions = contract.view_opened_leverage_positions_by_user(
            alice(),
            current_buy_token_price,
            market_data,
            U128(10),
            U128(1),
        );

        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 6_usize);
        assert_eq!(opened_positions.data.len(), 2_usize);
        assert_eq!(opened_positions.total_positions, U128(2));
        assert_eq!(
            opened_positions.data.get(0).unwrap(),
            &true_1st_opened_position
        );
        assert_eq!(
            opened_positions.data.get(1).unwrap(),
            &true_2nd_opened_position
        );
    }

    #[test]
    fn test_view_opened_leverage_positions_by_user_by_pair() {
        let current_day = get_current_day_in_nanoseconds(91); // borrow period 90 days
        let context = get_context(false, current_day);
        testing_env!(context);

        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // pair id "WNEAR/USDT"
        let pair_id = PairId {
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        // pair data for "USDT/WNEAR"
        let pair_data1 = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        // pair data for "WNEAR/USDT"
        let pair_data2 = TradePair {
            sell_ticker_id: "WNEAR".to_string(),
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "USDT".to_string(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 6,
            buy_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "wnear.qa.v1.nearlend.testnet|usdt.qa.v1.nearlend.testnet|2001".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data1);
        contract.add_pair(pair_data2);

        let market_data = Some(MarketData {
            underlying_token: AccountId::new_unchecked("usdt.qa.v1.nearlend.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        });

        for count in 0..6 {
            if count < 1 {
                // order with status of "Pending" on leverage "3.0" and in pair "USDT/WNEAR" with timestamp "86400000"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Executed" on leverage "2.0" and in pair "WNEAR/USDT" with timestamp "86400001"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Short\",\"amount\":2000000000000000000000000000,\"sell_token\":\"wnear.qa.v1.nearlend.testnet\",\"buy_token\":\"usdt.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 3 {
                // order with status of "Pending" on leverage "4.0" and in pair "WNEAR/USDT" with timestamp "86400002"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Short\",\"amount\":2000000000000000000000000000,\"sell_token\":\"wnear.qa.v1.nearlend.testnet\",\"buy_token\":\"usdt.qa.v1.nearlend.testnet\",\"leverage\":\"4.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400002,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 4 {
                // order with status of "Pending" on leverage "1.0"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":3000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400003,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Executed" on leverage "1.0"
                let order_as_string = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":4000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400004,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }
        // take-profit order for order with timestamp "86400001"
        let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"TakeProfit\",\"amount\":2000000000000000000000000000,\"sell_token\":\"wnear.qa.v1.nearlend.testnet\",\"buy_token\":\"usdt.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1500000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400050,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
        let order: Order = near_sdk::serde_json::from_str(order_as_string.as_str()).unwrap();

        let return_amounts = ReturnAmounts {
            amount_buy_token: U128(0_u128),
            amount_sell_token: U128(0_u128),
        };

        contract
            .take_profit_orders
            .insert(&2, &((0, 40), order, return_amounts));

        // opened position with take-profit order in pair "WNEAR/USDT"
        let true_1st_opened_position_by_pair = LeveragedPositionView {
            order_id: U128(2),
            timestamp: 86400001,
            pair: "WNEAR/USDT".to_string(),
            order_type: OrderType::Short,
            price: U128(25 * 10_u128.pow(23)),
            leverage: U128(2 * 10_u128.pow(24)),
            amount: U128(2 * 10_u128.pow(27)),
            filled: 1,
            total: U128(2 * 10_u128.pow(27)),
            pnl: PnLView {
                is_profit: false,
                amount: U128(430600000000000000000000002),
            },
            take_profit_order: Some(TakeProfitOrderView {
                timestamp: 86400050,
                pair: "WNEAR/USDT".to_string(),
                order_type: OrderType::TakeProfit,
                price: U128(25 * 10_u128.pow(23)),
                amount: U128(2 * 10_u128.pow(27)),
                filled: 0,
                total: U128(2 * 10_u128.pow(27)),
            }),
        };

        // opened position without take-profit order in pair "USDT/WNEAR"
        let true_2nd_opened_position_by_pair = LeveragedPositionView {
            order_id: U128(3),
            timestamp: 86400002,
            pair: "WNEAR/USDT".to_string(),
            order_type: OrderType::Short,
            price: U128(25 * 10_u128.pow(23)),
            leverage: U128(4 * 10_u128.pow(24)),
            amount: U128(2 * 10_u128.pow(27)),
            filled: 0,
            total: U128(6 * 10_u128.pow(27)),
            pnl: PnLView {
                is_profit: true,
                amount: U128(0_u128),
            },
            take_profit_order: None,
        };

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        let opened_positions = contract.view_opened_leverage_positions_by_user_by_pair(
            alice(),
            pair_id.sell_token,
            pair_id.buy_token,
            current_buy_token_price,
            market_data.clone(),
            U128(10),
            U128(1),
        );

        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 6_usize);
        assert_eq!(
            contract
                .view_opened_leverage_positions_by_user(
                    alice(),
                    current_buy_token_price,
                    market_data,
                    U128(10),
                    U128(1)
                )
                .total_positions,
            U128(3)
        );
        assert_eq!(opened_positions.data.len(), 2_usize);
        assert_eq!(opened_positions.total_positions, U128(2));
        assert_eq!(
            opened_positions.data.get(0).unwrap(),
            &true_1st_opened_position_by_pair
        );
        assert_eq!(
            opened_positions.data.get(1).unwrap(),
            &true_2nd_opened_position_by_pair
        );
    }

    #[test]
    fn test_view_view_opened_leverage_positions_when_user_has_no_opened_positions() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // pair data for "USDT/WNEAR"
        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data);

        let market_data = Some(MarketData {
            underlying_token: AccountId::new_unchecked("usdt.qa.v1.nearlend.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        });

        for count in 0..3 {
            if count < 1 {
                // order with status of "Pending" on leverage "1.0"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Liquidated" on leverage "2.0"
                let order_as_string = "{\"status\":\"Liquidated\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Canceled" on leverage "3.0"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        let limit_orders = contract.view_opened_leverage_positions_by_user(
            alice(),
            current_buy_token_price,
            market_data,
            U128(10),
            U128(1),
        );
        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 3_usize);
        assert_eq!(limit_orders.data.len(), 0_usize);
        assert_eq!(limit_orders.total_positions, U128(0));
    }

    #[test]
    fn test_view_view_opened_leverage_positions_when_user_has_no_view_opened_positions_by_pair() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // pair id "WNEAR/USDT"
        let pair_id = PairId {
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
        };

        // pair data for "USDT/WNEAR"
        let pair_data = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data);

        let market_data = Some(MarketData {
            underlying_token: AccountId::new_unchecked("usdt.qa.v1.nearlend.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        });

        for count in 0..4 {
            if count < 1 {
                // order with status of "Pending" on leverage "1.0"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 2 {
                // order with status of "Liquidated" on leverage "2.0"
                let order_as_string = "{\"status\":\"Liquidated\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else if count < 3 {
                // order with status of "Canceled" on leverage "3.0"
                let order_as_string = "{\"status\":\"Canceled\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            } else {
                // order with status of "Pending" on leverage "3.0" in pair "USDT/WNEAR"
                let order_as_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":2000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"3.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1000000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"2500000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":1, \"timestamp_ms\":86400001,\"lpt_id\":\"usdt.fakes.testnet|wrap.testnet|2000#132\",\"history_data\":null}".to_string();
                contract.add_order_from_string(alice(), order_as_string);
            }
        }

        let current_buy_token_price = U128::from(3 * 10_u128.pow(24)); // current price token

        // view opened leverage positions in pair "WNEAR/USDT"
        let limit_orders = contract.view_opened_leverage_positions_by_user_by_pair(
            alice(),
            pair_id.sell_token,
            pair_id.buy_token,
            current_buy_token_price,
            market_data,
            U128(10),
            U128(1),
        );
        assert_eq!(contract.orders.get(&alice()).unwrap().len(), 4_usize);
        assert_eq!(limit_orders.data.len(), 0_usize);
        assert_eq!(limit_orders.total_positions, U128(0));
    }

    #[test]
    fn test_take_profit_order_view() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let market_data = MarketData {
            underlying_token: AccountId::new_unchecked("usdt.qa.v1.nearlend.testnet".to_string()),
            underlying_token_decimals: 6,
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        };

        let pair_data = TradePair {
            sell_ticker_id: "usdt".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "wnear".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 18,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDt".to_string(),
                value: U128(10_u128.pow(24)), // current price token
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "near".to_string(),
                value: U128(3 * 10_u128.pow(24)), // current price token
            },
        );

        let order_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3040000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930910, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#540\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_string);

        let order_id: u128 = 1;
        let new_price = U128(305 * 10_u128.pow(22));
        let left_point = -9860;
        let right_point = -9820;
        contract.create_take_profit_order(
            U128(order_id),
            new_price,
            left_point,
            right_point,
            market_data,
        );

        let tpo = contract.take_profit_orders.get(&(order_id as u64)).unwrap();
        assert_eq!(tpo.1.status, OrderStatus::PendingOrderExecute);
        assert_eq!(tpo.1.open_or_close_price, BigDecimal::from(new_price));

        let tpo_view = contract.take_profit_order_view(U128(order_id)).unwrap();
        assert_eq!(tpo_view.price, new_price);
    }

    #[test]
    fn test_take_profit_order_view_if_not_exist() {
        let context = get_context(false, None);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let pair_data = TradePair {
            sell_ticker_id: "usdt".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "wnear".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 18,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };
        contract.add_pair(pair_data);

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDt".to_string(),
                value: U128(10_u128.pow(24)), // current price token
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "near".to_string(),
                value: U128(3 * 10_u128.pow(24)), // current price token
            },
        );

        let order_string = "{\"status\":\"Pending\",\"order_type\":\"Long\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1010000000000000000000000\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3040000000000000000000000\"},\"open_or_close_price\":\"2.5\",\"block\":103930910, \"timestamp_ms\":86400000,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#540\",\"history_data\":null}".to_string();
        contract.add_order_from_string(alice(), order_string);

        let order_id: u128 = 1;

        let tpo_view = contract.take_profit_order_view(U128(order_id));
        assert_eq!(tpo_view, None);
    }

    #[test]
    fn calculate_short_liquidation_price_test() {
        let contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // 3000.00 USDT
        let sell_token_amount = U128::from(3000000000000000000000000000);
        // 12000.00 NEAR
        let buy_token_amount = U128::from(12000000000000000000000000000);
        // 2.50$
        let open_price = U128::from(2500000000000000000000000);
        // 5.0
        let leverage = U128::from(5000000000000000000000000);
        // 5.00%
        let borrow_fee = U128::from(50000000000000000000000);
        // 0.20%
        let swap_fee = U128::from(2000000000000000000000);

        let short_liquidation_price = contract.calculate_short_liquidation_price(
            sell_token_amount,
            buy_token_amount,
            open_price,
            leverage,
            borrow_fee,
            swap_fee,
        );

        // 2.6042$
        let expected_result = U128::from(2604200000000000000000000);

        assert_eq!(short_liquidation_price, expected_result);
    }

    #[test]
    fn calculate_long_liquidation_price_test() {
        let contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        // 2000.00 USDT
        let sell_token_amount = U128::from(2000000000000000000000000000);
        // 2.50$
        let open_price = U128::from(2500000000000000000000000);
        // 5.0
        let leverage = U128::from(5000000000000000000000000);
        // 5.00%
        let borrow_fee = U128::from(50000000000000000000000);
        // 0.20%
        let swap_fee = U128::from(2000000000000000000000);

        let long_liquidation_price = contract.calculate_long_liquidation_price(
            sell_token_amount,
            open_price,
            leverage,
            borrow_fee,
            swap_fee,
        );

        // 2.0221$
        let expected_result = U128::from(2029063888888888888888888);

        assert_eq!(long_liquidation_price, expected_result);
    }

    #[test]
    fn test_view_pairs() {
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );
        // if there are no pairs at all
        let view_pairs = contract.view_pairs();
        assert_eq!(view_pairs.len(), 0_usize);

        // pair data for "USDT/WNEAR"
        let pair_data1 = TradePair {
            sell_ticker_id: "USDT".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 6,
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "WNEAR".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 24,
            buy_token_market: "wnear_market.develop.v1.omomo-finance.testnet"
                .parse()
                .unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        // pair data for "WNEAR/USDT"
        let pair_data2 = TradePair {
            sell_ticker_id: "WNEAR".to_string(),
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_decimals: 24,
            sell_token_market: "wnear_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "USDT".to_string(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token_decimals: 6,
            buy_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "wnear.qa.v1.nearlend.testnet|usdt.qa.v1.nearlend.testnet|2001".to_string(),
            max_leverage: U128(25 * 10_u128.pow(23)),
            swap_fee: U128(3 * 10_u128.pow(20)),
        };

        contract.add_pair(pair_data1.clone());
        contract.add_pair(pair_data2.clone());

        let true_result = vec![
            PairId {
                sell_token: pair_data1.sell_token,
                buy_token: pair_data1.buy_token,
            },
            PairId {
                sell_token: pair_data2.sell_token,
                buy_token: pair_data2.buy_token,
            },
        ];

        let view_pairs = contract.view_pairs();

        assert_eq!(view_pairs.len(), 2_usize);
        assert_eq!(view_pairs, true_result);
    }
}

'''
'''--- contracts/leverage_trading/src/withdraw.rs ---
use crate::big_decimal::WBalance;
use crate::cancel_order::ext_self;
use crate::common::Event;
use crate::utils::ext_token;
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::utils::is_promise_success;
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, Promise, PromiseOrValue, ONE_YOCTO,
};

#[near_bindgen]
impl Contract {
    pub fn withdraw(
        &mut self,
        token: AccountId,
        amount: U128,
        reward_executor: Option<bool>,
    ) -> PromiseOrValue<WBalance> {
        let user = env::signer_account_id();
        let user_balance = self.balance_of(user.clone(), token.clone());

        require!(
            Balance::from(amount) > 0,
            "Amount should be a positive number"
        );
        require!(
            user_balance >= amount,
            "The account doesn't have enough digital tokens to do withdraw"
        );

        let token_decimals = self.view_token_decimals(&token);
        let token_amount = self.from_protocol_to_token_decimals(amount, token_decimals);

        ext_token::ext(token.clone())
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer(user.clone(), token_amount, None)
            .then(ext_self::ext(env::current_account_id()).withdraw_callback(
                user,
                token,
                amount,
                reward_executor,
            ))
            .into()
    }

    pub fn withdraw_callback(
        &mut self,
        account_id: AccountId,
        token: AccountId,
        amount: U128,
        reward_executor: Option<bool>,
    ) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            return PromiseOrValue::Value(U128(0));
        };

        self.decrease_balance(&account_id, &token, amount.0);
        Event::WithdrawEvent { token, amount }.emit();

        if let Some(reward) = reward_executor {
            if reward {
                let executor_reward_in_near = env::used_gas().0 as Balance * 2_u128;
                Promise::new(env::signer_account_id()).transfer(executor_reward_in_near);
            }
        }

        PromiseOrValue::Value(amount)
    }
}

'''
'''--- contracts/leverage_trading/test.sh ---
#!/bin/bash
set -e

cargo test --manifest-path ./Cargo.toml -- --nocapture

'''
'''--- contracts/leverage_trading/tests/workspace/main.rs ---
pub mod utils;
pub mod withdraw;

'''
'''--- contracts/leverage_trading/tests/workspace/utils.rs ---
use near_sdk::serde_json::json;
use workspaces::network::Sandbox;
use workspaces::{Account, Worker};

const LEVERAGE_TRADING_WASM: &str = "./target/wasm32-unknown-unknown/release/leverage_trading.wasm";
const MOCK_TOKEN_WASM: &str = "./../target/wasm32-unknown-unknown/release/mock_token.wasm";

pub async fn deploy_leverage_trading(
    owner: &Account,
    worker: &Worker<Sandbox>,
) -> Result<workspaces::Contract, workspaces::error::Error> {
    let wasm = std::fs::read(LEVERAGE_TRADING_WASM);
    let leverage_trading = worker.dev_deploy(&wasm.unwrap()).await?;

    let _ = leverage_trading
        .call("new_with_config")
        .args_json(json!({"owner_id": owner.id(), "oracle_account_id": owner.id()}))
        .max_gas()
        .transact()
        .await?;

    Ok(leverage_trading)
}

pub async fn deploy_mock_token(
    owner: &Account,
    worker: &Worker<Sandbox>,
) -> Result<workspaces::Contract, workspaces::error::Error> {
    let wasm = std::fs::read(MOCK_TOKEN_WASM);
    let underlying = worker.dev_deploy(&wasm.unwrap()).await?;

    let _ = underlying
        .call("new_default_meta")
        .args_json(json!({ "owner_id": owner.id(),
        "name": "Wrapped Ethereum",
        "symbol": "WETH",
        "total_supply": "1000000000000000000000000000",
        "decimals": 24
                }))
        .max_gas()
        .transact()
        .await?;

    Ok(underlying)
}

'''
'''--- contracts/leverage_trading/tests/workspace/withdraw/mod.rs ---
mod test_withdraw;

'''
'''--- contracts/leverage_trading/tests/workspace/withdraw/test_withdraw.rs ---
use crate::utils::*;
use leverage_trading::Actions;
use near_sdk::json_types::U128;
use near_sdk::require;
use near_sdk::serde_json::json;
use workspaces::network::Sandbox;
use workspaces::{Account, Worker};

async fn withdraw_fixture(
    owner: &Account,
    user: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<(workspaces::Contract, workspaces::Contract), anyhow::Error> {
    ////////////////////////////////////////////////////////////////////////////
    // Stage 1: Deploy contracts such as leverage_trading and mock_token
    ////////////////////////////////////////////////////////////////////////////

    let leverage_trading = deploy_leverage_trading(owner, worker).await?;
    let mock_token = deploy_mock_token(owner, worker).await?;

    ////////////////////////////////////////////////////////////////////////////
    // Stage 2: Adding a marker to a contract leverage_trading.
    ////////////////////////////////////////////////////////////////////////////

    let _ = leverage_trading
        .call("add_pair")
        .args_json(json!({"pair_data": {
            "sell_ticker_id": mock_token.id().to_string(),
            "sell_token": mock_token.id(),
            "sell_token_decimals": 24,
            "sell_token_market": mock_token.id(),
            "buy_ticker_id": mock_token.id().to_string(),
            "buy_token": mock_token.id(),
            "buy_token_decimals": 24,
            "buy_token_market": mock_token.id(),
            "pool_id": mock_token.id().to_string(),
            "max_leverage": "2500000000000000000000000",
            "swap_fee": "300000000000000000000"
        }}))
        .max_gas()
        .transact()
        .await?;

    ////////////////////////////////////////////////////////////////////////////
    // Stage 3: Deposit the storage for contract leverage_trading,
    // mint for user and user transfer to a contract leverage_trading
    ////////////////////////////////////////////////////////////////////////////

    let _ = mock_token
        .call("storage_deposit")
        .args_json(json!({
            "account_id": leverage_trading.id()
        }))
        .max_gas()
        .deposit(25 * 10_u128.pow(23))
        .transact()
        .await?;

    let _ = mock_token
        .call("mint")
        .args_json(json!({
            "account_id": user.id(),
            "amount": U128::from(25 * 10_u128.pow(26))
        }))
        .max_gas()
        .transact()
        .await?;

    let user_ft_balance_of_after_mint: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": user.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        user_ft_balance_of_after_mint,
        U128::from(25 * 10_u128.pow(26)),
        "user_ft_balance_of_after_mint"
    );

    let token: near_sdk::AccountId = mock_token.id().to_string().parse().unwrap();
    let action = Actions::Deposit { token };

    let _ = user
        .call(mock_token.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": leverage_trading.id(),
            "amount": U128::from(12 * 10_u128.pow(26)),
            "msg": near_sdk::serde_json::to_string(&action).unwrap()
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    ////////////////////////////////////////////////////////////////////////////
    // Stage 4: Check balance after reserve ft_transfer_call
    ////////////////////////////////////////////////////////////////////////////

    let contract_ft_balance_of_after_transfer_call: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": leverage_trading.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_ft_balance_of_after_transfer_call,
        U128::from(12 * 10_u128.pow(26)),
    );

    let user_ft_balance_of_after_transfer_call: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": user.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        user_ft_balance_of_after_transfer_call,
        U128::from(13 * 10_u128.pow(26))
    );

    Ok((mock_token, leverage_trading))
}

#[tokio::test]
async fn test_successful_withdraw() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.root_account()?;
    let user = worker.dev_create_account().await?;
    let (mock_token, leverage_trading) = withdraw_fixture(&owner, &user, &worker).await?;

    let contract_ft_balance_of_before_withdraw: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": leverage_trading.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let user_balance_of_before_withdraw: U128 = worker
        .view(
            leverage_trading.id(),
            "balance_of",
            json!({
                "account_id": user.id(),
                "token": mock_token.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let _ = user
        .call(leverage_trading.id(), "withdraw")
        .args_json(json!({
            "token": mock_token.id(),
            "amount": U128::from(6 * 10_u128.pow(26)),
        }))
        .max_gas()
        .transact()
        .await?;

    let contract_ft_balance_of_after_withdraw: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": leverage_trading.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let user_balance_of_after_withdraw: U128 = worker
        .view(
            leverage_trading.id(),
            "balance_of",
            json!({
                "account_id": user.id(),
                "token": mock_token.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let user_ft_balance_of_after_withdraw: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": user.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_ft_balance_of_before_withdraw,
        user_balance_of_before_withdraw
    );
    assert_eq!(
        contract_ft_balance_of_after_withdraw,
        user_balance_of_after_withdraw
    );
    assert_eq!(
        user_ft_balance_of_after_withdraw,
        U128(19 * 10_u128.pow(26))
    );

    Ok(())
}

#[tokio::test]
async fn test_withdraw_with_more_than_a_balance() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.root_account()?;
    let user = worker.dev_create_account().await?;
    let (mock_token, leverage_trading) = withdraw_fixture(&owner, &user, &worker).await?;

    let contract_ft_balance_of_before_withdraw: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": leverage_trading.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let user_balance_of_before_withdraw: U128 = worker
        .view(
            leverage_trading.id(),
            "balance_of",
            json!({
                "account_id": user.id(),
                "token": mock_token.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let withdraw = user
        .call(leverage_trading.id(), "withdraw")
        .args_json(json!({
            "token": mock_token.id(),
            "amount": U128::from(85 * 10_u128.pow(26)),
        }))
        .max_gas()
        .transact()
        .await?
        .into_result();

    require!(withdraw.is_err());

    let contract_ft_balance_of_after_withdraw: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": leverage_trading.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let user_balance_of_after_withdraw: U128 = worker
        .view(
            leverage_trading.id(),
            "balance_of",
            json!({
                "account_id": user.id(),
                "token": mock_token.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let user_ft_balance_of_after_withdraw: U128 = worker
        .view(
            mock_token.id(),
            "ft_balance_of",
            json!({
                "account_id": user.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_ft_balance_of_before_withdraw,
        user_balance_of_before_withdraw
    );
    assert_eq!(
        contract_ft_balance_of_after_withdraw,
        user_balance_of_after_withdraw
    );
    assert_eq!(
        user_ft_balance_of_after_withdraw,
        U128(13 * 10_u128.pow(26))
    );

    Ok(())
}

'''
'''--- contracts/market/Cargo.toml ---
[package]
name = "market"
version = "0.0.1"
authors = ["mark.ts@blaize.tech", "tymofii.s@blaize.tech", "vladyslav.v@blaize.tech", "orest.o@blaize.tech", "sergii.p@blaize.tech"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.6"
near-contract-standards = "4.0.0-pre.6"
general = { path = "../general" }
near-sys = "0.2.0"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.6"
workspaces = "0.6.0"
tokio = "1.21.1"
anyhow = "1.0.65"
mock-token = { path = "../mock-token" }
controller = { path = "../controller" }
'''
'''--- contracts/market/src/admin.rs ---
use general::NO_DEPOSIT;
use near_sdk::env::block_height;
use near_sdk::{env, require, AccountId};

use crate::*;

#[near_bindgen]
impl Contract {
    pub fn get_admin(&self) -> AccountId {
        self.admin.clone()
    }

    pub fn set_admin(&mut self, account: AccountId) {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );
        self.admin = account;
    }

    pub fn get_eligible_to_borrow_uncollateralized_account(&self) -> AccountId {
        self.eligible_to_borrow_uncollateralized.clone()
    }

    pub fn set_eligible_to_borrow_uncollateralized_account(&mut self, account: AccountId) {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );
        self.eligible_to_borrow_uncollateralized = account;
    }
}

impl Contract {
    pub fn is_valid_admin_call(&self) -> bool {
        env::signer_account_id() == self.admin
            || env::signer_account_id() == env::current_account_id()
    }

    pub fn is_allowed_to_borrow_uncollateralized(&self) -> bool {
        env::predecessor_account_id() == self.eligible_to_borrow_uncollateralized
    }

    pub fn add_inconsistent_account(&mut self, account: AccountId) {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );

        controller::set_account_consistency(
            account,
            false,
            block_height(),
            self.get_controller_address(),
            NO_DEPOSIT,
            self.terra_gas(5),
        );
    }
}

#[cfg(test)]
mod tests {
    use crate::InterestRateModel;
    use general::ratio::Ratio;
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};
    use std::str::FromStr;

    use crate::Config;

    use super::*;

    pub fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .signer_account_id(alice())
            .is_view(is_view)
            .build()
    }

    pub fn init(is_admin: bool) -> Contract {
        let (dtoken_account, underlying_token_account, controller_account) =
            (alice(), bob(), carol());

        if is_admin {
            testing_env!(get_context(false));
        }

        let mut contract = Contract::new(Config {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: underlying_token_account,
            underlying_token_decimals: 24,
            owner_id: dtoken_account,
            controller_account_id: controller_account,
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true,
        });

        if is_admin {
            contract.set_total_reserves(200);
        }

        contract
    }

    #[test]
    fn set_get_admin() {
        let dtoken_contract = Contract::new(Config {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: "weth".parse().unwrap(),
            underlying_token_decimals: 24,
            owner_id: "dtoken".parse().unwrap(),
            controller_account_id: "controller".parse().unwrap(),
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true,
        });

        assert_eq!(dtoken_contract.admin, dtoken_contract.get_admin());
        assert_eq!(
            AccountId::new_unchecked("dtoken".parse().unwrap()),
            dtoken_contract.get_admin()
        );
    }

    #[test]
    fn update_exchange_rate() {
        let mut dtoken_contract = Contract::new(Config {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: "weth".parse().unwrap(),
            underlying_token_decimals: 24,
            owner_id: "dtoken".parse().unwrap(),
            controller_account_id: "controller".parse().unwrap(),
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true,
        });
        dtoken_contract.mint(bob(), U128(10000));
        let exchange_rate = dtoken_contract.get_exchange_rate(U128(20000));
        assert_eq!(exchange_rate, Ratio::from_str("2").unwrap());

        dtoken_contract.set_total_reserves(10000);
        let exchange_rate = dtoken_contract.get_exchange_rate(U128(20000));
        assert_eq!(exchange_rate, Ratio::from_str("1").unwrap());
    }

    #[test]
    fn test_increase_total_reserve() {
        let mut contract = init(true);

        contract.increase_reserve(U128(300));

        // 200 is initial total_reserve set up in init_test_env
        assert_eq!(U128(200 + 300), contract.view_total_reserves());
    }
}

'''
'''--- contracts/market/src/borrow.rs ---
use crate::*;
use near_sdk::env::signer_account_id;

const GAS_FOR_BORROW: Gas = Gas(65_000_000_000_000);

impl Contract {
    pub fn decrease_borrows(&mut self, account: AccountId, token_amount: WBalance) -> Balance {
        let borrows = self.get_account_borrows(account.clone());
        let new_borrows = borrows - Balance::from(token_amount);

        self.set_account_borrows(account, U128(new_borrows))
    }

    pub fn increase_borrows(&mut self, account: AccountId, token_amount: WBalance) -> Balance {
        let borrows: Balance = self.get_account_borrows(account.clone());
        let new_borrows = borrows + Balance::from(token_amount);

        self.set_account_borrows(account, U128(new_borrows))
    }
}

#[near_bindgen]
impl Contract {
    pub fn post_borrow(
        &mut self,
        token_amount: WBalance,
        account_to_borrow: AccountId,
    ) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            return PromiseOrValue::Value(token_amount);
        }

        if account_to_borrow != self.get_eligible_to_borrow_uncollateralized_account() {
            self.adjust_rewards_by_campaign_type(CampaignType::Borrow);
        }

        let balance_of = self.view_contract_balance().into();

        let borrow_rate = self.get_borrow_rate(
            U128(balance_of),
            U128(self.get_total_borrows()),
            U128(self.get_total_reserves()),
        );
        let borrow_accrued_interest = self
            .config
            .get()
            .unwrap()
            .interest_rate_model
            .calculate_accrued_interest(
                borrow_rate,
                self.get_account_borrows(account_to_borrow.clone()),
                self.get_accrued_borrow_interest(account_to_borrow.clone()),
            );
        self.set_accrued_borrow_interest(
            account_to_borrow.clone(),
            borrow_accrued_interest.clone(),
        );

        controller::make_borrow(
            account_to_borrow.clone(),
            self.get_contract_address(),
            token_amount,
            borrow_accrued_interest.last_recalculation_block,
            WRatio::from(borrow_rate),
            self.get_controller_address(),
            NO_DEPOSIT,
            self.terra_gas(15),
        )
        .then(ext_self::make_borrow_callback(
            token_amount,
            account_to_borrow,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(40),
        ))
        .into()
    }
}

#[near_bindgen]
impl Contract {
    pub fn borrow(&mut self, amount: WBalance) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_BORROW,
            "Prepaid gas is not enough for borrow flow"
        );

        assert!(
            Balance::from(amount) > 0,
            "Amount should be a positive number"
        );

        let mut account_to_borrow = env::predecessor_account_id();

        if !self.is_allowed_to_borrow_uncollateralized() {
            account_to_borrow = signer_account_id();
        }

        self.mutex_account_lock(
            Actions::Borrow { account_to_borrow },
            amount,
            self.terra_gas(80),
        )
    }

    #[private]
    pub fn make_borrow_callback(
        &mut self,
        token_amount: WBalance,
        account_to_borrow: AccountId,
    ) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            log!(
                "{}",
                Events::BorrowFailedToIncreaseBorrowOnController(
                    account_to_borrow,
                    Balance::from(token_amount)
                )
            );
            self.mutex_account_unlock();
            return PromiseOrValue::Value(token_amount);
        }

        underlying_token::ft_transfer(
            account_to_borrow.clone(),
            self.to_decimals_token(token_amount),
            Some(format!(
                "Borrow with token_amount {}",
                Balance::from(token_amount)
            )),
            self.get_underlying_contract_address(),
            ONE_YOCTO,
            self.terra_gas(4),
        )
        .then(ext_self::borrow_ft_transfer_callback(
            token_amount,
            account_to_borrow,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(14),
        ))
        .into()
    }

    #[private]
    pub fn borrow_ft_transfer_callback(
        &mut self,
        token_amount: WBalance,
        account_to_borrow: AccountId,
    ) -> PromiseOrValue<WBalance> {
        if is_promise_success() {
            self.increase_borrows(account_to_borrow.clone(), token_amount);
            self.update_campaigns_market_total_by_type(CampaignType::Borrow);
            self.mutex_account_unlock();
            log!(
                "{}",
                Events::BorrowSuccess(account_to_borrow, Balance::from(token_amount))
            );
            self.decrease_contract_balance(token_amount);
            PromiseOrValue::Value(U128(0))
        } else {
            controller::decrease_borrows(
                account_to_borrow.clone(),
                self.get_contract_address(),
                token_amount,
                self.get_controller_address(),
                NO_DEPOSIT,
                self.terra_gas(4),
            )
            .then(ext_self::controller_decrease_borrows_fail_callback(
                token_amount,
                account_to_borrow,
                env::current_account_id(),
                NO_DEPOSIT,
                self.terra_gas(2),
            ))
            .into()
        }
    }

    #[private]
    pub fn controller_decrease_borrows_fail_callback(
        &mut self,
        token_amount: WBalance,
        account_to_borrow: AccountId,
    ) {
        if !is_promise_success() {
            self.add_inconsistent_account(env::signer_account_id());
            log!(
                "{}",
                Events::BorrowFailedToFallback(account_to_borrow, Balance::from(token_amount))
            );
        } else {
            self.mutex_account_unlock();
            log!(
                "{}",
                Events::BorrowFallbackSuccess(account_to_borrow, Balance::from(token_amount))
            );
        }
    }

    #[private]
    pub fn set_account_borrows(&mut self, account: AccountId, token_amount: WBalance) -> Balance {
        let mut user = self.user_profiles.get(&account).unwrap_or_default();
        user.borrows = Balance::from(token_amount);
        self.user_profiles.insert(&account, &user);

        self.get_account_borrows(account)
    }

    pub fn get_account_borrows(&self, account: AccountId) -> Balance {
        self.user_profiles.get(&account).unwrap_or_default().borrows
    }
}

'''
'''--- contracts/market/src/common.rs ---
use crate::*;
use general::ratio::Ratio;
use std::fmt;

pub enum Events {
    BorrowFailedToGetUnderlyingBalance(AccountId, Balance, AccountId, AccountId),
    BorrowFailedToIncreaseBorrowOnController(AccountId, Balance),
    BorrowSuccess(AccountId, Balance),
    BorrowFailedToFallback(AccountId, Balance),
    BorrowFallbackSuccess(AccountId, Balance),

    RepayFailedToUpdateUserBalance(AccountId, Balance),
    RepaySuccess(AccountId, Balance),

    SupplyFailedToGetUnderlyingBalance(AccountId, Balance, AccountId, AccountId),
    SupplyFailedToIncreaseSupplyOnController(AccountId, Balance),
    SupplySuccess(AccountId, Balance),

    DepositFailedToGetUnderlyingBalance(AccountId, Balance, AccountId, AccountId),
    MarginTradingFailedToIncreaseUserDeposit(AccountId, Balance),
    MarginTradingDepositSuccess(AccountId, Balance),
    MarginTradingFailedToDecreaseUserDeposit(AccountId, Balance),
    MarginTradingRevertDepositSuccess(AccountId, Balance),

    WithdrawFailedToGetUnderlyingBalance(AccountId, Balance, AccountId, AccountId),
    WithdrawFailedToDecreaseSupplyOnController(AccountId, Balance, AccountId),
    WithdrawSuccess(AccountId, Balance),
    WithdrawFailedToFallback(AccountId, Balance),
    WithdrawFallbackSuccess(AccountId, Balance),

    LiquidationSuccess(AccountId, AccountId, Balance),
    LiquidationFailed(AccountId, AccountId, Balance),
}

impl Contract {
    pub fn get_controller_address(&self) -> AccountId {
        let config: Config = self.get_contract_config();

        AccountId::new_unchecked(config.controller_account_id.to_string())
    }

    pub fn get_contract_address(&self) -> AccountId {
        env::current_account_id()
    }

    pub fn get_signer_address(&self) -> AccountId {
        env::signer_account_id()
    }

    pub fn get_underlying_contract_address(&self) -> AccountId {
        self.underlying_token.clone()
    }

    pub fn get_exchange_rate(&self, underlying_balance: WBalance) -> Ratio {
        let total_borrows = self.get_total_borrows();
        let total_reserves = self.get_total_reserves();
        let total_supplies = self.get_total_supplies();

        self.calculate_exchange_rate(
            underlying_balance,
            total_borrows,
            total_reserves,
            total_supplies,
        )
    }

    fn calculate_exchange_rate(
        &self,
        underlying_balance: WBalance,
        total_borrows: Balance,
        total_reserves: Balance,
        total_supplies: Balance,
    ) -> Ratio {
        if total_supplies == 0 {
            return self.initial_exchange_rate;
        }

        (Ratio::from(underlying_balance.0) + Ratio::from(total_borrows)
            - Ratio::from(total_reserves))
            / Ratio::from(total_supplies)
    }

    pub fn terra_gas(&self, gas: u64) -> Gas {
        TGAS * gas
    }

    pub fn mutex_account_lock(
        &mut self,
        action: Actions,
        amount: WBalance,
        gas: Gas,
    ) -> PromiseOrValue<U128> {
        controller::mutex_lock(
            action.clone(),
            self.get_controller_address(),
            NO_DEPOSIT,
            self.terra_gas(5),
        )
        .then(ext_self::mutex_lock_callback(
            action,
            amount,
            env::current_account_id(),
            NO_DEPOSIT,
            gas,
        ))
        .into()
    }

    pub fn mutex_account_unlock(&mut self) {
        controller::mutex_unlock(self.get_controller_address(), NO_DEPOSIT, self.terra_gas(5));
    }

    pub fn get_total_supplies(&self) -> Balance {
        // DTokens amount
        self.token.total_supply
    }

    pub fn get_total_borrows(&self) -> Balance {
        // Tokens amount
        self.user_profiles
            .iter()
            .map(|(_, value)| value.borrows)
            .sum()
    }

    pub fn get_total_reserves(&self) -> Balance {
        self.total_reserves
    }

    pub fn get_repay_info(&self, user_id: AccountId, underlying_balance: WBalance) -> RepayInfo {
        let borrow_rate = self.get_borrow_rate(
            underlying_balance,
            U128(self.get_total_borrows()),
            U128(self.get_total_reserves()),
        );
        let user_borrows = self.get_account_borrows(user_id.clone());

        let borrow_accrued_interest = self
            .config
            .get()
            .unwrap()
            .interest_rate_model
            .calculate_accrued_interest(
                borrow_rate,
                user_borrows,
                self.get_accrued_borrow_interest(user_id),
            );
        let accumulated_interest = borrow_accrued_interest.accumulated_interest;

        RepayInfo {
            accrued_interest_per_block: WBalance::from(borrow_rate),
            total_amount: WBalance::from(accumulated_interest + user_borrows),
            borrow_amount: WBalance::from(user_borrows),
            accumulated_interest: WBalance::from(accumulated_interest),
        }
    }

    pub fn get_withdraw_info(
        &self,
        user_id: AccountId,
        underlying_balance: WBalance,
    ) -> WithdrawInfo {
        let exchange_rate = U128::from(self.get_exchange_rate(underlying_balance));
        let interest_rate_model = self.config.get().unwrap().interest_rate_model;
        let supply_rate: Ratio = self.get_supply_rate(
            underlying_balance,
            U128(self.get_total_borrows()),
            U128(self.get_total_reserves()),
            interest_rate_model.get_reserve_factor(),
        );
        let accrued_supply_interest = interest_rate_model.calculate_accrued_interest(
            supply_rate,
            self.get_account_supplies(user_id.clone()),
            self.get_accrued_supply_interest(user_id.clone()),
        );
        let total_interest = U128::from(
            self.get_accrued_supply_interest(user_id)
                .accumulated_interest
                + accrued_supply_interest.accumulated_interest,
        );

        WithdrawInfo {
            exchange_rate,
            total_interest,
        }
    }

    pub fn set_total_reserves(&mut self, amount: Balance) -> Balance {
        self.total_reserves = amount;
        self.get_total_reserves()
    }

    pub fn get_unique_id(&self) -> String {
        self.uid.to_string()
    }

    pub fn request_unique_id(&mut self) -> String {
        self.uid += 1;
        self.get_unique_id()
    }

    fn set_contract_balance(&mut self, amount: Balance) -> Balance {
        self.contract_balance = amount;
        self.get_contract_balance()
    }

    pub fn get_contract_balance(&self) -> Balance {
        self.contract_balance
    }

    pub fn increase_contract_balance(&mut self, amount: WBalance) -> Balance {
        self.set_contract_balance(self.get_contract_balance() + Balance::from(amount))
    }

    pub fn decrease_contract_balance(&mut self, amount: WBalance) -> Balance {
        assert!(self.get_contract_balance() > Balance::from(amount));
        self.set_contract_balance(self.get_contract_balance() - Balance::from(amount))
    }
}

#[near_bindgen]
impl Contract {
    #[private]
    pub fn mint(&mut self, account_id: AccountId, amount: WBalance) {
        if self.token.accounts.get(&account_id).is_none() {
            self.token.internal_register_account(&account_id);
        };
        self.token.internal_deposit(&account_id, amount.into());
    }

    #[private]
    pub fn burn(&mut self, account_id: &AccountId, amount: WBalance) {
        if !self.token.accounts.contains_key(&account_id.clone()) {
            panic!("User with account {} wasn't found", account_id.clone());
        }
        self.token.internal_withdraw(account_id, amount.into());
    }

    #[private]
    pub fn mutex_lock_callback(
        &mut self,
        action: Actions,
        amount: WBalance,
    ) -> PromiseOrValue<WBalance> {
        match action {
            Actions::Repay => self.post_repay(amount),
            Actions::Withdraw => self.post_withdraw(amount),
            Actions::Supply => self.post_supply(amount),
            Actions::Borrow { account_to_borrow } => self.post_borrow(amount, account_to_borrow),
            Actions::Deposit => self.post_deposit(amount),
            _ => {
                panic!("Incorrect action at mutex lock callback")
            }
        }
    }
}

impl fmt::Display for Events {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Events::BorrowFailedToGetUnderlyingBalance(
                account,
                balance,
                contract_id,
                underlying_token_id,
            ) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "BorrowFailedToGetUnderlyingBalance", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to get {contract_id} balance on {underlying_token_id}"}}}}"#
            ),
            Events::BorrowFailedToIncreaseBorrowOnController(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "BorrowFailedToInceaseBorrowOnController", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to make borrow for {account} on {balance} token amount"}}}}"#
            ),
            Events::BorrowSuccess(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "BorrowSuccess", "data": {{"account_id": "{account}", "amount": "{balance}"}}}}"#
            ),
            Events::BorrowFailedToFallback(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "BorrowFailedToMakeFallback", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to revert state for {account}"}}}}"#
            ),
            Events::BorrowFallbackSuccess(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "BorrowFallbackSuccess", "data": {{"account_id": "{account}", "amount": "{balance}"}}}}"#
            ),
            Events::RepayFailedToUpdateUserBalance(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "RepayFailedToUpdateUserBalance", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to update user {account} balance {balance}: user is not registered"}}}}"#
            ),
            Events::RepaySuccess(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "RepaySuccess", "data": {{"account_id": "{account}", "amount": "{balance}"}}}}"#
            ),
            Events::SupplyFailedToGetUnderlyingBalance(
                account,
                balance,
                contract_id,
                underlying_token_id,
            ) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "SupplyFailedToGetUnderlyingBalance", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to get {contract_id} balance on {underlying_token_id}"}}}}"#
            ),
            Events::SupplyFailedToIncreaseSupplyOnController(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "SupplyFailedToInceaseSupplyOnController", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to increase {account} supply balance of {balance} on controller"}}}}"#
            ),
            Events::SupplySuccess(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "SupplySuccess", "data": {{"account_id": "{account}", "amount": "{balance}"}}}}"#
            ),
            Events::WithdrawFailedToGetUnderlyingBalance(
                account,
                balance,
                contract_id,
                underlying_token_id,
            ) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "WithdrawFailedToGetUnderlyingBalance", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to get {contract_id} balance on {underlying_token_id}"}}}}"#
            ),
            Events::WithdrawFailedToDecreaseSupplyOnController(account, balance, contract_id) => {
                write!(
                    f,
                    r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "WithdrawFailedToDecreaseSupplyOnController", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to decrease {account} supply balance of {contract_id} on controller"}}}}"#
                )
            }
            Events::WithdrawSuccess(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "WithdrawSuccess", "data": {{"account_id": "{account}", "amount": "{balance}"}}}}"#
            ),
            Events::WithdrawFailedToFallback(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "WithdrawFailedToMakeFallback", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to revert state for {account}"}}}}"#
            ),
            Events::WithdrawFallbackSuccess(account, balance) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "WithdrawFallbackSuccess", "data": {{"account_id": "{account}", "amount": "{balance}"}}}}"#
            ),
            Events::LiquidationSuccess(liquidator, borrower, amount_liquidate) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "LiquidationSuccess", "data": {{"liquidator_account_id": "{liquidator}", "borrower_account_id": {borrower},"amount": "{amount_liquidate}"}}}}"#
            ),
            Events::LiquidationFailed(liquidator, borrower, amount_liquidate) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "LiquidationFailed", "data": {{"liquidator_account_id": "{liquidator}", "borrower_account_id": {borrower},"amount": "{amount_liquidate}"}}}}"#
            ),
            Events::DepositFailedToGetUnderlyingBalance(
                account,
                balance,
                contract_id,
                underlying_token_id,
            ) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "DepositFailedToGetUnderlyingBalance", "data": {{"account_id": "{account}", "amount": "{balance}", "reason": "failed to get {contract_id} balance on {underlying_token_id}"}}}}"#
            ),
            Events::MarginTradingFailedToIncreaseUserDeposit(account, amount) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "MtradingFailedToIncreaseUserDeposit", "data": {{"account_id": "{account}", "amount": "{amount}", "reason": "failed to increase {account} deposit balance of {amount} on margin trading contract"}}}}"#
            ),
            Events::MarginTradingDepositSuccess(account, amount) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "MarginTradingDepositSuccess", "data": {{"account_id": "{account}", "amount": "{amount}"}}}}"#
            ),
            Events::MarginTradingFailedToDecreaseUserDeposit(account, amount) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "MarginTradingFailedToDecreaseUserDeposit", "data": {{"account_id": "{account}", "amount": "{amount}", "reason": "failed to revert state for {account}"}}}}"#
            ),
            Events::MarginTradingRevertDepositSuccess(account, amount) => write!(
                f,
                r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "MarginTradingRevertDepositSuccess", "data": {{"account_id": "{account}", "amount": "{amount}"}}}}"#
            ),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::InterestRateModel;
    use crate::{Config, Contract};
    use general::ratio::Ratio;
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use std::str::FromStr;

    pub fn init_env() -> Contract {
        let (dtoken_account, underlying_token_account, controller_account) =
            (alice(), bob(), carol());

        Contract::new(Config {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: underlying_token_account,
            underlying_token_decimals: 24,
            owner_id: dtoken_account,
            controller_account_id: controller_account,
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true,
        })
    }

    #[test]
    fn test_request_unique_id() {
        let mut contract = init_env();
        let uuid = contract.request_unique_id();

        assert_eq!(
            uuid,
            contract.get_unique_id(),
            "uuid {uuid} doesn't match to state value"
        );
    }

    #[test]
    fn test_exchange_rate_initial_state() {
        let contract = init_env();

        let total_reserves = 10_000;
        let total_borrows = 0;
        let total_supplies = 0;

        // Ratio that represents xrate = 1
        assert_eq!(
            Ratio::one(),
            contract.calculate_exchange_rate(
                U128(10_000),
                total_borrows,
                total_reserves,
                total_supplies,
            )
        );
    }

    #[test]
    fn test_exchange_rate_after_supply() {
        let contract = init_env();

        // supply 1000 tokens
        let total_reserves = 10_000;
        let total_borrows = 0;
        let total_supplies = 1000;

        // Ratio that represents xrate = 1
        assert_eq!(
            Ratio::one(),
            contract.calculate_exchange_rate(
                U128(11_000),
                total_borrows,
                total_reserves,
                total_supplies,
            )
        );
    }

    #[test]
    fn test_exchange_rate_after_borrow() {
        let contract = init_env();

        // borrow 1000 tokens
        let total_reserves = 10_000;
        let total_borrows = 1000;
        let total_supplies = 1000;

        // Ratio that represents xrate = 1
        assert_eq!(
            Ratio::one(),
            contract.calculate_exchange_rate(
                U128(10_000),
                total_borrows,
                total_reserves,
                total_supplies,
            )
        );
    }

    #[test]
    fn test_exchange_rate_after_borrow_more_than_supplies() {
        let contract = init_env();

        // borrow 5000 tokens
        let total_reserves = 10_000;
        let total_borrows = 5_000;
        let total_supplies = 1_000;

        // Ratio that represents xrate = 1
        assert_eq!(
            Ratio::one(),
            contract.calculate_exchange_rate(
                U128(6_000),
                total_borrows,
                total_reserves,
                total_supplies,
            )
        );
    }

    #[test]
    fn test_exchange_rate_after_repay() {
        let contract = init_env();

        // repay 1000 borrows and 50 debt
        let total_reserves = 10_000;
        let total_borrows = 0;
        let total_supplies = 1000;

        // Ratio that represents xrate = 1.05
        assert_eq!(
            Ratio::from_str("1.05").unwrap(),
            contract.calculate_exchange_rate(
                U128(11_050),
                total_borrows,
                total_reserves,
                total_supplies,
            )
        );
    }
}

'''
'''--- contracts/market/src/config.rs ---
use crate::*;
use near_sdk::json_types::U128;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The exchange rate which will be used by default
    pub initial_exchange_rate: U128,

    /// The account ID of underlying_token
    pub underlying_token_id: AccountId,
    pub underlying_token_decimals: u8,

    /// The account ID of the contract owner that allows to modify config
    pub owner_id: AccountId,

    /// The account ID of the controller contract
    pub controller_account_id: AccountId,

    /// The interest rate model with custom values
    pub interest_rate_model: InterestRateModel,

    /// The flag that dtoken can be transferred
    pub disable_transfer_token: bool,
}

impl Contract {
    pub fn get_contract_config(&self) -> Config {
        self.config.get().unwrap()
    }
}

'''
'''--- contracts/market/src/deposit.rs ---
use crate::*;

const GAS_FOR_DEPOSIT: Gas = Gas(120_000_000_000_000);

impl Contract {
    pub fn deposit(&mut self, token_amount: WBalance) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_DEPOSIT,
            "Prepaid gas is not enough for deposit flow"
        );

        self.mutex_account_lock(Actions::Deposit, token_amount, self.terra_gas(120))
    }

    pub fn post_deposit(&mut self, token_amount: WBalance) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            return PromiseOrValue::Value(self.to_decimals_token(token_amount));
        }
        underlying_token::ft_balance_of(
            env::current_account_id(),
            self.get_underlying_contract_address(),
            NO_DEPOSIT,
            TGAS,
        )
        .then(ext_self::deposit_balance_of_callback(
            token_amount,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(100),
        ))
        .into()
        // TODO better gas amount and create corresponding task in margin trading scope
    }
}

#[near_bindgen]
impl Contract {
    #[private]
    pub fn deposit_balance_of_callback(&mut self, amount: WBalance) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            log!(
                "{}",
                Events::DepositFailedToGetUnderlyingBalance(
                    env::signer_account_id(),
                    Balance::from(amount),
                    self.get_contract_address(),
                    self.get_underlying_contract_address()
                )
            );
            self.mutex_account_unlock();
            return PromiseOrValue::Value(self.to_decimals_token(amount));
        }
        log!(
            "prepaid {:?}; burn{:?}",
            env::prepaid_gas(),
            env::used_gas()
        );

        mtrading::increase_user_deposit(
            self.get_underlying_contract_address(),
            env::signer_account_id(),
            amount,
            self.eligible_to_borrow_uncollateralized.clone(),
            NO_DEPOSIT,
            self.terra_gas(16),
        )
        .then(ext_self::mtrading_increase_user_deposit_callback(
            self.get_underlying_contract_address(),
            env::signer_account_id(),
            amount,
            self.get_contract_address(),
            NO_DEPOSIT,
            self.terra_gas(26),
        ))
        .into()
    }

    #[private]
    pub fn mtrading_increase_user_deposit_callback(
        &mut self,
        amount: WBalance,
    ) -> PromiseOrValue<WBalance> {
        if is_promise_success() {
            log!(
                "{}",
                Events::MarginTradingDepositSuccess(
                    self.get_underlying_contract_address(),
                    Balance::from(amount)
                )
            );
            self.mutex_account_unlock();

            PromiseOrValue::Value(U128(0))
        } else {
            log!(
                "{}",
                Events::MarginTradingFailedToIncreaseUserDeposit(
                    self.get_underlying_contract_address(),
                    Balance::from(amount)
                )
            );

            mtrading::decrease_user_deposit(
                self.get_underlying_contract_address(),
                env::signer_account_id(),
                amount,
                self.eligible_to_borrow_uncollateralized.clone(),
                NO_DEPOSIT,
                self.terra_gas(15),
            )
            .then(ext_self::mtrading_decrease_user_deposit_fail_callback(
                amount,
                self.get_contract_address(),
                NO_DEPOSIT,
                self.terra_gas(10),
            ))
            .into()
        }
    }

    #[private]
    pub fn mtrading_decrease_user_deposit_fail_callback(
        &mut self,
        amount: WBalance,
    ) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            log!(
                "{}",
                Events::MarginTradingFailedToDecreaseUserDeposit(
                    self.get_underlying_contract_address(),
                    Balance::from(amount)
                )
            );
            self.mutex_account_unlock();

            PromiseOrValue::Value(self.to_decimals_token(amount))
        } else {
            log!(
                "{}",
                Events::MarginTradingRevertDepositSuccess(
                    self.get_underlying_contract_address(),
                    Balance::from(amount)
                )
            );
            self.mutex_account_unlock();

            PromiseOrValue::Value(U128(0))
        }
    }
}

'''
'''--- contracts/market/src/ft.rs ---
use crate::*;
use near_contract_standards::fungible_token::core::FungibleTokenCore;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::serde_json;
use near_sdk::AccountId;

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            env::predecessor_account_id(),
            self.underlying_token,
            "The call should come from token account"
        );
        assert!(
            Balance::from(amount) > 0,
            "Amount should be a positive number"
        );

        log!(format!("sender_id {sender_id}, msg {msg}"));

        let converted_amount = self.to_decimals_system(amount);

        let action: Actions = serde_json::from_str(&msg).expect("Incorrect command in transfer");

        match action {
            Actions::Supply => self.supply(converted_amount),
            Actions::Repay => self.repay(converted_amount),
            Actions::Liquidate {
                borrower,
                borrowing_dtoken,
                collateral_dtoken,
            } => self.liquidate(
                borrower,
                borrowing_dtoken,
                env::signer_account_id(),
                collateral_dtoken,
                converted_amount,
            ),
            Actions::Reserve => self.reserve(converted_amount),
            Actions::Deposit => self.deposit(converted_amount),
            _ => {
                panic!("Incorrect action in transfer")
            }
        }
    }
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        require!(!self.disable_transfer, "Transfer dtoken is disabled");
        self.token.ft_transfer(receiver_id, amount, memo);
    }

    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        require!(!self.disable_transfer, "Transfer dtoken is disabled");
        self.token.ft_transfer_call(receiver_id, amount, memo, msg)
    }

    fn ft_total_supply(&self) -> U128 {
        self.token.ft_total_supply()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        self.token.ft_balance_of(account_id)
    }
}

'''
'''--- contracts/market/src/interest_model.rs ---
use crate::*;
use general::ratio::{BigBalance, Ratio};
use std::cmp::min;

#[near_bindgen]
impl Contract {
    pub fn get_supply_rate(
        &self,
        underlying_balance: WBalance,
        total_borrows: WBalance,
        total_reserves: WBalance,
        reserve_factor: Ratio,
    ) -> Ratio {
        let max_reserve_factor_value = Ratio::one();

        assert!(
            reserve_factor <= max_reserve_factor_value,
            "{}",
            "Reserve factor should be less {max_reserve_factor_value}"
        );
        let rest_of_supply_factor = Ratio::one() - reserve_factor;
        let borrow_rate = self.get_borrow_rate(underlying_balance, total_borrows, total_reserves);
        let rate_to_pool = borrow_rate * rest_of_supply_factor / Ratio::one();
        let util_rate = self.get_util_rate(underlying_balance, total_borrows, total_reserves);

        util_rate * rate_to_pool / Ratio::one()
    }

    pub fn get_borrow_rate(
        &self,
        underlying_balance: WBalance,
        total_borrows: WBalance,
        total_reserves: WBalance,
    ) -> Ratio {
        let util = self.get_util_rate(underlying_balance, total_borrows, total_reserves);
        let interest_rate_model = self.config.get().unwrap().interest_rate_model;
        let kink = interest_rate_model.get_kink();
        let multiplier_per_block = interest_rate_model.get_multiplier_per_block();
        let base_rate_per_block = interest_rate_model.get_base_rate_per_block();
        let jump_multiplier_per_block = interest_rate_model.get_jump_multiplier_per_block();

        let multiplier = if util > kink {
            util - kink
        } else {
            Ratio::zero()
        };

        min(util, kink) * multiplier_per_block
            + multiplier * jump_multiplier_per_block
            + base_rate_per_block
    }

    fn get_util_rate(
        &self,
        underlying_balance: WBalance,
        total_borrows: WBalance,
        total_reserves: WBalance,
    ) -> Ratio {
        let denominator = if Balance::from(underlying_balance) + Balance::from(total_borrows)
            > Balance::from(total_reserves)
        {
            BigBalance::from(
                Balance::from(underlying_balance) + Balance::from(total_borrows)
                    - Balance::from(total_reserves),
            )
        } else {
            self.config.get().unwrap().interest_rate_model.get_kink()
        };

        // this may happen when there is no supplies
        if denominator == Ratio::zero() {
            return Ratio::zero();
        }

        BigBalance::from(total_borrows.0) / denominator
    }
}

#[cfg(test)]
mod tests {
    use crate::InterestRateModel;
    use general::ratio::Ratio;
    use general::WRatio;
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use std::str::FromStr;

    use crate::{Config, Contract};

    pub fn init_test_env() -> Contract {
        let (user_account, underlying_token_account, controller_account) =
            (alice(), bob(), carol());

        Contract::new(Config {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: underlying_token_account,
            underlying_token_decimals: 24,
            owner_id: user_account,
            controller_account_id: controller_account,
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true,
        })
    }

    #[test]
    fn test_get_util_rate() {
        let contract = init_test_env();

        assert_eq!(
            contract.get_util_rate(U128(20), U128(180), U128(0)),
            Ratio::from_str("0.9").unwrap()
        );
    }

    #[test]
    fn test_get_borrow_rate() {
        let contract = init_test_env();

        let mut interest_rate_model = contract.config.get().unwrap().interest_rate_model;

        interest_rate_model.set_base_rate_per_block(WRatio::from(0));
        interest_rate_model.set_multiplier_per_block(WRatio::from(500000000));
        interest_rate_model.set_kink(WRatio::from(800000000000000000000000));
        interest_rate_model.set_jump_multiplier_per_block(WRatio::from(10900000000));

        assert_eq!(
            contract.get_borrow_rate(U128(20), U128(180), U128(0)),
            Ratio::from_str("1.9").unwrap()
        );
    }

    #[test]
    fn test_get_supply_rate() {
        let contract = init_test_env();

        let mut interest_rate_model = contract.config.get().unwrap().interest_rate_model;

        interest_rate_model.set_base_rate_per_block(WRatio::from(0));
        interest_rate_model.set_multiplier_per_block(WRatio::from(500000000));
        interest_rate_model.set_kink(WRatio::from(800000000000000000000000));
        interest_rate_model.set_jump_multiplier_per_block(WRatio::from(10900000000));
        interest_rate_model.set_reserve_factor(WRatio::from(700000000));

        assert_eq!(
            contract.get_supply_rate(
                U128(20),
                U128(180),
                U128(0),
                interest_rate_model.get_reserve_factor(),
            ),
            Ratio::from_str("1.709999999999998803").unwrap()
        );
    }
}

'''
'''--- contracts/market/src/interest_rate_model.rs ---
use crate::*;
use general::ratio::{BigBalance, Ratio};
use near_sdk::env::block_height;
use std::fmt;
use std::str::FromStr;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct InterestRateModel {
    pub kink: WRatio,
    pub multiplier_per_block: WRatio,
    pub base_rate_per_block: WRatio,
    pub jump_multiplier_per_block: WRatio,
    pub reserve_factor: WRatio,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RepayInfo {
    pub accrued_interest_per_block: WBalance,
    pub total_amount: WBalance,
    pub borrow_amount: WBalance,
    pub accumulated_interest: WBalance,
}

impl fmt::Display for RepayInfo {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct WithdrawInfo {
    pub exchange_rate: U128,
    pub total_interest: U128,
}

impl fmt::Display for WithdrawInfo {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

impl InterestRateModel {
    pub fn get_kink(&self) -> Ratio {
        Ratio::from(self.kink)
    }

    pub fn get_multiplier_per_block(&self) -> Ratio {
        Ratio::from(self.multiplier_per_block)
    }

    pub fn get_base_rate_per_block(&self) -> Ratio {
        Ratio::from(self.base_rate_per_block)
    }

    pub fn get_jump_multiplier_per_block(&self) -> Ratio {
        Ratio::from(self.jump_multiplier_per_block)
    }

    pub fn get_reserve_factor(&self) -> Ratio {
        Ratio::from(self.reserve_factor)
    }

    pub fn set_kink(&mut self, value: WRatio) {
        self.kink = value;
    }

    pub fn set_multiplier_per_block(&mut self, value: WRatio) {
        self.multiplier_per_block = value;
    }

    pub fn set_base_rate_per_block(&mut self, value: WRatio) {
        self.base_rate_per_block = value;
    }

    pub fn set_jump_multiplier_per_block(&mut self, value: WRatio) {
        self.jump_multiplier_per_block = value;
    }

    pub fn set_reserve_factor(&mut self, value: WRatio) {
        self.reserve_factor = value;
    }

    pub fn calculate_accrued_interest(
        &self,
        borrow_rate: Ratio,
        total_borrow: Balance,
        accrued_interest: AccruedInterest,
    ) -> AccruedInterest {
        let current_block_height = block_height();
        let accrued_rate = BigBalance::from(total_borrow)
            * borrow_rate
            * BigBalance::from(current_block_height - accrued_interest.last_recalculation_block);

        AccruedInterest {
            accumulated_interest: accrued_interest.accumulated_interest + accrued_rate.round_u128(),
            last_recalculation_block: current_block_height,
        }
    }
}

impl Default for InterestRateModel {
    fn default() -> Self {
        Self {
            kink: WRatio::from(Ratio::one()),
            base_rate_per_block: WRatio::from(Ratio::one()),
            multiplier_per_block: WRatio::from(Ratio::one()),
            jump_multiplier_per_block: WRatio::from(Ratio::one()),
            reserve_factor: WRatio::from(Ratio::from_str("0.05").unwrap()),
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_accrued_borrow_interest(&self, account: AccountId) -> AccruedInterest {
        self.user_profiles
            .get(&account)
            .unwrap_or_default()
            .borrow_interest
    }

    pub fn get_accrued_supply_interest(&self, account: AccountId) -> AccruedInterest {
        self.user_profiles
            .get(&account)
            .unwrap_or_default()
            .supply_interest
    }

    #[private]
    pub fn set_accrued_supply_interest(
        &mut self,
        account: AccountId,
        accrued_interest: AccruedInterest,
    ) {
        let mut user = self.user_profiles.get(&account).unwrap_or_default();
        user.supply_interest = accrued_interest;
        self.user_profiles.insert(&account, &user);
    }

    #[private]
    pub fn set_accrued_borrow_interest(
        &mut self,
        account: AccountId,
        accrued_interest: AccruedInterest,
    ) {
        let mut user = self.user_profiles.get(&account).unwrap_or_default();
        user.borrow_interest = accrued_interest;
        self.user_profiles.insert(&account, &user);
    }
}

'''
'''--- contracts/market/src/lib.rs ---
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedMap};
use near_sdk::json_types::U128;
use near_sdk::require;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, is_promise_success, log, near_bindgen, AccountId, Balance, BlockHeight,
    BorshStorageKey, Gas, PromiseOrValue, PromiseResult,
};
use std::collections::HashMap;

pub use general::ratio::Ratio;
#[allow(unused_imports)]
pub use general::*;

pub use crate::borrow::*;
pub use crate::common::*;
pub use crate::config::*;
pub use crate::ft::*;
pub use crate::interest_model::*;
pub use crate::interest_rate_model::*;
pub use crate::repay::*;
pub use crate::rewards::*;
pub use crate::supply::*;
pub use crate::user_profile::*;
pub use crate::utils::*;
pub use crate::views::*;
pub use crate::withdraw::*;

mod admin;
mod borrow;
mod common;
mod config;
mod deposit;
mod ft;
mod interest_model;
mod interest_rate_model;
mod liquidation;
mod repay;
mod reserve;
mod rewards;
mod supply;
mod upgrade;
mod user_profile;
mod utils;
mod views;
mod withdraw;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKeys {
    Config,
    UserProfiles,
    RewardCampaigns,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    ///  Exchange rate in case of zero supplies
    initial_exchange_rate: Ratio,

    /// Total sum of supplied tokens
    total_reserves: Balance,

    /// Underlying balance of contract itself
    contract_balance: Balance,

    /// Account Id -> Token's amount
    user_profiles: UnorderedMap<AccountId, UserProfile>,

    /// Address of underlying token
    underlying_token: AccountId,
    underlying_token_decimals: u8,

    /// Pointer for contract token
    token: FungibleToken,

    /// Contract configuration object
    config: LazyOption<Config>,

    model: InterestRateModel,

    /// Contract admin account (dtoken itself by default)
    pub admin: AccountId,

    /// Contracts that are allowed to do uncollateralized borrow from market
    /// contract itself by default, can be set to different account
    eligible_to_borrow_uncollateralized: AccountId,

    /// Campaign id -> Reward campaign
    reward_campaigns: UnorderedMap<String, RewardCampaign>,

    /// Unique incremental identifier
    uid: u64,

    /// User account_id -> { campaign_id -> reward }
    rewards: HashMap<AccountId, HashMap<String, Reward>>,

    /// Disable transfer opportunity
    disable_transfer: bool,
}

impl Default for Contract {
    fn default() -> Self {
        env::panic_str("Token contract should be initialized before usage")
    }
}

#[ext_contract(underlying_token)]
trait UnderlineTokenInterface {
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: WBalance, memo: Option<String>);
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: WBalance,
        memo: Option<String>,
        msg: String,
    );
    fn ft_resolve_transfer(&self, account_id: AccountId) -> U128;
}

#[ext_contract(mtrading)]
trait MarginTradingInterface {
    fn increase_user_deposit(&mut self, market_id: AccountId, user_id: AccountId, amount: WBalance);
    fn decrease_user_deposit(&mut self, market_id: AccountId, user_id: AccountId, amount: WBalance);
}

#[ext_contract(controller)]
trait ControllerInterface {
    fn increase_supplies(
        &mut self,
        account: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
    );
    fn decrease_supplies(&mut self, account_id: AccountId, amount: WBalance);
    fn repay_borrows(
        &mut self,
        account_id: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
        borrow_block: BlockHeight,
        borrow_rate: WRatio,
    );
    fn withdraw_supplies(
        &mut self,
        account_id: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
    ) -> Promise;
    fn make_borrow(
        &mut self,
        account_id: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
        borrow_block: BlockHeight,
        borrow_rate: WRatio,
    );
    fn decrease_borrows(
        &mut self,
        account: AccountId,
        token_address: AccountId,
        token_amount: WBalance,
    );
    fn liquidation(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        liquidator: AccountId,
        collateral_dtoken: AccountId,
        liquidation_amount: WBalance,
    );
    fn liquidation_repay_and_swap(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        collateral_dtoken: AccountId,
        liquidator: AccountId,
        liquidation_amount: WBalance,
        liquidation_revenue_amount: WBalance,
        borrow_rate: WRatio,
    );
    fn mutex_lock(&mut self, action: Actions);
    fn mutex_unlock(&mut self);
    fn set_account_consistency(
        &mut self,
        account: AccountId,
        consistency: bool,
        block: BlockHeight,
    );
}

#[ext_contract(ext_self)]
trait InternalTokenInterface {
    fn supply_ft_transfer_call_callback(&mut self, amount: WBalance);
    fn controller_increase_supplies_callback(&mut self, amount: WBalance, dtoken_amount: WBalance);

    fn make_borrow_callback(
        &mut self,
        token_amount: WBalance,
        account_to_borrow: AccountId,
    ) -> PromiseOrValue<WBalance>;
    fn repay_balance_of_callback(&mut self, token_amount: WBalance) -> PromiseOrValue<WBalance>;
    fn borrow_ft_transfer_callback(
        &mut self,
        token_amount: WBalance,
        account_to_borrow: AccountId,
    ) -> PromiseOrValue<WBalance>;
    fn controller_repay_borrows_callback(
        &mut self,
        token_amount: WBalance,
    ) -> PromiseOrValue<WBalance>;
    fn controller_decrease_borrows_fail_callback(
        &mut self,
        token_amount: WBalance,
        account_to_borrow: AccountId,
    ) -> PromiseOrValue<WBalance>;

    fn withdraw_supplies_callback(
        &mut self,
        user_account: AccountId,
        token_amount: WBalance,
        dtoken_amount: WBalance,
        whole_amount: WBalance,
    ) -> PromiseOrValue<WBalance>;
    fn withdraw_ft_transfer_call_callback(
        &mut self,
        token_amount: WBalance,
        dtoken_amount: WBalance,
    ) -> PromiseOrValue<WBalance>;
    fn withdraw_increase_supplies_callback(
        &mut self,
        token_amount: WBalance,
    ) -> PromiseOrValue<WBalance>;
    fn liquidate_callback(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        collateral_dtoken: AccountId,
        liquidator: AccountId,
        liquidation_amount: WBalance,
    );
    fn liquidate_balance_of_callback(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        collateral_dtoken: AccountId,
        liquidator: AccountId,
        liquidation_amount: WBalance,
        result: Option<Vec<u8>>,
    );
    fn mutex_lock_callback(
        &mut self,
        action: Actions,
        amount: WBalance,
    ) -> PromiseOrValue<WBalance>;
    fn claim_reward_ft_transfer_callback(
        &mut self,
        reward: Reward,
        account_id: AccountId,
        amount: WBalance,
        unlocked: WBalance,
    );

    fn deposit_balance_of_callback(&mut self, amount: WBalance) -> PromiseOrValue<WBalance>;
    fn mtrading_increase_user_deposit_callback(
        &mut self,
        market_id: AccountId,
        user_id: AccountId,
        amount: WBalance,
    ) -> PromiseOrValue<WBalance>;
    fn mtrading_decrease_user_deposit_fail_callback(
        &mut self,
        amount: WBalance,
    ) -> PromiseOrValue<WBalance>;
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new_with_config(
        owner_id: AccountId,
        underlying_token_id: AccountId,
        underlying_token_decimals: u8,
        controller_account_id: AccountId,
        initial_exchange_rate: U128,
        interest_rate_model: InterestRateModel,
    ) -> Self {
        Self::new(Config {
            owner_id,
            underlying_token_id,
            underlying_token_decimals,
            controller_account_id,
            initial_exchange_rate,
            interest_rate_model,
            disable_transfer_token: true,
        })
    }

    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new(config: Config) -> Self {
        require!(!env::state_exists(), "Already initialized");

        Self {
            initial_exchange_rate: Ratio::from(config.initial_exchange_rate),
            total_reserves: 0,
            contract_balance: 0,
            user_profiles: UnorderedMap::new(StorageKeys::UserProfiles),
            underlying_token: config.underlying_token_id.clone(),
            underlying_token_decimals: config.underlying_token_decimals,
            token: FungibleToken::new(b"t".to_vec()),
            config: LazyOption::new(StorageKeys::Config, Some(&config)),
            model: config.interest_rate_model,
            admin: config.owner_id.clone(),
            eligible_to_borrow_uncollateralized: config.owner_id,
            reward_campaigns: UnorderedMap::new(StorageKeys::RewardCampaigns),
            uid: 0,
            rewards: HashMap::new(),
            disable_transfer: config.disable_transfer_token,
        }
    }
}

'''
'''--- contracts/market/src/liquidation.rs ---
use crate::*;
use near_sdk::promise_result_as_success;

impl Contract {
    pub fn liquidate(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        liquidator: AccountId,
        collateral_dtoken: AccountId,
        liquidation_amount: WBalance,
    ) -> PromiseOrValue<U128> {
        assert_eq!(self.get_contract_address(), borrowing_dtoken);

        require!(
            liquidation_amount.0 > 0,
            "Liquidation amount cannot be zero"
        );

        controller::liquidation(
            borrower.clone(),
            borrowing_dtoken.clone(),
            liquidator.clone(),
            collateral_dtoken.clone(),
            liquidation_amount,
            self.get_controller_address(),
            NO_DEPOSIT,
            self.terra_gas(30),
        )
        .then(ext_self::liquidate_callback(
            borrower,
            borrowing_dtoken,
            collateral_dtoken,
            liquidator,
            liquidation_amount,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(90),
        ))
        .into()
    }
}

#[near_bindgen]
impl Contract {
    #[private]
    pub fn liquidate_callback(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        collateral_dtoken: AccountId,
        liquidator: AccountId,
        liquidation_amount: WBalance,
    ) -> PromiseOrValue<U128> {
        let err_message = format!(
            "Revenue amount is not available! liquidator_account_id: {}, borrower_account_id: {}, amount: {}",
            liquidator,
            borrower,
            Balance::from(liquidation_amount)
        );
        require!(is_promise_success(), &err_message);
        let result = promise_result_as_success();

        require!(result.is_some(), err_message);

        underlying_token::ft_balance_of(
            self.get_contract_address(),
            self.get_underlying_contract_address(),
            NO_DEPOSIT,
            TGAS,
        )
        .then(ext_self::liquidate_balance_of_callback(
            borrower,
            borrowing_dtoken,
            collateral_dtoken,
            liquidator,
            liquidation_amount,
            result,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(60),
        ))
        .into()
    }

    #[private]
    pub fn liquidate_balance_of_callback(
        &mut self,
        borrower: AccountId,
        borrowing_dtoken: AccountId,
        collateral_dtoken: AccountId,
        liquidator: AccountId,
        liquidation_amount: WBalance,
        result: Option<Vec<u8>>,
    ) -> PromiseOrValue<U128> {
        let err_message = format!(
            "Revenue amount is not available! liquidator_account_id: {}, borrower_account_id: {}, amount: {}",
            liquidator,
            borrower,
            Balance::from(liquidation_amount)
        );
        require!(is_promise_success(), &err_message);

        let balance_of: Balance = match env::promise_result(0) {
            PromiseResult::NotReady => 0,
            PromiseResult::Failed => 0,
            PromiseResult::Successful(result) => near_sdk::serde_json::from_slice::<U128>(&result)
                .unwrap()
                .into(),
        };

        let borrow_rate = self.get_borrow_rate(
            U128(balance_of - liquidation_amount.0),
            U128(self.get_total_borrows()),
            U128(self.get_total_reserves()),
        );

        let liquidation_revenue_amount: WBalance =
            near_sdk::serde_json::from_slice::<U128>(&result.unwrap()).unwrap();

        self.decrease_borrows(borrower.clone(), liquidation_amount);

        controller::liquidation_repay_and_swap(
            borrower,
            borrowing_dtoken,
            collateral_dtoken,
            liquidator,
            liquidation_amount,
            liquidation_revenue_amount,
            U128::from(borrow_rate),
            self.get_controller_address(),
            NO_DEPOSIT,
            self.terra_gas(40),
        )
        .into()
    }

    pub fn swap_supplies(
        &mut self,
        borrower: AccountId,
        liquidator: AccountId,
        liquidation_revenue_amount: WBalance,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            env::predecessor_account_id(),
            self.get_controller_address(),
            "This method can be called only from controller contract"
        );
        let amount: Balance = liquidation_revenue_amount.into();

        if !self.token.accounts.contains_key(&liquidator) {
            self.token.internal_register_account(&liquidator);
        }

        self.token
            .internal_transfer(&borrower, &liquidator, amount, None);

        log!(
            "{}",
            Events::LiquidationSuccess(
                liquidator,
                borrower,
                Balance::from(liquidation_revenue_amount)
            )
        );
        PromiseOrValue::Value(U128(0))
    }
}

'''
'''--- contracts/market/src/repay.rs ---
use crate::*;

const GAS_FOR_REPAY: Gas = Gas(120_000_000_000_000);

impl Contract {
    pub fn repay(&mut self, token_amount: WBalance) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_REPAY,
            "Prepaid gas is not enough for repay flow"
        );
        self.mutex_account_lock(Actions::Repay, token_amount, self.terra_gas(140))
    }

    pub fn post_repay(&mut self, token_amount: WBalance) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            return PromiseOrValue::Value(self.to_decimals_token(token_amount));
        }
        self.adjust_rewards_by_campaign_type(CampaignType::Borrow);

        let balance_of = self.view_contract_balance();

        let borrow_rate = self.get_borrow_rate(
            U128(Balance::from(balance_of)),
            U128(self.get_total_borrows()),
            U128(self.get_total_reserves()),
        );

        let borrow_accrued_interest = self
            .config
            .get()
            .unwrap()
            .interest_rate_model
            .calculate_accrued_interest(
                borrow_rate,
                self.get_account_borrows(env::signer_account_id()),
                self.get_accrued_borrow_interest(env::signer_account_id()),
            );

        // let borrow_amount = self.get_account_borrows(env::signer_account_id());
        //
        // let borrow_with_rate_amount = borrow_amount + borrow_accrued_interest.accumulated_interest;
        self.set_accrued_borrow_interest(env::signer_account_id(), borrow_accrued_interest.clone());

        let borrow_amount = self.get_account_borrows(env::signer_account_id());

        // if borrow is less then accrued interest then we do not decerease borrows on controller
        // if borrow is up to borrows + accrued then we repay accrued and decrease remaining tokens on controller
        // if borrow is over borrows + accrued then we decrease full borrows on controller
        let borrow_decrease_amount = if token_amount.0
            <= borrow_accrued_interest.accumulated_interest
        {
            0u128
        } else if token_amount.0 <= borrow_amount + borrow_accrued_interest.accumulated_interest {
            token_amount.0 - borrow_accrued_interest.accumulated_interest
        } else {
            borrow_amount
        };

        controller::repay_borrows(
            env::signer_account_id(),
            self.get_contract_address(),
            U128(borrow_decrease_amount),
            borrow_accrued_interest.last_recalculation_block,
            U128::from(borrow_rate),
            self.get_controller_address(),
            NO_DEPOSIT,
            self.terra_gas(5),
        )
        .then(ext_self::controller_repay_borrows_callback(
            token_amount,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(20),
        ))
        .into()
    }
}

#[near_bindgen]
impl Contract {
    #[private]
    pub fn controller_repay_borrows_callback(
        &mut self,
        token_amount: WBalance,
    ) -> PromiseOrValue<U128> {
        if !is_promise_success() {
            log!(
                "{}",
                Events::RepayFailedToUpdateUserBalance(
                    env::signer_account_id(),
                    Balance::from(token_amount)
                )
            );
            self.mutex_account_unlock();
            return PromiseOrValue::Value(self.to_decimals_token(token_amount));
        }

        let mut borrow_interest = self.get_accrued_borrow_interest(env::signer_account_id());
        // update total reserves only after successful repay
        let new_total_reserve = self.get_total_reserves()
            + (Ratio::from(borrow_interest.accumulated_interest) * self.model.get_reserve_factor())
                .round_u128();
        self.set_total_reserves(new_total_reserve);

        let dust_balance = U128::from(
            token_amount
                .0
                .saturating_sub(self.get_account_borrows(env::signer_account_id()))
                .saturating_sub(borrow_interest.accumulated_interest),
        );

        let borrow_accrued_interest = self.get_accrued_borrow_interest(env::signer_account_id());
        let borrow_amount = self.get_account_borrows(env::signer_account_id());

        // if borrow is less then accrued interest then we decerease only accrued interest
        // if borrow is up to borrows + accrued then we repay accrued and decrease borrows by remaining tokens
        // if borrow is over borrows + accrued then we decrease full borrows
        if token_amount.0 <= borrow_accrued_interest.accumulated_interest {
            borrow_interest.accumulated_interest -= token_amount.0;
            self.set_accrued_borrow_interest(env::signer_account_id(), borrow_interest);
            self.increase_contract_balance(token_amount)
        } else if token_amount.0 <= borrow_amount + borrow_accrued_interest.accumulated_interest {
            self.decrease_borrows(
                env::signer_account_id(),
                WBalance::from(token_amount.0 - borrow_interest.accumulated_interest),
            );
            self.set_accrued_borrow_interest(env::signer_account_id(), AccruedInterest::default());
            self.increase_contract_balance(token_amount)
        } else {
            self.decrease_borrows(env::signer_account_id(), U128(borrow_amount));
            self.set_accrued_borrow_interest(env::signer_account_id(), AccruedInterest::default());
            self.increase_contract_balance(U128::from(
                borrow_amount + borrow_accrued_interest.accumulated_interest,
            ))
        };

        self.mutex_account_unlock();
        self.update_campaigns_market_total_by_type(CampaignType::Borrow);
        log!(
            "{}",
            Events::RepaySuccess(env::signer_account_id(), Balance::from(token_amount))
        );

        PromiseOrValue::Value(self.to_decimals_token(dust_balance))
    }
}

'''
'''--- contracts/market/src/reserve.rs ---
use crate::*;

const GAS_FOR_RESERVE: Gas = Gas(120_000_000_000_000);

impl Contract {
    pub fn reserve(&mut self, token_amount: WBalance) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_RESERVE,
            "Prepaid gas is not enough for reserve flow"
        );

        require!(
            self.is_valid_admin_call(),
            "Reserve action can be called by admin only"
        );

        self.increase_reserve(token_amount);

        self.increase_contract_balance(token_amount);

        PromiseOrValue::Value(U128(0))
    }

    fn set_total_reserve(&mut self, amount: Balance) -> Balance {
        self.total_reserves = amount;
        self.get_total_reserves()
    }

    pub fn increase_reserve(&mut self, token_amount: WBalance) -> Balance {
        self.set_total_reserve(self.get_total_reserves() + Balance::from(token_amount))
    }
}

'''
'''--- contracts/market/src/rewards.rs ---
use crate::*;
use general::ratio::{BigBalance, Ratio};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use std::cmp::{max, min};
use std::fmt;

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Eq, PartialEq, Clone, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum CampaignType {
    Supply,
    Borrow,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Vesting {
    /// Campaign vesting start time, seconds
    start_time: u64,
    /// Campaign vesting end time, seconds
    end_time: u64,
    /// Penalty amount which will be arrested in case of early withdraw
    penalty: Ratio,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardCampaign {
    /// Reward campaign type
    campaign_type: CampaignType,
    /// Campaign start time seconds
    start_time: u64,
    /// Campaign end time seconds
    end_time: u64,
    /// Reward token address
    token: AccountId,
    /// Token ticker id
    ticker_id: String,
    /// Reward tokens total amount
    reward_amount: WBalance,
    /// Last time when rewardPerToken was recomputed/updated
    last_update_time: u64,
    /// Represent the token rewards amount which contract should pay for 1 token putted into liquidity
    rewards_per_token: BigBalance,
    /// Last market total by campaign type value
    last_market_total: WBalance,
    /// Vesting configuration
    vesting: Vesting,
}

impl fmt::Display for RewardCampaign {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardCampaignExtended {
    /// Reward campaign id
    campaign_id: String,
    /// Reward campaign data
    campaign: RewardCampaign,
    /// Market total Supply/Borrow depends on reward campaign type
    market_total: WBalance,
    /// Rewards per day token amount
    rewards_per_day: WBalance,
}

impl fmt::Display for RewardCampaignExtended {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardState {
    max_claim_amount: WBalance,

    max_unlock_amount: WBalance,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Reward {
    /// Reward campaign id
    campaign_id: String,
    /// Total rewards amount, default = 0
    amount: WBalance,
    /// The last rewards_per_token which used for rewards adjustment, default = 0
    rewards_per_token_paid: BigBalance,
    /// Tokens total amount that has been claimed by the user
    claimed: WBalance,
    /// Tokens amount which were unlocked with penalty
    unlocked: WBalance,
}

impl fmt::Display for Reward {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

impl Reward {
    pub fn new(campaig_id: String) -> Reward {
        Reward {
            campaign_id: campaig_id,
            amount: U128(0),
            rewards_per_token_paid: BigBalance::zero(),
            claimed: U128(0),
            unlocked: U128(0),
        }
    }
}

impl Contract {
    pub fn get_reward_campaign_by_id(&self, campaign_id: String) -> Option<RewardCampaign> {
        self.reward_campaigns.get(&campaign_id)
    }

    pub fn get_reward_campaigns_extended(&self) -> Vec<RewardCampaignExtended> {
        self.reward_campaigns
            .iter()
            .map(|(id, campaign)| RewardCampaignExtended {
                campaign_id: id,
                campaign: campaign.clone(),
                market_total: self.get_market_total(campaign.clone()),
                rewards_per_day: self.get_reward_tokens_per_day(campaign),
            })
            .collect::<Vec<RewardCampaignExtended>>()
    }

    pub fn get_rewards_per_time(&self, campaign: RewardCampaign, seconds: u128) -> WBalance {
        let divider = u128::from(campaign.end_time - campaign.start_time);
        let rewards_per_time = match divider {
            0 => 0,
            _ => campaign.reward_amount.0 * seconds / divider,
        };
        WBalance::from(rewards_per_time)
    }

    pub fn get_timestamp_in_seconds(&self) -> u64 {
        env::block_timestamp_ms() / 1000u64
    }

    pub fn get_rewards_per_second(&self, campaign: RewardCampaign) -> WBalance {
        self.get_rewards_per_time(campaign, 1)
    }

    pub fn get_reward_tokens_per_day(&self, campaign: RewardCampaign) -> WBalance {
        self.get_rewards_per_time(campaign, 24 * 60 * 60)
    }

    pub fn get_market_total(&self, campaign: RewardCampaign) -> WBalance {
        if self.get_timestamp_in_seconds() > campaign.end_time {
            return campaign.last_market_total;
        }
        let total_amount = match campaign.campaign_type {
            CampaignType::Supply => self.get_total_supplies(), // Tokens
            CampaignType::Borrow => self.get_total_borrows(),  // Tokens
        };
        WBalance::from(total_amount)
    }

    pub fn get_account_total(&self, campaign: RewardCampaign, account_id: AccountId) -> WBalance {
        let account_total = match campaign.campaign_type {
            CampaignType::Supply => self.get_account_supplies(account_id),
            CampaignType::Borrow => self.get_account_borrows(account_id),
        };
        WBalance::from(account_total)
    }

    fn insert_map_if_not_exists(&mut self, account_id: AccountId) {
        let rewards_map: HashMap<String, Reward> = HashMap::new();
        self.rewards
            .entry(account_id)
            .or_insert_with(|| rewards_map);
    }

    pub fn get_accrued_rewards_per_token(&self, campaign_id: String) -> BigBalance {
        if let Some(campaign) = self.get_reward_campaign_by_id(campaign_id.clone()) {
            let total = self.get_market_total(campaign.clone());
            let current_time = min(self.get_timestamp_in_seconds(), campaign.end_time);
            if total.0 == 0 {
                return BigBalance::zero();
            };

            let rewards_per_time = self.get_rewards_per_time(
                campaign.clone(),
                u128::from(current_time - max(campaign.last_update_time, campaign.start_time)),
            );

            let result = (BigBalance::from(rewards_per_time.0) / BigBalance::from(total.0))
                * BigBalance::from(ONE_TOKEN);
            return result;
        }
        panic!(
            "Campaign {} wasn't found on the current contract",
            campaign_id
        );
    }

    pub fn update_reward_campaign(&mut self, campaign_id: String) -> RewardCampaign {
        let mut campaign = self.get_reward_campaign_by_id(campaign_id.clone()).unwrap();
        let accrued_tokens = self.get_accrued_rewards_per_token(campaign_id.clone());
        campaign.rewards_per_token = campaign.rewards_per_token + accrued_tokens;
        campaign.last_update_time = min(self.get_timestamp_in_seconds(), campaign.end_time);
        self.reward_campaigns.insert(&campaign_id, &campaign);
        campaign
    }

    pub fn update_campaign_market_total(&mut self, campaign_id: String) -> RewardCampaign {
        let mut campaign = self.get_reward_campaign_by_id(campaign_id.clone()).unwrap();
        campaign.last_market_total = self.get_market_total(campaign.clone());
        self.reward_campaigns.insert(&campaign_id, &campaign);
        campaign
    }

    pub fn get_updated_reward_amount(&self, reward: &Reward, account_id: AccountId) -> WBalance {
        self.get_updated_reward_amount_with_accrued(reward, account_id, BigBalance::zero())
    }

    pub fn get_updated_reward_amount_with_accrued(
        &self,
        reward: &Reward,
        account_id: AccountId,
        accrued: BigBalance,
    ) -> WBalance {
        let campaign_option = self.get_reward_campaign_by_id(reward.campaign_id.clone());

        assert!(
            campaign_option.is_some(),
            "{}",
            "Campaign for reward {reward} not exists"
        );
        let campaign = campaign_option.unwrap();
        let total = self.get_account_total(campaign.clone(), account_id);
        WBalance::from(
            reward.amount.0
                + (BigBalance::from(total.0)
                    * (campaign.rewards_per_token - reward.rewards_per_token_paid + accrued)
                    / BigBalance::from(ONE_TOKEN))
                .round_u128(),
        )
    }

    pub fn update_reward(&mut self, campaign_id: String, account_id: AccountId) -> Reward {
        let campaign = self.update_reward_campaign(campaign_id.clone());
        let default_reward = Reward::new(campaign_id.clone());

        self.insert_map_if_not_exists(account_id.clone());

        let account_rewards = self.rewards.get(&account_id).unwrap();
        let old_reward = account_rewards.get(&campaign_id).unwrap_or(&default_reward);
        let mut reward = Reward::new(campaign_id.clone());

        reward.amount = self.get_updated_reward_amount(old_reward, account_id.clone());
        reward.rewards_per_token_paid = campaign.rewards_per_token;
        reward.claimed = old_reward.claimed;
        reward.unlocked = old_reward.unlocked;

        reward
    }

    pub fn update_reward_in_state(&mut self, account_id: AccountId, reward: Reward) -> Reward {
        let default_reward = Reward::new(reward.campaign_id.clone());
        *self
            .rewards
            .entry(account_id)
            .or_default()
            .entry(reward.campaign_id.clone())
            .or_insert(default_reward) = reward.clone();
        reward
    }

    pub fn get_campaigns_by_campaign_type(&mut self, campaign_type: CampaignType) -> Vec<String> {
        self.reward_campaigns
            .iter()
            .filter(|(_, campaign)| {
                campaign.campaign_type == campaign_type
                    && campaign.end_time >= self.get_timestamp_in_seconds()
            })
            .map(|(campaign_id, _)| campaign_id)
            .collect::<Vec<String>>()
    }

    pub fn adjust_rewards_by_campaign_type(&mut self, campaign_type: CampaignType) {
        let campaigns = self.get_campaigns_by_campaign_type(campaign_type);

        campaigns.iter().for_each(|campaign_id| {
            self.adjust_reward(campaign_id.clone());
        });
    }

    pub fn update_campaigns_market_total_by_type(&mut self, campaign_type: CampaignType) {
        let campaigns = self.get_campaigns_by_campaign_type(campaign_type);

        campaigns.iter().for_each(|campaign_id| {
            self.update_campaign_market_total(campaign_id.clone());
        });
    }

    pub fn adjust_reward(&mut self, campaign_id: String) -> Reward {
        let account_id = env::signer_account_id();
        let reward = self.update_reward(campaign_id, account_id.clone());
        self.update_reward_in_state(account_id, reward)
    }

    pub fn get_view_reward_state_for_user(
        &self,
        account_id: AccountId,
        campaign_id: String,
        reward: Reward,
    ) -> Reward {
        let accrued = self.get_accrued_rewards_per_token(campaign_id);
        Reward {
            campaign_id: reward.campaign_id.clone(),
            amount: self.get_updated_reward_amount_with_accrued(&reward, account_id, accrued),
            rewards_per_token_paid: reward.rewards_per_token_paid,
            claimed: reward.claimed,
            unlocked: reward.unlocked,
        }
    }

    pub fn get_reward_state(&self, account_id: AccountId, campaign_id: String) -> RewardState {
        let default_reward = Reward::new(campaign_id.clone());
        let reward = self
            .rewards
            .get(&account_id)
            .unwrap()
            .get(&campaign_id)
            .unwrap_or(&default_reward);

        let updated_reward =
            self.get_view_reward_state_for_user(account_id, campaign_id, reward.clone());

        let available_to_claim_amount = self.get_amount_available_to_claim(updated_reward.clone());
        let available_to_unlock_amount = updated_reward.amount.0 - available_to_claim_amount;
        RewardState {
            max_claim_amount: WBalance::from(available_to_claim_amount),
            max_unlock_amount: WBalance::from(available_to_unlock_amount),
        }
    }

    pub fn get_rewards_list(&self, account_id: AccountId) -> HashMap<String, Reward> {
        let default_map: HashMap<String, Reward> = HashMap::new();
        let account_rewards = self.rewards.get(&account_id).unwrap_or(&default_map);
        let mut view_rewards: HashMap<String, Reward> = HashMap::new();

        account_rewards.iter().for_each(|(campaign_id, reward)| {
            view_rewards.insert(
                campaign_id.clone(),
                self.get_view_reward_state_for_user(
                    account_id.clone(),
                    campaign_id.clone(),
                    reward.clone(),
                ),
            );
        });
        view_rewards
    }

    pub fn get_amount_available_to_claim(&self, reward: Reward) -> Balance {
        let mut result: Balance = 0;
        if let Some(campaign) = self.get_reward_campaign_by_id(reward.campaign_id.clone()) {
            if campaign.vesting.start_time > self.get_timestamp_in_seconds() {
                return result;
            };
            let vesting_duration =
                Balance::from(campaign.vesting.end_time - campaign.vesting.start_time);
            let current_time = min(self.get_timestamp_in_seconds(), campaign.vesting.end_time);

            result = match vesting_duration {
                0 => reward.amount.0 - reward.claimed.0,
                _ => ((BigBalance::from(reward.amount.0 - reward.claimed.0)
                    * BigBalance::from(current_time - campaign.vesting.start_time))
                    / BigBalance::from(vesting_duration))
                .round_u128(),
            }
        }
        result
    }

    pub fn claim_or_unlock_request(
        &mut self,
        account_id: AccountId,
        transfer_amount: WBalance,
        msg: String,
        token_address: AccountId,
        claimed_amount: WBalance,
        unlocked_amount: WBalance,
        reward: Reward,
    ) {
        underlying_token::ft_transfer(
            account_id.clone(),
            self.to_decimals_token(transfer_amount),
            Some(msg),
            token_address,
            ONE_YOCTO,
            self.terra_gas(10),
        )
        .then(ext_self::claim_reward_ft_transfer_callback(
            reward,
            account_id,
            claimed_amount,
            unlocked_amount,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(5),
        ));
    }
}

#[near_bindgen]
impl Contract {
    pub fn add_reward_campaign(&mut self, reward_campaign: RewardCampaign) -> String {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );
        require!(
            reward_campaign.end_time >= self.get_timestamp_in_seconds(),
            "Campaign end time can't be in the past"
        );
        let campaign_id = self.request_unique_id();
        self.reward_campaigns.insert(&campaign_id, &reward_campaign);
        campaign_id
    }

    pub fn get_all_rewards_by_campaign_id(
        &self,
        campaign_id: String,
    ) -> HashMap<AccountId, Reward> {
        let mut result: HashMap<AccountId, Reward> = HashMap::new();
        self.rewards.iter().for_each(|(account_id, rewards)| {
            if let Some(reward) = rewards.get(&campaign_id) {
                result.insert(account_id.clone(), reward.clone());
            }
        });
        result
    }

    pub fn remove_rewards_entries_by_campaign_id(&mut self, campaign_id: String) {
        self.get_all_rewards_by_campaign_id(campaign_id)
            .iter()
            .for_each(|(account_id, reward)| {
                self.rewards
                    .get_mut(account_id)
                    .unwrap()
                    .remove(&reward.campaign_id);
            });
    }

    pub fn remove_reward_campaign(&mut self, campaign_id: String) {
        require!(
            self.is_valid_admin_call(),
            "This functionality is allowed to be called by admin or contract only"
        );
        require!(
            self.get_reward_campaign_by_id(campaign_id.clone())
                .is_some(),
            "Reward campaign by this key doesn't exists"
        );
        self.remove_rewards_entries_by_campaign_id(campaign_id.clone());
        self.reward_campaigns.remove(&campaign_id);
    }

    pub fn claim_rewards(&mut self, campaign_id: String, amount: WBalance) {
        let account_id = env::signer_account_id();
        let reward = self.adjust_reward(campaign_id.clone());
        let available_amount = self.get_amount_available_to_claim(reward.clone());
        let campaign = self.get_reward_campaign_by_id(campaign_id).unwrap();
        assert!(
            self.get_timestamp_in_seconds() > campaign.vesting.start_time,
            "No rewards amount available to claim, because vesting is not started"
        );
        assert!(
            amount.0 <= available_amount,
            "{}",
            "There are not enough amount to claim. Possible amount is {available_amount}"
        );

        let message = format!("Claim reward with token_amount {}", amount.0);
        self.claim_or_unlock_request(
            account_id,
            amount,
            message,
            campaign.token,
            amount,
            WBalance::from(0),
            reward,
        )
    }

    pub fn unlock_rewards(&mut self, campaign_id: String, amount: WBalance) {
        let account_id = env::signer_account_id();
        let reward = self.adjust_reward(campaign_id.clone());
        let available_to_claim_amount = self.get_amount_available_to_claim(reward.clone());
        let available_to_unlock_amount = reward.amount.0 - available_to_claim_amount;
        let campaign = self.get_reward_campaign_by_id(campaign_id).unwrap();
        assert!(
            self.get_timestamp_in_seconds() > campaign.vesting.start_time,
            "No unlock amount available to claim, because vesting is not started"
        );
        assert!(
            amount.0 <= available_to_unlock_amount,
            "{}", "There are not enough amount to unlock. Possible amount is {available_to_unlock_amount}"
        );

        let amount_with_penalty =
            WBalance::from(BigBalance::from(amount) * campaign.vesting.penalty);
        let message = format!(
            "Unlock rewards with amount {} and amount_with_penalty {}",
            amount.0, amount_with_penalty.0
        );
        self.claim_or_unlock_request(
            account_id,
            amount_with_penalty,
            message,
            campaign.token,
            amount,
            amount_with_penalty,
            reward,
        )
    }

    #[private]
    pub fn claim_reward_ft_transfer_callback(
        &mut self,
        reward: Reward,
        account_id: AccountId,
        amount: WBalance,
        unlocked: WBalance,
    ) {
        assert!(is_promise_success(), "Claim operation wasn't successful");
        self.update_reward_in_state(
            account_id,
            Reward {
                campaign_id: reward.campaign_id,
                amount: reward.amount,
                rewards_per_token_paid: reward.rewards_per_token_paid,
                claimed: WBalance::from(reward.claimed.0 + amount.0),
                unlocked: WBalance::from(reward.unlocked.0 + unlocked.0),
            },
        );
    }
}

#[cfg(test)]
mod tests {
    use crate::rewards::{CampaignType, Vesting};
    use crate::{Config, Contract, Reward};
    use crate::{InterestRateModel, RewardCampaign};
    use general::ratio::{BigBalance, Ratio};
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{env, testing_env, AccountId, Balance, BlockHeight, VMContext};

    use general::{WBalance, ONE_TOKEN};
    use std::convert::TryFrom;

    const REWARD_AMOUNT: Balance = 100000 * 10u128.pow(0);

    pub fn init_env() -> Contract {
        let (dtoken_account, underlying_token_account, controller_account) =
            (alice(), bob(), carol());

        Contract::new(Config {
            initial_exchange_rate: U128(10000),
            underlying_token_id: underlying_token_account,
            underlying_token_decimals: 24,
            owner_id: dtoken_account,
            controller_account_id: controller_account,
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true,
        })
    }

    fn get_custom_context_with_signer(
        is_view: bool,
        block_timestamp: u64,
        block_index: BlockHeight,
        signer: AccountId,
    ) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(signer.clone())
            .signer_account_id(signer.clone())
            .predecessor_account_id(signer)
            .block_index(block_index)
            .block_timestamp(block_timestamp)
            .is_view(is_view)
            .build()
    }

    fn get_custom_context(
        is_view: bool,
        block_timestamp: u64,
        block_index: BlockHeight,
    ) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(AccountId::try_from(alice().to_string()).unwrap())
            .signer_account_id(AccountId::try_from(alice().to_string()).unwrap())
            .predecessor_account_id(AccountId::try_from(alice().to_string()).unwrap())
            .block_index(block_index)
            .block_timestamp(block_timestamp)
            .is_view(is_view)
            .build()
    }

    fn get_context(is_view: bool) -> VMContext {
        get_custom_context(is_view, 0, 100)
    }

    fn get_campaign() -> RewardCampaign {
        let vesting = Vesting {
            start_time: 1651362400,
            end_time: 1651372400,
            penalty: Ratio::from(5000u128),
        };

        RewardCampaign {
            campaign_type: CampaignType::Supply,
            start_time: 1651352400,
            end_time: 1651362400,
            token: carol(),
            ticker_id: "CAROL".to_string(),
            reward_amount: U128(REWARD_AMOUNT),
            last_update_time: 0,
            rewards_per_token: BigBalance::zero(),
            last_market_total: U128(0),
            vesting,
        }
    }

    #[test]
    fn test_adjust_rewards_by_campaign_type() {
        let mut contract = init_env();
        let campaign1 = get_campaign();
        let campaign2 = get_campaign();

        let context = get_custom_context(false, 1651352400000000000, 95459174);
        testing_env!(context);

        let campaign_id1 = contract.add_reward_campaign(campaign1.clone());
        contract.add_reward_campaign(campaign2);
        contract.adjust_rewards_by_campaign_type(CampaignType::Supply);
        contract.mint(contract.get_signer_address(), WBalance::from(100000));
        contract.update_campaigns_market_total_by_type(CampaignType::Supply);

        let context = get_custom_context(false, 1651357400000000000, 95459174);
        testing_env!(context.clone());

        let rewards_list_on_half_way = contract.get_rewards_list(context.signer_account_id.clone());

        assert_eq!(
            rewards_list_on_half_way.len(),
            2,
            "Rewards list should be consist of 2 rewards"
        );

        assert_eq!(
            rewards_list_on_half_way
                .get(campaign_id1.as_str())
                .unwrap()
                .amount
                .0,
            campaign1.reward_amount.0 / 2,
            "Rewards amount should be half of full campaign rewards"
        );

        let context1 = get_custom_context_with_signer(false, 1651357400000000000, 95459174, bob());
        testing_env!(context1);

        contract.adjust_rewards_by_campaign_type(CampaignType::Supply);
        contract.mint(contract.get_signer_address(), WBalance::from(300000));
        contract.update_campaigns_market_total_by_type(CampaignType::Supply);

        let context1 = get_custom_context_with_signer(false, 1651362400000000000, 95459174, bob());
        testing_env!(context1.clone());

        let rewards_list_on_finish_alice =
            contract.get_rewards_list(context.signer_account_id.clone());

        let rewards_list_on_finish_bob =
            contract.get_rewards_list(context1.signer_account_id.clone());

        assert_eq!(
            rewards_list_on_finish_alice.len(),
            2,
            "Rewards list should be consist of 2 rewards"
        );

        let half_reward = campaign1.reward_amount.0 / 2;
        assert_eq!(
            rewards_list_on_finish_alice
                .get(campaign_id1.as_str())
                .unwrap()
                .amount
                .0,
            half_reward + half_reward / 4,
            "Rewards amount should be 50000 + (50000 * 0.25)"
        );

        assert_eq!(
            rewards_list_on_finish_bob.len(),
            2,
            "Rewards list should be consist of 2 rewards"
        );

        assert_eq!(
            rewards_list_on_finish_bob
                .get(campaign_id1.as_str())
                .unwrap()
                .amount
                .0,
            half_reward * 3 / 4,
            "Rewards amount should be 0 + (50000 * 0.75)"
        );

        let context2 =
            get_custom_context_with_signer(false, 1651372400000000000, 95459174, carol());
        testing_env!(context2);
        contract.adjust_rewards_by_campaign_type(CampaignType::Supply);
        contract.mint(contract.get_signer_address(), WBalance::from(600000));
        contract.update_campaigns_market_total_by_type(CampaignType::Supply);

        let rewards_list_on_finish_alice = contract.get_rewards_list(context.signer_account_id);

        let rewards_list_on_finish_bob = contract.get_rewards_list(context1.signer_account_id);

        assert_eq!(
            rewards_list_on_finish_alice
                .get(campaign_id1.as_str())
                .unwrap()
                .amount
                .0,
            half_reward + half_reward / 4,
            "Counting after campaign has been finished! Rewards amount should be 50000 + (50000 * 0.25)"
        );

        assert_eq!(
            rewards_list_on_finish_bob
                .get(campaign_id1.as_str())
                .unwrap()
                .amount
                .0,
            half_reward * 3 / 4,
            "Counting after campaign has been finished! Rewards amount should be 0 + (50000 * 0.75)"
        );
    }

    #[test]
    fn test_get_amount_available_to_claim() {
        let mut contract = init_env();
        let mut campaign = get_campaign();
        campaign.campaign_type = CampaignType::Borrow;

        let context = get_custom_context(false, 1651362400000000000, 1);
        testing_env!(context);
        let account_id = env::signer_account_id();
        let campaign_id = contract.add_reward_campaign(campaign);

        contract.increase_borrows(account_id, WBalance::from(1000));
        let reward = contract.adjust_reward(campaign_id);

        println!("{reward}");
        let amount_available_to_claim = contract.get_amount_available_to_claim(reward.clone());
        assert_eq!(
            amount_available_to_claim, 0,
            "Amount for claim doesn't match to expected"
        );

        let context1 = get_custom_context(false, 1651367400000000000, 1);
        testing_env!(context1);

        let amount_available_to_claim1 = contract.get_amount_available_to_claim(reward.clone());
        assert_eq!(
            amount_available_to_claim1,
            reward.amount.0 / 2,
            "Amount for claim doesn't match to expected"
        );

        let context2 = get_custom_context(false, 1651372400000000000, 1);
        testing_env!(context2);
        let amount_available_to_claim2 = contract.get_amount_available_to_claim(reward.clone());
        assert_eq!(
            amount_available_to_claim2, reward.amount.0,
            "Amount for claim doesn't match to expected"
        );

        let context3 = get_custom_context(false, 1651375400000000000, 1);
        testing_env!(context3);
        let amount_available_to_claim3 = contract.get_amount_available_to_claim(reward.clone());
        assert_eq!(
            amount_available_to_claim3, reward.amount.0,
            "Amount for claim doesn't match to expected"
        );
    }

    #[test]
    fn test_get_rewards_list() {
        let mut contract = init_env();
        let mut campaign = get_campaign();
        campaign.campaign_type = CampaignType::Borrow;

        let context = get_custom_context(false, 1651357400000000000, 1);
        testing_env!(context);
        let account_id = env::signer_account_id();
        let campaign_id = contract.add_reward_campaign(campaign);

        contract.increase_borrows(account_id.clone(), WBalance::from(1000));
        contract.adjust_reward(campaign_id.clone());

        let result1 = contract.get_rewards_list(account_id.clone());
        assert_eq!(
            result1.len(),
            1,
            "Rewards list length doesn't match to expected"
        );

        let context = get_custom_context(false, 1651362400000000000, 1);
        testing_env!(context);
        let result2 = contract.get_rewards_list(account_id);
        assert_eq!(
            result2.len(),
            1,
            "Rewards list length doesn't match to expected"
        );
        assert_ne!(
            result1.get(&campaign_id).unwrap().amount,
            result2.get(&campaign_id).unwrap().amount,
            "Amounts are shouldn't be equal"
        );
        assert_eq!(
            result1.get(&campaign_id).unwrap().rewards_per_token_paid,
            result2.get(&campaign_id).unwrap().rewards_per_token_paid,
            "Rewards per token paid are should be similar"
        )
    }

    #[test]
    pub fn test_get_updated_reward_amount() {
        let account_id = AccountId::try_from(alice().to_string()).unwrap();
        let mut contract = init_env();
        let mut campaign = get_campaign();
        campaign.rewards_per_token = BigBalance::from(10 * ONE_TOKEN);
        let context = get_context(false);
        testing_env!(context);
        campaign.campaign_type = CampaignType::Borrow;
        let campaign_id = contract.add_reward_campaign(campaign);

        let reward = Reward::new(campaign_id);
        contract.increase_borrows(account_id.clone(), WBalance::from(100));

        let result = contract.get_updated_reward_amount(&reward, account_id);

        assert_eq!(
            result.0, 1000,
            "Reward amount doesn't match to expected value"
        );
    }

    #[test]
    fn test_get_accrued_rewards_with_no_total() {
        let mut contract = init_env();
        let campaign = get_campaign();
        let context = get_context(false);
        testing_env!(context);
        let campaign_id = contract.add_reward_campaign(campaign);
        let campaign_result = contract.get_accrued_rewards_per_token(campaign_id);

        assert_eq!(
            BigBalance::zero(),
            campaign_result,
            "Get accrued rewards should return 0 due to empty total supply"
        );
    }

    #[test]
    fn test_get_accrued_rewards_per_token() {
        let mut contract = init_env();
        let campaign = get_campaign();
        let context = get_custom_context(false, 1651362400000000000, 1);
        let total_supply: Balance = 100;
        testing_env!(context);
        contract.mint(contract.get_signer_address(), WBalance::from(total_supply));

        let campaign_id = contract.add_reward_campaign(campaign.clone());
        let campaign_result = contract.get_accrued_rewards_per_token(campaign_id);

        assert_eq!(
            (BigBalance::from(campaign.reward_amount.0) * BigBalance::from(ONE_TOKEN)
                / BigBalance::from(total_supply)),
            campaign_result,
            "Get accrued rewards value doesn't match"
        );
    }

    #[test]
    fn test_get_market_total() {
        let contract = init_env();
        let mut campaign = get_campaign();
        campaign.campaign_type = CampaignType::Supply;
        let supply_total = contract.get_market_total(campaign.clone());
        assert_eq!(
            supply_total.0,
            contract.get_total_supplies(),
            "Supplies total doesn't match"
        );

        campaign.campaign_type = CampaignType::Borrow;
        let borrow_total = contract.get_market_total(campaign);
        assert_eq!(
            borrow_total.0,
            contract.get_total_borrows(),
            "Supplies total doesn't match"
        );
    }

    #[test]
    fn test_get_rewards_per_second() {
        let contract = init_env();
        let campaign = get_campaign();
        let amount = contract.get_rewards_per_second(campaign.clone());

        assert_eq!(
            REWARD_AMOUNT / Balance::from(campaign.end_time - campaign.start_time),
            amount.0,
            "Rewards per second doesn't match"
        );
    }

    #[test]
    fn test_get_reward_tokens_per_day() {
        let contract = init_env();
        let campaign = get_campaign();
        let amount_per_second = contract.get_rewards_per_second(campaign.clone());
        let amount = contract.get_reward_tokens_per_day(campaign);
        assert_eq!(
            24 * 60 * 60 * amount_per_second.0,
            amount.0,
            "Rewards per day doesn't match"
        );
    }

    #[test]
    fn test_remove_reward_campaign() {
        let mut contract = init_env();
        let campaign = get_campaign();
        let context = get_context(false);
        testing_env!(context);

        let campaign_id = contract.add_reward_campaign(campaign);
        assert!(
            contract
                .get_reward_campaign_by_id(campaign_id.clone())
                .is_some(),
            "{}",
            "Campaign with id {campaign_id} wasn't added"
        );

        contract.remove_reward_campaign(campaign_id.clone());
        assert!(
            contract.get_reward_campaign_by_id(campaign_id).is_none(),
            "{}",
            "Campaign with id {campaign_id} wasn't removed"
        );
    }

    #[test]
    fn test_get_reward_campaigns_extended() {
        let mut contract = init_env();
        let campaign = get_campaign();
        let context = get_context(false);
        testing_env!(context);
        contract.add_reward_campaign(campaign.clone());
        contract.add_reward_campaign(campaign.clone());
        contract.add_reward_campaign(campaign.clone());

        let campaign_list = contract.get_reward_campaigns_extended();

        assert_eq!(campaign_list.len(), 3, "Campaign list len doesn't match");

        let gotten_campaign = campaign_list.get(0).unwrap();

        assert_eq!(
            gotten_campaign.rewards_per_day.0,
            contract.get_reward_tokens_per_day(campaign.clone()).0,
            "Values rewards_per_day don't match"
        );
        assert_eq!(
            gotten_campaign.market_total.0,
            contract.get_market_total(campaign).0,
            "Values rewards_per_day don't match"
        );
    }

    #[test]
    fn test_add_reward_campaign() {
        let mut contract = init_env();
        let campaign = get_campaign();
        let context = get_context(false);
        testing_env!(context);
        let campaign_id = contract.add_reward_campaign(campaign.clone());
        assert_eq!(
            campaign_id,
            contract.get_unique_id(),
            "CampaignId doesn't match for expected result"
        );
        let received_campaign = contract.get_reward_campaign_by_id(campaign_id);
        assert!(received_campaign.is_some(), "Campaign wasn't found");
        let received_campaign_unwrapped = received_campaign.unwrap();
        assert_eq!(
            campaign.campaign_type, received_campaign_unwrapped.campaign_type,
            "Campaigns are not similar"
        );
        assert_eq!(
            campaign.start_time, received_campaign_unwrapped.start_time,
            "Campaigns are not similar"
        );
        assert_eq!(
            campaign.end_time, received_campaign_unwrapped.end_time,
            "Campaigns are not similar"
        );
        assert_eq!(
            campaign.token, received_campaign_unwrapped.token,
            "Campaigns are not similar"
        );
        assert_eq!(
            campaign.last_update_time, received_campaign_unwrapped.last_update_time,
            "Campaigns are not similar"
        );
    }
}

'''
'''--- contracts/market/src/supply.rs ---
use crate::*;
use general::ratio::{BigBalance, Ratio};

const GAS_FOR_SUPPLY: Gas = Gas(120_000_000_000_000);

impl Contract {
    pub fn supply(&mut self, token_amount: WBalance) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_SUPPLY,
            "Prepaid gas is not enough for supply flow"
        );
        self.mutex_account_lock(Actions::Supply, token_amount, self.terra_gas(120))
    }
}

#[near_bindgen]
impl Contract {
    pub fn post_supply(&mut self, token_amount: WBalance) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            return PromiseOrValue::Value(self.to_decimals_token(token_amount));
        }
        self.adjust_rewards_by_campaign_type(CampaignType::Supply);

        let balance_of = self.view_contract_balance();

        let exchange_rate = self.get_exchange_rate(balance_of);
        let dtoken_amount = WBalance::from(
            (BigBalance::from(Balance::from(token_amount)) / exchange_rate).round_u128(),
        );

        let interest_rate_model = self.config.get().unwrap().interest_rate_model;
        let supply_rate: Ratio = self.get_supply_rate(
            balance_of,
            U128(self.get_total_borrows()),
            U128(self.get_total_reserves()),
            interest_rate_model.get_reserve_factor(),
        );
        let accrued_interest = self.get_accrued_supply_interest(env::signer_account_id());
        let accrued_supply_interest = interest_rate_model.calculate_accrued_interest(
            supply_rate,
            self.get_account_supplies(env::signer_account_id()),
            accrued_interest,
        );
        self.set_accrued_supply_interest(env::signer_account_id(), accrued_supply_interest);

        // Dtokens minting and adding them to the user account
        self.mint(self.get_signer_address(), dtoken_amount);

        log!(
            "Supply from Account {} to Dtoken contract {} with tokens amount {} was successfully done!",
            self.get_signer_address(),
            self.get_contract_address(),
            Balance::from(token_amount)
        );

        controller::increase_supplies(
            env::signer_account_id(),
            self.get_contract_address(),
            dtoken_amount,
            self.get_controller_address(),
            NO_DEPOSIT,
            self.terra_gas(5),
        )
        .then(ext_self::controller_increase_supplies_callback(
            token_amount,
            dtoken_amount,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(20),
        ))
        .into()
    }

    pub fn get_account_supplies(&self, account: AccountId) -> Balance {
        self.token.accounts.get(&account).unwrap_or_default()
    }

    #[private]
    pub fn controller_increase_supplies_callback(
        &mut self,
        amount: WBalance,
        dtoken_amount: WBalance,
    ) -> PromiseOrValue<U128> {
        if !is_promise_success() {
            log!(
                "{}",
                Events::SupplyFailedToIncreaseSupplyOnController(
                    env::signer_account_id(),
                    Balance::from(amount)
                )
            );
            self.burn(&self.get_signer_address(), dtoken_amount);

            self.mutex_account_unlock();
            return PromiseOrValue::Value(self.to_decimals_token(amount));
        }
        self.update_campaigns_market_total_by_type(CampaignType::Supply);
        log!(
            "{}",
            Events::SupplySuccess(env::signer_account_id(), Balance::from(amount))
        );
        self.increase_contract_balance(amount);

        self.mutex_account_unlock();
        PromiseOrValue::Value(U128(0))
    }
}

'''
'''--- contracts/market/src/upgrade.rs ---
use crate::*;
use near_sdk::PanicOnDefault;

pub trait Upgradable {
    /// function to migrate state with or without new field.
    /// make sure you are using the same method name in upgrade function
    fn migrate() -> Self;

    /// contract versioning
    fn get_version(&self) -> String;

    /// upgrade feature to be called on new deployed contract and read the state of previous contract
    /// using migrate function
    #[cfg(target_arch = "wasm32")]
    fn upgrade(self);
}

#[near_bindgen]
impl Upgradable for Contract {
    #[init(ignore_state)]
    #[private]
    fn migrate() -> Self {
        #[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
        /// Copy of the scheme before upgrade
        struct PreviousStorageSchema {
            // Define previous scheme here
            /// Contract admin account (dtoken itself by default)
            pub admin: AccountId,
            // .. etc
        }

        // read and parse previos storage
        let contract: PreviousStorageSchema =
            env::state_read().expect("Contract is not initialized");

        // initialize new storage from an old schema
        Contract {
            admin: contract.admin,
            ..Contract::default()
        }
    }

    fn get_version(&self) -> String {
        env!("CARGO_PKG_VERSION").to_string()
    }

    #[cfg(target_arch = "wasm32")]
    fn upgrade(self) {
        const GAS_FOR_UPGRADE: u64 = 20 * TGAS.0; //gas occupied by this fn

        //after upgrade we call *pub fn migrate()* on the NEW CODE
        let current_id = env::current_account_id();

        let migrate_method_name = "migrate".as_bytes().to_vec();
        let attached_gas = env::prepaid_gas().0 - env::used_gas().0 - GAS_FOR_UPGRADE;
        unsafe {
            // Load input (new contract code) into register 0
            near_sys::input(0);

            // prepare self-call promise
            let promise_id = near_sys::promise_batch_create(
                current_id.as_bytes().len() as _,
                current_id.as_bytes().as_ptr() as _,
            );

            //1st action, deploy/upgrade code (takes code from register 0)
            near_sys::promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);

            // 2nd action, schedule a call to "migrate()".
            // Will execute on the new code
            near_sys::promise_batch_action_function_call(
                promise_id,
                migrate_method_name.len() as _,
                migrate_method_name.as_ptr() as _,
                0 as _,
                0 as _,
                0 as _,
                attached_gas,
            );
        }
    }
}

'''
'''--- contracts/market/src/user_profile.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct AccruedInterest {
    pub last_recalculation_block: BlockHeight,
    pub accumulated_interest: Balance,
}

// Cannot derive Default as `last_recalculation_block` by default should be current block
impl Default for AccruedInterest {
    fn default() -> Self {
        AccruedInterest {
            last_recalculation_block: env::block_height(),
            accumulated_interest: 0,
        }
    }
}

#[derive(Default, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct UserProfile {
    pub borrows: Balance,

    pub borrow_interest: AccruedInterest,
    pub supply_interest: AccruedInterest,

    pub is_consistent: bool,
}

'''
'''--- contracts/market/src/utils.rs ---
use crate::Contract;

use near_sdk::json_types::U128;

const SYSTEM_DECIMALS: u32 = 24;

impl Contract {
    pub fn to_decimals_system(&self, amount: U128) -> U128 {
        if self.underlying_token_decimals != 24 {
            U128::from(
                amount.0 / 10_u128.pow(self.underlying_token_decimals as u32)
                    * 10_u128.pow(SYSTEM_DECIMALS),
            )
        } else {
            amount
        }
    }

    pub fn to_decimals_token(&self, amount: U128) -> U128 {
        if self.underlying_token_decimals != 24 {
            U128::from(
                amount.0 / 10_u128.pow(SYSTEM_DECIMALS)
                    * 10_u128.pow(self.underlying_token_decimals as u32),
            )
        } else {
            amount
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::InterestRateModel;
    use general::ratio::Ratio;
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::test_env::{alice, bob, carol};

    use crate::{Config, Contract};

    pub fn init_test_env() -> Contract {
        let (dtoken_account, underlying_token_account, controller_account) =
            (alice(), bob(), carol());

        Contract::new(Config {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: underlying_token_account,
            underlying_token_decimals: 6,
            owner_id: dtoken_account,
            controller_account_id: controller_account,
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true,
        })
    }

    #[test]
    fn test_conversion_to_decimals_system() {
        let contract = init_test_env();

        let decimals_token = 6;
        let decimals_system = 24;

        let amount_with_decimals_token = U128(200 * 10_u128.pow(decimals_token));
        let amount_with_decimals_system = contract.to_decimals_system(amount_with_decimals_token);

        assert_eq!(
            amount_with_decimals_system,
            U128(200 * 10_u128.pow(decimals_system))
        );
    }

    #[test]
    fn test_conversion_to_decimals_token() {
        let contract = init_test_env();

        let decimals_token = 6;
        let decimals_system = 24;

        let amount_with_decimals_system = U128(200 * 10_u128.pow(decimals_system));
        let amount_with_decimals_token = contract.to_decimals_token(amount_with_decimals_system);

        assert_eq!(
            amount_with_decimals_token,
            U128(200 * 10_u128.pow(decimals_token))
        );
    }
}

'''
'''--- contracts/market/src/views.rs ---
use crate::*;
use general::ratio::Ratio;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketData {
    pub underlying_token: AccountId,
    /// WARN: should be the same as `underlying_token.ft_metadata.decimals`
    pub underlying_token_decimals: u8,

    /// Total supplies with precision 10^24
    pub total_supplies: WBalance,
    /// Total borrows with precision 10^24
    pub total_borrows: WBalance,
    /// Total reserves with precision 10^24
    pub total_reserves: WBalance,

    pub exchange_rate_ratio: WRatio,
    pub interest_rate_ratio: WRatio,
    pub borrow_rate_ratio: WRatio,
}

#[near_bindgen]
impl Contract {
    pub fn view_contract_balance(&self) -> WBalance {
        WBalance::from(self.contract_balance)
    }

    pub fn view_total_supplies(&self) -> WBalance {
        WBalance::from(self.get_total_supplies())
    }

    pub fn view_total_borrows(&self) -> WBalance {
        WBalance::from(self.get_total_borrows())
    }

    pub fn view_total_reserves(&self) -> WBalance {
        WBalance::from(self.get_total_reserves())
    }

    pub fn view_market_data(&self) -> MarketData {
        let total_supplies = self.get_total_supplies();
        let total_borrows = self.get_total_borrows();
        let total_reserves = self.get_total_reserves();

        let contract_ft_balance = self.view_contract_balance();

        let exchange_rate = self.get_exchange_rate(contract_ft_balance);
        let reserve_factor = self
            .config
            .get()
            .unwrap()
            .interest_rate_model
            .get_reserve_factor();

        let interest_rate = self.get_supply_rate(
            contract_ft_balance,
            WBalance::from(total_borrows),
            WBalance::from(total_reserves),
            reserve_factor,
        );
        let borrow_rate = self.get_borrow_rate(
            contract_ft_balance,
            WBalance::from(total_borrows),
            WBalance::from(total_reserves),
        );

        MarketData {
            underlying_token: self.underlying_token.clone(),
            underlying_token_decimals: self.underlying_token_decimals,
            total_supplies: WBalance::from(total_supplies),
            total_borrows: WBalance::from(total_borrows),
            total_reserves: WBalance::from(total_reserves),
            exchange_rate_ratio: WRatio::from(exchange_rate),
            interest_rate_ratio: WRatio::from(interest_rate),
            borrow_rate_ratio: WRatio::from(borrow_rate),
        }
    }

    pub fn view_repay_info(&self, user_id: AccountId, ft_balance: WBalance) -> RepayInfo {
        self.get_repay_info(user_id, ft_balance)
    }

    pub fn view_exchange_rate(&self, ft_balance: WBalance) -> Ratio {
        self.get_exchange_rate(ft_balance)
    }

    pub fn view_withdraw_info(&self, user_id: AccountId, ft_balance: WBalance) -> WithdrawInfo {
        self.get_withdraw_info(user_id, ft_balance)
    }

    pub fn view_reward_campaigns(&self) -> Vec<RewardCampaignExtended> {
        self.get_reward_campaigns_extended()
    }

    pub fn view_rewards_list(&self, user_id: AccountId) -> HashMap<String, Reward> {
        self.get_rewards_list(user_id)
    }

    pub fn view_reward_state(&self, user_id: AccountId, campaign_id: String) -> RewardState {
        self.get_reward_state(user_id, campaign_id)
    }
}

#[cfg(test)]
mod tests {
    use crate::InterestRateModel;
    use general::ratio::Ratio;
    use general::WBalance;
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    use crate::views::MarketData;
    use crate::{Config, Contract};

    pub fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .signer_account_id(alice())
            .is_view(is_view)
            .build()
    }

    pub fn init_test_env(is_admin: bool) -> Contract {
        let (dtoken_account, underlying_token_account, controller_account) =
            (alice(), bob(), carol());

        if is_admin {
            testing_env!(get_context(false));
        }

        let mut contract = Contract::new(Config {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: underlying_token_account,
            underlying_token_decimals: 24,
            owner_id: dtoken_account,
            controller_account_id: controller_account,
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true,
        });

        if is_admin {
            contract.set_total_reserves(200);
        }

        contract
    }

    #[test]
    fn test_view_repay_info() {
        let contract = init_test_env(false);

        let repay = contract.view_repay_info(bob(), WBalance::from(0));

        assert_eq!(
            // as there are no borrows yet accrued_interest_per_block = 0
            repay.accrued_interest_per_block,
            WBalance::from(Ratio::one()),
            "RepayInfo accrued_interest_per_block is not matches to expected"
        );
        assert_eq!(
            repay.total_amount,
            WBalance::from(0u128),
            "RepayInfo total_amount is not matches to expected"
        );
        assert_eq!(
            repay.borrow_amount,
            WBalance::from(0u128),
            "RepayInfo borrow_amount is not matches to expected"
        );
        assert_eq!(
            repay.accumulated_interest,
            WBalance::from(0u128),
            "RepayInfo accumulated_interest is not matches to expected"
        );
    }

    #[test]
    fn test_view_market_data() {
        let contract = init_test_env(true);

        let gotten_md = contract.view_market_data();

        let _expected_md = MarketData {
            underlying_token: contract.underlying_token,
            underlying_token_decimals: contract.underlying_token_decimals,
            total_supplies: U128(0),
            total_borrows: U128(0),
            total_reserves: U128(200),
            exchange_rate_ratio: U128::from(Ratio::one()),
            interest_rate_ratio: U128(0),
            borrow_rate_ratio: U128::from(Ratio::one()),
        };

        assert_eq!(
            &gotten_md.total_supplies, &_expected_md.total_supplies,
            "Market total supplies values check has been failed"
        );
        assert_eq!(
            &gotten_md.total_borrows, &_expected_md.total_borrows,
            "Market total borrows values check has been failed"
        );
        assert_eq!(
            &gotten_md.total_reserves, &_expected_md.total_reserves,
            "Market total reserves values check has been failed"
        );
        assert_eq!(
            &gotten_md.exchange_rate_ratio, &_expected_md.exchange_rate_ratio,
            "Exchange rate values check has been failed"
        );
        assert_eq!(
            &gotten_md.interest_rate_ratio, &_expected_md.interest_rate_ratio,
            "Interest rate values check has been failed"
        );
        assert_eq!(
            &gotten_md.borrow_rate_ratio, &_expected_md.borrow_rate_ratio,
            "Borrow rate values check has been failed"
        );
    }

    #[test]
    fn test_view_withdraw_info() {
        let contract = init_test_env(false);

        let withdraw_info = contract.view_withdraw_info(bob(), U128(1000));

        // total interest should be 0
        // exchange_rate = initial_exchange_rate = 1000000000000000000000000

        assert_eq!(
            withdraw_info.exchange_rate,
            U128::from(Ratio::one()),
            "Withdraw exchange_rate is not matches to expected"
        );
        assert_eq!(
            withdraw_info.total_interest,
            U128(0),
            "Withdraw total_interest is not matches to expected"
        );
    }
}

'''
'''--- contracts/market/src/withdraw.rs ---
use crate::*;
use general::ratio::Ratio;

const GAS_FOR_WITHDRAW: Gas = Gas(180_000_000_000_000);

impl Contract {
    pub fn post_withdraw(&mut self, dtoken_amount: WBalance) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            return PromiseOrValue::Value(dtoken_amount);
        }
        self.adjust_rewards_by_campaign_type(CampaignType::Supply);

        let balance_of = self.view_contract_balance();

        let exchange_rate: Ratio = self.get_exchange_rate(balance_of);

        let interest_rate_model = self.config.get().unwrap().interest_rate_model;

        let supply_rate: Ratio = self.get_supply_rate(
            balance_of,
            U128(self.get_total_borrows()),
            U128(self.get_total_reserves()),
            interest_rate_model.get_reserve_factor(),
        );

        let accrued_supply_interest = interest_rate_model.calculate_accrued_interest(
            supply_rate,
            self.get_account_supplies(env::signer_account_id()),
            self.get_accrued_supply_interest(env::signer_account_id()),
        );

        let token_amount: Balance =
            (Ratio::from(Balance::from(dtoken_amount)) * exchange_rate).round_u128();

        let whole_amount: Balance = token_amount + accrued_supply_interest.accumulated_interest;

        self.set_accrued_supply_interest(env::signer_account_id(), accrued_supply_interest);

        controller::withdraw_supplies(
            env::signer_account_id(),
            self.get_contract_address(),
            dtoken_amount,
            self.get_controller_address(),
            NO_DEPOSIT,
            self.terra_gas(10),
        )
        .then(ext_self::withdraw_supplies_callback(
            env::signer_account_id(),
            token_amount.into(),
            dtoken_amount,
            whole_amount.into(),
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(80),
        ))
        .into()
    }
}

#[near_bindgen]
impl Contract {
    pub fn withdraw(&mut self, amount: WBalance) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_WITHDRAW,
            "Prepaid gas is not enough for withdraw flow"
        );
        assert!(
            Balance::from(amount) > 0,
            "Amount should be a positive number"
        );
        assert!(
            amount.0
                <= self
                    .token
                    .accounts
                    .get(&env::signer_account_id())
                    .unwrap_or(0),
            "The account doesn't have enough digital tokens to do withdraw"
        );
        self.mutex_account_lock(Actions::Withdraw, amount, GAS_FOR_WITHDRAW)
    }

    #[private]
    pub fn withdraw_supplies_callback(
        &mut self,
        user_account: AccountId,
        token_amount: WBalance,
        dtoken_amount: WBalance,
        whole_amount: WBalance,
    ) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            log!(
                "{}",
                Events::WithdrawFailedToDecreaseSupplyOnController(
                    env::signer_account_id(),
                    Balance::from(dtoken_amount),
                    self.get_contract_address()
                )
            );
            self.mutex_account_unlock();
            return PromiseOrValue::Value(dtoken_amount);
        }

        // Cross-contract call to market token
        underlying_token::ft_transfer(
            user_account,
            self.to_decimals_token(whole_amount),
            Some(format!(
                "Withdraw with token_amount {}",
                Balance::from(whole_amount)
            )),
            self.get_underlying_contract_address(),
            ONE_YOCTO,
            self.terra_gas(10),
        )
        .then(ext_self::withdraw_ft_transfer_call_callback(
            token_amount,
            dtoken_amount,
            env::current_account_id(),
            NO_DEPOSIT,
            self.terra_gas(30),
        ))
        .into()
    }

    #[private]
    pub fn withdraw_ft_transfer_call_callback(
        &mut self,
        token_amount: WBalance,
        dtoken_amount: WBalance,
    ) -> PromiseOrValue<WBalance> {
        if is_promise_success() {
            self.burn(&env::signer_account_id(), dtoken_amount);
            self.mutex_account_unlock();
            log!(
                "{}",
                Events::WithdrawSuccess(env::signer_account_id(), Balance::from(dtoken_amount))
            );
            self.set_accrued_supply_interest(env::signer_account_id(), AccruedInterest::default());

            self.decrease_contract_balance(dtoken_amount);

            PromiseOrValue::Value(dtoken_amount)
        } else {
            controller::increase_supplies(
                env::signer_account_id(),
                self.get_contract_address(),
                token_amount,
                self.get_controller_address(),
                NO_DEPOSIT,
                self.terra_gas(5),
            )
            .then(ext_self::withdraw_increase_supplies_callback(
                token_amount,
                env::current_account_id(),
                NO_DEPOSIT,
                self.terra_gas(10),
            ))
            .into()
        }
    }

    #[private]
    pub fn withdraw_increase_supplies_callback(
        &mut self,
        token_amount: WBalance,
    ) -> PromiseOrValue<WBalance> {
        if !is_promise_success() {
            self.add_inconsistent_account(env::signer_account_id());
            log!(
                "{}",
                Events::WithdrawFailedToFallback(
                    env::signer_account_id(),
                    Balance::from(token_amount)
                )
            );
            return PromiseOrValue::Value(token_amount);
        }
        self.update_campaigns_market_total_by_type(CampaignType::Supply);
        self.mutex_account_unlock();
        log!(
            "{}",
            Events::WithdrawFallbackSuccess(env::signer_account_id(), Balance::from(token_amount))
        );
        PromiseOrValue::Value(token_amount)
    }
}

'''
'''--- contracts/market/tests/sim/borrow/borrow_more_than_allowed.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_three_dtokens, initialize_three_utokens,
    mint_tokens, new_user, set_price, supply, view_balance,
};
use controller::ActionType::Borrow;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 10;
const WNEAR_AMOUNT: Balance = 10;
const BORROW_AMOUNT: Balance = 21;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;

fn borrow_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let (_, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    let mint_amount = U128(START_BALANCE);
    mint_tokens(&weth, weth_market.account_id(), mint_amount);
    mint_tokens(&wnear, wnear_market.account_id(), mint_amount);
    mint_tokens(&wbtc, dwbtc.account_id(), mint_amount);
    mint_tokens(&weth, user.account_id(), U128(WETH_AMOUNT));
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_AMOUNT));
    mint_tokens(&wbtc, user.account_id(), U128(0));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();

    (dwbtc, controller, wbtc, user)
}

#[test]
fn scenario_borrow_zero_tokens() {
    let (dwbtc, controller, wbtc, user) = borrow_fixture();

    borrow(&user, &dwbtc, BORROW_AMOUNT).assert_success();

    let user_balance: Balance =
        view_balance(&controller, Borrow, user.account_id(), dwbtc.account_id());
    assert_eq!(
        user_balance, 0,
        "User borrow balance on controller should be 0"
    );

    let user_balance: Balance = view!(dwbtc.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(user_balance, 0, "User borrow balance on dtoken should be 0");

    let user_balance: U128 = view!(wbtc.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance, U128(0), "User utoken balance should be 0");

    let dtoken_balance: U128 = view!(wbtc.ft_balance_of(dwbtc.account_id())).unwrap_json();
    assert_eq!(
        dtoken_balance,
        U128(START_BALANCE),
        "Dtoken balance on utoken should be {}",
        START_BALANCE
    );
}

'''
'''--- contracts/market/tests/sim/borrow/borrow_success.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_three_dtokens, initialize_three_utokens,
    mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance,
};
use controller::ActionType::Borrow;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 10;
const WNEAR_AMOUNT: Balance = 10;
const BORROW_AMOUNT: Balance = 11;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;
const RESERVE_AMOUNT: Balance = 100;

fn borrow_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, RESERVE_AMOUNT);

    mint_tokens(&weth, user.account_id(), U128(WETH_AMOUNT));
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_AMOUNT));
    mint_tokens(&wbtc, user.account_id(), U128(0));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();

    (dwbtc, controller, wbtc, user)
}

#[test]
fn scenario_borrow() {
    let (dwbtc, controller, wbtc, user) = borrow_fixture();

    borrow(&user, &dwbtc, BORROW_AMOUNT).assert_success();

    let user_balance: Balance =
        view_balance(&controller, Borrow, user.account_id(), dwbtc.account_id());
    assert_eq!(
        user_balance, BORROW_AMOUNT,
        "User borrow balance on controller should be {}",
        BORROW_AMOUNT
    );

    let user_balance: Balance = view!(dwbtc.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance, BORROW_AMOUNT,
        "User borrow balance on dtoken should be 10"
    );

    let user_balance: U128 = view!(wbtc.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance,
        U128(BORROW_AMOUNT),
        "User utoken balance should be {}",
        BORROW_AMOUNT
    );

    let dtoken_balance: U128 = view!(wbtc.ft_balance_of(dwbtc.account_id())).unwrap_json();
    assert_eq!(
        dtoken_balance,
        U128(START_BALANCE - BORROW_AMOUNT),
        "Dtoken balance on utoken should be {}",
        START_BALANCE - BORROW_AMOUNT
    );
}

'''
'''--- contracts/market/tests/sim/borrow/borrow_success_after_failure.rs ---
use crate::utils::{
    add_market, assert_failure, borrow, initialize_controller, initialize_three_dtokens,
    initialize_three_utokens, mint_and_reserve, mint_tokens, new_user, set_price, supply,
    view_balance,
};
use controller::ActionType::Borrow;
use general::Price;
use market::InterestRateModel;
use near_sdk::json_types::U128;
use near_sdk::Balance;
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 10;
const WNEAR_AMOUNT: Balance = 10;
const BORROW_AMOUNT: Balance = 11;
const WBTC_START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;
const RESERVE_AMOUNT: Balance = 100;

fn borrow_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, RESERVE_AMOUNT);

    mint_tokens(&weth, user.account_id(), U128(WETH_AMOUNT));
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_AMOUNT));
    mint_tokens(&wbtc, user.account_id(), U128(0));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();

    (dwbtc, controller, wbtc, user)
}

#[test]
fn scenario_borrow_zero_tokens() {
    let (dwbtc, controller, wbtc, user) = borrow_fixture();

    let result = borrow(&user, &dwbtc, 0);
    assert_failure(result, "Amount should be a positive number");

    borrow(&user, &dwbtc, BORROW_AMOUNT).assert_success();

    let user_balance: Balance =
        view_balance(&controller, Borrow, user.account_id(), dwbtc.account_id());
    assert_eq!(
        user_balance, BORROW_AMOUNT,
        "User borrow balance on controller should be {}",
        BORROW_AMOUNT
    );

    let user_balance: Balance = view!(dwbtc.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance, BORROW_AMOUNT,
        "User borrow balance on dtoken should be {}",
        BORROW_AMOUNT
    );

    let user_balance: U128 = view!(wbtc.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance,
        U128(BORROW_AMOUNT),
        "User utoken balance should be {}",
        BORROW_AMOUNT
    );

    let dtoken_balance: U128 = view!(wbtc.ft_balance_of(dwbtc.account_id())).unwrap_json();
    assert_eq!(
        dtoken_balance,
        U128(WBTC_START_BALANCE - BORROW_AMOUNT),
        "Dtoken balance on utoken should be {}",
        WBTC_START_BALANCE - BORROW_AMOUNT
    );
}

'''
'''--- contracts/market/tests/sim/borrow/borrow_undercollateralized.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_three_dtokens, initialize_three_utokens,
    mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance,
};
use controller::ActionType::Borrow;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{call, init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 5;
const WNEAR_AMOUNT: Balance = 5;
const BORROW_AMOUNT: Balance = 11;
const START_BALANCE: Balance = 1000;
const START_PRICE: Balance = 10000;
const RESERVE_AMOUNT: Balance = 1000;

fn borrow_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);

    mint_tokens(&weth, user.account_id(), U128(WETH_AMOUNT));
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_AMOUNT));
    mint_tokens(&wbtc, user.account_id(), U128(0));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();

    (dwbtc, controller, wbtc, user)
}

#[test]
fn scenario_undercollaterilazied_borrow() {
    let (dwbtc, controller, wbtc, user) = borrow_fixture();

    call!(
        dwbtc.user_account,
        dwbtc.set_admin(user.account_id.clone()),
        deposit = 0
    );
    call!(
        controller.user_account,
        controller.set_admin(user.account_id.clone()),
        deposit = 0
    );
    call!(
        dwbtc.user_account,
        dwbtc.set_eligible_to_borrow_uncollateralized_account(user.account_id.clone()),
        deposit = 0
    );
    call!(
        controller.user_account,
        controller.set_eligible_to_borrow_uncollateralized_account(user.account_id.clone()),
        deposit = 0
    );

    let leverage = 2u128;

    // borrowing 2 times more

    borrow(&user, &dwbtc, BORROW_AMOUNT * leverage).assert_success();

    let user_balance: Balance =
        view_balance(&controller, Borrow, user.account_id(), dwbtc.account_id());

    assert_eq!(
        user_balance,
        BORROW_AMOUNT * leverage,
        "User borrow balance on controller should be {}",
        BORROW_AMOUNT * leverage
    );

    let user_balance: Balance = view!(dwbtc.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance,
        BORROW_AMOUNT * leverage,
        "User borrow balance on dtoken should be {}",
        BORROW_AMOUNT * leverage
    );

    let user_balance: U128 = view!(wbtc.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance,
        U128(BORROW_AMOUNT * leverage),
        "User utoken balance should be {}",
        BORROW_AMOUNT * leverage
    );

    let dtoken_balance: U128 = view!(wbtc.ft_balance_of(dwbtc.account_id())).unwrap_json();
    assert_eq!(
        dtoken_balance,
        U128(START_BALANCE - BORROW_AMOUNT * leverage),
        "Dtoken balance on utoken should be {}",
        START_BALANCE - BORROW_AMOUNT * leverage
    );
}

'''
'''--- contracts/market/tests/sim/borrow/borrow_zero_tokens.rs ---
use crate::utils::{
    add_market, assert_failure, borrow, initialize_controller, initialize_three_dtokens,
    initialize_three_utokens, mint_and_reserve, mint_tokens, new_user, set_price, supply,
    view_balance,
};
use controller::ActionType::Borrow;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 10;
const WNEAR_AMOUNT: Balance = 10;
const BORROW_AMOUNT: Balance = 0;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;
const RESERVE_AMOUNT: Balance = 100;

fn borrow_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, RESERVE_AMOUNT);

    mint_tokens(&weth, user.account_id(), U128(WETH_AMOUNT));
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_AMOUNT));
    mint_tokens(&wbtc, user.account_id(), U128(0));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();

    (dwbtc, controller, wbtc, user)
}

#[test]
fn scenario_borrow_zero_tokens() {
    let (dwbtc, controller, wbtc, user) = borrow_fixture();

    let result = borrow(&user, &dwbtc, BORROW_AMOUNT);
    assert_failure(result, "Amount should be a positive number");

    let user_balance: Balance =
        view_balance(&controller, Borrow, user.account_id(), dwbtc.account_id());
    assert_eq!(
        user_balance, BORROW_AMOUNT,
        "User borrow balance on controller should be {}",
        BORROW_AMOUNT
    );

    let user_balance: Balance = view!(dwbtc.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance, BORROW_AMOUNT,
        "User borrow balance on dtoken should be 10"
    );

    let user_balance: U128 = view!(wbtc.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance,
        U128(BORROW_AMOUNT),
        "User utoken balance should be {}",
        BORROW_AMOUNT
    );

    let dtoken_balance: U128 = view!(wbtc.ft_balance_of(dwbtc.account_id())).unwrap_json();
    assert_eq!(
        dtoken_balance,
        U128(START_BALANCE),
        "Dtoken balance on utoken should be {}",
        START_BALANCE
    );
}

'''
'''--- contracts/market/tests/sim/borrow/mod.rs ---
mod borrow_more_than_allowed;
mod borrow_success;
mod borrow_success_after_failure;
mod borrow_undercollateralized;
mod borrow_zero_tokens;

'''
'''--- contracts/market/tests/sim/liquidation/liquidation_fail_as_liquidator_is_borrower.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_two_dtokens, initialize_two_utokens,
    liquidate, mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance,
};
use controller::ActionType::{Borrow, Supply};
use general::Price;
use market::InterestRateModel;
use near_sdk::json_types::U128;
use near_sdk::Balance;
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const BORROWER_SUPPLY: Balance = 60000;
const BORROWER_BORROW: Balance = 40000;
const MINT_BALANCE: Balance = 100000000000;
const START_PRICE: Balance = 2000;
const CHANGED_PRICE: Balance = 1200;
const RESERVE_AMOUNT: Balance = 100000000000;

fn liquidation_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
    UserAccount,
) {
    let root = init_simulator(None);

    // Initialize
    let borrower = new_user(&root, "borrower".parse().unwrap());
    let liquidator = new_user(&root, "liquidator".parse().unwrap());
    let (weth, wnear) = initialize_two_utokens(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market, wnear_market) = initialize_two_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    let mint_amount = U128(MINT_BALANCE);
    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);

    mint_tokens(&weth, borrower.account_id(), mint_amount);
    mint_tokens(&wnear, liquidator.account_id(), mint_amount);
    mint_tokens(&weth, liquidator.account_id(), mint_amount);
    mint_tokens(&wnear, borrower.account_id(), mint_amount);
    mint_tokens(&wnear, borrower.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(
        &borrower,
        &wnear,
        wnear_market.account_id(),
        BORROWER_SUPPLY,
    )
    .assert_success();

    borrow(&borrower, &weth_market, BORROWER_BORROW).assert_success();

    let user_balance: Balance =
        view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
    assert_eq!(
        user_balance, BORROWER_BORROW,
        "Borrow balance on dtoken should be {}",
        BORROWER_BORROW
    );

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        borrower.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_balance, BORROWER_BORROW,
        "Borrow balance on controller should be {}",
        BORROWER_BORROW
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(CHANGED_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    (
        weth_market,
        wnear_market,
        controller,
        weth,
        wnear,
        borrower,
        liquidator,
    )
}

#[test]
fn scenario_liquidation_fail_as_liquidator_is_borrower() {
    let (weth_market, wnear_market, controller, weth, _wnear, borrower, liquidator) =
        liquidation_fixture();

    let amount = 3500;

    liquidate(
        &liquidator,
        &liquidator,
        &weth_market,
        &wnear_market,
        &weth,
        amount,
    )
    .assert_success();

    let user_borrows: Balance =
        view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
    assert_eq!(
        user_borrows, BORROWER_BORROW,
        "Borrow balance on dtoken should be BORROWER_BORROW"
    );

    let user_borrows: Balance = view_balance(
        &controller,
        Borrow,
        borrower.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_borrows, BORROWER_BORROW,
        "Borrow balance on controller should be BORROWER_BORROW"
    );

    let user_balance: Balance = view_balance(
        &controller,
        Supply,
        liquidator.account_id(),
        wnear_market.account_id(),
    );

    assert_eq!(user_balance, 0, "Supply balance on dtoken should be 0");
}

'''
'''--- contracts/market/tests/sim/liquidation/liquidation_fail_due_to_low_health_factor.rs ---
// use std::str::FromStr;

// use crate::utils::{
//     add_market, borrow, initialize_controller, initialize_two_dtokens, initialize_two_utokens,
//     liquidate, mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance,
// };
// use controller::ActionType::{Borrow, Supply};
// use market::InterestRateModel;
// use general::ratio::Ratio;
// use general::Price;
// use near_sdk::json_types::U128;
// use near_sdk::Balance;
// use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

// const RESERVE_AMOUNT: Balance = 100000000000;
// const BORROWER_SUPPLY: Balance = 60000;
// const BORROWER_BORROW: Balance = 40000;
// const MINT_BALANCE: Balance = 100000000000;
// const START_PRICE: Balance = 2000;
// const CHANGED_PRICE: Balance = 1200;

// fn liquidation_fixture() -> (
//     ContractAccount<market::ContractContract>,
//     ContractAccount<market::ContractContract>,
//     ContractAccount<controller::ContractContract>,
//     ContractAccount<mock_token::ContractContract>,
//     ContractAccount<mock_token::ContractContract>,
//     UserAccount,
//     UserAccount,
// ) {
//     let root = init_simulator(None);

//     // Initialize
//     let borrower = new_user(&root, "borrower".parse().unwrap());
//     let liquidator = new_user(&root, "liquidator".parse().unwrap());
//     let (weth, wnear) = initialize_two_utokens(&root);
//     let controller = initialize_controller(&root);
//     let (droot, weth_market, wnear_market) = initialize_two_dtokens(
//         &root,
//         weth.account_id(),
//         wnear.account_id(),
//         controller.account_id(),
//         InterestRateModel::default(),
//         InterestRateModel::default(),
//     );

//     mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
//     mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);

//     let mint_amount = U128(MINT_BALANCE);
//     mint_tokens(&weth, borrower.account_id(), mint_amount);
//     mint_tokens(&wnear, liquidator.account_id(), mint_amount);
//     mint_tokens(&weth, liquidator.account_id(), mint_amount);
//     mint_tokens(&wnear, borrower.account_id(), mint_amount);
//     mint_tokens(&wnear, borrower.account_id(), mint_amount);

//     add_market(
//         &controller,
//         weth.account_id(),
//         weth_market.account_id(),
//         "weth".to_string(),
//     );

//     add_market(
//         &controller,
//         wnear.account_id(),
//         wnear_market.account_id(),
//         "wnear".to_string(),
//     );

//     set_price(
//         &controller,
//         weth_market.account_id(),
//         &Price {
//             ticker_id: "weth".to_string(),
//             value: U128(START_PRICE),
//             volatility: U128(100),
//             fraction_digits: 4,
//         },
//     );

//     set_price(
//         &controller,
//         wnear_market.account_id(),
//         &Price {
//             ticker_id: "wnear".to_string(),
//             value: U128(START_PRICE),
//             volatility: U128(100),
//             fraction_digits: 4,
//         },
//     );

//     supply(&borrower, &wnear, wnear_market.account_id(), BORROWER_SUPPLY).assert_success();

//     borrow(&borrower, &weth_market, BORROWER_BORROW).assert_success();

//     let user_balance: Balance =
//         view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
//     assert_eq!(
//         user_balance, BORROWER_BORROW,
//         "Borrow balance on dtoken should be {}",
//         BORROWER_BORROW
//     );

//     let user_balance: Balance = view_balance(
//         &controller,
//         Borrow,
//         borrower.account_id(),
//         weth_market.account_id(),
//     );
//     assert_eq!(
//         user_balance, BORROWER_BORROW,
//         "Borrow balance on controller should be {}",
//         BORROWER_BORROW
//     );

//     set_price(
//         &controller,
//         wnear_market.account_id(),
//         &Price {
//             ticker_id: "wnear".to_string(),
//             value: U128(CHANGED_PRICE),
//             volatility: U128(100),
//             fraction_digits: 4,
//         },
//     );

//     let health_factor: Ratio =
//         view!(controller.get_health_factor(borrower.account_id())).unwrap_json();
//     assert_eq!(health_factor, Ratio::from_str("0.9").unwrap());

//     (weth_market, wnear_market, controller, weth, wnear, borrower, liquidator)
// }

// #[test]
// fn scenario_liquidation_fail_due_to_low_health_factor() {
//     let (weth_market, wnear_market, controller, weth, _wnear, borrower, liquidator) = liquidation_fixture();

//     let amount = 4500;

//     liquidate(&borrower, &liquidator, &weth_market, &wnear_market, &weth, amount).assert_success();

//     let user_borrows: Balance =
//         view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
//     assert_eq!(
//         user_borrows, BORROWER_BORROW,
//         "Borrow balance on dtoken should be {}",
//         BORROWER_BORROW
//     );

//     let user_borrows: Balance = view_balance(
//         &controller,
//         Borrow,
//         borrower.account_id(),
//         weth_market.account_id(),
//     );
//     assert_eq!(
//         user_borrows, BORROWER_BORROW,
//         "Borrow balance on controller should be {}",
//         BORROWER_BORROW
//     );

//     let user_balance: Balance = view_balance(
//         &controller,
//         Supply,
//         liquidator.account_id(),
//         wnear_market.account_id(),
//     );

//     assert_eq!(user_balance, 0, "Supply balance on dtoken should be 0");
// }

'''
'''--- contracts/market/tests/sim/liquidation/liquidation_fail_not_allowed_amount.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_two_dtokens, initialize_two_utokens,
    liquidate, mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance,
};
use controller::ActionType::{Borrow, Supply};
use general::Price;
use market::InterestRateModel;
use near_sdk::json_types::U128;
use near_sdk::Balance;
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const BORROWER_SUPPLY: Balance = 60000;
const BORROWER_BORROW: Balance = 40000;
const MINT_BALANCE: Balance = 100000000000;
const START_PRICE: Balance = 2000;
const CHANGED_PRICE: Balance = 1200;
const RESERVE_AMOUNT: Balance = 100000000000;

fn liquidation_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
    UserAccount,
) {
    let root = init_simulator(None);

    // Initialize
    let borrower = new_user(&root, "borrower".parse().unwrap());
    let liquidator = new_user(&root, "liquidator".parse().unwrap());
    let (weth, wnear) = initialize_two_utokens(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market, wnear_market) = initialize_two_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    let mint_amount = U128(MINT_BALANCE);
    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);

    mint_tokens(&weth, borrower.account_id(), mint_amount);
    mint_tokens(&wnear, liquidator.account_id(), mint_amount);
    mint_tokens(&weth, liquidator.account_id(), mint_amount);
    mint_tokens(&wnear, borrower.account_id(), mint_amount);
    mint_tokens(&wnear, borrower.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(
        &borrower,
        &wnear,
        wnear_market.account_id(),
        BORROWER_SUPPLY,
    )
    .assert_success();

    borrow(&borrower, &weth_market, BORROWER_BORROW).assert_success();

    let user_balance: Balance =
        view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
    assert_eq!(
        user_balance, BORROWER_BORROW,
        "Borrow balance on dtoken should be {}",
        BORROWER_BORROW
    );

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        borrower.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_balance, BORROWER_BORROW,
        "Borrow balance on controller should be {}",
        BORROWER_BORROW
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(CHANGED_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    (
        weth_market,
        wnear_market,
        controller,
        weth,
        wnear,
        borrower,
        liquidator,
    )
}

#[test]
fn scenario_liquidation_failed_on_too_much_for_liquidation() {
    let (weth_market, wnear_market, controller, weth, _wnear, borrower, liquidator) =
        liquidation_fixture();

    let amount = 70000;
    liquidate(
        &borrower,
        &liquidator,
        &weth_market,
        &wnear_market,
        &weth,
        amount,
    )
    .assert_success();

    let user_borrows: Balance =
        view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
    assert_eq!(
        user_borrows, BORROWER_BORROW,
        "Borrow balance on dtoken should be BORROWER_BORROW"
    );

    let user_borrows: Balance = view_balance(
        &controller,
        Borrow,
        borrower.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_borrows, BORROWER_BORROW,
        "Borrow balance on controller should be BORROWER_BORROW"
    );

    let user_balance: Balance = view_balance(
        &controller,
        Supply,
        liquidator.account_id(),
        wnear_market.account_id(),
    );

    assert_eq!(user_balance, 0, "Supply balance on dtoken should be 0");
}

'''
'''--- contracts/market/tests/sim/liquidation/liquidation_failed_on_call_with_wrong_borrow_token.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_two_dtokens, initialize_two_utokens,
    liquidate, mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance,
};
use controller::ActionType::{Borrow, Supply};
use general::Price;
use market::InterestRateModel;
use near_sdk::json_types::U128;
use near_sdk::Balance;
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const BORROWER_SUPPLY: Balance = 60000;
const BORROWER_BORROW: Balance = 40000;
const MINT_BALANCE: Balance = 100000000000;
const START_PRICE: Balance = 2000;
const CHANGED_PRICE: Balance = 1200;
const RESERVE_AMOUNT: Balance = 100000000000;

fn liquidation_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
    UserAccount,
) {
    let root = init_simulator(None);

    // Initialize
    let borrower = new_user(&root, "borrower".parse().unwrap());
    let liquidator = new_user(&root, "liquidator".parse().unwrap());
    let (weth, wnear) = initialize_two_utokens(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market, wnear_market) = initialize_two_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    let mint_amount = U128(MINT_BALANCE);

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);

    mint_tokens(&weth, borrower.account_id(), mint_amount);
    mint_tokens(&wnear, liquidator.account_id(), mint_amount);
    mint_tokens(&weth, liquidator.account_id(), mint_amount);
    mint_tokens(&wnear, borrower.account_id(), mint_amount);
    mint_tokens(&wnear, borrower.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(
        &borrower,
        &wnear,
        wnear_market.account_id(),
        BORROWER_SUPPLY,
    )
    .assert_success();

    borrow(&borrower, &weth_market, BORROWER_BORROW).assert_success();

    let user_balance: Balance =
        view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
    assert_eq!(
        user_balance, BORROWER_BORROW,
        "Borrow balance on dtoken should be {}",
        BORROWER_BORROW
    );

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        borrower.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_balance, BORROWER_BORROW,
        "Borrow balance on controller should be {}",
        BORROWER_BORROW
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(CHANGED_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    (
        weth_market,
        wnear_market,
        controller,
        weth,
        wnear,
        borrower,
        liquidator,
    )
}

#[test]
fn scenario_liquidation_failed_on_call_with_wrong_borrow_token() {
    let (weth_market, wnear_market, controller, weth, _wnear, borrower, liquidator) =
        liquidation_fixture();

    let amount = 70000;
    liquidate(
        &borrower,
        &liquidator,
        &wnear_market,
        &wnear_market,
        &weth,
        amount,
    );

    let user_borrows: Balance =
        view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
    assert_eq!(
        user_borrows, BORROWER_BORROW,
        "Borrow balance on dtoken should be BORROWER_BORROW"
    );

    let user_borrows: Balance = view_balance(
        &controller,
        Borrow,
        borrower.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_borrows, BORROWER_BORROW,
        "Borrow balance on controller should be BORROWER_BORROW"
    );

    let user_balance: Balance = view_balance(
        &controller,
        Supply,
        liquidator.account_id(),
        wnear_market.account_id(),
    );

    assert_eq!(user_balance, 0, "Supply balance on dtoken should be 0");
}

'''
'''--- contracts/market/tests/sim/liquidation/liquidation_success.rs ---
// use std::str::FromStr;

// use crate::utils::{
//     add_market, borrow, initialize_controller, initialize_two_dtokens, initialize_two_utokens,
//     liquidate, mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance,
// };
// use controller::get_default_liquidation_incentive;
// use controller::ActionType::{Borrow, Supply};
// use market::InterestRateModel;
// use general::ratio::Ratio;
// use general::Price;
// use near_sdk::json_types::U128;
// use near_sdk::Balance;
// use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

// const RESERVE_AMOUNT: Balance = 100000000000;
// const BORROWER_SUPPLY: Balance = 60000;
// const BORROWER_BORROW: Balance = 40000;
// const MINT_BALANCE: Balance = 100000000000;
// const START_PRICE: Balance = 2000;
// const CHANGED_PRICE: Balance = 1200;

// fn liquidation_success_fixture() -> (
//     ContractAccount<market::ContractContract>,
//     ContractAccount<market::ContractContract>,
//     ContractAccount<controller::ContractContract>,
//     ContractAccount<mock_token::ContractContract>,
//     ContractAccount<mock_token::ContractContract>,
//     UserAccount,
//     UserAccount,
// ) {
//     let root = init_simulator(None);

//     // Initialize
//     let borrower = new_user(&root, "borrower".parse().unwrap());
//     let liquidator = new_user(&root, "liquidator".parse().unwrap());
//     let (weth, wnear) = initialize_two_utokens(&root);
//     let controller = initialize_controller(&root);
//     let (droot, weth_market, wnear_market) = initialize_two_dtokens(
//         &root,
//         weth.account_id(),
//         wnear.account_id(),
//         controller.account_id(),
//         InterestRateModel::default(),
//         InterestRateModel::default(),
//     );

//     mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
//     mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);

//     let mint_amount = U128(MINT_BALANCE);
//     mint_tokens(&weth, borrower.account_id(), mint_amount);
//     mint_tokens(&wnear, liquidator.account_id(), mint_amount);
//     mint_tokens(&weth, liquidator.account_id(), mint_amount);
//     mint_tokens(&wnear, borrower.account_id(), mint_amount);

//     add_market(
//         &controller,
//         weth.account_id(),
//         weth_market.account_id(),
//         "weth".to_string(),
//     );

//     add_market(
//         &controller,
//         wnear.account_id(),
//         wnear_market.account_id(),
//         "wnear".to_string(),
//     );

//     set_price(
//         &controller,
//         weth_market.account_id(),
//         &Price {
//             ticker_id: "weth".to_string(),
//             value: U128(START_PRICE),
//             volatility: U128(100),
//             fraction_digits: 4,
//         },
//     );

//     set_price(
//         &controller,
//         wnear_market.account_id(),
//         &Price {
//             ticker_id: "wnear".to_string(),
//             value: U128(START_PRICE),
//             volatility: U128(100),
//             fraction_digits: 4,
//         },
//     );

//     supply(&borrower, &wnear, wnear_market.account_id(), BORROWER_SUPPLY).assert_success();
//     let health_factor: Ratio =
//         view!(controller.get_health_factor(borrower.account_id())).unwrap_json();
//     assert_eq!(
//         health_factor,
//         Ratio::from_str("1.5").unwrap(),
//         "health factor should be default eq to 150%"
//     );

//     borrow(&borrower, &weth_market, BORROWER_BORROW).assert_success();
//     let health_factor: Ratio =
//         view!(controller.get_health_factor(borrower.account_id())).unwrap_json();
//     assert_eq!(
//         health_factor,
//         Ratio::from_str("1.5").unwrap(),
//         "health factor should be eq to 150%"
//     );

//     let user_balance: Balance =
//         view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();
//     assert_eq!(
//         user_balance, BORROWER_BORROW,
//         "Borrow balance on dtoken should be {}",
//         BORROWER_BORROW
//     );

//     let user_balance: Balance = view_balance(
//         &controller,
//         Borrow,
//         borrower.account_id(),
//         weth_market.account_id(),
//     );
//     assert_eq!(
//         user_balance, BORROWER_BORROW,
//         "Borrow balance on controller should be {}",
//         BORROWER_BORROW
//     );

//     set_price(
//         &controller,
//         wnear_market.account_id(),
//         &Price {
//             ticker_id: "wnear".to_string(),
//             value: U128(CHANGED_PRICE),
//             volatility: U128(100),
//             fraction_digits: 4,
//         },
//     );
//     let health_factor: Ratio =
//         view!(controller.get_health_factor(borrower.account_id())).unwrap_json();
//     assert_eq!(health_factor, Ratio::from_str("0.9").unwrap());

//     (weth_market, wnear_market, controller, weth, wnear, borrower, liquidator)
// }

// #[test]
// fn scenario_liquidation_success() {
//     let (weth_market, wnear_market, controller, weth, _wnear, borrower, liquidator) =
//         liquidation_success_fixture();

//     let liquidation_amount = 3500;

//     liquidate(
//         &borrower,
//         &liquidator,
//         &weth_market,
//         &wnear_market,
//         &weth,
//         liquidation_amount,
//     )
//     .assert_success();

//     let weth_ft_balance_of_for_weth_market: U128 =
//         view!(weth.ft_balance_of(weth_market.account_id())).unwrap_json();

//     assert_eq!(
//         Balance::from(weth_ft_balance_of_for_weth_market),
//         (MINT_BALANCE - BORROWER_BORROW + liquidation_amount),
//         "weth_market_balance_of_on_weth balance of should be {}",
//         (MINT_BALANCE - BORROWER_BORROW + liquidation_amount)
//     );

//     let user_borrows: Balance =
//         view!(weth_market.get_account_borrows(borrower.account_id())).unwrap_json();

//     let borrow_balance = BORROWER_BORROW - liquidation_amount;

//     assert_eq!(
//         user_borrows,
//         borrow_balance.clone(),
//         "Borrow balance on dtoken should be {}",
//         borrow_balance.clone()
//     );

//     let user_borrows: Balance = view_balance(
//         &controller,
//         Borrow,
//         borrower.account_id(),
//         weth_market.account_id(),
//     );
//     assert_eq!(
//         user_borrows,
//         borrow_balance.clone(),
//         "Borrow balance on controller should be {}",
//         borrow_balance
//     );

//     let user_balance: Balance = view_balance(
//         &controller,
//         Supply,
//         liquidator.account_id(),
//         wnear_market.account_id(),
//     );

//     // 100% + 5% * liquidation_amount * old_price / new_price
//     let revenue_amount: Balance = ((Ratio::one() + get_default_liquidation_incentive())
//         * Ratio::from(liquidation_amount)
//         * Ratio::from(START_PRICE)
//         / Ratio::from(CHANGED_PRICE))
//     .round_u128();

//     assert_eq!(
//         user_balance,
//         revenue_amount.clone(),
//         "Supply balance on dtoken should be {}",
//         revenue_amount.clone()
//     );

//     let borrower_wnear_market_balance: U128 =
//         view!(wnear_market.ft_balance_of(borrower.account_id())).unwrap_json();

//     assert_eq!(
//         Balance::from(borrower_wnear_market_balance),
//         BORROWER_SUPPLY - revenue_amount,
//         "Borrower balance on dtokn ft should be {}",
//         BORROWER_SUPPLY - revenue_amount
//     );

//     let liquidator_wnear_market_balance: U128 =
//         view!(wnear_market.ft_balance_of(liquidator.account_id())).unwrap_json();

//     assert_eq!(
//         Balance::from(liquidator_wnear_market_balance),
//         revenue_amount.clone(),
//         "Liquidator balance on utoken should be {}",
//         revenue_amount.clone()
//     );
// }

'''
'''--- contracts/market/tests/sim/liquidation/mod.rs ---
mod liquidation_fail_as_liquidator_is_borrower;
mod liquidation_fail_due_to_low_health_factor;
mod liquidation_fail_not_allowed_amount;
mod liquidation_failed_on_call_with_wrong_borrow_token;
mod liquidation_success;

'''
'''--- contracts/market/tests/sim/main_old.rs ---
mod borrow;
mod liquidation;
mod repay;
mod supply;
mod upgrade;
mod utils;
mod withdraw;

'''
'''--- contracts/market/tests/sim/repay/mod.rs ---
mod repay_by_parts;
mod repay_by_parts_with_interest;
mod repay_on_token_with_no_borrow;
mod repay_success;
mod repay_success_after_failure;
mod repay_zero_tokens;

'''
'''--- contracts/market/tests/sim/repay/repay_by_parts.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_three_dtokens, initialize_three_utokens,
    mint_and_reserve, mint_tokens, new_user, repay, repay_info, set_price, supply, view_balance,
};
use controller::ActionType::Borrow;
use general::{ratio::Ratio, Price};
use market::{InterestRateModel, WRatio};
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 60;
const WNEAR_AMOUNT: Balance = 70;
const WBTC_AMOUNT: Balance = 100;
const WETH_BORROW: Balance = 30;
const WNEAR_BORROW: Balance = 40;
const START_BALANCE: Balance = 200;
const START_PRICE: Balance = 10000;
const FIRST_PART_TO_REPAY: Balance = 10;

fn repay_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let interest_rate_model = InterestRateModel {
        kink: WRatio::from(0),
        base_rate_per_block: WRatio::from(0),
        multiplier_per_block: WRatio::from(0),
        jump_multiplier_per_block: WRatio::from(0),
        reserve_factor: WRatio::from(0),
    };
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        interest_rate_model.clone(),
        interest_rate_model.clone(),
        interest_rate_model,
    );

    mint_and_reserve(&droot, &weth, &weth_market, WETH_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, WNEAR_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, WBTC_AMOUNT);

    let mint_amount = U128(START_BALANCE);
    mint_tokens(&weth, user.account_id(), mint_amount);
    mint_tokens(&wnear, user.account_id(), mint_amount);
    mint_tokens(&wbtc, user.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();
    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();
    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    assert_eq!(exchange_rate, Ratio::one(), "xrate should be 1.0");

    borrow(&user, &weth_market, WETH_BORROW).assert_success();

    borrow(&user, &wnear_market, WNEAR_BORROW).assert_success();

    (wnear_market, controller, wnear, user)
}

#[test]
fn scenario_repay_by_parts() {
    let (wnear_market, controller, wnear, user) = repay_fixture();

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let repay_info = repay_info(&user, &wnear_market, wnear_market_balance);
    let repay_amount = Balance::from(repay_info.total_amount);

    repay(
        &user,
        wnear_market.account_id(),
        &wnear,
        FIRST_PART_TO_REPAY,
    )
    .assert_success();

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance.0,
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - FIRST_PART_TO_REPAY,
        "Repay was partially done, user balance should be {}",
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - FIRST_PART_TO_REPAY
    );

    let user_balance: Balance =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance,
        WNEAR_BORROW - FIRST_PART_TO_REPAY,
        "Borrow balance on dtoken should be {}",
        WNEAR_BORROW - FIRST_PART_TO_REPAY
    );

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        user.account_id(),
        wnear_market.account_id(),
    );
    assert_eq!(
        user_balance,
        WNEAR_BORROW - FIRST_PART_TO_REPAY,
        "Borrow balance on controller should be {}",
        WNEAR_BORROW - FIRST_PART_TO_REPAY
    );

    repay(
        &user,
        wnear_market.account_id(),
        &wnear,
        repay_amount - FIRST_PART_TO_REPAY,
    )
    .assert_success();

    let balance_after_first_repay =
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - FIRST_PART_TO_REPAY;

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance.0,
        balance_after_first_repay - (repay_amount - FIRST_PART_TO_REPAY),
        "Repay was fully done, user balance should be {}",
        balance_after_first_repay - (repay_amount - FIRST_PART_TO_REPAY)
    );

    let user_balance: Balance =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(user_balance, 0, "Borrow balance on dtoken should be 0");

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        user.account_id(),
        wnear_market.account_id(),
    );
    assert_eq!(user_balance, 0, "Borrow balance on controller should be 0");
    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    assert_eq!(exchange_rate, Ratio::one(), "xrate should be 1.0");
}

'''
'''--- contracts/market/tests/sim/repay/repay_by_parts_with_interest.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_three_dtokens, initialize_three_utokens,
    mint_and_reserve, mint_tokens, new_user, repay, repay_info, set_price, supply, view_balance,
};
use controller::ActionType::Borrow;
use general::{ratio::Ratio, Price, ONE_TOKEN};
use market::{InterestRateModel, WRatio};
use near_sdk::{json_types::U128, Balance};

use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 60 * ONE_TOKEN;
const WNEAR_AMOUNT: Balance = 70 * ONE_TOKEN;
const WBTC_AMOUNT: Balance = 100 * ONE_TOKEN;
const WETH_BORROW: Balance = 30 * ONE_TOKEN;
const WNEAR_BORROW: Balance = 40 * ONE_TOKEN;
const START_BALANCE: Balance = 200 * ONE_TOKEN;
const START_PRICE: Balance = 10000;
const FIRST_PART_TO_REPAY: Balance = 10 * ONE_TOKEN;

fn repay_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let interest_rate_model = InterestRateModel {
        kink: WRatio::from(650000000000000000000000),
        base_rate_per_block: WRatio::from(0),
        multiplier_per_block: WRatio::from(62800000000000000),
        jump_multiplier_per_block: WRatio::from(76100000000000000),
        reserve_factor: WRatio::from(10000000000000000000000),
    };
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        interest_rate_model.clone(),
        interest_rate_model.clone(),
        interest_rate_model,
    );

    mint_and_reserve(&droot, &weth, &weth_market, WETH_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, WNEAR_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, WBTC_AMOUNT);

    let mint_amount = U128(START_BALANCE);
    mint_tokens(&weth, user.account_id(), mint_amount);
    mint_tokens(&wnear, user.account_id(), mint_amount);
    mint_tokens(&wbtc, user.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();

    borrow(&user, &weth_market, WETH_BORROW).assert_success();

    borrow(&user, &wnear_market, WNEAR_BORROW).assert_success();

    (wnear_market, controller, wnear, user)
}

#[test]
fn repay_by_parts_with_interest() {
    let (wnear_market, controller, wnear, user) = repay_fixture();

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();

    let first_repay_info = repay_info(&user, &wnear_market, wnear_market_balance);
    println!("{:?}", first_repay_info);

    let initial_total_reserve = view!(wnear_market.view_total_reserves()).unwrap_json::<U128>();
    let old_wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();

    repay(
        &user,
        wnear_market.account_id(),
        &wnear,
        FIRST_PART_TO_REPAY,
    )
    .assert_success();

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();

    let total_reserve_after_first_repay =
        view!(wnear_market.view_total_reserves()).unwrap_json::<U128>();
    assert!(total_reserve_after_first_repay.0 > initial_total_reserve.0);
    assert!(
        exchange_rate > Ratio::one(),
        "xrate should greater than 1.0"
    );

    assert_eq!(
        user_balance.0,
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - FIRST_PART_TO_REPAY,
        "Repay was partially done, user balance should be {}",
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - FIRST_PART_TO_REPAY
    );

    assert_eq!(
        wnear_market_balance.0,
        old_wnear_market_balance.0 + FIRST_PART_TO_REPAY,
        "Repay was partially done, dtoken balance should be {}",
        old_wnear_market_balance.0 + FIRST_PART_TO_REPAY,
    );

    let second_repay_info = repay_info(&user, &wnear_market, wnear_market_balance);

    repay(
        &user,
        wnear_market.account_id(),
        &wnear,
        second_repay_info.total_amount.0,
    )
    .assert_success();

    let total_reserve_after_second_repay =
        view!(wnear_market.view_total_reserves()).unwrap_json::<U128>();
    assert!(total_reserve_after_second_repay.0 > total_reserve_after_first_repay.0);
    dbg!(total_reserve_after_second_repay.0 - total_reserve_after_first_repay.0);

    let balance_after_first_repay =
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - FIRST_PART_TO_REPAY;

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();

    assert_eq!(
        user_balance.0,
        balance_after_first_repay - second_repay_info.total_amount.0,
        "Repay was fully done, user balance should be {}",
        balance_after_first_repay - second_repay_info.total_amount.0
    );

    let user_balance: Balance =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json();
    assert_ne!(user_balance, 0, "Borrow balance on dtoken should be 0");

    repay(
        &user,
        wnear_market.account_id(),
        &wnear,
        // paying out the rest have left so there is no borrow
        second_repay_info.total_amount.0,
    )
    .assert_success();

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        user.account_id(),
        wnear_market.account_id(),
    );
    assert_eq!(user_balance, 0, "Borrow balance on controller should be 0");

    let user_balance: Balance =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(user_balance, 0, "Borrow balance on dtoken should be 0");

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    assert!(
        exchange_rate > Ratio::one(),
        "xrate should greater than 1.0"
    );
}

'''
'''--- contracts/market/tests/sim/repay/repay_on_token_with_no_borrow.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_two_dtokens, initialize_two_utokens,
    mint_tokens, new_user, repay, set_price, supply,
};
use general::Price;
use market::{InterestRateModel, WRatio};
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 60;
const WNEAR_AMOUNT: Balance = 70;
const WETH_BORROW: Balance = 30;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;

fn repay_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear) = initialize_two_utokens(&root);
    let controller = initialize_controller(&root);
    let interest_rate_model = InterestRateModel {
        kink: WRatio::from(0),
        base_rate_per_block: WRatio::from(0),
        multiplier_per_block: WRatio::from(0),
        jump_multiplier_per_block: WRatio::from(0),
        reserve_factor: WRatio::from(0),
    };
    let (_, weth_market, wnear_market) = initialize_two_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        controller.account_id(),
        interest_rate_model.clone(),
        interest_rate_model,
    );

    let mint_amount = U128(START_BALANCE);
    mint_tokens(&weth, weth_market.account_id(), U128(WETH_AMOUNT));
    mint_tokens(&wnear, wnear_market.account_id(), U128(WNEAR_AMOUNT));
    mint_tokens(&weth, user.account_id(), mint_amount);
    mint_tokens(&wnear, user.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    borrow(&user, &weth_market, WETH_BORROW).assert_success();

    (wnear_market, controller, wnear, user)
}

#[test]
fn scenario_repay() {
    let (wnear_market, _controller, wnear, user) = repay_fixture();

    repay(&user, wnear_market.account_id(), &wnear, WETH_BORROW).assert_success();

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, START_BALANCE,);
}

'''
'''--- contracts/market/tests/sim/repay/repay_success.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_three_dtokens, initialize_three_utokens,
    mint_and_reserve, mint_tokens, new_user, repay, repay_info, set_price, supply, view_balance,
};
use controller::ActionType::Borrow;
use general::{ratio::Ratio, Price, WBalance};
use market::{InterestRateModel, WRatio};
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const RESERVE_AMOUNT: Balance = 1000;
const WETH_AMOUNT: Balance = 60;
const WNEAR_AMOUNT: Balance = 70;
const WETH_BORROW: Balance = 30;
const WNEAR_BORROW: Balance = 40;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;

fn repay_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let interest_rate_model = InterestRateModel {
        kink: WRatio::from(0),
        base_rate_per_block: WRatio::from(0),
        multiplier_per_block: WRatio::from(0),
        jump_multiplier_per_block: WRatio::from(0),
        reserve_factor: WRatio::from(0),
    };
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        interest_rate_model.clone(),
        interest_rate_model.clone(),
        interest_rate_model,
    );

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, RESERVE_AMOUNT);

    let mint_amount = U128(START_BALANCE);
    mint_tokens(&weth, user.account_id(), mint_amount);
    mint_tokens(&wnear, user.account_id(), mint_amount);
    mint_tokens(&wbtc, user.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();
    let underlying_balance: WBalance =
        view!(weth.ft_balance_of(weth_market.account_id())).unwrap_json();
    assert_eq!(
        underlying_balance,
        WBalance::from(RESERVE_AMOUNT + WETH_AMOUNT),
        "Unexpected weth_market balance"
    );

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();
    let underlying_balance: WBalance =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    assert_eq!(
        underlying_balance,
        WBalance::from(RESERVE_AMOUNT + WNEAR_AMOUNT),
        "Unexpected wnear_market balance"
    );

    borrow(&user, &weth_market, WETH_BORROW).assert_success();
    borrow(&user, &wnear_market, WNEAR_BORROW).assert_success();

    (wnear_market, controller, wnear, user)
}

#[test]
fn scenario_repay() {
    let (wnear_market, controller, wnear, user) = repay_fixture();

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    assert_eq!(exchange_rate, Ratio::one(), "xrate should be 1.0");

    let repay_info = repay_info(&user, &wnear_market, wnear_market_balance);
    let repay_amount = Balance::from(repay_info.total_amount);

    repay(&user, wnear_market.account_id(), &wnear, repay_amount).assert_success();

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance.0,
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - repay_amount,
        "Repay wasn`t done"
    );

    let user_balance: Balance =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(user_balance, 0, "Borrow balance on dtoken should be 0");

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        user.account_id(),
        wnear_market.account_id(),
    );
    assert_eq!(user_balance, 0, "Borrow balance on controller should be 0");

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    assert_eq!(exchange_rate, Ratio::one(), "xrate should be 1.0");
}

'''
'''--- contracts/market/tests/sim/repay/repay_success_after_failure.rs ---
use crate::utils::{
    add_market, assert_failure, borrow, initialize_controller, initialize_three_dtokens,
    initialize_three_utokens, mint_and_reserve, mint_tokens, new_user, repay, repay_info,
    set_price, supply, view_balance,
};
use controller::ActionType::Borrow;
use general::{ratio::Ratio, Price, WBalance};
use market::{InterestRateModel, WRatio};
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const RESERVE_AMOUNT: Balance = 1000;
const WETH_AMOUNT: Balance = 60;
const WNEAR_AMOUNT: Balance = 70;
const WETH_BORROW: Balance = 30;
const WNEAR_BORROW: Balance = 40;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;

fn repay_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let interest_rate_model = InterestRateModel {
        kink: WRatio::from(0),
        base_rate_per_block: WRatio::from(0),
        multiplier_per_block: WRatio::from(0),
        jump_multiplier_per_block: WRatio::from(0),
        reserve_factor: WRatio::from(0),
    };
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        interest_rate_model.clone(),
        interest_rate_model.clone(),
        interest_rate_model,
    );

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, RESERVE_AMOUNT);

    let mint_amount = U128(START_BALANCE);
    mint_tokens(&weth, user.account_id(), mint_amount);
    mint_tokens(&wnear, user.account_id(), mint_amount);
    mint_tokens(&wbtc, user.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();
    let underlying_balance: WBalance =
        view!(weth.ft_balance_of(weth_market.account_id())).unwrap_json();
    assert_eq!(
        underlying_balance,
        WBalance::from(RESERVE_AMOUNT + WETH_AMOUNT),
        "Unexpected weth_market balance"
    );

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();
    let underlying_balance: WBalance =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    assert_eq!(
        underlying_balance,
        WBalance::from(RESERVE_AMOUNT + WNEAR_AMOUNT),
        "Unexpected wnear_market balance"
    );

    borrow(&user, &weth_market, WETH_BORROW).assert_success();
    borrow(&user, &wnear_market, WNEAR_BORROW).assert_success();

    (wnear_market, controller, wnear, user)
}

#[test]
fn scenario_repay_after_failure() {
    let (wnear_market, controller, wnear, user) = repay_fixture();

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    assert_eq!(exchange_rate, Ratio::one(), "xrate should be 1.0");

    let result = repay(&user, wnear_market.account_id(), &wnear, 0);
    assert_failure(result, "The amount should be a positive number");

    let repay_info = repay_info(&user, &wnear_market, wnear_market_balance);
    let repay_amount = Balance::from(repay_info.total_amount);

    repay(&user, wnear_market.account_id(), &wnear, repay_amount).assert_success();

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance.0,
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - repay_amount,
        "Repay wasn`t done"
    );

    let user_balance: Balance =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(user_balance, 0, "Borrow balance on dtoken should be 0");

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        user.account_id(),
        wnear_market.account_id(),
    );
    assert_eq!(user_balance, 0, "Borrow balance on controller should be 0");

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    assert_eq!(exchange_rate, Ratio::one(), "xrate should be 1.0");
}

'''
'''--- contracts/market/tests/sim/repay/repay_zero_tokens.rs ---
use crate::utils::{
    add_market, assert_failure, borrow, initialize_controller, initialize_three_dtokens,
    initialize_three_utokens, mint_tokens, new_user, repay, set_price, supply, view_balance,
};
use controller::ActionType::Borrow;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 60;
const WNEAR_AMOUNT: Balance = 70;
const WBTC_AMOUNT: Balance = 100;
const WETH_BORROW: Balance = 30;
const WNEAR_BORROW: Balance = 40;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;

fn repay_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let (_, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    let mint_amount = U128(START_BALANCE);
    mint_tokens(&weth, weth_market.account_id(), U128(WETH_AMOUNT));
    mint_tokens(&wnear, wnear_market.account_id(), U128(WNEAR_AMOUNT));
    mint_tokens(&wbtc, dwbtc.account_id(), U128(WBTC_AMOUNT));
    mint_tokens(&weth, user.account_id(), mint_amount);
    mint_tokens(&wnear, user.account_id(), mint_amount);
    mint_tokens(&wbtc, user.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();

    borrow(&user, &weth_market, WETH_BORROW).assert_success();

    borrow(&user, &wnear_market, WNEAR_BORROW).assert_success();

    (wnear_market, controller, wnear, user)
}

#[test]
fn scenario_repay_zero_tokens() {
    let (wnear_market, controller, wnear, user) = repay_fixture();

    let result = repay(&user, wnear_market.account_id(), &wnear, 0);

    assert_failure(result, "The amount should be a positive number");

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance.0,
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW,
        "Repay wasn`t done"
    );

    let user_balance: Balance =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance, WNEAR_BORROW,
        "Borrow balance on dtoken should be {}",
        WNEAR_BORROW
    );

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        user.account_id(),
        wnear_market.account_id(),
    );
    assert_eq!(
        user_balance, WNEAR_BORROW,
        "Borrow balance on controller should be {}",
        WNEAR_BORROW
    );
}

'''
'''--- contracts/market/tests/sim/supply/mod.rs ---
mod supply_amount_should_be_positive;
mod supply_not_enough_tokens;
mod supply_success;
mod supply_success_after_failure;

'''
'''--- contracts/market/tests/sim/supply/supply_amount_should_be_positive.rs ---
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, ContractAccount, UserAccount};

use general::Price;

use crate::utils::{
    add_market, assert_failure, initialize_controller, initialize_dtoken, initialize_utoken,
    mint_tokens, new_user, set_price, supply,
};

const WNEAR_BALANCE: Balance = 50;
const SUPPLY_AMOUNT: Balance = 0;
const START_PRICE: Balance = 10000;

fn supply_amount_should_be_positive_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let wnear = initialize_utoken(&root);
    let controller = initialize_controller(&root);
    let (_, wnear_market) = initialize_dtoken(
        &root,
        wnear.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
    );

    mint_tokens(&wnear, wnear_market.account_id(), U128(100));
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_BALANCE));

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    (wnear_market, wnear, user)
}

#[test]
fn scenario_supply_amount_should_be_positive() {
    let (wnear_market, wnear, user) = supply_amount_should_be_positive_fixture();

    let result = supply(&user, &wnear, wnear_market.account_id(), SUPPLY_AMOUNT);
    assert_failure(result, "The amount should be a positive number");
}

'''
'''--- contracts/market/tests/sim/supply/supply_not_enough_tokens.rs ---
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, ContractAccount, UserAccount};

use general::Price;

use crate::utils::{
    add_market, assert_failure, initialize_controller, initialize_dtoken, initialize_utoken,
    mint_tokens, new_user, set_price, supply,
};

const WNEAR_BALANCE: Balance = 50;
const SUPPLY_AMOUNT: Balance = 100;
const START_PRICE: Balance = 10000;

fn supply_not_enough_tokens_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let wnear = initialize_utoken(&root);
    let controller = initialize_controller(&root);
    let (_, wnear_market) = initialize_dtoken(
        &root,
        wnear.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
    );

    mint_tokens(&wnear, wnear_market.account_id(), U128(100));
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_BALANCE));

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    (wnear_market, wnear, user)
}

#[test]
fn scenario_supply_not_enough_balance() {
    let (wnear_market, wnear, user) = supply_not_enough_tokens_fixture();

    let result = supply(&user, &wnear, wnear_market.account_id(), SUPPLY_AMOUNT);
    assert_failure(result, "The account doesn't have enough balance");
}

'''
'''--- contracts/market/tests/sim/supply/supply_success.rs ---
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

use controller::ActionType::Supply;
use general::Price;

use crate::utils::{
    add_market, initialize_controller, initialize_dtoken, initialize_utoken, mint_tokens, new_user,
    set_price, supply, view_balance,
};

const SUPPLY_AMOUNT: Balance = 100;
const START_PRICE: Balance = 10000;

fn supply_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let weth = initialize_utoken(&root);
    let controller = initialize_controller(&root);
    let (_, weth_market) = initialize_dtoken(
        &root,
        weth.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
    );

    mint_tokens(&weth, weth_market.account_id(), U128(100));
    mint_tokens(&weth, user.account_id(), U128(SUPPLY_AMOUNT));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    (weth_market, controller, weth, user)
}

#[test]
fn scenario_supply() {
    let (weth_market, controller, weth, user) = supply_fixture();

    supply(&user, &weth, weth_market.account_id(), SUPPLY_AMOUNT).assert_success();

    let user_balance: U128 = view!(weth.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance, U128(0), "User balance should be 0");

    let user_dtoken_balance: U128 =
        view!(weth_market.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_dtoken_balance,
        U128(SUPPLY_AMOUNT),
        "User dtoken balance should be {}",
        SUPPLY_AMOUNT
    );

    let user_balance: Balance = view_balance(
        &controller,
        Supply,
        user.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_balance, SUPPLY_AMOUNT,
        "Balance on controller should be {}",
        SUPPLY_AMOUNT
    );
}

'''
'''--- contracts/market/tests/sim/supply/supply_success_after_failure.rs ---
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

use controller::ActionType::Supply;
use general::Price;

use crate::utils::{
    add_market, assert_failure, initialize_controller, initialize_two_dtokens,
    initialize_two_utokens, mint_tokens, new_user, set_price, supply, view_balance,
};

const WNEAR_BALANCE: Balance = 50;
const WETH_BALANCE: Balance = 100;
const SUPPLY_WETH_AMOUNT: Balance = 100;
const SUPPLY_WNEAR_AMOUNT: Balance = 0;
const START_PRICE: Balance = 10000;

fn supply_success_after_failure_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear) = initialize_two_utokens(&root);
    let controller = initialize_controller(&root);
    let (_, weth_market, wnear_market) = initialize_two_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    mint_tokens(&wnear, wnear_market.account_id(), U128(100));
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_BALANCE));
    mint_tokens(&weth, weth_market.account_id(), U128(100));
    mint_tokens(&weth, user.account_id(), U128(WETH_BALANCE));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "weth".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    (weth_market, wnear_market, controller, weth, wnear, user)
}

#[test]
fn scenario_supply_success_after_failure() {
    let (weth_market, wnear_market, controller, weth, wnear, user) =
        supply_success_after_failure_fixture();

    let result = supply(
        &user,
        &wnear,
        wnear_market.account_id(),
        SUPPLY_WNEAR_AMOUNT,
    );
    assert_failure(result, "The amount should be a positive number");

    supply(&user, &weth, weth_market.account_id(), SUPPLY_WETH_AMOUNT).assert_success();

    let user_balance: U128 = view!(weth.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance, U128(0), "User balance should be 0");

    let user_balance: Balance = view_balance(
        &controller,
        Supply,
        user.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_balance, SUPPLY_WETH_AMOUNT,
        "Balance on controller should be {}",
        SUPPLY_WETH_AMOUNT
    );
}

'''
'''--- contracts/market/tests/sim/upgrade/mod.rs ---
mod upgrade_check_state;
mod upgrade_without_field;

'''
'''--- contracts/market/tests/sim/upgrade/upgrade_check_state.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_three_dtokens, initialize_three_utokens,
    mint_and_reserve, mint_tokens, new_user, repay, repay_info, set_price, supply, upgrade_dtoken,
    view_balance,
};
use controller::ActionType::{Borrow, Supply};
use general::{ratio::Ratio, Price, WBalance};
use market::{InterestRateModel, WRatio};
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const RESERVE_AMOUNT: Balance = 1000;
const WETH_AMOUNT: Balance = 60;
const WNEAR_AMOUNT: Balance = 70;
const WETH_BORROW: Balance = 30;
const WNEAR_BORROW: Balance = 40;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 10000;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    DTOKEN_CURRENT_WASM_BYTES => "../target/wasm32-unknown-unknown/release/market.wasm",
}

fn upgrade_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear, wbtc) = initialize_three_utokens(&root);
    let controller = initialize_controller(&root);
    let interest_rate_model = InterestRateModel {
        kink: WRatio::from(0),
        base_rate_per_block: WRatio::from(0),
        multiplier_per_block: WRatio::from(0),
        jump_multiplier_per_block: WRatio::from(0),
        reserve_factor: WRatio::from(0),
    };
    let (droot, weth_market, wnear_market, dwbtc) = initialize_three_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        interest_rate_model.clone(),
        interest_rate_model.clone(),
        interest_rate_model,
    );

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, RESERVE_AMOUNT);

    let mint_amount = U128(START_BALANCE);
    mint_tokens(&weth, user.account_id(), mint_amount);
    mint_tokens(&wnear, user.account_id(), mint_amount);
    mint_tokens(&wbtc, user.account_id(), mint_amount);

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();
    let underlying_balance: WBalance =
        view!(weth.ft_balance_of(weth_market.account_id())).unwrap_json();
    assert_eq!(
        underlying_balance,
        WBalance::from(RESERVE_AMOUNT + WETH_AMOUNT),
        "Unexpected weth_market balance"
    );

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();
    let underlying_balance: WBalance =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    assert_eq!(
        underlying_balance,
        WBalance::from(RESERVE_AMOUNT + WNEAR_AMOUNT),
        "Unexpected wnear_market balance"
    );

    borrow(&user, &weth_market, WETH_BORROW).assert_success();
    borrow(&user, &wnear_market, WNEAR_BORROW).assert_success();

    (wnear_market, controller, wnear, user)
}

#[test]
fn test_upgrade_check_state() {
    let (wnear_market, controller, wnear, user) = upgrade_fixture();

    assert_eq!(
        view!(wnear_market.get_version()).unwrap_json::<String>(),
        env!("CARGO_PKG_VERSION").to_string()
    );

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();

    assert_eq!(exchange_rate, Ratio::one(), "xrate should be 1.0");

    let repay_info = repay_info(&user, &wnear_market, wnear_market_balance);
    let repay_amount = Balance::from(repay_info.total_amount);

    let old_total_supplies = view!(wnear_market.view_total_supplies()).unwrap_json::<U128>();
    let old_total_borrows = view!(wnear_market.view_total_borrows()).unwrap_json::<U128>();
    let old_total_reserves = view!(wnear_market.view_total_reserves()).unwrap_json::<U128>();
    let old_user_borrows =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json::<Balance>();
    let old_user_supplies: Balance = view_balance(
        &controller,
        Supply,
        user.account_id(),
        wnear_market.account_id(),
    );

    upgrade_dtoken(&wnear_market, &DTOKEN_CURRENT_WASM_BYTES).assert_success();

    assert_eq!(
        view!(wnear_market.get_version()).unwrap_json::<String>(),
        env!("CARGO_PKG_VERSION").to_string()
    );

    repay(&user, wnear_market.account_id(), &wnear, repay_amount).assert_success();

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(
        user_balance.0,
        START_BALANCE - WNEAR_AMOUNT + WNEAR_BORROW - repay_amount,
        "Repay wasn`t done"
    );

    let user_balance: Balance =
        view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json();
    assert_eq!(user_balance, 0, "Borrow balance on dtoken should be 0");

    let user_balance: Balance = view_balance(
        &controller,
        Borrow,
        user.account_id(),
        wnear_market.account_id(),
    );
    assert_eq!(user_balance, 0, "Borrow balance on controller should be 0");

    let wnear_market_balance: U128 =
        view!(wnear.ft_balance_of(wnear_market.account_id())).unwrap_json();
    let exchange_rate: Ratio =
        view!(wnear_market.view_exchange_rate(wnear_market_balance)).unwrap_json();
    assert_eq!(exchange_rate, Ratio::one(), "xrate should be 1.0");

    assert_eq!(
        old_total_supplies,
        view!(wnear_market.view_total_supplies()).unwrap_json::<U128>()
    );
    assert!(
        old_total_borrows.0
            > view!(wnear_market.view_total_borrows())
                .unwrap_json::<U128>()
                .0
    );
    assert_eq!(
        old_total_reserves.0,
        view!(wnear_market.view_total_reserves())
            .unwrap_json::<U128>()
            .0
    );
    assert!(
        old_user_borrows
            > view!(wnear_market.get_account_borrows(user.account_id())).unwrap_json::<Balance>()
    );
    assert_eq!(
        old_user_supplies,
        view_balance(
            &controller,
            Supply,
            user.account_id(),
            wnear_market.account_id()
        )
    );
}

'''
'''--- contracts/market/tests/sim/upgrade/upgrade_without_field.rs ---
// IMPORTANT! Update previous version after migration
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    DTOKEN_CURRENT_WASM_BYTES => "../target/wasm32-unknown-unknown/release/market.wasm",
    DTOKEN_PREVIOUS_WASM_BYTES => "tests/sim/contracts/dtoken_v1.wasm",
}

const PREVIOUS_VERSION: &str = "0.0.1";

use crate::utils::{
    add_market, initialize_controller, initialize_utoken, new_user, set_price, upgrade_dtoken,
    view_balance,
};
use controller::ActionType::Supply;
use general::ratio::Ratio;
use general::Price;
use market::Config as dConfig;
use market::ContractContract as Dtoken;
use market::InterestRateModel;
use near_sdk::json_types::U128;
use near_sdk::{AccountId, Balance};
use near_sdk_sim::{call, deploy, init_simulator, to_yocto, view, ContractAccount, UserAccount};

fn upgrade_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let controller = initialize_controller(&root);
    let droot = root.create_user("dtoken".parse().unwrap(), to_yocto("1200000"));
    let contract_id = AccountId::new_unchecked("dtoken_contract".to_string());

    let utoken = initialize_utoken(&root);

    let dtoken = deploy!(
        contract: Dtoken,
        contract_id: contract_id,
        bytes: &DTOKEN_PREVIOUS_WASM_BYTES,
        signer_account: droot
    );

    call!(
        dtoken.user_account,
        dtoken.new(dConfig {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: utoken.account_id(),
            underlying_token_decimals: 24,
            owner_id: droot.account_id,
            controller_account_id: controller.account_id(),
            interest_rate_model: InterestRateModel::default(),
            disable_transfer_token: true
        }),
        deposit = 0
    )
    .assert_success();

    call!(
        dtoken.user_account,
        dtoken.mint(user.account_id(), U128(10000)),
        0,
        100000000000000
    );

    let user_balance: U128 = view!(dtoken.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, 10000);

    let version: String = view!(dtoken.get_version()).unwrap_json();
    assert_eq!(version, PREVIOUS_VERSION);

    add_market(
        &controller,
        utoken.account_id(),
        dtoken.account_id(),
        "weth".to_string(),
    );

    set_price(
        &controller,
        dtoken.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(10000),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    (dtoken, controller, utoken, user)
}

#[test]
fn test_upgrade_without_field() {
    let (dtoken, controller, _, user) = upgrade_fixture();

    let old_total_supplies = view!(dtoken.view_total_supplies()).unwrap_json::<U128>();
    let old_total_borrows = view!(dtoken.view_total_borrows()).unwrap_json::<U128>();
    let old_total_reserves = view!(dtoken.view_total_reserves()).unwrap_json::<U128>();
    let old_user_borrows =
        view!(dtoken.get_account_borrows(user.account_id())).unwrap_json::<Balance>();
    let old_user_supplies: Balance =
        view_balance(&controller, Supply, user.account_id(), dtoken.account_id());

    upgrade_dtoken(&dtoken, &DTOKEN_CURRENT_WASM_BYTES).assert_success();

    assert_eq!(
        view!(dtoken.get_version()).unwrap_json::<String>(),
        env!("CARGO_PKG_VERSION").to_string()
    );

    // there are no such field so Err occurred
    // no method named `view_mock_field` found for struct `market::ContractContract` in the current scope
    // let mock_field_after_upgrade_check = view!(dtoken.view_mock_field(user.account_id())).unwrap_json();

    assert_eq!(
        old_total_supplies,
        view!(dtoken.view_total_supplies()).unwrap_json::<U128>()
    );
    assert_eq!(
        old_total_borrows,
        view!(dtoken.view_total_borrows()).unwrap_json::<U128>()
    );
    assert_eq!(
        old_total_reserves,
        view!(dtoken.view_total_reserves()).unwrap_json::<U128>()
    );
    assert_eq!(
        old_user_borrows,
        view!(dtoken.get_account_borrows(user.account_id())).unwrap_json::<Balance>()
    );
    assert_eq!(
        old_user_supplies,
        view_balance(&controller, Supply, user.account_id(), dtoken.account_id())
    );
}

'''
'''--- contracts/market/tests/sim/utils.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::{AccountId, Balance, Gas};
use near_sdk_sim::{call, deploy, to_yocto, view, ContractAccount, ExecutionResult, UserAccount};
use std::str::FromStr;

use controller::ContractContract as Controller;
use controller::{ActionType, Config as cConfig};
use general::{ratio::Ratio, Price, WBalance};
use market::ContractContract as Dtoken;
use market::InterestRateModel;
use market::{Config as dConfig, RepayInfo};
use mock_token::ContractContract as Utoken;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    DTOKEN_WASM_BYTES => "../target/wasm32-unknown-unknown/release/market.wasm",
    UTOKEN_WASM_BYTES => "../target/wasm32-unknown-unknown/release/mock_token.wasm",
    CONTROLLER_WASM_BYTES => "../target/wasm32-unknown-unknown/release/controller.wasm",
}

pub fn new_user(root: &UserAccount, account_id: AccountId) -> UserAccount {
    root.create_user(
        account_id,
        to_yocto("10000"), // initial balance
    )
}

pub fn init_dtoken(root: &UserAccount, token_id: AccountId) -> ContractAccount<Dtoken> {
    let contract = deploy!(
        contract: Dtoken,
        contract_id: token_id,
        bytes: &DTOKEN_WASM_BYTES,
        signer_account: root
    );

    contract
}

pub fn init_utoken(root: &UserAccount, token_id: AccountId) -> ContractAccount<Utoken> {
    let contract = deploy!(
        contract: Utoken,
        contract_id: token_id,
        bytes: &UTOKEN_WASM_BYTES,
        signer_account: root
    );

    contract
}

pub fn init_controller(root: &UserAccount, token_id: AccountId) -> ContractAccount<Controller> {
    let contract = deploy!(
        contract: Controller,
        contract_id: token_id,
        bytes: &CONTROLLER_WASM_BYTES,
        signer_account: root
    );

    contract
}

pub fn assert_failure(outcome: ExecutionResult, error_message: &str) {
    assert!(!outcome.is_ok());
    let exe_status = format!(
        "{:?}",
        outcome.promise_errors()[0].as_ref().unwrap().status()
    );
    println!("{}", exe_status);
    assert!(exe_status.contains(error_message));
}

pub fn view_balance(
    contract: &ContractAccount<controller::ContractContract>,
    action: ActionType,
    user_account: AccountId,
    dtoken_account: AccountId,
) -> u128 {
    view!(contract.get_entity_by_token(action, user_account, dtoken_account)).unwrap_json()
}

fn internal_utoken_initialize(
    account: &UserAccount,
    utoken: &ContractAccount<mock_token::ContractContract>,
    owner: AccountId,
) {
    call!(
        account,
        utoken.new_default_meta(
            owner,
            String::from("Mock Token"),
            String::from("MOCK"),
            U128(10000),
            24
        ),
        deposit = 0
    )
    .assert_success();
}

pub fn initialize_utoken(root: &UserAccount) -> ContractAccount<mock_token::ContractContract> {
    let uroot = root.create_user("utoken".parse().unwrap(), to_yocto("1200000"));
    let utoken = init_utoken(
        &uroot,
        AccountId::new_unchecked("utoken_contract".to_string()),
    );
    internal_utoken_initialize(&utoken.user_account, &utoken, uroot.account_id());
    utoken
}

pub fn initialize_two_utokens(
    root: &UserAccount,
) -> (
    ContractAccount<mock_token::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
) {
    let uroot1 = root.create_user("utoken1".parse().unwrap(), to_yocto("1200000"));
    let utoken1 = init_utoken(
        &uroot1,
        AccountId::new_unchecked("utoken_contract1".to_string()),
    );
    internal_utoken_initialize(&utoken1.user_account, &utoken1, uroot1.account_id());

    let uroot2 = root.create_user("utoken2".parse().unwrap(), to_yocto("1200000"));
    let utoken2 = init_utoken(
        &uroot2,
        AccountId::new_unchecked("utoken_contract2".to_string()),
    );
    internal_utoken_initialize(&utoken2.user_account, &utoken2, uroot2.account_id());

    (utoken1, utoken2)
}

pub fn initialize_three_utokens(
    root: &UserAccount,
) -> (
    ContractAccount<mock_token::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
) {
    let uroot1 = root.create_user("utoken1".parse().unwrap(), to_yocto("1200000"));
    let utoken1 = init_utoken(
        &uroot1,
        AccountId::new_unchecked("utoken_contract1".to_string()),
    );
    internal_utoken_initialize(&utoken1.user_account, &utoken1, uroot1.account_id());

    let uroot2 = root.create_user("utoken2".parse().unwrap(), to_yocto("1200000"));
    let utoken2 = init_utoken(
        &uroot2,
        AccountId::new_unchecked("utoken_contract2".to_string()),
    );
    internal_utoken_initialize(&utoken2.user_account, &utoken2, uroot2.account_id());

    let uroot3 = root.create_user("utoken3".parse().unwrap(), to_yocto("1200000"));
    let utoken3 = init_utoken(
        &uroot3,
        AccountId::new_unchecked("utoken_contract3".to_string()),
    );
    internal_utoken_initialize(&utoken3.user_account, &utoken3, uroot3.account_id());

    (utoken1, utoken2, utoken3)
}

pub fn initialize_controller(root: &UserAccount) -> ContractAccount<controller::ContractContract> {
    let croot = root.create_user("controller".parse().unwrap(), to_yocto("1200000"));
    let controller = init_controller(
        &croot,
        AccountId::new_unchecked("controller_contract".to_string()),
    );
    call!(
        controller.user_account,
        controller.new(cConfig {
            owner_id: croot.account_id(),
            oracle_account_id: "oracle".parse().unwrap()
        }),
        deposit = 0
    )
    .assert_success();
    controller
}

fn internal_dtoken_initialize(
    account: &UserAccount,
    dtoken: &ContractAccount<market::ContractContract>,
    owner: AccountId,
    utoken_account: AccountId,
    controller_account: AccountId,
    model: InterestRateModel,
) {
    call!(
        account,
        dtoken.new(dConfig {
            initial_exchange_rate: U128::from(Ratio::one()),
            underlying_token_id: utoken_account,
            underlying_token_decimals: 24,
            owner_id: owner,
            controller_account_id: controller_account,
            interest_rate_model: model,
            disable_transfer_token: true,
        }),
        deposit = 0
    )
    .assert_success();
}

pub fn initialize_dtoken(
    root: &UserAccount,
    utoken_account: AccountId,
    controller_account: AccountId,
    interest_model: InterestRateModel,
) -> (UserAccount, ContractAccount<market::ContractContract>) {
    let droot = root.create_user("dtoken".parse().unwrap(), to_yocto("1200000"));
    let dtoken = init_dtoken(
        &droot,
        AccountId::new_unchecked("dtoken_contract".to_string()),
    );
    internal_dtoken_initialize(
        &dtoken.user_account,
        &dtoken,
        droot.account_id(),
        utoken_account,
        controller_account,
        interest_model,
    );

    (droot, dtoken)
}

pub fn initialize_two_dtokens(
    root: &UserAccount,
    utoken_account1: AccountId,
    utoken_account2: AccountId,
    controller_account: AccountId,
    interest_model1: InterestRateModel,
    interest_model2: InterestRateModel,
) -> (
    UserAccount,
    ContractAccount<market::ContractContract>,
    ContractAccount<market::ContractContract>,
) {
    let droot = root.create_user("dtoken".parse().unwrap(), to_yocto("1200000"));
    let dtoken1 = init_dtoken(
        &droot,
        AccountId::new_unchecked("dtoken_contract1".to_string()),
    );

    let dtoken2 = init_dtoken(
        &droot,
        AccountId::new_unchecked("dtoken_contract2".to_string()),
    );

    internal_dtoken_initialize(
        &dtoken1.user_account,
        &dtoken1,
        droot.account_id(),
        utoken_account1,
        controller_account.clone(),
        interest_model1,
    );

    internal_dtoken_initialize(
        &dtoken2.user_account,
        &dtoken2,
        droot.account_id(),
        utoken_account2,
        controller_account,
        interest_model2,
    );
    (droot, dtoken1, dtoken2)
}

pub fn initialize_three_dtokens(
    root: &UserAccount,
    utoken_account1: AccountId,
    utoken_account2: AccountId,
    utoken_account3: AccountId,
    controller_account: AccountId,
    interest_model1: InterestRateModel,
    interest_model2: InterestRateModel,
    interest_model3: InterestRateModel,
) -> (
    UserAccount,
    ContractAccount<market::ContractContract>,
    ContractAccount<market::ContractContract>,
    ContractAccount<market::ContractContract>,
) {
    let droot = root.create_user("dtoken".parse().unwrap(), to_yocto("1200000"));
    let dtoken1 = init_dtoken(
        &droot,
        AccountId::new_unchecked("dtoken_contract1".to_string()),
    );

    let dtoken2 = init_dtoken(
        &droot,
        AccountId::new_unchecked("dtoken_contract2".to_string()),
    );
    let dtoken3 = init_dtoken(
        &droot,
        AccountId::new_unchecked("dtoken_contract3".to_string()),
    );

    internal_dtoken_initialize(
        &dtoken1.user_account,
        &dtoken1,
        droot.account_id(),
        utoken_account1,
        controller_account.clone(),
        interest_model1,
    );

    internal_dtoken_initialize(
        &dtoken2.user_account,
        &dtoken2,
        droot.account_id(),
        utoken_account2,
        controller_account.clone(),
        interest_model2,
    );
    internal_dtoken_initialize(
        &dtoken3.user_account,
        &dtoken3,
        droot.account_id(),
        utoken_account3,
        controller_account,
        interest_model3,
    );
    (droot, dtoken1, dtoken2, dtoken3)
}

pub fn add_market(
    controller: &ContractAccount<controller::ContractContract>,
    utoken_id: AccountId,
    dtoken_id: AccountId,
    ticker_id: String,
) {
    let ltv = Ratio::from_str("0.6").unwrap();
    let lth = Ratio::from_str("0.8").unwrap();
    call!(
        controller.user_account,
        controller.add_market(utoken_id, dtoken_id, ticker_id, ltv, lth),
        deposit = 0
    );
}

pub fn mint_tokens(
    utoken: &ContractAccount<mock_token::ContractContract>,
    receiver: AccountId,
    amount: U128,
) {
    call!(
        utoken.user_account,
        utoken.mint(receiver, amount),
        0,
        100000000000000
    )
    .assert_success();
}

pub fn set_price(
    controller: &ContractAccount<controller::ContractContract>,
    dtoken_id: AccountId,
    price: &Price,
) {
    call!(
        controller.user_account,
        controller.upsert_price(dtoken_id, price),
        deposit = 0
    )
    .assert_success();
}

pub fn reserve_storage(
    dtoken_admin: &UserAccount,
    utoken: &ContractAccount<mock_token::ContractContract>,
    dtoken: &ContractAccount<market::ContractContract>,
) {
    call!(
        dtoken_admin,
        utoken.storage_deposit(Some(dtoken.account_id()), None),
        deposit = to_yocto("0.25")
    )
    .assert_success();
}

pub fn mint_and_reserve(
    dtoken_admin: &UserAccount,
    utoken: &ContractAccount<mock_token::ContractContract>,
    dtoken: &ContractAccount<market::ContractContract>,
    amount: Balance,
) {
    mint_tokens(utoken, dtoken_admin.account_id(), U128(amount));
    reserve_storage(dtoken_admin, utoken, dtoken);

    let action = "\"Reserve\"".to_string();
    call!(
        dtoken_admin,
        utoken.ft_transfer_call(
            dtoken.account_id(),
            U128(amount),
            Some("RESERVE".to_string()),
            action
        ),
        deposit = 1
    )
    .assert_success();

    let underlying_balance: WBalance =
        view!(utoken.ft_balance_of(dtoken.account_id())).unwrap_json();
    assert_eq!(
        underlying_balance,
        WBalance::from(amount),
        "Unexpected dtoken balance"
    );

    let total_reserves: WBalance = view!(dtoken.view_total_reserves()).unwrap_json();
    assert_eq!(
        total_reserves,
        WBalance::from(amount),
        "Unexpected total reserves"
    );
}

pub fn supply(
    user: &UserAccount,
    utoken: &ContractAccount<mock_token::ContractContract>,
    dtoken: AccountId,
    amount: Balance,
) -> ExecutionResult {
    let action = "\"Supply\"".to_string();
    call!(
        user,
        utoken.ft_transfer_call(dtoken, U128(amount), Some("SUPPLY".to_string()), action),
        deposit = 1
    )
}

pub fn withdraw(
    user: &UserAccount,
    dtoken: &ContractAccount<market::ContractContract>,
    amount: Balance,
) -> ExecutionResult {
    call!(user, dtoken.withdraw(U128(amount)), deposit = 0)
}

pub fn borrow(
    user: &UserAccount,
    dtoken: &ContractAccount<market::ContractContract>,
    amount: Balance,
) -> ExecutionResult {
    call!(user, dtoken.borrow(U128(amount)), deposit = 0)
}

pub fn repay(
    user: &UserAccount,
    dtoken: AccountId,
    utoken: &ContractAccount<mock_token::ContractContract>,
    amount: Balance,
) -> ExecutionResult {
    let action = "\"Repay\"".to_string();

    call!(
        user,
        utoken.ft_transfer_call(dtoken, U128(amount), Some("REPAY".to_string()), action),
        deposit = 1
    )
}

pub fn liquidate(
    borrower: &UserAccount,
    liquidator: &UserAccount,
    borrowing_dtoken: &ContractAccount<market::ContractContract>,
    collateral_dtoken: &ContractAccount<market::ContractContract>,
    borrowing_utoken: &ContractAccount<mock_token::ContractContract>,
    amount: Balance,
) -> ExecutionResult {
    let action = json!({
        "Liquidate":{
            "borrower": borrower.account_id.as_str(),
            "borrowing_dtoken": borrowing_dtoken.account_id().as_str(),
            "collateral_dtoken": collateral_dtoken.account_id().as_str(),
        }
    })
    .to_string();

    call!(
        liquidator,
        borrowing_utoken.ft_transfer_call(
            borrowing_dtoken.account_id(),
            U128::from(amount),
            None,
            action
        ),
        deposit = 1
    )
}

pub fn repay_info(
    user: &UserAccount,
    dtoken: &ContractAccount<market::ContractContract>,
    dtoken_balance: U128,
) -> RepayInfo {
    call!(
        user,
        dtoken.view_repay_info(user.account_id(), dtoken_balance),
        deposit = 0
    )
    .unwrap_json::<RepayInfo>()
}

pub fn upgrade_dtoken(
    dtoken: &ContractAccount<market::ContractContract>,
    contract_bytes: &[u8],
) -> ExecutionResult {
    const MAX_GAS: Gas = Gas(Gas::ONE_TERA.0 * 300);

    dtoken
        .user_account
        .create_transaction(dtoken.account_id())
        .function_call("upgrade".to_string(), contract_bytes.to_vec(), MAX_GAS.0, 0)
        .submit()
}

'''
'''--- contracts/market/tests/sim/withdraw/mod.rs ---
mod withdraw_after_borrow;
mod withdraw_fail_zero_tokens;
mod withdraw_more_fail_after_borrow;
mod withdraw_more_than_supply;
mod withdraw_success;
mod withdraw_success_after_failure;

'''
'''--- contracts/market/tests/sim/withdraw/withdraw_after_borrow.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_two_dtokens, initialize_two_utokens,
    mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance, withdraw,
};
use controller::ActionType::Supply;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WBTC_AMOUNT: Balance = 0;
const BORROW_AMOUNT: Balance = 50;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 50000;
const WITHDRAW: Balance = START_BALANCE / 8;
const EXCHANGE_RATE: Balance = 1;

fn withdraw_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wbtc) = initialize_two_utokens(&root);
    let controller = initialize_controller(&root);
    let interest_model = InterestRateModel {
        kink: U128(0),
        multiplier_per_block: U128(0),
        base_rate_per_block: U128(0),
        jump_multiplier_per_block: U128(0),
        reserve_factor: U128(0),
    };
    let (droot, weth_market, dwbtc) = initialize_two_dtokens(
        &root,
        weth.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        interest_model.clone(),
        interest_model,
    );

    mint_and_reserve(&droot, &weth, &weth_market, START_BALANCE);
    mint_and_reserve(&droot, &wbtc, &dwbtc, START_BALANCE);

    mint_tokens(&weth, user.account_id(), U128(START_BALANCE));
    mint_tokens(&wbtc, user.account_id(), U128(WBTC_AMOUNT));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), START_BALANCE).assert_success();

    borrow(&user, &dwbtc, BORROW_AMOUNT).assert_success();

    (weth_market, controller, weth, user)
}

#[test]
fn scenario_borrow() {
    let (weth_market, controller, weth, user) = withdraw_fixture();

    withdraw(&user, &weth_market, WITHDRAW).assert_success();

    let user_supply_balance: u128 = view_balance(
        &controller,
        Supply,
        user.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_supply_balance,
        START_BALANCE - (EXCHANGE_RATE * WITHDRAW),
        "Balance should be {}",
        START_BALANCE - (EXCHANGE_RATE * WITHDRAW)
    );

    let user_balance: U128 = view!(weth.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, EXCHANGE_RATE * WITHDRAW);
}

'''
'''--- contracts/market/tests/sim/withdraw/withdraw_fail_zero_tokens.rs ---
use crate::utils::{
    add_market, assert_failure, initialize_controller, initialize_dtoken, initialize_utoken,
    mint_tokens, new_user, set_price, supply, view_balance, withdraw,
};
use controller::ActionType::Supply;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WETH_AMOUNT: Balance = 100;
const START_PRICE: Balance = 10000;

fn withdraw_fail_zero_tokens_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let weth = initialize_utoken(&root);
    let controller = initialize_controller(&root);
    let (_, weth_market) = initialize_dtoken(
        &root,
        weth.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
    );

    mint_tokens(&weth, weth_market.account_id(), U128(100));
    mint_tokens(&weth, user.account_id(), U128(WETH_AMOUNT));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), WETH_AMOUNT).assert_success();

    (weth_market, controller, weth, user)
}

#[test]
fn scenario_withdraw_fail_zero_tokens() {
    let (weth_market, controller, weth, user) = withdraw_fail_zero_tokens_fixture();

    let result = withdraw(&user, &weth_market, 0);
    assert_failure(result, "Amount should be a positive number");

    let user_supply_balance: Balance = view_balance(
        &controller,
        Supply,
        user.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(user_supply_balance, WETH_AMOUNT, "Balance should be 0");

    let user_balance: U128 = view!(weth.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, 0);
}

'''
'''--- contracts/market/tests/sim/withdraw/withdraw_more_fail_after_borrow.rs ---
use crate::utils::{
    add_market, borrow, initialize_controller, initialize_two_dtokens, initialize_two_utokens,
    mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance, withdraw,
};
use controller::ActionType::Supply;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WBTC_AMOUNT: Balance = 0;
const BORROW_AMOUNT: Balance = 50;
const START_BALANCE: Balance = 100;
const START_PRICE: Balance = 50000;
const RESERVE_AMOUNT: Balance = 100;

fn withdraw_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wbtc) = initialize_two_utokens(&root);
    let controller = initialize_controller(&root);
    let interest_model = InterestRateModel {
        kink: U128(0),
        multiplier_per_block: U128(0),
        base_rate_per_block: U128(0),
        jump_multiplier_per_block: U128(0),
        reserve_factor: U128(0),
    };
    let (droot, weth_market, dwbtc) = initialize_two_dtokens(
        &root,
        weth.account_id(),
        wbtc.account_id(),
        controller.account_id(),
        interest_model.clone(),
        interest_model,
    );

    let mint_amount = U128(START_BALANCE);
    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wbtc, &dwbtc, RESERVE_AMOUNT);
    mint_tokens(&weth, user.account_id(), mint_amount);
    mint_tokens(&wbtc, user.account_id(), U128(WBTC_AMOUNT));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wbtc.account_id(),
        dwbtc.account_id(),
        "wbtc".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        dwbtc.account_id(),
        &Price {
            ticker_id: "wbtc".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), START_BALANCE).assert_success();

    borrow(&user, &dwbtc, BORROW_AMOUNT).assert_success();

    (weth_market, controller, weth, user)
}

#[test]
fn scenario_withdraw_more_after_borrow() {
    let (weth_market, controller, weth, user) = withdraw_fixture();

    withdraw(&user, &weth_market, START_BALANCE).assert_success();

    let user_supply_balance: u128 = view_balance(
        &controller,
        Supply,
        user.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_supply_balance, START_BALANCE,
        "Balance should be {}",
        START_BALANCE
    );

    let user_balance: U128 = view!(weth.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, 0);
}

'''
'''--- contracts/market/tests/sim/withdraw/withdraw_more_than_supply.rs ---
use crate::utils::{
    add_market, assert_failure, initialize_controller, initialize_dtoken, initialize_utoken,
    mint_and_reserve, mint_tokens, new_user, set_price, supply, view_balance, withdraw,
};
use controller::ActionType::Supply;
use general::ratio::Ratio;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const WNEAR_AMOUNT: Balance = 50;
const WITHDRAW_AMOUNT: Balance = 100;
const START_PRICE: Balance = 10000;

fn withdraw_more_than_supply_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let wnear = initialize_utoken(&root);
    let controller = initialize_controller(&root);
    let interest_model = InterestRateModel {
        kink: U128::from(Ratio::zero()),
        multiplier_per_block: U128::from(Ratio::zero()),
        base_rate_per_block: U128::from(Ratio::zero()),
        jump_multiplier_per_block: U128::from(Ratio::zero()),
        reserve_factor: U128::from(Ratio::zero()),
    };
    let (droot, wnear_market) = initialize_dtoken(
        &root,
        wnear.account_id(),
        controller.account_id(),
        interest_model,
    );

    mint_and_reserve(&droot, &wnear, &wnear_market, WNEAR_AMOUNT);
    mint_tokens(&wnear, user.account_id(), U128(WNEAR_AMOUNT));

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &wnear, wnear_market.account_id(), WNEAR_AMOUNT).assert_success();

    (wnear_market, controller, wnear, user)
}

#[test]
fn scenario_withdraw_more_than_supply() {
    let (wnear_market, controller, wnear, user) = withdraw_more_than_supply_fixture();

    let result = withdraw(&user, &wnear_market, WITHDRAW_AMOUNT);

    assert_failure(
        result,
        "The account doesn't have enough digital tokens to do withdraw",
    );

    let user_supply_balance: Balance = view_balance(
        &controller,
        Supply,
        user.account_id(),
        wnear_market.account_id(),
    );
    assert_eq!(
        user_supply_balance, WNEAR_AMOUNT,
        "Balance should be {}",
        WNEAR_AMOUNT
    );

    let user_balance: U128 = view!(wnear.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, 0);
}

'''
'''--- contracts/market/tests/sim/withdraw/withdraw_success.rs ---
use crate::utils::{
    add_market, initialize_controller, initialize_dtoken, initialize_utoken, mint_and_reserve,
    mint_tokens, new_user, set_price, supply, view_balance, withdraw,
};
use controller::ActionType::Supply;
use general::Price;
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

const SUPPLY_AMOUNT: Balance = 100;
const WITHDRAW_AMOUNT: Balance = SUPPLY_AMOUNT / 3;
const START_PRICE: Balance = 10000;

fn withdraw_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let weth = initialize_utoken(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market) = initialize_dtoken(
        &root,
        weth.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
    );

    mint_and_reserve(&droot, &weth, &weth_market, SUPPLY_AMOUNT);
    mint_tokens(&weth, user.account_id(), U128(SUPPLY_AMOUNT));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), SUPPLY_AMOUNT).assert_success();

    (weth_market, controller, weth, user)
}

#[test]
fn scenario_partial_withdraw() {
    let (weth_market, controller, weth, user) = withdraw_fixture();

    withdraw(&user, &weth_market, WITHDRAW_AMOUNT).assert_success();
    let user_dtoken_balance: U128 =
        view!(weth_market.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_dtoken_balance.0, SUPPLY_AMOUNT - WITHDRAW_AMOUNT);

    let user_supply_balance: u128 = view_balance(
        &controller,
        Supply,
        user.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(
        user_supply_balance,
        SUPPLY_AMOUNT - WITHDRAW_AMOUNT,
        "Balance should be {}",
        SUPPLY_AMOUNT - WITHDRAW_AMOUNT
    );

    let user_balance: U128 = view!(weth.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, WITHDRAW_AMOUNT);
}

#[test]
fn scenario_full_withdraw() {
    let (weth_market, controller, weth, user) = withdraw_fixture();

    withdraw(&user, &weth_market, SUPPLY_AMOUNT).assert_success();
    let user_dtoken_balance: U128 =
        view!(weth_market.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_dtoken_balance.0, 0);

    let user_supply_balance: u128 = view_balance(
        &controller,
        Supply,
        user.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(user_supply_balance, 0, "Balance should be {}", 0);

    let user_balance: U128 = view!(weth.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, SUPPLY_AMOUNT);
}

'''
'''--- contracts/market/tests/sim/withdraw/withdraw_success_after_failure.rs ---
use market::InterestRateModel;
use near_sdk::{json_types::U128, Balance};
use near_sdk_sim::{init_simulator, view, ContractAccount, UserAccount};

use controller::ActionType::Supply;
use general::Price;

use crate::utils::{
    add_market, assert_failure, initialize_controller, initialize_two_dtokens,
    initialize_two_utokens, mint_and_reserve, mint_tokens, new_user, set_price, supply,
    view_balance, withdraw,
};

const RESERVE_AMOUNT: Balance = 100;
const WNEAR_BALANCE: Balance = 50;
const WETH_BALANCE: Balance = 100;
const SUPPLY_WETH_AMOUNT: Balance = 100;
const START_PRICE: Balance = 10000;

fn withdraw_success_after_failure_fixture() -> (
    ContractAccount<market::ContractContract>,
    ContractAccount<market::ContractContract>,
    ContractAccount<controller::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    ContractAccount<mock_token::ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let user = new_user(&root, "user".parse().unwrap());
    let (weth, wnear) = initialize_two_utokens(&root);
    let controller = initialize_controller(&root);
    let (droot, weth_market, wnear_market) = initialize_two_dtokens(
        &root,
        weth.account_id(),
        wnear.account_id(),
        controller.account_id(),
        InterestRateModel::default(),
        InterestRateModel::default(),
    );

    mint_and_reserve(&droot, &weth, &weth_market, RESERVE_AMOUNT);
    mint_and_reserve(&droot, &wnear, &wnear_market, RESERVE_AMOUNT);

    mint_tokens(&wnear, user.account_id(), U128(WNEAR_BALANCE));
    mint_tokens(&weth, user.account_id(), U128(WETH_BALANCE));

    add_market(
        &controller,
        weth.account_id(),
        weth_market.account_id(),
        "weth".to_string(),
    );

    add_market(
        &controller,
        wnear.account_id(),
        wnear_market.account_id(),
        "wnear".to_string(),
    );

    set_price(
        &controller,
        wnear_market.account_id(),
        &Price {
            ticker_id: "wnear".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    set_price(
        &controller,
        weth_market.account_id(),
        &Price {
            ticker_id: "weth".to_string(),
            value: U128(START_PRICE),
            volatility: U128(100),
            fraction_digits: 4,
        },
    );

    supply(&user, &weth, weth_market.account_id(), SUPPLY_WETH_AMOUNT).assert_success();

    (weth_market, wnear_market, controller, weth, wnear, user)
}

#[test]
fn scenario_withdraw_success_after_failure() {
    let (weth_market, wnear_market, controller, weth, _wnear, user) =
        withdraw_success_after_failure_fixture();

    let result = withdraw(&user, &wnear_market, 0);
    assert_failure(result, "Amount should be a positive number");

    withdraw(&user, &weth_market, SUPPLY_WETH_AMOUNT).assert_success();

    let user_supply_balance: Balance = view_balance(
        &controller,
        Supply,
        user.account_id(),
        weth_market.account_id(),
    );
    assert_eq!(user_supply_balance, 0, "Balance should be {}", 0);

    let user_balance: U128 = view!(weth.ft_balance_of(user.account_id())).unwrap_json();
    assert_eq!(user_balance.0, SUPPLY_WETH_AMOUNT);
}

'''
'''--- contracts/market/tests/workspace/borrow/mod.rs ---
mod test_balance_after_borrow;

'''
'''--- contracts/market/tests/workspace/borrow/test_balance_after_borrow.rs ---
use crate::utils::*;
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use workspaces::network::Sandbox;
use workspaces::{Account, Worker};

const DECIMALS: u8 = 24;

async fn borrow_fixture(
    owner: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<
    (
        workspaces::Contract,
        workspaces::Contract,
        workspaces::Contract,
    ),
    anyhow::Error,
> {
    ////////////////////////////////////////////////////////////////////////////
    // Stage 1: Deploy contracts such as underlying, controller, and markets
    ////////////////////////////////////////////////////////////////////////////

    let underlying = deploy_underlying(owner, worker, DECIMALS).await?;
    let controller = deploy_controller(owner, worker).await?;
    let market = deploy_market(
        owner,
        worker,
        underlying.as_account(),
        DECIMALS,
        controller.as_account(),
    )
    .await?;

    let contract_ft_balance_of: U128 = worker
        .view(
            market.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field, contract_ft_balance_of,
        "Balances should match"
    );

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 2: Deposit the storage for contract, mint and fund with reserve underlying contract
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = underlying
        .call("storage_deposit")
        .args_json(json!({
            "account_id": market.id()
        }))
        .max_gas()
        .deposit(25 * 10u128.pow(23))
        .transact()
        .await?;

    let _ = underlying
        .call("mint")
        .args_json(json!({
            "account_id": owner.id(),
            "amount": U128::from(2000000000000000000000000000)
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(1000000000000000000000000000),
            "msg": "\"Reserve\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Check corresponding field after reserve
    ////////////////////////////////////////////////////////////////////////////////////////////

    let total_reserves_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_total_reserves",
            json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        total_reserves_after_reserve,
        U128::from(1000000000000000000000000000)
    );

    let contract_ft_balance_of_after_reserve: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field_after_reserve,
        contract_ft_balance_of_after_reserve
    );
    assert_ne!(contract_ft_balance_of, contract_ft_balance_of_after_reserve);
    assert_ne!(contract_balance_field, contract_balance_field_after_reserve);

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Register market on controller
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = controller
        .call("add_market")
        .args_json(json!({
            "asset_id": underlying.id(),
            "dtoken": market.id(),
            "ticker_id": "weth",
            "ltv": "0.4",
            "lth": "0.8"
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(1000000000000000000000000000),
            "msg": "\"Supply\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    Ok((underlying, controller, market))
}

#[tokio::test]
async fn test_successful_borrow() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.root_account()?;
    let (underlying, _, market) = borrow_fixture(&owner, &worker).await?;

    let contract_ft_balance_of_before_borrow: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_before_borrow: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let _ = owner
        .call(market.id(), "borrow")
        .args_json(json!({
            "amount": U128::from(1000000000000000000000000000 / 2),
        }))
        .max_gas()
        .transact()
        .await?;

    let contract_ft_balance_of_after_borrow: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_after_borrow: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert!(contract_ft_balance_of_before_borrow.0 > contract_ft_balance_of_after_borrow.0);
    assert!(contract_balance_field_before_borrow.0 > contract_balance_field_after_borrow.0);
    assert_eq!(
        contract_balance_field_after_borrow,
        contract_ft_balance_of_after_borrow
    );

    Ok(())
}

'''
'''--- contracts/market/tests/workspace/main.rs ---
pub mod borrow;
pub mod repay;
pub mod reserve;
pub mod supply;
pub mod utils;
pub mod withdraw;

'''
'''--- contracts/market/tests/workspace/repay/mod.rs ---
mod test_balance_after_repay;

'''
'''--- contracts/market/tests/workspace/repay/test_balance_after_repay.rs ---
use crate::utils::*;
use market::RepayInfo;
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::{require, Balance};
use workspaces::network::Sandbox;
use workspaces::{Account, Worker};

const DECIMALS: u8 = 24;

// 10 Near
const BORROW_AMOUNT: Balance = 10000000000000000000000000;

async fn repay_fixture(
    owner: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<
    (
        workspaces::Contract,
        workspaces::Contract,
        workspaces::Contract,
    ),
    anyhow::Error,
> {
    ////////////////////////////////////////////////////////////////////////////
    // Stage 1: Deploy contracts such as underlying, controller, and markets
    ////////////////////////////////////////////////////////////////////////////

    let underlying = deploy_underlying(owner, worker, DECIMALS).await?;
    let controller = deploy_controller(owner, worker).await?;
    let market = deploy_market(
        owner,
        worker,
        underlying.as_account(),
        DECIMALS,
        controller.as_account(),
    )
    .await?;

    let contract_ft_balance_of: U128 = worker
        .view(
            market.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field, contract_ft_balance_of,
        "Balances should match"
    );

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 2: Deposit the storage for contract, mint and fund with reserve underlying contract
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = underlying
        .call("storage_deposit")
        .args_json(json!({
            "account_id": market.id()
        }))
        .max_gas()
        .deposit(25 * 10u128.pow(23))
        .transact()
        .await?;

    let _ = underlying
        .call("mint")
        .args_json(json!({
            "account_id": owner.id(),
            "amount": U128::from(200000000000000000000000000)
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(100000000000000000000000000),
            "msg": "\"Reserve\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Check corresponding field after reserve
    ////////////////////////////////////////////////////////////////////////////////////////////

    let total_reserves_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_total_reserves",
            json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        total_reserves_after_reserve,
        U128::from(100000000000000000000000000)
    );

    let contract_ft_balance_of_after_reserve: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field_after_reserve,
        contract_ft_balance_of_after_reserve
    );
    assert_ne!(contract_ft_balance_of, contract_ft_balance_of_after_reserve);
    assert_ne!(contract_balance_field, contract_balance_field_after_reserve);

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Register market on controller
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = controller
        .call("add_market")
        .args_json(json!({
            "asset_id": underlying.id(),
            "dtoken": market.id(),
            "ticker_id": "weth",
            "ltv": "0.4",
            "lth": "0.8"
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(100000000000000000000000000),
            "msg": "\"Supply\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    let _ = owner
        .call(market.id(), "borrow")
        .args_json(json!({
            "amount": U128::from(BORROW_AMOUNT),
        }))
        .max_gas()
        .transact()
        .await?;

    Ok((underlying, controller, market))
}

#[tokio::test]
async fn test_repay_part_of_accumulated_interest() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.root_account()?;
    let (underlying, _, market) = repay_fixture(&owner, &worker).await?;

    // passing 100 blocks
    let blocks_to_advance = 100;
    worker.fast_forward(blocks_to_advance).await?;

    let contract_ft_balance_of_before_repay: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_before_repay: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field_before_repay, contract_ft_balance_of_before_repay,
        "Corresponding fields should match"
    );

    let repay_info: RepayInfo = worker
        .view(
            market.id(),
            "view_repay_info",
            json!({
                "user_id": owner.id(),
                "ft_balance": contract_balance_field_before_repay})
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let _repay_result = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(repay_info.accumulated_interest.0 / 2) ,
            "msg": "\"Repay\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    let contract_ft_balance_of_after_repay: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_after_repay: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert!(contract_balance_field_before_repay.0 < contract_balance_field_after_repay.0);
    assert!(contract_ft_balance_of_before_repay.0 < contract_balance_field_after_repay.0);

    assert_eq!(
        contract_ft_balance_of_before_repay.0 + (repay_info.accumulated_interest.0 / 2),
        contract_ft_balance_of_after_repay.0
    );
    assert_eq!(
        contract_balance_field_before_repay.0 + (repay_info.accumulated_interest.0 / 2),
        contract_balance_field_after_repay.0
    );

    assert_eq!(
        contract_balance_field_after_repay,
        contract_ft_balance_of_after_repay
    );

    Ok(())
}

#[tokio::test]
async fn test_repay_more() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.root_account()?;
    let (underlying, _, market) = repay_fixture(&owner, &worker).await?;

    // passing 1000 blocks
    let blocks_to_advance = 1000;
    worker.fast_forward(blocks_to_advance).await?;

    let contract_ft_balance_of_before_repay: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_before_repay: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_ft_balance_of_before_repay, contract_ft_balance_of_before_repay,
        "Corresponding fields should match"
    );

    let repay_info_before_repay: RepayInfo = worker
        .view(
            market.id(),
            "view_repay_info",
            json!({
                "user_id": owner.id(),
                "ft_balance": contract_balance_field_before_repay})
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_ne!(repay_info_before_repay.accumulated_interest.0, 0);

    require!(owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(BORROW_AMOUNT * 2)  ,
            "msg": "\"Repay\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?
        .is_success());

    // passing 10 blocks
    let blocks_to_advance = 10;
    worker.fast_forward(blocks_to_advance).await?;

    let contract_ft_balance_of_after_repay: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_after_repay: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field_after_repay, contract_ft_balance_of_after_repay,
        "Corresponding fields should match"
    );

    let repay_info_after_repay: RepayInfo = worker
        .view(
            market.id(),
            "view_repay_info",
            json!({
                "user_id": owner.id(),
                "ft_balance": contract_ft_balance_of_after_repay})
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(repay_info_after_repay.borrow_amount.0, 0);

    assert!(contract_balance_field_before_repay.0 < contract_balance_field_after_repay.0);
    assert!(contract_ft_balance_of_before_repay.0 < contract_balance_field_after_repay.0);

    Ok(())
}

'''
'''--- contracts/market/tests/workspace/reserve/mod.rs ---
mod test_balance_after_reserve;

'''
'''--- contracts/market/tests/workspace/reserve/test_balance_after_reserve.rs ---
use crate::utils::*;
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;

const DECIMALS: u8 = 24;

#[tokio::test]
async fn test_balance_after_reserve() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.root_account()?;

    ////////////////////////////////////////////////////////////////////////////
    // Stage 1: Deploy contracts such as underlying, controller, and markets
    ////////////////////////////////////////////////////////////////////////////

    let underlying = deploy_underlying(&owner, &worker, DECIMALS).await?;
    let controller = deploy_controller(&owner, &worker).await?;
    let market = deploy_market(
        &owner,
        &worker,
        underlying.as_account(),
        DECIMALS,
        controller.as_account(),
    )
    .await?;

    let contract_ft_balance_of: U128 = worker
        .view(
            market.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field, contract_ft_balance_of,
        "Balances should match"
    );

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 2: Deposit the storage for contract, mint and fund with reserve underlying contract
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = underlying
        .call("storage_deposit")
        .args_json(json!({
            "account_id": market.id()
        }))
        .max_gas()
        .deposit(25 * 10u128.pow(23))
        .transact()
        .await?;

    let _ = underlying
        .call("mint")
        .args_json(json!({
            "account_id": owner.id(),
            "amount": U128::from(1000000000000000000000000000)
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(1000000000000000000000000000),
            "msg": "\"Reserve\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Check corresponding field afterwards
    ////////////////////////////////////////////////////////////////////////////////////////////

    let total_reserves_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_total_reserves",
            json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        total_reserves_after_reserve,
        U128::from(1000000000000000000000000000)
    );

    let contract_ft_balance_of_after_reserve: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field_after_reserve,
        contract_ft_balance_of_after_reserve
    );
    assert_ne!(contract_ft_balance_of, contract_ft_balance_of_after_reserve);
    assert_ne!(contract_balance_field, contract_balance_field_after_reserve);

    Ok(())
}

'''
'''--- contracts/market/tests/workspace/supply/mod.rs ---
mod test_balance_after_supply;

'''
'''--- contracts/market/tests/workspace/supply/test_balance_after_supply.rs ---
use crate::utils::*;
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use workspaces::network::Sandbox;
use workspaces::{Account, Worker};

const DECIMALS: u8 = 24;

async fn supply_fixture(
    owner: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<
    (
        workspaces::Contract,
        workspaces::Contract,
        workspaces::Contract,
    ),
    anyhow::Error,
> {
    ////////////////////////////////////////////////////////////////////////////
    // Stage 1: Deploy contracts such as underlying, controller, and markets
    ////////////////////////////////////////////////////////////////////////////

    let underlying = deploy_underlying(owner, worker, DECIMALS).await?;
    let controller = deploy_controller(owner, worker).await?;
    let market = deploy_market(
        owner,
        worker,
        underlying.as_account(),
        DECIMALS,
        controller.as_account(),
    )
    .await?;

    let contract_ft_balance_of: U128 = worker
        .view(
            market.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field, contract_ft_balance_of,
        "Balances should match"
    );

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 2: Deposit the storage for contract, mint and fund with reserve underlying contract
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = underlying
        .call("storage_deposit")
        .args_json(json!({
            "account_id": market.id()
        }))
        .max_gas()
        .deposit(25 * 10u128.pow(23))
        .transact()
        .await?;

    let _ = underlying
        .call("mint")
        .args_json(json!({
            "account_id": owner.id(),
            "amount": U128::from(2000000000000000000000000000)
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(1000000000000000000000000000),
            "msg": "\"Reserve\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Check corresponding field after reserve
    ////////////////////////////////////////////////////////////////////////////////////////////

    let total_reserves_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_total_reserves",
            json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        total_reserves_after_reserve,
        U128::from(1000000000000000000000000000)
    );

    let contract_ft_balance_of_after_reserve: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field_after_reserve,
        contract_ft_balance_of_after_reserve
    );
    assert_ne!(contract_ft_balance_of, contract_ft_balance_of_after_reserve);
    assert_ne!(contract_balance_field, contract_balance_field_after_reserve);

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Register market on controller
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = controller
        .call("add_market")
        .args_json(json!({
            "asset_id": underlying.id(),
            "dtoken": market.id(),
            "ticker_id": "weth",
            "ltv": "0.4",
            "lth": "0.8"
        }))
        .max_gas()
        .transact()
        .await?;

    Ok((underlying, controller, market))
}

#[tokio::test]
async fn test_successful_supply() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.root_account()?;
    let (underlying, _, market) = supply_fixture(&owner, &worker).await?;

    let contract_ft_balance_of_before_supply: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_before_supply: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let _ = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(1000000000000000000000000000),
            "msg": "\"Supply\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    let contract_ft_balance_of_after_supply: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field_after_supply: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_ne!(
        contract_ft_balance_of_before_supply,
        contract_ft_balance_of_after_supply
    );
    assert_ne!(
        contract_balance_field_before_supply,
        contract_balance_field_after_supply
    );
    assert_eq!(
        contract_balance_field_after_supply,
        contract_ft_balance_of_after_supply
    );

    Ok(())
}

'''
'''--- contracts/market/tests/workspace/utils.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json;
use near_sdk::serde_json::json;
use workspaces::network::Sandbox;
use workspaces::{Account, Worker};

const MARKET_WASM: &str = "../target/wasm32-unknown-unknown/release/market.wasm";
const UNDERLYING_WASM: &str = "../target/wasm32-unknown-unknown/release/mock_token.wasm";
const CONTROLLER_WASM: &str = "../target/wasm32-unknown-unknown/release/controller.wasm";

pub async fn deploy_underlying(
    owner: &Account,
    worker: &Worker<Sandbox>,
    decimals: u8,
) -> Result<workspaces::Contract, workspaces::error::Error> {
    let wasm = std::fs::read(UNDERLYING_WASM);
    let underlying = worker.dev_deploy(&wasm.unwrap()).await?;

    let _ = underlying
        .call("new_default_meta")
        .args_json(json!({ "owner_id": owner.id(),
        "name": "Wrapped Ethereum",
        "symbol": "WETH",
        "total_supply": "1000000000000000000000000000",
        "decimals": decimals
                }))
        .max_gas()
        .transact()
        .await?;

    Ok(underlying)
}

pub async fn deploy_market(
    owner: &Account,
    worker: &Worker<Sandbox>,
    underlying_token: &Account,
    decimals: u8,
    controller: &Account,
) -> Result<workspaces::Contract, workspaces::error::Error> {
    let wasm = std::fs::read(MARKET_WASM);
    let market = worker.dev_deploy(&wasm.unwrap()).await?;

    let _ = market
        .call("new_with_config")
        .args_json(json!({
            "owner_id":  owner.id(),
            "underlying_token_id": underlying_token.id(),
            "underlying_token_decimals": decimals,
            "controller_account_id": controller.id(),
            "initial_exchange_rate":"1000000000000000000000000",
            "interest_rate_model":{
                "kink":"650000000000000000000000",
                "multiplier_per_block":"3044140030441400",
                "base_rate_per_block":"0",
                "jump_multiplier_per_block":"38051750380517500",
                "reserve_factor":"10000000000000000000000"
            }
        }))
        .max_gas()
        .transact()
        .await?;

    let total_reserves: U128 = worker
        .view(
            market.id(),
            "view_total_reserves",
            serde_json::json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(total_reserves, U128(0));

    Ok(market)
}

pub async fn deploy_controller(
    owner: &Account,
    worker: &Worker<Sandbox>,
) -> Result<workspaces::Contract, workspaces::error::Error> {
    let wasm = std::fs::read(CONTROLLER_WASM);
    let controller = worker.dev_deploy(&wasm.unwrap()).await?;
    let oracle = worker.dev_create_account().await?;

    let _ = controller
        .call("new_with_config")
        .args_json(json!({
        "owner_id": owner.id(),
        "oracle_account_id":oracle.id()
        }))
        .max_gas()
        .transact()
        .await?;

    Ok(controller)
}

'''
'''--- contracts/market/tests/workspace/withdraw/mod.rs ---
mod test_balance_after_withdraw;

'''
'''--- contracts/market/tests/workspace/withdraw/test_balance_after_withdraw.rs ---
use crate::utils::*;
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use workspaces::network::Sandbox;
use workspaces::{Account, Worker};

const DECIMALS: u8 = 6;

async fn withdraw_fixture(
    owner: &Account,
    user: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<
    (
        workspaces::Contract,
        workspaces::Contract,
        workspaces::Contract,
    ),
    anyhow::Error,
> {
    ////////////////////////////////////////////////////////////////////////////
    // Stage 1: Deploy contracts such as underlying, controller, and markets
    ////////////////////////////////////////////////////////////////////////////

    let underlying = deploy_underlying(owner, worker, DECIMALS).await?;
    let controller = deploy_controller(owner, worker).await?;
    let market = deploy_market(
        owner,
        worker,
        underlying.as_account(),
        DECIMALS,
        controller.as_account(),
    )
    .await?;

    let contract_ft_balance_of: U128 = worker
        .view(
            market.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let contract_balance_field: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field, contract_ft_balance_of,
        "Balances should match"
    );

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 2: Deposit the storage for contract, mint and fund with reserve underlying contract
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = underlying
        .call("storage_deposit")
        .args_json(json!({
            "account_id": market.id()
        }))
        .max_gas()
        .deposit(25 * 10u128.pow(23))
        .transact()
        .await?;

    let _ = underlying
        .call("mint")
        .args_json(json!({
            "account_id": user.id(),
            "amount": U128::from(2000 * 10_u128.pow(6))
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = underlying
        .call("mint")
        .args_json(json!({
            "account_id": owner.id(),
            "amount": U128::from(2000 * 10_u128.pow(6))
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = owner
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(1000 * 10_u128.pow(6)),
            "msg": "\"Reserve\""
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Check corresponding field after reserve
    ////////////////////////////////////////////////////////////////////////////////////////////

    let total_reserves_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_total_reserves",
            json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        total_reserves_after_reserve,
        U128::from(1000 * 10_u128.pow(24))
    );

    let contract_underlying_ft_balance_of_after_reserve: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_underlying_ft_balance_of_after_reserve,
        U128(1000 * 10_u128.pow(6))
    );

    let contract_market_balance_field_after_reserve: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_market_balance_field_after_reserve,
        U128(1000 * 10_u128.pow(24))
    );

    assert_ne!(
        contract_balance_field,
        contract_market_balance_field_after_reserve
    );

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Stage 3: Register market on controller
    ////////////////////////////////////////////////////////////////////////////////////////////

    let _ = controller
        .call("add_market")
        .args_json(json!({
            "asset_id": underlying.id(),
            "dtoken": market.id(),
            "ticker_id": "weth",
            "ltv": "0.4",
            "lth": "0.8"
        }))
        .max_gas()
        .transact()
        .await?;

    let _ = controller
        .call("upsert_price")
        .args_json(json!({
            "dtoken_id": market.id(),
            "price": {
            "ticker_id": "weth".to_string(),
            "value": U128(2000),
            "volatility": U128(100),
            "fraction_digits": 4,
        }}))
        .max_gas()
        .transact()
        .await?;

    Ok((underlying, market, controller))
}

#[tokio::test]
async fn test_successful_withdraw() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.root_account()?;
    let user = worker.dev_create_account().await?;
    let (underlying, market, _) = withdraw_fixture(&owner, &user, &worker).await?;

    let _a = user
        .call(underlying.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": market.id(),
            "amount": U128::from(1000 * 10_u128.pow(6)),
            "msg": "\"Supply\"",
        }))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;

    let contract_underlying_ft_balance_of_after_supply: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": user.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_underlying_ft_balance_of_after_supply,
        U128(1000 * 10_u128.pow(6))
    );

    let contract_market_ft_balance_of_after_supply: U128 = worker
        .view(
            market.id(),
            "ft_balance_of",
            json!({
                "account_id": user.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_market_ft_balance_of_after_supply,
        U128(1000 * 10_u128.pow(24))
    );

    let contract_ft_balance_of_before_withdraw: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_ft_balance_of_before_withdraw,
        U128(2000 * 10_u128.pow(6))
    );

    let contract_balance_field_before_withdraw: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field_before_withdraw,
        U128(2000 * 10_u128.pow(24))
    );

    let _ = user
        .call(market.id(), "withdraw")
        .args_json(json!({
            "amount": U128::from(500 * 10_u128.pow(24)),
        }))
        .max_gas()
        .transact()
        .await?;

    let contract_ft_balance_of_market_after_withdraw: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_ft_balance_of_market_after_withdraw,
        U128(1500 * 10_u128.pow(6))
    );

    let contract_ft_balance_of_user_after_withdraw: U128 = worker
        .view(
            underlying.id(),
            "ft_balance_of",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_ft_balance_of_user_after_withdraw,
        U128(1500 * 10_u128.pow(6))
    );

    let contract_balance_field_after_withdraw: U128 = worker
        .view(
            market.id(),
            "view_contract_balance",
            json!({
                "account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_balance_field_after_withdraw,
        U128(1500 * 10_u128.pow(24))
    );

    let contract_market_ft_balance_of_after_withdraw: U128 = worker
        .view(
            market.id(),
            "ft_balance_of",
            json!({
                "account_id": user.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(
        contract_market_ft_balance_of_after_withdraw,
        U128(500 * 10_u128.pow(24))
    );
    Ok(())
}

'''
'''--- contracts/mock-token/Cargo.toml ---
[package]
name = "mock-token"
version = "0.0.1"
authors = ["mark.ts@blaize.tech", "tymofii.s@blaize.tech", "vladyslav.v@blaize.tech", "orest.o@blaize.tech", "sergii.p@blaize.tech"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.3"
near-contract-standards = "4.0.0-pre.6"

'''
'''--- contracts/mock-token/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::require;
use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

// example from near
const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg viewBox='0 0 40 41' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M20 40.3967C31.0457 40.3967 40 31.4424 40 20.3967C40 9.35103 31.0457 0.396729 20 0.396729C8.9543 0.396729 0 9.35103 0 20.3967C0 31.4424 8.9543 40.3967 20 40.3967ZM9.94128 26.8949C10.8013 27.6658 11.8831 27.8967 12.92 27.8967C14.0181 27.8967 15.0686 27.635 15.7432 27.467L15.7518 27.4648C15.8896 27.4288 16.0125 27.3988 16.1084 27.3778C18.6046 26.829 21.1098 26.805 23.5551 27.2939C23.6803 27.3172 23.8337 27.3575 24.01 27.4037L24.0256 27.4078L24.0427 27.4121C25.4456 27.7647 28.3397 28.4921 30.2856 26.652C31.0407 25.9442 31.5442 24.9274 31.703 23.7996L31.7042 23.791C31.9467 22.0799 32.2474 19.9585 31.658 17.0091C31.5352 16.3792 31.0677 15.0625 30.3485 14.2287C29.1828 12.87 27.2919 12.5521 24.7238 13.2689L24.6369 13.2929C21.859 14.0578 19.0451 14.1357 16.2762 13.5239L16.0395 13.4699L16.0332 13.4684C15.1327 13.2611 13.4619 12.8765 11.973 13.086C10.6275 13.2779 9.43185 14.1627 8.77558 15.4614C8.52686 15.9503 8.40699 16.4452 8.33208 16.8231C7.90056 18.9827 7.88857 21.5411 8.30211 23.8506C8.52086 25.0653 9.10221 26.1481 9.94128 26.8949ZM12.4165 16.2383C12.5723 16.2173 12.7372 16.2083 12.908 16.2083C13.75 16.2083 14.7509 16.4362 15.3263 16.5772L15.59 16.6402C18.8683 17.363 22.1916 17.2731 25.4729 16.3702L25.5808 16.3433C27.3159 15.8514 27.8103 16.1543 27.9422 16.3073C28.1999 16.6042 28.4936 17.36 28.5475 17.639C29.033 20.0624 28.7842 21.8141 28.5625 23.3587C28.5056 23.7726 28.3407 24.1326 28.11 24.3515C27.4265 24.997 25.7497 24.5746 24.8276 24.3423L24.8047 24.3365C24.559 24.2735 24.3462 24.2225 24.1754 24.1865C21.3016 23.6077 18.3589 23.6437 15.4341 24.2795C15.3141 24.3059 15.1654 24.3437 14.9937 24.3874L14.9817 24.3905L14.9487 24.3986C14.3211 24.5535 12.5601 24.9881 12.0479 24.5315C11.7393 24.2585 11.5115 23.8086 11.4216 23.2987C11.083 21.4001 11.089 19.2136 11.4426 17.459C11.4756 17.291 11.5295 17.0541 11.6044 16.9041C11.7902 16.5322 12.0959 16.2833 12.4165 16.2383Z' fill='%2386EC8A'/%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(
        owner_id: AccountId,
        name: String,
        symbol: String,
        total_supply: U128,
        decimals: u8,
    ) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name,
                symbol,
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");

        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        this
    }

    pub fn mint(&mut self, account_id: AccountId, amount: U128) {
        if self.token.accounts.get(&account_id).is_none() {
            self.token.internal_register_account(&account_id);
        };
        self.token.internal_deposit(&account_id, amount.into());
    }

    pub fn burn(&mut self, account_id: AccountId, amount: U128) {
        self.token.internal_withdraw(&account_id, amount.into());
    }
}

// main implementation for token and storage
near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::test_env::{alice, bob};
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{env, testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn init() -> (VMContextBuilder, AccountId, Contract) {
        // get VM builer
        let context = VMContextBuilder::new();

        // account for contract
        let _contract_account = alice();

        // init the contract

        let contract = Contract::new_default_meta(
            _contract_account.clone(),
            String::from("Mock Token"),
            String::from("MOCK"),
            TOTAL_SUPPLY.into(),
            24,
        );

        (context, _contract_account, contract)
    }

    #[allow(dead_code)]
    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn check_total_supply() {
        let (context, _contract_account, contract) = init();

        testing_env!(context.build());

        assert_eq!(contract.ft_total_supply(), 1_000_000_000_000_000.into());
    }

    #[test]
    fn test_mint_bob() {
        let (context, _, mut contract) = init();

        testing_env!(context.build());

        let bob_account = bob();

        contract.mint(bob_account.clone(), (TOTAL_SUPPLY / 100).into());

        assert_eq!(
            contract.ft_balance_of(bob_account),
            (TOTAL_SUPPLY / 100).into()
        )
    }

    #[test]
    fn test_burn_bob() {
        let (context, _, mut contract) = init();

        testing_env!(context.build());

        let bob_account = bob();

        contract.mint(bob_account.clone(), (TOTAL_SUPPLY / 100).into());
        contract.burn(bob_account.clone(), (TOTAL_SUPPLY / 100).into());

        assert_eq!(contract.ft_balance_of(bob_account), 0.into())
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());

        let mut contract = Contract::new_default_meta(
            accounts(2),
            String::from("Mock Token"),
            String::from("MOCK"),
            TOTAL_SUPPLY.into(),
            24,
        );

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());

        let transferred_tokens = TOTAL_SUPPLY / 100;
        contract.ft_transfer(
            accounts(1),
            transferred_tokens.into(),
            Some("you have received some tokens bro".to_string()),
        );

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());

        assert_eq!(
            contract.ft_balance_of(accounts(2)).0,
            (TOTAL_SUPPLY - transferred_tokens)
        );
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transferred_tokens);
    }
}

'''
'''--- contracts/token/Cargo.toml ---
[package]
name = "token"
version = "0.0.1"
authors = ["mark.ts@blaize.tech", "tymofii.s@blaize.tech", "vladyslav.v@blaize.tech", "orest.o@blaize.tech", "sergii.p@blaize.tech"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.3"
near-contract-standards = "4.0.0-pre.6"

'''
'''--- contracts/token/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::require;
use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

// example from near
const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg viewBox='0 0 40 41' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M20 40.3967C31.0457 40.3967 40 31.4424 40 20.3967C40 9.35103 31.0457 0.396729 20 0.396729C8.9543 0.396729 0 9.35103 0 20.3967C0 31.4424 8.9543 40.3967 20 40.3967ZM9.94128 26.8949C10.8013 27.6658 11.8831 27.8967 12.92 27.8967C14.0181 27.8967 15.0686 27.635 15.7432 27.467L15.7518 27.4648C15.8896 27.4288 16.0125 27.3988 16.1084 27.3778C18.6046 26.829 21.1098 26.805 23.5551 27.2939C23.6803 27.3172 23.8337 27.3575 24.01 27.4037L24.0256 27.4078L24.0427 27.4121C25.4456 27.7647 28.3397 28.4921 30.2856 26.652C31.0407 25.9442 31.5442 24.9274 31.703 23.7996L31.7042 23.791C31.9467 22.0799 32.2474 19.9585 31.658 17.0091C31.5352 16.3792 31.0677 15.0625 30.3485 14.2287C29.1828 12.87 27.2919 12.5521 24.7238 13.2689L24.6369 13.2929C21.859 14.0578 19.0451 14.1357 16.2762 13.5239L16.0395 13.4699L16.0332 13.4684C15.1327 13.2611 13.4619 12.8765 11.973 13.086C10.6275 13.2779 9.43185 14.1627 8.77558 15.4614C8.52686 15.9503 8.40699 16.4452 8.33208 16.8231C7.90056 18.9827 7.88857 21.5411 8.30211 23.8506C8.52086 25.0653 9.10221 26.1481 9.94128 26.8949ZM12.4165 16.2383C12.5723 16.2173 12.7372 16.2083 12.908 16.2083C13.75 16.2083 14.7509 16.4362 15.3263 16.5772L15.59 16.6402C18.8683 17.363 22.1916 17.2731 25.4729 16.3702L25.5808 16.3433C27.3159 15.8514 27.8103 16.1543 27.9422 16.3073C28.1999 16.6042 28.4936 17.36 28.5475 17.639C29.033 20.0624 28.7842 21.8141 28.5625 23.3587C28.5056 23.7726 28.3407 24.1326 28.11 24.3515C27.4265 24.997 25.7497 24.5746 24.8276 24.3423L24.8047 24.3365C24.559 24.2735 24.3462 24.2225 24.1754 24.1865C21.3016 23.6077 18.3589 23.6437 15.4341 24.2795C15.3141 24.3059 15.1654 24.3437 14.9937 24.3874L14.9817 24.3905L14.9487 24.3986C14.3211 24.5535 12.5601 24.9881 12.0479 24.5315C11.7393 24.2585 11.5115 23.8086 11.4216 23.2987C11.083 21.4001 11.089 19.2136 11.4426 17.459C11.4756 17.291 11.5295 17.0541 11.6044 16.9041C11.7902 16.5322 12.0959 16.2833 12.4165 16.2383Z' fill='%2386EC8A'/%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(
        owner_id: AccountId,
        name: String,
        symbol: String,
        total_supply: U128,
    ) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name,
                symbol,
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");

        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        this
    }
}

// main implementation for token and storage
near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- deploy.sh ---
# build & test
build_and_test() {
    ./build.sh && ./test.sh
}

# clean up previous deployment
clean_up_previous_deployment () {
    echo 'y' | near delete weth_market.$1 $1 & 
    echo 'y' | near delete wnear_market.$1 $1 & 
    echo 'y' | near delete usdt_market.$1 $1 & 
    echo 'y' | near delete usdc_market.$1 $1 &

    # TODO unify naming
    echo 'y' | near delete $CONTROLLER_ACCOUNT.$1 $1 &
    wait
}

# delete mock tokens
clean_up_tokens () {
    echo 'y' | near delete $ETH_TOKEN  --masterAccount $1 $1 & 
    echo 'y' | near delete $NEAR_TOKEN --masterAccount $1 $1 &
    echo 'y' | near delete $USDT_TOKEN --masterAccount $1 $1 & 
    echo 'y' | near delete $USDC_TOKEN --masterAccount $1 $1 &

    wait
}

# create underlying tokens
create_underlying_tokens() {
    near create-account $ETH_TOKEN  --masterAccount $1 --initialBalance 3 &
    near create-account $NEAR_TOKEN --masterAccount $1 --initialBalance 3 &
    near create-account $USDT_TOKEN --masterAccount $1 --initialBalance 3 &
    near create-account $USDC_TOKEN --masterAccount $1 --initialBalance 3 &
    wait
}

# create markets
create_markets() {
    near create-account weth_market.$1 --masterAccount $1 --initialBalance 7 &
    near create-account wnear_market.$1 --masterAccount $1 --initialBalance 7 &
    near create-account usdt_market.$1 --masterAccount $1 --initialBalance 7 &
    near create-account usdc_market.$1 --masterAccount $1 --initialBalance 7 &
    wait
}

# create controller
create_controller() {
    near create-account $CONTROLLER_ACCOUNT.$1 --masterAccount $1 --initialBalance 10 &
    wait
}

# deploy underlyings
deploy_underlyings() {
    near deploy weth.$1 \
        --wasmFile ./contracts/target/wasm32-unknown-unknown/release/mock_token.wasm \
        --initFunction 'new_default_meta' \
        --initArgs '{
            "owner_id": "'$1'",
            "name": "Wrapped Ethereum",
            "symbol": "WETH",
            "total_supply": "0",
            "decimals": '$ETH_TOKEN_DECIMALS'
        }' &
    near deploy wnear.$1 \
        --wasmFile ./contracts/target/wasm32-unknown-unknown/release/mock_token.wasm \
        --initFunction 'new_default_meta' \
        --initArgs '{
            "owner_id": "'$1'",
            "name": "Wrapped Near",
            "symbol": "WNEAR",
            "total_supply": "0",
            "decimals": '$NEAR_TOKEN_DECIMALS'
        }' &
    near deploy usdt.$1 \
        --wasmFile ./contracts/target/wasm32-unknown-unknown/release/mock_token.wasm \
        --initFunction 'new_default_meta' \
        --initArgs '{
            "owner_id": "'$1'",
            "name": "Tether",
            "symbol": "USDT",
            "total_supply": "0",
            "decimals": '$USDT_TOKEN_DECIMALS'
        }' &
    near deploy usdc.$1 \
        --wasmFile ./contracts/target/wasm32-unknown-unknown/release/mock_token.wasm \
        --initFunction 'new_default_meta' \
        --initArgs '{
            "owner_id": "'$1'",
            "name": "USD Coin",
            "symbol": "USDC",
            "total_supply": "0",
            "decimals": '$USDC_TOKEN_DECIMALS'
        }' &

    wait
}

# deploy markets
deploy_markets(){
    near deploy weth_market.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/market.wasm \
        --initFunction 'new_with_config' \
        --initArgs '{
            "owner_id":"'$1'",
            "underlying_token_id":"'$ETH_TOKEN'",
            "underlying_token_decimals": '$ETH_TOKEN_DECIMALS',
            "controller_account_id":"'$CONTROLLER_ACCOUNT'.'$1'",
            "initial_exchange_rate":"1000000000000000000000000",
            "interest_rate_model":{
                "kink":"650000000000000000000000",
                "multiplier_per_block":"3044140030441400",
                "base_rate_per_block":"0",
                "jump_multiplier_per_block":"38051750380517500",
                "reserve_factor":"10000000000000000000000"
            }
        }' &
    near deploy wnear_market.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/market.wasm \
        --initFunction 'new_with_config' \
        --initArgs '{
            "owner_id":"'$1'",
            "underlying_token_id":"'$NEAR_TOKEN'",
            "underlying_token_decimals": '$NEAR_TOKEN_DECIMALS',
            "controller_account_id":"'$CONTROLLER_ACCOUNT'.'$1'",
            "initial_exchange_rate":"1000000000000000000000000",
            "interest_rate_model":{
                "kink":"650000000000000000000000",
                "multiplier_per_block":"3044140030441400",
                "base_rate_per_block":"0",
                "jump_multiplier_per_block":"38051750380517500",
                "reserve_factor":"10000000000000000000000"
            }
        }' &
    near deploy usdt_market.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/market.wasm \
        --initFunction 'new_with_config' \
        --initArgs '{
        "owner_id":"'$1'",
        "underlying_token_id":"'$USDT_TOKEN'",
        "underlying_token_decimals": '$USDT_TOKEN_DECIMALS',
        "controller_account_id":"'$CONTROLLER_ACCOUNT'.'$1'",
            "initial_exchange_rate":"1000000000000000000000000",
            "interest_rate_model":{
            "kink":"800000000000000000000000",
            "multiplier_per_block":"1522070015220700",
            "base_rate_per_block":"0",
            "jump_multiplier_per_block":"28538812785388100",
            "reserve_factor":"10000000000000000000000"
            }
        }' &
    near deploy usdc_market.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/market.wasm \
        --initFunction 'new_with_config' \
        --initArgs '{
        "owner_id":"'$1'",
        "underlying_token_id":"'$USDC_TOKEN'",
        "underlying_token_decimals": '$USDC_TOKEN_DECIMALS',
        "controller_account_id":"'$CONTROLLER_ACCOUNT'.'$1'",
            "initial_exchange_rate":"1000000000000000000000000",
            "interest_rate_model":{
            "kink":"800000000000000000000000",
            "multiplier_per_block":"1522070015220700",
            "base_rate_per_block":"0",
            "jump_multiplier_per_block":"28538812785388100",
            "reserve_factor":"10000000000000000000000"
            }
        }' &
    
    wait
}

redeploy_markets(){
    echo 'y' | near deploy weth_market.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/market.wasm \
        --initFunction 'migrate' \
        --initArgs '{}' &
    echo 'y' | near deploy wnear_market.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/market.wasm \
        --initFunction 'migrate' \
        --initArgs '{}' &
    echo 'y' | near deploy usdt_market.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/market.wasm \
        --initFunction 'migrate' \
        --initArgs '{}' &
    echo 'y' | near deploy usdc_market.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/market.wasm \
        --initFunction 'migrate' \
        --initArgs '{}' &
    
    wait
}

# deploy controller
deploy_controller(){
    near deploy $CONTROLLER_ACCOUNT.$1 \
        --wasmFile ./contracts/target/wasm32-unknown-unknown/release/controller.wasm \
        --initFunction 'new_with_config' \
        --initArgs '{
            "owner_id":"'$1'",
            "oracle_account_id":"'$ORACLE_ACCOUNT'"
        }' &

    wait
}

redeploy_controller(){
    echo 'y' | near deploy $CONTROLLER_ACCOUNT.$1 \
        --wasmFile  ./contracts/target/wasm32-unknown-unknown/release/controller.wasm \
        --initFunction 'migrate' \
        --initArgs '{}' &

    wait
}

# create account on underlyings for dtokens
create_account_on_underlyings_for_dtokens(){
    near call $ETH_TOKEN storage_deposit '{"account_id": "weth_market.'$1'"}' --accountId $1 --amount 0.25 &
    near call $NEAR_TOKEN storage_deposit '{"account_id": "wnear_market.'$1'"}' --accountId $1 --amount 0.25 &
    near call $USDT_TOKEN storage_deposit '{"account_id": "usdt_market.'$1'"}' --accountId $1 --amount 0.25 &
    near call $USDC_TOKEN storage_deposit '{"account_id": "usdc_market.'$1'"}' --accountId $1 --amount 0.25 &

    wait
}

# register markets
register_markets_on_controller(){
    near call $CONTROLLER_ACCOUNT.$1 add_market '{
            "asset_id": "'$ETH_TOKEN'",
            "dtoken": "weth_market.'$1'",
            "ticker_id": "nWETH",
            "ltv": "0.4",
            "lth": "0.8"
        }' --accountId $1 &
    near call $CONTROLLER_ACCOUNT.$1 add_market '{
            "asset_id": "'$NEAR_TOKEN'",
            "dtoken": "wnear_market.'$1'",
            "ticker_id": "near",
            "ltv": "0.5",
            "lth": "0.8"
        }' --accountId $1 &
    near call $CONTROLLER_ACCOUNT.$1 add_market '{
            "asset_id": "'$USDT_TOKEN'",
            "dtoken": "usdt_market.'$1'",
            "ticker_id": "USDt",
            "ltv": "0.8",
            "lth": "0.9"
        }' --accountId $1 &
    near call $CONTROLLER_ACCOUNT.$1 add_market '{
            "asset_id": "'$USDC_TOKEN'",
            "dtoken": "usdc_market.'$1'",
            "ticker_id": "nUSDC",
            "ltv": "0.8",
            "lth": "0.9"
        }' --accountId $1 &

    wait
}

setup_reserves(){
    # mint reserves
    near call $ETH_TOKEN mint '{
        "account_id": "'$1'",
        "amount": "1000000000000000000000000000"
    }' --accountId $1 &
    near call $NEAR_TOKEN mint '{
        "account_id": "'$1'",
        "amount": "1000000000000000000000000000"
    }' --accountId $1 &
    near call $USDT_TOKEN mint '{
        "account_id": "'$1'",
        "amount": "1000000000000000000000000000"
    }' --accountId $1 &
    near call $USDC_TOKEN mint '{
        "account_id": "'$1'",
        "amount": "1000000000000000000000000000"
    }' --accountId $1 &

    wait

    # transfer reserves
    near call $ETH_TOKEN ft_transfer_call '{
        "receiver_id": "weth_market.'$1'",
        "amount": "1000000000000000000000000000",
        "msg": "\"Reserve\""
    }' --depositYocto 1 --gas 300000000000000 --accountId $1 &
    near call $NEAR_TOKEN ft_transfer_call '{
        "receiver_id": "wnear_market.'$1'",
        "amount": "1000000000000000000000000000",
        "msg": "\"Reserve\""
    }' --depositYocto 1 --gas 300000000000000 --accountId $1 &
    near call $USDT_TOKEN ft_transfer_call '{
        "receiver_id": "usdt_market.'$1'",
        "amount": "1000000000000000000000000000",
        "msg": "\"Reserve\""
    }' --depositYocto 1 --gas 300000000000000 --accountId $1 &
    near call $USDC_TOKEN ft_transfer_call '{
        "receiver_id": "usdc_market.'$1'",
        "amount": "1000000000000000000000000000",
        "msg": "\"Reserve\""
    }' --depositYocto 1 --gas 300000000000000 --accountId $1 &

    wait
}

configure_acl() {
    # set shared admin as admin for dtokens
    near call weth_market.$1 set_admin '{"account": "shared_admin.testnet"}' --gas 300000000000000 --accountId $1 &
    near call wnear_market.$1 set_admin '{"account": "shared_admin.testnet"}' --gas 300000000000000 --accountId $1 &
    near call usdt_market.$1 set_admin '{"account": "shared_admin.testnet"}' --gas 300000000000000 --accountId $1 &
    near call usdc_market.$1 set_admin '{"account": "shared_admin.testnet"}' --gas 300000000000000 --accountId $1 &

    wait
}
'''
'''--- deploy_dev.sh ---
# setup
source ./deploy.sh

ROOT_ACCOUNT=develop.v1.omomo-finance.testnet
CONTROLLER_ACCOUNT=controller
ORACLE_ACCOUNT=oracle.omomo-finance.testnet

ETH_TOKEN=weth.develop.v1.omomo-finance.testnet
ETH_TOKEN_DECIMALS=24

NEAR_TOKEN=wnear.develop.v1.omomo-finance.testnet
NEAR_TOKEN_DECIMALS=24

USDT_TOKEN=usdt.develop.v1.omomo-finance.testnet
USDT_TOKEN_DECIMALS=24

USDC_TOKEN=usdc.develop.v1.omomo-finance.testnet
USDC_TOKEN_DECIMALS=24

# deployment steps
build_and_test

clean_up_previous_deployment $ROOT_ACCOUNT &
clean_up_tokens $ROOT_ACCOUNT &
wait

create_underlying_tokens $ROOT_ACCOUNT &
create_markets $ROOT_ACCOUNT &
create_controller $ROOT_ACCOUNT &
wait

deploy_underlyings $ROOT_ACCOUNT &
deploy_markets $ROOT_ACCOUNT &
deploy_controller $ROOT_ACCOUNT &
wait

create_account_on_underlyings_for_dtokens $ROOT_ACCOUNT $ROOT_ACCOUNT
register_markets_on_controller $ROOT_ACCOUNT &
setup_reserves $ROOT_ACCOUNT &
wait

configure_acl $ROOT_ACCOUNT &
wait

# view status
near view $CONTROLLER_ACCOUNT.$ROOT_ACCOUNT view_markets '{}' --accountId $CONTROLLER_ACCOUNT.$ROOT_ACCOUNT
near view $CONTROLLER_ACCOUNT.$ROOT_ACCOUNT view_prices '{ "dtokens": ["wnear_market.'$ROOT_ACCOUNT'", "weth_market.'$ROOT_ACCOUNT'", "usdt_market.'$ROOT_ACCOUNT'", "usdc_market.'$ROOT_ACCOUNT'"] }' --accountId $CONTROLLER_ACCOUNT.$ROOT_ACCOUNT

# view balances
near view $ETH_TOKEN  ft_balance_of '{"account_id": "weth_market.'$ROOT_ACCOUNT'"}'
near view $NEAR_TOKEN ft_balance_of '{"account_id": "wnear_market.'$ROOT_ACCOUNT'"}'
near view $USDT_TOKEN ft_balance_of '{"account_id": "usdt_market.'$ROOT_ACCOUNT'"}'
near view $USDC_TOKEN ft_balance_of '{"account_id": "usdc_market.'$ROOT_ACCOUNT'"}'

# mark commit with deploy-tag
LATEST_TAG=`git tag -l "v*" | sort -r | head -n1`
echo $LATEST_TAG

DEPLOY_TAG="dev_deploy_"${LATEST_TAG}_`date +%s`
echo $DEPLOY_TAG

git tag $DEPLOY_TAG
git push origin $DEPLOY_TAG
'''
'''--- deploy_stage.sh ---
# setup
source ./deploy.sh

ROOT_ACCOUNT=v1.omomo-finance.testnet
CONTROLLER_ACCOUNT=controller
ORACLE_ACCOUNT=oracle.omomo-finance.testnet
ETH_TOKEN=eth.fakes.testnet
ETH_TOKEN_DECIMALS=18

NEAR_TOKEN=wrap.testnet
NEAR_TOKEN_DECIMALS=24

USDT_TOKEN=usdt.fakes.testnet
USDT_TOKEN_DECIMALS=24

USDC_TOKEN=usdc.fakes.testnet
USDC_TOKEN_DECIMALS=6

# deployment steps
build_and_test
clean_up_previous_deployment $ROOT_ACCOUNT
create_markets $ROOT_ACCOUNT &
create_controller $ROOT_ACCOUNT &
wait

deploy_markets $ROOT_ACCOUNT &
# redeploy_markets $ROOT_ACCOUNT &
deploy_controller $ROOT_ACCOUNT &
# redeploy_controller $ROOT_ACCOUNT &
wait

create_account_on_underlyings_for_dtokens $ROOT_ACCOUNT
register_markets_on_controller $ROOT_ACCOUNT &
setup_reserves $ROOT_ACCOUNT &
wait

configure_acl $ROOT_ACCOUNT &
wait

# login
# near login

# view status
near view $CONTROLLER_ACCOUNT.$ROOT_ACCOUNT view_markets '{}' --accountId $CONTROLLER_ACCOUNT.$ROOT_ACCOUNT
near view $CONTROLLER_ACCOUNT.$ROOT_ACCOUNT view_prices '{ "dtokens": ["wnear_market.'$ROOT_ACCOUNT'", "weth_market.'$ROOT_ACCOUNT'", "usdt_market.'$ROOT_ACCOUNT'", "usdc_market.'$ROOT_ACCOUNT'"] }' --accountId $CONTROLLER_ACCOUNT.$ROOT_ACCOUNT

# view balances
near view $ETH_TOKEN ft_balance_of '{"account_id": "weth_market.'$ROOT_ACCOUNT'"}'
near view $NEAR_TOKEN ft_balance_of '{"account_id": "wnear_market.'$ROOT_ACCOUNT'"}'
near view $USDT_TOKEN ft_balance_of '{"account_id": "usdt_market.'$ROOT_ACCOUNT'"}'
near view $USDC_TOKEN ft_balance_of '{"account_id": "usdc_market.'$ROOT_ACCOUNT'"}'

'''
'''--- developers/contact.md ---
# Contact us

|         |                                                                                                                                          |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| Medium  | [medium](https://medium.com/nearlend/introducing-nearlend-the-most-user-friendly-liquidity-protocol-coming-to-near-mainnet-1c78bd3858ca) |
| Web     | [nearlend.io](https://nearlend.io)                                                                                                       |
| Twitter | [@nearlend](https://twitter.com/nearlend\_io?s=20)                                                                                       |
| Email   | [support@nearlend.io](mailto:support@nearlend.io)                                                                                        |
| Discord | #discord\_nearlend                                                                                                                       |

'''
'''--- developers/contracts.md ---
# Contracts

* Controller
* Token

![](../.gitbook/assets/general.png)

'''
'''--- general/roadmap.md ---
# Roadmap

## Timeline and plans

Nearlend MVP development is an ongoing process, which is planned for Q1-Q2 2022. The working MVP will include all basic operations for the limited number of markets and provide the liquidation mechanism with partly automated internal processes.

## Closest roadmap

### Phase 1. MVP development (Q1 – Q2 2022)

* Develop basic supply/withdraw and borrow/repay functionality
* Develop the initial version of the liquidation mechanism
* Implement dApp V1
* Add initial markets for NEAR and popular stablecoins
* Implement price feeds by directly connecting the app to a DEX
* Implement the initial interest rate model
* Develop Nearlend native token and integrate basic tokenomics
* Develop reserves system

### **MVP launch (Q2 2022)**

### **Phase 2 (end of Q2 – Q3 2022)**

* Implement market registration mechanism
* Connect a secure Oracle for price feeds
* Integrate native token incentivization
* Expand collateralization to include several markets
* Expand the number of the markets
* Develop Nearlend DAO
* Expand the existing tokenomics and token utility

### **Phase 3 (end of Q3 – Q4 2022)**

* Add fixed-rate loan system over existing markets
* Provide active liquidity management
* Add third-party protocol integrations to get DeFi strategies for the liquidity
* Implement automated operations
* Become a full-fledged DeFi 2.0 protocol in all aspects

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1643989821674-62411420266789
'''
'''--- product/borrow.md ---
# Borrow

## Borrow VS Withdraw

Withdrawing your assets means closing your position on that particular asset. However, if you are in a deposit but you need liquidity, withdrawing funds is not the only option. Instead of withdrawal, you can borrow assets against your deposited assets without losing your position.

You can get a loan on any asset, even the one you have deposited. This way, you won’t use your position and will be able to use necessary assets for the chosen strategy.

## How do I borrow?

1. To enable borrowing, you need to supply any asset to be used as collateral.&#x20;
2. Select the asset you are interested in and click on the **Borrow** button.&#x20;
3. In the **Borrow tab**, set the amount you’d like to borrow based on your available supplies that would be used as collateral for the loan.&#x20;
4. Submit your transaction and wait for confirmation.

## How does borrowing work?

![](../.gitbook/assets/borrow.png)

## **How much can I borrow?**

The maximum amount you can borrow depends on the value you have supplied and the available liquidity. In other words, you can’t borrow an asset if there is not enough liquidity or if your Health factor doesn’t allow you to.

## **What is the Health factor**?

Health factor indicates the safety of your deposited assets against the borrowed assets and their underlying value. It directly influences the amount you can still borrow on the platform or the amount you need to deposit to avoid liquidation.

Learn more about how the Health factor is computed in the corresponding part of the [**Liquidation**](liquidation.md) chapter.

***

## **When do I pay back the loan?**

There are no particular time limits to pay back the loan. As long as your position is safe and you haven’t reached the critical Health factor, you can borrow for an undefined period. However, please keep in mind that the accrued interest will grow with time, decreasing your Health factor, which may lead to the liquidation of your deposited assets.

***

## **What if my Health factor is getting low?**

Unfortunately, as your Health factor decreases, the risk of liquidation gets higher.

***

## **How can I avoid liquidation?**&#x20;

To avoid liquidation, you need to keep your Health factor high. For that, you should do the following:

* repay your loans
* deposit more assets to increase your liquidity

'''
'''--- product/interest_rate_model.md ---
---
description: Interest rate model in Nearlend is similar to Compound protocol.
---

# Interest rate model

## Exchange rate

$$
xrate = 
\begin{cases} 
     \text{if TotalSupply > 0,}\ \frac{MarketBalance + TotalBorrows - TotalReserves}{TotalSupply}\\ 
    \text{if TotalSupply = 0,}\ {InitialExchangeRate}\\ 
\end{cases}
\\
\text{where InitialExchangeRate = 1}\
$$

## The utilization rate

The interest rate in Nearlend is determined as a function of a metric known as the utilization rate. It signifies the percentage of money borrowed out of the total amount supplied.

The utilization rate is calculated with the following formula:

$$
U_a = \frac{Borrows_a}{(Cash_a + Borrows_a - Reserves_a)}\
$$

> * U\_a **** the utilization rate
> * Borrows\_a refers to the amount of a borrowed.
> * Cash\_a refers to the amount of a left in the system.
> * Reserves\_a refers to the amount of a that Nearlend keeps as profit.

A high ratio signifies that a lot of borrowing is taking place, so interest rates go up to get more people to inject cash into the system. A low ratio signifies that the demand for borrowing is low, so interest rates go down to encourage more people to borrow cash from the system. This follows economic theory's idea of price (the "price" of money is its interest rate) relative to supply and demand.

## Borrow & Supply rates

Borrow and supply rates are calculated using the utilization rate and several arbitrary constants.

The supply rate is calculated as follows:

$$
Supply Interest Rate_a = Borrowing Interest Rate_a * U_a * ( 1−Reserve Factor_a )\
$$

The borrow interest rate calculation is described in the following part.

## Standard Interest Rate Model

The borrowing rate calculation depends on something called an interest rate model – the algorithmic model to determine borrow and supply rates at the money market.

This standard interest rate model takes in two parameters:&#x20;

> * Base rate per year – the minimum borrowing rate;
> * Multiplier per year – the rate of increase in interest rate with respect to utilization.

$$
Borrow Interest Rate = Multiplier * Utilization Rate + Base Rate
$$

## The Jump Rate model

Some markets follow what is known as the "Jump Rate" model. This model has the standard parameters:

* Base rate per year - the minimum borrowing rate
* Multiplier per year - the rate of increase in interest rate with respect to utilization after the kink.

Yet, it also introduces two new parameters:

> * Kink, the point in the model in which the model follows the jump multiplier
> * Jump Multiplier per year, the rate of increase in interest rate with respect to utilization after the "kink"

The borrowing rate of the jump rate model is defined as follows:

$$
Borrow Interest Rate = Multiplier * min(U_a, Kink) + \\Jump Multiplier * max(0, U_a - Kink) +\\ Base Rate\
$$

## Example

| Parameter:        | Value |
| ----------------- | :---: |
| Supplies          |  200M |
| Borrows           |  180M |
| Cash              |  20M  |
| Base rate, annual |   0%  |
| Multiplier        |   5%  |
| Kink              |  80%  |
| Jump multiplier   |  109% |

Doing the math:

$$
U_a = \frac{$180M}{$180M+$20M} = 90\%
$$

$$
BorrowInterestRate = 5\% * 80\% + 109\% * ( 90\% − 80\% ) + 0\% = 14.9\%
$$

$$
SupplyInterestRate = 14.9\% * 90\% * (1-7\%)=12.5\%
$$

'''
'''--- product/liquidation.md ---
# Liquidation

## **What is liquidation?**

Liquidation is the process of terminating a borrower's account when their Health factor goes below 100%, and their collateral value does not fully cover their loan value. This might occur when the collateral decreases in value or the loan debt increases in value against each other. You can learn more about how the Health factor is calculated lower on the page, in the Health factor part.

## **How does liquidation work?**

![](../.gitbook/assets/liquidation.png)

## **Liquidation threshold**

The liquidation threshold is the percentage at which a position is defined as undercollateralized. For example, a liquidation threshold of 95% means that if the value rises above 95% of the collateral, the position is undercollateralized and could be liquidated.

## Liquidation Bonus

A liquidation bonus is a special reward that depends on the price of assets of the collateral. It is allocated when liquidators purchase it as part of the liquidation of a loan that has passed the liquidation threshold.

## Health factor

The Health factor is a numeric representation of the safety of your deposited assets against the borrowed assets and their underlying value. It is computed per account instead of per asset.

Each account may have multiple collateral asset supplies and may borrow multiple assets. Each market has a configuration value volatility ratio which indicates the expected price stability score. The higher the ratio, the higher expectation of the stability of the price of the corresponding asset.

$$
Collaterals_{affected} = \sum_{i=0}^{n}{Collaterals_i*Price_i* Volatility Ratio_i}\\ Borrows_{affected} = \sum_{i=0}^{n}{Borrows_i*Price_i* Volatility Ratio_i}\
$$

Now we can compute the Health factor:

$$
H_{fact}= \frac{Collaterals_{affected}}{Borrows_{affected}}\
$$

If the Health factor is higher than 100%, it means that the account is in good shape and can't be liquidated.

If the Health factor is less than 100%, it means the account can be partially liquidated and can't borrow more without repaying some amount of the existing loans or providing more collateral assets.

## Liquidation flow

Contract liquidations are designed to make liquidators compete for the profit that they make during liquidations to minimize the loss taken by the unhealthy accounts. Instead of the fixed profit that is used in the legacy products, this contract introduces a variable discount with variable liquidation size.

> Liquidations rules:
>
> * the initial Health factor of the liquidated accounts has to be below 100%
> * the discounted sum of the taken collateral should be less than the sum of repaid assets;
> * the final Health factor of the liquidated accounts has to stay below 100%.

A liquidation action consists of the following:

> * account\_id - the account ID that is being liquidated
> * in\_asset - the assets and corresponding amounts to repay form borrowed assets
> * out\_asset - the assets and corresponding amounts to take from collateral assets

The discount is computed based on the initial Health score of the liquidated account:

$$
Discount = \frac{(1 - H_{fact})}{2}\
$$

Now, we can compute the taken discounted collateral sum and the repaid borrowed sum:

$$
Taken\_sum = \sum_{i=0}^{n}{(out\_asset_i * price_i)} \\Discounted\_collateral\_sum = taken\_sum * (1 - discount) \\ Repaid\_sum =\sum_{i=0}^{n}{(in\_asset_i * price_i)}
$$

Once these calculations are done, we can compute the final values and verify the liquidation rules:

* health\_factor < 100% (to liquidate only unhealthy accounts);
* discounted\_collateral\_sum <= repaid\_sum (to prevent from taking more collateral than the repaid sum (after discount));
* new\_health\_factor < 100% (to prevent the liquidator from repaying too much of the borrowed assets).

'''
'''--- product/repay.md ---
# Repay

## **How can I repay the loan with my collateral/deposits?**

1. Open the main page of the app.&#x20;
2. Select the asset you’d like to repay and click on the **Borrow** button.&#x20;
3. In the pop-up window, go to the **Repay tab**, where you will find your loan information and accrued interest.&#x20;
4. Click on the **Repay** button at the bottom of the pop-up window and submit your transaction.

## How does **repayment** work?

![](../.gitbook/assets/repay.png)

'''
'''--- product/supply_withdraw.md ---
# Deposit & Earning

## How do I deposit

1. Connect your wallet by clicking on the Connect Wallet button on the main page of the application.&#x20;
2. Find an asset you’d like to supply and click the Supply button. Then, select the amount you wish to deposit in a pop-up window and submit your transaction.&#x20;
3. Once the transaction is confirmed, your deposit is successfully registered, and you start earning interest on the supplied amount.

## How do I earn?

Once your deposit is registered and supplied, you start getting rewards in dTokens.

All dTokens holders receive incentives that evolve with market conditions. You can learn more about incentivization and earning interest with Nearlend in the Interest Rate Model chapter.

## How does deposit work?

![](<../.gitbook/assets/deposit (1).png>)

## **Is there any minimum or maximum limit to deposit?**

You can deposit any amount you want, there are no limits. Still, it's important to keep in mind potential transaction fees that will directly influence your deposit amount and final earnings. We highly recommend you consider this when depositing low amounts since transaction fees might be higher than the expected earnings, and your deposit may lose its value.

***

## **How can I withdraw?**

You can withdraw deposited funds anytime.

1. Open the main page of the application.&#x20;
2. Select the asset you would like to withdraw and click the Supply button.&#x20;
3. In the pop-up window, go to the Withdraw tab and select the amount of dTokens you wish to withdraw.&#x20;
4. Submit the transaction and wait a few minutes for confirmation. Check your wallet as you receive the confirmation and find your assets.&#x20;
5. In case the transaction fails, try again or contact our team.

## How does withdrawal work?

![](../.gitbook/assets/withdraw.png)

## Can I use my assets as collateral?

After depositing your assets, you can use them as collateral in any way or combination. If you don't want to use a particular asset as collateral, you can disable this feature anytime.

'''
'''--- product/tokenomics.md ---
---
description: ...
---

# Tokenomics

## **Introduction**

The heart of the Nearlend ecosystem is dToken – the native utility token of the protocol. It will enable two key utility cases: incentivization and DAO governance.

## **Token utility**

dToken is used as an internal asset to get access to the full functionality of the Nearlend platform. This includes depositing and borrowing funds, withdrawing assets, repaying loans, etc.

#### dToken utility:&#x20;

* collateral;
* repayment method;&#x20;
* depositors incentivisation;&#x20;
* borrowers incentivization;&#x20;
* service roles incentivization;&#x20;
* DAO governance.

'''
'''--- redeploy_dev.sh ---
# login
# near login

# build & test
./build.sh && ./test.sh

# deploy markets
echo 'y' | near deploy weth_market.nearlend.testnet \
    --wasmFile ./contracts/target/wasm32-unknown-unknown/release/market.wasm
echo 'y' | near deploy wnear_market.nearlend.testnet \
    --wasmFile ./contracts/target/wasm32-unknown-unknown/release/market.wasm
echo 'y' | near deploy usdt_market.nearlend.testnet \
    --wasmFile ./contracts/target/wasm32-unknown-unknown/release/market.wasm
echo 'y' | near deploy usdc_market.nearlend.testnet \
    --wasmFile ./contracts/target/wasm32-unknown-unknown/release/market.wasm
# deploy controller
echo 'y' | near deploy controller.nearlend.testnet \
    --wasmFile ./contracts/target/wasm32-unknown-unknown/release/controller.wasm

near view controller.nearlend.testnet view_markets '{}' --accountId controller.nearlend.testnet
near view controller.nearlend.testnet view_prices '{ "dtokens": ["wnear_market.nearlend.testnet", "weth_market.nearlend.testnet", "usdt_market.nearlend.testnet", "usdc_market.nearlend.testnet"] }' --accountId controller.nearlend.testnet 

near view weth.nearlend.testnet ft_balance_of '{"account_id": "weth_market.nearlend.testnet"}'
near view wnear.nearlend.testnet ft_balance_of '{"account_id": "wnear_market.nearlend.testnet"}'
near view usdt.nearlend.testnet ft_balance_of '{"account_id": "usdt_market.nearlend.testnet"}'
near view usdc.nearlend.testnet ft_balance_of '{"account_id": "usdc_market.nearlend.testnet"}'
'''
'''--- scenarios.txt ---
WETH
supply
supply withdraw_max
supply withdraw withdraw_max
supply borrow_max withdraw_max

near call weth.nearlend.testnet ft_transfer_call '{"receiver_id": "weth_market.nearlend.testnet", "amount": "100000000000000000000000000", "msg": "\"Supply\""}' --depositYocto 1 --gas 300000000000000 --accountId nearlend.testnet

near view controller.nearlend.testnet get_entity_by_token '{"action": "Supply", "user_id": "nearlend.testnet", "token_address": "weth_market.nearlend.testnet"}'
near view weth_market.nearlend.testnet view_total_supplies

near view controller.nearlend.testnet get_entity_by_token '{"action": "Borrow", "user_id": "nearlend.testnet", "token_address": "weth_market.nearlend.testne
t"}'
near view weth_market.nearlend.testnet view_total_borrows

near view weth.nearlend.testnet ft_balance_of '{"account_id": "weth_market.nearlend.testnet"}'
near view weth_market.nearlend.testnet view_withdraw_info '{ "user_id": "nearlend.testnet", "ft_balance": "1100000196412178905446812000"}'
near view weth_market.nearlend.testnet view_repay_info '{"user_id": "nearlend.testnet", "ft_balance": "1050000000000000000000000000"}'

near view controller.nearlend.testnet view_borrow_max '{"user_id": "nearlend.testnet", "dtoken_id": "weth_market.nearlend.testnet"}'
near view controller.nearlend.testnet view_withdraw_max '{"user_id": "nearlend.testnet", "dtoken_id": "weth_market.nearlend.testnet"}'

near call weth.nearlend.testnet ft_transfer_call '{"receiver_id": "weth_market.nearlend.testnet", "amount": "51000000000000000000000000", "msg": "\"Repay\""}' --depositYocto 1 --gas 300000000000000 --accountId nearlend.testnet

near view weth_market.nearlend.testnet ft_balance_of '{"account_id": "nearlend.testnet"}'

near view weth_market.nearlend.testnet view_market_data '{"ft_balance": "1100000284540328315443305500"}'
'''
'''--- test.sh ---
#!/bin/bash
set -e

cargo test --manifest-path ./contracts/Cargo.toml -- --nocapture

'''