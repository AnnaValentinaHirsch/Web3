*GitHub Repository "gheja/js13k2022"*

'''--- .vscode/launch.json ---
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "chrome",
            "request": "launch",
            "name": "Launch Chrome against localhost",
            "url": "http://localhost:5500/src/",
            "webRoot": "${workspaceFolder}"
        }
    ]
}

'''
'''--- .vscode/settings.json ---
{
    "files.exclude": {
        "**/*.js": {
            "when": "$(basename).ts"
        },
        "**/*.js.map": {
        },
        "*.zip": {
        },
    }
}

'''
'''--- .vscode/tasks.json ---
{
    "version": "2.0.0",
    "tasks": [
        {
            "type": "typescript",
            "tsconfig": "tsconfig.json",
            "problemMatcher": [
                "$tsc"
            ],
            "group": "build",
            "label": "tsc: build - tsconfig.json"
        }
    ]
}

'''
'''--- README.md ---
![Cooking for Skully](preview_v1_400x250.jpg)

# Cooking for Skully

An entry for the [js13kgames](https://js13kgames.com/) [2022](http://2022.js13kgames.com/) gamejam for the theme "death".

Entry: https://js13kgames.com/entries/cooking-for-skully

Branch for the jam version: [js13k2022-entry](https://github.com/gheja/js13k2022/tree/js13k2022-entry)

The main branch contains some further developments.

# Details

The game is about the Devil who is asked by Skully (aka. Death) to cook
some meal for him.

The Devil is controlled by the player, they need to prepare dishes with
various ingredients and seasoning based on recipes then Skully judges
their performance by 5-star rating.

Goblin (finding a better name is still on the TODO list) tries to guide
the player and introduce them to new elements.

And also, there is Cerberus, the three headed pup who takes care of any
leftovers.

The game is created with HTML5 + TypeScript + CSS, GIMP for graphics.

The graphics is displayed using CSS3D, it also has Bonus features [...]

For the release I use a build.sh to merge all TypeScript sources and use
[typescript-closure-compiler](https://www.npmjs.com/package/typescript-closure-compiler)
to transpile the bundle to JavaScript (ECMAScript 5), which is then compressed by
[google-closure-compiler](https://www.npmjs.com/package/google-closure-compiler).
The output gets embedded into a minimized HTML file, alongside with
CSS and the images, then the hand-minimized server.js gets copied and
these two files are compressed into a single ZIP file, which then gets
recompressed by [advancecomp](https://github.com/amadvance/advancecomp)'s
AdvZIP to be able to squeeze a few more bytes (can shave off 4% compared
to the standard high compression ZIP).

# Screenshots

![Screenshot from Cooking for Skully](preview_gameplay1.png)

'''
'''--- TODO.md ---
# js13k2022

## notes
- If you mess up but have the ingredients you can try to cook it again. (skipping alreadyDone)

## general
- [x] optimize performance (auto-reduce effects if runing with low FPS)
- [x] set colors for dialog boxes based on speakers
- [x] find a name
- [x] handle ticks separately from frames (skip frames instead of slowing down)
- [ ] ~reduce running speed~
- [x] cooking individual ingredients
- [x] text progressbar for cooking
- [x] level loading
- [x] save/load progress
- [x] new game
- [x] recipes
- [x] feedback (â˜… = &starf;)
- [x] menu button
- [x] recipe text content caching
- [x] play area boundaries
- [x] add status - score display, recipe+stars, total points
- [x] common way to update the contents of recipe, description, status divs
- [x] head pats for Cerberos
- [ ] ~About page~
- [ ] add a highlight to action buttons before they are used
- [ ] Goblin should remind to attach the recipe

## sounds
- [x] steps x2
- [x] cooking
- [x] different sound for petting
- [/] ~dialog x3~
- [ ] ~level load~
- [ ] ~level win~
- [x] seasoning
- [x] steps sound should be quieter

## input
- [x] virtual gamepad for mobile

## ui
- [x] menu
- [x] welcome screen
- [x] level transition effect

## graphics
- [x] wall
- [x] cutting board
- [ ] ~firewood/place~

## extras/bonuses

### Coil
- [x] add notice

### NEAR
- [x] add login
- [x] tip?
- [x] "thank you" message for tip

### in game
- [x] infinite pans, pots
- [x] extended last 3 seconds

## server features

### stats
- [x] total meals started
- [x] total meals finished
- [ ] total time cooked
- [x] total pans and pots used
- [ ] total seasoning used
- [x] total stars collected
- [x] total pats for Cerberos

## content

### ingredients
- [x] fire fungi
- [x] some vegetables

### seasoning
- [x] black pepper
- [ ] ~garlic~
- [x] green chili
- [ ] ~red habanero~

## annoying bugs
- [x] "in front of you" checks the grabbed object and its children as well
- [ ] jagged/buggy edges of transformed divs (Chrome only)
- [x] "d" div has background color
- [ ] stats are off when in transit (see code)

## severe bugs

## breaking bugs

## optimizations
- [x] cache the sprites in getSprite()
- [x] rename css classes, ids, etc.
- [x] remove newlines from minimized html
- [x] use integers instead of strings for object types
- [x] remove css comments
- [x] AdvZIP
- [/] pack sprite sheet more densly
- [x] replace all unicode characters with html entities
- [ ] set Google Closure Compiler to use single quotes (already set?!)
- [x] remove unused dialogs
- [x] remove console.log() calls
- [x] trash icon in sprites is unused
- [x] reduce sprites.png palette
- [x] remove chute sprite
- [ ] remove additional delay handling in dialog
- [ ] remove quotes from some attributes (i.e. onclick)
- [ ] Google Closure Compiler does not rename ".position", ".name", ".description", ".status"

## nice to have
- [ ] some transition from the welcome screen
- [ ] Find a name for Goblin
- [x] green dialog box for Goblin
- [ ] Goblin should walk around
- [ ] proper move and slide
- [ ] GameObject is interactable?
- [ ] proper 3rd axis handling (z-height?)
- [x] stacking z-height handling
- [ ] sort the contents of dishes properly
- [ ] ~fix border around dialog profile picture~
- [x] better font
- [ ] progressbar for cooking
- [ ] disable text selection
- [x] recursive highlight so the meat also blinks
- [ ] better gamepad dead zone handling (i.e. https://www.smashingmagazine.com/2015/11/gamepad-api-in-web-games/#applying-a-dead-zone )
- [x] cursor always arrow
- [ ] blinky "Press Start"? :)
- [ ] _floorHeight, _floorWidth, _padX, _padY, _zoom -> const
- [ ] _names -> data
- [ ] separate shadows from objects?
- [ ] dynamic shirt, pants colors
- [x] rearrange description box, separate boxes for "in front of", "drop target", etc.
- [ ] easter egg for trying to leave the play area
- [ ] easter egg for cooking stuffs too long (turn into coal)

'''
'''--- build.sh ---
#!/bin/bash

name="js13k2022"
tmp=`readlink -f "$0"`
dir=`dirname $tmp`
source_dir="${dir}/src"
target_dir="/tmp/build"
extra_dir="/home/gheja/works_local/extra"
final_dir="${dir}"
min_dir="${dir}/tmp/min"
csv="${final_dir}/build_stats.csv"
advzip_iterations="3000"

if [ $TERM == "xterm" ] || [ $TERM == "screen" ]; then
	color_error='\033[1;31m'
	color_success='\033[1;32m'
	color_title='\033[1;38m'
	color_default='\033[0m'
else
	color_error=''
	color_success=''
	color_title=''
	color_default=''
fi

_title()
{
	echo ""
	echo -ne "${color_title}"
	echo "$@"
	echo -ne "${color_default}"
}

_error()
{
	echo -ne "${color_error}"
	echo "$@"
	echo -ne "${color_default}"
}

_success()
{
	echo -ne "${color_success}"
	echo "$@"
	echo -ne "${color_default}"
}

try()
{
	$@
	
	result=$?
	if [ $result != 0 ]; then
		_error "ERROR: \"$@\" failed with exit code $result."
		exit 1
	fi
}

function get_size()
{
	local files="$@"
	
	cat $files | wc -c | awk '{ print $1; }'
}

function get_lines()
{
	local files="$@"
	
	cat $files | wc -l | awk '{ print $1; }'
}

if [ -e "$target_dir" ]; then
	rm -r "$target_dir"
fi

mkdir "$target_dir"

cd "$target_dir"

### stage1 - compilation of typescript to javascript, minimization of javascript and css files

mkdir stage1
mkdir stage1/3rdparty
cd stage1

now=`date +%Y%m%d_%H%M%S`
now2=`date '+%Y-%m-%d %H:%M:%S'`
zip_prefix="${name}_${now}"

_title "Copying files to build directory..."

try rsync -xa --exclude '*.js' --exclude '*.js.map' --exclude '*.zip' "${source_dir}/" ./
try rsync -xa "${source_dir}/3rdparty/" ./3rdparty/
try rsync -xa "${source_dir}/bonus/" ./bonus/
try cp "${source_dir}/server/server.min.js" ./
try cp "${source_dir}/externs.js" ./
try cp "${source_dir}/exports.js" ./

zip -r9 ${zip_prefix}_original.zip .

if [ -d "${extra_dir}" ]; then
	try rsync -xa "${extra_dir}/" ./
fi

_title "Checking and installing node packages..."

echo "travis_fold:start:npm"

try npm install typescript-closure-compiler google-closure-compiler

echo "travis_fold:end:npm"

export PATH="${target_dir}/stage1/node_modules/.bin:${PATH}"

# note: near.js has a near.min.js version

files_html="index.html"
files_javascript=`cat index.html | grep -E '<script.* src="([^"]+)"' | grep -Eo 'src=\".*\"' | cut -d \" -f 2 | grep -vE '/socket.io|https:|bonus/near\.js' | grep -vE '^(3rdparty|bonus|https:)/'`
files_javascript_extra=`cat index.html | grep -E '<script.* src="([^"]+)"' | grep -Eo 'src=\".*\"' | cut -d \" -f 2 | grep -vE '/socket.io|https:|bonus/near\.js' | grep -E '^(3rdparty|bonus)/'`
files_typescript=`echo "$files_javascript" | sed -r 's/\.js$/.ts/g'`
files_css=`cat index.html | grep -E '<link type="text/css" rel="stylesheet" href="([^"]+)"' | grep -Eo 'href=\".*\"' | cut -d \" -f 2`

# cat ./src/$i | sed -e '/DEBUG BEGIN/,/\DEBUG END/{d}' | grep -vE '^\"use strict\";$' >> ./build/stage1/merged.js

lines_html=`get_lines $files_html`
lines_typescript=`get_lines $files_typescript`
lines_css=`get_lines $files_css`

size_html=`get_size $files_html`
size_typescript=`get_size $files_typescript`
size_css=`get_size $files_css`

_title "Compiling TypeScript to JavaScript..."

echo "travis_fold:start:tscc"

cat $files_typescript > merged.ts
sed -r -i 's/^(const IS_PROD_BUILD).*/\1 = true;/g' merged.ts
try tscc merged.ts

echo "travis_fold:end:tscc"

_title "Minimizing JavaScript using Google Closure Compiler - 1/2: pretty print..."

echo "travis_fold:start:closure-compiler-1"

try google-closure-compiler \
	--compilation_level ADVANCED \
	--warning_level VERBOSE \
	--language_in ECMASCRIPT_2018 \
	--language_out ECMASCRIPT_2018 \
	--formatting PRETTY_PRINT \
	--formatting SINGLE_QUOTES \
	--externs externs.js \
	--js_output_file min_pretty.js \
	$files_javascript_extra merged.js exports.js

echo "travis_fold:end:closure-compiler-1"

_title "Minimizing JavaScript using Google Closure Compiler - 2/2: whitespace removal..."

echo "travis_fold:start:closure-compiler-2"

try google-closure-compiler \
	--compilation_level WHITESPACE \
	--language_in ECMASCRIPT_2018 \
	--language_out ECMASCRIPT_2018 \
	--formatting SINGLE_QUOTES \
	--externs externs.js \
	--js_output_file min.js \
	min_pretty.js

# embed the near.min.js
mv min.js min.js.1
cat bonus/near.min.js min.js.1 > min.js

echo "travis_fold:end:closure-compiler-2"

_title "Minimizing CSS..."

cat $files_css | \
	sed -s 's,/\*.*\*/,,g' | \
	sed -r 's/^\s+//g' | \
	sed -r 's/\s+$//g' | \
	tr -d '\r\n' | \
	sed -r 's/}/}\n/g' | \
	sed -r 's/ *\{ */{/g' | \
	sed -r 's/; *}/}/g' | \
	sed -r 's/ *, */,/g' | \
	sed -r 's/ *: */:/g' \
	> min.css

cd ..

### stage2 - compiling the final html and creating zip files

mkdir stage2
cd stage2

cp ../stage1/min.css ../stage1/min.js ../stage1/index.min.html ../stage1/server.min.js ./

mv server.min.js server.js

_title "Embedding files into final HTML..."

cat index.min.html | sed \
	-e '/<!-- insert minified javascript here -->/{' \
	-e 'i <script>' \
	-e 'r min.js' \
	-e 'a </script>' \
	-e 'd}' \
	-e '/<!-- insert minified css here -->/{' \
	-e 'i <style>' \
	-e 'r min.css' \
	-e 'a </style>' \
	-e 'd}' \
	> index.html

_title "Creating ZIP files..."

try zip -9 ${zip_prefix}.zip index.html server.js

_title "Running advzip..."

try cp ${zip_prefix}.zip ${zip_prefix}_advzip.zip
try advzip -z -k -4 -i ${advzip_iterations} ${zip_prefix}_advzip.zip

size2_html=`get_size index.min.html`
size2_javascript=`get_size min.js`
size2_css=`get_size min.css`
size2_zip=`get_size ${zip_prefix}.zip`
size3_zip=`get_size ${zip_prefix}_advzip.zip`

cd ..

_title "Extracting ZIP file to test directory..."

### final steps

cp stage1/*.zip ./
cp stage2/*.zip ./

cp *.zip ${final_dir}/

if [ -e "${min_dir}" ]; then
	rm -r ${min_dir}
fi

mkdir -p "${min_dir}"

cd ${min_dir}

# cp ${final_dir}/${zip_prefix}_twemoji.zip ./
# unzip ${zip_prefix}_twemoji.zip

_title "Some stats"

cd "${target_dir}"

ls -alb stage2/ *.zip

echo ""
echo "HTML: ${lines_html} lines, ${size_html} -> ${size2_html} bytes"
echo "TypeScript: ${lines_typescript} lines, ${size_typescript} -> ${size2_javascript} bytes"
echo "CSS: ${lines_css} lines, ${size_css} -> ${size2_css} bytes"
echo "Total source: $((size_html + size_typescript + size_css)) -> ${size2_zip} -> ${size3_zip} bytes in final ZIP"

cd "${source_dir}"

git_hash=`git rev-parse HEAD 2>/dev/null`

if [ ! -e "$csv" ]; then
	echo "date_time;filename;git_hash;lines_html;size_html;size2_html;lines_typescript;size_typescript;size2_javascript;lines_css;size_css;size2_css;size2_zip;size3_zip" > $csv
fi

echo "${now2};${zip_prefix}.zip;${git_hash};${lines_html};${size_html};${size2_html};${lines_typescript};${size_typescript};${size2_javascript};${lines_css};${size_css};${size2_css};${size2_zip};${size3_zip}" >> $csv

final_limit=13312
percent=$((size3_zip * 100 / final_limit))

echo ""

if [ ${size3_zip} -gt ${final_limit} ]; then
	_error "Final ZIP is ${size3_zip} bytes, more than ${final_limit}!"
	
	exit 1
fi

_success "Final ZIP file is ${size3_zip} bytes of ${final_limit} (${percent}%)!"

exit 0

'''
'''--- embed_gfx.sh ---
#!/bin/bash

tmp=`readlink -f "$0"`
dir=`dirname $tmp`
source_dir="${dir}/src"

{
echo -n "const GFX_SPRITES = \"data:image/png;base64,"
cat "${source_dir}/graphics/sprites_optimized.png" | base64 --wrap 0
echo "\";"
# echo -n "const GFX_FLOOR = \"data:image/png;base64,"
# cat "${source_dir}/graphics/floor_optimized.png" | base64 --wrap 0
# echo "\";"
} > "${source_dir}/data_graphics.ts"

'''
'''--- experiments/coil.html ---
<html>
    <head>
        <title>Coil test</title>
        <meta name="monetization" content="$ilp.gatehub.net/770547877" />
        <script>
            let _coilActive;

            function coilInit()
            {
                _coilActive = (document.monetization && document.monetization.state);

                if (_coilActive)
                {
                    document.getElementById("coil-info").innerHTML = "Coil is active!";
                }
                else
                {
                    document.getElementById("coil-info").innerHTML = "Coil is not active.";
                }
            }

            window.addEventListener("load", coilInit);
        </script>
    </head>
    <body>
        <h1>Coil test</h1>

        <div id="coil-info">Loading...</div>

        <p>
            Based on the followings:
            <ul>
                <li><a href="https://webmonetization.org/docs/getting-started/">https://webmonetization.org/docs/getting-started/</a></li>
                <li><a href="https://help.coil.com/docs/monetize/wallets/gatehub/index.html">https://help.coil.com/docs/monetize/wallets/gatehub/index.html</a></li>
            </ul>
        </p>
    </body>
</html>

'''
'''--- experiments/near_login.html ---
<html>
    <head>
        <title>NEAR test - login only</title>
        <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
        <script>
            let _nearButton;

            function nearLogin()
            {
                _nearWallet['requestSignIn']();
            }

            function nearInit()
            {
                _nearButton = document.getElementById("near-button");

                window.nearApi
                .connect({
                    nodeUrl: 'https://rpc.testnet.near.org',
                    walletUrl: 'https://wallet.testnet.near.org',
                    helperUrl: 'https://helper.testnet.near.org',
                    explorerUrl: 'https://explorer.testnet.near.org',
                    networkId: 'testnet',
                    keyStore: new window.nearApi.keyStores.BrowserLocalStorageKeyStore(),
                })
                .then((near) => {
                    _nearWallet = new window.nearApi.WalletConnection(near);

                    if (_nearWallet['isSignedIn']()) {
                        _nearButton.innerHTML = "Logged in!";
                    } else {
                        _nearButton.innerHTML = "NEAR login";
                        _nearButton.addEventListener("click", nearLogin);
                    }
                });
            }

            window.addEventListener("load", nearInit);
        </script>
    </head>
    <body>
        <h1>NEAR test</h1>

        <button id="near-button">Loading...</button>

        <p>Based on the followings:
             <ul>
                <li><a href="https://docs.near.org/tools/near-api-js/faq">https://docs.near.org/tools/near-api-js/faq</a></li>
                <li><a href="https://docs.near.org/tools/near-api-js/quick-reference">https://docs.near.org/tools/near-api-js/quick-reference</li>
             </ul>
        </p>
    </body>
</html>
'''
'''--- experiments/near_send_money.html ---
<html>
    <head>
        <title>NEAR test - login and send money</title>
        <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
        <script>
            let _nearWallet;
            let _nearButton;

            function nearLogin()
            {
                _nearWallet['requestSignIn']();
            }

            function nearInit()
            {
                _nearButton = document.getElementById("near-button");

                window.nearApi
                .connect({
                    nodeUrl: 'https://rpc.testnet.near.org',
                    walletUrl: 'https://wallet.testnet.near.org',
                    helperUrl: 'https://helper.testnet.near.org',
                    explorerUrl: 'https://explorer.testnet.near.org',
                    networkId: 'testnet',
                    keyStore: new window.nearApi.keyStores.BrowserLocalStorageKeyStore(),
                })
                .then((near) => {
                    _nearWallet = new window.nearApi.WalletConnection(near);

                    if (_nearWallet['isSignedIn']()) {
                        _nearButton.innerHTML = "Logged in!";
                        _nearConnection = near.connection;
                    } else {
                        _nearButton.innerHTML = "NEAR login";
                        _nearButton.addEventListener("click", nearLogin);
                    }
                });
            }

            async function nearTip()
            {
                const account = await _nearWallet.account();
                await account.sendMoney(
                    "receiver-account.testnet", // receiver account
                    "250000000000000000000000" // amount in yoctoNEAR (~1.2 USD on Aug 11th 2022)
                );

                // window.location after a failed payment (i.e. declined, non-existent receiver):
                //  .../near_send_money.html?errorCode=userRejected&errorMessage=User%2520rejected%2520transaction
                //
                // window.location after a successful payment (does not strip query string!):
                //  .../near_send_money.html?transactionHashes=8AnSrE98vwUrUc2DAri7itSmkLah6GqPhkHJeXKjNZkV
                //  .../near_send_money.html?errorCode=userRejected&errorMessage=User%2520rejected%2520transaction&transactionHashes=4jtxv2M6dg8X3ooyHDMZr5jPfv7HNAqKDsUyuz7JSTk9
            }

            window.addEventListener("load", nearInit);
        </script>
    </head>
    <body>
        <h1>NEAR test</h1>

        <button id="near-button">Loading...</button>
        <button id="near-send" onClick="nearTip();">Send money</button>

        <p>Based on the followings:
             <ul>
                <li><a href="https://docs.near.org/tools/near-api-js/faq">https://docs.near.org/tools/near-api-js/faq</a></li>
                <li><a href="https://docs.near.org/tools/near-api-js/quick-reference">https://docs.near.org/tools/near-api-js/quick-reference</li>
             </ul>
        </p>
    </body>
</html>
'''
'''--- minimized_names.md ---
```
--- ids ---
d - div layer
r1 - recipe
r2 - description
r3 - status
f1 - bar1
f2 - bar2
s1 - speak1
s2 - speak2
o1 - overlay-bg
o2 - overlay
c - controls
a0 - button 0 (A) container
a1 - button 1 (B) container
a2 - button 2 (options) container
b0 - button 0 (A) text
b1 - button 1 (B) text
b2 - button 2 (options) text
e1 - title box
e2 - menu box
mn - near menu item
e3 - bonus box
wc - bonus status for coil
wn - bonus status for near
e4 - start box
l4 - floor

--- classes ---
s - speak
u - speak-visible
m - message
n - name
t - text
v - visible
w - level transition
b - box
c - box2
l - link

set on body:
w - welcome screen is active
ag - xbox controls visible
ah - playstation controls visible
ak - keyboard controls visible

more:
g g0 g1 - xbox buttons
h h0 h1 - playstation buttons
k - keyboard keys
c1 - label for slots
bl bt br bf - box left, top, right front

--- css keyframes ---
a2 - dust2
a3
a1 - l1

--- from css ---
#bar1
#bar2
.speak
.speak-visible
.message
.name
#speak1
#speak2
#speak2 .portrait
#speak2 .name
#recipe
#status
#description
#a0
#a1
#a2
#d
#l0
#l1
#l2
#l3
#floor
.o
.o div
.g
.h,
.k
body.ag .g
body.ah .h
body.ak .k
.g0
.g1
.h0
.h1
.box
.box2
.box2
.c1
.bl
.bt
.br
.bf
#recipe
#status
#overlay
#overlay-bg
#title
#menu
#start
#bonus
#title b
#menu
#menu li
#menu li:hover
#start
#bonus
body.w #overlay-bg
body.w #overlay
body.w #start
body.w #menu
.link
#gp
@keyframes dust2
@keyframes a3
@keyframes l1
```
'''
'''--- settings.json ---
{
    "liveServer.settings.port": 5500,
    "liveServer.settings.CustomBrowser" : "chrome",
    "liveServer.settings.AdvanceCustomBrowserCmdLine": "chrome --incognito --remote-debugging-port=9222",
    "liveServer.settings.NoBrowser" : false,
    "liveServer.settings.ignoreFiles" : [
            ".vscode/**",
            "**/*.scss",
            "**/*.sass"
    ]
}

'''
'''--- src/3rdparty/ZzFXMicro.min.js ---
// ZzFX - Zuper Zmall Zound Zynth - Micro Edition
// MIT License - Copyright 2019 Frank Force
// https://github.com/KilledByAPixel/ZzFX

// This is a tiny build of zzfx with only a zzfx function to play sounds.
// You can use zzfxV to set volume.
// Feel free to minify it further for your own needs!

'use strict';let zzfx,zzfxV,zzfxX

// ZzFXMicro - Zuper Zmall Zound Zynth - v1.1.8 ~ 884 bytes minified
zzfxV=.3    // volume
zzfx=       // play sound
(p=1,k=.05,b=220,e=0,r=0,t=.1,q=0,D=1,u=0,y=0,v=0,z=0,l=0,E=0,A=0,F=0,c=0,w=1,m=0,B=0)=>{let
M=Math,R=44100,d=2*M.PI,G=u*=500*d/R/R,C=b*=(1-k+2*k*M.random(k=[]))*d/R,g=0,H=0,a=0,n=1,I=0
,J=0,f=0,x,h;e=R*e+9;m*=R;r*=R;t*=R;c*=R;y*=500*d/R**3;A*=d/R;v*=d/R;z*=R;l=R*l|0;for(h=e+m+
r+t+c|0;a<h;k[a++]=f)++J%(100*F|0)||(f=q?1<q?2<q?3<q?M.sin((g%d)**3):M.max(M.min(M.tan(g),1)
,-1):1-(2*g/d%2+2)%2:1-4*M.abs(M.round(g/d)-g/d):M.sin(g),f=(l?1-B+B*M.sin(d*a/l):1)*(0<f?1:
-1)*M.abs(f)**D*p*zzfxV*(a<e?a/e:a<e+m?1-(a-e)/m*(1-w):a<e+m+r?w:a<h-c?(h-a-c)/t*w:0),f=c?f/
2+(c>a?0:(a<h-c?1:(h-a)/c)*k[a-c|0]/2):f),x=(b+=u+=y)*M.cos(A*H++),g+=x-x*E*(1-1E9*(M.sin(a)
+1)%2),n&&++n>z&&(b+=v,C+=v,n=0),!l||++I%l||(b=C,u=G,n=n||1);p=zzfxX.createBuffer(1,h,R);p.
getChannelData(0).set(k);b=zzfxX.createBufferSource();b.buffer=p;b.connect(zzfxX.destination
);b.start();return b};zzfxX=new (window.AudioContext) // audio context
'''
'''--- src/bonus/coil.js ---
function coilInit()
{
    _coilActive = (document.monetization && document.monetization.state);
}

'''
'''--- src/bonus/near.js ---
// 4bac6a20787a1ac17f03bc524e0c62a36df6bc147a3597b6beb34a5237a57cac

// <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
let _nearWallet;
let _nearNetName = "testnet";

function nearActive()
{
    return _nearWallet["isSignedIn"]();
}

function nearLogin()
{
    _nearWallet["requestSignIn"]();
}

function nearInit()
{
    window.nearApi
    .connect({
        nodeUrl: "https://rpc." + _nearNetName + ".near.org",
        walletUrl: "https://wallet." + _nearNetName + ".near.org",
        helperUrl: "https://helper." + _nearNetName + ".near.org",
        explorerUrl: "https://explorer." + _nearNetName + ".near.org",
        networkId: _nearNetName,
        keyStore: new window.nearApi.keyStores.BrowserLocalStorageKeyStore(),
    })
    .then((near) => {
        _nearWallet = new window.nearApi.WalletConnection(near);
    });
}

async function nearTip()
{
    const account = await _nearWallet.account();
    await account.sendMoney(
        "4bac6a20787a1ac17f03bc524e0c62a36df6bc147a3597b6beb34a5237a57cac",
        "250000000000000000000000"// about 1.5 USD
    );
}

let na = nearActive;
let nw = _nearWallet;
let nn = _nearNetName;
let nl = nearLogin;
let ni = nearInit;
let nt = nearTip;

'''
'''--- src/bonus/near.min.js ---
function na(){return nw.isSignedIn();}nw=0;nn="testnet";function nl(){nw.requestSignIn();}function ni(){window.nearApi.connect({nodeUrl:"https://rpc."+nn+".near.org",walletUrl:"https://wallet."+nn+".near.org",explorerUrl:"https://explorer."+nn+".near.org",networkId:nn,keyStore:new window.nearApi.keyStores.BrowserLocalStorageKeyStore()}).then((a)=>{nw=new window.nearApi.WalletConnection(a);});}async function nt(){const a=await nw.account();await a.sendMoney("4bac6a20787a1ac17f03bc524e0c62a36df6bc147a3597b6beb34a5237a57cac","250000000000000000000000");}
'''
'''--- src/consts.ts ---
const MAX_DROP_DISTANCE: number = 15;
const MAX_GRAB_DISTANCE: number = 15;
const IS_PROD_BUILD = false;

const RECIPE_STATUS_NEW = 1;
const RECIPE_STATUS_ACCEPTED = 2;
const RECIPE_STATUS_COOKING = 3;
const RECIPE_STATUS_DONE = 4;

const FIRST_LEVEL_NUMBER = 1;

const OBJ_UNDEFINED = 0;
const OBJ_MEAT = 1;
const OBJ_SHROOM = 2;
const OBJ_CARROT = 3;
const OBJ_PAN = 4;
const OBJ_POT = 5;
const OBJ_SEASONING = 6;

const OBJ_INGREDIENT_FIRST = 1;
const OBJ_INGREDIENT_LAST = 1;

const MESSAGE_RECORD = "b";
const MESSAGE_STATS = "d";

const STATS_LEVELS_STARTED = 0;
const STATS_LEVELS_FINISHED = 1;
const STATS_FIRES_STARTED = 2;
const STATS_FOODS_SERVED = 3;
const STATS_FOODS_STARTED = 4;
const STATS_STARS_COLLECTED = 5;
const STATS_PATS = 6;
const STATS_FOODS_PERFECT = 7;

const LOCALSTORAGE_PREFIX = "hg22:";

// minimum frames per second before attempting to remove effects
const PERF_MIN_FPS = 30;

'''
'''--- src/data.ts ---
const SOUND_STEP_1 = 0;
const SOUND_STEP_2 = 1;
const SOUND_FRYING = 2;
const SOUND_PICK_UP = 3;
const SOUND_DROP = 4;
const SOUND_BLIP = 5;
const SOUND_SPEAK_1 = 6;
const SOUND_SPEAK_2 = 7;
const SOUND_SEASONING = 8;
const SOUND_PET_1 = 9;
const SOUND_PET_2 = 10;

let _sounds = [
    [.2,0,392,.01,,.03,2,.8,,,,,,5,,,,.3], // SOUND_STEP_1
    [.2,0,440,.01,,.03,2,.8,,,,,,5,,,,.3], // SOUND_STEP_2
    [.3,0,,.5,,2,4,,,,550,,,3.6], // SOUND_FRYING
    [,,40,.02,.02,,,.4,3.2,,,,,.8,,,,.7,.02], // SOUND_PICK_UP
    [,0,170,.02,.02,,,.3,-4,,,,,,,,,.7,.03], // SOUND_DROP
    [.7,0,600,.01,,.07,1,,,,300,.03,,,,,,.9,.01], // SOUND_BLIP
    [,0,62,.01,.03,.05,3,,.2,1.5,,,,,2,,.12,.6], // SOUND_SPEAK_1
    [,0,128,.01,.03,.05,3,,.2,1.5,,,,,2,,.12,.6], // SOUND_SPEAK_2
    [.3,0,2e3,.01,,.04,4,,,,,,,3.6], // SOUND_SEASONING
    [.7,0,400,.01,,.07,1,,,,300,.03,,,,,,.9,.01], // SOUND_PET_1
    [.7,0,504,.01,,.07,1,,,,300,.03,,,,,,.9,.01], // SOUND_PET_2
];

'''
'''--- src/data_graphics.ts ---
const GFX_SPRITES = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAABQCAMAAAByFOZhAAAATlBMVEUAAAAAAABpICkYFBNmAAAiHBuSAADr6+vrJDbrsjbJNhYAAADh4eH+8qP5eD+Hwy1FyS6GhoYSWAAjqADLy8v75mI9AABiBwQ2MT//uwAyWWE3AAAAAnRSTlMAgJsrThgAAAI6SURBVFjD7dbRctowEIVhVxKQokoQHBx4/xftntWuhISM68x0kgv/Nul2mm9WOEzb4UfmHL9eZpovSge3d3TT8MIG035hC0w5TCsxdu457H+BgzGBncT4Dnzf45f7C/zGmcdpmkiW3DQN1AV3i7GtwWqnSTRsuNDd4vhGd4UdC+eA0ww8Uglba3vHDgmjwQE6jvFtHG+MbQgh6xAgWBtMUqJp5s2Hw1hhNTqZbPXwGBI+jOMBGLpYqrNZMY4vi2W1PR6PtvOe4YtlnTGODQwr2lhYazDB2oKJy+c7PS+ytxrrscvUYD569aOyp9PJlqcEolOLyQq+XBTbjK2hu0wthk3nvtBdsGjczQTMia0/25aura2tra31+bXgFyWjMWal9RR0wSa3bEWXYxsr1ThWQ2wwVs7jGOIQIoZr4N8tYnwTXiDXSC9MNMRwncNGrAG5Cok80ASNsfvAqv80Rm4oUx7Lj+rn9Bs10wnxdEY8HRFPDqlAPHm6MJ1SbD1dZ9iUWmgljJFgTxdjJNjT1WKk2GOqNnv0tNk7P489Ud9iGjqbfefYXo8N+4S9Z/z1p/0fes8dtI9FZLlh+KOtwFYCpq1dfH5SMVa4v1mfXmvlISqef8/0jT28vBmWerKowu997BSbFM+fn8vvWRaLtEhwpYd5rJ8q1rJZV2sFf+Rgh1w69UI7yu6QzT3+ee9fm9DBO6nGgSuY/67+Z4y9glXHtZt72dwcxt4ZvNNmMfoyxlv+ls1SF9vnHvBf+fUz0p/8oHsAAAAASUVORK5CYII=";

'''
'''--- src/dialog.ts ---
let _names = [ "Devil", "Skully", "phone", "Goblin" ];
let _dialog;
let _dialogIndex;
let _dialogTimeout;

function dialogShowLine(obj, line)
{
	let name = obj.getElementsByClassName("n")[0]; // name
	let text = obj.getElementsByClassName("t")[0]; // text

	removeClass(obj, "actor0");
	removeClass(obj, "actor1");
	removeClass(obj, "actor2");
	removeClass(obj, "actor3");
	addClass(obj, "u"); // speak-visible
	addClass(obj, "actor" + line[0]); // speak-visible
	
	name.innerHTML = _names[line[0]];
	text.innerHTML = line[2];

	if (line[1] == 1)
	{
		// lower dialog box
		playSound(SOUND_SPEAK_1);
	}
	else
	{
		// upper dialog box
		playSound(SOUND_SPEAK_2);
	}
	
	_input.registerAction(0, "Continue", dialogStep.bind(null));
}

function dialogEnd()
{
	if (_dialogTimeout)
	{
		window.clearTimeout(_dialogTimeout);
	}
	
	removeClass(getDomElement("s1"), "u"); // speak1, speak-visible
	removeClass(getDomElement("s2"), "u"); // speak2, speak-visible
	removeClass(getDomElement("f1"), "v"); // bar1, visible
	removeClass(getDomElement("f2"), "v"); // bar2, visible

	_input.deregisterAction(0);
	_input.deregisterAction(1);
	_input.registerAction(2, "Pause", _game.onPauseClick.bind(_game));

	_game.setPause(false);
	if (_game.onDialogEnd)
	{
		_game.onDialogEnd.call();
	}
}

function dialogStep()
{
	_input.deregisterAction(0);

	if (_dialogIndex >= _dialog.length)
	{
		dialogEnd();
		return;
	}
	
	let line = _dialog[_dialogIndex];
	let obj = getDomElement("s" + line[1]); // speak1/speak2
	let delay = line[3];
	
	removeClass(obj, "u"); // speak-visible
	_dialogTimeout = window.setTimeout(dialogShowLine.bind(this, obj, line), delay ? 1200 : 200);
	
	_dialogIndex++;
}

function dialogStart(dialog)
{
	_dialog = dialog;
	_dialogIndex = 0;
	_game.setPause(true, false);
	_input.deregisterAction(2);

	addClass(getDomElement("f1"), "v"); // visible
	addClass(getDomElement("f2"), "v"); // visible

	dialogStep();
}

'''
'''--- src/exports.js ---
// NOT part of the Visual Studio Code build process (excluded in tsconfig.json)

// These functions and variables won't be renamed by Google Closure Compiler
// so they can be accessed from HTML.

window['b'] = b;
window['na'] = na;
'''
'''--- src/external.d.ts ---
// These classes, functions and variables are not part of the code but are
// included in external libraries, imports or are added to the final bundle
// by the build.sh build process.
//
// This makes sure VS Code knows about them and they can be used in the
// project.
//
// https://stackoverflow.com/a/13087849 - thanks!

interface dummyFunction { (): any; }
interface zzfxFunction { (...parameters): any; }

declare var coilInit: dummyFunction;

declare var na: dummyFunction; // nearActive
declare var ni: dummyFunction; // nearInit
declare var nl: dummyFunction; // nearLogin
declare var nt: dummyFunction; // nearTip
declare var nn: string; // _nearNetName

declare var io: dummyFunction; // socket.io

declare var zzfx: zzfxFunction;

'''
'''--- src/externs.js ---
// NOT part of the Visual Studio Code build process (excluded in tsconfig.json)

// These classes, functions and variables are not part of the code but are
// included in external libraries or imports. This prevents Google Closure
// Compiler from renaming them.

let io = {};
io.connect = function(a){};
io.connect.on = function(a, b){};
io.connect.emit = function(a, b){};
io.listen = function(a){};
io.sockets = {};
io.sockets.socket = {};

/*
// I don't have time to properly do this, creating a hand minimized version instead...

window.nearApi = {};
window.nearApi.connect = function(a){};
window.nearApi.connect.then = function(a){};
window.nearApi.keyStores = {};
window.nearApi.keyStores.BrowserLocalStorageKeyStore = function();
window.nearApi.WalletConnection = function();
*/

document.monetization = {};
document.monetization.state = false;

let na = function(){}; // _nearActive
let nw = 1; // _nearWallet
let nn = ""; // _nearNetName
let nl = function(){}; // nearLogin()
let ni = function(){}; // nearInit()
let nt = function(){}; // nearTip()

let localStorage = {};
localStorage.setItem = function(a, b){};
localStorage.getItem = function(a){};

'''
'''--- src/game.ts ---
class Game
{
	ticks: number;
	frames: number;
	lastFrameTime: number;
	maxSpeed: number = 100;
	playerObject: GameObjectPlayer;
	paused: boolean = false;
	objects: Array<GameObject>;
	grabbedObject: GameObject;
	dialogOnStart: Array<any> = null;
	onDialogEnd: any = null;
	nearestGrabTarget: GameObject;
	nearestDropTarget: GameObject;
	nearestObject: GameObject;
	lastLevelNumber: number;
	recipeToCook: GameObjectRecipe;
	welcomePaused: boolean = false;
	levelFinished: boolean;
	pats: number = 0;
	perfLastFrames: number = 0;
	perfLevel: number = 3;
	perfCheckFails: number = 0;

	constructor()
	{
		this.frames = 0;
		this.ticks = 0;
		this.lastFrameTime = performance.now();
	}

	loadLevel(n: number)
	{
		let stock: Array<number> = [];
		let recipes: Array<any> = [];

		// end the transition effect
		getDomElement("f1").classList.remove("w");
		getDomElement("f2").classList.remove("w");

		this.lastLevelNumber = n;
		if (n > 1)
		{
			saveLevelNumber(n);
		}

		// TODO: optimize?

		// #l0 - layer 0 - transform base
		// #l1 - layer 1 - lava
		// #l2 - layer 2 - rocks
		// #l3 - layer 3 - fog
		_divLayer.innerHTML = "<div id=\"l0\">" + (this.perfLevel > 2 ? "<div id=\"l1\"></div>" : "") + (this.perfLevel > 1 ? "<div id=\"l2\"></div>" : "") + "<div id=\"l3\"></div>" + (n > 1 ? "<div id=\"l4\"></div>" : "") + "</div>";
		this.objects = [];
		this.grabbedObject = null;
		this.dialogOnStart = null;
		this.onDialogEnd = null;
		this.paused = false;
		this.levelFinished = false;

		_input.deregisterAction(0);
		_input.deregisterAction(1);
		_input.deregisterAction(2);

		_input.registerAction(2, "Pause", _game.onPauseClick.bind(_game));

		this.objects.push(new GameObjectPlayer(new Vec2D(170, 100)));

		if (n > 1)
		{
			this.objects.push(new GameObjectDeputy(new Vec2D(170, 50)));

			this.objects.push(new GameObjectWall(new Vec2D(0, 0), 14, 1, 2));
			this.objects.push(new GameObjectWall(new Vec2D(140, 0), 3, 1, 1));
			this.objects.push(new GameObjectWall(new Vec2D(170, 0), 3, 1, 2));
			this.objects.push(new GameObjectWall(new Vec2D(0, 120), 20, 1, 1));
			this.objects.push(new GameObjectWall(new Vec2D(0, 110)));
			this.objects.push(new GameObjectWall(new Vec2D(190, 110)));

			this.objects.push(new GameObjectSlot(new Vec2D(90, 80)));
			this.objects.push(new GameObjectSlot(new Vec2D(110, 80)));
			this.objects.push(new GameObjectSlot(new Vec2D(130, 80)));
			this.objects.push(new GameObjectSlot(new Vec2D(110, 100)));

			// ingredients, seasoning, etc.
			this.objects.push(new GameObjectCountertop(new Vec2D(10, 10), 11, 1, 1));

			this.objects.push(new GameObjectCountertop(new Vec2D(140, 10), 3, 1, 1));
			this.objects.push(new GameObjectSlotChute(new Vec2D(150, 10)));

			this.objects.push(new GameObjectCountertop(new Vec2D(80, 80), 7, 1, 1));
			this.objects.push(new GameObjectCountertop(new Vec2D(110, 90)));
			this.objects.push(new GameObjectCountertop(new Vec2D(110, 100)));
			this.objects.push(new GameObjectCountertop(new Vec2D(110, 110)));
		}

		if (n > 2)
		{
			// hello, Cerberos
			this.objects.push(new GameObjectSlotTrash(new Vec2D(180, 10)));
		}

		if (n > 3)
		{
			this.objects.push(new GameObjectSlot(new Vec2D(110, 10)));
			this.objects.push(new GameObjectSeasoning(new Vec2D(110, 10)));
			this.objects[this.objects.length - 2].catch(this.objects[this.objects.length - 1]);
		}

		this.playerObject = (this.objects[0] as GameObjectPlayer);

		switch (n)
		{
			// a dummy level for the welcome screen
			case 0:
			break;

			case 1:
				this.dialogOnStart = [
					[ 0, 2, "Ahh... what a wonderful day!" ],
					[ 0, 2, "The temperature is sweet, the weather is just perfect...", 1 ],
					[ 0, 2, "A really wonderful day!", 1 ],
					[ 0, 2, "*sigh* I am bored.", 1 ],
					[ 2, 2, "*ring-ring*", 1 ],
					[ 0, 2, "Hello, Devil speaking!" ],
					[ 1, 1, "Hey Dev, this is Skully!" ],
					[ 0, 2, "Death, what a nice surprise! How's it going?" ],
					[ 1, 1, "Great, great. Listen. By any chance..." ],
					[ 1, 1, "Is that restaurant of yours still around?" ],
					[ 0, 2, "Yeah, it is. But--" ],
					[ 1, 1, "Great! So I'll have a party tonight with friends and we want to have something delicious and thought you could help us out!" ],
					[ 0, 2, "Sure, but--" ],
					[ 1, 1, "Thanks, I'll send some meat over, you're the best!" ],
					[ 2, 1, "*click*" ],
					[ 0, 2, "I better get going...", 1 ],
				];
				this.onDialogEnd = this.loadNextLevelDelayed.bind(this);
			break;

			case 2:
				// meat, shroom, carrot, pan, pot
				stock = [ 0, 2, 0, 0, 3 ];
				recipes = [
					[ "Fried foe", OBJ_PAN, [ 0, 1 ], [ 0, 0 ] ]
				];

				this.dialogOnStart = [
					[ 3, 1, "Hey Boss!" ],
					[ 3, 1, "It's been a while. How do you do?" ],
					[ 0, 2, "Hey Goblin! All fine, thanks. I need to cook for Skully, do we have pans around?" ],
					[ 3, 1, "Sure we have! Just pick the recipe first." ],
					[ 3, 1, "And don't worry they still love to be cooked." ],
					[ 3, 1, "Just don't burn them....", 1 ],
				];
			break;

			case 3:
				// meat, shroom, carrot, pan, pot
				stock = [ 0, 4, 0, 0, 3 ];
				recipes = [
					[ "Fried foe", OBJ_PAN, [ 0, 1 ], [ 0, 0 ] ],
					[ "Fried foe", OBJ_PAN, [ 0, 1 ], [ 0, 0 ] ]
				];

				this.dialogOnStart = [
					[ 3, 1, "Hey Boss!" ],
					[ 3, 1, "Look who came by! Your favorite three-in-one pup, Cerberos!" ],
					[ 3, 1, "I guess he can help you out with leftovers." ],
					[ 3, 1, "Also, Skully asked for two more." ],
				];
			break;

			case 4:
				// meat, shroom, carrot, pan, pot
				stock = [ 0, 4, 0, 0, 3 ];
				recipes = [
					[ "Spicy fried friends", OBJ_PAN, [ 0, 2 ], [ 10, 0 ] ],
				];

				this.dialogOnStart = [
					[ 3, 1, "Hey Boss!" ],
					[ 3, 1, "I just found some spices." ],
				];
			break;

			case 5:
				// meat, shroom, carrot, pan, pot
				stock = [ 0, 2, 0, 4, 3 ];
				recipes = [
					[ "Fred and vegs", OBJ_PAN, [ 0, 1, 0, 2 ], [ 0, 5 ] ],
				];

				this.dialogOnStart = [
					[ 3, 1, "Hey Boss!" ],
					[ 3, 1, "I found some stuff in the fridge.<br/>Might come handy." ],
				];
			break;

			case 6:
				// meat, shroom, carrot, pan, pot
				stock = [ 0, 2, 0, 3, 3, 3 ];
				recipes = [
					[ "Carrot soup", OBJ_POT, [ 0, 0, 0, 3 ], [ 0, 5 ] ],
					[ "Fried foe",   OBJ_PAN, [ 0, 1       ], [ 0, 0 ] ]
				];

				this.dialogOnStart = [
					[ 3, 1, "Hey Boss!" ],
					[ 3, 1, "Look! Pots!" ],
				];
			break;

			case 7:
				// meat, shroom, carrot, pan, pot
				stock = [ 0, 1, 3, 3, 3, 3 ];
				recipes = [
					[ "Super soupper", OBJ_POT, [ 0, 0, 2, 2 ], [ 5, 15 ] ],
					[ "Fried foe",     OBJ_PAN, [ 0, 1       ], [ 0,  0 ] ]
				];

				this.dialogOnStart = [
					[ 3, 1, "Hey Boss!" ],
					[ 3, 1, "Another dinner for two?" ],
					[ 3, 1, "Erm... not for us. Of course.", 1 ],
				];
			break;

			case 8:
				// meat, shroom, carrot, pan, pot
				stock = [ 0, 4, 3, 3, 3, 3 ];
				recipes = [
					[ "Fred and vegs",       OBJ_PAN, [ 0, 1, 0, 2 ], [ 0,  5 ] ],
					[ "Spicy fried friends", OBJ_PAN, [ 0, 2       ], [ 10, 0 ] ],
					[ "All in!",             OBJ_POT, [ 0, 1, 1, 1 ], [ 10, 5 ] ],
				];

				this.dialogOnStart = [
					[ 3, 1, "Hey Boss!" ],
					[ 3, 1, "Skully called and..." ],
				];
			break;

			case 9:
				// meat, shroom, carrot, pan, pot
				stock = [ 0, 4, 3, 3, 3, 3 ];
				this.dialogOnStart = [
					[ 3, 1, "Hey Boss!" ],
					[ 3, 1, "No orders for today, but--" ],
					[ 0, 2, "Say no more! I take the week off!" ],
				];
				this.onDialogEnd = this.finishGame.bind(this);
			break;
		
			default:
				_exception("invalid level");
			break;
		}

		let i;

		for (i=0; i<6; i++)
		{
			if (stock[i])
			{
				this.objects.push(new GameObjectSlot(new Vec2D(10 + (i-1) * 20, 10)));
				(this.objects[this.objects.length - 1] as GameObjectSlot).setSpawn(i, stock[i]);
			}
		}

		for (i=0;i<recipes.length;i++)
		{
			this.objects.push(new GameObjectRecipe(new Vec2D(20, 80 - i * 10), recipes[i][0], recipes[i][1], recipes[i][2], recipes[i][3]));
		}

		if (this.dialogOnStart)
		{
			window.setTimeout(dialogStart.bind(null, this.dialogOnStart), 1000);
		}

		if (n >= FIRST_LEVEL_NUMBER)
		{
			statsIncrease(STATS_LEVELS_STARTED, 1);
		}
	}

	checkAndFixPerformance()
	{
		let fps: number;
		let b: HTMLElement;

		fps = this.frames - this.perfLastFrames;

		if (fps < PERF_MIN_FPS)
		{
			this.perfCheckFails++;
		}

		if (this.perfCheckFails > 3)
		{
			// reduce performance if we can
			this.perfLevel--;
			this.perfCheckFails = 0;

			console.log("Performance is too low (~" + fps + " FPS), trying to remove elements to increase it.");

			if (this.perfLevel == 2)
			{
				b = getDomElement("l1");

				if (b)
				{
					removeDomElement(b);
				}
			}

			if (this.perfLevel == 1)
			{
				b = getDomElement("l2");

				if (b)
				{
					removeDomElement(b);
				}
			}
			
		}

		this.perfLastFrames = this.frames;
	}

	finishGame()
	{
		getDomElement("f1").classList.add("w");
		getDomElement("f2").classList.add("w");
		window.setTimeout(this.setPause.bind(this, true, true), 1500);
	}

	loadNextLevel()
	{
		getDomElement("f1").classList.add("w");
		getDomElement("f2").classList.add("w");
		window.setTimeout(this.loadLevel.bind(this, this.lastLevelNumber + 1), 500);
	}

	loadNextLevelDelayed()
	{
		window.setTimeout(this.loadNextLevel.bind(this), 300);
	}

	handleInput()
	{
		let a = _input.getSpeedAndDirection();
		_input.handleActions();
		_input.clearPressedKeys();

		this.playerObject.velocity.x = lerp(this.playerObject.velocity.x, Math.cos(a.direction) * a.speed * this.maxSpeed, 0.3);
		this.playerObject.velocity.y = lerp(this.playerObject.velocity.y, Math.sin(a.direction) * a.speed * this.maxSpeed, 0.3);

		if (_input.xboxGamepadUsedTick > _input.keyboardUsedTick && _input.xboxGamepadUsedTick > _input.psGamepadUsedTick)
		{
			document.body.classList.remove('ah');
			document.body.classList.add('ag');
			document.body.classList.remove('ak');
		}
		else if (_input.psGamepadUsedTick > _input.keyboardUsedTick && _input.psGamepadUsedTick > _input.xboxGamepadUsedTick)
		{
			document.body.classList.add('ah');
			document.body.classList.remove('ag');
			document.body.classList.remove('ak');
		}
		else if (_input.keyboardUsedTick > _input.psGamepadUsedTick && _input.keyboardUsedTick > _input.xboxGamepadUsedTick)
		{
			document.body.classList.remove('ah');
			document.body.classList.remove('ag');
			document.body.classList.add('ak');
		}
	}

	destroyObjectRecursively(obj: GameObject)
	{
		obj.childObjects.forEach((element: GameObject) => {
			this.destroyObjectRecursively(element);
		});

		obj.onDestroy();
		obj.destroyed = true;
	}

	cleanupDestroyedObjects()
	{
		let i;

		for (i=this.objects.length; i--; i >= 0)
		{
			if (this.objects[i].destroyed)
			{
				removeDomElement(this.objects[i].domObject);
				this.objects.splice(i, 1);
			}
		}
	}

	updateDescription()
	{
		let description: string = "";
		

		// -- description

		if (this.grabbedObject)
		{
			description += "Carrying:<br/>";
			description += "<div class=\"b\">";
			description += this.grabbedObject.getDescription();
			description += "</div>";
		}

		// TODO: optimize this
		if (this.nearestDropTarget)
		{
			description += "Drop target:";
			description += "<div class=\"b\">";
			if (this.nearestDropTarget.childObjects.length != 0)
			{
				description += this.nearestDropTarget.childObjects[0].getDescription();
			}
			else
			{
				description += this.nearestDropTarget.getDescription();
			}
			description += "</div>";
		}
		else if (this.nearestGrabTarget)
		{
			description += "In front of you:";
			description += "<div class=\"b\">";
			if (this.nearestGrabTarget.childObjects.length != 0)
			{
				description += this.nearestGrabTarget.childObjects[0].getDescription();
			}
			else
			{
				description += this.nearestGrabTarget.getDescription();
			}
			description += "</div>";
		}
		else if (this.nearestObject)
		{
			description += "In front of you:";
			description += "<div class=\"b\">";
			description += this.nearestObject.getDescription();
			description += "</div>";
		}

		// -- recipe

		let a: GameObjectRecipe = null;
		let b: string = "";

		if (this.grabbedObject instanceof GameObjectContainer && (this.grabbedObject as GameObjectContainer).recipe)
		{
			a = (this.grabbedObject as GameObjectContainer).recipe;
		}
		else if (this.nearestGrabTarget && this.nearestGrabTarget.childObjects.length != 0 && (this.nearestGrabTarget.childObjects[0] instanceof GameObjectContainer) && (this.nearestGrabTarget.childObjects[0] as GameObjectContainer).recipe)
		{
			a = (this.nearestGrabTarget.childObjects[0] as GameObjectContainer).recipe;
		}
		else if (this.nearestDropTarget && this.nearestDropTarget.childObjects.length != 0 && (this.nearestDropTarget.childObjects[0] instanceof GameObjectContainer) && (this.nearestDropTarget.childObjects[0] as GameObjectContainer).recipe)
		{
			a = (this.nearestDropTarget.childObjects[0] as GameObjectContainer).recipe;
		}
		else if (this.recipeToCook)
		{
			a = this.recipeToCook;
			description += "<div class=\"c\">";
			description += "Pick up a pan or pot to start the recipe.";
			description += "</div>";
		}

		if (a)
		{
			b = a.getDescription();
		}

		
		// -- status

		let status: string = "";
		let starsMax: number = 0;
		let starsLeft: number;
		let starsCollected: number = 0;

		this.objects.forEach(element => {
			if (element instanceof GameObjectRecipe)
			{
				status += "<b>" + element.name + "</b><br/>";

				starsMax += 5;

				if (element.stars)
				{
					starsCollected += element.stars;
					status += element.stars + "/5<br/>";
				}
				else
				{
					status += "(new)<br/>";
				}
			}
		});

		starsLeft = Math.max(starsMax / 5 * 4 - starsCollected, 0);

		status += "<br/>";
		status += "<b>" + starsCollected + " stars collected</b> of " + starsMax + ".<br/>";
		status += "You need " + starsLeft + " more to finish.";

		if (_statsIo['connected'])
		{
			status += "<br/>";
			status += "<br/>";
			status += "<b>Global stats:</b><br/>";
			status += statsLine("Foods served", STATS_FOODS_SERVED);
			status += statsLine("Fires started", STATS_FIRES_STARTED);
			status += statsLine("Stars collected", STATS_STARS_COLLECTED);
			status += statsLine("Perfect foods", STATS_FOODS_PERFECT);
			status += statsLine("Total pats", STATS_PATS);
		}

		let newLevelFinished: boolean = (this.lastLevelNumber > 1 && this.lastLevelNumber != 9 && starsLeft <= 0);

		if (!this.levelFinished && newLevelFinished)
		{
			// just finished the level
			window.setTimeout(dialogStart.bind(null, [[ 3, 1, (this.lastLevelNumber == 2 ? "Wow! " : "") + "You completed all orders!<br/>Check your action buttons to proceed to the next level." ]]), 1000);
			statsIncrease(STATS_LEVELS_FINISHED, 1);
		}

		this.levelFinished = newLevelFinished;

		setInnerHTML("r1", b);
		setInnerHTML("r2", description);
		setInnerHTML("r3", status);
	}

	updateGrabDropTargets()
	{
		let a: GameObject;
		let b: number;
		let grabSlot: GameObject;
		let grabDistanceMin: number = 9999;
		let dropSlot: GameObject;
		let dropDistanceMin: number = 9999;
		let obj: GameObject;
		let objDistanceMin: number = 9999;
		let canDropHere: boolean;

		for (a of this.objects)
		{
			a.highlighted = false;

			if (a.canCatch)
			{
				b = dist2d(a.position, this.playerObject.position);
				canDropHere = true;
				
				if (this.grabbedObject)
				{
					if (a.childObjects.length != 0)
					{
						canDropHere = false;
						
						if (a.childObjects[0] instanceof GameObjectContainer && (this.grabbedObject instanceof GameObjectIngredient || (this.grabbedObject && this.grabbedObject instanceof GameObjectSeasoning)))
						{
							canDropHere = true;
						}
					}
				}

				if (a.childObjects.length != 0 && !this.grabbedObject)
				{
					if (b < grabDistanceMin)
					{
						grabDistanceMin = b;
						grabSlot = a;
					}
				}
				else
				{
					if (canDropHere && b < dropDistanceMin)
					{
						dropDistanceMin = b;
						dropSlot = a;
					}
				}
			}
			else if (a instanceof GameObject && !(a instanceof GameObjectPlayer || a instanceof GameObjectSlot || a instanceof GameObjectWall))
			{
				b = dist2d(a.position, this.playerObject.position);
				
				if (b < objDistanceMin)
				{
					objDistanceMin = b;
					obj = a;
				}
			}
		}

		this.nearestGrabTarget = null;
		this.nearestDropTarget = null;
		this.nearestObject = null;

		// TODO: only highlight when interactable

		if (objDistanceMin <= MAX_GRAB_DISTANCE && !obj.getIsGrabbed())
		{
			this.nearestObject = obj;
			this.nearestObject.highlighted = true;
		}

		if (grabDistanceMin <= MAX_GRAB_DISTANCE)
		{
			this.nearestGrabTarget = grabSlot;
			this.nearestGrabTarget.highlighted = true;
			if (this.nearestGrabTarget.childObjects.length != 0)
			{
				this.nearestGrabTarget.childObjects[0].highlighted = true;
			}
		}

		if (dropDistanceMin <= MAX_DROP_DISTANCE)
		{
			this.nearestDropTarget = dropSlot;
			this.nearestDropTarget.highlighted = true;
			if (this.nearestDropTarget.childObjects.length != 0)
			{
				this.nearestDropTarget.childObjects[0].highlighted = true;
			}
		}
	}

	onFrame()
	{
		let delta = 1000/60;

		let now = performance.now();

		this.frames++;

		this.handleInput();

		if (!this.paused && !this.welcomePaused)
		{
			let scale = (window.innerHeight / 1080) * 1.2;

			while (this.lastFrameTime < now)
			{
				this.ticks += 1;
				this.objects.forEach((element) => { element.update(); element.moveAndSlide(delta); element.updateChildObjectsPosition(); });
				this.lastFrameTime += delta;
			}

			// TODO: check this alignment
			_divLayer.style.transform = "scale(" + scale + ") perspective(800px) translateY(200px)";
			_divLayer.style.left = (window.innerWidth / 2 - _z(_floorWidth) / 2) + "px";
			_divLayer.style.transformOrigin = (_floorWidth * 0.5 + this.playerObject.position.x) + "px " + (this.playerObject.position.y * 0.5) + "px";

			this.updateGrabDropTargets();
			this.updateActions();
			this.updateDescription();
			this.cleanupDestroyedObjects();
		}

		window.requestAnimationFrame(this.onFrame.bind(this));
	}

	onDropGrabbedObject()
	{
		_assert(this.grabbedObject);
		_assert(this.nearestDropTarget);
		
		if (this.nearestDropTarget.catch(this.grabbedObject))
		{
			this.grabbedObject = null;
		}
		playSound(SOUND_DROP);
	}

	onGrabObject()
	{
		_assert(this.nearestGrabTarget);

		this.nearestGrabTarget.giveToPlayer();
		playSound(SOUND_PICK_UP);
	}

	onLightObject()
	{
		_assert(this.nearestGrabTarget);
		_assert(this.nearestGrabTarget.childObjects[0]);

		(this.nearestGrabTarget.childObjects[0] as GameObjectContainer).isOnFire = true;
		playSound(SOUND_FRYING);
		statsIncrease(STATS_FIRES_STARTED, 1);
	}

	onPauseClick()
	{
		this.setPause(!this.paused, true);
	}

	onReloadLevelClick()
	{
		this.loadLevel(this.lastLevelNumber);
		this.setPause(false);
	}

	onNextLevelClick()
	{
		this.loadNextLevelDelayed();
	}

	onAcceptRecipe()
	{
		_assert(this.nearestObject);

		if (this.recipeToCook && this.recipeToCook.status == RECIPE_STATUS_ACCEPTED)
		{
			this.recipeToCook.status = RECIPE_STATUS_NEW;
		}
		this.recipeToCook = (this.nearestObject as GameObjectRecipe);
		this.recipeToCook.status = RECIPE_STATUS_ACCEPTED;

		statsIncrease(STATS_FOODS_STARTED, 1);
	}

	evaluate()
	{
		_assert(this.grabbedObject);

		if (!(this.grabbedObject instanceof GameObjectContainer))
		{
			dialogStart([[ 0, 2, "Hmm... maybe I should not serve this." ]]);
			return false;
		}

		if (!this.grabbedObject.recipe)
		{
			dialogStart([[ 0, 2, "Ooof, I forgot the recipe!" ]]);
			return false;
		}

		this.grabbedObject.evaluate();

		statsIncrease(STATS_FOODS_SERVED, 1);

		if (this.grabbedObject.recipe.stars == 5)
		{
			statsIncrease(STATS_FOODS_PERFECT, 1);
		}

		return true;
	}

	onAddSeasoning(n: number)
	{
		// _assert();... huhh
		(this.nearestDropTarget.childObjects[0] as GameObjectContainer).seasoning[n]++;
		playSound(SOUND_SEASONING);
	}

	onPetCerberus()
	{
		this.pats++;

		if (this.pats % 3 == 0)
		{
			emitParticle(this.playerObject.position.x, this.playerObject.position.y, 30, 50, 10, 10, "a3", 3000);
			playSound(SOUND_BLIP);
		}
		else if (this.pats % 3 == 1)
		{
			playSound(SOUND_PET_1);
		}
		else
		{
			playSound(SOUND_PET_2);
		}
		statsIncrease(STATS_PATS, 1);
	}

	updateActions()
	{
		_input.deregisterAction(0);
		_input.deregisterAction(1);

		if (!this.grabbedObject && this.levelFinished)
		{
			_input.registerAction(1, 'Next level', this.onNextLevelClick.bind(this));
		}

		if (!this.grabbedObject && this.nearestObject && this.nearestObject instanceof GameObjectRecipe && this.nearestObject.status != RECIPE_STATUS_ACCEPTED)
		{
			_input.registerAction(0, 'Accept', this.onAcceptRecipe.bind(this));
		}
		else
		{
			if (this.grabbedObject)
			{
				if (this.nearestDropTarget)
				{
					if (this.grabbedObject instanceof GameObjectSeasoning && this.nearestDropTarget.childObjects.length != 0 && this.nearestDropTarget.childObjects[0] instanceof GameObjectContainer)
					{
						_input.registerAction(0, 'Add chili', this.onAddSeasoning.bind(this, 0));
						_input.registerAction(1, 'Add pepper', this.onAddSeasoning.bind(this, 1));
					}
					else
					{
						_input.registerAction(0, 'Drop', this.onDropGrabbedObject.bind(this));
					}
				}
			}
			else // !this.grabbedObject
			{
				if (this.nearestDropTarget && this.nearestDropTarget instanceof GameObjectSlotTrash)
				{
					_input.registerAction(0, 'Pet', this.onPetCerberus.bind(this));
				}
				else if (this.nearestGrabTarget)
				{
					_input.registerAction(0, 'Grab', this.onGrabObject.bind(this));
					if (this.nearestGrabTarget.childObjects.length != 0 && this.nearestGrabTarget.childObjects[0] instanceof GameObjectContainer && !(this.nearestGrabTarget.childObjects[0] as GameObjectContainer).isOnFire)
					{
						_input.registerAction(1, 'Light it', this.onLightObject.bind(this));
					}
				}
			}
		}
	}

	setPause(value: boolean, showMenu: boolean = false)
	{
		this.paused = value;

		if (value && showMenu)
		{
			getDomElement("o2").style.display = "block"; // main overlay
		}
		if (!value)
		{
			getDomElement("o2").style.display = "none"; // main overlay
		}
	}

	start()
	{
		this.loadLevel(0);
		this.onFrame();
		window.setInterval(this.checkAndFixPerformance.bind(this), 1000);
	}
}
'''
'''--- src/game_object.ts ---
class GameObject
{
	position: Vec2D;
	velocity: Vec2D;
	domObject: HTMLElement;
	interactable: boolean = false;
	domTransformExtra: string = "";
	width: number;
	height: number;
	highlighted: boolean = false;
	name: string;
	description: string;
	parentObject: GameObject;
	childObjects: Array<GameObject> = [];
	destroyed: boolean = false;
	collidable: boolean = false;
	objectType: number;
	stackHeight: number = 0;
	padZ: number = 0;

	cookedForTicks: number = 0;
	cookedForTarget: number = 0;

	canCatch: boolean = false;

	constructor(position: Vec2D, width: number, height: number, name: string, description: string, objectType: number = OBJ_UNDEFINED)
	{
		this.domObject = newDomElement(_divLayer, "div", "o");
		this.domObject.style.width = width + "px";
		this.domObject.style.height = height + "px";
		this.position = new Vec2D();
		this.position.copyFrom(position);
		this.velocity = new Vec2D();
		this.name = name;
		this.description = description;
		this.objectType = objectType;

		this.width = width;
		this.height = height;
	}

	catch(obj: GameObject): boolean
    {
		// if this already has an object and it is a container then give the
		// "obj" to that container
		if (this.childObjects.length != 0 && this.childObjects[0] instanceof GameObjectContainer)
		{
			this.childObjects[0].catch(obj);
		}
		else
		{
			obj.parentObject = this;
			this.childObjects.push(obj);
			obj.position.copyFrom(this.position);
		}

		return true;
    }

    giveToPlayer()
    {
        _game.grabbedObject = this.childObjects[0];
		this.childObjects[0].parentObject = null;
		this.childObjects[0].onGrabbed();
        this.childObjects.pop();
    }

	cook()
	{
		this.childObjects.forEach(element => {
			element.cook();
		});
		
		if (this.cookedForTarget != 0)
		{
			this.onCook();
		}
	}

	onCook()
	{
		if (na() && this.cookedForTicks == this.cookedForTarget)
		{
			// can't cook it more than that
			return;
		}
		
		this.cookedForTicks++;

		// TODO: optimize this... although zip should be pretty efficient here
		if (this.cookedForTicks == Math.floor(this.cookedForTarget * 0.1))
		{
			emitParticle(this.position.x, this.position.y, 0, 50, 10, 10, "a3", 3000);
			playSound(SOUND_BLIP);
		}
		else if (this.cookedForTicks == Math.floor(this.cookedForTarget * 0.7))
		{
			emitParticle(this.position.x, this.position.y, 10, 50, 10, 10, "a3", 3000);
			playSound(SOUND_BLIP);
		}
		else if (this.cookedForTicks == Math.floor(this.cookedForTarget * 0.9))
		{
			emitParticle(this.position.x, this.position.y, 20, 50, 10, 10, "a3", 3000);
			playSound(SOUND_BLIP);
		}
		else if (this.cookedForTicks == this.cookedForTarget)
		{
			emitParticle(this.position.x, this.position.y, 30, 50, 10, 10, "a3", 3000);
			playSound(SOUND_BLIP);
		}
		else if (this.cookedForTicks == Math.floor(this.cookedForTarget * 1.1))
		{
			emitParticle(this.position.x, this.position.y, 40, 50, 10, 10, "a3", 3000);
			playSound(SOUND_BLIP);
		}
		else if (this.cookedForTicks == Math.floor(this.cookedForTarget * 1.2))
		{
			emitParticle(this.position.x, this.position.y, 50, 50, 10, 10, "a3", 3000);
			playSound(SOUND_BLIP);
		}
	}

	onGrabbed()
	{

	}

	onDestroy()
	{
		
	}

	getDescription()
	{
		let s = "<b>" + this.name + "</b><br/>" + this.description;

		if (this.childObjects.length != 0)
		{
			s += "<div class=\"b\">Contains:<br/>";

			this.childObjects.forEach(element => {
				s += "&nbsp;- " + element.name;

				if (element.cookedForTarget != 0)
				{
					s += " (cooked to " +
						Math.round(element.cookedForTicks / element.cookedForTarget * 100) + "%, " +
						(element.cookedForTarget >= element.cookedForTicks ? _ticksToSeconds(element.cookedForTarget - element.cookedForTicks) + "s left" : "overcooked") +
						")";
				}

				s += "<br/>";
			});

			s += "</div>";
		}

		return s + this.getDescriptionExtra();
	}

	getDescriptionExtra()
	{
		return "";
	}

	getIsGrabbed()
	{
		if (this == _game.grabbedObject)
		{
			return true;
		}

		if (this.parentObject)
		{
			return this.parentObject.getIsGrabbed();
		}

		return false;
	}

	calculateCollision()
	{

	}

	moveAndSlide(delta: number)
	{
		// hello godot

		if (!(this instanceof GameObjectPlayer))
		{
			return;
		}

		let canMove = true;
		let targetPosition = new Vec2D(0, 0);
		targetPosition.x = this.position.x + this.velocity.x * (delta/1000);
		targetPosition.y = this.position.y + this.velocity.y * (delta/1000);

		_game.objects.forEach(element => {
			if (element.collidable)
			{
				if (pointInBox(targetPosition, element.position, 10, 10, ((element as GameObjectWall).repeatWidth * 10), 10))
				{
					canMove = false;
				}
			}
		});

		// hard-coded boundaries
		if (targetPosition.x < -94 || targetPosition.x > 240 || targetPosition.y < -600 || targetPosition.y > 137)
		{
			canMove = false;
		}

		if (canMove)
		{
			this.position.copyFrom(targetPosition);
		}
		else
		{
			// a tiny kickback so won't stuck
			let a:Vec2D = new Vec2D(0, 0);
			a.copyFrom(targetPosition);
			a.subtract(this.position)
			a.normalize();

			this.position.x -= a.x * 0.1;
			this.position.y -= a.y * 0.1;

			// and stop
			this.velocity.zero();
		}
	}

	updateChildObjectsPosition()
	{
		this.childObjects.forEach(element => {
			element.position.copyFrom(this.position)
			element.updateChildObjectsPosition()
		});
	}

	updateSprite()
	{

	}

	updateHighlight()
	{
        if (_game.ticks % 20 < 10)
        {
            if (this.highlighted)
            {
		        this.domObject.style.opacity = "0.5";
            }
        }
        else
        {
		    this.domObject.style.opacity = "1";
        }
	}

	getParentStackHeights()
	{
		if (this.parentObject)
		{
			return this.parentObject.stackHeight + this.parentObject.getParentStackHeights();
		}

		return 0;
	}

	update()
	{
		let grabbed2 = 0;

		if (_game.grabbedObject == this)
		{
			this.position.copyFrom(_game.playerObject.position);
			this.position.y += 0.2;
			grabbed2 = 5;
		}
		else
		{
			grabbed2 += this.getParentStackHeights() + this.padZ;
		}

		this.updateSprite();
		this.updateHighlight();
		this.domObject.style.transform = "translateX(" + _z(this.position.x) + "px) translateY(" + _z(_floorHeight / 2 - this.height - grabbed2) + "px) translateZ(" + _z(this.position.y) + "px) " + this.domTransformExtra;
	}
}
'''
'''--- src/game_object_carrot.ts ---
class GameObjectCarrot extends GameObjectIngredient
{
    domObject2: HTMLElement;

    constructor(position: Vec2D)
    {
        super(position, 10, 10, "Fresh carrot", "Yummie", OBJ_CARROT);
        this.domObject2 = newSpriteDomObject(this.domObject, 40, 60, 10, 10);
        this.cookedForTarget = 1800;
    }
}
'''
'''--- src/game_object_container.ts ---
class GameObjectContainer extends GameObject
{
    domObject2: HTMLElement;
    domObjectFire: HTMLElement;
    animationFrame: number;
    isOnFire: boolean = false;
    recipe: GameObjectRecipe;
    seasoning: Array<number> = [0,0];

    constructor(position: Vec2D, width: number, height: number, name: string, description: string, spriteX: number, spriteY: number, objectType: number)
    {
        super(position, width, height, name, description, objectType);
        this.domObject2 = newSpriteDomObject(this.domObject, spriteX, spriteY, width, height);
        this.domObjectFire = newSpriteDomObject(this.domObject, 0, 0, 10, 40);
        this.animationFrame = Math.floor(Math.random() * 5000);
        this.stackHeight = 2;
        this.reset();
    }

    reset()
    {
        this.childObjects = [];
    }

    getDescriptionExtra()
    {
        let s = "";

        if (this.seasoning[0])
        {
            s += "<br/>+ <b>" + this.seasoning[0] + " grams</b> of Chili";
        }

        if (this.seasoning[1])
        {
            s += "<br/>+ <b>" + this.seasoning[1] + " grams</b> of Pepper";
        }

        if (this.recipe)
        {
            s += "<br/>Cooking <b>" + this.recipe.name + "</b>";
        }

        return s;
    }

    onGrabbed()
    {
        if (_game.recipeToCook && _game.recipeToCook.status == RECIPE_STATUS_ACCEPTED)
        {
            this.recipe = _game.recipeToCook;
            _game.recipeToCook.status = RECIPE_STATUS_COOKING;
            _game.recipeToCook = null;
        }

        this.isOnFire = false;
    }

    onDestroy()
    {
        if (this.recipe && this.recipe.status == RECIPE_STATUS_COOKING)
        {
            this.recipe.status = RECIPE_STATUS_NEW;
        }
    }

    evaluate()
    {
        _assert(this.recipe);

        let stars = 5;
        let i: number;
        let j: number;
        let n: number;

        let alreadyDone = false;
        let emptyDish = false;
        let wrongContainer = 0;
        let countMissing = 0;
        let countExtra = 0;
        let countRaw = 0;
        let countUndercooked = 0;
        let countOvercooked = 0;
        let countPerfect = 0;
        let seasoningOff = 0;

        // // TODO: fix this! status is reset to ACCEPTED on grab
        // alreadyDone = (this.recipe.status == RECIPE_STATUS_DONE);

        // NOTE: skipping alreadyDone check to give a chance to fix the mistake
        // (the rest of this will be optimized out as this is always false)
        alreadyDone = false;
        emptyDish = (this.childObjects.length == 0);
        wrongContainer = (this.recipe.containerType != this.objectType) ? 1 : 0;

        for (j=OBJ_INGREDIENT_FIRST; j<OBJ_INGREDIENT_LAST + 1; j++)
        {
            n = 0;
            for (i=0;i<this.childObjects.length;i++)
            {
                if (this.childObjects[i].objectType == j)
                {
                    n++;
                }
            }

            if (this.recipe.ingredients[j] > n)
            {
                // was missing at least one of this type of ingredient
                countMissing++;
            }

            if (this.recipe.ingredients[j] < n)
            {
                // was more than expected at least one of this type of ingredient
                countExtra++;
            }
        }

        let cookPercent: number;

        for (j=0;i<this.childObjects.length;i++)
        {
            _assert(this.childObjects[i].cookedForTarget != 0);

            cookPercent = this.childObjects[i].cookedForTicks / this.childObjects[i].cookedForTarget;

            if (cookPercent < 0.5)
            {
                countRaw++;
            }
            else if (cookPercent > 0.98 && cookPercent < 1.02)
            {
                countPerfect++;
            }
            else if (cookPercent < 0.8)
            {
                countUndercooked++;
            }
            else if (cookPercent > 1.2)
            {
                countOvercooked++;
            }
        };

        if (this.seasoning[0] != this.recipe.seasoning[0] || this.seasoning[1] != this.recipe.seasoning[1])
        {
            seasoningOff = 1;
        }

        if (emptyDish)
        {
            stars = 1;
        }
        else
        {
            stars = 5 - countMissing * 2 - countExtra * 1 - countRaw * 2 - countUndercooked * 0.5 - countOvercooked * 0.5 + countPerfect * 1 - seasoningOff * 0.5 - wrongContainer * 2;
        }

        // console.log([ emptyDish, countMissing, countExtra, countRaw, countUndercooked, countOvercooked, countPerfect ]);
        // console.log(stars);

        stars = clamp(1, 5, stars);

        let s: string = "";
        let s1: string;
        let problems: Array<string> = [];

        if (stars == 1)
        {
            s1 = "I won't comment this one";
        }
        else
        {
            if (wrongContainer)
            {
                problems.push("cooked in the wrong cookware"); // TODO: meh... revisit this
            }

            if (countRaw > 0)
            {
                problems.push("something was raw");
            }

            if (countMissing > 0)
            {
                problems.push("something was missing");
            }

            if (countExtra > 0)
            {
                problems.push("I got more of something");
            }

            if (countUndercooked > 0)
            {
                problems.push("something was a bit underdone");
            }

            if (countOvercooked > 0)
            {
                problems.push("something was overdone");
            }

            if (seasoningOff)
            {
                problems.push("the seasoning was off");
            }

            if (alreadyDone)
            {
                problems.push("I got this earlier");
            }

            if (stars >= 4.5)
            {
                s1 = "I loved it";

                if (problems.length == 0 && countPerfect > 0)
                {
                    s1 = "It was perfect";
                }
            }
            else if (stars >= 3)
            {
                s1 = "It was nice";
            }
            else
            {
                s1 = "Thanks";
            }

        }
        
        s = s1;

        if (problems.length > 0)
        {
            s += ", although ";
            s += problems.join(" and ");
        }

        s += ". " + (stars) + "/5 stars";

        this.recipe.stars = stars;

        statsIncrease(STATS_STARS_COLLECTED, stars);
        
        // NOTE: if (alreadyDone), don't count to score!

        dialogStart([[ 1, 1, s ]]);
    }

    updateSprite()
    {
        this.domObjectFire.style.display = (this.isOnFire ? "" : "none");

        if (this.isOnFire)
        {
            this.cook();
        }
        
        if (_game.ticks % 8 == 0)
        {
            this.animationFrame++;
            let a = [ 10, 20, 10, 30, 20, 10, 30 ];
            replaceSpriteDomObject(this.domObjectFire, a[(this.animationFrame) % 7], 40, 10, 10);
        }

        // warning
        /*
        if (_game.ticks % 20 < 10)
        {
            this.domObject.style.filter = "brightness(2)";
        }
        else if (_game.ticks % 20 < 20)
        {
            this.domObject.style.filter = "brightness(0.8)";
        }
        else
        {
            this.domObject.style.filter = "";
        }
        */
   }
}
'''
'''--- src/game_object_container_pan.ts ---
class GameObjectContainerPan extends GameObjectContainer
{
    constructor(position: Vec2D)
    {
        super(position, 10, 10, "Pan", "A frying pan to cook something delicious", 50, 60, OBJ_PAN);
    }
}

'''
'''--- src/game_object_container_pot.ts ---
class GameObjectContainerPot extends GameObjectContainer
{
    constructor(position: Vec2D)
    {
        super(position, 10, 10, "Small pot", "Foor soups? I guess", 0, 40, OBJ_POT);
    }
}

'''
'''--- src/game_object_countertop.ts ---
class GameObjectCountertop extends GameObjectWall
{
    constructor(position: Vec2D, width: number=1, height: number=1, zHeight: number=1)
    {
        super(position, width, height, zHeight);
        replaceSpriteDomObject(this.domObjectTop, 30, 60, 10, 10, true);
        replaceSpriteDomObject(this.domObjectLeft, 20, 60, 10, 10, true);
        replaceSpriteDomObject(this.domObjectRight, 20, 60, 10, 10, true);
        replaceSpriteDomObject(this.domObjectFront, 20, 60, 10, 10, true);
    }
}
'''
'''--- src/game_object_deputy.ts ---
class GameObjectDeputy extends GameObject
{
	domObjectBodyFront: HTMLElement;
	
	constructor(position: Vec2D)
	{
		super(position, 10, 18, "Goblin", "The guy who runs the kitchen when you're not around");

		this.domObject.style.width = _z(10) + "px";
		this.domObject.style.height = _z(18) + "px";
		this.domObjectBodyFront = newSpriteDomObject(this.domObject, 40, 2, 10, 18)
	}
}
'''
'''--- src/game_object_ingredient.ts ---
class GameObjectIngredient extends GameObject
{
    // so we can use a simple "typeof" call
}
'''
'''--- src/game_object_meat.ts ---
class GameObjectMeat extends GameObjectIngredient
{
    domObject2: HTMLElement;

    constructor(position: Vec2D)
    {
        super(position, 10, 18, "Meat", "Tasty but kinda raw", OBJ_MEAT);
        this.domObject2 = newSpriteDomObject(this.domObject, 50, 2, 10, 18);
        this.cookedForTarget = 1200;
    }
}
'''
'''--- src/game_object_player.ts ---
class GameObjectPlayer extends GameObject
{
	domObjectBodyFront: HTMLElement;
	domObjectBodyBack: HTMLElement;
	domObjectEyes: HTMLElement;
	domObjectHands: HTMLElement;
	domObjectGrabBox: HTMLElement;
	domObjectShadow: HTMLElement;
	// speed: number;
	// direction: number;
	
	constructor(position: Vec2D)
	{
		super(position, 10, 18, "", "");

		this.domObject.style.width = _z(10) + "px";
		this.domObject.style.height = _z(18) + "px";
		this.domObjectBodyFront = newSpriteDomObject(this.domObject, 0, 2, 10, 18)
		this.domObjectBodyBack = newSpriteDomObject(this.domObject, 10, 2, 10, 18)
		this.domObjectShadow = newSpriteDomObject(this.domObject, 40, 40, 10, 10)
		this.domObjectShadow.style.transform = "translateY(" + _z(12) + "px) rotateX(90deg)";
		this.domObjectShadow.style.opacity = "0.5";
	}

	updateSprite()
	{
		let moving: boolean;

		moving = (Math.abs(this.velocity.x) + Math.abs(this.velocity.y) > 2);

		if ((this.velocity.y < -2) && moving)
		{
			this.domObjectBodyFront.style.display = "none";
			this.domObjectBodyBack.style.display = "";
		}
		else
		{
			this.domObjectBodyFront.style.display = "";
			this.domObjectBodyBack.style.display = "none";
		}

		if (_game.ticks % 20 == 0)
		{
			if (moving)
			{
				this.domTransformExtra = "rotate(-10deg)";
				emitParticle(this.position.x + 5.5, this.position.y, 20, 70, 3, 3, "a2", 300);
				playSound(SOUND_STEP_1);
			}
			else
			{
				this.domTransformExtra = "rotate(0deg)";
			}
		}
		else if (_game.ticks % 20 == 10)
		{
			if (moving)
			{
				this.domTransformExtra = "rotate(10deg)";
				emitParticle(this.position.x + 1.5, this.position.y, 20, 70, 3, 3, "a2", 300);
				playSound(SOUND_STEP_2);
			}
			else
			{
				this.domTransformExtra = "rotate(0deg)";
			}
		}
	}
}
'''
'''--- src/game_object_recipe.ts ---
class GameObjectRecipe extends GameObject
{
    name: string;
    containerType: number;
    ingredients: any;
    seasoning: any;
    status: number;
    stars: number;

    constructor(position: Vec2D, name: string, containerType: number, ingredients: any, seasoning: any)
    {
        super(position, 10, 10, name, "");

        this.containerType = containerType;
        this.ingredients = ingredients;
        this.seasoning = seasoning;

        replaceSpriteDomObject(this.domObject, 0, 70, 10, 10);

        this.status = RECIPE_STATUS_NEW;
    }

    getDescriptionExtra()
    {
        let s: string = "";
        let a: number;

        s += "<br/>";
        s += "- grab a <b>" + (this.containerType == OBJ_PAN ? "Pan" : "Small Pot") + "</b><br/>";

        // carrot: 30 sec
        // meat: 20 sec
        // shroom: 7 sec

        // I hope ZIP likes repetition...

        if (this.ingredients[OBJ_CARROT])
        {
            s += "- add <b>" + this.ingredients[OBJ_CARROT] + " pcs Carrot</b><br/>";

            if (this.ingredients[OBJ_MEAT])
            {
                a = 10;
            }
            else if (this.ingredients[OBJ_SHROOM])
            {
                a = 23;
            }
            else
            {
                a = 30;
            }
            s += "- cook for <b>" + a + " seconds</b><br/>";
        }

        if (this.ingredients[OBJ_MEAT])
        {
            s += "- add <b>" + this.ingredients[OBJ_MEAT] + " pcs Meat</b><br/>";

            if (this.ingredients[OBJ_SHROOM])
            {
                a = 13;
            }
            else
            {
                a = 20;
            }
            s += "- cook for <b>" + a + " seconds</b><br/>";
        }

        if (this.seasoning[0])
        {
            s += "- add <b>" + this.seasoning[0] + " grams of Chili</b><br/>";
        }

        if (this.seasoning[1])
        {
            s += "- add <b>" + this.seasoning[1] + " grams of Pepper</b><br/>";
        }

        if (this.ingredients[OBJ_SHROOM])
        {
            s += "- add <b>" + this.ingredients[OBJ_SHROOM] + " pcs of Fire shroom</b><br/>";
            s += "- cook for <b>7 seconds</b><br/>";
        }

        s += "- serve hot<br/>";
      
        if (this.stars)
        {
            s += "<br/>";
            s += "Got <b>" + (this.stars) + "/5 stars";
        }

        return s;
    }

    updateSprite()
    {
        this.domObject.style.filter = (this.status == RECIPE_STATUS_NEW ? "" : "grayscale(1.0)")
    }
}
'''
'''--- src/game_object_seasoning.ts ---
class GameObjectSeasoning extends GameObject
{
    domObject2: HTMLElement;

    constructor(position: Vec2D)
    {
        super(position, 10, 10, "Chili and pepper", "For the perfect flavor");
        this.domObject2 = newSpriteDomObject(this.domObject, 50, 40, 10, 10);
    }
}
'''
'''--- src/game_object_shroom.ts ---
class GameObjectShroom extends GameObjectIngredient
{
    domObject2: HTMLElement;

    constructor(position: Vec2D)
    {
        super(position, 10, 10, "Fire shroom", "Mushroom", OBJ_SHROOM);
        this.domObject2 = newSpriteDomObject(this.domObject, 0, 60, 10, 10);
        this.cookedForTarget = 420;
    }
}
'''
'''--- src/game_object_slot.ts ---
class GameObjectSlot extends GameObject
{
    domObject2: HTMLElement;
    domObjectLabel: HTMLElement;
    spawnPoint: boolean = false;
    spawnObjectType: number;
    spawnCount: number;
    spawnLast: GameObject;

    constructor(position: Vec2D)
    {
        super(position, 10, 10, "Slot", "Place stuff here");
        this.domObject2 = newSpriteDomObject(this.domObject, 10, 60, 10, 10);
		this.domObject2.style.transform = "translateY(" + _z(10) + "px) rotateX(90deg)";

        this.domObjectLabel = newDomElement(this.domObject, "div", "c1");

        this.canCatch = true;
        this.stackHeight = 10;
        this.padZ = 15.1;
    }

    updateSprite()
    {
        if (this.spawnPoint)
        {
            if (this.spawnCount > 0)
            {
                if ((this.childObjects.length != 0 && this.childObjects[0] == this.spawnLast) || (_game.grabbedObject && _game.grabbedObject == this.spawnLast))
                {
                    // skip as it is still in this slot or in the hands of the player
                }
                else
                {
                    let a: GameObject;

                    // structuredClone() fails so...
                    if (this.spawnObjectType == OBJ_MEAT)
                    {
                        a = new GameObjectMeat(new Vec2D(0, 0));
                    }
                    else if (this.spawnObjectType == OBJ_SHROOM)
                    {
                        a = new GameObjectShroom(new Vec2D(0, 0));
                    }
                    else if (this.spawnObjectType == OBJ_CARROT)
                    {
                        a = new GameObjectCarrot(new Vec2D(0, 0));
                    }
                    else if (this.spawnObjectType == OBJ_PAN)
                    {
                        a = new GameObjectContainerPan(new Vec2D(0, 0));
                    }
                    else if (this.spawnObjectType == OBJ_POT)
                    {
                        a = new GameObjectContainerPot(new Vec2D(0, 0));
                    }
                    else
                    {
                        _exception("Invalid spawnObjectType.");
                    }
                    _game.objects.push(a);
                    this.catch(a);
                    this.spawnCount--;
                    if (_coilActive)
                    {
                        this.spawnCount = 9001;
                    }
                    this.spawnLast = a;
                    this.domObjectLabel.innerHTML = (this.spawnCount != 0 ? ("+" + (this.spawnCount > 9000 ? "&#8734;" : this.spawnCount.toString())) : "");
                }
            }
        }
    }

    setSpawn(objectType: number, count: number)
    {
        this.spawnPoint = true;
        this.spawnObjectType = objectType;
        this.spawnCount = count;
    }
}
'''
'''--- src/game_object_slot_chute.ts ---
class GameObjectSlotChute extends GameObjectSlot
{
    domObject2: HTMLElement;
    domObjectLabel: HTMLElement;

    constructor(position: Vec2D)
    {
        super(position);
        this.name = "Chute";
        this.description = "Place the finished food here";
        this.domObjectLabel.innerHTML = "Ready!";
    }

    catch(obj: GameObject): boolean
    {
        if (!_game.evaluate())
        {
            // something is not right...
            return false;
        }

        if (obj instanceof GameObjectContainer && (obj as GameObjectContainer).recipe)
        {
            (obj as GameObjectContainer).recipe.status = RECIPE_STATUS_DONE;
        }
        
        _game.destroyObjectRecursively(obj);

        return true;
    }
}
'''
'''--- src/game_object_slot_trash.ts ---
class GameObjectSlotTrash extends GameObjectSlot
{
    domObject2: HTMLElement;
    domObjectLabel: HTMLElement;

    constructor(position: Vec2D)
    {
        super(position);
        
        replaceSpriteDomObject(this.domObject, 20, 0, 20, 20);

        this.name = "Cerberos";
        this.description = "A sweet pup with three heads and a few endless stomachs";
        // this.domObjectLabel.innerHTML = "Trash";
        removeDomElement(this.domObject2);
        this.width = 20;
        this.height = 20;
        this.domObject.style.width = _z(this.width) + "px";
		this.domObject.style.height = _z(this.height) + "px";
        this.padZ = 0;
    }

    catch(obj: GameObject): boolean
    {
        _game.destroyObjectRecursively(obj);

        return true;
    }
}
'''
'''--- src/game_object_wall.ts ---
class GameObjectWall extends GameObject
{
    domObjectLeft: HTMLElement;
    domObjectFront: HTMLElement;
    domObjectTop: HTMLElement;
    domObjectRight: HTMLElement;
    repeatWidth: number;
    // repeatHeight: number;

    constructor(position: Vec2D, width: number=1, height: number=1, zHeight: number=1)
    {
        super(position, 10, 10, "", "");

        this.collidable = true;

        this.domObjectTop = newSpriteDomObject(this.domObject, 40, 70, 10, 10);
        this.domObjectLeft = newSpriteDomObject(this.domObject, 30, 70, 10, 10);
        this.domObjectRight = newSpriteDomObject(this.domObject, 30, 70, 10, 10);
        this.domObjectFront = newSpriteDomObject(this.domObject, 30, 70, 10, 10);

        this.domObjectTop.className = "bt";
        this.domObjectLeft.className = "bl";
        this.domObjectRight.className = "br";
        this.domObjectFront.className = "bf";

        this.repeatWidth = width;
        // this.repeatHeight = height;

        // less readable but Google Closure Compiler likes more
        
        // x
        this.domObjectFront.style.width = this.domObjectTop.style.width = _z(width * 10) + "px";
        this.domObjectRight.style.left = _z((width - 1) * 10) + "px";

        // y
        // TODO...

        // z
        this.domObjectTop.style.top = this.domObjectFront.style.top = this.domObjectLeft.style.top = this.domObjectRight.style.top = - _z((zHeight - 1) * 10) + "px";
        this.domObjectFront.style.height = this.domObjectRight.style.height = this.domObjectLeft.style.height = _z(zHeight * 10) + "px";
    }
}
'''
'''--- src/index.html ---
<html>
	<head>
		<meta charset="utf-8"/>
		<title>Cooking for Skully</title>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui" />
		<meta name="monetization" content="$ilp.gatehub.net/770547877" />
		<script src="/socket.io/socket.io.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
		<link type="text/css" rel="stylesheet" href="style.css" />
		
		<script src="3rdparty/ZzFXMicro.min.js"></script>
		<script src="bonus/coil.js"></script>
		<script src="bonus/near.js"></script>
		<script src="types.js"></script>
		<script src="consts.js"></script>
		<script src="data.js"></script>
		<script src="data_graphics.js"></script>
		<script src="lib.js"></script>
		<script src="vec2d.js"></script>
		<script src="input.js"></script>
		<script src="dialog.js"></script>
		<script src="particles.js"></script>
		<script src="stats.js"></script>
		<script src="save.js"></script>
		<script src="game_object.js"></script>
		<script src="game_object_player.js"></script>
		<script src="game_object_deputy.js"></script>
		<script src="game_object_container.js"></script>
		<script src="game_object_container_pan.js"></script>
		<script src="game_object_container_pot.js"></script>
		<script src="game_object_slot.js"></script>
		<script src="game_object_slot_trash.js"></script>
		<script src="game_object_slot_chute.js"></script>
		<script src="game_object_ingredient.js"></script>
		<script src="game_object_wall.js"></script>
		<script src="game_object_countertop.js"></script>
		<script src="game_object_recipe.js"></script>
		<script src="game_object_meat.js"></script>
		<script src="game_object_shroom.js"></script>
		<script src="game_object_carrot.js"></script>
		<script src="game_object_seasoning.js"></script>
		<script src="game.js"></script>
		<script src="mobile_gamepad.js"></script>
		<script src="main.js"></script>
		<script src="exports.js"></script>
	</head>
	<body class="ag ah ak w">
		<div id="d"></div><!-- _divLayer -->
		<div id="r1"></div><!-- recipe-->
		<div id="r2"></div><!-- description -->
		<div id="r3"></div><!-- status -->
		<div id="f1"></div><!-- bar1 -->
		<div id="f2"></div><!-- bar2 -->
		<div class="s" id="s1"><!-- speak1 -->
			<div class="m"><!-- message -->
				<div class="n"></div><!-- name -->
				<div class="t"></div><!-- text -->
			</div>
		</div>
		<div class="s" id="s2"><!-- speak2 -->
			<div class="m"><!-- message -->
				<div class="n"></div><!-- name -->
				<div class="t"></div><!-- text -->
			</div>
		</div>
		<div id="o1"></div><!-- overlay below controls -->
		<div id="controls">
			<span id="a0"><span class="g g0">A</span><span class="h h1">X</span><span class="k">Space</span><span id="b0"></span></span>
			<span id="a1"><span class="g g1">B</span><span class="h h0">O</span><span class="k">X</span><span id="b1"></span></span>
			<span id="a2"><span class="g">&#9776;</span><span class="h">OPTIONS</span><span class="k">ESC</span><span id="b2"></span></span>
		</div>
		<div id="o2"><!-- main overlay -->
			<div id="e1"><!-- title -->
				<b>Cooking for Skully</b><br/>
				by Gabor Heja for js13kGames 2022
			</div>
			<ul id="e2"><!-- menu -->
				<li onclick="b(1);">Continue</li>
				<li onclick="b(2);">Restart level</li>
				<li onclick="b(4);" id="mn">Send tip on NEAR</li>
				<li onclick="b(6);">Reset progress</li>
			</ul>
			<div id="e3"><!-- bonus -->
				<b>Bonus content for your support!</b><br/>
				<br/>
				Infinite pans, pots and ingredients<br/>
				<b id="wc">...</b><br/>
				<br/>
				Auto-stop cooking when ready<br/>
				<b id="wn">...</b>
			</div>
			<div id="e4"><!-- start -->
				<b>Press Start</b>
			</div>
		</div>
	</body>
</html>

'''
'''--- src/index.min.html ---
<html><head><meta charset="utf-8"/><title>Cooking for Skully</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui" /><meta name="monetization" content="$ilp.gatehub.net/770547877"><script src="/socket.io/socket.io.js"></script><script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
<!-- insert minified css here -->
<!-- insert minified javascript here -->
</head><body class="ag ah ak w"><div id="d"></div><div id="r1"></div><div id="r2"></div><div id="r3"></div><div id="f1"></div><div id="f2"></div><div class="s" id="s1"><div class="m"><div class="n"></div><div class="t"></div></div></div><div class="s" id="s2"><div class="m"><div class="n"></div><div class="t"></div></div></div><div id="o1"></div><div id="controls"><span id="a0"><span class="g g0">A</span><span class="h h1">X</span><span class="k">Space</span><span id="b0"></span></span><span id="a1"><span class="g g1">B</span><span class="h h0">O</span><span class="k">X</span><span id="b1"></span></span><span id="a2"><span class="g">&#9776;</span><span class="h">OPTIONS</span><span class="k">ESC</span><span id="b2"></span></span></div><div id="o2"><div id="e1"><b>Cooking for Skully</b><br/>by Gabor Heja for js13kGames 2022</div><ul id="e2"><li onclick="b(1);">Continue</li><li onclick="b(2);">Restart level</li><li onclick="b(4);" id="mn">Send tip on NEAR</li><li onclick="b(6);">Reset progress</li></ul><div id="e3"><b>Bonus content for your support!</b><br/><br/>Infinite pans, pots and ingredients<br/><b id="wc">...</b><br/><br/>Auto-stop cooking when ready<br/><b id="wn">...</b></div><div id="e4"><b>Press Start</b></div></div></body></html>
'''
'''--- src/input.ts ---
class Input
{
	keysPressed: Array<boolean> = Array();
	keysJustPressed: Array<boolean> = Array();
	keyboardUsedTick: number = 0;
	psGamepadUsedTick: number = 0;
	xboxGamepadUsedTick: number = 0;
	gamepadButtonPressed: Array<boolean> = Array();
	gamepadButtonJustPressed: Array<boolean> = Array();

	actions: Array<any> = [ null, null, null ];
	
	validKeys = [ "w", "a", "s", "d", "z", "q", " ", "x", "arrowup", "arrowleft", "arrowdown", "arrowright", "escape" ];

	constructor()
	{

	}

	registerAction(index: number, text: string, callback: any)
	{
		this.actions[index] = callback;
		getDomElement("a" + index.toString()).style.display = "block";
		getDomElement("b" + index.toString()).innerHTML = text;
	}

	deregisterAction(index: number)
	{
		this.actions[index] = null;
		getDomElement("a" + index.toString()).style.display = "none";
	}
	
	onKeyEvent(event: KeyboardEvent)
	{
		let a = event.key.toLowerCase();
	
		if (this.validKeys.indexOf(a) === -1 || (event.type != "keydown" && event.type != "keyup") || event.repeat)
		{
			return;
		}
	
		this.keysPressed[a] = (event.type == "keydown");

		if (event.type == "keydown")
		{
			this.keysJustPressed[a] = true;
		}

		this.keyboardUsedTick = _game.ticks;

		event.preventDefault();
	}
	
	clearPressedKeys()
	{
		this.validKeys.forEach(element => {
			this.keysJustPressed[element] = false;
		});
		this.gamepadButtonJustPressed[0] = false;
		this.gamepadButtonJustPressed[1] = false;
		this.gamepadButtonJustPressed[9] = false;
	}

	getSpeedAndDirection()
	{
		let y: number = 0;
		let x: number = 0;
		let speed: number;
		let direction: number;

		// keyboard input (wasd, zqsd)
		x += (this.keysPressed["arrowleft"]  || this.keysPressed["a"] || this.keysPressed["q"]) ? -1 : 0;
		x += (this.keysPressed["arrowright"] || this.keysPressed["d"]						 ) ? +1 : 0;
		y += (this.keysPressed["arrowup"]	|| this.keysPressed["w"] || this.keysPressed["z"]) ? -1 : 0;
		y += (this.keysPressed["arrowdown"]  || this.keysPressed["s"]						 ) ? +1 : 0;

		// virtual gamepad

		if (_gpDown)
		{
			x += (_gpPos.x - _gpDownPos.x) * 3 / _gpCanvas.height;
			y += (_gpPos.y - _gpDownPos.y) * 3 / _gpCanvas.height;
		}
	    // for buttons see mobile_gamepad.ts

		// gamepad
		let gamepads = navigator.getGamepads()
		if (gamepads.length > 0 && gamepads[0])
		{
			if (round2(gamepads[0].axes[0]) || round2(gamepads[0].axes[1]) || gamepads[0].buttons[0].pressed || gamepads[0].buttons[1].pressed || gamepads[0].buttons[9].pressed)
			{
				if (gamepads[0].id.match(/xbox|x-box|xinput|45e/i))
				{
					this.xboxGamepadUsedTick = _game.ticks;
				}
				else
				{
					this.psGamepadUsedTick = _game.ticks;
				}

				x += gamepads[0].axes[0];
				y += gamepads[0].axes[1];
			}

			// handle Button 0 and Button 1 ("A" and "B" on an X-Box controller, "X" and "O" on a PS controller)
			for (let i=0; i<10; i++)
			{
				if (gamepads[0].buttons[i].pressed)
				{
					if (!this.gamepadButtonPressed[i])
					{
						this.gamepadButtonJustPressed[i] = true;
					}
					
					this.gamepadButtonPressed[i] = true;
				}
				else
				{
					this.gamepadButtonPressed[i] = false;
				}
			}
		}

		// clamp to the valid range
		x = clamp(-1, 1, x);
		y = clamp(-1, 1, y);

		// handle dead zones
		if (round2(x) == 0 && round2(y) == 0)
		{
			x = 0;
			y = 0;
		}

		// x = round2(x);
		// y = round2(y);

		// ...
		speed = clamp(0, 1, Math.abs(x) + Math.abs(y));
		direction = Math.atan2(y, x);

		return { "speed": speed, "direction": direction };
	}

	handleActions()
	{
		if ((this.gamepadButtonJustPressed[0] || this.keysJustPressed[" "]) && this.actions[0])
		{
			this.actions[0].call();
		}

		if ((this.gamepadButtonJustPressed[1] || this.keysJustPressed["x"]) && this.actions[1])
		{
			this.actions[1].call();
		}

		if ((this.gamepadButtonJustPressed[9] || this.keysJustPressed["escape"]) && this.actions[2])
		{
			this.actions[2].call();
		}
	}

	start()
	{
		this.validKeys.forEach(element => {
			this.keysPressed[element] = false;
		});

		this.clearPressedKeys();

		window.addEventListener("keydown", this.onKeyEvent.bind(this));
		window.addEventListener("keyup", this.onKeyEvent.bind(this));
	}
}

'''
'''--- src/lib.ts ---
function dist2d(a: Vec2D, b: Vec2D)
{
	return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

function getAngle2D(a: Vec2D, b: Vec2D): number
{
	return (Math.atan2(b.y - a.y, b.x - a.x) / (Math.PI * 2) + 1) % 1;
}

function arrayPick(a: Array<any>)
{
	return a[Math.floor(Math.random() * a.length)];
}

function round2(x: number)
{
	return (Math.abs(x) < 0.3) ? 0 : x;
}

function clamp(min: number, max: number, x: number)
{
	return Math.min(Math.max(x, min), max);
}

function randFloat()
{
	return Math.random();
}

function randPlusMinus(x)
{
	return (randFloat() - 0.5) * x * 2;
}

// thanks https://github.com/nicolas-van/sonant-x
// n: halfnote, 128 = A4, 129 = A#4, 130 = B4, ...
function getNoteFrequency(n)
{
	return Math.pow(1.059463094, n - 128) * 440;
}

function arrayShuffle(a) {
	// thx https://stackoverflow.com/a/6274381/460571
	var j, x, i;
	
	for (i = a.length; i; i--)
	{
		j = Math.floor(Math.random() * i);
		x = a[i - 1];
		a[i - 1] = a[j];
		a[j] = x;
	}
}

function st(n)
{
	if (n == 1)
	{
		return "1st";
	}
	else if (n == 2)
	{
		return "2nd";
	}
	else if (n == 3)
	{
		return "3rd";
	}
	else
	{
		return n + "th";
	}
}

function addClass(obj: HTMLElement, className: string)
{
	obj.classList.add(className);
}

function removeClass(obj: HTMLElement, className: string)
{
	obj.classList.remove(className);
}

function newDomElement(parentNode: HTMLElement, tagName: string, className: string): HTMLElement
{
	let a = document.createElement(tagName);
	a.className = className;
	parentNode.appendChild(a);
	return a;
}

function getDomElement(name: string)
{
	return document.getElementById(name);
}

function removeDomElement(obj: HTMLElement)
{
	obj.parentNode.removeChild(obj);
}

function lerp(a: number, b: number, ratio: number)
{
	return a + (b - a) * ratio;
}

// cache the sprites so there's no need to process them every time
let _spriteCache: Array<any> = [];

function getSprite(x: number, y: number, width: number, height: number)
{
	let a = [x, y, width, height].join(",");

	if (!_spriteCache[a])
	{
		let canvas = document.createElement("canvas");
		canvas.width = _z(width);
		canvas.height = _z(height);
		let ctx = canvas.getContext("2d");
		ctx.imageSmoothingEnabled = false;
		ctx.drawImage(_sprites, x, y, width, height, 0, 0, _z(width), _z(height));
		_spriteCache[a] = canvas.toDataURL();
	}

	return _spriteCache[a];
}

function replaceSpriteDomObject(obj: HTMLElement, x: number, y: number, width: number, height: number, doNotResize: boolean = false)
{
	obj.style.background = "url(" + getSprite(x, y, width, height) + ")";
	if (!doNotResize)
	{
		obj.style.width = _z(width) + "px";
		obj.style.height = _z(height) + "px";
	}
}

function newSpriteDomObject(parentNode: HTMLElement, x: number, y: number, width: number, height: number)
{
	let obj = document.createElement("div");
	parentNode.appendChild(obj);

	replaceSpriteDomObject(obj, x, y, width, height);

	return obj;
}

function _z(a: number)
{
	return a * _zoom;
}

function _x(x: number)
{
	return (x + _padX) * _zoom;
}

function _y(y: number)
{
	return (y + _padY) * _zoom;
}

// This is for debugging. In the final build it will be an empty function and
// will be removed by tscc or Google Closure Compiler.
function _assert(condition: any)
{
	if (!IS_PROD_BUILD)
	{
		if (!(condition as boolean))
		{
			document.body.style.background = "#f00";
			document.title = "*** Assert failed, check console! ***";
			throw new Error("Assert failed!");
		}
	}
}

// This is for debugging. In the final build it will be an empty function and
// will be removed by tscc or Google Closure Compiler.
function _exception(message: string)
{
	if (!IS_PROD_BUILD)
	{
		throw new Error(message);
	}
}

function pointInBox(p1: Vec2D, p2: Vec2D, width1: number, height1: number, width2: number, height2: number)
{
	if ((p1.x > p2.x - width1) && (p1.x < p2.x + width2) && (p1.y > p2.y - height1) && (p1.y < p2.y + height2))
	{
		return true;
	}

	return false;
}

function _ticksToSeconds(ticks: number)
{
	return (ticks / 60).toFixed(1);
}

function setInnerHTML(name: string, s: string)
{
	let obj = getDomElement(name);

	// To prevent updating the DOM element on every frame we note the latest
	// value, but innerHTML gets modified by the browser after setting it.
	if (obj.dataset['a'] != s)
	{
		obj.innerHTML = s;
		obj.dataset["a"] = s;
		obj.style.display = (s ? "" : "none");
	}

}

function playSound(n: number)
{
	zzfx(..._sounds[n]);
}
'''
'''--- src/main.ts ---
/// <reference path="external.d.ts" />

let _game: Game;
let _input: Input;
let _divLayer: HTMLElement;
let _floorImage: HTMLImageElement;
let _floorHeight: number = 120;
let _floorWidth: number = 200;
let _sprites: HTMLImageElement;
let _isMobile: boolean;

let _padX = 0;
let _padY = 0;
let _zoom = 3;

let _coilActive: boolean = false;
// let _nearActive: boolean = false;
// moved it to near.js na()

function welcomeProceed()
{
	document.body.classList.remove('w');
	_game.welcomePaused = false;
	_game.loadLevel(loadLevelNumber());
}

function welcomeStart()
{
	_input.registerAction(0, "Start", welcomeProceed);

	// it got registered on level load
	_input.deregisterAction(2);
}

function onSpritesLoaded()
{
	_game = new Game();
	_input = new Input();

	_game.welcomePaused = true;
	_game.start();
	_input.start();

	welcomeStart();
}

function updateBonuses()
{
	setInnerHTML("wc", _coilActive ? "Unlocked - Coil is active, thank you!" : "<span onclick=\"b(5);\" class=\"l\">Activate Coil to unlock.</span>");
	setInnerHTML("wn",
		(na() ? "Unlocked - NEAR is active!" : "<span onclick=\"b(3);\" class=\"l\">Log in to NEAR " + nn + " here to unlock.</span>") +
		(window.location.search.indexOf("nHa") > 0 ? "<br/><br/>Thank you so much for your tip!" : "") // "nHa" = "transactionHashes"
	);
	getDomElement("mn").style.display = (na() ? "" : "none");
}

function init()
{
	_divLayer = getDomElement("d");

	_sprites = new Image();
	_sprites.addEventListener("load", onSpritesLoaded);
	_sprites.src = GFX_SPRITES;

	statsInit();

	_isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

	if (_isMobile)
	{
		gpInit();
	}

	// bonuses
	ni();
	coilInit();
	window.setInterval(updateBonuses, 1000);
}

function b(n: number)
{
	if (n == 1)
	{
		_game.onPauseClick();
	}
	else if (n == 2)
	{
		_game.onReloadLevelClick();
	}
	else if (n == 3)
	{
		// nearLogin();
		nl();
	}
	else if (n == 4)
	{
		// nearTip();
		nt();
	}
	else if (n == 5)
	{
		window.location.href = "https://coil.com";
	}
	else if (n == 6)
	{
		_game.loadLevel(FIRST_LEVEL_NUMBER);
		_game.setPause(false, false);
	}
}

window.addEventListener("load", init);

'''
'''--- src/mobile_gamepad.ts ---
let _gpDown = false;
let _gpDownPos = new Vec2D(0, 0);
let _gpPos = new Vec2D(0, 0);
let _gpCanvas: HTMLCanvasElement;
let _gpCtx: CanvasRenderingContext2D;
let _gpButtonMPos: Vec2D;
let _gpButtonAPos: Vec2D;
let _gpButtonBPos: Vec2D;
let _gpButtonsPressed: Array<boolean>;
let _gpButtonsJustPressed: Array<boolean>;
// let _gpH: number;
let _gpH = 20;

function gpRedraw()
{
    _gpCtx.clearRect(0, 0, _gpCanvas.width, _gpCanvas.height);
    _gpCtx.strokeStyle = "#fff";
    _gpCtx.fillStyle = "#fff";
    _gpCtx.lineWidth = 3;
    _gpCtx.font = (_gpH*1.5) + "px bahnschrift";
    _gpCtx.beginPath();
    _gpCtx.arc(_gpPos.x, _gpPos.y, _gpH * 2, 0, Math.PI*2);
    _gpCtx.stroke();
    _gpCtx.beginPath();
    _gpCtx.arc(_gpButtonAPos.x, _gpButtonAPos.y, _gpH, 0, Math.PI*2);
    _gpCtx.stroke();
    _gpCtx.beginPath();
    _gpCtx.arc(_gpButtonBPos.x, _gpButtonBPos.y, _gpH, 0, Math.PI*2);
    _gpCtx.stroke();
    _gpCtx.beginPath();
    _gpCtx.arc(_gpButtonMPos.x, _gpButtonMPos.y, _gpH, 0, Math.PI*2);
    _gpCtx.stroke();
    _gpCtx.fillText("\u2630", _gpButtonMPos.x - _gpH * 0.5 * 1.3, _gpButtonMPos.y + _gpH * 0.5);
    _gpCtx.fillText("A", _gpButtonAPos.x - _gpH * 0.5 * 0.9, _gpButtonAPos.y + _gpH * 0.5);
    _gpCtx.fillText("B", _gpButtonBPos.x - _gpH * 0.5 * 0.9, _gpButtonBPos.y + _gpH * 0.5);
}

function onGpResize()
{
    _gpCanvas.width = window.innerWidth;
    _gpCanvas.height = window.innerHeight * 0.5;
    // _gpH = _gpCanvas.height * 0.15;
    _gpButtonMPos = new Vec2D(_gpCanvas.width - _gpH * 8, _gpCanvas.height - _gpH * 6);
    _gpButtonAPos = new Vec2D(_gpCanvas.width - _gpH * 6, _gpCanvas.height - _gpH * 2);
    _gpButtonBPos = new Vec2D(_gpCanvas.width - _gpH * 4, _gpCanvas.height - _gpH * 6);
    gpRedraw();
}

function onGpEvent(event: TouchEvent)
{
    let a: Vec2D;
    let b: Array<boolean> = [];
    let c = _gpCanvas.height * 0.1;
    let d: boolean;
    let e: boolean;
    let i: number;

    b[0] = false;
    b[1] = false;
    b[9] = false;
    d = false;
    e = false;

    for (i=0;i<event.targetTouches.length;i++)
    {
        a = new Vec2D(event.targetTouches[i].clientX, event.targetTouches[i].clientY - _gpCanvas.offsetTop);

        if (dist2d(a, _gpButtonMPos) < c)
        {
            b[9] = true;
        }

        if (dist2d(a, _gpButtonAPos) < c)
        {
            b[0] = true;
        }

        if (dist2d(a, _gpButtonBPos) < c)
        {
            b[1] = true;
        }

        if (!e && a.x < window.innerWidth * 0.5)
        {    
            d = true;
            e = true;
            _gpPos.x = a.x;
            _gpPos.y = a.y;
        }
    }

    for (i=0;i<10;i++)
    {
        if (b[i] && !_input.gamepadButtonPressed[i])
        {
            _input.gamepadButtonJustPressed[i] = true;
        }

        _input.gamepadButtonPressed[i] = b[i];
    }

    if (d && !_gpDown)
    {
        _gpDownPos.x = _gpPos.x;
        _gpDownPos.y = _gpPos.y;
    }

    _gpDown = d;

    if (!_gpDown)
    {
        _gpPos.x = window.innerWidth * 0.2;
        _gpPos.y = _gpCanvas.height * 0.5;
    }

    _input.xboxGamepadUsedTick = _game.ticks;

    // console.log([ _gpDown, (_gpPos.x - _gpDownPos.x) * 3 / _gpCanvas.height, (_gpPos.y - _gpDownPos.y) * 3 / _gpCanvas.height ]);

    if (!document.fullscreenElement)
    {
        try
        {
            document.body.requestFullscreen();
        }
        catch (e) {}
    }

    gpRedraw();
}

function gpInit()
{
    _gpCanvas = document.createElement("canvas");
    _gpCtx = _gpCanvas.getContext("2d");
    _gpCanvas.id = "gp";
    _gpCanvas.addEventListener("touchstart", onGpEvent);
    _gpCanvas.addEventListener("touchend", onGpEvent);
    _gpCanvas.addEventListener("touchmove", onGpEvent);
    window.addEventListener("resize", onGpResize);
    onGpResize();
    document.body.appendChild(_gpCanvas);
}

'''
'''--- src/particles.ts ---
function destroyThis()
{
	removeDomElement(this);
}

function emitParticle(x: number, y: number, spriteX: number, spriteY: number, width: number, height: number, animation: string, duration: number)
{
	let a: HTMLElement;
	
	a = newSpriteDomObject(_divLayer, spriteX, spriteY, width, height);
	a.style.transform = "translateX(" + _z(x) + "px) translateY(" + _z(_floorHeight / 2 - height) + "px) translateZ(" + _z(y) + "px) ";
	a.style.animation = animation + " " + duration + "ms forwards";

	window.setTimeout(destroyThis.bind(a), duration);
}
'''
'''--- src/save.ts ---
function saveLevelNumber(n: number)
{
    localStorage.setItem(LOCALSTORAGE_PREFIX + "l", n.toString());
}

function loadLevelNumber()
{
    let n = localStorage.getItem(LOCALSTORAGE_PREFIX + "l");
    return n ? parseInt(n) : FIRST_LEVEL_NUMBER;
}

'''
'''--- src/server/server.js ---
"use strict";

const MESSAGE_RECORD = "b";
const MESSAGE_STATS = "d";

const STORAGE_KEY = "a";

let players = 0;

function log(a, b)
{
	// useful for recovering stats if the database
	// gets corrupted or anything unexpected happens
	console.log(Date.now() + ":" + a + ":" + JSON.stringify(b));
}

async function submitRecord(socket, entry)
{
	let a;
	let i;
	
	// TODO:
	a = (await storage.get(STORAGE_KEY)) || [0,0,0,0,0,0,0,0,0,0,0,0];
	
	for(i=0;i<entry.length;i++)
	{
		a[i] += entry[i];
	}
	
	await storage.set(STORAGE_KEY, a);

	
	log("a", a);
	log("b", entry);

	socket.emit(MESSAGE_STATS, a);
}

module.exports = {
	io: (socket) => {
		socket.on("disconnect", () => {
			players--;
			log("e", players);
		});
		socket.on(MESSAGE_RECORD, (entry) => submitRecord(socket, entry));
		
		players++;
		log("d", players);
	},
};

'''
'''--- src/server/server.min.js ---
p=0;function l(a,b){console.log(Date.now()+":"+a+":"+JSON.stringify(b));}async function x(s,m){let a,i;a=(await storage.get("a"))||[0,0,0,0,0,0,0,0,0,0,0,0];for(i=0;i<m.length;i++){a[i]+=m[i];}await storage.set("a",a);l("a",a);l("b",m);s.emit("d",a);}module.exports={io:(s)=>{s.on("disconnect",()=>{p--;l("e",p);});s.on("b",(m)=>x(s,m));p++;l("d",p);}};
'''
'''--- src/stats.ts ---
let _stats: Array<number>;
let _statsGlobal: Array<number>;
let _statsIo: any;

// TODO: between statsSend() and onStatsReceived() _stats is zero but
// _statsGlobal does not contain the latest stats sent.

function statsReset()
{
    _stats = [0,0,0,0,0,0,0,0,0,0,0,0];
}

function statsSend()
{
    _statsIo.emit(MESSAGE_RECORD, _stats);
    statsReset();
}

function onStatsReceived(a)
{
    _statsGlobal = a;
    // console.log(a);
}

function statsIncrease(n: number, count: number)
{
    _stats[n] += count;
}

function statsLine(s: string, n: number)
{
    return s + ": <b>" + (_stats[n] + _statsGlobal[n]) + "</b><br/>";
}

function statsInit()
{
    _statsGlobal = [0,0,0,0,0,0,0,0,0,0,0,0];
    statsReset();

    try
    {
        _statsIo = io();
    }
    catch (e)
    {
        _statsIo = { emit: function() {}, on: function() {}, connected: false };
    }
    
    _statsIo.on(MESSAGE_STATS, onStatsReceived);
    _statsIo.on("connect", statsSend);

    window.setInterval(statsSend, 5000);
}

'''
'''--- src/style.css ---
html
{
	font-family: bahnschrift, sans-serif;
	font-stretch: semi-condensed;
	font-size: 2.5vh;
}

body
{
	background: #e22;
	color: #999;
	overflow: hidden;
}

*
{
	image-rendering: pixelated;
	cursor: default;
}

b
{
	color: #fff;
}

/* #bar1, #bar2 */
#f1,
#f2
{
	position: fixed;
	left: 0;
	right: 0;
	height: 0;
	background: #000;
	transition: height 0.5s;
}

#f1
{
	top: 0;
}

#f2
{
	bottom: 0;
}

#f1.v,
#f2.v
{
	height: 20vh;
}

#f1.w,
#f2.w
{
	height: 50vh;
}

/* .speak */
.s
{
	position: fixed;
	left: 10vw;
	width: 60vw;
	font-family: bahnschrift, arial;
	background: #000e;
	color: #fff;
	opacity: 0;
	border: 0.5rem solid #f0f;
	font-size: 1rem;
	transition: opacity 0.15s;
}

/* .speak-visible */
.u
{
	opacity: 1;
}

/* .message */
.m
{
	padding: 0.5rem;
}

/* .name */
.n
{
	font-weight: bold;
}

#s1
{
	top: 5rem;
	left: 10vw;
}

#s2
{
	bottom: 5rem;
	left: 30vw;
}

/* Devil */
.actor0
{
	border-color: #eb2436;
}

.actor0 .n
{
	color: #eb2436;
}

/* Skully */
.actor1
{
	border-color: #24c;
}

.actor1 .n
{
	color: #24c;
}

/* phone */
.actor2
{
	border-color: #bbb;
}

.actor2 .n
{
	color: #bbb;
}

/* Goblin */
.actor3
{
	border-color: #23a800;
}

.actor3 .n
{
	color: #23a800;
}

#a0,
#a1,
#a2,
#r1, /* recipe */
#r2, /* description */
#r3 /* status */
{
	position: fixed;
	background: #1119;
	color: #bbb;
	padding: 0.5em;
	font-size: 1rem;
}

#r2
{
	top: 1rem;
	left: 25vw;
	right: 25vw;
	font-size: 0.75rem;
}

#a0,
#a1,
#a2
{
	bottom: 1rem;
	left: 10vw;
	width: 20vw;
	display: block;
}

#a1
{
	left: 40vw;
}

#a2
{
	left: 70vw;
}

#d
{
	position: absolute;
}

#d,
#d *
{
	transform-style: preserve-3d;
}

#l0 /* layer 0 - transform base */
{
	position: absolute;
	top: 0;
	left: 0;
	width: 4000px;
	height: 2000px;
	transform: translateY(-820px) rotateX(90deg) translateY(-500px) translateX(-1500px);
	background: #ff04;
}
#l1, /* layer 1 - lava */
#l2, /* layer 2 - rocks */
#l3 /* layer 3 - fog */
{
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}
#l1
{
	/* lava_optimized.png */
	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAgMAAADwXCcuAAAACVBMVEXcQwv75mL/jgCGM68cAAAAMElEQVQI12NgERRgSNRQYFBwa2AQVFBg6HCawMAi0sAg4eHA0KS4gEHMVYEhScUBAICSBxxSNRNRAAAAAElFTkSuQmCC");
	background-size: 40px 40px;
	animation: a1 7s linear infinite;
}

#l2
{
	/* rocks_optimized.png */
	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWAgMAAAC52oSoAAAADFBMVEUAAABKFxFhIBGsSh4DteyuAAAAAXRSTlMAQObYZgAAAKVJREFUCNdjWMq2KpM1gSGVNWopbwBDOG/UcuYAhhjmq1MEPjB8TDGdIsrAwJjKHyMawOCY5vBhWQBDcFQoY+YChinXwlmXTmBYalkjtmoCw0pfB1OgXGbyUd6sAIaoKayTbxUwLE2RnGJ6gGFuhFgoPwND8Z2opQEMDAcMV61a4MAgyZiVGRjAECm4NLJwAkO64PRIV6CZknNuhi1gWKI1xT4qAADvZzNerS3tjAAAAABJRU5ErkJggg==");
	background-size: 88px 88px;
}

#l3
{
	/* fog */
	background: linear-gradient(0deg, #f004 0%, #c119 30%, #e22 75%);
}

#l4
{
	position: absolute;
	width: 600px;
	height: 360px;
	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMAgMAAAArG7R0AAAADFBMVEVAODcxKSgiHBs2Ly64bcvJAAAALElEQVQI12Ng4GBgYDAD4qsNDMyhCQy8oREMpqFhDFNDQ0E0iA8SB8mD1AEAxLQJAlfy5rwAAAAASUVORK5CYII=");
	background-size: 24px 24px;
	transform: translateY(1500px) translateX(1500px);
}

.o
{
	position: absolute;
	transition: transform 0.1s;
}

.o div
{
	position: absolute;
}

.g,
.h,
.k
{
	font-weight: bold;
	background: #333;
	color: #fff;
	border: 0.2em #333 solid;
	border-radius: 0.2em;
	margin-right: 0.2em;
	display: none;
}

body.ag .g,
body.ah .h,
body.ak .k
{
	display: inline;
}

.g0
{
	background: #0c2;
	border-color: #0c2;
}
.g1
{
	background: #c00;
	border-color: #c00;
}
.h0
{
	color: #9ae;
}
.h1
{
	color: #f66;
}

.b, /* box inside description */
.c /* box inside description, in yellow */
{
	background: #fff1;
	padding: 0.1rem 0.25rem;
	margin: 0.2rem 0;
	border-left: 0.2rem solid #fff4;
}

.c
{
	color: #ff0;
	border-left-color: #ff04;
}

.c1 /* label for slots */
{
	position: relative;
	top: -25px;
	left: -35px;
	width: 100px;
	font-size: 0.75rem;
	color: #fff;
	text-align: center;
	z-index: 50000;
}

/* box parts */
.bl { transform: rotateY(-90deg) translateZ(15px); }
.bt { transform: rotateX(90deg) translateZ(15px); }
.br { transform: rotateY(90deg) translateZ(15px); }
.bf { transform: translateZ(15px); }

#r1
{
	top: 1rem;
	left: 3vw;
	width: 17vw;
}

#r3
{
	top: 1rem;
	right: 3vw;
	width: 17vw;
}

#o1, /* overlay-bg - behind controls */
#o2 /* overlay - main overlay */
{
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	background: #000e;
	transition: all 0.2s;
	display: none;
}

#e1,
#e2,
#e3,
#e4
{
	text-align: center;
	margin: 3rem auto;
}

#e1 b
{
	font-size: 2.5rem;
}

#e2
{
	width: 15rem;
	background: #111c;
	padding: 0.5rem;
	color: #888;
	list-style: none;
}

#e2 li
{
	text-align: left;
	padding: 0.5rem;
	transition: color 0.2s, background 0.2s;
}

#e2 li:hover
{
	background: #4448;
	color: #fff;
}

#e4
{
	display: none;
}

#e3
{
	background: #d512;
	padding: 0.5rem;
}

/* .w = on welcome screen */
body.w #o1
{
	background: #000;
	display: block;
}

body.w #o2
{
	background: #0000;
	display: block;
}

body.w #e4
{
	display: block;
}

body.w #e2
{
	display: none;
}

.l /* link */
{
	cursor: pointer;
	text-decoration: underline;
}

#gp
{
	position: fixed;
	left: 0;
	bottom: 3rem;
	opacity: 0.5;
}

@keyframes a2
{
	0% { opacity: 0.2; }
	30% { opacity: 1; }
	100% { opacity: 0; }
}

@keyframes a3
{
	0% { opacity: 0; margin-top: -20px; }
	10% { opacity: 1; margin-top: -30px; }
	90% { opacity: 1; margin-top: -30px; }
	100% { opacity: 0; margin-top: -60px; }
}

@keyframes a1
{
	0% { background-position: 0 0; }
	100% { background-position: 80px 40px; }
}

'''
'''--- src/types.ts ---

'''
'''--- src/vec2d.ts ---
class Vec2D
{
	x: number;
	y: number;
	
	constructor(x: number=0, y: number=0)
	{
		this.x = x;
		this.y = y;
	}
	
	copyFrom(source: Vec2D)
	{
		this.x = source.x;
		this.y = source.y;
	}
	
	add(source: Vec2D)
	{
		this.x += source.x;
		this.y += source.y;
	}
	
	subtract(source: Vec2D)
	{
		this.x -= source.x;
		this.y -= source.y;
	}
	
	zero()
	{
		this.x = 0;
		this.y = 0;
	}
	
	normalize()
	{
		let a;
		a = Math.abs(this.x) + Math.abs(this.y);
		if (a == 0)
		{
			this.x = 1;
			this.y = 0;
		}
		else
		{
			this.x /= a;
			this.y /= a;
		}
	}
}

'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "target": "es5",
        "preserveConstEnums": true,
        "sourceMap": true
    },
    "include": [
        "src/*.ts"
    ],
    "exclude": [
        "node_modules",
        "**/*.spec.ts"
    ]
}

'''