*GitHub Repository "Peersyst/lumos"*

'''--- .eslintrc.js ---
module.exports = {
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "sourceType": "module"
  },
  "plugins": [
    "@typescript-eslint"
  ],
  "env": {
    "node": true,
    "es2020": true
  },
  "globals": {
    "Atomics": "readonly",
    "SharedArrayBuffer": "readonly"
  },
  "rules": {
    "no-var": "error",
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        "varsIgnorePattern": "^_"
      }
    ]
  }
};

'''
'''--- .github/workflows/publish.yml ---
name: publish
on:
  # When Release Pull Request is merged
  pull_request:
    branches:
      - develop
    types: [closed]

permissions:
  contents: write # for checkout and tag
  pull-requests: write # for comments
  packages: write # for publish

jobs:
  publish:
    name: Publish
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Setup Node ${{ matrix.node_version }}
        uses: actions/setup-node@v2
        with:
          node-version: 16
          registry-url: "https://registry.npmjs.org"
      - name: Git Identity
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/$GITHUB_REPOSITORY
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Install
        run: yarn install
      # Define ${CURRENT_VERSION}
      - name: Set Current Version
        run: |
          CURRENT_VERSION=$(node -p 'require("./lerna.json").version')
          echo "CURRENT_VERSION=${CURRENT_VERSION}" >> $GITHUB_ENV
      - name: Tag Check
        id: tag_check
        run: |
          GET_API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/git/ref/tags/v${CURRENT_VERSION}"
          http_status_code=$(curl -LI $GET_API_URL -o /dev/null -w '%{http_code}\n' -s \
            -H "Authorization: token ${GITHUB_TOKEN}")
          if [ "$http_status_code" -ne "404" ] ; then
            echo "::set-output name=exists_tag::true"
          else
            echo "::set-output name=exists_tag::false"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Create Git Tag
        if: steps.tag_check.outputs.exists_tag == 'false'
        uses: pkgdeps/git-tag-action@v2
        with:
          version: ${{ env.CURRENT_VERSION }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          github_repo: ${{ github.repository }}
          git_commit_sha: ${{ github.sha }}
          git_tag_prefix: "v"
      - name: Create Release
        id: create_release
        if: steps.tag_check.outputs.exists_tag == 'false' && github.event.pull_request.merged == true
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ env.CURRENT_VERSION }}
          # Copy Pull Request's tile and body to Release Note
          release_name: ${{ github.event.pull_request.title }}
          body: |
            ${{ github.event.pull_request.body }}
          draft: false
          prerelease: false
      - name: Publish
        if: steps.tag_check.outputs.exists_tag == 'false'
        run: |
          yarn run build
          yarn run build-release
          yarn lerna publish from-package --yes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

'''
'''--- DEVELOPMENT.md ---
# Development

## Publish

0. [Local] Checkout release branch: `git checkout release/<uniq>`
1. [Local] Run `yarn run versionup`
   - Update CHANGELOG.md and `package.json`'s `version`, and `lerna.json`'s `version`
   - It does not git tag
2. [Local] Submit to Release Pull Request
3. [GitHub] Review Release Pull Request
4. [GitHub] Write Release Note into the Release Pull Request's body
5. [GitHub] Merge Release Pull Request
6. [CI] Create git tag && Create GitHub Release && publish to npm(GitHub Package Registry)
   - :memo: The GitHub Release's body is copied from Release Pull Request's body

'''
'''--- README.md ---
# lumos

![build](https://github.com/nervosnetwork/lumos/actions/workflows/github-ci.yaml/badge.svg)
[![codecov](https://codecov.io/gh/nervosnetwork/lumos/branch/develop/graph/badge.svg?token=6WJJOOMD2F)](https://codecov.io/gh/nervosnetwork/lumos)
![license](https://img.shields.io/github/license/nervosnetwork/lumos)
![Lumos](./assets/lumos.jpg)

> Lumos is still under active development and considered to be a work in progress.

Lumos is a full featured JavaScript/TypeScript based dapp framework for Nervos CKB. It aims to simplify dapp development on Nervos CKB. The [name](https://harrypotter.fandom.com/wiki/Lumos_Maxima) explains what the project is about: the wonderland of CKB, though vast and fertile, still remains dark in most of the parts, lumos tries to shed light upon the land, guiding people into this beautiful new world.

As of now, lumos contains the following components:

- [ckb-indexer](./packages/ckb-indexer): an cell/tx indexer base on [ckb-indexer](https://github.com/nervosnetwork/ckb-indexer).
- [BI](./packages/bi): a big number library for lumos.
- [toolkit](./packages/toolkit): JavaScript toolkit for Nervos CKB. It contains a series of independent tools that can aid develoment of CKB dapps. This is different from a normal CKB SDK, since it tries to minimize the work done in an SDK, while providing more utlities that could be handy.
- [lumos](./packages/lumos): A root package to integrate of common functions from the Lumos sub-package.
- [base](./packages/base): a base package containing common types and utilities that are used by most packages. If there is a CKB specific task you need to perform, you might want to look here first. Chances are they are already provided.
- [helpers](./packages/helpers): a helper package containing more utilities. The difference between `helpers` and `base`, is that `base` contains pure stateless functions, while `helpers` works in a more intrinsic way: it requires `config-manager` mentioned below to be setup.
- [common-scripts](./packages/common-scripts): integrations for known scripts on CKB. While we try our best to provide integrations for popular CKB scripts, people might be working on innovations everyday. As a result, we are also designing a set of APIs, so developers can freely integrate their own scripts into lumos for everyone to use. One integrated, `common-scripts` should be able to leverage those new scripts as well.
- [config-manager](./packages/config-manager): a manager for dealing with differences between different chains, such as mainnet, testnet, or numerous dev chains. We abstract each chain into individual config file. Once loaded, config manager will be able to handle the chain specific logic, so you don't have to deal with this in your own code.
- [transaction-manager](./packages/transaction-manager): a transaction manager for CKB. One problem with UTXO based blockchains, is that a certain amount of gap period exists between a transaction is accepted by a blockchain, and when it is actually committed on chain. During this gap, new cells created by the pending transaction will not be available. Transaction manager package takes care of this. It wraps an indexer instance, and makes sure cells created in pending transactions, are also exposed and available for assembling new transactions. This means you are no longer bounded to one transaction at a time, you can freely send series of transactions as you wish.
- [hd](./packages/hd): an HD wallet manager for CKB. It support mnemonic and keystore, compatible with `Neuron` and `ckb-cli`, you can load keystore from `Neuron` or `ckb-cli` directly and import mnemonic generated by `Neuron`.
- [hd-cache](./packages/hd-cache): an HD cache manager for CKB. It build a memory cache for derived addresses and live cells of these addresses.
- [rpc](./packages/rpc): RPC module for CKB RPC. Provide type definations for CKB RPC interface.

## Examples

we have provided some use cases for Lumos, such as interactions with MetaMask, transfers CKB, address conversions, etc. which you can find in [examples](./examples)

## Building

### Requirements

- [Node.js](https://nodejs.org)
- [Yarn](https://yarnpkg.com/)
- [node-gyp](https://github.com/nodejs/node-gyp)

```bash
sudo apt-get update
sudo apt install nodejs
npm install --global yarn
sudo apt install build-essential
```

### Build

```bash
yarn run build
```

### Test (ava)

```bash
yarn run test
```

### Test Coverage (c8)

```bash
yarn run test-coverage
```

### Format & Lint

```bash
yarn run lint
```

### Clean

```bash
yarn run clean
```

'''
'''--- babel.config.js ---
const presets = [
  [
    "@babel/preset-env",
    {
      targets: {
        chrome: "79",
      },
    },
  ],
  "@babel/preset-typescript",
];

module.exports = { presets };

'''
'''--- commitlint.config.ts ---
import type { UserConfig } from "@commitlint/types";

const scopeEnumValues = [
  "base",
  "bi",
  "ckb-indexer",
  "common-scripts",
  "config-manager",
  "hd",
  "hd-cache",
  "helper",
  "indexer",
  "lumos",
  "rpc",
  "sql-indexer",
  "testkit",
  "toolkit",
  "transaction-manager",
  "examples",
  "website",
];
const Configuration: UserConfig = {
  extends: ["@commitlint/config-conventional"],
  rules: {
    "scope-enum": [2, "always", scopeEnumValues],
  },
};

module.exports = Configuration;

'''
'''--- documentations/migration-from-bigint-to-bi.md ---
## Migration From BigInt to BI

Lumos was initially designed to run in NodeJS 12+, but we found that some of the dApps actually run in browsers, and some of the earlier browsers, such as safari in iOS13, do not support the BigInt feature, so we plan to migrate the bigint-related APIs from BigInt to BI. If your dApp is also having this problem, you can use the code under this branch to build the program.

In order to keep compatibility, we have adapted the API according to the following rules

### Migration Rule

#### BigInt in Parameter

We provide a union API that allow user pass a BIish as the parameter, for example, both `toBigUint128LE(1n)` and `toBigUint128LE(BI.from(1))` will work

#### BigInt in Return

We provide a new API for returning BI that ends with Compatible, for example, both `readBigUint128LE -> readBigUint128LECompatible`

## Progress

- [x] base
- [x] config-manager
- [x] helpers
- [x] rpc
- [x] ckb-indexer
- [x] common-scripts
- [x] hd
- [x] hd-cache
- [x] transaction-manager

## Quick Start

The migration is still a work in progress and you will need to work ahead based on this branch, see the following example

```
git clone https://github.com/nervosnetwork/lumos.git
cd lumos
make build-bi
cd packages/bi
yarn link

cd /path/to/my/proj
yarn link @ckb-lumos/bi
```

### package.json

```json
{
  "resolutions": {
    "@ckb-lumos": "x.y.z"
  }
}
```

### Codemod

```ts
// before
minimalCapacity(...) // bigint

// after
minimalCapacityCompatible(...) // BI
```

## Related API

### base

- `parseSince` -> `parseSinceCompatible`
- `generateSince`
- `toBigUInt64LE`
- `readBigUInt64LE` -> `readBigUint64LECompatible`
- `toBigUInt128LE`
- `readBigUInt128LE` -> `readBigUInt128LECompatible`

### helpers

- `minimalCellCapacity` -> `minimalCellCapacityCompatible`

### common-scripts

- `anyone_can_pay.checkLimit`
- `anyone_can_pay.injectCapacity`
- `anyone_can_pay.withdraw`
- `common.transfer`
- `common.injectCapacity`
- `common.payFee`
- `common.payFeeByFeeRate`
- `common.collectInputCompatible`
- `dao.deposit`
- `dao.calculateDaoEarliestSince` -> `dao.calculateDaoEarliestSinceCompatible`
- `dao.extractDaoData` -> `dao.extractDaoDataCompatible`
- `dao.calculateMaximumWithdraw` -> `dao.calculateMaximumWithdrawCompatible`
- `deploy.completeTx`
- `deploy.injectCapacity`
- `deploy.calculateTxFee`
- `deploy.calculateFee`
- `locktime_pool.transfer` -> `locktime_pool.transferCompatible`
- `locktime_pool.injectCapacityWithoutChange` -> `locktime_pool.injectCapacityWithoutChangeCompatible`
- `locktime_pool.payFee`

- `secp256k1_blake160.transfer` -> `secp256k1_blake160.transferCompatible`
- `secp256k1_blake160.payFee`
- `secp256k1_blake160_multisig.transfer` -> `secp256k1_blake160_multisig.transferCompatible`
- `secp256k1_blake160_multisig.payFee`

* `sudt.issueToken`
* `sudt.transfer`

'''
'''--- docusaurus/docs/intro.md ---
---
sidebar_position: 1
---

# Tutorial

Lumos is a full-featured JavaScript(TypeScript) library for building Nervos CKB dApp.

## Quick Start

```
yarn add @ckb-lumos/lumos
```

'''
'''--- docusaurus/website/README.md ---
# Website

This website is built using [Docusaurus 2](https://docusaurus.io/), a modern static website generator.

### Installation

```
$ yarn
```

### Local Development

```
$ yarn start
```

This command starts a local development server and opens up a browser window. Most changes are reflected live without having to restart the server.

### Build

```
$ yarn build
```

This command generates static content into the `build` directory and can be served using any static contents hosting service.

### Deployment

Using SSH:

```
$ USE_SSH=true yarn deploy
```

Not using SSH:

```
$ GIT_USER=<Your GitHub username> yarn deploy
```

If you are using GitHub pages for hosting, this command is a convenient way to build the website and push to the `gh-pages` branch.

'''
'''--- docusaurus/website/babel.config.js ---
module.exports = {
  presets: [require.resolve('@docusaurus/core/lib/babel/preset')],
};

'''
'''--- docusaurus/website/docs/intro.md ---
---
sidebar_position: 1
---

# Tutorial Intro

Let's discover **Docusaurus in less than 5 minutes**.

## Getting Started

Get started by **creating a new site**.

Or **try Docusaurus immediately** with **[docusaurus.new](https://docusaurus.new)**.

## Generate a new site

Generate a new Docusaurus site using the **classic template**:

```shell
npm init docusaurus@latest my-website classic
```

## Start your site

Run the development server:

```shell
cd my-website

npx docusaurus start
```

Your site starts at `http://localhost:3000`.

Open `docs/intro.md` and edit some lines: the site **reloads automatically** and displays your changes.

'''
'''--- docusaurus/website/docusaurus.config.js ---
// @ts-check
// Note: type annotations allow type checking and IDEs autocompletion

const lightCodeTheme = require("prism-react-renderer/themes/github");
const darkCodeTheme = require("prism-react-renderer/themes/dracula");

/** @type {import('@docusaurus/types').Config} */
const config = {
  title: "Lumos Docs",
  tagline: "Full featured JavaScript(TypeScript) based dApp library for Nervos CKB",
  url: "https://nervosnetwork.github.io",
  baseUrl: "/lumos/",
  onBrokenLinks: "throw",
  onBrokenMarkdownLinks: "warn",
  favicon: "img/favicon.ico",
  organizationName: "nervosnetwork", // Usually your GitHub org/user name.
  projectName: "lumos", // Usually your repo name.

  presets: [
    [
      "classic",
      /** @type {import('@docusaurus/preset-classic').Options} */
      ({
        docs: {
          path: "../docs",
          sidebarPath: require.resolve("./sidebars.js"),
          editUrl:
            "https://github.com/nervosnetwork/lumos/tree/develop/docusaurus/website/",
        },
        blog: {
          showReadingTime: true,
          editUrl:
            "https://github.com/nervosnetwork/lumos/tree/develop/docusaurus/website/",
        },
        theme: {
          customCss: require.resolve("./src/css/custom.css"),
        },
      }),
    ],
  ],

  themeConfig:
    /** @type {import('@docusaurus/preset-classic').ThemeConfig} */
    ({
      navbar: {
        title: "Lumos Docs",
        // TODO need a logo
        // logo: {
        //   alt: "Lumos Docs",
        //   src: "img/logo.svg",
        // },
        items: [
          {
            type: "doc",
            docId: "intro",
            position: "left",
            label: "Docs",
          },
          // { to: "/blog", label: "Blog", position: "left" },
          {
            href: "https://github.com/nervosnetwork/lumos",
            label: "GitHub",
            position: "right",
          },
          {
            type: 'localeDropdown',
            position: 'right',
          },
        ],
      },
      footer: {
        style: "dark",
        links: [
          {
            title: "Docs",
            items: [
              {
                label: "Tutorial",
                to: "/docs/intro",
              },
              {
                label: "RFCs",
                href: "https://github.com/nervosnetwork/rfcs",
              },
            ],
          },
          {
            title: "More",
            items: [
              {
                label: "CKB",
                href: "https://github.com/nervosnetwork/ckb",
              },
              {
                label: "GitHub",
                href: "https://github.com/nervosnetwork/lumos",
              },
            ],
          },
        ],
        // copyright: `Copyright © ${new Date().getFullYear()} Lumos, Inc. Built with Docusaurus.`,
      },
      prism: {
        theme: lightCodeTheme,
        darkTheme: darkCodeTheme,
      },
    }),
  i18n: {
    defaultLocale: 'en',
    locales: ['en', 'zh'],
    localeConfigs: {
      en: {
        label: 'English',
        direction: 'ltr',
        htmlLang: 'en-US',
      },
      zh: {
        label: '中文',
        direction: 'ltr',
        htmlLang: 'zh-CH',
      },
    },
  },
};

module.exports = config;

'''
'''--- docusaurus/website/i18n/zh/code.json ---
{
  "theme.ErrorPageContent.title": {
    "message": "页面已崩溃。",
    "description": "The title of the fallback page when the page crashed"
  },
  "theme.ErrorPageContent.tryAgain": {
    "message": "重试",
    "description": "The label of the button to try again when the page crashed"
  },
  "theme.NotFound.title": {
    "message": "找不到页面",
    "description": "The title of the 404 page"
  },
  "theme.NotFound.p1": {
    "message": "我们找不到您要找的页面。",
    "description": "The first paragraph of the 404 page"
  },
  "theme.NotFound.p2": {
    "message": "请联系原始链接来源网站的所有者，并告知他们链接已损坏。",
    "description": "The 2nd paragraph of the 404 page"
  },
  "theme.BackToTopButton.buttonAriaLabel": {
    "message": "回到顶部",
    "description": "The ARIA label for the back to top button"
  },
  "theme.AnnouncementBar.closeButtonAriaLabel": {
    "message": "关闭",
    "description": "The ARIA label for close button of announcement bar"
  },
  "theme.blog.archive.title": {
    "message": "历史博文",
    "description": "The page & hero title of the blog archive page"
  },
  "theme.blog.archive.description": {
    "message": "历史博文",
    "description": "The page & hero description of the blog archive page"
  },
  "theme.blog.paginator.navAriaLabel": {
    "message": "博文列表分页导航",
    "description": "The ARIA label for the blog pagination"
  },
  "theme.blog.paginator.newerEntries": {
    "message": "较新的博文",
    "description": "The label used to navigate to the newer blog posts page (previous page)"
  },
  "theme.blog.paginator.olderEntries": {
    "message": "较旧的博文",
    "description": "The label used to navigate to the older blog posts page (next page)"
  },
  "theme.blog.post.readingTime.plurals": {
    "message": "{readingTime} 分钟阅读",
    "description": "Pluralized label for \"{readingTime} min read\". Use as much plural forms (separated by \"|\") as your language support (see https://www.unicode.org/cldr/cldr-aux/charts/34/supplemental/language_plural_rules.html)"
  },
  "theme.blog.post.readMore": {
    "message": "阅读更多",
    "description": "The label used in blog post item excerpts to link to full blog posts"
  },
  "theme.blog.post.paginator.navAriaLabel": {
    "message": "博文分页导航",
    "description": "The ARIA label for the blog posts pagination"
  },
  "theme.blog.post.paginator.newerPost": {
    "message": "较新一篇",
    "description": "The blog post button label to navigate to the newer/previous post"
  },
  "theme.blog.post.paginator.olderPost": {
    "message": "较旧一篇",
    "description": "The blog post button label to navigate to the older/next post"
  },
  "theme.blog.sidebar.navAriaLabel": {
    "message": "最近博文导航",
    "description": "The ARIA label for recent posts in the blog sidebar"
  },
  "theme.blog.post.plurals": {
    "message": "{count} 篇博文",
    "description": "Pluralized label for \"{count} posts\". Use as much plural forms (separated by \"|\") as your language support (see https://www.unicode.org/cldr/cldr-aux/charts/34/supplemental/language_plural_rules.html)"
  },
  "theme.blog.tagTitle": {
    "message": "{nPosts} 含有标签「{tagName}」",
    "description": "The title of the page for a blog tag"
  },
  "theme.tags.tagsPageLink": {
    "message": "查看所有标签",
    "description": "The label of the link targeting the tag list page"
  },
  "theme.CodeBlock.copyButtonAriaLabel": {
    "message": "复制代码到剪贴板",
    "description": "The ARIA label for copy code blocks button"
  },
  "theme.CodeBlock.copied": {
    "message": "复制成功",
    "description": "The copied button label on code blocks"
  },
  "theme.CodeBlock.copy": {
    "message": "复制",
    "description": "The copy button label on code blocks"
  },
  "theme.docs.sidebar.expandButtonTitle": {
    "message": "展开侧边栏",
    "description": "The ARIA label and title attribute for expand button of doc sidebar"
  },
  "theme.docs.sidebar.expandButtonAriaLabel": {
    "message": "展开侧边栏",
    "description": "The ARIA label and title attribute for expand button of doc sidebar"
  },
  "theme.docs.paginator.navAriaLabel": {
    "message": "文档分页导航",
    "description": "The ARIA label for the docs pagination"
  },
  "theme.docs.paginator.previous": {
    "message": "上一页",
    "description": "The label used to navigate to the previous doc"
  },
  "theme.docs.paginator.next": {
    "message": "下一页",
    "description": "The label used to navigate to the next doc"
  },
  "theme.docs.sidebar.collapseButtonTitle": {
    "message": "收起侧边栏",
    "description": "The title attribute for collapse button of doc sidebar"
  },
  "theme.docs.sidebar.collapseButtonAriaLabel": {
    "message": "收起侧边栏",
    "description": "The title attribute for collapse button of doc sidebar"
  },
  "theme.DocSidebarItem.toggleCollapsedCategoryAriaLabel": {
    "message": "打开/收起侧边栏菜单「{label}」",
    "description": "The ARIA label to toggle the collapsible sidebar category"
  },
  "theme.docs.tagDocListPageTitle.nDocsTagged": {
    "message": "{count} 篇文档带有标签",
    "description": "Pluralized label for \"{count} docs tagged\". Use as much plural forms (separated by \"|\") as your language support (see https://www.unicode.org/cldr/cldr-aux/charts/34/supplemental/language_plural_rules.html)"
  },
  "theme.docs.tagDocListPageTitle": {
    "message": "{nDocsTagged} 篇带有标签「{tagName}」",
    "description": "The title of the page for a docs tag"
  },
  "theme.docs.versions.unreleasedVersionLabel": {
    "message": "此为 {siteTitle} {versionLabel} 版尚未发行的文档。",
    "description": "The label used to tell the user that he's browsing an unreleased doc version"
  },
  "theme.docs.versions.unmaintainedVersionLabel": {
    "message": "此为 {siteTitle} {versionLabel} 版的文档，现已不再积极维护。",
    "description": "The label used to tell the user that he's browsing an unmaintained doc version"
  },
  "theme.docs.versions.latestVersionSuggestionLabel": {
    "message": "最新的文档请参阅 {latestVersionLink} ({versionLabel})。",
    "description": "The label used to tell the user to check the latest version"
  },
  "theme.docs.versions.latestVersionLinkLabel": {
    "message": "最新版本",
    "description": "The label used for the latest version suggestion link label"
  },
  "theme.common.editThisPage": {
    "message": "编辑此页",
    "description": "The link label to edit the current page"
  },
  "theme.common.headingLinkTitle": {
    "message": "标题的直接链接",
    "description": "Title for link to heading"
  },
  "theme.lastUpdated.atDate": {
    "message": "于 {date} ",
    "description": "The words used to describe on which date a page has been last updated"
  },
  "theme.lastUpdated.byUser": {
    "message": "由 {user} ",
    "description": "The words used to describe by who the page has been last updated"
  },
  "theme.lastUpdated.lastUpdatedAtBy": {
    "message": "最后{byUser}{atDate}更新",
    "description": "The sentence used to display when a page has been last updated, and by who"
  },
  "theme.navbar.mobileSidebarSecondaryMenu.backButtonLabel": {
    "message": "← 回到主菜单",
    "description": "The label of the back button to return to main menu, inside the mobile navbar sidebar secondary menu (notably used to display the docs sidebar)"
  },
  "theme.navbar.mobileVersionsDropdown.label": {
    "message": "选择版本",
    "description": "The label for the navbar versions dropdown on mobile view"
  },
  "theme.common.skipToMainContent": {
    "message": "跳到主要内容",
    "description": "The skip to content label used for accessibility, allowing to rapidly navigate to main content with keyboard tab/enter navigation"
  },
  "theme.TOCCollapsible.toggleButtonLabel": {
    "message": "本页总览",
    "description": "The label used by the button on the collapsible TOC component"
  },
  "theme.tags.tagsListLabel": {
    "message": "标签：",
    "description": "The label alongside a tag list"
  },
  "theme.tags.tagsPageTitle": {
    "message": "标签",
    "description": "The title of the tag list page"
  }
}

'''
'''--- docusaurus/website/i18n/zh/docusaurus-plugin-content-blog/options.json ---
{
  "title": {
    "message": "Blog",
    "description": "The title for the blog used in SEO"
  },
  "description": {
    "message": "Blog",
    "description": "The description for the blog used in SEO"
  },
  "sidebar.title": {
    "message": "Recent posts",
    "description": "The label for the left sidebar"
  }
}

'''
'''--- docusaurus/website/i18n/zh/docusaurus-plugin-content-docs/current.json ---
{
  "version.label": {
    "message": "Next",
    "description": "The label for version current"
  }
}

'''
'''--- docusaurus/website/i18n/zh/docusaurus-plugin-content-docs/current/intro.md ---
---
sidebar_position: 1
---

# Tutorial

Lumos 是一个为了开发Nervos CKB dApp的工具库.

## Quick Start

```
yarn add @ckb-lumos/lumos
```

'''
'''--- docusaurus/website/i18n/zh/docusaurus-plugin-content-docs/current/run-lumos-on-web.md ---
---
sidebar_position: 2
---

# Now lumos can run on browser
### TL;DR

Lumos was originally run on NodeJS only. To run on browser, we replaced native indexer with ckb-indexer, added BI which is a big number library, and a series of other upgrades.

The following example of getting the balance will show you how to use lumos in your web project.

```shell
npm install @ckb-lumos/lumos
# yarn add @ckb-lumos/lumos
```

```jsx
import { Script, Indexer, BI } from "@ckb-lumos/lumos";

async function main(): Promise<BI> {
    const lock = { code_hash: '0x...', hash_type: 'type', args: '0x...' }
    const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
    const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";
    const indexer = new Indexer(CKB_INDEXER_URL, CKB_RPC_URL);
    const collector = indexer.collector({ lock });
    let balance: BI = BI.from(0);
    for await (const cell of collector.collect()) {
        balance = balance.add(cell.cell_output.capacity);
    }
    return balance;
}

main();
```
please refer to [ckb-indexer-collector example] (https://github.com/nervosnetwork/lumos/blob/develop/examples/ckb-indexer-collector.ts) for a complete example.

### ckb-indexer

Because `@ckb-lumos/indexer` and `@ckb-lumos/sql-indexer` need to start the database and compile the code locally, cannot be run on the web side, we removed them and introduced `@ckb-lumos/ckb-indexer`. Examples of how to use`@ckb-lumos/ckb-indexer` are as follows.

```jsx
const { Indexer } = require("@ckb-lumos/ckb-indexer");
const nodeUri = "https://testnet.ckb.dev/rpc";
const indexUri = "https://testnet.ckb.dev/indexer";
const indexer = new Indexer(indexUri, nodeUri);
```

For a detailed tutorial, please refer to the [ckb-indexer User Guide](https://github.com/nervosnetwork/lumos/tree/develop/packages/ckb-indexer).

To migrate from `@ckb-lumos/indexer` to `@ckb-lumos/ckb-indexer`, please refer to the [migration documentation.] ([https://github.com/nervosnetwork/lumos/blob/develop/packages/ckb-indexer/mirgation.md](https://github.com/nervosnetwork/lumos/blob/develop/packages/ckb-indexer/mirgation.md))

### root package

There are multiple packages under the `@ckb-lumos` organization, such as `@ckb-lumos/helpers`, `@ckb-lumos/config`, etc. The user needs to refer to a separate package when using it. For example, to use `parseAddress` you need to refer to `@ckb-lumos/helpers`. To use `initializeConfig`, you need to refer to `@ckb-lumos/config`.

For your convenience, we have introduced the new `@ckb-lumos/lumos` package. All subpackages are included, so there is no need to introduce them one by one.

```jsx
import {
    Script,
    Indexer as CkbIndexer,
    helpers,
    config,
} from "@ckb-lumos/lumos";
config.initializeConfig(config.predefined.AGGRON4);
const address = "ckt1qyqxgftlqzmtv05cwcyl4xlz6ryx6dgsyrasjrp27t";
const lock: Script = helpers.parseAddress(address);
```

### BI big number library

In order to facilitate the calculation of large numbers, we provide the [large number library BI](https://github.com/nervosnetwork/lumos/tree/develop/packages/bi). You can convert strings, numbers, etc. to and from BI and perform some common operations.

```jsx
import { BI } from "@ckb-lumos/bi";

BI.from(1).add(1)
```

For more use of the API, please refer to [BI Test Cases].(https://github.com/nervosnetwork/lumos/blob/develop/packages/bi/tests/index.test.ts)

### More Updates

1. Migrate ckb-js-toolkit to @ckb-lumos/toolkit
    
    [ckb-js-toolkit](https://github.com/nervosnetwork/ckb-js-toolkit) is a tool to help ckb users develop `dapp`. It provides a set of standalone tools such as `reader`, `rpc`, etc., which have now been integrated into the `@ckb-lumos/toolkit` package. It has been maintained as part of `lumos`. 
    
2. Conversion of new addresses
    
    Lumos also supports ckb2021 upgraded [address](https://github.com/nervosnetwork/rfcs/pull/239/files), adding methods such as `encodeToAddress`. Refer to this [PR](https:/ /github.com/nervosnetwork/lumos/pull/205) for more.
    
3. Example code additions
    
    Added `secp256k1-transfer`, `secp256k1-multisig-transfer`, `pw-lock-metamask`, `omni-lock-metamask` and other sample code, please refer to [lumos/example](https:// [github.com/nervosnetwork/lumos/tree/develop/examples](http://github.com/nervosnetwork/lumos/tree/develop/examples))
    
4. Online tools
    
    The online tool supports interconversion between script and address. Visit the link [🔗](https://nervosnetwork.github.io/lumos/tools/address-conversion)
    
5. [lumos playground](https://codesandbox.io/s/objective-cloud-282i4?file=/src/index.js)
    
    We used codesandbox and `@ckb-lumos/lumos` to build the [playground](https://codesandbox.io/s/objective-cloud-282i4?file=/src/index.js) where you can quickly try out the features of lumos.
    
6. A contract deployment generator is provided in lumos to facilitate the deployment of contracts, visit the link [🔗](https://github.com/nervosnetwork/lumos/tree/develop/packages/common-) scripts#usage)

### Follow up plan

1. integrate [moleculec](https://github.com/nervosnetwork/molecule).
2. provide more tool functions to facilitate the manipulation of transaction structures.
3. Integrate [standalone debugger](https://github.com/nervosnetwork/ckb-standalone-debugger) to allow unit testing offline.
'''
'''--- docusaurus/website/i18n/zh/docusaurus-theme-classic/footer.json ---
{
  "link.title.Docs": {
    "message": "Docs",
    "description": "The title of the footer links column with title=Docs in the footer"
  },
  "link.title.More": {
    "message": "More",
    "description": "The title of the footer links column with title=More in the footer"
  },
  "link.item.label.Tutorial": {
    "message": "Tutorial",
    "description": "The label of footer link with label=Tutorial linking to /docs/intro"
  },
  "link.item.label.RFCs": {
    "message": "RFCs",
    "description": "The label of footer link with label=RFCs linking to https://github.com/nervosnetwork/rfcs"
  },
  "link.item.label.CKB": {
    "message": "CKB",
    "description": "The label of footer link with label=CKB linking to https://github.com/nervosnetwork/ckb"
  },
  "link.item.label.GitHub": {
    "message": "GitHub",
    "description": "The label of footer link with label=GitHub linking to https://github.com/nervosnetwork/lumos"
  }
}

'''
'''--- docusaurus/website/i18n/zh/docusaurus-theme-classic/navbar.json ---
{
  "title": {
    "message": "Lumos Docs",
    "description": "The title in the navbar"
  },
  "item.label.Docs": {
    "message": "Docs",
    "description": "Navbar item with label Docs"
  },
  "item.label.Tools": {
    "message": "Tools",
    "description": "Navbar item with label Tools"
  },
  "item.label.API": {
    "message": "API",
    "description": "Navbar item with label API"
  },
  "item.label.GitHub": {
    "message": "GitHub",
    "description": "Navbar item with label GitHub"
  }
}

'''
'''--- docusaurus/website/package.json ---
{
  "name": "docusaurus",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "docusaurus": "docusaurus",
    "start": "docusaurus start",
    "build": "docusaurus build",
    "swizzle": "docusaurus swizzle",
    "deploy": "docusaurus deploy",
    "clear": "docusaurus clear",
    "serve": "docusaurus serve",
    "write-translations": "docusaurus write-translations",
    "write-heading-ids": "docusaurus write-heading-ids",
    "typecheck": "tsc"
  },
  "dependencies": {
    "@ckb-lumos/lumos": "0.18.0-rc5",
    "@docusaurus/core": "^2.0.0-beta.15",
    "@docusaurus/module-type-aliases": "^2.0.0-beta.15",
    "@docusaurus/preset-classic": "^2.0.0-beta.15",
    "@mdx-js/react": "^1.6.21",
    "clsx": "^1.1.1",
    "prism-react-renderer": "^1.2.1",
    "react": "^17.0.1",
    "react-dom": "^17.0.1"
  },
  "devDependencies": {
    "@tsconfig/docusaurus": "^1.0.4",
    "buffer": "^6.0.3",
    "typescript": "^4.5.2"
  },
  "browserslist": {
    "production": [
      ">0.5%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
'''
'''--- docusaurus/website/sidebars.js ---
/**
 * Creating a sidebar enables you to:
 - create an ordered group of docs
 - render a sidebar for each doc of that group
 - provide next/previous navigation

 The sidebars can be generated from the filesystem, or explicitly defined here.

 Create as many sidebars as you want.
 */

// @ts-check

/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */
const sidebars = {
  // By default, Docusaurus generates a sidebar from the docs folder structure
  tutorialSidebar: [{type: 'autogenerated', dirName: '.'}],

  // But you can create a sidebar manually
  /*
  tutorialSidebar: [
    {
      type: 'category',
      label: 'Tutorial',
      items: ['hello'],
    },
  ],
   */
};

module.exports = sidebars;

'''
'''--- docusaurus/website/src/components/HomepageFeatures.module.css ---
.features {
  display: flex;
  align-items: center;
  padding: 2rem 0;
  width: 100%;
}

.featureSvg {
  height: 200px;
  width: 200px;
}

'''
'''--- docusaurus/website/src/css/custom.css ---
/**
 * Any CSS included here will be global. The classic template
 * bundles Infima by default. Infima is a CSS framework designed to
 * work well for content-centric websites.
 */

/* You can override the default Infima variables here. */
:root {
  --ifm-color-primary: #25c2a0;
  --ifm-color-primary-dark: rgb(33, 175, 144);
  --ifm-color-primary-darker: rgb(31, 165, 136);
  --ifm-color-primary-darkest: rgb(26, 136, 112);
  --ifm-color-primary-light: rgb(70, 203, 174);
  --ifm-color-primary-lighter: rgb(102, 212, 189);
  --ifm-color-primary-lightest: rgb(146, 224, 208);
  --ifm-code-font-size: 95%;
}

.docusaurus-highlight-code-line {
  background-color: rgba(0, 0, 0, 0.1);
  display: block;
  margin: 0 calc(-1 * var(--ifm-pre-padding));
  padding: 0 var(--ifm-pre-padding);
}

html[data-theme='dark'] .docusaurus-highlight-code-line {
  background-color: rgba(0, 0, 0, 0.3);
}

'''
'''--- docusaurus/website/src/pages/index.module.css ---
/**
 * CSS files with the .module.css suffix will be treated as CSS modules
 * and scoped locally.
 */

.heroBanner {
  padding: 4rem 0;
  text-align: center;
  position: relative;
  overflow: hidden;
}

@media screen and (max-width: 966px) {
  .heroBanner {
    padding: 2rem;
  }
}

.buttons {
  display: flex;
  align-items: center;
  justify-content: center;
}

'''
'''--- docusaurus/website/src/pages/markdown-page.md ---
---
title: Markdown page example
---

# Markdown page example

You don't need React to write simple standalone pages.

'''
'''--- docusaurus/website/tsconfig.json ---
{
  // This file is not used in compilation. It is here just for a nice editor experience.
  "extends": "@tsconfig/docusaurus/tsconfig.json",
  "compilerOptions": {
    "baseUrl": "."
  }
}

'''
'''--- examples/README.md ---
# Lumos Examples

## Quick Start

### Build lumos

```sh
git clone https://github.com/nervosnetwork/lumos.git
cd lumos
yarn
yarn build
yarn build-release
```

### Check if the build is working

```
yarn ts-node examples/config-manager.ts
```

## Online Preview

Using [GitHubBox.com](https://codesandbox.io/docs/importing#using-githubboxcom), you can preview and interact with example code online through codesandbox.

For example:  
Change the GitHub URL: https://github.com/nervosnetwork/lumos/tree/develop/examples/omni-lock-metamask  
To: https://githubbox.com/nervosnetwork/lumos/tree/develop/examples/omni-lock-metamask

Note that due to the incompatibility of namiwallet and iframe, you need to open the result in a new window while opening [cardano-lock-namiwallet](https://github.com/nervosnetwork/lumos/tree/develop/examples/cardano-lock-namiwallet) with codesandbox.

'''
'''--- examples/cardano-lock-namiwallet/README.md ---
# Cardano lock NamiWallet

This is a simple example of how to interactive with CKB via [NamiWallet](https://github.com/Berry-Pool/nami-wallet).

The cardano lock is compiled from this [commit](https://github.com/nervosnetwork/ckb-production-scripts/tree/4b6f7ec2c3c29798ad56ed9ed513b9391ff7d60d).

## Deployment

- Aggron

| parameter   | value                                                                |
| ----------- | -------------------------------------------------------------------- |
| `code_hash` | `0x3625f5ccecdbb8edff6890db2225b0218d753b7932e144a41b0a77b1111c921b` |
| `hash_type` | `type`                                                               |
| `tx_hash`   | `0xadf72b5a58b18e3763ab9e7769e16ffcb222da07a2cae2b407a6ffc47a2d39ff` |
| `index`     | `0x0`                                                                |
| `dep_type`  | `code`                                                               |

## Reference

- [cardano lock spec](https://github.com/XuJiandong/docs-bank/blob/master/cardano_lock.md)

## Online Preview

Using [GitHubBox.com](https://codesandbox.io/docs/importing#using-githubboxcom), you can preview and interact with example code online through codesandbox.

Change the GitHub URL: https://github.com/nervosnetwork/lumos/tree/develop/examples/cardano-lock-namiwallet  
To: https://githubbox.com/nervosnetwork/lumos/tree/develop/examples/cardano-lock-namiwallet

Note that due to the incompatibility of namiwallet and iframe, you need to open the result in a new window:  
![codesandbox](./codesandbox.png)

'''
'''--- examples/cardano-lock-namiwallet/generated/cardano.d.ts ---
export interface CastToArrayBuffer {
  toArrayBuffer(): ArrayBuffer;
}

export type CanCastToArrayBuffer = ArrayBuffer | CastToArrayBuffer;

export interface CreateOptions {
  validate?: boolean;
}

export interface UnionType {
  type: string;
  value: any;
}

export type Byte64Type = CanCastToArrayBuffer;

export interface CardanoWitnessLockType {
  pubkey: Byte32Type;
  signature: Byte64Type;
  sig_structure: BytesType;
}

export type Uint32Type = CanCastToArrayBuffer;

export type Uint64Type = CanCastToArrayBuffer;

export type Uint128Type = CanCastToArrayBuffer;

export type Byte32Type = CanCastToArrayBuffer;

export type Uint256Type = CanCastToArrayBuffer;

export type BytesType = CanCastToArrayBuffer;

export type BytesVecType = BytesType[];

export type Byte32VecType = Byte32Type[];

export type ProposalShortIdType = CanCastToArrayBuffer;

export type UncleBlockVecType = UncleBlockType[];

export type TransactionVecType = TransactionType[];

export type ProposalShortIdVecType = ProposalShortIdType[];

export type CellDepVecType = CellDepType[];

export type CellInputVecType = CellInputType[];

export type CellOutputVecType = CellOutputType[];

export interface ScriptType {
  code_hash: Byte32Type;
  hash_type: CanCastToArrayBuffer;
  args: BytesType;
}

export interface OutPointType {
  tx_hash: Byte32Type;
  index: Uint32Type;
}

export interface CellInputType {
  since: Uint64Type;
  previous_output: OutPointType;
}

export interface CellOutputType {
  capacity: Uint64Type;
  lock: ScriptType;
  type_?: ScriptType;
}

export interface CellDepType {
  out_point: OutPointType;
  dep_type: CanCastToArrayBuffer;
}

export interface RawTransactionType {
  version: Uint32Type;
  cell_deps: CellDepVecType;
  header_deps: Byte32VecType;
  inputs: CellInputVecType;
  outputs: CellOutputVecType;
  outputs_data: BytesVecType;
}

export interface TransactionType {
  raw: RawTransactionType;
  witnesses: BytesVecType;
}

export interface RawHeaderType {
  version: Uint32Type;
  compact_target: Uint32Type;
  timestamp: Uint64Type;
  number: Uint64Type;
  epoch: Uint64Type;
  parent_hash: Byte32Type;
  transactions_root: Byte32Type;
  proposals_hash: Byte32Type;
  uncles_hash: Byte32Type;
  dao: Byte32Type;
}

export interface HeaderType {
  raw: RawHeaderType;
  nonce: Uint128Type;
}

export interface UncleBlockType {
  header: HeaderType;
  proposals: ProposalShortIdVecType;
}

export interface BlockType {
  header: HeaderType;
  uncles: UncleBlockVecType;
  transactions: TransactionVecType;
  proposals: ProposalShortIdVecType;
}

export interface CellbaseWitnessType {
  lock: ScriptType;
  message: BytesType;
}

export interface WitnessArgsType {
  lock?: BytesType;
  input_type?: BytesType;
  output_type?: BytesType;
}

export function SerializeByte64(value: CanCastToArrayBuffer): ArrayBuffer;
export class Byte64 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeCardanoWitnessLock(value: CardanoWitnessLockType): ArrayBuffer;
export class CardanoWitnessLock {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getPubkey(): Byte32;
  getSignature(): Byte64;
  getSigStructure(): Bytes;
}

export function SerializeUint32(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint32 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  toBigEndianUint32(): number;
  toLittleEndianUint32(): number;
  static size(): Number;
}

export function SerializeUint64(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint64 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeUint128(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint128 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeByte32(value: CanCastToArrayBuffer): ArrayBuffer;
export class Byte32 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeUint256(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint256 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeBytes(value: CanCastToArrayBuffer): ArrayBuffer;
export class Bytes {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  length(): number;
}

export function SerializeBytesOpt(value: CanCastToArrayBuffer | null): ArrayBuffer;
export class BytesOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  value(): Bytes;
  hasValue(): boolean;
}

export function SerializeBytesVec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class BytesVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Bytes;
  length(): number;
}

export function SerializeByte32Vec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class Byte32Vec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Byte32;
  length(): number;
}

export function SerializeScriptOpt(value: object | null): ArrayBuffer;
export class ScriptOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  value(): Script;
  hasValue(): boolean;
}

export function SerializeProposalShortId(value: CanCastToArrayBuffer): ArrayBuffer;
export class ProposalShortId {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeUncleBlockVec(value: Array<object>): ArrayBuffer;
export class UncleBlockVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): UncleBlock;
  length(): number;
}

export function SerializeTransactionVec(value: Array<object>): ArrayBuffer;
export class TransactionVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Transaction;
  length(): number;
}

export function SerializeProposalShortIdVec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class ProposalShortIdVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): ProposalShortId;
  length(): number;
}

export function SerializeCellDepVec(value: Array<object>): ArrayBuffer;
export class CellDepVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellDep;
  length(): number;
}

export function SerializeCellInputVec(value: Array<object>): ArrayBuffer;
export class CellInputVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellInput;
  length(): number;
}

export function SerializeCellOutputVec(value: Array<object>): ArrayBuffer;
export class CellOutputVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellOutput;
  length(): number;
}

export function SerializeScript(value: ScriptType): ArrayBuffer;
export class Script {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCodeHash(): Byte32;
  getHashType(): number;
  getArgs(): Bytes;
}

export function SerializeOutPoint(value: OutPointType): ArrayBuffer;
export class OutPoint {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getTxHash(): Byte32;
  getIndex(): Uint32;
}

export function SerializeCellInput(value: CellInputType): ArrayBuffer;
export class CellInput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getSince(): Uint64;
  getPreviousOutput(): OutPoint;
}

export function SerializeCellOutput(value: CellOutputType): ArrayBuffer;
export class CellOutput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCapacity(): Uint64;
  getLock(): Script;
  getType(): ScriptOpt;
}

export function SerializeCellDep(value: CellDepType): ArrayBuffer;
export class CellDep {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getOutPoint(): OutPoint;
  getDepType(): number;
}

export function SerializeRawTransaction(value: RawTransactionType): ArrayBuffer;
export class RawTransaction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getVersion(): Uint32;
  getCellDeps(): CellDepVec;
  getHeaderDeps(): Byte32Vec;
  getInputs(): CellInputVec;
  getOutputs(): CellOutputVec;
  getOutputsData(): BytesVec;
}

export function SerializeTransaction(value: TransactionType): ArrayBuffer;
export class Transaction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getRaw(): RawTransaction;
  getWitnesses(): BytesVec;
}

export function SerializeRawHeader(value: RawHeaderType): ArrayBuffer;
export class RawHeader {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getVersion(): Uint32;
  getCompactTarget(): Uint32;
  getTimestamp(): Uint64;
  getNumber(): Uint64;
  getEpoch(): Uint64;
  getParentHash(): Byte32;
  getTransactionsRoot(): Byte32;
  getProposalsHash(): Byte32;
  getUnclesHash(): Byte32;
  getDao(): Byte32;
}

export function SerializeHeader(value: HeaderType): ArrayBuffer;
export class Header {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getRaw(): RawHeader;
  getNonce(): Uint128;
}

export function SerializeUncleBlock(value: UncleBlockType): ArrayBuffer;
export class UncleBlock {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getProposals(): ProposalShortIdVec;
}

export function SerializeBlock(value: BlockType): ArrayBuffer;
export class Block {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getUncles(): UncleBlockVec;
  getTransactions(): TransactionVec;
  getProposals(): ProposalShortIdVec;
}

export function SerializeCellbaseWitness(value: CellbaseWitnessType): ArrayBuffer;
export class CellbaseWitness {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): Script;
  getMessage(): Bytes;
}

export function SerializeWitnessArgs(value: WitnessArgsType): ArrayBuffer;
export class WitnessArgs {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): BytesOpt;
  getInputType(): BytesOpt;
  getOutputType(): BytesOpt;
}

'''
'''--- examples/cardano-lock-namiwallet/generated/cardano.js ---
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScriptOpt = exports.Script = exports.RawTransaction = exports.RawHeader = exports.ProposalShortIdVec = exports.ProposalShortId = exports.OutPoint = exports.Header = exports.CellbaseWitness = exports.CellOutputVec = exports.CellOutput = exports.CellInputVec = exports.CellInput = exports.CellDepVec = exports.CellDep = exports.CardanoWitnessLock = exports.BytesVec = exports.BytesOpt = exports.Bytes = exports.Byte64 = exports.Byte32Vec = exports.Byte32 = exports.Block = void 0;
exports.SerializeBlock = SerializeBlock;
exports.SerializeByte32 = SerializeByte32;
exports.SerializeByte32Vec = SerializeByte32Vec;
exports.SerializeByte64 = SerializeByte64;
exports.SerializeBytes = SerializeBytes;
exports.SerializeBytesOpt = SerializeBytesOpt;
exports.SerializeBytesVec = SerializeBytesVec;
exports.SerializeCardanoWitnessLock = SerializeCardanoWitnessLock;
exports.SerializeCellDep = SerializeCellDep;
exports.SerializeCellDepVec = SerializeCellDepVec;
exports.SerializeCellInput = SerializeCellInput;
exports.SerializeCellInputVec = SerializeCellInputVec;
exports.SerializeCellOutput = SerializeCellOutput;
exports.SerializeCellOutputVec = SerializeCellOutputVec;
exports.SerializeCellbaseWitness = SerializeCellbaseWitness;
exports.SerializeHeader = SerializeHeader;
exports.SerializeOutPoint = SerializeOutPoint;
exports.SerializeProposalShortId = SerializeProposalShortId;
exports.SerializeProposalShortIdVec = SerializeProposalShortIdVec;
exports.SerializeRawHeader = SerializeRawHeader;
exports.SerializeRawTransaction = SerializeRawTransaction;
exports.SerializeScript = SerializeScript;
exports.SerializeScriptOpt = SerializeScriptOpt;
exports.SerializeTransaction = SerializeTransaction;
exports.SerializeTransactionVec = SerializeTransactionVec;
exports.SerializeUint128 = SerializeUint128;
exports.SerializeUint256 = SerializeUint256;
exports.SerializeUint32 = SerializeUint32;
exports.SerializeUint64 = SerializeUint64;
exports.SerializeUncleBlock = SerializeUncleBlock;
exports.SerializeUncleBlockVec = SerializeUncleBlockVec;
exports.SerializeWitnessArgs = SerializeWitnessArgs;
exports.WitnessArgs = exports.UncleBlockVec = exports.UncleBlock = exports.Uint64 = exports.Uint32 = exports.Uint256 = exports.Uint128 = exports.TransactionVec = exports.Transaction = void 0;

function dataLengthError(actual, required) {
  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);
}

function assertDataLength(actual, required) {
  if (actual !== required) {
    dataLengthError(actual, required);
  }
}

function assertArrayBuffer(reader) {
  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {
    reader = reader.toArrayBuffer();
  }

  if (!(reader instanceof ArrayBuffer)) {
    throw new Error("Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!");
  }

  return reader;
}

function verifyAndExtractOffsets(view, expectedFieldCount, compatible) {
  if (view.byteLength < 4) {
    dataLengthError(view.byteLength, ">4");
  }

  const requiredByteLength = view.getUint32(0, true);
  assertDataLength(view.byteLength, requiredByteLength);

  if (requiredByteLength === 4) {
    return [requiredByteLength];
  }

  if (requiredByteLength < 8) {
    dataLengthError(view.byteLength, ">8");
  }

  const firstOffset = view.getUint32(4, true);

  if (firstOffset % 4 !== 0 || firstOffset < 8) {
    throw new Error(`Invalid first offset: ${firstOffset}`);
  }

  const itemCount = firstOffset / 4 - 1;

  if (itemCount < expectedFieldCount) {
    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);
  } else if (!compatible && itemCount > expectedFieldCount) {
    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);
  }

  if (requiredByteLength < firstOffset) {
    throw new Error(`First offset is larger than byte length: ${firstOffset}`);
  }

  const offsets = [];

  for (let i = 0; i < itemCount; i++) {
    const start = 4 + i * 4;
    offsets.push(view.getUint32(start, true));
  }

  offsets.push(requiredByteLength);

  for (let i = 0; i < offsets.length - 1; i++) {
    if (offsets[i] > offsets[i + 1]) {
      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);
    }
  }

  return offsets;
}

function serializeTable(buffers) {
  const itemCount = buffers.length;
  let totalSize = 4 * (itemCount + 1);
  const offsets = [];

  for (let i = 0; i < itemCount; i++) {
    offsets.push(totalSize);
    totalSize += buffers[i].byteLength;
  }

  const buffer = new ArrayBuffer(totalSize);
  const array = new Uint8Array(buffer);
  const view = new DataView(buffer);
  view.setUint32(0, totalSize, true);

  for (let i = 0; i < itemCount; i++) {
    view.setUint32(4 + i * 4, offsets[i], true);
    array.set(new Uint8Array(buffers[i]), offsets[i]);
  }

  return buffer;
}

class Byte64 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 64);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 64;
  }

}

exports.Byte64 = Byte64;

function SerializeByte64(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 64);
  return buffer;
}

class CardanoWitnessLock {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new Byte64(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
  }

  getPubkey() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Byte32(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getSignature() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Byte64(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getSigStructure() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new Bytes(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.CardanoWitnessLock = CardanoWitnessLock;

function SerializeCardanoWitnessLock(value) {
  const buffers = [];
  buffers.push(SerializeByte32(value.pubkey));
  buffers.push(SerializeByte64(value.signature));
  buffers.push(SerializeBytes(value.sig_structure));
  return serializeTable(buffers);
}

class Uint32 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 4);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  toBigEndianUint32() {
    return this.view.getUint32(0, false);
  }

  toLittleEndianUint32() {
    return this.view.getUint32(0, true);
  }

  static size() {
    return 4;
  }

}

exports.Uint32 = Uint32;

function SerializeUint32(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 4);
  return buffer;
}

class Uint64 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 8);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 8;
  }

}

exports.Uint64 = Uint64;

function SerializeUint64(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 8);
  return buffer;
}

class Uint128 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 16);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 16;
  }

}

exports.Uint128 = Uint128;

function SerializeUint128(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 16);
  return buffer;
}

class Byte32 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 32);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 32;
  }

}

exports.Byte32 = Byte32;

function SerializeByte32(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 32);
  return buffer;
}

class Uint256 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 32);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 32;
  }

}

exports.Uint256 = Uint256;

function SerializeUint256(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 32);
  return buffer;
}

class Bytes {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);
  }

  raw() {
    return this.view.buffer.slice(4);
  }

  indexAt(i) {
    return this.view.getUint8(4 + i);
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.Bytes = Bytes;

function SerializeBytes(value) {
  const item = assertArrayBuffer(value);
  const array = new Uint8Array(4 + item.byteLength);
  new DataView(array.buffer).setUint32(0, item.byteLength, true);
  array.set(new Uint8Array(item), 4);
  return array.buffer;
}

class BytesOpt {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.hasValue()) {
      this.value().validate(compatible);
    }
  }

  value() {
    return new Bytes(this.view.buffer, {
      validate: false
    });
  }

  hasValue() {
    return this.view.byteLength > 0;
  }

}

exports.BytesOpt = BytesOpt;

function SerializeBytesOpt(value) {
  if (value) {
    return SerializeBytes(value);
  } else {
    return new ArrayBuffer(0);
  }
}

class BytesVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new Bytes(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.BytesVec = BytesVec;

function SerializeBytesVec(value) {
  return serializeTable(value.map(item => SerializeBytes(item)));
}

class Byte32Vec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * Byte32.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.Byte32Vec = Byte32Vec;

function SerializeByte32Vec(value) {
  const array = new Uint8Array(4 + Byte32.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeByte32(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());
  }

  return array.buffer;
}

class ScriptOpt {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.hasValue()) {
      this.value().validate(compatible);
    }
  }

  value() {
    return new Script(this.view.buffer, {
      validate: false
    });
  }

  hasValue() {
    return this.view.byteLength > 0;
  }

}

exports.ScriptOpt = ScriptOpt;

function SerializeScriptOpt(value) {
  if (value) {
    return SerializeScript(value);
  } else {
    return new ArrayBuffer(0);
  }
}

class ProposalShortId {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 10);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 10;
  }

}

exports.ProposalShortId = ProposalShortId;

function SerializeProposalShortId(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 10);
  return buffer;
}

class UncleBlockVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new UncleBlock(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.UncleBlockVec = UncleBlockVec;

function SerializeUncleBlockVec(value) {
  return serializeTable(value.map(item => SerializeUncleBlock(item)));
}

class TransactionVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new Transaction(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.TransactionVec = TransactionVec;

function SerializeTransactionVec(value) {
  return serializeTable(value.map(item => SerializeTransaction(item)));
}

class ProposalShortIdVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * ProposalShortId.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new ProposalShortId(this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.ProposalShortIdVec = ProposalShortIdVec;

function SerializeProposalShortIdVec(value) {
  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeProposalShortId(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());
  }

  return array.buffer;
}

class CellDepVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * CellDep.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.CellDepVec = CellDepVec;

function SerializeCellDepVec(value) {
  const array = new Uint8Array(4 + CellDep.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeCellDep(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());
  }

  return array.buffer;
}

class CellInputVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * CellInput.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.CellInputVec = CellInputVec;

function SerializeCellInputVec(value) {
  const array = new Uint8Array(4 + CellInput.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeCellInput(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());
  }

  return array.buffer;
}

class CellOutputVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new CellOutput(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.CellOutputVec = CellOutputVec;

function SerializeCellOutputVec(value) {
  return serializeTable(value.map(item => SerializeCellOutput(item)));
}

class Script {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();

    if (offsets[2] - offsets[1] !== 1) {
      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);
    }

    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
  }

  getCodeHash() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Byte32(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getHashType() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);
  }

  getArgs() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new Bytes(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.Script = Script;

function SerializeScript(value) {
  const buffers = [];
  buffers.push(SerializeByte32(value.code_hash));
  const hashTypeView = new DataView(new ArrayBuffer(1));
  hashTypeView.setUint8(0, value.hash_type);
  buffers.push(hashTypeView.buffer);
  buffers.push(SerializeBytes(value.args));
  return serializeTable(buffers);
}

class OutPoint {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getTxHash() {
    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
      validate: false
    });
  }

  getIndex() {
    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {
      validate: false
    });
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, OutPoint.size());
    this.getTxHash().validate(compatible);
    this.getIndex().validate(compatible);
  }

  static size() {
    return 0 + Byte32.size() + Uint32.size();
  }

}

exports.OutPoint = OutPoint;

function SerializeOutPoint(value) {
  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);
  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());
  return array.buffer;
}

class CellInput {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getSince() {
    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), {
      validate: false
    });
  }

  getPreviousOutput() {
    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {
      validate: false
    });
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, CellInput.size());
    this.getSince().validate(compatible);
    this.getPreviousOutput().validate(compatible);
  }

  static size() {
    return 0 + Uint64.size() + OutPoint.size();
  }

}

exports.CellInput = CellInput;

function SerializeCellInput(value) {
  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeUint64(value.since)), 0);
  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());
  return array.buffer;
}

class CellOutput {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new Script(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
  }

  getCapacity() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Uint64(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getLock() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Script(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getType() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.CellOutput = CellOutput;

function SerializeCellOutput(value) {
  const buffers = [];
  buffers.push(SerializeUint64(value.capacity));
  buffers.push(SerializeScript(value.lock));
  buffers.push(SerializeScriptOpt(value.type_));
  return serializeTable(buffers);
}

class CellDep {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getOutPoint() {
    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), {
      validate: false
    });
  }

  getDepType() {
    return this.view.getUint8(0 + OutPoint.size());
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, CellDep.size());
    this.getOutPoint().validate(compatible);
  }

  static size() {
    return 0 + OutPoint.size() + 1;
  }

}

exports.CellDep = CellDep;

function SerializeCellDep(value) {
  const array = new Uint8Array(0 + OutPoint.size() + 1);
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);
  view.setUint8(0 + OutPoint.size(), value.dep_type);
  return array.buffer;
}

class RawTransaction {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), {
      validate: false
    }).validate();
    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), {
      validate: false
    }).validate();
    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), {
      validate: false
    }).validate();
  }

  getVersion() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Uint32(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getCellDeps() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new CellDepVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getHeaderDeps() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getInputs() {
    const start = 16;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new CellInputVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getOutputs() {
    const start = 20;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getOutputsData() {
    const start = 24;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.RawTransaction = RawTransaction;

function SerializeRawTransaction(value) {
  const buffers = [];
  buffers.push(SerializeUint32(value.version));
  buffers.push(SerializeCellDepVec(value.cell_deps));
  buffers.push(SerializeByte32Vec(value.header_deps));
  buffers.push(SerializeCellInputVec(value.inputs));
  buffers.push(SerializeCellOutputVec(value.outputs));
  buffers.push(SerializeBytesVec(value.outputs_data));
  return serializeTable(buffers);
}

class Transaction {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getRaw() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new RawTransaction(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getWitnesses() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.Transaction = Transaction;

function SerializeTransaction(value) {
  const buffers = [];
  buffers.push(SerializeRawTransaction(value.raw));
  buffers.push(SerializeBytesVec(value.witnesses));
  return serializeTable(buffers);
}

class RawHeader {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getVersion() {
    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {
      validate: false
    });
  }

  getCompactTarget() {
    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {
      validate: false
    });
  }

  getTimestamp() {
    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()), {
      validate: false
    });
  }

  getNumber() {
    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size()), {
      validate: false
    });
  }

  getEpoch() {
    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size()), {
      validate: false
    });
  }

  getParentHash() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size()), {
      validate: false
    });
  }

  getTransactionsRoot() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size()), {
      validate: false
    });
  }

  getProposalsHash() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size()), {
      validate: false
    });
  }

  getUnclesHash() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), {
      validate: false
    });
  }

  getDao() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), {
      validate: false
    });
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, RawHeader.size());
    this.getVersion().validate(compatible);
    this.getCompactTarget().validate(compatible);
    this.getTimestamp().validate(compatible);
    this.getNumber().validate(compatible);
    this.getEpoch().validate(compatible);
    this.getParentHash().validate(compatible);
    this.getTransactionsRoot().validate(compatible);
    this.getProposalsHash().validate(compatible);
    this.getUnclesHash().validate(compatible);
    this.getDao().validate(compatible);
  }

  static size() {
    return 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size();
  }

}

exports.RawHeader = RawHeader;

function SerializeRawHeader(value) {
  const array = new Uint8Array(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeUint32(value.version)), 0);
  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());
  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());
  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());
  array.set(new Uint8Array(SerializeUint64(value.epoch)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size());
  array.set(new Uint8Array(SerializeByte32(value.parent_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size());
  array.set(new Uint8Array(SerializeByte32(value.transactions_root)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size());
  array.set(new Uint8Array(SerializeByte32(value.proposals_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size());
  array.set(new Uint8Array(SerializeByte32(value.uncles_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size());
  array.set(new Uint8Array(SerializeByte32(value.dao)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());
  return array.buffer;
}

class Header {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getRaw() {
    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), {
      validate: false
    });
  }

  getNonce() {
    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {
      validate: false
    });
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, Header.size());
    this.getRaw().validate(compatible);
    this.getNonce().validate(compatible);
  }

  static size() {
    return 0 + RawHeader.size() + Uint128.size();
  }

}

exports.Header = Header;

function SerializeHeader(value) {
  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);
  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());
  return array.buffer;
}

class UncleBlock {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getHeader() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Header(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getProposals() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.UncleBlock = UncleBlock;

function SerializeUncleBlock(value) {
  const buffers = [];
  buffers.push(SerializeHeader(value.header));
  buffers.push(SerializeProposalShortIdVec(value.proposals));
  return serializeTable(buffers);
}

class Block {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), {
      validate: false
    }).validate();
  }

  getHeader() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Header(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getUncles() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getTransactions() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new TransactionVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getProposals() {
    const start = 16;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.Block = Block;

function SerializeBlock(value) {
  const buffers = [];
  buffers.push(SerializeHeader(value.header));
  buffers.push(SerializeUncleBlockVec(value.uncles));
  buffers.push(SerializeTransactionVec(value.transactions));
  buffers.push(SerializeProposalShortIdVec(value.proposals));
  return serializeTable(buffers);
}

class CellbaseWitness {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Script(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getLock() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Script(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getMessage() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new Bytes(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.CellbaseWitness = CellbaseWitness;

function SerializeCellbaseWitness(value) {
  const buffers = [];
  buffers.push(SerializeScript(value.lock));
  buffers.push(SerializeBytes(value.message));
  return serializeTable(buffers);
}

class WitnessArgs {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
  }

  getLock() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getInputType() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getOutputType() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.WitnessArgs = WitnessArgs;

function SerializeWitnessArgs(value) {
  const buffers = [];
  buffers.push(SerializeBytesOpt(value.lock));
  buffers.push(SerializeBytesOpt(value.input_type));
  buffers.push(SerializeBytesOpt(value.output_type));
  return serializeTable(buffers);
}

'''
'''--- examples/cardano-lock-namiwallet/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumos with Cardano Lock</title>
</head>
<body>
    <div id="root"></div>
    <script src="index.tsx" type="module"></script>
</body>
</html>
'''
'''--- examples/cardano-lock-namiwallet/lib.ts ---
import { BI, Cell, config, core, helpers, Indexer, RPC, toolkit, utils, commons } from "@ckb-lumos/lumos";
import {
  COSESign1Builder,
  HeaderMap,
  Label,
  AlgorithmId,
  CBORValue,
  Headers,
  ProtectedHeaderMap,
  COSESign1,
  COSEKey,
  BigNum,
  Int,
} from "@emurgo/cardano-message-signing-asmjs";
import { SerializeCardanoWitnessLock } from "./generated/cardano";

export const CONFIG = config.createConfig({
  PREFIX: "ckt",
  SCRIPTS: {
    ...config.predefined.AGGRON4.SCRIPTS,
    CARDANO_LOCK: {
      CODE_HASH: "0x3625f5ccecdbb8edff6890db2225b0218d753b7932e144a41b0a77b1111c921b",
      HASH_TYPE: "type",
      TX_HASH: "0xadf72b5a58b18e3763ab9e7769e16ffcb222da07a2cae2b407a6ffc47a2d39ff",
      INDEX: "0x0",
      DEP_TYPE: "code",
    },
  },
});

config.initializeConfig(CONFIG);

const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";
const rpc = new RPC(CKB_RPC_URL);
const indexer = new Indexer(CKB_INDEXER_URL, CKB_RPC_URL);

export interface Cardano {
  nami: {
    enable: () => Promise<CIP30FullAPI>;
  };
}
export interface CIP30FullAPI {
  getUsedAddresses: () => Promise<string[]>;
  signData: (address: string, message: string) => Promise<{ signature: string; key: string }>;
}

declare global {
  interface Window {
    cardano: Cardano;
  }
}

export async function detectCardano(): Promise<Cardano> {
  const start = Date.now();
  while (true) {
    if (Date.now() - start > 5000) {
      throw new Error("It seems you dont have NamiWallet installed");
    }
    if (window.cardano) return window.cardano;
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
}

interface Options {
  from: string;
  to: string;
  amount: string;
  api: CIP30FullAPI;
  cardanoAddr: string;
}

export async function transfer(options: Options): Promise<string> {
  let tx = helpers.TransactionSkeleton({});
  const fromScript = helpers.parseAddress(options.from);
  const toScript = helpers.parseAddress(options.to);

  // additional 0.001 ckb for tx fee
  // the tx fee could calculated by tx size
  // this is just a simple example
  const neededCapacity = BI.from(options.amount).add("100000");
  let collectedSum = BI.from(0);
  const collectedCells: Cell[] = [];
  const collector = indexer.collector({ lock: fromScript, type: "empty" });
  for await (const cell of collector.collect()) {
    collectedSum = collectedSum.add(cell.cell_output.capacity);
    collectedCells.push(cell);
    if (BI.from(collectedSum).gte(neededCapacity)) break;
  }

  if (collectedSum.lt(neededCapacity)) {
    throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedSum} `);
  }

  const transferOutput: Cell = {
    cell_output: {
      capacity: BI.from(options.amount).toHexString(),
      lock: toScript,
    },
    data: "0x",
  };

  const changeOutput: Cell = {
    cell_output: {
      capacity: collectedSum.sub(neededCapacity).toHexString(),
      lock: fromScript,
    },
    data: "0x",
  };

  tx = tx.update("inputs", (inputs) => inputs.push(...collectedCells));
  tx = tx.update("outputs", (outputs) => outputs.push(transferOutput, changeOutput));
  tx = tx.update("cellDeps", (cellDeps) =>
    cellDeps.push({
      out_point: {
        tx_hash: CONFIG.SCRIPTS.CARDANO_LOCK.TX_HASH,
        index: CONFIG.SCRIPTS.CARDANO_LOCK.INDEX,
      },
      dep_type: CONFIG.SCRIPTS.CARDANO_LOCK.DEP_TYPE,
    })
  );

  const protectedHeaders = HeaderMap.new();
  protectedHeaders.set_algorithm_id(Label.from_algorithm_id(AlgorithmId.EdDSA));
  // protectedHeaders.set_key_id(publicKey.as_bytes());
  protectedHeaders.set_header(Label.new_text("address"), CBORValue.new_bytes(Buffer.from(options.cardanoAddr, "hex")));
  const protectedSerialized = ProtectedHeaderMap.new(protectedHeaders);
  const unprotectedHeaders = HeaderMap.new();
  const headers = Headers.new(protectedSerialized, unprotectedHeaders);

  const payload = "00".repeat(32);
  let builder = COSESign1Builder.new(headers, Buffer.from(payload, "hex"), false);
  let toSign = builder.make_data_to_sign().to_bytes();

  const placeHolder = new toolkit.Reader(
    "0x" +
      "00".repeat(
        SerializeCardanoWitnessLock({
          pubkey: new toolkit.Reader("0x" + "00".repeat(32)).toArrayBuffer(),
          signature: new toolkit.Reader("0x" + "00".repeat(64)).toArrayBuffer(),
          sig_structure: toSign.buffer,
        }).byteLength
      )
  );

  const tmpWitnessArgs = core.SerializeWitnessArgs(toolkit.normalizers.NormalizeWitnessArgs({ lock: placeHolder }));
  const witness = new toolkit.Reader(tmpWitnessArgs).serializeJson();

  for (let i = 0; i < tx.inputs.toArray().length; i++) {
    tx = tx.update("witnesses", (witnesses) => witnesses.push(witness));
  }

  const signLock = tx.inputs.get(0)?.cell_output.lock!;
  const messageGroup = commons.createP2PKHMessageGroup(tx, [signLock]);
  const messageForSigning = messageGroup[0].message.slice(2);

  builder = COSESign1Builder.new(headers, Buffer.from(messageForSigning, "hex"), false);
  toSign = builder.make_data_to_sign().to_bytes(); // sig_structure

  const signedRes = await options.api.signData(options.cardanoAddr, messageForSigning);
  const signedSignature = signedRes.signature;

  const COSESignature = COSESign1.from_bytes(Buffer.from(signedSignature, "hex"));

  const signedKey = COSEKey.from_bytes(Buffer.from(signedRes.key, "hex"));
  const label = Label.new_int(Int.new_negative(BigNum.from_str("2")));
  const CBORPubkey = signedKey.header(label)!;

  const signedWitnessArgs = new toolkit.Reader(
    SerializeCardanoWitnessLock({
      pubkey: CBORPubkey.as_bytes()!.buffer,
      signature: COSESignature.signature().buffer,
      sig_structure: toSign.buffer,
    })
  );

  const signedWitness = new toolkit.Reader(
    core.SerializeWitnessArgs(toolkit.normalizers.NormalizeWitnessArgs({ lock: signedWitnessArgs }))
  ).serializeJson();
  tx = tx.update("witnesses", (witnesses) => witnesses.set(0, signedWitness));

  const signedTx = helpers.createTransactionFromSkeleton(tx);
  const txHash = await rpc.send_transaction(signedTx, "passthrough");

  return txHash;
}

export async function capacityOf(address: string): Promise<BI> {
  const collector = indexer.collector({
    lock: helpers.parseAddress(address),
  });

  let balance = BI.from(0);
  for await (const cell of collector.collect()) {
    balance = balance.add(cell.cell_output.capacity);
  }

  return balance;
}

'''
'''--- examples/cardano-lock-namiwallet/package.json ---
{
  "private": true,
  "name": "@lumos-examples/cardano-lock-namiwallet",
  "version": "0.17.0-rc8",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "parcel index.html",
    "lint": "tsc --noEmit"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@types/react": "^17.0.34",
    "@types/react-dom": "^17.0.11",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "@ckb-lumos/lumos": "0.17.0-rc8",
    "@emurgo/cardano-serialization-lib-asmjs": "^10.0.4",
    "@emurgo/cardano-message-signing-asmjs": "^1.0.1"
  }
}

'''
'''--- examples/cardano-lock-namiwallet/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
      "lib": ["dom"],
      "jsx": "react"
  }
}

'''
'''--- examples/ckb-indexer-collector.ts ---
// This example shows how to use the CkbIndexer to collect cells

import { Script, Indexer as CkbIndexer, helpers, config, BI } from "@ckb-lumos/lumos";

config.initializeConfig(config.predefined.AGGRON4);

const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";
const indexer = new CkbIndexer(CKB_INDEXER_URL, CKB_RPC_URL);

async function capacityOf(lock: Script): Promise<BI> {
  const collector = indexer.collector({ lock });

  let balance: BI = BI.from(0);
  for await (const cell of collector.collect()) {
    balance = balance.add(cell.cell_output.capacity);
  }

  return balance;
}

async function main() {
  const address = "ckt1qyqxgftlqzmtv05cwcyl4xlz6ryx6dgsyrasjrp27t";
  const lock: Script = helpers.parseAddress(address);

  const balance = await capacityOf(lock);

  const integer = balance.div(BI.from(10).pow(8));
  const fraction = balance.mod(BI.from(10).pow(8));

  console.log(`lock of ${address} is`, lock, "\n");
  console.log(`total CKB of ${address} is ${integer + "." + fraction}`);
}

main();

'''
'''--- examples/config-manager.ts ---
import { config, helpers } from "@ckb-lumos/lumos";

const script = {
  code_hash: config.predefined.AGGRON4.SCRIPTS.SECP256K1_BLAKE160.CODE_HASH,
  hash_type: config.predefined.AGGRON4.SCRIPTS.SECP256K1_BLAKE160.HASH_TYPE,
  args: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
};

/* DEPRECATED: initialize config via env mainnet */
console.log("deprecated initialize", helpers.generateAddress(script));

/* initialize config via AGGRON testnet */
config.initializeConfig(config.predefined.AGGRON4);
console.log("testnet address is:", helpers.generateAddress(script));

/* initialize config via LINA testnet */
config.initializeConfig(config.predefined.LINA);
console.log("mainnet address is:", helpers.generateAddress(script));

'''
'''--- examples/omni-lock-metamask/README.md ---
# Lumos Works with MetaMask

Nervos maintains a powerful lock
called [Omni Lock](https://github.com/XuJiandong/docs-bank/blob/master/omni_lock.md) (previously named RC lock), which
can use MetaMask as a signer. This example will show how to use Lumos to send a transaction using Omni lock and MetaMask

## Quick Start

> we should [build](..) Lumos project first before we start this example

```
yarn run build
yarn run build-release
cd examples/omni-lock-metamask
yarn start
```

## Links

- [MetaMask](https://metamask.io/) - A crpto wallet
- [Nervos Faucet](https://faucet.nervos.org/) - Claim Nervos testnet CKB
- [Omni lock](https://github.com/XuJiandong/docs-bank/blob/master/omni_lock.md) - Omni lock intro

'''
'''--- examples/omni-lock-metamask/generated/omni.d.ts ---
export interface CastToArrayBuffer {
  toArrayBuffer(): ArrayBuffer;
}

export type CanCastToArrayBuffer = ArrayBuffer | CastToArrayBuffer;

export interface CreateOptions {
  validate?: boolean;
}

export interface UnionType {
  type: string;
  value: any;
}

export function SerializeIdentity(value: CanCastToArrayBuffer): ArrayBuffer;
export class Identity {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeRcIdentity(value: object): ArrayBuffer;
export class RcIdentity {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getIdentity(): Identity;
  getProofs(): SmtProofEntryVec;
}

export function SerializeRcIdentityOpt(value: object | null): ArrayBuffer;
export class RcIdentityOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  value(): RcIdentity;
  hasValue(): boolean;
}

export function SerializeRcLockWitnessLock(value: object): ArrayBuffer;
export class RcLockWitnessLock {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getSignature(): BytesOpt;
  getRcIdentity(): RcIdentityOpt;
  getPreimage(): BytesOpt;
}

export function SerializeScriptVec(value: Array<object>): ArrayBuffer;
export class ScriptVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Script;
  length(): number;
}

export function SerializeScriptVecOpt(value: Array<object> | null): ArrayBuffer;
export class ScriptVecOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  value(): ScriptVec;
  hasValue(): boolean;
}

export function SerializeXudtWitnessInput(value: object): ArrayBuffer;
export class XudtWitnessInput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getRawExtensionData(): ScriptVecOpt;
  getExtensionData(): BytesVec;
}

export function SerializeRCRule(value: object): ArrayBuffer;
export class RCRule {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getSmtRoot(): Byte32;
  getFlags(): number;
}

export function SerializeRCCellVec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class RCCellVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Byte32;
  length(): number;
}

export function SerializeRCData(value: UnionType): ArrayBuffer;
export class RCData {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  unionType(): string;
  value(): any;
}

export function SerializeSmtProof(value: CanCastToArrayBuffer): ArrayBuffer;
export class SmtProof {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  length(): number;
}

export function SerializeSmtProofEntry(value: object): ArrayBuffer;
export class SmtProofEntry {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getMask(): number;
  getProof(): SmtProof;
}

export function SerializeSmtProofEntryVec(value: Array<object>): ArrayBuffer;
export class SmtProofEntryVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): SmtProofEntry;
  length(): number;
}

export function SerializeSmtUpdateItem(value: object): ArrayBuffer;
export class SmtUpdateItem {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getKey(): Byte32;
  getPackedValues(): number;
}

export function SerializeSmtUpdateItemVec(value: Array<object>): ArrayBuffer;
export class SmtUpdateItemVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): SmtUpdateItem;
  length(): number;
}

export function SerializeSmtUpdateAction(value: object): ArrayBuffer;
export class SmtUpdateAction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getUpdates(): SmtUpdateItemVec;
  getProof(): SmtProof;
}

export function SerializeXudtData(value: object): ArrayBuffer;
export class XudtData {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): Bytes;
  getData(): BytesVec;
}

export function SerializeUint32(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint32 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  toBigEndianUint32(): number;
  toLittleEndianUint32(): number;
  static size(): Number;
}

export function SerializeUint64(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint64 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeUint128(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint128 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeByte32(value: CanCastToArrayBuffer): ArrayBuffer;
export class Byte32 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeUint256(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint256 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeBytes(value: CanCastToArrayBuffer): ArrayBuffer;
export class Bytes {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  length(): number;
}

export function SerializeBytesOpt(value: CanCastToArrayBuffer | null): ArrayBuffer;
export class BytesOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  value(): Bytes;
  hasValue(): boolean;
}

export function SerializeBytesVec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class BytesVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Bytes;
  length(): number;
}

export function SerializeByte32Vec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class Byte32Vec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Byte32;
  length(): number;
}

export function SerializeScriptOpt(value: object | null): ArrayBuffer;
export class ScriptOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  value(): Script;
  hasValue(): boolean;
}

export function SerializeProposalShortId(value: CanCastToArrayBuffer): ArrayBuffer;
export class ProposalShortId {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeUncleBlockVec(value: Array<object>): ArrayBuffer;
export class UncleBlockVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): UncleBlock;
  length(): number;
}

export function SerializeTransactionVec(value: Array<object>): ArrayBuffer;
export class TransactionVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Transaction;
  length(): number;
}

export function SerializeProposalShortIdVec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class ProposalShortIdVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): ProposalShortId;
  length(): number;
}

export function SerializeCellDepVec(value: Array<object>): ArrayBuffer;
export class CellDepVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellDep;
  length(): number;
}

export function SerializeCellInputVec(value: Array<object>): ArrayBuffer;
export class CellInputVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellInput;
  length(): number;
}

export function SerializeCellOutputVec(value: Array<object>): ArrayBuffer;
export class CellOutputVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellOutput;
  length(): number;
}

export function SerializeScript(value: object): ArrayBuffer;
export class Script {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCodeHash(): Byte32;
  getHashType(): number;
  getArgs(): Bytes;
}

export function SerializeOutPoint(value: object): ArrayBuffer;
export class OutPoint {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getTxHash(): Byte32;
  getIndex(): Uint32;
}

export function SerializeCellInput(value: object): ArrayBuffer;
export class CellInput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getSince(): Uint64;
  getPreviousOutput(): OutPoint;
}

export function SerializeCellOutput(value: object): ArrayBuffer;
export class CellOutput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCapacity(): Uint64;
  getLock(): Script;
  getType(): ScriptOpt;
}

export function SerializeCellDep(value: object): ArrayBuffer;
export class CellDep {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getOutPoint(): OutPoint;
  getDepType(): number;
}

export function SerializeRawTransaction(value: object): ArrayBuffer;
export class RawTransaction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getVersion(): Uint32;
  getCellDeps(): CellDepVec;
  getHeaderDeps(): Byte32Vec;
  getInputs(): CellInputVec;
  getOutputs(): CellOutputVec;
  getOutputsData(): BytesVec;
}

export function SerializeTransaction(value: object): ArrayBuffer;
export class Transaction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getRaw(): RawTransaction;
  getWitnesses(): BytesVec;
}

export function SerializeRawHeader(value: object): ArrayBuffer;
export class RawHeader {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getVersion(): Uint32;
  getCompactTarget(): Uint32;
  getTimestamp(): Uint64;
  getNumber(): Uint64;
  getEpoch(): Uint64;
  getParentHash(): Byte32;
  getTransactionsRoot(): Byte32;
  getProposalsHash(): Byte32;
  getUnclesHash(): Byte32;
  getDao(): Byte32;
}

export function SerializeHeader(value: object): ArrayBuffer;
export class Header {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getRaw(): RawHeader;
  getNonce(): Uint128;
}

export function SerializeUncleBlock(value: object): ArrayBuffer;
export class UncleBlock {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getProposals(): ProposalShortIdVec;
}

export function SerializeBlock(value: object): ArrayBuffer;
export class Block {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getUncles(): UncleBlockVec;
  getTransactions(): TransactionVec;
  getProposals(): ProposalShortIdVec;
}

export function SerializeCellbaseWitness(value: object): ArrayBuffer;
export class CellbaseWitness {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): Script;
  getMessage(): Bytes;
}

export function SerializeWitnessArgs(value: object): ArrayBuffer;
export class WitnessArgs {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): BytesOpt;
  getInputType(): BytesOpt;
  getOutputType(): BytesOpt;
}

'''
'''--- examples/omni-lock-metamask/generated/omni.js ---
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScriptVecOpt = exports.ScriptVec = exports.ScriptOpt = exports.Script = exports.RcLockWitnessLock = exports.RcIdentityOpt = exports.RcIdentity = exports.RawTransaction = exports.RawHeader = exports.RCRule = exports.RCData = exports.RCCellVec = exports.ProposalShortIdVec = exports.ProposalShortId = exports.OutPoint = exports.Identity = exports.Header = exports.CellbaseWitness = exports.CellOutputVec = exports.CellOutput = exports.CellInputVec = exports.CellInput = exports.CellDepVec = exports.CellDep = exports.BytesVec = exports.BytesOpt = exports.Bytes = exports.Byte32Vec = exports.Byte32 = exports.Block = void 0;
exports.SerializeBlock = SerializeBlock;
exports.SerializeByte32 = SerializeByte32;
exports.SerializeByte32Vec = SerializeByte32Vec;
exports.SerializeBytes = SerializeBytes;
exports.SerializeBytesOpt = SerializeBytesOpt;
exports.SerializeBytesVec = SerializeBytesVec;
exports.SerializeCellDep = SerializeCellDep;
exports.SerializeCellDepVec = SerializeCellDepVec;
exports.SerializeCellInput = SerializeCellInput;
exports.SerializeCellInputVec = SerializeCellInputVec;
exports.SerializeCellOutput = SerializeCellOutput;
exports.SerializeCellOutputVec = SerializeCellOutputVec;
exports.SerializeCellbaseWitness = SerializeCellbaseWitness;
exports.SerializeHeader = SerializeHeader;
exports.SerializeIdentity = SerializeIdentity;
exports.SerializeOutPoint = SerializeOutPoint;
exports.SerializeProposalShortId = SerializeProposalShortId;
exports.SerializeProposalShortIdVec = SerializeProposalShortIdVec;
exports.SerializeRCCellVec = SerializeRCCellVec;
exports.SerializeRCData = SerializeRCData;
exports.SerializeRCRule = SerializeRCRule;
exports.SerializeRawHeader = SerializeRawHeader;
exports.SerializeRawTransaction = SerializeRawTransaction;
exports.SerializeRcIdentity = SerializeRcIdentity;
exports.SerializeRcIdentityOpt = SerializeRcIdentityOpt;
exports.SerializeRcLockWitnessLock = SerializeRcLockWitnessLock;
exports.SerializeScript = SerializeScript;
exports.SerializeScriptOpt = SerializeScriptOpt;
exports.SerializeScriptVec = SerializeScriptVec;
exports.SerializeScriptVecOpt = SerializeScriptVecOpt;
exports.SerializeSmtProof = SerializeSmtProof;
exports.SerializeSmtProofEntry = SerializeSmtProofEntry;
exports.SerializeSmtProofEntryVec = SerializeSmtProofEntryVec;
exports.SerializeSmtUpdateAction = SerializeSmtUpdateAction;
exports.SerializeSmtUpdateItem = SerializeSmtUpdateItem;
exports.SerializeSmtUpdateItemVec = SerializeSmtUpdateItemVec;
exports.SerializeTransaction = SerializeTransaction;
exports.SerializeTransactionVec = SerializeTransactionVec;
exports.SerializeUint128 = SerializeUint128;
exports.SerializeUint256 = SerializeUint256;
exports.SerializeUint32 = SerializeUint32;
exports.SerializeUint64 = SerializeUint64;
exports.SerializeUncleBlock = SerializeUncleBlock;
exports.SerializeUncleBlockVec = SerializeUncleBlockVec;
exports.SerializeWitnessArgs = SerializeWitnessArgs;
exports.SerializeXudtData = SerializeXudtData;
exports.SerializeXudtWitnessInput = SerializeXudtWitnessInput;
exports.XudtWitnessInput = exports.XudtData = exports.WitnessArgs = exports.UncleBlockVec = exports.UncleBlock = exports.Uint64 = exports.Uint32 = exports.Uint256 = exports.Uint128 = exports.TransactionVec = exports.Transaction = exports.SmtUpdateItemVec = exports.SmtUpdateItem = exports.SmtUpdateAction = exports.SmtProofEntryVec = exports.SmtProofEntry = exports.SmtProof = void 0;

function dataLengthError(actual, required) {
  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);
}

function assertDataLength(actual, required) {
  if (actual !== required) {
    dataLengthError(actual, required);
  }
}

function assertArrayBuffer(reader) {
  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {
    reader = reader.toArrayBuffer();
  }

  if (!(reader instanceof ArrayBuffer)) {
    throw new Error("Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!");
  }

  return reader;
}

function verifyAndExtractOffsets(view, expectedFieldCount, compatible) {
  if (view.byteLength < 4) {
    dataLengthError(view.byteLength, ">4");
  }

  const requiredByteLength = view.getUint32(0, true);
  assertDataLength(view.byteLength, requiredByteLength);

  if (requiredByteLength === 4) {
    return [requiredByteLength];
  }

  if (requiredByteLength < 8) {
    dataLengthError(view.byteLength, ">8");
  }

  const firstOffset = view.getUint32(4, true);

  if (firstOffset % 4 !== 0 || firstOffset < 8) {
    throw new Error(`Invalid first offset: ${firstOffset}`);
  }

  const itemCount = firstOffset / 4 - 1;

  if (itemCount < expectedFieldCount) {
    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);
  } else if (!compatible && itemCount > expectedFieldCount) {
    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);
  }

  if (requiredByteLength < firstOffset) {
    throw new Error(`First offset is larger than byte length: ${firstOffset}`);
  }

  const offsets = [];

  for (let i = 0; i < itemCount; i++) {
    const start = 4 + i * 4;
    offsets.push(view.getUint32(start, true));
  }

  offsets.push(requiredByteLength);

  for (let i = 0; i < offsets.length - 1; i++) {
    if (offsets[i] > offsets[i + 1]) {
      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);
    }
  }

  return offsets;
}

function serializeTable(buffers) {
  const itemCount = buffers.length;
  let totalSize = 4 * (itemCount + 1);
  const offsets = [];

  for (let i = 0; i < itemCount; i++) {
    offsets.push(totalSize);
    totalSize += buffers[i].byteLength;
  }

  const buffer = new ArrayBuffer(totalSize);
  const array = new Uint8Array(buffer);
  const view = new DataView(buffer);
  view.setUint32(0, totalSize, true);

  for (let i = 0; i < itemCount; i++) {
    view.setUint32(4 + i * 4, offsets[i], true);
    array.set(new Uint8Array(buffers[i]), offsets[i]);
  }

  return buffer;
}

class Identity {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 21);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 21;
  }

}

exports.Identity = Identity;

function SerializeIdentity(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 21);
  return buffer;
}

class RcIdentity {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Identity(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new SmtProofEntryVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getIdentity() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Identity(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getProofs() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new SmtProofEntryVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.RcIdentity = RcIdentity;

function SerializeRcIdentity(value) {
  const buffers = [];
  buffers.push(SerializeIdentity(value.identity));
  buffers.push(SerializeSmtProofEntryVec(value.proofs));
  return serializeTable(buffers);
}

class RcIdentityOpt {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.hasValue()) {
      this.value().validate(compatible);
    }
  }

  value() {
    return new RcIdentity(this.view.buffer, {
      validate: false
    });
  }

  hasValue() {
    return this.view.byteLength > 0;
  }

}

exports.RcIdentityOpt = RcIdentityOpt;

function SerializeRcIdentityOpt(value) {
  if (value) {
    return SerializeRcIdentity(value);
  } else {
    return new ArrayBuffer(0);
  }
}

class RcLockWitnessLock {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new RcIdentityOpt(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
  }

  getSignature() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getRcIdentity() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new RcIdentityOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getPreimage() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.RcLockWitnessLock = RcLockWitnessLock;

function SerializeRcLockWitnessLock(value) {
  const buffers = [];
  buffers.push(SerializeBytesOpt(value.signature));
  buffers.push(SerializeRcIdentityOpt(value.rc_identity));
  buffers.push(SerializeBytesOpt(value.preimage));
  return serializeTable(buffers);
}

class ScriptVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new Script(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.ScriptVec = ScriptVec;

function SerializeScriptVec(value) {
  return serializeTable(value.map(item => SerializeScript(item)));
}

class ScriptVecOpt {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.hasValue()) {
      this.value().validate(compatible);
    }
  }

  value() {
    return new ScriptVec(this.view.buffer, {
      validate: false
    });
  }

  hasValue() {
    return this.view.byteLength > 0;
  }

}

exports.ScriptVecOpt = ScriptVecOpt;

function SerializeScriptVecOpt(value) {
  if (value) {
    return SerializeScriptVec(value);
  } else {
    return new ArrayBuffer(0);
  }
}

class XudtWitnessInput {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new ScriptVecOpt(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getRawExtensionData() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new ScriptVecOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getExtensionData() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.XudtWitnessInput = XudtWitnessInput;

function SerializeXudtWitnessInput(value) {
  const buffers = [];
  buffers.push(SerializeScriptVecOpt(value.raw_extension_data));
  buffers.push(SerializeBytesVec(value.extension_data));
  return serializeTable(buffers);
}

class RCRule {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getSmtRoot() {
    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
      validate: false
    });
  }

  getFlags() {
    return this.view.getUint8(0 + Byte32.size());
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, RCRule.size());
    this.getSmtRoot().validate(compatible);
  }

  static size() {
    return 0 + Byte32.size() + 1;
  }

}

exports.RCRule = RCRule;

function SerializeRCRule(value) {
  const array = new Uint8Array(0 + Byte32.size() + 1);
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeByte32(value.smt_root)), 0);
  view.setUint8(0 + Byte32.size(), value.flags);
  return array.buffer;
}

class RCCellVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * Byte32.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.RCCellVec = RCCellVec;

function SerializeRCCellVec(value) {
  const array = new Uint8Array(4 + Byte32.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeByte32(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());
  }

  return array.buffer;
}

class RCData {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      assertDataLength(this.view.byteLength, ">4");
    }

    const t = this.view.getUint32(0, true);

    switch (t) {
      case 0:
        new RCRule(this.view.buffer.slice(4), {
          validate: false
        }).validate();
        break;

      case 1:
        new RCCellVec(this.view.buffer.slice(4), {
          validate: false
        }).validate();
        break;

      default:
        throw new Error(`Invalid type: ${t}`);
    }
  }

  unionType() {
    const t = this.view.getUint32(0, true);

    switch (t) {
      case 0:
        return "RCRule";

      case 1:
        return "RCCellVec";

      default:
        throw new Error(`Invalid type: ${t}`);
    }
  }

  value() {
    const t = this.view.getUint32(0, true);

    switch (t) {
      case 0:
        return new RCRule(this.view.buffer.slice(4), {
          validate: false
        });

      case 1:
        return new RCCellVec(this.view.buffer.slice(4), {
          validate: false
        });

      default:
        throw new Error(`Invalid type: ${t}`);
    }
  }

}

exports.RCData = RCData;

function SerializeRCData(value) {
  switch (value.type) {
    case "RCRule":
      {
        const itemBuffer = SerializeRCRule(value.value);
        const array = new Uint8Array(4 + itemBuffer.byteLength);
        const view = new DataView(array.buffer);
        view.setUint32(0, 0, true);
        array.set(new Uint8Array(itemBuffer), 4);
        return array.buffer;
      }

    case "RCCellVec":
      {
        const itemBuffer = SerializeRCCellVec(value.value);
        const array = new Uint8Array(4 + itemBuffer.byteLength);
        const view = new DataView(array.buffer);
        view.setUint32(0, 1, true);
        array.set(new Uint8Array(itemBuffer), 4);
        return array.buffer;
      }

    default:
      throw new Error(`Invalid type: ${value.type}`);
  }
}

class SmtProof {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);
  }

  raw() {
    return this.view.buffer.slice(4);
  }

  indexAt(i) {
    return this.view.getUint8(4 + i);
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.SmtProof = SmtProof;

function SerializeSmtProof(value) {
  const item = assertArrayBuffer(value);
  const array = new Uint8Array(4 + item.byteLength);
  new DataView(array.buffer).setUint32(0, item.byteLength, true);
  array.set(new Uint8Array(item), 4);
  return array.buffer;
}

class SmtProofEntry {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    if (offsets[1] - offsets[0] !== 1) {
      throw new Error(`Invalid offset for mask: ${offsets[0]} - ${offsets[1]}`);
    }

    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getMask() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);
  }

  getProof() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new SmtProof(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.SmtProofEntry = SmtProofEntry;

function SerializeSmtProofEntry(value) {
  const buffers = [];
  const maskView = new DataView(new ArrayBuffer(1));
  maskView.setUint8(0, value.mask);
  buffers.push(maskView.buffer);
  buffers.push(SerializeSmtProof(value.proof));
  return serializeTable(buffers);
}

class SmtProofEntryVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new SmtProofEntry(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new SmtProofEntry(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.SmtProofEntryVec = SmtProofEntryVec;

function SerializeSmtProofEntryVec(value) {
  return serializeTable(value.map(item => SerializeSmtProofEntry(item)));
}

class SmtUpdateItem {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getKey() {
    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
      validate: false
    });
  }

  getPackedValues() {
    return this.view.getUint8(0 + Byte32.size());
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, SmtUpdateItem.size());
    this.getKey().validate(compatible);
  }

  static size() {
    return 0 + Byte32.size() + 1;
  }

}

exports.SmtUpdateItem = SmtUpdateItem;

function SerializeSmtUpdateItem(value) {
  const array = new Uint8Array(0 + Byte32.size() + 1);
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeByte32(value.key)), 0);
  view.setUint8(0 + Byte32.size(), value.packed_values);
  return array.buffer;
}

class SmtUpdateItemVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * SmtUpdateItem.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new SmtUpdateItem(this.view.buffer.slice(4 + i * SmtUpdateItem.size(), 4 + (i + 1) * SmtUpdateItem.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.SmtUpdateItemVec = SmtUpdateItemVec;

function SerializeSmtUpdateItemVec(value) {
  const array = new Uint8Array(4 + SmtUpdateItem.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeSmtUpdateItem(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * SmtUpdateItem.size());
  }

  return array.buffer;
}

class SmtUpdateAction {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new SmtUpdateItemVec(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getUpdates() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new SmtUpdateItemVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getProof() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new SmtProof(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.SmtUpdateAction = SmtUpdateAction;

function SerializeSmtUpdateAction(value) {
  const buffers = [];
  buffers.push(SerializeSmtUpdateItemVec(value.updates));
  buffers.push(SerializeSmtProof(value.proof));
  return serializeTable(buffers);
}

class XudtData {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getLock() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Bytes(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getData() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.XudtData = XudtData;

function SerializeXudtData(value) {
  const buffers = [];
  buffers.push(SerializeBytes(value.lock));
  buffers.push(SerializeBytesVec(value.data));
  return serializeTable(buffers);
}

class Uint32 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 4);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  toBigEndianUint32() {
    return this.view.getUint32(0, false);
  }

  toLittleEndianUint32() {
    return this.view.getUint32(0, true);
  }

  static size() {
    return 4;
  }

}

exports.Uint32 = Uint32;

function SerializeUint32(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 4);
  return buffer;
}

class Uint64 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 8);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 8;
  }

}

exports.Uint64 = Uint64;

function SerializeUint64(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 8);
  return buffer;
}

class Uint128 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 16);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 16;
  }

}

exports.Uint128 = Uint128;

function SerializeUint128(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 16);
  return buffer;
}

class Byte32 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 32);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 32;
  }

}

exports.Byte32 = Byte32;

function SerializeByte32(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 32);
  return buffer;
}

class Uint256 {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 32);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 32;
  }

}

exports.Uint256 = Uint256;

function SerializeUint256(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 32);
  return buffer;
}

class Bytes {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);
  }

  raw() {
    return this.view.buffer.slice(4);
  }

  indexAt(i) {
    return this.view.getUint8(4 + i);
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.Bytes = Bytes;

function SerializeBytes(value) {
  const item = assertArrayBuffer(value);
  const array = new Uint8Array(4 + item.byteLength);
  new DataView(array.buffer).setUint32(0, item.byteLength, true);
  array.set(new Uint8Array(item), 4);
  return array.buffer;
}

class BytesOpt {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.hasValue()) {
      this.value().validate(compatible);
    }
  }

  value() {
    return new Bytes(this.view.buffer, {
      validate: false
    });
  }

  hasValue() {
    return this.view.byteLength > 0;
  }

}

exports.BytesOpt = BytesOpt;

function SerializeBytesOpt(value) {
  if (value) {
    return SerializeBytes(value);
  } else {
    return new ArrayBuffer(0);
  }
}

class BytesVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new Bytes(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.BytesVec = BytesVec;

function SerializeBytesVec(value) {
  return serializeTable(value.map(item => SerializeBytes(item)));
}

class Byte32Vec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * Byte32.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.Byte32Vec = Byte32Vec;

function SerializeByte32Vec(value) {
  const array = new Uint8Array(4 + Byte32.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeByte32(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());
  }

  return array.buffer;
}

class ScriptOpt {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.hasValue()) {
      this.value().validate(compatible);
    }
  }

  value() {
    return new Script(this.view.buffer, {
      validate: false
    });
  }

  hasValue() {
    return this.view.byteLength > 0;
  }

}

exports.ScriptOpt = ScriptOpt;

function SerializeScriptOpt(value) {
  if (value) {
    return SerializeScript(value);
  } else {
    return new ArrayBuffer(0);
  }
}

class ProposalShortId {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, 10);
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  raw() {
    return this.view.buffer;
  }

  static size() {
    return 10;
  }

}

exports.ProposalShortId = ProposalShortId;

function SerializeProposalShortId(value) {
  const buffer = assertArrayBuffer(value);
  assertDataLength(buffer.byteLength, 10);
  return buffer;
}

class UncleBlockVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new UncleBlock(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.UncleBlockVec = UncleBlockVec;

function SerializeUncleBlockVec(value) {
  return serializeTable(value.map(item => SerializeUncleBlock(item)));
}

class TransactionVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new Transaction(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.TransactionVec = TransactionVec;

function SerializeTransactionVec(value) {
  return serializeTable(value.map(item => SerializeTransaction(item)));
}

class ProposalShortIdVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * ProposalShortId.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new ProposalShortId(this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.ProposalShortIdVec = ProposalShortIdVec;

function SerializeProposalShortIdVec(value) {
  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeProposalShortId(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());
  }

  return array.buffer;
}

class CellDepVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * CellDep.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.CellDepVec = CellDepVec;

function SerializeCellDepVec(value) {
  const array = new Uint8Array(4 + CellDep.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeCellDep(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());
  }

  return array.buffer;
}

class CellInputVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    if (this.view.byteLength < 4) {
      dataLengthError(this.view.byteLength, ">4");
    }

    const requiredByteLength = this.length() * CellInput.size() + 4;
    assertDataLength(this.view.byteLength, requiredByteLength);

    for (let i = 0; i < 0; i++) {
      const item = this.indexAt(i);
      item.validate(compatible);
    }
  }

  indexAt(i) {
    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {
      validate: false
    });
  }

  length() {
    return this.view.getUint32(0, true);
  }

}

exports.CellInputVec = CellInputVec;

function SerializeCellInputVec(value) {
  const array = new Uint8Array(4 + CellInput.size() * value.length);
  new DataView(array.buffer).setUint32(0, value.length, true);

  for (let i = 0; i < value.length; i++) {
    const itemBuffer = SerializeCellInput(value[i]);
    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());
  }

  return array.buffer;
}

class CellOutputVec {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);

    for (let i = 0; i < offsets.length - 1; i++) {
      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
        validate: false
      }).validate();
    }
  }

  length() {
    if (this.view.byteLength < 8) {
      return 0;
    } else {
      return this.view.getUint32(4, true) / 4 - 1;
    }
  }

  indexAt(i) {
    const start = 4 + i * 4;
    const offset = this.view.getUint32(start, true);
    let offset_end = this.view.byteLength;

    if (i + 1 < this.length()) {
      offset_end = this.view.getUint32(start + 4, true);
    }

    return new CellOutput(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.CellOutputVec = CellOutputVec;

function SerializeCellOutputVec(value) {
  return serializeTable(value.map(item => SerializeCellOutput(item)));
}

class Script {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();

    if (offsets[2] - offsets[1] !== 1) {
      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);
    }

    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
  }

  getCodeHash() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Byte32(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getHashType() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);
  }

  getArgs() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new Bytes(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.Script = Script;

function SerializeScript(value) {
  const buffers = [];
  buffers.push(SerializeByte32(value.code_hash));
  const hashTypeView = new DataView(new ArrayBuffer(1));
  hashTypeView.setUint8(0, value.hash_type);
  buffers.push(hashTypeView.buffer);
  buffers.push(SerializeBytes(value.args));
  return serializeTable(buffers);
}

class OutPoint {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getTxHash() {
    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
      validate: false
    });
  }

  getIndex() {
    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {
      validate: false
    });
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, OutPoint.size());
    this.getTxHash().validate(compatible);
    this.getIndex().validate(compatible);
  }

  static size() {
    return 0 + Byte32.size() + Uint32.size();
  }

}

exports.OutPoint = OutPoint;

function SerializeOutPoint(value) {
  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);
  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());
  return array.buffer;
}

class CellInput {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getSince() {
    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), {
      validate: false
    });
  }

  getPreviousOutput() {
    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {
      validate: false
    });
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, CellInput.size());
    this.getSince().validate(compatible);
    this.getPreviousOutput().validate(compatible);
  }

  static size() {
    return 0 + Uint64.size() + OutPoint.size();
  }

}

exports.CellInput = CellInput;

function SerializeCellInput(value) {
  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeUint64(value.since)), 0);
  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());
  return array.buffer;
}

class CellOutput {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new Script(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
  }

  getCapacity() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Uint64(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getLock() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Script(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getType() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.CellOutput = CellOutput;

function SerializeCellOutput(value) {
  const buffers = [];
  buffers.push(SerializeUint64(value.capacity));
  buffers.push(SerializeScript(value.lock));
  buffers.push(SerializeScriptOpt(value.type_));
  return serializeTable(buffers);
}

class CellDep {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getOutPoint() {
    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), {
      validate: false
    });
  }

  getDepType() {
    return this.view.getUint8(0 + OutPoint.size());
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, CellDep.size());
    this.getOutPoint().validate(compatible);
  }

  static size() {
    return 0 + OutPoint.size() + 1;
  }

}

exports.CellDep = CellDep;

function SerializeCellDep(value) {
  const array = new Uint8Array(0 + OutPoint.size() + 1);
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);
  view.setUint8(0 + OutPoint.size(), value.dep_type);
  return array.buffer;
}

class RawTransaction {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), {
      validate: false
    }).validate();
    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), {
      validate: false
    }).validate();
    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), {
      validate: false
    }).validate();
  }

  getVersion() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Uint32(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getCellDeps() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new CellDepVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getHeaderDeps() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getInputs() {
    const start = 16;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new CellInputVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getOutputs() {
    const start = 20;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getOutputsData() {
    const start = 24;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.RawTransaction = RawTransaction;

function SerializeRawTransaction(value) {
  const buffers = [];
  buffers.push(SerializeUint32(value.version));
  buffers.push(SerializeCellDepVec(value.cell_deps));
  buffers.push(SerializeByte32Vec(value.header_deps));
  buffers.push(SerializeCellInputVec(value.inputs));
  buffers.push(SerializeCellOutputVec(value.outputs));
  buffers.push(SerializeBytesVec(value.outputs_data));
  return serializeTable(buffers);
}

class Transaction {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getRaw() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new RawTransaction(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getWitnesses() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.Transaction = Transaction;

function SerializeTransaction(value) {
  const buffers = [];
  buffers.push(SerializeRawTransaction(value.raw));
  buffers.push(SerializeBytesVec(value.witnesses));
  return serializeTable(buffers);
}

class RawHeader {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getVersion() {
    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {
      validate: false
    });
  }

  getCompactTarget() {
    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {
      validate: false
    });
  }

  getTimestamp() {
    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()), {
      validate: false
    });
  }

  getNumber() {
    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size()), {
      validate: false
    });
  }

  getEpoch() {
    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size()), {
      validate: false
    });
  }

  getParentHash() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size()), {
      validate: false
    });
  }

  getTransactionsRoot() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size()), {
      validate: false
    });
  }

  getProposalsHash() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size()), {
      validate: false
    });
  }

  getUnclesHash() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), {
      validate: false
    });
  }

  getDao() {
    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), {
      validate: false
    });
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, RawHeader.size());
    this.getVersion().validate(compatible);
    this.getCompactTarget().validate(compatible);
    this.getTimestamp().validate(compatible);
    this.getNumber().validate(compatible);
    this.getEpoch().validate(compatible);
    this.getParentHash().validate(compatible);
    this.getTransactionsRoot().validate(compatible);
    this.getProposalsHash().validate(compatible);
    this.getUnclesHash().validate(compatible);
    this.getDao().validate(compatible);
  }

  static size() {
    return 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size();
  }

}

exports.RawHeader = RawHeader;

function SerializeRawHeader(value) {
  const array = new Uint8Array(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeUint32(value.version)), 0);
  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());
  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());
  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());
  array.set(new Uint8Array(SerializeUint64(value.epoch)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size());
  array.set(new Uint8Array(SerializeByte32(value.parent_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size());
  array.set(new Uint8Array(SerializeByte32(value.transactions_root)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size());
  array.set(new Uint8Array(SerializeByte32(value.proposals_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size());
  array.set(new Uint8Array(SerializeByte32(value.uncles_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size());
  array.set(new Uint8Array(SerializeByte32(value.dao)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());
  return array.buffer;
}

class Header {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  getRaw() {
    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), {
      validate: false
    });
  }

  getNonce() {
    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {
      validate: false
    });
  }

  validate(compatible = false) {
    assertDataLength(this.view.byteLength, Header.size());
    this.getRaw().validate(compatible);
    this.getNonce().validate(compatible);
  }

  static size() {
    return 0 + RawHeader.size() + Uint128.size();
  }

}

exports.Header = Header;

function SerializeHeader(value) {
  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());
  const view = new DataView(array.buffer);
  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);
  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());
  return array.buffer;
}

class UncleBlock {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getHeader() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Header(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getProposals() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.UncleBlock = UncleBlock;

function SerializeUncleBlock(value) {
  const buffers = [];
  buffers.push(SerializeHeader(value.header));
  buffers.push(SerializeProposalShortIdVec(value.proposals));
  return serializeTable(buffers);
}

class Block {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), {
      validate: false
    }).validate();
  }

  getHeader() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Header(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getUncles() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getTransactions() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new TransactionVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getProposals() {
    const start = 16;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.Block = Block;

function SerializeBlock(value) {
  const buffers = [];
  buffers.push(SerializeHeader(value.header));
  buffers.push(SerializeUncleBlockVec(value.uncles));
  buffers.push(SerializeTransactionVec(value.transactions));
  buffers.push(SerializeProposalShortIdVec(value.proposals));
  return serializeTable(buffers);
}

class CellbaseWitness {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new Script(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
  }

  getLock() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new Script(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getMessage() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new Bytes(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.CellbaseWitness = CellbaseWitness;

function SerializeCellbaseWitness(value) {
  const buffers = [];
  buffers.push(SerializeScript(value.lock));
  buffers.push(SerializeBytes(value.message));
  return serializeTable(buffers);
}

class WitnessArgs {
  constructor(reader, {
    validate = true
  } = {}) {
    this.view = new DataView(assertArrayBuffer(reader));

    if (validate) {
      this.validate();
    }
  }

  validate(compatible = false) {
    const offsets = verifyAndExtractOffsets(this.view, 0, true);
    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {
      validate: false
    }).validate();
    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), {
      validate: false
    }).validate();
    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {
      validate: false
    }).validate();
  }

  getLock() {
    const start = 4;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getInputType() {
    const start = 8;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.getUint32(start + 4, true);
    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

  getOutputType() {
    const start = 12;
    const offset = this.view.getUint32(start, true);
    const offset_end = this.view.byteLength;
    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
      validate: false
    });
  }

}

exports.WitnessArgs = WitnessArgs;

function SerializeWitnessArgs(value) {
  const buffers = [];
  buffers.push(SerializeBytesOpt(value.lock));
  buffers.push(SerializeBytesOpt(value.input_type));
  buffers.push(SerializeBytesOpt(value.output_type));
  return serializeTable(buffers);
}

'''
'''--- examples/omni-lock-metamask/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumos with Omni Lock</title>
</head>
<body>
    <div id="root"></div>
    <script src="index.tsx" type="module"></script>
</body>
</html>
'''
'''--- examples/omni-lock-metamask/lib.ts ---
import { BI, Cell, config, core, helpers, Indexer, RPC, toolkit, utils, commons } from "@ckb-lumos/lumos";
import { SerializeRcLockWitnessLock } from "./generated/omni";

export const CONFIG = config.createConfig({
  PREFIX: "ckt",
  SCRIPTS: {
    ...config.predefined.AGGRON4.SCRIPTS,
    // for more about Omni lock, please check https://github.com/XuJiandong/docs-bank/blob/master/omni_lock.md
    OMNI_LOCK: {
      CODE_HASH: "0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e",
      HASH_TYPE: "type",
      TX_HASH: "0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c",
      INDEX: "0x0",
      DEP_TYPE: "code",
    },
  },
});

config.initializeConfig(CONFIG);

const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";
const rpc = new RPC(CKB_RPC_URL);
const indexer = new Indexer(CKB_INDEXER_URL, CKB_RPC_URL);

// prettier-ignore
interface EthereumRpc {
    (payload: { method: 'personal_sign'; params: [string /*from*/, string /*message*/] }): Promise<string>;
  }

// prettier-ignore
export interface EthereumProvider {
    selectedAddress: string;
    isMetaMask?: boolean;
    enable: () => Promise<string[]>;
    addListener: (event: 'accountsChanged', listener: (addresses: string[]) => void) => void;
    removeEventListener: (event: 'accountsChanged', listener: (addresses: string[]) => void) => void;
    request: EthereumRpc;
  }
// @ts-ignore
export const ethereum = window.ethereum as EthereumProvider;

export function asyncSleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

interface Options {
  from: string;
  to: string;
  amount: string;
}

export async function transfer(options: Options): Promise<string> {
  let tx = helpers.TransactionSkeleton({});
  const fromScript = helpers.parseAddress(options.from);
  const toScript = helpers.parseAddress(options.to);

  // additional 0.001 ckb for tx fee
  // the tx fee could calculated by tx size
  // this is just a simple example
  const neededCapacity = BI.from(options.amount).add(100000n);
  let collectedSum = BI.from(0);
  const collectedCells: Cell[] = [];
  const collector = indexer.collector({ lock: fromScript, type: "empty" });
  for await (const cell of collector.collect()) {
    collectedSum = collectedSum.add(cell.cell_output.capacity);
    collectedCells.push(cell);
    if (BI.from(collectedSum).gte(neededCapacity)) break;
  }

  if (collectedSum.lt(neededCapacity)) {
    throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedSum} `);
  }

  const transferOutput: Cell = {
    cell_output: {
      capacity: BI.from(options.amount).toHexString(),
      lock: toScript,
    },
    data: "0x",
  };

  const changeOutput: Cell = {
    cell_output: {
      capacity: collectedSum.sub(neededCapacity).toHexString(),
      lock: fromScript,
    },
    data: "0x",
  };

  tx = tx.update("inputs", (inputs) => inputs.push(...collectedCells));
  tx = tx.update("outputs", (outputs) => outputs.push(transferOutput, changeOutput));
  tx = tx.update("cellDeps", (cellDeps) =>
    cellDeps.push(
      // omni lock dep
      {
        out_point: {
          tx_hash: CONFIG.SCRIPTS.OMNI_LOCK.TX_HASH,
          index: CONFIG.SCRIPTS.OMNI_LOCK.INDEX,
        },
        dep_type: CONFIG.SCRIPTS.OMNI_LOCK.DEP_TYPE,
      },
      // SECP256K1 lock is depended by omni lock
      {
        out_point: {
          tx_hash: CONFIG.SCRIPTS.SECP256K1_BLAKE160.TX_HASH,
          index: CONFIG.SCRIPTS.SECP256K1_BLAKE160.INDEX,
        },
        dep_type: CONFIG.SCRIPTS.SECP256K1_BLAKE160.DEP_TYPE,
      }
    )
  );

  const messageForSigning = (() => {
    const hasher = new utils.CKBHasher();

    const SECP_SIGNATURE_PLACEHOLDER = new toolkit.Reader(
      "0x" +
        "00".repeat(
          SerializeRcLockWitnessLock({
            signature: new toolkit.Reader("0x" + "00".repeat(65)),
          }).byteLength
        )
    );
    const newWitnessArgs = { lock: SECP_SIGNATURE_PLACEHOLDER };
    const witness = new toolkit.Reader(
      core.SerializeWitnessArgs(toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs))
    ).serializeJson();

    // fill txSkeleton's witness with 0
    for (let i = 0; i < tx.inputs.toArray().length; i++) {
      tx = tx.update("witnesses", (witnesses) => witnesses.push(witness));
    }

    // locks you want to sign
    const signLock = tx.inputs.get(0)?.cell_output.lock!;

    const messageGroup = commons.createP2PKHMessageGroup(tx, [signLock], {
      hasher: {
        update: (message) => hasher.update(message.buffer),
        digest: () => new Uint8Array(hasher.digestReader().toArrayBuffer()),
      },
    });

    return messageGroup[0];
  })();

  let signedMessage = await ethereum.request({
    method: "personal_sign",
    params: [ethereum.selectedAddress, messageForSigning.message],
  });

  let v = Number.parseInt(signedMessage.slice(-2), 16);
  if (v >= 27) v -= 27;
  signedMessage = "0x" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, "0");

  const signedWitness = new toolkit.Reader(
    core.SerializeWitnessArgs({
      lock: SerializeRcLockWitnessLock({
        signature: new toolkit.Reader(signedMessage),
      }),
    })
  ).serializeJson();

  tx = tx.update("witnesses", (witnesses) => witnesses.set(0, signedWitness));

  const signedTx = helpers.createTransactionFromSkeleton(tx);
  const txHash = await rpc.send_transaction(signedTx, "passthrough");

  return txHash;
}

function hashWitness(hasher: utils.CKBHasher, witness: ArrayBuffer): void {
  const lengthBuffer = new ArrayBuffer(8);
  const view = new DataView(lengthBuffer);
  view.setBigUint64(0, BigInt(new toolkit.Reader(witness).length()), true);

  hasher.update(lengthBuffer);
  hasher.update(witness);
}

export async function capacityOf(address: string): Promise<BI> {
  const collector = indexer.collector({
    lock: helpers.parseAddress(address),
  });

  let balance = BI.from(0);
  for await (const cell of collector.collect()) {
    balance = balance.add(cell.cell_output.capacity);
  }

  return balance;
}

'''
'''--- examples/omni-lock-metamask/package.json ---
{
  "private": true,
  "name": "@lumos-examples/omni-lock-metamask",
  "version": "0.17.0-rc8",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "parcel index.html",
    "lint": "tsc --noEmit"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@types/react": "^17.0.34",
    "@types/react-dom": "^17.0.11",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "@ckb-lumos/lumos": "0.17.0-rc8"
  }
}

'''
'''--- examples/omni-lock-metamask/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
      "lib": ["dom"],
      "jsx": "react"
  }
}

'''
'''--- examples/pw-lock-metamask/README.md ---
# Lumos Works with PW-Lock via MetaMask

## Quick Start

> we should [build](..) Lumos project first before we start this example

```
cd examples/pw-lock-metamask
yarn start
```

## Links

- [MetaMask](https://metamask.io/) - A crpto wallet
- [Nervos Faucet](https://faucet.nervos.org/) - Claim Nervos testnet CKB
- [PW lock](https://docs.nervos.org/docs/essays/pw-lock) - PW lock intro

'''
'''--- examples/pw-lock-metamask/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>PW lock example</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="index.tsx" type="module"></script>
  </body>
</html>

'''
'''--- examples/pw-lock-metamask/lib.ts ---
import { BI, Cell, config, core, helpers, Indexer, RPC, toolkit, commons } from "@ckb-lumos/lumos";
import { default as createKeccak } from "keccak";

export const CONFIG = config.createConfig({
  PREFIX: "ckt",
  SCRIPTS: {
    ...config.predefined.AGGRON4.SCRIPTS,
    // https://github.com/lay2dev/pw-core/blob/861310b3dd8638f668db1a08d4c627db4c34d815/src/constants.ts#L156-L169
    PW_LOCK: {
      CODE_HASH: "0x58c5f491aba6d61678b7cf7edf4910b1f5e00ec0cde2f42e0abb4fd9aff25a63",
      HASH_TYPE: "type",
      TX_HASH: "0x57a62003daeab9d54aa29b944fc3b451213a5ebdf2e232216a3cfed0dde61b38",
      INDEX: "0x0",
      DEP_TYPE: "code",
    },
  },
});

config.initializeConfig(CONFIG);

const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";
const rpc = new RPC(CKB_RPC_URL);
const indexer = new Indexer(CKB_INDEXER_URL, CKB_RPC_URL);

// prettier-ignore
interface EthereumRpc {
    (payload: { method: 'personal_sign'; params: [string /*from*/, string /*message*/] }): Promise<string>;
}

// prettier-ignore
export interface EthereumProvider {
    selectedAddress: string;
    isMetaMask?: boolean;
    enable: () => Promise<string[]>;
    addListener: (event: 'accountsChanged', listener: (addresses: string[]) => void) => void;
    removeEventListener: (event: 'accountsChanged', listener: (addresses: string[]) => void) => void;
    request: EthereumRpc;
}

// @ts-ignore
export const ethereum = window.ethereum as EthereumProvider;

export function asyncSleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

interface Options {
  from: string;
  to: string;
  amount: string;
}

export async function transfer(options: Options): Promise<string> {
  let tx = helpers.TransactionSkeleton({});
  const fromScript = helpers.parseAddress(options.from);
  const toScript = helpers.parseAddress(options.to);

  // additional 0.001 ckb for tx fee
  // the tx fee could calculated by tx size
  // this is just a simple example
  const neededCapacity = BI.from(options.amount).add(100000n);
  let collectedSum = BI.from(0);
  const collectedCells: Cell[] = [];
  const collector = indexer.collector({ lock: fromScript, type: "empty" });
  for await (const cell of collector.collect()) {
    collectedSum = collectedSum.add(cell.cell_output.capacity);
    collectedCells.push(cell);
    if (BI.from(collectedSum).gte(neededCapacity)) break;
  }

  if (collectedSum.lt(neededCapacity)) {
    throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedSum} `);
  }

  const transferOutput: Cell = {
    cell_output: {
      capacity: BI.from(options.amount).toHexString(),
      lock: toScript,
    },
    data: "0x",
  };

  const changeOutput: Cell = {
    cell_output: {
      capacity: collectedSum.sub(neededCapacity).toHexString(),
      lock: fromScript,
    },
    data: "0x",
  };

  tx = tx.update("inputs", (inputs) => inputs.push(...collectedCells));
  tx = tx.update("outputs", (outputs) => outputs.push(transferOutput, changeOutput));
  tx = tx.update("cellDeps", (cellDeps) =>
    cellDeps.push(
      // pw-lock dep
      {
        out_point: {
          tx_hash: CONFIG.SCRIPTS.PW_LOCK.TX_HASH,
          index: CONFIG.SCRIPTS.PW_LOCK.INDEX,
        },
        dep_type: CONFIG.SCRIPTS.PW_LOCK.DEP_TYPE,
      },
      // pw-lock is dependent on secp256k1
      {
        out_point: {
          tx_hash: CONFIG.SCRIPTS.SECP256K1_BLAKE160.TX_HASH,
          index: CONFIG.SCRIPTS.SECP256K1_BLAKE160.INDEX,
        },
        dep_type: CONFIG.SCRIPTS.SECP256K1_BLAKE160.DEP_TYPE,
      }
    )
  );

  const messageForSigning = (() => {
    const SECP_SIGNATURE_PLACEHOLDER = "0x" + "00".repeat(65);
    const newWitnessArgs = { lock: SECP_SIGNATURE_PLACEHOLDER };
    const witness = new toolkit.Reader(
      core.SerializeWitnessArgs(toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs))
    ).serializeJson();

    // fill txSkeleton's witness with 0
    for (let i = 0; i < tx.inputs.toArray().length; i++) {
      tx = tx.update("witnesses", (witnesses) => witnesses.push(witness));
    }

    // locks you want to sign
    const signLock = tx.inputs.get(0)?.cell_output.lock!;

    // just like P2PKH
    // https://github.com/nervosnetwork/ckb-system-scripts/wiki/How-to-sign-transaction
    const keccak = createKeccak("keccak256");

    const messageGroup = commons.createP2PKHMessageGroup(tx, [signLock], {
      hasher: {
        update: (message) => keccak.update(Buffer.from(new Uint8Array(message))),
        digest: () => keccak.digest(),
      },
    });

    return messageGroup[0];
  })();

  let signedMessage = await ethereum.request({
    method: "personal_sign",
    params: [ethereum.selectedAddress, messageForSigning.message],
  });

  let v = Number.parseInt(signedMessage.slice(-2), 16);
  if (v >= 27) v -= 27;
  signedMessage = "0x" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, "0");

  const signedWitness = new toolkit.Reader(
    core.SerializeWitnessArgs({
      lock: new toolkit.Reader(signedMessage),
    })
  ).serializeJson();

  tx = tx.update("witnesses", (witnesses) => witnesses.set(0, signedWitness));

  const signedTx = helpers.createTransactionFromSkeleton(tx);
  const txHash = await rpc.send_transaction(signedTx, "passthrough");

  return txHash;
}

export async function capacityOf(address: string): Promise<BI> {
  const collector = indexer.collector({
    lock: helpers.parseAddress(address),
  });

  let balance = BI.from(0);
  for await (const cell of collector.collect()) {
    balance = balance.add(cell.cell_output.capacity);
  }

  return balance;
}

'''
'''--- examples/pw-lock-metamask/package.json ---
{
  "private": true,
  "name": "@lumos-examples/pw-lock-metamask",
  "version": "0.17.0-rc8",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "parcel index.html",
    "lint": "tsc --noEmit"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@types/react": "^17.0.34",
    "@types/react-dom": "^17.0.11",
    "@ckb-lumos/lumos": "0.17.0-rc8",
    "keccak": "^3.0.1",
    "react": "^17.0.2",
    "react-dom": "^17.0.2"
  }
}

'''
'''--- examples/pw-lock-metamask/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
      "lib": ["dom"],
      "jsx": "react"
  }
}

'''
'''--- examples/secp256k1-multisig-transfer/index.ts ---
import {
  Indexer,
  helpers,
  Script,
  RPC,
  hd,
  config,
  Cell,
  commons,
  core,
  WitnessArgs,
  toolkit,
} from "@ckb-lumos/lumos";
import { values } from "@ckb-lumos/base";
import {
  parseFromInfo,
  MultisigScript,
} from "@ckb-lumos/common-scripts/lib/from_info";
const { ScriptValue } = values;

const { AGGRON4 } = config.predefined;

const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";
const rpc = new RPC(CKB_RPC_URL);
const indexer = new Indexer(CKB_INDEXER_URL, CKB_RPC_URL);

const ALICE = {
  PRIVATE_KEY:
    "0x2c56a92a03d767542222432e4f2a0584f01e516311f705041d86b1af7573751f",
  ARGS: "0x3d35d87fac0008ba5b12ee1c599b102fc8f5fdf8",
};

const BOB = {
  PRIVATE_KEY:
    "0x3bc65932a75f76c5b6a04660e4d0b85c2d9b5114efa78e6e5cf7ad0588ca09c8",
  ARGS: "0x99dbe610c43186696e1f88cb7b59252d4c92afda",
};

const CHARLES = {
  PRIVATE_KEY:
    "0xbe06025fbd8c74f65a513a28e62ac56f3227fcb307307a0f2a0ef34d4a66e81f",
  ARGS: "0xc055df68fdd47c6a5965b9ab21cd6825d8696a76",
};

const TO_ADDRESS = "ckt1qyqptxys5l9vk39ft0hswscxgseawc77y2wqlr558h";

/**
 * Generate fromInfo for multisig transfer.
 * @param R The provided signatures must match at least the first R items of the Pubkey list.
 * @param M M of N signatures must be provided to unlock the cell. N equals to the size of publicKeyHashes.
 * @param publicKeyHashes The list of Lock Args generated by the blake160 function that extracts
 * the first 20 bytes of a public key hash.
 *
 * R, M are single byte unsigned integers that ranges from 0 to 255.
 * R must no more than M.
 */
function generateMofNMultisigInfo(
  R: number,
  M: number,
  publicKeyHashes: string[]
): MultisigScript {
  return {
    R,
    M,
    publicKeyHashes,
  };
}

type Account = {
  fromScript: Script;
  multisigScript: string | undefined;
};

function generateAccountFromMultisigInfo(fromInfo: MultisigScript): Account {
  const { fromScript, multisigScript } = parseFromInfo(fromInfo, {
    config: AGGRON4,
  });
  return {
    fromScript,
    multisigScript,
  };
}

interface Options {
  fromInfo: MultisigScript;
  toAddress: string;
  amount: bigint;
  privKeys: string[];
}

export async function transfer(options: Options): Promise<string> {
  let txSkeleton = helpers.TransactionSkeleton({});

  const { fromScript, multisigScript } = generateAccountFromMultisigInfo(
    options.fromInfo
  );
  const toScript = helpers.parseAddress(options.toAddress, { config: AGGRON4 });

  // additional 0.001 ckb for tx fee
  // the tx fee could calculated by tx size
  // this is just a simple example
  const neededCapacity = BigInt(options.amount) + 100000n;
  let collectedSum = 0n;
  const collected: Cell[] = [];
  const collector = indexer.collector({ lock: fromScript, type: "empty" });
  for await (const cell of collector.collect()) {
    collectedSum += BigInt(cell.cell_output.capacity);
    collected.push(cell);
    if (collectedSum >= neededCapacity) break;
  }

  if (collectedSum < neededCapacity) {
    throw new Error("Not enough CKB");
  }

  const transferOutput: Cell = {
    cell_output: {
      capacity: "0x" + BigInt(options.amount).toString(16),
      lock: toScript,
    },
    data: "0x",
  };

  const changeOutput: Cell = {
    cell_output: {
      capacity: "0x" + BigInt(collectedSum - neededCapacity).toString(16),
      lock: fromScript,
    },
    data: "0x",
  };

  txSkeleton = txSkeleton.update("inputs", (inputs) =>
    inputs.push(...collected)
  );
  txSkeleton = txSkeleton.update("outputs", (outputs) =>
    outputs.push(transferOutput, changeOutput)
  );
  txSkeleton = txSkeleton.update("cellDeps", (cellDeps) =>
    cellDeps.push({
      out_point: {
        tx_hash: AGGRON4.SCRIPTS.SECP256K1_BLAKE160_MULTISIG.TX_HASH,
        index: AGGRON4.SCRIPTS.SECP256K1_BLAKE160_MULTISIG.INDEX,
      },
      dep_type: AGGRON4.SCRIPTS.SECP256K1_BLAKE160_MULTISIG.DEP_TYPE,
    })
  );

  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
    }
    let witness: string = txSkeleton.get("witnesses").get(firstIndex)!;
    let newWitnessArgs: WitnessArgs;
    const SECP_SIGNATURE_PLACEHOLDER =
      "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

    newWitnessArgs = {
      lock:
        "0x" +
        multisigScript!.slice(2) +
        SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(options.fromInfo.M),
    };

    if (witness !== "0x") {
      const witnessArgs = new core.WitnessArgs(new toolkit.Reader(witness));
      const lock = witnessArgs.getLock();
      if (
        lock.hasValue() &&
        new toolkit.Reader(lock.value().raw()).serializeJson() !==
          newWitnessArgs.lock
      ) {
        throw new Error(
          "Lock field in first witness is set aside for signature!"
        );
      }
      const inputType = witnessArgs.getInputType();
      if (inputType.hasValue()) {
        newWitnessArgs.input_type = new toolkit.Reader(
          inputType.value().raw()
        ).serializeJson();
      }
      const outputType = witnessArgs.getOutputType();
      if (outputType.hasValue()) {
        newWitnessArgs.output_type = new toolkit.Reader(
          outputType.value().raw()
        ).serializeJson();
      }
    }
    witness = new toolkit.Reader(
      core.SerializeWitnessArgs(
        toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs)
      )
    ).serializeJson();
    txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
      witnesses.set(firstIndex, witness)
    );
  }

  txSkeleton = commons.common.prepareSigningEntries(txSkeleton);
  const message = txSkeleton.get("signingEntries").get(0)?.message;

  let pubkeyHashN: string = "";
  options.fromInfo.publicKeyHashes.forEach((publicKeyHash) => {
    pubkeyHashN += publicKeyHash.slice(2);
  });

  let sigs: string = "";
  options.privKeys.forEach((privKey) => {
    if (privKey !== "") {
      let sig = hd.key.signRecoverable(message!, privKey);
      sig = sig.slice(2);
      sigs += sig;
    }
  });

  sigs =
    "0x00" +
    ("00" + options.fromInfo.R.toString(16)).slice(-2) +
    ("00" + options.fromInfo.M.toString(16)).slice(-2) +
    ("00" + options.fromInfo.publicKeyHashes.length.toString(16)).slice(-2) +
    pubkeyHashN +
    sigs;

  const tx = helpers.sealTransaction(txSkeleton, [sigs]);
  const hash = await rpc.send_transaction(tx, "passthrough");
  console.log("The transaction hash is", hash);

  return hash;
}

// Multisig transfer example
function main() {
  const fromInfo = generateMofNMultisigInfo(2, 2, [
    ALICE.ARGS,
    BOB.ARGS,
    CHARLES.ARGS,
  ]);
  const privKeys = [ALICE.PRIVATE_KEY, BOB.PRIVATE_KEY];
  transfer({ fromInfo, toAddress: TO_ADDRESS, amount: 8800000000n, privKeys });
}
main();

'''
'''--- examples/secp256k1-multisig-transfer/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "lib": ["dom"],
  }
}

'''
'''--- examples/secp256k1-transfer/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lumos Transfer</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="index.tsx" type="module"></script>
  </body>
</html>

'''
'''--- examples/secp256k1-transfer/lib.ts ---
import {
  Indexer,
  helpers,
  Address,
  Script,
  RPC,
  hd,
  config,
  Cell,
  commons,
  core,
  WitnessArgs,
  toolkit,
} from "@ckb-lumos/lumos";
import { values } from "@ckb-lumos/base";
const { ScriptValue } = values;

export const { AGGRON4 } = config.predefined;

const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";
const rpc = new RPC(CKB_RPC_URL);
const indexer = new Indexer(CKB_INDEXER_URL, CKB_RPC_URL);

type Account = {
  lockScript: Script;
  address: Address;
  pubKey: string;
};
export const generateAccountFromPrivateKey = (privKey: string): Account => {
  const pubKey = hd.key.privateToPublic(privKey);
  const args = hd.key.publicKeyToBlake160(pubKey);
  const template = AGGRON4.SCRIPTS["SECP256K1_BLAKE160"]!;
  const lockScript = {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args: args,
  };
  const address = helpers.generateAddress(lockScript, { config: AGGRON4 });
  return {
    lockScript,
    address,
    pubKey,
  };
};

export async function capacityOf(address: string): Promise<bigint> {
  const collector = indexer.collector({
    lock: helpers.parseAddress(address, { config: AGGRON4 }),
  });

  let balance = 0n;
  for await (const cell of collector.collect()) {
    balance += BigInt(cell.cell_output.capacity);
  }

  return balance;
}

interface Options {
  from: string;
  to: string;
  amount: string;
  privKey: string;
}

export async function transfer(options: Options): Promise<string> {
  let txSkeleton = helpers.TransactionSkeleton({});
  const fromScript = helpers.parseAddress(options.from, { config: AGGRON4 });
  const toScript = helpers.parseAddress(options.to, { config: AGGRON4 });

  // additional 0.001 ckb for tx fee
  // the tx fee could calculated by tx size
  // this is just a simple example
  const neededCapacity = BigInt(options.amount) + 100000n;
  let collectedSum = 0n;
  const collected: Cell[] = [];
  const collector = indexer.collector({ lock: fromScript, type: "empty" });
  for await (const cell of collector.collect()) {
    collectedSum += BigInt(cell.cell_output.capacity);
    collected.push(cell);
    if (collectedSum >= neededCapacity) break;
  }

  if (collectedSum < neededCapacity) {
    throw new Error("Not enough CKB");
  }

  const transferOutput: Cell = {
    cell_output: {
      capacity: "0x" + BigInt(options.amount).toString(16),
      lock: toScript,
    },
    data: "0x",
  };

  const changeOutput: Cell = {
    cell_output: {
      capacity: "0x" + BigInt(collectedSum - neededCapacity).toString(16),
      lock: fromScript,
    },
    data: "0x",
  };

  txSkeleton = txSkeleton.update("inputs", (inputs) =>
    inputs.push(...collected)
  );
  txSkeleton = txSkeleton.update("outputs", (outputs) =>
    outputs.push(transferOutput, changeOutput)
  );
  txSkeleton = txSkeleton.update("cellDeps", (cellDeps) =>
    cellDeps.push({
      out_point: {
        tx_hash: AGGRON4.SCRIPTS.SECP256K1_BLAKE160.TX_HASH,
        index: AGGRON4.SCRIPTS.SECP256K1_BLAKE160.INDEX,
      },
      dep_type: AGGRON4.SCRIPTS.SECP256K1_BLAKE160.DEP_TYPE,
    })
  );

  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
    }
    let witness: string = txSkeleton.get("witnesses").get(firstIndex)!;
    const newWitnessArgs: WitnessArgs = {
      /* 65-byte zeros in hex */
      lock:
        "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    };
    if (witness !== "0x") {
      const witnessArgs = new core.WitnessArgs(new toolkit.Reader(witness));
      const lock = witnessArgs.getLock();
      if (
        lock.hasValue() &&
        new toolkit.Reader(lock.value().raw()).serializeJson() !==
          newWitnessArgs.lock
      ) {
        throw new Error(
          "Lock field in first witness is set aside for signature!"
        );
      }
      const inputType = witnessArgs.getInputType();
      if (inputType.hasValue()) {
        newWitnessArgs.input_type = new toolkit.Reader(
          inputType.value().raw()
        ).serializeJson();
      }
      const outputType = witnessArgs.getOutputType();
      if (outputType.hasValue()) {
        newWitnessArgs.output_type = new toolkit.Reader(
          outputType.value().raw()
        ).serializeJson();
      }
    }
    witness = new toolkit.Reader(
      core.SerializeWitnessArgs(
        toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs)
      )
    ).serializeJson();
    txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
      witnesses.set(firstIndex, witness)
    );
  }

  txSkeleton = commons.common.prepareSigningEntries(txSkeleton);
  const message = txSkeleton.get("signingEntries").get(0)?.message;
  const Sig = hd.key.signRecoverable(message!, options.privKey);
  const tx = helpers.sealTransaction(txSkeleton, [Sig]);
  const hash = await rpc.send_transaction(tx, "passthrough");
  console.log("The transaction hash is", hash);

  return hash;
}

'''
'''--- examples/secp256k1-transfer/package.json ---
{
  "private": true,
  "name": "@lumos-examples/secp256k1-transfer",
  "version": "0.17.0-rc7",
  "description": "",
  "main": "index.js",
  "scripts": {
    "lint": "tsc --noEmit"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@types/react": "^17.0.34",
    "@types/react-dom": "^17.0.11",
    "@ckb-lumos/lumos": "0.17.0-rc8",
    "react": "^17.0.2",
    "react-dom": "^17.0.2"
  },
  "devDependencies": {
    "@babel/cli": "^7.16.0",
    "@babel/core": "^7.16.0",
    "@babel/plugin-transform-modules-commonjs": "^7.16.0"
  }
}

'''
'''--- examples/secp256k1-transfer/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "lib": ["dom"],
    "jsx": "react"
  }
}

'''
'''--- lerna.json ---
{
  "packages": [
    "packages/*"
  ],
  "npmClient": "yarn",
  "useWorkspaces": true,
  "version": "0.17.0-rc8",
  "command": {
    "publish": {
      "access": "public"
    }
  }
}

'''
'''--- package.json ---
{
  "name": "@peersyst/lumos",
  "version": "0.17.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/Peersyst/lumos.git"
  },
  "private": true,
  "workspaces": [
    "packages/*",
    "examples/*"
  ],
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "resolutions": {
    "lerna/**/json-schema": "^0.4.0",
    "@strictsoftware/typedoc-plugin-monorepo/highlight.js": "^10.4.1",
    "ava/trim-off-newlines": "^1.0.3",
    "ava/**/ansi-regex": "^5.0.1",
    "lerna/**/ansi-regex": "^5.0.1"
  },
  "devDependencies": {
    "@ava/typescript": "^1.1.1",
    "@babel/cli": "^7.16.7",
    "@babel/core": "^7.16.7",
    "@babel/preset-env": "^7.16.7",
    "@babel/preset-typescript": "^7.16.7",
    "@commitlint/cli": "^16.1.0",
    "@commitlint/config-conventional": "^16.0.0",
    "@commitlint/types": "^16.0.0",
    "@strictsoftware/typedoc-plugin-monorepo": "^0.3.1",
    "@typescript-eslint/eslint-plugin": "^3.5.0",
    "@typescript-eslint/parser": "^3.5.0",
    "ava": "^3.8.2",
    "c8": "^7.10.0",
    "eslint": "^7.1.0",
    "husky": "^7.0.4",
    "lerna": "^4.0.0",
    "mysql2": "^2.1.0",
    "npm-run-all": "^4.1.5",
    "parcel": "^2.2.1",
    "prettier": "^2.0.5",
    "sinon": "^9.2.0",
    "ts-node": "^8.10.2",
    "typedoc": "^0.17.7",
    "typescript": "^3.9.5"
  },
  "scripts": {
    "docs": "typedoc .",
    "prepare": "husky install",
    "test": "lerna run test --parallel",
    "test-coverage": "yarn c8 --reporter=cobertura --reporter=html --clean -o coverage yarn run test",
    "build:types": "lerna run build:types",
    "build:js": "lerna run build:js --parallel",
    "build": "run-p build:*",
    "build-release": "lerna run --scope @ckb-lumos/lumos build:umd",
    "lint": "run-p lint:* && git diff --exit-code",
    "lint:fmt": "lerna run fmt --parallel",
    "lint:eslint": "lerna run lint --parallel",
    "clean": "lerna run clean",
    "versionup": "lerna version --conventional-commits --no-git-tag-version",
    "versionup:patch": "lerna version patch --conventional-commits --no-git-tag-version",
    "versionup:minor": "lerna version minor --conventional-commits --no-git-tag-version",
    "versionup:major": "lerna version major --conventional-commits --no-git-tag-version",
    "postversionup": "npm run commit-version",
    "postversionup:patch": "npm run commit-version",
    "postversionup:minor": "npm run commit-version",
    "postversionup:major": "npm run commit-version",
    "commit-version": "git add . && git commit -m \"chore: publish `node -p 'require(\"./lerna.json\").version'`\""
  },
  "husky": {
    "hooks": {
      "pre-push": "yarn run lint"
    }
  }
}

'''
'''--- packages/base/README.md ---
# `@ckb-lumos/base`

Base data structures and utilities used in lumos.

'''
'''--- packages/base/index.d.ts ---
import * as core from "./lib/core";
import * as utils from "./lib/utils";
import * as helpers from "./lib/helpers";
import * as since from "./lib/since";
import * as denormalizers from "./lib/denormalizers";
import * as values from "./lib/values";
import * as logger from "./lib/logger";

export * from "./lib/primitive";
export * from "./lib/api";
export * from "./lib/indexer";

export { core, utils, helpers, since, denormalizers, values, logger };
export { SinceValidationInfo } from "./lib/since";

export interface Tip {
  block_number: string;
  block_hash: string;
}

'''
'''--- packages/base/lib/api.d.ts ---
import { Hash, HexNumber, HexString, PackedSince } from "./primitive";

export interface Header {
  timestamp: HexNumber;
  number: HexNumber;
  epoch: HexNumber;
  compact_target: HexNumber;
  dao: Hash;
  hash: Hash;
  nonce: HexNumber;
  parent_hash: Hash;
  proposals_hash: Hash;
  transactions_root: Hash;
  uncles_hash: Hash;
  version: HexNumber;
}

export type HashType = "type" | "data";
export interface Script {
  code_hash: Hash;
  hash_type: HashType;
  args: HexString;
}

export interface OutPoint {
  tx_hash: Hash;
  index: HexNumber;
}

export type DepType = "dep_group" | "code";
export interface CellDep {
  out_point: OutPoint;
  dep_type: DepType;
}

export interface Input {
  previous_output: OutPoint;
  since: PackedSince;
}

export interface Output {
  capacity: HexString;
  lock: Script;
  type?: Script;
}

export interface WitnessArgs {
  lock?: HexString;
  input_type?: HexString;
  output_type?: HexString;
}
export interface RawTransaction {
  cell_deps: CellDep[];
  hash?: Hash;
  header_deps: Hash[];
  inputs: Input[];
  outputs: Output[];
  outputs_data: HexString[];
  version: HexString;
}
export interface Transaction {
  cell_deps: CellDep[];
  hash?: Hash;
  header_deps: Hash[];
  inputs: Input[];
  outputs: Output[];
  outputs_data: HexString[];
  version: HexNumber;
  witnesses: HexString[];
}

export interface TxStatus {
  block_hash?: Hash;
  status: string;
}

export interface TransactionWithStatus {
  transaction: Transaction;
  tx_status: TxStatus;
}

export interface Cell {
  cell_output: {
    capacity: HexNumber;
    lock: Script;
    type?: Script;
  };
  data: HexString;
  out_point?: OutPoint;
  block_hash?: Hash;
  block_number?: HexNumber;
}

export interface UncleBlock {
  header: Header;
  proposals: HexString[];
}

export interface Block {
  header: Header;
  transactions: Transaction[];
  uncles: UncleBlock[];
  proposals: HexString[];
}

export interface CellWithStatus {
  cell: {
    data: {
      content: HexString;
      hash: Hash;
    };
    output: Output;
  } | null;
  status: "live" | "unknown";
}

export interface Epoch {
  compact_target: HexNumber;
  length: HexNumber;
  start_number: HexNumber;
  number: HexNumber;
}

export interface BlockEconomicState {
  issuance: {
    primary: HexNumber;
    secondary: HexNumber;
  };
  miner_reward: {
    primary: HexNumber;
    secondary: HexNumber;
    committed: HexNumber;
    proposal: HexNumber;
  };
  txs_fee: HexNumber;
  finalized_at: Hash;
}

export interface MerkleProof {
  indices: HexNumber[];
  lemmas: Hash[];
}

export interface TransactionProof {
  block_hash: Hash;
  witnesses_root: Hash;
  proof: MerkleProof;
}

export interface Rational {
  denom: HexNumber;
  numer: HexNumber;
}

export interface ProposalWindow {
  closest: HexNumber;
  farthest: HexNumber;
}

export interface Consensus {
  id: string;
  genesis_hash: Hash;
  dao_type_hash?: Hash;
  secp256k1_blake160_sighash_all_type_hash?: Hash;
  secp256k1_blake160_multisig_all_type_hash?: Hash;
  initial_primary_epoch_reward: HexNumber;
  secondary_epoch_reward: HexNumber;
  max_uncles_num: HexNumber;
  orphan_rate_target: Rational;
  epoch_duration_target: HexNumber;
  tx_proposal_window: ProposalWindow;
  proposer_reward_ratio: Rational;
  cellbase_maturity: HexNumber;
  median_time_block_count: HexNumber;
  max_block_cycles: HexNumber;
  max_block_bytes: HexNumber;
  block_version: HexNumber;
  tx_version: HexNumber;
  type_id_code_hash: Hash;
  max_block_proposals_limit: HexNumber;
  primary_epoch_reward_halving_interval: HexNumber;
  permanent_difficulty_in_dummy: boolean;
}

export interface DryRunResult {
  cycles: HexNumber;
}

export interface NodeAddress {
  address: string;
  score: HexNumber;
}

export interface LocalNodeProtocol {
  id: HexNumber;
  name: string;
  support_versions: string[];
}

export interface LocalNode {
  version: string;
  node_id: string;
  active: boolean;
  addresses: NodeAddress[];
  protocols: LocalNodeProtocol[];
  connections: HexNumber;
}

export interface PeerSyncState {
  best_known_header_hash?: HexString;
  best_known_header_number?: HexNumber;
  last_common_header_hash?: HexString;
  last_common_header_number?: HexNumber;
  unknown_header_list_size?: HexNumber;
}

export interface RemoteNodeProtocol {
  id: HexNumber;
  version: string;
}

export interface RemoteNode {
  version: string;
  node_id: string;
  addresses: NodeAddress[];
  is_outbount: boolean;
  connected_duration: HexNumber;
  last_ping_duration?: HexNumber;
  sync_state?: PeerSyncState;
  protocols: RemoteNodeProtocol[];
}

export interface BannedAddr {
  address: string;
  ban_until: HexNumber;
  ban_reason: string;
  created_at: HexNumber;
}

export interface SyncState {
  ibd: boolean;
  best_known_block_number: HexNumber;
  best_known_block_timestamp: HexNumber;
  orphan_blocks_count: HexNumber;
  inflight_blocks_count: HexNumber;
  fast_time: HexNumber;
  normal_time: HexNumber;
  low_time: HexNumber;
}

export interface TxPoolInfo {
  tip_hash: Hash;
  tip_number: HexNumber;
  pending: HexNumber;
  proposed: HexNumber;
  orphan: HexNumber;
  total_tx_size: HexNumber;
  total_tx_cycles: HexNumber;
  min_fee_rate: HexNumber;
  last_txs_updated_at: HexNumber;
}

export interface TxPoolIds {
  pending: Hash[];
  proposed: Hash[];
}

export interface TxVerbosity {
  cycles: HexNumber;
  size: HexNumber;
  fee: HexNumber;
  ancestors_size: HexNumber;
  ancestors_cycles: HexNumber;
  ancestors_count: HexNumber;
}

export interface TxPoolVerbosity {
  pending: {
    [key: string]: TxVerbosity;
  };
  proposed: {
    [key: string]: TxVerbosity;
  };
}

export type RawTxPool = TxPoolIds | TxPoolVerbosity;

export interface AlertMessage {
  id: HexNumber;
  priority: HexNumber;
  notice_until: HexNumber;
  message: string;
}

export interface ChainInfo {
  chain: string;
  median_time: HexNumber;
  epoch: HexNumber;
  difficulty: HexNumber;
  is_initial_block_download: boolean;
  alerts: AlertMessage[];
}

export interface Alert {
  id: HexNumber;
  cancel: HexNumber;
  min_version?: string;
  max_version?: string;
  priority: HexNumber;
  notice_until: HexNumber;
  message: string;
  signatures: HexString[];
}

'''
'''--- packages/base/lib/api.js ---
// for typescript

'''
'''--- packages/base/lib/core.d.ts ---
export interface CastToArrayBuffer {
  toArrayBuffer(): ArrayBuffer;
}

export type CanCastToArrayBuffer = ArrayBuffer | CastToArrayBuffer;

export interface CreateOptions {
  validate?: boolean;
}

export interface UnionType {
  type: string;
  value: any;
}

export function SerializeUint32(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint32 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  toBigEndianUint32(): number;
  toLittleEndianUint32(): number;
  static size(): Number;
}

export function SerializeUint64(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint64 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  toBigEndianUint64(): BigInt;
  toLittleEndianUint64(): BigInt;
  static size(): Number;
}

export function SerializeUint128(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint128 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeByte32(value: CanCastToArrayBuffer): ArrayBuffer;
export class Byte32 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeUint256(value: CanCastToArrayBuffer): ArrayBuffer;
export class Uint256 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeBytes(value: CanCastToArrayBuffer): ArrayBuffer;
export class Bytes {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  length(): number;
}

export function SerializeBytesOpt(value: CanCastToArrayBuffer | null): ArrayBuffer;
export class BytesOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  value(): Bytes;
  hasValue(): boolean;
}

export function SerializeBytesVec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class BytesVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Bytes;
  length(): number;
}

export function SerializeByte32Vec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class Byte32Vec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Byte32;
  length(): number;
}

export function SerializeScriptOpt(value: object | null): ArrayBuffer;
export class ScriptOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  value(): Script;
  hasValue(): boolean;
}

export function SerializeProposalShortId(value: CanCastToArrayBuffer): ArrayBuffer;
export class ProposalShortId {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): number;
  raw(): ArrayBuffer;
  static size(): Number;
}

export function SerializeUncleBlockVec(value: Array<object>): ArrayBuffer;
export class UncleBlockVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): UncleBlock;
  length(): number;
}

export function SerializeTransactionVec(value: Array<object>): ArrayBuffer;
export class TransactionVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): Transaction;
  length(): number;
}

export function SerializeProposalShortIdVec(value: Array<CanCastToArrayBuffer>): ArrayBuffer;
export class ProposalShortIdVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): ProposalShortId;
  length(): number;
}

export function SerializeCellDepVec(value: Array<object>): ArrayBuffer;
export class CellDepVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellDep;
  length(): number;
}

export function SerializeCellInputVec(value: Array<object>): ArrayBuffer;
export class CellInputVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellInput;
  length(): number;
}

export function SerializeCellOutputVec(value: Array<object>): ArrayBuffer;
export class CellOutputVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  indexAt(i: number): CellOutput;
  length(): number;
}

export function SerializeScript(value: object): ArrayBuffer;
export class Script {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCodeHash(): Byte32;
  getHashType(): number;
  getArgs(): Bytes;
}

export function SerializeOutPoint(value: object): ArrayBuffer;
export class OutPoint {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getTxHash(): Byte32;
  getIndex(): Uint32;
}

export function SerializeCellInput(value: object): ArrayBuffer;
export class CellInput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getSince(): Uint64;
  getPreviousOutput(): OutPoint;
}

export function SerializeCellOutput(value: object): ArrayBuffer;
export class CellOutput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCapacity(): Uint64;
  getLock(): Script;
  getType(): ScriptOpt;
}

export function SerializeCellDep(value: object): ArrayBuffer;
export class CellDep {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getOutPoint(): OutPoint;
  getDepType(): number;
}

export function SerializeRawTransaction(value: object): ArrayBuffer;
export class RawTransaction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getVersion(): Uint32;
  getCellDeps(): CellDepVec;
  getHeaderDeps(): Byte32Vec;
  getInputs(): CellInputVec;
  getOutputs(): CellOutputVec;
  getOutputsData(): BytesVec;
}

export function SerializeTransaction(value: object): ArrayBuffer;
export class Transaction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getRaw(): RawTransaction;
  getWitnesses(): BytesVec;
}

export function SerializeRawHeader(value: object): ArrayBuffer;
export class RawHeader {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getVersion(): Uint32;
  getCompactTarget(): Uint32;
  getTimestamp(): Uint64;
  getNumber(): Uint64;
  getEpoch(): Uint64;
  getParentHash(): Byte32;
  getTransactionsRoot(): Byte32;
  getProposalsHash(): Byte32;
  getUnclesHash(): Byte32;
  getDao(): Byte32;
}

export function SerializeHeader(value: object): ArrayBuffer;
export class Header {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  static size(): Number;
  getRaw(): RawHeader;
  getNonce(): Uint128;
}

export function SerializeUncleBlock(value: object): ArrayBuffer;
export class UncleBlock {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getProposals(): ProposalShortIdVec;
}

export function SerializeBlock(value: object): ArrayBuffer;
export class Block {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getUncles(): UncleBlockVec;
  getTransactions(): TransactionVec;
  getProposals(): ProposalShortIdVec;
}

export function SerializeCellbaseWitness(value: object): ArrayBuffer;
export class CellbaseWitness {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): Script;
  getMessage(): Bytes;
}

export function SerializeWitnessArgs(value: object): ArrayBuffer;
export class WitnessArgs {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): BytesOpt;
  getInputType(): BytesOpt;
  getOutputType(): BytesOpt;
}

'''
'''--- packages/base/lib/core.js ---
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.CKBCore = {}));
}(this, (function (exports) { 'use strict';

  function dataLengthError(actual, required) {
      throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);
  }

  function assertDataLength(actual, required) {
    if (actual !== required) {
      dataLengthError(actual, required);
    }
  }

  function assertArrayBuffer(reader) {
    if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {
      reader = reader.toArrayBuffer();
    }
    if (!(reader instanceof ArrayBuffer)) {
      throw new Error("Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!");
    }
    return reader;
  }

  function verifyAndExtractOffsets(view, expectedFieldCount, compatible) {
    if (view.byteLength < 4) {
      dataLengthError(view.byteLength, ">4");
    }
    const requiredByteLength = view.getUint32(0, true);
    assertDataLength(view.byteLength, requiredByteLength);
    if (requiredByteLength === 4) {
      return [requiredByteLength];
    }
    if (requiredByteLength < 8) {
      dataLengthError(view.byteLength, ">8");
    }
    const firstOffset = view.getUint32(4, true);
    if (firstOffset % 4 !== 0 || firstOffset < 8) {
      throw new Error(`Invalid first offset: ${firstOffset}`);
    }
    const itemCount = firstOffset / 4 - 1;
    if (itemCount < expectedFieldCount) {
      throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);
    } else if ((!compatible) && itemCount > expectedFieldCount) {
      throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);
    }
    if (requiredByteLength < firstOffset) {
      throw new Error(`First offset is larger than byte length: ${firstOffset}`);
    }
    const offsets = [];
    for (let i = 0; i < itemCount; i++) {
      const start = 4 + i * 4;
      offsets.push(view.getUint32(start, true));
    }
    offsets.push(requiredByteLength);
    for (let i = 0; i < offsets.length - 1; i++) {
      if (offsets[i] > offsets[i + 1]) {
        throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);
      }
    }
    return offsets;
  }

  function serializeTable(buffers) {
    const itemCount = buffers.length;
    let totalSize = 4 * (itemCount + 1);
    const offsets = [];

    for (let i = 0; i < itemCount; i++) {
      offsets.push(totalSize);
      totalSize += buffers[i].byteLength;
    }

    const buffer = new ArrayBuffer(totalSize);
    const array = new Uint8Array(buffer);
    const view = new DataView(buffer);

    view.setUint32(0, totalSize, true);
    for (let i = 0; i < itemCount; i++) {
      view.setUint32(4 + i * 4, offsets[i], true);
      array.set(new Uint8Array(buffers[i]), offsets[i]);
    }
    return buffer;
  }

  class Uint32 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 4);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    toBigEndianUint32() {
      return this.view.getUint32(0, false);
    }

    toLittleEndianUint32() {
      return this.view.getUint32(0, true);
    }

    static size() {
      return 4;
    }
  }

  function SerializeUint32(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 4);
    return buffer;
  }

  class Uint64 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 8);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    toBigEndianBigUint64() {
      return this.view.getBigUint64(0, false);
    }

    toLittleEndianBigUint64() {
      return this.view.getUint64(0, true);
    }

    static size() {
      return 8;
    }
  }

  function SerializeUint64(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 8);
    return buffer;
  }

  class Uint128 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 16);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    static size() {
      return 16;
    }
  }

  function SerializeUint128(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 16);
    return buffer;
  }

  class Byte32 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 32);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    static size() {
      return 32;
    }
  }

  function SerializeByte32(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 32);
    return buffer;
  }

  class Uint256 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 32);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    static size() {
      return 32;
    }
  }

  function SerializeUint256(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 32);
    return buffer;
  }

  class Bytes {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
    }

    raw() {
      return this.view.buffer.slice(4);
    }

    indexAt(i) {
      return this.view.getUint8(4 + i);
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeBytes(value) {
    const item = assertArrayBuffer(value);
    const array = new Uint8Array(4 + item.byteLength);
    (new DataView(array.buffer)).setUint32(0, item.byteLength, true);
    array.set(new Uint8Array(item), 4);
    return array.buffer;
  }

  class BytesOpt {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.hasValue()) {
        this.value().validate(compatible);
      }
    }

    value() {
      return new Bytes(this.view.buffer, { validate: false });
    }

    hasValue() {
      return this.view.byteLength > 0;
    }
  }

  function SerializeBytesOpt(value) {
    if (value) {
      return SerializeBytes(value);
    } else {
      return new ArrayBuffer(0);
    }
  }

  class BytesVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      for (let i = 0; i < len(offsets) - 1; i++) {
        new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
      }
    }

    length() {
      if (this.view.byteLength < 8) {
        return 0;
      } else {
        return this.view.getUint32(4, true) / 4 - 1;
      }
    }

    indexAt(i) {
      const start = 4 + i * 4;
      const offset = this.view.getUint32(start, true);
      let offset_end = this.view.byteLength;
      if (i + 1 < this.length()) {
        offset_end = this.view.getUint32(start + 4, true);
      }
      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeBytesVec(value) {
    return serializeTable(value.map(item => SerializeBytes(item)));
  }

  class Byte32Vec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() * Byte32.size() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
      for (let i = 0; i < 0; i++) {
        const item = this.indexAt(i);
        item.validate(compatible);
      }
    }

    indexAt(i) {
      return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeByte32Vec(value) {
    const array = new Uint8Array(4 + Byte32.size() * value.length);
    (new DataView(array.buffer)).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
      const itemBuffer = SerializeByte32(value[i]);
      array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());
    }
    return array.buffer;
  }

  class ScriptOpt {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.hasValue()) {
        this.value().validate(compatible);
      }
    }

    value() {
      return new Script(this.view.buffer, { validate: false });
    }

    hasValue() {
      return this.view.byteLength > 0;
    }
  }

  function SerializeScriptOpt(value) {
    if (value) {
      return SerializeScript(value);
    } else {
      return new ArrayBuffer(0);
    }
  }

  class ProposalShortId {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 10);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    static size() {
      return 10;
    }
  }

  function SerializeProposalShortId(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 10);
    return buffer;
  }

  class UncleBlockVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      for (let i = 0; i < len(offsets) - 1; i++) {
        new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
      }
    }

    length() {
      if (this.view.byteLength < 8) {
        return 0;
      } else {
        return this.view.getUint32(4, true) / 4 - 1;
      }
    }

    indexAt(i) {
      const start = 4 + i * 4;
      const offset = this.view.getUint32(start, true);
      let offset_end = this.view.byteLength;
      if (i + 1 < this.length()) {
        offset_end = this.view.getUint32(start + 4, true);
      }
      return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeUncleBlockVec(value) {
    return serializeTable(value.map(item => SerializeUncleBlock(item)));
  }

  class TransactionVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      for (let i = 0; i < len(offsets) - 1; i++) {
        new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
      }
    }

    length() {
      if (this.view.byteLength < 8) {
        return 0;
      } else {
        return this.view.getUint32(4, true) / 4 - 1;
      }
    }

    indexAt(i) {
      const start = 4 + i * 4;
      const offset = this.view.getUint32(start, true);
      let offset_end = this.view.byteLength;
      if (i + 1 < this.length()) {
        offset_end = this.view.getUint32(start + 4, true);
      }
      return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeTransactionVec(value) {
    return serializeTable(value.map(item => SerializeTransaction(item)));
  }

  class ProposalShortIdVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() * ProposalShortId.size() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
      for (let i = 0; i < 0; i++) {
        const item = this.indexAt(i);
        item.validate(compatible);
      }
    }

    indexAt(i) {
      return new ProposalShortId(this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()), { validate: false });
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeProposalShortIdVec(value) {
    const array = new Uint8Array(4 + ProposalShortId.size() * value.length);
    (new DataView(array.buffer)).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
      const itemBuffer = SerializeProposalShortId(value[i]);
      array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());
    }
    return array.buffer;
  }

  class CellDepVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() * CellDep.size() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
      for (let i = 0; i < 0; i++) {
        const item = this.indexAt(i);
        item.validate(compatible);
      }
    }

    indexAt(i) {
      return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), { validate: false });
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeCellDepVec(value) {
    const array = new Uint8Array(4 + CellDep.size() * value.length);
    (new DataView(array.buffer)).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
      const itemBuffer = SerializeCellDep(value[i]);
      array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());
    }
    return array.buffer;
  }

  class CellInputVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() * CellInput.size() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
      for (let i = 0; i < 0; i++) {
        const item = this.indexAt(i);
        item.validate(compatible);
      }
    }

    indexAt(i) {
      return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), { validate: false });
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeCellInputVec(value) {
    const array = new Uint8Array(4 + CellInput.size() * value.length);
    (new DataView(array.buffer)).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
      const itemBuffer = SerializeCellInput(value[i]);
      array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());
    }
    return array.buffer;
  }

  class CellOutputVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      for (let i = 0; i < len(offsets) - 1; i++) {
        new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
      }
    }

    length() {
      if (this.view.byteLength < 8) {
        return 0;
      } else {
        return this.view.getUint32(4, true) / 4 - 1;
      }
    }

    indexAt(i) {
      const start = 4 + i * 4;
      const offset = this.view.getUint32(start, true);
      let offset_end = this.view.byteLength;
      if (i + 1 < this.length()) {
        offset_end = this.view.getUint32(start + 4, true);
      }
      return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeCellOutputVec(value) {
    return serializeTable(value.map(item => SerializeCellOutput(item)));
  }

  class Script {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      if (offsets[2] - offsets[1] !== 1) {
        throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`)
      }
      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
    }

    getCodeHash() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getHashType() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);
    }

    getArgs() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeScript(value) {
    const buffers = [];
    buffers.push(SerializeByte32(value.code_hash));
    const hashTypeView = new DataView(new ArrayBuffer(1));
    hashTypeView.setUint8(0, value.hash_type);
    buffers.push(hashTypeView.buffer);
    buffers.push(SerializeBytes(value.args));
    return serializeTable(buffers);
  }

  class OutPoint {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getTxHash() {
      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });
    }

    getIndex() {
      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, OutPoint.size());
      this.getTxHash().validate(compatible);
      this.getIndex().validate(compatible);
    }
    static size() {
      return 0 + Byte32.size() + Uint32.size();
    }
  }

  function SerializeOutPoint(value) {
    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());
    array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);
    array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());
    return array.buffer;
  }

  class CellInput {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getSince() {
      return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });
    }

    getPreviousOutput() {
      return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), { validate: false });
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, CellInput.size());
      this.getSince().validate(compatible);
      this.getPreviousOutput().validate(compatible);
    }
    static size() {
      return 0 + Uint64.size() + OutPoint.size();
    }
  }

  function SerializeCellInput(value) {
    const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());
    array.set(new Uint8Array(SerializeUint64(value.since)), 0);
    array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());
    return array.buffer;
  }

  class CellOutput {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
      new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
    }

    getCapacity() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getLock() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getType() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeCellOutput(value) {
    const buffers = [];
    buffers.push(SerializeUint64(value.capacity));
    buffers.push(SerializeScript(value.lock));
    buffers.push(SerializeScriptOpt(value.type_));
    return serializeTable(buffers);
  }

  class CellDep {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getOutPoint() {
      return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });
    }

    getDepType() {
      return this.view.getUint8(0 + OutPoint.size());
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, CellDep.size());
      this.getOutPoint().validate(compatible);
    }
    static size() {
      return 0 + OutPoint.size() + 1;
    }
  }

  function SerializeCellDep(value) {
    const array = new Uint8Array(0 + OutPoint.size() + 1);
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);
    view.setUint8(0 + OutPoint.size(), value.dep_type);
    return array.buffer;
  }

  class RawTransaction {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
      new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
      new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();
      new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();
      new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();
    }

    getVersion() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getCellDeps() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getHeaderDeps() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getInputs() {
      const start = 16;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getOutputs() {
      const start = 20;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getOutputsData() {
      const start = 24;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeRawTransaction(value) {
    const buffers = [];
    buffers.push(SerializeUint32(value.version));
    buffers.push(SerializeCellDepVec(value.cell_deps));
    buffers.push(SerializeByte32Vec(value.header_deps));
    buffers.push(SerializeCellInputVec(value.inputs));
    buffers.push(SerializeCellOutputVec(value.outputs));
    buffers.push(SerializeBytesVec(value.outputs_data));
    return serializeTable(buffers);
  }

  class Transaction {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
    }

    getRaw() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getWitnesses() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeTransaction(value) {
    const buffers = [];
    buffers.push(SerializeRawTransaction(value.raw));
    buffers.push(SerializeBytesVec(value.witnesses));
    return serializeTable(buffers);
  }

  class RawHeader {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getVersion() {
      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });
    }

    getCompactTarget() {
      return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), { validate: false });
    }

    getTimestamp() {
      return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()), { validate: false });
    }

    getNumber() {
      return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size()), { validate: false });
    }

    getEpoch() {
      return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size()), { validate: false });
    }

    getParentHash() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size()), { validate: false });
    }

    getTransactionsRoot() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size()), { validate: false });
    }

    getProposalsHash() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size()), { validate: false });
    }

    getUnclesHash() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), { validate: false });
    }

    getDao() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), { validate: false });
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, RawHeader.size());
      this.getVersion().validate(compatible);
      this.getCompactTarget().validate(compatible);
      this.getTimestamp().validate(compatible);
      this.getNumber().validate(compatible);
      this.getEpoch().validate(compatible);
      this.getParentHash().validate(compatible);
      this.getTransactionsRoot().validate(compatible);
      this.getProposalsHash().validate(compatible);
      this.getUnclesHash().validate(compatible);
      this.getDao().validate(compatible);
    }
    static size() {
      return 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size();
    }
  }

  function SerializeRawHeader(value) {
    const array = new Uint8Array(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());
    array.set(new Uint8Array(SerializeUint32(value.version)), 0);
    array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());
    array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());
    array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());
    array.set(new Uint8Array(SerializeUint64(value.epoch)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.parent_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.transactions_root)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.proposals_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.uncles_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.dao)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());
    return array.buffer;
  }

  class Header {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getRaw() {
      return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });
    }

    getNonce() {
      return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), { validate: false });
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, Header.size());
      this.getRaw().validate(compatible);
      this.getNonce().validate(compatible);
    }
    static size() {
      return 0 + RawHeader.size() + Uint128.size();
    }
  }

  function SerializeHeader(value) {
    const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());
    array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);
    array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());
    return array.buffer;
  }

  class UncleBlock {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
    }

    getHeader() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getProposals() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeUncleBlock(value) {
    const buffers = [];
    buffers.push(SerializeHeader(value.header));
    buffers.push(SerializeProposalShortIdVec(value.proposals));
    return serializeTable(buffers);
  }

  class Block {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
      new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
      new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();
    }

    getHeader() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getUncles() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getTransactions() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getProposals() {
      const start = 16;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeBlock(value) {
    const buffers = [];
    buffers.push(SerializeHeader(value.header));
    buffers.push(SerializeUncleBlockVec(value.uncles));
    buffers.push(SerializeTransactionVec(value.transactions));
    buffers.push(SerializeProposalShortIdVec(value.proposals));
    return serializeTable(buffers);
  }

  class CellbaseWitness {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
    }

    getLock() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getMessage() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeCellbaseWitness(value) {
    const buffers = [];
    buffers.push(SerializeScript(value.lock));
    buffers.push(SerializeBytes(value.message));
    return serializeTable(buffers);
  }

  class WitnessArgs {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
      new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
    }

    getLock() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getInputType() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getOutputType() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeWitnessArgs(value) {
    const buffers = [];
    buffers.push(SerializeBytesOpt(value.lock));
    buffers.push(SerializeBytesOpt(value.input_type));
    buffers.push(SerializeBytesOpt(value.output_type));
    return serializeTable(buffers);
  }

  exports.Block = Block;
  exports.Byte32 = Byte32;
  exports.Byte32Vec = Byte32Vec;
  exports.Bytes = Bytes;
  exports.BytesOpt = BytesOpt;
  exports.BytesVec = BytesVec;
  exports.CellDep = CellDep;
  exports.CellDepVec = CellDepVec;
  exports.CellInput = CellInput;
  exports.CellInputVec = CellInputVec;
  exports.CellOutput = CellOutput;
  exports.CellOutputVec = CellOutputVec;
  exports.CellbaseWitness = CellbaseWitness;
  exports.Header = Header;
  exports.OutPoint = OutPoint;
  exports.ProposalShortId = ProposalShortId;
  exports.ProposalShortIdVec = ProposalShortIdVec;
  exports.RawHeader = RawHeader;
  exports.RawTransaction = RawTransaction;
  exports.Script = Script;
  exports.ScriptOpt = ScriptOpt;
  exports.SerializeBlock = SerializeBlock;
  exports.SerializeByte32 = SerializeByte32;
  exports.SerializeByte32Vec = SerializeByte32Vec;
  exports.SerializeBytes = SerializeBytes;
  exports.SerializeBytesOpt = SerializeBytesOpt;
  exports.SerializeBytesVec = SerializeBytesVec;
  exports.SerializeCellDep = SerializeCellDep;
  exports.SerializeCellDepVec = SerializeCellDepVec;
  exports.SerializeCellInput = SerializeCellInput;
  exports.SerializeCellInputVec = SerializeCellInputVec;
  exports.SerializeCellOutput = SerializeCellOutput;
  exports.SerializeCellOutputVec = SerializeCellOutputVec;
  exports.SerializeCellbaseWitness = SerializeCellbaseWitness;
  exports.SerializeHeader = SerializeHeader;
  exports.SerializeOutPoint = SerializeOutPoint;
  exports.SerializeProposalShortId = SerializeProposalShortId;
  exports.SerializeProposalShortIdVec = SerializeProposalShortIdVec;
  exports.SerializeRawHeader = SerializeRawHeader;
  exports.SerializeRawTransaction = SerializeRawTransaction;
  exports.SerializeScript = SerializeScript;
  exports.SerializeScriptOpt = SerializeScriptOpt;
  exports.SerializeTransaction = SerializeTransaction;
  exports.SerializeTransactionVec = SerializeTransactionVec;
  exports.SerializeUint128 = SerializeUint128;
  exports.SerializeUint256 = SerializeUint256;
  exports.SerializeUint32 = SerializeUint32;
  exports.SerializeUint64 = SerializeUint64;
  exports.SerializeUncleBlock = SerializeUncleBlock;
  exports.SerializeUncleBlockVec = SerializeUncleBlockVec;
  exports.SerializeWitnessArgs = SerializeWitnessArgs;
  exports.Transaction = Transaction;
  exports.TransactionVec = TransactionVec;
  exports.Uint128 = Uint128;
  exports.Uint256 = Uint256;
  exports.Uint32 = Uint32;
  exports.Uint64 = Uint64;
  exports.UncleBlock = UncleBlock;
  exports.UncleBlockVec = UncleBlockVec;
  exports.WitnessArgs = WitnessArgs;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

'''
'''--- packages/base/lib/denormalizers.d.ts ---
import core from "./core";
import { OutPoint, Script } from "./api";

export function DenormalizeOutPoint(outPoint: core.OutPoint): OutPoint;

export function DenormalizeScript(script: core.Script): Script;

'''
'''--- packages/base/lib/denormalizers.js ---
const { BI } = require("@ckb-lumos/bi");
const { Reader } = require("@ckb-lumos/toolkit");

function DenormalizeOutPoint(outPoint) {
  return {
    tx_hash: new Reader(outPoint.getTxHash().raw()).serializeJson(),
    index:
      "0x" + BI.from(outPoint.getIndex().toLittleEndianUint32()).toString(16),
  };
}

function DenormalizeScript(script) {
  return {
    code_hash: new Reader(script.getCodeHash().raw()).serializeJson(),
    hash_type: script.getHashType() === 0 ? "data" : "type",
    args: new Reader(script.getArgs().raw()).serializeJson(),
  };
}

module.exports = {
  DenormalizeOutPoint,
  DenormalizeScript,
};

'''
'''--- packages/base/lib/helpers.d.ts ---
import { Cell } from "./api";
import { QueryOptions } from "./indexer";

export declare function isCellMatchQueryOptions(
  cell: Cell,
  queryOptions: QueryOptions
): boolean;

'''
'''--- packages/base/lib/helpers.js ---
const { ScriptValue } = require("./values");
const { BI } = require("@ckb-lumos/bi");

function isCellMatchQueryOptions(
  cell,
  {
    lock = undefined,
    type = undefined,
    argsLen = -1,
    data = "any",
    fromBlock = undefined,
    toBlock = undefined,
  }
) {
  let wrappedLock = null;
  let wrappedType = null;
  // Wrap the plain `Script` into `ScriptWrapper`.
  if (lock && !lock.script) {
    wrappedLock = { script: lock, argsLen: argsLen };
  } else if (lock && lock.script) {
    wrappedLock = lock;
    // check argsLen
    if (!lock.argsLen) {
      wrappedLock.argsLen = argsLen;
    }
  }
  if (type && type === "empty") {
    wrappedType = type;
  } else if (type && typeof type === "object" && !type.script) {
    wrappedType = { script: type, argsLen: argsLen };
  } else if (type && typeof type === "object" && type.script) {
    wrappedType = type;
    // check argsLen
    if (!type.argsLen) {
      wrappedType.argsLen = argsLen;
    }
  }

  if (wrappedLock && wrappedLock.script && wrappedLock.argsLen === -1) {
    if (
      !new ScriptValue(cell.cell_output.lock, {
        validate: false,
      }).equals(new ScriptValue(wrappedLock.script, { validate: false }))
    ) {
      return false;
    }
  }

  if (wrappedLock && wrappedLock.script && wrappedLock.argsLen === "any") {
    const cellLock = cell.cell_output.lock;
    if (
      cellLock.code_hash !== wrappedLock.script.code_hash ||
      cellLock.hash_type !== wrappedLock.script.hash_type ||
      !cellLock.args.startsWith(wrappedLock.script.args)
    ) {
      return false;
    }
  }

  if (
    wrappedLock &&
    wrappedLock.script &&
    typeof wrappedLock.argsLen === "number" &&
    wrappedLock.argsLen >= 0
  ) {
    const length = wrappedLock.argsLen * 2 + 2;
    const lockArgsLength = wrappedLock.script.args.length;
    const minLength = Math.min(length, lockArgsLength);

    const cellLock = cell.cell_output.lock;
    if (cellLock.args.length !== length) {
      return false;
    }
    if (
      !(
        cellLock.code_hash === wrappedLock.script.code_hash &&
        cellLock.hash_type === wrappedLock.script.hash_type &&
        cellLock.args.slice(0, minLength) ===
          wrappedLock.script.args.slice(0, minLength)
      )
    ) {
      return false;
    }
  }

  if (wrappedType && wrappedType === "empty" && cell.cell_output.type) {
    return false;
  }
  if (wrappedType && typeof wrappedType === "object") {
    if (
      !cell.cell_output.type ||
      !new ScriptValue(cell.cell_output.type, {
        validate: false,
      }).equals(new ScriptValue(wrappedType.script, { validate: false }))
    ) {
      return false;
    }
  }
  if (data && data !== "any" && cell.data !== data) {
    return false;
  }
  if (
    fromBlock &&
    cell.block_number &&
    BI.from(cell.block_number).lt(BI.from(fromBlock))
  ) {
    return false;
  }
  if (
    toBlock &&
    cell.block_number &&
    BI.from(cell.block_number).gt(BI.from(toBlock))
  ) {
    return false;
  }

  return true;
}

module.exports = {
  isCellMatchQueryOptions,
};

'''
'''--- packages/base/lib/index.js ---
module.exports = {
  core: require("./core"),
  denormalizers: require("./denormalizers"),
  values: require("./values"),
  utils: require("./utils"),
  since: require("./since"),
  helpers: require("./helpers"),
  indexer: require("./indexer"),
  logger: require("./logger"),
};

'''
'''--- packages/base/lib/indexer.d.ts ---
import { Cell, Script, Transaction, TransactionWithStatus } from "./api";
import { Hexadecimal, HexString } from "./primitive";
import { Logger } from "./logger";

/**
 * argsLen: if argsLen = 20, it means collected cells cell.cell_output.lock.args should be 20-byte length, and prefix match to lock.args.
 * And if argsLen = -1 (default), means cell.cell_output.lock.args should equals to lock.args.
 */
export interface QueryOptions {
  lock?: Script | ScriptWrapper;
  type?: Script | ScriptWrapper | "empty";
  // data = any means any data content is ok
  data?: string | "any";
  argsLen?: number | "any";
  /** `fromBlock` itself is included in range query. */
  fromBlock?: Hexadecimal;
  /** `toBlock` itself is included in range query. */
  toBlock?: Hexadecimal;
  skip?: number;
  order?: "asc" | "desc";
}

export interface ScriptWrapper {
  script: Script;
  ioType?: "input" | "output" | "both";
  argsLen?: number | "any";
}

export interface CellCollectorResults {
  [Symbol.asyncIterator](): AsyncIterator<Cell>;
}

export interface CellCollector {
  collect(): CellCollectorResults;
}

export interface CellProvider {
  uri?: string;
  collector(queryOptions: QueryOptions): CellCollector;
}

export interface Tip {
  block_number: string;
  block_hash: string;
}

export interface IndexerOptions {
  pollIntervalSeconds?: number;
  livenessCheckIntervalSeconds?: number;
  logger?: Logger;
  keepNum?: number;
  pruneInterval?: number;
  rpcOptions?: object;
}

export declare class Indexer {
  uri: string;

  running(): boolean;
  startForever(): void;
  start(): void;
  stop(): void;
  tip(): Promise<Tip>;

  collector(queries: QueryOptions): CellCollector;
  subscribe(queries: QueryOptions): NodeJS.EventEmitter;
  subscribeMedianTime(): NodeJS.EventEmitter;
  waitForSync(blockDifference?: number): Promise<void>;
}

// CellCollector
export declare interface BaseCellCollector extends CellCollector {
  count(): Promise<number>;

  collect(): CellCollectorResults;
}

// TransactionCollector
export interface TransactionCollectorOptions {
  skipMissing?: boolean;
  includeStatus?: boolean;
}

export interface TransactionCollectorResults {
  [Symbol.asyncIterator](): AsyncIterator<Transaction | TransactionWithStatus>;
}

export declare class TransactionCollector {
  constructor(
    indexer: Indexer,
    queries: QueryOptions,
    options?: TransactionCollectorOptions
  );

  count(): Promise<number>;

  getTransactionHashes(): Promise<HexString[]>;

  collect(): TransactionCollectorResults;
}

export const indexer: {
  TransactionCollector: typeof TransactionCollector;
};

'''
'''--- packages/base/lib/indexer.js ---
const { validators } = require("@ckb-lumos/toolkit");
const utils = require("./utils");

// Notice this TransactionCollector implementation only uses indexer
// here. Since the indexer we use doesn't store full transaction data,
// we will have to run CKB RPC queries on each tx hash to fetch transaction
// data. In some cases this might slow your app down. An ideal solution would
// be combining this with some cacher to accelerate this process.
class TransactionCollector {
  constructor(
    indexer,
    {
      lock = null,
      type = null,
      argsLen = -1,
      fromBlock = null,
      toBlock = null,
      order = "asc",
      skip = null,
    } = {},
    { skipMissing = false, includeStatus = true } = {}
  ) {
    if (!lock && (!type || type === "empty")) {
      throw new Error("Either lock or type script must be provided!");
    }
    // Wrap the plain `Script` into `ScriptWrapper`.
    if (lock && !lock.script) {
      validators.ValidateScript(lock);
      this.lock = { script: lock, ioType: "both", argsLen: argsLen };
    } else if (lock && lock.script) {
      validators.ValidateScript(lock.script);
      this.lock = lock;
      // check ioType, argsLen
      if (!lock.argsLen) {
        this.lock.argsLen = argsLen;
      }
      if (!lock.ioType) {
        this.lock.ioType = "both";
      }
    }
    if (type === "empty") {
      this.type = type;
    } else if (type && !type.script) {
      validators.ValidateScript(type);
      this.type = { script: type, ioType: "both", argsLen: argsLen };
    } else if (type && type.script) {
      validators.ValidateScript(type.script);
      this.type = type;
      // check ioType, argsLen
      if (!type.argsLen) {
        this.type.argsLen = argsLen;
      }
      if (!type.ioType) {
        this.type.ioType = "both";
      }
    }
    if (fromBlock) {
      utils.assertHexadecimal("fromBlock", fromBlock);
    }
    if (toBlock) {
      utils.assertHexadecimal("toBlock", toBlock);
    }
    if (order !== "asc" && order !== "desc") {
      throw new Error("Order must be either asc or desc!");
    }
    this.indexer = indexer;
    this.skipMissing = skipMissing;
    this.includeStatus = includeStatus;
    this.fromBlock = fromBlock;
    this.toBlock = toBlock;
    this.order = order;
    this.skip = skip;
    this.rpc = indexer.rpc;
  }

  async getTransactionHashes() {
    throw new Error("Not implement!");
  }

  async count() {
    let hashes = await this.getTransactionHashes();
    return hashes.size;
  }

  async *collect() {
    let hashes = await this.getTransactionHashes();
    for (const hash of hashes) {
      const tx = await this.rpc.get_transaction(hash);
      if (!this.skipMissing && !tx) {
        throw new Error(`Transaction ${h} is missing!`);
      }
      if (this.includeStatus) {
        yield tx;
      } else {
        yield tx.transaction;
      }
    }
  }
}

module.exports = {
  TransactionCollector,
};

'''
'''--- packages/base/lib/logger.d.ts ---
export type LogLevel = "warn" | "error" | string;
// Indexer
export type Logger = (level: LogLevel, message: string) => void;
export type Log = (message: string) => void;
export function deprecated(message: string): void;

'''
'''--- packages/base/lib/logger.js ---
function defaultLogger(level, message) {
  const outputMessage = `[${level}] ${message}`;

  if (level === "error") return console.warn(outputMessage);
  if (level === "warn") return console.warn(outputMessage);

  console.log(`[${level}] ${message}`);
}

function deprecated(message) {
  defaultLogger("deprecated", message);
}

exports = module.exports = { defaultLogger, deprecated };

'''
'''--- packages/base/lib/primitive.d.ts ---
/**
 * HexString represents string starts with "0x" and followed by even number(including empty) of [0-9a-fA-F] characters.
 */
export type HexString = string;
/**
 * Hexadecimal represents string starts with "0x" and followed by any number(excluding empty) of [0-9a-fA-F] characters.
 */
export type Hexadecimal = string;
export type Hash = HexString;
export type HexNumber = Hexadecimal;
export type PackedSince = string;
export type PackedDao = string;

export type Address = string;

export type HexadecimalRange = [Hexadecimal, Hexadecimal];

'''
'''--- packages/base/lib/primitive.js ---
// for typescript

'''
'''--- packages/base/lib/since.d.ts ---
import { BIish, BI } from "@ckb-lumos/bi";
import { HexNumber, PackedSince, HexString } from "./primitive";

export interface EpochSinceValue {
  length: number;
  index: number;
  number: number;
}

export type SinceType = "epochNumber" | "blockNumber" | "blockTimestamp";

export interface SinceValidationInfo {
  block_number: HexNumber;
  epoch: HexNumber;
  median_timestamp: HexNumber;
}

/**
 * Parse since and get relative or not, type, and value of since
 *
 * @param since
 */
export function parseSince(
  since: PackedSince
):
  | {
      relative: boolean;
      type: "epochNumber";
      value: EpochSinceValue;
    }
  | {
      relative: boolean;
      type: "blockNumber" | "blockTimestamp";
      value: bigint;
    };

export function parseSinceCompatible(
  since: PackedSince
):
  | {
      relative: boolean;
      type: "epochNumber";
      value: EpochSinceValue;
    }
  | {
      relative: boolean;
      type: "blockNumber" | "blockTimestamp";
      value: BI;
    };

/**
 * parse epoch from blockHeader.epoch
 *
 * @param epoch
 */
export function parseEpoch(epoch: HexString): EpochSinceValue;

/**
 * return maximum since of args
 *
 * @param args sinces in absolute-epoch-number format
 */
export function maximumAbsoluteEpochSince(...args: PackedSince[]): PackedSince;

/**
 * generate absolute-epoch-number format since
 *
 * @param params
 */
export function generateAbsoluteEpochSince(
  params: EpochSinceValue
): PackedSince;

/**
 * Will throw an error if since not in absolute-epoch-number format
 *
 * @param since
 */
export function parseAbsoluteEpochSince(since: PackedSince): EpochSinceValue;

/**
 * Will throw an error if since not in absolute-epoch-number format
 *
 * @param since
 * @param tipHeaderEpoch
 */
export function validateAbsoluteEpochSince(
  since: PackedSince,
  tipHeaderEpoch: HexString
): boolean;

/**
 * Compare since with tipHeader, check since is valid or not.
 *
 * @param since
 * @param tipHeader
 * @param sinceHeader can left empty if absolute since
 */
export function validateSince(
  since: PackedSince,
  tipSinceValidationInfo: SinceValidationInfo,
  cellSinceValidationInfo?: SinceValidationInfo
): boolean;

/**
 *
 * @param params
 */
export function generateSince(
  params:
    | {
        relative: boolean;
        type: SinceType;
        value: BIish;
      }
    | {
        relative: boolean;
        type: "epochNumber";
        value: EpochSinceValue;
      }
): PackedSince;

/**
 * generate header epoch from epoch since value
 *
 * @param params
 */
export function generateHeaderEpoch(params: EpochSinceValue): HexString;

'''
'''--- packages/base/lib/since.js ---
const { BI, isBIish } = require("@ckb-lumos/bi");
function parseSince(since) {
  const result = parseSinceCompatible(since);

  if (result.type === "epochNumber") return result;
  return { ...result, value: result.value.toBigInt() };
}

function parseSinceCompatible(since) {
  since = BI.from(since);
  const flag = since.shr(56);
  const metricFlag = flag.shr(5).and("0b11");
  let type;
  let value;
  if (metricFlag.eq(0b00)) {
    type = "blockNumber";
    value = since.and("0xFFFFFFFFFFFFFF");
  } else if (metricFlag.eq(0b01)) {
    type = "epochNumber";
    value = {
      length: since.shr(40).and(0xffff).toNumber(),
      index: since.shr(24).and(0xffff).toNumber(),
      number: since.and(0xffffff).toNumber(),
    };
  } else if (metricFlag.eq(0b10)) {
    type = "blockTimestamp";
    value = since.and("0xFFFFFFFFFFFFFF");
  } else {
    throw new Error("Invalid metric flag!");
  }

  return {
    relative: !flag.and("0x80").eq(0),
    type,
    value,
  };
}

function generateSince({ relative, type, value }) {
  let flag = BI.from(0);

  if (relative) {
    flag = flag.add(0b10000000);
  }

  if (type === "epochNumber") {
    flag = flag.add(0b00100000);
  } else if (type === "blockTimestamp") {
    flag = flag.add(0b01000000);
  }

  let v;
  if (isBIish(value)) {
    v = BI.from(value);
  } else if (typeof value === "object") {
    v = generateHeaderEpoch(value);
  } else {
    v = BI.from(value);
  }
  return _toHex(flag.shl(56).add(v));
}

function parseEpoch(epoch) {
  epoch = BI.from(epoch);
  return {
    length: epoch.shr(40).and(0xffff).toNumber(),
    index: epoch.shr(24).and(0xffff).toNumber(),
    number: epoch.and(0xffffff).toNumber(),
  };
}

function maximumAbsoluteEpochSince(...args) {
  const parsedArgs = args.map((arg) => parseAbsoluteEpochSince(arg));
  const maxNumber = Math.max(...parsedArgs.map((arg) => arg.number));
  const maxArgs = parsedArgs.filter((arg) => arg.number === maxNumber);
  let max = maxArgs[0];

  for (let i = 1; i < maxArgs.length; ++i) {
    const current = maxArgs[i];
    if (
      BI.from(current.index)
        .mul(max.length)
        .gte(BI.from(max.index).mul(current.length))
    ) {
      max = current;
    }
  }

  return generateAbsoluteEpochSince(max);
}

function generateAbsoluteEpochSince({ length, index, number }) {
  return generateSince({
    relative: false,
    type: "epochNumber",
    value: { length, index, number },
  });
}

function generateHeaderEpoch({ length, index, number }) {
  return _toHex(
    BI.from(length).shl(40).add(BI.from(index).shl(24)).add(number)
  );
}

function parseAbsoluteEpochSince(since) {
  const { relative, type, value } = parseSinceCompatible(since);

  if (!(relative === false && type === "epochNumber")) {
    throw new Error("Since format error!");
  }

  return value;
}

function validateAbsoluteEpochSince(since, tipHeaderEpoch) {
  const { value } = parseSinceCompatible(since);
  const headerEpochParams = parseEpoch(tipHeaderEpoch);
  return (
    BI.from(value.number).lt(headerEpochParams.number) ||
    (BI.from(value.number).eq(headerEpochParams.number) &&
      BI.from(value.index)
        .mul(headerEpochParams.length)
        .lte(BI.from(headerEpochParams.index).mul(value.length)))
  );
}

function validateSince(since, tipSinceValidationInfo, cellSinceValidationInfo) {
  const { relative, type, value } = parseSinceCompatible(since);

  if (!relative) {
    if (type === "epochNumber") {
      return validateAbsoluteEpochSince(since, tipSinceValidationInfo.epoch);
    }

    if (type === "blockNumber") {
      return BI.from(value).lte(tipSinceValidationInfo.block_number);
    }

    if (type === "blockTimestamp") {
      if (!tipSinceValidationInfo.median_timestamp) {
        throw new Error(`Must provide tip median_timestamp!`);
      }
      return BI.from(value)
        .mul(1000)
        .lte(tipSinceValidationInfo.median_timestamp);
    }
  } else {
    if (type === "epochNumber") {
      const tipHeaderEpoch = parseEpoch(tipSinceValidationInfo.epoch);
      const sinceHeaderEpoch = parseEpoch(cellSinceValidationInfo.epoch);
      const added = {
        number: BI.from(value.number).add(sinceHeaderEpoch.number),
        index: BI.from(value.index)
          .mul(sinceHeaderEpoch.length)
          .add(BI.from(sinceHeaderEpoch.index).mul(value.length)),
        length: BI.from(value.length).mul(sinceHeaderEpoch.length),
      };

      if (value.length === 0 && sinceHeaderEpoch.length !== 0) {
        added.index = sinceHeaderEpoch.index;
        added.length = sinceHeaderEpoch.length;
      } else if (sinceHeaderEpoch.length === 0 && value.length !== 0) {
        added.index = BI.from(value.index);
        added.length = BI.from(value.length);
      }

      if (
        !BI.from(added.length).eq(0) &&
        BI.from(added.index).gte(added.length)
      ) {
        added.number = added.index.div(added.length).add(added.number);
        added.index = added.index.mod(added.length);
      }

      return (
        BI.from(added.number).lt(tipHeaderEpoch.number) ||
        (BI.from(added.number).eq(tipHeaderEpoch.number) &&
          BI.from(added.index)
            .mul(tipHeaderEpoch.length)
            .lte(BI.from(tipHeaderEpoch.index).mul(added.length)))
      );
    }

    if (type === "blockNumber") {
      return BI.from(value)
        .add(cellSinceValidationInfo.block_number)
        .lte(tipSinceValidationInfo.block_number);
    }

    if (type === "blockTimestamp") {
      if (
        !tipSinceValidationInfo.median_timestamp ||
        !cellSinceValidationInfo.median_timestamp
      ) {
        throw new Error(`Must provide median_timestamp!`);
      }
      return BI.from(value)
        .mul(1000)
        .add(cellSinceValidationInfo.median_timestamp)
        .lte(tipSinceValidationInfo.median_timestamp);
    }
  }
}

function _toHex(num) {
  return "0x" + num.toString(16);
}

module.exports = {
  parseSince,
  parseSinceCompatible,
  parseEpoch,
  maximumAbsoluteEpochSince,
  generateAbsoluteEpochSince,
  parseAbsoluteEpochSince,
  validateAbsoluteEpochSince,
  validateSince,
  generateSince,
  generateHeaderEpoch,
};

'''
'''--- packages/base/lib/utils.d.ts ---
import { Reader } from "@ckb-lumos/toolkit";
import { HexNumber } from "..";
import { BI, BIish } from "@ckb-lumos/bi";
import { Script, Input } from "./api";
import { Hash, HexString } from "./primitive";

export class CKBHasher {
  update(data: string | Reader | ArrayBuffer): this;

  digestReader(): Reader;

  digestHex(): Hash;
}

export function ckbHash(buffer: ArrayBuffer): Reader;

/**
 * convert bigint to BigUInt64 little-endian hex string
 *
 * @param num
 */
export function toBigUInt64LE(num: BIish): HexString;

/**
 * convert BigUInt64 little-endian hex string to bigint
 *
 * @param hex BigUInt64 little-endian hex string
 */
export function readBigUInt64LE(hex: HexString): bigint;
export function readBigUInt64LECompatible(hex: HexString): BI;

/**
 * convert bigint to BigUInt128 little-endian hex string
 *
 * @param u128
 */
export function toBigUInt128LE(u128: BIish): string;

/**
 * convert BigUInt64 little-endian hex string to bigint
 *
 * @param leHex BigUInt128 little-endian hex string
 */
export function readBigUInt128LE(leHex: HexString): bigint;
export function readBigUInt128LECompatible(leHex: HexString): BI;

/**
 * compute lock/type hash
 *
 * @param script
 * @param options
 */
export function computeScriptHash(
  script: Script,
  options?: { validate?: boolean }
): Hash;

export function hashCode(buffer: Buffer): number;

export function assertHexString(debugPath: string, str: string): void;

export function assertHexadecimal(debugPath: string, str: string): void;

export function isDeepEqual(a: unknown, b: unknown): boolean;
export function generateTypeIdScript(
  input: Input,
  outputIndex?: HexNumber
): Script;

'''
'''--- packages/base/lib/utils.js ---
const blake2b = require("blake2b");
const { validators, normalizers, Reader } = require("@ckb-lumos/toolkit");
const isEqual = require("lodash.isequal");
const { SerializeScript, SerializeCellInput } = require("./core");
const { xxHash32 } = require("js-xxhash");
const { BI } = require("@ckb-lumos/bi");

class CKBHasher {
  constructor() {
    this.hasher = blake2b(
      32,
      null,
      null,
      new Uint8Array(Reader.fromRawString("ckb-default-hash").toArrayBuffer())
    );
  }

  update(data) {
    this.hasher.update(new Uint8Array(new Reader(data).toArrayBuffer()));
    return this;
  }

  digestReader() {
    const out = new Uint8Array(32);
    this.hasher.digest(out);
    return new Reader(out.buffer);
  }

  digestHex() {
    return this.digestReader().serializeJson();
  }
}

function ckbHash(buffer) {
  const hasher = new CKBHasher();
  hasher.update(buffer);
  return hasher.digestReader();
}

function toBigUInt64LE(num) {
  return toBigUInt64LECompatible(num);
}

function toBigUInt64LECompatible(num) {
  num = BI.from(num);
  const buf = Buffer.alloc(8);
  buf.writeUInt32LE(num.and("0xffffffff").toNumber(), 0);
  num = num.shr(32);
  buf.writeUInt32LE(num.and("0xffffffff").toNumber(), 4);
  return `0x${buf.toString("hex")}`;
}

function readBigUInt64LE(hex) {
  return readBigUInt64LECompatible(hex).toBigInt();
}

function readBigUInt64LECompatible(hex) {
  const buf = Buffer.from(hex.slice(2), "hex");
  return BI.from(buf.readUInt32LE()).add(BI.from(buf.readUInt32LE(4)).shl(32));
}

// const U128_MIN = BigInt(0);
// const U128_MAX = BigInt("340282366920938463463374607431768211455");
function toBigUInt128LE(u128) {
  return toBigUInt128LECompatible(u128);
}

const U128_MIN_COMPATIBLE = BI.from(0);
const U128_MAX_COMPATIBLE = BI.from("340282366920938463463374607431768211455");
function toBigUInt128LECompatible(num) {
  num = BI.from(num);
  if (num.lt(U128_MIN_COMPATIBLE)) {
    throw new Error(`u128 ${num} too small`);
  }

  if (num.gt(U128_MAX_COMPATIBLE)) {
    throw new Error(`u128 ${num} too large`);
  }

  const buf = Buffer.alloc(16);
  buf.writeUInt32LE(num.and(0xffffffff).toNumber(), 0);
  num = num.shr(32);
  buf.writeUInt32LE(num.and(0xffffffff).toNumber(), 4);

  num = num.shr(32);
  buf.writeUInt32LE(num.and(0xffffffff).toNumber(), 8);

  num = num.shr(32);
  buf.writeUInt32LE(num.and(0xffffffff).toNumber(), 12);
  return `0x${buf.toString("hex")}`;
}

function readBigUInt128LE(leHex) {
  return readBigUInt128LECompatible(leHex).toBigInt();
}

function readBigUInt128LECompatible(leHex) {
  if (leHex.length < 34 || !leHex.startsWith("0x")) {
    throw new Error(`leHex format error`);
  }

  const buf = Buffer.from(leHex.slice(2, 34), "hex");

  return BI.from(buf.readUInt32LE(0))
    .shl(0)
    .add(BI.from(buf.readUInt32LE(4)).shl(32))
    .add(BI.from(buf.readUInt32LE(8)).shl(64))
    .add(BI.from(buf.readUInt32LE(12)).shl(96));
}

function computeScriptHash(script, { validate = true } = {}) {
  if (validate) {
    validators.ValidateScript(script);
  }

  return ckbHash(
    new Reader(SerializeScript(normalizers.NormalizeScript(script)))
  ).serializeJson();
}

function hashCode(buffer) {
  return xxHash32(buffer, 0);
}

function assertHexString(debugPath, str) {
  if (!/^0x([0-9a-fA-F][0-9a-fA-F])*$/.test(str)) {
    throw new Error(`${debugPath} must be a hex string!`);
  }
}

function assertHexadecimal(debugPath, str) {
  if (!/^0x(0|[0-9a-fA-F]+)$/.test(str)) {
    throw new Error(`${debugPath} must be a hexadecimal!`);
  }
}

function isDeepEqual(a, b) {
  return isEqual(a, b);
}
// Buffer.from('TYPE_ID')
const TYPE_ID_CODE_HASH =
  "0x00000000000000000000000000000000000000000000000000545950455f4944";

function generateTypeIdArgs(input, outputIndex) {
  const outPointBuf = SerializeCellInput(normalizers.NormalizeCellInput(input));
  const outputIndexBuf = toBigUInt64LE(outputIndex);
  const ckbHasher = new CKBHasher();
  ckbHasher.update(outPointBuf);
  ckbHasher.update(outputIndexBuf);
  return ckbHasher.digestHex();
}

function generateTypeIdScript(input, outputIndex = "0x0") {
  validators.ValidateCellInput(input);
  assertHexadecimal("outputIndex", outputIndex);

  const args = generateTypeIdArgs(input, outputIndex);
  return {
    code_hash: TYPE_ID_CODE_HASH,
    hash_type: "type",
    args,
  };
}

module.exports = {
  CKBHasher,
  ckbHash,
  toBigUInt64LE,
  toBigUInt64LECompatible,
  readBigUInt64LE,
  readBigUInt64LECompatible,
  toBigUInt128LE,
  toBigUInt128LECompatible,
  readBigUInt128LE,
  readBigUInt128LECompatible,
  computeScriptHash,
  hashCode,
  assertHexString,
  assertHexadecimal,
  isDeepEqual,
  generateTypeIdScript,
};

'''
'''--- packages/base/lib/values.d.ts ---
import { OutPoint, RawTransaction, Script, Transaction } from "./api";
import { Hash } from "./primitive";

declare class Value {
  equals(other: Value): boolean;

  hashCode(): number;

  hash(): Hash;
}

export class ScriptValue extends Value {
  constructor(script: Script, options: { validate?: boolean });
}

export class OutPointValue extends Value {
  constructor(outPoint: OutPoint, options: { validate?: boolean });
}
export class RawTransactionValue extends Value {
  constructor(rawTransaction: RawTransaction, options?: { validate?: boolean });
}

export class TransactionValue extends Value {
  constructor(transaction: Transaction, options?: { validate?: boolean });
}

'''
'''--- packages/base/lib/values.js ---
// This module provides a ValueObject implementation for CKB related data
// structures to allow seamless immutable.js integration.
const { validators, normalizers, Reader } = require("@ckb-lumos/toolkit");
const { xxHash32 } = require("js-xxhash");
const core = require("./core");
const { ckbHash } = require("./utils");

class Value {
  constructor(buffer, value) {
    this.buffer = buffer;
    this.value = value;
  }

  equals(other) {
    return (
      new Reader(this.buffer).serializeJson() ===
      new Reader(other.buffer).serializeJson()
    );
  }

  hashCode() {
    return xxHash32(Buffer.from(this.buffer), 0);
  }

  hash() {
    return ckbHash(this.buffer).serializeJson();
  }
}

class ScriptValue extends Value {
  constructor(script, { validate = true } = {}) {
    if (validate) {
      validators.ValidateScript(script);
    }
    super(core.SerializeScript(normalizers.NormalizeScript(script)), script);
  }
}

class OutPointValue extends Value {
  constructor(outPoint, { validate = true } = {}) {
    if (validate) {
      validators.ValidateOutPoint(outPoint);
    }
    super(
      core.SerializeOutPoint(normalizers.NormalizeOutPoint(outPoint)),
      outPoint
    );
  }
}

class RawTransactionValue extends Value {
  constructor(rawTransaction, { validate = true } = {}) {
    if (validate) {
      validators.ValidateRawTransaction(rawTransaction);
    }
    super(
      core.SerializeRawTransaction(
        normalizers.NormalizeRawTransaction(rawTransaction)
      ),
      rawTransaction
    );
  }
}

class TransactionValue extends Value {
  constructor(transaction, { validate = true } = {}) {
    if (validate) {
      validators.ValidateTransaction(transaction);
    }
    super(
      core.SerializeTransaction(normalizers.NormalizeTransaction(transaction)),
      transaction
    );
  }
}

module.exports = {
  ScriptValue,
  OutPointValue,
  RawTransactionValue,
  TransactionValue,
};

'''
'''--- packages/base/package.json ---
{
  "name": "@ckb-lumos/base",
  "version": "0.17.0-rc8",
  "description": "Base data structures and utilities used in lumos",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "files": [
    "lib",
    "index.d.ts"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{lib,tests}/**/*.js\" index.d.ts package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{lib,tests}/**/*.js\"",
    "regenerate-schema": "mkdir -p tmp && curl -L https://raw.githubusercontent.com/nervosnetwork/ckb/b8a4743c4ae9368f5d56880c74d7edb7580d0d45/util/types/schemas/blockchain.mol -o tmp/blockchain.mol && moleculec --language - --schema-file tmp/blockchain.mol --format json > tmp/core.json && moleculec-es -inputFile tmp/core.json -outputFile tmp/core.esm.js -generateTypeScriptDefinition && rollup -f umd -i tmp/core.esm.js -o lib/core.js --name CKBCore && cp tmp/core.esm.d.ts lib/core.d.ts && rm -rf tmp",
    "test": "ava"
  },
  "devDependencies": {
    "rollup": "^1.32.0"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "dependencies": {
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8",
    "@types/lodash.isequal": "^4.5.5",
    "blake2b": "^2.1.3",
    "js-xxhash": "^1.0.4",
    "lodash.isequal": "^4.5.0"
  },
  "peerDependencies": {
    "jsbi": "^4.1.0"
  }
}

'''
'''--- packages/base/tests/denormalizers.js ---
const test = require("ava");
const { normalizers } = require("@ckb-lumos/toolkit");

const core = require("../lib/core");
const denormalizers = require("../lib/denormalizers");

test.before(() => {
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("denormalize script", (t) => {
  const script = {
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: "0x1234",
    hash_type: "data",
  };
  const data = core.SerializeScript(normalizers.NormalizeScript(script));
  const script2 = denormalizers.DenormalizeScript(new core.Script(data));
  t.deepEqual(script, script2);
});

test("denormalize out_point", (t) => {
  const outPoint = {
    tx_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    index: "0x3",
  };
  const data = core.SerializeOutPoint(normalizers.NormalizeOutPoint(outPoint));
  const outPoint2 = denormalizers.DenormalizeOutPoint(new core.OutPoint(data));
  t.deepEqual(outPoint, outPoint2);
});

'''
'''--- packages/base/tests/is_cell_match_query_options.js ---
const test = require("ava");
const { helpers } = require("../lib");
const { isCellMatchQueryOptions } = helpers;

const cells = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x486ead64a7c2c1a3132c2e03d2af364050f4f0f6dfafad291daa7db6aed53e10",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: {
        code_hash:
          "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
        hash_type: "type",
        args:
          "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
      },
    },
    data: "0x10270000000000000000000000000000",
    out_point: {
      tx_hash:
        "0x486ead64a7c2c1a3132c2e03d2af364050f4f0f6dfafad291daa7db6aed53e10",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x2",
  },
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d80000000000000000",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x486ead64a7c2c1a3132c2e03d2af364050f4f0f6dfafad291daa7db6aed53e10",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x5",
  },
];

function filterIndex(cells, queryOptions) {
  return cells
    .map((cell, index) => {
      if (isCellMatchQueryOptions(cell, queryOptions)) {
        return index;
      }
      return undefined;
    })
    .filter((index) => typeof index === "number");
}

test.before(() => {
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("filter by lock", (t) => {
  const queryOptions = {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
  };

  t.deepEqual(filterIndex(cells, queryOptions), [0, 1]);
});

test("filter by wrapped lock", (t) => {
  const queryOptions = {
    lock: {
      script: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
    },
  };

  t.deepEqual(filterIndex(cells, queryOptions), [0, 1]);
});

test("filter by lock & empty type", (t) => {
  const queryOptions = {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
    type: "empty",
  };

  t.deepEqual(filterIndex(cells, queryOptions), [0]);
});

test("filter by wrapped lock & empty type", (t) => {
  const queryOptions = {
    lock: {
      script: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
    },
    type: "empty",
  };

  t.deepEqual(filterIndex(cells, queryOptions), [0]);
});

test("filter by lock & type", (t) => {
  const queryOptions = {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
    type: {
      code_hash:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      hash_type: "type",
      args:
        "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
    },
  };

  t.deepEqual(filterIndex(cells, queryOptions), [1]);
});

test("filter by wrapped lock & wrapped type", (t) => {
  const queryOptions = {
    lock: {
      script: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
    },
    type: {
      script: {
        code_hash:
          "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
        hash_type: "type",
        args:
          "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
      },
    },
  };

  t.deepEqual(filterIndex(cells, queryOptions), [1]);
});

test("filter by lock & data", (t) => {
  const queryOptions = {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
    data: "0x10270000000000000000000000000000",
  };

  t.deepEqual(filterIndex(cells, queryOptions), [1]);
});

test("filter by lock & argsLen", (t) => {
  const queryOptions = {
    lock: {
      code_hash:
        "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      hash_type: "type",
      args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
    },
    argsLen: 28,
  };

  t.deepEqual(filterIndex(cells, queryOptions), [2]);
});

test("filter by wrapped lock & argsLen", (t) => {
  const queryOptions = {
    lock: {
      script: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
      },
      argsLen: 28,
    },
  };

  t.deepEqual(filterIndex(cells, queryOptions), [2]);
});

test("filter by lock & argsLen, failed", (t) => {
  const queryOptions = {
    lock: {
      code_hash:
        "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      hash_type: "type",
      args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
    },
    argsLen: 27,
  };

  t.deepEqual(filterIndex(cells, queryOptions), []);
});

test("filter by fromBlock", (t) => {
  const queryOptions = {
    fromBlock: "0x2",
  };
  t.deepEqual(filterIndex(cells, queryOptions), [1, 2]);
});

test("filter by toBlock", (t) => {
  const queryOptions = {
    toBlock: "0x2",
  };
  t.deepEqual(filterIndex(cells, queryOptions), [0, 1]);
});

test("filter by fromBlock & toBlock", (t) => {
  const queryOptions = {
    fromBlock: "0x3",
    toBlock: "0x6",
  };
  t.deepEqual(filterIndex(cells, queryOptions), [2]);
});

test("filter by argsLen = any", (t) => {
  t.deepEqual(
    filterIndex(cells, {
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
      },
      argsLen: "any",
    }),
    [2]
  );

  t.deepEqual(
    filterIndex(cells, {
      argsLen: "any",
    }),
    [0, 1, 2]
  );
});

'''
'''--- packages/base/tests/since.test.js ---
const test = require("ava");
const { BI } = require("@ckb-lumos/bi");

const { since, utils } = require("../lib");

const {
  parseSinceCompatible,
  generateSince,
  parseEpoch,
  maximumAbsoluteEpochSince,
  generateAbsoluteEpochSince,
  parseAbsoluteEpochSince,
  validateAbsoluteEpochSince,
  validateSince,
  generateHeaderEpoch,
} = since;

const fixtrues = [
  {
    since: "0x3039",
    parsed: {
      relative: false,
      type: "blockNumber",
      value: BI.from(12345),
    },
  },
  {
    since: "0x400000005e83d980",
    parsed: {
      relative: false,
      type: "blockTimestamp",
      value: BI.from(+new Date("2020-04-01")).div(1000),
    },
  },
  {
    since: "0x2000000000000400",
    parsed: {
      relative: false,
      type: "epochNumber",
      value: {
        number: 1024,
        index: 0,
        length: 0,
      },
    },
  },
  {
    since: "0x8000000000000064",
    parsed: {
      relative: true,
      type: "blockNumber",
      value: BI.from(100),
    },
  },
  {
    since: "0xc000000000127500",
    parsed: {
      relative: true,
      type: "blockTimestamp",
      value: BI.from(14 * 24 * 60 * 60),
    },
  },
  {
    since: "0xa000000000000018",
    parsed: {
      relative: true,
      type: "epochNumber",
      value: {
        number: 24,
        length: 0,
        index: 0,
      },
    },
  },
];

const epochFixtrue = {
  epoch: "0x" + BI.from("1979121332649985").toString(16),
  parsed: {
    length: 1800,
    index: 24,
    number: 1,
  },
};
test.before(() => {
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("parsedSince", (t) => {
  fixtrues.forEach((v) => {
    const parsed = parseSinceCompatible(v.since);
    t.true(utils.isDeepEqual(parsed, v.parsed));
  });
});

test("generateSince", (t) => {
  fixtrues.forEach((v) => {
    const since = generateSince(v.parsed);
    t.is(since, v.since);
  });
});

test("parseEpoch", (t) => {
  const result = parseEpoch(epochFixtrue.epoch);
  t.deepEqual(result, epochFixtrue.parsed);
});

test("generateHeaderEpoch", (t) => {
  const result = generateHeaderEpoch(epochFixtrue.parsed);
  t.is(result, epochFixtrue.epoch);
});

test("generateAbsoluteEpochSince", (t) => {
  fixtrues
    .filter(
      (f) => f.parsed.type === "epochNumber" && f.parsed.relative === false
    )
    .map((f) => {
      const since = generateAbsoluteEpochSince(f.parsed.value);
      t.deepEqual(since, f.since);
    });
});

test("parseAbsoluteEpochSince", (t) => {
  fixtrues.map((f) => {
    if (f.parsed.relative === false && f.parsed.type === "epochNumber") {
      t.deepEqual(parseAbsoluteEpochSince(f.since), f.parsed.value);
    } else {
      t.throws(() => parseAbsoluteEpochSince(f.since));
    }
  });
});

test("validateSince, absolute blockNumber", (t) => {
  const since = generateSince({
    relative: false,
    type: "blockNumber",
    value: BI.from("12345").toString(),
  });

  const cellSinceValidationInfo = {
    number: "0x" + BI.from(11).toString(16),
  };

  t.true(
    validateSince(
      since,
      {
        block_number: "0x" + BI.from(12345).toString(16),
      },
      cellSinceValidationInfo
    )
  );
  t.false(
    validateSince(
      since,
      {
        block_number: "0x" + BI.from(12345 - 1).toString(16),
      },
      cellSinceValidationInfo
    )
  );
});

test("validateSince, relative blockNumber", (t) => {
  const since = generateSince({
    relative: true,
    type: "blockNumber",
    value: BI.from("12345"),
  });

  const cellSinceValidationInfo = {
    block_number: "0x" + BI.from(11).toString(16),
  };

  t.true(
    validateSince(
      since,
      {
        block_number: "0x" + BI.from(11 + 12345).toString(16),
      },
      cellSinceValidationInfo
    )
  );
  t.false(
    validateSince(
      since,
      {
        block_number: "0x" + BI.from(11 + 12345 - 1).toString(16),
      },
      cellSinceValidationInfo
    )
  );
});

test("validateSince, absolute blockTimestamp", (t) => {
  const timestamp = BI.from(+new Date("2020-04-01")).div(1000);
  const since = generateSince({
    relative: false,
    type: "blockTimestamp",
    value: BI.from(timestamp.toString()),
  });

  const cellSinceValidationInfo = {
    // timestamp: "0x" + BigInt(+new Date("2020-01-01")).toString(16),
  };
  const validTipMedianTimestamp = "0x" + timestamp.mul(1000).toString(16);
  const invalidTipMedianTimestamp =
    "0x" + timestamp.mul(1000).sub(1).toString(16);
  t.true(
    validateSince(
      since,
      {
        median_timestamp: validTipMedianTimestamp,
      },
      cellSinceValidationInfo
    )
  );
  t.false(
    validateSince(
      since,
      {
        median_timestamp: invalidTipMedianTimestamp,
      },
      cellSinceValidationInfo
    )
  );
});

test("validateSince, relative blockTimestamp", (t) => {
  const timestamp = BI.from(14 * 24 * 60 * 60);
  const since = generateSince({
    relative: true,
    type: "blockTimestamp",
    value: BI.from(timestamp.toString()),
  });

  const cellMedianTimestamp =
    "0x" + BI.from(+new Date("2020-01-01")).toString(16);
  const cellSinceValidationInfo = {
    median_timestamp: cellMedianTimestamp,
  };

  const validTipMedianTimestamp =
    "0x" + BI.from(cellMedianTimestamp).add(timestamp.mul(1000)).toString(16);
  const invalidTipMedianTimestamp =
    "0x" +
    BI.from(cellMedianTimestamp).add(timestamp.mul(1000)).sub(1).toString(16);
  t.true(
    validateSince(
      since,
      {
        median_timestamp: validTipMedianTimestamp,
      },
      cellSinceValidationInfo
    )
  );
  t.false(
    validateSince(
      since,
      {
        median_timestamp: invalidTipMedianTimestamp,
      },
      cellSinceValidationInfo
    )
  );
});

test("validateSince, absolute epochNumber", (t) => {
  const value = {
    number: 1024,
    index: 0,
    length: 0,
  };
  const since = generateSince({
    relative: false,
    type: "epochNumber",
    value: value,
  });

  const cellSinceValidationInfo = {
    epoch: generateHeaderEpoch({
      number: 1000,
      index: 0,
      length: 0,
    }),
  };

  t.true(
    validateSince(
      since,
      {
        epoch: generateHeaderEpoch(value),
      },
      cellSinceValidationInfo
    )
  );
  t.false(
    validateSince(
      since,
      {
        epoch: generateHeaderEpoch({
          number: 1023,
          length: 1800,
          index: 1799,
        }),
      },
      cellSinceValidationInfo
    )
  );
});

test("validateSince, relative epochNumber", (t) => {
  const value = {
    number: 1024,
    index: 0,
    length: 0,
  };
  const since = generateSince({
    relative: true,
    type: "epochNumber",
    value: value,
  });

  const cellSinceValidationInfo = {
    epoch: generateHeaderEpoch({
      number: 1000,
      index: 0,
      length: 0,
    }),
  };

  t.true(
    validateSince(
      since,
      {
        epoch: generateHeaderEpoch({
          number: 2024,
          length: 0,
          index: 0,
        }),
      },
      cellSinceValidationInfo
    )
  );
  t.false(
    validateSince(
      since,
      {
        epoch: generateHeaderEpoch({
          number: 2023,
          length: 1800,
          index: 1799,
        }),
      },
      cellSinceValidationInfo
    )
  );
});

test("validateAbsoluteEpochSince", (t) => {
  const value = {
    number: 1024,
    index: 0,
    length: 0,
  };
  const since = generateSince({
    relative: false,
    type: "epochNumber",
    value: value,
  });
  t.true(validateAbsoluteEpochSince(since, generateHeaderEpoch(value)));
});

test("maximumAbsoluteEpochSince", (t) => {
  const one = generateAbsoluteEpochSince({
    number: 1024,
    length: 1800,
    index: 1000,
  });
  const another = generateAbsoluteEpochSince({
    number: 1024,
    length: 1800,
    index: 1001,
  });

  t.is(maximumAbsoluteEpochSince(one, another), another);
});

'''
'''--- packages/base/tests/utils-bigint.test.js ---
const test = require("ava");

const { readBigUInt128LE, toBigUInt128LE } = require("../lib/utils");

const u128 = BigInt("1208925819614629174706177");
const u128le = "0x01000000000000000000010000000000";

test("BigInt:toBigUInt128LE", (t) => {
  t.is(toBigUInt128LE(u128), u128le);
});

test("BigInt:toBigUInt128LE, to small", (t) => {
  t.throws(() => toBigUInt128LE(-1n));
  t.notThrows(() => toBigUInt128LE(0n));
});

test("BigInt:toBigUInt128LE, to big", (t) => {
  t.throws(() => toBigUInt128LE(2n ** 128n));
  t.notThrows(() => toBigUInt128LE(2n ** 128n - 1n));
});

test("BigInt:readBigUInt128LE", (t) => {
  t.is(readBigUInt128LE(u128le), u128);
});

'''
'''--- packages/base/tests/utils.test.js ---
const test = require("ava");
const { Reader } = require("@ckb-lumos/toolkit");
const { BI } = require("@ckb-lumos/bi");

const {
  CKBHasher,
  ckbHash,
  toBigUInt64LECompatible,
  readBigUInt64LECompatible,
  readBigUInt128LECompatible,
  toBigUInt128LECompatible,
  computeScriptHash,
  hashCode,
  assertHexString,
  assertHexadecimal,
  generateTypeIdScript,
} = require("../lib/utils");

const message = "0x";
const messageDigest =
  "0x44f4c69744d5f8c55d642062949dcae49bc4e7ef43d388c5a12f42b5633d163e";

test.before(() => {
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("CKBHasher, hex", (t) => {
  const result = new CKBHasher().update(message).digestHex();
  t.is(result, messageDigest);
});

test("CKBHasher, reader", (t) => {
  const result = new CKBHasher().update(new Reader(message)).digestHex();
  t.is(result, messageDigest);
});

test("ckbHash", (t) => {
  const arrayBuffer = new Reader(message).toArrayBuffer();
  const result = ckbHash(arrayBuffer);
  t.is(result.serializeJson(), messageDigest);
});

const uint64Compatible = BI.from(1965338);
const uint64leCompatible = "0x1afd1d0000000000";

test("toBigUInt64LECompatible", (t) => {
  t.is(toBigUInt64LECompatible(uint64Compatible), uint64leCompatible);
});

test("readBigUInt64LECompatible", (t) => {
  t.true(readBigUInt64LECompatible(uint64leCompatible).eq(uint64Compatible));
});
const u128Compatible = BI.from("1208925819614629174706177");
const u128leCompatible = "0x01000000000000000000010000000000";

test("toBigUInt128LECompatible", (t) => {
  t.is(toBigUInt128LECompatible(u128Compatible), u128leCompatible);
});

test("toBigUInt128LECompatible, to small", (t) => {
  t.throws(() => toBigUInt128LECompatible(BI.from(-1)));
  t.notThrows(() => toBigUInt128LECompatible(0));
});

test("toBigUInt128LECompatible, to big", (t) => {
  t.throws(() => toBigUInt128LECompatible(BI.from(2).pow(128)));
  t.notThrows(() => toBigUInt128LECompatible(BI.from(2).pow(128).sub(1)));
});

test("readBigUInt128LECompatible", (t) => {
  t.true(readBigUInt128LECompatible(u128leCompatible).eq(u128Compatible));
});

const script = {
  code_hash:
    "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
  hash_type: "type",
  args: "0x36c329ed630d6ce750712a477543672adab57f4c",
};
const scriptHash =
  "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d";

test("computeScriptHash", (t) => {
  t.is(computeScriptHash(script), scriptHash);
});

test("hashCode, should return same hash if same input", (t) => {
  const buffer = Buffer.from("1234ab", "hex");
  t.is(hashCode(buffer), hashCode(buffer));
});

test("assertHexString", (t) => {
  t.notThrows(() => assertHexString("", "0x"));
  t.notThrows(() => assertHexString("", "0x1234"));
  t.throws(() => assertHexString("", "1234"));
  t.throws(() => assertHexString("", "0x123"));
  t.throws(() => assertHexString("", "0x123h"));
});

test("assertHexadecimal", (t) => {
  t.notThrows(() => assertHexadecimal("", "0x0"));
  t.notThrows(() => assertHexadecimal("", "0x01"));
  t.notThrows(() => assertHexadecimal("", "0x12"));
  t.throws(() => assertHexadecimal("", "12"));
  t.throws(() => assertHexadecimal("", "1r"));
});

test("test type id", (t) => {
  const input = {
    previous_output: {
      index: "0x0",
      tx_hash:
        "0x128b201cd1995efba3126d4431f837c34f7d2f6a29ed8968d2ebc39059add56a",
    },
    since: "0x0",
  };
  const typeIdScript = {
    args: "0xa803c9ed6c190fd780e64d885794933ab23da641e94ad1b9270ebac893a7cdcc",
    code_hash:
      "0x00000000000000000000000000000000000000000000000000545950455f4944",
    hash_type: "type",
  };
  t.deepEqual(generateTypeIdScript(input, "0x0"), typeIdScript);
});

'''
'''--- packages/bi/README.md ---
# @ckb-lumos/bi

A big number library for lumos.

## Example

```ts
import { BI } from "@ckb-lumos/bi";

BI.from(1).add(1)
```

'''
'''--- packages/bi/package.json ---
{
  "name": "@ckb-lumos/bi",
  "version": "0.17.0-rc8",
  "description": "Bigint support in lumos",
  "author": "",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib"
  ],
  "dependencies": {
    "jsbi": "^4.1.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests,examples}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests,examples}/**/*.ts\"",
    "test": "ava **/*.test.ts --timeout=2m",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  }
}

'''
'''--- packages/bi/src/index.ts ---
import JSBI from "jsbi";
export type BIish = number | string | bigint | BI;

export function isBIish(value: any): value is BIish {
  return (
    value !== null &&
    ((typeof value === "number" && value % 1 === 0) ||
      (typeof value === "string" &&
        (!!value.match(/^0x(0|[0-9a-fA-F]+)$/) ||
          !!value.match(/^-?[0-9]+$/))) ||
      typeof value === "bigint" ||
      BI.isBI(value))
  );
}

export class BI {
  private readonly jsbi: JSBI;
  readonly _isBI: boolean;

  constructor(value: JSBI) {
    this.jsbi = value;
    this._isBI = true;
  }

  add(other: BIish): BI {
    return toBI(JSBI.add(this.jsbi, toJSBI(other)));
  }

  sub(other: BIish): BI {
    return toBI(JSBI.subtract(this.jsbi, toJSBI(other)));
  }

  div(other: BIish): BI {
    return toBI(JSBI.divide(this.jsbi, toJSBI(other)));
  }

  mul(other: BIish): BI {
    return toBI(JSBI.multiply(this.jsbi, toJSBI(other)));
  }

  mod(other: BIish): BI {
    return toBI(JSBI.remainder(this.jsbi, toJSBI(other)));
  }

  abs(): BI {
    if (JSBI.greaterThanOrEqual(this.jsbi, toJSBI(0))) {
      return toBI(this.jsbi);
    } else {
      return toBI(JSBI.unaryMinus(this.jsbi));
    }
  }

  pow(other: BIish): BI {
    return toBI(JSBI.exponentiate(this.jsbi, toJSBI(other)));
  }

  and(other: BIish): BI {
    return toBI(JSBI.bitwiseAnd(this.jsbi, toJSBI(other)));
  }

  or(other: BIish): BI {
    return toBI(JSBI.bitwiseOr(this.jsbi, toJSBI(other)));
  }

  xor(other: BIish): BI {
    return toBI(JSBI.bitwiseXor(this.jsbi, toJSBI(other)));
  }

  not(): BI {
    return toBI(JSBI.bitwiseNot(this.jsbi));
  }

  mask(other: BIish): BI {
    const jsbiOther = toJSBI(other);
    if (
      JSBI.lessThan(jsbiOther, toJSBI(0)) ||
      JSBI.lessThan(this.jsbi, toJSBI(0))
    ) {
      throw new Error("mask works only with positive numbers");
    }

    const length = toJSBI(this.jsbi.toString(2).length);
    if (JSBI.lessThanOrEqual(length, jsbiOther)) {
      return toBI(this.jsbi);
    } else {
      const maskNum = JSBI.leftShift(
        JSBI.signedRightShift(this.jsbi, jsbiOther),
        jsbiOther
      );
      return toBI(JSBI.bitwiseXor(this.jsbi, maskNum));
    }
  }

  shl(other: BIish): BI {
    return toBI(JSBI.leftShift(this.jsbi, toJSBI(other)));
  }

  shr(other: BIish): BI {
    return toBI(JSBI.signedRightShift(this.jsbi, toJSBI(other)));
  }

  eq(other: BIish): boolean {
    return JSBI.equal(this.jsbi, toJSBI(other));
  }

  lt(other: BIish): boolean {
    return JSBI.lessThan(this.jsbi, toJSBI(other));
  }

  lte(other: BIish): boolean {
    return JSBI.lessThanOrEqual(this.jsbi, toJSBI(other));
  }

  gt(other: BIish): boolean {
    return JSBI.greaterThan(this.jsbi, toJSBI(other));
  }

  gte(other: BIish): boolean {
    return JSBI.greaterThanOrEqual(this.jsbi, toJSBI(other));
  }

  isNegative(): boolean {
    return JSBI.lessThan(this.jsbi, toJSBI(0));
  }

  isZero(): boolean {
    return JSBI.equal(this.jsbi, toJSBI(0));
  }

  toNumber(): number {
    return JSBI.toNumber(this.jsbi);
  }

  toBigInt(): bigint {
    try {
      return BigInt(this.jsbi.toString(10));
    } catch (e) {
      throw new Error("this platform does not support BigInt");
    }
  }

  toString(radix?: number): string {
    radix = radix || 10;
    return this.jsbi.toString(radix);
  }

  toHexString(): string {
    if (JSBI.lessThan(this.jsbi, toJSBI(0))) {
      return "-0x" + JSBI.unaryMinus(this.jsbi).toString(16);
    } else {
      return "0x" + this.jsbi.toString(16);
    }
  }

  static from(value: any): BI {
    if (value instanceof BI) {
      return value;
    } else if (isBIish(value)) {
      return toBI(toJSBI(value));
    } else if (value instanceof JSBI) {
      return toBI(toJSBI(value.toString()));
    } else {
      throw new Error(`invalid type: ${value} can't be converted into BI`);
    }
  }

  static isBI(value: any): value is BI {
    return !!(value && value._isBI);
  }
}

function toBI(value: JSBI): BI {
  return new BI(value);
}

export function toJSBI(value: BIish): JSBI {
  if (typeof value === "number" || typeof value === "string") {
    return JSBI.BigInt(value);
  } else {
    return JSBI.BigInt(value.toString());
  }
}

'''
'''--- packages/bi/tests/index.test.ts ---
import test from "ava";
import { isBIish, BI, toJSBI } from "../src/index";
import JSBI from "jsbi";

test("validate if a value is BIish", (t) => {
  t.is(isBIish(1), true);
  t.is(isBIish(-1), true);
  t.is(isBIish("1"), true);
  t.is(isBIish("-1"), true);
  t.is(isBIish("0xf"), true);
  t.is(isBIish("0xF"), true);
  t.is(isBIish(BigInt(1)), true);
  t.is(isBIish(BI.from(1)), true);
  t.is(isBIish("f"), false);
  t.is(isBIish("0x"), false);
});

test("addition", (t) => {
  const bi = BI.from(1);
  t.is(bi.add(2).toNumber(), 3);
  t.is(bi.add("2").toNumber(), 3);
  t.is(bi.add("0x2").toNumber(), 3);
});

test("subtraction", (t) => {
  const bi = BI.from("3");
  t.is(bi.sub(1).toNumber(), 2);
  t.is(bi.sub("-1").toNumber(), 4);
  t.is(bi.sub("0x4").toNumber(), -1);
});

test("division", (t) => {
  const bi = BI.from("0x10");
  t.is(bi.div("0x4").toNumber(), 4);
  t.is(bi.div(-2).toNumber(), -8);
  t.throws(() => {
    bi.div("0");
  });
});

test("multiplication", (t) => {
  const bi = BI.from(BigInt(2));
  t.is(bi.mul(3).toNumber(), 6);
  t.is(bi.mul(BI.from(2)).toNumber(), 4);
});

test("remainder", (t) => {
  const bi = BI.from(7);
  t.is(bi.mod(3).toNumber(), 1);
  t.throws(() => {
    bi.mod(0);
  });
  t.is(BI.from(-7).mod(4).toNumber(), -3);
});

test("absolute value", (t) => {
  t.is(BI.from(2).abs().toNumber(), 2);
  t.is(BI.from(-2).abs().toNumber(), 2);
});

test("exponentiation", (t) => {
  const bi = BI.from(2);
  t.is(bi.pow(3).toNumber(), 8);
  t.is(bi.pow(0).toNumber(), 1);
});

test("bitwise and", (t) => {
  t.is(BI.from("0x1234").and("0xff").toHexString(), "0x34");
});

test("bitwise or", (t) => {
  t.is(BI.from("0xf0").or("0xf").toHexString(), "0xff");
});

test("bitwise xor", (t) => {
  t.is(BI.from("0xf0f0f0f0").xor("0xf0ff0f0").toHexString(), "0xffff0000");
});

test("bitwise not", (t) => {
  t.is(BI.from("5").not().toNumber(), -6);
});

test("mask", (t) => {
  t.is(BI.from(3).mask(1).toNumber(), 1);
  t.is(BI.from("0x1234567").mask(8).toHexString(), "0x67");
  t.is(BI.from("0x12345").mask(30).toHexString(), "0x12345");
  t.throws(() => {
    BI.from(-1).mask(3);
  });
  t.throws(() => {
    BI.from(1).mask(-3);
  });
});

test("left shifting", (t) => {
  t.is(BI.from(3).shl(2).toNumber(), 12);
});

test("right shifting", (t) => {
  t.is(BI.from("0xff").shr(4).toHexString(), "0xf");
});

test("equal", (t) => {
  t.is(BI.from(3).eq("3"), true);
  t.is(BI.from(3).eq(3), true);
  t.is(BI.from(3).eq("0x3"), true);
  t.is(BI.from(3).eq(BigInt(3)), true);
  t.is(BI.from(3).eq(BI.from(3)), true);
  t.is(BI.from(3).eq(2), false);
});

test("less than", (t) => {
  t.is(BI.from(3).lt(5), true);
  t.is(BI.from(-3).lt("5"), true);
  t.is(BI.from("-3").lt(-2), true);
  t.is(BI.from(5).lt(3), false);
  t.is(BI.from(-3).lt(-5), false);
  t.is(BI.from(3).lt(3), false);
});

test("less than and equal", (t) => {
  t.is(BI.from(3).lte(5), true);
  t.is(BI.from(-3).lte("5"), true);
  t.is(BI.from("-3").lte(-2), true);
  t.is(BI.from(5).lte(3), false);
  t.is(BI.from(-3).lte(-5), false);
  t.is(BI.from(3).lte(3), true);
});

test("greater than", (t) => {
  t.is(BI.from(3).gt(5), false);
  t.is(BI.from(-3).gt("5"), false);
  t.is(BI.from("-3").gt(-2), false);
  t.is(BI.from(5).gt(3), true);
  t.is(BI.from(-3).gt(-5), true);
  t.is(BI.from(3).gt(3), false);
});

test("greater than and equal", (t) => {
  t.is(BI.from(3).gte(5), false);
  t.is(BI.from(-3).gte("5"), false);
  t.is(BI.from("-3").gte(-2), false);
  t.is(BI.from(5).gte(3), true);
  t.is(BI.from(-3).gte(-5), true);
  t.is(BI.from(3).gte(3), true);
});

test("is negative", (t) => {
  t.is(BI.from(3).isNegative(), false);
  t.is(BI.from(-3).isNegative(), true);
  t.is(BI.from(0).isNegative(), false);
});

test("is zero", (t) => {
  t.is(BI.from(3).isZero(), false);
  t.is(BI.from(-3).isZero(), false);
  t.is(BI.from(0).isZero(), true);
});

test("to number", (t) => {
  t.is(BI.from(3).toNumber(), 3);
  t.is(BI.from("-3").toNumber(), -3);
  t.is(BI.from("0x3").toNumber(), 3);
  t.is(BI.from(BigInt(3)).toNumber(), 3);
});

test("to bigint", (t) => {
  t.is(BI.from(3).toBigInt(), BigInt(3));
});

test("to string", (t) => {
  const bi = BI.from(1234);
  t.is(bi.toString(), "1234");
  t.is(bi.toString(10), "1234");
  t.is(bi.toString(16), "4d2");
  t.is(bi.toString(2), "10011010010");
});

test("to hex string", (t) => {
  t.is(BI.from(15).toHexString(), "0xf");
  t.is(BI.from(-15).toHexString(), "-0xf");
});

test("from", (t) => {
  t.throws(() => {
    BI.from("0x");
  });
  t.throws(() => {
    BI.from("ss");
  });
});

test("is BI", (t) => {
  t.is(BI.isBI(BI.from(0)), true);
  t.is(BI.isBI(0), false);
  t.is(BI.isBI("0"), false);
  t.is(BI.isBI("0x0"), false);
  t.is(BI.isBI(BI.from(BI.from(0))), true);
});

test("to jsbi", (t) => {
  const bi = BI.from(2);
  const jsbi = JSBI.BigInt(2);
  t.is(toJSBI(bi) instanceof JSBI, true);
  t.is(JSBI.equal(toJSBI(bi), jsbi), true);
});

test("from JSBI", (t) => {
  const bi = BI.from(JSBI.BigInt(2));
  const jsbi = JSBI.BigInt(2);
  t.is(toJSBI(bi) instanceof JSBI, true);
  t.is(JSBI.equal(toJSBI(bi), jsbi), true);
});

'''
'''--- packages/bi/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src"]
}

'''
'''--- packages/ckb-indexer/README.md ---
CKB indexer is based on  [ckb-indexer](https://github.com/nervosnetwork/ckb-indexer) with more features. It is designed for:

- Web client usage.
- CKB's RPC query.

## **Usage**

### **Indexer**

```jsx
const { Indexer } = require("@ckb-lumos/ckb-indexer");
const nodeUri = "https://testnet.ckb.dev/rpc";
const indexUri = "https://testnet.ckb.dev/indexer";
const indexer = new Indexer(indexUri, nodeUri);
```

### **CellCollector**

To query existing cells, you can create a CellCollector:

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    code_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    hash_type: "data",
    args: "0x62e907b15cbf27d5425399ebf6f0fb50ebb88f18",
  },
});

for await (const cell of cellCollector.collect()) {
  console.log(cell);
}
```

Specify `lock` or `type` script as constraints for advance search:

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    args: "0x92aad3bbab20f225cff28ec1d856c6ab63284c7a",
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
  },
  type: {
    args: "0x",
    code_hash:
      "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
    hash_type: "type",
  },
});
```

Query cells in certain block_numbers range (`fromBlock` and `toBlock` are included):

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df323",
  },
  fromBlock: "0x225510", // "0x" + 2250000n.toString(16)
  toBlock: "0x225ce0", // "0x" + 2252000n.toString(16)
});

for await (const cell of cellCollector.collect()) {
  console.log(cell);
}
```

Skip a certain number of query results, e.g. the below code snippet means it would skip the first 100 cells and return from the 101st one

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df323",
  },
  skip: 100,
});

for await (const tx of cellCollector.collect()) {
  console.log(tx);
}
```

Order by block number is supported by setting `order` field explicitly:

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df323",
  },
  fromBlock: "0x253b40", // "0x" + 2440000n.toString(16)
  toBlock: "0x253f28", // "0x" + 2441000n.toString(16)
  order: "desc", // default option is "asc"
  skip: 300,
});

for await (const cell of cellCollector.collect()) {
  console.log(cell);
}
```

Prefix search is supported on `args`. The default `argsLen` is -1, which means you pass the full slice of original args, and you can specify it when the `args` field is the prefix of original args.

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df3", // truncate the last byte of orignal args: 0xa528f2b9a51118b193178db4cf2f3db92e7df323
  },
  argsLen: 20, // default option is -1
  fromBlock: "0x253b40", // "0x" + 2440000n.toString(16)
  toBlock: "0x253f28", // "0x" + 2441000n.toString(16)
  order: "desc", // default option is "asc"
  skip: 300,
});

for await (const cell of cellCollector.collect()) {
  console.log(cell);
}
```

You can also set it as `any` when the argsLen has multiple possibilities. For example, lock script's args is 20 in normal scenario and 28 in multisig scenario, or any other length in customized scenarios.

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7d", // truncate the last two bytes of original args: 0xa528f2b9a51118b193178db4cf2f3db92e7df323
  },
  argsLen: "any",
  fromBlock: "0x253b40", // "0x" + 2440000n.toString(16)
  toBlock: "0x253f28", // "0x" + 2441000n.toString(16)
  order: "desc", // default option is "asc"
  skip: 300,
});

for await (const cell of cellCollector.collect()) {
  console.log(cell);
}
```

Fine grained query for cells can be achieved by using [ScriptWrapper](https://github.com/nervosnetwork/lumos/blob/cd418d258085d3cb6ab47eeaf5347073acf5422e/packages/base/index.d.ts#L123), with customized options like `argsLen`:

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    script: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0xe60f7f88c94ef365d540afc1574c46bb017765", // trucate the last byte of original args: 0xe60f7f88c94ef365d540afc1574c46bb017765a2
    },
    argsLen: 20,
  },
  type: {
    script: {
      code_hash:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      hash_type: "type",
      args: "0x",
    },
    // when the `argsLen` is not setted here, it will use the outside `argsLen` config, which in this case is -1 by default
  },
});

for await (const cell of cellCollector.collect()) {
  console.log(cell);
}
```

`outputDataLenRange` for filtering cell by data length, and `outputCapacityRange` for filtering cell by capacity:

```jsx
cellCollector = new CellCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7d", // truncate the last two bytes of original args: 0xa528f2b9a51118b193178db4cf2f3db92e7df323
  },
  outputDataLenRange: [0x0, 0x160],
  outputCapacityRange: [0x10000, 0x100000],
});

for await (const cell of cellCollector.collect()) {
  console.log(cell);
}
```

To return block_hash in the result, add the following query options:

```jsx
const otherQueryOptions: OtherQueryOptions = {
    withBlockHash: true,
    ckbRpcUrl: nodeUri,
  };
  const cellCollector = new CellCollector(
    indexer,
   { lock: type }
   otherQueryOptions
  );
```

### **TransactionCollector**

Similar usage for quering transactions:

```jsx
txCollector = new TransactionCollector(indexer, {
  lock: {
    code_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    hash_type: "data",
    args: "0x62e907b15cbf27d5425399ebf6f0fb50ebb88f18",
  },
  CKBRpcUrl,
});

for await (const tx of txCollector.collect()) {
  console.log(tx);
}
```

Query cells in certain block_numbers range (`fromBlock` and `toBlock` are included):

```jsx
txCollector = new TransactionCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df323",
  },
  fromBlock: "0x0", // "0x" + 0n.toString(16)
  toBlock: "0x7d0" , // "0x" + 2000n.toString(16)
});

for await (const tx of txCollector.collect()) {
  console.log(tx);

```

Skip a certain number of query results, e.g. the below code snippet means it would skip the first 100 cells and return from the 101st one.

```jsx
txCollector = new TransactionCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df323",
  },
  skip: 100,
});

for await (const tx of txCollector.collect()) {
  console.log(tx);
}
```

Order by block number is supported:

```jsx
txCollector = new TransactionCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df323",
  },
  fromBlock: "0x4e20", // "0x" + 20000n.toString(16)
  toBlock: "0x5208", // "0x" + 21000n.toString(16)
  order: "desc", // default option is "asc"
  skip: 10,
});

for await (const tx of txCollector.collect()) {
  console.log(tx);
}
```

Prefix search is supported on `args`. The default `argsLen` is -1, which means you pass the full slice of original args, and you can specify it when the `args` field is the prefix of original args.

```jsx
txCollector = new TransactionCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df3", // truncate the last byte of orignal args: 0xa528f2b9a51118b193178db4cf2f3db92e7df323
  },
  argsLen: 20, // default option is -1
  fromBlock: "0x253b40", // "0x" + 2440000n.toString(16)
  toBlock: "0x253f28", // "0x" + 2441000n.toString(16)
  order: "desc", // default option is "asc"
  skip: 300,
});

for await (const tx of txCollector.collect()) {
  console.log(tx);
}
```

You can also set it as `any` when the argsLen of the field args might have multiple possibilities, for example, lock script's args could be 20 in normal scenario and 28 in multisig scenario, or any other length in customized scenarios. However, there's some performance lost when use `any` rather than explicitly specified length due to the low-level implementation.

```jsx
txCollector = new TransactionCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7d", // truncate the last two bytes of original args: 0xa528f2b9a51118b193178db4cf2f3db92e7df323
  },
  argsLen: "any",
  fromBlock: "0x253b40", // "0x" + 2440000n.toString(16)
  toBlock: "0x253f28", // "0x" + 2441000n.toString(16)
  order: "desc", // default option is "asc"
  skip: 300,
});

for await (const tx of txCollector.collect()) {
  console.log(tx);
}
```

Fine grained query for transactions can be achieved by using [ScriptWrapper](https://github.com/nervosnetwork/lumos/blob/cd418d258085d3cb6ab47eeaf5347073acf5422e/packages/base/index.d.ts#L123), with customized options like `ioType`, `argsLen`:

```jsx
txCollector = new TransactionCollector(indexer, {
  lock: {
    script: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0xe60f7f88c94ef365d540afc1574c46bb017765", // trucate the last byte of original args: 0xe60f7f88c94ef365d540afc1574c46bb017765a2
    },
    ioType: "both",
    argsLen: 20, // when the `argsLen` is not setted here, it will use the outside `argsLen` config
  },
  type: {
    script: {
      code_hash:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      hash_type: "type",
      args: "0x",
    },
    ioType: "input",
  },
});

for await (const tx of txCollector.collect()) {
  console.log(tx);
}
```

The `ioType` field is among `input | output | both`.

`outputDataLenRange` is support to filter cell by data length, `outputCapacityRange` is support to filter cell by capacity。you can use as below.

```jsx
txCollector = new TransactionCollector(indexer, {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7d", // truncate the last two bytes of original args: 0xa528f2b9a51118b193178db4cf2f3db92e7df323
  },
  outputDataLenRange: [0x0, 0x160],
  outputCapacityRange: [0x10000, 0x100000],
});

for await (const tx of txCollector.collect()) {
  console.log(tx);
}
```

### **EventEmitter**

Besides polling pattern, event-driven pattern is also supported. After subsribing for certain `lock|type` script, it will emit a `changed` event when a block containing the subsribed script is indexed or rollbacked.

The principle of the design is unreliable notification queue, so developers are supposed to pull from the data sources via `CellCollector|TransactionCollector`, to find out what might happened: cell consumed, new cell generated, new transaction generated, or a chain fork happened, etc; and take the next step accordingly.

```jsx
eventEmitter = indexer.subscribe({
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7df323",
  },
});

eventEmitter.on("changed", () => {
  console.log(
    "States changed with the script, please pull the data sources from the indexer to find out what happend"
  );
});
```

Other query options like `fromBlock|argsLen|data` are also supported.

```jsx
eventEmitter = indexer.subscribe({
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    // the args bytes length is 18, truncate the last 2 bytes.
    args: "0xa528f2b9a51118b193178db4cf2f3db92e7d",
  },
  // default value is -1
  argsLen: 20,
  // default value is "any"
  data: "0x",
  // default value is 0
  fromBlock: 0x3e8, // "0x" + 1000n.toString(16)
});
```

Listen to median time change when blocks changed.

```jsx
const medianTimeEmitter = indexer.subscribeMedianTime();
medianTimeEmitter.on("changed", (medianTime) => {
  console.log(medianTime);
});
```

## **Migration**

If you want to migrate native indexer to ckb-indexer, please check more detail in our [migration docs](https://github.com/nervosnetwork/lumos/blob/develop/packages/ckb-indexer/mirgation.md)

'''
'''--- packages/ckb-indexer/mirgation.md ---
## Migrate from native indexer

Lumos is used for execution on server side, so we provide `@ckb-lumos/indexer` and @ckb-`lumos/sql-indexer`. While bringing flexibility, it also increases the complexity of using it, such as you have to run the database locally, compile the code, etc.

Now that lumos plans to support running on the web, we removed `native-indexer` and `sql-indexer`, and introduced `ckb-indexer`. This document is to help you upgrade from the old version.

### **Start Indexer**

Instead of calling `indexer.startForever()` in `native-indexer`, you just need to create an indexer instance in `@ckb-lumos/ckb-indexer`, and we will turn it on for you automatically.

### Constractor

**CellCollector**

To return the `block_hash`, you need to carry carry the third parameter in `CellCollector`.

```jsx
const otherQueryOptions: OtherQueryOptions = {
    withBlockHash: true,
    ckbRpcUrl: nodeUri,
  };
  const cellCollector = new CellCollector(
    indexer,
   { lock: type }
   otherQueryOptions
  );
```

**TransactionCollector**

The constructor of `TransactionCollector` adds a parameter of `nodeUri`, moving options down to the fourth parameter.

```diff
const transactionCollector = new TransactionCollector(
      indexer,
      query,
+     nodeUri,
     options
   );
```

**TransactionCollector batch request**

Indexer no longer exposes RPC to the public. If you need to get a `batchRpc` object, you need to get it from `@cbk-lumos/tookit`

```diff
import {RPC} from '@ckb-lumos/toolkit';

...
-batchRpc = indexer.rpc.batch();
+batchRpc = new PRC(URL).batch()
...
```

'''
'''--- packages/ckb-indexer/package.json ---
{
  "name": "@ckb-lumos/ckb-indexer",
  "version": "0.17.0-rc8",
  "description": "CKB Indexer",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "files": [
    "lib",
    "src"
  ],
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "@ckb-lumos/rpc": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8",
    "cross-fetch": "^3.1.4",
    "events": "^3.3.0"
  },
  "devDependencies": {
    "@types/sinon": "^10.0.6",
    "sinon": "^12.0.1"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests,examples}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests,examples}/**/*.ts\"",
    "test": "ava **/*.test.ts --timeout=2m",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  }
}

'''
'''--- packages/ckb-indexer/src/collector.ts ---
import { utils, Cell, BaseCellCollector } from "@ckb-lumos/base";
import { validators } from "@ckb-lumos/toolkit";
import {
  SearchKeyFilter,
  CKBIndexerQueryOptions,
  GetCellsResults,
  Order,
  OtherQueryOptions,
} from "./type";

import { CkbIndexer } from "./indexer";
import {
  generateSearchKey,
  getHexStringBytes,
  instanceOfScriptWrapper,
} from "./services";
import fetch from "cross-fetch";

interface GetBlockHashRPCResult {
  jsonrpc: string;
  id: number;
  result: string;
}

/** CellCollector will not get cell with block_hash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get block_hash if you need. */
export class CKBCellCollector implements BaseCellCollector {
  constructor(
    public indexer: CkbIndexer,
    public queries: CKBIndexerQueryOptions,
    public otherQueryOptions?: OtherQueryOptions
  ) {
    const defaultQuery: CKBIndexerQueryOptions = {
      lock: undefined,
      type: undefined,
      argsLen: -1,
      data: "any",
      fromBlock: undefined,
      toBlock: undefined,
      order: "asc",
      skip: undefined,
      outputDataLenRange: undefined,
      outputCapacityRange: undefined,
      bufferSize: undefined,
    };
    this.queries = { ...defaultQuery, ...this.queries };
    if (
      !this.queries.lock &&
      (!this.queries.type || this.queries.type === "empty")
    ) {
      throw new Error("Either lock or type script must be provided!");
    }

    // unWrap `ScriptWrapper` into `Script`.
    if (this.queries.lock) {
      if (!instanceOfScriptWrapper(this.queries.lock)) {
        validators.ValidateScript(this.queries.lock);
      } else if (instanceOfScriptWrapper(this.queries.lock)) {
        validators.ValidateScript(this.queries.lock.script);
        this.queries.lock = this.queries.lock.script;
      }
    }

    // unWrap `ScriptWrapper` into `Script`.
    if (this.queries.type && this.queries.type !== "empty") {
      if (
        typeof this.queries.type === "object" &&
        !instanceOfScriptWrapper(this.queries.type)
      ) {
        validators.ValidateScript(this.queries.type);
      } else if (
        typeof this.queries.type === "object" &&
        instanceOfScriptWrapper(this.queries.type)
      ) {
        validators.ValidateScript(this.queries.type.script);
        this.queries.type = this.queries.type.script;
      }
    }

    if (this.queries.fromBlock) {
      utils.assertHexadecimal("fromBlock", this.queries.fromBlock);
    }
    if (this.queries.toBlock) {
      utils.assertHexadecimal("toBlock", this.queries.toBlock);
    }
    if (this.queries.order !== "asc" && this.queries.order !== "desc") {
      throw new Error("Order must be either asc or desc!");
    }
    if (this.queries.outputCapacityRange) {
      utils.assertHexadecimal(
        "outputCapacityRange[0]",
        this.queries.outputCapacityRange[0]
      );
      utils.assertHexadecimal(
        "outputCapacityRange[1]",
        this.queries.outputCapacityRange[1]
      );
    }

    if (this.queries.outputDataLenRange) {
      utils.assertHexadecimal(
        "outputDataLenRange[0]",
        this.queries.outputDataLenRange[0]
      );
      utils.assertHexadecimal(
        "outputDataLenRange[1]",
        this.queries.outputDataLenRange[1]
      );
    }

    if (this.queries.skip && typeof this.queries.skip !== "number") {
      throw new Error("skip must be a number!");
    }

    if (
      this.queries.bufferSize &&
      typeof this.queries.bufferSize !== "number"
    ) {
      throw new Error("bufferSize must be a number!");
    }
  }

  private async getLiveCell(lastCursor?: string): Promise<GetCellsResults> {
    const searchKeyFilter: SearchKeyFilter = {
      sizeLimit: this.queries.bufferSize,
      order: this.queries.order as Order,
    };
    if (lastCursor) {
      searchKeyFilter.lastCursor = lastCursor;
    }
    const result: GetCellsResults = await this.indexer.getCells(
      generateSearchKey(this.queries),
      undefined,
      searchKeyFilter
    );
    return result;
  }

  private shouldSkipped(cell: Cell, skippedCount: number = 0) {
    if (this.queries.skip && skippedCount < this.queries.skip) {
      return true;
    }
    if (cell && this.queries.type === "empty" && cell.cell_output.type) {
      return true;
    }
    if (this.queries.data !== "any" && cell.data !== this.queries.data) {
      return true;
    }
    if (
      this.queries.argsLen !== -1 &&
      this.queries.argsLen !== "any" &&
      getHexStringBytes(cell.cell_output.lock.args) !== this.queries.argsLen
    ) {
      return true;
    }
  }

  async count() {
    let lastCursor: undefined | string = undefined;
    const getCellWithCursor = async (): Promise<Cell[]> => {
      const result: GetCellsResults = await this.getLiveCell(lastCursor);
      lastCursor = result.lastCursor;
      return result.objects;
    };
    let counter = 0;
    let cells: Cell[] = await getCellWithCursor();
    if (cells.length === 0) {
      return 0;
    }
    let buffer: Promise<Cell[]> = getCellWithCursor();
    let index: number = 0;
    let skippedCount: number = 0;
    while (true) {
      if (!this.shouldSkipped(cells[index], skippedCount)) {
        counter += 1;
      } else {
        skippedCount++;
      }
      index++;
      //reset index and exchange `cells` and `buffer` after count last cell
      if (index === cells.length) {
        index = 0;
        cells = await buffer;
        // break if can not get more cells
        if (cells.length === 0) {
          break;
        }
        buffer = getCellWithCursor();
      }
    }
    return counter;
  }

  private async request(rpcUrl: string, data: unknown): Promise<any> {
    const res: Response = await fetch(rpcUrl, {
      method: "POST",
      body: JSON.stringify(data),
      headers: {
        "Content-Type": "application/json",
      },
    });
    if (res.status !== 200) {
      throw new Error(`indexer request failed with HTTP code ${res.status}`);
    }
    const result = await res.json();
    if (result.error !== undefined) {
      throw new Error(
        `indexer request rpc failed with error: ${JSON.stringify(result.error)}`
      );
    }
    return result;
  }

  private async getLiveCellWithBlockHash(lastCursor?: string) {
    if (!this.otherQueryOptions) {
      throw new Error("CKB Rpc URL must provide");
    }
    let result: GetCellsResults = await this.getLiveCell(lastCursor);
    if (result.objects.length === 0) {
      return result;
    }
    const requestData = result.objects.map((cell, index) => {
      return {
        id: index,
        jsonrpc: "2.0",
        method: "get_block_hash",
        params: [cell.block_number],
      };
    });
    const blockHashList: GetBlockHashRPCResult[] = await this.request(
      this.otherQueryOptions.ckbRpcUrl,
      requestData
    );
    result.objects = result.objects.map((item, index) => {
      const rpcResponse = blockHashList.find(
        (responseItem: GetBlockHashRPCResult) => responseItem.id === index
      );
      const block_hash = rpcResponse && rpcResponse.result;
      return { ...item, block_hash };
    });
    return result;
  }

  /** collect cells without block_hash by default.if you need block_hash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl when constructor CellCollect.
   * don't use OtherQueryOption if you don't need block_hash,cause it will slowly your collect.
   */
  async *collect() {
    const withBlockHash =
      this.otherQueryOptions &&
      "withBlockHash" in this.otherQueryOptions &&
      this.otherQueryOptions.withBlockHash;
    let lastCursor: undefined | string = undefined;
    const getCellWithCursor = async (): Promise<Cell[]> => {
      const result: GetCellsResults = await (withBlockHash
        ? this.getLiveCellWithBlockHash(lastCursor)
        : this.getLiveCell(lastCursor));
      lastCursor = result.lastCursor;
      return result.objects;
    };
    let cells: Cell[] = await getCellWithCursor();
    if (cells.length === 0) {
      return;
    }
    let buffer: Promise<Cell[]> = getCellWithCursor();
    let index: number = 0;
    let skippedCount: number = 0;
    while (true) {
      if (!this.shouldSkipped(cells[index], skippedCount)) {
        yield cells[index];
      } else {
        skippedCount++;
      }
      index++;
      //reset index and exchange `cells` and `buffer` after yield last cell
      if (index === cells.length) {
        index = 0;
        cells = await buffer;
        // break if can not get more cells
        if (cells.length === 0) {
          break;
        }
        buffer = getCellWithCursor();
      }
    }
  }
}

'''
'''--- packages/ckb-indexer/src/index.ts ---
import { CKBCellCollector } from "./collector";
import { CkbIndexer } from "./indexer";
import { CKBIndexerTransactionCollector } from "./transaction_collector";
import { RPC as CKBRPC } from "./rpc";

/** CkbIndexer.collector will not get cell with block_hash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get block_hash if you need. */
export const Indexer = CkbIndexer;

/** CellCollector will not get cell with block_hash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get block_hash if you need. */
export const CellCollector = CKBCellCollector;
export const TransactionCollector = CKBIndexerTransactionCollector;
export const RPC = CKBRPC;

'''
'''--- packages/ckb-indexer/src/indexer.ts ---
import {
  Cell,
  CellCollector,
  HexString,
  Indexer,
  Script,
  Tip,
  Output,
  utils,
  Block,
} from "@ckb-lumos/base";
import { validators } from "@ckb-lumos/toolkit";
import { RPC } from "@ckb-lumos/rpc";
import { request, requestBatch } from "./services";
import { CKBCellCollector } from "./collector";
import { EventEmitter } from "events";
import {
  GetTransactionRPCResult,
  CKBIndexerQueryOptions,
  GetCellsResults,
  GetLiveCellsResult,
  GetTransactionsResult,
  GetTransactionsResults,
  IndexerEmitter,
  OutputToVerify,
  SearchKey,
  SearchKeyFilter,
  Terminator,
  OtherQueryOptions,
} from "./type";
import { BI } from "@ckb-lumos/bi";

const DefaultTerminator: Terminator = () => {
  return { stop: false, push: true };
};

function defaultLogger(level: string, message: string) {
  console.log(`[${level}] ${message}`);
}

/** CkbIndexer.collector will not get cell with block_hash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get block_hash if you need. */
export class CkbIndexer implements Indexer {
  uri: string;
  medianTimeEmitters: EventEmitter[] = [];
  emitters: IndexerEmitter[] = [];
  isSubscribeRunning: boolean = false;
  constructor(public ckbIndexerUrl: string, public ckbRpcUrl: string) {
    this.uri = ckbRpcUrl;
  }

  private getCkbRpc(): RPC {
    return new RPC(this.ckbRpcUrl);
  }

  async tip(): Promise<Tip> {
    const res = await request(this.ckbIndexerUrl, "get_tip");
    return res as Tip;
  }

  asyncSleep(timeout: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, timeout));
  }

  async waitForSync(blockDifference = 0): Promise<void> {
    const rpcTipNumber = parseInt(
      (await this.getCkbRpc().get_tip_header()).number,
      16
    );
    while (true) {
      const indexerTipNumber = parseInt((await this.tip()).block_number, 16);
      if (indexerTipNumber + blockDifference >= rpcTipNumber) {
        return;
      }
      await this.asyncSleep(1000);
    }
  }

  /** collector cells without block_hash by default.if you need block_hash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl.
   * don't use OtherQueryOption if you don't need block_hash,cause it will slowly your collect.
   */
  collector(
    queries: CKBIndexerQueryOptions,
    otherQueryOptions?: OtherQueryOptions
  ): CellCollector {
    return new CKBCellCollector(this, queries, otherQueryOptions);
  }

  private async request(
    method: string,
    params?: any,
    ckbIndexerUrl: string = this.ckbIndexerUrl
  ): Promise<any> {
    return request(ckbIndexerUrl, method, params);
  }

  public async getCells(
    searchKey: SearchKey,
    terminator: Terminator = DefaultTerminator,
    searchKeyFilter: SearchKeyFilter = {}
  ): Promise<GetCellsResults> {
    const infos: Cell[] = [];
    let cursor: string | undefined = searchKeyFilter.lastCursor;
    let sizeLimit = searchKeyFilter.sizeLimit || 100;
    let order = searchKeyFilter.order || "asc";
    const index = 0;
    while (true) {
      let params = [searchKey, order, `0x${sizeLimit.toString(16)}`, cursor];
      const res: GetLiveCellsResult = await this.request("get_cells", params);
      const liveCells = res.objects;
      cursor = res.last_cursor;
      for (const liveCell of liveCells) {
        const cell: Cell = {
          cell_output: liveCell.output,
          data: liveCell.output_data,
          out_point: liveCell.out_point,
          block_number: liveCell.block_number,
        };
        const { stop, push } = terminator(index, cell);
        if (push) {
          infos.push(cell);
        }
        if (stop) {
          return {
            objects: infos,
            lastCursor: cursor,
          };
        }
      }
      if (liveCells.length <= sizeLimit) {
        break;
      }
    }
    return {
      objects: infos,
      lastCursor: cursor,
    };
  }

  public async getTransactions(
    searchKey: SearchKey,
    searchKeyFilter: SearchKeyFilter = {}
  ): Promise<GetTransactionsResults> {
    let infos: GetTransactionsResult[] = [];
    let cursor: string | undefined = searchKeyFilter.lastCursor;
    let sizeLimit = searchKeyFilter.sizeLimit || 100;
    let order = searchKeyFilter.order || "asc";
    for (;;) {
      const params = [searchKey, order, `0x${sizeLimit.toString(16)}`, cursor];
      const res = await this.request("get_transactions", params);
      const txs = res.objects;
      cursor = res.last_cursor as string;
      infos = infos.concat(txs);
      if (txs.length <= sizeLimit) {
        break;
      }
    }
    return {
      objects: infos,
      lastCursor: cursor,
    };
  }

  running(): boolean {
    return true;
  }

  start(): void {
    defaultLogger(
      "warn",
      "deprecated: no need to start the ckb-indexer manually"
    );
  }

  startForever(): void {
    defaultLogger(
      "warn",
      "deprecated: no need to startForever the ckb-indexer manually"
    );
  }

  stop(): void {
    defaultLogger(
      "warn",
      "deprecated: no need to stop the ckb-indexer manually"
    );
  }

  subscribe(queries: CKBIndexerQueryOptions): EventEmitter {
    this.isSubscribeRunning = true;
    this.scheduleLoop();
    if (queries.lock && queries.type) {
      throw new Error(
        "The notification machanism only supports you subscribing for one script once so far!"
      );
    }
    if (queries.toBlock !== null || queries.skip !== null) {
      defaultLogger(
        "warn",
        "The passing fields such as toBlock and skip are ignored in subscribe() method."
      );
    }
    let emitter = new IndexerEmitter();
    emitter.argsLen = queries.argsLen;
    emitter.outputData = queries.data;
    if (queries.fromBlock) {
      utils.assertHexadecimal("fromBlock", queries.fromBlock);
    }
    emitter.fromBlock = !queries.fromBlock
      ? BI.from(0)
      : BI.from(queries.fromBlock);
    if (queries.lock) {
      validators.ValidateScript(queries.lock);
      emitter.lock = queries.lock as Script;
    } else if (queries.type && queries.type !== "empty") {
      validators.ValidateScript(queries.type);
      emitter.type = queries.type as Script;
    } else {
      throw new Error("Either lock or type script must be provided!");
    }
    this.emitters.push(emitter);
    return emitter;
  }

  private loop() {
    if (!this.isSubscribeRunning) {
      return;
    }
    this.poll()
      .then((timeout) => {
        this.scheduleLoop(timeout);
      })
      .catch((e) => {
        defaultLogger(
          "error",
          `Error occurs: ${e} ${e.stack}, stopping indexer!`
        );
        this.isSubscribeRunning = false;
      });
  }

  private scheduleLoop(timeout = 1) {
    setTimeout(() => {
      this.loop();
    }, timeout);
  }

  private async poll() {
    let timeout = 1;
    const tip = await this.tip();
    const { block_number, block_hash } = tip;
    if (block_number === "0x0") {
      const block: Block = await this.request(
        "get_block_by_number",
        [block_number],
        this.ckbRpcUrl
      );
      await this.publishAppendBlockEvents(block);
    }
    const nextBlockNumber = BI.from(block_number).add(1);
    const block = await this.request(
      "get_block_by_number",
      [`0x${nextBlockNumber.toString(16)}`],
      this.ckbRpcUrl
    );
    if (block) {
      if (block.header.parent_hash === block_hash) {
        await this.publishAppendBlockEvents(block);
      } else {
        const block: Block = await this.request(
          "get_block_by_number",
          [block_number],
          this.ckbRpcUrl
        );
        await this.publishAppendBlockEvents(block);
      }
    } else {
      const block = await this.request(
        "get_block_by_number",
        [block_number],
        this.ckbRpcUrl
      );
      await this.publishAppendBlockEvents(block);
      timeout = 3 * 1000;
    }
    return timeout;
  }

  private async publishAppendBlockEvents(block: Block) {
    for (const [txIndex, tx] of block.transactions.entries()) {
      const blockNumber = block.header.number;
      // publish changed events if subscribed script exists in previous output cells , skip the cellbase.
      if (txIndex > 0) {
        const requestData = tx.inputs.map((input, index) => {
          return {
            id: index,
            jsonrpc: "2.0",
            method: "get_transaction",
            params: [input.previous_output.tx_hash],
          };
        });

        // batch request by block
        const transactionResponse: OutputToVerify[] = await requestBatch(
          this.ckbRpcUrl,
          requestData
        ).then((response: GetTransactionRPCResult[]) => {
          return response.map(
            (item: GetTransactionRPCResult, index: number) => {
              const cellIndex = tx.inputs[index].previous_output.index;
              const outputCell =
                item.result.transaction.outputs[parseInt(cellIndex)];
              const outputData =
                item.result.transaction.outputs_data[parseInt(cellIndex)];
              return { output: outputCell, outputData } as OutputToVerify;
            }
          );
        });
        transactionResponse.forEach(({ output, outputData }) => {
          this.filterEvents(output, blockNumber, outputData);
        });
      }
      // publish changed events if subscribed script exists in output cells.
      for (const [outputIndex, output] of tx.outputs.entries()) {
        const outputData = tx.outputs_data[outputIndex];
        this.filterEvents(output, blockNumber, outputData);
      }
    }
    await this.emitMedianTimeEvents();
  }

  private filterEvents(
    output: Output,
    blockNumber: string,
    outputData: HexString
  ) {
    for (const emitter of this.emitters) {
      if (
        emitter.lock !== undefined &&
        this.checkFilterOptions(
          emitter,
          blockNumber,
          outputData,
          emitter.lock,
          output.lock
        )
      ) {
        emitter.emit("changed");
      }
    }
    if (output.type !== null) {
      for (const emitter of this.emitters) {
        if (
          emitter.type !== undefined &&
          this.checkFilterOptions(
            emitter,
            blockNumber,
            outputData,
            emitter.type,
            output.type
          )
        ) {
          emitter.emit("changed");
        }
      }
    }
  }

  private checkFilterOptions(
    emitter: IndexerEmitter,
    blockNumber: string,
    outputData: string,
    emitterScript: Script,
    script: Script | undefined
  ) {
    const checkBlockNumber = emitter.fromBlock
      ? BI.from(emitter.fromBlock).lte(blockNumber)
      : true;
    const checkOutputData =
      emitter.outputData === "any" || !emitter.outputData
        ? true
        : emitter.outputData === outputData;
    const checkScript = !script
      ? true
      : emitterScript.code_hash === script.code_hash &&
        emitterScript.hash_type === script.hash_type &&
        this.checkArgs(emitter.argsLen, emitterScript.args, script.args);
    return checkBlockNumber && checkOutputData && checkScript;
  }

  private checkArgs(
    argsLen: number | "any" | undefined,
    emitterArgs: HexString,
    args: HexString
  ) {
    if (argsLen === -1 || (!argsLen && argsLen !== 0)) {
      return emitterArgs === args;
    } else if (typeof argsLen === "number" && args.length === argsLen * 2 + 2) {
      return args.substring(0, emitterArgs.length) === emitterArgs;
    } else if (argsLen === "any") {
      return args.substring(0, emitterArgs.length) === emitterArgs;
    } else {
      return false;
    }
  }

  private async emitMedianTimeEvents() {
    if (this.medianTimeEmitters.length === 0) {
      return;
    }
    const info = await request(this.ckbRpcUrl, "get_blockchain_info");
    const medianTime = info.median_time;
    for (const medianTimeEmitter of this.medianTimeEmitters) {
      medianTimeEmitter.emit("changed", medianTime);
    }
  }

  subscribeMedianTime(): EventEmitter {
    this.isSubscribeRunning = true;
    this.scheduleLoop();
    const medianTimeEmitter = new EventEmitter();
    this.medianTimeEmitters.push(medianTimeEmitter);
    return medianTimeEmitter;
  }
}

'''
'''--- packages/ckb-indexer/src/rpc.ts ---
import { RPC as ToolkitRPC } from "@ckb-lumos/toolkit";
import { HexString, Tip } from "@ckb-lumos/base";
import {
  GetCellsResults,
  GetTransactionsResults,
  Order,
  SearchKey,
} from "./type";

interface GetCellsCapacityResult {
  capacity: HexString;
  block_hash: HexString;
  block_number: HexString;
}

const handler = {
  get: (target: any, method: string) => {
    return async (...params: any) => {
      const result = await target.rpc[method](...params);
      return result;
    };
  },
};
class RpcProxy {
  private rpc: ToolkitRPC;
  constructor(uri: string) {
    this.rpc = new ToolkitRPC(uri);
  }

  getProxy() {
    return new Proxy(this, handler);
  }
}

export class RPC {
  private rpcProxy: any;

  /**
   *
   * @param uri  indexer uri
   */
  constructor(uri: string) {
    this.rpcProxy = new RpcProxy(uri).getProxy();
  }

  async get_tip(): Promise<Tip> {
    return this.rpcProxy.get_tip();
  }
  async get_cells(
    searchKey: SearchKey,
    order: Order,
    limit: HexString,
    after_cursor?: string
  ): Promise<GetCellsResults> {
    return this.rpcProxy.get_cells(searchKey, order, limit, after_cursor);
  }
  async get_transactions(
    searchKey: SearchKey,
    order: Order,
    limit: HexString,
    after_cursor?: string
  ): Promise<GetTransactionsResults> {
    return this.rpcProxy.get_transactions(
      searchKey,
      order,
      limit,
      after_cursor
    );
  }
  async get_cells_capacity(
    searchKey: SearchKey
  ): Promise<GetCellsCapacityResult> {
    return this.rpcProxy.get_cells_capacity(searchKey);
  }
  async get_indexer_info(): Promise<string> {
    return this.rpcProxy.get_indexer_info();
  }
}

'''
'''--- packages/ckb-indexer/src/services.ts ---
import { utils, Script, ScriptWrapper, HexString } from "@ckb-lumos/base";
import {
  CKBIndexerQueryOptions,
  HexadecimalRange,
  SearchFilter,
  ScriptType,
  SearchKey,
} from "./type";
import fetch from "cross-fetch";
import { BI } from "@ckb-lumos/bi";

function instanceOfScriptWrapper(object: unknown): object is ScriptWrapper {
  return typeof object === "object" && object != null && "script" in object;
}
const UnwrapScriptWrapper = (inputScript: ScriptWrapper | Script): Script => {
  if (instanceOfScriptWrapper(inputScript)) {
    return inputScript.script;
  }
  return inputScript;
};
const generateSearchKey = (queries: CKBIndexerQueryOptions): SearchKey => {
  let script: Script | undefined = undefined;
  const filter: SearchFilter = {};
  let script_type: ScriptType | undefined = undefined;
  if (queries.lock) {
    const lock = UnwrapScriptWrapper(queries.lock);
    script = lock as Script;
    script_type = "lock";
    if (queries.type && typeof queries.type !== "string") {
      const type = UnwrapScriptWrapper(queries.type);
      filter.script = type as Script;
    }
  } else if (queries.type && typeof queries.type !== "string") {
    const type = UnwrapScriptWrapper(queries.type);
    script = type as Script;
    script_type = "type";
  }
  let block_range: HexadecimalRange | null = null;
  if (queries.fromBlock && queries.toBlock) {
    //toBlock+1 cause toBlock need to be included
    block_range = [
      queries.fromBlock,
      `0x${BI.from(queries.toBlock).add(1).toString(16)}`,
    ];
  }
  if (block_range) {
    filter.block_range = block_range;
  }
  if (queries.outputDataLenRange) {
    filter.output_data_len_range = queries.outputDataLenRange;
  }
  if (queries.outputCapacityRange) {
    filter.output_capacity_range = queries.outputCapacityRange;
  }
  if (!script) {
    throw new Error("Either lock or type script must be provided!");
  }
  if (!script_type) {
    throw new Error("script_type must be provided");
  }
  return {
    script,
    script_type,
    filter,
  };
};

const getHexStringBytes = (hexString: HexString) => {
  utils.assertHexString("", hexString);
  return Math.ceil(hexString.substr(2).length / 2);
};

const requestBatch = async (rpcUrl: string, data: unknown): Promise<any> => {
  const res: Response = await fetch(rpcUrl, {
    method: "POST",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json",
    },
  });
  if (res.status !== 200) {
    throw new Error(`indexer request failed with HTTP code ${res.status}`);
  }
  const result = await res.json();
  if (result.error !== undefined) {
    throw new Error(
      `indexer request rpc failed with error: ${JSON.stringify(result.error)}`
    );
  }
  return result;
};

const request = async (
  ckbIndexerUrl: string,
  method: string,
  params?: any
): Promise<any> => {
  const res = await fetch(ckbIndexerUrl, {
    method: "POST",
    body: JSON.stringify({
      id: 0,
      jsonrpc: "2.0",
      method,
      params,
    }),
    headers: {
      "Content-Type": "application/json",
    },
  });
  if (res.status !== 200) {
    throw new Error(`indexer request failed with HTTP code ${res.status}`);
  }
  const data = await res.json();
  if (data.error !== undefined) {
    throw new Error(
      `indexer request rpc failed with error: ${JSON.stringify(data.error)}`
    );
  }
  return data.result;
};

export {
  generateSearchKey,
  getHexStringBytes,
  instanceOfScriptWrapper,
  requestBatch,
  request,
};

'''
'''--- packages/ckb-indexer/src/transaction_collector.ts ---
import {
  TransactionCollectorOptions,
  indexer as BaseIndexerModule,
  Output,
  OutPoint,
  TransactionWithStatus,
} from "@ckb-lumos/base";
import {
  SearchKeyFilter,
  CKBIndexerQueryOptions,
  GetTransactionsResult,
  GetTransactionsResults,
  IOType,
  Order,
  TransactionWithIOType,
  GetTransactionRPCResult,
} from "./type";
import { CkbIndexer } from "./indexer";
import * as services from "./services";

interface GetTransactionDetailResult {
  objects: TransactionWithStatus[];
  lastCursor: string | undefined;
}

export class CKBIndexerTransactionCollector extends BaseIndexerModule.TransactionCollector {
  filterOptions: TransactionCollectorOptions;
  constructor(
    public indexer: CkbIndexer,
    public queries: CKBIndexerQueryOptions,
    public CKBRpcUrl: string,
    public options?: TransactionCollectorOptions
  ) {
    super(indexer, queries, options);
    const defaultOptions: TransactionCollectorOptions = {
      skipMissing: false,
      includeStatus: true,
    };
    this.filterOptions = { ...defaultOptions, ...this.options };
  }

  /*
   *lock?: ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;
   *type?:  ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;
   *data?: will not filter
   *argsLen?: filter after get transaction detail;
   *fromBlock?: query by ckb-indexer;
   *toBlock?: query by ckb-indexer;
   *skip?: filter after get transaction from ckb-indexer;;
   *order?: query by ckb-indexer;
   */
  private async getTransactions(
    lastCursor?: string
  ): Promise<GetTransactionDetailResult> {
    const searchKeyFilter: SearchKeyFilter = {
      sizeLimit: this.queries.bufferSize,
      order: this.queries.order as Order,
    };
    if (lastCursor) {
      searchKeyFilter.lastCursor = lastCursor;
    }
    let transactionHashList: GetTransactionsResults = {
      objects: [],
      lastCursor: "",
    };
    /*
     * if both lock and type exist,we need search them in independent and then get intersection
     * cause ckb-indexer use searchKey script on each cell but native indexer use lock and type on transaction,
     * and one transaction may have many cells both in input and output, more detail in test 'Test query transaction by both input lock and output type script'
     */

    //if both lock and type, search search them in independent and then get intersection, GetTransactionsResults.lastCursor change to `${lockLastCursor}-${typeLastCursor}`
    if (
      services.instanceOfScriptWrapper(this.queries.lock) &&
      services.instanceOfScriptWrapper(this.queries.type)
    ) {
      transactionHashList = await this.getTransactionByLockAndTypeIndependent(
        searchKeyFilter
      );
      lastCursor = transactionHashList.lastCursor;
    } else {
      //query by ScriptWrapper.script,block_range,order
      transactionHashList = await this.indexer.getTransactions(
        services.generateSearchKey(this.queries),
        searchKeyFilter
      );
      lastCursor = transactionHashList.lastCursor;
    }

    // filter by ScriptWrapper.io_type
    transactionHashList.objects = this.filterByTypeIoTypeAndLockIoType(
      transactionHashList.objects,
      this.queries
    );
    // return if transaction hash list if empty
    if (transactionHashList.objects.length === 0) {
      return {
        objects: [],
        lastCursor: lastCursor,
      };
    }
    let transactionList: TransactionWithIOType[] = await this.getTransactionListFromRpc(
      transactionHashList
    );
    //get input cell transaction batch
    const txIoTypeInputOutPointList: any[] = [];
    transactionList.forEach((transactionWrapper) => {
      if (transactionWrapper.ioType === "input") {
        const targetOutPoint: OutPoint =
          transactionWrapper.transaction.inputs[
            parseInt(transactionWrapper.ioIndex)
          ].previous_output;
        const id =
          targetOutPoint.index + "-" + transactionWrapper.transaction.hash;
        if (!txIoTypeInputOutPointList.some((txReq) => txReq.id === id)) {
          txIoTypeInputOutPointList.push({
            id,
            jsonrpc: "2.0",
            method: "get_transaction",
            params: [targetOutPoint.tx_hash],
          });
        }
      }
    });
    if (txIoTypeInputOutPointList.length > 0) {
      await services
        .requestBatch(this.CKBRpcUrl, txIoTypeInputOutPointList)
        .then((response: GetTransactionRPCResult[]) => {
          response.forEach((item: GetTransactionRPCResult) => {
            const itemId = item.id.toString();
            const [cellIndex, transactionHash] = itemId.split("-");
            const output: Output =
              item.result.transaction.outputs[parseInt(cellIndex)];
            const targetTxs = transactionList.filter(
              (tx) =>
                tx.transaction.hash === transactionHash &&
                tx.ioType === "input" &&
                tx.transaction.inputs[parseInt(tx.ioIndex)].previous_output
                  .index === cellIndex
            );
            targetTxs.forEach((targetTx) => (targetTx.inputCell = output));
          });
        });
    }

    //filter by ScriptWrapper.argsLen
    transactionList = transactionList.filter(
      (transactionWrapper: TransactionWithIOType) => {
        if (
          transactionWrapper.ioType === "input" &&
          transactionWrapper.inputCell
        ) {
          return this.isCellScriptArgsValid(transactionWrapper.inputCell);
        } else {
          const targetCell: Output =
            transactionWrapper.transaction.outputs[
              parseInt(transactionWrapper.ioIndex)
            ];
          return this.isCellScriptArgsValid(targetCell);
        }
      }
    );
    const objects = transactionList.map((tx) => ({
      transaction: tx.transaction,
      tx_status: tx.tx_status,
    }));
    return {
      objects: objects,
      lastCursor: lastCursor,
    };
  }

  private async getTransactionByLockAndTypeIndependent(
    searchKeyFilter: SearchKeyFilter
  ): Promise<GetTransactionsResults> {
    const queryWithTypeAdditionOptions = { ...searchKeyFilter };
    const queryWithLockAdditionOptions = { ...searchKeyFilter };
    if (searchKeyFilter.lastCursor) {
      const [lockLastCursor, typeLastCursor] = searchKeyFilter.lastCursor.split(
        "-"
      );
      queryWithLockAdditionOptions.lastCursor = lockLastCursor;
      queryWithTypeAdditionOptions.lastCursor = typeLastCursor;
    }
    const queriesWithoutType = { ...this.queries, type: undefined };
    const transactionByLock = await this.indexer.getTransactions(
      services.generateSearchKey(queriesWithoutType),
      queryWithTypeAdditionOptions
    );
    const queriesWithoutLock = { ...this.queries, lock: undefined };
    const transactionByType = await this.indexer.getTransactions(
      services.generateSearchKey(queriesWithoutLock),
      queryWithLockAdditionOptions
    );

    const intersection = (
      transactionList1: GetTransactionsResult[],
      transactionList2: GetTransactionsResult[]
    ) => {
      const result: GetTransactionsResult[] = [];
      transactionList1.forEach((tx1) => {
        const tx2 = transactionList2.find(
          (item) => item.tx_hash === tx1.tx_hash
        );
        if (tx2) {
          // put the output io_type to intersection result, cause output have cells
          const targetTx = tx1.io_type === "output" ? tx1 : tx2;
          // change io_type to both cause targetTx exist both input and output
          result.push({ ...targetTx, io_type: "both" });
        }
      });
      return result;
    };
    let hashList = intersection(
      transactionByType.objects,
      transactionByLock.objects
    );
    const lastCursor =
      transactionByLock.lastCursor + "-" + transactionByType.lastCursor;
    const objects = hashList;
    return { objects, lastCursor };
  }

  private getTransactionListFromRpc = async (
    transactionHashList: GetTransactionsResults
  ) => {
    const getDetailRequestData = transactionHashList.objects.map(
      (hashItem: GetTransactionsResult, index: number) => {
        return {
          id: index,
          jsonrpc: "2.0",
          method: "get_transaction",
          params: [hashItem.tx_hash],
        };
      }
    );
    const transactionList: TransactionWithIOType[] = await services
      .requestBatch(this.CKBRpcUrl, getDetailRequestData)
      .then((response: GetTransactionRPCResult[]) => {
        return response.map(
          (item: GetTransactionRPCResult): TransactionWithIOType => {
            if (!this.filterOptions.skipMissing && !item.result) {
              throw new Error(
                `Transaction ${
                  transactionHashList.objects[item.id].tx_hash
                } is missing!`
              );
            }
            const ioType = transactionHashList.objects[item.id].io_type;
            const ioIndex = transactionHashList.objects[item.id].io_index;
            return { ioType, ioIndex, ...item.result };
          }
        );
      });
    return transactionList;
  };

  private isLockArgsLenMatched = (
    args: string | undefined,
    argsLen?: number | "any"
  ) => {
    if (!argsLen) return true;
    if (argsLen === "any") return true;
    if (argsLen === -1) return true;
    return services.getHexStringBytes(args as string) === argsLen;
  };

  // only valid after pass flow three validate
  private isCellScriptArgsValid = (targetCell: Output) => {
    if (this.queries.lock) {
      let lockArgsLen = services.instanceOfScriptWrapper(this.queries.lock)
        ? this.queries.lock.argsLen
        : this.queries.argsLen;
      if (!this.isLockArgsLenMatched(targetCell.lock.args, lockArgsLen)) {
        return false;
      }
    }

    if (this.queries.type && this.queries.type !== "empty") {
      let typeArgsLen = services.instanceOfScriptWrapper(this.queries.type)
        ? this.queries.type.argsLen
        : this.queries.argsLen;
      if (!this.isLockArgsLenMatched(targetCell.type?.args, typeArgsLen)) {
        return false;
      }
    }

    if (this.queries.type && this.queries.type === "empty") {
      if (targetCell.type) {
        return false;
      }
    }

    return true;
  };

  private filterByIoType = (
    inputResult: GetTransactionsResult[],
    ioType: IOType
  ) => {
    if (ioType === "both") {
      return inputResult;
    }
    if (ioType === "input" || ioType === "output") {
      return inputResult.filter(
        (item: GetTransactionsResult) =>
          item.io_type === ioType || item.io_type === "both"
      );
    }
    return inputResult;
  };

  private filterByTypeIoTypeAndLockIoType = (
    inputResult: GetTransactionsResult[],
    queries: CKBIndexerQueryOptions
  ) => {
    let result = inputResult;
    if (services.instanceOfScriptWrapper(queries.lock) && queries.lock.ioType) {
      result = this.filterByIoType(result, queries.lock.ioType);
    }
    if (services.instanceOfScriptWrapper(queries.type) && queries.type.ioType) {
      result = this.filterByIoType(result, queries.type.ioType);
    }
    return result;
  };

  async count(): Promise<number> {
    let lastCursor: undefined | string = undefined;
    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {
      const result: GetTransactionDetailResult = await this.getTransactions(
        lastCursor
      );
      lastCursor = result.lastCursor;
      return result.objects;
    };
    let counter = 0;
    let txs: TransactionWithStatus[] = await getTxWithCursor();
    if (txs.length === 0) {
      return 0;
    }
    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();
    let index: number = 0;
    let skippedCount: number = 0;
    while (true) {
      if (this.queries.skip && skippedCount < this.queries.skip) {
        skippedCount++;
      } else {
        counter += 1;
      }
      index++;
      //reset index and exchange `txs` and `buffer` after count last tx
      if (index === txs.length) {
        index = 0;
        txs = await buffer;
        // break if can not get more txs
        if (txs.length === 0) {
          break;
        }
        buffer = getTxWithCursor();
      }
    }
    return counter;
  }
  async getTransactionHashes(): Promise<string[]> {
    let lastCursor: undefined | string = undefined;
    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {
      const result: GetTransactionDetailResult = await this.getTransactions(
        lastCursor
      );
      lastCursor = result.lastCursor;
      return result.objects;
    };

    let transactionHashes: string[] = [];
    //skip query result in first query
    let txs: TransactionWithStatus[] = await getTxWithCursor();
    if (txs.length === 0) {
      return [];
    }
    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();
    let index: number = 0;
    let skippedCount: number = 0;
    while (true) {
      if (this.queries.skip && skippedCount < this.queries.skip) {
        skippedCount++;
      } else {
        if (txs[index].transaction.hash) {
          transactionHashes.push(txs[index].transaction.hash as string);
        }
      }

      index++;
      //reset index and exchange `txs` and `buffer` after count last tx
      if (index === txs.length) {
        index = 0;
        txs = await buffer;
        // break if can not get more txs
        if (txs.length === 0) {
          break;
        }
        buffer = getTxWithCursor();
      }
    }
    return transactionHashes;
  }
  async *collect() {
    let lastCursor: undefined | string = undefined;
    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {
      const result: GetTransactionDetailResult = await this.getTransactions(
        lastCursor
      );
      lastCursor = result.lastCursor;
      return result.objects;
    };
    //skip query result in first query
    let txs: TransactionWithStatus[] = await getTxWithCursor();
    if (txs.length === 0) {
      return 0;
    }
    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();
    let index: number = 0;
    let skippedCount: number = 0;
    while (true) {
      if (this.queries.skip && skippedCount < this.queries.skip) {
        skippedCount++;
      } else {
        if (this.filterOptions.includeStatus) {
          yield txs[index];
        } else {
          yield txs[index].transaction;
        }
      }
      index++;
      //reset index and exchange `txs` and `buffer` after count last tx
      if (index === txs.length) {
        index = 0;
        txs = await buffer;
        // break if can not get more txs
        if (txs.length === 0) {
          break;
        }
        buffer = getTxWithCursor();
      }
    }
  }
}

'''
'''--- packages/ckb-indexer/src/type.ts ---
import {
  Cell,
  Hexadecimal,
  HexString,
  QueryOptions,
  Script,
  OutPoint,
  HexNumber,
  Output,
  TransactionWithStatus,
} from "@ckb-lumos/base";
import { EventEmitter } from "events";
import { BIish } from "@ckb-lumos/bi";

export type ScriptType = "type" | "lock";
export type Order = "asc" | "desc";

export interface CKBIndexerQueryOptions extends QueryOptions {
  outputDataLenRange?: HexadecimalRange;
  outputCapacityRange?: HexadecimalRange;
  bufferSize?: number;
}

export type HexadecimalRange = [Hexadecimal, Hexadecimal];
export interface SearchFilter {
  script?: Script;
  output_data_len_range?: HexadecimalRange; //empty
  output_capacity_range?: HexadecimalRange; //empty
  block_range?: HexadecimalRange; //fromBlock-toBlock
}
export interface SearchKey {
  script: Script;
  script_type: ScriptType;
  filter?: SearchFilter;
}

export interface GetLiveCellsResult {
  last_cursor: string;
  objects: IndexerCell[];
}

export interface rpcResponse {
  status: number;
  data: rpcResponseData;
}

export interface rpcResponseData {
  result: string;
  error: string;
}

export interface IndexerCell {
  block_number: Hexadecimal;
  out_point: OutPoint;
  output: {
    capacity: HexNumber;
    lock: Script;
    type?: Script;
  };
  output_data: HexString;
  tx_index: Hexadecimal;
}

export interface TerminatorResult {
  stop: boolean;
  push: boolean;
}

export declare type Terminator = (
  index: number,
  cell: Cell
) => TerminatorResult;

export type HexNum = string;
export type IOType = "input" | "output" | "both";
export type Bytes32 = string;
export type GetTransactionsResult = {
  block_number: HexNum;
  io_index: HexNum;
  io_type: IOType;
  tx_hash: Bytes32;
  tx_index: HexNum;
};
export interface GetTransactionsResults {
  lastCursor: string | undefined;
  objects: GetTransactionsResult[];
}

export interface GetCellsResults {
  lastCursor: string;
  objects: Cell[];
}

export interface SearchKeyFilter {
  sizeLimit?: number;
  order?: Order;
  lastCursor?: string | undefined;
}

export interface OutputToVerify {
  output: Output;
  outputData: string;
}

export class IndexerEmitter extends EventEmitter {
  lock?: Script;
  type?: Script;
  outputData?: HexString | "any";
  argsLen?: number | "any";
  fromBlock?: BIish;
}

export interface OtherQueryOptions {
  withBlockHash: true;
  ckbRpcUrl: string;
}

export interface GetTransactionRPCResult {
  jsonrpc: string;
  id: number;
  result: TransactionWithStatus;
}

export interface TransactionWithIOType extends TransactionWithStatus {
  inputCell?: Output;
  ioType: IOType;
  ioIndex: string;
}

'''
'''--- packages/ckb-indexer/tests/collector.test.ts ---
import test from "ava";
import { Indexer, CellCollector } from "../src";
const {
  lock,
  type,
  cellCollectorTestCases,
  queryWithBlockHash,
} = require("./test_cases.js");
import { HashType } from "@ckb-lumos/base";
import { OtherQueryOptions } from "../src/type";

const nodeUri = "http://127.0.0.1:8118/rpc";
const indexUri = "http://127.0.0.1:8120";
const indexer = new Indexer(indexUri, nodeUri);

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("get count correct", async (t) => {
  const type = {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type" as HashType,
    args: "0xa178db16d8228db82911fdb536df1916e761e205",
  };
  const cellCollector = new CellCollector(indexer, { lock: type });
  const count = await cellCollector.count();
  t.is(count, 1);
});

test("query cells with block hash", async (t) => {
  const otherQueryOptions: OtherQueryOptions = {
    withBlockHash: true,
    ckbRpcUrl: nodeUri,
  };
  const cellCollector = new CellCollector(
    indexer,
    queryWithBlockHash.queryOption,
    otherQueryOptions
  );
  let cells = [];
  for await (const cell of cellCollector.collect()) {
    cells.push(cell);
  }
  t.deepEqual(
    cells,
    queryWithBlockHash.expectedResult,
    queryWithBlockHash.desc
  );
});

test("query cells with different queryOptions", async (t) => {
  for (const queryCase of cellCollectorTestCases) {
    const cellCollector = new CellCollector(indexer, queryCase.queryOption);
    let cells = [];
    for await (const cell of cellCollector.collect()) {
      cells.push(cell);
    }
    t.deepEqual(cells, queryCase.expectedResult, queryCase.desc);
  }
});

test("wrap plain Script into ScriptWrapper ", (t) => {
  const argsLen = 20;
  const wrappedLock = { script: lock, argsLen: argsLen };
  const wrappedType = { script: type, argsLen: argsLen };
  const queryOptions = {
    lock: wrappedLock,
    type: wrappedType,
    argsLen: argsLen,
  };
  const cellCollector = new CellCollector(indexer, queryOptions);
  t.deepEqual(cellCollector.queries.lock, lock);
  t.deepEqual(cellCollector.queries.type, type);
});

test("pass Scrip to CellCollector", (t) => {
  const argsLen = 20;
  const wrappedLock = { script: lock, argsLen: argsLen };
  const wrappedType = { script: type, argsLen: argsLen };
  const queryOptions = {
    lock: wrappedLock,
    type: wrappedType,
    argsLen: argsLen,
  };
  const cellCollector = new CellCollector(indexer, queryOptions);
  t.deepEqual(cellCollector.queries.lock, lock);
  t.deepEqual(cellCollector.queries.type, type);
});
test("throw error when pass null lock and null type to CellCollector", (t) => {
  const error = t.throws(
    () => {
      const queryOptions = {};
      new CellCollector(indexer, queryOptions);
    },
    { instanceOf: Error }
  );
  t.is(error.message, "Either lock or type script must be provided!");
});

test("throw error when pass null lock and empty type to CellCollector", (t) => {
  const error = t.throws(
    () => {
      const queryOptions = {
        type: "empty" as "empty",
      };
      new CellCollector(indexer, queryOptions);
    },
    { instanceOf: Error }
  );
  t.is(error.message, "Either lock or type script must be provided!");
});

test("throw error when pass wrong order to CellCollector", (t) => {
  const error = t.throws(
    () => {
      const queryOptions = {
        lock: lock,
        order: "some" as "asc",
      };
      new CellCollector(indexer, queryOptions);
    },
    { instanceOf: Error }
  );
  t.is(error.message, "Order must be either asc or desc!");
});

test("throw error when pass wrong fromBlock(toBlock) to CellCollector", (t) => {
  let error = t.throws(
    () => {
      const queryOptions = {
        lock: lock,
        order: "asc" as "asc",
        fromBlock: "1000",
      };
      new CellCollector(indexer, queryOptions);
    },
    { instanceOf: Error }
  );
  t.is(error.message, "fromBlock must be a hexadecimal!");

  error = t.throws(
    () => {
      const queryOptions = {
        lock: lock,
        order: "asc" as "asc",
        toBlock: "0x",
      };
      new CellCollector(indexer, queryOptions);
    },
    { instanceOf: Error }
  );
  t.is(error.message, "toBlock must be a hexadecimal!");
});

'''
'''--- packages/ckb-indexer/tests/indexer.test.ts ---
import sinon from "sinon";
import test from "ava";
import fs from "fs";
import path from "path";
const { indexerSubscribeTestCases } = require("./test_cases.js");
import { Indexer } from "../src";
const nodeUri = "http://127.0.0.1:8118/rpc";
const indexUri = "http://127.0.0.1:8120";
const indexer = new Indexer(indexUri, nodeUri);
test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

async function asyncRetry(
  callback: () => Promise<boolean> | boolean,
  interval: number,
  timeout: number
) {
  const start = Date.now();
  while (true) {
    if (Date.now() - start >= timeout) throw new Error("timeout");
    const shouldBreak = await callback();
    if (shouldBreak) break;
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
}

test("subscribe cells", async (t) => {
  let blockIndex = 0;
  const stub = sinon.stub(indexer, "tip").callsFake(() => {
    const blocks = JSON.parse(
      fs.readFileSync(path.join(__dirname, "./blocks_data.json")).toString()
    );
    const block = blocks[blockIndex];
    if (blockIndex !== 99) {
      blockIndex = blockIndex + 1;
    }
    return Promise.resolve({
      block_hash: block.header.hash,
      block_number: block.header.number,
    });
  });

  for (const queryCase of indexerSubscribeTestCases) {
    let spy = sinon.spy();
    const eventEmitter = indexer.subscribe(queryCase.queryOption);
    eventEmitter.on("changed", spy);
    asyncRetry(
      () => {
        return spy.callCount >= queryCase.expectedResult;
      },
      1000,
      10000
    ).then(() => {
      t.is(spy.callCount, queryCase.expectedResult, queryCase.desc);
      stub.resetHistory();
      blockIndex = 0;
      spy.resetHistory();
    });
  }
});

test("subscribe emitMedian TimeEvents", async (t) => {
  const expectedResult = "0x17d3723d27d";
  let result = "";
  const handle = (data: string) => {
    result = data;
  };
  const eventEmitter = indexer.subscribeMedianTime();
  eventEmitter.on("changed", handle);
  await asyncRetry(
    () => {
      return !!result;
    },
    1000,
    10000
  ).then(() => {
    t.is(result, expectedResult);
  });
});

test("throw error when pass both null lock and null type to subscribe", (t) => {
  const error = t.throws(
    () => {
      const queryOption = {};
      indexer.subscribe(queryOption);
    },
    { instanceOf: Error }
  );
  console.log(error);
  t.is(error.message, "Either lock or type script must be provided!");
});

'''
'''--- packages/ckb-indexer/tests/rpc.test.ts ---
import { Tip } from "@ckb-lumos/base";
import test from "ava";
import { RPC } from "../src";
const indexUri = "http://127.0.0.1:8120";
const rpc = new RPC(indexUri);
test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});
test("get tip", async (t) => {
  const expectTip: Tip = {
    block_hash:
      "0x4d0913d3d9330b1f2acf70d1b38baffa1d0588a92b006be3c5a0ca031e9841c7",
    block_number: "0x63",
  };
  const tip = await rpc.get_tip();
  t.deepEqual(tip, expectTip);
});

'''
'''--- packages/ckb-indexer/tests/transaction_collector.test.ts ---
import test from "ava";
import { Indexer, TransactionCollector } from "../src";
import { Order } from "../src/type";
const {
  lock,
  transactionCollectorHashTestCases,
  transactionCollectorCollectTestCases,
} = require("./test_cases.js");
import sinon from "sinon";
import * as services from "../src/services";
import {
  batchRequestAllIoType,
  batchRequestIoTypeInput,
  batchRequestResult,
  getTransactionFromIndexerResult,
  ioTypeInputResult,
  queryOption,
} from "./transaction_collector_special_test_case";

const nodeUri = "http://127.0.0.1:8118/rpc";
const indexUri = "http://127.0.0.1:8120";
const indexer = new Indexer(indexUri, nodeUri);
test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});
test("get count correct", async (t) => {
  const queryCase = transactionCollectorHashTestCases[0];
  const cellCollector = new TransactionCollector(
    indexer,
    queryCase.queryOption,
    nodeUri
  );
  const count = await cellCollector.count();
  t.is(count, 7);
});

test("get count correct with buffer 3 and skip 1", async (t) => {
  const queryCase = transactionCollectorHashTestCases[0];
  const newQueryOption = {
    ...queryCase.queryOption,
    ...{ skip: 1, bufferSize: 3 },
  };
  const cellCollector = new TransactionCollector(
    indexer,
    newQueryOption,
    nodeUri
  );
  const count = await cellCollector.count();
  t.is(count, 6);
});

test("get count correct if skip bigger than buffer size", async (t) => {
  const queryCase = transactionCollectorHashTestCases[0];
  const newQueryOption = {
    ...queryCase.queryOption,
    ...{ skip: 4, bufferSize: 3 },
  };
  const cellCollector = new TransactionCollector(
    indexer,
    newQueryOption,
    nodeUri
  );
  const count = await cellCollector.count();
  t.is(count, 3);
});

test("query transaction hash with different queryOptions", async (t) => {
  for (const queryCase of transactionCollectorHashTestCases) {
    const transactionCollector = new TransactionCollector(
      indexer,
      queryCase.queryOption,
      nodeUri
    );
    let transactionHashes = [];
    for (const hash of await transactionCollector.getTransactionHashes()) {
      transactionHashes.push(hash);
    }
    t.deepEqual(transactionHashes, queryCase.expectedResult, queryCase.desc);
  }
});

test("query transactions with different queryOptions", async (t) => {
  for (const queryCase of transactionCollectorCollectTestCases) {
    const transactionCollector = new TransactionCollector(
      indexer,
      queryCase.queryOption,
      nodeUri
    );
    let transactionList = [];
    for await (const hash of transactionCollector.collect()) {
      transactionList.push(hash);
    }
    t.deepEqual(transactionList, queryCase.expectedResult, queryCase.desc);
  }
});

test("throw error when pass null lock and null type to TransactionCollector", (t) => {
  const error = t.throws(
    () => {
      const queryOptions = {};
      new TransactionCollector(indexer, queryOptions, nodeUri);
    },
    { instanceOf: Error }
  );
  t.is(error.message, "Either lock or type script must be provided!");
});

test("throw error when pass null lock and empty type to TransactionCollector", (t) => {
  const error = t.throws(
    () => {
      const queryOptions = {
        type: "empty" as "empty",
      };
      new TransactionCollector(indexer, queryOptions, nodeUri);
    },
    { instanceOf: Error }
  );
  t.is(error.message, "Either lock or type script must be provided!");
});

test("throw error when pass wrong fromBlock(toBlock) to TransactionCollector", (t) => {
  let error = t.throws(
    () => {
      const queryOptions = {
        lock: lock,
        order: "asc" as Order,
        toBlock: "0x",
      };
      new TransactionCollector(indexer, queryOptions, nodeUri);
    },
    { instanceOf: Error }
  );
  t.is(error.message, "toBlock must be a hexadecimal!");
});

test("input cell can be found in transaction detail", async (t) => {
  const getTransactionsStub = sinon.stub(indexer, "getTransactions");
  getTransactionsStub.onCall(0).returns(getTransactionFromIndexerResult);
  getTransactionsStub.onCall(1).returns(
    Promise.resolve({
      lastCursor:
        "0x809bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce801bde8b19b4505dd1d1310223edecea20adc4e240e000000000021420d000000010000000000",
      objects: [],
    })
  );
  const requestBatchStub = sinon.stub(services, "requestBatch");
  requestBatchStub
    .withArgs(nodeUri, batchRequestAllIoType)
    .returns(batchRequestResult);
  requestBatchStub
    .withArgs(nodeUri, batchRequestIoTypeInput)
    .returns(ioTypeInputResult);
  const cellCollector = new TransactionCollector(indexer, queryOption, nodeUri);
  const count = await cellCollector.count();
  t.is(count, 2);
  getTransactionsStub.reset();
  requestBatchStub.reset();
  getTransactionsStub.restore();
  requestBatchStub.restore();
});

'''
'''--- packages/ckb-indexer/tests/transaction_collector_special_test_case.ts ---
import { HashType } from "@ckb-lumos/base";
import { IOType } from "../src/type";

export const queryOption = {
  lock: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type" as HashType,
    args: "0xbde8b19b4505dd1d1310223edecea20adc4e240e",
  },
};

export const ioTypeInputResult = Promise.resolve([
  {
    jsonrpc: "2.0",
    result: {
      transaction: {
        cell_deps: [
          {
            dep_type: "dep_group",
            out_point: {
              index: "0x0",
              tx_hash:
                "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
            },
          },
        ],
        hash:
          "0x02a002fc56640bf15cd43d06e0d31ec01acd69ef534c2223cd677d2df9316bc0",
        header_deps: [],
        inputs: [
          {
            previous_output: {
              index: "0x0",
              tx_hash:
                "0xe39bd05f4814c9148d60273e252c6ac7cbad750adf7e74a1d8b37ed709d04be4",
            },
            since: "0x0",
          },
        ],
        outputs: [
          {
            capacity: "1111111",
            lock: {
              args: "0x81a870a08f4721c5fa495de9c29e3076440af55f",
              code_hash:
                "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              hash_type: "type",
            },
            type: null,
          },
          {
            capacity: "0x189640200",
            lock: {
              args: "0xbde8b19b4505dd1d1310223edecea20adc4e240e",
              code_hash:
                "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              hash_type: "type",
            },
            type: null,
          },
        ],
        outputs_data: ["0x", "0x"],
        version: "0x0",
        witnesses: [
          "0x5500000010000000550000005500000041000000ea523d1845e793f67f3048c0df950de85b02f8934eeabdbe0a8b6073f5065d9558c1f997f1a20215193393e3b46575b91dd9b042d36811fc0a7ac0c5eedf026a00",
        ],
      },
      tx_status: {
        block_hash:
          "0x344ea1f8ff1105a033f27e728bd92cf8a3666c3dbe5a84151c7200cad88bdd79",
        reason: null,
        status: "committed",
      },
    },
    id:
      "0x1-0xc8a7917a9b269ca746f49177e75d4f5e7eb7ad20f79f44b079b5caecd4ffe96f",
  },
]);
export const batchRequestIoTypeInput = [
  {
    id:
      "0x1-0xc8a7917a9b269ca746f49177e75d4f5e7eb7ad20f79f44b079b5caecd4ffe96f",
    jsonrpc: "2.0",
    method: "get_transaction",
    params: [
      "0x02a002fc56640bf15cd43d06e0d31ec01acd69ef534c2223cd677d2df9316bc0",
    ],
  },
];
export const getTransactionFromIndexerResult = Promise.resolve({
  lastCursor:
    "0x809bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce801bde8b19b4505dd1d1310223edecea20adc4e240e000000000021420d000000010000000000",
  objects: [
    {
      block_number: "xxxxxxx",
      io_index: "0x1",
      io_type: "output" as IOType,
      tx_hash:
        "0x02a002fc56640bf15cd43d06e0d31ec01acd69ef534c2223cd677d2df9316bc0",
      tx_index: "0x2",
    },
    {
      block_number: "0x21420d",
      io_index: "0x0",
      io_type: "input" as IOType,
      tx_hash:
        "0xc8a7917a9b269ca746f49177e75d4f5e7eb7ad20f79f44b079b5caecd4ffe96f",
      tx_index: "0x1",
    },
  ],
});
export const batchRequestAllIoType = [
  {
    id: 0,
    jsonrpc: "2.0",
    method: "get_transaction",
    params: [
      "0x02a002fc56640bf15cd43d06e0d31ec01acd69ef534c2223cd677d2df9316bc0",
    ],
  },
  {
    id: 1,
    jsonrpc: "2.0",
    method: "get_transaction",
    params: [
      "0xc8a7917a9b269ca746f49177e75d4f5e7eb7ad20f79f44b079b5caecd4ffe96f",
    ],
  },
];
export const batchRequestResult = Promise.resolve([
  {
    jsonrpc: "2.0",
    result: {
      transaction: {
        cell_deps: [
          {
            dep_type: "dep_group",
            out_point: {
              index: "0x0",
              tx_hash:
                "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
            },
          },
        ],
        hash:
          "0x02a002fc56640bf15cd43d06e0d31ec01acd69ef534c2223cd677d2df9316bc0",
        header_deps: [],
        inputs: [
          {
            previous_output: {
              index: "0x0",
              tx_hash:
                "0xe39bd05f4814c9148d60273e252c6ac7cbad750adf7e74a1d8b37ed709d04be4",
            },
            since: "0x0",
          },
        ],
        outputs: [
          {
            capacity: "1111111",
            lock: {
              args: "0x81a870a08f4721c5fa495de9c29e3076440af55f",
              code_hash:
                "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              hash_type: "type",
            },
            type: null,
          },
          {
            capacity: "0x189640200",
            lock: {
              args: "0xbde8b19b4505dd1d1310223edecea20adc4e240e",
              code_hash:
                "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              hash_type: "type",
            },
            type: null,
          },
        ],
        outputs_data: ["0x", "0x"],
        version: "0x0",
        witnesses: [
          "0x5500000010000000550000005500000041000000ea523d1845e793f67f3048c0df950de85b02f8934eeabdbe0a8b6073f5065d9558c1f997f1a20215193393e3b46575b91dd9b042d36811fc0a7ac0c5eedf026a00",
        ],
      },
      tx_status: {
        block_hash:
          "0x344ea1f8ff1105a033f27e728bd92cf8a3666c3dbe5a84151c7200cad88bdd79",
        reason: null,
        status: "committed",
      },
    },
    id: 0,
  },
  {
    jsonrpc: "2.0",
    result: {
      transaction: {
        cell_deps: [
          {
            dep_type: "dep_group",
            out_point: {
              index: "0x0",
              tx_hash:
                "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
            },
          },
        ],
        hash:
          "0xc8a7917a9b269ca746f49177e75d4f5e7eb7ad20f79f44b079b5caecd4ffe96f",
        header_deps: [],
        inputs: [
          {
            previous_output: {
              index: "0x1",
              tx_hash:
                "0x02a002fc56640bf15cd43d06e0d31ec01acd69ef534c2223cd677d2df9316bc0",
            },
            since: "0x0",
          },
          {
            previous_output: {
              index: "0x0",
              tx_hash:
                "0x02a002fc56640bf15cd43d06e0d31ec01acd69ef534c2223cd677d2df9316bc0",
            },
            since: "0x0",
          },
        ],
        outputs: [
          {
            capacity: "0x746a528800",
            lock: {
              args: "0xf4f9a05e39ac30f79a1a6fede73528be23002bba",
              code_hash:
                "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              hash_type: "type",
            },
            type: null,
          },
          {
            capacity: "0x7269990f76f",
            lock: {
              args: "0xcde34141e599aa7473cb0f56fa7f97b92503f275",
              code_hash:
                "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              hash_type: "type",
            },
            type: null,
          },
        ],
        outputs_data: ["0x", "0x"],
        version: "0x0",
        witnesses: [
          "0x5500000010000000550000005500000041000000a100bd5e8eb121e07dc73680377830be7f8f28f9a22136b65ca113a3750e6c4d0e5a6bba9da2d1add0c252d103a3957705dcffc25d18a1be2e80dc0de412588601",
          "0x5500000010000000550000005500000041000000107e1c7ebec06c3ce900256efded7ccaa26b74ddb8b3dd180ae8727d52ae38f1449eca346fcd8b474ea9060dea40c1ab1ce4c0930567ddd511e17d0466a0f4a500",
        ],
      },
      tx_status: {
        block_hash:
          "0x2d564e5524762bdb0a4ab8120dd7fa4d3f2720406e82a2dfe2d239fe0f2d579e",
        reason: null,
        status: "committed",
      },
    },
    id: 1,
  },
]);

'''
'''--- packages/ckb-indexer/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib",
    "lib": ["es2020", "dom"]
  },
  "include": ["src"]
}

'''
'''--- packages/common-scripts/README.md ---
# `@ckb-lumos/common-scripts`

Common script implementation for lumos. Includes `secp256k1_blake2b` lock script, `secp256k1_blake160_multisig` lock script, `dao` type script, `sudt` type script now.

`LocktimePool` script includes `secp256k1_blake160_multisig` cells which with locktime in lock `args` (which `args` total length is 28 bytes, last 8 bytes is a `since` format locktime in BigUInt64LE encode) and `DAO` step2 cells.

`common` script allows you to `transfer` capacity from `fromInfos` to an address. It will use locktime pool cells first by default.

`deploy` script provides `generateDeployWithDataTx`, `generateDeployWithTypeIdTx` and `generateUpgradeTypeIdDataTx`, these generators help in the process of deploying contracts.

`p2pkh` scripts generates message for signing P2PKH transaction.

## Usage

`common` script support new lock scripts provided by user, and [`pw-lock`](./examples/pw_lock/lock.ts) shows how to do it.

Following script will show how to use `common` script to transfer capacity to another address. `secp256k1_blake160`, `secp256k1_blake160_multisig` and `locktime_pool` script are similar to `common`, and `common` maybe a better choose.

```javascript
const { common } = require('@ckb-lumos/common-scripts');
const { sealTransaction } = require("@ckb-lumos/helpers")
const { Indexer } = require("@ckb-lumos/ckb-indexer")

// We can use Indexer module as cell provider
const indexer = new Indexer("http://127.0.0.1:8114");

const tipHeader = {
  compact_target: '0x20010000',
  dao: '0x49bfb20771031d556c8480d47f2a290059f0ac7e383b6509006f4a772ed50200',
  epoch: '0xa0006002b18',
  hash: '0x432451e23c26f45eaceeedcc261764d6485ea5c9a204ac55ad755bb8dec9a079',
  nonce: '0x8199548f8a5ac7a0f0caef1620f37b79',
  number: '0x1aef6',
  parent_hash: '0x63594a64108f19f6aed53d0dca9ab4075aac4379cb80b2097b0deac8fc16fd3b',
  proposals_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  timestamp: '0x172f6b9a4cf',
  transactions_root: '0x282dbadcd49f3e229d997875f37f4e4f19cb4f04fcf762e9639145aaa667b6f8',
  uncles_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  version: '0x0'
}

const fromInfos = [
  "ckb1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gq5f9mxs",
  {
    R: 0,
    M: 1,
    publicKeyHashes: ["0x36c329ed630d6ce750712a477543672adab57f4c"],
  },
]

let txSkeleton = TransactionSkeleton({ cellProvider: indexer })

// If using secp256k1_blake160_multisig lock script, put MultisigScript to `fromInfos` for generate signing messages.
// By default, `common.transfer` will use cells with locktime firstly. `tipHeader` is required when you want to spent cells with locktime.
txSkeleton = await common.transfer(
  txSkeleton,
  fromInfos,
  "ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd",
  BigInt(3500 * 10 ** 8),
  tipHeader,
)

// Or you want to use cells without locktime firstly.
txSkeleton = await common.transfer(
  txSkeleton,
  fromInfos,
  "ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd",
  BigInt(3500 * 10 ** 8),
  tipHeader,
  { useLocktimeCellsFirst: false }
)

// When you want to pay fee for transaction, just call `payFee`.
txSkeleton = await common.payFee(
  txSkeleton,
  fromInfos,
  BigInt(1*10**8),
  tipHeader,
)

// `prepareSigningEntries` will generate message for signing.
// Signing messages will fill in `txSkeleton.signingEntries`.
txSkeleton = await common.prepareSigningEntries(
  txSkeleton
)

// Then you can sign messages in order and get contents.
// NOTE: lumos not provided tools for generate signatures now.
// Call `sealTransaction` to get a transaction.
const tx = sealTransaction(txSkeleton, contents)

// Then you can send tx to a CKB node via RPC `send_transaction`.
```

Following script will show how to use `DAO` script.

```javascript
const { dao } = require("@ckb-lumos/common-scripts")

let txSkeleton = TransactionSkeleton({ cellProvider: indexer })

// First, deposit capacity to dao.
txSkeleton = await dao.deposit(
  txSkeleton,
  "ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd", // will gather inputs from this address.
  "ckb1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gq5f9mxs", // will generate a dao cell with lock of this address.
  BigInt(1000*10**8),
)

// Using `listDaoCells` to list all deposited cells.
const daoDepositedCells = await dao.listDaoCells(
  indexer,
  "ckb1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gq5f9mxs",
  "deposit",
)

// Or using `CellCollector`
const daoDepositedCellCollector = new dao.CellCollector(
  "ckb1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gq5f9mxs",
  indexer,
  "deposit",
)

for await (const inputCell of daoDepositedCellCollector.collect()) {
  console.log(inputCell)
}

// And pick one to withdraw.
// `fromInfo` only required for multisig script.
txSkeleton = await dao.withdraw(
  txSkeleton,
  daoDepositedCells[0],
)

// Then if want to unlock dao withdrew cells, just use `common.transfer`.
```

Following script will show how to use `sUDT` script.

```javascript
const { sudt } = require("@ckb-lumos/common-scripts")
let txSkeleton = TransactionSkeleton({ cellProvider: indexer })

// issue an sudt token, will use the second param address to generate sudt token(it's lock hash).
txSkeleton = await sudt.issueToken(
  txSkeleton,
  "ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd",
  10000n,
);

// and transfer sUDT
const sudtToken = "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d"
txSkeleton = await sudt.transfer(
  txSkeleton,
  ["ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd"],
  sudtToken,
  "ckb1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gq5f9mxs",
  1000n,
  "ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd",
);
```

Following script will show how to use `deploy` script.
```javascript
const { generateDeployWithDataTx, generateDeployWithTypeIdTx, generateUpgradeTypeIdDataTx, payFee } = require("@ckb-lumos/common-scripts");
const { Indexer } = require("@ckb-lumos/ckb-indexer");
const { initializeConfig, predefined } = require("@ckb-lumos/config-manager");
const { parseAddress } = require("@ckb-lumos/helpers");

initializeConfig(predefined.AGGRON4);

const CKB_RPC_URL = "http://localhost:8114";
const CKB_INDEXER_URL = "http://localhost:8116";
const indexer = new Indexer(CKB_INDEXER_URL, CKB_RPC_URL);

const address = "ckt1qyqptxys5l9vk39ft0hswscxgseawc77y2wqlr558h";
// Lock script of the deploy account
const outputScriptLock = parseAddress(address);
// Binary data you want to deploy
const scriptBinary = Uint8Array.of(1);

let deployOptions = {
  cellProvider: indexer,
  scriptBinary: scriptBinary,
  outputScriptLock: outputScriptLock,
}

// Ganarate txSkeleton for deploying with data.
let txSkeleton = await generateDeployWithDataTx(deployOptions);
// Or if you want to delpoy with Type ID so that you can upgarde the contract in the future.
let txSkeleton = await generateDeployWithTypeIdTx(deployOptions);

// Pay transaction fee.
txSkeleton = await payFee(txSkeleton, address, txFee);
// Then you can sign and seal the transaction for sending.

// To upgrade a contract with Type ID, add its Type ID to deployOptions.
const typeId = {
  code_hash: '0x00000000000000000000000000000000000000000000000000545950455f4944',
  hash_type: 'type',
  args: '0x7abcd9f949a16b40ff5b50b56e62d2a6a007e544d8491bb56476693b6c45fd27'
}
const upgradeOptions = {
  cellProvider: cellProvider,
  scriptBinary: scriptBinary,
  outputScriptLock: outputScriptLock,
  typeId: typeId
}
// Ganarate txSkeleton for upgrading.
let upgradeTxSkeleton = await generateUpgradeTypeIdDataTx(upgradeOptions);
```

Check [omni lock example](https://github.com/nervosnetwork/lumos/blob/develop/examples/omni-lock-metamask/lib.ts) and [pw lock example](https://github.com/nervosnetwork/lumos/blob/develop/examples/pw-lock-metamask/lib.ts) for how to use `p2pkh` script.

'''
'''--- packages/common-scripts/examples/pw_lock/config.json ---
{
  "__COMMENT__": "It's a devnet config, different devnet has different config. Set env.LUMOS_CONFIG_FILE to this config file (or your own config file) and call `initializeConfig()`, see ./lock.ts#L349-L350 as an example.",
  "PREFIX": "ckt",
  "SCRIPTS": {
    "SECP256K1_BLAKE160": {
      "CODE_HASH": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      "HASH_TYPE": "type",
      "TX_HASH": "0x785aa819c8f9f8565a62f744685f8637c1b34886e57154e4e5a2ac7f225c7bf5",
      "INDEX": "0x0",
      "DEP_TYPE": "dep_group",
      "SHORT_ID": 0
    },
    "SECP256K1_BLAKE160_MULTISIG": {
      "CODE_HASH": "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      "HASH_TYPE": "type",
      "TX_HASH": "0x785aa819c8f9f8565a62f744685f8637c1b34886e57154e4e5a2ac7f225c7bf5",
      "INDEX": "0x1",
      "DEP_TYPE": "dep_group",
      "SHORT_ID": 1
    },
    "DAO": {
      "CODE_HASH": "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      "HASH_TYPE": "type",
      "TX_HASH": "0x13c137fdf071c0ab3e6a4c8aaefc16c9bb7b9593b77822b151b18412ecd2ee41",
      "INDEX": "0x2",
      "DEP_TYPE": "code"
    },
    "SUDT": {
      "CODE_HASH": "0x48dbf59b4c7ee1547238021b4869bceedf4eea6b43772e5d66ef8865b6ae7212",
      "HASH_TYPE": "data",
      "TX_HASH": "0x473a05da909427e2b77d3c4226d29a15539b12d9ddf7d4fda4de8a76df18555c",
      "INDEX": "0x0",
      "DEP_TYPE": "code"
    },
    "ANYONE_CAN_PAY": {
      "CODE_HASH": "0x636be2afb13c1d0f3478c22c6572b12dd13bd492f648302d5682fffe7e7efdaa",
      "HASH_TYPE": "type",
      "TX_HASH": "0xc520c895e20ade5b6b0bd90598f8b205afefdc316e38e87fac239ca3f0829378",
      "INDEX": "0x0",
      "DEP_TYPE": "dep_group"
    },
    "PW_LOCK": {
      "CODE_HASH": "0xabd63bf842d098c568f32b53191106649a84817288fd0116d4f3ed1b88f0f7e2",
      "HASH_TYPE": "type",
      "TX_HASH": "0x7441b129b99b4c6ced2016d9b44fcb88544510b426fcdcbf11e9f3c9d0a338dc",
      "INDEX": "0x0",
      "DEP_TYPE": "dep_group"
    }
  }
}

'''
'''--- packages/common-scripts/examples/pw_lock/lock.ts ---
import { LockScriptInfo, FromInfo, parseFromInfo, common } from "../../src";
import {
  Script,
  CellProvider,
  QueryOptions,
  CellCollector as CellCollectorInterface,
  Cell,
  HexString,
  PackedSince,
  OutPoint,
  values,
  WitnessArgs,
  core,
  utils,
  CellDep,
} from "@ckb-lumos/base";
import {
  Options,
  TransactionSkeletonType,
  createTransactionFromSkeleton,
} from "@ckb-lumos/helpers";
import { getConfig, Config, initializeConfig } from "@ckb-lumos/config-manager";
import { Reader, normalizers } from "@ckb-lumos/toolkit";
import { Set } from "immutable";
import keccak, { Keccak } from "keccak";

const { ScriptValue } = values;

// https://github.com/lay2dev/pw-lock/commit/b447c2bb3f855e933e36212b45af4dec92adf705 pw-lock is a lock script which uses secp256k1_keccak256 algorithm.

/* 65-byte zeros in hex */
export const SIGNATURE_PLACEHOLDER =
  "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

function isPwLock(script: Script, config: Config) {
  const template = config.SCRIPTS.PW_LOCK!;
  return (
    script.code_hash === template.CODE_HASH &&
    script.hash_type === template.HASH_TYPE
  );
}

// Help to deal with cell deps, add cell dep to txSkeleton.get("cellDeps") if not exists.
function addCellDep(
  txSkeleton: TransactionSkeletonType,
  newCellDep: CellDep
): TransactionSkeletonType {
  const cellDep = txSkeleton.get("cellDeps").find((cellDep) => {
    return (
      cellDep.dep_type === newCellDep.dep_type &&
      new values.OutPointValue(cellDep.out_point, { validate: false }).equals(
        new values.OutPointValue(newCellDep.out_point, { validate: false })
      )
    );
  });

  if (!cellDep) {
    txSkeleton = txSkeleton.update("cellDeps", (cellDeps) => {
      return cellDeps.push({
        out_point: newCellDep.out_point,
        dep_type: newCellDep.dep_type,
      });
    });
  }

  return txSkeleton;
}

// Defined a `CellCollector` class that implements `CellCollectorInterface`.
// `collect` method will collect pw-lock cells.
class CellCollector implements CellCollectorInterface {
  private cellCollector: CellCollectorInterface;
  private config: Config;
  private fromScript: Script;

  constructor(
    fromInfo: FromInfo,
    cellProvider: CellProvider,
    {
      config = undefined,
      queryOptions = {},
    }: Options & {
      queryOptions?: QueryOptions;
    }
  ) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }
    config = config || getConfig();
    this.fromScript = parseFromInfo(fromInfo, { config }).fromScript;
    this.config = config;

    queryOptions = {
      ...queryOptions,
      lock: this.fromScript,
      type: queryOptions.type || "empty",
    };

    this.cellCollector = cellProvider.collector(queryOptions);
  }

  async *collect(): AsyncGenerator<Cell> {
    if (!isPwLock(this.fromScript, this.config)) {
      return;
    }

    for await (const inputCell of this.cellCollector.collect()) {
      yield inputCell;
    }
  }
}

// `setupInputCell` accpet a input and transfer this input to an output.
// Then add the input and output to txSkeleton, it should be noted that the output must be added to the end of txSkeleton.get("outputs").
// And this function should also add required cell deps and witnesses.
async function setupInputCell(
  txSkeleton: TransactionSkeletonType,
  inputCell: Cell,
  _fromInfo?: FromInfo,
  {
    config = undefined,
    defaultWitness = "0x",
    since = undefined,
  }: Options & {
    defaultWitness?: HexString;
    since?: PackedSince;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  const fromScript = inputCell.cell_output.lock;
  if (!isPwLock(fromScript, config)) {
    throw new Error(`Not PW_LOCK input!`);
  }

  // add inputCell to txSkeleton
  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(inputCell);
  });

  const output: Cell = {
    cell_output: {
      capacity: inputCell.cell_output.capacity,
      lock: inputCell.cell_output.lock,
      type: inputCell.cell_output.type,
    },
    data: inputCell.data,
  };

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(output);
  });

  if (since) {
    txSkeleton = txSkeleton.update("inputSinces", (inputSinces) => {
      return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
    });
  }

  txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
    return witnesses.push(defaultWitness);
  });

  const template = config.SCRIPTS.PW_LOCK;
  if (!template) {
    throw new Error(`PW_LOCK script not defined in config!`);
  }

  const scriptOutPoint: OutPoint = {
    tx_hash: template.TX_HASH,
    index: template.INDEX,
  };

  // add cell dep
  txSkeleton = addCellDep(txSkeleton, {
    out_point: scriptOutPoint,
    dep_type: template.DEP_TYPE,
  });

  // add witness
  /*
   * Modify the skeleton, so the first witness of the fromAddress script group
   * has a WitnessArgs construct with 65-byte zero filled values. While this
   * is not required, it helps in transaction fee estimation.
   */
  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
    }
    let witness: string = txSkeleton.get("witnesses").get(firstIndex)!;
    const newWitnessArgs: WitnessArgs = {
      /* 65-byte zeros in hex */
      lock: SIGNATURE_PLACEHOLDER,
    };
    if (witness !== "0x") {
      const witnessArgs = new core.WitnessArgs(new Reader(witness));
      const lock = witnessArgs.getLock();
      if (
        lock.hasValue() &&
        new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock
      ) {
        throw new Error(
          "Lock field in first witness is set aside for signature!"
        );
      }
      const inputType = witnessArgs.getInputType();
      if (inputType.hasValue()) {
        newWitnessArgs.input_type = new Reader(
          inputType.value().raw()
        ).serializeJson();
      }
      const outputType = witnessArgs.getOutputType();
      if (outputType.hasValue()) {
        newWitnessArgs.output_type = new Reader(
          outputType.value().raw()
        ).serializeJson();
      }
    }
    witness = new Reader(
      core.SerializeWitnessArgs(
        normalizers.NormalizeWitnessArgs(newWitnessArgs)
      )
    ).serializeJson();
    txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
      witnesses.set(firstIndex, witness)
    );
  }

  return txSkeleton;
}

// It's a secp256k1_keccak256 sighash all lock script, so we need a keccak256 hash method.
class Keccak256Hasher {
  private hasher: Keccak;

  constructor() {
    this.hasher = keccak("keccak256");
  }

  update(data: string | ArrayBuffer | Reader): this {
    const reader = new Reader(data);
    const array: Buffer = Buffer.from(reader.serializeJson().slice(2), "hex");
    this.hasher.update(array);
    return this;
  }

  digestReader(): Reader {
    const hex = "0x" + this.hasher.digest("hex").toString();
    return new Reader(hex);
  }

  digestHex() {
    return this.digestReader().serializeJson();
  }
}

function hashWitness(hasher: any, witness: HexString): void {
  const lengthBuffer = new ArrayBuffer(8);
  const view = new DataView(lengthBuffer);
  const witnessReader = new Reader(witness);
  view.setBigUint64(0, BigInt(witnessReader.length()), true);
  hasher.update(view.buffer);
  hasher.update(witnessReader);
}

// This function help to generate signing messages from pw-lock inputs.
function prepareSigningEntries(
  txSkeleton: TransactionSkeletonType,
  { config = undefined }: Options = {}
): TransactionSkeletonType {
  config = config || getConfig();

  const template = config.SCRIPTS.PW_LOCK;
  if (!template) {
    throw new Error(`Provided config does not have PW_LOCK script setup!`);
  }
  let processedArgs = Set<string>();
  const tx = createTransactionFromSkeleton(txSkeleton);
  const txHash = utils
    .ckbHash(
      core.SerializeRawTransaction(normalizers.NormalizeRawTransaction(tx))
    )
    .serializeJson();
  const inputs = txSkeleton.get("inputs");
  const witnesses = txSkeleton.get("witnesses");
  let signingEntries = txSkeleton.get("signingEntries");
  for (let i = 0; i < inputs.size; i++) {
    const input = inputs.get(i)!;
    if (
      template.CODE_HASH === input.cell_output.lock.code_hash &&
      template.HASH_TYPE === input.cell_output.lock.hash_type &&
      !processedArgs.has(input.cell_output.lock.args)
    ) {
      processedArgs = processedArgs.add(input.cell_output.lock.args);
      const lockValue = new values.ScriptValue(input.cell_output.lock, {
        validate: false,
      });
      const hasher = new Keccak256Hasher();
      hasher.update(txHash);
      if (i >= witnesses.size) {
        throw new Error(
          `The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`
        );
      }
      hashWitness(hasher, witnesses.get(i)!);
      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
        const otherInput = inputs.get(j)!;
        if (
          lockValue.equals(
            new values.ScriptValue(otherInput.cell_output.lock, {
              validate: false,
            })
          )
        ) {
          hashWitness(hasher, witnesses.get(j)!);
        }
      }
      for (let j = inputs.size; j < witnesses.size; j++) {
        hashWitness(hasher, witnesses.get(j)!);
      }
      const hh = new Keccak256Hasher();
      // This magic number is from https://github.com/lay2dev/pw-lock/blob/b447c2bb3f855e933e36212b45af4dec92adf705/c/secp256k1_keccak256_lock.h#L523
      hh.update("0x19457468657265756d205369676e6564204d6573736167653a0a3332");
      hh.update(hasher.digestHex());
      const signingEntry = {
        type: "witness_args_lock",
        index: i,
        message: hh.digestHex(),
      };
      signingEntries = signingEntries.push(signingEntry);
    }
  }
  txSkeleton = txSkeleton.set("signingEntries", signingEntries);
  return txSkeleton;
}

export async function main() {
  // set config
  // deploy your own pw-lock and update config.json
  process.env.LUMOS_CONFIG_FILE = __dirname + "/config.json";
  initializeConfig();

  const config = getConfig();
  const template = config.SCRIPTS.PW_LOCK!;
  // Get a lockScriptInfo and register to common
  // `setupOutputCell` is an optional method, if you only want to add a to output, you can ignore this.
  // `anyone_can_pay` script shows how to use `setupOutputCell`.
  const lockScriptInfo: LockScriptInfo = {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    lockScriptInfo: {
      CellCollector,
      setupInputCell,
      prepareSigningEntries,
    },
  };
  common.registerCustomLockScriptInfos([lockScriptInfo]);

  // Then you can use functions like `common.setupInputCell` and `common.transfer` as other lock scripts.
  // Flowing is a example to show how to do.

  // let txSkeleton = TransactionSkeleton({ cellProvider: indexer })
  // const fromScript: Script = {
  //   code_hash: template.CODE_HASH,
  //   hash_type: template.HASH_TYPE,
  //   args: pwLockArgs,
  // }
  // const fromAddress = generateAddress(fromScript)

  // const toAddress = "ckt1qyqrdsefa43s6m882pcj53m4gdnj4k440axqswmu83"

  // txSkeleton = await common.transfer(
  //   txSkeleton,
  //   [fromAddress],
  //   toAddress,
  //   BigInt(200*10**8),
  // )

  // txSkeleton = common.prepareSigningEntries(txSkeleton)

  // Then sign messages by key pair.
}

'''
'''--- packages/common-scripts/package.json ---
{
  "name": "@ckb-lumos/common-scripts",
  "version": "0.17.0-rc8",
  "description": "Common script support in lumos",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "src"
  ],
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "@ckb-lumos/config-manager": "^0.17.0-rc8",
    "@ckb-lumos/helpers": "^0.17.0-rc8",
    "@ckb-lumos/rpc": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8",
    "immutable": "^4.0.0-rc.12"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests,examples}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests,examples}/**/*.ts\"",
    "test": "ava **/*.test.ts --timeout=2m",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  },
  "devDependencies": {
    "@types/keccak": "^3.0.1",
    "keccak": "^3.0.1"
  }
}

'''
'''--- packages/common-scripts/src/anyone_can_pay.ts ---
import {
  Address,
  Cell,
  CellCollector as CellCollectorType,
  CellProvider,
  core,
  HexString,
  OutPoint,
  PackedSince,
  QueryOptions,
  Script,
  utils,
  values,
  WitnessArgs,
} from "@ckb-lumos/base";
import { Config, getConfig } from "@ckb-lumos/config-manager";
import {
  createTransactionFromSkeleton,
  generateAddress,
  minimalCellCapacityCompatible,
  Options,
  parseAddress,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import { normalizers, Reader } from "@ckb-lumos/toolkit";
import { List, Set } from "immutable";
import { BI, BIish } from "@ckb-lumos/bi";
import { FromInfo, parseFromInfo } from "./from_info";
import {
  addCellDep,
  hashWitness,
  isAcpScript,
  SECP_SIGNATURE_PLACEHOLDER,
} from "./helper";
const { ScriptValue } = values;
const { CKBHasher, ckbHash, readBigUInt128LECompatible } = utils;

export class CellCollector implements CellCollectorType {
  private cellCollector: CellCollectorType;
  private config: Config;
  public readonly fromScript: Script;

  constructor(
    fromInfo: FromInfo,
    cellProvider: CellProvider,
    {
      config = undefined,
      queryOptions = {},
    }: Options & {
      queryOptions?: QueryOptions;
    } = {}
  ) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }
    config = config || getConfig();
    this.fromScript = parseFromInfo(fromInfo, { config }).fromScript;

    this.config = config;

    queryOptions = {
      ...queryOptions,
      lock: this.fromScript,
      type: queryOptions.type || "empty",
    };

    this.cellCollector = cellProvider.collector(queryOptions);
  }

  async *collect(): AsyncGenerator<Cell> {
    if (!isAcpScript(this.fromScript, this.config)) {
      return;
    }
    for await (const inputCell of this.cellCollector.collect()) {
      yield inputCell;
    }
  }
}

export async function setupInputCell(
  txSkeleton: TransactionSkeletonType,
  inputCell: Cell,
  _fromInfo?: FromInfo,
  {
    config = undefined,
    defaultWitness = "0x",
    since = undefined,
  }: Options & {
    defaultWitness?: HexString;
    since?: PackedSince;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  const inputLock: Script = inputCell.cell_output.lock;
  if (!isAcpScript(inputLock, config)) {
    throw new Error("Not anyone-can-pay input!");
  }

  // add inputCell to txSkeleton
  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(inputCell);
  });

  if (since) {
    txSkeleton = txSkeleton.update("inputSinces", (inputSinces) => {
      return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
    });
  }

  txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
    return witnesses.push(defaultWitness);
  });

  const outputCell: Cell = {
    cell_output: {
      capacity: inputCell.cell_output.capacity,
      lock: inputCell.cell_output.lock,
      type: inputCell.cell_output.type,
    },
    data: inputCell.data,
  };

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(outputCell);
  });

  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push({
      field: "outputs",
      index: txSkeleton.get("outputs").size - 1,
    });
  });

  const template = config.SCRIPTS.ANYONE_CAN_PAY;
  if (!template) {
    throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
  }

  const scriptOutPoint: OutPoint = {
    tx_hash: template.TX_HASH,
    index: template.INDEX,
  };

  // add cell_dep
  txSkeleton = addCellDep(txSkeleton, {
    out_point: scriptOutPoint,
    dep_type: template.DEP_TYPE,
  });

  // add witness
  const firstIndex = txSkeleton.get("inputs").findIndex((input) => {
    return new ScriptValue(input.cell_output.lock, { validate: false }).equals(
      new ScriptValue(inputLock, { validate: false })
    );
  });
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
        return witnesses.push("0x");
      });
    }
    let witness: HexString = txSkeleton.get("witnesses").get(firstIndex)!;
    const newWitnessArgs: WitnessArgs = {
      /* 65-byte zeros in hex */
      lock: SECP_SIGNATURE_PLACEHOLDER,
    };
    if (witness !== "0x") {
      const witnessArgs = new core.WitnessArgs(new Reader(witness));
      const lock = witnessArgs.getLock();
      if (
        lock.hasValue() &&
        new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock
      ) {
        throw new Error(
          "Lock field in first witness is set aside for signature!"
        );
      }
      const inputType = witnessArgs.getInputType();
      if (inputType.hasValue()) {
        newWitnessArgs.input_type = new Reader(
          inputType.value().raw()
        ).serializeJson();
      }
      const outputType = witnessArgs.getOutputType();
      if (outputType.hasValue()) {
        newWitnessArgs.output_type = new Reader(
          outputType.value().raw()
        ).serializeJson();
      }
    }
    witness = new Reader(
      core.SerializeWitnessArgs(
        normalizers.NormalizeWitnessArgs(newWitnessArgs)
      )
    ).serializeJson();
    txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
      return witnesses.set(firstIndex, witness);
    });
  }

  return txSkeleton;
}

// export for tests
export function checkLimit(acpArgs: HexString, capacity: BIish): void {
  let _capacity = BI.from(capacity);
  let minimalAmount: BI | undefined;
  let minimalCapacity: BI | undefined;
  if (acpArgs.length >= 46) {
    minimalAmount = BI.from(10).pow("0x" + acpArgs.slice(44, 46));
  }
  if (acpArgs.length >= 44) {
    // should convert to shannons
    const multiplier = BI.from(10).pow("0x" + acpArgs.slice(42, 44));
    const multiplicand = BI.from(10).pow(8);
    minimalCapacity = multiplier.mul(multiplicand);
  }
  // Both minimalAmount & minimalCapacity OR only minimalCapacity
  if (minimalCapacity && minimalAmount) {
    //check if undefined
    if (_capacity.lt(minimalCapacity)) {
      throw new Error(
        `capacity(${capacity}) less than toAddress minimal capacity limit(${minimalCapacity}), and amount less then toAddress minimal amount limit(${minimalAmount})! If you want to transfer sudt, maybe sudt.transfer can help you.`
      );
    }
  } else if (minimalCapacity) {
    //check if undefined
    if (_capacity.lt(minimalCapacity)) {
      throw new Error(
        `capacity(${capacity}) less than toAddress minimal capacity limit(${minimalCapacity})!`
      );
    }
  }
}

export async function setupOutputCell(
  txSkeleton: TransactionSkeletonType,
  outputCell: Cell,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  const toScript: Script = outputCell.cell_output.lock;

  const capacity: BI = BI.from(outputCell.cell_output.capacity);

  checkLimit(toScript.args, capacity.toString());

  const cellProvider = txSkeleton.get("cellProvider");
  if (!cellProvider) {
    throw new Error(`Cell Provider is missing!`);
  }

  const toAddress: Address = generateAddress(toScript, { config });
  const toAddressCellCollector = new CellCollector(toAddress, cellProvider, {
    config,
  });

  const toAddressInput: Cell | void = (
    await toAddressCellCollector.collect().next()
  ).value;

  let outputCapacity: BI = capacity;
  if (toAddressInput) {
    outputCapacity = capacity.add(toAddressInput.cell_output.capacity);

    txSkeleton = txSkeleton.update("inputs", (inputs) => {
      return inputs.push(toAddressInput);
    });
    txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
      return witnesses.push("0x");
    });
  }

  outputCell.cell_output.capacity = "0x" + outputCapacity.toString(16);
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(outputCell);
  });

  if (toAddressInput) {
    const template = config.SCRIPTS.ANYONE_CAN_PAY;
    if (!template) {
      throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
    }
    const scriptOutPoint: OutPoint = {
      tx_hash: template.TX_HASH,
      index: template.INDEX,
    };

    // add cell_dep
    txSkeleton = addCellDep(txSkeleton, {
      out_point: scriptOutPoint,
      dep_type: template.DEP_TYPE,
    });
  }

  return txSkeleton;
}

export async function injectCapacity(
  cellCollector: CellCollector,
  txSkeleton: TransactionSkeletonType,
  outputIndex: number,
  capacity: BIish,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  if (outputIndex >= txSkeleton.get("outputs").size) {
    throw new Error(`Invalid output index!`);
  }

  let _capacity = BI.from(capacity);

  const template = config.SCRIPTS.ANYONE_CAN_PAY;
  if (!template) {
    throw new Error(
      `Provided config does not have ANYONE_CAN_PAY script setup!`
    );
  }

  const fromScript: Script = cellCollector.fromScript;

  /*
   * First, check if there is any output cells that contains enough capacity
   * for us to tinker with.
   *
   * TODO: the solution right now won't cover all cases, some outputs before the
   * last output might still be tinkerable, right now we are working on the
   * simple solution, later we can change this for more optimizations.
   */
  const lastFreezedOutput = txSkeleton
    .get("fixedEntries")
    .filter(({ field }) => field === "outputs")
    .maxBy(({ index }) => index);
  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
  for (; i < txSkeleton.get("outputs").size && _capacity.gt(0); i++) {
    const output = txSkeleton.get("outputs").get(i)!;
    if (
      new ScriptValue(output.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    ) {
      const cellCapacity: BI = BI.from(output.cell_output.capacity);
      const availableCapacity: BI = cellCapacity.sub(
        minimalCellCapacityCompatible(output)
      );
      // should maintain minimal cell capcity in anyone-can-pay output
      const deductCapacity: BI = _capacity.gte(availableCapacity)
        ? availableCapacity
        : _capacity;
      _capacity = _capacity.sub(deductCapacity);
      output.cell_output.capacity =
        "0x" + cellCapacity.sub(deductCapacity).toString(16);
    }
  }
  // Remove all output cells with capacity equal to 0
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.filter(
      (output) => !BI.from(output.cell_output.capacity).eq(0)
    );
  });

  const getInputKey = (input: Cell) =>
    `${input.out_point!.tx_hash}_${input.out_point!.index}`;
  if (_capacity.gt(0)) {
    const changeCell: Cell = {
      cell_output: {
        capacity: "0x0",
        lock: fromScript,
        type: undefined,
      },
      data: "0x",
      out_point: undefined,
      block_hash: undefined,
    };
    let changeCapacity = BI.from(0);
    const minimalChangeCapacity: BI = BI.from(
      minimalCellCapacityCompatible(changeCell)
    );

    let previousInputs = Set<string>();
    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(getInputKey(input));
    }

    // Are all from same lock script and type script, so only need one change cell
    for await (const inputCell of cellCollector.collect()) {
      if (previousInputs.has(getInputKey(inputCell))) {
        continue;
      }

      txSkeleton = await setupInputCell(txSkeleton, inputCell, undefined, {
        config,
      });
      const lastOutputIndex: number = txSkeleton.get("outputs").size - 1;
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.remove(lastOutputIndex);
      });
      const fixedEntryIndex: number = txSkeleton
        .get("fixedEntries")
        .findIndex((fixedEntry) => {
          return (
            fixedEntry.field === "outputs" &&
            fixedEntry.index === lastOutputIndex
          );
        });
      if (fixedEntryIndex >= 0) {
        txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
          return fixedEntries.remove(fixedEntryIndex);
        });
      }

      const inputCapacity = BI.from(inputCell.cell_output.capacity);
      let deductCapacity = inputCapacity;
      if (deductCapacity.gt(_capacity)) {
        deductCapacity = _capacity;
      }
      _capacity = _capacity.sub(deductCapacity);
      changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));
      if (_capacity.eq(0) && changeCapacity.gte(minimalChangeCapacity)) {
        break;
      }

      changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(changeCell);
      });
    }

    if (_capacity.gt(0) || changeCapacity < minimalChangeCapacity) {
      throw new Error(`Not enough capacity in from address!`);
    }

    changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
      return outputs.push(changeCell);
    });
  }

  return txSkeleton;
}

export function prepareSigningEntries(
  txSkeleton: TransactionSkeletonType,
  { config = undefined }: Options = {}
): TransactionSkeletonType {
  config = config || getConfig();

  const scriptType = "ANYONE_CAN_PAY";
  const template = config.SCRIPTS[scriptType];
  if (!template) {
    throw new Error(
      `Provided config does not have ${scriptType} script setup!`
    );
  }

  let processedArgs = Set<string>();
  const tx = createTransactionFromSkeleton(txSkeleton);
  const txHash = ckbHash(
    core.SerializeRawTransaction(normalizers.NormalizeRawTransaction(tx))
  ).serializeJson();
  const inputs = txSkeleton.get("inputs");
  const witnesses = txSkeleton.get("witnesses");
  let signingEntries = txSkeleton.get("signingEntries");
  for (let i = 0; i < inputs.size; i++) {
    const input = inputs.get(i)!;
    if (
      template.CODE_HASH === input.cell_output.lock.code_hash &&
      template.HASH_TYPE === input.cell_output.lock.hash_type &&
      !processedArgs.has(input.cell_output.lock.args)
    ) {
      processedArgs = processedArgs.add(input.cell_output.lock.args);

      // skip if input sum capcity <= output sum capacity
      // and input sum amount <= output sum amount
      const outputs: List<Cell> = txSkeleton.get("outputs").filter((output) => {
        return new ScriptValue(output.cell_output.lock, {
          validate: false,
        }).equals(new ScriptValue(input.cell_output.lock, { validate: false }));
      });
      const sumOfOutputCapacity: BI = outputs
        .map((output) => BI.from(output.cell_output.capacity))
        .reduce((result, c) => result.add(c), BI.from(0));

      const sumOfOutputAmount: BI = outputs
        .filter((output) => output.data !== "0x")
        .map((output) => BI.from(readBigUInt128LECompatible(output.data)))
        .reduce((result, c) => result.add(c), BI.from(0));

      const fInputs: List<Cell> = inputs.filter((i) => {
        return new ScriptValue(i.cell_output.lock, { validate: false }).equals(
          new ScriptValue(input.cell_output.lock, { validate: false })
        );
      });

      const sumOfInputCapacity: BI = fInputs
        .map((i) => BI.from(i.cell_output.capacity))
        .reduce((result, c) => result.add(c), BI.from(0));

      const sumOfInputAmount: BI = fInputs
        .filter((i) => i.data !== "0x")
        .map((i) => BI.from(readBigUInt128LECompatible(i.data)))
        .reduce((result, c) => result.add(c), BI.from(0));

      if (
        sumOfInputCapacity.lte(sumOfOutputCapacity) &&
        sumOfInputAmount.lte(sumOfOutputAmount)
      ) {
        continue;
      }

      const lockValue = new values.ScriptValue(input.cell_output.lock, {
        validate: false,
      });
      const hasher = new CKBHasher();
      hasher.update(txHash);
      if (i >= witnesses.size) {
        throw new Error(
          `The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`
        );
      }
      hashWitness(hasher, witnesses.get(i)!);
      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
        const otherInput = inputs.get(j)!;
        if (
          lockValue.equals(
            new values.ScriptValue(otherInput.cell_output.lock, {
              validate: false,
            })
          )
        ) {
          hashWitness(hasher, witnesses.get(j)!);
        }
      }
      for (let j = inputs.size; j < witnesses.size; j++) {
        hashWitness(hasher, witnesses.get(j)!);
      }
      const signingEntry = {
        type: "witness_args_lock",
        index: i,
        message: hasher.digestHex(),
      };
      signingEntries = signingEntries.push(signingEntry);
    }
  }
  txSkeleton = txSkeleton.set("signingEntries", signingEntries);
  return txSkeleton;
}

export async function withdraw(
  txSkeleton: TransactionSkeletonType,
  fromInput: Cell,
  toAddress: Address,
  capacity: BIish,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  // from input must be a anyone-can-pay script
  if (!isAcpScript(fromInput.cell_output.lock, config)) {
    throw new Error(`fromInput is not a ANYONE_CAN_PAY cell!`);
  }

  // check capacity
  let _capacity = BI.from(capacity);
  const fromInputCapacity: BI = BI.from(fromInput.cell_output.capacity);
  const inputMinimalCellCapacity: BI = BI.from(
    minimalCellCapacityCompatible(fromInput)
  );
  if (
    !(
      (_capacity.gte(0) &&
        _capacity.lte(fromInputCapacity.sub(inputMinimalCellCapacity))) ||
      _capacity.eq(fromInputCapacity)
    )
  ) {
    throw new Error(
      `capacity must be in [0, ${fromInputCapacity.sub(
        inputMinimalCellCapacity
      )}] or ${fromInputCapacity} !`
    );
  }

  const toScript = parseAddress(toAddress, { config });

  const targetOutput: Cell = {
    cell_output: {
      capacity: "0x" + capacity.toString(16),
      lock: toScript,
      type: undefined,
    },
    data: "0x",
    out_point: undefined,
    block_hash: undefined,
  };

  if (isAcpScript(toScript, config)) {
    checkLimit(toScript.args, capacity);

    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) {
      throw new Error(`Cell Provider is missing!`);
    }

    const toAddressCellCollector = new CellCollector(toAddress, cellProvider, {
      config,
    });

    const toAddressInput: Cell | void = (
      await toAddressCellCollector.collect().next()
    ).value;
    if (!toAddressInput) {
      throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);
    }

    const outputCapacity: BI = _capacity.add(
      toAddressInput.cell_output.capacity
    );
    targetOutput.cell_output.capacity = "0x" + outputCapacity.toString(16);

    txSkeleton = txSkeleton.update("inputs", (inputs) => {
      return inputs.push(toAddressInput);
    });
    txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
      return witnesses.push("0x");
    });
  }

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(targetOutput);
  });

  txSkeleton = await setupInputCell(
    txSkeleton,
    fromInput,
    generateAddress(fromInput.cell_output.lock, { config }),
    { config }
  );
  // remove output and fixedEntry added by `setupInputCell`
  const lastOutputIndex: number = txSkeleton.get("outputs").size - 1;
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.remove(lastOutputIndex);
  });
  const fixedEntryIndex: number = txSkeleton
    .get("fixedEntries")
    .findIndex((fixedEntry) => {
      return (
        fixedEntry.field === "outputs" && fixedEntry.index === lastOutputIndex
      );
    });
  if (fixedEntryIndex >= 0) {
    txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
      return fixedEntries.remove(fixedEntryIndex);
    });
  }

  if (!_capacity.eq(fromInputCapacity)) {
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
      return outputs.push({
        cell_output: {
          capacity: "0x" + fromInputCapacity.sub(capacity).toString(16),
          lock: fromInput.cell_output.lock,
          type: fromInput.cell_output.type,
        },
        data: fromInput.data,
      });
    });
  }

  return txSkeleton;
}

export default {
  CellCollector,
  setupInputCell,
  setupOutputCell,
  injectCapacity,
  prepareSigningEntries,
  withdraw,
};

'''
'''--- packages/common-scripts/src/common.ts ---
import {
  parseAddress,
  TransactionSkeletonType,
  Options,
  createTransactionFromSkeleton,
  minimalCellCapacityCompatible,
} from "@ckb-lumos/helpers";
import secp256k1Blake160Multisig from "./secp256k1_blake160_multisig";
import { FromInfo, parseFromInfo } from "./from_info";
import secp256k1Blake160 from "./secp256k1_blake160";
import { getConfig, Config } from "@ckb-lumos/config-manager";
import locktimePool from "./locktime_pool";
import {
  Address,
  Header,
  Script,
  values,
  Cell,
  HexString,
  Hash,
  PackedSince,
  utils,
  Transaction,
} from "@ckb-lumos/base";
import anyoneCanPay from "./anyone_can_pay";
const { ScriptValue } = values;
import { Set } from "immutable";
import { SerializeTransaction } from "@ckb-lumos/base/lib/core";
import { normalizers } from "@ckb-lumos/toolkit";
import { isAcpScript } from "./helper";
import { BI, BIish } from "@ckb-lumos/bi";

function defaultLogger(level: string, message: string) {
  console.log(`[${level}] ${message}`);
}

/**
 * CellCollector should be a class which implement CellCollectorInterface.
 * If you want to work well with `transfer`, `injectCapacity`, `payFee`, `payFeeByFeeRate`,
 *  please add the `output` at the end of `txSkeleton.get("outputs")`
 */
export interface LockScriptInfo {
  code_hash: Hash;
  hash_type: "type" | "data";
  lockScriptInfo: {
    CellCollector: any;
    setupInputCell(
      txSkeleton: TransactionSkeletonType,
      inputCell: Cell,
      fromInfo?: FromInfo,
      options?: {
        config?: Config;
        defaultWitness?: HexString;
        since?: PackedSince;
      }
    ): Promise<TransactionSkeletonType>;
    prepareSigningEntries(
      txSkeleton: TransactionSkeletonType,
      options: Options
    ): TransactionSkeletonType;
    setupOutputCell?: (
      txSkeleton: TransactionSkeletonType,
      outputCell: Cell,
      options: Options
    ) => Promise<TransactionSkeletonType>;
  };
}

/**
 * `infos` includes predefined and customized.
 */
let lockScriptInfos: {
  configHashCode: number;
  _predefinedInfos: LockScriptInfo[];
  _customInfos: LockScriptInfo[];
  infos: LockScriptInfo[];
} = {
  configHashCode: 0,
  _predefinedInfos: [],
  _customInfos: [],
  get infos(): LockScriptInfo[] {
    return [...this._predefinedInfos, ...this._customInfos];
  },
};

function resetLockScriptInfos(): void {
  lockScriptInfos.configHashCode = 0;
  lockScriptInfos._predefinedInfos = [];
  lockScriptInfos._customInfos = [];
}

function getLockScriptInfos() {
  return lockScriptInfos;
}

export function registerCustomLockScriptInfos(infos: LockScriptInfo[]): void {
  lockScriptInfos._customInfos = infos;
}

function generateLockScriptInfos({ config = undefined }: Options = {}): void {
  config = config || getConfig();

  // lazy load
  const getPredefinedInfos = () => {
    const secpTemplate = config!.SCRIPTS.SECP256K1_BLAKE160;
    const multisigTemplate = config!.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
    const acpTemplate = config!.SCRIPTS.ANYONE_CAN_PAY;

    const predefinedInfos: LockScriptInfo[] = [];

    if (secpTemplate) {
      predefinedInfos.push({
        code_hash: secpTemplate.CODE_HASH,
        hash_type: secpTemplate.HASH_TYPE,
        lockScriptInfo: secp256k1Blake160,
      });
    } else {
      defaultLogger(
        "warn",
        "SECP256K1_BLAKE160 script info not found in config!"
      );
    }

    if (multisigTemplate) {
      predefinedInfos.push({
        code_hash: multisigTemplate.CODE_HASH,
        hash_type: multisigTemplate.HASH_TYPE,
        lockScriptInfo: secp256k1Blake160Multisig,
      });
    } else {
      defaultLogger(
        "warn",
        "SECP256K1_BLAKE160_MULTISIG script info not found in config!"
      );
    }

    if (acpTemplate) {
      predefinedInfos.push({
        code_hash: acpTemplate.CODE_HASH,
        hash_type: acpTemplate.HASH_TYPE,
        lockScriptInfo: anyoneCanPay,
      });
    } else {
      defaultLogger("warn", "ANYONE_CAN_PAY script info not found in config!");
    }

    return predefinedInfos;
  };

  const configHashCode: number = utils.hashCode(
    Buffer.from(JSON.stringify(config!))
  );

  if (lockScriptInfos.infos.length === 0) {
    lockScriptInfos._predefinedInfos = getPredefinedInfos();
    lockScriptInfos.configHashCode = configHashCode;
  } else {
    if (configHashCode !== lockScriptInfos.configHashCode) {
      defaultLogger(`warn`, "`config` changed, regenerate lockScriptInfos!");
      lockScriptInfos._predefinedInfos = getPredefinedInfos();
      lockScriptInfos.configHashCode = configHashCode;
    }
  }
}

/**
 *
 * @param txSkeleton
 * @param fromInfos
 * @param toAddress
 * @param changeAddress
 * @param amount
 * @param tipHeader will not use locktime cells if tipHeader not provided
 * @param options
 */
export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  toAddress: Address,
  amount: BIish,
  changeAddress?: Address,
  tipHeader?: Header,
  {
    config = undefined,
    useLocktimeCellsFirst = true,
    LocktimePoolCellCollector = locktimePool.CellCollector,
  }: {
    config?: Config;
    useLocktimeCellsFirst?: boolean;
    LocktimePoolCellCollector?: any;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  let _amount = BI.from(amount);
  if (!toAddress) {
    throw new Error("You must provide a to address!");
  }

  const toScript: Script = parseAddress(toAddress, { config });
  const targetOutput: Cell = {
    cell_output: {
      capacity: "0x" + _amount.toString(16),
      lock: toScript,
      type: undefined,
    },
    data: "0x",
  };

  generateLockScriptInfos({ config });

  const targetLockScriptInfo:
    | LockScriptInfo
    | undefined = lockScriptInfos.infos.find((lockScriptInfo) => {
    return (
      lockScriptInfo.code_hash === toScript.code_hash &&
      lockScriptInfo.hash_type === toScript.hash_type
    );
  });

  if (
    targetLockScriptInfo &&
    "setupOutputCell" in targetLockScriptInfo.lockScriptInfo
  ) {
    txSkeleton = await targetLockScriptInfo.lockScriptInfo.setupOutputCell!(
      txSkeleton,
      targetOutput,
      {
        config,
      }
    );
  } else {
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
      return outputs.push(targetOutput);
    });
  }

  txSkeleton = await injectCapacity(
    txSkeleton,
    fromInfos,
    _amount.toString(),
    changeAddress,
    tipHeader,
    {
      config,
      useLocktimeCellsFirst,
      LocktimePoolCellCollector,
    }
  );

  return txSkeleton;
}

export async function injectCapacity(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  amount: BIish,
  changeAddress?: Address,
  tipHeader?: Header,
  {
    config = undefined,
    useLocktimeCellsFirst = true,
    LocktimePoolCellCollector = locktimePool.CellCollector,
    enableDeductCapacity = true,
  }: {
    config?: Config;
    useLocktimeCellsFirst?: boolean;
    LocktimePoolCellCollector?: any;
    enableDeductCapacity?: boolean;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  let _amount = BI.from(amount);
  let deductAmount = _amount;

  if (fromInfos.length === 0) {
    throw new Error("No from info provided!");
  }

  const changeLockScript: Script = parseFromInfo(
    changeAddress || fromInfos[0]!,
    { config }
  ).fromScript;
  const changeCell: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: changeLockScript,
      type: undefined,
    },
    data: "0x",
  };
  const minimalChangeCapacity: BI = BI.from(
    minimalCellCapacityCompatible(changeCell)
  );
  let changeCapacity: BI = BI.from(0);
  if (useLocktimeCellsFirst) {
    if (tipHeader) {
      const result = await locktimePool.injectCapacityWithoutChangeCompatible(
        txSkeleton,
        fromInfos,
        deductAmount.toString(),
        tipHeader,
        minimalChangeCapacity.toString(),
        {
          config,
          LocktimeCellCollector: LocktimePoolCellCollector,
          enableDeductCapacity,
        }
      );
      txSkeleton = result.txSkeleton;
      deductAmount = BI.from(result.capacity);
      // if deductAmount > 0, changeCapacity must be 0
      changeCapacity = BI.from(result.changeCapacity);
    }

    if (deductAmount.gt(0)) {
      const result = await _commonTransferCompatible(
        txSkeleton,
        fromInfos,
        deductAmount,
        minimalChangeCapacity,
        { config, enableDeductCapacity }
      );
      txSkeleton = result.txSkeleton;
      deductAmount = result.capacity;
      changeCapacity = result.changeCapacity;
    } else if (
      deductAmount.eq(0) &&
      changeCapacity.gt(0) &&
      changeCapacity.lt(minimalChangeCapacity)
    ) {
      const result = await _commonTransferCompatible(
        txSkeleton,
        fromInfos,
        minimalChangeCapacity.sub(changeCapacity),
        BI.from(0),
        { config, enableDeductCapacity }
      );
      txSkeleton = result.txSkeleton;
      deductAmount = result.capacity;
      changeCapacity = result.changeCapacity;
    }
  } else {
    const result = await _commonTransferCompatible(
      txSkeleton,
      fromInfos,
      deductAmount,
      minimalChangeCapacity,
      { config, enableDeductCapacity }
    );
    txSkeleton = result.txSkeleton;
    deductAmount = result.capacity;
    changeCapacity = result.changeCapacity;

    if (tipHeader) {
      if (deductAmount.gt(0)) {
        const result = await locktimePool.injectCapacityWithoutChangeCompatible(
          txSkeleton,
          fromInfos,
          deductAmount.toString(),
          tipHeader,
          minimalChangeCapacity.toString(),
          {
            config,
            LocktimeCellCollector: LocktimePoolCellCollector,
            enableDeductCapacity,
          }
        );
        txSkeleton = result.txSkeleton;
        deductAmount = BI.from(result.capacity);
        changeCapacity = BI.from(result.changeCapacity);
      } else if (
        deductAmount.eq(0) &&
        changeCapacity.gt(0) &&
        changeCapacity.lt(minimalChangeCapacity)
      ) {
        const result = await locktimePool.injectCapacityWithoutChangeCompatible(
          txSkeleton,
          fromInfos,
          minimalChangeCapacity.sub(changeCapacity).toString(),
          tipHeader,
          0,
          {
            config,
            LocktimeCellCollector: LocktimePoolCellCollector,
            enableDeductCapacity,
          }
        );
        txSkeleton = result.txSkeleton;
        deductAmount = BI.from(result.capacity);
        changeCapacity = BI.from(result.changeCapacity);
      }
    }
  }

  if (deductAmount.gt(0)) {
    throw new Error("Not enough capacity in from infos!");
  }

  if (changeCapacity.gt(0) && changeCapacity.lt(minimalChangeCapacity)) {
    throw new Error("Not enough capacity in from infos for change!");
  }

  if (changeCapacity.gt(0)) {
    changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);

    txSkeleton = txSkeleton.update("outputs", (outputs) => {
      return outputs.push(changeCell);
    });
  }

  return txSkeleton;
}

export async function payFee(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  amount: BIish,
  tipHeader?: Header,
  {
    config = undefined,
    useLocktimeCellsFirst = true,
    enableDeductCapacity = true,
  }: {
    config?: Config;
    useLocktimeCellsFirst?: boolean;
    enableDeductCapacity?: boolean;
  } = {}
): Promise<TransactionSkeletonType> {
  return injectCapacity(txSkeleton, fromInfos, amount, undefined, tipHeader, {
    config,
    useLocktimeCellsFirst,
    enableDeductCapacity,
  });
}

export function prepareSigningEntries(
  txSkeleton: TransactionSkeletonType,
  { config = undefined }: Options = {}
): TransactionSkeletonType {
  config = config || getConfig();

  generateLockScriptInfos({ config });

  for (const lockScriptInfo of lockScriptInfos.infos) {
    txSkeleton = lockScriptInfo.lockScriptInfo.prepareSigningEntries(
      txSkeleton,
      { config }
    );
  }

  return txSkeleton;
}

async function _commonTransfer(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  amount: bigint,
  minimalChangeCapacity: bigint,
  {
    config = undefined,
    enableDeductCapacity = true,
  }: Options & { enableDeductCapacity?: boolean } = {}
): Promise<{
  txSkeleton: TransactionSkeletonType;
  capacity: bigint;
  changeCapacity: bigint;
}> {
  const result = await _commonTransferCompatible(
    txSkeleton,
    fromInfos,
    amount,
    minimalChangeCapacity,
    {
      config,
      enableDeductCapacity,
    }
  );
  return {
    txSkeleton: result.txSkeleton,
    capacity: BigInt(result.capacity.toString()),
    changeCapacity: BigInt(result.changeCapacity.toString()),
  };
}

async function _commonTransferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  amount: BIish,
  minimalChangeCapacity: BIish,
  {
    config = undefined,
    enableDeductCapacity = true,
  }: Options & { enableDeductCapacity?: boolean } = {}
): Promise<{
  txSkeleton: TransactionSkeletonType;
  capacity: BI;
  changeCapacity: BI;
}> {
  config = config || getConfig();
  let _amount = BI.from(amount);

  const cellProvider = txSkeleton.get("cellProvider");
  if (!cellProvider) {
    throw new Error("Cell Provider is missing!");
  }

  const getInputKey = (input: Cell) =>
    `${input.out_point!.tx_hash}_${input.out_point!.index}`;
  let previousInputs = Set<string>();
  for (const input of txSkeleton.get("inputs")) {
    previousInputs = previousInputs.add(getInputKey(input));
  }

  const fromScripts: Script[] = fromInfos.map((fromInfo) => {
    return parseFromInfo(fromInfo, { config }).fromScript;
  });

  for (const fromScript of fromScripts) {
    if (enableDeductCapacity && _amount.gt(0)) {
      [txSkeleton, _amount] = _deductCapacityCompatible(
        txSkeleton,
        fromScript,
        _amount
      );
    }
  }

  generateLockScriptInfos({ config });

  let changeCapacity: BI = BI.from(0);

  if (_amount.gt(0)) {
    // collect cells
    loop1: for (const fromInfo of fromInfos) {
      const cellCollectors = lockScriptInfos.infos.map((lockScriptInfo) => {
        return new lockScriptInfo.lockScriptInfo.CellCollector(
          fromInfo,
          cellProvider,
          {
            config,
          }
        );
      });

      for (const cellCollector of cellCollectors) {
        for await (const inputCell of cellCollector.collect()) {
          const inputKey: string = getInputKey(inputCell);
          if (previousInputs.has(inputKey)) {
            continue;
          }
          previousInputs = previousInputs.add(inputKey);
          const result = await collectInputCompatible(
            txSkeleton,
            inputCell,
            fromInfo,
            {
              config,
              needCapacity: _amount,
            }
          );
          txSkeleton = result.txSkeleton;

          const inputCapacity: BI = BI.from(result.availableCapacity);
          let deductCapacity: BI = inputCapacity;
          if (deductCapacity.gt(_amount)) {
            deductCapacity = _amount;
          }
          _amount = _amount.sub(deductCapacity);
          changeCapacity = changeCapacity.add(
            inputCapacity.sub(deductCapacity)
          );

          if (
            _amount.eq(0) &&
            (changeCapacity.eq(0) || changeCapacity.gt(minimalChangeCapacity))
          ) {
            break loop1;
          }
        }
      }
    }
  }

  return {
    txSkeleton,
    capacity: _amount,
    changeCapacity,
  };
}

function _deductCapacityCompatible(
  txSkeleton: TransactionSkeletonType,
  fromScript: Script,
  capacity: BIish
): [TransactionSkeletonType, BI] {
  /*
   * First, check if there is any output cells that contains enough capacity
   * for us to tinker with.
   *
   * TODO: the solution right now won't cover all cases, some outputs before the
   * last output might still be tinkerable, right now we are working on the
   * simple solution, later we can change this for more optimizations.
   */
  let _capacity = BI.from(capacity);
  const lastFreezedOutput = txSkeleton
    .get("fixedEntries")
    .filter(({ field }) => field === "outputs")
    .maxBy(({ index }) => index);
  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
  for (; i < txSkeleton.get("outputs").size && _capacity.gt(0); i++) {
    const output = txSkeleton.get("outputs").get(i)!;
    if (
      new ScriptValue(output.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    ) {
      const clonedOutput: Cell = JSON.parse(JSON.stringify(output));
      const cellCapacity = BI.from(clonedOutput.cell_output.capacity);
      const availableCapacity: BI = cellCapacity;
      let deductCapacity;
      if (_capacity.gte(availableCapacity)) {
        deductCapacity = availableCapacity;
      } else {
        deductCapacity = cellCapacity.sub(
          minimalCellCapacityCompatible(clonedOutput)
        );
        if (deductCapacity.gt(capacity)) {
          deductCapacity = capacity;
        }
      }
      _capacity = _capacity.sub(deductCapacity);
      clonedOutput.cell_output.capacity =
        "0x" + cellCapacity.sub(deductCapacity).toString(16);

      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.update(i, () => clonedOutput);
      });
    }
  }
  // Remove all output cells with capacity equal to 0
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.filter(
      (output) =>
        BI.from(output.cell_output.capacity).toString() !==
        BI.from(0).toString()
    );
  });

  return [txSkeleton, _capacity];
}

// Alter output generated by `setupInputCell`
async function collectInputCompatible(
  txSkeleton: TransactionSkeletonType,
  inputCell: Cell,
  fromInfo?: FromInfo,
  {
    config = undefined,
    since = undefined,
    defaultWitness = "0x",
    needCapacity = undefined,
  }: Options & {
    defaultWitness?: HexString;
    since?: PackedSince;
    needCapacity?: BIish;
  } = {}
): Promise<{
  txSkeleton: TransactionSkeletonType;
  availableCapacity: BI;
}> {
  config = config || getConfig();

  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {
    config,
    since,
    defaultWitness,
  });

  const lastOutputIndex: number = txSkeleton.get("outputs").size - 1;
  const lastOutput: Cell = txSkeleton.get("outputs").get(lastOutputIndex)!;
  const lastOutputCapacity: BI = BI.from(lastOutput.cell_output.capacity);
  const lastOutputFixedEntryIndex: number = txSkeleton
    .get("fixedEntries")
    .findIndex((fixedEntry) => {
      return (
        fixedEntry.field === "outputs" && fixedEntry.index === lastOutputIndex
      );
    });
  const fromScript: Script = inputCell.cell_output.lock;

  let availableCapacity: BI = BI.from(0);
  if (config.SCRIPTS.ANYONE_CAN_PAY && isAcpScript(fromScript, config)) {
    const destroyable: boolean = !!(
      fromInfo &&
      typeof fromInfo === "object" &&
      "destroyable" in fromInfo &&
      fromInfo.destroyable
    );
    let _needCapacity = needCapacity
      ? BI.from(needCapacity)
      : lastOutputCapacity;

    if (destroyable) {
      availableCapacity = lastOutputCapacity;
      // remove output & fixedEntry added by `setupInputCell`
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.remove(lastOutputIndex);
      });
      if (lastOutputFixedEntryIndex >= 0) {
        txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
          return fixedEntries.remove(lastOutputFixedEntryIndex);
        });
      }
    } else {
      // Ignore `fixedEntries` and update capacity of output which generated by `setupInputCell`
      const minimalOutputCapacity: BI = BI.from(
        minimalCellCapacityCompatible(lastOutput)
      );
      const canUseCapacity = lastOutputCapacity.sub(minimalOutputCapacity);
      const clonedLastOutput: Cell = JSON.parse(JSON.stringify(lastOutput));
      let outputCapacity: BI = minimalOutputCapacity;
      availableCapacity = canUseCapacity;
      if (_needCapacity.lt(canUseCapacity)) {
        outputCapacity = lastOutputCapacity.sub(_needCapacity);
        availableCapacity = _needCapacity;
      }
      clonedLastOutput.cell_output.capacity =
        "0x" + outputCapacity.toString(16);
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.update(lastOutputIndex, () => clonedLastOutput);
      });
    }
  } else {
    // Ignore if last output is fixed.
    if (lastOutputFixedEntryIndex < 0) {
      // Remove last output
      availableCapacity = BI.from(
        txSkeleton.get("outputs").get(lastOutputIndex)!.cell_output.capacity
      );
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.remove(lastOutputIndex);
      });
    }
  }

  return {
    txSkeleton,
    availableCapacity,
  };
}

/**
 * A function to transfer input to output, and add input & output to txSkeleton.
 * And it will deal with cell deps and witnesses too. (Add the input required cell deps and witnesses.)
 * It should be noted that the output must be added to the end of txSkeleton.get("outputs").
 *
 * @param txSkeleton
 * @param inputCell
 * @param fromInfo
 * @param options
 */
export async function setupInputCell(
  txSkeleton: TransactionSkeletonType,
  inputCell: Cell,
  fromInfo?: FromInfo,
  {
    config = undefined,
    since = undefined,
    defaultWitness = undefined,
  }: Options & {
    since?: PackedSince;
    defaultWitness?: HexString;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  generateLockScriptInfos({ config });
  const inputLock = inputCell.cell_output.lock;

  const targetLockScriptInfo:
    | LockScriptInfo
    | undefined = lockScriptInfos.infos.find((lockScriptInfo) => {
    return (
      lockScriptInfo.code_hash === inputLock.code_hash &&
      lockScriptInfo.hash_type === inputLock.hash_type
    );
  });

  if (!targetLockScriptInfo) {
    throw new Error(`No LockScriptInfo found for setupInputCell!`);
  }

  return targetLockScriptInfo.lockScriptInfo.setupInputCell(
    txSkeleton,
    inputCell,
    fromInfo,
    {
      config,
      since,
      defaultWitness,
    }
  );
}

export async function payFeeByFeeRate(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  feeRate: BIish,
  tipHeader?: Header,
  {
    config = undefined,
    useLocktimeCellsFirst = true,
    enableDeductCapacity = true,
  }: {
    config?: Config;
    useLocktimeCellsFirst?: boolean;
    enableDeductCapacity?: boolean;
  } = {}
): Promise<TransactionSkeletonType> {
  let size: number = 0;
  let newTxSkeleton: TransactionSkeletonType = txSkeleton;

  /**
   * Only one case `currentTransactionSize < size` :
   * change output capacity equals current fee (feeA), so one output reduced,
   * and if reduce the fee, change output will add again, fee will increase to feeA.
   */
  let currentTransactionSize: number = getTransactionSize(newTxSkeleton);
  while (currentTransactionSize > size) {
    size = currentTransactionSize;
    const fee: BI = calculateFeeCompatible(size, feeRate);

    newTxSkeleton = await payFee(txSkeleton, fromInfos, fee, tipHeader, {
      config,
      useLocktimeCellsFirst,
      enableDeductCapacity,
    });
    currentTransactionSize = getTransactionSize(newTxSkeleton);
  }

  return newTxSkeleton;
}

function calculateFee(size: number, feeRate: bigint): bigint {
  const result = calculateFeeCompatible(size, feeRate);
  return BigInt(result.toString());
}

function calculateFeeCompatible(size: number, feeRate: BIish): BI {
  const ratio = BI.from(1000);
  const base = BI.from(size).mul(feeRate);
  const fee = base.div(ratio);
  if (fee.mul(ratio).lt(base)) {
    return fee.add(1);
  }
  return BI.from(fee);
}

function getTransactionSize(txSkeleton: TransactionSkeletonType): number {
  const tx = createTransactionFromSkeleton(txSkeleton);
  return getTransactionSizeByTx(tx);
}

function getTransactionSizeByTx(tx: Transaction): number {
  const serializedTx = SerializeTransaction(
    normalizers.NormalizeTransaction(tx)
  );
  // 4 is serialized offset bytesize
  const size = serializedTx.byteLength + 4;
  return size;
}

export default {
  transfer,
  payFee,
  prepareSigningEntries,
  injectCapacity,
  setupInputCell,
  registerCustomLockScriptInfos,
  payFeeByFeeRate,
  __tests__: {
    _commonTransfer,
    resetLockScriptInfos,
    getLockScriptInfos,
    generateLockScriptInfos,
    getTransactionSizeByTx,
    getTransactionSize,
    calculateFee,
    calculateFeeCompatible,
  },
};

'''
'''--- packages/common-scripts/src/dao.ts ---
import {
  parseAddress,
  TransactionSkeletonType,
  Options,
  generateAddress,
  minimalCellCapacityCompatible,
} from "@ckb-lumos/helpers";
import {
  core,
  utils,
  since as sinceUtils,
  HexString,
  Address,
  CellProvider,
  Cell,
  WitnessArgs,
  PackedDao,
  PackedSince,
  CellCollector as CellCollectorInterface,
} from "@ckb-lumos/base";
import { getConfig, Config } from "@ckb-lumos/config-manager";
const { toBigUInt64LE, readBigUInt64LE } = utils;
const { parseSince } = sinceUtils;
import { normalizers, Reader } from "@ckb-lumos/toolkit";
import secp256k1Blake160 from "./secp256k1_blake160";
import secp256k1Blake160Multisig from "./secp256k1_blake160_multisig";
import { FromInfo, parseFromInfo } from "./from_info";
import {
  addCellDep,
  isSecp256k1Blake160Script,
  isSecp256k1Blake160MultisigScript,
  generateDaoScript,
} from "./helper";
import { RPC } from "@ckb-lumos/rpc";
import { readBigUInt64LECompatible } from "@ckb-lumos/base/lib/utils";
import { BI, BIish } from "@ckb-lumos/bi";

const DEPOSIT_DAO_DATA: HexString = "0x0000000000000000";
const DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE = BI.from(180);

export class CellCollector implements CellCollectorInterface {
  private cellCollector: CellCollectorInterface;
  private cellType: "all" | "deposit" | "withdraw";

  constructor(
    fromInfo: FromInfo,
    cellProvider: CellProvider,
    cellType: "all" | "deposit" | "withdraw",
    { config = undefined }: Options = {}
  ) {
    if (!cellProvider) {
      throw new Error("Cell Provider is missing!");
    }

    config = config || getConfig();

    const fromScript = parseFromInfo(fromInfo, { config }).fromScript;
    const daoTypeScript = generateDaoScript(config);
    const data: HexString | string =
      cellType === "deposit" ? DEPOSIT_DAO_DATA : "any";
    this.cellType = cellType;

    this.cellCollector = cellProvider.collector({
      lock: fromScript,
      type: daoTypeScript,
      data,
    });
  }

  async *collect(): AsyncGenerator<Cell> {
    for await (const inputCell of this.cellCollector.collect()) {
      if (this.cellType === "withdraw" && inputCell.data === DEPOSIT_DAO_DATA) {
        continue;
      }

      yield inputCell;
    }
  }
}

/**
 * list DAO cells,
 *
 * @param cellProvider
 * @param fromAddress
 * @param cellType
 * @param options
 */
export async function* listDaoCells(
  cellProvider: CellProvider,
  fromAddress: Address,
  cellType: "all" | "deposit" | "withdraw",
  { config = undefined }: Options = {}
): AsyncIterator<Cell> {
  const collector = new CellCollector(fromAddress, cellProvider, cellType, {
    config,
  });

  for await (const cell of collector.collect()) {
    yield cell;
  }
}

// TODO: reject multisig with non absolute-epoch-number locktime lock
/**
 * deposit a cell to DAO
 *
 * @param txSkeleton
 * @param fromInfo
 * @param toAddress deposit cell lock address
 * @param amount capacity in shannon
 * @param options
 */
export async function deposit(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  toAddress: Address,
  amount: BIish,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  const DAO_SCRIPT = config.SCRIPTS.DAO;
  if (!DAO_SCRIPT) {
    throw new Error("Provided config does not have DAO script setup!");
  }

  _checkFromInfoSince(fromInfo, config);

  // check and add cellDep if not exists
  txSkeleton = _addDaoCellDep(txSkeleton, config);

  if (!toAddress) {
    throw new Error("You must provide a to address!");
  }

  const toScript = parseAddress(toAddress, { config });
  const daoTypeScript = {
    code_hash: DAO_SCRIPT.CODE_HASH,
    hash_type: DAO_SCRIPT.HASH_TYPE,
    args: "0x",
  };

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push({
      cell_output: {
        capacity: "0x" + BI.from(amount).toString(16),
        lock: toScript,
        type: daoTypeScript,
      },
      data: DEPOSIT_DAO_DATA,
      out_point: undefined,
      block_hash: undefined,
    });
  });

  const outputIndex = txSkeleton.get("outputs").size - 1;

  // fix entry
  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push({
      field: "outputs",
      index: outputIndex,
    });
  });

  if (typeof fromInfo === "string") {
    const fromScript = parseAddress(fromInfo, { config });
    // address
    if (isSecp256k1Blake160Script(fromScript, config)) {
      txSkeleton = await secp256k1Blake160.injectCapacity(
        txSkeleton,
        outputIndex,
        fromInfo,
        { config }
      );
    } else if (isSecp256k1Blake160MultisigScript(fromScript, config)) {
      txSkeleton = await secp256k1Blake160Multisig.injectCapacity(
        txSkeleton,
        outputIndex,
        fromInfo,
        { config }
      );
    }
  } else if (fromInfo) {
    txSkeleton = await secp256k1Blake160Multisig.injectCapacity(
      txSkeleton,
      outputIndex,
      fromInfo,
      { config }
    );
  }

  return txSkeleton;
}

function _checkFromInfoSince(fromInfo: FromInfo, config: Config): void {
  let since;
  if (typeof fromInfo === "string") {
    // fromInfo is an address
    const fromScript = parseAddress(fromInfo, { config });
    const args = fromScript.args;
    if (args.length === 58) {
      since = "0x" + readBigUInt64LE("0x" + args.slice(42)).toString(16);
    }
  } else if ("R" in fromInfo) {
    since = fromInfo.since;
  }

  if (since != null) {
    const { relative, type } = parseSince(since);
    if (!(!relative && type === "epochNumber")) {
      throw new Error(
        "Can't deposit a dao cell with multisig locktime which not using absolute-epoch-number format!"
      );
    }
  }
}

/**
 * withdraw an deposited DAO cell
 *
 * @param txSkeleton
 * @param fromInput deposited DAO cell
 * @param fromInfo
 * @param options
 */
async function withdraw(
  txSkeleton: TransactionSkeletonType,
  fromInput: Cell,
  fromInfo?: FromInfo,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  _checkDaoScript(config);
  txSkeleton = _addDaoCellDep(txSkeleton, config);

  // check inputs.size == outputs.size
  if (txSkeleton.get("inputs").size !== txSkeleton.get("outputs").size) {
    throw new Error("Input size must equals to output size in txSkeleton!");
  }

  if (!config.SCRIPTS.DAO) {
    throw new Error("Provided config does not have DAO script setup!");
  }

  // TODO: check fromInput

  const cellProvider = txSkeleton.get("cellProvider");
  if (!cellProvider) {
    throw new Error("Cell provider is missing!");
  }
  const typeScript = fromInput.cell_output.type;
  const DAO_SCRIPT = config.SCRIPTS.DAO;
  if (
    !typeScript ||
    typeScript.code_hash !== DAO_SCRIPT.CODE_HASH ||
    typeScript.hash_type !== DAO_SCRIPT.HASH_TYPE ||
    fromInput.data !== DEPOSIT_DAO_DATA
  ) {
    throw new Error("fromInput is not a DAO deposit cell.");
  }

  // setup input cell
  const fromLockScript = fromInput.cell_output.lock;
  if (isSecp256k1Blake160Script(fromLockScript, config)) {
    txSkeleton = await secp256k1Blake160.setupInputCell(
      txSkeleton,
      fromInput,
      undefined,
      {
        config,
      }
    );
  } else if (isSecp256k1Blake160MultisigScript(fromLockScript, config)) {
    txSkeleton = await secp256k1Blake160Multisig.setupInputCell(
      txSkeleton,
      fromInput,
      fromInfo || generateAddress(fromLockScript, { config }),
      { config }
    );
  }

  const targetOutputIndex: number = txSkeleton.get("outputs").size - 1;
  const targetOutput: Cell = txSkeleton.get("outputs").get(targetOutputIndex)!;
  const clonedTargetOutput: Cell = JSON.parse(JSON.stringify(targetOutput));
  clonedTargetOutput.data = toBigUInt64LE(BI.from(fromInput.block_number));
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.update(targetOutputIndex, () => clonedTargetOutput);
  });

  // add header deps
  txSkeleton = txSkeleton.update("headerDeps", (headerDeps) => {
    return headerDeps.push(fromInput.block_hash!);
  });

  // fix inputs / outputs / witnesses
  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push(
      {
        field: "inputs",
        index: txSkeleton.get("inputs").size - 1,
      },
      {
        field: "outputs",
        index: txSkeleton.get("outputs").size - 1,
      }
    );
  });

  return txSkeleton;
}

function parseEpochCompatible(
  epoch: BIish
): {
  length: BI;
  index: BI;
  number: BI;
} {
  const _epoch = BI.from(epoch);
  return {
    length: _epoch.shr(40).and(0xfff),
    index: _epoch.shr(24).and(0xfff),
    number: _epoch.and(0xffffff),
  };
}

function epochSinceCompatible({
  length,
  index,
  number,
}: {
  length: BIish;
  index: BIish;
  number: BIish;
}): BI {
  const _length = BI.from(length);
  const _index = BI.from(index);
  const _number = BI.from(number);
  return BI.from(0x20)
    .shl(56)
    .add(_length.shl(40))
    .add(_index.shl(24))
    .add(_number);
}

/**
 * Unlock a withdrew DAO cell
 *
 * @param txSkeleton
 * @param depositInput deposited DAO cell
 * @param withdrawInput withdrew DAO cell
 * @param toAddress
 * @param fromInfo
 * @param options
 */
export async function unlock(
  txSkeleton: TransactionSkeletonType,
  depositInput: Cell,
  withdrawInput: Cell,
  toAddress: Address,
  fromInfo: FromInfo,
  {
    config = undefined,
    RpcClient = RPC,
  }: Options & { RpcClient?: typeof RPC } = {}
) {
  config = config || getConfig();
  _checkDaoScript(config);
  txSkeleton = _addDaoCellDep(txSkeleton, config);

  if (!config.SCRIPTS.DAO) {
    throw new Error("Provided config does not have DAO script setup!");
  }

  const cellProvider = txSkeleton.get("cellProvider");
  if (!cellProvider) {
    throw new Error("Cell provider is missing!");
  }
  const rpc = new RpcClient(cellProvider.uri!);

  const typeScript = depositInput.cell_output.type;
  const DAO_SCRIPT = config.SCRIPTS.DAO;
  if (
    !typeScript ||
    typeScript.code_hash !== DAO_SCRIPT.CODE_HASH ||
    typeScript.hash_type !== DAO_SCRIPT.HASH_TYPE ||
    depositInput.data !== DEPOSIT_DAO_DATA
  ) {
    throw new Error("depositInput is not a DAO deposit cell.");
  }

  const withdrawTypeScript = withdrawInput.cell_output.type;
  if (
    !withdrawTypeScript ||
    withdrawTypeScript.code_hash !== DAO_SCRIPT.CODE_HASH ||
    withdrawTypeScript.hash_type !== DAO_SCRIPT.HASH_TYPE ||
    withdrawInput.data === DEPOSIT_DAO_DATA
  ) {
    throw new Error("withdrawInput is not a DAO withdraw cell.");
  }

  // calculate since & capacity (interest)
  const depositBlockHeader = await rpc.get_header(depositInput.block_hash!);
  const depositEpoch = parseEpochCompatible(depositBlockHeader!.epoch);
  // const depositCapacity = BigInt(depositInput.cell_output.capacity)

  const withdrawBlockHeader = await rpc.get_header(withdrawInput.block_hash!);
  const withdrawEpoch = parseEpochCompatible(withdrawBlockHeader!.epoch);

  const withdrawFraction = withdrawEpoch.index.mul(depositEpoch.length);
  const depositFraction = depositEpoch.index.mul(withdrawEpoch.length);
  let depositedEpochs = withdrawEpoch.number.sub(depositEpoch.number);

  if (withdrawFraction.gt(depositFraction)) {
    depositedEpochs = depositedEpochs.add(1);
  }

  const lockEpochs = depositedEpochs
    .add(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE)
    .sub(1)
    .div(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE)
    .mul(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE);
  const minimalSinceEpoch = {
    number: BI.from(depositEpoch.number.add(lockEpochs)),
    index: BI.from(depositEpoch.index),
    length: BI.from(depositEpoch.length),
  };
  const minimalSince = epochSinceCompatible(minimalSinceEpoch);

  const outputCapacity: HexString =
    "0x" +
    calculateMaximumWithdrawCompatible(
      withdrawInput,
      depositBlockHeader!.dao,
      withdrawBlockHeader!.dao
    ).toString(16);

  const toScript = parseAddress(toAddress, { config });
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push({
      cell_output: {
        capacity: outputCapacity,
        lock: toScript,
        type: undefined,
      },
      data: "0x",
      out_point: undefined,
      block_hash: undefined,
    });
  });

  const since: PackedSince = "0x" + minimalSince.toString(16);

  while (txSkeleton.get("witnesses").size < txSkeleton.get("inputs").size - 1) {
    txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
      witnesses.push("0x")
    );
  }

  // add header deps
  txSkeleton = txSkeleton.update("headerDeps", (headerDeps) => {
    return headerDeps.push(depositInput.block_hash!, withdrawInput.block_hash!);
  });

  const depositHeaderDepIndex = txSkeleton.get("headerDeps").size - 2;

  // setup input cell
  const defaultWitnessArgs: WitnessArgs = {
    input_type: toBigUInt64LE(depositHeaderDepIndex),
  };
  const defaultWitness: HexString = new Reader(
    core.SerializeWitnessArgs(
      normalizers.NormalizeWitnessArgs(defaultWitnessArgs)
    )
  ).serializeJson();
  const fromLockScript = withdrawInput.cell_output.lock;
  if (isSecp256k1Blake160Script(fromLockScript, config)) {
    txSkeleton = await secp256k1Blake160.setupInputCell(
      txSkeleton,
      withdrawInput,
      undefined,
      { config, since, defaultWitness }
    );
  } else if (isSecp256k1Blake160MultisigScript(fromLockScript, config)) {
    txSkeleton = await secp256k1Blake160Multisig.setupInputCell(
      txSkeleton,
      withdrawInput,
      fromInfo || generateAddress(fromLockScript, { config }),
      { config, since, defaultWitness }
    );
  }
  // remove change output by setupInputCell
  const lastOutputIndex: number = txSkeleton.get("outputs").size - 1;
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.remove(lastOutputIndex);
  });

  // fix inputs / outputs / witnesses
  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push(
      {
        field: "inputs",
        index: txSkeleton.get("inputs").size - 1,
      },
      {
        field: "outputs",
        index: txSkeleton.get("outputs").size - 1,
      },
      {
        field: "witnesses",
        index: txSkeleton.get("witnesses").size - 1,
      },
      {
        field: "headerDeps",
        index: txSkeleton.get("headerDeps").size - 2,
      }
    );
  });

  return txSkeleton;
}

/**
 * calculate a withdraw dao cell minimal unlock since
 *
 * @param depositBlockHeaderEpoch depositBlockHeader.epoch
 * @param withdrawBlockHeaderEpoch withdrawBlockHeader.epoch
 */
export function calculateDaoEarliestSince(
  depositBlockHeaderEpoch: HexString,
  withdrawBlockHeaderEpoch: HexString
): bigint {
  const result = calculateDaoEarliestSinceCompatible(
    depositBlockHeaderEpoch,
    withdrawBlockHeaderEpoch
  );
  return BigInt(result.toString());
}

/**
 * calculate a withdraw dao cell minimal unlock since
 *
 * @param depositBlockHeaderEpoch depositBlockHeader.epoch
 * @param withdrawBlockHeaderEpoch withdrawBlockHeader.epoch
 */
export function calculateDaoEarliestSinceCompatible(
  depositBlockHeaderEpoch: HexString,
  withdrawBlockHeaderEpoch: HexString
): BI {
  const depositEpoch = parseEpochCompatible(depositBlockHeaderEpoch);
  const withdrawEpoch = parseEpochCompatible(withdrawBlockHeaderEpoch);
  const withdrawFraction = withdrawEpoch.index.mul(depositEpoch.length);
  const depositFraction = depositEpoch.index.mul(withdrawEpoch.length);
  let depositedEpochs = withdrawEpoch.number.sub(depositEpoch.number);

  if (withdrawFraction.gt(depositFraction)) {
    depositedEpochs = depositedEpochs.add(1);
  }

  const lockEpochs = depositedEpochs
    .add(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE)
    .sub(1)
    .div(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE)
    .mul(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE);
  const minimalSinceEpoch = {
    number: BI.from(depositEpoch.number.add(lockEpochs)),
    index: BI.from(depositEpoch.index),
    length: BI.from(depositEpoch.length),
  };
  return epochSinceCompatible(minimalSinceEpoch);
}

function _checkDaoScript(config: Config): void {
  const DAO_SCRIPT = config.SCRIPTS.DAO;
  if (!DAO_SCRIPT) {
    throw new Error("Provided config does not have DAO script setup!");
  }
}

/**
 *
 * @param {TransactionSkeleton} txSkeleton
 * @param {any} config
 * @returns {TransactionSkeleton} txSkeleton
 */
function _addDaoCellDep(
  txSkeleton: TransactionSkeletonType,
  config: Config
): TransactionSkeletonType {
  const template = config.SCRIPTS.DAO!;
  return addCellDep(txSkeleton, {
    out_point: {
      tx_hash: template.TX_HASH,
      index: template.INDEX,
    },
    dep_type: template.DEP_TYPE,
  });
}

function extractDaoDataCompatible(
  dao: PackedDao
): {
  [key: string]: BI;
} {
  if (!/^(0x)?([0-9a-fA-F]){64}$/.test(dao)) {
    throw new Error("Invalid dao format!");
  }

  const len = 8 * 2;
  const hex = dao.startsWith("0x") ? dao.slice(2) : dao;

  return ["c", "ar", "s", "u"]
    .map((key, i) => {
      return {
        [key]: BI.from(
          readBigUInt64LECompatible("0x" + hex.slice(len * i, len * (i + 1)))
        ),
      };
    })
    .reduce((result, c) => ({ ...result, ...c }), {});
}

/**
 * calculate maximum withdraw capacity when unlock
 *
 * @param withdrawCell withdrawCell or depositCell
 * @param depositDao depositBlockHeader.dao
 * @param withdrawDao withdrawBlockHeader.dao
 */
export function calculateMaximumWithdraw(
  withdrawCell: Cell,
  depositDao: PackedDao,
  withdrawDao: PackedDao
): bigint {
  return calculateMaximumWithdrawCompatible(
    withdrawCell,
    depositDao,
    withdrawDao
  ).toBigInt();
}

/**
 * calculate maximum withdraw capacity when unlock
 *
 * @param withdrawCell withdrawCell or depositCell
 * @param depositDao depositBlockHeader.dao
 * @param withdrawDao withdrawBlockHeader.dao
 */
export function calculateMaximumWithdrawCompatible(
  withdrawCell: Cell,
  depositDao: PackedDao,
  withdrawDao: PackedDao
): BI {
  const depositAR = BI.from(extractDaoDataCompatible(depositDao).ar);
  const withdrawAR = BI.from(extractDaoDataCompatible(withdrawDao).ar);

  const occupiedCapacity = BI.from(minimalCellCapacityCompatible(withdrawCell));
  const outputCapacity = BI.from(withdrawCell.cell_output.capacity);
  const countedCapacity = outputCapacity.sub(occupiedCapacity);
  const withdrawCountedCapacity = countedCapacity
    .mul(withdrawAR)
    .div(depositAR);

  return withdrawCountedCapacity.add(occupiedCapacity);
}

export default {
  deposit,
  withdraw,
  unlock,
  calculateMaximumWithdraw,
  calculateMaximumWithdrawCompatible,
  calculateDaoEarliestSince,
  calculateDaoEarliestSinceCompatible,
  CellCollector,
  listDaoCells,
};

'''
'''--- packages/common-scripts/src/deploy.ts ---
import {
  Script,
  OutPoint,
  CellProvider,
  Cell,
  utils,
  values,
  core,
  WitnessArgs,
  Transaction,
} from "@ckb-lumos/base";
import { SerializeTransaction } from "@ckb-lumos/base/lib/core";
import { getConfig, Config, helpers } from "@ckb-lumos/config-manager";
import {
  TransactionSkeletonType,
  TransactionSkeleton,
  Options,
  createTransactionFromSkeleton,
  parseAddress,
  minimalCellCapacityCompatible,
} from "@ckb-lumos/helpers";
import { Reader, normalizers } from "@ckb-lumos/toolkit";
import { RPC } from "@ckb-lumos/rpc";
import { Set } from "immutable";
import { FromInfo, parseFromInfo, MultisigScript } from "./from_info";
import { BI, BIish } from "@ckb-lumos/bi";
const { ScriptValue } = values;

function bytesToHex(bytes: Uint8Array): string {
  return `0x${[...bytes].map((b) => b.toString(16).padStart(2, "0")).join("")}`;
}

async function findCellsByLock(
  lockScript: Script,
  cellProvider: CellProvider
): Promise<Cell[]> {
  const collector = cellProvider.collector({
    lock: lockScript,
    type: "empty",
    data: "0x",
  });
  const cells: Cell[] = [];
  for await (const cell of collector.collect()) {
    cells.push(cell);
  }
  return cells;
}

function updateOutputs(
  txSkeleton: TransactionSkeletonType,
  output: Cell
): TransactionSkeletonType {
  const cellCapacity = minimalCellCapacityCompatible(output);
  output.cell_output.capacity = `0x${cellCapacity.toString(16)}`;
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(output);
  });

  return txSkeleton;
}

function updateCellDeps(
  txSkeleton: TransactionSkeletonType,
  config?: Config
): TransactionSkeletonType {
  txSkeleton = txSkeleton.update("cellDeps", (cellDeps) => {
    return cellDeps.clear();
  });
  config = config || getConfig();
  const secp256k1Config = config.SCRIPTS.SECP256K1_BLAKE160;
  const secp256k1MultiSigConfig = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
  if (!secp256k1Config || !secp256k1MultiSigConfig) {
    throw new Error(
      "Provided config does not have SECP256K1_BLAKE160 or SECP256K1_BLAKE160_MULTISIG script setup!"
    );
  }
  txSkeleton = txSkeleton.update("cellDeps", (cellDeps) => {
    return cellDeps.push(
      {
        out_point: {
          tx_hash: secp256k1Config.TX_HASH,
          index: secp256k1Config.INDEX,
        },
        dep_type: secp256k1Config.DEP_TYPE,
      },
      // TODO: optimize me, push dep directly without checking actual locks used would cause bigger tx
      {
        out_point: {
          tx_hash: secp256k1MultiSigConfig.TX_HASH,
          index: secp256k1MultiSigConfig.INDEX,
        },
        dep_type: secp256k1MultiSigConfig.DEP_TYPE,
      }
    );
  });

  return txSkeleton;
}

async function completeTx(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  config?: Config,
  feeRate?: BIish
): Promise<TransactionSkeletonType> {
  const inputCapacity = txSkeleton
    .get("inputs")
    .map((c) => BI.from(c.cell_output.capacity))
    .reduce((a, b) => a.add(b), BI.from(0));
  const outputCapacity = txSkeleton
    .get("outputs")
    .map((c) => BI.from(c.cell_output.capacity))
    .reduce((a, b) => a.add(b), BI.from(0));
  const needCapacity = outputCapacity.sub(inputCapacity);
  txSkeleton = await injectCapacity(
    txSkeleton,
    fromInfo,
    BI.from(needCapacity),
    {
      config: config,
      feeRate: feeRate,
    }
  );
  return txSkeleton;
}

async function injectCapacity(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  amount: BIish,
  {
    config = undefined,
    feeRate = undefined,
  }: { config?: Config; feeRate?: BIish }
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  let _feeRate = feeRate || 1000;
  let _amount = BI.from(amount);
  const { fromScript, multisigScript } = parseFromInfo(fromInfo, { config });
  _amount = _amount.add(BI.from(10).pow(8));
  let changeCapacity = BI.from(10).pow(8);
  const changeCell: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: fromScript,
      type: undefined,
    },
    data: "0x",
  };
  const minimalChangeCapacity: BI = BI.from(
    minimalCellCapacityCompatible(changeCell)
  ).add(BI.from(10).pow(8));

  if (_amount.lt(0)) {
    changeCapacity = changeCapacity.sub(_amount);
    _amount = BI.from(0);
  }
  if (_amount.gt(0) || changeCapacity.lt(minimalChangeCapacity)) {
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) throw new Error("Cell provider is missing!");
    const cellCollector = cellProvider.collector({
      lock: fromScript,
      type: "empty",
      data: "0x",
    });

    let previousInputs = Set<string>();
    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(
        `${input.out_point!.tx_hash}_${input.out_point!.index}`
      );
    }

    for await (const inputCell of cellCollector.collect()) {
      if (
        previousInputs.has(
          `${inputCell.out_point!.tx_hash}_${inputCell.out_point!.index}`
        )
      )
        continue;
      txSkeleton = txSkeleton.update("inputs", (inputs) =>
        inputs.push(inputCell)
      );
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
      const inputCapacity = BI.from(inputCell.cell_output.capacity);
      let deductCapacity = inputCapacity;
      if (deductCapacity.gt(_amount)) {
        deductCapacity = _amount;
      }
      _amount = _amount.sub(deductCapacity);
      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);
      if (
        _amount.eq(0) &&
        (changeCapacity.eq(0) || changeCapacity.gte(minimalChangeCapacity))
      )
        break;
    }
  }

  if (changeCapacity.gt(0)) {
    changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", (outputs) =>
      outputs.push(changeCell)
    );
  }
  if (_amount.gt(0) || changeCapacity.lt(minimalChangeCapacity))
    throw new Error("Not enough capacity in from address!");

  /*
   * Modify the skeleton, so the first witness of the fromAddress script group
   * has a WitnessArgs construct with 65-byte zero filled values. While this
   * is not required, it helps in transaction fee estimation.
   */
  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
    }
    let witness: string = txSkeleton.get("witnesses").get(firstIndex)!;
    let newWitnessArgs: WitnessArgs;
    const SECP_SIGNATURE_PLACEHOLDER =
      "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

    if (typeof fromInfo !== "string") {
      newWitnessArgs = {
        lock:
          "0x" +
          multisigScript!.slice(2) +
          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(
            (fromInfo as MultisigScript).M
          ),
      };
    } else {
      newWitnessArgs = { lock: SECP_SIGNATURE_PLACEHOLDER };
    }

    if (witness !== "0x") {
      const witnessArgs = new core.WitnessArgs(new Reader(witness));
      const lock = witnessArgs.getLock();
      if (
        lock.hasValue() &&
        new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock
      ) {
        throw new Error(
          "Lock field in first witness is set aside for signature!"
        );
      }
      const inputType = witnessArgs.getInputType();
      if (inputType.hasValue()) {
        newWitnessArgs.input_type = new Reader(
          inputType.value().raw()
        ).serializeJson();
      }
      const outputType = witnessArgs.getOutputType();
      if (outputType.hasValue()) {
        newWitnessArgs.output_type = new Reader(
          outputType.value().raw()
        ).serializeJson();
      }
    }
    witness = new Reader(
      core.SerializeWitnessArgs(
        normalizers.NormalizeWitnessArgs(newWitnessArgs)
      )
    ).serializeJson();
    txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
      witnesses.set(firstIndex, witness)
    );
  }

  const txFee = calculateTxFee(txSkeleton, _feeRate);
  changeCapacity = changeCapacity.sub(txFee);

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.pop();
  });
  if (changeCapacity.gt(0)) {
    changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", (outputs) =>
      outputs.push(changeCell)
    );
  }

  return txSkeleton;
}

function getTransactionSize(txSkeleton: TransactionSkeletonType): number {
  const tx = createTransactionFromSkeleton(txSkeleton);
  return getTransactionSizeByTx(tx);
}

function getTransactionSizeByTx(tx: Transaction): number {
  const serializedTx = SerializeTransaction(
    normalizers.NormalizeTransaction(tx)
  );
  // 4 is serialized offset bytesize
  const size = serializedTx.byteLength + 4;
  return size;
}

function calculateFee(size: number, feeRate: BIish): BI {
  const ratio = BI.from(1000);
  const base = BI.from(size).mul(feeRate);
  const fee = base.div(ratio);

  if (fee.mul(ratio).lt(base)) {
    return fee.add(1);
  }
  return BI.from(fee);
}

function calculateTxFee(
  txSkeleton: TransactionSkeletonType,
  feeRate: BIish
): BI {
  const txSize = getTransactionSize(txSkeleton);
  return BI.from(calculateFee(txSize, feeRate));
}

function calculateCodeHashByBin(scriptBin: Uint8Array): string {
  const bin = scriptBin.valueOf();
  return new utils.CKBHasher()
    .update(bin.buffer.slice(bin.byteOffset, bin.byteLength + bin.byteOffset))
    .digestHex();
}

async function getDataHash(outPoint: OutPoint, rpc: RPC): Promise<string> {
  const txHash = outPoint.tx_hash;
  const index = parseInt(outPoint.index, 10);
  const tx = await rpc.get_transaction(txHash);

  if (!tx) throw new Error(`TxHash(${txHash}) is not found`);

  const outputData = tx.transaction.outputs_data[index];
  if (!outputData) throw new Error(`cannot find output data`);

  return new utils.CKBHasher().update(new Reader(outputData)).digestHex();
}

interface ScriptConfig {
  // if hash_type is type, code_hash is ckbHash(type_script)
  // if hash_type is data, code_hash is ckbHash(data)
  CODE_HASH: string;

  HASH_TYPE: "type" | "data";

  TX_HASH: string;
  // the deploy cell can be found at index of tx's outputs
  INDEX: string;

  // now deployWithX only supportted `code `
  DEP_TYPE: "dep_group" | "code";

  // empty
  SHORT_ID?: number;
}

function calculateTxHash(txSkeleton: TransactionSkeletonType): string {
  const tx = createTransactionFromSkeleton(txSkeleton);
  const txHash = utils
    .ckbHash(
      core.SerializeRawTransaction(normalizers.NormalizeRawTransaction(tx))
    )
    .serializeJson();
  return txHash;
}

function getScriptConfigByDataHash(
  txSkeleton: TransactionSkeletonType,
  outputIndex: number
): ScriptConfig {
  const data = txSkeleton.outputs.get(outputIndex)!.data;
  const codeHash = utils
    .ckbHash(new Reader(data).toArrayBuffer())
    .serializeJson();
  const txHash = calculateTxHash(txSkeleton);
  const scriptConfig: ScriptConfig = {
    CODE_HASH: codeHash,
    HASH_TYPE: "data",
    TX_HASH: txHash,
    INDEX: "0x0",
    DEP_TYPE: "code",
  };
  return scriptConfig;
}

function getScriptConfigByTypeHash(
  txSkeleton: TransactionSkeletonType,
  outputIndex: number
): ScriptConfig {
  const typeScript = txSkeleton.outputs.get(outputIndex)!.cell_output.type!;
  const codeHash = utils.computeScriptHash(typeScript);
  const txHash = calculateTxHash(txSkeleton);
  const scriptConfig: ScriptConfig = {
    CODE_HASH: codeHash,
    HASH_TYPE: "type",
    TX_HASH: txHash,
    INDEX: "0x0",
    DEP_TYPE: "code",
  };
  return scriptConfig;
}

function getScriptConfig(
  txSkeleton: TransactionSkeletonType,
  outputIndex: number
): ScriptConfig {
  const outputCell = txSkeleton.outputs.get(outputIndex);
  if (outputCell == undefined)
    throw new Error("Invalid txSkeleton or outputIndex");
  const type = outputCell.cell_output.type;
  if (type !== undefined)
    return getScriptConfigByTypeHash(txSkeleton, outputIndex);
  return getScriptConfigByDataHash(txSkeleton, outputIndex);
}

function isMultisigFromInfo(fromInfo: FromInfo): fromInfo is MultisigScript {
  if (typeof fromInfo !== "object") return false;
  return (
    "M" in fromInfo &&
    "R" in fromInfo &&
    Array.isArray(fromInfo.publicKeyHashes)
  );
}

function verifyFromInfo(
  fromInfo: FromInfo,
  { config = undefined }: Options = {}
): void {
  config = config || getConfig();
  if (typeof fromInfo === "string") {
    if (
      helpers.nameOfScript(
        parseAddress(fromInfo, { config }),
        config.SCRIPTS
      ) !== "SECP256K1_BLAKE160"
    )
      throw new Error(
        "only SECP256K1_BLAKE160 or SECP256K1_MULTISIG is supported"
      );
  } else if (!isMultisigFromInfo(fromInfo)) {
    throw new Error(
      "only SECP256K1_BLAKE160 or SECP256K1_MULTISIG is supported"
    );
  }
}

interface DeployOptions {
  cellProvider: CellProvider;
  scriptBinary: Uint8Array;
  fromInfo: FromInfo;
  config?: Config;
  feeRate?: bigint;
}

interface UpgradeOptions extends DeployOptions {
  typeId: Script;
}

interface DeployResult {
  txSkeleton: TransactionSkeletonType;
  scriptConfig: ScriptConfig;
}

interface TypeIDDeployResult extends DeployResult {
  typeId: Script;
}

/**
 * Generate txSkeleton for writing binary data to CKB, usually for deploying contracts.
 * This generator only supports `SECP256K1_BLAKE160` and `SECP256K1_BLAKE160_MULTISIG` currently.
 *
 * @param options
 */
export async function generateDeployWithDataTx(
  options: DeployOptions
): Promise<DeployResult> {
  verifyFromInfo(options.fromInfo, { config: options.config });

  let txSkeleton = TransactionSkeleton({ cellProvider: options.cellProvider });
  const { fromScript } = parseFromInfo(options.fromInfo, {
    config: options.config,
  });

  const output: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: fromScript,
    },
    data: bytesToHex(options.scriptBinary),
  };

  txSkeleton = updateOutputs(txSkeleton, output);
  txSkeleton = updateCellDeps(txSkeleton, options.config);
  txSkeleton = await completeTx(
    txSkeleton,
    options.fromInfo,
    options.config,
    options.feeRate
  );

  const scriptConfig = getScriptConfig(txSkeleton, 0);

  return {
    txSkeleton,
    scriptConfig,
  };
}

/**
 * Generate txSkeleton for writing binary data to CKB via Type ID, usually for deploying contracts.
 * Deploying via Type ID makes it possible to upgrade contract, for more information about Type ID, please check: https://xuejie.space/2020_02_03_introduction_to_ckb_script_programming_type_id/
 * This generator only supports `SECP256K1_BLAKE160` and `SECP256K1_BLAKE160_MULTISIG` currently.
 *
 * @param options
 */
export async function generateDeployWithTypeIdTx(
  options: DeployOptions
): Promise<TypeIDDeployResult> {
  verifyFromInfo(options.fromInfo, { config: options.config });

  let txSkeleton = TransactionSkeleton({ cellProvider: options.cellProvider });
  const { fromScript } = parseFromInfo(options.fromInfo, {
    config: options.config,
  });

  const [resolved] = await findCellsByLock(fromScript, options.cellProvider);
  if (!resolved) throw new Error(`fromAddress has no live ckb`);

  const typeId = utils.generateTypeIdScript(
    { previous_output: resolved.out_point!, since: "0x0" },
    "0x0"
  );
  const output: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: fromScript,
      type: typeId,
    },
    data: bytesToHex(options.scriptBinary),
  };

  txSkeleton = updateOutputs(txSkeleton, output);
  txSkeleton = updateCellDeps(txSkeleton, options.config);
  txSkeleton = await completeTx(
    txSkeleton,
    options.fromInfo,
    options.config,
    options.feeRate
  );

  const scriptConfig = getScriptConfig(txSkeleton, 0);

  return {
    txSkeleton,
    scriptConfig,
    typeId,
  };
}

export async function generateUpgradeTypeIdDataTx(
  options: UpgradeOptions
): Promise<DeployResult> {
  verifyFromInfo(options.fromInfo, { config: options.config });

  let txSkeleton = TransactionSkeleton({ cellProvider: options.cellProvider });
  const { fromScript } = parseFromInfo(options.fromInfo, {
    config: options.config,
  });

  const collector = options.cellProvider.collector({ type: options.typeId });
  const cells: Cell[] = [];
  for await (const cell of collector.collect()) {
    cells.push(cell);
  }
  if (cells.length !== 1) throw new Error("the typeid maybe wrong");

  const deployedCell = cells[0];
  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(deployedCell);
  });

  const output: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: fromScript,
      type: options.typeId,
    },
    data: bytesToHex(options.scriptBinary),
  };

  txSkeleton = updateOutputs(txSkeleton, output);
  txSkeleton = updateCellDeps(txSkeleton, options.config);
  txSkeleton = await completeTx(
    txSkeleton,
    options.fromInfo,
    options.config,
    options.feeRate
  );

  const scriptConfig = getScriptConfig(txSkeleton, 0);

  return {
    txSkeleton,
    scriptConfig,
  };
}

export async function compareScriptBinaryWithOnChainData(
  scriptBinary: Uint8Array,
  outPoint: OutPoint,
  rpc: RPC
): Promise<boolean> {
  const localHash = calculateCodeHashByBin(scriptBinary);
  const onChainHash = await getDataHash(outPoint, rpc);
  return localHash === onChainHash;
}

export default {
  generateDeployWithDataTx,
  generateDeployWithTypeIdTx,
  generateUpgradeTypeIdDataTx,
  compareScriptBinaryWithOnChainData,
  __tests__: {
    calculateTxFee,
  },
};

'''
'''--- packages/common-scripts/src/from_info.ts ---
import {
  PackedSince,
  Hash,
  Address,
  Script,
  HexString,
  utils,
} from "@ckb-lumos/base";
import { Options, parseAddress } from "@ckb-lumos/helpers";
import { getConfig } from "@ckb-lumos/config-manager";
import { BI } from "@ckb-lumos/bi";

const { CKBHasher, toBigUInt64LE } = utils;

/**
 * secp256k1_blake160_multisig script requires S, R, M, N and public key hashes
 * S must be zero now
 * and N equals to publicKeyHashes size
 * so only need to provide R, M and public key hashes
 */
export interface MultisigScript {
  /** first nth public keys must match, 1 byte */
  R: number;
  /** threshold, 1 byte */
  M: number;
  /** blake160 hashes of compressed public keys */
  publicKeyHashes: Hash[];
  /** locktime in since format */
  since?: PackedSince;
}

export interface ACP {
  address: Address;
  destroyable?: boolean; // default to false
}

export interface CustomScript {
  script: Script;
  customData: HexString;
}

export type FromInfo = MultisigScript | Address | ACP | CustomScript;

/**
 *
 * @param params multisig script params
 * @returns serialized multisig script
 */
export function serializeMultisigScript({
  R,
  M,
  publicKeyHashes,
}: MultisigScript): HexString {
  if (R < 0 || R > 255) {
    throw new Error("`R` should be less than 256!");
  }
  if (M < 0 || M > 255) {
    throw new Error("`M` should be less than 256!");
  }
  // TODO: validate publicKeyHashes
  return (
    "0x00" +
    ("00" + R.toString(16)).slice(-2) +
    ("00" + M.toString(16)).slice(-2) +
    ("00" + publicKeyHashes.length.toString(16)).slice(-2) +
    publicKeyHashes.map((h) => h.slice(2)).join("")
  );
}

/**
 *
 * @param serializedMultisigScript
 * @param since
 * @returns lock script args
 */
export function multisigArgs(
  serializedMultisigScript: HexString,
  since?: PackedSince
): HexString {
  let sinceLE = "0x";
  if (since != null) {
    sinceLE = toBigUInt64LE(BI.from(since));
  }
  return (
    new CKBHasher().update(serializedMultisigScript).digestHex().slice(0, 42) +
    sinceLE.slice(2)
  );
}

export function parseFromInfo(
  fromInfo: FromInfo,
  { config = undefined }: Options = {}
): {
  fromScript: Script;
  multisigScript?: HexString;
  destroyable?: boolean;
  customData?: HexString;
} {
  config = config || getConfig();

  let fromScript: Script | undefined;
  let multisigScript: HexString | undefined;
  let destroyable: boolean | undefined;
  let customData: HexString | undefined;

  if (typeof fromInfo === "string") {
    // fromInfo is an address
    fromScript = parseAddress(fromInfo, { config });
  } else {
    if ("R" in fromInfo) {
      const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
      if (!template) {
        throw new Error(
          "Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!"
        );
      }

      multisigScript = serializeMultisigScript(fromInfo);
      const fromScriptArgs = multisigArgs(multisigScript, fromInfo.since);
      fromScript = {
        code_hash: template.CODE_HASH,
        hash_type: template.HASH_TYPE,
        args: fromScriptArgs,
      };
    } else if ("address" in fromInfo) {
      const template = config.SCRIPTS.ANYONE_CAN_PAY;
      if (!template) {
        throw new Error(
          "Provided config does not have ANYONE_CAN_PAY script setup!"
        );
      }

      const address = fromInfo.address;
      fromScript = parseAddress(address, { config });
      destroyable = fromInfo.destroyable;

      if (
        fromScript.code_hash !== template.CODE_HASH ||
        fromScript.hash_type !== template.HASH_TYPE
      ) {
        throw new Error(`fromInfo.address is not ANYONE_CAN_PAY address!`);
      }
    } else if ("script" in fromInfo) {
      fromScript = fromInfo.script;
      customData = fromInfo.customData;
    } else {
      throw new Error("Invalid fromInfo format!");
    }
  }

  return {
    fromScript,
    multisigScript,
    destroyable,
    customData,
  };
}

'''
'''--- packages/common-scripts/src/helper.ts ---
import { Set } from "immutable";
import {
  createTransactionFromSkeleton,
  parseAddress,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import {
  core,
  values,
  utils,
  CellDep,
  Script,
  Address,
  HexString,
} from "@ckb-lumos/base";
const { CKBHasher, ckbHash } = utils;
import { normalizers, Reader } from "@ckb-lumos/toolkit";
import { Config } from "@ckb-lumos/config-manager";
import { BI } from "@ckb-lumos/bi";

export function addCellDep(
  txSkeleton: TransactionSkeletonType,
  newCellDep: CellDep
): TransactionSkeletonType {
  const cellDep = txSkeleton.get("cellDeps").find((cellDep) => {
    return (
      cellDep.dep_type === newCellDep.dep_type &&
      new values.OutPointValue(cellDep.out_point, { validate: false }).equals(
        new values.OutPointValue(newCellDep.out_point, { validate: false })
      )
    );
  });

  if (!cellDep) {
    txSkeleton = txSkeleton.update("cellDeps", (cellDeps) => {
      return cellDeps.push({
        out_point: newCellDep.out_point,
        dep_type: newCellDep.dep_type,
      });
    });
  }

  return txSkeleton;
}

export function generateDaoScript(config: Config): Script {
  const template = config.SCRIPTS.DAO!;

  return {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args: "0x",
  };
}

export function isSecp256k1Blake160Script(
  script: Script,
  config: Config
): boolean {
  const template = config.SCRIPTS.SECP256K1_BLAKE160!;
  return (
    script.code_hash === template.CODE_HASH &&
    script.hash_type === template.HASH_TYPE
  );
}

export function isSecp256k1Blake160Address(
  address: Address,
  config: Config
): boolean {
  const script = parseAddress(address, { config });
  return isSecp256k1Blake160Script(script, config);
}

export function isSecp256k1Blake160MultisigScript(
  script: Script,
  config: Config
): boolean {
  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG!;
  return (
    script.code_hash === template.CODE_HASH &&
    script.hash_type === template.HASH_TYPE
  );
}

export function isSecp256k1Blake160MultisigAddress(
  address: Address,
  config: Config
): boolean {
  const script = parseAddress(address, { config });
  return isSecp256k1Blake160MultisigScript(script, config);
}

export function isDaoScript(
  script: Script | undefined,
  config: Config
): boolean {
  const template = config.SCRIPTS.DAO!;

  return (
    !!script &&
    script.code_hash === template.CODE_HASH &&
    script.hash_type === template.HASH_TYPE
  );
}

export function isSudtScript(
  script: Script | undefined,
  config: Config
): boolean {
  const template = config.SCRIPTS.SUDT;

  if (!template) {
    throw new Error(`SUDT script not defined in config!`);
  }

  return (
    !!script &&
    script.code_hash === template.CODE_HASH &&
    script.hash_type === template.HASH_TYPE
  );
}

export function isAcpScript(script: Script, config: Config): boolean {
  const template = config.SCRIPTS.ANYONE_CAN_PAY;

  if (!template) {
    throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
  }

  return (
    !!script &&
    script.code_hash === template.CODE_HASH &&
    script.hash_type === template.HASH_TYPE
  );
}

export function isAcpAddress(address: Address, config: Config): boolean {
  const script = parseAddress(address, { config });

  return isAcpScript(script, config);
}

export function hashWitness(hasher: any, witness: HexString): void {
  const lengthBuffer = new ArrayBuffer(8);
  const view = new DataView(lengthBuffer);
  const witnessHexString = BI.from(new Reader(witness).length()).toString(16);
  if (witnessHexString.length <= 8) {
    view.setUint32(0, Number("0x" + witnessHexString), true);
    view.setUint32(4, Number("0x" + "00000000"), true);
  }

  if (witnessHexString.length > 8 && witnessHexString.length <= 16) {
    view.setUint32(0, Number("0x" + witnessHexString.slice(-8)), true);
    view.setUint32(4, Number("0x" + witnessHexString.slice(0, -8)), true);
  }
  hasher.update(lengthBuffer);
  hasher.update(witness);
}

export function prepareSigningEntries(
  txSkeleton: TransactionSkeletonType,
  config: Config,
  scriptType: "SECP256K1_BLAKE160" | "SECP256K1_BLAKE160_MULTISIG"
): TransactionSkeletonType {
  const template = config.SCRIPTS[scriptType];
  if (!template) {
    throw new Error(
      `Provided config does not have ${scriptType} script setup!`
    );
  }
  let processedArgs = Set<string>();
  const tx = createTransactionFromSkeleton(txSkeleton);
  const txHash = ckbHash(
    core.SerializeRawTransaction(normalizers.NormalizeRawTransaction(tx))
  ).serializeJson();
  const inputs = txSkeleton.get("inputs");
  const witnesses = txSkeleton.get("witnesses");
  let signingEntries = txSkeleton.get("signingEntries");
  for (let i = 0; i < inputs.size; i++) {
    const input = inputs.get(i)!;
    if (
      template.CODE_HASH === input.cell_output.lock.code_hash &&
      template.HASH_TYPE === input.cell_output.lock.hash_type &&
      !processedArgs.has(input.cell_output.lock.args)
    ) {
      processedArgs = processedArgs.add(input.cell_output.lock.args);
      const lockValue = new values.ScriptValue(input.cell_output.lock, {
        validate: false,
      });
      const hasher = new CKBHasher();
      hasher.update(txHash);
      if (i >= witnesses.size) {
        throw new Error(
          `The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`
        );
      }
      hashWitness(hasher, witnesses.get(i)!);
      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
        const otherInput = inputs.get(j)!;
        if (
          lockValue.equals(
            new values.ScriptValue(otherInput.cell_output.lock, {
              validate: false,
            })
          )
        ) {
          hashWitness(hasher, witnesses.get(j)!);
        }
      }
      for (let j = inputs.size; j < witnesses.size; j++) {
        hashWitness(hasher, witnesses.get(j)!);
      }
      const signingEntry = {
        type: "witness_args_lock",
        index: i,
        message: hasher.digestHex(),
      };
      signingEntries = signingEntries.push(signingEntry);
    }
  }
  txSkeleton = txSkeleton.set("signingEntries", signingEntries);
  return txSkeleton;
}

export function ensureScript(
  script: Script,
  config: Config,
  scriptType: "SECP256K1_BLAKE160" | "SECP256K1_BLAKE160_MULTISIG" | "DAO"
): void {
  const template = config.SCRIPTS[scriptType];
  if (!template) {
    throw new Error(
      `Provided config does not have ${scriptType} script setup!`
    );
  }
  if (
    template.CODE_HASH !== script.code_hash ||
    template.HASH_TYPE !== script.hash_type
  ) {
    throw new Error(`Provided script is not ${scriptType} script!`);
  }
}

/* 65-byte zeros in hex */
export const SECP_SIGNATURE_PLACEHOLDER =
  "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

export default {
  addCellDep,
  generateDaoScript,
  isSecp256k1Blake160Script,
  isSecp256k1Blake160MultisigScript,
  isDaoScript,
  isSudtScript,
  prepareSigningEntries,
  isSecp256k1Blake160Address,
  isSecp256k1Blake160MultisigAddress,
  ensureScript,
  isAcpScript,
  isAcpAddress,
};

'''
'''--- packages/common-scripts/src/index.ts ---
import secp256k1Blake160 from "./secp256k1_blake160";
import secp256k1Blake160Multisig from "./secp256k1_blake160_multisig";
import { MultisigScript, FromInfo } from "./from_info";
import dao from "./dao";
import locktimePool, { LocktimeCell } from "./locktime_pool";
import common, { LockScriptInfo } from "./common";
import sudt from "./sudt";
import anyoneCanPay from "./anyone_can_pay";
import { parseFromInfo } from "./from_info";
import { createP2PKHMessageGroup } from "./p2pkh";

export {
  secp256k1Blake160,
  secp256k1Blake160Multisig,
  dao,
  locktimePool,
  common,
  LocktimeCell,
  MultisigScript,
  FromInfo,
  sudt,
  anyoneCanPay,
  LockScriptInfo,
  parseFromInfo,
  createP2PKHMessageGroup,
};

export default {
  secp256k1Blake160,
  secp256k1Blake160Multisig,
  dao,
  locktimePool,
  common,
  sudt,
  anyoneCanPay,
};

'''
'''--- packages/common-scripts/src/locktime_pool.ts ---
import {
  parseAddress,
  Options,
  TransactionSkeletonType,
  minimalCellCapacityCompatible,
} from "@ckb-lumos/helpers";
import { FromInfo, parseFromInfo } from "./from_info";
import secp256k1Blake160 from "./secp256k1_blake160";
import {
  calculateMaximumWithdrawCompatible,
  calculateDaoEarliestSinceCompatible,
} from "./dao";
import {
  core,
  values,
  utils,
  since as sinceUtils,
  CellProvider,
  Script,
  PackedSince,
  Cell,
  Hash,
  HexString,
  Address,
  Header,
  QueryOptions,
  CellCollector as CellCollectorType,
  SinceValidationInfo,
} from "@ckb-lumos/base";
const { toBigUInt64LE, readBigUInt64LECompatible, readBigUInt64LE } = utils;
const { ScriptValue } = values;
import { normalizers, Reader } from "@ckb-lumos/toolkit";
import {
  generateDaoScript,
  isSecp256k1Blake160MultisigScript,
  isSecp256k1Blake160Script,
  isDaoScript,
  prepareSigningEntries as _prepareSigningEntries,
  addCellDep,
} from "./helper";
const {
  parseEpoch,
  maximumAbsoluteEpochSince,
  generateAbsoluteEpochSince,
  validateSince,
} = sinceUtils;
import { List, Set } from "immutable";
import { getConfig, Config } from "@ckb-lumos/config-manager";
import { RPC } from "@ckb-lumos/rpc";
import { secp256k1Blake160Multisig } from ".";
import { parseSinceCompatible } from "@ckb-lumos/base/lib/since";
import { BI, BIish } from "@ckb-lumos/bi";

export interface LocktimeCell extends Cell {
  since: PackedSince;
  depositBlockHash?: Hash;
  withdrawBlockHash?: Hash;
  sinceValidationInfo?: SinceValidationInfo;
}

export class CellCollector implements CellCollectorType {
  private cellCollectors: List<CellCollectorType>;
  private config: Config;
  private rpc: RPC;
  private tipHeader?: Header;
  private tipSinceValidationInfo?: SinceValidationInfo;
  public readonly fromScript: Script;
  public readonly multisigScript?: HexString;

  constructor(
    fromInfo: FromInfo,
    cellProvider: CellProvider,
    {
      config = undefined,
      queryOptions = {},
      tipHeader = undefined,
      NodeRPC = RPC,
    }: Options & {
      queryOptions?: QueryOptions;
      tipHeader?: Header;
      NodeRPC?: typeof RPC;
    } = {}
  ) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }
    config = config || getConfig();
    const result = parseFromInfo(fromInfo, { config });
    const fromScript = result.fromScript;
    this.multisigScript = result.multisigScript;
    this.fromScript = fromScript;

    this.config = config;
    this.tipHeader = tipHeader;

    if (tipHeader) {
      // TODO: `median_timestamp` is not provided now!
      this.tipSinceValidationInfo = {
        block_number: tipHeader.number,
        epoch: tipHeader.epoch,
        median_timestamp: "",
      };
    }

    this.rpc = new NodeRPC(cellProvider.uri!);

    queryOptions = {
      ...queryOptions,
      lock: this.fromScript,
    };

    let cellCollectors = List<CellCollectorType>([]);
    if (isSecp256k1Blake160MultisigScript(fromScript, config)) {
      const lock: Script = {
        code_hash: fromScript.code_hash,
        hash_type: fromScript.hash_type,
        args: fromScript.args.slice(0, 42),
      };
      // multisig with locktime, not dao
      cellCollectors = cellCollectors.push(
        cellProvider.collector({
          lock,
          argsLen: queryOptions.argsLen || 28,
          type: queryOptions.type || "empty",
          data: queryOptions.data || "0x",
        })
      );
      // multisig without locktime, dao
      if (
        !queryOptions.type &&
        (!queryOptions.data || queryOptions.data === "any")
      ) {
        cellCollectors = cellCollectors.push(
          cellProvider.collector({
            lock,
            type: generateDaoScript(config),
            data: "any",
          })
        );
        // multisig with locktime, dao
        cellCollectors = cellCollectors.push(
          cellProvider.collector({
            lock,
            argsLen: 28,
            type: generateDaoScript(config),
            data: "any",
          })
        );
      }
    } else if (isSecp256k1Blake160Script(fromScript, config)) {
      // secp256k1_blake160, dao
      if (
        !queryOptions.type &&
        (!queryOptions.data || queryOptions.data === "any")
      ) {
        cellCollectors = cellCollectors.push(
          cellProvider.collector({
            lock: fromScript,
            type: generateDaoScript(config),
            data: "any",
          })
        );
      }
    }

    this.cellCollectors = cellCollectors;
  }

  async *collect(): AsyncGenerator<LocktimeCell> {
    for (const cellCollector of this.cellCollectors) {
      for await (const inputCell of cellCollector.collect()) {
        const lock = inputCell.cell_output.lock;

        let since: PackedSince | undefined;
        let maximumCapacity: BI | undefined;
        let depositBlockHash: Hash | undefined;
        let withdrawBlockHash: Hash | undefined;
        let sinceValidationInfo: SinceValidationInfo | undefined;

        // multisig
        if (lock.args.length === 58) {
          const header = (await this.rpc.get_header(inputCell.block_hash!))!;
          since =
            "0x" + _parseMultisigArgsSinceCompatible(lock.args).toString(16);
          // TODO: `median_timestamp` not provided now!
          sinceValidationInfo = {
            epoch: header.epoch,
            block_number: header.number,
            median_timestamp: "",
          };
        }

        // dao
        if (isDaoScript(inputCell.cell_output.type, this.config)) {
          if (inputCell.data === "0x0000000000000000") {
            continue;
          }
          const transactionWithStatus = (await this.rpc.get_transaction(
            inputCell.out_point!.tx_hash
          ))!;
          withdrawBlockHash = transactionWithStatus.tx_status.block_hash;
          const transaction = transactionWithStatus.transaction;
          const depositOutPoint =
            transaction.inputs[+inputCell.out_point!.index].previous_output;
          depositBlockHash = (await this.rpc.get_transaction(
            depositOutPoint.tx_hash
          ))!.tx_status.block_hash!;
          const depositBlockHeader = await this.rpc.get_header(
            depositBlockHash
          );
          const withdrawBlockHeader = await this.rpc.get_header(
            withdrawBlockHash!
          );
          let daoSince: PackedSince =
            "0x" +
            calculateDaoEarliestSinceCompatible(
              depositBlockHeader!.epoch,
              withdrawBlockHeader!.epoch
            ).toString(16);
          maximumCapacity = calculateMaximumWithdrawCompatible(
            inputCell,
            depositBlockHeader!.dao,
            withdrawBlockHeader!.dao
          );
          const withdrawEpochValue = parseEpoch(withdrawBlockHeader!.epoch);
          const fourEpochsLater = {
            number: withdrawEpochValue.number + 4,
            length: withdrawEpochValue.length,
            index: withdrawEpochValue.index,
          };
          daoSince = maximumAbsoluteEpochSince(
            daoSince,
            generateAbsoluteEpochSince(fourEpochsLater)
          );

          // if multisig with locktime
          if (since) {
            const multisigSince = parseSinceCompatible(since);
            if (
              !(
                multisigSince.relative === false &&
                multisigSince.type === "epochNumber"
              )
            ) {
              // throw new Error(
              //   "Multisig since not an absolute-epoch-number since format!"
              // );
              // skip multisig with locktime in non-absolute-epoch-number format, can't unlock it
              continue;
            }

            try {
              since = maximumAbsoluteEpochSince(daoSince, since);
            } catch {
              since = daoSince;
            }
          } else {
            since = daoSince;
          }
        }

        if (
          parseSinceCompatible(since!).type === "blockTimestamp" ||
          (this.tipHeader &&
            !validateSince(
              since!,
              this.tipSinceValidationInfo!,
              sinceValidationInfo
            ))
        ) {
          continue;
        }

        const result = {
          ...inputCell,
          since: since!,
          depositBlockHash: depositBlockHash,
          withdrawBlockHash: withdrawBlockHash,
          sinceValidationInfo,
        };
        result.cell_output.capacity =
          "0x" +
          (maximumCapacity || BI.from(inputCell.cell_output.capacity)).toString(
            16
          );

        yield result;
      }
    }
  }
}

export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  toAddress: Address | undefined,
  amount: bigint,
  tipHeader: Header,
  {
    config,
    requireToAddress,
    assertAmountEnough,
    LocktimeCellCollector,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: true;
    LocktimeCellCollector?: any;
  }
): Promise<TransactionSkeletonType>;

export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  toAddress: Address | undefined,
  amount: bigint,
  tipHeader: Header,
  {
    config,
    requireToAddress,
    assertAmountEnough,
    LocktimeCellCollector,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough: false;
    LocktimeCellCollector?: any;
  }
): Promise<[TransactionSkeletonType, bigint]>;

export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  toAddress: Address | undefined,
  amount: bigint,
  tipHeader: Header,
  {
    config = undefined,
    requireToAddress = true,
    assertAmountEnough = true,
    LocktimeCellCollector = CellCollector,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: boolean;
    LocktimeCellCollector?: any;
  } = {}
): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {
  const result = await transferCompatible(
    txSkeleton,
    fromInfos,
    toAddress,
    amount,
    tipHeader,
    {
      config,
      requireToAddress,
      assertAmountEnough: assertAmountEnough as true | undefined,
      LocktimeCellCollector,
    }
  );
  let _txSkeleton: TransactionSkeletonType;
  let _amount: bigint;
  if (result instanceof Array) {
    _txSkeleton = result[0];
    _amount = BigInt(result[1].toString());
    return [_txSkeleton, _amount];
  } else {
    _txSkeleton = result;
    return _txSkeleton;
  }
}

export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  toAddress: Address | undefined,
  amount: BIish,
  tipHeader: Header,
  {
    config,
    requireToAddress,
    assertAmountEnough,
    LocktimeCellCollector,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: true;
    LocktimeCellCollector?: any;
  }
): Promise<TransactionSkeletonType>;

export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  toAddress: Address | undefined,
  amount: BIish,
  tipHeader: Header,
  {
    config,
    requireToAddress,
    assertAmountEnough,
    LocktimeCellCollector,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough: false;
    LocktimeCellCollector?: any;
  }
): Promise<[TransactionSkeletonType, BI]>;
export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  toAddress: Address | undefined,
  amount: BIish,
  tipHeader: Header,
  {
    config = undefined,
    requireToAddress = true,
    assertAmountEnough = true,
    LocktimeCellCollector = CellCollector,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: boolean;
    LocktimeCellCollector?: any;
  } = {}
): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {
  let _amount = BI.from(amount);
  for (const [index, fromInfo] of fromInfos.entries()) {
    const value = (await _transferCompatible(
      txSkeleton,
      fromInfo,
      index === 0 ? toAddress : undefined,
      _amount,
      tipHeader,
      {
        config,
        requireToAddress: index === 0 ? requireToAddress : false,
        assertAmountEnough: false,
        LocktimeCellCollector,
      }
    )) as [TransactionSkeletonType, BI];
    // [txSkeleton, amount] = value
    txSkeleton = value[0];
    _amount = value[1];

    if (_amount.eq(0)) {
      if (assertAmountEnough) {
        return txSkeleton;
      }
      return [txSkeleton, BI.from(_amount)];
    }
  }

  if (assertAmountEnough) {
    throw new Error("Not enough capacity in from addresses!");
  }
  return [txSkeleton, BI.from(_amount)];
}

async function _transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  toAddress: Address | undefined,
  amount: BIish,
  tipHeader: Header,
  {
    config = undefined,
    requireToAddress = true,
    assertAmountEnough = true,
    LocktimeCellCollector = CellCollector,
    changeAddress = undefined,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: boolean;
    LocktimeCellCollector: any;
    changeAddress?: Address;
  }
): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {
  config = config || getConfig();
  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig
  const { fromScript } = parseFromInfo(fromInfo, { config });

  // validate fromScript
  if (
    !isSecp256k1Blake160MultisigScript(fromScript, config) &&
    !isSecp256k1Blake160Script(fromScript, config)
  ) {
    throw new Error("fromInfo not supported!");
  }

  if (requireToAddress && !toAddress) {
    throw new Error("You must provide a to address!");
  }

  let _amount = BI.from(amount || 0);
  if (toAddress) {
    const toScript = parseAddress(toAddress, { config });

    txSkeleton = txSkeleton.update("outputs", (outputs) => {
      return outputs.push({
        cell_output: {
          capacity: "0x" + _amount.toString(16),
          lock: toScript,
          type: undefined,
        },
        data: "0x",
        out_point: undefined,
        block_hash: undefined,
      });
    });
  }

  const lastFreezedOutput = txSkeleton
    .get("fixedEntries")
    .filter(({ field }) => field === "outputs")
    .maxBy(({ index }) => index);
  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
  for (; i < txSkeleton.get("outputs").size && _amount.gt(0); ++i) {
    const output = txSkeleton.get("outputs").get(i)!;
    if (
      new ScriptValue(output.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    ) {
      const cellCapacity = BI.from(output.cell_output.capacity);
      let deductCapacity;
      if (_amount.gte(cellCapacity)) {
        deductCapacity = cellCapacity;
      } else {
        deductCapacity = cellCapacity.sub(
          minimalCellCapacityCompatible(output)
        );
        if (deductCapacity.gt(_amount)) {
          deductCapacity = _amount;
        }
      }
      _amount = _amount.sub(deductCapacity);

      const clonedOutput = JSON.parse(JSON.stringify(output));
      clonedOutput.cell_output.capacity =
        "0x" + cellCapacity.sub(deductCapacity).toString(16);
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.update(i, () => clonedOutput);
      });
    }
  }
  // remove all output cells with capacity equal to 0
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.filter(
      (output) => !BI.from(output.cell_output.capacity).eq(0)
    );
  });
  /*
   * Collect and add new input cells so as to prepare remaining capacities.
   */
  if (_amount.gt(0)) {
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) {
      throw new Error("cell provider is missing!");
    }

    const changeLockScript: Script = changeAddress
      ? parseAddress(changeAddress, { config })
      : fromScript;
    const changeCell: Cell = {
      cell_output: {
        capacity: "0x0",
        lock: changeLockScript,
        type: undefined,
      },
      data: "0x",
      out_point: undefined,
      block_hash: undefined,
    };
    let changeCapacity = BI.from(0);

    let previousInputs = Set<string>();
    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(
        `${input.out_point!.tx_hash}_${input.out_point!.index}`
      );
    }
    const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {
      config,
      tipHeader,
    });
    for await (const inputCell of cellCollector.collect()) {
      // skip inputs already exists in txSkeleton.inputs
      if (
        previousInputs.has(
          `${inputCell.out_point!.tx_hash}_${inputCell.out_point!.index}`
        )
      ) {
        continue;
      }

      let multisigSince: BI | undefined;
      if (isSecp256k1Blake160MultisigScript(fromScript, config)) {
        const lockArgs = inputCell.cell_output.lock.args;
        multisigSince =
          lockArgs.length === 58
            ? BI.from(_parseMultisigArgsSinceCompatible(lockArgs))
            : undefined;
      }
      let witness: HexString = "0x";
      if (isDaoScript(inputCell.cell_output.type, config)) {
        const template = config.SCRIPTS.DAO!;
        txSkeleton = addCellDep(txSkeleton, {
          dep_type: template.DEP_TYPE,
          out_point: {
            tx_hash: template.TX_HASH,
            index: template.INDEX,
          },
        });

        txSkeleton = txSkeleton.update("headerDeps", (headerDeps) => {
          return headerDeps.push(
            inputCell.depositBlockHash!,
            inputCell.withdrawBlockHash!
          );
        });

        const depositHeaderDepIndex = txSkeleton.get("headerDeps").size - 2;

        const witnessArgs = {
          input_type: toBigUInt64LE(depositHeaderDepIndex),
        };
        witness = new Reader(
          core.SerializeWitnessArgs(
            normalizers.NormalizeWitnessArgs(witnessArgs)
          )
        ).serializeJson();
      }

      txSkeleton = await collectInput(
        txSkeleton,
        inputCell,
        isSecp256k1Blake160MultisigScript(fromScript, config)
          ? Object.assign({}, fromInfo, { since: multisigSince })
          : fromInfo,
        { config, defaultWitness: witness, since: inputCell.since }
      );

      const inputCapacity = BI.from(inputCell.cell_output.capacity);
      let deductCapacity = inputCapacity;
      if (deductCapacity.gt(_amount)) {
        deductCapacity = _amount;
      }
      _amount = _amount.sub(deductCapacity);
      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);
      if (isDaoScript(inputCell.cell_output.type, config)) {
        // fix inputs / outputs / witnesses
        txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
          return fixedEntries.push(
            {
              field: "inputs",
              index: txSkeleton.get("inputs").size - 1,
            },
            {
              field: "witnesses",
              index: txSkeleton.get("witnesses").size - 1,
            },
            {
              field: "headerDeps",
              index: txSkeleton.get("headerDeps").size - 2,
            }
          );
        });
      }
      if (
        _amount.eq(0) &&
        (changeCapacity.eq(0) ||
          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))
      ) {
        break;
      }
    }
    if (changeCapacity.gt(0)) {
      changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
      txSkeleton = txSkeleton.update("outputs", (outputs) =>
        outputs.push(changeCell)
      );
    }
  }

  if (!assertAmountEnough) {
    return [txSkeleton, _amount];
  }

  if (_amount.gt(0)) {
    throw new Error("Not enough capacity in from address!");
  }

  return txSkeleton;
}

async function injectCapacityWithoutChangeCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  amount: BIish,
  tipHeader: Header,
  minimalChangeCapacity: BIish,
  {
    config = undefined,
    LocktimeCellCollector = CellCollector,
    enableDeductCapacity = true,
  }: {
    config?: Config;
    LocktimeCellCollector?: any;
    enableDeductCapacity?: boolean;
  }
): Promise<{
  txSkeleton: TransactionSkeletonType;
  capacity: BI;
  changeCapacity: BI;
}> {
  config = config || getConfig();
  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig

  let _amount = BI.from(amount);
  const _minimalChangeCapacity = BI.from(minimalChangeCapacity);
  if (enableDeductCapacity) {
    for (const fromInfo of fromInfos) {
      const fromScript: Script = parseFromInfo(fromInfo, { config }).fromScript;
      // validate fromScript
      if (
        !isSecp256k1Blake160MultisigScript(fromScript, config) &&
        !isSecp256k1Blake160Script(fromScript, config)
      ) {
        // Skip if not support.
        continue;
      }
      const lastFreezedOutput = txSkeleton
        .get("fixedEntries")
        .filter(({ field }) => field === "outputs")
        .maxBy(({ index }) => index);
      let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
      for (; i < txSkeleton.get("outputs").size && _amount.gt(0); ++i) {
        const output = txSkeleton.get("outputs").get(i)!;
        if (
          new ScriptValue(output.cell_output.lock, { validate: false }).equals(
            new ScriptValue(fromScript, { validate: false })
          )
        ) {
          const clonedOutput: Cell = JSON.parse(JSON.stringify(output));
          const cellCapacity = BI.from(clonedOutput.cell_output.capacity);
          let deductCapacity;
          if (_amount.gte(cellCapacity)) {
            deductCapacity = cellCapacity;
          } else {
            deductCapacity = cellCapacity.sub(
              minimalCellCapacityCompatible(clonedOutput)
            );
            if (deductCapacity.gt(_amount)) {
              deductCapacity = _amount;
            }
          }
          _amount = _amount.sub(deductCapacity);
          clonedOutput.cell_output.capacity =
            "0x" + cellCapacity.sub(deductCapacity).toString(16);

          txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.update(i, () => clonedOutput);
          });
        }
      }
      // remove all output cells with capacity equal to 0
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.filter(
          (output) => !BI.from(output.cell_output.capacity).eq(0)
        );
      });
    }
  }

  /*
   * Collect and add new input cells so as to prepare remaining capacities.
   */
  let changeCapacity = BI.from(0);
  if (_amount.gt(0)) {
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) {
      throw new Error("cell provider is missing!");
    }

    const getInputKey = (input: Cell) =>
      `${input.out_point!.tx_hash}_${input.out_point!.index}`;
    let previousInputs = Set<string>();
    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(getInputKey(input));
    }

    for (const fromInfo of fromInfos) {
      const fromScript: Script = parseFromInfo(fromInfo, { config }).fromScript;
      const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {
        config,
        tipHeader,
      });
      for await (const inputCell of cellCollector.collect()) {
        // skip inputs already exists in txSkeleton.inputs
        if (previousInputs.has(getInputKey(inputCell))) {
          continue;
        }

        let witness: HexString = "0x";
        if (isDaoScript(inputCell.cell_output.type, config)) {
          const template = config.SCRIPTS.DAO!;
          txSkeleton = addCellDep(txSkeleton, {
            dep_type: template.DEP_TYPE,
            out_point: {
              tx_hash: template.TX_HASH,
              index: template.INDEX,
            },
          });

          txSkeleton = txSkeleton.update("headerDeps", (headerDeps) => {
            return headerDeps.push(
              inputCell.depositBlockHash!,
              inputCell.withdrawBlockHash!
            );
          });

          const depositHeaderDepIndex = txSkeleton.get("headerDeps").size - 2;
          const witnessArgs = {
            input_type: toBigUInt64LE(
              BI.from(depositHeaderDepIndex).toString()
            ),
          };
          witness = new Reader(
            core.SerializeWitnessArgs(
              normalizers.NormalizeWitnessArgs(witnessArgs)
            )
          ).serializeJson();
        }
        let multisigSince: BI | undefined;
        if (isSecp256k1Blake160MultisigScript(fromScript, config)) {
          // multisig
          const lockArgs = inputCell.cell_output.lock.args;
          multisigSince =
            lockArgs.length === 58
              ? BI.from(_parseMultisigArgsSinceCompatible(lockArgs))
              : undefined;
        }
        txSkeleton = await collectInput(
          txSkeleton,
          inputCell,
          Object.assign({}, fromInfo, { since: multisigSince }),
          { config, defaultWitness: witness, since: inputCell.since }
        );

        const inputCapacity = BI.from(inputCell.cell_output.capacity);
        let deductCapacity = inputCapacity;
        if (deductCapacity.gt(_amount)) {
          deductCapacity = _amount;
        }
        _amount = _amount.sub(deductCapacity);
        changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);

        if (isDaoScript(inputCell.cell_output.type, config)) {
          // fix inputs / outputs / witnesses
          txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
            return fixedEntries.push(
              {
                field: "inputs",
                index: txSkeleton.get("inputs").size - 1,
              },
              {
                field: "witnesses",
                index: txSkeleton.get("witnesses").size - 1,
              },
              {
                field: "headerDeps",
                index: txSkeleton.get("headerDeps").size - 2,
              }
            );
          });
        }

        if (
          _amount.eq(0) &&
          (changeCapacity.eq(0) || changeCapacity.gt(_minimalChangeCapacity))
        ) {
          break;
        }
      }
    }
  }

  return {
    txSkeleton,
    capacity: BI.from(_amount.toString()),
    changeCapacity: BI.from(changeCapacity.toString()),
  };
}

async function injectCapacityWithoutChange(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  amount: bigint,
  tipHeader: Header,
  minimalChangeCapacity: bigint,
  {
    config = undefined,
    LocktimeCellCollector = CellCollector,
    enableDeductCapacity = true,
  }: {
    config?: Config;
    LocktimeCellCollector?: any;
    enableDeductCapacity?: boolean;
  }
): Promise<{
  txSkeleton: TransactionSkeletonType;
  capacity: bigint;
  changeCapacity: bigint;
}> {
  const result = await injectCapacityWithoutChangeCompatible(
    txSkeleton,
    fromInfos,
    amount,
    tipHeader,
    minimalChangeCapacity,
    {
      config,
      LocktimeCellCollector,
      enableDeductCapacity,
    }
  );

  return {
    txSkeleton: result.txSkeleton,
    capacity: result.capacity.toBigInt(),
    changeCapacity: result.changeCapacity.toBigInt(),
  };
}

export async function payFee(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  amount: BIish,
  tipHeader: Header,
  {
    config = undefined,
    LocktimeCellCollector = CellCollector,
  }: {
    config?: Config;
    LocktimeCellCollector?: any;
  } = {}
): Promise<TransactionSkeletonType> {
  return transferCompatible(
    txSkeleton,
    fromInfos,
    undefined,
    amount,
    tipHeader,
    {
      config,
      requireToAddress: false,
      LocktimeCellCollector,
    }
  );
}

export function prepareSigningEntries(
  txSkeleton: TransactionSkeletonType,
  { config = undefined }: Options = {}
): TransactionSkeletonType {
  config = config || getConfig();
  txSkeleton = _prepareSigningEntries(txSkeleton, config, "SECP256K1_BLAKE160");
  txSkeleton = _prepareSigningEntries(
    txSkeleton,
    config,
    "SECP256K1_BLAKE160_MULTISIG"
  );
  return txSkeleton;
}

export async function injectCapacity(
  txSkeleton: TransactionSkeletonType,
  outputIndex: number,
  fromInfos: FromInfo[],
  tipHeader: Header,
  {
    config = undefined,
    LocktimeCellCollector = CellCollector,
  }: Options & {
    cellCollector?: (...params: any[]) => AsyncIterable<LocktimeCell>;
    LocktimeCellCollector?: any;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  if (outputIndex >= txSkeleton.get("outputs").size) {
    throw new Error("Invalid output index!");
  }
  const capacity = BI.from(
    txSkeleton.get("outputs").get(outputIndex)!.cell_output.capacity
  );
  return transferCompatible(
    txSkeleton,
    fromInfos,
    undefined,
    BI.from(capacity),
    tipHeader,
    {
      config,
      requireToAddress: false,
      LocktimeCellCollector,
    }
  );
}

async function collectInput(
  txSkeleton: TransactionSkeletonType,
  inputCell: Cell,
  fromInfo?: FromInfo,
  {
    config = undefined,
    since = undefined,
    defaultWitness = "0x",
  }: Options & { defaultWitness?: HexString; since?: PackedSince } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {
    config,
    since,
    defaultWitness,
  });

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.remove(outputs.size - 1);
  });

  return txSkeleton;
}

export async function setupInputCell(
  txSkeleton: TransactionSkeletonType,
  inputCell: Cell,
  fromInfo?: FromInfo,
  {
    config = undefined,
    since = undefined,
    defaultWitness = "0x",
  }: Options & { defaultWitness?: HexString; since?: PackedSince } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  const inputLock = inputCell.cell_output.lock;

  if (isSecp256k1Blake160Script(inputLock, config)) {
    return secp256k1Blake160.setupInputCell(txSkeleton, inputCell, fromInfo, {
      config,
      defaultWitness,
      since,
    });
  } else if (isSecp256k1Blake160MultisigScript(inputLock, config)) {
    return secp256k1Blake160Multisig.setupInputCell(
      txSkeleton,
      inputCell,
      fromInfo,
      { config, defaultWitness, since }
    );
  } else {
    throw new Error(`Not supported input lock!`);
  }
}

function _parseMultisigArgsSince(args: HexString): bigint {
  if (args.length !== 58) {
    throw new Error("Invalid multisig with since args!");
  }
  return readBigUInt64LE("0x" + args.slice(42));
}

function _parseMultisigArgsSinceCompatible(args: HexString): BI {
  if (args.length !== 58) {
    throw new Error("Invalid multisig with since args!");
  }
  return readBigUInt64LECompatible("0x" + args.slice(42));
}

export default {
  CellCollector,
  transfer,
  transferCompatible,
  payFee,
  prepareSigningEntries,
  injectCapacity,
  setupInputCell,
  injectCapacityWithoutChange,
  injectCapacityWithoutChangeCompatible,
};

'''
'''--- packages/common-scripts/src/p2pkh.ts ---
import { Cell, core, utils } from "@ckb-lumos/base";
import {
  TransactionSkeletonType,
  createTransactionFromSkeleton,
} from "@ckb-lumos/helpers";
import { Reader, normalizers } from "@ckb-lumos/toolkit";
import { Hash, Script } from "@ckb-lumos/base";
import { BI } from "@ckb-lumos/bi";

function groupInputs(inputs: Cell[], locks: Script[]): Map<string, number[]> {
  const lockSet = new Set<string>();
  for (const lock of locks) {
    const scriptHash = utils
      .ckbHash(core.SerializeScript(normalizers.NormalizeScript(lock)))
      .serializeJson();
    lockSet.add(scriptHash);
  }

  const groups = new Map<string, number[]>();
  for (let i = 0; i < inputs.length; i++) {
    const scriptHash = utils
      .ckbHash(
        core.SerializeScript(
          normalizers.NormalizeScript(inputs[i].cell_output.lock)
        )
      )
      .serializeJson();
    if (lockSet.has(scriptHash)) {
      if (groups.get(scriptHash) === undefined) groups.set(scriptHash, []);
      groups.get(scriptHash)!.push(i);
    }
  }
  return groups;
}

function calcRawTxHash(tx: TransactionSkeletonType): Reader {
  return utils.ckbHash(
    core.SerializeRawTransaction(
      normalizers.NormalizeRawTransaction(createTransactionFromSkeleton(tx))
    )
  );
}

export interface Hasher {
  update(message: Uint8Array): void;
  digest(): Uint8Array;
}

type Group = {
  index: number;
  lock: Script;
  message: Hash;
};

interface Options {
  hasher?: Hasher;
}

/**
 * Return an array of messages as well as their corresponding position indexes and locks for signing a P2PKH transaction.
 * For more details, please see:
 * https://github.com/nervosnetwork/ckb-system-scripts/wiki/How-to-sign-transaction
 *
 * @param tx TxSkeleton with all input cells' witnessArgs.lock filled with 0.
 * @param locks Locks you want to sign, e.g. you don't need to sign ACP cells.
 * @param hasher Message hasher, defaults to CKB blake2b hasher. Check
 * https://github.com/nervosnetwork/ckb-system-scripts/blob/e975e8b7d5231fdb1c537b830dd934b305492417/c/secp256k1_blake160_sighash_all.c#L22-L28 for more.
 * @returns An array of Group containing: lock of the input cell you need to sign, message for signing, witness index of this message (first index of the input cell with this lock).
 */
export function createP2PKHMessageGroup(
  tx: TransactionSkeletonType,
  locks: Script[],
  { hasher = undefined }: Options = {}
): Group[] {
  const groups = groupInputs(tx.inputs.toArray(), locks);
  const rawTxHash = calcRawTxHash(tx);

  const defaultHasher = new utils.CKBHasher();
  hasher = hasher || {
    update: (message) => defaultHasher.update(message.buffer),
    digest: () => new Uint8Array(defaultHasher.digestReader().toArrayBuffer()),
  };

  const messageGroup: Group[] = [];

  for (const group of groups.keys()) {
    const indexes = groups.get(group)!;
    const firstIndex = indexes[0];
    const firstWitness = tx.witnesses.get(firstIndex);
    if (firstWitness === undefined) {
      throw new Error("Please fill witnesses with 0 first!");
    }

    hasher.update(new Uint8Array(rawTxHash.toArrayBuffer()));

    const lengthBuffer = new ArrayBuffer(8);
    const view = new DataView(lengthBuffer);
    const witnessHexString = BI.from(
      new Reader(firstWitness).length()
    ).toString(16);
    if (witnessHexString.length <= 8) {
      view.setUint32(0, Number("0x" + witnessHexString), true);
      view.setUint32(4, Number("0x" + "00000000"), true);
    }

    if (witnessHexString.length > 8 && witnessHexString.length <= 16) {
      view.setUint32(0, Number("0x" + witnessHexString.slice(-8)), true);
      view.setUint32(4, Number("0x" + witnessHexString.slice(0, -8)), true);
    }

    hasher.update(new Uint8Array(lengthBuffer));
    hasher.update(new Uint8Array(new Reader(firstWitness).toArrayBuffer()));

    for (let i = 1; i < indexes.length; i++) {
      const witness = tx.witnesses.get(indexes[i])!;
      hasher.update(new Uint8Array(lengthBuffer));
      hasher.update(new Uint8Array(new Reader(witness).toArrayBuffer()));
    }

    for (
      let i = tx.inputs.toArray().length;
      i < tx.witnesses.toArray().length;
      i++
    ) {
      const witness = tx.witnesses.get(i)!;
      hasher.update(new Uint8Array(lengthBuffer));
      hasher.update(new Uint8Array(new Reader(witness).toArrayBuffer()));
    }

    const g: Group = {
      index: firstIndex,
      lock: tx.inputs.get(firstIndex)!.cell_output.lock,
      message:
        "0x" +
        Array.prototype.map
          .call(hasher.digest(), (x) => ("00" + x.toString(16)).slice(-2))
          .join(""),
    };

    messageGroup.push(g);
  }

  return messageGroup;
}

'''
'''--- packages/common-scripts/src/secp256k1_blake160.ts ---
import { Set } from "immutable";
import { normalizers, Reader } from "@ckb-lumos/toolkit";
import {
  parseAddress,
  minimalCellCapacityCompatible,
} from "@ckb-lumos/helpers";
import {
  core,
  values,
  Address,
  Cell,
  WitnessArgs,
  CellCollector as CellCollectorType,
  Script,
  CellProvider,
  QueryOptions,
  OutPoint,
  HexString,
  PackedSince,
} from "@ckb-lumos/base";
import { getConfig, Config } from "@ckb-lumos/config-manager";
import { TransactionSkeletonType, Options } from "@ckb-lumos/helpers";
import {
  addCellDep,
  ensureScript,
  prepareSigningEntries as _prepareSigningEntries,
  SECP_SIGNATURE_PLACEHOLDER,
  isSecp256k1Blake160Script,
} from "./helper";
import { FromInfo } from ".";
import { parseFromInfo } from "./from_info";
import { BI, BIish } from "@ckb-lumos/bi";
const { ScriptValue } = values;

export class CellCollector implements CellCollectorType {
  private cellCollector: CellCollectorType;
  private config: Config;
  public readonly fromScript: Script;

  constructor(
    fromInfo: FromInfo,
    cellProvider: CellProvider,
    {
      config = undefined,
      queryOptions = {},
    }: Options & {
      queryOptions?: QueryOptions;
    } = {}
  ) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }
    config = config || getConfig();
    this.fromScript = parseFromInfo(fromInfo, { config }).fromScript;

    this.config = config;

    queryOptions = {
      ...queryOptions,
      lock: this.fromScript,
      type: queryOptions.type || "empty",
    };

    this.cellCollector = cellProvider.collector(queryOptions);
  }

  async *collect(): AsyncGenerator<Cell> {
    if (!isSecp256k1Blake160Script(this.fromScript, this.config)) {
      return;
    }

    for await (const inputCell of this.cellCollector.collect()) {
      yield inputCell;
    }
  }
}

/**
 * Setup input cell infos, such as cell deps and witnesses.
 *
 * @param txSkeleton
 * @param inputCell
 * @param _fromInfo
 * @param options
 */
export async function setupInputCell(
  txSkeleton: TransactionSkeletonType,
  inputCell: Cell,
  _fromInfo?: FromInfo,
  {
    config = undefined,
    defaultWitness = "0x",
    since = undefined,
  }: Options & {
    defaultWitness?: HexString;
    since?: PackedSince;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  const fromScript = inputCell.cell_output.lock;
  if (!isSecp256k1Blake160Script(fromScript, config)) {
    throw new Error(`Not SECP256K1_BLAKE160 input!`);
  }

  // add inputCell to txSkeleton
  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(inputCell);
  });

  const output: Cell = {
    cell_output: {
      capacity: inputCell.cell_output.capacity,
      lock: inputCell.cell_output.lock,
      type: inputCell.cell_output.type,
    },
    data: inputCell.data,
  };

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(output);
  });

  if (since) {
    txSkeleton = txSkeleton.update("inputSinces", (inputSinces) => {
      return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
    });
  }

  txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
    return witnesses.push(defaultWitness);
  });

  const template = config.SCRIPTS.SECP256K1_BLAKE160;
  if (!template) {
    throw new Error(`SECP256K1_BLAKE160 script not defined in config!`);
  }

  const scriptOutPoint: OutPoint = {
    tx_hash: template.TX_HASH,
    index: template.INDEX,
  };

  // add cell dep
  txSkeleton = addCellDep(txSkeleton, {
    out_point: scriptOutPoint,
    dep_type: template.DEP_TYPE,
  });

  // add witness
  /*
   * Modify the skeleton, so the first witness of the fromAddress script group
   * has a WitnessArgs construct with 65-byte zero filled values. While this
   * is not required, it helps in transaction fee estimation.
   */
  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
    }
    let witness: string = txSkeleton.get("witnesses").get(firstIndex)!;
    const newWitnessArgs: WitnessArgs = {
      /* 65-byte zeros in hex */
      lock: SECP_SIGNATURE_PLACEHOLDER,
    };
    if (witness !== "0x") {
      const witnessArgs = new core.WitnessArgs(new Reader(witness));
      const lock = witnessArgs.getLock();
      if (
        lock.hasValue() &&
        new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock
      ) {
        throw new Error(
          "Lock field in first witness is set aside for signature!"
        );
      }
      const inputType = witnessArgs.getInputType();
      if (inputType.hasValue()) {
        newWitnessArgs.input_type = new Reader(
          inputType.value().raw()
        ).serializeJson();
      }
      const outputType = witnessArgs.getOutputType();
      if (outputType.hasValue()) {
        newWitnessArgs.output_type = new Reader(
          outputType.value().raw()
        ).serializeJson();
      }
    }
    witness = new Reader(
      core.SerializeWitnessArgs(
        normalizers.NormalizeWitnessArgs(newWitnessArgs)
      )
    ).serializeJson();
    txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
      witnesses.set(firstIndex, witness)
    );
  }

  return txSkeleton;
}

export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromAddress: Address,
  toAddress: Address | null | undefined,
  amount: bigint,
  options?: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: true;
  }
): Promise<TransactionSkeletonType>;

export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromAddress: Address,
  toAddress: Address | null | undefined,
  amount: bigint,
  options: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough: false;
  }
): Promise<[TransactionSkeletonType, bigint]>;

/**
 * transfer capacity from secp256k1_blake160 script cells
 *
 * @param txSkeleton
 * @param fromAddress
 * @param toAddress
 * @param amount
 * @param options
 */
export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromAddress: Address,
  toAddress: Address | null | undefined,
  amount: bigint,
  {
    config = undefined,
    requireToAddress = true,
    assertAmountEnough = true,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: boolean;
  } = {}
): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {
  const result = await transferCompatible(
    txSkeleton,
    fromAddress,
    toAddress,
    amount,
    {
      config,
      requireToAddress,
      assertAmountEnough: assertAmountEnough as true | undefined,
    }
  );
  let _txSkeleton: TransactionSkeletonType;
  let _amount: bigint;
  if (result instanceof Array) {
    _txSkeleton = result[0];
    _amount = BigInt(result[1].toString());
    return [_txSkeleton, _amount];
  } else {
    _txSkeleton = result;
    return _txSkeleton;
  }
}
export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromAddress: Address,
  toAddress: Address | null | undefined,
  amount: BIish,
  options?: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: true;
  }
): Promise<TransactionSkeletonType>;

export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromAddress: Address,
  toAddress: Address | null | undefined,
  amount: BIish,
  options: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough: false;
  }
): Promise<[TransactionSkeletonType, BI]>;
/**
 * transfer capacity from secp256k1_blake160 script cells
 *
 * @param txSkeleton
 * @param fromAddress
 * @param toAddress
 * @param amount
 * @param options
 */
export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromAddress: Address,
  toAddress: Address | null | undefined,
  amount: BIish,
  {
    config = undefined,
    requireToAddress = true,
    assertAmountEnough = true,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: boolean;
  } = {}
): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {
  config = config || getConfig();

  const template = config.SCRIPTS.SECP256K1_BLAKE160;
  if (!template) {
    throw new Error(
      "Provided config does not have SECP256K1_BLAKE160 script setup!"
    );
  }
  const scriptOutPoint = {
    tx_hash: template.TX_HASH,
    index: template.INDEX,
  };

  txSkeleton = addCellDep(txSkeleton, {
    out_point: scriptOutPoint,
    dep_type: template.DEP_TYPE,
  });

  const fromScript = parseAddress(fromAddress, { config });
  ensureScript(fromScript, config, "SECP256K1_BLAKE160");

  if (requireToAddress && !toAddress) {
    throw new Error("You must provide a to address!");
  }

  let _amount = BI.from(amount);
  if (toAddress) {
    const toScript = parseAddress(toAddress, { config });

    txSkeleton = txSkeleton.update("outputs", (outputs) => {
      return outputs.push({
        cell_output: {
          capacity: "0x" + _amount.toString(16),
          lock: toScript,
          type: undefined,
        },
        data: "0x",
        out_point: undefined,
        block_hash: undefined,
      });
    });
  }

  /*
   * First, check if there is any output cells that contains enough capacity
   * for us to tinker with.
   *
   * TODO: the solution right now won't cover all cases, some outputs before the
   * last output might still be tinkerable, right now we are working on the
   * simple solution, later we can change this for more optimizations.
   */
  const lastFreezedOutput = txSkeleton
    .get("fixedEntries")
    .filter(({ field }) => field === "outputs")
    .maxBy(({ index }) => index);
  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
  for (; i < txSkeleton.get("outputs").size && _amount.gt(0); i++) {
    const output = txSkeleton.get("outputs").get(i)!;
    if (
      new ScriptValue(output.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    ) {
      const cellCapacity = BI.from(output.cell_output.capacity);
      let deductCapacity;
      if (_amount.gte(cellCapacity)) {
        deductCapacity = cellCapacity;
      } else {
        deductCapacity = cellCapacity.sub(
          minimalCellCapacityCompatible(output)
        );
        if (deductCapacity.gt(_amount)) {
          deductCapacity = _amount;
        }
      }
      _amount = _amount.sub(deductCapacity);
      output.cell_output.capacity =
        "0x" + cellCapacity.sub(deductCapacity).toString(16);
    }
  }
  // Remove all output cells with capacity equal to 0
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.filter(
      (output) => !BI.from(output.cell_output.capacity).eq(0)
    );
  });
  /*
   * Collect and add new input cells so as to prepare remaining capacities.
   */
  if (_amount.gt(0)) {
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) {
      throw new Error("Cell provider is missing!");
    }
    const cellCollector = cellProvider.collector({
      lock: fromScript,
      type: "empy",
    });
    const changeCell: Cell = {
      cell_output: {
        capacity: "0x0",
        lock: fromScript,
        type: undefined,
      },
      data: "0x",
      out_point: undefined,
      block_hash: undefined,
    };
    let changeCapacity = BI.from(0);
    let previousInputs = Set<string>();
    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(
        `${input.out_point!.tx_hash}_${input.out_point!.index}`
      );
    }
    for await (const inputCell of cellCollector.collect()) {
      // skip inputs already exists in txSkeleton.inputs
      if (
        previousInputs.has(
          `${inputCell.out_point!.tx_hash}_${inputCell.out_point!.index}`
        )
      ) {
        continue;
      }
      txSkeleton = txSkeleton.update("inputs", (inputs) =>
        inputs.push(inputCell)
      );
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
      const inputCapacity = BI.from(inputCell.cell_output.capacity);
      let deductCapacity = inputCapacity;
      if (deductCapacity.gt(_amount)) {
        deductCapacity = _amount;
      }
      _amount = _amount.sub(deductCapacity);
      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);
      if (
        _amount.eq(0) &&
        (changeCapacity.eq(0) ||
          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))
      ) {
        break;
      }
    }
    if (changeCapacity.gt(0)) {
      changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
      txSkeleton = txSkeleton.update("outputs", (outputs) =>
        outputs.push(changeCell)
      );
    }
  }
  if (_amount.gt(0) && assertAmountEnough) {
    throw new Error("Not enough capacity in from address!");
  }
  /*
   * Modify the skeleton, so the first witness of the fromAddress script group
   * has a WitnessArgs construct with 65-byte zero filled values. While this
   * is not required, it helps in transaction fee estimation.
   */
  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
    }
    let witness: string = txSkeleton.get("witnesses").get(firstIndex)!;
    const newWitnessArgs: WitnessArgs = {
      /* 65-byte zeros in hex */
      lock: SECP_SIGNATURE_PLACEHOLDER,
    };
    if (witness !== "0x") {
      const witnessArgs = new core.WitnessArgs(new Reader(witness));
      const lock = witnessArgs.getLock();
      if (
        lock.hasValue() &&
        new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock
      ) {
        throw new Error(
          "Lock field in first witness is set aside for signature!"
        );
      }
      const inputType = witnessArgs.getInputType();
      if (inputType.hasValue()) {
        newWitnessArgs.input_type = new Reader(
          inputType.value().raw()
        ).serializeJson();
      }
      const outputType = witnessArgs.getOutputType();
      if (outputType.hasValue()) {
        newWitnessArgs.output_type = new Reader(
          outputType.value().raw()
        ).serializeJson();
      }
    }
    witness = new Reader(
      core.SerializeWitnessArgs(
        normalizers.NormalizeWitnessArgs(newWitnessArgs)
      )
    ).serializeJson();
    txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
      witnesses.set(firstIndex, witness)
    );
  }
  if (!assertAmountEnough) {
    return [txSkeleton, BI.from(_amount)];
  }
  return txSkeleton;
}

/**
 * pay fee by secp256k1_blake160 script cells
 *
 * @param txSkeleton
 * @param fromAddress
 * @param amount fee in shannon
 * @param options
 */
export async function payFee(
  txSkeleton: TransactionSkeletonType,
  fromAddress: Address,
  amount: BIish,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  return await transferCompatible(txSkeleton, fromAddress, null, amount, {
    config,
    requireToAddress: false,
  });
}

/**
 * Inject capacity from `fromAddress` to target output.
 *
 * @param txSkeleton
 * @param outputIndex
 * @param fromAddress
 * @param options
 */
export async function injectCapacity(
  txSkeleton: TransactionSkeletonType,
  outputIndex: number,
  fromAddress: Address,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  if (outputIndex >= txSkeleton.get("outputs").size) {
    throw new Error("Invalid output index!");
  }
  const capacity = BI.from(
    txSkeleton.get("outputs").get(outputIndex)!.cell_output.capacity
  );
  return await transferCompatible(
    txSkeleton,
    fromAddress,
    null,
    BI.from(capacity),
    {
      config,
      requireToAddress: false,
    }
  );
}

/**
 * prepare for txSkeleton signingEntries, will update txSkeleton.get("signingEntries")
 *
 * @param txSkeleton
 * @param options
 */
export function prepareSigningEntries(
  txSkeleton: TransactionSkeletonType,
  { config = undefined }: Options = {}
): TransactionSkeletonType {
  config = config || getConfig();

  return _prepareSigningEntries(txSkeleton, config, "SECP256K1_BLAKE160");
}

export default {
  transfer,
  transferCompatible,
  payFee,
  prepareSigningEntries,
  injectCapacity,
  setupInputCell,
  CellCollector,
};

'''
'''--- packages/common-scripts/src/secp256k1_blake160_multisig.ts ---
import {
  parseAddress,
  TransactionSkeletonType,
  Options,
  minimalCellCapacityCompatible,
} from "@ckb-lumos/helpers";
import {
  core,
  values,
  HexString,
  Script,
  Address,
  OutPoint,
  Cell,
  WitnessArgs,
  CellCollector as CellCollectorType,
  CellProvider,
  QueryOptions,
  PackedSince,
} from "@ckb-lumos/base";
import { getConfig, Config } from "@ckb-lumos/config-manager";
const { ScriptValue } = values;
import { normalizers, Reader } from "@ckb-lumos/toolkit";
import { Set } from "immutable";
import {
  addCellDep,
  ensureScript,
  SECP_SIGNATURE_PLACEHOLDER,
  prepareSigningEntries as _prepareSigningEntries,
  isSecp256k1Blake160MultisigScript,
} from "./helper";
import {
  FromInfo,
  parseFromInfo,
  MultisigScript,
  serializeMultisigScript,
  multisigArgs,
} from "./from_info";
import { BI, BIish } from "@ckb-lumos/bi";

export { serializeMultisigScript, multisigArgs };

export class CellCollector implements CellCollectorType {
  private cellCollector: CellCollectorType;
  private config: Config;
  public readonly fromScript: Script;
  public readonly multisigScript?: HexString;

  constructor(
    fromInfo: FromInfo,
    cellProvider: CellProvider,
    {
      config = undefined,
      queryOptions = {},
    }: Options & {
      queryOptions?: QueryOptions;
    } = {}
  ) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }
    config = config || getConfig();
    const result = parseFromInfo(fromInfo, { config });
    this.fromScript = result.fromScript;
    this.multisigScript = result.multisigScript;

    this.config = config;

    queryOptions = {
      ...queryOptions,
      lock: this.fromScript,
      type: queryOptions.type || "empty",
    };

    this.cellCollector = cellProvider.collector(queryOptions);
  }

  async *collect(): AsyncGenerator<Cell> {
    if (!isSecp256k1Blake160MultisigScript(this.fromScript, this.config)) {
      return;
    }

    for await (const inputCell of this.cellCollector.collect()) {
      yield inputCell;
    }
  }
}

/**
 * Setup input cell infos, such as cell deps and witnesses.
 *
 * @param txSkeleton
 * @param inputCell
 * @param fromInfo
 * @param options
 */
export async function setupInputCell(
  txSkeleton: TransactionSkeletonType,
  inputCell: Cell,
  fromInfo?: FromInfo,
  {
    config = undefined,
    defaultWitness = "0x",
    since = undefined,
    requireMultisigScript = true,
  }: Options & {
    defaultWitness?: HexString;
    requireMultisigScript?: boolean;
    since?: PackedSince;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();

  if (requireMultisigScript && typeof fromInfo !== "object") {
    throw new Error("`fromInfo` must be MultisigScript format!");
  }

  const fromScript: Script = inputCell.cell_output.lock;

  if (fromInfo) {
    const parsedFromScript: Script = parseFromInfo(fromInfo, { config })
      .fromScript;
    if (
      !new ScriptValue(parsedFromScript, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    ) {
      throw new Error("`fromInfo` not match to input lock!");
    }
  }

  if (!isSecp256k1Blake160MultisigScript(fromScript, config)) {
    throw new Error(`Not SECP256K1_BLAKE160_MULTISIG input!`);
  }

  // add inputCell to txSkeleton
  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(inputCell);
  });

  if (since) {
    txSkeleton = txSkeleton.update("inputSinces", (inputSinces) => {
      return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
    });
  }

  txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
    return witnesses.push(defaultWitness);
  });

  const outputCell: Cell = {
    cell_output: {
      capacity: inputCell.cell_output.capacity,
      lock: inputCell.cell_output.lock,
      type: inputCell.cell_output.type,
    },
    data: inputCell.data,
  };

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(outputCell);
  });

  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
  if (!template) {
    throw new Error(
      `SECP256K1_BLAKE160_MULTISIG script not defined in config!`
    );
  }

  const scriptOutPoint: OutPoint = {
    tx_hash: template.TX_HASH,
    index: template.INDEX,
  };

  // add cell dep
  txSkeleton = addCellDep(txSkeleton, {
    out_point: scriptOutPoint,
    dep_type: template.DEP_TYPE,
  });

  // add witness
  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript!, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
    }

    const firstIndexWitness = txSkeleton.get("witnesses").get(firstIndex)!;
    // If never prepared witness of this lock script before, should using fromInfo(MultisigScript) to update witness
    if (firstIndexWitness === "0x" && typeof fromInfo !== "object") {
      throw new Error("`fromInfo` must be MultisigScript format!");
    }

    // if using MultisigScript, check witnesses
    if (typeof fromInfo === "object") {
      const multisigScript: HexString = parseFromInfo(fromInfo, { config })
        .multisigScript!;
      let witness = txSkeleton.get("witnesses").get(firstIndex)!;
      const newWitnessArgs: WitnessArgs = {
        lock:
          "0x" +
          multisigScript.slice(2) +
          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(
            (fromInfo as MultisigScript).M
          ),
      };
      if (witness !== "0x") {
        const witnessArgs = new core.WitnessArgs(new Reader(witness));
        const lock = witnessArgs.getLock();
        if (
          lock.hasValue() &&
          new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock
        ) {
          throw new Error(
            "Lock field in first witness is set aside for signature!"
          );
        }
        const inputType = witnessArgs.getInputType();
        if (inputType.hasValue()) {
          newWitnessArgs.input_type = new Reader(
            inputType.value().raw()
          ).serializeJson();
        }
        const outputType = witnessArgs.getOutputType();
        if (outputType.hasValue()) {
          newWitnessArgs.output_type = new Reader(
            outputType.value().raw()
          ).serializeJson();
        }
      }
      witness = new Reader(
        core.SerializeWitnessArgs(
          normalizers.NormalizeWitnessArgs(newWitnessArgs)
        )
      ).serializeJson();
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.set(firstIndex, witness)
      );
    }
  }

  return txSkeleton;
}

export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  toAddress: Address | undefined,
  amount: bigint,
  options?: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: true;
  }
): Promise<TransactionSkeletonType>;

export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  toAddress: Address | undefined,
  amount: bigint,
  options: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough: false;
  }
): Promise<[TransactionSkeletonType, bigint]>;

/**
 * transfer capacity from multisig script cells
 *
 * @param txSkeleton
 * @param fromInfo fromAddress or fromMultisigScript, if this address new to txSkeleton inputs, must use fromMultisigScript
 * @param toAddress
 * @param amount transfer CKB capacity in shannon.
 * @param options
 */
export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  toAddress: Address | undefined,
  amount: bigint,
  {
    config = undefined,
    requireToAddress = true,
    assertAmountEnough = true,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: boolean;
  } = {}
): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {
  const result = await transferCompatible(
    txSkeleton,
    fromInfo,
    toAddress,
    amount,
    {
      config,
      requireToAddress,
      assertAmountEnough: assertAmountEnough as true | undefined,
    }
  );
  let _txSkeleton: TransactionSkeletonType;
  let _amount: bigint;
  if (result instanceof Array) {
    _txSkeleton = result[0];
    _amount = BigInt(result[1].toString());
    return [_txSkeleton, _amount];
  } else {
    _txSkeleton = result;
    return _txSkeleton;
  }
}
export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  toAddress: Address | undefined,
  amount: BIish,
  options?: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: true;
  }
): Promise<TransactionSkeletonType>;

export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  toAddress: Address | undefined,
  amount: BIish,
  options: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough: false;
  }
): Promise<[TransactionSkeletonType, BI]>;

export async function transferCompatible(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  toAddress: Address | undefined,
  amount: BIish,
  {
    config = undefined,
    requireToAddress = true,
    assertAmountEnough = true,
  }: {
    config?: Config;
    requireToAddress?: boolean;
    assertAmountEnough?: boolean;
  } = {}
): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {
  config = config || getConfig();
  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
  if (!template) {
    throw new Error(
      "Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!"
    );
  }
  const scriptOutPoint: OutPoint = {
    tx_hash: template.TX_HASH,
    index: template.INDEX,
  };

  txSkeleton = addCellDep(txSkeleton, {
    out_point: scriptOutPoint,
    dep_type: template.DEP_TYPE,
  });

  const { fromScript, multisigScript } = parseFromInfo(fromInfo, { config });

  ensureScript(fromScript, config, "SECP256K1_BLAKE160_MULTISIG");

  const noMultisigBefore = !txSkeleton.get("inputs").find((i) => {
    return new ScriptValue(i.cell_output.lock, { validate: false }).equals(
      new ScriptValue(fromScript!, { validate: false })
    );
  });

  if (noMultisigBefore && fromInfo === "string") {
    throw new Error("MultisigScript is required for witness!");
  }

  if (requireToAddress && !toAddress) {
    throw new Error("You must provide a to address!");
  }

  let _amount = amount ? BI.from(amount) : BI.from(0);
  if (toAddress) {
    const toScript = parseAddress(toAddress, { config });

    txSkeleton = txSkeleton.update("outputs", (outputs) => {
      return outputs.push({
        cell_output: {
          capacity: "0x" + _amount.toString(16),
          lock: toScript,
          type: undefined,
        },
        data: "0x",
        out_point: undefined,
        block_hash: undefined,
      });
    });
  }

  const lastFreezedOutput = txSkeleton
    .get("fixedEntries")
    .filter(({ field }) => field === "outputs")
    .maxBy(({ index }) => index);
  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
  for (; i < txSkeleton.get("outputs").size && _amount.gt(0); ++i) {
    const output = txSkeleton.get("outputs").get(i)!;
    if (
      new ScriptValue(output.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    ) {
      const cellCapacity = BI.from(output.cell_output.capacity);
      let deductCapacity;
      if (_amount.gte(cellCapacity)) {
        deductCapacity = cellCapacity;
      } else {
        deductCapacity = cellCapacity.sub(
          minimalCellCapacityCompatible(output)
        );
        if (deductCapacity.gt(_amount)) {
          deductCapacity = _amount;
        }
      }
      _amount = _amount.sub(deductCapacity);
      output.cell_output.capacity =
        "0x" + cellCapacity.sub(deductCapacity).toString(16);
    }
  }
  // remove all output cells with capacity equal to 0
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.filter(
      (output) => !BI.from(output.cell_output.capacity).eq(0)
    );
  });
  /*
   * Collect and add new input cells so as to prepare remaining capacities.
   */
  if (_amount.gt(0)) {
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) {
      throw new Error("cell provider is missing!");
    }
    // TODO: ignore locktime now.
    const cellCollector = cellProvider.collector({
      lock: fromScript,
    });
    const changeCell: Cell = {
      cell_output: {
        capacity: "0x0",
        lock: fromScript,
        type: undefined,
      },
      data: "0x",
      out_point: undefined,
      block_hash: undefined,
    };
    let changeCapacity = BI.from(0);
    let previousInputs = Set<string>();
    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(
        `${input.out_point!.tx_hash}_${input.out_point!.index}`
      );
    }
    for await (const inputCell of cellCollector.collect()) {
      // skip inputs already exists in txSkeleton.inputs
      if (
        previousInputs.has(
          `${inputCell.out_point!.tx_hash}_${inputCell.out_point!.index}`
        )
      ) {
        continue;
      }
      txSkeleton = txSkeleton.update("inputs", (inputs) =>
        inputs.push(inputCell)
      );
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
      const inputCapacity = BI.from(inputCell.cell_output.capacity);
      let deductCapacity = inputCapacity;
      if (deductCapacity.gt(_amount)) {
        deductCapacity = _amount;
      }
      _amount = _amount.sub(deductCapacity);
      changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));
      if (
        _amount.eq(0) &&
        (changeCapacity.eq(0) ||
          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))
      ) {
        break;
      }
    }
    if (changeCapacity.gt(0)) {
      changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
      txSkeleton = txSkeleton.update("outputs", (outputs) =>
        outputs.push(changeCell)
      );
    }
  }
  if (_amount.gt(0) && assertAmountEnough) {
    throw new Error("Not enough capacity in from address!");
  }

  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cell_output.lock, { validate: false }).equals(
        new ScriptValue(fromScript!, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (BI.from(firstIndex).gte(txSkeleton.get("witnesses").size)) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.push("0x")
      );
    }

    // if using MultisigScript, check witnesses
    if (noMultisigBefore || typeof fromInfo !== "string") {
      let witness = txSkeleton.get("witnesses").get(firstIndex)!;
      const newWitnessArgs: WitnessArgs = {
        lock:
          "0x" +
          multisigScript!.slice(2) +
          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(
            (fromInfo as MultisigScript).M
          ),
      };
      if (witness !== "0x") {
        const witnessArgs = new core.WitnessArgs(new Reader(witness));
        const lock = witnessArgs.getLock();
        if (
          lock.hasValue() &&
          new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock
        ) {
          throw new Error(
            "Lock field in first witness is set aside for signature!"
          );
        }
        const inputType = witnessArgs.getInputType();
        if (inputType.hasValue()) {
          newWitnessArgs.input_type = new Reader(
            inputType.value().raw()
          ).serializeJson();
        }
        const outputType = witnessArgs.getOutputType();
        if (outputType.hasValue()) {
          newWitnessArgs.output_type = new Reader(
            outputType.value().raw()
          ).serializeJson();
        }
      }
      witness = new Reader(
        core.SerializeWitnessArgs(
          normalizers.NormalizeWitnessArgs(newWitnessArgs)
        )
      ).serializeJson();
      txSkeleton = txSkeleton.update("witnesses", (witnesses) =>
        witnesses.set(firstIndex, witness)
      );
    }
  }
  if (!assertAmountEnough) {
    return [txSkeleton, BI.from(_amount)];
  }
  return txSkeleton;
}

/**
 * pay fee by multisig script cells
 *
 * @param txSkeleton
 * @param fromInfo
 * @param amount fee in shannon
 * @param options
 */
export async function payFee(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  amount: BIish,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  return transferCompatible(txSkeleton, fromInfo, undefined, amount, {
    config,
    requireToAddress: false,
  });
}

/**
 * Inject capacity from `fromInfo` to target output.
 *
 * @param txSkeleton
 * @param outputIndex
 * @param fromInfo
 * @param options
 */
export async function injectCapacity(
  txSkeleton: TransactionSkeletonType,
  outputIndex: number,
  fromInfo: FromInfo,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  if (outputIndex >= txSkeleton.get("outputs").size) {
    throw new Error("Invalid output index!");
  }
  const capacity = BI.from(
    txSkeleton.get("outputs").get(outputIndex)!.cell_output.capacity
  );
  return transferCompatible(txSkeleton, fromInfo, undefined, capacity, {
    config,
    requireToAddress: false,
  });
}

/**
 * prepare for txSkeleton signingEntries, will update txSkeleton.get("signingEntries")
 *
 * @param txSkeleton
 * @param options
 */
export function prepareSigningEntries(
  txSkeleton: TransactionSkeletonType,
  { config = undefined }: Options = {}
): TransactionSkeletonType {
  config = config || getConfig();

  return _prepareSigningEntries(
    txSkeleton,
    config,
    "SECP256K1_BLAKE160_MULTISIG"
  );
}

export default {
  transfer,
  transferCompatible,
  payFee,
  prepareSigningEntries,
  serializeMultisigScript,
  multisigArgs,
  injectCapacity,
  setupInputCell,
  CellCollector,
};

'''
'''--- packages/common-scripts/src/sudt.ts ---
import { addCellDep, isAcpScript } from "./helper";
import {
  utils,
  Hash,
  Address,
  Cell,
  Script,
  Header,
  CellCollector as CellCollectorInterface,
  values,
} from "@ckb-lumos/base";
const { toBigUInt128LE, computeScriptHash } = utils;
import secp256k1Blake160Multisig from "./secp256k1_blake160_multisig";
import { FromInfo, parseFromInfo } from "./from_info";
import common from "./common";
import {
  parseAddress,
  TransactionSkeletonType,
  Options,
  minimalCellCapacityCompatible,
} from "@ckb-lumos/helpers";
import { Set, List } from "immutable";
import { getConfig, Config } from "@ckb-lumos/config-manager";
import { CellCollector as LocktimeCellCollector } from "./locktime_pool";
import anyoneCanPay, {
  CellCollector as AnyoneCanPayCellCollector,
} from "./anyone_can_pay";
const { ScriptValue } = values;
import secp256k1Blake160 from "./secp256k1_blake160";
import { readBigUInt128LECompatible } from "@ckb-lumos/base/lib/utils";
import { BI, BIish } from "@ckb-lumos/bi";

export type Token = Hash;

/**
 * Issue an sUDT cell
 *
 * @param txSkeleton
 * @param fromInfo
 * @param amount
 * @param capacity
 * @param tipHeader
 * @param options
 */
export async function issueToken(
  txSkeleton: TransactionSkeletonType,
  fromInfo: FromInfo,
  amount: BIish,
  capacity?: BIish,
  tipHeader?: Header,
  { config = undefined }: Options = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  const template = config.SCRIPTS.SUDT;

  if (!template) {
    throw new Error("Provided config does not have SUDT script setup!");
  }

  txSkeleton = addCellDep(txSkeleton, {
    out_point: {
      tx_hash: template.TX_HASH,
      index: template.INDEX,
    },
    dep_type: template.DEP_TYPE,
  });

  const fromScript = parseFromInfo(fromInfo, { config }).fromScript;

  const toScript = fromScript;

  const sudtTypeScript = {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args: computeScriptHash(fromScript),
  };

  const targetOutput: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: toScript,
      type: sudtTypeScript,
    },
    data: toBigUInt128LE(amount),
    out_point: undefined,
    block_hash: undefined,
  };

  if (!capacity) {
    capacity = minimalCellCapacityCompatible(targetOutput);
  }
  let _capacity = BI.from(capacity);
  targetOutput.cell_output.capacity = "0x" + _capacity.toString(16);

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(targetOutput);
  });

  const outputIndex = txSkeleton.get("outputs").size - 1;

  // fix entry
  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push({
      field: "outputs",
      index: outputIndex,
    });
  });

  txSkeleton = await common.injectCapacity(
    txSkeleton,
    [fromInfo],
    BI.from(BI.from(targetOutput.cell_output.capacity)),
    undefined,
    tipHeader,
    {
      config,
    }
  );

  return txSkeleton;
}

/**
 *
 * @param txSkeleton
 * @param fromInfos
 * @param sudtToken
 * @param toAddress
 * @param amount
 * @param changeAddress if not provided, will use first fromInfo
 * @param capacity
 * @param tipHeader
 * @param options When `splitChangeCell = true` && change amount > 0 && change capacity >= minimalCellCapacity(change cell with sudt) + minimalCellCapacity(change cell without sudt), change cell will split to two change cells, one with sudt and one without.
 */
export async function transfer(
  txSkeleton: TransactionSkeletonType,
  fromInfos: FromInfo[],
  sudtToken: Token,
  toAddress: Address,
  amount: BIish,
  changeAddress?: Address,
  capacity?: BIish,
  tipHeader?: Header,
  {
    config = undefined,
    LocktimePoolCellCollector = LocktimeCellCollector,
    splitChangeCell = false,
  }: Options & {
    LocktimePoolCellCollector?: any;
    splitChangeCell?: boolean;
  } = {}
): Promise<TransactionSkeletonType> {
  config = config || getConfig();
  let _amount = BI.from(amount);
  let _capacity = capacity ? BI.from(capacity) : undefined;

  const SUDT_SCRIPT = config.SCRIPTS.SUDT;

  if (!SUDT_SCRIPT) {
    throw new Error("Provided config does not have SUDT script setup!");
  }

  if (fromInfos.length === 0) {
    throw new Error("`fromInfos` can't be empty!");
  }

  if (!toAddress) {
    throw new Error("You must provide a to address!");
  }
  const toScript = parseAddress(toAddress, { config });

  const fromScripts: Script[] = fromInfos.map(
    (fromInfo) => parseFromInfo(fromInfo, { config }).fromScript
  );
  const changeOutputLockScript = changeAddress
    ? parseAddress(changeAddress, { config })
    : fromScripts[0];

  if (_amount.lte(0)) {
    throw new Error("amount must be greater than 0");
  }

  const sudtType = _generateSudtScript(sudtToken, config);

  const cellProvider = txSkeleton.get("cellProvider");
  if (!cellProvider) {
    throw new Error("Cell provider is missing!");
  }

  // if toScript is an anyone-can-pay script
  let toAddressInputCapacity: BI = BI.from(0);
  let toAddressInputAmount: BI = BI.from(0);
  if (isAcpScript(toScript, config)) {
    const toAddressCellCollector = new AnyoneCanPayCellCollector(
      toAddress,
      cellProvider,
      {
        config,
        queryOptions: {
          type: sudtType,
          data: "any",
        },
      }
    );

    const toAddressInput: Cell | void = (
      await toAddressCellCollector.collect().next()
    ).value;
    if (!toAddressInput) {
      throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);
    }

    txSkeleton = txSkeleton.update("inputs", (inputs) => {
      return inputs.push(toAddressInput);
    });

    txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
      return witnesses.push("0x");
    });

    toAddressInputCapacity = BI.from(toAddressInput.cell_output.capacity);
    toAddressInputAmount = BI.from(
      readBigUInt128LECompatible(toAddressInput.data)
    );
  }

  const targetOutput: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: toScript,
      type: sudtType,
    },
    data: toBigUInt128LE(_amount.toString()),
    out_point: undefined,
    block_hash: undefined,
  };
  if (isAcpScript(toScript, config)) {
    if (!_capacity) {
      _capacity = BI.from(0);
    }
    targetOutput.cell_output.capacity =
      "0x" + toAddressInputCapacity.add(_capacity).toString(16);
    targetOutput.data = toBigUInt128LE(toAddressInputAmount.add(_amount));
  } else {
    if (!_capacity) {
      _capacity = BI.from(minimalCellCapacityCompatible(targetOutput));
    }
    targetOutput.cell_output.capacity = "0x" + _capacity.toString(16);
  }

  // collect cells with which includes sUDT info
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(targetOutput);
  });

  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push({
      field: "outputs",
      index: txSkeleton.get("outputs").size - 1,
    });
  });

  txSkeleton = addCellDep(txSkeleton, {
    out_point: {
      tx_hash: SUDT_SCRIPT.TX_HASH,
      index: SUDT_SCRIPT.INDEX,
    },
    dep_type: SUDT_SCRIPT.DEP_TYPE,
  });

  // collect cells
  const changeCell: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: changeOutputLockScript,
      type: sudtType,
    },
    data: toBigUInt128LE(BI.from(0).toString()),
    out_point: undefined,
    block_hash: undefined,
  };
  const changeCellWithoutSudt: Cell = {
    cell_output: {
      capacity: "0x0",
      lock: changeOutputLockScript,
      type: undefined,
    },
    data: "0x",
    out_point: undefined,
    block_hash: undefined,
  };
  let changeCapacity = BI.from(0);
  let changeAmount = BI.from(0);
  let previousInputs = Set<string>();
  for (const input of txSkeleton.get("inputs")) {
    previousInputs = previousInputs.add(
      `${input.out_point!.tx_hash}_${input.out_point!.index}`
    );
  }
  let cellCollectorInfos: List<{
    cellCollector: CellCollectorInterface;
    index: number;
    isAnyoneCanPay?: boolean;
    destroyable?: boolean;
  }> = List();
  if (tipHeader) {
    fromInfos.forEach((fromInfo, index) => {
      const locktimePoolCellCollector = new LocktimePoolCellCollector(
        fromInfo,
        cellProvider,
        {
          config,
          tipHeader,
          queryOptions: {
            type: sudtType,
            data: "any",
          },
        }
      );

      cellCollectorInfos = cellCollectorInfos.push({
        cellCollector: locktimePoolCellCollector,
        index,
      });
    });
  }
  fromInfos.forEach((fromInfo, index) => {
    const secpCollector = new secp256k1Blake160.CellCollector(
      fromInfo,
      cellProvider,
      {
        config,
        queryOptions: {
          type: sudtType,
          data: "any",
        },
      }
    );
    const multisigCollector = new secp256k1Blake160Multisig.CellCollector(
      fromInfo,
      cellProvider,
      {
        config,
        queryOptions: {
          type: sudtType,
          data: "any",
        },
      }
    );
    const acpCollector = new anyoneCanPay.CellCollector(
      fromInfo,
      cellProvider,
      {
        config,
        queryOptions: {
          type: sudtType,
          data: "any",
        },
      }
    );

    cellCollectorInfos = cellCollectorInfos.push(
      {
        cellCollector: secpCollector,
        index,
      },
      {
        cellCollector: multisigCollector,
        index,
      },
      {
        cellCollector: acpCollector,
        index,
        isAnyoneCanPay: true,
        destroyable: parseFromInfo(fromInfo, { config }).destroyable,
      }
    );
  });
  if (tipHeader) {
    fromInfos.forEach((fromInfo, index) => {
      const locktimeCellCollector = new LocktimePoolCellCollector(
        fromInfo,
        cellProvider,
        {
          config,
          tipHeader,
        }
      );

      cellCollectorInfos = cellCollectorInfos.push({
        cellCollector: locktimeCellCollector,
        index,
      });
    });
  }
  fromInfos.forEach((fromInfo, index) => {
    const secpCollector = new secp256k1Blake160.CellCollector(
      fromInfo,
      cellProvider,
      {
        config,
      }
    );
    const multisigCollector = new secp256k1Blake160Multisig.CellCollector(
      fromInfo,
      cellProvider,
      {
        config,
      }
    );
    const acpCollector = new anyoneCanPay.CellCollector(
      fromInfo,
      cellProvider,
      {
        config,
      }
    );

    cellCollectorInfos = cellCollectorInfos.push(
      {
        cellCollector: secpCollector,
        index,
      },
      {
        cellCollector: multisigCollector,
        index,
      },
      {
        cellCollector: acpCollector,
        index,
        isAnyoneCanPay: true,
        destroyable: parseFromInfo(fromInfo, { config }).destroyable,
      }
    );
  });
  for (const {
    index,
    cellCollector,
    isAnyoneCanPay,
    destroyable,
  } of cellCollectorInfos) {
    for await (const inputCell of cellCollector.collect()) {
      // skip inputs already exists in txSkeleton.inputs
      const key = `${inputCell.out_point!.tx_hash}_${
        inputCell.out_point!.index
      }`;
      if (previousInputs.has(key)) {
        continue;
      }
      previousInputs = previousInputs.add(key);

      const fromInfo = fromInfos[index];
      txSkeleton = await common.setupInputCell(
        txSkeleton,
        inputCell,
        fromInfo,
        {
          config,
        }
      );
      // remove output which added by `setupInputCell`
      const lastOutputIndex: number = txSkeleton.get("outputs").size - 1;
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.remove(lastOutputIndex);
      });
      // remove output fixedEntry
      const fixedEntryIndex: number = txSkeleton
        .get("fixedEntries")
        .findIndex((fixedEntry) => {
          return (
            fixedEntry.field === "outputs" &&
            fixedEntry.index === lastOutputIndex
          );
        });
      if (fixedEntryIndex >= 0) {
        txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
          return fixedEntries.remove(fixedEntryIndex);
        });
      }

      const inputCapacity: BI = BI.from(inputCell.cell_output.capacity);
      const inputAmount: BI = inputCell.cell_output.type
        ? BI.from(readBigUInt128LECompatible(inputCell.data))
        : BI.from(0);
      let deductCapacity: BI =
        isAnyoneCanPay && !destroyable
          ? inputCapacity.sub(minimalCellCapacityCompatible(inputCell))
          : inputCapacity;
      let deductAmount: BI = inputAmount;
      if (deductCapacity.gt(_capacity)) {
        deductCapacity = BI.from(_capacity);
      }
      _capacity = _capacity.sub(deductCapacity);
      const currentChangeCapacity: BI = inputCapacity.sub(deductCapacity);
      if (!isAnyoneCanPay || (isAnyoneCanPay && destroyable)) {
        changeCapacity = changeCapacity.add(currentChangeCapacity);
      }
      if (deductAmount.gt(_amount)) {
        deductAmount = _amount;
      }
      _amount = _amount.sub(deductAmount);
      const currentChangeAmount: BI = inputAmount.sub(deductAmount);
      if (!isAnyoneCanPay || (isAnyoneCanPay && destroyable)) {
        changeAmount = changeAmount.add(currentChangeAmount);
      }

      if (isAnyoneCanPay && !destroyable) {
        const acpChangeCell: Cell = {
          cell_output: {
            capacity: "0x" + currentChangeCapacity.toString(16),
            lock: inputCell.cell_output.lock,
            type: inputCell.cell_output.type,
          },
          data: inputCell.cell_output.type
            ? toBigUInt128LE(currentChangeAmount.toString())
            : "0x",
        };

        txSkeleton = txSkeleton.update("outputs", (outputs) => {
          return outputs.push(acpChangeCell);
        });

        if (inputCell.cell_output.type) {
          txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
            return fixedEntries.push({
              field: "outputs",
              index: txSkeleton.get("outputs").size - 1,
            });
          });
        }
      }

      // changeAmount = 0n, the change output no need to include sudt type script
      if (
        _capacity.eq(0) &&
        _amount.eq(0) &&
        ((changeCapacity.eq(0) && changeAmount.eq(0)) ||
          (changeCapacity.gt(
            minimalCellCapacityCompatible(changeCellWithoutSudt)
          ) &&
            changeAmount.eq(0)))
      ) {
        changeCell.cell_output.type = undefined;
        changeCell.data = "0x";
        break;
      }
      if (
        _capacity.eq(0) &&
        _amount.eq(0) &&
        changeCapacity.gt(
          minimalCellCapacityCompatible(changeCellWithoutSudt)
        ) &&
        changeAmount.gt(0)
      ) {
        break;
      }
    }
  }

  // if change cell is an anyone-can-pay cell and exists in txSkeleton.get("outputs") and not in fixedEntries
  // 1. change lock script is acp
  // 2. lock and type are equal to output OutputA in outputs
  // 3. OutputA is not fixed.
  let changeOutputIndex = -1;
  if (
    isAcpScript(changeCell.cell_output.lock, config) &&
    (changeOutputIndex = txSkeleton.get("outputs").findIndex((output) => {
      return (
        new ScriptValue(changeCell.cell_output.lock, {
          validate: false,
        }).equals(
          new ScriptValue(output.cell_output.lock, { validate: false })
        ) &&
        ((changeAmount.eq(0) &&
          !changeCell.cell_output.type &&
          !output.cell_output.type) ||
          (changeAmount.gte(0) &&
            !!changeCell.cell_output.type &&
            !!output.cell_output.type &&
            new ScriptValue(changeCell.cell_output.type, {
              validate: false,
            }).equals(
              new ScriptValue(output.cell_output.type, { validate: false })
            )))
      );
    })) !== -1 &&
    txSkeleton.get("fixedEntries").findIndex((fixedEntry) => {
      return (
        fixedEntry.field === "output" && fixedEntry.index === changeOutputIndex
      );
    }) === -1
  ) {
    const originOutput: Cell = txSkeleton
      .get("outputs")
      .get(changeOutputIndex)!;
    const clonedOutput: Cell = JSON.parse(JSON.stringify(originOutput));
    clonedOutput.cell_output.capacity =
      "0x" +
      BI.from(originOutput.cell_output.capacity)
        .add(changeCapacity)
        .toString(16);
    if (changeAmount.gt(0)) {
      clonedOutput.data = toBigUInt128LE(
        readBigUInt128LECompatible(originOutput.data).add(changeAmount)
      );
    }

    const minimalChangeCellCapcaity = BI.from(
      minimalCellCapacityCompatible(changeCell)
    );
    const minimalChangeCellWithoutSudtCapacity = BI.from(
      minimalCellCapacityCompatible(changeCellWithoutSudt)
    );
    let splitFlag: boolean = false;
    if (
      changeAmount.gt(0) &&
      splitChangeCell &&
      changeCapacity.gte(
        minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity)
      )
    ) {
      clonedOutput.cell_output.capacity = originOutput.cell_output.capacity;
      changeCellWithoutSudt.cell_output.capacity =
        "0x" + changeCapacity.toString(16);
      splitFlag = true;
    }

    txSkeleton = txSkeleton.update("outputs", (outputs) => {
      return outputs.set(changeOutputIndex, clonedOutput);
    });

    if (splitFlag) {
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(changeCellWithoutSudt);
      });
    }
  } else if (changeCapacity.gte(minimalCellCapacityCompatible(changeCell))) {
    changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
    if (changeAmount.gt(0)) {
      changeCell.data = toBigUInt128LE(changeAmount.toString());
    }

    const minimalChangeCellCapcaity = BI.from(
      minimalCellCapacityCompatible(changeCell)
    );
    const minimalChangeCellWithoutSudtCapacity = BI.from(
      minimalCellCapacityCompatible(changeCellWithoutSudt)
    );
    let splitFlag = false;
    if (changeAmount.gt(0) && splitChangeCell) {
      if (
        changeCapacity.gte(
          minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity)
        )
      ) {
        changeCell.cell_output.capacity =
          "0x" + minimalChangeCellCapcaity.toString(16);
        changeCellWithoutSudt.cell_output.capacity =
          "0x" + changeCapacity.sub(minimalChangeCellCapcaity).toString(16);
        splitFlag = true;
      }
    }

    txSkeleton = txSkeleton.update("outputs", (outputs) =>
      outputs.push(changeCell)
    );
    if (changeAmount.gt(0)) {
      txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
        return fixedEntries.push({
          field: "outputs",
          index: txSkeleton.get("outputs").size - 1,
        });
      });
    }
    if (splitFlag) {
      txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(changeCellWithoutSudt);
      });
    }
  } else if (
    changeAmount.gt(0) &&
    changeCapacity.lt(minimalCellCapacityCompatible(changeCell))
  ) {
    throw new Error("Not enough capacity for change in from infos!");
  }
  if (_capacity.gt(0)) {
    throw new Error("Not enough capacity in from infos!");
  }
  if (_amount.gt(0)) {
    throw new Error("Not enough amount in from infos!");
  }

  return txSkeleton;
}

function _generateSudtScript(token: Hash, config: Config): Script {
  const SUDT_SCRIPT = config.SCRIPTS.SUDT!;
  // TODO: check token is a valid hash
  return {
    code_hash: SUDT_SCRIPT.CODE_HASH,
    hash_type: SUDT_SCRIPT.HASH_TYPE,
    args: token,
  };
}

/**
 * Compute sudt token by owner from info.
 *
 * @param fromInfo
 * @param options
 */
export function ownerForSudt(
  fromInfo: FromInfo,
  { config = undefined }: Options = {}
): Token {
  config = config || getConfig();
  const { fromScript } = parseFromInfo(fromInfo, { config });
  const lockHash = computeScriptHash(fromScript);
  return lockHash;
}

export default {
  issueToken,
  transfer,
  ownerForSudt,
};

'''
'''--- packages/common-scripts/tests/account_info.ts ---
export const bob = {
  mainnetAddress: "ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd",
  testnetAddress: "ckt1qyqrdsefa43s6m882pcj53m4gdnj4k440axqswmu83",
  blake160: "0x36c329ed630d6ce750712a477543672adab57f4c",
  multisigTestnetAddress: "ckt1qyq4du5pk02tkh788363w990p0mcaw9t5rvq8ywwns",
  multisigArgs: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
  acpTestnetAddress:
    "ckt1qs6pngwqn6e9vlm92th84rk0l4jp2h8lurchjmnwv8kq3rt5psf4vdkr98kkxrtvuag8z2j8w4pkw2k6k4l5ca50gs9",
  secpLockHash:
    "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
  get fromInfo() {
    return {
      R: 0,
      M: 1,
      publicKeyHashes: [this.blake160],
    };
  },
};

export const alice = {
  mainnetAddress: "ckb1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gq5f9mxs",
  testnetAddress: "ckt1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gqfvmy2v",
  blake160: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
  multisigTestnetAddress: "ckt1qyq4zqqvh8alx39hhunc930tmhaqlrtnvkcqnp5xln",
  acpTestnetAddress:
    "ckt1qs6pngwqn6e9vlm92th84rk0l4jp2h8lurchjmnwv8kq3rt5psf4dcse8h6367zpzcqhj6e4k9a5lrevmpdaqsy58dz",
  get fromInfo() {
    return {
      R: 0,
      M: 1,
      publicKeyHashes: [this.blake160],
    };
  },
};

export const fullAddressInfo = {
  mainnetAddress:
    "ckb1qsqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpvumhs9nvu786dj9p0q5elx66t24n3kxgmz0sxt",
  testnetAddress:
    "ckt1qsqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpvumhs9nvu786dj9p0q5elx66t24n3kxgkpkap5",
  lock: {
    code_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    hash_type: "type",
    args: "0xb39bbc0b3673c7d36450bc14cfcdad2d559c6c64",
  },
};

'''
'''--- packages/common-scripts/tests/anyone_can_pay.test.ts ---
import test from "ava";
import { anyoneCanPay } from "../src";
import { CellProvider } from "./cell_provider";
import {
  TransactionSkeletonType,
  TransactionSkeleton,
  minimalCellCapacityCompatible,
} from "@ckb-lumos/helpers";
import { predefined } from "@ckb-lumos/config-manager";
import { bob, alice } from "./account_info";
import { bobAcpCells, aliceAcpCells } from "./inputs";
import { Cell, values } from "@ckb-lumos/base";
const { AGGRON4 } = predefined;
import { checkLimit } from "../src/anyone_can_pay";
import { BI } from "@ckb-lumos/bi";
test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});
test("withdraw, acp to acp, all", async (t) => {
  const cellProvider = new CellProvider([bobAcpCells[0], aliceAcpCells[0]]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  txSkeleton = await anyoneCanPay.withdraw(
    txSkeleton,
    bobAcpCells[0],
    alice.acpTestnetAddress,
    BI.from(BI.from(1000 * 10 ** 8)),
    { config: AGGRON4 }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("cellDeps").size, 1);
  t.is(
    txSkeleton.get("cellDeps").get(0)!.out_point.tx_hash,
    AGGRON4.SCRIPTS.ANYONE_CAN_PAY!.TX_HASH
  );

  t.is(txSkeleton.get("headerDeps").size, 0);

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 1);

  t.deepEqual(
    txSkeleton
      .get("inputs")
      .map((i) => i.cell_output.lock.args)
      .toArray(),
    [alice.blake160, bob.blake160]
  );

  t.deepEqual(
    txSkeleton
      .get("outputs")
      .map((o) => o.cell_output.lock.args)
      .toArray(),
    [alice.blake160]
  );

  t.is(txSkeleton.get("witnesses").size, 2);
  t.is(txSkeleton.get("witnesses").get(0), "0x");

  txSkeleton = anyoneCanPay.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0xf862243671a339a33e5843877e88e640f848b6f2394a3995bc00b44bf9d19d4e";

  t.is(txSkeleton.get("signingEntries").get(0)!.message, expectedMessage);
});

test("withdraw, acp to acp, half", async (t) => {
  const cellProvider = new CellProvider([...bobAcpCells, ...aliceAcpCells]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const capacity = BI.from(500 * 10 ** 8);
  txSkeleton = await anyoneCanPay.withdraw(
    txSkeleton,
    bobAcpCells[0],
    alice.acpTestnetAddress,
    BI.from(capacity),
    { config: AGGRON4 }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("cellDeps").size, 1);
  t.is(
    txSkeleton.get("cellDeps").get(0)!.out_point.tx_hash,
    AGGRON4.SCRIPTS.ANYONE_CAN_PAY!.TX_HASH
  );

  t.is(txSkeleton.get("headerDeps").size, 0);

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 2);

  t.deepEqual(
    txSkeleton
      .get("inputs")
      .map((i) => i.cell_output.lock.args)
      .toArray(),
    [alice.blake160, bob.blake160]
  );

  t.deepEqual(
    txSkeleton
      .get("outputs")
      .map((o) => o.cell_output.lock.args)
      .toArray(),
    [alice.blake160, bob.blake160]
  );

  const aliceReceiveCapacity: BI = BI.from(
    txSkeleton.get("outputs").get(0)!.cell_output.capacity
  ).sub(BI.from(txSkeleton.get("inputs").get(0)!.cell_output.capacity));

  t.is(aliceReceiveCapacity.toString(), capacity.toString());

  t.is(txSkeleton.get("witnesses").size, 2);
  t.is(txSkeleton.get("witnesses").get(0), "0x");

  txSkeleton = anyoneCanPay.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0x5acf7d234fc5c9adbc9b01f4938a5efdf6efde2b0a836f4740e6a79f81b64d65";

  t.is(txSkeleton.get("signingEntries").get(0)!.message, expectedMessage);
});

test("withdraw, acp to secp, half", async (t) => {
  const cellProvider = new CellProvider([...bobAcpCells, ...aliceAcpCells]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const capacity = BI.from(500 * 10 ** 8);
  txSkeleton = await anyoneCanPay.withdraw(
    txSkeleton,
    bobAcpCells[0],
    alice.testnetAddress,
    BI.from(capacity),
    { config: AGGRON4 }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("cellDeps").size, 1);
  t.is(
    txSkeleton.get("cellDeps").get(0)!.out_point.tx_hash,
    AGGRON4.SCRIPTS.ANYONE_CAN_PAY!.TX_HASH
  );

  t.is(txSkeleton.get("headerDeps").size, 0);

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);

  t.deepEqual(
    txSkeleton
      .get("inputs")
      .map((i) => i.cell_output.lock.args)
      .toArray(),
    [bob.blake160]
  );

  t.deepEqual(
    txSkeleton
      .get("outputs")
      .map((o) => o.cell_output.lock.args)
      .toArray(),
    [alice.blake160, bob.blake160]
  );

  const aliceReceiveCapacity: BI = BI.from(
    txSkeleton.get("outputs").get(0)!.cell_output.capacity
  );

  t.is(aliceReceiveCapacity.toString(), capacity.toString());

  t.is(txSkeleton.get("witnesses").size, 1);
  t.is(
    txSkeleton.get("witnesses").get(0),
    "0x55000000100000005500000055000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  );

  txSkeleton = anyoneCanPay.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0x554307c4b5858beed7c655b3b7a5537492f532a99ef419df59c94ac7f9347e8e";

  t.is(txSkeleton.get("signingEntries").get(0)!.message, expectedMessage);
});

test("withdraw, acp to secp, all", async (t) => {
  const cellProvider = new CellProvider([...bobAcpCells, ...aliceAcpCells]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const capacity = BI.from(1000 * 10 ** 8);
  txSkeleton = await anyoneCanPay.withdraw(
    txSkeleton,
    bobAcpCells[0],
    alice.testnetAddress,
    BI.from(capacity),
    { config: AGGRON4 }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("cellDeps").size, 1);
  t.is(
    txSkeleton.get("cellDeps").get(0)!.out_point.tx_hash,
    AGGRON4.SCRIPTS.ANYONE_CAN_PAY!.TX_HASH
  );

  t.is(txSkeleton.get("headerDeps").size, 0);

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 1);

  t.deepEqual(
    txSkeleton
      .get("inputs")
      .map((i) => i.cell_output.lock.args)
      .toArray(),
    [bob.blake160]
  );

  t.deepEqual(
    txSkeleton
      .get("outputs")
      .map((o) => o.cell_output.lock.args)
      .toArray(),
    [alice.blake160]
  );

  const aliceReceiveCapacity: BI = BI.from(
    txSkeleton.get("outputs").get(0)!.cell_output.capacity
  );

  t.is(aliceReceiveCapacity.toString(), capacity.toString());

  t.is(txSkeleton.get("witnesses").size, 1);
  t.is(
    txSkeleton.get("witnesses").get(0),
    "0x55000000100000005500000055000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  );

  txSkeleton = anyoneCanPay.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0x1cb8e323da40058080ddd386ab0f6e62b793abacf68fd3da835273dd0e278c25";

  t.is(txSkeleton.get("signingEntries").get(0)!.message, expectedMessage);
});

test("withdraw, acp to secp, greater than capacity - minimal", async (t) => {
  const cellProvider = new CellProvider([...bobAcpCells, ...aliceAcpCells]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const bobCell = bobAcpCells[0]!;

  const capacity = BI.from(bobCell.cell_output.capacity)
    .sub(minimalCellCapacityCompatible(bobCell))
    .add(1);

  await t.throwsAsync(
    async () => {
      await anyoneCanPay.withdraw(
        txSkeleton,
        bobCell,
        alice.testnetAddress,
        BI.from(capacity),
        { config: AGGRON4 }
      );
    },
    null,
    "capacity must be in [0, 93900000000] or 100000000000 !"
  );
});

test("setupInputCell", async (t) => {
  const cellProvider = new CellProvider([...bobAcpCells, ...aliceAcpCells]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });
  const inputCell: Cell = bobAcpCells[0];

  txSkeleton = await anyoneCanPay.setupInputCell(
    txSkeleton,
    inputCell,
    bob.testnetAddress,
    {
      config: AGGRON4,
    }
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);

  const input: Cell = txSkeleton.get("inputs").get(0)!;
  const output: Cell = txSkeleton.get("outputs").get(0)!;

  t.is(input.cell_output.capacity, output.cell_output.capacity);
  t.is(input.data, output.data);
  t.true(
    new values.ScriptValue(input.cell_output.lock, { validate: false }).equals(
      new values.ScriptValue(output.cell_output.lock, { validate: false })
    )
  );
  t.true(
    (!input.cell_output.type && !output.cell_output.type) ||
      new values.ScriptValue(input.cell_output.type!, {
        validate: false,
      }).equals(
        new values.ScriptValue(output.cell_output.type!, { validate: false })
      )
  );
});

test("checkLimit, amount and capacity", (t) => {
  const args = bob.blake160 + "01" + "02";
  t.throws(() => checkLimit(args, BI.from(BI.from(0))));
  t.throws(() => checkLimit(args, BI.from(BI.from(10 * 10 ** 8 - 1))));
  t.notThrows(() => checkLimit(args, BI.from(BI.from(10 * 10 ** 8))));
});

test("checkLimit, only capacity", (t) => {
  const args = bob.blake160 + "01";
  t.throws(() => checkLimit(args, BI.from(BI.from(0))));
  t.throws(() => checkLimit(args, BI.from(BI.from(10 * 10 ** 8 - 1))));
  t.notThrows(() => checkLimit(args, BI.from(BI.from(10 * 10 ** 8))));
});

test("checkLimit, no limit", (t) => {
  const args = bob.blake160;
  t.notThrows(() => checkLimit(args, BI.from(BI.from(0))));
});

'''
'''--- packages/common-scripts/tests/cell_provider.ts ---
import { Cell, Script, helpers } from "@ckb-lumos/base";
const { isCellMatchQueryOptions } = helpers;

interface Options {
  lock?: Script;
}

class CellCollector {
  private options: Options;
  private cells: Cell[];

  constructor(options: Options, cells: Cell[]) {
    this.options = options;
    this.cells = cells;
  }

  async *collect(): AsyncGenerator<Cell> {
    for (const cell of this.cells) {
      if (isCellMatchQueryOptions(cell, this.options)) {
        yield cell;
      }
    }
  }
}

export class CellProvider {
  private cells: Cell[];

  constructor(cells: Cell[]) {
    this.cells = cells;
  }

  collector(options: Options): CellCollector {
    return new CellCollector(options, this.cells);
  }
}

'''
'''--- packages/common-scripts/tests/common-bigint.test.ts ---
import test from "ava";
import common from "../src/common";
const { __tests__ } = common;
const { _commonTransfer } = __tests__;
import { CellProvider } from "./cell_provider";
import {
  TransactionSkeleton,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import { Cell } from "@ckb-lumos/base";
import { FromInfo } from "../src";
import { predefined } from "@ckb-lumos/config-manager";
const { AGGRON4 } = predefined;

const aliceInput: Cell = {
  cell_output: {
    capacity: "0x1d1a3543f00",
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
    },
  },
  out_point: {
    tx_hash:
      "0x42300d78faea694e0e1c2316de091964a0d976a4ed27775597bad2d43a3e17da",
    index: "0x1",
  },
  block_hash:
    "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
  block_number: "0x1929c",
  data: "0x",
};

const multisigInput: Cell = {
  cell_output: {
    capacity: "0xba37cb7e00",
    lock: {
      code_hash:
        "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      hash_type: "type",
      args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
    },
  },
  out_point: {
    tx_hash:
      "0xc0018c999d6e7d1f830ea645d980a3a9c3c3832d12e72172708ce8461fc5821e",
    index: "0x1",
  },
  block_hash:
    "0x29c8f7d773ccd74724f95f562d049182c2461dd7459ebfc494b7bb0857e8c902",
  block_number: "0x1aed9",
  data: "0x",
};

const cellProvider = new CellProvider([aliceInput].concat([multisigInput]));
let txSkeleton: TransactionSkeletonType = TransactionSkeleton({ cellProvider });

const aliceAddress = "ckt1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gqfvmy2v";

const fromInfo: FromInfo = {
  R: 0,
  M: 1,
  publicKeyHashes: ["0x36c329ed630d6ce750712a477543672adab57f4c"],
};
// TODO: need to add _commonTransferCompatible test
test("BigInt:_commonTransfer, only alice", async (t) => {
  const amount: bigint = BigInt(20000 * 10 ** 8);
  const result = await _commonTransfer(
    txSkeleton,
    [aliceAddress],
    amount,
    BigInt(61 * 10 ** 8),
    { config: AGGRON4 }
  );
  txSkeleton = result.txSkeleton;

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 0);
  t.is(result.capacity, amount - BigInt(aliceInput.cell_output.capacity));
});

test("BigInt:_commonTransfer, alice and fromInfo", async (t) => {
  const amount: bigint = BigInt(20000 * 10 ** 8);
  const result = await _commonTransfer(
    txSkeleton,
    [aliceAddress, fromInfo],
    amount,
    BigInt(61 * 10 ** 8),
    { config: AGGRON4 }
  );
  txSkeleton = result.txSkeleton;

  const inputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BigInt(i.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 0);
  t.is(result.capacity, BigInt(0));
  t.is(result.changeCapacity, inputCapacity - amount);
});

test("BigInt:calculateFee, without carry", (t) => {
  t.is(__tests__.calculateFee(1035, BigInt(1000)), BigInt(1035));
});

test("BigInt:calculateFee, with carry", (t) => {
  t.is(__tests__.calculateFee(1035, BigInt(900)), BigInt(932));
});

'''
'''--- packages/common-scripts/tests/common.test.ts ---
import test from "ava";
import common from "../src/common";
const { __tests__ } = common;
import { CellProvider } from "./cell_provider";
import {
  parseAddress,
  TransactionSkeleton,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import { Cell, Transaction, values, Script } from "@ckb-lumos/base";
import { anyoneCanPay, parseFromInfo } from "../src";
import { Config, predefined } from "@ckb-lumos/config-manager";
const { AGGRON4, LINA } = predefined;

import {
  bobSecpInputs,
  bobMultisigInputs,
  bobMultisigLockInputs,
  tipHeader,
  bobAcpCells,
  aliceAcpCells,
} from "./inputs";
import { bob, alice } from "./account_info";
import { List } from "immutable";
import { BI } from "@ckb-lumos/bi";

const aliceAddress = "ckt1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gqfvmy2v";

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("transfer, acp => acp", async (t) => {
  const cellProvider = new CellProvider([...bobAcpCells, ...aliceAcpCells]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(500 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.acpTestnetAddress],
    alice.acpTestnetAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.toString(), sumOfOutputCapcity.toString());

  t.is(txSkeleton.get("witnesses").size, 2);

  t.is(txSkeleton.get("witnesses").get(0)!, "0x");

  const expectedMessage =
    "0x5acf7d234fc5c9adbc9b01f4938a5efdf6efde2b0a836f4740e6a79f81b64d65";

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.is(txSkeleton.get("signingEntries").size, 1);

  t.is(txSkeleton.get("signingEntries").get(0)!.message, expectedMessage);
});

test("lockScriptInfos", (t) => {
  common.__tests__.resetLockScriptInfos();
  t.is(common.__tests__.getLockScriptInfos().infos.length, 0);
  common.registerCustomLockScriptInfos([
    {
      code_hash: "",
      hash_type: "type",
      lockScriptInfo: anyoneCanPay,
    },
  ]);
  t.is(common.__tests__.getLockScriptInfos().infos.length, 1);

  common.__tests__.resetLockScriptInfos();
  t.is(common.__tests__.getLockScriptInfos().infos.length, 0);
  common.__tests__.generateLockScriptInfos({ config: AGGRON4 });
  t.is(common.__tests__.getLockScriptInfos().infos.length, 3);
  const configCodeHash = common.__tests__.getLockScriptInfos().configHashCode;
  t.not(configCodeHash, 0);

  // run again, won't change
  common.__tests__.generateLockScriptInfos({ config: AGGRON4 });
  t.is(common.__tests__.getLockScriptInfos().infos.length, 3);
  t.is(common.__tests__.getLockScriptInfos().configHashCode, configCodeHash);

  // using LINA
  common.__tests__.generateLockScriptInfos({ config: LINA });
  t.is(common.__tests__.getLockScriptInfos().infos.length, 3);
  t.not(common.__tests__.getLockScriptInfos().configHashCode, configCodeHash);
});

test("transfer secp => secp", async (t) => {
  const cellProvider = new CellProvider([...bobSecpInputs]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.toString(), sumOfOutputCapcity.toString());

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(
    BI.from(txSkeleton.get("outputs").get(0)!.cell_output.capacity).toString(),
    amount.toString()
  );

  t.is(txSkeleton.get("witnesses").size, 1);

  const expectedMessages = [
    "0x997f7d53307a114104b37c0fcdef97240d250d468189e71632d79e1c3b20a4f9",
  ];

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.deepEqual(
    txSkeleton
      .get("signingEntries")
      .sort((a, b) => a.index - b.index)
      .map((s) => s.message)
      .toArray(),
    expectedMessages
  );
});

test("transfer secp & multisig => secp", async (t) => {
  const cellProvider = new CellProvider([
    bobSecpInputs[0],
    ...bobMultisigInputs,
  ]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(1500 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress, bob.fromInfo],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.toString(), sumOfOutputCapcity.toString());

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(
    BI.from(txSkeleton.get("outputs").get(0)!.cell_output.capacity).toString(),
    amount.toString()
  );

  t.is(txSkeleton.get("witnesses").size, 2);

  const expectedMessages = [
    "0x45e7955cbc1ae0f8c2fbb3392a3afcea9ae1ae83c48e4355f131d751325ea615",
    "0x051a18a11dacfd6573a689328ea7ee0cc3f2533de9c15e4f9e12f0e4a6e9691c",
  ];

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.deepEqual(
    txSkeleton
      .get("signingEntries")
      .sort((a, b) => a.index - b.index)
      .map((s) => s.message)
      .toArray(),
    expectedMessages
  );
});

test("transfer multisig lock => secp", async (t) => {
  const cellProvider = new CellProvider([...bobMultisigLockInputs]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  class LocktimePoolCellCollector {
    async *collect() {
      yield {
        ...bobMultisigLockInputs[0],
        since: "0x0",
        depositBlockHash: undefined,
        withdrawBlockHash: undefined,
        sinceBaseValue: undefined,
      };
    }
  }

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.fromInfo],
    alice.testnetAddress,
    BI.from(amount),
    undefined,
    tipHeader,
    {
      config: AGGRON4,
      LocktimePoolCellCollector,
    }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.toString(), sumOfOutputCapcity.toString());

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(
    BI.from(txSkeleton.get("outputs").get(0)!.cell_output.capacity).toString(),
    amount.toString()
  );

  t.is(txSkeleton.get("witnesses").size, 1);

  const expectedMessages = [
    "0x54f766189f91dcf10a23833c5b1f0d318044c7237a2a703ad77ea46990190b8b",
  ];

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.deepEqual(
    txSkeleton
      .get("signingEntries")
      .sort((a, b) => a.index - b.index)
      .map((s) => s.message)
      .toArray(),
    expectedMessages
  );
});

test("transfer secp => acp", async (t) => {
  const cellProvider = new CellProvider([...bobSecpInputs, ...aliceAcpCells]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    alice.acpTestnetAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.toString(), sumOfOutputCapcity.toString());

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(
    BI.from(txSkeleton.get("outputs").get(0)!.cell_output.capacity)
      .sub(BI.from(aliceAcpCells[0]!.cell_output.capacity))
      .toString(),
    amount.toString()
  );

  const expectedWitnesses = [
    "0x",
    "0x55000000100000005500000055000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  ];
  t.deepEqual(txSkeleton.get("witnesses").toJS(), expectedWitnesses);

  const expectedMessages = [
    "0x7449d526fa5fbaf942cbf29f833d89026b6f28322d0bd4725eb8c0b921b3b275",
  ];

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.deepEqual(
    txSkeleton
      .get("signingEntries")
      .sort((a, b) => a.index - b.index)
      .map((s) => s.message)
      .toArray(),
    expectedMessages
  );
});

test("transfer secp => acp, no acp previous input", async (t) => {
  const cellProvider = new CellProvider([...bobSecpInputs]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    alice.acpTestnetAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.toString(), sumOfOutputCapcity.toString());

  t.is(txSkeleton.get("cellDeps").size, 1);
  t.is(txSkeleton.get("headerDeps").size, 0);
  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(
    BI.from(txSkeleton.get("outputs").get(0)!.cell_output.capacity).toString(),
    amount.toString()
  );

  const expectedWitnesses = [
    "0x55000000100000005500000055000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  ];
  t.deepEqual(txSkeleton.get("witnesses").toJS(), expectedWitnesses);

  const expectedMessages = [
    "0x68a543a1ef68667281609d9331f3587f4bfac16002f0fbac72e3774de80f45fb",
  ];

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.deepEqual(
    txSkeleton
      .get("signingEntries")
      .sort((a, b) => a.index - b.index)
      .map((s) => s.message)
      .toArray(),
    expectedMessages
  );
});

test("transfer acp => secp, destroy", async (t) => {
  const cellProvider = new CellProvider([...bobAcpCells]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(1000 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [
      {
        address: bob.acpTestnetAddress,
        destroyable: true,
      },
    ],
    bob.testnetAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.toString(), sumOfOutputCapcity.toString());

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 1);
  t.is(
    BI.from(txSkeleton.get("outputs").get(0)!.cell_output.capacity).toString(),
    amount.toString()
  );

  t.is(txSkeleton.get("witnesses").size, 1);

  const expectedMessages = [
    "0x3196d29d3365c1d3d599be55e80e4addd631acb6605646329eb39a1b9264ab89",
  ];

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.deepEqual(
    txSkeleton
      .get("signingEntries")
      .sort((a, b) => a.index - b.index)
      .map((s) => s.message)
      .toArray(),
    expectedMessages
  );
});

test("Don't update capacity directly when deduct", async (t) => {
  const cellProvider = new CellProvider([bobSecpInputs[0]]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const getCapacities = (cells: List<Cell>): string[] => {
    return cells.map((c) => c.cell_output.capacity).toJS();
  };

  const inputCapacitiesBefore = getCapacities(txSkeleton.get("inputs"));
  const outputCapacitiesBefore = getCapacities(txSkeleton.get("outputs"));

  let errFlag = false;
  try {
    await common.transfer(
      txSkeleton,
      [bob.testnetAddress],
      aliceAddress,
      BI.from(BI.from(500 * 10 ** 8)),
      undefined,
      undefined,
      { config: AGGRON4 }
    );
  } catch {
    errFlag = true;
  }

  const inputCapacitiesAfter = getCapacities(txSkeleton.get("inputs"));
  const outputCapacitiesAfter = getCapacities(txSkeleton.get("outputs"));

  t.true(errFlag);
  t.deepEqual(inputCapacitiesBefore, inputCapacitiesAfter);
  t.deepEqual(outputCapacitiesBefore, outputCapacitiesAfter);
});

test("setupInputCell secp", async (t) => {
  const cellProvider = new CellProvider([...bobSecpInputs]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const inputCell: Cell = bobSecpInputs[0];

  txSkeleton = await common.setupInputCell(
    txSkeleton,
    inputCell,
    bob.testnetAddress,
    {
      config: AGGRON4,
    }
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);

  const input: Cell = txSkeleton.get("inputs").get(0)!;
  const output: Cell = txSkeleton.get("outputs").get(0)!;

  t.is(input.cell_output.capacity, output.cell_output.capacity);
  t.is(input.data, output.data);
  t.true(
    new values.ScriptValue(input.cell_output.lock, { validate: false }).equals(
      new values.ScriptValue(output.cell_output.lock, { validate: false })
    )
  );
  t.true(
    (!input.cell_output.type && !output.cell_output.type) ||
      new values.ScriptValue(input.cell_output.type!, {
        validate: false,
      }).equals(
        new values.ScriptValue(output.cell_output.type!, { validate: false })
      )
  );
});

const testTx: Transaction = {
  version: "0x0",
  cell_deps: [
    {
      out_point: {
        tx_hash:
          "0xc12386705b5cbb312b693874f3edf45c43a274482e27b8df0fd80c8d3f5feb8b",
        index: "0x0",
      },
      dep_type: "dep_group",
    },
    {
      out_point: {
        tx_hash:
          "0x0fb4945d52baf91e0dee2a686cdd9d84cad95b566a1d7409b970ee0a0f364f60",
        index: "0x2",
      },
      dep_type: "code",
    },
  ],
  header_deps: [],
  inputs: [
    {
      previous_output: {
        tx_hash:
          "0x31f695263423a4b05045dd25ce6692bb55d7bba2965d8be16b036e138e72cc65",
        index: "0x1",
      },
      since: "0x0",
    },
  ],
  outputs: [
    {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x68d5438ac952d2f584abf879527946a537e82c7f3c1cbf6d8ebf9767437d8e88",
        args: "0x59a27ef3ba84f061517d13f42cf44ed020610061",
        hash_type: "type",
      },
      type: {
        code_hash:
          "0xece45e0979030e2f8909f76258631c42333b1e906fd9701ec3600a464a90b8f6",
        args: "0x",
        hash_type: "data",
      },
    },
    {
      capacity: "0x59e1416a5000",
      lock: {
        code_hash:
          "0x68d5438ac952d2f584abf879527946a537e82c7f3c1cbf6d8ebf9767437d8e88",
        args: "0x59a27ef3ba84f061517d13f42cf44ed020610061",
        hash_type: "type",
      },
      type: undefined,
    },
  ],
  outputs_data: ["0x1234", "0x"],
  witnesses: [
    "0x82df73581bcd08cb9aa270128d15e79996229ce8ea9e4f985b49fbf36762c5c37936caf3ea3784ee326f60b8992924fcf496f9503c907982525a3436f01ab32900",
  ],
};

test("getTransactionSizeByTx", (t) => {
  const size: number = __tests__.getTransactionSizeByTx(testTx);
  t.is(size, 536);
});

test("calculateFeeCompatible, without carry", (t) => {
  t.is(
    __tests__.calculateFeeCompatible(1035, BI.from(BI.from(1000))).toString(),
    BI.from(1035).toString()
  );
});

test("calculateFeeCompatible, with carry", (t) => {
  t.is(
    __tests__.calculateFeeCompatible(1035, BI.from(BI.from(900))).toString(),
    BI.from(932).toString()
  );
});

function getExpectedFee(txSkeleton: TransactionSkeletonType, feeRate: BI): BI {
  return BI.from(
    __tests__.calculateFeeCompatible(
      __tests__.getTransactionSize(txSkeleton),
      BI.from(feeRate)
    )
  );
}

function getFee(txSkeleton: TransactionSkeletonType): BI {
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  return sumOfInputCapacity.sub(sumOfOutputCapcity);
}

// from same address and only secp156k1_blake160 lock
// const ONE_IN_ONE_OUT_SIZE = 355
const ONE_IN_TWO_OUT_SIZE = 464;
// const TWO_IN_ONE_OUT_SIZE = 407
// const TWO_IN_TWO_OUT_SIZE = 516

test("payFeeByFeeRate 1 in 1 out, add 1 in 1 out", async (t) => {
  const cellProvider = new CellProvider(bobSecpInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(1000 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const feeRate = BI.from(1 * 10 ** 8 * 1000);
  txSkeleton = await common.payFeeByFeeRate(
    txSkeleton,
    [bob.testnetAddress],
    BI.from(feeRate),
    undefined,
    {
      config: AGGRON4,
    }
  );

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(
    getFee(txSkeleton).toString(),
    getExpectedFee(txSkeleton, feeRate).toString()
  );
});

test("payFeeByFeeRate 1 in 2 out, add nothing", async (t) => {
  const cellProvider = new CellProvider(bobSecpInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const feeRate = BI.from(1 * 10 ** 8);
  txSkeleton = await common.payFeeByFeeRate(
    txSkeleton,
    [bob.testnetAddress],
    BI.from(feeRate),
    undefined,
    {
      config: AGGRON4,
    }
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(
    getFee(txSkeleton).toString(),
    getExpectedFee(txSkeleton, feeRate).toString()
  );
});

test("payFeeByFeeRate 1 in 2 out, reduce 1 out", async (t) => {
  const cellProvider = new CellProvider(bobSecpInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(536 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const feeRate = BI.from(1 * 10 ** 8 * 1000);
  txSkeleton = await common.payFeeByFeeRate(
    txSkeleton,
    [bob.testnetAddress],
    BI.from(feeRate),
    undefined,
    {
      config: AGGRON4,
    }
  );

  // NOTE: 1000CKB => 536CKB + 464CKB(change), need 464CKB for fee, so reduced change cell
  // But, new tx is 1000CKB => 536CKB, need 355CKB for fee
  // when you add a new change output, fee will up to 464CKB or even a new input, so left 1000CKB => 536CKB is best choice.
  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 1);
  t.is(
    getFee(txSkeleton).toString(),
    __tests__
      .calculateFeeCompatible(ONE_IN_TWO_OUT_SIZE, BI.from(feeRate))
      .toString()
  );
});

test("payFeeByFeeRate 1 in 2 out, add 1 in", async (t) => {
  const cellProvider = new CellProvider(bobSecpInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const feeRate = BI.from(1 * 10 ** 8 * 1000);
  txSkeleton = await common.payFeeByFeeRate(
    txSkeleton,
    [bob.testnetAddress],
    BI.from(feeRate),
    undefined,
    {
      config: AGGRON4,
    }
  );

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(
    getFee(txSkeleton).toString(),
    getExpectedFee(txSkeleton, feeRate).toString()
  );
});

test("payFeeByFeeRate, capacity 500", async (t) => {
  const cellProvider = new CellProvider(bobSecpInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(500 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const feeRate = BI.from(1000);
  txSkeleton = await common.payFeeByFeeRate(
    txSkeleton,
    [bob.testnetAddress],
    BI.from(feeRate),
    undefined,
    {
      config: AGGRON4,
    }
  );

  const expectedFee: BI = BI.from(464);

  t.is(getFee(txSkeleton).toString(), expectedFee.toString());
});

test("payFeeByFeeRate, capacity 1000", async (t) => {
  const cellProvider = new CellProvider(bobSecpInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(1000 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    aliceAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const feeRate = BI.from(1000);
  txSkeleton = await common.payFeeByFeeRate(
    txSkeleton,
    [bob.testnetAddress],
    BI.from(feeRate),
    undefined,
    {
      config: AGGRON4,
    }
  );

  const expectedFee: BI = BI.from(516);

  t.is(getFee(txSkeleton).toString(), expectedFee.toString());
});

test("Should not throw if anyone-can-pay config not provided", async (t) => {
  // config without anyone-can-pay
  const config: Config = {
    PREFIX: AGGRON4.PREFIX,
    SCRIPTS: {
      SECP256K1_BLAKE160: AGGRON4.SCRIPTS.SECP256K1_BLAKE160,
      SECP256K1_BLAKE160_MULTISIG: AGGRON4.SCRIPTS.SECP256K1_BLAKE160_MULTISIG,
      DAO: AGGRON4.SCRIPTS.DAO,
    },
  };

  const cellProvider = new CellProvider([...bobSecpInputs]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(600 * 10 ** 8);
  await t.notThrowsAsync(async () => {
    await common.transfer(
      txSkeleton,
      [bob.testnetAddress],
      aliceAddress,
      BI.from(amount),
      undefined,
      undefined,
      { config }
    );
  });
});

// disable deduct capacity
test("transfer secp => secp, without deduct capacity", async (t) => {
  const cellProvider = new CellProvider([...bobSecpInputs]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.testnetAddress],
    alice.testnetAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  t.is(txSkeleton.get("inputs").size, 1);

  t.is(txSkeleton.get("outputs").size, 2);

  const fee: BI = BI.from(1000);
  txSkeleton = await common.payFee(
    txSkeleton,
    [bob.testnetAddress],
    BI.from(fee),
    undefined,
    {
      config: AGGRON4,
      enableDeductCapacity: false,
    }
  );

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 3);

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.sub(sumOfOutputCapcity).toString(), fee.toString());

  t.is(
    BI.from(txSkeleton.get("outputs").get(0)!.cell_output.capacity).toString(),
    amount.toString()
  );
  t.is(
    BI.from(txSkeleton.get("outputs").get(1)!.cell_output.capacity).toString(),
    BI.from(bobSecpInputs[0].cell_output.capacity).sub(amount).toString()
  );
  t.is(
    BI.from(txSkeleton.get("outputs").get(2)!.cell_output.capacity).toString(),
    BI.from(bobSecpInputs[1].cell_output.capacity).sub(fee).toString()
  );

  const changeLockScript: Script = parseAddress(bob.testnetAddress, {
    config: AGGRON4,
  });

  t.true(
    new values.ScriptValue(txSkeleton.get("outputs").get(1)!.cell_output.lock, {
      validate: false,
    }).equals(new values.ScriptValue(changeLockScript, { validate: false }))
  );
  t.true(
    new values.ScriptValue(txSkeleton.get("outputs").get(2)!.cell_output.lock, {
      validate: false,
    }).equals(new values.ScriptValue(changeLockScript, { validate: false }))
  );
  t.is(txSkeleton.get("fixedEntries").size, 0);

  const expectedMessages = [
    "0x7bf7f9183d54e3a69d80c1d049d0b1cda7005341f428b70b22abc356286dbf70",
  ];

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.deepEqual(
    txSkeleton
      .get("signingEntries")
      .sort((a, b) => a.index - b.index)
      .map((s) => s.message)
      .toArray(),
    expectedMessages
  );
});

test("transfer multisig lock => secp, without deduct capacity", async (t) => {
  const cellProvider = new CellProvider([...bobMultisigInputs]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  class LocktimePoolCellCollector {
    async *collect() {
      for (const cell of bobMultisigInputs) {
        yield {
          ...cell,
          since: "0x0",
          depositBlockHash: undefined,
          withdrawBlockHash: undefined,
          sinceBaseValue: undefined,
        };
      }
    }
  }

  const amount = BI.from(600 * 10 ** 8);
  txSkeleton = await common.transfer(
    txSkeleton,
    [bob.fromInfo],
    alice.testnetAddress,
    BI.from(amount),
    undefined,
    tipHeader,
    {
      config: AGGRON4,
      LocktimePoolCellCollector,
    }
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);

  const fee = BI.from(1000);
  txSkeleton = await common.injectCapacity(
    txSkeleton,
    [bob.fromInfo],
    BI.from(fee),
    undefined,
    tipHeader,
    {
      config: AGGRON4,
      LocktimePoolCellCollector,
      enableDeductCapacity: false,
    }
  );

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 3);

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputCapcity = txSkeleton
    .get("outputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputCapacity.sub(sumOfOutputCapcity).toString(), fee.toString());

  t.is(
    BI.from(txSkeleton.get("outputs").get(0)!.cell_output.capacity).toString(),
    amount.toString()
  );
  t.is(
    BI.from(txSkeleton.get("outputs").get(1)!.cell_output.capacity).toString(),
    BI.from(bobMultisigInputs[0].cell_output.capacity).sub(amount).toString()
  );
  t.is(
    BI.from(txSkeleton.get("outputs").get(2)!.cell_output.capacity).toString(),
    BI.from(bobMultisigInputs[1].cell_output.capacity).sub(fee).toString()
  );

  const changeLockScript: Script = parseFromInfo(bob.fromInfo, {
    config: AGGRON4,
  }).fromScript;
  t.true(
    new values.ScriptValue(txSkeleton.get("outputs").get(1)!.cell_output.lock, {
      validate: false,
    }).equals(new values.ScriptValue(changeLockScript, { validate: false }))
  );
  t.true(
    new values.ScriptValue(txSkeleton.get("outputs").get(2)!.cell_output.lock, {
      validate: false,
    }).equals(new values.ScriptValue(changeLockScript, { validate: false }))
  );
  t.is(txSkeleton.get("fixedEntries").size, 0);

  const expectedMessages = [
    "0x01fc08c48a5cab51686b808e65d041966a460a17cfa82bb77cbd270fff4634c0",
  ];

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.deepEqual(
    txSkeleton
      .get("signingEntries")
      .sort((a, b) => a.index - b.index)
      .map((s) => s.message)
      .toArray(),
    expectedMessages
  );
});

'''
'''--- packages/common-scripts/tests/dao-bigint.test.ts ---
import test from "ava";
import { dao } from "../src";
import { Cell } from "@ckb-lumos/base";

const calculateMaximumWithdrawInfo = {
  depositInput: {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
      },
      type: {
        code_hash:
          "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
        hash_type: "type",
        args: "0x",
      },
    },
    out_point: {
      tx_hash:
        "0x9fbcf16a96897c1b0b80d4070752b9f30577d91275f5b460b048b955b58e08eb",
      index: "0x0",
    },
    block_hash:
      "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
    block_number: "0x19249",
    data: "0x0000000000000000",
  },
  depositHeader: {
    compact_target: "0x20010000",
    dao: "0x8eedf002d7c88852433518952edc28002dd416364532c50800d096d05aac0200",
    epoch: "0xa000500283a",
    hash: "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
    nonce: "0x98e10e0a992f7274c7dc0c62e9d42f02",
    number: "0x19249",
    parent_hash:
      "0xd4f3e8725de77aedadcf15755c0f6cdd00bc8d4a971e251385b59ce8215a5d70",
    proposals_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    timestamp: "0x17293289266",
    transactions_root:
      "0x9294a800ec389d1b0d9e7c570c249da260a44cc2790bd4aa250f3d5c83eb8cde",
    uncles_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    version: "0x0",
  },
  withdrawHeader: {
    compact_target: "0x20010000",
    dao: "0x39d32247d33f90523d37dae613dd280037e9cc1d7b01c708003d8849d8ac0200",
    epoch: "0xa0008002842",
    hash: "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
    nonce: "0x7ffb49f45f12f2b30ac45586ecf13de2",
    number: "0x1929c",
    parent_hash:
      "0xfe601308a34f1faf68906d2338e60246674ed1f1fbbad3d8471daca21a11cdf7",
    proposals_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    timestamp: "0x1729cdd69c9",
    transactions_root:
      "0x467d72af12af6cb122985f9838bfc47073bba30cc37a4075aef54b0f0768f384",
    uncles_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    version: "0x0",
  },
  expectedWithdrawCapacity: BigInt("0x1748ec3fdc"),
};

test("BigInt:calculateMaximumWithdraw", (t) => {
  const {
    depositInput,
    depositHeader,
    withdrawHeader,
    expectedWithdrawCapacity,
  } = calculateMaximumWithdrawInfo;
  const result = dao.calculateMaximumWithdraw(
    depositInput as Cell,
    depositHeader.dao,
    withdrawHeader.dao
  );

  t.is(result, expectedWithdrawCapacity);
});

test("BigInt:calculateDaoEarliestSince", (t) => {
  const { depositHeader, withdrawHeader } = calculateMaximumWithdrawInfo;

  const result = dao.calculateDaoEarliestSince(
    depositHeader.epoch,
    withdrawHeader.epoch
  );

  // since: relative = false, type = epochNumber value = { length: 10, index: 5, number: 10478 }
  // if decrease index to 4, will false to validation by dao script
  t.is(result, BigInt("0x20000a00050028ee"));
});

'''
'''--- packages/common-scripts/tests/dao.test.ts ---
import test from "ava";
import { CellProvider } from "./cell_provider";
import {
  TransactionSkeleton,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import { dao, common } from "../src";
import { predefined, Config } from "@ckb-lumos/config-manager";
const { LINA, AGGRON4 } = predefined;
import { bob } from "./account_info";
import { inputs } from "./secp256k1_blake160_inputs";
import { Script, Cell, HexString } from "@ckb-lumos/base";
import {
  bobMultisigDaoInputs,
  bobMultisigInputs,
  bobSecpDaoDepositInput,
  bobSecpDaoWithdrawInput,
} from "./inputs";
import { BI } from "@ckb-lumos/bi";

const cellProvider = new CellProvider(inputs());
let txSkeleton: TransactionSkeletonType = TransactionSkeleton({ cellProvider });

const generateDaoTypeScript = (config: Config): Script => {
  return {
    code_hash: config.SCRIPTS.DAO!.CODE_HASH,
    hash_type: config.SCRIPTS.DAO!.HASH_TYPE,
    args: "0x",
  };
};

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("deposit secp256k1_blake160", async (t) => {
  txSkeleton = await dao.deposit(
    txSkeleton,
    bob.mainnetAddress,
    bob.mainnetAddress,
    BI.from(BI.from(1000 * 10 ** 8))
  );

  const inputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const outputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(outputCapacity.toString(), inputCapacity.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);

  t.deepEqual(txSkeleton.get("cellDeps").get(0)!.out_point, {
    tx_hash: LINA.SCRIPTS.DAO!.TX_HASH,
    index: LINA.SCRIPTS.DAO!.INDEX,
  });
  t.is(txSkeleton.get("cellDeps").get(0)!.dep_type, LINA.SCRIPTS.DAO!.DEP_TYPE);

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);

  t.is(txSkeleton.get("outputs").size, 2);
  t.deepEqual(
    txSkeleton.get("outputs").get(0)!.cell_output!.type,
    generateDaoTypeScript(LINA)
  );
});

test("withdraw secp256k1_blake160", async (t) => {
  txSkeleton = await dao.deposit(
    txSkeleton,
    bob.mainnetAddress,
    bob.mainnetAddress,
    BI.from(BI.from(1000 * 10 ** 8))
  );

  const fromInput = txSkeleton.get("outputs").get(0)!;
  (fromInput.block_hash = "0x" + "1".repeat(64)),
    (fromInput.block_number = "0x100");
  fromInput.out_point = {
    tx_hash: "0x" + "1".repeat(64),
    index: "0x0",
  };

  txSkeleton = TransactionSkeleton({ cellProvider });
  txSkeleton = await dao.withdraw(txSkeleton, fromInput, bob.mainnetAddress);

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.deepEqual(txSkeleton.get("cellDeps").get(0)!.out_point, {
    tx_hash: LINA.SCRIPTS.DAO!.TX_HASH,
    index: LINA.SCRIPTS.DAO!.INDEX,
  });
  t.is(txSkeleton.get("cellDeps").get(0)!.dep_type, LINA.SCRIPTS.DAO!.DEP_TYPE);

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);
  t.not(txSkeleton.get("witnesses").get(0)!, "0x");

  t.is(txSkeleton.get("outputs").size, 1);
  t.is(
    txSkeleton.get("inputs").get(0)!.cell_output.capacity,
    txSkeleton.get("outputs").get(0)!.cell_output.capacity
  );
  t.is(txSkeleton.get("headerDeps").size, 1);
  t.is(txSkeleton.get("headerDeps").get(0)!, fromInput.block_hash);
  t.deepEqual(
    txSkeleton.get("outputs").get(0)!.cell_output.type,
    generateDaoTypeScript(LINA)
  );

  const inputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const outputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(outputCapacity.toString(), inputCapacity.toString());
});

const calculateMaximumWithdrawInfo = {
  depositInput: {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
      },
      type: {
        code_hash:
          "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
        hash_type: "type",
        args: "0x",
      },
    },
    out_point: {
      tx_hash:
        "0x9fbcf16a96897c1b0b80d4070752b9f30577d91275f5b460b048b955b58e08eb",
      index: "0x0",
    },
    block_hash:
      "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
    block_number: "0x19249",
    data: "0x0000000000000000",
  },
  depositHeader: {
    compact_target: "0x20010000",
    dao: "0x8eedf002d7c88852433518952edc28002dd416364532c50800d096d05aac0200",
    epoch: "0xa000500283a",
    hash: "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
    nonce: "0x98e10e0a992f7274c7dc0c62e9d42f02",
    number: "0x19249",
    parent_hash:
      "0xd4f3e8725de77aedadcf15755c0f6cdd00bc8d4a971e251385b59ce8215a5d70",
    proposals_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    timestamp: "0x17293289266",
    transactions_root:
      "0x9294a800ec389d1b0d9e7c570c249da260a44cc2790bd4aa250f3d5c83eb8cde",
    uncles_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    version: "0x0",
  },
  withdrawHeader: {
    compact_target: "0x20010000",
    dao: "0x39d32247d33f90523d37dae613dd280037e9cc1d7b01c708003d8849d8ac0200",
    epoch: "0xa0008002842",
    hash: "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
    nonce: "0x7ffb49f45f12f2b30ac45586ecf13de2",
    number: "0x1929c",
    parent_hash:
      "0xfe601308a34f1faf68906d2338e60246674ed1f1fbbad3d8471daca21a11cdf7",
    proposals_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    timestamp: "0x1729cdd69c9",
    transactions_root:
      "0x467d72af12af6cb122985f9838bfc47073bba30cc37a4075aef54b0f0768f384",
    uncles_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    version: "0x0",
  },
  expectedWithdrawCapacity: BigInt("0x1748ec3fdc"),
};

test("JSBI:calculateMaximumWithdrawCompatible", (t) => {
  const {
    depositInput,
    depositHeader,
    withdrawHeader,
    expectedWithdrawCapacity,
  } = calculateMaximumWithdrawInfo;
  const result = dao.calculateMaximumWithdrawCompatible(
    depositInput as Cell,
    depositHeader.dao,
    withdrawHeader.dao
  );

  t.is(
    result.toString(),
    BI.from(expectedWithdrawCapacity.toString()).toString()
  );
});

test("deposit multisig", async (t) => {
  const cellProvider = new CellProvider(bobMultisigInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  txSkeleton = await dao.deposit(
    txSkeleton,
    bob.fromInfo,
    bob.multisigTestnetAddress,
    BI.from(BI.from(500 * 10 ** 8)),
    { config: AGGRON4 }
  );

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  const inputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const outputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(outputCapacity.toString(), inputCapacity.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);

  t.deepEqual(txSkeleton.get("cellDeps").get(0)!.out_point, {
    tx_hash: AGGRON4.SCRIPTS.DAO!.TX_HASH,
    index: AGGRON4.SCRIPTS.DAO!.INDEX,
  });
  t.is(
    txSkeleton.get("cellDeps").get(0)!.dep_type,
    AGGRON4.SCRIPTS.DAO!.DEP_TYPE
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);

  t.is(txSkeleton.get("outputs").size, 2);
  t.deepEqual(
    txSkeleton.get("outputs").get(0)!.cell_output!.type,
    generateDaoTypeScript(AGGRON4)
  );

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0xa41875ea85b7abda153b7aa3c24e2874e30c88d69203a2f8b9bceb6e52e8b73c";
  const message = txSkeleton.get("signingEntries").get(0)!.message;
  t.is(message, expectedMessage);

  t.is(txSkeleton.get("witnesses").size, 1);
  const expectedWitness =
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
  const witness = txSkeleton.get("witnesses").get(0)!;
  t.is(witness, expectedWitness);
});

test("withdraw multisig", async (t) => {
  const cellProvider = new CellProvider(bobMultisigDaoInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  txSkeleton = await dao.withdraw(
    txSkeleton,
    bobMultisigDaoInputs[0],
    bob.fromInfo,
    {
      config: AGGRON4,
    }
  );

  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: AGGRON4 });

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.deepEqual(txSkeleton.get("cellDeps").get(0)!.out_point, {
    tx_hash: AGGRON4.SCRIPTS.DAO!.TX_HASH,
    index: AGGRON4.SCRIPTS.DAO!.INDEX,
  });
  t.is(
    txSkeleton.get("cellDeps").get(0)!.dep_type,
    AGGRON4.SCRIPTS.DAO!.DEP_TYPE
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);
  t.not(txSkeleton.get("witnesses").get(0)!, "0x");

  t.is(txSkeleton.get("outputs").size, 1);
  t.is(
    txSkeleton.get("inputs").get(0)!.cell_output.capacity,
    txSkeleton.get("outputs").get(0)!.cell_output.capacity
  );
  t.is(txSkeleton.get("headerDeps").size, 1);
  t.is(
    txSkeleton.get("headerDeps").get(0)!,
    bobMultisigDaoInputs[0].block_hash
  );
  t.deepEqual(
    txSkeleton.get("outputs").get(0)!.cell_output.type,
    generateDaoTypeScript(AGGRON4)
  );

  const inputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const outputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(outputCapacity.toString(), inputCapacity.toString());

  const expectedMessage =
    "0x0d54fdf2cb8ec8cfbb41376e8fbd2851866a07724e5f5075d83d8b519279e801";
  const expectedWitness =
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

  t.is(txSkeleton.get("signingEntries").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);

  const message = txSkeleton.get("signingEntries").get(0)!.message;
  t.is(message, expectedMessage);
  const witness = txSkeleton.get("witnesses").get(0);
  t.is(witness, expectedWitness);
});

test("deposit, dao script not exists", async (t) => {
  await t.throwsAsync(
    async () => {
      await dao.deposit(
        txSkeleton,
        bob.mainnetAddress,
        bob.mainnetAddress,
        BigInt(1000 * 10 ** 8),
        {
          config: {
            PREFIX: "ckt",
            SCRIPTS: {},
          },
        }
      );
    },
    undefined,
    "Provided config does not have DAO script setup!"
  );
});

test("deposit, toAddress not exists", async (t) => {
  await t.throwsAsync(
    async () => {
      await dao.deposit(
        txSkeleton,
        bob.mainnetAddress,
        undefined as any,
        BigInt(1000 * 10 ** 8),
        {
          config: {
            PREFIX: "ckt",
            SCRIPTS: {},
          },
        }
      );
    },
    undefined,
    "You must provide a to address!"
  );
});

test("CellCollector, all", async (t) => {
  const cellProvider = new CellProvider(bobMultisigDaoInputs);
  const iter = new dao.CellCollector(
    bob.multisigTestnetAddress,
    cellProvider,
    "all",
    {
      config: AGGRON4,
    }
  ).collect();
  let count = 0;
  while (!(await iter.next()).done) {
    count += 1;
  }

  t.is(count, 1);
});

test("CellCollector, deposit", async (t) => {
  const cellProvider = new CellProvider(bobMultisigDaoInputs);
  const iter = new dao.CellCollector(
    bob.multisigTestnetAddress,
    cellProvider,
    "deposit",
    {
      config: AGGRON4,
    }
  ).collect();
  let count = 0;
  while (!(await iter.next()).done) {
    count += 1;
  }

  t.is(count, 1);
});

test("CellCollector, withdraw", async (t) => {
  const cellProvider = new CellProvider(bobMultisigDaoInputs);
  const iter = new dao.CellCollector(
    bob.multisigTestnetAddress,
    cellProvider,
    "withdraw",
    {
      config: AGGRON4,
    }
  ).collect();
  let count = 0;
  while (!(await iter.next()).done) {
    count += 1;
  }

  t.is(count, 0);
});

test("listDaoCells, deposit", async (t) => {
  const cellProvider = new CellProvider(bobMultisigDaoInputs);
  const iter = dao.listDaoCells(
    cellProvider,
    bob.multisigTestnetAddress,
    "deposit",
    {
      config: AGGRON4,
    }
  );
  let count = 0;
  while (!(await iter.next()).done) {
    count += 1;
  }

  t.is(count, 1);
});

test("JSBI:calculateDaoEarliestSinceCompatible", (t) => {
  const { depositHeader, withdrawHeader } = calculateMaximumWithdrawInfo;

  const result = dao.calculateDaoEarliestSinceCompatible(
    depositHeader.epoch,
    withdrawHeader.epoch
  );

  // since: relative = false, type = epochNumber value = { length: 10, index: 5, number: 10478 }
  // if decrease index to 4, will false to validation by dao script
  t.is(result.toString(), BI.from("0x20000a00050028ee").toString());
});

class RpcMocker {
  async get_header(hash: HexString) {
    if (hash === calculateMaximumWithdrawInfo.depositHeader.hash) {
      return calculateMaximumWithdrawInfo.depositHeader;
    }
    if (hash === calculateMaximumWithdrawInfo.withdrawHeader.hash) {
      return calculateMaximumWithdrawInfo.withdrawHeader;
    }
    throw new Error("RpcMocker get_header error!");
  }
}

test("unlock", async (t) => {
  const cellProvider = new CellProvider([bobSecpDaoWithdrawInput]);
  let txSkeleton = TransactionSkeleton({ cellProvider });

  txSkeleton = await dao.unlock(
    txSkeleton,
    bobSecpDaoDepositInput,
    bobSecpDaoWithdrawInput,
    bob.testnetAddress,
    bob.testnetAddress,
    {
      config: AGGRON4,
      RpcClient: RpcMocker as any,
    }
  );

  txSkeleton = common.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 1);
  t.deepEqual(txSkeleton.get("headerDeps").toJS(), [
    calculateMaximumWithdrawInfo.depositHeader.hash,
    calculateMaximumWithdrawInfo.withdrawHeader.hash,
  ]);

  const expectedMessage =
    "0xf276a45b7dbc018c2e10c4cd0a61915dd28db768894efc1b2c557c9566fc43fd";
  const expectedWitness =
    "0x61000000100000005500000061000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000";

  t.is(txSkeleton.get("signingEntries").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);

  const message = txSkeleton.get("signingEntries").get(0)!.message;
  const witness = txSkeleton.get("witnesses").get(0)!;

  t.is(message, expectedMessage);
  t.is(witness, expectedWitness);
});

'''
'''--- packages/common-scripts/tests/deploy.test.ts ---
import { Cell, Script } from "@ckb-lumos/base";
import { common } from "@ckb-lumos/common-scripts";
import test from "ava";
import { CellProvider } from "./cell_provider";
import deploy from "../src/deploy";
const { __tests__ } = deploy;
const { calculateTxFee } = __tests__;
import { predefined } from "@ckb-lumos/config-manager";
import { TransactionSkeletonType } from "@ckb-lumos/helpers";
import { BI } from "@ckb-lumos/bi";
const { AGGRON4 } = predefined;

const FROMADDRESS = "ckt1qyqptxys5l9vk39ft0hswscxgseawc77y2wqlr558h";
const OUTPUTSCRIPTLOCK: Script = {
  code_hash:
    "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
  hash_type: "type",
  args: "0x159890a7cacb44a95bef0743064433d763de229c",
};
const LOCKARG1 = "0x3d35d87fac0008ba5b12ee1c599b102fc8f5fdf8";
const LOCKARG2 = "0x99dbe610c43186696e1f88cb7b59252d4c92afda";
const LOCKARG3 = "0xc055df68fdd47c6a5965b9ab21cd6825d8696a76";
const FROMINFO = {
  R: 2,
  M: 2,
  publicKeyHashes: [LOCKARG1, LOCKARG2, LOCKARG3],
};
const MULTISIGSCRIPT = {
  code_hash:
    "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
  hash_type: "type",
  args: "0xed20af7322823d0dc33bfb215486a05082669905",
};
const SCRIPTBINARY = Uint8Array.of(1);

function getTxFee(txSkeleton: TransactionSkeletonType): BI {
  const inputCapacity = txSkeleton
    .get("inputs")
    .map((c) => BI.from(c.cell_output.capacity))
    .reduce((a, b) => a.add(b), BI.from(0));
  const outputCapacity = txSkeleton
    .get("outputs")
    .map((c) => BI.from(c.cell_output.capacity))
    .reduce((a, b) => a.add(b), BI.from(0));
  const txFee = inputCapacity.sub(outputCapacity);
  return txFee;
}

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("deploy with data", async (t) => {
  const inputs: Cell[] = [
    {
      cell_output: {
        capacity: "0x1718c7e00",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x01",
      out_point: {
        index: "0x0",
        tx_hash:
          "0xa11728dd5b27224179c19e831f8e8dc0c67835bcd2d5d3bb87c7cc27d0b66cfc",
      },
      block_number: "0x352583",
    },
    {
      cell_output: {
        capacity: "0x2f4fa9f00",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: {
          args:
            "0xe9451f3528af55247ff7d3851a00b54a5fe7de38d40dc29580ce2c069332633a",
          code_hash:
            "0x00000000000000000000000000000000000000000000000000545950455f4944",
          hash_type: "type",
        },
      },
      data: "0x01",
      out_point: {
        index: "0x0",
        tx_hash:
          "0x46176211dd8ea0bfaa652a08de97992fec25d243411fec63826c7ee989491d97",
      },
      block_number: "0x3525b6",
    },
    {
      cell_output: {
        capacity: "0x981bb6e5000",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0x4c9457e28e7dd2c87be8b814e33b94d114b83d10bb3cad37de6c60f408f2773e",
      },
      block_number: "0x36145f",
    },
  ];
  const cellProvider = new CellProvider(inputs);
  const deployOptions = {
    cellProvider: cellProvider,
    scriptBinary: SCRIPTBINARY,
    fromInfo: FROMADDRESS,
    config: AGGRON4,
  };

  let { txSkeleton } = await deploy.generateDeployWithDataTx(deployOptions);

  for (const input of txSkeleton.get("inputs")) {
    const type = input.cell_output.type;
    const data = input.data;
    t.is(type, undefined);
    t.is(data, "0x");
  }

  const txFee = getTxFee(txSkeleton);
  const expectTxFee = calculateTxFee(txSkeleton, BI.from(BI.from(1000)));
  t.is(txFee.toString(), expectTxFee.toString());
  t.true(BI.from(txFee).lt(1000000));

  const deployLock = txSkeleton.outputs.get(0)!.cell_output.lock!;
  const changeLock = txSkeleton.outputs.get(1)!.cell_output.lock!;
  t.deepEqual(deployLock, OUTPUTSCRIPTLOCK);
  t.deepEqual(changeLock, OUTPUTSCRIPTLOCK);

  const deployData = txSkeleton.outputs.get(0)!.data;
  t.is(deployData, "0x01");
});

test("deploy with typeID", async (t) => {
  const inputs: Cell[] = [
    {
      cell_output: {
        capacity: "0x1718c7e00",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x01",
      out_point: {
        index: "0x0",
        tx_hash:
          "0xa11728dd5b27224179c19e831f8e8dc0c67835bcd2d5d3bb87c7cc27d0b66cfc",
      },
      block_number: "0x352583",
    },
    {
      cell_output: {
        capacity: "0x2f4fa9f00",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: {
          args:
            "0xe9451f3528af55247ff7d3851a00b54a5fe7de38d40dc29580ce2c069332633a",
          code_hash:
            "0x00000000000000000000000000000000000000000000000000545950455f4944",
          hash_type: "type",
        },
      },
      data: "0x01",
      out_point: {
        index: "0x0",
        tx_hash:
          "0x46176211dd8ea0bfaa652a08de97992fec25d243411fec63826c7ee989491d97",
      },
      block_number: "0x3525b6",
    },
    {
      cell_output: {
        capacity: "0x543fd2fccaf2",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0x0a97968e137594e7b698668202d1f63bd2dc9f070db6524125a0a74224d13b6e",
      },
      block_number: "0x36146d",
    },
  ];
  const cellProvider = new CellProvider(inputs);
  const deployOptions = {
    cellProvider: cellProvider,
    scriptBinary: SCRIPTBINARY,
    fromInfo: FROMADDRESS,
    config: AGGRON4,
  };

  let { txSkeleton } = await deploy.generateDeployWithTypeIdTx(deployOptions);

  for (const input of txSkeleton.get("inputs")) {
    const type = input.cell_output.type;
    const data = input.data;
    t.is(type, undefined);
    t.is(data, "0x");
  }

  const txFee = getTxFee(txSkeleton);
  const expectTxFee = calculateTxFee(txSkeleton, BI.from(BI.from(1000)));
  t.is(txFee.toString(), expectTxFee.toString());
  t.true(BI.from(txFee).lt(1000000));

  const deployLock = txSkeleton.outputs.get(0)!.cell_output.lock!;
  const changeLock = txSkeleton.outputs.get(1)!.cell_output.lock!;
  t.deepEqual(deployLock, OUTPUTSCRIPTLOCK);
  t.deepEqual(changeLock, OUTPUTSCRIPTLOCK);

  const deployData = txSkeleton.outputs.get(0)!.data;
  t.is(deployData, "0x01");
});

test("upgrade with typeID", async (t) => {
  const inputs: Cell[] = [
    {
      cell_output: {
        capacity: "0x2f4fa9f00",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: {
          args:
            "0x2c82a38950de3204a4ae166c50331d1b104e97a21402cb5bdb7ca23bb9c15f0f",
          code_hash:
            "0x00000000000000000000000000000000000000000000000000545950455f4944",
          hash_type: "type",
        },
      },
      data: "0x01",
      out_point: {
        index: "0x0",
        tx_hash:
          "0x7afcb80f91d0a52bc376e5113494546e825a3de2b7378b3bed91fed35e2839e8",
      },
      block_number: "0x3614af",
    },
    {
      cell_output: {
        capacity: "0x1718adf5a",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0xc68f8f08958c60ad83a81e7e590c3aba6abdaed2bbcfd8fbe0e014b7396affb1",
      },
      block_number: "0x361485",
    },
    {
      cell_output: {
        capacity: "0x98049e1d02f",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0x0f1cf3ddefa6141d16375dfefc9ac3bef40fd7698e206925ee9df4c809ea1958",
      },
      block_number: "0x361489",
    },
  ];
  const cellProvider = new CellProvider(inputs);
  const upgradeBinary = Uint8Array.of(1, 2, 3);
  const upgradeOptions = {
    cellProvider: cellProvider,
    scriptBinary: upgradeBinary,
    fromInfo: FROMADDRESS,
    typeId: {
      code_hash:
        "0x00000000000000000000000000000000000000000000000000545950455f4944",
      hash_type: "type" as const,
      args:
        "0x2c82a38950de3204a4ae166c50331d1b104e97a21402cb5bdb7ca23bb9c15f0f",
    },
    config: AGGRON4,
  };

  let { txSkeleton } = await deploy.generateUpgradeTypeIdDataTx(upgradeOptions);

  const txFee = getTxFee(txSkeleton);
  const expectTxFee = calculateTxFee(txSkeleton, BI.from(BI.from(1000)));
  t.is(txFee.toString(), expectTxFee.toString());
  t.true(BI.from(txFee).lt(1000000));

  const deployLock = txSkeleton.outputs.get(0)!.cell_output.lock!;
  const changeLock = txSkeleton.outputs.get(1)!.cell_output.lock!;
  t.deepEqual(deployLock, OUTPUTSCRIPTLOCK);
  t.deepEqual(changeLock, OUTPUTSCRIPTLOCK);

  const deployData = txSkeleton.outputs.get(0)!.data;
  t.is(deployData, "0x010203");
});

test("upgrade contract with size reduced", async (t) => {
  const inputs: Cell[] = [
    {
      cell_output: {
        capacity: "0x5f5e10000",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: {
          args:
            "0x2c82a38950de3204a4ae166c50331d1b104e97a21402cb5bdb7ca23bb9c15f0f",
          code_hash:
            "0x00000000000000000000000000000000000000000000000000545950455f4944",
          hash_type: "type",
        },
      },
      data: "0x01010101010101",
      out_point: {
        index: "0x0",
        tx_hash:
          "0x7afcb80f91d0a52bc376e5113494546e825a3de2b7378b3bed91fed35e2839e8",
      },
      block_number: "0x3614af",
    },
    {
      cell_output: {
        capacity: "0x1718adf5a",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0xc68f8f08958c60ad83a81e7e590c3aba6abdaed2bbcfd8fbe0e014b7396affb1",
      },
      block_number: "0x361485",
    },
    {
      cell_output: {
        capacity: "0x98049e1d02f",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0x0f1cf3ddefa6141d16375dfefc9ac3bef40fd7698e206925ee9df4c809ea1958",
      },
      block_number: "0x361489",
    },
  ];
  const cellProvider = new CellProvider(inputs);
  const upgradeBinary = Uint8Array.of(1);
  const upgradeOptions = {
    cellProvider: cellProvider,
    scriptBinary: upgradeBinary,
    fromInfo: FROMADDRESS,
    typeId: {
      code_hash:
        "0x00000000000000000000000000000000000000000000000000545950455f4944",
      hash_type: "type" as const,
      args:
        "0x2c82a38950de3204a4ae166c50331d1b104e97a21402cb5bdb7ca23bb9c15f0f",
    },
    config: AGGRON4,
  };

  let { txSkeleton } = await deploy.generateUpgradeTypeIdDataTx(upgradeOptions);

  const txFee = getTxFee(txSkeleton);
  const expectTxFee = calculateTxFee(txSkeleton, BI.from(BI.from(1000)));
  t.is(txFee.toString(), expectTxFee.toString());
  t.true(BI.from(txFee).lt(1000000));

  const deployLock = txSkeleton.outputs.get(0)!.cell_output.lock!;
  const changeLock = txSkeleton.outputs.get(1)!.cell_output.lock!;
  t.deepEqual(deployLock, OUTPUTSCRIPTLOCK);
  t.deepEqual(changeLock, OUTPUTSCRIPTLOCK);

  const deployData = txSkeleton.outputs.get(0)!.data;
  t.is(deployData, "0x01");
});

test("deploy with data by multisig", async (t) => {
  const inputs: Cell[] = [
    {
      cell_output: {
        capacity: "0x1718c7e00",
        lock: {
          args: "0xed20af7322823d0dc33bfb215486a05082669905",
          code_hash:
            "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x01",
      out_point: {
        index: "0x0",
        tx_hash:
          "0xa11728dd5b27224179c19e831f8e8dc0c67835bcd2d5d3bb87c7cc27d0b66cfc",
      },
      block_number: "0x352583",
    },
    {
      cell_output: {
        capacity: "0x2f4fa9f00",
        lock: {
          args: "0xed20af7322823d0dc33bfb215486a05082669905",
          code_hash:
            "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
          hash_type: "type",
        },
        type: {
          args:
            "0xe9451f3528af55247ff7d3851a00b54a5fe7de38d40dc29580ce2c069332633a",
          code_hash:
            "0x00000000000000000000000000000000000000000000000000545950455f4944",
          hash_type: "type",
        },
      },
      data: "0x01",
      out_point: {
        index: "0x0",
        tx_hash:
          "0x46176211dd8ea0bfaa652a08de97992fec25d243411fec63826c7ee989491d97",
      },
      block_number: "0x3525b6",
    },
    {
      cell_output: {
        capacity: "0xdf0743f080",
        lock: {
          args: "0xed20af7322823d0dc33bfb215486a05082669905",
          code_hash:
            "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0xcaa553f8a2b973e8fb3c88c87742e52ba5d310663dcf9bca435a7572c02e9b81",
      },
      block_number: "0x36f668",
    },
  ];
  const cellProvider = new CellProvider(inputs);
  const deployOptions = {
    cellProvider: cellProvider,
    scriptBinary: SCRIPTBINARY,
    fromInfo: FROMINFO,
    config: AGGRON4,
  };

  let { txSkeleton } = await deploy.generateDeployWithDataTx(deployOptions);

  for (const input of txSkeleton.get("inputs")) {
    const type = input.cell_output.type;
    const data = input.data;
    t.is(type, undefined);
    t.is(data, "0x");
  }

  const txFee = getTxFee(txSkeleton);
  const expectTxFee = calculateTxFee(txSkeleton, BI.from(BI.from(1000)));
  t.is(txFee.toString(), expectTxFee.toString());
  t.true(BI.from(txFee).lt(1000000));

  const deployLock = txSkeleton.outputs.get(0)!.cell_output.lock!;
  const changeLock = txSkeleton.outputs.get(1)!.cell_output.lock!;
  t.deepEqual(deployLock, MULTISIGSCRIPT);
  t.deepEqual(changeLock, MULTISIGSCRIPT);

  const deployData = txSkeleton.outputs.get(0)!.data;
  t.is(deployData, "0x01");

  txSkeleton = common.prepareSigningEntries(txSkeleton);
  const signingEntries = {
    type: "witness_args_lock",
    index: 0,
    message:
      "0x156e0322b21018c83ad7dfbc32f35128d0e374d43308643febf9453b262123c7",
  };
  t.deepEqual(txSkeleton.get("signingEntries").get(0), signingEntries);
});

test("collected capacity is enough for change cell and deploy cell", async (t) => {
  const inputs: Cell[] = [
    {
      cell_output: {
        capacity: "0x2e318fc00",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0x4c9457e28e7dd2c87be8b814e33b94d114b83d10bb3cad37de6c60f408f2773e",
      },
      block_number: "0x36145f",
    },
  ];
  const cellProvider = new CellProvider(inputs);
  const deployOptions = {
    cellProvider: cellProvider,
    scriptBinary: SCRIPTBINARY,
    fromInfo: FROMADDRESS,
    config: AGGRON4,
  };
  const { txSkeleton } = await deploy.generateDeployWithDataTx(deployOptions);
  const changeCapacity = txSkeleton.outputs.get(1)!.cell_output.capacity!;
  t.is(changeCapacity, "0x1718c7c0a");
});

test("collected capacity is NOT enough for change cell and deploy cell", async (t) => {
  const inputs: Cell[] = [
    {
      cell_output: {
        capacity: "0x165a0bc00",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0x4c9457e28e7dd2c87be8b814e33b94d114b83d10bb3cad37de6c60f408f2773e",
      },
      block_number: "0x36145f",
    },
  ];
  const cellProvider = new CellProvider(inputs);
  const deployOptions = {
    cellProvider: cellProvider,
    scriptBinary: SCRIPTBINARY,
    fromInfo: FROMADDRESS,
    config: AGGRON4,
  };
  const error = await t.throwsAsync(() =>
    deploy.generateDeployWithDataTx(deployOptions)
  );
  t.is(error.message, "Not enough capacity in from address!");
});

test("collected capacity is enough for deploy cell but NOT enough for change cell", async (t) => {
  const inputs: Cell[] = [
    {
      cell_output: {
        capacity: "0x2cb417800",
        lock: {
          args: "0x159890a7cacb44a95bef0743064433d763de229c",
          code_hash:
            "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          hash_type: "type",
        },
        type: undefined,
      },
      data: "0x",
      out_point: {
        index: "0x1",
        tx_hash:
          "0x4c9457e28e7dd2c87be8b814e33b94d114b83d10bb3cad37de6c60f408f2773e",
      },
      block_number: "0x36145f",
    },
  ];
  const cellProvider = new CellProvider(inputs);
  const deployOptions = {
    cellProvider: cellProvider,
    scriptBinary: SCRIPTBINARY,
    fromInfo: FROMADDRESS,
    config: AGGRON4,
  };
  const error = await t.throwsAsync(() =>
    deploy.generateDeployWithDataTx(deployOptions)
  );
  t.is(error.message, "Not enough capacity in from address!");
});

'''
'''--- packages/common-scripts/tests/dev_config.ts ---
import { Config } from "@ckb-lumos/config-manager";

export const DEV_CONFIG: Config = {
  PREFIX: "ckt",
  SCRIPTS: {
    SECP256K1_BLAKE160: {
      CODE_HASH:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      HASH_TYPE: "type",
      TX_HASH:
        // "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
        "0x785aa819c8f9f8565a62f744685f8637c1b34886e57154e4e5a2ac7f225c7bf5",
      INDEX: "0x0",
      DEP_TYPE: "dep_group",
      SHORT_ID: 0,
    },
    SECP256K1_BLAKE160_MULTISIG: {
      CODE_HASH:
        "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      HASH_TYPE: "type",
      TX_HASH:
        // "0x6495cede8d500e4309218ae50bbcadb8f722f24cc7572dd2274f5876cb603e4e",
        "0x785aa819c8f9f8565a62f744685f8637c1b34886e57154e4e5a2ac7f225c7bf5",
      INDEX: "0x1",
      DEP_TYPE: "dep_group",
      SHORT_ID: 1,
    },
    DAO: {
      CODE_HASH:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      HASH_TYPE: "type",
      TX_HASH:
        // "0x96fea0dfaac1186fbb98fd452cb9b13976f9a00bcce130035fe2e30dac931d1d",
        "0x13c137fdf071c0ab3e6a4c8aaefc16c9bb7b9593b77822b151b18412ecd2ee41",
      INDEX: "0x2",
      DEP_TYPE: "code",
    },
  },
};

'''
'''--- packages/common-scripts/tests/from_info.test.ts ---
import test from "ava";
import { serializeMultisigScript, multisigArgs } from "../src/from_info";
import { bob } from "./account_info";
import { parseFromInfo } from "../src";
import { predefined } from "@ckb-lumos/config-manager";
import { parseAddress } from "@ckb-lumos/helpers";
const { AGGRON4 } = predefined;

// from https://github.com/nervosnetwork/rfcs/blob/v2020.01.15/rfcs/0021-ckb-address-format/0021-ckb-address-format.md
const multiInfo = {
  R: 1,
  M: 2,
  publicKeyHashes: [
    "0xbd07d9f32bce34d27152a6a0391d324f79aab854",
    "0x094ee28566dff02a012a66505822a2fd67d668fb",
    "0x4643c241e59e81b7876527ebff23dfb24cf16482",
  ],
  multisigArgs: "0x4fb2be2e5d0c1a3b8694f832350a33c1685d477a",
};

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("multisigArgs, single", (t) => {
  const serialized = serializeMultisigScript(bob.fromInfo);
  const args = multisigArgs(serialized);
  t.is(args, bob.multisigArgs);
});

test("multisigArgs, multi", (t) => {
  const serialized = serializeMultisigScript({
    R: multiInfo.R,
    M: multiInfo.M,
    publicKeyHashes: multiInfo.publicKeyHashes,
  });
  const args = multisigArgs(serialized);

  t.is(args, multiInfo.multisigArgs);
});

test("parseFromInfo, secp address", (t) => {
  const result = parseFromInfo(bob.testnetAddress, { config: AGGRON4 });
  const template = AGGRON4.SCRIPTS.SECP256K1_BLAKE160!;

  t.is(result.fromScript.code_hash, template.CODE_HASH);
  t.is(result.fromScript.hash_type, template.HASH_TYPE);
  t.is(result.fromScript.args, bob.blake160);
  t.is(result.multisigScript, undefined);
  t.is(result.destroyable, undefined);
  t.is(result.customData, undefined);
});

test("parseFromInfo, MultisigScript", (t) => {
  const result = parseFromInfo(bob.fromInfo, {
    config: AGGRON4,
  });

  const template = AGGRON4.SCRIPTS.SECP256K1_BLAKE160_MULTISIG!;

  t.is(result.fromScript.code_hash, template.CODE_HASH);
  t.is(result.fromScript.hash_type, template.HASH_TYPE);
  t.is(result.fromScript.args, bob.multisigArgs);
  t.is(result.multisigScript, serializeMultisigScript(bob.fromInfo));
  t.is(result.destroyable, undefined);
  t.is(result.customData, undefined);
});

test("parseFromInfo, ACP, destroyable", (t) => {
  const result = parseFromInfo(
    {
      address: bob.acpTestnetAddress,
      destroyable: true,
    },
    {
      config: AGGRON4,
    }
  );

  const template = AGGRON4.SCRIPTS.ANYONE_CAN_PAY!;

  t.is(result.fromScript.code_hash, template.CODE_HASH);
  t.is(result.fromScript.hash_type, template.HASH_TYPE);
  t.is(result.fromScript.args, bob.blake160);
  t.is(result.multisigScript, undefined);
  t.true(result.destroyable);
  t.is(result.customData, undefined);
});

test("parseFromInfo, ACP, default", (t) => {
  const result = parseFromInfo(
    {
      address: bob.acpTestnetAddress,
    },
    {
      config: AGGRON4,
    }
  );

  const template = AGGRON4.SCRIPTS.ANYONE_CAN_PAY!;

  t.is(result.fromScript.code_hash, template.CODE_HASH);
  t.is(result.fromScript.hash_type, template.HASH_TYPE);
  t.is(result.fromScript.args, bob.blake160);
  t.is(result.multisigScript, undefined);
  t.false(!!result.destroyable);
  t.is(result.customData, undefined);
});

test("parseFromInfo, CustomScript", (t) => {
  const script = parseAddress(bob.acpTestnetAddress, { config: AGGRON4 });
  const customData = "0x1234ab";

  const result = parseFromInfo(
    {
      script,
      customData,
    },
    {
      config: AGGRON4,
    }
  );

  const template = AGGRON4.SCRIPTS.ANYONE_CAN_PAY!;

  t.is(result.fromScript.code_hash, template.CODE_HASH);
  t.is(result.fromScript.hash_type, template.HASH_TYPE);
  t.is(result.fromScript.args, bob.blake160);
  t.is(result.multisigScript, undefined);
  t.is(result.destroyable, undefined);
  t.is(result.customData, customData);
});

'''
'''--- packages/common-scripts/tests/helper.ts ---
import { TransactionSkeletonType } from "@ckb-lumos/helpers";
import { Cell, CellDep, core } from "@ckb-lumos/base";
import { TransactionSkeleton } from "@ckb-lumos/helpers";
import { Reader, normalizers } from "@ckb-lumos/toolkit";

export interface txObject {
  inputs: Cell[];
  outputs: Cell[];
  cellDeps: CellDep[];
}

export function txSkeletonFromJson(
  tx: txObject,
  witnessHolder?: Reader | string
): TransactionSkeletonType {
  let skeleton = TransactionSkeleton({});
  const inputCell: Cell[] = tx.inputs;
  const outputCell: Cell[] = tx.outputs;
  const depCells: CellDep[] = tx.cellDeps;
  skeleton = skeleton.update("inputs", (inputs) => inputs.push(...inputCell));
  skeleton = skeleton.update("outputs", (outputs) =>
    outputs.push(...outputCell)
  );
  skeleton = skeleton.update("cellDeps", (cellDeps) =>
    cellDeps.push(...depCells)
  );

  if (witnessHolder !== undefined) {
    const tmpWitnessArgs = { lock: witnessHolder };
    const tmpWitness = new Reader(
      core.SerializeWitnessArgs(
        normalizers.NormalizeWitnessArgs(tmpWitnessArgs)
      )
    ).serializeJson();
    for (let i = 0; i < inputCell.length; i++) {
      skeleton = skeleton.update("witnesses", (witnesses) =>
        witnesses.push(tmpWitness)
      );
    }
  }

  return skeleton;
}

'''
'''--- packages/common-scripts/tests/inputs.ts ---
import { Cell, Header } from "@ckb-lumos/base";
import { LocktimeCell } from "../src";

export const bobSecpInputs: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x486ead64a7c2c1a3132c2e03d2af364050f4f0f6dfafad291daa7db6aed53e10",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x486ead64a7c2c1a3132c2e03d2af364050f4f0f6dfafad291daa7db6aed53e10",
      index: "0x1",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const bobMultisigInputs: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x74c3264f67663ba244c35453c3b3c790e6ae6dbf24eba5809494d6bf4d9cd89d",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x74c3264f67663ba244c35453c3b3c790e6ae6dbf24eba5809494d6bf4d9cd89d",
      index: "0x1",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const bobMultisigLockInputs: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d80000000000000000",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x765c43a94a38d758dd74ffd3671399da62c1ddeac705a8ca47657970a5be7a13",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const bobAcpCells: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x3419a1c09eb2567f6552ee7a8ecffd64155cffe0f1796e6e61ec088d740c1356",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0xcd56140e689205eeda3a0b853abf985f7cc405df758091601783844c18153527",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const aliceAcpCells: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x3419a1c09eb2567f6552ee7a8ecffd64155cffe0f1796e6e61ec088d740c1356",
        hash_type: "type",
        args: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x0a2955b8ac416a660bff138a8d33d1722086e264c5cdf5a33fea07e9613ec860",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const bobSecpSudtInputs: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: {
        code_hash:
          "0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4",
        hash_type: "type",
        args:
          "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
      },
    },
    data: "0x10270000000000000000000000000000",
    out_point: {
      tx_hash:
        "0x6747f0fa9ae72efc75079b5f7b2347f965df0754e22818f511750f1f2d08d2cc",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const bobMultisigLockSudtInputs: LocktimeCell[] = [
  {
    cell_output: {
      // origin capacity: "0x4a817c800"
      capacity: "0x" + BigInt(20000000000).toString(16),
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d80000000000000000",
      },
      type: {
        code_hash:
          "0x48dbf59b4c7ee1547238021b4869bceedf4eea6b43772e5d66ef8865b6ae7212",
        hash_type: "data",
        args:
          "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
      },
    },
    data: "0x10270000000000000000000000000000",
    out_point: {
      tx_hash:
        "0x6747f0fa9ae72efc75079b5f7b2347f965df0754e22818f511750f1f2d08d2cc",
      index: "0x1",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
    since: "0x0",
    depositBlockHash: undefined,
    withdrawBlockHash: undefined,
    sinceValidationInfo: undefined,
  },
];

export const bobAcpSudtInputs: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x3419a1c09eb2567f6552ee7a8ecffd64155cffe0f1796e6e61ec088d740c1356",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: {
        code_hash:
          "0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4",
        hash_type: "type",
        args:
          "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
      },
    },
    data: "0x10270000000000000000000000000000",
    out_point: {
      tx_hash:
        "0xbe405f293f2a7c981b7ff77a3b59eac192ebd5416a4f5c41728f84e94fb9f8fa",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const aliceAcpSudtInputs: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x3419a1c09eb2567f6552ee7a8ecffd64155cffe0f1796e6e61ec088d740c1356",
        hash_type: "type",
        args: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
      },
      type: {
        code_hash:
          "0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4",
        hash_type: "type",
        args:
          "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
      },
    },
    data: "0xd0070000000000000000000000000000",
    out_point: {
      tx_hash:
        "0xde542cd098d64b3420b5a9f08d48d8745bff268655e51f473a009423193a30fd",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const tipHeader: Header = {
  compact_target: "0x1d4543f7",
  dao: "0x85f96976f65bbf2fc56358de57bb2300a51874a76a153b000068217d4ec10507",
  epoch: "0x28d00ae00013e",
  hash: "0x2a68f7a4162a80c2b9cea95cf8b0d2ff43de80eec0fb37c78a9650271053ba24",
  nonce: "0xf37f9e024d995f35443443be1169f4f9",
  number: "0x36281",
  parent_hash:
    "0x4b714a2d708e49a2ccc27088861b85038525afe06fc69ba9961af272ed94e3ff",
  proposals_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  timestamp: "0x1734b70be18",
  transactions_root:
    "0x3aa8da1d229a6fb5d85ae5d71c6db4f6de9eefab288f2d635a79d0f2a610bc67",
  uncles_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  version: "0x0",
};

export const bobMultisigDaoInputs: Cell[] = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
      },
      type: {
        code_hash:
          "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
        hash_type: "type",
        args: "0x",
      },
    },
    data: "0x0000000000000000",
    out_point: {
      tx_hash:
        "0x391c9a8b9a521f85e898c368419f22e9b814e94266c757384aea2ef090056e6b",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

export const bobSecpDaoDepositInput: Cell = {
  cell_output: {
    capacity: "0x174876e800",
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
    type: {
      code_hash:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      hash_type: "type",
      args: "0x",
    },
  },
  data: "0x0000000000000000",
  out_point: {
    tx_hash:
      "0xd28e3c0cb927d5e9ee2103a4f95887558c2f45d3e9711c1d08d7c9e8773cae54",
    index: "0x0",
  },
  block_hash:
    "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
  block_number: "0x19249",
};

export const bobSecpDaoWithdrawInput: Cell = {
  cell_output: {
    capacity: "0x174876e800",
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
    type: {
      code_hash:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      hash_type: "type",
      args: "0x",
    },
  },
  data: "0x4992010000000000",
  out_point: {
    tx_hash:
      "0x48cfb73ccd70be0cbfbd1abd7ecf316acbd3e1710db581bf4b8c2d724efdae7f",
    index: "0x0",
  },
  block_hash:
    "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
  block_number: "0x1929c",
};

'''
'''--- packages/common-scripts/tests/locktime_pool-bigint.test.ts ---
import test from "ava";
import {
  TransactionSkeleton,
  TransactionSkeletonType,
  Options,
} from "@ckb-lumos/helpers";
import { locktimePool, LocktimeCell, FromInfo } from "../src";
const { transfer, prepareSigningEntries, payFee } = locktimePool;
import { CellProvider } from "./cell_provider";
import { calculateMaximumWithdraw } from "../src/dao";
import { List } from "immutable";
import { DEV_CONFIG } from "./dev_config";
import { Config, predefined } from "@ckb-lumos/config-manager";
import { Header, Cell, CellCollector } from "@ckb-lumos/base";
import { parseFromInfo } from "../src/from_info";
import {
  bobSecpDaoDepositInput,
  bobSecpDaoWithdrawInput,
  tipHeader as inputTipHeader,
} from "./inputs";
import { bob } from "./account_info";
import { since as SinceUtils } from "@ckb-lumos/base";
import { BI } from "@ckb-lumos/bi";
const { AGGRON4 } = predefined;

const originCapacity = "0x174876e800";
const inputInfos: LocktimeCell[] = [
  {
    // multisig
    cell_output: {
      capacity: "0x" + BigInt("100000000000").toString(16),
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d80000000000000000",
      },
      type: undefined,
    },
    out_point: {
      tx_hash:
        "0xb4f92e2a74905ca2d24b952e782c42f35f18893cb56e46728857a926a893f41f",
      index: "0x0",
    },
    block_hash:
      "0x62e03ef430cb72041014224417de08caf73d4e804eaca7813c2015abcd6afe1a",
    block_number: "0x1aee1",
    data: "0x",
    since: "0x0",
    depositBlockHash: undefined,
    withdrawBlockHash: undefined,
    sinceValidationInfo: {
      epoch: "0xa0005002b16",
      block_number: "0x1aee1",
      // timestamp: "0x172b7721b70",
      median_timestamp: "",
    },
  },
  {
    // multisig
    cell_output: {
      capacity: "0x" + BigInt("100000000000").toString(16),
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8152b00c000f00020",
      },
      type: undefined,
    },
    out_point: {
      tx_hash:
        "0x7d18dee8cf66bdc4721d18207dc18434f1d68af75537c89f97cb8618de73d871",
      index: "0x0",
    },
    block_hash:
      "0xee89cacb5ff0dd3edcca3904619693355396536cce45658bf9a9c676ae3819c3",
    block_number: "0x1aedd",
    data: "0x",
    since: "0x2000f000c0002b15",
    depositBlockHash: undefined,
    withdrawBlockHash: undefined,
    sinceValidationInfo: {
      epoch: "0xa0001002b16",
      block_number: "0x1aedd",
      // timestamp: "0x172b6608868",
      median_timestamp: "",
    },
  },
  {
    // default lock, dao
    cell_output: {
      capacity: "0x" + BigInt("100007690204").toString(16),
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
      },
      type: {
        code_hash:
          "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
        hash_type: "type",
        args: "0x",
      },
    },
    out_point: {
      tx_hash:
        "0x42300d78faea694e0e1c2316de091964a0d976a4ed27775597bad2d43a3e17da",
      index: "0x0",
    },
    block_hash:
      "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
    block_number: "0x1929c",
    data: "0x4992010000000000",
    since: "0x20000a00050028ee",
    depositBlockHash:
      "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
    withdrawBlockHash:
      "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
    sinceValidationInfo: undefined,
  },
];

const depositDao =
  "0x8eedf002d7c88852433518952edc28002dd416364532c50800d096d05aac0200";
const withdrawDao =
  "0x39d32247d33f90523d37dae613dd280037e9cc1d7b01c708003d8849d8ac0200";

class LocktimeCellCollector {
  private fromInfo: FromInfo;
  private config: Config;

  constructor(
    fromInfo: FromInfo,
    _: any,
    { config = undefined }: Options = {}
  ) {
    this.fromInfo = fromInfo;
    this.config = config!;
  }

  async *collect() {
    const { fromScript } = parseFromInfo(this.fromInfo, {
      config: this.config,
    });
    for (const info of inputInfos) {
      const lock = info.cell_output.lock;
      if (
        lock.code_hash === fromScript.code_hash &&
        lock.hash_type === fromScript.hash_type
      ) {
        yield info;
      }
    }
  }
}

const cellProvider = new CellProvider([]);
let txSkeleton: TransactionSkeletonType = TransactionSkeleton({ cellProvider });

const tipHeader: Header = {
  compact_target: "0x20010000",
  dao: "0x443110aefc4d1b55b10353894c2a29001e664c552fd16409005ef48f09d50200",
  epoch: "0xa0007002b16",
  hash: "0xf77591af1c30a65d5aec4c4753a3e967ecbcb850f90a9a63f59a4e513029d135",
  nonce: "0x8d543978c6abec5d9924183a39e2eeb0",
  number: "0x1aee3",
  parent_hash:
    "0x421f28afb4187d8034bb3895b671aa183e759f23036a744c792ff9c90b293c9d",
  proposals_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  timestamp: "0x172b772235e",
  transactions_root:
    "0xb8b4cee50a21a4c494d8eb4e34f6232fa72129fa9d7a2e4b09417ae224a43ebd",
  uncles_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  version: "0x0",
};
const aliceAddress = "ckt1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gqfvmy2v";
const bobAddress = "ckt1qyqrdsefa43s6m882pcj53m4gdnj4k440axqswmu83";

const fromInfo: FromInfo = {
  R: 0,
  M: 1,
  publicKeyHashes: ["0x36c329ed630d6ce750712a477543672adab57f4c"],
};

test("BigInt:transfer multisig", async (t) => {
  txSkeleton = await transfer(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BigInt(500 * 10 ** 8),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);
  t.is(txSkeleton.get("inputSinces").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(txSkeleton.get("cellDeps").size, 1);
  t.is(txSkeleton.get("headerDeps").size, 0);
});

test("BigInt:prepareSigningEntries, multisig", async (t) => {
  txSkeleton = await transfer(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BigInt(500 * 10 ** 8),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  txSkeleton = prepareSigningEntries(txSkeleton, { config: DEV_CONFIG });

  t.is(txSkeleton.get("signingEntries").size, 1);

  const expectedMessage =
    "0x185fb55177cefec3187c681889d10f85bb142400bf9817dd68b4efb5b51b9b04";

  const signingEntry = txSkeleton.get("signingEntries").get(0)!;
  t.is(signingEntry.index, 0);
  t.is(signingEntry.type, "witness_args_lock");
  t.is(signingEntry.message, expectedMessage);
});

test("BigInt:transfer multisig & dao", async (t) => {
  txSkeleton = await transfer(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BigInt(2500 * 10 ** 8),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const interest =
    calculateMaximumWithdraw(
      {
        ...inputInfos[2],
        cell_output: {
          ...inputInfos[2].cell_output,
          capacity: originCapacity,
        },
      },
      depositDao,
      withdrawDao
    ) - BigInt(originCapacity);

  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());
  t.is(
    interest.toString(),
    sumOfInputCapacity
      .sub(BI.from(originCapacity).mul(txSkeleton.get("inputs").size))
      .toString()
  );

  t.is(txSkeleton.get("inputs").size, 3);
  t.is(txSkeleton.get("witnesses").size, 3);
  t.is(txSkeleton.get("inputSinces").size, 3);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(txSkeleton.get("cellDeps").size, 3);
  t.is(txSkeleton.get("headerDeps").size, 2);

  const expectedWitnesses = [
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0x61000000100000005500000061000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000",
  ];

  t.true(txSkeleton.get("witnesses").equals(List(expectedWitnesses)));
});

test("BigInt:prepareSigningEntries, multisig & dao", async (t) => {
  txSkeleton = await transfer(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BigInt(2500 * 10 ** 8),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  txSkeleton = await prepareSigningEntries(txSkeleton, { config: DEV_CONFIG });

  t.is(txSkeleton.get("signingEntries").size, 3);

  const expectedMessages = [
    "0x98d2c7a0f7293f7cc95383f9bfd3559db148b661559684b2109c3ee22dc261f6",
    "0x98d2c7a0f7293f7cc95383f9bfd3559db148b661559684b2109c3ee22dc261f6",
    "0x8c34fa355fc0b13cca51e3a9ee9926b1f35795dc22f986d5596fc443321bdc44",
  ];

  expectedMessages.forEach((expectedMessage, index) => {
    const message = txSkeleton
      .get("signingEntries")
      .find((s) => s.type === "witness_args_lock" && s.index === index)!
      .message;
    t.is(message, expectedMessage);
  });
});

test("BigInt:payFee, multisig & dao", async (t) => {
  txSkeleton = await transfer(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BigInt(2500 * 10 ** 8),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  const fee = BigInt(1 * 10 ** 8);
  txSkeleton = await payFee(
    txSkeleton,
    [fromInfo, aliceAddress],
    fee,
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BigInt(i.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BigInt(o.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));

  const interest =
    calculateMaximumWithdraw(
      {
        ...inputInfos[2],
        cell_output: {
          ...inputInfos[2].cell_output,
          capacity: originCapacity,
        },
      },
      depositDao,
      withdrawDao
    ) - BigInt(originCapacity);

  t.is(sumOfOutputCapacity, sumOfInputCapacity - fee);
  t.is(
    interest,
    sumOfInputCapacity -
      BigInt(originCapacity) * BigInt(txSkeleton.get("inputs").size)
  );

  t.is(txSkeleton.get("inputs").size, 3);
  t.is(txSkeleton.get("witnesses").size, 3);
  t.is(txSkeleton.get("inputSinces").size, 3);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(txSkeleton.get("cellDeps").size, 3);
  t.is(txSkeleton.get("headerDeps").size, 2);
});

test("BigInt:Don't update capacity directly when deduct", async (t) => {
  class LocktimeCellCollector {
    private fromInfo: FromInfo;
    private config: Config;

    constructor(
      fromInfo: FromInfo,
      _: any,
      { config = undefined }: Options = {}
    ) {
      this.fromInfo = fromInfo;
      this.config = config!;
    }

    async *collect() {
      const { fromScript } = parseFromInfo(this.fromInfo, {
        config: this.config,
      });
      for (const info of [inputInfos[0]]) {
        const lock = info.cell_output.lock;
        if (
          lock.code_hash === fromScript.code_hash &&
          lock.hash_type === fromScript.hash_type
        ) {
          yield info;
        }
      }
    }
  }

  txSkeleton = await transfer(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BigInt(600 * 10 ** 8),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  const getCapacities = (cells: List<Cell>): string[] => {
    return cells.map((c) => c.cell_output.capacity).toJS();
  };

  const inputCapacitiesBefore = getCapacities(txSkeleton.get("inputs"));
  const outputCapacitiesBefore = getCapacities(txSkeleton.get("outputs"));

  let errFlag: boolean = false;
  try {
    await transfer(
      txSkeleton,
      [fromInfo, aliceAddress],
      bobAddress,
      BigInt(500 * 10 ** 8),
      tipHeader,
      { config: DEV_CONFIG, LocktimeCellCollector }
    );
  } catch {
    errFlag = true;
  }

  const inputCapacitiesAfter = getCapacities(txSkeleton.get("inputs"));
  const outputCapacitiesAfter = getCapacities(txSkeleton.get("outputs"));

  t.true(errFlag);
  t.deepEqual(inputCapacitiesBefore, inputCapacitiesAfter);
  t.deepEqual(outputCapacitiesBefore, outputCapacitiesAfter);
});

const depositHeader = {
  compact_target: "0x20010000",
  dao: "0x8eedf002d7c88852433518952edc28002dd416364532c50800d096d05aac0200",
  epoch: "0xa000500283a",
  hash: "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
  nonce: "0x98e10e0a992f7274c7dc0c62e9d42f02",
  number: "0x19249",
  parent_hash:
    "0xd4f3e8725de77aedadcf15755c0f6cdd00bc8d4a971e251385b59ce8215a5d70",
  proposals_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  timestamp: "0x17293289266",
  transactions_root:
    "0x9294a800ec389d1b0d9e7c570c249da260a44cc2790bd4aa250f3d5c83eb8cde",
  uncles_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  version: "0x0",
};
const withdrawHeader = {
  compact_target: "0x20010000",
  dao: "0x39d32247d33f90523d37dae613dd280037e9cc1d7b01c708003d8849d8ac0200",
  epoch: "0xa0008002842",
  hash: "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
  nonce: "0x7ffb49f45f12f2b30ac45586ecf13de2",
  number: "0x1929c",
  parent_hash:
    "0xfe601308a34f1faf68906d2338e60246674ed1f1fbbad3d8471daca21a11cdf7",
  proposals_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  timestamp: "0x1729cdd69c9",
  transactions_root:
    "0x467d72af12af6cb122985f9838bfc47073bba30cc37a4075aef54b0f0768f384",
  uncles_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  version: "0x0",
};

class RpcMocker {
  constructor() {}

  async get_header(hash: string) {
    if (hash === depositHeader.hash) {
      return depositHeader;
    }
    if (hash === withdrawHeader.hash) {
      return withdrawHeader;
    }

    throw new Error(`Error header hash!`);
  }

  async get_transaction(hash: string): Promise<any> {
    if (hash === bobSecpDaoWithdrawInput.out_point!.tx_hash) {
      return {
        tx_status: {
          block_hash: bobSecpDaoWithdrawInput.block_hash,
        },
        transaction: {
          inputs: [
            {
              previous_output: bobSecpDaoDepositInput.out_point,
            },
          ],
        },
      };
    }

    if (hash === bobSecpDaoDepositInput.out_point!.tx_hash) {
      return {
        tx_status: {
          block_hash: bobSecpDaoDepositInput.block_hash,
        },
      };
    }

    throw new Error("Error transaction hash!");
  }
}

function cloneObject<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

async function collectAllCells(collector: CellCollector): Promise<Cell[]> {
  const cells = [];
  for await (const cell of collector.collect()) {
    cells.push(cell);
  }
  return cells;
}

test("BigInt:CellCollector, dao", async (t) => {
  const cellProvider = new CellProvider([bobSecpDaoWithdrawInput]);
  const tipHeader = cloneObject(inputTipHeader);
  const epochValue = { length: 10, index: 5, number: 10478 };
  const epoch = SinceUtils.generateHeaderEpoch(epochValue);
  tipHeader.epoch = epoch;
  const collector = new locktimePool.CellCollector(
    bob.testnetAddress,
    cellProvider,
    {
      config: AGGRON4,
      NodeRPC: RpcMocker as any,
      tipHeader,
    }
  );

  const maximumWithdrawCapacity = calculateMaximumWithdraw(
    bobSecpDaoWithdrawInput,
    depositHeader.dao,
    withdrawHeader.dao
  );

  const cells = await collectAllCells(collector);

  t.is(cells.length, 1);

  const cell = cells[0]! as LocktimeCell;

  const parsedSince = SinceUtils.parseSince(cell.since);
  t.deepEqual(parsedSince.value, epochValue);
  t.is(cell.depositBlockHash, depositHeader.hash);
  t.is(cell.withdrawBlockHash, withdrawHeader.hash);
  t.is(cell.block_hash, withdrawHeader.hash);
  t.is(cell.block_number, withdrawHeader.number);
  t.is(BigInt(cell.cell_output.capacity), maximumWithdrawCapacity);
});

'''
'''--- packages/common-scripts/tests/locktime_pool.test.ts ---
import test from "ava";
import {
  TransactionSkeleton,
  TransactionSkeletonType,
  Options,
} from "@ckb-lumos/helpers";
import {
  locktimePool,
  LocktimeCell,
  FromInfo,
  secp256k1Blake160Multisig,
} from "../src";
const { prepareSigningEntries, payFee } = locktimePool;
import { CellProvider } from "./cell_provider";
import { List } from "immutable";
import { DEV_CONFIG } from "./dev_config";
import { Config, predefined } from "@ckb-lumos/config-manager";
import { Header, Cell, CellCollector, Script } from "@ckb-lumos/base";
import { parseFromInfo } from "../src/from_info";
import {
  bobMultisigInputs,
  bobSecpDaoDepositInput,
  bobSecpDaoWithdrawInput,
  tipHeader as inputTipHeader,
} from "./inputs";
import { bob } from "./account_info";
import { since as SinceUtils } from "@ckb-lumos/base";
import { transferCompatible } from "../lib/locktime_pool";
import { calculateMaximumWithdrawCompatible } from "../lib/dao";
import { BI } from "@ckb-lumos/bi";
const { AGGRON4 } = predefined;

const originCapacity = "0x174876e800";
const inputInfos: LocktimeCell[] = [
  {
    // multisig
    cell_output: {
      capacity: "0x" + BigInt("100000000000").toString(16),
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d80000000000000000",
      },
      type: undefined,
    },
    out_point: {
      tx_hash:
        "0xb4f92e2a74905ca2d24b952e782c42f35f18893cb56e46728857a926a893f41f",
      index: "0x0",
    },
    block_hash:
      "0x62e03ef430cb72041014224417de08caf73d4e804eaca7813c2015abcd6afe1a",
    block_number: "0x1aee1",
    data: "0x",
    since: "0x0",
    depositBlockHash: undefined,
    withdrawBlockHash: undefined,
    sinceValidationInfo: {
      epoch: "0xa0005002b16",
      block_number: "0x1aee1",
      // timestamp: "0x172b7721b70",
      median_timestamp: "",
    },
  },
  {
    // multisig
    cell_output: {
      capacity: "0x" + BigInt("100000000000").toString(16),
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8152b00c000f00020",
      },
      type: undefined,
    },
    out_point: {
      tx_hash:
        "0x7d18dee8cf66bdc4721d18207dc18434f1d68af75537c89f97cb8618de73d871",
      index: "0x0",
    },
    block_hash:
      "0xee89cacb5ff0dd3edcca3904619693355396536cce45658bf9a9c676ae3819c3",
    block_number: "0x1aedd",
    data: "0x",
    since: "0x2000f000c0002b15",
    depositBlockHash: undefined,
    withdrawBlockHash: undefined,
    sinceValidationInfo: {
      epoch: "0xa0001002b16",
      block_number: "0x1aedd",
      // timestamp: "0x172b6608868",
      median_timestamp: "",
    },
  },
  {
    // default lock, dao
    cell_output: {
      capacity: "0x" + BigInt("100007690204").toString(16),
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
      },
      type: {
        code_hash:
          "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
        hash_type: "type",
        args: "0x",
      },
    },
    out_point: {
      tx_hash:
        "0x42300d78faea694e0e1c2316de091964a0d976a4ed27775597bad2d43a3e17da",
      index: "0x0",
    },
    block_hash:
      "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
    block_number: "0x1929c",
    data: "0x4992010000000000",
    since: "0x20000a00050028ee",
    depositBlockHash:
      "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
    withdrawBlockHash:
      "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
    sinceValidationInfo: undefined,
  },
];

const depositDao =
  "0x8eedf002d7c88852433518952edc28002dd416364532c50800d096d05aac0200";
const withdrawDao =
  "0x39d32247d33f90523d37dae613dd280037e9cc1d7b01c708003d8849d8ac0200";

class LocktimeCellCollector {
  private fromInfo: FromInfo;
  private config: Config;

  constructor(
    fromInfo: FromInfo,
    _: any,
    { config = undefined }: Options = {}
  ) {
    this.fromInfo = fromInfo;
    this.config = config!;
  }

  async *collect() {
    const { fromScript } = parseFromInfo(this.fromInfo, {
      config: this.config,
    });
    for (const info of inputInfos) {
      const lock = info.cell_output.lock;
      if (
        lock.code_hash === fromScript.code_hash &&
        lock.hash_type === fromScript.hash_type
      ) {
        yield info;
      }
    }
  }
}

const cellProvider = new CellProvider([]);
let txSkeleton: TransactionSkeletonType = TransactionSkeleton({ cellProvider });

const tipHeader: Header = {
  compact_target: "0x20010000",
  dao: "0x443110aefc4d1b55b10353894c2a29001e664c552fd16409005ef48f09d50200",
  epoch: "0xa0007002b16",
  hash: "0xf77591af1c30a65d5aec4c4753a3e967ecbcb850f90a9a63f59a4e513029d135",
  nonce: "0x8d543978c6abec5d9924183a39e2eeb0",
  number: "0x1aee3",
  parent_hash:
    "0x421f28afb4187d8034bb3895b671aa183e759f23036a744c792ff9c90b293c9d",
  proposals_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  timestamp: "0x172b772235e",
  transactions_root:
    "0xb8b4cee50a21a4c494d8eb4e34f6232fa72129fa9d7a2e4b09417ae224a43ebd",
  uncles_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  version: "0x0",
};
const aliceAddress = "ckt1qyqwyxfa75whssgkq9ukkdd30d8c7txct0gqfvmy2v";
const bobAddress = "ckt1qyqrdsefa43s6m882pcj53m4gdnj4k440axqswmu83";

const fromInfo: FromInfo = {
  R: 0,
  M: 1,
  publicKeyHashes: ["0x36c329ed630d6ce750712a477543672adab57f4c"],
};

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("JSBI:transferCompatible multisig", async (t) => {
  txSkeleton = await transferCompatible(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BI.from(BI.from(500 * 10 ** 8)),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);
  t.is(txSkeleton.get("inputSinces").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(txSkeleton.get("cellDeps").size, 1);
  t.is(txSkeleton.get("headerDeps").size, 0);
});

test("JSBI:prepareSigningEntries, multisig", async (t) => {
  txSkeleton = await transferCompatible(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BI.from(BI.from(500 * 10 ** 8)),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  txSkeleton = prepareSigningEntries(txSkeleton, { config: DEV_CONFIG });

  t.is(txSkeleton.get("signingEntries").size, 1);

  const expectedMessage =
    "0x185fb55177cefec3187c681889d10f85bb142400bf9817dd68b4efb5b51b9b04";

  const signingEntry = txSkeleton.get("signingEntries").get(0)!;
  t.is(signingEntry.index, 0);
  t.is(signingEntry.type, "witness_args_lock");
  t.is(signingEntry.message, expectedMessage);
});

test("JSBI:transferCompatible multisig & dao", async (t) => {
  txSkeleton = await transferCompatible(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BI.from(BI.from(2500 * 10 ** 8)),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const interest = calculateMaximumWithdrawCompatible(
    {
      ...inputInfos[2],
      cell_output: {
        ...inputInfos[2].cell_output,
        capacity: originCapacity,
      },
    },
    depositDao,
    withdrawDao
  ).sub(originCapacity);

  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());
  t.is(
    interest.toString(),
    sumOfInputCapacity
      .sub(BI.from(originCapacity).mul(txSkeleton.get("inputs").size))
      .toString()
  );

  t.is(txSkeleton.get("inputs").size, 3);
  t.is(txSkeleton.get("witnesses").size, 3);
  t.is(txSkeleton.get("inputSinces").size, 3);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(txSkeleton.get("cellDeps").size, 3);
  t.is(txSkeleton.get("headerDeps").size, 2);

  const expectedWitnesses = [
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "0x61000000100000005500000061000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000",
  ];

  t.true(txSkeleton.get("witnesses").equals(List(expectedWitnesses)));
});

test("JSBI.prepareSigningEntries, multisig & dao", async (t) => {
  txSkeleton = await transferCompatible(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BI.from(BI.from(2500 * 10 ** 8)),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  txSkeleton = await prepareSigningEntries(txSkeleton, { config: DEV_CONFIG });

  t.is(txSkeleton.get("signingEntries").size, 3);

  const expectedMessages = [
    "0x98d2c7a0f7293f7cc95383f9bfd3559db148b661559684b2109c3ee22dc261f6",
    "0x98d2c7a0f7293f7cc95383f9bfd3559db148b661559684b2109c3ee22dc261f6",
    "0x8c34fa355fc0b13cca51e3a9ee9926b1f35795dc22f986d5596fc443321bdc44",
  ];

  expectedMessages.forEach((expectedMessage, index) => {
    const message = txSkeleton
      .get("signingEntries")
      .find((s) => s.type === "witness_args_lock" && s.index === index)!
      .message;
    t.is(message, expectedMessage);
  });
});

test("JSBI:payFee, multisig & dao", async (t) => {
  txSkeleton = await transferCompatible(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BI.from(BI.from(2500 * 10 ** 8)),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  const fee = BI.from(1 * 10 ** 8);
  txSkeleton = await payFee(
    txSkeleton,
    [fromInfo, aliceAddress],
    BI.from(fee),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));

  const interest = calculateMaximumWithdrawCompatible(
    {
      ...inputInfos[2],
      cell_output: {
        ...inputInfos[2].cell_output,
        capacity: originCapacity,
      },
    },
    depositDao,
    withdrawDao
  ).sub(originCapacity);
  console.log(fee);
  console.log(sumOfInputCapacity);
  console.log(sumOfOutputCapacity);
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.sub(fee).toString());
  t.is(
    interest.toString(),
    sumOfInputCapacity
      .sub(BI.from(originCapacity).mul(txSkeleton.get("inputs").size))
      .toString()
  );

  t.is(txSkeleton.get("inputs").size, 3);
  t.is(txSkeleton.get("witnesses").size, 3);
  t.is(txSkeleton.get("inputSinces").size, 3);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(txSkeleton.get("cellDeps").size, 3);
  t.is(txSkeleton.get("headerDeps").size, 2);
});

test("JSBI:Don't update capacity directly when deduct", async (t) => {
  class LocktimeCellCollector {
    private fromInfo: FromInfo;
    private config: Config;

    constructor(
      fromInfo: FromInfo,
      _: any,
      { config = undefined }: Options = {}
    ) {
      this.fromInfo = fromInfo;
      this.config = config!;
    }

    async *collect() {
      const { fromScript } = parseFromInfo(this.fromInfo, {
        config: this.config,
      });
      for (const info of [inputInfos[0]]) {
        const lock = info.cell_output.lock;
        if (
          lock.code_hash === fromScript.code_hash &&
          lock.hash_type === fromScript.hash_type
        ) {
          yield info;
        }
      }
    }
  }

  txSkeleton = await transferCompatible(
    txSkeleton,
    [fromInfo, aliceAddress],
    bobAddress,
    BI.from(BI.from(600 * 10 ** 8)),
    tipHeader,
    { config: DEV_CONFIG, LocktimeCellCollector }
  );

  const getCapacities = (cells: List<Cell>): string[] => {
    return cells.map((c) => c.cell_output.capacity).toJS();
  };

  const inputCapacitiesBefore = getCapacities(txSkeleton.get("inputs"));
  const outputCapacitiesBefore = getCapacities(txSkeleton.get("outputs"));

  let errFlag: boolean = false;
  try {
    await transferCompatible(
      txSkeleton,
      [fromInfo, aliceAddress],
      bobAddress,
      BI.from(BI.from(500 * 10 ** 8)),
      tipHeader,
      { config: DEV_CONFIG, LocktimeCellCollector }
    );
  } catch {
    errFlag = true;
  }

  const inputCapacitiesAfter = getCapacities(txSkeleton.get("inputs"));
  const outputCapacitiesAfter = getCapacities(txSkeleton.get("outputs"));

  t.true(errFlag);
  t.deepEqual(inputCapacitiesBefore, inputCapacitiesAfter);
  t.deepEqual(outputCapacitiesBefore, outputCapacitiesAfter);
});

const depositHeader = {
  compact_target: "0x20010000",
  dao: "0x8eedf002d7c88852433518952edc28002dd416364532c50800d096d05aac0200",
  epoch: "0xa000500283a",
  hash: "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
  nonce: "0x98e10e0a992f7274c7dc0c62e9d42f02",
  number: "0x19249",
  parent_hash:
    "0xd4f3e8725de77aedadcf15755c0f6cdd00bc8d4a971e251385b59ce8215a5d70",
  proposals_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  timestamp: "0x17293289266",
  transactions_root:
    "0x9294a800ec389d1b0d9e7c570c249da260a44cc2790bd4aa250f3d5c83eb8cde",
  uncles_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  version: "0x0",
};
const withdrawHeader = {
  compact_target: "0x20010000",
  dao: "0x39d32247d33f90523d37dae613dd280037e9cc1d7b01c708003d8849d8ac0200",
  epoch: "0xa0008002842",
  hash: "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
  nonce: "0x7ffb49f45f12f2b30ac45586ecf13de2",
  number: "0x1929c",
  parent_hash:
    "0xfe601308a34f1faf68906d2338e60246674ed1f1fbbad3d8471daca21a11cdf7",
  proposals_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  timestamp: "0x1729cdd69c9",
  transactions_root:
    "0x467d72af12af6cb122985f9838bfc47073bba30cc37a4075aef54b0f0768f384",
  uncles_hash:
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  version: "0x0",
};

class RpcMocker {
  constructor() {}

  async get_header(hash: string) {
    if (hash === depositHeader.hash) {
      return depositHeader;
    }
    if (hash === withdrawHeader.hash) {
      return withdrawHeader;
    }

    throw new Error(`Error header hash!`);
  }

  async get_transaction(hash: string): Promise<any> {
    if (hash === bobSecpDaoWithdrawInput.out_point!.tx_hash) {
      return {
        tx_status: {
          block_hash: bobSecpDaoWithdrawInput.block_hash,
        },
        transaction: {
          inputs: [
            {
              previous_output: bobSecpDaoDepositInput.out_point,
            },
          ],
        },
      };
    }

    if (hash === bobSecpDaoDepositInput.out_point!.tx_hash) {
      return {
        tx_status: {
          block_hash: bobSecpDaoDepositInput.block_hash,
        },
      };
    }

    throw new Error("Error transaction hash!");
  }
}

function cloneObject<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

async function collectAllCells(collector: CellCollector): Promise<Cell[]> {
  const cells = [];
  for await (const cell of collector.collect()) {
    cells.push(cell);
  }
  return cells;
}

test("CellCollector, dao, invalid", async (t) => {
  const cellProvider = new CellProvider([bobSecpDaoWithdrawInput]);
  const tipHeader = cloneObject(inputTipHeader);
  const epochValue = { length: 10, index: 4, number: 10478 };
  const epoch = SinceUtils.generateHeaderEpoch(epochValue);
  tipHeader.epoch = epoch;
  const collector = new locktimePool.CellCollector(
    bob.testnetAddress,
    cellProvider,
    {
      config: AGGRON4,
      NodeRPC: RpcMocker as any,
      tipHeader,
    }
  );

  const cells = await collectAllCells(collector);

  t.is(cells.length, 0);
});

test("CellCollector, multisig", async (t) => {
  const tipHeader = inputTipHeader;
  const epochValue = { length: 653, index: 174, number: 318 };
  const since = SinceUtils.generateSince({
    relative: false,
    type: "epochNumber",
    value: epochValue,
  });
  const multisigScript = secp256k1Blake160Multisig.serializeMultisigScript(
    bob.fromInfo
  );
  const args = secp256k1Blake160Multisig.multisigArgs(multisigScript, since);
  const input: Cell = cloneObject(bobMultisigInputs[0]);
  input.cell_output.lock.args = args;
  // For using RpcMocker
  input.block_hash = withdrawHeader.hash;

  const cellProvider = new CellProvider([input]);

  const collector = new locktimePool.CellCollector(
    bob.multisigTestnetAddress,
    cellProvider,
    {
      config: AGGRON4,
      NodeRPC: RpcMocker as any,
      tipHeader,
    }
  );

  const cells = await collectAllCells(collector);

  t.is(cells.length, 1);
  const cell = cells[0]! as LocktimeCell;
  t.is(cell.cell_output.capacity, bobMultisigInputs[0]!.cell_output.capacity);
  t.is(cell.block_hash, withdrawHeader.hash);
  t.is(cell.since, since);
  t.deepEqual(cell.sinceValidationInfo, {
    epoch: withdrawHeader.epoch,
    block_number: withdrawHeader.number,
    // timestamp: withdrawHeader.timestamp,
    median_timestamp: "",
  });
});

test("CellCollector, multisig, timestamp should be skipped", async (t) => {
  const tipHeader = inputTipHeader;
  const since = SinceUtils.generateSince({
    relative: false,
    type: "blockTimestamp",
    value: BI.from(BI.from(0)),
  });
  const multisigScript = secp256k1Blake160Multisig.serializeMultisigScript(
    bob.fromInfo
  );
  const args = secp256k1Blake160Multisig.multisigArgs(multisigScript, since);
  const input: Cell = cloneObject(bobMultisigInputs[0]);
  input.cell_output.lock.args = args;
  // For using RpcMocker
  input.block_hash = withdrawHeader.hash;

  const cellProvider = new CellProvider([input]);

  const collector = new locktimePool.CellCollector(
    bob.multisigTestnetAddress,
    cellProvider,
    {
      config: AGGRON4,
      NodeRPC: RpcMocker as any,
      tipHeader,
    }
  );

  const cells = await collectAllCells(collector);

  t.is(cells.length, 0);
});

test("CellCollector, dao & multisig, dao since > multisig since", async (t) => {
  const tipHeader = cloneObject(inputTipHeader);

  const epochValue = { length: 10, index: 4, number: 10478 };
  const multisigSince = SinceUtils.generateSince({
    relative: false,
    type: "epochNumber",
    value: epochValue,
  });
  const daoEpochValue = { length: 10, index: 5, number: 10478 };
  const daoSince = SinceUtils.generateSince({
    relative: false,
    type: "epochNumber",
    value: daoEpochValue,
  });
  const multisigScript = secp256k1Blake160Multisig.serializeMultisigScript(
    bob.fromInfo
  );
  const args = secp256k1Blake160Multisig.multisigArgs(
    multisigScript,
    multisigSince
  );
  const depositCell: Cell = cloneObject(bobSecpDaoDepositInput);
  const withdrawCell: Cell = cloneObject(bobSecpDaoWithdrawInput);

  const multisigLock: Script = {
    code_hash:
      "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
    hash_type: "type",
    args,
  };

  depositCell.cell_output.lock = cloneObject(multisigLock);
  depositCell.block_hash = depositHeader.hash;
  withdrawCell.cell_output.lock = cloneObject(multisigLock);
  withdrawCell.block_hash = withdrawHeader.hash;

  const headerEpochValue = { length: 10, index: 5, number: 10479 };
  const epoch = SinceUtils.generateHeaderEpoch(headerEpochValue);
  tipHeader.epoch = epoch;

  const cellProvider = new CellProvider([withdrawCell]);
  const collector = new locktimePool.CellCollector(
    bob.multisigTestnetAddress,
    cellProvider,
    {
      config: AGGRON4,
      NodeRPC: RpcMocker as any,
      tipHeader,
    }
  );

  const maximumWithdrawCapacity = calculateMaximumWithdrawCompatible(
    withdrawCell,
    depositHeader.dao,
    withdrawHeader.dao
  );

  const cells = await collectAllCells(collector);

  t.is(cells.length, 1);

  const cell = cells[0]! as LocktimeCell;

  t.is(cell.depositBlockHash, depositHeader.hash);
  t.is(cell.withdrawBlockHash, withdrawHeader.hash);
  t.is(cell.block_hash, withdrawHeader.hash);
  t.is(cell.block_number, withdrawHeader.number);

  // t.is(cell.since, multisigSince)
  t.is(cell.since, daoSince);
  t.is(
    BI.from(cell.cell_output.capacity).toString(),
    maximumWithdrawCapacity.toString()
  );
});

test("CellCollector, dao & multisig, multisig since > dao since", async (t) => {
  const tipHeader = cloneObject(inputTipHeader);

  const epochValue = { length: 10, index: 6, number: 10478 };
  const multisigSince = SinceUtils.generateSince({
    relative: false,
    type: "epochNumber",
    value: epochValue,
  });
  // const daoEpochValue = { length: 10, index: 5, number: 10478 }
  // const daoSince = SinceUtils.generateSince({
  //   relative: false,
  //   type: "epochNumber",
  //   value: daoEpochValue
  // })
  const multisigScript = secp256k1Blake160Multisig.serializeMultisigScript(
    bob.fromInfo
  );
  const args = secp256k1Blake160Multisig.multisigArgs(
    multisigScript,
    multisigSince
  );
  const depositCell: Cell = cloneObject(bobSecpDaoDepositInput);
  const withdrawCell: Cell = cloneObject(bobSecpDaoWithdrawInput);

  const multisigLock: Script = {
    code_hash:
      "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
    hash_type: "type",
    args,
  };

  depositCell.cell_output.lock = cloneObject(multisigLock);
  depositCell.block_hash = depositHeader.hash;
  withdrawCell.cell_output.lock = cloneObject(multisigLock);
  withdrawCell.block_hash = withdrawHeader.hash;

  // number add 1
  const headerEpochValue = { length: 10, index: 5, number: 10479 };
  const epoch = SinceUtils.generateHeaderEpoch(headerEpochValue);
  tipHeader.epoch = epoch;

  const cellProvider = new CellProvider([withdrawCell]);
  const collector = new locktimePool.CellCollector(
    bob.multisigTestnetAddress,
    cellProvider,
    {
      config: AGGRON4,
      NodeRPC: RpcMocker as any,
      tipHeader,
    }
  );

  const maximumWithdrawCapacity = calculateMaximumWithdrawCompatible(
    withdrawCell,
    depositHeader.dao,
    withdrawHeader.dao
  );

  const cells = await collectAllCells(collector);

  t.is(cells.length, 1);

  const cell = cells[0]! as LocktimeCell;

  t.is(cell.depositBlockHash, depositHeader.hash);
  t.is(cell.withdrawBlockHash, withdrawHeader.hash);
  t.is(cell.block_hash, withdrawHeader.hash);
  t.is(cell.block_number, withdrawHeader.number);
  t.is(
    BI.from(cell.cell_output.capacity).toString(),
    maximumWithdrawCapacity.toString()
  );

  t.is(cell.since, multisigSince);
});

test("CellCollector, dao & multisig, multisig since type = blockNumber", async (t) => {
  const tipHeader = cloneObject(inputTipHeader);

  const epochValue = BI.from(1024);
  const multisigSince = SinceUtils.generateSince({
    relative: false,
    type: "blockNumber",
    value: BI.from(epochValue),
  });
  // const daoEpochValue = { length: 10, index: 5, number: 10478 }
  // const daoSince = SinceUtils.generateSince({
  //   relative: false,
  //   type: "epochNumber",
  //   value: daoEpochValue
  // })
  const multisigScript = secp256k1Blake160Multisig.serializeMultisigScript(
    bob.fromInfo
  );
  const args = secp256k1Blake160Multisig.multisigArgs(
    multisigScript,
    multisigSince
  );
  const depositCell: Cell = cloneObject(bobSecpDaoDepositInput);
  const withdrawCell: Cell = cloneObject(bobSecpDaoWithdrawInput);

  const multisigLock: Script = {
    code_hash:
      "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
    hash_type: "type",
    args,
  };

  depositCell.cell_output.lock = cloneObject(multisigLock);
  depositCell.block_hash = depositHeader.hash;
  withdrawCell.cell_output.lock = cloneObject(multisigLock);
  withdrawCell.block_hash = withdrawHeader.hash;

  // number add 1
  const headerEpochValue = { length: 10, index: 5, number: 10479 };
  const epoch = SinceUtils.generateHeaderEpoch(headerEpochValue);
  tipHeader.epoch = epoch;

  const cellProvider = new CellProvider([withdrawCell]);
  const collector = new locktimePool.CellCollector(
    bob.multisigTestnetAddress,
    cellProvider,
    {
      config: AGGRON4,
      NodeRPC: RpcMocker as any,
      tipHeader,
    }
  );

  const cells = await collectAllCells(collector);

  // will skip
  t.is(cells.length, 0);
});

'''
'''--- packages/common-scripts/tests/p2pkh.json ---
{
  "SCRIPTS": {
    "SECP256K1_BLAKE160": {
      "CODE_HASH": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      "HASH_TYPE": "type",
      "TX_HASH": "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
      "INDEX": "0x0",
      "DEP_TYPE": "dep_group"
    },
    "OMNI_LOCK": {
      "CODE_HASH": "0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e",
      "HASH_TYPE": "type",
      "TX_HASH": "0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c",
      "INDEX": "0x0",
      "DEP_TYPE": "code"
    },
    "PW_LOCK": {
      "CODE_HASH": "0x58c5f491aba6d61678b7cf7edf4910b1f5e00ec0cde2f42e0abb4fd9aff25a63",
      "HASH_TYPE": "type",
      "TX_HASH": "0x57a62003daeab9d54aa29b944fc3b451213a5ebdf2e232216a3cfed0dde61b38",
      "INDEX": "0x0",
      "DEP_TYPE": "code"
    }
  },
  "OMNI_LOCK_[G1]": {
    "tx": {
      "inputs": [
        {
          "cell_output": {
            "capacity": "0xdd305a59c0",
            "lock": {
              "args": "0x01a08bcc398854db4eaffd9c28b881c65f91e3a28b00",
              "code_hash": "0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e",
              "hash_type": "type"
            }
          },
          "data": "0x",
          "out_point": {
            "index": "0x1",
            "tx_hash": "0x99b883d44d1d82e6a612baafc3bdd573a96702a378e52b38b86c11c86413a00f"
          },
          "block_number": "0x424da6"
        }
      ],
      "outputs": [
        {
          "cell_output": {
            "capacity": "0x2540be400",
            "lock": {
              "args": "0x159890a7cacb44a95bef0743064433d763de229c",
              "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              "hash_type": "type"
            }
          },
          "data": "0x"
        },
        {
          "cell_output": {
            "capacity": "0xdadc4cef20",
            "lock": {
              "args": "0x01a08bcc398854db4eaffd9c28b881c65f91e3a28b00",
              "code_hash": "0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e",
              "hash_type": "type"
            }
          },
          "data": "0x"
        }
      ],
      "cellDeps": [
        {
          "out_point": {
            "tx_hash": "0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c",
            "index": "0x0"
          },
          "dep_type": "code"
        },
        {
          "out_point": {
            "tx_hash": "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
            "index": "0x0"
          },
          "dep_type": "dep_group"
        }
      ]
    },
    "SIGN_LOCK": {
      "args": "0x01a08bcc398854db4eaffd9c28b881c65f91e3a28b00",
      "code_hash": "0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e",
      "hash_type": "type"
    },
    "MESSAGE": "0x40ff344bc1d32aadbab4029ebb5160b8768734508e562c8dafea664361ec474d"
  },
  "PW_LOCK_[G1]": {
    "tx": {
      "inputs": [
        {
          "cell_output": {
            "capacity": "0xd8884725a0",
            "lock": {
              "args": "0xa41127471f513ff4c37fc76a46b6e9abd74a590b",
              "code_hash": "0x58c5f491aba6d61678b7cf7edf4910b1f5e00ec0cde2f42e0abb4fd9aff25a63",
              "hash_type": "type"
            }
          },
          "data": "0x",
          "out_point": {
            "index": "0x1",
            "tx_hash": "0xebd2f47f26630b38f99d078324163ca7fc521955b3e63b23d016d4f52155356c"
          },
          "block_number": "0x424cb6"
        }
      ],
      "outputs": [
        {
          "cell_output": {
            "capacity": "0x2540be400",
            "lock": {
              "args": "0x159890a7cacb44a95bef0743064433d763de229c",
              "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              "hash_type": "type"
            }
          },
          "data": "0x"
        },
        {
          "cell_output": {
            "capacity": "0xd63439bb00",
            "lock": {
              "args": "0xa41127471f513ff4c37fc76a46b6e9abd74a590b",
              "code_hash": "0x58c5f491aba6d61678b7cf7edf4910b1f5e00ec0cde2f42e0abb4fd9aff25a63",
              "hash_type": "type"
            }
          },
          "data": "0x"
        }
      ],
      "cellDeps": [
        {
          "out_point": {
            "tx_hash": "0x57a62003daeab9d54aa29b944fc3b451213a5ebdf2e232216a3cfed0dde61b38",
            "index": "0x0"
          },
          "dep_type": "code"
        },
        {
          "out_point": {
            "tx_hash": "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
            "index": "0x0"
          },
          "dep_type": "dep_group"
        }
      ]
    },
    "SIGN_LOCK": {
      "args": "0xa41127471f513ff4c37fc76a46b6e9abd74a590b",
      "code_hash": "0x58c5f491aba6d61678b7cf7edf4910b1f5e00ec0cde2f42e0abb4fd9aff25a63",
      "hash_type": "type"
    },
    "MESSAGE": "0x96a0c9b667b73ec970f46cd86e44ebac2995dd3d872bcc9822249906e9c9afa1"
  },
  "SECP256K1_[G1]": {
    "tx": {
      "inputs": [
        {
          "cell_output": {
            "capacity": "0xe68097a560",
            "lock": {
              "args": "0x7f599d5e44c248e211aa1d1ff47276758cab96f4",
              "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              "hash_type": "type"
            }
          },
          "data": "0x",
          "out_point": {
            "index": "0x1",
            "tx_hash": "0x62f634d380484b56cee28c166f55ffc562129f0ef5311618396bbb979b806ab5"
          },
          "block_number": "0x42516f"
        }
      ],
      "outputs": [
        {
          "cell_output": {
            "capacity": "0x2540be400",
            "lock": {
              "args": "0x159890a7cacb44a95bef0743064433d763de229c",
              "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              "hash_type": "type"
            }
          },
          "data": "0x"
        },
        {
          "cell_output": {
            "capacity": "0xe42c8a3ac0",
            "lock": {
              "args": "0x7f599d5e44c248e211aa1d1ff47276758cab96f4",
              "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              "hash_type": "type"
            }
          },
          "data": "0x"
        }
      ],
      "cellDeps": [
        {
          "out_point": {
            "tx_hash": "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
            "index": "0x0"
          },
          "dep_type": "dep_group"
        }
      ]
    },
    "SIGN_LOCK": {
      "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      "hash_type": "type",
      "args": "0x7f599d5e44c248e211aa1d1ff47276758cab96f4"
    },
    "MESSAGE": "0x9081f53dba1baaafd15be1f6b85bc3e961babf04b9b190f7960f1b514b506c0b"
  },
  "SECP256K1_[G1_G1]": {
    "tx": {
      "inputs": [
        {
          "cell_output": {
            "capacity": "0x2540be400",
            "lock": {
              "args": "0x92764594e255afbb89cd9486b0035c393b2c5323",
              "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              "hash_type": "type"
            }
          },
          "data": "0x",
          "out_point": {
            "index": "0x0",
            "tx_hash": "0x45def2fa2371895941e9e0b26ef9c27dca3ab446238548a472fed3b8ccc799f6"
          },
          "block_number": "0x426d67"
        },
        {
          "cell_output": {
            "capacity": "0x2540be400",
            "lock": {
              "args": "0x92764594e255afbb89cd9486b0035c393b2c5323",
              "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              "hash_type": "type"
            }
          },
          "data": "0x",
          "out_point": {
            "index": "0x0",
            "tx_hash": "0x9fb88345432208ea1182987ff62b7911de877e74c8016cf4af5168815ce30480"
          },
          "block_number": "0x426d87"
        }
      ],
      "outputs": [
        {
          "cell_output": {
            "capacity": "0x28fa6ae00",
            "lock": {
              "args": "0xed20af7322823d0dc33bfb215486a05082669905",
              "code_hash": "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
              "hash_type": "type"
            }
          },
          "data": "0x"
        },
        {
          "cell_output": {
            "capacity": "0x2186f9360",
            "lock": {
              "args": "0x92764594e255afbb89cd9486b0035c393b2c5323",
              "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
              "hash_type": "type"
            }
          },
          "data": "0x"
        }
      ],
      "cellDeps": [
        {
          "out_point": {
            "tx_hash": "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
            "index": "0x0"
          },
          "dep_type": "dep_group"
        }
      ]
    },
    "SIGN_LOCK": {
      "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      "hash_type": "type",
      "args": "0x92764594e255afbb89cd9486b0035c393b2c5323"
    },
    "MESSAGE": "0xae04988711de62dca841cb09d78ef182dc3c2c9cc107626d5ccedae75eaf7033"
  }
}

'''
'''--- packages/common-scripts/tests/p2pkh.test.ts ---
import test from "ava";
import { Script, utils } from "@ckb-lumos/base";
import { Reader } from "@ckb-lumos/toolkit";
import { default as createKeccak } from "keccak";
import { createP2PKHMessageGroup } from "../src/p2pkh";
import { txObject, txSkeletonFromJson } from "./helper";
import p2pkhJson from "./p2pkh.json";

test("omni lock [g1]", (t) => {
  const SIGNATURE_PLACEHOLDER = new Reader("0x" + "00".repeat(85));
  let tx = txSkeletonFromJson(
    p2pkhJson["OMNI_LOCK_[G1]"].tx as txObject,
    SIGNATURE_PLACEHOLDER
  );

  const hasher = new utils.CKBHasher();
  const signLock = p2pkhJson["OMNI_LOCK_[G1]"].SIGN_LOCK as Script;

  const messageGroup = createP2PKHMessageGroup(tx, [signLock], {
    hasher: {
      update: (message) => hasher.update(message.buffer),
      digest: () => new Uint8Array(hasher.digestReader().toArrayBuffer()),
    },
  });
  t.is(messageGroup.length, 1);
  t.is(messageGroup[0].index, 0);
  t.deepEqual(messageGroup[0].lock, signLock);
  t.is(messageGroup[0].message, p2pkhJson["OMNI_LOCK_[G1]"].MESSAGE);
});

test("pw lock [g1]", (t) => {
  const SIGNATURE_PLACEHOLDER = "0x" + "00".repeat(65);
  let tx = txSkeletonFromJson(
    p2pkhJson["PW_LOCK_[G1]"].tx as txObject,
    SIGNATURE_PLACEHOLDER
  );

  const keccak = createKeccak("keccak256");
  const signLock = p2pkhJson["PW_LOCK_[G1]"].SIGN_LOCK as Script;

  const messageGroup = createP2PKHMessageGroup(tx, [signLock], {
    hasher: {
      update: (message) => {
        keccak.update(Buffer.from(new Uint8Array(message)));
      },
      digest: () => keccak.digest(),
    },
  });
  t.is(messageGroup.length, 1);
  t.is(messageGroup[0].index, 0);
  t.deepEqual(messageGroup[0].lock, signLock);
  t.is(messageGroup[0].message, p2pkhJson["PW_LOCK_[G1]"].MESSAGE);
});

test("seck256k1 [g1]", (t) => {
  const SIGNATURE_PLACEHOLDER = "0x" + "00".repeat(65);
  let tx = txSkeletonFromJson(
    p2pkhJson["SECP256K1_[G1]"].tx as txObject,
    SIGNATURE_PLACEHOLDER
  );

  const signLock = p2pkhJson["SECP256K1_[G1]"].SIGN_LOCK as Script;

  const messageGroup = createP2PKHMessageGroup(tx, [signLock]);
  t.is(messageGroup.length, 1);
  t.is(messageGroup[0].index, 0);
  t.deepEqual(messageGroup[0].lock, signLock);
  t.is(messageGroup[0].message, p2pkhJson["SECP256K1_[G1]"].MESSAGE);
});

test("seck256k1 [g1, g1]", (t) => {
  const SIGNATURE_PLACEHOLDER = "0x" + "00".repeat(65);
  let tx = txSkeletonFromJson(
    p2pkhJson["SECP256K1_[G1_G1]"].tx as txObject,
    SIGNATURE_PLACEHOLDER
  );

  const signLock = p2pkhJson["SECP256K1_[G1_G1]"].SIGN_LOCK as Script;

  const messageGroup = createP2PKHMessageGroup(tx, [signLock]);
  t.is(messageGroup.length, 1);
  t.is(messageGroup[0].index, 0);
  t.deepEqual(messageGroup[0].lock, signLock);
  t.is(messageGroup[0].message, p2pkhJson["SECP256K1_[G1_G1]"].MESSAGE);
});

test("doesn't fill witnesses beforehand", (t) => {
  let tx = txSkeletonFromJson(p2pkhJson["SECP256K1_[G1]"].tx as txObject);

  const signLock = p2pkhJson["SECP256K1_[G1]"].SIGN_LOCK as Script;

  const error = t.throws(() => createP2PKHMessageGroup(tx, [signLock]));

  t.is(error.message, "Please fill witnesses with 0 first!");
});

'''
'''--- packages/common-scripts/tests/secp256k1_blake160-bigint.test.ts ---
import test from "ava";
import { CellProvider } from "./cell_provider";
import {
  TransactionSkeleton,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import { secp256k1Blake160 } from "../src";
import { predefined } from "@ckb-lumos/config-manager";
const { LINA } = predefined;
import { bob, alice, fullAddressInfo } from "./account_info";
import { inputs } from "./secp256k1_blake160_inputs";

const cellProvider = new CellProvider(inputs());
let txSkeleton: TransactionSkeletonType = TransactionSkeleton({ cellProvider });

test("BigInt:transfer success", async (t) => {
  txSkeleton = await secp256k1Blake160.transfer(
    txSkeleton,
    bob.mainnetAddress,
    alice.mainnetAddress,
    BigInt(1000 * 10 ** 8)
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BigInt(i.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BigInt(o.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  t.is(sumOfOutputCapacity, sumOfInputCapacity);
});

test("BigInt:transfer to non secp256k1_blake160 address", async (t) => {
  txSkeleton = await secp256k1Blake160.transfer(
    txSkeleton,
    bob.mainnetAddress,
    fullAddressInfo.mainnetAddress,
    BigInt(1000 * 10 ** 8)
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BigInt(i.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BigInt(o.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  t.is(sumOfOutputCapacity, sumOfInputCapacity);

  t.is(txSkeleton.get("outputs").size, 2);
  const targetOutput = txSkeleton.get("outputs").get(0)!;
  t.deepEqual(targetOutput.cell_output!.lock, fullAddressInfo.lock);
  const changeOutput = txSkeleton.get("outputs").get(1)!;
  const template = LINA.SCRIPTS.SECP256K1_BLAKE160!;
  const expectedChangeLockScript = {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args: bob.blake160,
  };
  t.deepEqual(changeOutput.cell_output!.lock, expectedChangeLockScript);
});

test("BigInt:payFee", async (t) => {
  txSkeleton = await secp256k1Blake160.transfer(
    txSkeleton,
    bob.mainnetAddress,
    alice.mainnetAddress,
    BigInt(1000 * 10 ** 8)
  );

  const fee = BigInt(1 * 10 ** 8);
  txSkeleton = await secp256k1Blake160.payFee(
    txSkeleton,
    bob.mainnetAddress,
    fee
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BigInt(i.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BigInt(o.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  t.is(sumOfOutputCapacity + fee, sumOfInputCapacity);

  t.is(txSkeleton.get("inputs").size, 1);
});

test("BigInt:prepareSigningEntries", async (t) => {
  const expectedMessage =
    "0xd90a4204aee91348bf2ada132065a9a7aa4479001ec61e046c54804987b309ce";

  txSkeleton = await secp256k1Blake160.transfer(
    txSkeleton,
    bob.mainnetAddress,
    alice.mainnetAddress,
    BigInt(1000 * 10 ** 8)
  );

  const fee = BigInt(1 * 10 ** 8);
  txSkeleton = await secp256k1Blake160.payFee(
    txSkeleton,
    bob.mainnetAddress,
    fee
  );

  txSkeleton = await secp256k1Blake160.prepareSigningEntries(txSkeleton);

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BigInt(i.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BigInt(o.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  t.is(sumOfOutputCapacity + fee, sumOfInputCapacity);

  t.is(txSkeleton.get("inputs").size, 1);

  const message = txSkeleton.get("signingEntries").get(0)!.message;
  t.is(message, expectedMessage);
});

test("BigInt:transfer, skip duplicated input", async (t) => {
  const firstInput = inputs()[0];
  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(firstInput);
  });
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push({
      cell_output: firstInput.cell_output,
      data: "0x",
      out_point: undefined,
      block_hash: undefined,
    });
  });
  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push({
      field: "outputs",
      index: 0,
    });
  });

  txSkeleton = await secp256k1Blake160.transfer(
    txSkeleton,
    bob.mainnetAddress,
    alice.mainnetAddress,
    BigInt(1000 * 10 ** 8)
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BigInt(i.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BigInt(o.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  t.is(sumOfOutputCapacity, sumOfInputCapacity);

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 3);
  t.notDeepEqual(
    txSkeleton.get("inputs").get(0)!.out_point,
    txSkeleton.get("inputs").get(1)!.out_point
  );
});

'''
'''--- packages/common-scripts/tests/secp256k1_blake160.test.ts ---
import test from "ava";
import { CellProvider } from "./cell_provider";
import {
  parseAddress,
  TransactionSkeleton,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import { secp256k1Blake160 } from "../src";
import { predefined } from "@ckb-lumos/config-manager";
const { LINA, AGGRON4 } = predefined;
import { bob, alice, fullAddressInfo } from "./account_info";
import { inputs } from "./secp256k1_blake160_inputs";
import { Cell, values } from "@ckb-lumos/base";
import { bobSecpInputs } from "./inputs";
import { BI } from "@ckb-lumos/bi";

const cellProvider = new CellProvider(inputs());
let txSkeleton: TransactionSkeletonType = TransactionSkeleton({ cellProvider });

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("JSBI:transfer success", async (t) => {
  txSkeleton = await secp256k1Blake160.transferCompatible(
    txSkeleton,
    bob.mainnetAddress,
    alice.mainnetAddress,
    BI.from(BI.from(1000 * 10 ** 8))
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());
});

test("JSBI:transfer to non secp256k1_blake160 address", async (t) => {
  txSkeleton = await secp256k1Blake160.transferCompatible(
    txSkeleton,
    bob.mainnetAddress,
    fullAddressInfo.mainnetAddress,
    BI.from(BI.from(1000 * 10 ** 8))
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("outputs").size, 2);
  const targetOutput = txSkeleton.get("outputs").get(0)!;
  t.deepEqual(targetOutput.cell_output!.lock, fullAddressInfo.lock);
  const changeOutput = txSkeleton.get("outputs").get(1)!;
  const template = LINA.SCRIPTS.SECP256K1_BLAKE160!;
  const expectedChangeLockScript = {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args: bob.blake160,
  };
  t.deepEqual(changeOutput.cell_output!.lock, expectedChangeLockScript);
});

test("JSBI:payFee", async (t) => {
  txSkeleton = await secp256k1Blake160.transferCompatible(
    txSkeleton,
    bob.mainnetAddress,
    alice.mainnetAddress,
    BI.from(BI.from(1000 * 10 ** 8))
  );

  const fee = BI.from(1 * 10 ** 8);
  txSkeleton = await secp256k1Blake160.payFee(
    txSkeleton,
    bob.mainnetAddress,
    BI.from(fee)
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.add(fee).toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("inputs").size, 1);
});

test("JSBI:prepareSigningEntries", async (t) => {
  const expectedMessage =
    "0xd90a4204aee91348bf2ada132065a9a7aa4479001ec61e046c54804987b309ce";

  txSkeleton = await secp256k1Blake160.transferCompatible(
    txSkeleton,
    bob.mainnetAddress,
    alice.mainnetAddress,
    BI.from(BI.from(1000 * 10 ** 8))
  );

  const fee = BI.from(1 * 10 ** 8);
  txSkeleton = await secp256k1Blake160.payFee(
    txSkeleton,
    bob.mainnetAddress,
    BI.from(fee)
  );

  txSkeleton = await secp256k1Blake160.prepareSigningEntries(txSkeleton);

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.add(fee).toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("inputs").size, 1);

  const message = txSkeleton.get("signingEntries").get(0)!.message;
  t.is(message, expectedMessage);
});

// TODO fix test, cause run test only success but failed while run all test
test.skip("JSBI:transferCompatible, skip duplicated input", async (t) => {
  const firstInput = inputs()[0];
  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(firstInput);
  });
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push({
      cell_output: firstInput.cell_output,
      data: "0x",
      out_point: undefined,
      block_hash: undefined,
    });
  });
  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push({
      field: "outputs",
      index: 0,
    });
  });

  txSkeleton = await secp256k1Blake160.transferCompatible(
    txSkeleton,
    bob.mainnetAddress,
    alice.mainnetAddress,
    BI.from(BI.from(1000 * 10 ** 8))
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 3);
  t.notDeepEqual(
    txSkeleton.get("inputs").get(0)!.out_point,
    txSkeleton.get("inputs").get(1)!.out_point
  );
});

test("setupInputCell", async (t) => {
  const inputCell: Cell = inputs()[0];
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  txSkeleton = await secp256k1Blake160.setupInputCell(
    txSkeleton,
    inputCell,
    undefined,
    {
      config: AGGRON4,
    }
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);

  const input: Cell = txSkeleton.get("inputs").get(0)!;
  const output: Cell = txSkeleton.get("outputs").get(0)!;

  t.is(input.cell_output.capacity, output.cell_output.capacity);
  t.is(input.data, output.data);
  t.true(
    new values.ScriptValue(input.cell_output.lock, { validate: false }).equals(
      new values.ScriptValue(output.cell_output.lock, { validate: false })
    )
  );
  t.true(
    (!input.cell_output.type && !output.cell_output.type) ||
      new values.ScriptValue(input.cell_output.type!, {
        validate: false,
      }).equals(
        new values.ScriptValue(output.cell_output.type!, { validate: false })
      )
  );
});

test("injectCapacity", async (t) => {
  const cellProvider = new CellProvider(bobSecpInputs);
  let txSkeleton = TransactionSkeleton({ cellProvider });

  const amount = BI.from(500 * 10 ** 8);
  const output: Cell = {
    cell_output: {
      capacity: "0x" + amount.toString(16),
      lock: parseAddress(alice.testnetAddress, { config: AGGRON4 }),
      type: undefined,
    },
    data: "0x",
  };
  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(output);
  });

  txSkeleton = await secp256k1Blake160.injectCapacity(
    txSkeleton,
    0,
    bob.testnetAddress,
    { config: AGGRON4 }
  );

  txSkeleton = secp256k1Blake160.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0xaeb7b9b819ae94b20bcb02abc7d156cfa771d71e8d8c136dc73f4e5de8d25bf2";
  const message = txSkeleton.get("signingEntries").get(0)!.message;
  t.is(message, expectedMessage);

  t.is(txSkeleton.get("witnesses").size, 1);
  const expectedWitness =
    "0x55000000100000005500000055000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
  const witness = txSkeleton.get("witnesses").get(0)!;
  t.is(witness, expectedWitness);
});

'''
'''--- packages/common-scripts/tests/secp256k1_blake160_inputs.ts ---
import { Cell } from "@ckb-lumos/base";

export const inputs = (): Cell[] => [
  {
    cell_output: {
      capacity: "0x11716ddd8a8e",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
    },
    out_point: {
      tx_hash:
        "0x8ea18fcaa83af496318068fd09c49883269c5eff18748ef3e0dd301108af9c01",
      index: "0x0",
    },
    block_hash:
      "0x70fc58921897f40f0c1b385a7f0e9455484d593dfba928583c770894651320da",
    block_number: "0x1a459",
    data: "0x",
  },
  {
    cell_output: {
      capacity: "0x11715a47ed38",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
    },
    out_point: {
      tx_hash:
        "0xc8536eaef90f9206041076e51ede8d2e40e4e9fd75fa422fa9fd22580f3b79ac",
      index: "0x0",
    },
    block_hash:
      "0x5141078759d32ed72cb579396ef8c3a0fe0bef581216a4cf15cf97cf60ca2674",
    block_number: "0x763b",
    data: "0x",
  },
  {
    cell_output: {
      capacity: "0x11715a8f47f4",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
    },
    out_point: {
      tx_hash:
        "0x8adbe39287d217cab78579af8bae1e0877560d3ab1d7c2019d0e9d62a583b7da",
      index: "0x0",
    },
    block_hash:
      "0x8babe9d40db17962a3b782e58e0c5f380762b22646753a9bf38f9ed1421fba80",
    block_number: "0x7928",
    data: "0x",
  },
];

'''
'''--- packages/common-scripts/tests/secp256k1_blake160_multisig-bigint.test.ts ---
import test from "ava";
import { CellProvider } from "./cell_provider";
import {
  TransactionSkeleton,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import { secp256k1Blake160Multisig } from "../src";
import { predefined } from "@ckb-lumos/config-manager";
const { AGGRON4 } = predefined;
import { bobMultisigInputs } from "./inputs";
import { bob, alice } from "./account_info";

const cellProvider = new CellProvider(bobMultisigInputs);
let txSkeleton: TransactionSkeletonType = TransactionSkeleton({ cellProvider });

test("BigInt:transfer success", async (t) => {
  txSkeleton = await secp256k1Blake160Multisig.transfer(
    txSkeleton,
    bob.fromInfo,
    alice.testnetAddress,
    BigInt(500 * 10 ** 8),
    {
      config: AGGRON4,
    }
  );

  txSkeleton = secp256k1Blake160Multisig.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BigInt(i.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BigInt(o.cell_output.capacity))
    .reduce((result, c) => result + c, BigInt(0));
  t.is(sumOfOutputCapacity, sumOfInputCapacity);

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0x692b35a7f06b5a0d80d6f4b393ae2da0176f4c04883fdc322e4b8861ea88121c";
  const message = txSkeleton.get("signingEntries").get(0)!.message;
  t.is(message, expectedMessage);
  const expectedWitness =
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
  t.is(txSkeleton.get("witnesses").size, 1);
  const witness = txSkeleton.get("witnesses").get(0)!;
  t.is(witness, expectedWitness);
});

'''
'''--- packages/common-scripts/tests/secp256k1_blake160_multisig.test.ts ---
import test from "ava";
import { CellProvider } from "./cell_provider";
import {
  parseAddress,
  TransactionSkeleton,
  TransactionSkeletonType,
} from "@ckb-lumos/helpers";
import { secp256k1Blake160Multisig } from "../src";
import { predefined } from "@ckb-lumos/config-manager";
const { AGGRON4 } = predefined;
import { Cell, values } from "@ckb-lumos/base";
import { bobMultisigInputs } from "./inputs";
import { bob, alice } from "./account_info";
import { BI } from "@ckb-lumos/bi";

const cellProvider = new CellProvider(bobMultisigInputs);
let txSkeleton: TransactionSkeletonType = TransactionSkeleton({ cellProvider });

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("setupInputCell", async (t) => {
  const inputCell: Cell = bobMultisigInputs[0];

  txSkeleton = await secp256k1Blake160Multisig.setupInputCell(
    txSkeleton,
    inputCell,
    bob.fromInfo,
    {
      config: AGGRON4,
    }
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 1);
  t.is(txSkeleton.get("witnesses").size, 1);

  const input: Cell = txSkeleton.get("inputs").get(0)!;
  const output: Cell = txSkeleton.get("outputs").get(0)!;

  t.is(input.cell_output.capacity, output.cell_output.capacity);
  t.is(input.data, output.data);
  t.true(
    new values.ScriptValue(input.cell_output.lock, { validate: false }).equals(
      new values.ScriptValue(output.cell_output.lock, { validate: false })
    )
  );
  t.true(
    (!input.cell_output.type && !output.cell_output.type) ||
      new values.ScriptValue(input.cell_output.type!, {
        validate: false,
      }).equals(
        new values.ScriptValue(output.cell_output.type!, { validate: false })
      )
  );
});

test("JSBI:transfer success", async (t) => {
  txSkeleton = await secp256k1Blake160Multisig.transferCompatible(
    txSkeleton,
    bob.fromInfo,
    alice.testnetAddress,
    BI.from(BI.from(500 * 10 ** 8)),
    {
      config: AGGRON4,
    }
  );

  txSkeleton = secp256k1Blake160Multisig.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0x692b35a7f06b5a0d80d6f4b393ae2da0176f4c04883fdc322e4b8861ea88121c";
  const message = txSkeleton.get("signingEntries").get(0)!.message;
  t.is(message, expectedMessage);
  const expectedWitness =
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
  t.is(txSkeleton.get("witnesses").size, 1);
  const witness = txSkeleton.get("witnesses").get(0)!;
  t.is(witness, expectedWitness);
});

test("injectCapacity", async (t) => {
  const amount = BI.from(500 * 10 ** 8);
  const output: Cell = {
    cell_output: {
      capacity: "0x" + amount.toString(16),
      lock: parseAddress(alice.testnetAddress, { config: AGGRON4 }),
      type: undefined,
    },
    data: "0x",
  };

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push(output);
  });

  txSkeleton = await secp256k1Blake160Multisig.injectCapacity(
    txSkeleton,
    0,
    bob.fromInfo,
    { config: AGGRON4 }
  );

  txSkeleton = secp256k1Blake160Multisig.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("signingEntries").size, 1);
  const expectedMessage =
    "0x692b35a7f06b5a0d80d6f4b393ae2da0176f4c04883fdc322e4b8861ea88121c";
  const message = txSkeleton.get("signingEntries").get(0)!.message;
  t.is(message, expectedMessage);
  const expectedWitness =
    "0x6d000000100000006d0000006d000000590000000000010136c329ed630d6ce750712a477543672adab57f4c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
  t.is(txSkeleton.get("witnesses").size, 1);
  const witness = txSkeleton.get("witnesses").get(0)!;
  t.is(witness, expectedWitness);
});

test("setupInputCell, require fromInfo", async (t) => {
  const inputCell: Cell = bobMultisigInputs[0];

  await t.throwsAsync(async () => {
    await secp256k1Blake160Multisig.setupInputCell(
      txSkeleton,
      inputCell,
      undefined,
      {
        config: AGGRON4,
      }
    );
  });
});

'''
'''--- packages/common-scripts/tests/sudt.test.ts ---
import test from "ava";
import { sudt, common } from "../src";
import { CellProvider } from "./cell_provider";
import {
  TransactionSkeletonType,
  TransactionSkeleton,
  parseAddress,
} from "@ckb-lumos/helpers";
import { bob, alice } from "./account_info";
import { predefined } from "@ckb-lumos/config-manager";
import { Script, utils } from "@ckb-lumos/base";
import { isSudtScript } from "../src/helper";
import {
  bobSecpInputs,
  bobSecpSudtInputs,
  bobMultisigLockSudtInputs,
  tipHeader,
  bobAcpSudtInputs,
  aliceAcpSudtInputs,
} from "./inputs";
import { readBigUInt128LECompatible } from "@ckb-lumos/base/lib/utils";
import { BI } from "@ckb-lumos/bi";
const { AGGRON4 } = predefined;

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("issueToken", async (t) => {
  const cellProvider = new CellProvider(bobSecpInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(10000);
  txSkeleton = await sudt.issueToken(
    txSkeleton,
    bob.testnetAddress,
    BI.from(amount),
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  // sum of outputs capacity should be equal to sum of inputs capacity
  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(0)!.data
    ).toString(),
    amount.toString()
  );

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(0)!.cell_output.type, AGGRON4)
  );
});

test("transfer secp", async (t) => {
  const cellProvider = new CellProvider(bobSecpSudtInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(10000);
  txSkeleton = await sudt.transfer(
    txSkeleton,
    [bob.testnetAddress],
    bob.secpLockHash,
    alice.testnetAddress,
    BI.from(amount),
    bob.testnetAddress,
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  const sumOfInputAmount = txSkeleton
    .get("inputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputAmount = txSkeleton
    .get("outputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputAmount.toString(), sumOfOutputAmount.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(0)!.data
    ).toString(),
    amount.toString()
  );

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(0)!.cell_output.type, AGGRON4)
  );
});

test("transfer locktime pool multisig & secp", async (t) => {
  const cellProvider = new CellProvider([bobSecpInputs[0]]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const since = "0x0";
  const amount = BI.from(10000);

  class LocktimePoolCellCollector {
    constructor() {}

    async *collect() {
      yield bobMultisigLockSudtInputs[0];
    }
  }

  txSkeleton = await sudt.transfer(
    txSkeleton,
    [
      {
        ...bob.fromInfo,
        since,
      },
      bob.testnetAddress,
    ],
    bob.secpLockHash,
    alice.testnetAddress,
    BI.from(amount),
    bob.testnetAddress,
    undefined,
    tipHeader,
    { config: AGGRON4, LocktimePoolCellCollector }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  const sumOfInputAmount = txSkeleton
    .get("inputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputAmount = txSkeleton
    .get("outputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputAmount.toString(), sumOfOutputAmount.toString());

  t.is(txSkeleton.get("cellDeps").size, 3);
  t.is(txSkeleton.get("headerDeps").size, 0);
  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 2);
  const targetOutput = txSkeleton.get("outputs").get(0)!;
  const changeOutput = txSkeleton.get("outputs").get(1)!;
  t.is(
    readBigUInt128LECompatible(targetOutput!.data).toString(),
    amount.toString()
  );
  t.true(isSudtScript(targetOutput.cell_output.type!, AGGRON4));
  t.is(changeOutput!.data, "0x");
  t.is(changeOutput.cell_output.type, undefined);

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(0)!.cell_output.type, AGGRON4)
  );
});

test("ownerForSudt, by address", (t) => {
  const sudtToken = sudt.ownerForSudt(bob.testnetAddress, { config: AGGRON4 });

  t.is(sudtToken, bob.secpLockHash);
});

test("ownerForSudt, by MultisigScript", (t) => {
  const sudtToken = sudt.ownerForSudt(bob.fromInfo);

  const expectedToken =
    "0x52ac8ff1f0486783a5a6a30659715fcee67709c75172ff7b015910ced4586436";

  t.is(sudtToken, expectedToken);
});

test("transfer acp", async (t) => {
  const cellProvider = new CellProvider([
    ...bobAcpSudtInputs,
    ...aliceAcpSudtInputs,
  ]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(10000);
  txSkeleton = await sudt.transfer(
    txSkeleton,
    [bob.acpTestnetAddress],
    bob.secpLockHash,
    alice.acpTestnetAddress,
    BI.from(amount),
    bob.acpTestnetAddress,
    undefined,
    undefined,
    { config: AGGRON4 }
  );

  txSkeleton = common.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  const sumOfInputAmount = txSkeleton
    .get("inputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputAmount = txSkeleton
    .get("outputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputAmount.toString(), sumOfOutputAmount.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(0)!.data
    ).toString(),
    amount
      .add(readBigUInt128LECompatible(aliceAcpSudtInputs[0].data))
      .toString()
  );

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(0)!.cell_output.type, AGGRON4)
  );

  const expectedMessage =
    "0xd35ffba0a67f0637dab904f9940b3080d2ba9d65bf68a028756438c767251eb4";
  t.is(txSkeleton.get("signingEntries").size, 1);
  t.is(txSkeleton.get("signingEntries").get(0)!.message, expectedMessage);
});

test("transfer acp => secp, destroyable", async (t) => {
  const cellProvider = new CellProvider([
    ...bobAcpSudtInputs,
    ...bobSecpInputs,
  ]);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(10000);
  txSkeleton = await sudt.transfer(
    txSkeleton,
    [
      {
        address: bob.acpTestnetAddress,
        destroyable: true,
      },
    ],
    bob.secpLockHash,
    alice.testnetAddress,
    BI.from(amount),
    bob.acpTestnetAddress,
    BI.from(BI.from(1000 * 10 ** 8)),
    undefined,
    { config: AGGRON4 }
  );

  txSkeleton = common.prepareSigningEntries(txSkeleton, {
    config: AGGRON4,
  });

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  const sumOfInputAmount = txSkeleton
    .get("inputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputAmount = txSkeleton
    .get("outputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputAmount.toString(), sumOfOutputAmount.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(0)!.data
    ).toString(),
    amount.toString()
  );

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(0)!.cell_output.type, AGGRON4)
  );

  const expectedMessage =
    "0xf8000f721af269f64f46c41ba0666a20957e9a70fad54e8badeeb6027dc351ad";
  t.is(txSkeleton.get("signingEntries").size, 1);
  t.is(txSkeleton.get("signingEntries").get(0)!.message, expectedMessage);
});

test("transfer secp => secp, change to acp and has previous output, fixed", async (t) => {
  const cellProvider = new CellProvider(bobSecpSudtInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const firstBobSecpInput = bobSecpInputs[0];

  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(firstBobSecpInput);
  });

  const sudtTypeScript: Script = {
    code_hash: AGGRON4.SCRIPTS.SUDT!.CODE_HASH,
    hash_type: AGGRON4.SCRIPTS.SUDT!.HASH_TYPE,
    args: bob.secpLockHash,
  };

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push({
      cell_output: {
        capacity: firstBobSecpInput.cell_output.capacity,
        lock: parseAddress(bob.acpTestnetAddress, { config: AGGRON4 }),
        type: sudtTypeScript,
      },
      data: utils.toBigUInt128LE(BI.from(BI.from(0))),
    });
  });

  txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
    return fixedEntries.push({
      field: "output",
      index: 0,
    });
  });

  const amount = BI.from(2000);
  const capacity = BI.from(200 * 10 ** 8);
  txSkeleton = await sudt.transfer(
    txSkeleton,
    [bob.testnetAddress],
    bob.secpLockHash,
    alice.testnetAddress,
    BI.from(amount),
    bob.acpTestnetAddress,
    BI.from(capacity),
    undefined,
    { config: AGGRON4 }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  const sumOfInputAmount = txSkeleton
    .get("inputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputAmount = txSkeleton
    .get("outputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputAmount.toString(), sumOfOutputAmount.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(0)!.data
    ).toString(),
    BI.from(0).toString()
  );
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(1)!.data
    ).toString(),
    amount.toString()
  );
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(2)!.data
    ).toString(),
    BI.from(10000).sub(amount).toString()
  );

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(1)!.cell_output.type, AGGRON4)
  );

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 3);
  t.is(txSkeleton.get("fixedEntries").size, 3);

  const lastOutput = txSkeleton.get("outputs").get(-1)!;
  t.true(isSudtScript(lastOutput.cell_output.type, AGGRON4));
});

test("transfer secp, split change cell", async (t) => {
  const cellProvider = new CellProvider(bobSecpSudtInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(2000);
  const capacity = BI.from((1000 - 142 - 61) * 10 ** 8);
  txSkeleton = await sudt.transfer(
    txSkeleton,
    [bob.testnetAddress],
    bob.secpLockHash,
    alice.testnetAddress,
    BI.from(amount),
    bob.testnetAddress,
    BI.from(capacity),
    undefined,
    { config: AGGRON4, splitChangeCell: true }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  const sumOfInputAmount = txSkeleton
    .get("inputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputAmount = txSkeleton
    .get("outputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputAmount.toString(), sumOfOutputAmount.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(0)!.data
    ).toString(),
    amount.toString()
  );

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(0)!.cell_output.type, AGGRON4)
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 3);
  t.is(txSkeleton.get("fixedEntries").size, 2);

  const lastOutput = txSkeleton.get("outputs").get(-1)!;
  t.is(lastOutput.cell_output.type, undefined);
});

test("transfer secp, split change cell, not enough for two minimals", async (t) => {
  const cellProvider = new CellProvider(bobSecpSudtInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const amount = BI.from(2000);
  const capacity = BI.from((1000 - 142 - 61 + 1) * 10 ** 8);
  txSkeleton = await sudt.transfer(
    txSkeleton,
    [bob.testnetAddress],
    bob.secpLockHash,
    alice.testnetAddress,
    BI.from(amount),
    bob.testnetAddress,
    BI.from(capacity),
    undefined,
    { config: AGGRON4, splitChangeCell: true }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  const sumOfInputAmount = txSkeleton
    .get("inputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputAmount = txSkeleton
    .get("outputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputAmount.toString(), sumOfOutputAmount.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(0)!.data
    ).toString(),
    amount.toString()
  );

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(0)!.cell_output.type, AGGRON4)
  );

  t.is(txSkeleton.get("inputs").size, 1);
  t.is(txSkeleton.get("outputs").size, 2);
  t.is(txSkeleton.get("fixedEntries").size, 2);

  const lastOutput = txSkeleton.get("outputs").get(-1)!;
  t.not(lastOutput.cell_output.type, undefined);
});

test("transfer secp => secp, change to acp and has previous output, split change cell", async (t) => {
  const cellProvider = new CellProvider(bobSecpSudtInputs);
  let txSkeleton: TransactionSkeletonType = TransactionSkeleton({
    cellProvider,
  });

  const firstBobSecpInput = bobSecpInputs[0];

  txSkeleton = txSkeleton.update("inputs", (inputs) => {
    return inputs.push(firstBobSecpInput);
  });

  const sudtTypeScript: Script = {
    code_hash: AGGRON4.SCRIPTS.SUDT!.CODE_HASH,
    hash_type: AGGRON4.SCRIPTS.SUDT!.HASH_TYPE,
    args: bob.secpLockHash,
  };

  txSkeleton = txSkeleton.update("outputs", (outputs) => {
    return outputs.push({
      cell_output: {
        capacity: firstBobSecpInput.cell_output.capacity,
        lock: parseAddress(bob.acpTestnetAddress, { config: AGGRON4 }),
        type: sudtTypeScript,
      },
      data: utils.toBigUInt128LE(BI.from(BI.from(0))),
    });
  });

  const amount = BI.from(2000);
  const capacity = BI.from((1000 - 142 - 61) * 10 ** 8);
  txSkeleton = await sudt.transfer(
    txSkeleton,
    [bob.testnetAddress],
    bob.secpLockHash,
    alice.testnetAddress,
    BI.from(amount),
    bob.acpTestnetAddress,
    BI.from(capacity),
    undefined,
    { config: AGGRON4, splitChangeCell: true }
  );

  const sumOfInputCapacity = txSkeleton
    .get("inputs")
    .map((i) => BI.from(i.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  const sumOfOutputCapacity = txSkeleton
    .get("outputs")
    .map((o) => BI.from(o.cell_output.capacity))
    .reduce((result, c) => result.add(c), BI.from(0));
  t.is(sumOfOutputCapacity.toString(), sumOfInputCapacity.toString());

  const sumOfInputAmount = txSkeleton
    .get("inputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  const sumOfOutputAmount = txSkeleton
    .get("outputs")
    .filter((i) => i.cell_output.type)
    .map((i) => readBigUInt128LECompatible(i.data))
    .reduce((result, c) => result.add(c), BI.from(0));

  t.is(sumOfInputAmount.toString(), sumOfOutputAmount.toString());

  t.is(txSkeleton.get("cellDeps").size, 2);
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(0)!.data
    ).toString(),
    BI.from(10000).sub(amount).toString()
  );
  t.is(
    readBigUInt128LECompatible(
      txSkeleton.get("outputs").get(1)!.data
    ).toString(),
    amount.toString()
  );

  t.true(
    isSudtScript(txSkeleton.get("outputs").get(1)!.cell_output.type, AGGRON4)
  );

  t.is(txSkeleton.get("inputs").size, 2);
  t.is(txSkeleton.get("outputs").size, 3);
  t.is(txSkeleton.get("fixedEntries").size, 1);

  const lastOutput = txSkeleton.get("outputs").get(-1)!;
  t.is(lastOutput.cell_output.type, undefined);
});

'''
'''--- packages/common-scripts/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib",
    "resolveJsonModule": true,
    "esModuleInterop": true
  },
  "include": ["src"]
}

'''
'''--- packages/config-manager/README.md ---
# @ckb-lumos/config-manager

## Example

```ts
import { initializeConfig, predefined } from '@ckb-lumos/config';
import { generateAddress } from '@ckb-lumos/helper'

initializeConfig(predefined.AGGRON);
generateAddress({...}) // ckt1...

initializeConfig(predefined.LINA);
generateAddress({...}) // ckb1...
```

'''
'''--- packages/config-manager/package.json ---
{
  "name": "@ckb-lumos/config-manager",
  "version": "0.17.0-rc8",
  "description": "Config manager for lumos",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "src"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests}/**/*.ts\"",
    "test": "ava",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "@types/deep-freeze-strict": "^1.1.0",
    "deep-freeze-strict": "^1.1.1"
  }
}

'''
'''--- packages/config-manager/src/helpers.ts ---
import { Script } from "@ckb-lumos/base";
import { ScriptConfig, ScriptConfigs } from "./types";
import { getConfig } from "./manager";

type ScriptTemplate = Omit<Script, "args">;

export function findConfigByScript(
  scriptTemplate: ScriptTemplate,
  SCRIPTS?: ScriptConfigs
): ScriptConfig | undefined {
  const scripts = SCRIPTS || getConfig().SCRIPTS;

  return Object.values(scripts).find(
    (item) =>
      item?.CODE_HASH === scriptTemplate.code_hash &&
      item?.HASH_TYPE === scriptTemplate.hash_type
  );
}

/**
 *
 * We may need to determine if a `scriptTemplate` is a kind of ScriptConfig
 *
 * ```typescript
 * if (keyOfScript({ code_hash... })  === 'SECP256K1')  {
 *   // ...
 * }
 * ```
 * @param scriptTemplate
 * @param SCRIPTS
 */
export function nameOfScript<S extends ScriptConfigs>(
  scriptTemplate: ScriptTemplate,
  SCRIPTS?: ScriptConfigs
): keyof S | undefined {
  const scripts = SCRIPTS || getConfig().SCRIPTS;

  const foundEntry = Object.entries(scripts).find(
    ([, config]) =>
      config?.CODE_HASH === scriptTemplate.code_hash &&
      config?.HASH_TYPE === scriptTemplate.hash_type
  );

  if (!foundEntry) return undefined;
  return foundEntry[0];
}

'''
'''--- packages/config-manager/src/index.ts ---
export * from "./types";
export { initializeConfig, getConfig, validateConfig } from "./manager";
export * as helpers from "./helpers";
export { predefined, createConfig } from "./predefined";

'''
'''--- packages/config-manager/src/manager.ts ---
import deepFreeze from "deep-freeze-strict";
import { logger } from "@ckb-lumos/base";
import { Config } from "./types";
import { predefined } from "./predefined";

function assertHexString(debugPath: string, string: string) {
  if (!/^0x([0-9a-fA-F][0-9a-fA-F])*$/.test(string)) {
    throw new Error(`${debugPath} must be a hex string!`);
  }
}

function assertHash(debugPath: string, hash: string) {
  assertHexString(debugPath, hash);
  if (hash.length != 66) {
    throw new Error(`${debugPath} must be a hex string of 66 bytes long!`);
  }
}

function assertInteger(debugPath: string, i: string) {
  if (i === "0x0") {
    return;
  }
  if (!/^0x[1-9a-fA-F][0-9a-fA-F]*$/.test(i)) {
    throw new Error(`${debugPath} must be a hex integer!`);
  }
}

function nonNullable(
  condition: unknown,
  debugPath = "variable"
): asserts condition {
  if (!condition) throw new Error(`${debugPath} cannot be nil`);
}

export function validateConfig(config: Config) {
  if (typeof config.SCRIPTS !== "object" || config.SCRIPTS == null)
    throw new Error();

  for (const scriptName of Object.keys(config.SCRIPTS)) {
    const scriptConfig = config.SCRIPTS[scriptName];

    nonNullable(scriptConfig?.CODE_HASH);

    assertHash(`SCRIPTS.${scriptName}.CODE_HASH`, scriptConfig.CODE_HASH);
    const hashType = scriptConfig.HASH_TYPE;
    if (hashType !== "type" && hashType !== "data") {
      throw new Error(
        `SCRIPTS.${scriptName}.HASH_TYPE must either be data or type!`
      );
    }
    assertHash(`SCRIPTS.${scriptName}.TX_HASH`, scriptConfig.TX_HASH);
    assertInteger(`SCRIPTS.${scriptName}.INDEX`, scriptConfig.INDEX);
    const depType = scriptConfig.DEP_TYPE;
    if (depType !== "dep_group" && depType !== "code") {
      throw new Error(
        `SCRIPTS.${scriptName}.DEP_TYPE must either be dep_group or code!`
      );
    }
    const shortId = scriptConfig.SHORT_ID;
    // Short ID is optional
    if (shortId != undefined) {
      if (typeof shortId !== "number") {
        throw new Error("SHORT_ID must be a number!");
      }
    }
  }
}

let config: Config = predefined.LINA;

export function getConfig(): Config {
  return config;
}

/**
 * Initialize current app with a config. The initializaton steps work as follows:
 * 1. If `LUMOS_CONFIG_NAME` environment variable is set to a predefined config,
 * the predefined config is loaded;
 * 2. If `LUMOS_CONFIG_FILE` environment variable is set, it will be used as the
 * name of a file containing the Config to use.
 * 3. A file named `config.json` in current running directory will be used as the
 * file containing the Config to use.
 * @deprecated
 * @returns void
 */
function initializeConfigLegacy() {
  const env = process?.env;
  const configName = env?.LUMOS_CONFIG_NAME;

  if (
    (configName === "LINA" || configName === "AGGRON4") &&
    predefined[configName]
  ) {
    config = predefined[configName];
    return;
  }

  const configFile = env?.LUMOS_CONFIG_FILE;
  const configFilename = configFile || "config.json";
  try {
    const data = require("fs").readFileSync(configFilename);
    const loadedConfig = JSON.parse(data);
    validateConfig(loadedConfig);
    config = deepFreeze(loadedConfig);
  } catch (e) {
    throw new Error(`Error loading config from file ${configFilename}: ${e}`);
  }
}

export function initializeConfig(inputConfig?: Config): void {
  if (!inputConfig) {
    logger.deprecated(
      "initializeConfig with env will be deprecated, please migrate to initializeConfig(...)"
    );
    initializeConfigLegacy();
  } else {
    validateConfig(inputConfig);
    config = deepFreeze(inputConfig);
  }
}

'''
'''--- packages/config-manager/src/predefined.ts ---
import deepFreeze from "deep-freeze-strict";
import { ScriptConfig } from "./types";

export type ScriptRecord = Record<string, ScriptConfig>;

/**
 * create a frozen {@link ScriptConfig}, also this is a TypeScript helper to create an autocomplete-friendly {@link ScriptConfigs}
 * @param configShape
 */
export function createConfig<S extends ScriptRecord>(configShape: {
  PREFIX: string;
  SCRIPTS: S;
}): typeof configShape {
  return deepFreeze(configShape);
}

const LINA = createConfig({
  PREFIX: "ckb",
  SCRIPTS: {
    SECP256K1_BLAKE160: {
      CODE_HASH:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      HASH_TYPE: "type",
      TX_HASH:
        "0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c",
      INDEX: "0x0",
      DEP_TYPE: "dep_group",
      SHORT_ID: 0,
    },
    SECP256K1_BLAKE160_MULTISIG: {
      CODE_HASH:
        "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      HASH_TYPE: "type",
      TX_HASH:
        "0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c",
      INDEX: "0x1",
      DEP_TYPE: "dep_group",
      SHORT_ID: 1,
    },
    DAO: {
      CODE_HASH:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      HASH_TYPE: "type",
      TX_HASH:
        "0xe2fb199810d49a4d8beec56718ba2593b665db9d52299a0f9e6e75416d73ff5c",
      INDEX: "0x2",
      DEP_TYPE: "code",
    },
    SUDT: {
      CODE_HASH:
        "0x5e7a36a77e68eecc013dfa2fe6a23f3b6c344b04005808694ae6dd45eea4cfd5",
      HASH_TYPE: "type",
      TX_HASH:
        "0xc7813f6a415144643970c2e88e0bb6ca6a8edc5dd7c1022746f628284a9936d5",
      INDEX: "0x0",
      DEP_TYPE: "code",
    },
    ANYONE_CAN_PAY: {
      CODE_HASH:
        "0xd369597ff47f29fbc0d47d2e3775370d1250b85140c670e4718af712983a2354",
      HASH_TYPE: "type",
      TX_HASH:
        "0x4153a2014952d7cac45f285ce9a7c5c0c0e1b21f2d378b82ac1433cb11c25c4d",
      INDEX: "0x0",
      DEP_TYPE: "dep_group",
    },
  },
});

const AGGRON4 = createConfig({
  PREFIX: "ckt",
  SCRIPTS: {
    SECP256K1_BLAKE160: {
      CODE_HASH:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      HASH_TYPE: "type",
      TX_HASH:
        "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
      INDEX: "0x0",
      DEP_TYPE: "dep_group",
      SHORT_ID: 0,
    },
    SECP256K1_BLAKE160_MULTISIG: {
      CODE_HASH:
        "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      HASH_TYPE: "type",
      TX_HASH:
        "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
      INDEX: "0x1",
      DEP_TYPE: "dep_group",
      SHORT_ID: 1,
    },
    DAO: {
      CODE_HASH:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      HASH_TYPE: "type",
      TX_HASH:
        "0x8f8c79eb6671709633fe6a46de93c0fedc9c1b8a6527a18d3983879542635c9f",
      INDEX: "0x2",
      DEP_TYPE: "code",
    },
    SUDT: {
      CODE_HASH:
        "0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4",
      HASH_TYPE: "type",
      TX_HASH:
        "0xe12877ebd2c3c364dc46c5c992bcfaf4fee33fa13eebdf82c591fc9825aab769",
      INDEX: "0x0",
      DEP_TYPE: "code",
    },
    ANYONE_CAN_PAY: {
      CODE_HASH:
        "0x3419a1c09eb2567f6552ee7a8ecffd64155cffe0f1796e6e61ec088d740c1356",
      HASH_TYPE: "type",
      TX_HASH:
        "0xec26b0f85ed839ece5f11c4c4e837ec359f5adc4420410f6453b1f6b60fb96a6",
      INDEX: "0x0",
      DEP_TYPE: "dep_group",
    },
  },
});

export const predefined = { LINA, AGGRON4 };

'''
'''--- packages/config-manager/src/types.ts ---
/** Deployed script on chain */
export interface ScriptConfig {
  CODE_HASH: string;
  HASH_TYPE: "type" | "data";
  TX_HASH: string;
  INDEX: string;
  DEP_TYPE: "dep_group" | "code";
  /** Short ID for creating CKB address, not all scripts have short IDs. */
  SHORT_ID?: number;
}

export interface ScriptConfigs {
  [field: string]: ScriptConfig | undefined;
}

/**
 * Each config is associated with one chain instance. It might have its
 * own address prefix, and its own set of deployed scripts.
 */
export interface Config {
  PREFIX: string;
  SCRIPTS: ScriptConfigs;
}

'''
'''--- packages/config-manager/tests/helper.test.ts ---
import test from "ava";
import { helpers, initializeConfig, predefined } from "../src";

const SECP256K1_BLAKE160 = predefined.LINA.SCRIPTS.SECP256K1_BLAKE160;

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test.beforeEach(() => {
  initializeConfig(predefined.LINA);
});

test("find config by script", (t) => {
  const config = helpers.findConfigByScript({
    code_hash: SECP256K1_BLAKE160.CODE_HASH,
    hash_type: SECP256K1_BLAKE160.HASH_TYPE,
  });

  t.deepEqual(config, SECP256K1_BLAKE160);
});

test("keyof script in config", (t) => {
  const name = helpers.nameOfScript({
    code_hash: SECP256K1_BLAKE160.CODE_HASH,
    hash_type: SECP256K1_BLAKE160.HASH_TYPE,
  });

  t.is(name, "SECP256K1_BLAKE160");
});

'''
'''--- packages/config-manager/tests/validator.js ---
const test = require("ava");

const { validateConfig, predefined } = require("../lib/index");

test.before(() => {
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("validate all predefined config", (t) => {
  for (const name of Object.keys(predefined)) {
    t.notThrows(() => {
      validateConfig(predefined[name]);
    }, `Predefined config ${name} fails verification!`);
  }
});

test("validate minimal config", (t) => {
  t.notThrows(() => {
    validateConfig({
      PREFIX: "ckb",
      SCRIPTS: {},
    });
  });
});

test("invalidate config", (t) => {
  t.throws(() => {
    validateConfig({
      PREFIX: "ckb",
      SCRIPTS: {
        ABC: {},
      },
    });
  });
});

'''
'''--- packages/config-manager/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib",
    "rootDir": "src"
  },
  "include": ["src"]
}

'''
'''--- packages/experiment/package.json ---
{
  "name": "@ckb-lumos/experiment",
  "version": "0.17.0-rc8",
  "description": "",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "src"
  ],
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/config-manager": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests,examples}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests,examples}/**/*.ts\"",
    "test": "ava **/*.test.ts --timeout=2m",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  }
}

'''
'''--- packages/experiment/src/index.ts ---
import { Script, CellDep } from "@ckb-lumos/base";
import { ScriptConfig, ScriptConfigs } from "@ckb-lumos/config-manager";
import { Reader } from "@ckb-lumos/toolkit";

interface ScriptRegistry<T extends ScriptConfigs> {
  extend: <T1 extends ScriptConfigs>(newPayload: T1) => ScriptRegistry<T & T1>;
  newScript: (key: keyof T, args: string | Reader) => Script;
  isScriptOf: (key: keyof T, script: Script) => boolean;
  newCellDep: (key: keyof T) => CellDep;
  nameOfScript: (script: Script) => keyof T | undefined;
}

export function createScriptRegistry<T extends ScriptConfigs>(
  payload: T
): ScriptRegistry<T> {
  const map: Map<keyof T, ScriptConfig | undefined> = new Map();
  Object.keys(payload).forEach((k) => map.set(k, payload[k]));

  const extend = <T1 extends ScriptConfigs>(newPayload: T1) => {
    return createScriptRegistry({ ...payload, ...newPayload });
  };

  const newScript = (key: keyof T, args: string | Reader) => {
    const config = map.get(key);
    if (config === undefined)
      throw new Error(`${key} doesn't exist in ScriptRegistry`);
    if (typeof args === "string") {
      return {
        code_hash: config.CODE_HASH,
        hash_type: config.HASH_TYPE,
        args: args,
      };
    } else {
      return {
        code_hash: config.CODE_HASH,
        hash_type: config.HASH_TYPE,
        args: args.serializeJson(),
      };
    }
  };

  const isScriptOf = (key: keyof T, script: Script) => {
    const config = map.get(key);
    if (config === undefined)
      throw new Error(`${key} doesn't exist in ScriptRegistry`);
    return (
      script.code_hash === config.CODE_HASH &&
      script.hash_type === config.HASH_TYPE
    );
  };

  const newCellDep = (key: keyof T) => {
    const config = map.get(key);
    if (config === undefined)
      throw new Error(`${key} doesn't exist in ScriptRegistry`);
    return {
      out_point: {
        tx_hash: config.TX_HASH,
        index: config.INDEX,
      },
      dep_type: config.DEP_TYPE,
    };
  };

  const nameOfScript = (script: Script) => {
    let name = undefined;
    map.forEach((value, key) => {
      if (
        script.code_hash === value?.CODE_HASH &&
        script.hash_type === value.HASH_TYPE
      ) {
        name = key;
      }
    });
    return name;
  };

  return {
    extend: extend,
    newScript: newScript,
    isScriptOf: isScriptOf,
    newCellDep: newCellDep,
    nameOfScript: nameOfScript,
  };
}

'''
'''--- packages/experiment/tests/index.test.ts ---
import { createScriptRegistry } from "../src";
import test from "ava";
import { predefined } from "@ckb-lumos/config-manager";
import { Reader } from "@ckb-lumos/toolkit";
import { Script } from "@ckb-lumos/base";
const { AGGRON4 } = predefined;

test("ScriptRegistry", (t) => {
  const registry = createScriptRegistry(AGGRON4.SCRIPTS);

  const secp256k1Script = registry.newScript("SECP256K1_BLAKE160", "0x");
  const SECP256K1_BLAKE160_SCRIPT: Script = {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0x",
  };
  t.deepEqual(secp256k1Script, SECP256K1_BLAKE160_SCRIPT);

  const multiSigScript = registry.newScript(
    "SECP256K1_BLAKE160_MULTISIG",
    new Reader("0x")
  );
  const SECP256K1_BLAKE160_MULTISIG_SCRIPT = {
    code_hash:
      "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
    hash_type: "type",
    args: new Reader("0x").serializeJson(),
  };
  t.deepEqual(multiSigScript, SECP256K1_BLAKE160_MULTISIG_SCRIPT);

  const newRegistry = registry.extend({
    OMNI_LOCK: {
      CODE_HASH:
        "0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e",
      HASH_TYPE: "type",
      TX_HASH:
        "0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c",
      INDEX: "0x0",
      DEP_TYPE: "code",
    },
  });
  const omniCellDep = newRegistry.newCellDep("OMNI_LOCK");
  const OMNI_CELL_DEP = {
    out_point: {
      tx_hash:
        "0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c",
      index: "0x0",
    },
    dep_type: "code",
  };
  t.deepEqual(omniCellDep, OMNI_CELL_DEP);

  const isSecp256k1 = newRegistry.isScriptOf(
    "SECP256K1_BLAKE160",
    SECP256K1_BLAKE160_SCRIPT
  );
  t.is(isSecp256k1, true);
  const isMultiSig = newRegistry.isScriptOf(
    "SECP256K1_BLAKE160_MULTISIG",
    SECP256K1_BLAKE160_SCRIPT
  );
  t.is(isMultiSig, false);

  let scriptName = newRegistry.nameOfScript(SECP256K1_BLAKE160_SCRIPT);
  t.is(scriptName, "SECP256K1_BLAKE160");

  const noneExistScript: Script = {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce7",
    hash_type: "type",
    args: "0x",
  };
  scriptName = newRegistry.nameOfScript(noneExistScript);
  t.is(scriptName, undefined);
});

'''
'''--- packages/experiment/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib",
    "resolveJsonModule": true,
    "esModuleInterop": true
  },
  "include": ["src"]
}

'''
'''--- packages/hd-cache/README.md ---
# `@ckb-lumos/hd-cache`

HD Cache manager for lumos.

## Usage

```javascript
const { CacheManager, CellCollector, CellCollectorWithQueryOptions, getBalance } = require("@ckb-lumos/hd-cache")
const { Indexer } = require("@ckb-lumos/ckb-indexer")
const indexer = new Indexer("http://localhost:8114")
const cacheManger = CacheManager.loadFromKeystore(indexer, "You keystore path", "You password")
// start to sync cache from indexer
cacheManager.startForever()

// if your keystore is from ckb-cli or you set needMasterPublicKey to true, you can get you master public key info by
cacheManager.getMasterPublicKeyInfo() // ckb-cli using this key by default

// now you can using following methods
cacheManager.getNextReceivingPublicKeyInfo()
cacheManager.getNextChangePublicKeyInfo()

// or collect cells  by CellCollectors
const cellCollector = new CellCollector(cacheManager)
// or with queryOptions
const cellCollector = new CellCollectorWithQueryOptions(
  new CellCollector(cacheManger),
  queryOptions,
)

for await (const cell of cellCollector.collect()) {
  console.log(cell)
}

// get HD wallet balance
await getBalance(cellCollector)
```

'''
'''--- packages/hd-cache/package.json ---
{
  "name": "@ckb-lumos/hd-cache",
  "version": "0.17.0-rc8",
  "description": "HD wallet cache in lumos",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "src"
  ],
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "@ckb-lumos/config-manager": "^0.17.0-rc8",
    "@ckb-lumos/hd": "^0.17.0-rc8",
    "@ckb-lumos/ckb-indexer": "^0.17.0-rc8",
    "@ckb-lumos/rpc": "^0.17.0-rc8",
    "immutable": "^4.0.0-rc.12"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests}/**/*.ts\"",
    "test": "ava **/*.test.ts --timeout=2m",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  }
}

'''
'''--- packages/hd-cache/src/index.ts ---
import {
  HexString,
  Script,
  Cell,
  OutPoint,
  QueryOptions,
  Transaction,
  Output,
  CellCollector as CellCollectorInterface,
  helpers,
  utils,
  Indexer,
} from "@ckb-lumos/base";
import { TransactionCollector as TxCollector } from "@ckb-lumos/ckb-indexer";
import { Map, Set } from "immutable";
import { Config, getConfig } from "@ckb-lumos/config-manager";
import { RPC } from "@ckb-lumos/rpc";
import {
  AccountExtendedPublicKey,
  AddressType,
  ExtendedPrivateKey,
  key,
  Keystore,
  mnemonic,
} from "@ckb-lumos/hd";
import { assertPublicKey, assertChainCode } from "@ckb-lumos/hd/lib/helper";
import { BI } from "@ckb-lumos/bi";
const { isCellMatchQueryOptions } = helpers;
const { publicKeyToBlake160 } = key;
const { mnemonicToSeedSync } = mnemonic;

export function serializeOutPoint(outPoint: OutPoint): string {
  return `${outPoint.tx_hash}_${outPoint.index}`;
}

export interface PublicKeyInfo {
  publicKey: HexString;
  path: string;
  index: number;
  blake160: HexString;
  historyTxCount: number;
}

interface LockScriptInfo {
  lockScript: Script;
  publicKeyInfo: PublicKeyInfo;
}

export interface LockScriptMappingInfo {
  code_hash: HexString;
  hash_type: "data" | "type";
  publicKeyToArgs: (publicKey: HexString) => HexString;
}

export class HDCache {
  private masterPublicKeyInfo?: PublicKeyInfo;
  private publicKey: HexString;
  private chainCode: HexString;
  private accountExtendedPublicKey: AccountExtendedPublicKey;

  public readonly receivingKeys: PublicKeyInfo[];
  public readonly changeKeys: PublicKeyInfo[];

  private lockScriptInfos: LockScriptInfo[];
  private infos: LockScriptMappingInfo[];

  static receivingKeyThreshold = 20;
  static changeKeyThreshold = 10;

  static receivingKeyInitCount: number = 30;
  static changeKeyInitCount: number = 20;

  constructor(
    publicKey: HexString,
    chainCode: HexString,
    infos: LockScriptMappingInfo[] = [],
    masterPublicKey?: HexString
  ) {
    if (masterPublicKey) {
      this.masterPublicKeyInfo = {
        publicKey: masterPublicKey,
        blake160: publicKeyToBlake160(masterPublicKey),
        path: AccountExtendedPublicKey.ckbAccountPath,
        index: -1,
        historyTxCount: 0,
      };
    }
    this.publicKey = publicKey;
    this.chainCode = chainCode;
    this.receivingKeys = [];
    this.changeKeys = [];
    this.accountExtendedPublicKey = new AccountExtendedPublicKey(
      this.publicKey,
      this.chainCode
    );
    this.init();

    this.infos = infos;
    this.lockScriptInfos = [];
    this.resetLockScripts();
  }

  getMasterPublicKeyInfo(): PublicKeyInfo | undefined {
    return this.masterPublicKeyInfo;
  }

  updateMasterPublicKeyHistoryTxCount(count: number): void {
    if (this.masterPublicKeyInfo) {
      this.masterPublicKeyInfo.historyTxCount = count;
    }
  }

  getLockScriptInfos(): LockScriptInfo[] {
    return this.lockScriptInfos;
  }

  resetLockScripts(): void {
    this.lockScriptInfos = this.getKeys()
      .map((publicKeyInfo) => {
        return this.infos.map((info) => {
          return {
            lockScript: {
              code_hash: info.code_hash,
              hash_type: info.hash_type,
              args: info.publicKeyToArgs(publicKeyInfo.publicKey),
            },
            publicKeyInfo,
          };
        });
      })
      .flat();
  }

  getKeys(): PublicKeyInfo[] {
    let keys = this.receivingKeys.concat(this.changeKeys);
    if (this.masterPublicKeyInfo) {
      keys = keys.concat([this.masterPublicKeyInfo]);
    }
    return keys;
  }

  private init(): void {
    this.deriveReceivingKeys(HDCache.receivingKeyInitCount);
    this.deriveChangeKeys(HDCache.changeKeyInitCount);
  }

  deriveKeys(): void {
    this.checkAndDeriveReceivingKeys();
    this.checkAndDeriveChangeKeys();

    // auto update LockScriptMappingInfos
    this.resetLockScripts();
  }

  private checkAndDeriveReceivingKeys(): void {
    const lastIndex: number = this.receivingKeys.length - 1;
    const usedKeys = this.receivingKeys.filter(
      (key) => key.historyTxCount !== 0
    );
    const lastUsedIndex: number =
      usedKeys.length === 0 ? -1 : usedKeys[usedKeys.length - 1].index;

    const unusedKeyCount: number = lastIndex - lastUsedIndex;
    if (unusedKeyCount < HDCache.receivingKeyThreshold) {
      this.deriveReceivingKeys(HDCache.receivingKeyThreshold);
    }
  }

  private deriveReceivingKeys(count: number): void {
    if (count <= 0) {
      return;
    }
    const lastIndex: number = this.receivingKeys.length - 1;
    for (let i = lastIndex + 1; i <= lastIndex + count; ++i) {
      this.receivingKeys.push(
        this.generatePublicKeyInfo(AddressType.Receiving, i)
      );
    }
  }

  private checkAndDeriveChangeKeys(): void {
    const lastIndex: number = this.changeKeys[this.changeKeys.length - 1].index;
    const usedKeys = this.changeKeys.filter((key) => key.historyTxCount !== 0);
    const lastUsedIndex: number =
      usedKeys.length === 0 ? -1 : usedKeys[usedKeys.length - 1].index;

    const unusedKeyCount: number = lastIndex - lastUsedIndex;
    if (unusedKeyCount < HDCache.changeKeyThreshold) {
      this.deriveChangeKeys(HDCache.changeKeyThreshold);
    }
  }

  private deriveChangeKeys(count: number): void {
    if (count <= 0) {
      return;
    }
    const lastIndex: number = this.changeKeys.length - 1;
    for (let i = lastIndex + 1; i <= lastIndex + count; ++i) {
      this.changeKeys.push(this.generatePublicKeyInfo(AddressType.Change, i));
    }
  }

  getNextReceivingPublicKeyInfo(): PublicKeyInfo {
    const info: PublicKeyInfo = this.receivingKeys.find(
      (key) => key.historyTxCount === 0
    )!;
    return info;
  }

  getNextChangePublicKeyInfo(): PublicKeyInfo {
    const info: PublicKeyInfo = this.changeKeys.find(
      (key) => key.historyTxCount === 0
    )!;
    return info;
  }

  private generatePublicKeyInfo(
    type: AddressType,
    index: number
  ): PublicKeyInfo {
    const publicKeyInfo = this.accountExtendedPublicKey.publicKeyInfo(
      type,
      index
    );
    return {
      publicKey: publicKeyInfo.publicKey,
      blake160: publicKeyInfo.blake160,
      path: publicKeyInfo.path,
      index,
      historyTxCount: 0,
    };
  }
}

function outputToCell(
  output: Output,
  data: HexString,
  txHash: HexString,
  index: HexString,
  blockHash: HexString,
  blockNumber: HexString
): Cell {
  return {
    cell_output: {
      capacity: output.capacity,
      lock: output.lock,
      type: output.type,
    },
    out_point: {
      tx_hash: txHash,
      index,
    },
    data: data,
    block_hash: blockHash,
    block_number: blockNumber,
  };
}

function lockScriptMatch(script: Script, otherScript: Script): boolean {
  const shorterArgsLength = Math.min(
    script.args.length,
    otherScript.args.length
  );
  return (
    script.code_hash === otherScript.code_hash &&
    script.hash_type === otherScript.hash_type &&
    script.args.slice(0, shorterArgsLength) ===
      otherScript.args.slice(0, shorterArgsLength)
  );
}

export class TransactionCache {
  // key: public key
  // value: transaction hash set
  private totalTransactionCountCache: Map<HexString, Set<HexString>>;
  private liveCellCache: Map<string, Cell>;
  private hdCache: HDCache;

  constructor(hdCache: HDCache) {
    this.liveCellCache = Map<string, Cell>();
    this.totalTransactionCountCache = Map();
    this.hdCache = hdCache;
  }

  getLiveCellCache(): Map<string, Cell> {
    return this.liveCellCache;
  }

  addTransactionCountCache(key: HexString, value: HexString): void {
    const previous = this.totalTransactionCountCache.get(key);
    const set = previous || Set<HexString>();
    this.totalTransactionCountCache = this.totalTransactionCountCache.set(
      key,
      set.add(value)
    );

    const count: number = this.totalTransactionCountCache.get(key)!.size;
    const receivingIndex: number = this.hdCache.receivingKeys.findIndex(
      (k) => k.publicKey === key
    );
    if (receivingIndex >= 0) {
      this.hdCache.receivingKeys[receivingIndex].historyTxCount = count;
    } else {
      const changeIndex: number = this.hdCache.changeKeys.findIndex(
        (k) => k.publicKey === key
      );
      if (changeIndex >= 0) {
        this.hdCache.changeKeys[changeIndex].historyTxCount = count;
      } else {
        const masterPublicKeyInfo = this.hdCache.getMasterPublicKeyInfo();
        if (masterPublicKeyInfo && masterPublicKeyInfo.publicKey === key) {
          this.hdCache.updateMasterPublicKeyHistoryTxCount(count);
        }
      }
    }
  }

  parseTransaction(
    transaction: Transaction,
    lockScript: Script,
    publicKey: HexString,
    blockHash: HexString,
    blockNumber: HexString
  ): void {
    const txHash: HexString = transaction.hash!;

    const outputs: Cell[] = transaction.outputs
      .map((output, index) => {
        if (!lockScriptMatch(output.lock, lockScript)) {
          return;
        }

        const outputIndex: HexString = "0x" + index.toString(16);

        const cell: Cell = outputToCell(
          output,
          transaction.outputs_data[index],
          txHash,
          outputIndex,
          blockHash,
          blockNumber
        );

        return cell;
      })
      .filter((output) => !!output) as Cell[];

    const inputOutPoints = transaction.inputs.map((input) => {
      return input.previous_output;
    });

    this.addTransactionCountCache(publicKey, txHash);

    outputs.forEach((output) => {
      const key = serializeOutPoint(output.out_point!);
      this.liveCellCache = this.liveCellCache.set(key, output);
    });
    inputOutPoints.forEach((inputOutPoint) => {
      const key = serializeOutPoint(inputOutPoint);
      this.liveCellCache = this.liveCellCache.delete(key);
    });
  }
}

export class Cache {
  public readonly hdCache: HDCache;
  public readonly txCache: TransactionCache;
  private indexer: Indexer;

  private lastTipBlockNumber: BI = BI.from(0);
  private TransactionCollector: any;

  private rpc: RPC;

  constructor(
    indexer: Indexer,
    publicKey: HexString,
    chainCode: HexString,
    infos: LockScriptMappingInfo[],
    {
      TransactionCollector = TxCollector,
      masterPublicKey = undefined,
      rpc = new RPC(indexer.uri),
    }: {
      TransactionCollector?: any;
      masterPublicKey?: HexString;
      rpc?: RPC;
    } = {}
  ) {
    this.indexer = indexer;
    this.hdCache = new HDCache(publicKey, chainCode, infos, masterPublicKey);
    this.txCache = new TransactionCache(this.hdCache);

    this.TransactionCollector = TransactionCollector;

    this.rpc = rpc;
  }

  getLastTipBlockNumber(): HexString {
    return "0x" + this.lastTipBlockNumber.toString(16);
  }

  async tip(): Promise<HexString> {
    const t = await this.indexer.tip();
    return t.block_number;
  }

  private async innerLoopTransactions(fromBlock: BI, toBlock: BI) {
    for (const lockScriptInfo of this.hdCache.getLockScriptInfos()) {
      const lockScript: Script = lockScriptInfo.lockScript;
      const transactionCollector = new this.TransactionCollector(
        this.indexer,
        {
          lock: lockScript,
          fromBlock: "0x" + fromBlock.toString(16),
          toBlock: "0x" + toBlock.toString(16),
          argsLen: "any",
        },
        {
          includeStatus: true,
        }
      );

      for await (const txWithStatus of transactionCollector.collect()) {
        const tx = txWithStatus.transaction;
        const blockHash: HexString = txWithStatus.tx_status.block_hash!;
        const tipHeader = await this.rpc.get_header(blockHash);
        const blockNumber: HexString = tipHeader!.number;
        this.txCache.parseTransaction(
          tx,
          lockScript,
          lockScriptInfo.publicKeyInfo.publicKey,
          blockHash,
          blockNumber
        );
        this.hdCache.deriveKeys();
      }
    }
  }

  private async loopTransactions(tipBlockNumber: HexString) {
    const tip: BI = BI.from(tipBlockNumber);
    if (tip.lte(this.lastTipBlockNumber)) {
      return;
    }

    await this.innerLoopTransactions(this.lastTipBlockNumber.add(1), tip);
    this.lastTipBlockNumber = tip;
  }

  async loop() {
    const tipBlockNumber: HexString = (await this.indexer.tip()).block_number;
    await this.loopTransactions(tipBlockNumber);
  }
}

// export for tests
export function publicKeyToMultisigArgs(publicKey: HexString): HexString {
  const blake160: HexString = publicKeyToBlake160(publicKey);

  const R = 0;
  const M = 1;
  const publicKeyHashes = [blake160];

  const serialized =
    "0x00" +
    ("00" + R.toString(16)).slice(-2) +
    ("00" + M.toString(16)).slice(-2) +
    ("00" + publicKeyHashes.length.toString(16)).slice(-2) +
    publicKeyHashes.map((h) => h.slice(2)).join("");

  const args = new utils.CKBHasher()
    .update(serialized)
    .digestHex()
    .slice(0, 42);
  return args;
}

export function getDefaultInfos(
  config: Config | undefined = undefined
): LockScriptMappingInfo[] {
  config = config || getConfig();
  const infos: LockScriptMappingInfo[] = [];
  const secpTemplate = config.SCRIPTS.SECP256K1_BLAKE160;
  if (secpTemplate) {
    infos.push({
      code_hash: secpTemplate.CODE_HASH,
      hash_type: secpTemplate.HASH_TYPE,
      publicKeyToArgs: publicKeyToBlake160,
    });
  }
  const multisigTemplate = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
  if (multisigTemplate) {
    infos.push({
      code_hash: multisigTemplate.CODE_HASH,
      hash_type: multisigTemplate.HASH_TYPE,
      publicKeyToArgs: publicKeyToMultisigArgs,
    });
  }
  const anyoneCanPayTemplate = config.SCRIPTS.ANYONE_CAN_PAY;
  if (anyoneCanPayTemplate) {
    infos.push({
      code_hash: anyoneCanPayTemplate.CODE_HASH,
      hash_type: anyoneCanPayTemplate.HASH_TYPE,
      publicKeyToArgs: publicKeyToBlake160,
    });
  }

  return infos;
}

function defaultLogger(level: string, message: string): void {
  console.log(`[${level}] ${message}`);
}

// Cache manager
export class CacheManager {
  private cache: Cache;
  private logger: (level: string, message: string) => void;
  private isRunning: boolean;
  private livenessCheckIntervalSeconds: number;
  private pollIntervalSeconds: number;

  constructor(
    indexer: Indexer,
    publicKey: HexString,
    chainCode: HexString,
    masterPublicKey?: HexString,
    infos: LockScriptMappingInfo[] = getDefaultInfos(),
    {
      logger = defaultLogger,
      pollIntervalSeconds = 2,
      livenessCheckIntervalSeconds = 5,
      TransactionCollector = TxCollector,
      rpc = new RPC(indexer.uri),
    }: {
      logger?: (level: string, message: string) => void;
      pollIntervalSeconds?: number;
      livenessCheckIntervalSeconds?: number;
      TransactionCollector?: any;
      rpc?: RPC;
    } = {}
  ) {
    assertPublicKey(publicKey);
    assertChainCode(chainCode);
    if (masterPublicKey) {
      assertPublicKey(masterPublicKey, "masterPublicKey");
    }
    this.logger = logger;
    this.cache = new Cache(indexer, publicKey, chainCode, infos, {
      TransactionCollector,
      masterPublicKey,
      rpc,
    });
    this.isRunning = false;
    this.pollIntervalSeconds = pollIntervalSeconds;
    this.livenessCheckIntervalSeconds = livenessCheckIntervalSeconds;
  }

  /**
   * Load from keystore, if needMasterPublicKey set to true or origin = "ckb-cli",
   * will enable masterPublicKey
   *
   * @param indexer
   * @param path
   * @param password
   * @param infos
   * @param options
   */
  static loadFromKeystore(
    indexer: Indexer,
    path: string,
    password: string,
    infos: LockScriptMappingInfo[] = getDefaultInfos(),
    options: {
      logger?: (level: string, message: string) => void;
      pollIntervalSeconds?: number;
      livenessCheckIntervalSeconds?: number;
      TransactionCollector?: any;
      needMasterPublicKey?: boolean;
      rpc?: RPC;
    } = {}
  ): CacheManager {
    const keystore = Keystore.load(path);
    const extendedPrivateKey = keystore.extendedPrivateKey(password);
    const accountExtendedPublicKey = extendedPrivateKey.toAccountExtendedPublicKey();

    let masterPublicKey: HexString | undefined;
    if (options.needMasterPublicKey || keystore.isFromCkbCli()) {
      const extendedPublicKey = extendedPrivateKey.toExtendedPublicKey();
      masterPublicKey = extendedPublicKey.publicKey;
    }

    return new CacheManager(
      indexer,
      accountExtendedPublicKey.publicKey,
      accountExtendedPublicKey.chainCode,
      masterPublicKey,
      infos,
      options
    );
  }

  static fromMnemonic(
    indexer: Indexer,
    mnemonic: string,
    infos: LockScriptMappingInfo[] = getDefaultInfos(),
    options: {
      logger?: (level: string, message: string) => void;
      pollIntervalSeconds?: number;
      livenessCheckIntervalSeconds?: number;
      TransactionCollector?: any;
      needMasterPublicKey?: boolean;
      rpc?: RPC;
    } = {}
  ): CacheManager {
    const seed = mnemonicToSeedSync(mnemonic);
    const extendedPrivateKey = ExtendedPrivateKey.fromSeed(seed);
    const accountExtendedPublicKey = extendedPrivateKey.toAccountExtendedPublicKey();

    let masterPublicKey: HexString | undefined;
    if (options.needMasterPublicKey) {
      const extendedPublicKey = extendedPrivateKey.toExtendedPublicKey();
      masterPublicKey = extendedPublicKey.publicKey;
    }

    return new CacheManager(
      indexer,
      accountExtendedPublicKey.publicKey,
      accountExtendedPublicKey.chainCode,
      masterPublicKey,
      infos,
      options
    );
  }

  running(): boolean {
    return this.isRunning;
  }

  scheduleLoop() {
    setTimeout(() => {
      this.loop();
    }, this.pollIntervalSeconds * 1000);
  }

  stop() {
    this.isRunning = false;
  }

  async loop() {
    if (!this.running()) {
      return;
    }
    this.cache
      .loop()
      .then(() => {
        this.scheduleLoop();
      })
      .catch((e) => {
        this.logger(
          "error",
          `Error occurs: ${e} ${e.stack}, stopping indexer!`
        );
        this.stop();
      });
  }

  start() {
    this.isRunning = true;
    this.scheduleLoop();
  }

  startForever() {
    this.start();
    setInterval(() => {
      if (!this.running()) {
        this.logger("error", "Error occurs, maybe check the log?");
        this.start();
      }
    }, this.livenessCheckIntervalSeconds * 1000);
  }

  getLiveCellsCache(): Map<string, Cell> {
    return this.cache.txCache.getLiveCellCache();
  }

  getMasterPublicKeyInfo(): PublicKeyInfo | undefined {
    return this.cache.hdCache.getMasterPublicKeyInfo();
  }

  getNextReceivingPublicKeyInfo(): PublicKeyInfo {
    return this.cache.hdCache.getNextReceivingPublicKeyInfo();
  }

  getNextChangePublicKeyInfo(): PublicKeyInfo {
    return this.cache.hdCache.getNextChangePublicKeyInfo();
  }

  getReceivingKeys(): PublicKeyInfo[] {
    return this.cache.hdCache.receivingKeys;
  }

  getChangeKeys(): PublicKeyInfo[] {
    return this.cache.hdCache.changeKeys;
  }
}

export class CellCollector implements CellCollectorInterface {
  private cacheManager: CacheManager;

  constructor(cacheManger: CacheManager) {
    this.cacheManager = cacheManger;
  }

  async *collect(): AsyncGenerator<Cell> {
    for (const cell of this.cacheManager.getLiveCellsCache().values()) {
      yield cell;
    }
  }
}

export class CellCollectorWithQueryOptions implements CellCollectorInterface {
  private collector: CellCollector;
  private queryOptions: QueryOptions;

  constructor(
    collector: CellCollector,
    {
      lock = undefined,
      type = undefined,
      argsLen = -1,
      data = "any",
      fromBlock = undefined,
      toBlock = undefined,
      skip = undefined,
    }: QueryOptions = {}
  ) {
    this.collector = collector;
    this.queryOptions = {
      lock,
      type,
      argsLen,
      data,
      fromBlock,
      toBlock,
      skip,
    };
  }

  async *collect(): AsyncGenerator<Cell> {
    const skip = this.queryOptions.skip;
    let skipCount = 0;
    for await (const cell of this.collector.collect()) {
      if (isCellMatchQueryOptions(cell, this.queryOptions)) {
        if (skip && skipCount < skip) {
          skipCount += 1;
        } else {
          yield cell;
        }
      }
    }
  }
}

export async function getBalance(
  cellCollector: CellCollectorInterface
): Promise<HexString> {
  let balance: BI = BI.from(0);
  for await (const cell of cellCollector.collect()) {
    balance = balance.add(cell.cell_output.capacity);
  }
  return "0x" + balance.toString(16);
}

'''
'''--- packages/hd-cache/tests/cache.test.ts ---
import test from "ava";
import { TransactionCollector } from "@ckb-lumos/ckb-indexer";
import { Indexer } from "@ckb-lumos/base";

import { CacheManager, getBalance } from "../src";
import {
  HDCache,
  getDefaultInfos,
  CellCollector,
  CellCollectorWithQueryOptions,
  publicKeyToMultisigArgs,
} from "../src/index";
import {
  Cell,
  QueryOptions,
  TransactionWithStatus,
  HexString,
} from "@ckb-lumos/base";
import { BI } from "@ckb-lumos/bi";

const mockTxs: TransactionWithStatus[] = [
  {
    transaction: {
      version: "0",
      hash:
        "0xfd69760e8062dca9142a6802d7f42f82204e1b266719e34a17cc1f5c0bd03b97",
      header_deps: [],
      cell_deps: [],
      inputs: [
        {
          previous_output: {
            tx_hash:
              "0x58a29007f29ede069d49221f468107681c1a4d8d341de1d053b9b60596d6b233",
            index: "0x0",
          },
          since: "0x0",
        },
      ],
      outputs: [
        {
          capacity: "0x" + BigInt(1000 * 10 ** 8).toString(16),
          lock: {
            code_hash:
              "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
            hash_type: "type",
            args: "0x89cba48c68b3978f185df19f31634bb870e94639",
          },
        },
      ],
      outputs_data: ["0x"],
      witnesses: [],
    },
    tx_status: {
      status: "committed",
      block_hash:
        "0x8df4763d10cf22509845f8ec728d56d1027d4dfe633cb91abf0d751ed5d45d68",
    },
  },
  {
    transaction: {
      version: "0",
      hash: "78a2d0c8da6daaa9e9cb7b2f69f90f3492719bb566e039d5c7d6a1534fcb301b",
      header_deps: [],
      cell_deps: [],
      inputs: [
        {
          previous_output: {
            tx_hash:
              "0xfd69760e8062dca9142a6802d7f42f82204e1b266719e34a17cc1f5c0bd03b97",
            index: "0x0",
          },
          since: "0x0",
        },
      ],
      outputs: [
        {
          capacity: "0x" + BigInt(200 * 10 ** 8).toString(16),
          lock: {
            code_hash:
              "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
            hash_type: "type",
            args: "0x0ce445e32d7f91c9392485ddb9bc6885ce46ad64",
          },
        },
        {
          capacity: "0x" + BigInt(300 * 10 ** 8).toString(16),
          lock: {
            code_hash:
              "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
            hash_type: "type",
            args: "0xaa5aa575dedb6f5d7a5c835428c3b4a3ea7ba1eb",
          },
        },
        {
          capacity: "0x" + BigInt(400 * 10 ** 8).toString(16),
          lock: {
            code_hash:
              "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
            hash_type: "type",
            args: "0xfa7b46aa28cb233db373e5712e16edcaaa4c4999",
          },
        },
        // master public key
        {
          capacity: "0x" + BigInt(50 * 10 ** 8).toString(16),
          lock: {
            code_hash:
              "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
            hash_type: "type",
            args: "0xa6ee79109863906e75668acd75d6c6adbd56469c",
          },
        },
      ],
      outputs_data: ["0x1234", "0x", "0x"],
      witnesses: [],
    },
    tx_status: {
      status: "committed",
      block_hash:
        "0x8df4763d10cf22509845f8ec728d56d1027d4dfe633cb91abf0d751ed5d45d68",
    },
  },
];

class MockRpc {
  constructor() {}

  async get_header(blockHash: HexString) {
    return {
      compact_target: "0x1e083126",
      dao: "0xb5a3e047474401001bc476b9ee573000c0c387962a38000000febffacf030000",
      epoch: "0x7080018000001",
      hash: blockHash,
      nonce: "0x0",
      number: "0x400",
      parent_hash:
        "0xae003585fa15309b30b31aed3dcf385e9472c3c3e93746a6c4540629a6a1ed2d",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      timestamp: "0x5cd2b117",
      transactions_root:
        "0xc47d5b78b3c4c4c853e2a32810818940d0ee403423bea9ec7b8e566d9595206c",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
    };
  }
}

const rpc: any = new MockRpc();

class MockIndexer {
  async tip() {
    return {
      block_hash:
        "0xb97f00e2d023a9be5b38cc0dabcfdfa149597a3c5f6bc89b013c2cb69e186432",
      block_number: "0x10",
    };
  }
}

HDCache.receivingKeyInitCount = 3;
HDCache.changeKeyInitCount = 2;
HDCache.receivingKeyThreshold = 2;
HDCache.changeKeyThreshold = 1;

// Private Key: 0x37d25afe073a6ba17badc2df8e91fc0de59ed88bcad6b9a0c2210f325fafca61
// Public Key: 0x020720a7a11a9ac4f0330e2b9537f594388ea4f1cd660301f40b5a70e0bc231065
// blake160: 0xa6ee79109863906e75668acd75d6c6adbd56469c
const mnemonic =
  "tank planet champion pottery together intact quick police asset flower sudden question";

/**
 * receiving keys blake160:
 * 0: 0x89cba48c68b3978f185df19f31634bb870e94639
 * 1: 0x0ce445e32d7f91c9392485ddb9bc6885ce46ad64
 * 2: 0xc337da539e4d0b89daad1370b945f7210fad4c43
 * 3: 0xd9a188cc1985a7d4a31f141f4ebb61f241aec182
 * 4: 0xebf9befcd8396e88cab8fcb920ab149231658f4b
 *
 * change keys blake160:
 * 0: 0xaa5aa575dedb6f5d7a5c835428c3b4a3ea7ba1eb
 * 1: 0xfa7b46aa28cb233db373e5712e16edcaaa4c4999
 * 2: 0xbba6e863e838bae614fd6df9828f3bf1eed57964
 * 3: 0x57a81755c7229decb0f21f93d73c1c7e1c0afe95
 */

class MockTransactionCollector extends TransactionCollector {
  async *collect(): any {
    const lock = (this as any).lock.script;
    const args = lock.args;
    if (args === "0x89cba48c68b3978f185df19f31634bb870e94639") {
      yield mockTxs[0];
    }
    if (
      [
        "0x89cba48c68b3978f185df19f31634bb870e94639",
        "0x0ce445e32d7f91c9392485ddb9bc6885ce46ad64",
        "0xaa5aa575dedb6f5d7a5c835428c3b4a3ea7ba1eb",
        "0xfa7b46aa28cb233db373e5712e16edcaaa4c4999",
        // master key
        "0xa6ee79109863906e75668acd75d6c6adbd56469c",
      ].includes(args)
    ) {
      yield mockTxs[1];
    }
  }
}

const indexer = new MockIndexer();

const cacheManager = CacheManager.fromMnemonic(
  indexer as Indexer,
  mnemonic,
  getDefaultInfos(),
  {
    TransactionCollector: MockTransactionCollector,
    rpc,
  }
);

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("derive threshold", async (t) => {
  const cacheManager = CacheManager.fromMnemonic(
    indexer as Indexer,
    mnemonic,
    getDefaultInfos(),
    {
      TransactionCollector: MockTransactionCollector,
      rpc,
    }
  );

  t.is(cacheManager.getReceivingKeys().length, 3);
  t.is(cacheManager.getChangeKeys().length, 2);

  // @ts-ignore
  await cacheManager.cache.loop();

  t.is(cacheManager.getReceivingKeys().length, 5);
  t.is(cacheManager.getChangeKeys().length, 3);

  t.deepEqual(
    cacheManager.getReceivingKeys().map((key) => key.index),
    Array.from({ length: 5 }).map((_, i) => i)
  );
  t.deepEqual(
    cacheManager.getChangeKeys().map((key) => key.index),
    Array.from({ length: 3 }).map((_, i) => i)
  );
});

test("getNextReceivingPublicKeyInfo", async (t) => {
  // @ts-ignore
  await cacheManager.cache.loop();

  t.is(
    cacheManager.getNextReceivingPublicKeyInfo().blake160,
    "0xc337da539e4d0b89daad1370b945f7210fad4c43"
  );
});

test("getNextChangePublicKeyInfo", async (t) => {
  // @ts-ignore
  await cacheManager.cache.loop();

  t.is(
    cacheManager.getNextChangePublicKeyInfo().blake160,
    "0xbba6e863e838bae614fd6df9828f3bf1eed57964"
  );
});

test("getMasterPublicKeyInfo, default", async (t) => {
  // @ts-ignore
  await cacheManager.cache.loop();

  t.false(!!cacheManager.getMasterPublicKeyInfo());
});

test("getMasterPublicKeyInfo, needMasterPublicKey", async (t) => {
  const cacheManager = CacheManager.fromMnemonic(
    indexer as Indexer,
    mnemonic,
    getDefaultInfos(),
    {
      TransactionCollector: MockTransactionCollector,
      rpc,
      needMasterPublicKey: true,
    }
  );
  // @ts-ignore
  await cacheManager.cache.loop();

  t.true(!!cacheManager.getMasterPublicKeyInfo());
  t.is(
    cacheManager.getMasterPublicKeyInfo()!.publicKey,
    "0x020720a7a11a9ac4f0330e2b9537f594388ea4f1cd660301f40b5a70e0bc231065"
  );
});

test("loadFromKeystore, ckb-cli", async (t) => {
  const cacheManager = CacheManager.loadFromKeystore(
    indexer as Indexer,
    __dirname + "/fixtures/ckb_cli_keystore.json",
    "aaaaaa",
    getDefaultInfos(),
    {
      TransactionCollector: MockTransactionCollector,
    }
  );

  // @ts-ignore
  await cacheManager.cache.loop();

  t.true(!!cacheManager.getMasterPublicKeyInfo());
});

test("CellCollector", async (t) => {
  // @ts-ignore
  await cacheManager.cache.loop();

  const cellCollector = new CellCollector(cacheManager);

  const cells: Cell[] = [];
  for await (const cell of cellCollector.collect()) {
    cells.push(cell);
  }

  t.is(cells.length, 3);
  t.deepEqual(
    cells.map((cell) => BI.from(cell.cell_output.capacity).toString()),
    [
      BI.from(200).mul(BI.from(10).pow(8)).toString(),
      BI.from(300).mul(BI.from(10).pow(8)).toString(),
      BI.from(400).mul(BI.from(10).pow(8)).toString(),
    ]
  );

  const firstCell = cells[0];
  t.is(firstCell.block_number, "0x400");
  t.is(
    firstCell.block_hash,
    "0x8df4763d10cf22509845f8ec728d56d1027d4dfe633cb91abf0d751ed5d45d68"
  );
});

test("CellCollectorWithQueryOptions", async (t) => {
  // @ts-ignore
  await cacheManager.cache.loop();

  const queryOptions: QueryOptions = {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x0ce445e32d7f91c9392485ddb9bc6885ce46ad64",
    },
  };

  const cellCollector = new CellCollectorWithQueryOptions(
    new CellCollector(cacheManager),
    queryOptions
  );

  const cells: Cell[] = [];
  for await (const cell of cellCollector.collect()) {
    cells.push(cell);
  }

  t.is(cells.length, 1);
  t.deepEqual(
    cells.map((cell) => BI.from(cell.cell_output.capacity).toString()),
    [BI.from(200).mul(BI.from(10).pow(8)).toString()]
  );
});

test("CellCollectorWithQueryOptions, skip", async (t) => {
  // @ts-ignore
  await cacheManager.cache.loop();

  const queryOptions: QueryOptions = {
    skip: 1,
  };

  const cellCollector = new CellCollectorWithQueryOptions(
    new CellCollector(cacheManager),
    queryOptions
  );

  const cells: Cell[] = [];
  for await (const cell of cellCollector.collect()) {
    cells.push(cell);
  }

  t.is(cells.length, 2);
  t.deepEqual(
    cells.map((cell) => BI.from(cell.cell_output.capacity).toString()),
    [
      BI.from(300).mul(BI.from(10).pow(8)).toString(),
      BI.from(400).mul(BI.from(10).pow(8)).toString(),
    ]
  );
});

test("getBalance", async (t) => {
  // @ts-ignore
  await cacheManager.cache.loop();

  const balance = await getBalance(new CellCollector(cacheManager));

  t.is(
    BI.from(balance).toString(),
    BI.from(900).mul(BI.from(10).pow(8)).toString()
  );
});

test("getBalance, needMasterPublicKey", async (t) => {
  const cacheManager = CacheManager.fromMnemonic(
    indexer as Indexer,
    mnemonic,
    getDefaultInfos(),
    {
      TransactionCollector: MockTransactionCollector,
      rpc,
      needMasterPublicKey: true,
    }
  );
  // @ts-ignore
  await cacheManager.cache.loop();

  const balance = await getBalance(new CellCollector(cacheManager));

  t.is(
    BI.from(balance).toString(),
    BI.from(950).mul(BI.from(10).pow(8)).toString()
  );
});

test("publicKeyToMultisigArgs", (t) => {
  const publicKey =
    "0x024a501efd328e062c8675f2365970728c859c592beeefd6be8ead3d901330bc01";
  const multisigArgs = "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8";

  t.is(publicKeyToMultisigArgs(publicKey), multisigArgs);
});

'''
'''--- packages/hd-cache/tests/fixtures/ckb_cli_keystore.json ---
{
  "crypto": {
    "cipher": "aes-128-ctr",
    "cipherparams": {
      "iv": "54cf58110a62bce69b9374cd08d8416b"
    },
    "ciphertext": "80fd150254497bb2127425e6c6a009a8071b42d9ecb8919e09ebb7a7d20220fbcf0db76711924d8640a3e0d5c6bbd1b33725bb206e5072b67e4153c22a038a0d",
    "kdf": "scrypt",
    "kdfparams": {
      "dklen": 32,
      "n": 262144,
      "p": 1,
      "r": 8,
      "salt": "c9611e41093ef0f3d4fe2463885385b11b270a2e9b453974a500740bb8f71c40"
    },
    "mac": "c6699cc6c78f13d768ca0876a407e8a3ff17b1d418ecd7c88bafd66ab60715a2"
  },
  "hash160": "36c329ed630d6ce750712a477543672adab57f4c",
  "id": "cf022e08-2596-4cc2-b8dd-030e9810d41a",
  "origin": "ckb-cli",
  "version": 3
}

'''
'''--- packages/hd-cache/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src"]
}

'''
'''--- packages/hd/README.md ---
# `@ckb-lumos/hd`

HD & Mnemonic implementation for lumos.

## Usage

Create a new HD wallet.

```javascript
const { mnemonic, ExtendedPrivateKey, Keystore } = require("@ckb-lumos/hd")
const m = mnemonic.generateMnemonic()
const seed = mnemonic.mnemonicToSeedSync(m)
const extendedPrivateKey = ExtendedPrivateKey.fromSeed(seed)
const keystore = Keystore.create(extendedPrivateKey, "Your password")
// save keystore file
keystore.save("you path, only dir")

// load keystore file
const keystore = Keystore.load("you file path, with file name")
```

XPub support.
```javascript
const { XPubStore } = require("@ckb-lumos/hd")

// load from xpub file.
const xpub = XPubStore.load("you path")

// to AccountExtendedPublicKey
const accountExtendedPublicKey = xpub.toAccountExtendedPublicKey()

// save xpub file.
xpub.save("your path")
```

'''
'''--- packages/hd/package.json ---
{
  "name": "@ckb-lumos/hd",
  "version": "0.17.0-rc8",
  "description": "HD wallet manager in lumos",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "src"
  ],
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "bn.js": "^5.1.3",
    "elliptic": "^6.5.4",
    "sha3": "^2.1.3",
    "uuid": "^8.3.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests}/**/*.ts\"",
    "test": "ava **/*.test.ts --timeout=2m",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  },
  "devDependencies": {
    "@types/bn.js": "^4.11.6",
    "@types/elliptic": "^6.4.12",
    "@types/uuid": "^8.3.0"
  }
}

'''
'''--- packages/hd/src/extended_key.ts ---
import Keychain from "./keychain";
import key, { privateToPublic } from "./key";
import { utils, HexString } from "@ckb-lumos/base";
import { assertPublicKey, assertChainCode, assertPrivateKey } from "./helper";

export enum AddressType {
  Receiving = 0,
  Change = 1,
}

export interface PublicKeyInfo {
  blake160: HexString;
  path: string;
  publicKey: HexString;
}

export class ExtendedPublicKey {
  publicKey: HexString;
  chainCode: HexString;

  constructor(publicKey: HexString, chainCode: HexString) {
    assertPublicKey(publicKey);
    assertChainCode(chainCode);

    this.publicKey = publicKey;
    this.chainCode = chainCode;
  }

  serialize(): HexString {
    return this.publicKey + this.chainCode.slice(2);
  }

  static parse(serialized: HexString): ExtendedPublicKey {
    utils.assertHexString("serialized", serialized);
    return new ExtendedPublicKey(
      serialized.slice(0, 68),
      "0x" + serialized.slice(68)
    );
  }
}

// Extended public key of the BIP44 path down to account level,
// which is `m/44'/309'/0'`. This key will be persisted to wallet
// and used to derive receiving/change addresses.
export class AccountExtendedPublicKey extends ExtendedPublicKey {
  public static ckbAccountPath = `m/44'/309'/0'`;

  static parse(serialized: HexString): AccountExtendedPublicKey {
    utils.assertHexString("serialized", serialized);
    return new AccountExtendedPublicKey(
      serialized.slice(0, 68),
      "0x" + serialized.slice(68)
    );
  }

  publicKeyInfo(type: AddressType, index: number): PublicKeyInfo {
    const publicKey: string = this.getPublicKey(type, index);
    const blake160: string = key.publicKeyToBlake160(publicKey);
    return {
      publicKey,
      blake160,
      path: AccountExtendedPublicKey.pathFor(type, index),
    };
  }

  public static pathForReceiving(index: number) {
    return AccountExtendedPublicKey.pathFor(AddressType.Receiving, index);
  }

  public static pathForChange(index: number) {
    return AccountExtendedPublicKey.pathFor(AddressType.Change, index);
  }

  public static pathFor(type: AddressType, index: number): string {
    return `${AccountExtendedPublicKey.ckbAccountPath}/${type}/${index}`;
  }

  private getPublicKey(type = AddressType.Receiving, index: number): HexString {
    const keychain = Keychain.fromPublicKey(
      Buffer.from(this.publicKey.slice(2), "hex"),
      Buffer.from(this.chainCode.slice(2), "hex"),
      AccountExtendedPublicKey.ckbAccountPath
    )
      .deriveChild(type, false)
      .deriveChild(index, false);

    return "0x" + keychain.publicKey.toString("hex");
  }
}

export interface PrivateKeyInfo {
  privateKey: HexString;
  publicKey: HexString;
  path: string;
}

export class ExtendedPrivateKey {
  privateKey: HexString;
  chainCode: HexString;

  constructor(privateKey: HexString, chainCode: HexString) {
    assertPrivateKey(privateKey);
    assertChainCode(chainCode);

    this.privateKey = privateKey;
    this.chainCode = chainCode;
  }

  serialize(): HexString {
    return this.privateKey + this.chainCode.slice(2);
  }

  toExtendedPublicKey(): ExtendedPublicKey {
    const publicKey: HexString = privateToPublic(this.privateKey);
    return new ExtendedPublicKey(publicKey, this.chainCode);
  }

  toAccountExtendedPublicKey(): AccountExtendedPublicKey {
    const masterKeychain = new Keychain(
      Buffer.from(this.privateKey.slice(2), "hex"),
      Buffer.from(this.chainCode.slice(2), "hex")
    );
    const accountKeychain = masterKeychain.derivePath(
      AccountExtendedPublicKey.ckbAccountPath
    );

    return new AccountExtendedPublicKey(
      "0x" + accountKeychain.publicKey.toString("hex"),
      "0x" + accountKeychain.chainCode.toString("hex")
    );
  }

  static fromSeed(seed: Buffer): ExtendedPrivateKey {
    const keychain = Keychain.fromSeed(seed);
    return new ExtendedPrivateKey(
      "0x" + keychain.privateKey.toString("hex"),
      "0x" + keychain.chainCode.toString("hex")
    );
  }

  privateKeyInfo(type: AddressType, index: number): PrivateKeyInfo {
    const path = AccountExtendedPublicKey.pathFor(type, index);
    return this.privateKeyInfoByPath(path);
  }

  privateKeyInfoByPath(path: string): PrivateKeyInfo {
    const keychain = new Keychain(
      Buffer.from(this.privateKey.slice(2), "hex"),
      Buffer.from(this.chainCode.slice(2), "hex")
    ).derivePath(path);

    return this.privateKeyInfoFromKeychain(keychain, path);
  }

  private privateKeyInfoFromKeychain(
    keychain: Keychain,
    path: string
  ): PrivateKeyInfo {
    return {
      privateKey: "0x" + keychain.privateKey.toString("hex"),
      publicKey: "0x" + keychain.publicKey.toString("hex"),
      path: path,
    };
  }

  static parse(serialized: HexString): ExtendedPrivateKey {
    utils.assertHexString("serialized", serialized);
    return new ExtendedPrivateKey(
      serialized.slice(0, 66),
      "0x" + serialized.slice(66)
    );
  }
}

'''
'''--- packages/hd/src/helper.ts ---
import { utils, HexString } from "@ckb-lumos/base";
const { assertHexString } = utils;

export function assertPublicKey(
  publicKey: HexString,
  debugPath?: string
): void {
  debugPath = debugPath || "publicKey";
  assertHexString(debugPath, publicKey);
  if (publicKey.length !== 68) {
    throw new Error(`publicKey must be length of 33 bytes!`);
  }
}

export function assertPrivateKey(privateKey: HexString): void {
  assertHexString("privateKey", privateKey);
  if (privateKey.length !== 66) {
    throw new Error(`privateKey must be length of 32 bytes!`);
  }
}

export function assertChainCode(chainCode: HexString): void {
  assertHexString("chainCode", chainCode);
  if (chainCode.length !== 66) {
    throw new Error(`chainCode must be length of 32 bytes!`);
  }
}

'''
'''--- packages/hd/src/index.ts ---
import Keystore, {
  UnsupportedCipher,
  IncorrectPassword,
  InvalidKeystore,
  HexStringWithoutPrefix,
} from "./keystore";
import { XPubStore } from "./xpub_store";
import Keychain from "./keychain";
import {
  AddressType,
  ExtendedPublicKey,
  AccountExtendedPublicKey,
  ExtendedPrivateKey,
  PrivateKeyInfo,
  PublicKeyInfo,
} from "./extended_key";
import mnemonic from "./mnemonic";
import key from "./key";

export {
  mnemonic,
  Keystore,
  UnsupportedCipher,
  IncorrectPassword,
  InvalidKeystore,
  HexStringWithoutPrefix,
  Keychain,
  AddressType,
  ExtendedPublicKey,
  AccountExtendedPublicKey,
  ExtendedPrivateKey,
  PrivateKeyInfo,
  PublicKeyInfo,
  key,
  XPubStore,
};

export default {
  mnemonic,
  Keystore,
  UnsupportedCipher,
  IncorrectPassword,
  InvalidKeystore,
  Keychain,
  AddressType,
  ExtendedPublicKey,
  AccountExtendedPublicKey,
  ExtendedPrivateKey,
  key,
  XPubStore,
};

'''
'''--- packages/hd/src/key.ts ---
import { HexString, utils } from "@ckb-lumos/base";
import { ec as EC, SignatureInput } from "elliptic";
import { assertPrivateKey, assertPublicKey } from "./helper";

const ec = new EC("secp256k1");

export function signRecoverable(
  message: HexString,
  privateKey: HexString
): HexString {
  utils.assertHexString("message", message);
  assertPrivateKey(privateKey);

  const key = ec.keyFromPrivate(privateKey.slice(2));
  const { r, s, recoveryParam } = key.sign(message.slice(2), {
    canonical: true,
  });
  if (recoveryParam === null) {
    throw new Error("Sign message failed!");
  }
  const fmtR = r.toString(16).padStart(64, "0");
  const fmtS = s.toString(16).padStart(64, "0");
  const fmtRecoverableParam = recoveryParam.toString(16).padStart(2, "0");
  return "0x" + fmtR + fmtS + fmtRecoverableParam;
}

export function recoverFromSignature(
  message: HexString,
  signature: HexString
): HexString {
  utils.assertHexString("message", message);
  utils.assertHexString("signature", signature);

  const msgBuffer = Buffer.from(message.slice(2), "hex");
  const sigBuffer = Buffer.from(signature.slice(2), "hex");

  const sign: SignatureInput = {
    r: sigBuffer.slice(0, 32),
    s: sigBuffer.slice(32, 64),
    recoveryParam: sigBuffer[64],
  };

  const point = ec.recoverPubKey(msgBuffer, sign, sign.recoveryParam!);
  const publicKey = "0x" + point.encode("hex", true).toLowerCase();
  return publicKey;
}

export function privateToPublic(privateKey: Buffer): Buffer;
export function privateToPublic(privateKey: HexString): HexString;

export function privateToPublic(
  privateKey: Buffer | HexString
): Buffer | HexString {
  let pkBuffer = privateKey;
  if (typeof privateKey === "string") {
    assertPrivateKey(privateKey);
    pkBuffer = Buffer.from(privateKey.slice(2), "hex");
  }
  if (pkBuffer.length !== 32) {
    throw new Error("Private key must be 32 bytes!");
  }

  const publickey = ec.keyFromPrivate(pkBuffer).getPublic(true, "hex");
  if (typeof privateKey === "string") {
    return "0x" + publickey;
  }
  return Buffer.from(publickey, "hex");
}

export function publicKeyToBlake160(publicKey: HexString): HexString {
  assertPublicKey(publicKey);

  const blake160: string = new utils.CKBHasher()
    .update(publicKey)
    .digestHex()
    .slice(0, 42);

  return blake160;
}

export function privateKeyToBlake160(privateKey: HexString): HexString {
  const publicKey: HexString = privateToPublic(privateKey);
  return publicKeyToBlake160(publicKey);
}

export default {
  signRecoverable,
  recoverFromSignature,
  privateToPublic,
  publicKeyToBlake160,
  privateKeyToBlake160,
};

'''
'''--- packages/hd/src/keychain.ts ---
import crypto from "crypto";
import { ec as EC } from "elliptic";
import BN from "bn.js";
import { privateToPublic } from "./key";

const ec = new EC("secp256k1");

const EMPTY_BUFFER = Buffer.from("");

// BIP32 Keychain. Not a full implementation.
export default class Keychain {
  privateKey: Buffer = EMPTY_BUFFER;
  publicKey: Buffer = EMPTY_BUFFER;
  chainCode: Buffer = EMPTY_BUFFER;
  index: number = 0;
  depth: number = 0;
  identifier: Buffer = EMPTY_BUFFER;
  fingerprint: number = 0;
  parentFingerprint: number = 0;

  constructor(privateKey: Buffer, chainCode: Buffer) {
    this.privateKey = privateKey;
    this.chainCode = chainCode;

    if (!this.isNeutered()) {
      this.publicKey = privateToPublic(this.privateKey);
    }
  }

  calculateFingerprint(): void {
    this.identifier = this.hash160(this.publicKey);
    this.fingerprint = this.identifier.slice(0, 4).readUInt32BE(0);
  }

  public static fromSeed(seed: Buffer): Keychain {
    const i = crypto
      .createHmac("sha512", Buffer.from("Bitcoin seed", "utf8"))
      .update(seed)
      .digest();
    const keychain = new Keychain(i.slice(0, 32), i.slice(32));
    keychain.calculateFingerprint();
    return keychain;
  }

  // Create a child keychain with extended public key and path.
  // Children of this keychain should not have any hardened paths.
  public static fromPublicKey(
    publicKey: Buffer,
    chainCode: Buffer,
    path: String
  ): Keychain {
    const keychain = new Keychain(EMPTY_BUFFER, chainCode);
    keychain.publicKey = publicKey;
    keychain.calculateFingerprint();

    const pathComponents = path.split("/");
    keychain.depth = pathComponents.length - 1;
    keychain.index = parseInt(pathComponents[pathComponents.length - 1], 10);

    return keychain;
  }

  public deriveChild(index: number, hardened: boolean): Keychain {
    let data: Buffer;

    const indexBuffer: Buffer = Buffer.allocUnsafe(4);

    if (hardened) {
      const pk = Buffer.concat([Buffer.alloc(1, 0), this.privateKey]);
      indexBuffer.writeUInt32BE(index + 0x80000000, 0);
      data = Buffer.concat([pk, indexBuffer]);
    } else {
      indexBuffer.writeUInt32BE(index, 0);
      data = Buffer.concat([this.publicKey, indexBuffer]);
    }

    const i = crypto.createHmac("sha512", this.chainCode).update(data).digest();
    const il = i.slice(0, 32);
    const ir = i.slice(32);

    let child: Keychain;
    if (this.isNeutered()) {
      child = new Keychain(EMPTY_BUFFER, ir);
      child.publicKey = Keychain.publicKeyAdd(this.publicKey, il);
      child.calculateFingerprint();
    } else {
      const privateKey = Keychain.privateKeyAdd(this.privateKey, il);
      child = new Keychain(privateKey, ir);
      child.calculateFingerprint();
    }

    child.index = index;
    child.depth = this.depth + 1;
    child.parentFingerprint = this.fingerprint;

    return child;
  }

  public derivePath(path: string): Keychain {
    const master = ["m", `/`, ""];
    if (master.includes(path)) {
      return this;
    }

    let bip32: Keychain = this;

    let entries = path.split("/");
    if (entries[0] === "m") {
      entries = entries.slice(1);
    }
    entries.forEach((c) => {
      const childIndex = parseInt(c, 10);
      const hardened = c.length > 1 && c[c.length - 1] === "'";
      bip32 = bip32.deriveChild(childIndex, hardened);
    });

    return bip32;
  }

  isNeutered(): Boolean {
    return this.privateKey === EMPTY_BUFFER;
  }

  hash160(data: Buffer): Buffer {
    const sha256 = crypto.createHash("sha256").update(data).digest();
    return crypto.createHash("ripemd160").update(sha256).digest();
  }

  private static privateKeyAdd(privateKey: Buffer, factor: Buffer): Buffer {
    const result = new BN(factor);
    result.iadd(new BN(privateKey));
    if (result.cmp(ec.curve.n) >= 0) {
      result.isub(ec.curve.n);
    }

    return result.toArrayLike(Buffer, "be", 32);
  }

  private static publicKeyAdd(publicKey: Buffer, factor: Buffer): Buffer {
    const x = new BN(publicKey.slice(1)).toRed(ec.curve.red);
    let y = x.redSqr().redIMul(x).redIAdd(ec.curve.b).redSqrt();
    if ((publicKey[0] === 0x03) !== y.isOdd()) {
      y = y.redNeg();
    }
    const point = ec.curve.g.mul(new BN(factor)).add({ x, y });
    return Buffer.from(point.encode(true, true));
  }
}

'''
'''--- packages/hd/src/keystore.ts ---
import crypto from "crypto";
import { Keccak } from "sha3";
import { v4 as uuid } from "uuid";
import fs from "fs";
import Path from "path";

import { ExtendedPrivateKey } from "./extended_key";
import { HexString } from "@ckb-lumos/base";

export type HexStringWithoutPrefix = string;

export class UnsupportedCipher extends Error {
  constructor() {
    super("Unsupported cipher!");
  }
}

export class IncorrectPassword extends Error {
  constructor() {
    super("Incorrect password!");
  }
}

export class InvalidKeystore extends Error {
  constructor() {
    super("Invalid keystore, please check your file integrity.");
  }
}

const CIPHER = "aes-128-ctr";
const CKB_CLI_ORIGIN = "ckb-cli";

interface CipherParams {
  iv: HexStringWithoutPrefix;
}

interface KdfParams {
  dklen: number;
  n: number;
  r: number;
  p: number;
  salt: HexStringWithoutPrefix;
}

interface Crypto {
  cipher: string;
  cipherparams: CipherParams;
  ciphertext: HexStringWithoutPrefix;
  kdf: string;
  kdfparams: KdfParams;
  mac: HexStringWithoutPrefix;
}

// Encrypt and save master extended private key.
export default class Keystore {
  crypto: Crypto;
  id: string;
  version: number = 3;
  origin: string | undefined;

  constructor(theCrypto: Crypto, id: string, origin?: string) {
    this.crypto = theCrypto;
    this.id = id;
    this.origin = origin;
  }

  static fromJson(json: string): Keystore {
    try {
      const object = JSON.parse(json);
      return new Keystore(object.crypto, object.id, object.origin);
    } catch {
      throw new InvalidKeystore();
    }
  }

  /**
   * Load keystore file from path.
   *
   * @param path
   */
  static load(path: string): Keystore {
    const json = fs.readFileSync(path, "utf-8");
    return this.fromJson(json);
  }

  /**
   * Keystore file default name is `${id}.json`.
   *
   * @param dir
   * @param options If you are sure to overwrite existing keystore file, set `overwrite` to true.
   */
  save(
    dir: string,
    {
      name = this.filename(),
      overwrite = false,
    }: { name?: string; overwrite?: boolean } = {}
  ): void {
    const path: string = Path.join(dir, name);
    if (!overwrite && fs.existsSync(path)) {
      throw new Error("Keystore file already exists!");
    }
    fs.writeFileSync(path, this.toJson());
  }

  private filename(): string {
    return this.id + ".json";
  }

  toJson(): string {
    return JSON.stringify(this);
  }

  isFromCkbCli(): boolean {
    return this.origin === CKB_CLI_ORIGIN;
  }

  // Create an empty keystore object that contains empty private key
  static createEmpty(): Keystore {
    const salt: Buffer = crypto.randomBytes(32);
    const iv: Buffer = crypto.randomBytes(16);
    const kdfparams: KdfParams = {
      dklen: 32,
      salt: salt.toString("hex"),
      n: 2 ** 18,
      r: 8,
      p: 1,
    };
    return new Keystore(
      {
        ciphertext: "",
        cipherparams: {
          iv: iv.toString("hex"),
        },
        cipher: CIPHER,
        kdf: "scrypt",
        kdfparams,
        mac: "",
      },
      uuid()
    );
  }

  static create(
    extendedPrivateKey: ExtendedPrivateKey,
    password: string,
    options: { salt?: Buffer; iv?: Buffer } = {}
  ): Keystore {
    const salt: Buffer = options.salt || crypto.randomBytes(32);
    const iv: Buffer = options.iv || crypto.randomBytes(16);
    const kdfparams: KdfParams = {
      dklen: 32,
      salt: salt.toString("hex"),
      n: 2 ** 18,
      r: 8,
      p: 1,
    };
    const derivedKey: Buffer = crypto.scryptSync(
      password,
      salt,
      kdfparams.dklen,
      Keystore.scryptOptions(kdfparams)
    );

    const cipher: crypto.Cipher = crypto.createCipheriv(
      CIPHER,
      derivedKey.slice(0, 16),
      iv
    );
    if (!cipher) {
      throw new UnsupportedCipher();
    }
    const ciphertext: Buffer = Buffer.concat([
      cipher.update(
        Buffer.from(extendedPrivateKey.serialize().slice(2), "hex")
      ),
      cipher.final(),
    ]);

    return new Keystore(
      {
        ciphertext: ciphertext.toString("hex"),
        cipherparams: {
          iv: iv.toString("hex"),
        },
        cipher: CIPHER,
        kdf: "scrypt",
        kdfparams,
        mac: Keystore.mac(derivedKey, ciphertext),
      },
      uuid()
    );
  }

  // Imported from xpub with empty private key.
  isEmpty(): boolean {
    return this.crypto.ciphertext === "" && this.crypto.mac === "";
  }

  // Decrypt and return serialized extended private key.
  decrypt(password: string): HexString {
    const derivedKey = this.derivedKey(password);
    const ciphertext = Buffer.from(this.crypto.ciphertext, "hex");
    if (Keystore.mac(derivedKey, ciphertext) !== this.crypto.mac) {
      throw new IncorrectPassword();
    }
    const decipher = crypto.createDecipheriv(
      this.crypto.cipher,
      derivedKey.slice(0, 16),
      Buffer.from(this.crypto.cipherparams.iv, "hex")
    );
    return (
      "0x" +
      Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString(
        "hex"
      )
    );
  }

  extendedPrivateKey(password: string): ExtendedPrivateKey {
    return ExtendedPrivateKey.parse(this.decrypt(password));
  }

  checkPassword(password: string): boolean {
    const derivedKey = this.derivedKey(password);
    const ciphertext = Buffer.from(this.crypto.ciphertext, "hex");
    return Keystore.mac(derivedKey, ciphertext) === this.crypto.mac;
  }

  derivedKey(password: string): Buffer {
    const { kdfparams } = this.crypto;
    return crypto.scryptSync(
      password,
      Buffer.from(kdfparams.salt, "hex"),
      kdfparams.dklen,
      Keystore.scryptOptions(kdfparams)
    );
  }

  static mac(derivedKey: Buffer, ciphertext: Buffer): HexStringWithoutPrefix {
    return new Keccak(256)
      .update(Buffer.concat([derivedKey.slice(16, 32), ciphertext]))
      .digest("hex");
  }

  static scryptOptions(kdfparams: KdfParams): crypto.ScryptOptions {
    return {
      N: kdfparams.n,
      r: kdfparams.r,
      p: kdfparams.p,
      maxmem: 128 * (kdfparams.n + kdfparams.p + 2) * kdfparams.r,
    };
  }
}

'''
'''--- packages/hd/src/mnemonic/index.ts ---
import crypto from "crypto";
import wordList from "./word_list";
import { HexString } from "@ckb-lumos/base";

const RADIX = 2048;
const PBKDF2_ROUNDS = 2048;
const KEY_LEN = 64;
const MIN_ENTROPY_SIZE = 16;
const MAX_ENTROPY_SIZE = 32;
const MIN_WORDS_SIZE = 12;
const MAX_WORDS_SIZE = 24;

const INVALID_MNEMONIC = `Invalid mnemonic`;
const INVALID_CHECKSUM = `Invalid checksum`;
const ENTROPY_NOT_DIVISIBLE = `Entropy should be divisable by 4`;
const ENTROPY_TOO_LONG = `Entropy should be shorter than ${
  MAX_ENTROPY_SIZE + 1
}`;
const ENTROPY_TOO_SHORT = `Entropy should be longer than ${
  MIN_ENTROPY_SIZE - 1
}`;
const WORDS_TOO_LONG = `Words should be shorter than ${MAX_WORDS_SIZE + 1}`;
const WORDS_TOO_SHORT = `Words should be longer than ${MIN_WORDS_SIZE - 1}`;

if (wordList.length !== RADIX) {
  throw new Error(
    `Word list should have ${RADIX} words, but ${wordList.length} received in fact`
  );
}

function bytesToBinary(bytes: Buffer): string {
  return bytes.reduce((binary, byte) => {
    return binary + byte.toString(2).padStart(8, "0");
  }, "");
}

function deriveChecksumBits(entropyBuffer: Buffer): string {
  const ENT = entropyBuffer.length * 8;
  const CS = ENT / 32;
  const hash = crypto.createHash("sha256").update(entropyBuffer).digest();
  return bytesToBinary(hash).slice(0, CS);
}

function salt(password: string = ""): string {
  return `mnemonic${password}`;
}

export function mnemonicToSeedSync(
  mnemonic: string = "",
  password: string = ""
): Buffer {
  const mnemonicBuffer = Buffer.from(mnemonic.normalize("NFKD"), "utf8");
  const saltBuffer = Buffer.from(salt(password.normalize("NFKD")), "utf8");
  return crypto.pbkdf2Sync(
    mnemonicBuffer,
    saltBuffer,
    PBKDF2_ROUNDS,
    KEY_LEN,
    "sha512"
  );
}

export function mnemonicToSeed(
  mnemonic: string = "",
  password: string = ""
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      const mnemonicBuffer = Buffer.from(mnemonic.normalize("NFKD"), "utf8");
      const saltBuffer = Buffer.from(salt(password.normalize("NFKD")), "utf8");
      crypto.pbkdf2(
        mnemonicBuffer,
        saltBuffer,
        PBKDF2_ROUNDS,
        KEY_LEN,
        "sha512",
        (err, data) => {
          if (err) {
            reject(err);
          }
          resolve(data);
        }
      );
    } catch (error) {
      reject(error);
    }
  });
}

export function mnemonicToEntropy(mnemonic: string = ""): HexString {
  const words = mnemonic.normalize("NFKD").split(" ");
  if (words.length < MIN_WORDS_SIZE) {
    throw new Error(WORDS_TOO_SHORT);
  }
  if (words.length > MAX_WORDS_SIZE) {
    throw new Error(WORDS_TOO_LONG);
  }
  if (words.length % 3 !== 0) {
    throw new Error(INVALID_MNEMONIC);
  }
  const bits = words
    .map((word) => {
      const index = wordList!.indexOf(word);
      if (index === -1) {
        throw new Error(INVALID_MNEMONIC);
      }
      return index.toString(2).padStart(11, "0");
    })
    .join("");

  const dividerIndex = Math.floor(bits.length / 33) * 32;
  const entropyBits = bits.slice(0, dividerIndex);
  const checksumBits = bits.slice(dividerIndex);

  const entropyBytes = entropyBits
    .match(/(.{1,8})/g)!
    .map((byte) => parseInt(byte, 2));
  if (entropyBytes.length < MIN_ENTROPY_SIZE) {
    throw new Error(ENTROPY_TOO_SHORT);
  }
  if (entropyBytes.length > MAX_ENTROPY_SIZE) {
    throw new Error(ENTROPY_TOO_LONG);
  }
  if (entropyBytes.length % 4 !== 0) {
    throw new Error(ENTROPY_NOT_DIVISIBLE);
  }

  const entropy = Buffer.from(entropyBytes);
  const newChecksum = deriveChecksumBits(entropy);
  if (newChecksum !== checksumBits) {
    throw new Error(INVALID_CHECKSUM);
  }

  return "0x" + entropy.toString("hex");
}

export function entropyToMnemonic(entropyStr: HexString): string {
  const entropy = Buffer.from(entropyStr.slice(2), "hex");

  if (entropy.length < MIN_ENTROPY_SIZE) {
    throw new TypeError(ENTROPY_TOO_SHORT);
  }
  if (entropy.length > MAX_ENTROPY_SIZE) {
    throw new TypeError(ENTROPY_TOO_LONG);
  }
  if (entropy.length % 4 !== 0) {
    throw new TypeError(ENTROPY_NOT_DIVISIBLE);
  }

  const entropyBytes = bytesToBinary(entropy);
  const checksumBytes = deriveChecksumBits(entropy);

  const bytes = entropyBytes + checksumBytes;
  const chunks = bytes.match(/(.{1,11})/g)!;
  const words = chunks.map((binary) => {
    const index = parseInt(binary, 2);
    return wordList[index];
  });

  return words.join(" ");
}

export function validateMnemonic(mnemonic: string): boolean {
  try {
    mnemonicToEntropy(mnemonic);
  } catch (e) {
    return false;
  }
  return true;
}

// Generate 12 words mnemonic code
export function generateMnemonic(): string {
  const entropySize = 16;
  const entropy: HexString =
    "0x" + crypto.randomBytes(entropySize).toString("hex");
  return entropyToMnemonic(entropy);
}

export default {
  entropyToMnemonic,
  mnemonicToEntropy,
  mnemonicToSeed,
  mnemonicToSeedSync,
  validateMnemonic,
  generateMnemonic,
};

'''
'''--- packages/hd/src/mnemonic/word_list.ts ---
export default [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo",
];

'''
'''--- packages/hd/src/xpub_store.ts ---
import { AccountExtendedPublicKey } from "./extended_key";
import fs from "fs";

export class XPubStore {
  private accountExtendedPublicKey: AccountExtendedPublicKey;

  constructor(accountExtendedPublicKey: AccountExtendedPublicKey) {
    this.accountExtendedPublicKey = accountExtendedPublicKey;
  }

  toAccountExtendedPublicKey(): AccountExtendedPublicKey {
    return this.accountExtendedPublicKey;
  }

  save(
    path: string,
    {
      overwrite = false,
    }: {
      overwrite?: boolean;
    } = {}
  ) {
    if (!overwrite && fs.existsSync(path)) {
      throw new Error("XPub file already exists!");
    }
    fs.writeFileSync(path, this.toJson());
  }

  toJson(): string {
    return JSON.stringify({
      xpubkey: this.accountExtendedPublicKey.serialize().slice(2),
    });
  }

  static load(path: string): XPubStore {
    const json = fs.readFileSync(path, "utf-8");
    const xpub = JSON.parse(json).xpubkey;
    const accountExtendedPublicKey = AccountExtendedPublicKey.parse(
      "0x" + xpub
    );
    return new XPubStore(accountExtendedPublicKey);
  }
}

'''
'''--- packages/hd/tests/extended_key.test.ts ---
import test from "ava";
import {
  ExtendedPublicKey,
  AccountExtendedPublicKey,
  ExtendedPrivateKey,
  AddressType,
} from "../src";
import { mnemonicToSeedSync } from "../src/mnemonic";
import { PrivateKeyInfo } from "../src/extended_key";

const fixture = {
  privateKey:
    "0xe8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35",
  publicKey:
    "0x0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2",
  chainCode:
    "0x873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508",
  accountPublicKey:
    "0x03e5b310636a0f6e7dcdfffa98f28d7ed70df858bb47acf13db830bfde3510b3f3",
  accountChainCode:
    "0x37e85a19f54f0a242a35599abac64a71aacc21e3a5860dd024377ffc7e6827d8",
};

test("ExtendedPublicKey, serialize and parse", (t) => {
  const extendedKey = new ExtendedPublicKey(
    fixture.publicKey,
    fixture.chainCode
  );
  const serialized = extendedKey.serialize();
  const parsed = ExtendedPublicKey.parse(serialized);
  t.is(parsed.publicKey, fixture.publicKey);
  t.is(parsed.chainCode, fixture.chainCode);
});

const extendedKey = new AccountExtendedPublicKey(
  fixture.accountPublicKey,
  fixture.accountChainCode
);

test("AccountExtendedPublicKey, key from extended public key", (t) => {
  t.is(
    // @ts-ignore: Private method
    extendedKey.getPublicKey(AddressType.Receiving, 0),
    "0x0331b3c0225388c5010e3507beb28ecf409c022ef6f358f02b139cbae082f5a2a3"
  );
  t.is(
    // @ts-ignore: Private method
    extendedKey.getPublicKey(AddressType.Change, 1),
    "0x0360bf05c11e7b4ac8de58077554e3d777acd64bf4abb9cd947002eb98a4827bba"
  );
});

test("AccountExtendedPublicKey, serialize and parse", (t) => {
  const serialized = extendedKey.serialize();
  const parsed = AccountExtendedPublicKey.parse(serialized);
  t.is(parsed.publicKey, extendedKey.publicKey);
  t.is(parsed.chainCode, extendedKey.chainCode);
});

test("AccountExtendedPublicKey, derive address", (t) => {
  const receivingBlake160Info = extendedKey.publicKeyInfo(
    AddressType.Receiving,
    0
  );
  t.is(receivingBlake160Info.path, `m/44'/309'/0'/0/0`);

  const changeBlake160Info = extendedKey.publicKeyInfo(AddressType.Change, 1);
  t.is(changeBlake160Info.path, `m/44'/309'/0'/1/1`);
});

test("ExtendedPrivateKey, serialize and parse", (t) => {
  const extendedKey = new ExtendedPrivateKey(
    fixture.privateKey,
    fixture.chainCode
  );
  const serialized = extendedKey.serialize();
  const parsed = ExtendedPrivateKey.parse(serialized);
  t.is(parsed.privateKey, fixture.privateKey);
  t.is(parsed.chainCode, fixture.chainCode);
});

test("ExtendedPrivateKey, derivate extended public key", (t) => {
  const extendedKey = new ExtendedPrivateKey(
    fixture.privateKey,
    fixture.chainCode
  ).toExtendedPublicKey();
  t.is(extendedKey.publicKey, fixture.publicKey);
  t.is(extendedKey.chainCode, fixture.chainCode);
});

test("ExtendedPrivateKey, derivate account extended public key", (t) => {
  const extendedKey = new ExtendedPrivateKey(
    fixture.privateKey,
    fixture.chainCode
  ).toAccountExtendedPublicKey();

  t.is(extendedKey.publicKey, fixture.accountPublicKey);
  t.is(extendedKey.chainCode, fixture.accountChainCode);
  t.true(extendedKey instanceof AccountExtendedPublicKey);
});

const mnemonic =
  "tank planet champion pottery together intact quick police asset flower sudden question";
const receivingKeyInfo: PrivateKeyInfo = {
  privateKey:
    "0x848422863825f69e66dc7f48a3302459ec845395370c23578817456ad6b04b14",
  publicKey:
    "0x034dc074f2663d73aedd36f5fc2d1a1e4ec846a4dffa62d8d8bae8a4d6fffdf2b0",
  path: `m/44'/309'/0'/0/0`,
};

const changeKeyInfo: PrivateKeyInfo = {
  privateKey:
    "0x15ec3e9ba7024557a116f37f08a99ee7769882c2cb4cfabeced1662394279747",
  publicKey:
    "0x03f3600eb8f2bd7675fd7763dbe3fc36a1103e45b46629860a88a374bcf015df03",
  path: `m/44'/309'/0'/1/0`,
};

test("ExtendedPrivateKey#privateKeyInfoByPath", (t) => {
  const seed = mnemonicToSeedSync(mnemonic);
  const extendedKey = ExtendedPrivateKey.fromSeed(seed);
  const receivingPrivateKeyInfo = extendedKey.privateKeyInfoByPath(
    receivingKeyInfo.path
  );
  t.is(receivingPrivateKeyInfo.privateKey, receivingKeyInfo.privateKey);
  t.is(receivingPrivateKeyInfo.publicKey, receivingKeyInfo.publicKey);
  t.is(receivingPrivateKeyInfo.path, receivingKeyInfo.path);

  const changePrivateKeyInfo = extendedKey.privateKeyInfoByPath(
    changeKeyInfo.path
  );
  t.is(changePrivateKeyInfo.privateKey, changeKeyInfo.privateKey);
  t.is(changePrivateKeyInfo.publicKey, changeKeyInfo.publicKey);
  t.is(changePrivateKeyInfo.path, changeKeyInfo.path);
});

test("ExtendedPrivateKey#privateKeyInfo", (t) => {
  const seed = mnemonicToSeedSync(mnemonic);
  const extendedKey = ExtendedPrivateKey.fromSeed(seed);
  const receivingPrivateKeyInfo = extendedKey.privateKeyInfo(
    AddressType.Receiving,
    0
  );
  t.is(receivingPrivateKeyInfo.privateKey, receivingKeyInfo.privateKey);
  t.is(receivingPrivateKeyInfo.publicKey, receivingKeyInfo.publicKey);
  t.is(receivingPrivateKeyInfo.path, receivingKeyInfo.path);

  const changePrivateKeyInfo = extendedKey.privateKeyInfo(
    AddressType.Change,
    0
  );
  t.is(changePrivateKeyInfo.privateKey, changeKeyInfo.privateKey);
  t.is(changePrivateKeyInfo.publicKey, changeKeyInfo.publicKey);
  t.is(changePrivateKeyInfo.path, changeKeyInfo.path);
});

'''
'''--- packages/hd/tests/fixtures/ckb_cli_keystore.json ---
{
  "crypto": {
    "cipher": "aes-128-ctr",
    "cipherparams": {
      "iv": "54cf58110a62bce69b9374cd08d8416b"
    },
    "ciphertext": "80fd150254497bb2127425e6c6a009a8071b42d9ecb8919e09ebb7a7d20220fbcf0db76711924d8640a3e0d5c6bbd1b33725bb206e5072b67e4153c22a038a0d",
    "kdf": "scrypt",
    "kdfparams": {
      "dklen": 32,
      "n": 262144,
      "p": 1,
      "r": 8,
      "salt": "c9611e41093ef0f3d4fe2463885385b11b270a2e9b453974a500740bb8f71c40"
    },
    "mac": "c6699cc6c78f13d768ca0876a407e8a3ff17b1d418ecd7c88bafd66ab60715a2"
  },
  "hash160": "36c329ed630d6ce750712a477543672adab57f4c",
  "id": "cf022e08-2596-4cc2-b8dd-030e9810d41a",
  "origin": "ckb-cli",
  "version": 3
}

'''
'''--- packages/hd/tests/fixtures/xpub.json ---
{"xpubkey":"03d8fc68aa9ddd16fa5449f13441366a814ef4a5246f54df9bc070e77106b75e34be7dabec2733a2f8d9820ce2ae2d17a2f7abde3d0af79a54dbb1fbe5a652b52d"}

'''
'''--- packages/hd/tests/key.test.ts ---
import test from "ava";
import { key } from "../src";
const {
  signRecoverable,
  recoverFromSignature,
  privateToPublic,
  publicKeyToBlake160,
  privateKeyToBlake160,
} = key;

const signInfo = {
  message: "0x95e919c41e1ae7593730097e9bb1185787b046ae9f47b4a10ff4e22f9c3e3eab",
  signature:
    "0x1e94db61cff452639cf7dd991cf0c856923dcf74af24b6f575b91479ad2c8ef40769812d1cf1fd1a15d2f6cb9ef3d91260ef27e65e1f9be399887e9a5447786301",
  privateKey:
    "0xe79f3207ea4980b7fed79956d5934249ceac4751a4fae01a0f7c4a96884bc4e3",
  publicKey:
    "0x024a501efd328e062c8675f2365970728c859c592beeefd6be8ead3d901330bc01",
  blake160: "0x36c329ed630d6ce750712a477543672adab57f4c",
};

test("signRecoverable", (t) => {
  const signature = signRecoverable(signInfo.message, signInfo.privateKey);
  t.is(signature, signInfo.signature);
});

test("recoverFromMessage", (t) => {
  const publicKey = recoverFromSignature(signInfo.message, signInfo.signature);
  t.is(publicKey, signInfo.publicKey);
});

test("privateToPublic, derive public key from private key, Buffer", (t) => {
  const privateKey = Buffer.from(
    "bb39d218506b30ca69b0f3112427877d983dd3cd2cabc742ab723e2964d98016",
    "hex"
  );
  const publicKey = Buffer.from(
    "03e5b310636a0f6e7dcdfffa98f28d7ed70df858bb47acf13db830bfde3510b3f3",
    "hex"
  );
  t.deepEqual(privateToPublic(privateKey), publicKey);
});

test("privateToPublic, derive public key from private key, HexString", (t) => {
  const privateKey =
    "0xbb39d218506b30ca69b0f3112427877d983dd3cd2cabc742ab723e2964d98016";
  const publicKey =
    "0x03e5b310636a0f6e7dcdfffa98f28d7ed70df858bb47acf13db830bfde3510b3f3";
  t.deepEqual(privateToPublic(privateKey), publicKey);
});

test("privateToPublic, derive public key from private key wrong length", (t) => {
  t.throws(() => {
    privateToPublic(Buffer.from(""));
  });
  t.throws(() => {
    privateToPublic(
      Buffer.from(
        "39d218506b30ca69b0f3112427877d983dd3cd2cabc742ab723e2964d98016",
        "hex"
      )
    );
  });
  t.throws(() => {
    privateToPublic(
      Buffer.from(
        "0xbb39d218506b30ca69b0f3112427877d983dd3cd2cabc742ab723e2964d98016",
        "hex"
      )
    );
  });
});

test("publicKeyToBlake160", (t) => {
  const blake160 = publicKeyToBlake160(signInfo.publicKey);
  t.is(blake160, signInfo.blake160);
});

test("privateKeyToBlake160", (t) => {
  const blake160 = privateKeyToBlake160(signInfo.privateKey);
  t.is(blake160, signInfo.blake160);
});

'''
'''--- packages/hd/tests/keychain.test.ts ---
import test from "ava";
import { Keychain } from "../src";

// https://en.bitcoin.it/wiki/BIP_0032_TestVectors
const shortSeed = Buffer.from("000102030405060708090a0b0c0d0e0f", "hex");
const longSeed = Buffer.from(
  "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
  "hex"
);

test("create master keychain from seed", (t) => {
  const master = Keychain.fromSeed(shortSeed);

  t.is(
    master.privateKey.toString("hex"),
    "e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35"
  );
  t.is(
    master.identifier.toString("hex"),
    "3442193e1bb70916e914552172cd4e2dbc9df811"
  );
  t.is(master.fingerprint, 876747070);
  t.is(
    master.chainCode.toString("hex"),
    "873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508"
  );
  t.is(master.index, 0);
  t.is(master.depth, 0);
  t.is(master.parentFingerprint, 0);
});

test("derive children hardened", (t) => {
  const master = Keychain.fromSeed(shortSeed);
  const child = master.deriveChild(0, true);

  t.is(
    child.privateKey.toString("hex"),
    "edb2e14f9ee77d26dd93b4ecede8d16ed408ce149b6cd80b0715a2d911a0afea"
  );
  t.is(
    child.identifier.toString("hex"),
    "5c1bd648ed23aa5fd50ba52b2457c11e9e80a6a7"
  );
  t.is(child.fingerprint, 1545328200);
  t.is(
    child.chainCode.toString("hex"),
    "47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141"
  );
  t.is(child.index, 0);
  t.is(child.depth, 1);
});

test("derive path", (t) => {
  const master = Keychain.fromSeed(shortSeed);
  t.is(
    master.derivePath(`m/0'`).privateKey.toString("hex"),
    "edb2e14f9ee77d26dd93b4ecede8d16ed408ce149b6cd80b0715a2d911a0afea"
  );

  const child = master.derivePath(`m/0'/1/2'`);

  t.is(
    child.privateKey.toString("hex"),
    "cbce0d719ecf7431d88e6a89fa1483e02e35092af60c042b1df2ff59fa424dca"
  );
  t.is(
    child.identifier.toString("hex"),
    "ee7ab90cde56a8c0e2bb086ac49748b8db9dce72"
  );
  t.is(child.fingerprint, 4001020172);
  t.is(
    child.chainCode.toString("hex"),
    "04466b9cc8e161e966409ca52986c584f07e9dc81f735db683c3ff6ec7b1503f"
  );
  t.is(child.index, 2);
  t.is(child.depth, 3);
});

test("create master keychain from long seed", (t) => {
  const master = Keychain.fromSeed(longSeed);

  t.is(
    master.privateKey.toString("hex"),
    "4b03d6fc340455b363f51020ad3ecca4f0850280cf436c70c727923f6db46c3e"
  );
  t.is(
    master.identifier.toString("hex"),
    "bd16bee53961a47d6ad888e29545434a89bdfe95"
  );
  t.is(master.fingerprint, 3172384485);
  t.is(
    master.chainCode.toString("hex"),
    "60499f801b896d83179a4374aeb7822aaeaceaa0db1f85ee3e904c4defbd9689"
  );
  t.is(master.index, 0);
  t.is(master.depth, 0);
  t.is(master.parentFingerprint, 0);
});

test("derive path large index", (t) => {
  const master = Keychain.fromSeed(longSeed);
  t.is(
    master.derivePath(`m`).privateKey.toString("hex"),
    "4b03d6fc340455b363f51020ad3ecca4f0850280cf436c70c727923f6db46c3e"
  );

  let child = master.derivePath(`0/2147483647'`);
  t.is(
    child.privateKey.toString("hex"),
    "877c779ad9687164e9c2f4f0f4ff0340814392330693ce95a58fe18fd52e6e93"
  );
  t.is(
    child.identifier.toString("hex"),
    "d8ab493736da02f11ed682f88339e720fb0379d1"
  );
  t.is(child.fingerprint, 3635104055);
  t.is(
    child.chainCode.toString("hex"),
    "be17a268474a6bb9c61e1d720cf6215e2a88c5406c4aee7b38547f585c9a37d9"
  );
  t.is(child.index, 2147483647);
  t.is(child.depth, 2);

  child = child.deriveChild(1, false);
  t.is(
    child.privateKey.toString("hex"),
    "704addf544a06e5ee4bea37098463c23613da32020d604506da8c0518e1da4b7"
  );
  t.is(
    child.identifier.toString("hex"),
    "78412e3a2296a40de124307b6485bd19833e2e34"
  );
  t.is(child.fingerprint, 2017537594);
  t.is(
    child.chainCode.toString("hex"),
    "f366f48f1ea9f2d1d3fe958c95ca84ea18e4c4ddb9366c336c927eb246fb38cb"
  );
  t.is(child.index, 1);
  t.is(child.depth, 3);

  child = child.deriveChild(2147483646, true);
  t.is(
    child.privateKey.toString("hex"),
    "f1c7c871a54a804afe328b4c83a1c33b8e5ff48f5087273f04efa83b247d6a2d"
  );
  t.is(
    child.identifier.toString("hex"),
    "31a507b815593dfc51ffc7245ae7e5aee304246e"
  );
  t.is(child.fingerprint, 832899000);
  t.is(
    child.chainCode.toString("hex"),
    "637807030d55d01f9a0cb3a7839515d796bd07706386a6eddf06cc29a65a0e29"
  );
  t.is(child.index, 2147483646);
  t.is(child.depth, 4);
});

test("derive children no hardened", (t) => {
  const master = Keychain.fromSeed(longSeed);
  const child = master.deriveChild(0, false);
  t.is(
    child.privateKey.toString("hex"),
    "abe74a98f6c7eabee0428f53798f0ab8aa1bd37873999041703c742f15ac7e1e"
  );
  t.is(
    child.identifier.toString("hex"),
    "5a61ff8eb7aaca3010db97ebda76121610b78096"
  );
  t.is(child.fingerprint, 1516371854);
  t.is(
    child.chainCode.toString("hex"),
    "f0909affaa7ee7abe5dd4e100598d4dc53cd709d5a5c2cac40e7412f232f7c9c"
  );
  t.is(child.index, 0);
  t.is(child.depth, 1);
});

test("create child keychain from public key", (t) => {
  const child = Keychain.fromPublicKey(
    Buffer.from(
      "0357bfe1e341d01c69fe5654309956cbea516822fba8a601743a012a7896ee8dc2",
      "hex"
    ),
    Buffer.from(
      "04466b9cc8e161e966409ca52986c584f07e9dc81f735db683c3ff6ec7b1503f",
      "hex"
    ),
    `m/0'/1/2'`
  );
  t.is(
    child.identifier.toString("hex"),
    "ee7ab90cde56a8c0e2bb086ac49748b8db9dce72"
  );
  t.is(child.fingerprint, 4001020172);
  t.is(child.index, 2);
  t.is(child.depth, 3);

  const grandchild = child.deriveChild(2, false);
  t.is(
    grandchild.publicKey.toString("hex"),
    "02e8445082a72f29b75ca48748a914df60622a609cacfce8ed0e35804560741d29"
  );
  t.is(
    grandchild.chainCode.toString("hex"),
    "cfb71883f01676f587d023cc53a35bc7f88f724b1f8c2892ac1275ac822a3edd"
  );
  t.is(
    grandchild.identifier.toString("hex"),
    "d880d7d893848509a62d8fb74e32148dac68412f"
  );
  t.is(grandchild.fingerprint, 3632322520);
  t.is(grandchild.index, 2);
  t.is(grandchild.depth, 4);
});

test("derive ckb keys", (t) => {
  const master = Keychain.fromSeed(shortSeed);
  const extendedKey = master.derivePath(`m/44'/309'/0'`);
  t.is(
    extendedKey.privateKey.toString("hex"),
    "bb39d218506b30ca69b0f3112427877d983dd3cd2cabc742ab723e2964d98016"
  );
  t.is(
    extendedKey.publicKey.toString("hex"),
    "03e5b310636a0f6e7dcdfffa98f28d7ed70df858bb47acf13db830bfde3510b3f3"
  );
  t.is(
    extendedKey.chainCode.toString("hex"),
    "37e85a19f54f0a242a35599abac64a71aacc21e3a5860dd024377ffc7e6827d8"
  );

  const addressKey = extendedKey.deriveChild(0, false).deriveChild(0, false);
  t.is(
    addressKey.privateKey.toString("hex"),
    "fcba4708f1f07ddc00fc77422d7a70c72b3456f5fef3b2f68368cdee4e6fb498"
  );
  t.is(
    addressKey.publicKey.toString("hex"),
    "0331b3c0225388c5010e3507beb28ecf409c022ef6f358f02b139cbae082f5a2a3"
  );
  t.is(
    addressKey.chainCode.toString("hex"),
    "c4b7aef857b625bbb0497267ed51151d090f81737f4f22a0ac3673483b927090"
  );
});

test("derive ckb keys another seed", (t) => {
  const master = Keychain.fromSeed(
    // From mnemonic `tank planet champion pottery together intact quick police asset flower sudden question`
    Buffer.from(
      "1371018cfad5990f5e451bf586d59c3820a8671162d8700533549b0df61a63330e5cd5099a5d3938f833d51e4572104868bfac7cfe5b4063b1509a995652bc08",
      "hex"
    )
  );
  t.is(
    master.privateKey.toString("hex"),
    "37d25afe073a6ba17badc2df8e91fc0de59ed88bcad6b9a0c2210f325fafca61"
  );

  t.is(
    master.derivePath(`m/44'/309'/0'`).privateKey.toString("hex"),
    "2925f5dfcbee3b6ad29100a37ed36cbe92d51069779cc96164182c779c5dc20e"
  );

  t.is(
    master
      .derivePath(`m/44'/309'/0'`)
      .deriveChild(0, false)
      .privateKey.toString("hex"),
    "047fae4f38b3204f93a6b39d6dbcfbf5901f2b09f6afec21cbef6033d01801f1"
  );

  t.is(
    master.derivePath(`m/44'/309'/0'/0`).privateKey.toString("hex"),
    "047fae4f38b3204f93a6b39d6dbcfbf5901f2b09f6afec21cbef6033d01801f1"
  );

  t.is(
    master
      .derivePath(`m/44'/309'/0'`)
      .deriveChild(0, false)
      .deriveChild(0, false)
      .privateKey.toString("hex"),
    "848422863825f69e66dc7f48a3302459ec845395370c23578817456ad6b04b14"
  );

  t.is(
    master.derivePath(`m/44'/309'/0'/0/0`).privateKey.toString("hex"),
    "848422863825f69e66dc7f48a3302459ec845395370c23578817456ad6b04b14"
  );
});

test("derive ckb keys from master extended key", (t) => {
  const privateKey = Buffer.from(
    "37d25afe073a6ba17badc2df8e91fc0de59ed88bcad6b9a0c2210f325fafca61",
    "hex"
  );
  const chainCode = Buffer.from(
    "5f772d1e3cfee5821911aefa5e8f79d20d4cf6678378d744efd08b66b2633b80",
    "hex"
  );
  const master = new Keychain(privateKey, chainCode);
  t.is(
    master.publicKey.toString("hex"),
    "020720a7a11a9ac4f0330e2b9537f594388ea4f1cd660301f40b5a70e0bc231065"
  );

  t.is(
    master.derivePath(`m/44'/309'/0'`).privateKey.toString("hex"),
    "2925f5dfcbee3b6ad29100a37ed36cbe92d51069779cc96164182c779c5dc20e"
  );

  t.is(
    master
      .derivePath(`m/44'/309'/0'`)
      .deriveChild(0, false)
      .privateKey.toString("hex"),
    "047fae4f38b3204f93a6b39d6dbcfbf5901f2b09f6afec21cbef6033d01801f1"
  );

  t.is(
    master.derivePath(`m/44'/309'/0'/0`).privateKey.toString("hex"),
    "047fae4f38b3204f93a6b39d6dbcfbf5901f2b09f6afec21cbef6033d01801f1"
  );

  t.is(
    master
      .derivePath(`m/44'/309'/0'`)
      .deriveChild(0, false)
      .deriveChild(0, false)
      .privateKey.toString("hex"),
    "848422863825f69e66dc7f48a3302459ec845395370c23578817456ad6b04b14"
  );

  t.is(
    master.derivePath(`m/44'/309'/0'/0/0`).privateKey.toString("hex"),
    "848422863825f69e66dc7f48a3302459ec845395370c23578817456ad6b04b14"
  );
});

test("private key add", (t) => {
  const privateKey = Buffer.from(
    "9e919c96ac5a4caea7ba0ea1f7dd7bca5dca8a11e66ed633690c71e483a6e3c9",
    "hex"
  );
  const toAdd = Buffer.from(
    "36e92e33659808bf06c3e4302b657f39ca285f6bb5393019bb4e2f7b96e3f914",
    "hex"
  );
  // @ts-ignore: Private method
  const sum = Keychain.privateKeyAdd(privateKey, toAdd);
  t.is(
    sum.toString("hex"),
    "d57acaca11f2556dae7df2d22342fb0427f2e97d9ba8064d245aa1601a8adcdd"
  );
});

test("public key add", (t) => {
  const publicKey = Buffer.from(
    "03556b2c7e03b12845a973a6555b49fe44b0836fbf3587709fa73bb040ba181b21",
    "hex"
  );
  const toAdd = Buffer.from(
    "953fd6b91b51605d32a28ab478f39ab53c90103b93bd688330b118c460e9c667",
    "hex"
  );
  // @ts-ignore: Private method
  const sum = Keychain.publicKeyAdd(publicKey, toAdd);
  t.is(
    sum.toString("hex"),
    "03db6eab66f918e434bae0e24fd73de1a2b293a2af9bd3ad53123996fa94494f37"
  );
});

'''
'''--- packages/hd/tests/keystore.test.ts ---
import test from "ava";
import { ExtendedPrivateKey, Keystore, IncorrectPassword } from "../src";

const fixture = {
  privateKey:
    "0xe8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35",
  publicKey:
    "0x0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2",
  chainCode:
    "0x873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508",
};

// 'load and check password'
const password = "hello~!23";
const keystore = Keystore.create(
  new ExtendedPrivateKey(fixture.privateKey, fixture.chainCode),
  password
);

test("checks wrong password", (t) => {
  t.false(keystore.checkPassword(`oops${password}`));
});

test("checks correct password", (t) => {
  t.true(keystore.checkPassword(password));
});

test("decrypts", (t) => {
  t.is(
    keystore.decrypt(password),
    new ExtendedPrivateKey(fixture.privateKey, fixture.chainCode).serialize()
  );
});

test("load and check password, loads private key", (t) => {
  const extendedPrivateKey = keystore.extendedPrivateKey(password);
  t.is(extendedPrivateKey.privateKey, fixture.privateKey);
  t.is(extendedPrivateKey.chainCode, fixture.chainCode);
});

// 'load ckb cli light keystore'
test("load ckb cli light keystore, checks correct password", (t) => {
  const password = "123";
  const keystoreString =
    '{"crypto":{"cipher": "aes-128-ctr", "ciphertext": "253397209cae86474e368720f9baa30f448767047d2cc5a7672ef121861974ed", "cipherparams": {"iv": "8bd8523e0048db3a4ae2534aec6d303a"}, "kdf": "scrypt", "kdfparams": {"dklen": 32, "n": 4096, "p": 6, "r": 8, "salt": "be3d86c99f4895f99d1a0048afb61a34153fa83d5edd033fc914de2c502f57e7"}, "mac": "4453cf5d4f6ec43d0664c3895c4ab9b1c9bcd2d02c7abb190c84375a42739099" },"id": "id", "version": 3}';
  const keystore = Keystore.fromJson(keystoreString);
  t.true(keystore.checkPassword(password));
});

// 'load ckb cli standard keystore'
test("load ckb cli standard keystore, checks correct password", (t) => {
  const password = "123";
  const keystoreString =
    '{"address":"ea22142fa5be326e834681144ca30326f99a6d5a","crypto":{"cipher":"aes-128-ctr","cipherparams":{"iv":"29304e5bcbb1885ef5cdcb40b5312b58"},"ciphertext":"93054530a8fbe5b11995acda856585d7362ac7d2b1e4f268c633d997be2d6532c4962501d0835bf52a4693ae7a091ac9bac9297793f4116ef7c123edb00dbc85","kdf":"scrypt","kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,"salt":"724327e67ca321ccf15035bb78a0a05c816bebbe218a0840abdc26da8453c1f4"},"mac":"1d0e5660ffbfc1f9ff4da97aefcfc2153c0ec1b411e35ffee26ee92815cc06f9"},"id":"43c1116e-efd5-4c9e-a86a-3ec0ab163122","version":3}';
  const keystore = Keystore.fromJson(keystoreString);
  t.true(keystore.checkPassword(password));
});

test("load ckb cli standard keystore, loads private key", (t) => {
  const password = "123";
  const keystoreString =
    '{"address":"ea22142fa5be326e834681144ca30326f99a6d5a","crypto":{"cipher":"aes-128-ctr","cipherparams":{"iv":"29304e5bcbb1885ef5cdcb40b5312b58"},"ciphertext":"93054530a8fbe5b11995acda856585d7362ac7d2b1e4f268c633d997be2d6532c4962501d0835bf52a4693ae7a091ac9bac9297793f4116ef7c123edb00dbc85","kdf":"scrypt","kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,"salt":"724327e67ca321ccf15035bb78a0a05c816bebbe218a0840abdc26da8453c1f4"},"mac":"1d0e5660ffbfc1f9ff4da97aefcfc2153c0ec1b411e35ffee26ee92815cc06f9"},"id":"43c1116e-efd5-4c9e-a86a-3ec0ab163122","version":3}';
  const keystore = Keystore.fromJson(keystoreString);
  const extendedPrivateKey = keystore.extendedPrivateKey(password);
  t.is(
    extendedPrivateKey.privateKey,
    "0x8af124598932440269a81771ad662642e83a38b323b2f70223b8ae0b6c5e0779"
  );
  t.is(
    extendedPrivateKey.chainCode,
    "0x615302e2c93151a55c29121dd02ad554e47908a6df6d7374f357092cec11675b"
  );
});

test("load ckb cli origin keystore", (t) => {
  const keystoreString =
    '{"origin":"ckb-cli", "address":"ea22142fa5be326e834681144ca30326f99a6d5a","crypto":{"cipher":"aes-128-ctr","cipherparams":{"iv":"29304e5bcbb1885ef5cdcb40b5312b58"},"ciphertext":"93054530a8fbe5b11995acda856585d7362ac7d2b1e4f268c633d997be2d6532c4962501d0835bf52a4693ae7a091ac9bac9297793f4116ef7c123edb00dbc85","kdf":"scrypt","kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,"salt":"724327e67ca321ccf15035bb78a0a05c816bebbe218a0840abdc26da8453c1f4"},"mac":"1d0e5660ffbfc1f9ff4da97aefcfc2153c0ec1b411e35ffee26ee92815cc06f9"},"id":"43c1116e-efd5-4c9e-a86a-3ec0ab163122","version":3}';

  const keystore = Keystore.fromJson(keystoreString);
  t.is(keystore.origin, "ckb-cli");
});

// "create empty keystore"
const emptyKeystore = Keystore.createEmpty();

test("empty keystore has empty cipertext and mac", (t) => {
  t.is(emptyKeystore.crypto.ciphertext, "");
  t.is(emptyKeystore.crypto.mac, "");
});

test("empty keystore won't verify password", (t) => {
  t.false(emptyKeystore.checkPassword(""));
  t.false(emptyKeystore.checkPassword("anypassword"));
});

test("empty keystore cannot decrypt", (t) => {
  const err = t.throws(() => emptyKeystore.decrypt(""));
  t.true(err instanceof IncorrectPassword);
});

'''
'''--- packages/hd/tests/mnemonic/fixtures.json ---
{
  "vectors": [
    {
      "entropy": "00000000000000000000000000000000",
      "mnemonic": "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
      "seed": "5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4"
    },

    {
      "entropy": "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
      "mnemonic": "legal winner thank year wave sausage worth useful legal winner thank yellow",
      "seed": "878386efb78845b3355bd15ea4d39ef97d179cb712b77d5c12b6be415fffeffe5f377ba02bf3f8544ab800b955e51fbff09828f682052a20faa6addbbddfb096"
    },

    {
      "entropy": "80808080808080808080808080808080",
      "mnemonic": "letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
      "seed": "77d6be9708c8218738934f84bbbb78a2e048ca007746cb764f0673e4b1812d176bbb173e1a291f31cf633f1d0bad7d3cf071c30e98cd0688b5bcce65ecaceb36"
    },

    {
      "entropy": "ffffffffffffffffffffffffffffffff",
      "mnemonic": "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
      "seed": "b6a6d8921942dd9806607ebc2750416b289adea669198769f2e15ed926c3aa92bf88ece232317b4ea463e84b0fcd3b53577812ee449ccc448eb45e6f544e25b6"
    },

    {
      "entropy": "000000000000000000000000000000000000000000000000",
      "mnemonic": "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
      "seed": "4975bb3d1faf5308c86a30893ee903a976296609db223fd717e227da5a813a34dc1428b71c84a787fc51f3b9f9dc28e9459f48c08bd9578e9d1b170f2d7ea506"
    },

    {
      "entropy": "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
      "mnemonic": "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
      "seed": "b059400ce0f55498a5527667e77048bb482ff6daa16c37b4b9e8af70c85b3f4df588004f19812a1a027c9a51e5e94259a560268e91cd10e206451a129826e740"
    },

    {
      "entropy": "808080808080808080808080808080808080808080808080",
      "mnemonic": "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
      "seed": "04d5f77103510c41d610f7f5fb3f0badc77c377090815cee808ea5d2f264fdfabf7c7ded4be6d4c6d7cdb021ba4c777b0b7e57ca8aa6de15aeb9905dba674d66"
    },

    {
      "entropy": "ffffffffffffffffffffffffffffffffffffffffffffffff",
      "mnemonic": "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
      "seed": "d2911131a6dda23ac4441d1b66e2113ec6324354523acfa20899a2dcb3087849264e91f8ec5d75355f0f617be15369ffa13c3d18c8156b97cd2618ac693f759f"
    },

    {
      "entropy": "0000000000000000000000000000000000000000000000000000000000000000",
      "mnemonic": "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
      "seed": "408b285c123836004f4b8842c89324c1f01382450c0d439af345ba7fc49acf705489c6fc77dbd4e3dc1dd8cc6bc9f043db8ada1e243c4a0eafb290d399480840"
    },

    {
      "entropy": "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
      "mnemonic": "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
      "seed": "761914478ebf6fe16185749372e91549361af22b386de46322cf8b1ba7e92e80c4af05196f742be1e63aab603899842ddadf4e7248d8e43870a4b6ff9bf16324"
    },

    {
      "entropy": "8080808080808080808080808080808080808080808080808080808080808080",
      "mnemonic": "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
      "seed": "848bbe19cad445e46f35fd3d1a89463583ac2b60b5eb4cfcf955731775a5d9e17a81a71613fed83f1ae27b408478fdec2bbc75b5161d1937aa7cdf4ad686ef5f"
    },

    {
      "entropy": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "mnemonic": "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
      "seed": "e28a37058c7f5112ec9e16a3437cf363a2572d70b6ceb3b6965447623d620f14d06bb321a26b33ec15fcd84a3b5ddfd5520e230c924c87aaa0d559749e044fef"
    },

    {
      "entropy": "77c2b00716cec7213839159e404db50d",
      "mnemonic": "jelly better achieve collect unaware mountain thought cargo oxygen act hood bridge",
      "seed": "c7b8fbb38c1abe38dfc0fea9797804558dfac244cd7737ae3a1b619991e0ad520155d982f906629639dc39e440520f98f820bea4f886a63a45923a63441f25ef"
    },

    {
      "entropy": "b63a9c59a6e641f288ebc103017f1da9f8290b3da6bdef7b",
      "mnemonic": "renew stay biology evidence goat welcome casual join adapt armor shuffle fault little machine walk stumble urge swap",
      "seed": "b1a1f06f175feccc998684667474b3d83efa57a0f39bb3a6cf3a3350ee7a6638ae6d15c4622c8252efe5aa319b026db1d4c91a80661ed34da1f2fb7d381224c8"
    },

    {
      "entropy": "3e141609b97933b66a060dcddc71fad1d91677db872031e85f4c015c5e7e8982",
      "mnemonic": "dignity pass list indicate nasty swamp pool script soccer toe leaf photo multiply desk host tomato cradle drill spread actor shine dismiss champion exotic",
      "seed": "ecf9632e864630c00be4ca3d752d4f19a852cd628d9bbc3309a4c1a2f39801461a6816ca52793ddd3dacb242e207ad48e8bfde3afd0e8f978ad0e8cc4dd276c1"
    },

    {
      "entropy": "0460ef47585604c5660618db2e6a7e7f",
      "mnemonic": "afford alter spike radar gate glance object seek swamp infant panel yellow",
      "seed": "3ddfd060236156416f8915ed6ced01c3316292aec7250434f7e32cda2338e76399874787257acad15618c81bcddd88714f8c0d316140dad809f0ca8b1a971679"
    },

    {
      "entropy": "72f60ebac5dd8add8d2a25a797102c3ce21bc029c200076f",
      "mnemonic": "indicate race push merry suffer human cruise dwarf pole review arch keep canvas theme poem divorce alter left",
      "seed": "fe34200c8c3781f81f48d19f628a7370eb25c94c75077c9a6d4a1ef30fd9cc2f29f8ea7ef52bb765c5278413c19b7b2854b62cb3591ce4d749cd7f497da436a6"
    },

    {
      "entropy": "2c85efc7f24ee4573d2b81a6ec66cee209b2dcbd09d8eddc51e0215b0b68e416",
      "mnemonic": "clutch control vehicle tonight unusual clog visa ice plunge glimpse recipe series open hour vintage deposit universe tip job dress radar refuse motion taste",
      "seed": "fa9ca5ef1ebfcb5e945091d413843bf7ce748d27b8b99bb5373d34b9a6b1450d2a2d7f04480904b29c78a41a6ea949288f687f72b5b8e322193a7eae8151f109"
    },

    {
      "entropy": "eaebabb2383351fd31d703840b32e9e2",
      "mnemonic": "turtle front uncle idea crush write shrug there lottery flower risk shell",
      "seed": "4ef6e8484a846392f996b15283906b73be4ec100859ce68689d5a0fad7f761745b86d70ea5f5c43e4cc93ce4b82b3d9aeed7f85d503fac00b10ebbc150399100"
    },

    {
      "entropy": "7ac45cfe7722ee6c7ba84fbc2d5bd61b45cb2fe5eb65aa78",
      "mnemonic": "kiss carry display unusual confirm curtain upgrade antique rotate hello void custom frequent obey nut hole price segment",
      "seed": "f0b24a453174e3c4f27634f3e2be07c069328f7cbaa24f695cbeb79a39e79f05154bddbabec57b832a46813d2e49e7b33f438e79cc566f78a3179dbce86cdd84"
    },

    {
      "entropy": "4fa1a8bc3e6d80ee1316050e862c1812031493212b7ec3f3bb1b08f168cabeef",
      "mnemonic": "exile ask congress lamp submit jacket era scheme attend cousin alcohol catch course end lucky hurt sentence oven short ball bird grab wing top",
      "seed": "8a91a843ad4fede95f23937099a94f117115a369903603761ecabae734b5d501ddba04b1a3c9f2256437ef2d230f295d8f08676e5de93ad5190da6645ded8160"
    },

    {
      "entropy": "18ab19a9f54a9274f03e5209a2ac8a91",
      "mnemonic": "board flee heavy tunnel powder denial science ski answer betray cargo cat",
      "seed": "22087755f76d6fb93ddd19e71106d4d4146f48424a241c0eda88787227827166223f61860d53652b635f360b5a37dd26c8aed3fa10b6f8e95be18f1913f4ca88"
    },

    {
      "entropy": "18a2e1d81b8ecfb2a333adcb0c17a5b9eb76cc5d05db91a4",
      "mnemonic": "board blade invite damage undo sun mimic interest slam gaze truly inherit resist great inject rocket museum chief",
      "seed": "99539dbb0a15a76cdadd9cc066bae337a006823fa3439b42656fd0fca3d48afe6a0ca6f7a1d10412df611c32e18669a29bc0494de61b4c36730a5c31045464e2"
    },

    {
      "entropy": "15da872c95a13dd738fbf50e427583ad61f18fd99f628c417a61cf8343c90419",
      "mnemonic": "beyond stage sleep clip because twist token leaf atom beauty genius food business side grid unable middle armed observe pair crouch tonight away coconut",
      "seed": "898c7388d88e3a5b3b2922a0f03f95c8e61aeadba9fa8a7b0b5629d7c98e1e0aec53f0b10fcbd4a913b4b8c985028b0026ec6fdb0a4442ee18344ca3fac4d692"
    }
  ]
}

'''
'''--- packages/hd/tests/mnemonic/index.test.ts ---
import test from "ava";
import {
  entropyToMnemonic,
  mnemonicToEntropy,
  mnemonicToSeed,
  mnemonicToSeedSync,
  validateMnemonic,
  generateMnemonic,
} from "../../src/mnemonic/index";

const fixtures = require("./fixtures.json");

test("generate & validate mnemonic", (t) => {
  fixtures.vectors.map(
    async ({
      entropy,
      mnemonic,
    }: {
      entropy: string;
      mnemonic: string;
      seed: string;
    }) => {
      t.true(validateMnemonic(mnemonic));
      t.is(entropyToMnemonic("0x" + entropy), mnemonic);
      t.is(mnemonicToEntropy(mnemonic), "0x" + entropy);
    }
  );
});

test("generate seed", async (t) => {
  await Promise.all(
    fixtures.vectors.map(
      async ({
        mnemonic,
        seed,
      }: {
        entropy: string;
        mnemonic: string;
        seed: string;
      }) => {
        t.is(
          await mnemonicToSeed(mnemonic).then((s) => s.toString("hex")),
          seed
        );
        t.is(mnemonicToSeedSync(mnemonic).toString("hex"), seed);
      }
    )
  );
});

test("generate mnemonic 12 words code", (t) => {
  const mnemonic = generateMnemonic();
  t.is(mnemonic.split(" ").length, 12);
});

'''
'''--- packages/hd/tests/xpub_store.test.ts ---
import test from "ava";
import { XPubStore, AccountExtendedPublicKey } from "../src";
import fs from "fs";

// const mnemonic = "tank planet champion pottery together intact quick police asset flower sudden question";

const accountExtendedPublicKey = new AccountExtendedPublicKey(
  "0x03d8fc68aa9ddd16fa5449f13441366a814ef4a5246f54df9bc070e77106b75e34",
  "0xbe7dabec2733a2f8d9820ce2ae2d17a2f7abde3d0af79a54dbb1fbe5a652b52d"
);

const filePath = __dirname + "/fixtures/xpub.json";

test("load", (t) => {
  const xpub = XPubStore.load(filePath);
  const a = xpub.toAccountExtendedPublicKey();

  t.is(a.publicKey, accountExtendedPublicKey.publicKey);

  t.is(a.chainCode, accountExtendedPublicKey.chainCode);
});

test("toJson", (t) => {
  const xpub = new XPubStore(accountExtendedPublicKey);

  const json = fs.readFileSync(filePath, "utf-8");

  t.is(xpub.toJson(), JSON.stringify(JSON.parse(json)));
});

'''
'''--- packages/hd/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src"]
}

'''
'''--- packages/helpers/README.md ---
# `@ckb-lumos/helpers`

Helper utilities for working with CKB transactions from lumos.

The difference between this and `@ckb-lumos/base`, is that `@ckb-lumos/base` contains only core definitions, while this module contains utilities used in a framework sense. One example is: you can pretty much use `@ckb-lumos/base` as a standalone library, while this library integrates more with `config` module so it knows whether the framework is running under testnet, or mainnet environment.

## Usage

```javascript
const { minimalCellCapacity, generateAddress, parseAddress } = require("@ckb-lumos/helpers")

// Get cell minimal capacity.
const result = minimalCellCapacity({
  cell_output: {
    capacity: "0x174876e800",
    lock: {
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
    },
    type: null,
  },
  data: "0x",
  block_hash: null,
  block_number: null,
  out_point: null,
})

// result will be 6100000000n shannons.

// Use `generateAddress` to get address from lock script.
const address = generateAddress({
  code_hash:
    "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
  hash_type: "type",
  args: "0x36c329ed630d6ce750712a477543672adab57f4c",
})

// Then you will get mainnet address "ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd", or you can generate testnet address by
const { predefined } = require("@ckb-lumos/config-manager")

const address = generateAddress({
  code_hash:
    "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
  hash_type: "type",
  args: "0x36c329ed630d6ce750712a477543672adab57f4c",
}, { config: predefined.AGGRON4 })

// Will get testnet address "ckt1qyqrdsefa43s6m882pcj53m4gdnj4k440axqswmu83".

// Use `parseAddress` to get lock script from an address.
const script = parseAddress("ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd")

// TransactionSkeleton <=> Object

// Convert TransactionSkeleton to js object
const obj = transactionSkeletonToObject(txSkeleton)
// then your can write to json file
fs.writeFileSync("your file", JSON.stringify(obj))

// Or convert js object to TransactionSkeleton
// If your object is from json file, make sure `cellProvider` is working properly.
const txSkeleton = objectToTransactionSkeleton(obj)
```

'''
'''--- packages/helpers/package.json ---
{
  "name": "@ckb-lumos/helpers",
  "version": "0.17.0-rc8",
  "description": "Helper functions for working with CKB",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "src"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests}/**/*.ts\"",
    "test": "ava tests/**/*.test.ts --timeout=2m",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "@ckb-lumos/config-manager": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8",
    "bech32": "^1.1.4",
    "immutable": "^4.0.0-rc.12"
  },
  "devDependencies": {
    "typescript": "^3.9.6"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  }
}

'''
'''--- packages/helpers/src/index.ts ---
import {
  core,
  HexString,
  Cell,
  Script,
  CellDep,
  Address,
  CellProvider,
  Hash,
  PackedSince,
  Transaction,
  WitnessArgs,
} from "@ckb-lumos/base";
import * as bech32 from "bech32";
import { normalizers, validators, Reader } from "@ckb-lumos/toolkit";
import { List, Record, Map as ImmutableMap } from "immutable";
import { getConfig, Config } from "@ckb-lumos/config-manager";
import { BI } from "@ckb-lumos/bi";

export interface Options {
  config?: Config;
}

const BECH32_LIMIT = 1023;

function byteArrayToHex(a: number[]): HexString {
  return "0x" + a.map((i) => ("00" + i.toString(16)).slice(-2)).join("");
}

function hexToByteArray(h: HexString): number[] {
  if (!/^(0x)?([0-9a-fA-F][0-9a-fA-F])*$/.test(h)) {
    throw new Error("Invalid hex string!");
  }
  if (h.startsWith("0x")) {
    h = h.slice(2);
  }
  const array = [];
  while (h.length >= 2) {
    array.push(parseInt(h.slice(0, 2), 16));
    h = h.slice(2);
  }
  return array;
}

export function minimalCellCapacity(
  fullCell: Cell,
  { validate = true }: { validate?: boolean } = {}
): bigint {
  const result = minimalCellCapacityCompatible(fullCell, { validate });
  return BigInt(result.toString());
}

export function minimalCellCapacityCompatible(
  fullCell: Cell,
  { validate = true }: { validate?: boolean } = {}
): BI {
  if (validate) {
    validators.ValidateCellOutput(fullCell.cell_output);
  }
  // Capacity field itself
  let bytes = 8;
  bytes += new Reader(fullCell.cell_output.lock.code_hash).length();
  bytes += new Reader(fullCell.cell_output.lock.args).length();
  // hash_type field
  bytes += 1;
  if (fullCell.cell_output.type) {
    bytes += new Reader(fullCell.cell_output.type.code_hash).length();
    bytes += new Reader(fullCell.cell_output.type.args).length();
    bytes += 1;
  }
  if (fullCell.data) {
    bytes += new Reader(fullCell.data).length();
  }
  return BI.from(bytes).mul(100000000);
}

export function locateCellDep(
  script: Script,
  { config = undefined }: Options = {}
): CellDep | null {
  config = config || getConfig();
  const scriptTemplate = Object.values(config.SCRIPTS).find(
    (s) =>
      s!.CODE_HASH === script.code_hash && s!.HASH_TYPE === script.hash_type
  );
  if (scriptTemplate) {
    return {
      dep_type: scriptTemplate.DEP_TYPE,
      out_point: {
        tx_hash: scriptTemplate.TX_HASH,
        index: scriptTemplate.INDEX,
      },
    };
  }
  return null;
}

export function generateAddress(
  script: Script,
  { config = undefined }: Options = {}
): Address {
  config = config || getConfig();
  const scriptTemplate = Object.values(config.SCRIPTS).find(
    (s) =>
      s!.CODE_HASH === script.code_hash && s!.HASH_TYPE === script.hash_type
  );
  const data = [];
  if (scriptTemplate && scriptTemplate.SHORT_ID !== undefined) {
    data.push(1, scriptTemplate.SHORT_ID);
    data.push(...hexToByteArray(script.args));
  } else {
    data.push(script.hash_type === "type" ? 4 : 2);
    data.push(...hexToByteArray(script.code_hash));
    data.push(...hexToByteArray(script.args));
  }
  const words = bech32.toWords(data);
  return bech32.encode(config.PREFIX, words, BECH32_LIMIT);
}

export const scriptToAddress = generateAddress;

function generatePredefinedAddress(
  args: HexString,
  scriptType: string,
  { config = undefined }: Options = {}
): Address {
  config = config || getConfig();
  const template = config.SCRIPTS[scriptType]!;
  const script: Script = {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args,
  };

  return generateAddress(script, { config });
}

export function generateSecp256k1Blake160Address(
  args: HexString,
  { config = undefined }: Options = {}
): Address {
  return generatePredefinedAddress(args, "SECP256K1_BLAKE160", { config });
}

export function generateSecp256k1Blake160MultisigAddress(
  args: HexString,
  { config = undefined }: Options = {}
): Address {
  return generatePredefinedAddress(args, "SECP256K1_BLAKE160_MULTISIG", {
    config,
  });
}

export function parseAddress(
  address: Address,
  { config = undefined }: Options = {}
): Script {
  config = config || getConfig();
  const { prefix, words } = bech32.decode(address, BECH32_LIMIT);
  if (prefix !== config.PREFIX) {
    throw Error(
      `Invalid prefix! Expected: ${config.PREFIX}, actual: ${prefix}`
    );
  }
  const data = bech32.fromWords(words);
  switch (data[0]) {
    case 1:
      if (data.length < 2) {
        throw Error(`Invalid payload length!`);
      }
      const scriptTemplate = Object.values(config.SCRIPTS).find(
        (s) => s!.SHORT_ID === data[1]
      );
      if (!scriptTemplate) {
        throw Error(`Invalid code hash index: ${data[1]}!`);
      }
      return {
        code_hash: scriptTemplate.CODE_HASH,
        hash_type: scriptTemplate.HASH_TYPE,
        args: byteArrayToHex(data.slice(2)),
      };
    case 2:
      if (data.length < 33) {
        throw Error(`Invalid payload length!`);
      }
      return {
        code_hash: byteArrayToHex(data.slice(1, 33)),
        hash_type: "data",
        args: byteArrayToHex(data.slice(33)),
      };
    case 4:
      if (data.length < 33) {
        throw Error(`Invalid payload length!`);
      }
      return {
        code_hash: byteArrayToHex(data.slice(1, 33)),
        hash_type: "type",
        args: byteArrayToHex(data.slice(33)),
      };
  }
  throw Error(`Invalid payload format type: ${data[0]}`);
}

export const addressToScript = parseAddress;

export interface TransactionSkeletonInterface {
  cellProvider: CellProvider | null;
  cellDeps: List<CellDep>;
  headerDeps: List<Hash>;
  inputs: List<Cell>;
  outputs: List<Cell>;
  witnesses: List<HexString>;
  fixedEntries: List<{ field: string; index: number }>;
  signingEntries: List<{ type: string; index: number; message: string }>;
  inputSinces: ImmutableMap<number, PackedSince>;
}

export type TransactionSkeletonType = Record<TransactionSkeletonInterface> &
  Readonly<TransactionSkeletonInterface>;

export const TransactionSkeleton = Record<TransactionSkeletonInterface>({
  cellProvider: null,
  cellDeps: List(),
  headerDeps: List(),
  inputs: List(),
  outputs: List(),
  witnesses: List(),
  fixedEntries: List(),
  signingEntries: List(),
  inputSinces: ImmutableMap(),
});

export function createTransactionFromSkeleton(
  txSkeleton: TransactionSkeletonType,
  { validate = true }: { validate?: boolean } = {}
): Transaction {
  const tx: Transaction = {
    version: "0x0",
    cell_deps: txSkeleton.get("cellDeps").toArray(),
    header_deps: txSkeleton.get("headerDeps").toArray(),
    inputs: txSkeleton
      .get("inputs")
      .map((input, i) => {
        return {
          since: txSkeleton.get("inputSinces").get(i, "0x0"),
          previous_output: input.out_point!,
        };
      })
      .toArray(),
    outputs: txSkeleton
      .get("outputs")
      .map((output) => output.cell_output)
      .toArray(),
    outputs_data: txSkeleton
      .get("outputs")
      .map((output) => output.data || "0x0")
      .toArray(),
    witnesses: txSkeleton.get("witnesses").toArray(),
  };
  if (validate) {
    validators.ValidateTransaction(tx);
  }
  return tx;
}

export function sealTransaction(
  txSkeleton: TransactionSkeletonType,
  sealingContents: HexString[]
): Transaction {
  const tx = createTransactionFromSkeleton(txSkeleton);
  if (sealingContents.length !== txSkeleton.get("signingEntries").size) {
    throw new Error(
      `Requiring ${
        txSkeleton.get("signingEntries").size
      } sealing contents but provided ${sealingContents.length}!`
    );
  }
  txSkeleton.get("signingEntries").forEach((e, i) => {
    switch (e.type) {
      case "witness_args_lock":
        const witness = tx.witnesses[e.index];
        const witnessArgs = new core.WitnessArgs(new Reader(witness));
        const newWitnessArgs: WitnessArgs = {
          lock: sealingContents[i],
        };
        const inputType = witnessArgs.getInputType();
        if (inputType.hasValue()) {
          newWitnessArgs.input_type = new Reader(
            inputType.value().raw()
          ).serializeJson();
        }
        const outputType = witnessArgs.getOutputType();
        if (outputType.hasValue()) {
          newWitnessArgs.output_type = new Reader(
            outputType.value().raw()
          ).serializeJson();
        }
        validators.ValidateWitnessArgs(newWitnessArgs);
        tx.witnesses[e.index] = new Reader(
          core.SerializeWitnessArgs(
            normalizers.NormalizeWitnessArgs(newWitnessArgs)
          )
        ).serializeJson();
        break;
      default:
        throw new Error(`Invalid signing entry type: ${e.type}`);
    }
  });
  return tx;
}

export interface TransactionSkeletonObject {
  cellProvider: CellProvider | null;
  cellDeps: CellDep[];
  headerDeps: Hash[];
  inputs: Cell[];
  outputs: Cell[];
  witnesses: HexString[];
  fixedEntries: Array<{ field: string; index: number }>;
  signingEntries: Array<{ type: string; index: number; message: string }>;
  inputSinces: Map<number, PackedSince>;
}

/**
 * Convert TransactionSkeleton to js object
 *
 * @param txSkelton
 */
export function transactionSkeletonToObject(
  txSkelton: TransactionSkeletonType
): TransactionSkeletonObject {
  return txSkelton.toJS();
}

/**
 * Convert js object to TransactionSkeleton
 *
 * @param obj
 */
export function objectToTransactionSkeleton(
  obj: TransactionSkeletonObject
): TransactionSkeletonType {
  let inputSinces = ImmutableMap<number, PackedSince>();
  for (const [key, value] of Object.entries(obj.inputSinces)) {
    inputSinces = inputSinces.set(+key, value);
  }
  const txSkeleton = TransactionSkeleton({
    cellProvider: obj.cellProvider,
    cellDeps: List(obj.cellDeps),
    headerDeps: List(obj.headerDeps),
    inputs: List(obj.inputs),
    outputs: List(obj.outputs),
    witnesses: List(obj.witnesses),
    fixedEntries: List(obj.fixedEntries),
    signingEntries: List(obj.signingEntries),
    inputSinces,
  });
  return txSkeleton;
}

'''
'''--- packages/helpers/tests/addresses.ts ---
import { Address, Script } from "@ckb-lumos/base";

interface AddressInfo {
  testnetAddress: Address;
  mainnetAddress: Address;
  script: Script;
}

export const shortAddressInfo: AddressInfo = {
  testnetAddress: "ckt1qyqrdsefa43s6m882pcj53m4gdnj4k440axqswmu83",
  mainnetAddress: "ckb1qyqrdsefa43s6m882pcj53m4gdnj4k440axqdt9rtd",
  script: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "type",
    args: "0x36c329ed630d6ce750712a477543672adab57f4c",
  },
};

export const multisigAddressInfo: AddressInfo = {
  mainnetAddress: "ckb1qyq5lv479ewscx3ms620sv34pgeuz6zagaaqklhtgg",
  testnetAddress: "ckt1qyq5lv479ewscx3ms620sv34pgeuz6zagaaqt6f5y5",
  script: {
    code_hash:
      "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
    hash_type: "type",
    args: "0x4fb2be2e5d0c1a3b8694f832350a33c1685d477a",
  },
};

export const fullAddressInfo: AddressInfo = {
  mainnetAddress:
    "ckb1qsqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpvumhs9nvu786dj9p0q5elx66t24n3kxgmz0sxt",
  testnetAddress:
    "ckt1qsqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpvumhs9nvu786dj9p0q5elx66t24n3kxgkpkap5",
  script: {
    code_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    hash_type: "type",
    args: "0xb39bbc0b3673c7d36450bc14cfcdad2d559c6c64",
  },
};

export const fullAddressInfoWithData: AddressInfo = {
  mainnetAddress:
    "ckb1q2da0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsdkr98kkxrtvuag8z2j8w4pkw2k6k4l5c7jxc4f",
  testnetAddress:
    "ckt1q2da0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsdkr98kkxrtvuag8z2j8w4pkw2k6k4l5cn3l4jk",
  script: {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    hash_type: "data",
    args: "0x36c329ed630d6ce750712a477543672adab57f4c",
  },
};

'''
'''--- packages/helpers/tests/convert_transaction_skeleton.test.ts ---
import test from "ava";
import { List, Record, Map as ImmutableMap } from "immutable";
import {
  objectToTransactionSkeleton,
  transactionSkeletonToObject,
} from "../src";

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("objectToTransactionSkeleton", (t) => {
  const txSkeletonObject = require("./fixtures/tx_skeleton.json");
  const txSkeleton = objectToTransactionSkeleton(txSkeletonObject);

  t.true(txSkeleton instanceof Record);
  t.true(txSkeleton.get("inputSinces") instanceof ImmutableMap);

  const keys = [
    "cellDeps",
    "headerDeps",
    "inputs",
    "outputs",
    "witnesses",
    "fixedEntries",
    "signingEntries",
  ];

  keys.forEach((key) => {
    t.true(txSkeleton.get(key as any) instanceof List);
    t.deepEqual(txSkeleton.get(key as any).toArray(), txSkeletonObject[key]);
  });

  t.deepEqual(
    txSkeleton.get("inputSinces").toJS(),
    txSkeletonObject["inputSinces"]
  );

  t.is(txSkeleton.get("inputSinces").get(0), txSkeletonObject.inputSinces["0"]);
});

test("transactionSkeletonToObject", (t) => {
  const txSkeletonObject = require("./fixtures/tx_skeleton.json");
  const txSkeleton = objectToTransactionSkeleton(txSkeletonObject);

  const obj = transactionSkeletonToObject(txSkeleton);

  const keys = [
    "cellDeps",
    "headerDeps",
    "inputs",
    "outputs",
    "witnesses",
    "fixedEntries",
    "signingEntries",
  ];

  keys.forEach((key) => {
    t.true((obj as any)[key] instanceof Array);
  });

  t.true(obj.inputSinces instanceof Object);
});

'''
'''--- packages/helpers/tests/fixtures/tx_skeleton.json ---
{
  "cellProvider": {
    "cells": []
  },
  "cellDeps": [
    {
      "out_point": {
        "tx_hash": "0x8f8c79eb6671709633fe6a46de93c0fedc9c1b8a6527a18d3983879542635c9f",
        "index": "0x2"
      },
      "dep_type": "code"
    },
    {
      "out_point": {
        "tx_hash": "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
        "index": "0x0"
      },
      "dep_type": "dep_group"
    }
  ],
  "headerDeps": [
    "0x41d081cd95d705c4e80a6b473f71050efc4a0a0057ee8cab98c4933ad11f0719",
    "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906"
  ],
  "inputs": [
    {
      "cell_output": {
        "capacity": "0x174876e800",
        "lock": {
          "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          "hash_type": "type",
          "args": "0x36c329ed630d6ce750712a477543672adab57f4c"
        },
        "type": {
          "code_hash": "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
          "hash_type": "type",
          "args": "0x"
        }
      },
      "data": "0x4992010000000000",
      "out_point": {
        "tx_hash": "0x48cfb73ccd70be0cbfbd1abd7ecf316acbd3e1710db581bf4b8c2d724efdae7f",
        "index": "0x0"
      },
      "block_hash": "0x156ecda80550b6664e5d745b6277c0ae56009681389dcc8f1565d815633ae906",
      "block_number": "0x1"
    }
  ],
  "outputs": [
    {
      "cell_output": {
        "capacity": "0x1748ec3fdc",
        "lock": {
          "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
          "hash_type": "type",
          "args": "0x36c329ed630d6ce750712a477543672adab57f4c"
        }
      },
      "data": "0x"
    }
  ],
  "witnesses": [
    "0x61000000100000005500000061000000410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000"
  ],
  "fixedEntries": [
    {
      "field": "inputs",
      "index": 0
    },
    {
      "field": "outputs",
      "index": 0
    },
    {
      "field": "witnesses",
      "index": 0
    },
    {
      "field": "headerDeps",
      "index": 0
    }
  ],
  "signingEntries": [
    {
      "type": "witness_args_lock",
      "index": 0,
      "message": "0xf276a45b7dbc018c2e10c4cd0a61915dd28db768894efc1b2c557c9566fc43fd"
    }
  ],
  "inputSinces": {
    "0": "0x20000a00050028ee"
  }
}

'''
'''--- packages/helpers/tests/generate_address.test.ts ---
import test from "ava";
import {
  generateAddress,
  generateSecp256k1Blake160Address,
  generateSecp256k1Blake160MultisigAddress,
  scriptToAddress,
} from "../src";
import { predefined } from "@ckb-lumos/config-manager";
const { LINA, AGGRON4 } = predefined;
import {
  shortAddressInfo,
  multisigAddressInfo,
  fullAddressInfo,
} from "./addresses";

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("short address, mainnet", (t) => {
  const address = generateAddress(shortAddressInfo.script, { config: LINA });

  t.is(address, shortAddressInfo.mainnetAddress);
});

test("short address, testnet", (t) => {
  const address = generateAddress(shortAddressInfo.script, { config: AGGRON4 });

  t.is(address, shortAddressInfo.testnetAddress);
});

test("multisig short address, mainnet", (t) => {
  const address = generateAddress(multisigAddressInfo.script, {
    config: LINA,
  });

  t.is(address, multisigAddressInfo.mainnetAddress);
});

test("multisig short address, testnet", (t) => {
  const address = generateAddress(multisigAddressInfo.script, {
    config: AGGRON4,
  });

  t.is(address, multisigAddressInfo.testnetAddress);
});

test("full address, mainnet", (t) => {
  const address = generateAddress(fullAddressInfo.script, {
    config: LINA,
  });

  t.is(address, fullAddressInfo.mainnetAddress);
});

test("full address, testnet", (t) => {
  const address = generateAddress(fullAddressInfo.script, {
    config: AGGRON4,
  });

  t.is(address, fullAddressInfo.testnetAddress);
});

test("short address, mainnet, scriptToAddress", (t) => {
  const address = scriptToAddress(shortAddressInfo.script, { config: LINA });

  t.is(address, shortAddressInfo.mainnetAddress);
});

test("generateSecp256k1Blake160Address, testnet", (t) => {
  const address = generateSecp256k1Blake160Address(
    shortAddressInfo.script.args,
    { config: AGGRON4 }
  );

  t.is(address, shortAddressInfo.testnetAddress);
});

test("generateSecp256k1Blake160Address, mainnet", (t) => {
  const address = generateSecp256k1Blake160Address(
    shortAddressInfo.script.args,
    { config: LINA }
  );

  t.is(address, shortAddressInfo.mainnetAddress);
});

test("generateSecp256k1Blake160MultisigAddress, testnet", (t) => {
  const address = generateSecp256k1Blake160MultisigAddress(
    multisigAddressInfo.script.args,
    { config: AGGRON4 }
  );

  t.is(address, multisigAddressInfo.testnetAddress);
});

test("generateSecp256k1Blake160MultisigAddress, mainnet", (t) => {
  const address = generateSecp256k1Blake160MultisigAddress(
    multisigAddressInfo.script.args,
    { config: LINA }
  );

  t.is(address, multisigAddressInfo.mainnetAddress);
});

'''
'''--- packages/helpers/tests/minimal_cell_capacity-bigint.test.ts ---
import test from "ava";
import { Cell } from "@ckb-lumos/base";
import { minimalCellCapacity } from "../src";

const normalCell: Cell = {
  cell_output: {
    capacity: "0x174876e800",
    lock: {
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
    },
    type: undefined,
  },
  data: "0x",
  block_hash: undefined,
  block_number: undefined,
  out_point: undefined,
};

const cellWithTypeAndData: Cell = {
  cell_output: {
    capacity: "0x174876e800",
    lock: {
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
    },
    type: {
      code_hash:
        "0x9e3b3557f11b2b3532ce352bfe8017e9fd11d154c4c7f9b7aaaa1e621b539a08",
      hash_type: "type",
      args: "0x",
    },
  },
  data: "0x1234",
  block_hash: undefined,
  block_number: undefined,
  out_point: undefined,
};

test("BigInt:normal cell, validate true", (t) => {
  const capacity = minimalCellCapacity(normalCell);
  const expectedCapacity = BigInt(61 * 10 ** 8);

  t.true(capacity === expectedCapacity);
});

test("BigInt:cell with type and data, validate true", (t) => {
  const capacity = minimalCellCapacity(cellWithTypeAndData);
  const expectedCapacity = BigInt((61 + 33 + 2) * 10 ** 8);

  t.true(capacity === expectedCapacity);
});

'''
'''--- packages/helpers/tests/minimal_cell_capacity.test.ts ---
import test from "ava";
import { Cell } from "@ckb-lumos/base";
import { minimalCellCapacity, minimalCellCapacityCompatible } from "../src";
import { BI } from "@ckb-lumos/bi";

const normalCell: Cell = {
  cell_output: {
    capacity: "0x174876e800",
    lock: {
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
    },
    type: undefined,
  },
  data: "0x",
  block_hash: undefined,
  block_number: undefined,
  out_point: undefined,
};

const invalidCell = {
  cell_output: {
    capacity: "0x174876e800",
    lock: {
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "typ",
    },
    type: undefined,
  },
  data: "0x",
  block_hash: undefined,
  block_number: undefined,
  out_point: undefined,
};

const cellWithTypeAndData: Cell = {
  cell_output: {
    capacity: "0x174876e800",
    lock: {
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
    },
    type: {
      code_hash:
        "0x9e3b3557f11b2b3532ce352bfe8017e9fd11d154c4c7f9b7aaaa1e621b539a08",
      hash_type: "type",
      args: "0x",
    },
  },
  data: "0x1234",
  block_hash: undefined,
  block_number: undefined,
  out_point: undefined,
};

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("normal cell, validate true", (t) => {
  const capacity = minimalCellCapacityCompatible(normalCell);
  const expectedCapacity = BI.from(61).mul(BI.from(10).pow(8));
  t.true(capacity.toString() === expectedCapacity.toString());
});

test("normal cell, validate failed", (t) => {
  t.throws(() => {
    minimalCellCapacity(invalidCell as any);
  });
});

test("cell with type and data, validate true", (t) => {
  const capacity = minimalCellCapacityCompatible(cellWithTypeAndData);
  const expectedCapacity = BI.from(61 + 33 + 2).mul(BI.from(10).pow(8));
  t.true(capacity.toString() === expectedCapacity.toString());
});

'''
'''--- packages/helpers/tests/parse_address.test.ts ---
import test from "ava";
import { parseAddress, addressToScript } from "../src";
import {
  shortAddressInfo,
  multisigAddressInfo,
  fullAddressInfo,
} from "./addresses";
import { predefined } from "@ckb-lumos/config-manager";
const { LINA, AGGRON4 } = predefined;

test.before(() => {
  // @ts-ignore: Unreachable code error
  BigInt = () => {
    throw new Error("can not find bigint");
  };
});

test("short address, mainnet", (t) => {
  const script = parseAddress(shortAddressInfo.mainnetAddress, {
    config: LINA,
  });

  t.deepEqual(script, shortAddressInfo.script);
});

test("short address, testnet", (t) => {
  const script = parseAddress(shortAddressInfo.testnetAddress, {
    config: AGGRON4,
  });

  t.deepEqual(script, shortAddressInfo.script);
});

test("short address, config not match address version", (t) => {
  t.throws(() => {
    parseAddress(shortAddressInfo.testnetAddress, { config: LINA });
  });
});

test("multisig address, mainnet", (t) => {
  const script = parseAddress(multisigAddressInfo.mainnetAddress);

  t.deepEqual(script, multisigAddressInfo.script);
});

test("multisig address, testnet", (t) => {
  const script = parseAddress(multisigAddressInfo.testnetAddress, {
    config: AGGRON4,
  });

  t.deepEqual(script, multisigAddressInfo.script);
});

test("full address, mainnet", (t) => {
  const script = parseAddress(fullAddressInfo.mainnetAddress);

  t.deepEqual(script, fullAddressInfo.script);
});

test("full address, testnet", (t) => {
  const script = parseAddress(fullAddressInfo.testnetAddress, {
    config: AGGRON4,
  });

  t.deepEqual(script, fullAddressInfo.script);
});

test("short address, mainnet, addressToScript", (t) => {
  const script = addressToScript(shortAddressInfo.mainnetAddress, {
    config: LINA,
  });

  t.deepEqual(script, shortAddressInfo.script);
});

'''
'''--- packages/helpers/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src"]
}

'''
'''--- packages/lumos/README.md ---
# @ckb-lumos/lumos

A root package to integrate of common functions from the Lumos sub-package

'''
'''--- packages/lumos/package.json ---
{
  "name": "@ckb-lumos/lumos",
  "version": "0.17.0-rc8",
  "description": "A root package for Lumos",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "browser": "lib/lumos.min.js",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "src"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests}/**/*.ts\"",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "build:umd": "webpack",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build && yarn run build:umd",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "@ckb-lumos/ckb-indexer": "^0.17.0-rc8",
    "@ckb-lumos/common-scripts": "^0.17.0-rc8",
    "@ckb-lumos/config-manager": "^0.17.0-rc8",
    "@ckb-lumos/hd": "^0.17.0-rc8",
    "@ckb-lumos/helpers": "^0.17.0-rc8",
    "@ckb-lumos/rpc": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8"
  },
  "devDependencies": {
    "buffer": "^6.0.3",
    "crypto-browserify": "^3.12.0",
    "fork-ts-checker-webpack-plugin": "^6.4.0",
    "ts-loader": "^9.2.6",
    "unminified-webpack-plugin": "^3.0.0",
    "webpack": "^5.64.1",
    "webpack-cli": "^4.9.1"
  }
}

'''
'''--- packages/lumos/src/index.ts ---
import {
  Reader,
  validators,
  normalizers,
  transformers,
} from "@ckb-lumos/toolkit";

export const toolkit = { Reader, validators, normalizers, transformers };

export type {
  Cell,
  RawTransaction,
  Transaction,
  OutPoint,
  CellDep,
  WitnessArgs,
  Header,
  Block,
  HashType,
  DepType,
  Input,
  Output,
  Script,
} from "@ckb-lumos/base/lib/api";

export type {
  Address,
  Hash,
  HexNumber,
  HexString,
  Hexadecimal,
  HexadecimalRange,
  PackedDao,
  PackedSince,
} from "@ckb-lumos/base/lib/primitive";

export { core, since, utils } from "@ckb-lumos/base";
export * as config from "@ckb-lumos/config-manager";

export { RPC } from "@ckb-lumos/rpc";
export * as hd from "@ckb-lumos/hd";
export { Indexer, CellCollector } from "@ckb-lumos/ckb-indexer";
export * as helpers from "@ckb-lumos/helpers";
export * as commons from "@ckb-lumos/common-scripts";
export { BI } from "@ckb-lumos/bi";

'''
'''--- packages/lumos/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib",
    "rootDir": "src"
  },
  "include": ["src"]
}

'''
'''--- packages/lumos/webpack.config.js ---
const path = require("path");
const webpack = require("webpack");
const ForkTsCheckerWebpackPlugin = require("fork-ts-checker-webpack-plugin");
const UnminifiedWebpackPlugin = require("unminified-webpack-plugin");

module.exports = {
  mode: "production",
  devtool: "source-map",
  entry: {
    output: "./src/index.ts",
  },
  output: {
    path: path.join(__dirname, "lib"),
    filename: "lumos.min.js",
    library: "lumos",
    libraryTarget: "umd",
    globalObject: "this",
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        loader: "ts-loader",
        options: {
          transpileOnly: true,
        },
      },
    ],
  },
  resolve: {
    extensions: [".ts", ".js", ".json"],
    fallback: {
      // https://www.npmjs.com/package/buffer#usage
      buffer: require.resolve("buffer/"),
      crypto: require.resolve("crypto-browserify"),
      path: false,
      fs: false,
      stream: false,
    },
  },
  plugins: [
    new ForkTsCheckerWebpackPlugin({ async: false }),
    new webpack.ProvidePlugin({ Buffer: ["buffer", "Buffer"] }),
    new UnminifiedWebpackPlugin(),
  ],
};

'''
'''--- packages/rpc/README.md ---
# `@ckb-lumos/rpc`

RPC module for lumos. Provide type definitions for CKB RPC interface.

## Usage

```javascript
import { RPC } from "@ckb-lumos/rpc"
const rpc = new RPC("http://localhost:8114");
await rpc.get_tip_header();

// Or provide an optional indexer param, if provided, will wait for sync after every RPC call.
const rpc = new RPC("http://localhost:8114", indexer)
await rpc.get_tip_header(); // before it return, will sync indexer to tip.
```

'''
'''--- packages/rpc/package.json ---
{
  "name": "@ckb-lumos/rpc",
  "version": "0.17.0-rc8",
  "description": "RPC module for CKB",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "src"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{src,tests}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests}/**/*.ts\"",
    "test": "echo \"No tests yet!\"",
    "build": "npm run build:types && npm run build:js",
    "build:types": "tsc --declaration --emitDeclarationOnly",
    "build:js": "babel --root-mode upward src --out-dir lib --extensions .ts -s",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/bi": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  }
}

'''
'''--- packages/rpc/src/index.ts ---
import { RPC as ToolkitRPC } from "@ckb-lumos/toolkit";
import {
  Alert,
  BannedAddr,
  Block,
  BlockEconomicState,
  CellWithStatus,
  ChainInfo,
  Consensus,
  DryRunResult,
  Epoch,
  Hash,
  Header,
  HexNumber,
  HexString,
  Indexer,
  LocalNode,
  OutPoint,
  RawTxPool,
  RemoteNode,
  SyncState,
  Transaction,
  TransactionProof,
  TransactionWithStatus,
  TxPoolIds,
  TxPoolInfo,
  TxPoolVerbosity,
} from "@ckb-lumos/base";
import { BI } from "@ckb-lumos/bi";

export type SerializedBlock = HexString;
export type SerializedHeader = HexString;
export type OutputsValidator = "default" | "passthrough";

function asyncSleep(ms = 0) {
  return new Promise((r) => setTimeout(r, ms));
}

const handler = {
  get: (target: any, method: string) => {
    return async (...params: any) => {
      const result = await target.rpc[method](...params);
      if (target.indexer) {
        await target.waitForBlockSync();
      }
      return result;
    };
  },
};

class RpcProxy {
  private rpc: ToolkitRPC;
  private indexer: Indexer | undefined;
  private waitForSyncCheckIntervalSeconds: number;
  private blockDifference: number;

  constructor(
    uri: string,
    indexer?: Indexer,
    {
      waitForSyncCheckIntervalSeconds = 1,
      blockDifference = 3,
      rpcOptions = {},
    }: {
      waitForSyncCheckIntervalSeconds?: number;
      blockDifference?: number;
      rpcOptions?: object;
    } = {}
  ) {
    this.rpc = new ToolkitRPC(uri, rpcOptions);
    this.indexer = indexer;
    this.waitForSyncCheckIntervalSeconds = waitForSyncCheckIntervalSeconds;
    this.blockDifference = blockDifference;
  }

  resetIndexer(indexer?: Indexer): void {
    this.indexer = indexer;
  }

  getProxy() {
    return new Proxy(this, handler);
  }

  async waitForBlockSync() {
    if (!this.indexer) {
      return;
    }
    const header: Header = await this.rpc.get_tip_header();
    const blockNumber = BI.from(header.number);
    while (true) {
      const tip = await this.indexer.tip();
      if (tip) {
        if (blockNumber.sub(tip.block_number).lte(this.blockDifference)) {
          // TODO: do we need to handle forks?
          break;
        }
      }
      await asyncSleep(this.waitForSyncCheckIntervalSeconds * 1000);
    }
  }
}

export class RPC {
  private rpcProxy: any;

  /**
   *
   * @param uri
   * @param indexer Will `waitForSync` after rpc call if provided.
   * @param options
   */
  constructor(
    uri: string,
    indexer?: Indexer,
    {
      waitForSyncCheckIntervalSeconds = 1,
      blockDifference = 3,
      rpcOptions = {},
    }: {
      waitForSyncCheckIntervalSeconds?: number;
      blockDifference?: number;
      rpcOptions?: object;
    } = {}
  ) {
    this.rpcProxy = new RpcProxy(uri, indexer, {
      waitForSyncCheckIntervalSeconds,
      blockDifference,
      rpcOptions,
    }).getProxy();
  }

  /**
   *
   * @param indexer If not provided or be undefined, will disable `waitForSync`, and if provided, will enable `waitForSync` with provided indexer.
   */
  resetIndexer(indexer?: Indexer): void {
    this.rpcProxy.resetIndexer(indexer);
  }

  // Module Chain

  async get_block(
    block_hash: Hash,
    verbosity: "0x0"
  ): Promise<SerializedBlock | null>;
  async get_block(block_hash: Hash, verbosity?: "0x2"): Promise<Block | null>;
  async get_block(
    block_hash: Hash,
    verbosity?: HexNumber
  ): Promise<Block | SerializedBlock | null> {
    return this.rpcProxy.get_block(block_hash, verbosity || null);
  }

  async get_block_by_number(
    block_number: HexNumber,
    verbosity: "0x0"
  ): Promise<SerializedBlock | null>;
  async get_block_by_number(
    block_number: HexNumber,
    verbosity?: "0x2"
  ): Promise<Block | null>;
  async get_block_by_number(
    block_number: HexNumber,
    verbosity?: HexNumber
  ): Promise<Block | SerializedBlock | null> {
    return this.rpcProxy.get_block_by_number(block_number, verbosity || null);
  }

  async get_header(
    block_hash: Hash,
    verbosity: "0x0"
  ): Promise<SerializedHeader | null>;
  async get_header(block_hash: Hash, verbosity?: "0x1"): Promise<Header | null>;
  async get_header(
    block_hash: Hash,
    verbosity?: HexNumber
  ): Promise<Header | SerializedHeader | null> {
    return this.rpcProxy.get_header(block_hash, verbosity || null);
  }

  async get_header_by_number(
    block_number: HexNumber,
    verbosity: "0x0"
  ): Promise<SerializedHeader | null>;
  async get_header_by_number(
    block_number: HexNumber,
    verbosity?: "0x1"
  ): Promise<Header | null>;
  async get_header_by_number(
    block_number: HexNumber,
    verbosity?: HexNumber
  ): Promise<Header | SerializedHeader | null> {
    return this.rpcProxy.get_header_by_number(block_number, verbosity || null);
  }

  async get_transaction(hash: Hash): Promise<TransactionWithStatus | null> {
    return this.rpcProxy.get_transaction(hash);
  }

  async get_block_hash(block_number: HexNumber): Promise<Hash | null> {
    return this.rpcProxy.get_block_hash(block_number);
  }

  async get_tip_header(verbosity: "0x0"): Promise<SerializedHeader>;
  async get_tip_header(verbosity?: "0x1"): Promise<Header>;
  async get_tip_header(
    verbosity?: HexNumber
  ): Promise<Header | SerializedHeader> {
    return this.rpcProxy.get_tip_header(verbosity);
  }

  async get_live_cell(
    out_point: OutPoint,
    with_data: boolean
  ): Promise<CellWithStatus> {
    return this.rpcProxy.get_live_cell(out_point, with_data);
  }

  async get_tip_block_number(): Promise<HexNumber> {
    return this.rpcProxy.get_tip_block_number();
  }

  async get_current_epoch(): Promise<Epoch> {
    return this.rpcProxy.get_current_epoch();
  }

  async get_epoch_by_number(epoch_number: HexNumber): Promise<Epoch | null> {
    return this.rpcProxy.get_epoch_by_number(epoch_number);
  }

  async get_block_economic_state(
    block_hash: Hash
  ): Promise<BlockEconomicState | null> {
    return this.rpcProxy.get_block_economic_state(block_hash);
  }

  async get_transaction_proof(
    tx_hashes: Hash[],
    block_hash?: Hash
  ): Promise<TransactionProof> {
    return this.rpcProxy.get_transaction_proof(tx_hashes, block_hash || null);
  }

  async verify_transaction_proof(tx_proof: TransactionProof): Promise<Hash[]> {
    return this.rpcProxy.verify_transaction_proof(tx_proof);
  }

  async get_fork_block(
    block_hash: Hash,
    verbosity: "0x0"
  ): Promise<SerializedBlock | null>;
  async get_fork_block(
    block_hash: Hash,
    verbosity?: "0x2"
  ): Promise<Block | null>;
  async get_fork_block(
    block_hash: Hash,
    verbosity?: HexNumber
  ): Promise<Block | SerializedBlock | null> {
    return this.rpcProxy.get_fork_block(
      block_hash,
      verbosity ? verbosity : null
    );
  }

  async get_consensus(): Promise<Consensus> {
    return this.rpcProxy.get_consensus();
  }

  // Module Experiment

  async dry_run_transaction(tx: Transaction): Promise<DryRunResult> {
    return this.rpcProxy.dry_run_transaction(tx);
  }

  async calculate_dao_maximum_withdraw(
    out_point: OutPoint,
    block_hash: Hash
  ): Promise<HexNumber> {
    return this.rpcProxy.calculate_dao_maximum_withdraw(out_point, block_hash);
  }

  // Module Net

  async local_node_info(): Promise<LocalNode> {
    return this.rpcProxy.local_node_info();
  }

  async get_peers(): Promise<RemoteNode[]> {
    return this.rpcProxy.get_peers();
  }

  async get_banned_addresses(): Promise<BannedAddr> {
    return this.rpcProxy.get_banned_addresses();
  }

  async clear_banned_addresses(): Promise<null> {
    return this.rpcProxy.clear_banned_addresses();
  }

  async set_ban(
    address: string,
    command: string,
    ban_time?: HexNumber,
    absolute?: boolean,
    reason?: string
  ): Promise<null> {
    return this.rpcProxy.set_ban(
      address,
      command,
      ban_time || null,
      absolute !== undefined ? absolute : null,
      reason || null
    );
  }

  async sync_state(): Promise<SyncState> {
    return this.rpcProxy.sync_state();
  }

  async set_network_active(state: boolean): Promise<null> {
    return this.rpcProxy.set_network_active(state);
  }

  async add_node(peer_id: string, address: string): Promise<null> {
    return this.rpcProxy.add_node(peer_id, address);
  }

  async remove_node(peer_id: string): Promise<null> {
    return this.rpcProxy.remove_node(peer_id);
  }

  async ping_peers(): Promise<null> {
    return this.rpcProxy.ping_peers();
  }

  // Module pool

  async send_transaction(
    tx: Transaction,
    outputs_validator?: OutputsValidator
  ): Promise<Hash> {
    return this.rpcProxy.send_transaction(tx, outputs_validator || null);
  }

  async tx_pool_info(): Promise<TxPoolInfo> {
    return this.rpcProxy.tx_pool_info();
  }

  async clear_tx_pool(): Promise<null> {
    return this.rpcProxy.clear_tx_pool();
  }

  async get_raw_tx_pool(verbose?: false): Promise<TxPoolIds>;
  async get_raw_tx_pool(verbose: true): Promise<TxPoolVerbosity>;
  async get_raw_tx_pool(verbose?: boolean): Promise<RawTxPool> {
    return this.rpcProxy.get_raw_tx_pool(
      verbose !== undefined ? verbose : null
    );
  }

  // Module Stats

  async get_blockchain_info(): Promise<ChainInfo> {
    return this.rpcProxy.get_blockchain_info();
  }

  // Module Alert

  async send_alert(alert: Alert): Promise<null> {
    return this.rpcProxy.send_alert(alert);
  }

  // Module Miner
}

'''
'''--- packages/rpc/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src"]
}

'''
'''--- packages/testkit/README.md ---
# `@ckb-lumos/base`

Test toolkit for testing CKB dApps

## Work With CKB Indexer

Starting a CKB mock rpc

```
$ ts-node packages/testkit/example-ckb-nodes.ts
server listen to 8118
```

And then launching a CKB indexer sync block data from the mock server

```
ckb-indexer -c http://127.0.0.1:8118/rpc -l 127.0.0.1:8116 -s indexer-store-tmp
```

'''
'''--- packages/testkit/example/mock-ckb-node.ts ---
import { createCKBMockRPC, mockData } from "../src";
import fs from "fs";
import path from "path";

const server = createCKBMockRPC({
  blocks: JSON.parse(
    fs
      .readFileSync(
        path.join(__dirname, "../../ckb-indexer/tests/blocks_data.json")
      )
      .toString()
  ),
  localNode: mockData.localNode(),
});

server.listen(8118, function () {
  console.log("🚀 server listen to 8118");
});

'''
'''--- packages/testkit/package.json ---
{
  "name": "@ckb-lumos/testkit",
  "version": "0.17.0-rc8",
  "private": true,
  "description": "Test toolkit for CKB",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib"
  ],
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8",
    "@types/body-parser": "^1.19.1",
    "@types/express": "^4.17.13",
    "body-parser": "^1.19.0",
    "express": "^4.17.1",
    "json-rpc-2.0": "^0.2.19",
    "ts-node": "^10.4.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "start": "ts-node example/mock-ckb-node.ts",
    "fmt": "prettier --write \"{src,tests,example}/**/*.ts\" package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests,example}/**/*.ts\"",
    "clean": "rm -rf lib",
    "prepublishOnly": "yarn run clean && yarn run build",
    "release": "npm publish"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "ava": {
    "extensions": [
      "ts"
    ],
    "require": [
      "ts-node/register"
    ]
  }
}

'''
'''--- packages/testkit/src/index.ts ---
export { createCKBMockRPC } from "./mock-ckb-jsonrpc";
export * as mockData from "./mock-data";

'''
'''--- packages/testkit/src/mock-ckb-jsonrpc.ts ---
import { JSONRPCResponse, JSONRPCServer } from "json-rpc-2.0";
import express, { Express } from "express";
import bodyParser from "body-parser";
import { LocalNode, Block, core } from "@ckb-lumos/base";
import { normalizers, Reader } from "@ckb-lumos/toolkit";

interface Options {
  blocks: Block[];
  localNode: LocalNode;
  // defaults to /rpc
  routePath?: string;
}

function assertsParams(param: unknown): asserts param {
  if (!param) throw new Error("Invalid params");
}

export function createCKBMockRPC(options: Options): Express {
  const { routePath = "/rpc", blocks, localNode } = options;

  const server = new JSONRPCServer();

  server.addMethod("local_node_info", () => localNode);
  server.addMethod("get_block_by_number", (params) => {
    assertsParams(Array.isArray(params));

    const blockNumber = params[0];
    const verbosity = params[1] || "0x2";
    assertsParams(
      typeof blockNumber === "string" && !isNaN(Number(blockNumber))
    );

    const block = blocks.find(
      (block) => Number(block.header.number) === Number(blockNumber)
    );
    if (!block) return null;

    if (Number(verbosity) === 0)
      return new Reader(
        core.SerializeBlock(normalizers.NormalizeBlock(block))
      ).serializeJson();
    return block;
  });

  server.addMethod("get_block_hash", (blockNumbers) => {
    assertsParams(Array.isArray(blockNumbers));
    const blockNumber = blockNumbers[0];
    assertsParams(
      typeof blockNumber === "string" && !isNaN(Number(blockNumber))
    );

    const block = blocks.find(
      (block) => Number(block.header.number) === Number(blockNumber)
    );
    if (!block) return null;

    return block.header.hash;
  });

  server.addMethod("get_tip_block_number", () => {
    if (blocks.length < 1) {
      return null;
    }
    return blocks[blocks.length - 1].header.number;
  });

  server.addMethod("get_transaction", (hashes) => {
    assertsParams(Array.isArray(hashes));
    const hash = hashes[0];
    let result;
    let blockHash;
    for (let block of blocks) {
      const tx = block.transactions.find((tx) => tx.hash === hash);
      if (tx) {
        result = tx;
        blockHash = block.header.hash;
        break;
      }
    }
    return {
      transaction: result,
      tx_status: { status: "padding", block_hash: blockHash },
    };
  });

  server.addMethod("get_blockchain_info", () => {
    return {
      alerts: [],
      chain: "ckb_testnet",
      difficulty: "0x1b6f506b",
      epoch: "0x708069a000cc5",
      is_initial_block_download: false,
      median_time: "0x17d3723d27d",
    };
  });

  const app = express();
  app.use(bodyParser.json());

  app.post(routePath, (req, res) => {
    const jsonRPCRequest = req.body;
    if (Array.isArray(jsonRPCRequest)) {
      const responseList: (JSONRPCResponse | null)[] = [];
      jsonRPCRequest.forEach((request) => {
        server.receive(request).then((response) => {
          responseList.push(response);
          if (responseList.length === jsonRPCRequest.length) {
            res.json(responseList);
          }
        });
      });
    } else {
      server.receive(jsonRPCRequest).then((jsonRPCResponse) => {
        if (jsonRPCResponse) {
          res.json(jsonRPCResponse);
        } else {
          res.sendStatus(204);
        }
      });
    }
  });

  return app;
}

'''
'''--- packages/testkit/src/mock-data.ts ---
import { LocalNode } from "@ckb-lumos/base";

export function localNode(info?: Partial<LocalNode>): LocalNode {
  return Object.assign(
    {},
    {
      active: true,
      addresses: [
        {
          address: "/ip4/0.0.0.0/tcp/8115",
          score: "0x1",
        },
      ],
      connections: "0x0",
      node_id: "QmVhtdYKJ7Na3Xmynmm1xA7ZTh41FJmYrQm8Uk88S8iqJp",
      protocols: [
        {
          id: "0x64",
          name: "/ckb/syn",
          support_versions: ["1"],
        },
        {
          id: "0x65",
          name: "/ckb/rel",
          support_versions: ["1"],
        },
        {
          id: "0x66",
          name: "/ckb/tim",
          support_versions: ["1"],
        },
        {
          id: "0x6e",
          name: "/ckb/alt",
          support_versions: ["1"],
        },
        {
          id: "0x3",
          name: "/ckb/flr",
          support_versions: ["0.0.1"],
        },
        {
          id: "0x4",
          name: "/ckb/disconnectmsg",
          support_versions: ["0.0.1"],
        },
        {
          id: "0x0",
          name: "/ckb/ping",
          support_versions: ["0.0.1"],
        },
        {
          id: "0x1",
          name: "/ckb/discovery",
          support_versions: ["0.0.1"],
        },
        {
          id: "0x2",
          name: "/ckb/identify",
          support_versions: ["0.0.1"],
        },
      ],
      version: "0.42.0 (bb888fe 2021-05-26)",
    },
    info
  );
}

'''
'''--- packages/testkit/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src"]
}

'''
'''--- packages/toolkit/README.md ---
ckb-js-toolkit
==============

JavaScript toolkit for Nervos CKB. It contains a series of independent tools that can aid develoment of CKB dapps. This is different from a normal CKB SDK, since it tries to minimize the work done in an SDK, while providing more utlities that could be handy.

# Design Goals

The toolkit here is built with specific design goals, if some of the design feels quirky to you, you might want to revisit this section to see if there is some tradeoff involved.

## Version Stability

One design goal here is the stability of the toolkit, meaning the toolkit version you use can stay unchanged unless one of the following conditions is met:

* A security vulnerability occurs
* A fork happens in CKB

## Code Compatibility

In the meantime, we also want to ensure code compatibility: we might upgrade the toolkit from time to time with new features. But when you are upgrading the toolkit version, you shouldn't expect any code breaks. Sometimes this might be infeasible, such as when security bugs or forks happen, but for the vast majority of the changes, we do want to ensure code compatibility at all costs.

And before you ask, personally I don't trust in [Semantic Versioning](https://semver.org/). I do want to ensure code compatibility with all my efforts regardless of the specific part changed in the version number.

## Runtime type checking

This might be a controversial one: with the whole JavaScript world moving into static typed languages such as TypeScript, ReasonML, etc. I'm building the toolkit here with plain JavaScript doing runtime type checking. This is because none of existing static typed languages in the JavaScript world provide decent type checking stories when you are calling the code from JavaScript. I've seen too many times that a piece of code runs `JSON.parse` on some user input data, then cast the resulting object directly to a TypeScript object, ignoring all the interface checks. If all you use in TypeScript in your project, that won't be a problem, but for a CKB Toolkit built for JavaScript, not TypeScript, nor ReasonML. I want to consider the case that some people would want to use JavaScript directly to call the code in the toolkit. That's why I'm opting for pure JavaScript in this project with runtime checking code. Speed is not much of a concern here, security is a huge concern.

In the future we might certainly provide TypeScript typing files(and maybe also ReasonML definition files), but that is just a different metric. Runtime type checking is still a critical aspect in this project.

# Table Of Contents

* [RPC](#rpc)
* [Reader](#reader)
* [Utility Functions](#utility-functions)
    + [Validators](#validators)
    + [Transformers](#transformers)
    + [Normalizers](#normalizers)
* [Cell Collectors](#cell-collectors)

# RPC

RPC class provides a way to make RPC calls directly to CKB. It works by utilizing [Proxy object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) so the toolkit can cope with new RPCs naturally in CKB. This is an example of `Code Compatibility` design goal.

```
node --experimental-repl-await
Welcome to Node.js v13.9.0.
Type ".help" for more information.
> const toolkit = require("ckb-js-toolkit")
> const rpc = new toolkit.RPC("http://127.0.0.1:9115/rpc")
> await rpc.get_blockchain_info()
{
  alerts: [],
  chain: 'ckb',
  difficulty: '0x5bb23548f6795',
  epoch: '0x708047900028b',
  is_initial_block_download: true,
  median_time: '0x170aee25ea5'
}
> await rpc.get_tip_header()
{
  compact_target: '0x1a2cab56',
  dao: '0x1a7930d4812eeb308acafdfe3cf1230088a770976aef78000032f12fbd5f0107',
  epoch: '0x708047900028b',
  hash: '0x1d0c693d8a78c9e2294ac7304934c635d7b65274fcdf46d5ce3d13ed66768cfd',
  nonce: '0xe2b8ce400000000000000194cf350200',
  number: '0xfcaf2',
  parent_hash: '0x9cf27f050122efb35c362d105d980062d8ea29a8e0f86ec6a4ea06178a5a0381',
  proposals_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  timestamp: '0x170aee486ee',
  transactions_root: '0x16c74b3272430f1a89bb2fca39a571bf7a1bffecb314de528b6cbe9ba0f5d280',
  uncles_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  version: '0x0'
}
> await rpc.get_header_by_number("0x12")
{
  compact_target: '0x1a08a97e',
  dao: '0x18a6312eb520a12e8e552ee0f286230026c8799e8500000000bc29f1c9fefe06',
  epoch: '0x6cf0012000000',
  hash: '0xbc00f447149004a38a8f7347dcd0a2050a2f10f4b926325d797c0f3e0d10f99b',
  nonce: '0x93317ca10000055400000000ba7e0100',
  number: '0x12',
  parent_hash: '0x4a191e12132587e852ddc30c73008426da6322a7def06ee153682afdceab16e7',
  proposals_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  timestamp: '0x16e71002eff',
  transactions_root: '0xcc05a6b1fc20464d4f07a40611f2cab00618ff66cc271ccee9a9fe5b4ea96a45',
  uncles_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  version: '0x0'
}
```

Please refer to [CKB's RPC documentation](https://github.com/nervosnetwork/ckb/tree/develop/rpc) for more details on different RPCs. All values accepted by the RPC module has to be JSON ready values(such as hex strings or objects) following CKB's JSONRPC formatting rules. See [Validators](#validators) and [Transformers](#transformers) sections below on how the toolkit can aid the conversion work.

# Reader

Reader class serves a unique purpose: depending on sources of data, we might get values in different formats:

* Hex string might be provided in CKB RPC responses
* ArrayBuffer might be provided by CKB syscalls
* Raw string might also be used for coding convenience

One big question, is how we can manage all those different data formats? How can we ensure we can convert them to the correct hex format beforing sending them to CKB's RPC? Reader class serves this purpose:

```
node --experimental-repl-await
Welcome to Node.js v13.9.0.
Type ".help" for more information.
> const toolkit = require("ckb-js-toolkit");
undefined
> const { Reader } = toolkit;
undefined
> const reader1 = new Reader("0x31323334")
undefined
> const arraybuffer = new ArrayBuffer(4)
undefined
> const view = new DataView(arraybuffer)
undefined
> view.setUint8(0, 0x31)
undefined
> view.setUint8(1, 0x32)
undefined
> view.setUint8(2, 0x33)
undefined
> view.setUint8(3, 0x34)
undefined
> const reader2 = new Reader(arraybuffer)
undefined
> const reader3 = Reader.fromRawString("1234")
undefined
> reader1.serializeJson()
'0x31323334'
> reader2.serializeJson()
'0x31323334'
> reader3.serializeJson()
'0x31323334'
```

Here we are setting `reader1`, `reader2` and `reader3` using differnet methods, the result here stays the same no matter what format the source data uses. Later in the [Transformers](#transformers) section we will see how we can combine Reader with transformers for a unified coding experience.

# Utility Functions

The toolkit doesn't provide pre-defined models on common constructs. Instead, it is defined to let you have your own model, and work with it. For example, typical Web project probably has models defined from an ORM over a SQL database. I don't want you to have both a cell data structure defined in your ORM, and in the toolkit. We wanta to take a different path here: you only need to define the data structure once, whether it's defined from an ORM, or defined as an ECMAScript class with methods customed to your project. All you need to do, is to follow rules defined by transformers, you will be able to use the utility functions defined here.

The diagram below illustrates the relations between the utility functions:

![Utility Function Relations](images/toolkit.svg)

`Normalizers`, `Transformers` and `Validators` are included in this repository. `Denormalizers` are kept in the more experimental [ckb-js-toolkit-contrib](https://github.com/xxuejie/ckb-js-toolkit-contrib) project for now, and might be moved here once it is stablized. `Serializers` and `Deserializers` refer to JavaScript source generated by the [moleculec-es](https://github.com/xxuejie/moleculec-es) project. In most cases, you don't have to use `moleculec-es` directly, a ready-to-use file has been put in [ckb-js-toolkit-contrib](https://github.com/xxuejie/ckb-js-toolkit-contrib/blob/master/src/blockchain.js).

There is one exception here: `Deserializers` are not functions actually, they are [classes](https://github.com/xxuejie/ckb-js-toolkit-contrib/blob/747db7616116a3d5511f633f71b0415b53e83060/src/blockchain.js#L691) that is constructed from ArrayBuffer to better leverage molecule's zero copy design.

You might also notice there is no conversions from JSON Ready Object to objects in your own data structures. This part will have to be implemented by yourself if needed.

## Validators

### Overview

Validator is an example of the `Runtime type checking` design goal, it provides a series of functions are provided here to validate that a JSON object follows required format for a CKB data structure, such as script, outpoint, transaction, block, etc. So when you have prepared the values required by the RPC class, you can pass the value through the validators here, to ensure they are of the correct format.

First, let's look at one example:

```
node --experimental-repl-await
Welcome to Node.js v13.9.0.
Type ".help" for more information.
> const toolkit = require("ckb-js-toolkit")
> const rpc = new toolkit.RPC("http://127.0.0.1:9115/rpc")
> const transaction = (await rpc.get_transaction("0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c")).transaction
> toolkit.validators.ValidateTransaction(transaction)
Uncaught:
Error: transaction does not have correct keys! Required keys: [cell_deps, header_deps, inputs, outputs, outputs_data, version, witnesses], optional keys: [], actual keys: [cell_deps, hash, header_deps, inputs, outputs, outputs_data, version, witnesses]
> delete transaction.hash
> transaction
{
  cell_deps: [
    { dep_type: 'code', out_point: [Object] },
    { dep_type: 'code', out_point: [Object] }
  ],
  header_deps: [],
  inputs: [ { previous_output: [Object], since: '0x0' } ],
  outputs: [
    { capacity: '0x2b95fd500', lock: [Object], type: null },
    { capacity: '0x2b95fd500', lock: [Object], type: null }
  ],
  outputs_data: [
    '0x02000000e2fb199810d49a4d8beec56718ba2593b665db9d52299a0f9e6e75416d73ff5c03000000e2fb199810d49a4d8beec56718ba2593b665db9d52299a0f9e6e75416d73ff5c01000000',
    '0x02000000e2fb199810d49a4d8beec56718ba2593b665db9d52299a0f9e6e75416d73ff5c03000000e2fb199810d49a4d8beec56718ba2593b665db9d52299a0f9e6e75416d73ff5c04000000'
  ],
  version: '0x0',
  witnesses: [
    '0x3ed693609d3ff7049415d33a2fff8eed581cf2790fae4785e27793330cfd55a6109b84a94494eae64217339bc9aafdf4e6453964c90e6752d96e20d127ca874901'
  ]
}
> toolkit.validators.ValidateTransaction(transaction)
undefined
> transaction.outputs[1].lock.args = 123
123
> toolkit.validators.ValidateTransaction(transaction)
Uncaught Error: transaction.outputs[1].lock.args must be a hex string!
    at nt (/home/ubuntu/code/ckb-js-toolkit/dist/ckb-js-toolkit.node.js:1:46599)
    at st (/home/ubuntu/code/ckb-js-toolkit/dist/ckb-js-toolkit.node.js:1:47003)
    at lt (/home/ubuntu/code/ckb-js-toolkit/dist/ckb-js-toolkit.node.js:1:47614)
    at /home/ubuntu/code/ckb-js-toolkit/dist/ckb-js-toolkit.node.js:1:48132
    at ct (/home/ubuntu/code/ckb-js-toolkit/dist/ckb-js-toolkit.node.js:1:48073)
    at ht (/home/ubuntu/code/ckb-js-toolkit/dist/ckb-js-toolkit.node.js:1:48343)
    at Object.dt [as ValidateTransaction] (/home/ubuntu/code/ckb-js-toolkit/dist/ckb-js-toolkit.node.js:1:48755)
```

From the example above, we can deduce some insights:

* Validator function will check if given object has correct keys for each field required in the object. For example, a transaction object do not need `hash` field, but CKB's RPC response contains this field, hence the first validator invocation fails. Later when we delete the `hash` key, the object passes all validation.
* By default validator function recursively check all fields to make sure they follow the correct format. In the above example, the validator would signal error when we change `args` field of one output's lock script to `123`, which is an invalid value. You will also notice that the error message generated in this case is: `transaction.outputs[1].lock.args must be a hex string!`, it contains the full path of the error value: `transaction.outputs[1].lock.args`.

Notice you are not required to use validator functions in your dapp: if you are familiar with CKB's data structure, you are perfectly good ignoring all validator functions, and ensure the objects are in correct format yourself. But I personally I believe validators are gonna be a very handy component in your toolbox when you run into formatting errors in your dapp.

### Function prototypes

For each CKB data structure, we have prepared a validator function, which means right now the following functions are available:

* [ValidateScript](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L65)
* [ValidateOutPoint](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L83)
* [ValidateCellInput](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L92)
* [ValidateCellOutput](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L106)
* [ValidateCellDep](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L125)
* [ValidateRawTransaction](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L195)
* [ValidateTransaction](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L215)
* [ValidateRawHeader](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L255)
* [ValidateHeader](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L279)
* [ValidateUncleBlock](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L316)
* [ValidateBlock](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L335)
* [ValidateCellbaseWitness](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L371)
* [ValidateWitnessArgs](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/validators.js#L385)

Each validator function uses exactly the same function prototype as below:

```js
function validate(value, { nestedValidation = true, debugPath = "" } = {})
```

`value` here contains the JSON object to check against. `nestedValidation` controls if nested validation is performed. For example, when you are validating the structure of a transaction, you can use this flag to control whether you want to validate transaction itself, or if you want to do recursive validation on all the included fields, such as inputs, outputs, etc. `debugPath` here is a value used to generate full value path in error messages, in 99% of the cases, you can safely ignore this value and just use the default ones.

The validator functions here would throw errors in case validation fails, otherwise the validation is considered successful. Return values of vaildator functions shall not be used.

## Transformers

### Overview

Transformer also provides a series of functions much like validators do, but transformers serve a different purpose: while RPC accepts JSON ready values such as strings or plain objects, you might not want the same thing in your dapps. Chances are you have some custom classes that wrap a CKB cell or even a CKB transaction, and will need separate processing work to transform the values into the final formats. Another case might be that you are leveraging the Reader class introduced above a lot, and you need to transform the very inner `args` part of cell outputs in your current transaction before you can send it to the RPC. Transformers fill in exactly this role: they help us transform custom data formats following a very single rule to the formats acceptable by CKB RPCs. This might sound quite abstract here, let's also look at one example. First, let's prepare a supporting commonjs JavaScript file:

```
$ cat << EOF > test.js
class Script {
  constructor(code_hash, args) {
    this.code_hash = code_hash;
    this.args = args;
  }

  serializeJson() {
    return {
      code_hash: this.code_hash,
      hash_type: "data",
      args: this.args
    };
  }
}

module.exports = Script;
EOF
```

Here we are defining a custom class wrapping Script. We can now see how transformers will help us use the wrapper class:

```
node --experimental-repl-await
Welcome to Node.js v13.9.0.
Type ".help" for more information.
> const toolkit = require("ckb-js-toolkit");
undefined
> const Script = require("./test.js");
undefined
> const script = new Script(new toolkit.Reader("0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c"), "0x")
undefined
> script
Script {
  code_hash: a {
    string: '0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c'
  },
  args: '0x'
}
> toolkit.validators.ValidateScript(script)
Uncaught:
Error: script does not have correct keys! Required keys: [args, code_hash, hash_type], optional keys: [], actual keys: [args, code_hash]
> const transformedScript = toolkit.transformers.TransformScript(script)
undefined
> transformedScript
{
  code_hash: '0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c',
  hash_type: 'data',
  args: '0x'
}
> toolkit.validators.ValidateScript(transformedScript)
undefined
```

If we pass objects instantiated from Script class directly, validator functions will fail, and so will CKB RPC(even if we haven't tested it here). However, if we pass the objects into transformer functions, the transformed value will have the correct format required by CKB's RPC. This shows that you can use whatever data format you want in your dapp, as long as it can be transformed to correct format by the transformers, you can largely ignore CKB's format rules in your dapp.

Of course, not any format can be transformed by transformer functions here. You might already noticed the `serializeJson` function included in the `Script` class, this is exactly how transformer functions work on. What's not so obvious, here, is that transformer functions will recursively invoke `serializeJson` on nested entities to make sure all sub-fields are also transformed properly. For example, the `code_hash` passed to Script object here, is actually a Reader instance, while `serializeJson` of Script class ignored the type of `code_hash`, transformer functions also perform the necessary transformation, which converts Reader object into hex strings.

Unlike validators, we expect you to heavily rely on transformers in your dapps. These days it will be very unlikely that people use plain old JavaScript objects to store data, we tend to use all kinds of abstractions that help us organize our code better.

### Function prototypes

For each CKB data structure, we have prepared a transformer function, which means right now the following functions are available:

* [TransformScript](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L44)
* [TransformOutPoint](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L62)
* [TransformCellInput](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L88)
* [TransformCellOutput](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L105)
* [TransformCellDep](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L123)
* [TransformRawTransaction](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L148)
* [TransformTransaction](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L169)
* [TransformRawHeader](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L191)
* [TransformHeader](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L216)
* [TransformUncleBlock](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L242)
* [TransformBlock](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L259)
* [TransformCellbaseWitness](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L278)
* [TransformWitnessArgs](https://github.com/xxuejie/ckb-js-toolkit/blob/48eb43f10da07d30ebc9411c7a0714905ef9164f/src/transformers.js#L295)

Each transformer function uses exactly the same function prototype as below:

```js
function transform(value, { validation = true, debugPath = "" } = {})
```

`value` here contains the value to perform transformation(see next section for transformation rules). `validation` controls if validators should also be called after transformation. `debugPath` works like the same value in validators, and could safely be ignored in 99% of the cases.

### Transformation Rules

Transformer functions use the following transformation rules:

* If the provide value is an object with method `serializeJson`, invoke the method and use the return value to replace provided value;
* Check if the value is an object, throw error if it is not;
* Remove all extra keys that should not exist for the type of current value object;
* For each field in the object, apply the transformation rules recursively.

### Note on Reader class

We have already provided `serializeJson` method for all instances of the Reader class, that means you can freely use Reader class in your code. As long as you apply transformer functions before sending the values to CKB RPC, all the Reader objects will be transformed to correct hex strings.

## Normalizers

### Overview

Normalizers serve a different purpose: in addition to the molecule serialization format, CKB still encodes certain domain specific knowledge to interpret the data. This brings a gap between the JSON data structure used in CKB RPC, and the molecule serialized formats used internally. If you are only using CKB RPC, you probably will not use this package, but if you need to work with CKB in a deeper level(for example, if you are writing a smart contract in JavaScript), chances are you might need this package.

A sample usage for this package can be seen in the included [tests](https://github.com/xxuejie/ckb-js-toolkit/blob/master/tests/serializers.js). A normalizer function takes plain JavaScript object that can be validated by validator function, it then emits another transformed plain JavaScript object which can be serialized by [moleculec-es](https://github.com/xxuejie/moleculec-es) into serialized ArrayBuffer data in molecule format.

### Function prototypes

For each CKB data structure, we have prepared a normalizer function, which means right now the following functions are available:

* [NormalizeScript](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L71)
* [NormalizeOutPoint](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L92)
* [NormalizeCellInput](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L107)
* [NormalizeCellOutput](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L117)
* [NormalizeCellDep](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L133)
* [NormalizeRawTransaction](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L161)
* [NormalizeTransaction](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L175)
* [NormalizeRawHeader](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L189)
* [NormalizeHeader](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L207)
* [NormalizeUncleBlock](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L218)
* [NormalizeBlock](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L228)
* [NormalizeCellbaseWitness](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L237)
* [NormalizeWitnessArgs](https://github.com/xxuejie/ckb-js-toolkit/blob/d17eda8dc41689b14913500332085d9a9ae85a01/src/normalizers.js#L247)

Each normalizer function uses exactly the same function prototype as below:

```js
function transform(value, { debugPath = "" } = {})
```

`value` here contains the value which can be validated by corresponding validator function. `debugPath` works like the same value in validators, and could safely be ignored in 99% of the cases.

# Cell Collectors

One extremely typical tasks in CKB, is to index and query cells with certain properties, such as live cells with the same lock script hash. Cell collectors has been provided in the toolkit to aid this task.

As usual, first let's see an example:

```
node --experimental-repl-await
Welcome to Node.js v13.9.0.
Type ".help" for more information.
> const toolkit = require("ckb-js-toolkit");
undefined
> const rpc = new toolkit.RPC("http://127.0.0.1:9115/rpc")
undefined
> const collector = new toolkit.cell_collectors.RPCCollector(rpc, "0x7c7232c0af4a7261674a45e14916f926ecec64b911f539e573fb4bb7817d001e")
undefined
> for await (const cell of collector.collect()) { console.log(cell); }
{
  cell_output: {
    capacity: '0x3faa252260000',
    lock: {
      args: '0xfa3afa2134319f9471cf21024f032831bc4651ad',
      code_hash: '0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8',
      hash_type: 'type'
    },
    type: null
  },
  out_point: {
    index: '0x7',
    tx_hash: '0xe2fb199810d49a4d8beec56718ba2593b665db9d52299a0f9e6e75416d73ff5c'
  },
  block_hash: '0x92b197aa1fba0f63633922c61c92375c9c074a93e85963554f5499fe1450d0e5',
  data: null,
  block_number: '0x0'
}
```

Here we are using [RPCCollector](https://github.com/xxuejie/ckb-js-toolkit/blob/master/src/cell_collectors/rpc_collector.js) to scan CKB via RPCs, and gather all live cells satisfying a given lock script hash. Notice [async iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator) is leveraged here to provide a clean API to the end users.

## Collector Interface

A cell collector should satisfy the following rules:

* It should provide a `collect` method that returns an async iterator;
* The async iterator should generate plain JavaScript objects with the following fields:
    + `cell_output`: CellOutput object that can be validated by `ValidateCellOutput`
    + `out_point`: OutPoint object that can be validated by `ValidateOutPoint`
    + `block_hash`: A 66-byte long hex string containing block header hash
    * `data`: An optional hex string containing cell data, depending on the specific cell collector, this could be omitted, in which case `null` should be used here.

In the above example we are only showing RPCCollector, there might be many different implementations of cell collectors, assuming they satisfy the above rules. In the future we might add more cell collector implementations here, and you are also welcome to create your own implementations of cell collectors.

One additional note here, is that even though RPCCollector above only gathers cells with the same lock script hash, this is not the case for your custom cell collectors. The only true requirement of a cell collector, is the async iterator interface. You can use any filtering logic in your cell collector, for example, you can gather by type script hash, or by lock script code hash, or you can even call external services, such as [animagus](https://github.com/xxuejie/animagus) to provide you with the cells to use.

## Collector Index

### RPCCollector

RPCCollector uses [get_cells_by_lock_hash](https://github.com/nervosnetwork/ckb/tree/develop/rpc#get_cells_by_lock_hash) to fetch matched live cells via CKB RPC. It only allows fetching live cells matching provided lock script hash, and can be controlled to either provide or omit cell data.

Note RPCCollector is a naive implementation, meaning it would do the full scanning every time you call `collect`. This means it could be quite slow, and you should never use it in production. It is only used here for demostration purposes.

'''
'''--- packages/toolkit/images/toolkit.svg ---
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="741px" height="331px" viewBox="-0.5 -0.5 741 331" content="&lt;mxfile host=&quot;app.diagrams.net&quot; modified=&quot;2020-04-02T01:10:27.122Z&quot; agent=&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36&quot; version=&quot;12.8.8&quot; etag=&quot;9PXx_xv01Bwwv3eO-2_5&quot; type=&quot;google&quot;&gt;&lt;diagram id=&quot;cpXa6irYi2zS5i0noqt6&quot;&gt;7Vpbj9o4FP41PBbFcS7MYwe6W+2q7aistu2jmxjI1sTIMQP0169N7FzspAkMYVgtGmkUH19if+f4O5cwgtP1/neGNqsPNMZk5DrxfgRnI9edhK74LwWHXBAEk1ywZEmci0ApmCc/sRI6SrpNYpzVBnJKCU82dWFE0xRHvCZDjNFdfdiCkvpbN2iJLcE8QsSWfklivlLH8p1S/h4ny5V+M3BUzxrpwUqQrVBMdxURfDeCU0Ypz5/W+ykmEjuNSz7vt5beYmMMp7zPBKWIZ0S26mzf6JYJyaddKv9//0fi5wZErPb4XXQES/k0ReujRqkcmqXoB5ZoowyrU/GDhorRbRpj+TYg5u1WCcfzDYpk707YhpCt+JqobrUZzDjetx4IFDAJ88J0jTk7iCFqQuDnM5RlAQ30rtRTIVtVdBQoGVKmsSxWLtETDwrAZjChBeYf808fheQzRvHhF3DObwlB6LwihJ4FoYUHTuO38g6LVkRQliVRHQK8T/jXyvM38eyMfdWayVM6unHQjVTs82u1UZklm+W0Y0vPyzeHY4MuMnGHIly7YRyxJeY1O+mhkgrkfgPiWsYwQTx5rm+iSQ3qDU80ES8uNG5eGhgamszPo2ZV2cRYCAJjIddYKEfBWuhoFcWxexmKbxnK9M9H+2Z9fpraBkSIcBS4+zKhbJN7j0WylxfwErfL73G7goEuV9BwuRRgGq+/GEqzBWVrzDLdKZYt+i0wBRK8jlrGGf2Bp5QI5wBnKU0l0ouEEEOESLJM5SUWyGEhf5S4JsLJvlUd6ySOSZuaSlaU93BBU67CBOBdRlHgwVAUbKBBp0FTps2fo6mwmwajLXsuvEIXJ5r4aI50xq5foUnQkyTHoV/lSfByloR3luxkSaFhdKgM28gBWfuGoVd/jxULmuMnvxwvHvIdnEvZk276+VuQQow4/b+Tj2kiblMMNhT5PHSTj0hbNvJxQfBeEc/pHJTGOnkSnunY1t3HQFf1Ad/Q4MiFswf5184sN8MZHjSciH8mZ3imNzIXulxkpZPsiv4/UIKjLcH/9VTGDa+YygDQzXcfRaQlqOjnPdoy7Nv1rkh4wK6CHD3d43axEFi9thX7ph+/qhXbRQ0LkE7mb2Hvtqj0Gpl7jLJVocMWN1INUDUrViNUbTe34278uqV48Ex3Y2apcDKcu2kq+Rg0OccsudNkQzzhTq5Jk3bNxUL+tKz0RF5wLsAL4cWJIbSJ4dZS1zfAdCGma+hLDG9MPw2GyV2LdY1ku21fRTw8UO4KetTOZji9h3N5b2hYycM1acounlXyl7a8hT7LSM+5pbjPzF5gE4qDxX1N1ZqXkH2NV09m/vEZZcqiLHmxbzk64KsFgeGNkX1gmI13bs0hMKNJZxiu943CqgcuzN1NBS2Lu7N7jDlqTDcbaWco8tZrdH3Xey/ZxKboV/20F/bI04f6tOc2FZsMcO5F254EakQv0OS9vgQawo6FLpdFa3W/srs+sxhTunknCKuOfuwA3W5x9qLxJJhbQCWp9AWfG3XCcTNmCAz3C88t5rhmFbxnMefknM3w4y58kR8XzfJ3cPnw8seE8N2/&lt;/diagram&gt;&lt;/mxfile&gt;"><defs/><g><rect x="0" y="0" width="120" height="60" rx="9" ry="9" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 30px; margin-left: 1px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">Your Own Object<br />Camel or snake case</div></div></div></foreignObject><text x="60" y="34" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Your Own Object...</text></switch></g><rect x="240" y="0" width="120" height="60" rx="9" ry="9" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 30px; margin-left: 241px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">JSON Ready Object<br />Snake case</div></div></div></foreignObject><text x="300" y="34" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">JSON Ready Object...</text></switch></g><path d="M 120 30 L 233.63 30" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 238.88 30 L 231.88 33.5 L 233.63 30 L 231.88 26.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><ellipse cx="470" cy="30" rx="30" ry="30" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 58px; height: 1px; padding-top: 30px; margin-left: 441px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">CKB<br />RPC</div></div></div></foreignObject><text x="470" y="34" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">CKB...</text></switch></g><rect x="130" y="10" width="100" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 98px; height: 1px; padding-top: 20px; margin-left: 131px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 14px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><b>Transformers</b></div></div></div></foreignObject><text x="180" y="24" fill="#000000" font-family="Helvetica" font-size="14px" text-anchor="middle">Transformers</text></switch></g><path d="M 270 60 Q 280 100 300 100 Q 320 100 328.46 66.18" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 329.73 61.08 L 331.43 68.72 L 328.46 66.18 L 324.64 67.03 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><rect x="250" y="100" width="100" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 98px; height: 1px; padding-top: 110px; margin-left: 251px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 14px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><b>Validators</b></div></div></div></foreignObject><text x="300" y="114" fill="#000000" font-family="Helvetica" font-size="14px" text-anchor="middle">Validators</text></switch></g><path d="M 370.5 37.5 L 370.5 22.5 L 395.5 22.5 L 395.5 9 L 429.5 30 L 395.5 51 L 395.5 37.5 Z" fill="#d9d9d9" stroke="#000000" stroke-linejoin="round" stroke-miterlimit="10" pointer-events="all"/><rect x="240" y="150" width="120" height="60" rx="9" ry="9" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 180px; margin-left: 241px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">Molecule Ready Object<br />Snake case</div></div></div></foreignObject><text x="300" y="184" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Molecule Ready Objec...</text></switch></g><rect x="130" y="120" width="100" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 98px; height: 1px; padding-top: 130px; margin-left: 131px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 14px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><b>Normalizers</b></div></div></div></foreignObject><text x="180" y="134" fill="#000000" font-family="Helvetica" font-size="14px" text-anchor="middle">Normalizers</text></switch></g><rect x="480" y="150" width="120" height="60" rx="9" ry="9" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 180px; margin-left: 481px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">ArrayBuffer</div></div></div></foreignObject><text x="540" y="184" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">ArrayBuffer</text></switch></g><path d="M 360 180 L 473.63 180" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="stroke"/><path d="M 478.88 180 L 471.88 183.5 L 473.63 180 L 471.88 176.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><rect x="370" y="160" width="100" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 98px; height: 1px; padding-top: 170px; margin-left: 371px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 14px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><b>Serializers</b></div></div></div></foreignObject><text x="420" y="174" fill="#000000" font-family="Helvetica" font-size="14px" text-anchor="middle">Serializers</text></switch></g><path d="M 240 300 Q 145 250 115 175 Q 85 100 234 47.13" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="stroke"/><path d="M 238.95 45.37 L 233.52 51.01 L 234 47.13 L 231.18 44.42 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><rect x="10" y="170" width="100" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 98px; height: 1px; padding-top: 180px; margin-left: 11px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 14px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><b>Denormalizers</b></div></div></div></foreignObject><text x="60" y="184" fill="#000000" font-family="Helvetica" font-size="14px" text-anchor="middle">Denormalizers</text></switch></g><rect x="240" y="270" width="120" height="60" rx="9" ry="9" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 300px; margin-left: 241px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">Molecule Object<br />over ArrayBuffer</div></div></div></foreignObject><text x="300" y="304" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Molecule Object...</text></switch></g><path d="M 540 210 Q 500 290 366.35 299.55" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="stroke"/><path d="M 361.12 299.92 L 367.85 295.93 L 366.35 299.55 L 368.35 302.91 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><rect x="480" y="270" width="100" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 98px; height: 1px; padding-top: 280px; margin-left: 481px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 14px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><b>Deserializers</b></div></div></div></foreignObject><text x="530" y="284" fill="#000000" font-family="Helvetica" font-size="14px" text-anchor="middle">Deserializers</text></switch></g><ellipse cx="710" cy="180" rx="30" ry="30" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 58px; height: 1px; padding-top: 180px; margin-left: 681px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">CKB<br />Hasher</div></div></div></foreignObject><text x="710" y="184" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">CKB...</text></switch></g><path d="M 610.5 187.5 L 610.5 172.5 L 635.5 172.5 L 635.5 159 L 669.5 180 L 635.5 201 L 635.5 187.5 Z" fill="#d9d9d9" stroke="#000000" stroke-linejoin="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 248.04 61.02 Q 200 110 236.84 174.47" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="stroke"/><path d="M 239.45 179.03 L 232.93 174.69 L 236.84 174.47 L 239.01 171.22 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://desk.draw.io/support/solutions/articles/16000042487" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Viewer does not support full SVG 1.1</text></a></switch></svg>
'''
'''--- packages/toolkit/index.d.ts ---
import JSBI from "jsbi";

export class Reader {
  constructor(reader: string | ArrayBuffer | Reader);
  static fromRawString(s: string): Reader;
  static isReader(x: unknown): x is Reader;
  static from(x: string | ArrayBuffer | Reader | Uint8Array): Reader;

  length(): number;
  indexAt(i: number): number;
  toArrayBuffer(): ArrayBuffer;
  serializeJson(): string;
}

export type RPCValue = any;
export type RPCSyncHandler = (...params: RPCValue[]) => RPCValue;
export type RPCHandler = (...params: RPCValue[]) => Promise<RPCValue>;

export class BatchRPCMethods {
  send: RPCHandler;
}

export class BatchRPCProxy {
  [method: string]: RPCSyncHandler;
}

export type BatchRPC = BatchRPCMethods & BatchRPCProxy;

export class RPCMethods {
  batch: () => BatchRPC;
}

export class RPCProxy {
  [method: string]: RPCHandler;
}

export class RPC {
  /**
   * To preserve compatibility, we still provide the default constructor
   * but it cannot tell if you are calling the sync method batch, or other
   * async methods. You will need to distinguish between them yourself.
   */
  constructor(uri: string, options?: object);
  [method: string]: RPCHandler | RPCSyncHandler;

  static create(uri: string): RPCMethods & RPCProxy;
}

export function HexStringToBigInt(hexString: string): JSBI;
export function BigIntToHexString(i: JSBI): string;

export interface ValidatorOptions {
  nestedValidation?: boolean;
  debugPath?: string;
}
type ValidatorFunction = (value: object, options?: ValidatorOptions) => void;

export namespace validators {
  const ValidateScript: ValidatorFunction;
  const ValidateOutPoint: ValidatorFunction;
  const ValidateCellInput: ValidatorFunction;
  const ValidateCellOutput: ValidatorFunction;
  const ValidateCellDep: ValidatorFunction;
  const ValidateRawTransaction: ValidatorFunction;
  const ValidateTransaction: ValidatorFunction;
  const ValidateRawHeader: ValidatorFunction;
  const ValidateHeader: ValidatorFunction;
  const ValidateUncleBlock: ValidatorFunction;
  const ValidateBlock: ValidatorFunction;
  const ValidateCellbaseWitness: ValidatorFunction;
  const ValidateWitnessArgs: ValidatorFunction;
}

export interface TransformerOptions {
  validation?: boolean;
  debugPath?: string;
}
type TransformerFunction = (
  value: object,
  options?: TransformerOptions
) => object;

export namespace transformers {
  const TransformScript: TransformerFunction;
  const TransformOutPoint: TransformerFunction;
  const TransformCellInput: TransformerFunction;
  const TransformCellOutput: TransformerFunction;
  const TransformCellDep: TransformerFunction;
  const TransformRawTransaction: TransformerFunction;
  const TransformTransaction: TransformerFunction;
  const TransformRawHeader: TransformerFunction;
  const TransformHeader: TransformerFunction;
  const TransformUncleBlock: TransformerFunction;
  const TransformBlock: TransformerFunction;
  const TransformCellbaseWitness: TransformerFunction;
  const TransformWitnessArgs: TransformerFunction;
}

export interface NormalizerOptions {
  debugPath?: string;
}
type NormalizerFunction = (
  value: object,
  options?: NormalizerOptions
) => object;

export namespace normalizers {
  const NormalizeScript: NormalizerFunction;
  const NormalizeOutPoint: NormalizerFunction;
  const NormalizeCellInput: NormalizerFunction;
  const NormalizeCellOutput: NormalizerFunction;
  const NormalizeCellDep: NormalizerFunction;
  const NormalizeRawTransaction: NormalizerFunction;
  const NormalizeTransaction: NormalizerFunction;
  const NormalizeRawHeader: NormalizerFunction;
  const NormalizeHeader: NormalizerFunction;
  const NormalizeUncleBlock: NormalizerFunction;
  const NormalizeBlock: NormalizerFunction;
  const NormalizeCellbaseWitness: NormalizerFunction;
  const NormalizeWitnessArgs: NormalizerFunction;
}

export interface Cell {
  cell_output: object;
  out_point: object;
  block_hash: string;
  data?: string;
  block_number?: string;
}

export interface CellCollectorResults {
  [Symbol.asyncIterator](): AsyncIterator<Cell>;
}

export interface CellCollector {
  collect(): CellCollectorResults;
}

export namespace cell_collectors {
  interface RPCCollectorOptions {
    skipCellWithContent?: boolean;
    loadData?: boolean;
  }

  class RPCCollector implements CellCollector {
    constructor(rpc: RPC, lockHash: string, options?: RPCCollectorOptions);

    collect(): CellCollectorResults;
  }
}

export type DepGroupUnpacker = (data: Reader) => Array<object>;
export interface TransactionDumperOptions {
  validateTransaction?: boolean;
  depGroupUnpacker?: DepGroupUnpacker;
}

export class TransactionDumper {
  constructor(rpc: RPC, options?: TransactionDumperOptions);

  dump(tx: object): Promise<string>;
}

export const VERSION: string;

'''
'''--- packages/toolkit/package.json ---
{
  "name": "@ckb-lumos/toolkit",
  "version": "0.17.0-rc8",
  "description": "JavaScript toolkits used to build dapps for Nervos CKB",
  "main": "lib/index.js",
  "types": "index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "files": [
    "index.d.ts",
    "lib"
  ],
  "scripts": {
    "build": "yarn run build:js",
    "build:js": "babel -s --plugins @babel/plugin-proposal-export-namespace-from --plugins @babel/plugin-transform-modules-commonjs src --out-dir lib",
    "clean": "rm -rf lib",
    "test": "ava",
    "fmt": "prettier --write \"{src,tests}/**/*.js\" index.d.ts",
    "lint": "eslint -c ../../.eslintrc.js \"{src,tests}/**/*.js\"",
    "update-test-files": "curl -L https://raw.githubusercontent.com/nervosnetwork/ckb/27c36a55e6358fd04153ec3da4638b6e10660da6/util/types/schemas/blockchain.mol -o testfiles/blockchain.mol && moleculec --language - --schema-file testfiles/blockchain.mol --format json > testfiles/blockchain.json && moleculec-es -inputFile testfiles/blockchain.json -outputFile testfiles/blockchain.esm.js && rollup -f umd -i testfiles/blockchain.esm.js -o testfiles/blockchain.umd.js --name Blockchain && rm testfiles/blockchain.mol testfiles/blockchain.json testfiles/blockchain.esm.js"
  },
  "author": "Xuejie Xiao",
  "license": "MIT",
  "peerDependencies": {
    "cross-fetch": "^3.1.4",
    "jsbi": "^4.1.0"
  }
}

'''
'''--- packages/toolkit/src/cell_collectors/index.js ---
export { RPCCollector } from "./rpc_collector";

'''
'''--- packages/toolkit/src/cell_collectors/rpc_collector.js ---
import JSBI from "jsbi";
import { Reader } from "../reader";
import { HexStringToBigInt, BigIntToHexString } from "../rpc";

export class RPCCollector {
  constructor(
    rpc,
    lockHash,
    {
      skipCellWithContent = true,
      loadData = false,
      loadBlockNumber = true,
    } = {}
  ) {
    this.rpc = rpc;
    this.lockHash = new Reader(lockHash).serializeJson();
    this.skipCellWithContent = skipCellWithContent;
    this.loadData = loadData;
    this.loadBlockNumber = loadBlockNumber;
  }

  async *collect() {
    const to = HexStringToBigInt(await this.rpc.get_tip_block_number());
    let currentFrom = JSBI.BigInt(0);
    while (JSBI.lessThanOrEqual(currentFrom, to)) {
      let currentTo = JSBI.add(currentFrom, JSBI.BigInt(100));
      if (JSBI.greaterThan(currentTo, to)) {
        currentTo = to;
      }
      const cells = await this.rpc.get_cells_by_lock_hash(
        this.lockHash,
        BigIntToHexString(currentFrom),
        BigIntToHexString(currentTo)
      );
      for (const cell of cells) {
        if (this.skipCellWithContent) {
          if (
            cell.type ||
            JSBI.greaterThan(
              HexStringToBigInt(cell.output_data_len),
              JSBI.BigInt(100)
            )
          ) {
            continue;
          }
        }
        let data = null;
        if (this.loadData) {
          const cellWithData = await this.rpc.get_live_cell(
            cell.out_point,
            true
          );
          data = cellWithData.cell.data.content;
        }
        let block_number = null;
        if (this.loadBlockNumber) {
          const header = await this.rpc.get_header(cell.block_hash);
          block_number = header.number;
        }
        yield {
          cellbase: cell.cellbase,
          cell_output: {
            capacity: cell.capacity,
            lock: cell.lock,
            type: cell.type,
          },
          out_point: cell.out_point,
          block_hash: cell.block_hash,
          data: data,
          output_data_len: cell.output_data_len,
          block_number,
        };
      }
      currentFrom = JSBI.add(currentTo, JSBI.BigInt(1));
    }
  }
}

'''
'''--- packages/toolkit/src/index.js ---
export { Reader } from "./reader.js";
export { TransactionDumper } from "./transaction_dumper.js";
export { RPC, HexStringToBigInt, BigIntToHexString } from "./rpc.js";
export * as normalizers from "./normalizers";
export * as transformers from "./transformers";
export * as validators from "./validators";
export * as cell_collectors from "./cell_collectors";
export const VERSION = "__development_build__";

'''
'''--- packages/toolkit/src/normalizers.js ---
// This package provides normalizer functions. Even though CKB uses molecule
// as the serialization layer. There is still CKB specific knowledge that does
// not belong in molecule. For example, all numbers in CKB protocols are
// serialized using little endian format. This package tries to encode such
// knowledge. The goal here, is that you are free to use whatever types that
// makes most sense to represent the values. As long as you pass your object
// through the normalizers here, molecule should be able to serialize the values
// into correct formats required by CKB.
//
// Note this is only used when you need to deal with CKB structures in molecule
// format. If you are using RPCs or GraphQL to interact with CKB, chances are you
// will not need this package.
import JSBI from "jsbi";
import { Reader } from "./reader";
import { BigIntToHexString } from "./rpc";

function normalizeHexNumber(length) {
  return function (debugPath, value) {
    if (!(value instanceof ArrayBuffer)) {
      let intValue = BigIntToHexString(JSBI.BigInt(value)).substr(2);
      if (intValue.length % 2 !== 0) {
        intValue = "0" + intValue;
      }
      if (intValue.length / 2 > length) {
        throw new Error(
          `${debugPath} is ${
            intValue.length / 2
          } bytes long, expected length is ${length}!`
        );
      }
      const view = new DataView(new ArrayBuffer(length));
      for (let i = 0; i < intValue.length / 2; i++) {
        const start = intValue.length - (i + 1) * 2;
        view.setUint8(i, parseInt(intValue.substr(start, 2), 16));
      }
      value = view.buffer;
    }
    if (value.byteLength < length) {
      const array = new Uint8Array(length);
      array.set(new Uint8Array(value), 0);
      value = array.buffer;
    }
    return value;
  };
}

function normalizeRawData(length) {
  return function (debugPath, value) {
    value = new Reader(value).toArrayBuffer();
    if (length > 0 && value.byteLength !== length) {
      throw new Error(
        `${debugPath} has invalid length ${value.byteLength}, required: ${length}`
      );
    }
    return value;
  };
}

function normalizeObject(debugPath, object, keys) {
  const result = {};

  for (const [key, f] of Object.entries(keys)) {
    const value = object[key];
    if (!value) {
      throw new Error(`${debugPath} is missing ${key}!`);
    }
    result[key] = f(`${debugPath}.${key}`, value);
  }
  return result;
}

export function NormalizeScript(script, { debugPath = "script" } = {}) {
  return normalizeObject(debugPath, script, {
    code_hash: normalizeRawData(32),
    hash_type: function (debugPath, value) {
      switch (value) {
        case "data":
          return 0;
        case "type":
          return 1;
        case 0:
          return value;
        case 1:
          return value;
        default:
          throw new Error(`${debugPath}.hash_type has invalid value: ${value}`);
      }
    },
    args: normalizeRawData(-1),
  });
}

export function NormalizeOutPoint(outPoint, { debugPath = "out_point" } = {}) {
  return normalizeObject(debugPath, outPoint, {
    tx_hash: normalizeRawData(32),
    index: normalizeHexNumber(4),
  });
}

function toNormalize(normalize) {
  return function (debugPath, value) {
    return normalize(value, {
      debugPath,
    });
  };
}

export function NormalizeCellInput(
  cellInput,
  { debugPath = "cell_input" } = {}
) {
  return normalizeObject(debugPath, cellInput, {
    since: normalizeHexNumber(8),
    previous_output: toNormalize(NormalizeOutPoint),
  });
}

export function NormalizeCellOutput(
  cellOutput,
  { debugPath = "cell_output" } = {}
) {
  const result = normalizeObject(debugPath, cellOutput, {
    capacity: normalizeHexNumber(8),
    lock: toNormalize(NormalizeScript),
  });
  if (cellOutput.type) {
    result.type_ = NormalizeScript(cellOutput.type, {
      debugPath: `${debugPath}.type`,
    });
  }
  return result;
}

export function NormalizeCellDep(cellDep, { debugPath = "cell_dep" } = {}) {
  return normalizeObject(debugPath, cellDep, {
    out_point: toNormalize(NormalizeOutPoint),
    dep_type: function (debugPath, value) {
      switch (value) {
        case "code":
          return 0;
        case "dep_group":
          return 1;
        case 0:
          return value;
        case 1:
          return value;
        default:
          throw new Error(`${debugPath}.dep_type has invalid value: ${value}`);
      }
    },
  });
}

function toNormalizeArray(normalizeFunction) {
  return function (debugPath, array) {
    return array.map((item, i) => {
      return normalizeFunction(`${debugPath}[${i}]`, item);
    });
  };
}

export function NormalizeRawTransaction(
  rawTransaction,
  { debugPath = "raw_transaction" } = {}
) {
  return normalizeObject(debugPath, rawTransaction, {
    version: normalizeHexNumber(4),
    cell_deps: toNormalizeArray(toNormalize(NormalizeCellDep)),
    header_deps: toNormalizeArray(normalizeRawData(32)),
    inputs: toNormalizeArray(toNormalize(NormalizeCellInput)),
    outputs: toNormalizeArray(toNormalize(NormalizeCellOutput)),
    outputs_data: toNormalizeArray(normalizeRawData(-1)),
  });
}

export function NormalizeTransaction(
  transaction,
  { debugPath = "transaction" } = {}
) {
  const rawTransaction = NormalizeRawTransaction(transaction, {
    debugPath: `(raw)${debugPath}`,
  });
  const result = normalizeObject(debugPath, transaction, {
    witnesses: toNormalizeArray(normalizeRawData(-1)),
  });
  result.raw = rawTransaction;
  return result;
}

export function NormalizeRawHeader(
  rawHeader,
  { debugPath = "raw_header" } = {}
) {
  return normalizeObject(debugPath, rawHeader, {
    version: normalizeHexNumber(4),
    compact_target: normalizeHexNumber(4),
    timestamp: normalizeHexNumber(8),
    number: normalizeHexNumber(8),
    epoch: normalizeHexNumber(8),
    parent_hash: normalizeRawData(32),
    transactions_root: normalizeRawData(32),
    proposals_hash: normalizeRawData(32),
    uncles_hash: normalizeRawData(32),
    dao: normalizeRawData(32),
  });
}

export function NormalizeHeader(header, { debugPath = "header" } = {}) {
  const rawHeader = NormalizeRawHeader(header, {
    debugPath: `(raw)${debugPath}`,
  });
  const result = normalizeObject(debugPath, header, {
    nonce: normalizeHexNumber(16),
  });
  result.raw = rawHeader;
  return result;
}

export function NormalizeUncleBlock(
  uncleBlock,
  { debugPath = "uncle_block" } = {}
) {
  return normalizeObject(debugPath, uncleBlock, {
    header: toNormalize(NormalizeHeader),
    proposals: toNormalizeArray(normalizeRawData(10)),
  });
}

export function NormalizeBlock(block, { debugPath = "block" } = {}) {
  return normalizeObject(debugPath, block, {
    header: toNormalize(NormalizeHeader),
    uncles: toNormalizeArray(toNormalize(NormalizeUncleBlock)),
    transactions: toNormalizeArray(toNormalize(NormalizeTransaction)),
    proposals: toNormalizeArray(normalizeRawData(10)),
  });
}

export function NormalizeCellbaseWitness(
  cellbaseWitness,
  { debugPath = "cellbase_witness" } = {}
) {
  return normalizeObject(debugPath, cellbaseWitness, {
    lock: toNormalize(NormalizeScript),
    message: normalizeRawData(-1),
  });
}

export function NormalizeWitnessArgs(
  witnessArgs,
  { debugPath = "witness_args" } = {}
) {
  const result = {};
  if (witnessArgs.lock) {
    result.lock = normalizeRawData(-1)(`${debugPath}.lock`, witnessArgs.lock);
  }
  if (witnessArgs.input_type) {
    result.input_type = normalizeRawData(-1)(
      `${debugPath}.input_type`,
      witnessArgs.input_type
    );
  }
  if (witnessArgs.output_type) {
    result.output_type = normalizeRawData(-1)(
      `${debugPath}.output_type`,
      witnessArgs.output_type
    );
  }
  return result;
}

'''
'''--- packages/toolkit/src/reader.js ---
class BaseReader {
  constructor() {
    /**
     * instanceof would be nice here, but when a user use multi version of Reader that may cause problem
     * @example
     * const { Reader } = require('ckb-js-toolkit'); // ckb-js-toolkit@0.100.1
     * const { readSomething } = require('other-serializer-lib'); // dependent on ckb-js-toolkit@0.100.0
     *
     * readSomething() instanceof Reader; // false
     *
     * @type {boolean}
     * @protected
     */
    this.__isByteLikeReader__ = true;
  }

  static isReader(x) {
    if (x == null) return false;
    if (x instanceof BaseReader) return true;
    return x.__isByteLikeReader__ === true;
  }
}

class ArrayBufferReader extends BaseReader {
  constructor(buffer) {
    super();
    this.view = new DataView(buffer);
  }

  length() {
    return this.view.byteLength;
  }

  indexAt(i) {
    return this.view.getUint8(i);
  }

  toArrayBuffer() {
    return this.view.buffer;
  }

  serializeJson() {
    return (
      "0x" +
      Array.prototype.map
        .call(new Uint8Array(this.view.buffer), (x) =>
          ("00" + x.toString(16)).slice(-2)
        )
        .join("")
    );
  }
}

class HexStringReader extends BaseReader {
  constructor(string) {
    super();
    this.string = string;
  }

  length() {
    return this.string.length / 2 - 1;
  }

  indexAt(i) {
    return parseInt(this.string.substr(2 + i * 2, 2), 16);
  }

  toArrayBuffer() {
    const buffer = new ArrayBuffer(this.length());
    const view = new DataView(buffer);

    for (let i = 0; i < this.length(); i++) {
      view.setUint8(i, this.indexAt(i));
    }
    return buffer;
  }

  serializeJson() {
    return this.string;
  }
}

export class Reader extends BaseReader {
  constructor(input) {
    super();
    if (
      input instanceof HexStringReader ||
      input instanceof ArrayBufferReader
    ) {
      return input;
    }
    if (typeof input === "string") {
      if (!input.startsWith("0x") || input.length % 2 !== 0) {
        throw new Error(
          "Hex string must start with 0x, and has even numbered length!"
        );
      }
      return new HexStringReader(input);
    }
    if (input instanceof ArrayBuffer) {
      return new ArrayBufferReader(input);
    }
    if (input instanceof Uint8Array) {
      return new ArrayBufferReader(Uint8Array.from(input).buffer);
    }
    throw new Error("Reader can only accept hex string or ArrayBuffer!");
  }

  static from(x) {
    return new Reader(x);
  }

  static fromRawString(string) {
    const buffer = new ArrayBuffer(string.length);
    const view = new DataView(buffer);

    for (let i = 0; i < string.length; i++) {
      const c = string.charCodeAt(i);
      if (c > 0xff) {
        throw new Error("fromRawString can only accept UTF-8 raw string!");
      }
      view.setUint8(i, c);
    }
    return new ArrayBufferReader(buffer);
  }
}

'''
'''--- packages/toolkit/src/rpc.js ---
import fetch from "cross-fetch";
import JSBI from "jsbi";

function mergeOptions(overrideOptions, defaultOptions) {
  defaultOptions = defaultOptions || {};
  const headers = Object.assign(
    {},
    defaultOptions.headers || {},
    overrideOptions.headers || {}
  );
  return Object.assign({}, defaultOptions, overrideOptions, {
    headers: headers,
  });
}

const batchHandler = {
  get: (target, method, receiver) => {
    if (method === "send") {
      return async () => {
        const response = await fetch(
          target.uri,
          mergeOptions(
            {
              method: "post",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(target.payload),
            },
            target.defaultOptions
          )
        );
        return await response.json();
      };
    }
    return (...params) => {
      const id = target.id;
      target.id = target.id + 1;
      target.payload.push({
        jsonrpc: "2.0",
        id: id,
        method: method,
        params: params,
      });
      return receiver;
    };
  },
};

const handler = {
  get: (target, method) => {
    if (method === "batch") {
      return () => {
        return new Proxy(
          {
            id: Math.round(Math.random() * 10000000),
            payload: [],
            uri: target.uri,
            defaultOptions: target.defaultOptions,
          },
          batchHandler
        );
      };
    }
    return async (...params) => {
      const id = Math.round(Math.random() * 10000000);
      const response = await fetch(
        target.uri,
        mergeOptions(
          {
            method: "post",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              jsonrpc: "2.0",
              id: id,
              method: method,
              params: params,
            }),
          },
          target.defaultOptions
        )
      );
      const data = await response.json();
      if (data.id !== id) {
        throw new Error("JSONRPCError: response ID does not match request ID!");
      }
      if (data.error) {
        throw new Error(
          `JSONRPCError: server error ${JSON.stringify(data.error)}`
        );
      }
      return data.result;
    };
  },
};

export class RPC {
  constructor(uri, defaultOptions = {}) {
    this.uri = uri;
    this.defaultOptions = defaultOptions;
    return new Proxy(this, handler);
  }

  static create(uri) {
    return new RPC(uri);
  }
}

export function HexStringToBigInt(hexString) {
  return JSBI.BigInt(hexString);
}

export function BigIntToHexString(bigInt) {
  return "0x" + bigInt.toString(16);
}

'''
'''--- packages/toolkit/src/transaction_dumper.js ---
import JSBI from "jsbi";
import { Reader } from "./reader";
import { ValidateTransaction, ValidateOutPoint } from "./validators";

export class TransactionDumper {
  constructor(
    rpc,
    { validateTransaction = true, depGroupUnpacker = null } = {}
  ) {
    this.rpc = rpc;
    this.validateTransaction = validateTransaction;
    this.depGroupUnpacker = depGroupUnpacker;
  }

  async dumpByHash(txHash) {
    const tx = (await this.rpc.get_transaction(txHash)).transaction;
    delete tx.hash;
    return await this.dump(tx);
  }

  async dump(tx) {
    if (this.validateTransaction) {
      ValidateTransaction(tx);
    }
    const mockInputs = [];
    for (const input of tx.inputs) {
      const { output, data, header } = await this._resolveOutPoint(
        input.previous_output
      );
      mockInputs.push({ input, output, data, header });
    }
    const mockCellDeps = [];
    for (const cellDep of tx.cell_deps) {
      const { output, data, header } = await this._resolveOutPoint(
        cellDep.out_point
      );
      mockCellDeps.push({
        cell_dep: cellDep,
        output,
        data,
        header,
      });
      if (cellDep.dep_type === "dep_group") {
        if (!this.depGroupUnpacker) {
          throw new Error(
            "depGroupUnpacker must be provided when the transaction contains dep_group!"
          );
        }
        const outPoints = this.depGroupUnpacker(new Reader(data));
        for (const outPoint of outPoints) {
          ValidateOutPoint(outPoint);
          const { output, data, header } = await this._resolveOutPoint(
            outPoint
          );
          mockCellDeps.push({
            cell_dep: {
              out_point: outPoint,
              dep_type: "code",
            },
            output,
            data,
            header,
          });
        }
      }
    }
    const mockHeaderDeps = [];
    for (const headerDep of tx.header_deps) {
      mockHeaderDeps.push(await this.rpc.get_header(headerDep));
    }
    return JSON.stringify({
      mock_info: {
        inputs: mockInputs,
        cell_deps: mockCellDeps,
        header_deps: mockHeaderDeps,
      },
      tx,
    });
  }

  async _resolveOutPoint(out_point) {
    const txStatus = await this.rpc.get_transaction(out_point.tx_hash);
    if (!txStatus || !txStatus.transaction) {
      throw new Error(`Transaction ${out_point.tx_hash} cannot be found!`);
    }
    const tx = txStatus.transaction;
    const index = JSBI.toNumber(JSBI.BigInt(out_point.index));
    if (index >= tx.outputs.length) {
      throw new Error(
        `Transaction ${out_point.tx_hash} does not have output ${index}!`
      );
    }
    const data = {
      output: tx.outputs[index],
      data: tx.outputs_data[index],
    };
    if (txStatus.tx_status.status === "committed") {
      data.header = txStatus.tx_status.block_hash;
    }
    return data;
  }
}

'''
'''--- packages/toolkit/src/transformers.js ---
// This package provides transformer functions that transform JavaScript objects
// into JSON ready objects that can be passed to RPC. It following the following
// rules:
//
// 1. If the specified object has a serializeJson method, it would invoke this
// method and use the result to replace current object.
// 2. It then restricts the keys of the object to keys required by the specified
// entity(i.e., a Script would only have code_hash, hash_type, args keys),for each
// sub-field, it then recursively perform the steps here from step 1.
// 3. It then optionally run validator functions to ensure the resulting object
// follows specified rules.
//
// Note rule 1 here provides the flexibility in defining your own structures: you
// could define a class containing custom data structures, then provide a
// serializeJson that transforms the custom one into the rigid data structure
// required by CKB. You can also leverage the Reader class we provide as much as
// possible. Since Reader class does provide serializeJson methods, transformers
// here will transform them to valid hex strings required by CKB.
import * as validators from "./validators";

function invokeSerializeJson(debugPath, value) {
  if (value instanceof Object && value.serializeJson instanceof Function) {
    return value.serializeJson.call(value);
  }
  return value;
}

function transformObject(debugPath, object, keys) {
  object = invokeSerializeJson(debugPath, object);
  if (!(object instanceof Object)) {
    throw new Error(`Transformed ${debugPath} is not an object!`);
  }
  const result = {};

  for (const [key, f] of Object.entries(keys)) {
    let value = object[key];
    if (!value) {
      const camelKey = key.replace(/(_[a-z])/g, (group) =>
        group.toUpperCase().replace("_", "")
      );
      value = object[camelKey];
    }
    if (value) {
      result[key] = f(`${debugPath}.${key}`, value);
    }
  }
  return result;
}

export function TransformScript(
  script,
  { validation = true, debugPath = "script" } = {}
) {
  script = transformObject(debugPath, script, {
    code_hash: invokeSerializeJson,
    hash_type: invokeSerializeJson,
    args: invokeSerializeJson,
  });

  if (validation) {
    validators.ValidateScript(script, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return script;
}

export function TransformOutPoint(
  outPoint,
  { validation = true, debugPath = "out_point" } = {}
) {
  outPoint = transformObject(debugPath, outPoint, {
    tx_hash: invokeSerializeJson,
    index: invokeSerializeJson,
  });

  if (validation) {
    validators.ValidateOutPoint(outPoint, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return outPoint;
}

function toInvoke(transform) {
  return function (debugPath, value) {
    return transform(value, {
      validation: false,
      debugPath,
    });
  };
}

export function TransformCellInput(
  cellInput,
  { validation = true, debugPath = "cell_input" } = {}
) {
  cellInput = transformObject(debugPath, cellInput, {
    since: invokeSerializeJson,
    previous_output: toInvoke(TransformOutPoint),
  });

  if (validation) {
    validators.ValidateCellInput(cellInput, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return cellInput;
}

export function TransformCellOutput(
  cellOutput,
  { validation = true, debugPath = "cell_output" } = {}
) {
  cellOutput = transformObject(debugPath, cellOutput, {
    capacity: invokeSerializeJson,
    lock: toInvoke(TransformScript),
    type: toInvoke(TransformScript),
  });

  if (validation) {
    validators.ValidateCellOutput(cellOutput, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return cellOutput;
}

export function TransformCellDep(
  cellDep,
  { validation = true, debugPath = "cell_dep" } = {}
) {
  cellDep = transformObject(debugPath, cellDep, {
    out_point: toInvoke(TransformOutPoint),
    dep_type: invokeSerializeJson,
  });

  if (validation) {
    validators.ValidateCellDep(cellDep, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return cellDep;
}

function toInvokeArray(invokeFunction) {
  return function (debugPath, array) {
    return array.map((item, i) => {
      return invokeFunction(`${debugPath}[${i}]`, item);
    });
  };
}

export function TransformRawTransaction(
  rawTransaction,
  { validation = true, debugPath = "raw_transaction" } = {}
) {
  rawTransaction = transformObject(debugPath, rawTransaction, {
    version: invokeSerializeJson,
    cell_deps: toInvokeArray(toInvoke(TransformCellDep)),
    header_deps: toInvokeArray(invokeSerializeJson),
    inputs: toInvokeArray(toInvoke(TransformCellInput)),
    outputs: toInvokeArray(toInvoke(TransformCellOutput)),
    outputs_data: toInvokeArray(invokeSerializeJson),
  });

  if (validation) {
    validators.ValidateRawTransaction(rawTransaction, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return rawTransaction;
}

export function TransformTransaction(
  transaction,
  { validation = true, debugPath = "transaction" } = {}
) {
  transaction = transformObject(debugPath, transaction, {
    version: invokeSerializeJson,
    cell_deps: toInvokeArray(toInvoke(TransformCellDep)),
    header_deps: toInvokeArray(invokeSerializeJson),
    inputs: toInvokeArray(toInvoke(TransformCellInput)),
    outputs: toInvokeArray(toInvoke(TransformCellOutput)),
    outputs_data: toInvokeArray(invokeSerializeJson),
    witnesses: toInvokeArray(invokeSerializeJson),
  });

  if (validation) {
    validators.ValidateTransaction(transaction, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return transaction;
}

export function TransformRawHeader(
  rawHeader,
  { validation = true, debugPath = "raw_header" } = {}
) {
  rawHeader = transformObject(debugPath, rawHeader, {
    version: invokeSerializeJson,
    compact_target: invokeSerializeJson,
    timestamp: invokeSerializeJson,
    number: invokeSerializeJson,
    epoch: invokeSerializeJson,
    parent_hash: invokeSerializeJson,
    transactions_root: invokeSerializeJson,
    proposals_hash: invokeSerializeJson,
    uncles_hash: invokeSerializeJson,
    dao: invokeSerializeJson,
  });

  if (validation) {
    validators.ValidateRawHeader(rawHeader, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return rawHeader;
}

export function TransformHeader(
  header,
  { validation = true, debugPath = "header" } = {}
) {
  header = transformObject(debugPath, header, {
    version: invokeSerializeJson,
    compact_target: invokeSerializeJson,
    timestamp: invokeSerializeJson,
    number: invokeSerializeJson,
    epoch: invokeSerializeJson,
    parent_hash: invokeSerializeJson,
    transactions_root: invokeSerializeJson,
    proposals_hash: invokeSerializeJson,
    uncles_hash: invokeSerializeJson,
    dao: invokeSerializeJson,
    nonce: invokeSerializeJson,
  });

  if (validation) {
    validators.ValidateHeader(header, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return header;
}

export function TransformUncleBlock(
  uncleBlock,
  { validation = true, debugPath = "uncle_block" } = {}
) {
  uncleBlock = transformObject(debugPath, uncleBlock, {
    header: toInvoke(TransformHeader),
    proposals: toInvokeArray(invokeSerializeJson),
  });

  if (validation) {
    validators.ValidateUncleBlock(uncleBlock, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return uncleBlock;
}

export function TransformBlock(
  block,
  { validation = true, debugPath = "block" } = {}
) {
  block = transformObject(debugPath, block, {
    header: toInvoke(TransformHeader),
    uncles: toInvokeArray(toInvoke(TransformUncleBlock)),
    transactions: toInvokeArray(toInvoke(TransformTransaction)),
    proposals: toInvokeArray(invokeSerializeJson),
  });

  if (validation) {
    validators.ValidateBlock(block, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return block;
}

export function TransformCellbaseWitness(
  cellbaseWitness,
  { validation = true, debugPath = "cellbase_witness" } = {}
) {
  cellbaseWitness = transformObject(debugPath, cellbaseWitness, {
    lock: toInvoke(TransformScript),
    message: invokeSerializeJson,
  });

  if (validation) {
    validators.ValidateCellbaseWitness(cellbaseWitness, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return cellbaseWitness;
}

export function TransformWitnessArgs(
  witnessArgs,
  { validation = true, debugPath = "witness_args" } = {}
) {
  witnessArgs = transformObject(debugPath, witnessArgs, {
    lock: invokeSerializeJson,
    input_type: invokeSerializeJson,
    output_type: invokeSerializeJson,
  });

  if (validation) {
    validators.ValidateWitnessArgs(witnessArgs, {
      debugPath: `(transformed) ${debugPath}`,
    });
  }
  return witnessArgs;
}

'''
'''--- packages/toolkit/src/validators.js ---
/* eslint-disable @typescript-eslint/no-unused-vars */
// This package provides validator functions that check JSON objects are
// following the correct format, so we can submit them to CKB via RPC
// directly

function assertObject(debugPath, object) {
  if (!(object instanceof Object)) {
    throw new Error(`${debugPath} is not an object!`);
  }
}

function assertObjectWithKeys(
  debugPath,
  object,
  expectedKeys,
  optionalKeys = []
) {
  assertObject(debugPath, object);
  const providedKeys = Object.keys(object).sort();
  const requiredLength = expectedKeys.length;
  const maximalLength = expectedKeys.length + optionalKeys.length;
  const errorMessage = `${debugPath} does not have correct keys! Required keys: [${expectedKeys
    .sort()
    .join(", ")}], optional keys: [${optionalKeys
    .sort()
    .join(", ")}], actual keys: [${providedKeys.join(", ")}]`;
  if (
    providedKeys.length < requiredLength ||
    providedKeys.length > maximalLength
  ) {
    throw new Error(errorMessage);
  }
  let optionalProvidedKeys = providedKeys.filter(
    (key) => !expectedKeys.includes(key)
  );
  if (providedKeys.length - optionalProvidedKeys.length !== requiredLength) {
    throw new Error(errorMessage);
  }
  if (optionalProvidedKeys.find((key) => !optionalKeys.includes(key))) {
    throw new Error(errorMessage);
  }
}

function assertHexString(debugPath, string) {
  if (!/^0x([0-9a-fA-F][0-9a-fA-F])*$/.test(string)) {
    throw new Error(`${debugPath} must be a hex string!`);
  }
}

function assertHash(debugPath, hash) {
  assertHexString(debugPath, hash);
  if (hash.length !== 66) {
    throw new Error(`${debugPath} must be a hex string of 66 bytes long!`);
  }
}

function assertInteger(debugPath, i) {
  if (i === "0x0") {
    return;
  }
  if (!/^0x[1-9a-fA-F][0-9a-fA-F]*$/.test(i)) {
    throw new Error(`${debugPath} must be a hex integer!`);
  }
}

export function ValidateScript(
  script,
  { nestedValidation = true, debugPath = "script" } = {}
) {
  assertObjectWithKeys(
    debugPath,
    script,
    ["code_hash", "hash_type", "args"],
    []
  );
  assertHash(`${debugPath}.code_hash`, script.code_hash);
  assertHexString(`${debugPath}.args`, script.args);

  if (script.hash_type !== "data" && script.hash_type !== "type") {
    throw new Error(`${debugPath}.hash_type must be either data or type!`);
  }
}

export function ValidateOutPoint(
  outPoint,
  { nestedValidation = true, debugPath = "out_point" } = {}
) {
  assertObjectWithKeys(debugPath, outPoint, ["tx_hash", "index"], []);
  assertHash(`${debugPath}.tx_hash`, outPoint.tx_hash);
  assertInteger(`${debugPath}.index`, outPoint.index);
}

export function ValidateCellInput(
  cellInput,
  { nestedValidation = true, debugPath = "cell_input" } = {}
) {
  assertObjectWithKeys(debugPath, cellInput, ["since", "previous_output"], []);
  assertInteger(`${debugPath}.since`, cellInput.since);

  if (nestedValidation) {
    ValidateOutPoint(cellInput.previous_output, {
      debugPath: `${debugPath}.previous_output`,
    });
  }
}

export function ValidateCellOutput(
  cellOutput,
  { nestedValidation = true, debugPath = "cell_output" } = {}
) {
  assertObjectWithKeys(debugPath, cellOutput, ["capacity", "lock"], ["type"]);
  assertInteger(`${debugPath}.capacity`, cellOutput.capacity);

  if (nestedValidation) {
    ValidateScript(cellOutput.lock, {
      debugPath: `${debugPath}.lock`,
    });
    if (cellOutput.type) {
      ValidateScript(cellOutput.type, {
        debugPath: `${debugPath}.type`,
      });
    }
  }
}

export function ValidateCellDep(
  cellDep,
  { nestedValidation = true, debugPath = "cell_dep" } = {}
) {
  assertObjectWithKeys(debugPath, cellDep, ["out_point", "dep_type"], []);
  if (cellDep.dep_type !== "code" && cellDep.dep_type !== "dep_group") {
    throw new Error(`${debugPath}.dep_type must be either code or dep_group!`);
  }

  if (nestedValidation) {
    ValidateOutPoint(cellDep.out_point, {
      debugPath: `${debugPath}.out_point`,
    });
  }
}

function assertArray(debugPath, array, validateFunction, nestedValidation) {
  if (!Array.isArray(array)) {
    throw new Error(`${debugPath} is not an array!`);
  }
  if (nestedValidation) {
    for (let i = 0; i < array.length; i++) {
      validateFunction(`${debugPath}[${i}]`, array[i]);
    }
  }
}

function toAssert(validateFunction, nestedValidation) {
  return function (debugPath, value) {
    validateFunction(value, {
      nestedValidation: nestedValidation,
      debugPath: debugPath,
    });
  };
}

function assertCommonTransaction(debugPath, rawTransaction, nestedValidation) {
  assertInteger(`${debugPath}.version`, rawTransaction.version);
  assertArray(
    `${debugPath}.cell_deps`,
    rawTransaction.cell_deps,
    toAssert(ValidateCellDep, nestedValidation),
    nestedValidation
  );
  assertArray(
    `${debugPath}.header_deps`,
    rawTransaction.header_deps,
    assertHash,
    nestedValidation
  );
  assertArray(
    `${debugPath}.inputs`,
    rawTransaction.inputs,
    toAssert(ValidateCellInput, nestedValidation),
    nestedValidation
  );
  assertArray(
    `${debugPath}.outputs`,
    rawTransaction.outputs,
    toAssert(ValidateCellOutput, nestedValidation),
    nestedValidation
  );
  assertArray(
    `${debugPath}.outputs_data`,
    rawTransaction.outputs_data,
    assertHexString,
    nestedValidation
  );
}

export function ValidateRawTransaction(
  rawTransaction,
  { nestedValidation = true, debugPath = "raw_transaction" } = {}
) {
  assertObjectWithKeys(
    debugPath,
    rawTransaction,
    [
      "version",
      "cell_deps",
      "header_deps",
      "inputs",
      "outputs",
      "outputs_data",
    ],
    []
  );
  assertCommonTransaction(debugPath, rawTransaction, nestedValidation);
}

export function ValidateTransaction(
  transaction,
  { nestedValidation = true, debugPath = "transaction" } = {}
) {
  assertObjectWithKeys(
    debugPath,
    transaction,
    [
      "version",
      "cell_deps",
      "header_deps",
      "inputs",
      "outputs",
      "outputs_data",
      "witnesses",
    ],
    []
  );
  assertCommonTransaction(debugPath, transaction, nestedValidation);
  assertArray(
    `${debugPath}.witnesses`,
    transaction.witnesses,
    assertHexString,
    nestedValidation
  );
}

function assertCommonHeader(debugPath, rawHeader) {
  assertInteger(`${debugPath}.version`, rawHeader.version);
  assertInteger(`${debugPath}.compact_target`, rawHeader.compact_target);
  assertInteger(`${debugPath}.timestamp`, rawHeader.timestamp);
  assertInteger(`${debugPath}.number`, rawHeader.number);
  assertInteger(`${debugPath}.epoch`, rawHeader.epoch);
  assertHash(`${debugPath}.parent_hash`, rawHeader.parent_hash);
  assertHash(`${debugPath}.transactions_root`, rawHeader.transactions_root);
  assertHash(`${debugPath}.proposals_hash`, rawHeader.proposals_hash);
  assertHash(`${debugPath}.uncles_hash`, rawHeader.uncles_hash);
  assertHash(`${debugPath}.dao`, rawHeader.dao);
}

export function ValidateRawHeader(
  rawHeader,
  { nestedValidation = true, debugPath = "raw_header" } = {}
) {
  assertObjectWithKeys(
    debugPath,
    rawHeader,
    [
      "version",
      "compact_target",
      "timestamp",
      "number",
      "epoch",
      "parent_hash",
      "transactions_root",
      "proposals_hash",
      "uncles_hash",
      "dao",
    ],
    []
  );
  assertCommonHeader(debugPath, rawHeader);
}

export function ValidateHeader(
  header,
  { nestedValidation = true, debugPath = "header" } = {}
) {
  assertObjectWithKeys(
    debugPath,
    header,
    [
      "version",
      "compact_target",
      "timestamp",
      "number",
      "epoch",
      "parent_hash",
      "transactions_root",
      "proposals_hash",
      "uncles_hash",
      "dao",
      "nonce",
    ],
    []
  );
  assertHexString(`${debugPath}.nonce`, header.nonce);
  if (header.nonce.length !== 34) {
    throw new Error(
      `${debugPath}.nonce must be a hex string of 34 bytes long!`
    );
  }
}

function assertProposalShortId(debugPath, shortId) {
  assertHexString(debugPath, shortId);
  if (shortId.length !== 22) {
    throw new Error(`${debugPath} must be a hex string of 22 bytes long!`);
  }
}

export function ValidateUncleBlock(
  uncleBlock,
  { nestedValidation = true, debugPath = "uncle_block" } = {}
) {
  assertObjectWithKeys(debugPath, uncleBlock, ["header", "proposals"], []);

  if (nestedValidation) {
    ValidateHeader(uncleBlock.header, {
      debugPath: `${debugPath}.header`,
    });
  }
  assertArray(
    `${debugPath}.proposals`,
    uncleBlock.proposals,
    assertProposalShortId,
    nestedValidation
  );
}

export function ValidateBlock(
  block,
  { nestedValidation = true, debugPath = "block" } = {}
) {
  assertObjectWithKeys(
    debugPath,
    block,
    ["header", "uncles", "transactions", "proposals"],
    []
  );

  if (nestedValidation) {
    ValidateHeader(block.header, {
      debugPath: `${debugPath}.header`,
    });
  }
  assertArray(
    `${debugPath}.uncles`,
    block.uncles,
    toAssert(ValidateUncleBlock, nestedValidation),
    nestedValidation
  );
  assertArray(
    `${debugPath}.transactions`,
    block.transactions,
    toAssert(ValidateTransaction, nestedValidation),
    nestedValidation
  );
  assertArray(
    `${debugPath}.proposals`,
    block.proposals,
    assertProposalShortId,
    nestedValidation
  );
}

export function ValidateCellbaseWitness(
  cellbaseWitness,
  { nestedValidation = true, debugPath = "cellbase_witness" } = {}
) {
  assertObjectWithKeys(debugPath, cellbaseWitness, ["lock", "message"], []);
  assertHexString(`${debugPath}.message`, cellbaseWitness.message);

  if (nestedValidation) {
    ValidateScript(cellbaseWitness.lock, {
      debugPath: `${debugPath}.lock`,
    });
  }
}

export function ValidateWitnessArgs(
  witnessArgs,
  { nestedValidation = true, debugPath = "witness_args" } = {}
) {
  assertObjectWithKeys(
    debugPath,
    witnessArgs,
    [],
    ["lock", "input_type", "output_type"]
  );

  if (witnessArgs.lock) {
    assertHexString(`${debugPath}.lock`, witnessArgs.lock);
  }
  if (witnessArgs.input_type) {
    assertHexString(`${debugPath}.input_type`, witnessArgs.input_type);
  }
  if (witnessArgs.output_type) {
    assertHexString(`${debugPath}.output_type`, witnessArgs.output_type);
  }
}

'''
'''--- packages/toolkit/testfiles/blockchain.umd.js ---
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.Blockchain = {}));
}(this, (function (exports) { 'use strict';

  function dataLengthError(actual, required) {
      throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);
  }

  function assertDataLength(actual, required) {
    if (actual !== required) {
      dataLengthError(actual, required);
    }
  }

  function assertArrayBuffer(reader) {
    if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {
      reader = reader.toArrayBuffer();
    }
    if (!(reader instanceof ArrayBuffer)) {
      throw new Error("Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!");
    }
    return reader;
  }

  function verifyAndExtractOffsets(view, expectedFieldCount, compatible) {
    if (view.byteLength < 4) {
      dataLengthError(view.byteLength, ">4");
    }
    const requiredByteLength = view.getUint32(0, true);
    assertDataLength(view.byteLength, requiredByteLength);
    if (requiredByteLength === 4) {
      return [requiredByteLength];
    }
    if (requiredByteLength < 8) {
      dataLengthError(view.byteLength, ">8");
    }
    const firstOffset = view.getUint32(4, true);
    if (firstOffset % 4 !== 0 || firstOffset < 8) {
      throw new Error(`Invalid first offset: ${firstOffset}`);
    }
    const itemCount = firstOffset / 4 - 1;
    if (itemCount < expectedFieldCount) {
      throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);
    } else if ((!compatible) && itemCount > expectedFieldCount) {
      throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);
    }
    if (requiredByteLength < firstOffset) {
      throw new Error(`First offset is larger than byte length: ${firstOffset}`);
    }
    const offsets = [];
    for (let i = 0; i < itemCount; i++) {
      const start = 4 + i * 4;
      offsets.push(view.getUint32(start, true));
    }
    offsets.push(requiredByteLength);
    for (let i = 0; i < offsets.length - 1; i++) {
      if (offsets[i] > offsets[i + 1]) {
        throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);
      }
    }
    return offsets;
  }

  function serializeTable(buffers) {
    const itemCount = buffers.length;
    let totalSize = 4 * (itemCount + 1);
    const offsets = [];

    for (let i = 0; i < itemCount; i++) {
      offsets.push(totalSize);
      totalSize += buffers[i].byteLength;
    }

    const buffer = new ArrayBuffer(totalSize);
    const array = new Uint8Array(buffer);
    const view = new DataView(buffer);

    view.setUint32(0, totalSize, true);
    for (let i = 0; i < itemCount; i++) {
      view.setUint32(4 + i * 4, offsets[i], true);
      array.set(new Uint8Array(buffers[i]), offsets[i]);
    }
    return buffer;
  }
  class Uint32 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 4);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    toBigEndianUint32() {
      return this.view.getUint32(0, false);
    }

    toLittleEndianUint32() {
      return this.view.getUint32(0, true);
    }

    static size() {
      return 4;
    }
  }

  function SerializeUint32(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 4);
    return buffer;
  }

  class Uint64 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 8);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    toBigEndianBigUint64() {
      return this.view.getBigUint64(0, false);
    }

    toLittleEndianBigUint64() {
      return this.view.getUint64(0, true);
    }

    static size() {
      return 8;
    }
  }

  function SerializeUint64(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 8);
    return buffer;
  }

  class Uint128 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 16);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    static size() {
      return 16;
    }
  }

  function SerializeUint128(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 16);
    return buffer;
  }

  class Byte32 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 32);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    static size() {
      return 32;
    }
  }

  function SerializeByte32(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 32);
    return buffer;
  }

  class Uint256 {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 32);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    static size() {
      return 32;
    }
  }

  function SerializeUint256(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 32);
    return buffer;
  }

  class Bytes {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
    }

    raw() {
      return this.view.buffer.slice(4);
    }

    indexAt(i) {
      return this.view.getUint8(4 + i);
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeBytes(value) {
    const item = assertArrayBuffer(value);
    const array = new Uint8Array(4 + item.byteLength);
    (new DataView(array.buffer)).setUint32(0, item.byteLength, true);
    array.set(new Uint8Array(item), 4);
    return array.buffer;
  }

  class BytesOpt {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.hasValue()) {
        this.value().validate(compatible);
      }
    }

    value() {
      return new Bytes(this.view.buffer, { validate: false });
    }

    hasValue() {
      return this.view.byteLength > 0;
    }
  }

  function SerializeBytesOpt(value) {
    if (value) {
      return SerializeBytes(value);
    } else {
      return new ArrayBuffer(0);
    }
  }

  class BytesVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      for (let i = 0; i < len(offsets) - 1; i++) {
        new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
      }
    }

    length() {
      if (this.view.byteLength < 8) {
        return 0;
      } else {
        return this.view.getUint32(4, true) / 4 - 1;
      }
    }

    indexAt(i) {
      const start = 4 + i * 4;
      const offset = this.view.getUint32(start, true);
      let offset_end = this.view.byteLength;
      if (i + 1 < this.length()) {
        offset_end = this.view.getUint32(start + 4, true);
      }
      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeBytesVec(value) {
    return serializeTable(value.map(item => SerializeBytes(item)));
  }

  class Byte32Vec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() * Byte32.size() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
      for (let i = 0; i < 0; i++) {
        const item = this.indexAt(i);
        item.validate(compatible);
      }
    }

    indexAt(i) {
      return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeByte32Vec(value) {
    const array = new Uint8Array(4 + Byte32.size() * value.length);
    (new DataView(array.buffer)).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
      const itemBuffer = SerializeByte32(value[i]);
      array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());
    }
    return array.buffer;
  }

  class ScriptOpt {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.hasValue()) {
        this.value().validate(compatible);
      }
    }

    value() {
      return new Script(this.view.buffer, { validate: false });
    }

    hasValue() {
      return this.view.byteLength > 0;
    }
  }

  function SerializeScriptOpt(value) {
    if (value) {
      return SerializeScript(value);
    } else {
      return new ArrayBuffer(0);
    }
  }

  class ProposalShortId {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, 10);
    }

    indexAt(i) {
      return this.view.getUint8(i);
    }

    raw() {
      return this.view.buffer;
    }

    static size() {
      return 10;
    }
  }

  function SerializeProposalShortId(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 10);
    return buffer;
  }

  class UncleBlockVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      for (let i = 0; i < len(offsets) - 1; i++) {
        new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
      }
    }

    length() {
      if (this.view.byteLength < 8) {
        return 0;
      } else {
        return this.view.getUint32(4, true) / 4 - 1;
      }
    }

    indexAt(i) {
      const start = 4 + i * 4;
      const offset = this.view.getUint32(start, true);
      let offset_end = this.view.byteLength;
      if (i + 1 < this.length()) {
        offset_end = this.view.getUint32(start + 4, true);
      }
      return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeUncleBlockVec(value) {
    return serializeTable(value.map(item => SerializeUncleBlock(item)));
  }

  class TransactionVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      for (let i = 0; i < len(offsets) - 1; i++) {
        new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
      }
    }

    length() {
      if (this.view.byteLength < 8) {
        return 0;
      } else {
        return this.view.getUint32(4, true) / 4 - 1;
      }
    }

    indexAt(i) {
      const start = 4 + i * 4;
      const offset = this.view.getUint32(start, true);
      let offset_end = this.view.byteLength;
      if (i + 1 < this.length()) {
        offset_end = this.view.getUint32(start + 4, true);
      }
      return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeTransactionVec(value) {
    return serializeTable(value.map(item => SerializeTransaction(item)));
  }

  class ProposalShortIdVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() * ProposalShortId.size() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
      for (let i = 0; i < 0; i++) {
        const item = this.indexAt(i);
        item.validate(compatible);
      }
    }

    indexAt(i) {
      return new ProposalShortId(this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()), { validate: false });
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeProposalShortIdVec(value) {
    const array = new Uint8Array(4 + ProposalShortId.size() * value.length);
    (new DataView(array.buffer)).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
      const itemBuffer = SerializeProposalShortId(value[i]);
      array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());
    }
    return array.buffer;
  }

  class CellDepVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() * CellDep.size() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
      for (let i = 0; i < 0; i++) {
        const item = this.indexAt(i);
        item.validate(compatible);
      }
    }

    indexAt(i) {
      return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), { validate: false });
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeCellDepVec(value) {
    const array = new Uint8Array(4 + CellDep.size() * value.length);
    (new DataView(array.buffer)).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
      const itemBuffer = SerializeCellDep(value[i]);
      array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());
    }
    return array.buffer;
  }

  class CellInputVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      if (this.view.byteLength < 4) {
        dataLengthError(this.view.byteLength, ">4");
      }
      const requiredByteLength = this.length() * CellInput.size() + 4;
      assertDataLength(this.view.byteLength, requiredByteLength);
      for (let i = 0; i < 0; i++) {
        const item = this.indexAt(i);
        item.validate(compatible);
      }
    }

    indexAt(i) {
      return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), { validate: false });
    }

    length() {
      return this.view.getUint32(0, true);
    }
  }

  function SerializeCellInputVec(value) {
    const array = new Uint8Array(4 + CellInput.size() * value.length);
    (new DataView(array.buffer)).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
      const itemBuffer = SerializeCellInput(value[i]);
      array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());
    }
    return array.buffer;
  }

  class CellOutputVec {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      for (let i = 0; i < len(offsets) - 1; i++) {
        new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
      }
    }

    length() {
      if (this.view.byteLength < 8) {
        return 0;
      } else {
        return this.view.getUint32(4, true) / 4 - 1;
      }
    }

    indexAt(i) {
      const start = 4 + i * 4;
      const offset = this.view.getUint32(start, true);
      let offset_end = this.view.byteLength;
      if (i + 1 < this.length()) {
        offset_end = this.view.getUint32(start + 4, true);
      }
      return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeCellOutputVec(value) {
    return serializeTable(value.map(item => SerializeCellOutput(item)));
  }

  class Script {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      if (offsets[2] - offsets[1] !== 1) {
        throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`)
      }
      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
    }

    getCodeHash() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getHashType() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);
    }

    getArgs() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeScript(value) {
    const buffers = [];
    buffers.push(SerializeByte32(value.code_hash));
    const hashTypeView = new DataView(new ArrayBuffer(1));
    hashTypeView.setUint8(0, value.hash_type);
    buffers.push(hashTypeView.buffer);
    buffers.push(SerializeBytes(value.args));
    return serializeTable(buffers);
  }

  class OutPoint {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getTxHash() {
      return new Byte32(this.view.buffer.slice(0, Byte32.size()), { validate: false });
    }

    getIndex() {
      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), Uint32.size()), { validate: false });
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, this.size());
      this.getTxHash().validate(compatible);
      this.getIndex().validate(compatible);
    }
    static size() {
      return 0 + Byte32.size() + Uint32.size();
    }
  }

  function SerializeOutPoint(value) {
    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());
    array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);
    array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());
    return array.buffer;
  }

  class CellInput {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getSince() {
      return new Uint64(this.view.buffer.slice(0, Uint64.size()), { validate: false });
    }

    getPreviousOutput() {
      return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), OutPoint.size()), { validate: false });
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, this.size());
      this.getSince().validate(compatible);
      this.getPreviousOutput().validate(compatible);
    }
    static size() {
      return 0 + Uint64.size() + OutPoint.size();
    }
  }

  function SerializeCellInput(value) {
    const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());
    array.set(new Uint8Array(SerializeUint64(value.since)), 0);
    array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());
    return array.buffer;
  }

  class CellOutput {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
      new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
    }

    getCapacity() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getLock() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getType() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeCellOutput(value) {
    const buffers = [];
    buffers.push(SerializeUint64(value.capacity));
    buffers.push(SerializeScript(value.lock));
    buffers.push(SerializeScriptOpt(value.type_));
    return serializeTable(buffers);
  }

  class CellDep {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getOutPoint() {
      return new OutPoint(this.view.buffer.slice(0, OutPoint.size()), { validate: false });
    }

    getDepType() {
      return this.view.getUint8(0 + OutPoint.size());
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, this.size());
      this.getOutPoint().validate(compatible);
    }
    static size() {
      return 0 + OutPoint.size() + 1;
    }
  }

  function SerializeCellDep(value) {
    const array = new Uint8Array(0 + OutPoint.size() + 1);
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);
    view.setUint8(0 + OutPoint.size(), value.dep_type);
    return array.buffer;
  }

  class RawTransaction {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
      new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
      new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();
      new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();
      new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();
    }

    getVersion() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getCellDeps() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getHeaderDeps() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getInputs() {
      const start = 16;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getOutputs() {
      const start = 20;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getOutputsData() {
      const start = 24;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeRawTransaction(value) {
    const buffers = [];
    buffers.push(SerializeUint32(value.version));
    buffers.push(SerializeCellDepVec(value.cell_deps));
    buffers.push(SerializeByte32Vec(value.header_deps));
    buffers.push(SerializeCellInputVec(value.inputs));
    buffers.push(SerializeCellOutputVec(value.outputs));
    buffers.push(SerializeBytesVec(value.outputs_data));
    return serializeTable(buffers);
  }

  class Transaction {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
    }

    getRaw() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getWitnesses() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeTransaction(value) {
    const buffers = [];
    buffers.push(SerializeRawTransaction(value.raw));
    buffers.push(SerializeBytesVec(value.witnesses));
    return serializeTable(buffers);
  }

  class RawHeader {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getVersion() {
      return new Uint32(this.view.buffer.slice(0, Uint32.size()), { validate: false });
    }

    getCompactTarget() {
      return new Uint32(this.view.buffer.slice(0 + Uint32.size(), Uint32.size()), { validate: false });
    }

    getTimestamp() {
      return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), Uint64.size()), { validate: false });
    }

    getNumber() {
      return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size(), Uint64.size()), { validate: false });
    }

    getEpoch() {
      return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(), Uint64.size()), { validate: false });
    }

    getParentHash() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(), Byte32.size()), { validate: false });
    }

    getTransactionsRoot() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(), Byte32.size()), { validate: false });
    }

    getProposalsHash() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(), Byte32.size()), { validate: false });
    }

    getUnclesHash() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size(), Byte32.size()), { validate: false });
    }

    getDao() {
      return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size(), Byte32.size()), { validate: false });
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, this.size());
      this.getVersion().validate(compatible);
      this.getCompactTarget().validate(compatible);
      this.getTimestamp().validate(compatible);
      this.getNumber().validate(compatible);
      this.getEpoch().validate(compatible);
      this.getParentHash().validate(compatible);
      this.getTransactionsRoot().validate(compatible);
      this.getProposalsHash().validate(compatible);
      this.getUnclesHash().validate(compatible);
      this.getDao().validate(compatible);
    }
    static size() {
      return 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size();
    }
  }

  function SerializeRawHeader(value) {
    const array = new Uint8Array(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());
    array.set(new Uint8Array(SerializeUint32(value.version)), 0);
    array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());
    array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());
    array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());
    array.set(new Uint8Array(SerializeUint64(value.epoch)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.parent_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.transactions_root)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.proposals_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.uncles_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.dao)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());
    return array.buffer;
  }

  class Header {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    getRaw() {
      return new RawHeader(this.view.buffer.slice(0, RawHeader.size()), { validate: false });
    }

    getNonce() {
      return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), Uint128.size()), { validate: false });
    }

    validate(compatible = false) {
      assertDataLength(this.view.byteLength, this.size());
      this.getRaw().validate(compatible);
      this.getNonce().validate(compatible);
    }
    static size() {
      return 0 + RawHeader.size() + Uint128.size();
    }
  }

  function SerializeHeader(value) {
    const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());
    array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);
    array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());
    return array.buffer;
  }

  class UncleBlock {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
    }

    getHeader() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getProposals() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeUncleBlock(value) {
    const buffers = [];
    buffers.push(SerializeHeader(value.header));
    buffers.push(SerializeProposalShortIdVec(value.proposals));
    return serializeTable(buffers);
  }

  class Block {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
      new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
      new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();
    }

    getHeader() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getUncles() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getTransactions() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getProposals() {
      const start = 16;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeBlock(value) {
    const buffers = [];
    buffers.push(SerializeHeader(value.header));
    buffers.push(SerializeUncleBlockVec(value.uncles));
    buffers.push(SerializeTransactionVec(value.transactions));
    buffers.push(SerializeProposalShortIdVec(value.proposals));
    return serializeTable(buffers);
  }

  class CellbaseWitness {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
    }

    getLock() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getMessage() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeCellbaseWitness(value) {
    const buffers = [];
    buffers.push(SerializeScript(value.lock));
    buffers.push(SerializeBytes(value.message));
    return serializeTable(buffers);
  }

  class WitnessArgs {
    constructor(reader, { validate = true } = {}) {
      this.view = new DataView(assertArrayBuffer(reader));
      if (validate) {
        this.validate();
      }
    }

    validate(compatible = false) {
      const offsets = verifyAndExtractOffsets(this.view, 0, true);
      new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();
      new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();
      new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();
    }

    getLock() {
      const start = 4;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getInputType() {
      const start = 8;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.getUint32(start + 4, true);
      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });
    }

    getOutputType() {
      const start = 12;
      const offset = this.view.getUint32(start, true);
      const offset_end = this.view.byteLength;
      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
  }

  function SerializeWitnessArgs(value) {
    const buffers = [];
    buffers.push(SerializeBytesOpt(value.lock));
    buffers.push(SerializeBytesOpt(value.input_type));
    buffers.push(SerializeBytesOpt(value.output_type));
    return serializeTable(buffers);
  }

  exports.Block = Block;
  exports.Byte32 = Byte32;
  exports.Byte32Vec = Byte32Vec;
  exports.Bytes = Bytes;
  exports.BytesOpt = BytesOpt;
  exports.BytesVec = BytesVec;
  exports.CellDep = CellDep;
  exports.CellDepVec = CellDepVec;
  exports.CellInput = CellInput;
  exports.CellInputVec = CellInputVec;
  exports.CellOutput = CellOutput;
  exports.CellOutputVec = CellOutputVec;
  exports.CellbaseWitness = CellbaseWitness;
  exports.Header = Header;
  exports.OutPoint = OutPoint;
  exports.ProposalShortId = ProposalShortId;
  exports.ProposalShortIdVec = ProposalShortIdVec;
  exports.RawHeader = RawHeader;
  exports.RawTransaction = RawTransaction;
  exports.Script = Script;
  exports.ScriptOpt = ScriptOpt;
  exports.SerializeBlock = SerializeBlock;
  exports.SerializeByte32 = SerializeByte32;
  exports.SerializeByte32Vec = SerializeByte32Vec;
  exports.SerializeBytes = SerializeBytes;
  exports.SerializeBytesOpt = SerializeBytesOpt;
  exports.SerializeBytesVec = SerializeBytesVec;
  exports.SerializeCellDep = SerializeCellDep;
  exports.SerializeCellDepVec = SerializeCellDepVec;
  exports.SerializeCellInput = SerializeCellInput;
  exports.SerializeCellInputVec = SerializeCellInputVec;
  exports.SerializeCellOutput = SerializeCellOutput;
  exports.SerializeCellOutputVec = SerializeCellOutputVec;
  exports.SerializeCellbaseWitness = SerializeCellbaseWitness;
  exports.SerializeHeader = SerializeHeader;
  exports.SerializeOutPoint = SerializeOutPoint;
  exports.SerializeProposalShortId = SerializeProposalShortId;
  exports.SerializeProposalShortIdVec = SerializeProposalShortIdVec;
  exports.SerializeRawHeader = SerializeRawHeader;
  exports.SerializeRawTransaction = SerializeRawTransaction;
  exports.SerializeScript = SerializeScript;
  exports.SerializeScriptOpt = SerializeScriptOpt;
  exports.SerializeTransaction = SerializeTransaction;
  exports.SerializeTransactionVec = SerializeTransactionVec;
  exports.SerializeUint128 = SerializeUint128;
  exports.SerializeUint256 = SerializeUint256;
  exports.SerializeUint32 = SerializeUint32;
  exports.SerializeUint64 = SerializeUint64;
  exports.SerializeUncleBlock = SerializeUncleBlock;
  exports.SerializeUncleBlockVec = SerializeUncleBlockVec;
  exports.SerializeWitnessArgs = SerializeWitnessArgs;
  exports.Transaction = Transaction;
  exports.TransactionVec = TransactionVec;
  exports.Uint128 = Uint128;
  exports.Uint256 = Uint256;
  exports.Uint32 = Uint32;
  exports.Uint64 = Uint64;
  exports.UncleBlock = UncleBlock;
  exports.UncleBlockVec = UncleBlockVec;
  exports.WitnessArgs = WitnessArgs;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

'''
'''--- packages/toolkit/tests/reader.js ---
const test = require("ava");
const { Reader } = require("../lib");

test("reader functions", (t) => {
  const ra = Reader.from("0x12345678");
  const rb = Reader.from(Uint8Array.from([0x12, 0x34, 0x56, 0x78]));
  const rc = Reader.from(Buffer.from("12345678", "hex"));
  const rd = Reader.from(Uint8Array.from([0x12, 0x34, 0x56, 0x78]).buffer);

  t.is(new DataView(ra.toArrayBuffer()).getUint32(0), 0x12345678);
  t.is(new DataView(rb.toArrayBuffer()).getUint32(0), 0x12345678);
  t.is(new DataView(rc.toArrayBuffer()).getUint32(0), 0x12345678);
  t.is(new DataView(rd.toArrayBuffer()).getUint32(0), 0x12345678);

  t.true(Reader.isReader(ra));
  t.true(Reader.isReader(rb));
  t.true(Reader.isReader(rc));
  t.true(Reader.isReader(rd));
});

'''
'''--- packages/toolkit/tests/serializers.js ---
const test = require("ava");
const { normalizers, Reader } = require("../lib");
const CKB = require("../testfiles/blockchain.umd.js");

test("normalize and serialize script", (t) => {
  const value = {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    args: "0xaabbccdd44332211",
    hash_type: "type",
  };
  const normalizedValue = normalizers.NormalizeScript(value);
  const serializedValue = CKB.SerializeScript(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x3d0000001000000030000000310000009bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce80108000000aabbccdd44332211"
  );
});

test("normalize and serialize script with integer hash type", (t) => {
  const value = {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    args: "0xaabbccdd44332211",
    hash_type: 1,
  };
  const normalizedValue = normalizers.NormalizeScript(value);
  const serializedValue = CKB.SerializeScript(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x3d0000001000000030000000310000009bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce80108000000aabbccdd44332211"
  );
});

test("normalize invalid script", (t) => {
  const value = {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    args: "0xaabbccdd4433221",
    hash_type: "type",
  };
  t.throws(() => {
    normalizers.NormalizeScript(value);
  });
});

test("normalize invalid script type", (t) => {
  const value = {
    code_hash:
      "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
    args: "0xaabbccdd44332211",
    hash_type: "invalidtype",
  };
  t.throws(() => {
    normalizers.NormalizeScript(value);
  });
});

test("normalize and serialize outpoint", (t) => {
  const value = {
    tx_hash:
      "0x4565f957aa65ca5d094ede05cbeaedcee70f5a71200ae2e31b643d2952c929bc",
    index: 3,
  };
  const normalizedValue = normalizers.NormalizeOutPoint(value);
  const serializedValue = CKB.SerializeOutPoint(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x4565f957aa65ca5d094ede05cbeaedcee70f5a71200ae2e31b643d2952c929bc03000000"
  );
});

test("normalize and serialize outpoint with hex number", (t) => {
  const value = {
    tx_hash:
      "0x4565f957aa65ca5d094ede05cbeaedcee70f5a71200ae2e31b643d2952c929bc",
    index: "0x3",
  };
  const normalizedValue = normalizers.NormalizeOutPoint(value);
  const serializedValue = CKB.SerializeOutPoint(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x4565f957aa65ca5d094ede05cbeaedcee70f5a71200ae2e31b643d2952c929bc03000000"
  );
});

test("normalize invalid outpoint", (t) => {
  const value = {
    tx_hash:
      "0x4565f957aa65ca5d094ede05cbeaedcee70f5a71200ae2e31b643d2952c929bc",
    index: "0x123412341",
  };
  t.throws(() => {
    normalizers.NormalizeOutPoint(value);
  });
});

test("normalize and serialize cellinput", (t) => {
  const value = {
    since: "0x60a0001234",
    previous_output: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x10",
    },
  };
  const normalizedValue = normalizers.NormalizeCellInput(value);
  const serializedValue = CKB.SerializeCellInput(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x341200a060000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da10000000"
  );
});

test("normalize invalid cellinput", (t) => {
  const value = {
    since: "0x60a0001234",
    previous_output: "hahah",
  };
  t.throws(() => {
    normalizers.NormalizeCellInput(value);
  });
});

test("normalize and serialize celloutput", (t) => {
  const value = {
    capacity: "0x10",
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
    type: {
      code_hash:
        "0xa98c57135830e1b900000000f6c4b8870828199a786b26f09f7dec4bc27a73db",
      args: "0x",
      hash_type: "type",
    },
  };
  const normalizedValue = normalizers.NormalizeCellOutput(value);
  const serializedValue = CKB.SerializeCellOutput(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x8400000010000000180000004f000000100000000000000037000000100000003000000031000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da0002000000123435000000100000003000000031000000a98c57135830e1b900000000f6c4b8870828199a786b26f09f7dec4bc27a73db0100000000"
  );
});

test("normalize and serialize celloutput without type", (t) => {
  const value = {
    capacity: "0x10",
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
  };
  const normalizedValue = normalizers.NormalizeCellOutput(value);
  const serializedValue = CKB.SerializeCellOutput(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x4f00000010000000180000004f000000100000000000000037000000100000003000000031000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da00020000001234"
  );
});

test("normalize invalid celloutput", (t) => {
  const value = {
    capacity: "0x102030405060708090",
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
  };
  t.throws(() => {
    normalizers.NormalizeCellOutput(value);
  });
});

test("normalize and serialize celldep", (t) => {
  const value = {
    dep_type: "code",
    out_point: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x11",
    },
  };
  const normalizedValue = normalizers.NormalizeCellDep(value);
  const serializedValue = CKB.SerializeCellDep(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da1100000000"
  );
});

test("normalize and serialize transaction", (t) => {
  const value = {
    version: "0x0",
    cell_deps: [
      {
        dep_type: "code",
        out_point: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300",
          index: "0x0",
        },
      },
    ],
    header_deps: [
      "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
    ],
    inputs: [
      {
        since: "0x10",
        previous_output: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
          index: "0x2",
        },
      },
    ],
    outputs: [
      {
        capacity: "0x1234",
        lock: {
          code_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
          args: "0x1234",
          hash_type: "data",
        },
      },
    ],
    outputs_data: ["0xabcdef"],
    witnesses: ["0x31313131"],
  };
  const normalizedValue = normalizers.NormalizeTransaction(value);
  const serializedValue = CKB.SerializeTransaction(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x1f0100000c0000000f010000030100001c00000020000000490000006d0000009d000000f40000000000000001000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300000000000001000000b39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6010000001000000000000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73010200000057000000080000004f00000010000000180000004f000000341200000000000037000000100000003000000031000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302000200000012340f0000000800000003000000abcdef10000000080000000400000031313131"
  );
});

test("normalize and serialize header", (t) => {
  const value = {
    compact_target: "0x1a2d3494",
    number: "0xfb1bc",
    parent_hash:
      "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
    nonce: "0x449b385049af131a0000001584a00100",
    timestamp: "0x170aba663c3",
    transactions_root:
      "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
    proposals_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    uncles_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    version: "0x0",
    epoch: "0x7080612000287",
    dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
  };
  const normalizedValue = normalizers.NormalizeHeader(value);
  const serializedValue = CKB.SerializeHeader(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x0000000094342d1ac363a6ab70010000bcb10f000000000087020012060807003134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e7901070001a084150000001a13af4950389b44"
  );
});

test("normalize and serialize uncle block", (t) => {
  const value = {
    header: {
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a00100",
      timestamp: "0x170aba663c3",
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    },
    proposals: ["0x12345678901234567890", "0xabcdeabcdeabcdeabcde"],
  };
  const normalizedValue = normalizers.NormalizeUncleBlock(value);
  const serializedValue = CKB.SerializeUncleBlock(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0xf40000000c000000dc0000000000000094342d1ac363a6ab70010000bcb10f000000000087020012060807003134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e7901070001a084150000001a13af4950389b440200000012345678901234567890abcdeabcdeabcdeabcde"
  );
});

test("normalize and serialize block", (t) => {
  const value = {
    header: {
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a00100",
      timestamp: "0x170aba663c3",
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    },
    transactions: [
      {
        version: "0x0",
        cell_deps: [
          {
            dep_type: "code",
            out_point: {
              tx_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300",
              index: "0x0",
            },
          },
        ],
        header_deps: [
          "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
        ],
        inputs: [
          {
            since: "0x10",
            previous_output: {
              tx_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
              index: "0x2",
            },
          },
        ],
        outputs: [
          {
            capacity: "0x1234",
            lock: {
              code_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
              args: "0x1234",
              hash_type: "data",
            },
          },
        ],
        outputs_data: ["0xabcdef"],
        witnesses: ["0x1111"],
      },
    ],
    uncles: [],
    proposals: ["0x12345678901234567890", "0xabcdeabcdeabcdeabcde"],
  };
  const normalizedValue = normalizers.NormalizeBlock(value);
  const serializedValue = CKB.SerializeBlock(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x2502000014000000e4000000e80000000d0200000000000094342d1ac363a6ab70010000bcb10f000000000087020012060807003134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e7901070001a084150000001a13af4950389b440400000025010000080000001d0100000c0000000f010000030100001c00000020000000490000006d0000009d000000f40000000000000001000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300000000000001000000b39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6010000001000000000000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73010200000057000000080000004f00000010000000180000004f000000341200000000000037000000100000003000000031000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302000200000012340f0000000800000003000000abcdef0e000000080000000200000011110200000012345678901234567890abcdeabcdeabcdeabcde"
  );
});

test("normalize and serialize cellbase witness", (t) => {
  const value = {
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
    message: "0x1234abcdef",
  };
  const normalizedValue = normalizers.NormalizeCellbaseWitness(value);
  const serializedValue = CKB.SerializeCellbaseWitness(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x4c0000000c0000004300000037000000100000003000000031000000a98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da00020000001234050000001234abcdef"
  );
});

test("normalize and serialize witness args", (t) => {
  const value = {
    lock: "0x1234",
    input_type: "0x4678",
    output_type: "0x2312",
  };
  const normalizedValue = normalizers.NormalizeWitnessArgs(value);
  const serializedValue = CKB.SerializeWitnessArgs(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(
    serializedHex,
    "0x2200000010000000160000001c000000020000001234020000004678020000002312"
  );
});

test("normalize and serialize empty witness args", (t) => {
  const value = {};
  const normalizedValue = normalizers.NormalizeWitnessArgs(value);
  const serializedValue = CKB.SerializeWitnessArgs(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(serializedHex, "0x10000000100000001000000010000000");
});

test("normalize and serialize only one witness args", (t) => {
  const value = {
    lock: "0x1234",
  };
  const normalizedValue = normalizers.NormalizeWitnessArgs(value);
  const serializedValue = CKB.SerializeWitnessArgs(normalizedValue);
  const serializedHex = new Reader(serializedValue).serializeJson();
  t.deepEqual(serializedHex, "0x16000000100000001600000016000000020000001234");
});

'''
'''--- packages/toolkit/tests/transformers.js ---
const test = require("ava");
const { transformers, Reader } = require("../lib");

test("transform script", (t) => {
  const s = transformers.TransformScript({
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: Reader.fromRawString("args1234"),
    hash_type: {
      serializeJson: () => "data",
    },
  });

  t.deepEqual(s, {
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: "0x6172677331323334",
    hash_type: "data",
  });
});

test("transform camel case script", (t) => {
  const s = transformers.TransformScript({
    codeHash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: Reader.fromRawString("args1234"),
    hashType: {
      serializeJson: () => "data",
    },
  });

  t.deepEqual(s, {
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: "0x6172677331323334",
    hash_type: "data",
  });
});

test("transform plain script", (t) => {
  const s = transformers.TransformScript({
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: "0x1234",
    hash_type: "data",
  });

  t.deepEqual(s, {
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: "0x1234",
    hash_type: "data",
  });
});

test("transform invalid script", (t) => {
  t.throws(() => {
    transformers.TransformScript({
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0xgghh",
      hash_type: "data",
    });
  });
});

test("transform invalid script but do not validate", (t) => {
  const s = transformers.TransformScript(
    {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0xgghh",
      hash_type: "data",
    },
    { validation: false }
  );

  t.deepEqual(s, {
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: "0xgghh",
    hash_type: "data",
  });
});

test("transform outpoint", (t) => {
  const o = transformers.TransformOutPoint({
    tx_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    index: "0x0",
  });

  t.deepEqual(o, {
    tx_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    index: "0x0",
  });
});

test("transform outpoint more fields", (t) => {
  const o = transformers.TransformOutPoint({
    tx_hash: {
      serializeJson: () =>
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      anotherfield: "not used",
    },
    index: "0x10",
    unneeded: "unneeded field",
  });

  t.deepEqual(o, {
    tx_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    index: "0x10",
  });
});

test("correct cellinput", (t) => {
  const v = transformers.TransformCellInput({
    since: "0x0",
    previous_output: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: new Reader("0x10"),
    },
  });

  t.deepEqual(v, {
    since: "0x0",
    previous_output: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x10",
    },
  });
});

test("correct cellinput with serialize function using this", (t) => {
  const v = transformers.TransformCellInput({
    since: "0x0",
    previous_output: {
      value: {
        tx_hash:
          "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
        index: "0x10",
      },
      serializeJson: function () {
        return this.value;
      },
    },
  });

  t.deepEqual(v, {
    since: "0x0",
    previous_output: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x10",
    },
  });
});

test("invalid cellinput", (t) => {
  t.throws(() => {
    transformers.TransformCellInput({
      since: "0x0",
      previous_output: {
        tx_hash:
          "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
        index: new Reader("0x00"),
      },
    });
  });
});

test("celloutput with type", (t) => {
  const v = transformers.TransformCellOutput({
    capacity: "0x10",
    lock: {
      value: {
        code_hash:
          "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
        args: new Reader("0x1234"),
        hash_type: "data",
      },
      serializeJson: function () {
        return this.value;
      },
    },
    type: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x",
      hash_type: "type",
    },
  });

  t.deepEqual(v, {
    capacity: "0x10",
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
    type: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x",
      hash_type: "type",
    },
  });
});

test("celloutput", (t) => {
  const v = transformers.TransformCellOutput({
    capacity: "0x1024",
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x",
      hash_type: "type",
    },
  });

  t.deepEqual(v, {
    capacity: "0x1024",
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x",
      hash_type: "type",
    },
  });
});

test("celloutput invalid lock but skip validation", (t) => {
  const v = transformers.TransformCellOutput(
    {
      capacity: "0x1024",
      type: {
        code_hash:
          "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
        args: "0x",
        hash_type: "type",
      },
      unused: "value",
    },
    { validation: false }
  );

  t.deepEqual(v, {
    capacity: "0x1024",
    type: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x",
      hash_type: "type",
    },
  });
});

test("celloutput invalid lock", (t) => {
  t.throws(() => {
    transformers.TransformCellOutput({
      capacity: "0x1024",
      type: {
        code_hash:
          "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
        args: "0x",
        hash_type: "type",
      },
    });
  });
});

test("correct celldep", (t) => {
  const v = transformers.TransformCellDep({
    dep_type: {
      serializeJson: () => {
        return "code";
      },
    },
    out_point: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x0",
    },
  });

  t.deepEqual(v, {
    dep_type: "code",
    out_point: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x0",
    },
  });
});

class DummyValueHolder {
  constructor(value) {
    this.value = value;
  }

  serializeJson() {
    return this.value;
  }
}

test("correct transaction", (t) => {
  const v = transformers.TransformTransaction({
    version: "0x0",
    cell_deps: [
      {
        dep_type: "code",
        out_point: {
          tx_hash: {
            value: "0xa98c57135830e1b91345948df6c4b887082819",
            serializeJson: function () {
              return this.value + "9a786b26f09f7dec4bc27a7300";
            },
          },
          index: "0x0",
        },
        redundant_key: "unused value",
      },
    ],
    header_deps: [
      "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
    ],
    inputs: [
      {
        since: new DummyValueHolder("0x10"),
        previous_output: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
          index: {
            serializeJson: () => {
              return "0x2";
            },
          },
        },
      },
    ],
    outputs: [
      {
        capacity: "0x1234",
        lock: {
          code_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
          args: new Reader("0x1234"),
          hash_type: "data",
        },
      },
    ],
    outputs_data: ["0xabcdef"],
    witnesses: [Reader.fromRawString("1111")],
  });

  t.deepEqual(v, {
    version: "0x0",
    cell_deps: [
      {
        dep_type: "code",
        out_point: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300",
          index: "0x0",
        },
      },
    ],
    header_deps: [
      "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
    ],
    inputs: [
      {
        since: "0x10",
        previous_output: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
          index: "0x2",
        },
      },
    ],
    outputs: [
      {
        capacity: "0x1234",
        lock: {
          code_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
          args: "0x1234",
          hash_type: "data",
        },
      },
    ],
    outputs_data: ["0xabcdef"],
    witnesses: ["0x31313131"],
  });
});

test("correct header", (t) => {
  const v = transformers.TransformHeader({
    compact_target: "0x1a2d3494",
    number: "0xfb1bc",
    parent_hash:
      "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
    nonce: "0x449b385049af131a0000001584a00100",
    timestamp: "0x170aba663c3",
    transactions_root: new Reader(
      "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a"
    ),
    proposals_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    uncles_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    version: "0x0",
    epoch: "0x7080612000287",
    dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
  });

  t.deepEqual(v, {
    compact_target: "0x1a2d3494",
    number: "0xfb1bc",
    parent_hash:
      "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
    nonce: "0x449b385049af131a0000001584a00100",
    timestamp: "0x170aba663c3",
    transactions_root:
      "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
    proposals_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    uncles_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    version: "0x0",
    epoch: "0x7080612000287",
    dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
  });
});

test("invalid header", (t) => {
  t.throws(() => {
    transformers.TransformHeader({
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a00100",
      timestamp: new Reader("0x170aba663c3"),
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287a",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    });
  });
});

test("correct block", (t) => {
  const v = transformers.TransformBlock({
    header: {
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a00100",
      timestamp: "0x170aba663c3",
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    },
    transactions: [
      {
        version: "0x0",
        cell_deps: [
          {
            dep_type: "code",
            out_point: {
              tx_hash: new Reader(
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300"
              ),
              index: "0x0",
            },
          },
        ],
        header_deps: [
          "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
        ],
        inputs: [
          {
            since: "0x10",
            previous_output: {
              tx_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
              index: "0x2",
            },
          },
        ],
        outputs: [
          {
            capacity: "0x1234",
            lock: {
              code_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
              args: "0x1234",
              hash_type: {
                serializeJson: () => {
                  return "data";
                },
              },
            },
          },
        ],
        outputs_data: ["0xabcdef"],
        witnesses: ["0x1111"],
      },
    ],
    uncles: [],
    proposals: ["0x12345678901234567890", "0xabcdeabcdeabcdeabcde"],
  });

  t.deepEqual(v, {
    header: {
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a00100",
      timestamp: "0x170aba663c3",
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    },
    transactions: [
      {
        version: "0x0",
        cell_deps: [
          {
            dep_type: "code",
            out_point: {
              tx_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300",
              index: "0x0",
            },
          },
        ],
        header_deps: [
          "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
        ],
        inputs: [
          {
            since: "0x10",
            previous_output: {
              tx_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
              index: "0x2",
            },
          },
        ],
        outputs: [
          {
            capacity: "0x1234",
            lock: {
              code_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
              args: "0x1234",
              hash_type: "data",
            },
          },
        ],
        outputs_data: ["0xabcdef"],
        witnesses: ["0x1111"],
      },
    ],
    uncles: [],
    proposals: ["0x12345678901234567890", "0xabcdeabcdeabcdeabcde"],
  });
});

test("correct cellbase witness", (t) => {
  const v = transformers.TransformCellbaseWitness({
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
      unneeded1: "unneeded1",
    },
    message: "0x1234abcdef",
    unneeded2: 2,
  });

  t.deepEqual(v, {
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
    message: "0x1234abcdef",
  });
});

test("correct witness args", (t) => {
  const v = transformers.TransformWitnessArgs({
    lock: "0x1234",
    input_type: "0x4678",
    output_type: "0x2312",
  });

  t.deepEqual(v, {
    lock: "0x1234",
    input_type: "0x4678",
    output_type: "0x2312",
  });
});

test("empty witness args", (t) => {
  const v = transformers.TransformWitnessArgs({});

  t.deepEqual(v, {});
});

test("only one witness args", (t) => {
  const v = transformers.TransformWitnessArgs({
    lock: "0x1234",
    unneeded: "unneeded123",
  });

  t.deepEqual(v, {
    lock: "0x1234",
  });
});

'''
'''--- packages/toolkit/tests/validators.js ---
const test = require("ava");
const { validators } = require("../lib");

test("correct script should pass validation", (t) => {
  validators.ValidateScript({
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: "0x1234",
    hash_type: "data",
  });
  t.pass();
});

test("correct script with empty args", (t) => {
  validators.ValidateScript({
    code_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    args: "0x",
    hash_type: "type",
  });
  t.pass();
});

test("script that is not object", (t) => {
  t.throws(() => {
    validators.ValidateScript("i am a script, trust me");
  });
});

test("script with invalid code hash", (t) => {
  t.throws(() => {
    validators.ValidateScript({
      code_hash: "0xa98c57135830e1b913",
      args: "0x",
      hash_type: "type",
    });
  });
});

test("script with invalid args", (t) => {
  t.throws(() => {
    validators.ValidateScript({
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0xthisisnothex",
      hash_type: "type",
    });
  });
});

test("script with invalid hash type", (t) => {
  t.throws(() => {
    validators.ValidateScript({
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x",
      hash_type: "code",
    });
  });
});

test("correct outpoint", (t) => {
  validators.ValidateOutPoint({
    tx_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    index: "0x0",
  });
  t.pass();
});

test("correct outpoint with positive number", (t) => {
  validators.ValidateOutPoint({
    tx_hash:
      "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
    index: "0x101",
  });
  t.pass();
});

test("outpoint with zero leaded invalid number", (t) => {
  t.throws(() => {
    validators.ValidateOutPoint({
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x010",
    });
  });
});

test("outpoint with invalid hex number", (t) => {
  t.throws(() => {
    validators.ValidateOutPoint({
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0xgg1",
    });
  });
});

test("correct cellinput", (t) => {
  validators.ValidateCellInput({
    since: "0x10",
    previous_output: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x0",
    },
  });
  t.pass();
});

test("cellinput with invalid since", (t) => {
  t.throws(() => {
    validators.ValidateCellInput({
      since: "0x0001",
      previous_output: {
        tx_hash: "0xa98c57135830e1b91345948df",
        index: "0x0",
      },
    });
  });
});

test("cellinput with invalid outpoint", (t) => {
  t.throws(() => {
    validators.ValidateCellInput({
      since: "0x0",
      previous_output: {
        tx_hash: "0xa98c57135830e1b91345948df",
        index: "0x0",
      },
    });
  });
});

test("cellinput with invalid outpoint but skip nested validation", (t) => {
  validators.ValidateCellInput(
    {
      since: "0x0",
      previous_output: {
        tx_hash: "0xa98c57135830e1b91345948df",
        index: "0x0",
      },
    },
    { nestedValidation: false }
  );
  t.pass();
});

test("correct celloutput", (t) => {
  validators.ValidateCellOutput({
    capacity: "0x10",
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
  });
  t.pass();
});

test("correct celloutput with type", (t) => {
  validators.ValidateCellOutput({
    capacity: "0x10",
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
    type: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x",
      hash_type: "type",
    },
  });
  t.pass();
});

test("celloutput with invalid capacity", (t) => {
  t.throws(() => {
    validators.ValidateCellOutput({
      capacity: "0xggg",
      lock: {
        code_hash:
          "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
        args: "0x1234",
        hash_type: "data",
      },
    });
  });
});

test("celloutput with invalid lock", (t) => {
  t.throws(() => {
    validators.ValidateCellOutput({
      capacity: "0x10",
      lock: {
        invalid: "lock",
      },
    });
  });
});

test("celloutput with invalid lock but skips validation", (t) => {
  validators.ValidateCellOutput(
    {
      capacity: "0x10",
      lock: {
        invalid: "lock",
      },
    },
    { nestedValidation: false }
  );
  t.pass();
});

test("correct celldep", (t) => {
  validators.ValidateCellDep({
    dep_type: "code",
    out_point: {
      tx_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      index: "0x0",
    },
  });
  t.pass();
});

test("celldep with invalid dep type", (t) => {
  t.throws(() => {
    validators.ValidateCellDep({
      dep_type: "data",
      out_point: {
        tx_hash:
          "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
        index: "0x0",
      },
    });
  });
});

test("celldep with invalid out point", (t) => {
  t.throws(() => {
    validators.ValidateCellDep({
      dep_type: "dep_group",
      out_point: "invalid out point",
    });
  });
});

test("celldep with invalid out point but skips validation", (t) => {
  validators.ValidateCellDep(
    {
      dep_type: "dep_group",
      out_point: "invalid out point",
    },
    { nestedValidation: false }
  );
  t.pass();
});

test("correct raw transaction", (t) => {
  validators.ValidateRawTransaction({
    version: "0x0",
    cell_deps: [
      {
        dep_type: "code",
        out_point: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300",
          index: "0x0",
        },
      },
    ],
    header_deps: [
      "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
    ],
    inputs: [
      {
        since: "0x10",
        previous_output: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
          index: "0x2",
        },
      },
    ],
    outputs: [
      {
        capacity: "0x1234",
        lock: {
          code_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
          args: "0x1234",
          hash_type: "data",
        },
      },
    ],
    outputs_data: ["0xabcdef"],
  });
  t.pass();
});

test("invalid raw transaction", (t) => {
  t.throws(() => {
    validators.ValidateRawTransaction({
      version: "0x0",
      cell_deps: "invalid",
      header_deps: [
        "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
      ],
      inputs: [
        {
          since: "0x10",
          previous_output: {
            tx_hash:
              "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
            index: "0x2",
          },
        },
      ],
      outputs: [
        {
          capacity: "0x1234",
          lock: {
            code_hash:
              "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
            args: "0x1234",
            hash_type: "data",
          },
        },
      ],
      outputs_data: ["0xabcdef"],
    });
  });
});

test("correct transaction", (t) => {
  validators.ValidateTransaction({
    version: "0x0",
    cell_deps: [
      {
        dep_type: "code",
        out_point: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300",
          index: "0x0",
        },
      },
    ],
    header_deps: [
      "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
    ],
    inputs: [
      {
        since: "0x10",
        previous_output: {
          tx_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
          index: "0x2",
        },
      },
    ],
    outputs: [
      {
        capacity: "0x1234",
        lock: {
          code_hash:
            "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
          args: "0x1234",
          hash_type: "data",
        },
      },
    ],
    outputs_data: ["0xabcdef"],
    witnesses: ["0x1111"],
  });
  t.pass();
});

test("correct header", (t) => {
  validators.ValidateHeader({
    compact_target: "0x1a2d3494",
    number: "0xfb1bc",
    parent_hash:
      "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
    nonce: "0x449b385049af131a0000001584a00100",
    timestamp: "0x170aba663c3",
    transactions_root:
      "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
    proposals_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    uncles_hash:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    version: "0x0",
    epoch: "0x7080612000287",
    dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
  });
  t.pass();
});

test("invalid header", (t) => {
  t.throws(() => {
    validators.ValidateHeader({
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a0",
      timestamp: "0x170aba663c3",
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    });
  });
});

test("invalid raw header", (t) => {
  t.throws(() => {
    validators.ValidateRawHeader({
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a00100",
      timestamp: "0x170aba663c3",
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    });
  });
});

test("validate uncle block", (t) => {
  validators.ValidateUncleBlock({
    header: {
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a00100",
      timestamp: "0x170aba663c3",
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    },
    proposals: ["0x12345678901234567890", "0xabcdeabcdeabcdeabcde"],
  });
  t.pass();
});

test("validate invalid uncle block", (t) => {
  t.throws(() => {
    validators.ValidateUncleBlock({
      header: {
        compact_target: "0x1a2d3494",
        number: "0xfb1bc",
        parent_hash:
          "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
        nonce: "0x449b385049af131a0000001584a00100",
        timestamp: "0x170aba663c3",
        transactions_root:
          "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
        proposals_hash:
          "0x0000000000000000000000000000000000000000000000000000000000000000",
        uncles_hash:
          "0x0000000000000000000000000000000000000000000000000000000000000000",
        version: "0x0",
        epoch: "0x7080612000287",
        dao:
          "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
      },
      proposals: ["0x12345678901234567890", "0xabcdeabcdeab"],
    });
  });
});

test("validate invalid uncle block but skips nested validation", (t) => {
  validators.ValidateUncleBlock(
    {
      header: 123123,
      proposals: ["0x12345678901234567890"],
    },
    { nestedValidation: false }
  );
  t.pass();
});

test("validate block", (t) => {
  validators.ValidateBlock({
    header: {
      compact_target: "0x1a2d3494",
      number: "0xfb1bc",
      parent_hash:
        "0x3134874027b9b2b17391d2fa545344b10bd8b8c49d9ea47d55a447d01142b21b",
      nonce: "0x449b385049af131a0000001584a00100",
      timestamp: "0x170aba663c3",
      transactions_root:
        "0x68a83c880eb942396d22020aa83343906986f66418e9b8a4488f2866ecc4e86a",
      proposals_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      uncles_hash:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      version: "0x0",
      epoch: "0x7080612000287",
      dao: "0x40b4d9a3ddc9e730736c7342a2f023001240f362253b780000b6ca2f1e790107",
    },
    transactions: [
      {
        version: "0x0",
        cell_deps: [
          {
            dep_type: "code",
            out_point: {
              tx_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7300",
              index: "0x0",
            },
          },
        ],
        header_deps: [
          "0xb39d53656421d1532dd995a0924441ca8f43052bc2b7740a0e814a488a8214d6",
        ],
        inputs: [
          {
            since: "0x10",
            previous_output: {
              tx_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7301",
              index: "0x2",
            },
          },
        ],
        outputs: [
          {
            capacity: "0x1234",
            lock: {
              code_hash:
                "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a7302",
              args: "0x1234",
              hash_type: "data",
            },
          },
        ],
        outputs_data: ["0xabcdef"],
        witnesses: ["0x1111"],
      },
    ],
    uncles: [],
    proposals: ["0x12345678901234567890", "0xabcdeabcdeabcdeabcde"],
  });
  t.pass();
});

test("correct cellbase witness", (t) => {
  validators.ValidateCellbaseWitness({
    lock: {
      code_hash:
        "0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da",
      args: "0x1234",
      hash_type: "data",
    },
    message: "0x1234abcdef",
  });
  t.pass();
});

test("correct witness args", (t) => {
  validators.ValidateWitnessArgs({
    lock: "0x1234",
    input_type: "0x4678",
    output_type: "0x2312",
  });
  t.pass();
});

test("empty witness args", (t) => {
  validators.ValidateWitnessArgs({});
  t.pass();
});

test("only one witness args", (t) => {
  validators.ValidateWitnessArgs({
    lock: "0x1234",
  });
  t.pass();
});

test("invalid witness args", (t) => {
  t.throws(() => {
    validators.ValidateWitnessArgs({
      lock: "0x1234",
      invalidkey: "0x1232",
    });
  });
});

test("invalid witness args content", (t) => {
  t.throws(() => {
    validators.ValidateWitnessArgs({
      lock: "0x1234gg",
    });
  });
});

'''
'''--- packages/transaction-manager/README.md ---
# `@ckb-lumos/transaction-manager`

TransactionManager is a tool for manager uncommitted cells, you can `send_transaction` via this tool and get uncommitted outputs by `collector`.

## Usage

```javascript
const TransactionManager = require("@ckb-lumos/transaction-manager");
const { Indexer } = require("@ckb-lumos/ckb-indexer");

// generate a new `TransactionManager` instance and start.
const indexer = new Indexer("http://127.0.0.1:8114");
const transactionManager = new TransactionManager(indexer);
transactionManager.start();

// now you send transaction via `transactionManager`.
const txHash = await transactionManager.send_transaction(transaction);

// you can get uncommitted cells by `transactionManager.collector`.
const collector = transactionManager.collector({ lock });
for await (const cell of collector.collect()) {
  console.log(cell);
}
```

'''
'''--- packages/transaction-manager/index.d.ts ---
import {
  Transaction,
  Hash,
  QueryOptions,
  logger,
  Indexer,
  CellCollector,
} from "@ckb-lumos/base";

declare class TransactionManager {
  constructor(
    indexer: Indexer,
    options?: {
      logger?: logger.Logger;
      pollIntervalSeconds?: number;
    }
  );

  start(): void;

  stop(): void;

  send_transaction(tx: Transaction): Promise<Hash>;

  /**
   * If set `usePendingOutputs` to false, will not use pending outputs, default to true.
   *
   * @param queryOptions
   * @param options
   */
  collector(
    queryOptions?: QueryOptions,
    options?: { usePendingOutputs?: boolean }
  ): CellCollector;
}

export = TransactionManager;

'''
'''--- packages/transaction-manager/lib/index.js ---
const { validators, RPC } = require("@ckb-lumos/toolkit");
const { List, Set } = require("immutable");
const { values, helpers } = require("@ckb-lumos/base");
const { TransactionCollector } = require("@ckb-lumos/ckb-indexer");
const { isCellMatchQueryOptions } = helpers;

function defaultLogger(level, message) {
  console.log(`[${level}] ${message}`);
}

class TransactionManager {
  constructor(
    indexer,
    {
      logger = defaultLogger,
      pollIntervalSeconds = 30,
      rpc = new RPC(indexer.uri),
    } = {}
  ) {
    this.indexer = indexer;
    this.rpc = rpc;
    this.transactions = Set();
    this.spentCells = Set();
    this.createdCells = List();
    this.logger = logger;
    this.running = false;
    this.pollIntervalSeconds = pollIntervalSeconds;
  }

  // Start a monitor of network with the following 2 changes:
  // * A transaction is accepted on chain.
  // * A transaction is ruled out due to another transaction spends its input(s).
  // TODO: right now this works by polling the data periodically, later we might switch
  // to a notification based mechanism.
  start() {
    this.running = true;
    this._loopMonitor();
  }

  stop() {
    this.running = false;
  }

  async _loopMonitor() {
    try {
      await this._checkTransactions();
    } catch (e) {
      this.logger("error", `Error checking transactions: ${e}`);
    }
    if (this.running) {
      setTimeout(() => this._loopMonitor(), this.pollIntervalSeconds * 1000);
    }
  }

  async _checkTransactions() {
    let filteredTransactions = Set();
    for await (let transactionValue of this.transactions) {
      /* Extract tx value from TransactionValue wrapper */
      let tx = transactionValue.value;
      /* First, remove all transactions that use already spent cells */
      for (const input of tx.inputs) {
        const cell = await this.rpc.get_live_cell(input.previous_output, false);
        if (!cell) {
          continue;
        }
      }
      /* Second, remove all transactions that have already been committed */
      const output = tx.outputs[0];
      if (output) {
        const transactionCollector = new TransactionCollector(this.indexer, {
          lock: output.lock,
        });
        const txHashes = await transactionCollector.getTransactionHashes();
        // remove witnesses property because it's redundant for calculating tx_hash
        delete tx.witnesses;
        const targetTxHash = new values.RawTransactionValue(tx, {
          validate: false,
        }).hash();
        if (txHashes.includes(targetTxHash)) {
          continue;
        }
      }
      filteredTransactions = filteredTransactions.add(transactionValue);
    }
    this.transactions = filteredTransactions;
    let createdCells = List();
    this.transactions.forEach((transactionValue) => {
      const tx = transactionValue.value;
      tx.outputs.forEach((output, i) => {
        const out_point = {
          tx_hash: tx.hash,
          index: "0x" + i.toString(16),
        };
        createdCells = createdCells.push({
          out_point,
          cell_output: output,
          data: tx.outputs_data[i],
          block_hash: null,
        });
      });
    });
    this.createdCells = createdCells;
  }

  async send_transaction(tx) {
    validators.ValidateTransaction(tx);
    tx.inputs.forEach((input) => {
      if (
        this.spentCells.includes(
          new values.OutPointValue(input.previous_output, { validate: false })
        )
      ) {
        throw new Error(
          `OutPoint ${input.previous_output.tx_hash}@${input.previous_output.index} has already been spent!`
        );
      }
    });
    const txHash = await this.rpc.send_transaction(tx);
    tx.hash = txHash;
    this.transactions = this.transactions.add(
      new values.TransactionValue(tx, { validate: false })
    );
    tx.inputs.forEach((input) => {
      this.spentCells = this.spentCells.add(
        new values.OutPointValue(input.previous_output, { validate: false })
      );
    });
    for (let i = 0; i < tx.outputs.length; i++) {
      const op = {
        tx_hash: txHash,
        index: `0x${i.toString(16)}`,
      };
      this.createdCells = this.createdCells.push({
        out_point: op,
        cell_output: tx.outputs[i],
        data: tx.outputs_data[i],
        block_hash: null,
      });
    }
    return txHash;
  }

  _filterCells(
    createdCells,
    { lock = null, type = null, argsLen = -1, data = "any" } = {}
  ) {
    const filteredCreatedCells = createdCells.filter((cell) => {
      return isCellMatchQueryOptions(cell, {
        lock,
        type,
        argsLen,
        data,
      });
    });
    return filteredCreatedCells;
  }

  collector(
    {
      lock = null,
      type = null,
      argsLen = -1,
      data = "any",
      fromBlock = null,
      toBlock = null,
      skip = null,
    } = {},
    { usePendingOutputs = true } = {}
  ) {
    const params = [
      {
        name: "fromBlock",
        value: fromBlock,
      },
      {
        name: "toBlock",
        value: toBlock,
      },
      {
        name: "skip",
        value: skip,
      },
    ]
      .filter((param) => param.value != null)
      .map((param) => param.name);
    if (usePendingOutputs && params.length !== 0) {
      this.logger(
        "warn",
        params.map((param) => `\`${param}\``).join(", ") +
          " will not effect on pending cells."
      );
    }
    const innerCollector = this.indexer.collector({
      lock,
      type,
      argsLen,
      data,
      fromBlock,
      toBlock,
      skip,
    });
    const filteredCreatedCells = this._filterCells(this.createdCells, {
      lock,
      type,
      argsLen,
      data,
    });
    return new TransactionManagerCellCollector(
      innerCollector,
      this.spentCells,
      filteredCreatedCells,
      { usePendingOutputs }
    );
  }
}

class TransactionManagerCellCollector {
  constructor(
    collector,
    spentCells,
    filteredCreatedCells,
    { usePendingOutputs = true } = {}
  ) {
    this.collector = collector;
    this.spentCells = Set(spentCells);
    this.filteredCreatedCells = filteredCreatedCells;
    this.usePendingOutputs = usePendingOutputs;
  }

  // TODO: optimize this
  async count() {
    let result = 0;
    const c = this.collect();
    while (true) {
      const item = await c.next();
      if (item.done) {
        break;
      }
      result += 1;
    }
    return result;
  }

  async *collect() {
    for await (const cell of this.collector.collect()) {
      if (!this.spentCells.has(new values.OutPointValue(cell.out_point))) {
        yield cell;
      }
    }
    if (this.usePendingOutputs) {
      for (const cell of this.filteredCreatedCells) {
        yield cell;
      }
    }
  }
}

module.exports = TransactionManager;

'''
'''--- packages/transaction-manager/package.json ---
{
  "name": "@ckb-lumos/transaction-manager",
  "version": "0.17.0-rc8",
  "description": "Pending Transaction Manager for lumos",
  "author": "Xuejie Xiao <xxuejie@gmail.com>",
  "homepage": "https://github.com/nervosnetwork/lumos#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "index.d.ts",
  "engines": {
    "node": ">=12.0.0"
  },
  "os": [
    "win32",
    "darwin",
    "linux"
  ],
  "directories": {
    "lib": "lib",
    "test": "tests"
  },
  "files": [
    "lib",
    "index.d.ts"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nervosnetwork/lumos.git"
  },
  "scripts": {
    "fmt": "prettier --write \"{lib,tests}/**/*.js\" index.d.ts package.json",
    "lint": "eslint -c ../../.eslintrc.js \"{lib,tests}/**/*.js\"",
    "test": "ava **/*.test.js"
  },
  "bugs": {
    "url": "https://github.com/nervosnetwork/lumos/issues"
  },
  "dependencies": {
    "@ckb-lumos/base": "^0.17.0-rc8",
    "@ckb-lumos/ckb-indexer": "^0.17.0-rc8",
    "@ckb-lumos/toolkit": "^0.17.0-rc8",
    "immutable": "^4.0.0-rc.12"
  }
}

'''
'''--- packages/transaction-manager/tests/filter_cells.test.js ---
const test = require("ava");
const TransactionManager = require("../lib");
const { utils } = require("@ckb-lumos/base");

const cells = [
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x486ead64a7c2c1a3132c2e03d2af364050f4f0f6dfafad291daa7db6aed53e10",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: {
        code_hash:
          "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
        hash_type: "type",
        args:
          "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
      },
    },
    data: "0x10270000000000000000000000000000",
    out_point: {
      tx_hash:
        "0x486ead64a7c2c1a3132c2e03d2af364050f4f0f6dfafad291daa7db6aed53e10",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
  {
    cell_output: {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
        hash_type: "type",
        args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d80000000000000000",
      },
      type: undefined,
    },
    data: "0x",
    out_point: {
      tx_hash:
        "0x486ead64a7c2c1a3132c2e03d2af364050f4f0f6dfafad291daa7db6aed53e10",
      index: "0x0",
    },
    block_hash:
      "0x1111111111111111111111111111111111111111111111111111111111111111",
    block_number: "0x1",
  },
];

function computeHashCodes(cells) {
  return cells.map((cell) => {
    return utils.hashCode(Buffer.from(JSON.stringify(cell)));
  });
}

const transactionManager = new TransactionManager({ uri: "" });

test("filter by lock", (t) => {
  const filterdCells = transactionManager._filterCells(cells, {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
  });

  t.is(filterdCells.length, 2);
  t.deepEqual(
    computeHashCodes(filterdCells),
    computeHashCodes([cells[0], cells[1]])
  );
});

test("filter by lock & empty type", (t) => {
  const filterdCells = transactionManager._filterCells(cells, {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
    type: "empty",
  });

  t.is(filterdCells.length, 1);
  t.deepEqual(computeHashCodes(filterdCells), computeHashCodes([cells[0]]));
});

test("filter by lock & type", (t) => {
  const filterdCells = transactionManager._filterCells(cells, {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
    type: {
      code_hash:
        "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      hash_type: "type",
      args:
        "0x1f2615a8dde4e28ca736ff763c2078aff990043f4cbf09eb4b3a58a140a0862d",
    },
  });

  t.is(filterdCells.length, 1);
  t.deepEqual(computeHashCodes(filterdCells), computeHashCodes([cells[1]]));
});

test("filter by lock & data", (t) => {
  const filterdCells = transactionManager._filterCells(cells, {
    lock: {
      code_hash:
        "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      hash_type: "type",
      args: "0x36c329ed630d6ce750712a477543672adab57f4c",
    },
    data: "0x10270000000000000000000000000000",
  });

  t.is(filterdCells.length, 1);
  t.deepEqual(computeHashCodes(filterdCells), computeHashCodes([cells[1]]));
});

test("filter by lock & argsLen", (t) => {
  const filterdCells = transactionManager._filterCells(cells, {
    lock: {
      code_hash:
        "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      hash_type: "type",
      args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
    },
    argsLen: 28,
  });

  t.is(filterdCells.length, 1);
  t.deepEqual(computeHashCodes(filterdCells), computeHashCodes([cells[2]]));
});

test("filter by lock & argsLen, failed", (t) => {
  const filterdCells = transactionManager._filterCells(cells, {
    lock: {
      code_hash:
        "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      hash_type: "type",
      args: "0x56f281b3d4bb5fc73c751714af0bf78eb8aba0d8",
    },
    argsLen: 27,
  });

  t.is(filterdCells.length, 0);
});

'''
'''--- packages/transaction-manager/tests/index.test.js ---
const test = require("ava");
const { helpers, values } = require("@ckb-lumos/base");
const TransactionManager = require("../lib");
const { isCellMatchQueryOptions } = helpers;
const sinon = require("sinon");
const { TransactionCollector } = require("@ckb-lumos/ckb-indexer");

const cells = [
  {
    cell_output: {
      capacity: "0x11714b9539d5",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
      type: undefined,
    },
    out_point: {
      tx_hash:
        "0x9ab6b0cbea64475f61d10a832cfdf06cd0f219a284778a07e41278f341025754",
      index: "0x0",
    },
    block_hash:
      "0x80642e5e6ec40e101f651e3d694f4fd4d3fc9e8808c1472503ccd9a040c0d734",
    block_number: "0xa7",
    data: "0x",
  },
];

const tx = {
  version: "0x0",
  cell_deps: [
    {
      out_point: {
        tx_hash:
          "0x785aa819c8f9f8565a62f744685f8637c1b34886e57154e4e5a2ac7f225c7bf5",
        index: "0x0",
      },
      dep_type: "dep_group",
    },
  ],
  header_deps: [],
  inputs: [
    {
      since: "0x0",
      previous_output: {
        tx_hash:
          "0x9ab6b0cbea64475f61d10a832cfdf06cd0f219a284778a07e41278f341025754",
        index: "0x0",
      },
    },
  ],
  outputs: [
    {
      capacity: "0x174876e800",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0xe2193df51d78411601796b35b17b4f8f2cd85bd0",
      },
    },
    {
      capacity: "0x115a031e51d5",
      lock: {
        code_hash:
          "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
        hash_type: "type",
        args: "0x36c329ed630d6ce750712a477543672adab57f4c",
      },
    },
  ],
  outputs_data: ["0x", "0x"],
  witnesses: [
    "0x5500000010000000550000005500000041000000f18aa27d7e30acae87d891784506ab2b85a26888e49e7570decfb195604dfc5233cdf7ffb78d51ee9d7106391c4b9baacf5119475b84da39d1fbb54216ddfc3000",
  ],
};

const txHash =
  "0x4ca142a2b1e3eae453161340dbf437368cf76040f3c4d8454f3780b46b4e48c8";

class MockCellCollector {
  constructor(
    indexer,
    {
      lock = null,
      type = null,
      argsLen = -1,
      data = "any",
      fromBlock = null,
      toBlock = null,
      skip = null,
    }
  ) {
    this.indexer = indexer;
    this.queryOptions = {
      lock,
      type,
      argsLen,
      data,
      fromBlock,
      toBlock,
      skip,
    };
  }

  async *collect() {
    for (const cell of cells) {
      if (isCellMatchQueryOptions(cell, this.queryOptions)) {
        yield cell;
      }
    }
  }
}

class MockIndexer {
  constructor(committedTxHashes = []) {
    this.uri = "";
    this.committedTxHashes = committedTxHashes;
  }

  collector({
    lock = null,
    type = null,
    argsLen = -1,
    data = "any",
    fromBlock = null,
    toBlock = null,
    skip = null,
  } = {}) {
    return new MockCellCollector(this, {
      lock,
      type,
      argsLen,
      data,
      fromBlock,
      toBlock,
      skip,
    });
  }
}

class MockRPC {
  async send_transaction() {
    return txHash;
  }
  async get_live_cell() {
    return cells[0];
  }
}

const indexer = new MockIndexer();
const rpc = new MockRPC();
const stub = sinon
  .stub(TransactionCollector.prototype, "getTransactionHashes")
  .onCall(0)
  .resolves([])
  .onCall(1)
  .resolves([txHash])
  .onCall(2)
  .resolves([txHash]);

test.afterEach(() => {
  stub.reset();
});
test("send_transaction1", async (t) => {
  const transactionManager = new TransactionManager(indexer, {
    rpc,
  });

  t.is(transactionManager.spentCells.size, 0);
  t.is(transactionManager.createdCells.size, 0);

  await transactionManager.send_transaction(tx);

  t.is(transactionManager.spentCells.size, 1);
  t.true(
    new values.OutPointValue(tx.inputs[0].previous_output, {
      validate: false,
    }).equals(transactionManager.spentCells.toArray()[0])
  );

  t.deepEqual(
    transactionManager.createdCells.toJS().map((cell) => {
      return new values.OutPointValue(cell.out_point, { validate: false })
        .buffer;
    }),
    tx.outputs.map((_, i) => {
      return new values.OutPointValue(
        {
          tx_hash: txHash,
          index: "0x" + i.toString(16),
        },
        {
          validate: false,
        }
      ).buffer;
    })
  );
});

test("_checkTransactions, uncommitted", async (t) => {
  const transactionManager = new TransactionManager(indexer, {
    rpc,
  });
  await transactionManager.send_transaction(tx);
  await transactionManager._checkTransactions();
  t.is(transactionManager.transactions.size, 1);
  t.is(transactionManager.createdCells.size, 2);
});

test("_checkTransactions, committed", async (t) => {
  const indexer = new MockIndexer([txHash]);
  const rpc = new MockRPC();
  const transactionManager = new TransactionManager(indexer, {
    rpc,
  });

  await transactionManager.send_transaction(tx);
  await transactionManager._checkTransactions();
  t.is(transactionManager.transactions.size, 0);
});

test("TransactionManagerCellCollector#collect", async (t) => {
  const transactionManager = new TransactionManager(indexer, {
    rpc,
  });

  await transactionManager.send_transaction(tx);

  const collector = transactionManager.collector();

  const collectedCells = [];
  for await (const c of collector.collect()) {
    collectedCells.push(c);
  }

  t.deepEqual(
    collectedCells.map((c) => {
      return new values.OutPointValue(c.out_point, { validate: false }).buffer;
    }),
    tx.outputs.map((_, i) => {
      return new values.OutPointValue(
        {
          tx_hash: txHash,
          index: "0x" + i.toString(16),
        },
        { validate: false }
      ).buffer;
    })
  );
});

test("TransactionManagerCellCollector#count", async (t) => {
  const transactionManager = new TransactionManager(indexer, {
    rpc,
  });
  await transactionManager.send_transaction(tx);

  const collector = transactionManager.collector();

  const count = await collector.count();

  t.is(count, 2);
});

test("TransactionManagerCellCollector, update createdCells if committed", async (t) => {
  const indexer = new MockIndexer([txHash]);
  const rpc = new MockRPC();
  const transactionManager = new TransactionManager(indexer, {
    rpc,
  });
  await transactionManager.send_transaction(tx);
  await transactionManager._checkTransactions();

  const collector = transactionManager.collector();

  const count = await collector.count();

  t.is(count, 0);
});

'''
'''--- scripts/symlink_node_modules.js ---
// In yarn (up to v1.22.4 we use), there is a bug when you tries to
// execute custom install command from a workspace environment:
// https://github.com/yarnpkg/yarn/issues/4564. For now, we will
// have to patch the code so a symlink is created. This bug only
// affects Windows environment.

const fs = require("fs");
const path = require("path");

if (process.platform !== "win32") {
  return;
}

const rootPath = path.resolve(path.join(__dirname, ".."));
const nodeModulesPath = path.join(rootPath, "node_modules");
const nestedPath = path.join(nodeModulesPath, "node_modules");

fs.mkdirSync(nodeModulesPath, { recursive: true });

try {
  fs.unlinkSync(nestedPath);
} catch (error) {
  if (error.code !== "ENOENT") {
    console.log(`Error removing previous symlink: ${error}`);
    process.exit(1);
  }
}

try {
  fs.symlinkSync(nodeModulesPath, nestedPath, "junction");
} catch (error) {
  console.log(`Error creating symlink: ${error}`);
  process.exit(1);
}

'''
'''--- style.md ---
# Lumos code styles

This is not something that is as complete as a [formal Style Guide](https://google.github.io/styleguide/jsguide.html). We might get there one day but for now this is just some initial points for us to organize our code better.

## General Ideas

* Lumos will be tested and supported on the latest stable and LTS versions of node.js, for a production environment, we recommend that you only use the latest LTS versions.
* Lumos will be tested and supported on 64-bit machines running latest versions of Windows, macOS and popular Linux distributions(we might expand on this later).
* For dapp developers that are just using lumos as an npm dependency, Rust shall not be needed, meaning pre-built binaries for the corresponding environment can be downloaded.
* Lumos is only designed to work with node.js environment, meaning browser is not a supported target.
* Lumos will provide TypeScript support, but all components of lumos should also support safe use from a pure JavaScript based environment. One example of this rule, is that all the components shall perform type checks dynamically within JavaScript, no TypeScript checking will be relied on for security.

## Rust Specific Part

* All Rust code should be compiled without warnings by the latest stable version of Rust.
* All Rust code should be formatted via the latest stable version of cargofmt.
* All Rust code should be checked by the latest stable version of clippy.
* As mentioned above, all components using Rust code shall provide pre-built binaries. See [indexer](https://github.com/nervosnetwork/lumos/tree/master/packages/indexer) for an example.

## JavaScript/TypeScript Specific Part

* All hand-written JavaScript, TypeScript, JSON files will be checked by [prettier](https://prettier.io/).
* JavaScript and TypeScript are both allowed, but when using JavaScript code, TypeScript typing definitions must be provided.
* The code must not rely on TypeScript type checking for securities. All types should be dynamically checked, even when using TypeScript.
* All public APIs shall have doc comments attached.

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "declaration": true,
    "outDir": "./lib",
    "types": ["node"],
    "lib": ["es2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "sourceMap": true
  },
  "exclude": ["**/node_modules", "**/tests", "**/lib"]
}

'''
'''--- typedoc.js ---
module.exports = {
  mode: "modules",
  out: "docs",
  exclude: [
    "**/node_modules/**",
    "**/tests/**/*",
    "**/examples/**/*",
    "**/docusaurus/**/*",
    "**/examples/**/*",
  ],
  name: "lumos",
  includeDeclarations: true,
  excludePrivate: true,
  "external-modulemap": ".*packages/([^/]+)/.*",
  esModuleInterop: true,
};

'''