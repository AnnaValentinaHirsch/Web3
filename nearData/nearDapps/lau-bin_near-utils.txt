*GitHub Repository "lau-bin/near-utils"*

'''--- Readme.md ---
# Testing platform for Near
Supports testnet and nearup
Use the functions provided in "lib" to make your scripts

## Considerations
**Nearup**  
The nearup instance should be running with default configuration  
**Other networks**  
The network env must be set to the network name

## Configure the network where tests will run
Before starting any test set the following environment variables
Consider that the balance of the master account is limited on some networks
### NETWORK
* "testnet"
* "local" if you will use nearup
'''
'''--- package.json ---
{
  "name": "near-utils",
  "version": "1.1.0",
  "description": "Near utilities",
  "scripts": {
    "prepare": "tsc"
  },
  "main": "out/index.js",
  "author": "Lautaro C",
  "dependencies": {
    "bn.js": "^5.2.0",
    "near-api-js": "^0.43.1",
    "js-utils": "git+ssh://git@github.com:lau-bin/js-utils.git",
    "typescript": "^4.5.2"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "@types/node": "14.14.31"
  },
  "keywords": [],
  "licence": "ISC"
}

'''
'''--- src/config.ts ---
import { existsSync, mkdirSync, readFileSync } from "fs"
import path from "path"
import { NetworkId } from "./near-connection"
import { hasValue, assert } from "js-utils"
import {__dirname} from "./init"

export function getConfig<T extends Network>(network: T): NetworkConfig<Network> {
  let config: NetworkConfig<T>
  switch (network) {
    case "local":
      config = {
        networkId: "sandbox",
        nodeUrl: "http://localhost:3030",
        master: {
          keyPath: "/tmp/near-sandbox/validator_key.json",
        }
      } as any
      break
    case "testnet":
      config = {
        networkId: "testnet",
        nodeUrl: "https://rpc.testnet.near.org",
        existentAcc: {
        }
      } as any
      break
    default:
      throw Error("network type not implemented")
  }

  return config
}

export function makeLogFile(_path?: string): string{
  try {
    let date = new Date()
    let file = _path || path.join(global.__dirname, "logs", `log_${date.getDay()}:${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}.txt`)
    if (!existsSync(path.dirname(file))) {
      mkdirSync(path.dirname(file))
    }
    return file
  }
  catch (e) {
    throw Error("error creating log file: " + e)
  }
}

export type Network = "local" | "testnet" | "betanet" | "mainnet"
export type NetworkConfig<T extends Network> = {
  networkId: NetworkId,
  nodeUrl: string,
  master: T extends "local" ? {
    keyPath: string
  } : undefined
}
'''
'''--- src/constants.ts ---
export const NAMED_ACCOUNT_MAX_LENGTH = 64

'''
'''--- src/contract.ts ---
import BN from "bn.js"
import { Account } from "near-api-js"
import {getTransactionLastResult, FinalExecutionStatus, FinalExecutionOutcome} from "near-api-js/lib/providers/provider"
import {asConst, hasValue, isString} from "js-utils"

export class Contract<T extends ContractSpec, S extends Account | string> {

  accountId: string
  account: S extends Account ? Account : null
  view: {[key in keyof T["viewMethods"]]:(account: S extends Account ? Account | null : Account, args?:T["viewMethods"][key]["args"])=> Promise<T["viewMethods"][key]["returnValue"]>} = {} as any
  call: {[key in keyof T["changeMethods"]]:(account: S extends Account ? Account | null : Account, args?:T["changeMethods"][key]["args"], gas?:BN, attachedDeposit?:BN)=> Promise<FinalExecutionOutcome>} = {} as any
  name: string
  spec: T

  constructor(accountOrId: S, contractSpec: T, name?: string){
    this.spec = contractSpec
    this.name = name || contractSpec.name
    if (!isString(accountOrId)){
      this.accountId = accountOrId.accountId
      this.account = accountOrId as any
    }
    else{
      this.accountId = accountOrId
      this.account = null as any
    }
    Object.keys(contractSpec.changeMethods).forEach(methodName=>{
      const fun = async (account?: Account, args?:Object, gas:BN = new BN(300000000000000), attachedDeposit:BN = new BN(0))=>{
        const element = {
          contractId: this.accountId,
          methodName: methodName,
          args: args ?? {},
          gas,
          attachedDeposit
        } 
        let caller = hasValue(account) ? account : this.account as Account
        return await caller.functionCall(element);
      }
      
      Object.defineProperty(this.call, methodName, {
        writable: false,
        enumerable: true,
        value: fun
      })
    })

    Object.keys(contractSpec.viewMethods).forEach(methodName=>{
      const fun = async (account?: Account, args?:Object)=>{
        let caller = hasValue(account) ? account : this.account as Account
        return await caller.viewFunction(this.accountId, methodName, args);
      }
      Object.defineProperty(this.view, methodName, {
        writable: false,
        enumerable: true,
        value: fun
      })
    })
  }
}

export type ContractSpec = {
  changeMethods: CtrMethodDefinition
  viewMethods: CtrMethodDefinition
  wasmName: string
  name: string
}

export type CtrMethodDefinition = {
  [p: string]: {
    args: any,
    returnValue: any
  }
}

export function asCtrSpec<T extends ContractSpec>(spec:T):T{
  return spec
}

'''
'''--- src/errors.ts ---
import {NAMED_ACCOUNT_MAX_LENGTH} from "./constants"

export const ACCOUNT_ID_TOO_BIG = `resulting name is too long (> ${NAMED_ACCOUNT_MAX_LENGTH})`
'''
'''--- src/index.ts ---
export * from "./config"
export * from "./constants"
export * from "./contract"
export * from "./errors"
export * from "./init"
export * from "./interactiveConsole"
export * from "./logger"
export * from "./near"
export * from "./near-connection"
export * from "./start"
export * from "./util"
'''
'''--- src/init.ts ---
import path from "path";

export const __dirname = path.resolve()
'''
'''--- src/interactiveConsole.ts ---
import {createInterface} from "readline"

export async function evalFromTerminal(_this:any) {
  if (process.argv.length >= 2 && (process.argv[2] === "-i" || process.argv[2] === "-il")) {
    await run.call(_this)
  }
}

async function run(){
  console.log("<Interactive mode>")
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout
  });
  let interactive = true
  while (interactive) {
    await new Promise<void>(resolve => {
      rl.question("_>", (command) => {
        if (command === "return") {
          rl.close()
          interactive = false
          return resolve()
        }
        eval(command)
        resolve()
      })
    })
  }
  console.log("<Console closed>")
}

export async function readLine(){
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise<string>(resolve => {
    rl.question("_>", (command) => {
      rl.close()
      return resolve(command)
    })
  })
}
'''
'''--- src/logger.ts ---
import {readFileSync, writeFileSync} from "fs"
import path from "path"
import { isObject, isString, JSONPrettify, makeEnumerable } from "js-utils"
import { replacer } from "./util"

export class Logger{
  private _logfile: string
  static instance: Logger

  private constructor(logfile: string){
    this._logfile = logfile
  }

  get logFile(){
    return this._logfile
  }

  static getLogger(logfile?: string){
    if (!this.instance){
      if (logfile){
        this.instance = new Logger(logfile)
      }
      else{
        return null
      }
    }
    return this.instance
  }

  static info(msg:string | Object | Array<any>, _console?:boolean){
    this.log(msg, "INFO", _console)
  }

  static error(msg:string | Object | Array<any>, _console?:boolean){
    this.log(msg, "ERROR", _console)
  }

  private static log(msg: any, type: string, _console?:boolean){
    let date = new Date()
    let message
    if (isString(msg)){
      if (msg.length >= 2){
        message = msg.charAt(0).toUpperCase() + msg.substring(1)
      }
    }
    else if (isObject(msg)){
      message = JSONPrettify(makeEnumerable(msg), replacer)
    }
    else if (Array.isArray(msg)){
      message = JSONPrettify(msg, replacer)
    }

    let toLog = `[${date.getDay()}:${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}]: ${type} - ${message ? message : msg}`
    if (_console){
      console.log(toLog)
    }
    if (this.instance){
      writeFileSync(this.instance._logfile, toLog + "\n", {flag:'a'})
    }
  }
}
'''
'''--- src/near-connection.ts ---
import { NetworkConfig } from "./config";
import { copyFile } from "fs";
import {keyStores, connect, Near} from "near-api-js"
import {hasValue} from "js-utils"

export class NearConncetion {
  keyStore = new keyStores.InMemoryKeyStore()
  private _near?: Near
  networkId: NetworkId

  private constructor(networkId: NetworkId){
    this.networkId = networkId
  }

  static async build(config: NetworkConfig<any>){
    let instance = new this(config.networkId)
    instance._near = await connect({
      keyStore: instance.keyStore,
      networkId: config.networkId,
      nodeUrl: config.nodeUrl,
    })
    return instance
  }

  get near(){
    return this._near!
  }
}
export type NetworkId = "sandbox" | "testnet"

'''
'''--- src/near.ts ---
import { NetworkConfig } from "./config"
import { Account, utils, keyStores, Near } from "near-api-js"
import { AccountBalance } from "near-api-js/lib/account"
import { NAMED_ACCOUNT_MAX_LENGTH } from "./constants"
import { ACCOUNT_ID_TOO_BIG } from "./errors"
import { NearConncetion } from "./near-connection"
import { BN } from "bn.js"
import { Logger } from "./logger"
import {ContractSpec} from "./contract"
import { readFileSync } from "fs"
import path from "path"
import { assert, isString } from "js-utils"
import {__dirname} from "./init"

export function getSubAccName(name: string, parentAccName: string) {
  let result = name + "." + parentAccName
  assert(result.length <= NAMED_ACCOUNT_MAX_LENGTH, ACCOUNT_ID_TOO_BIG + " is " + result.length)
  return result
}

export async function getAccFromFile(file: string, connection: NearConncetion): Promise<Account> {
  let keyFile: { secret_key: string, private_key: string, account_id: string }
  try {
    keyFile = JSON.parse(readFileSync(file).toString())
  }
  catch (e) {
    throw Error(`file: ${file} not found`)
  }

  let key = keyFile.secret_key || keyFile.private_key
  let name = keyFile.account_id
  return await getExistentAcc(name, connection, getKeyPair(key))
}
interface KeyFile {
  secret_key?: string
  private_key?: string
  account_id: string
}
export type PrivKey = string
export function getKeyPair(privKey: string) {
  return utils.KeyPair.fromString(privKey)
}

export async function getKey(account: Account, connection : NearConncetion): Promise<PrivKey>{
  let key = await connection.keyStore.getKey(connection.networkId, account.accountId)
  return key.toString()
}

export async function getExistentAcc(name: string, connection: NearConncetion, keyPair: utils.key_pair.KeyPair | string): Promise<Account> {
  if (isString(keyPair)){
    keyPair = getKeyPair(keyPair)
  }
  await connection.keyStore.setKey(connection.networkId, name, keyPair)
  return await connection.near.account(name)
}
export async function createSubAccount(masterAccount: Account, connection: NearConncetion, name?: string, props?: { nameSuffixLength?: number, accountIdlength?: number, near?: number }): Promise<Account> {
  let times = 0
  let accountName: string
  let run = async () => {
    // get final name of account
    if (name) {
      if (props?.nameSuffixLength) {
        let length = NAMED_ACCOUNT_MAX_LENGTH - masterAccount.accountId.length - name.length - 1
        length = length > props.nameSuffixLength ? props.nameSuffixLength : length
        assert(length > 0, ACCOUNT_ID_TOO_BIG + " is " + length)
        let id = makeRandomid(length)
        accountName = getSubAccName(name + "_" + id, masterAccount.accountId)
      }
      else {
        assert(name.length + masterAccount.accountId.length + 1 <= NAMED_ACCOUNT_MAX_LENGTH, ACCOUNT_ID_TOO_BIG + " is " + name.length + masterAccount.accountId.length)
        accountName = getSubAccName(name, masterAccount.accountId)
      }
    }
    else {
      accountName = getSubAccName(makeRandomid(props?.accountIdlength || NAMED_ACCOUNT_MAX_LENGTH - masterAccount.accountId.length), masterAccount.accountId)
    }

    let masterKey = await connection.keyStore.getKey(connection.networkId, masterAccount.accountId)
    await connection.keyStore.setKey(connection.networkId, accountName, masterKey)
    let transfer = props?.near ? utils.format.parseNearAmount(String(props.near)) : "0"
    await masterAccount.createAccount(
      accountName,
      masterKey.getPublicKey(),
      new BN(transfer ? transfer : "0")
    );
  }
  try {
    await run()
  } catch (e) {
    if (times < 5)
    times++
    await run()
    Logger.error("error creating account: " + e, true)
    throw Error("error creating account: " + e)
  }
  let account = await connection.near.account(accountName!)
  Logger.info("account created: " + account.accountId, true)
  return account
}

export async function getKeyPairOfAcc(accountId: string, connection: NearConncetion) {
  return await connection.keyStore.getKey(connection.networkId, accountId)
}

export async function deployContract(contractAccount: Account, contract: string) {
  await contractAccount.deployContract(readFileSync(contract))
  let msg = `contract deployed at ${contractAccount.accountId}`
  Logger.info(msg, true)
}

function makeRandomid(length: number) {
  var result = '';
  var characters = 'abcdefghijklmnopqrstuvwxyz';
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() *
      charactersLength));
  }

  return result;
}
export async function deleteAccounts(accounts: Account[], beneficiary: Account) {
  for (let i = 0; i < accounts.length; i++) {
    try {
      accounts[i].deleteAccount(beneficiary.accountId)
    } catch (e) {
      Logger.error("Error deleting " + accounts[i].accountId, true)
    }
  }
}
'''
'''--- src/start.ts ---
import { readdirSync } from "fs"
import path from "path"
import {assert, hasValue} from "js-utils"
import "./init"
import { readLine } from "./interactiveConsole.js"
import { Logger } from "./logger.js"
import {__dirname} from "./init"

export async function askWhatToExecute(options: string[]): Promise<string>{
  console.log("select script to run or 'q' to quit\n")

  for (let index = 0; index < options.length; index++) {
    let element = options[index]
    console.log(index + 1 + "> " + element)
  }
  let command = await readLine()
  if (command.toLowerCase() === "q"){
    process.exit(0)
  }
  let option = Number.parseInt(command)
  
  if (Number.isInteger(option) && option <= options.length && option > 0){
    Logger.info("executing \"" + options[option - 1] + "\"", true)
    return options[option - 1]
  }
  else{
    console.log("Invalid option")
    process.exit(1)
  }
}

'''
'''--- src/util.ts ---
function areEqualShallow(a: any, b: any) {
  for (var key in a) {
    if (!(key in b) || a[key] !== b[key]) {
      return false;
    }
  }
  for (var key in b) {
    if (!(key in a) || a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function allPropsEqual(a: any, b: any) {
  for (var key in a) {
    if ((key in b) && a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}

function* times(x: any) {
  for (var i = 0; i < x; i++)
    yield i;
}

export function replacer(key: any, value: any) {
  if(value instanceof Map) {
    return Object.fromEntries(value.entries())
  } else {
    return value
  }
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "out",
    "allowJs": true,
    "moduleResolution": "node",
    "declaration": true,
    "noImplicitAny": true,
    "removeComments": false,
    "preserveConstEnums": false,
    "sourceMap": true,
    "target": "es2021",
    "experimentalDecorators": true,
    "baseUrl": "./",
    "esModuleInterop": true,
    "strict": true,
    "alwaysStrict": true,
  }
}
'''