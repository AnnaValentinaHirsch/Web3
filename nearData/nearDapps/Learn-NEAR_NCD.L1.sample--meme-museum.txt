*GitHub Repository "Learn-NEAR/NCD.L1.sample--meme-museum"*

'''--- Cargo.toml ---
[workspace]
members = [
  "simulation"
]

'''
'''--- README.md ---
# The Meme Museum

This repository includes contracts for NEAR Academy

## ⚠️ Warning

Any content produced by NEAR, or developer resources that NEAR provides, are for educational and inspiration purposes only.  NEAR does not encourage, induce or sanction the deployment of any such applications in violation of applicable laws or regulations.

## Usage

### Getting started

1. clone this repo to a local folder
2. run `yarn`
3. run `yarn test`

### Top-level `yarn` commands

- run `yarn test` to run all tests
  - (!) be sure to run `yarn build:release` at least once before:
    - run `yarn test:unit` to run only unit tests
    - run `yarn test:simulate` to run only simulation tests
- run `yarn build` to quickly verify build status
- run `yarn clean` to clean up build folder

### Other documentation

- **Meme** contract and test documentation
  - see `/src/meme/README` for Meme interface
  - see `/src/meme/__tests__/README` for Meme unit testing details

- **Museum** contract and test documentation
  - see `/src/museum/README` for Museum interface
  - see `/src/museum/__tests__/README` for Museum unit testing details

- simulation tests
  - see `/simulation/README` for simulation testing

## The file system

Please note that boilerplate project configuration files have been ommitted from the following lists for simplicity.

### Contracts and Unit Tests

```txt
src
├── meme                          <-- Meme contract
│   ├── README.md
│   ├── __tests__
│   │   ├── README.md
│   │   └── index.unit.spec.ts
│   └── assembly
│       ├── index.ts
│       └── models.ts
├── museum                        <-- Museum contract
│   ├── README.md
│   ├── __tests__
│   │   ├── README.md
│   │   └── index.unit.spec.ts
│   └── assembly
│       ├── index.ts
│       └── models.ts
└── utils.ts                      <-- shared contract code
```

### Simulation Tests

```txt
simulation                        <-- simulation tests
├── Cargo.toml
├── README.md
└── src
    ├── lib.rs
    ├── meme.rs
    └── museum.rs
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/meme",
    "src/museum"
  ]
}

'''
'''--- package.json ---
{
  "name": "near-academy-contracts",
  "version": "0.0.1",
  "description": "Contracts for the Meme Museum on NEAR Academy",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn build:release && yarn test:unit && yarn test:simulate",
    "test:simulate": "cargo test -- --nocapture",
    "clean": "rm -rf ./build",
    "test:debug": "node --inspect-brk ./node_modules/.bin/asp"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "2.2.4"
  }
}

'''
'''--- simulation/Cargo.toml ---
[package]
name = "simulation-near-academy-contracts"
version = "0.1.0"
authors = ["NEAR Inc <hello@near.org>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = { git = "https://github.com/near/near-sdk-rs.git", tag = "2.2.0" }
near-sdk-sim = { git = "https://github.com/near/near-sdk-rs.git", tag = "2.2.0"}

'''
'''--- simulation/README.md ---
# Simulation Tests

## Usage

`yarn test:simulate`

## File Structure

```txt
simulation
├── Cargo.toml      <-- Rust project config
├── README.md       <-- * you are here
└── src
    ├── lib.rs      <-- this is the business end of simulation
    ├── meme.rs     <-- type wrapper for Meme contract
    └── museum.rs   <-- type wrapper for Museum contract
```

## Orientation

The simulation environment requires that we

## Output

```txt
running 1 test
---------------------------------------
---- INIT MUSEUM ----------------------
---------------------------------------

ExecutionResult {
    outcome: ExecutionOutcome {
        logs: [
            "museum was created",
        ],
        receipt_ids: [],
        burnt_gas: 4354462070277,
        tokens_burnt: 0,
        status: SuccessValue(``),
    },
}

---------------------------------------
---- ADD CONTRIBUTOR ------------------
---------------------------------------

ExecutionResult {
    outcome: ExecutionOutcome {
        logs: [
            "contributor was added",
        ],
        receipt_ids: [],
        burnt_gas: 4884161460212,
        tokens_burnt: 0,
        status: SuccessValue(``),
    },
}

---------------------------------------
---- CREATE MEME ----------------------
---------------------------------------

[
    Some(
        ExecutionResult {
            outcome: ExecutionOutcome {
                logs: [],
                receipt_ids: [
                    `AmMRhhhYir4wNuUxhf8uCoKgnpv5nHQGvBqAeEWFL344`,
                ],
                burnt_gas: 2428142357466,
                tokens_burnt: 0,
                status: SuccessReceiptId(AmMRhhhYir4wNuUxhf8uCoKgnpv5nHQGvBqAeEWFL344),
            },
        },
    ),
    Some(
        ExecutionResult {
            outcome: ExecutionOutcome {
                logs: [
                    "attempting to create meme",
                ],
                receipt_ids: [
                    `B2BBAoJYj3EFE3Co6PRmfkXopTD654gUj8H6ywSsQD9e`,
                    `4NWBWN9dWuwiwbkwnub9Rv134Ubu2eJmbkdk1bJzeFtr`,
                ],
                burnt_gas: 19963342520004,
                tokens_burnt: 0,
                status: SuccessValue(``),
            },
        },
    ),
    Some(
        ExecutionResult {
            outcome: ExecutionOutcome {
                logs: [],
                receipt_ids: [],
                burnt_gas: 4033749130056,
                tokens_burnt: 0,
                status: SuccessValue(``),
            },
        },
    ),
    Some(
        ExecutionResult {
            outcome: ExecutionOutcome {
                logs: [
                    "Meme [ usain.museum ] successfully created",
                ],
                receipt_ids: [],
                burnt_gas: 4644097556149,
                tokens_burnt: 0,
                status: SuccessValue(``),
            },
        },
    ),
]

---------------------------------------
---- VERIFY MEME ----------------------
---------------------------------------

Object({
    "creator": String(
        "museum",
    ),
    "created_at": String(
        "17000000000",
    ),
    "vote_score": Number(
        0,
    ),
    "total_donations": String(
        "0",
    ),
    "title": String(
        "usain refrain",
    ),
    "data": String(
        "https://9gag.com/gag/ayMDG8Y",
    ),
    "category": Number(
        0,
    ),
})

test test::test_add_meme ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests simulation-near-academy-contracts

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

✨  Done in 20.99s.

```

'''
'''--- simulation/src/lib.rs ---
#![allow(dead_code, unused_variables, unused_imports, non_snake_case)]
mod museum;
pub use museum::*;

mod meme;
pub use meme::*;

#[cfg(test)]
mod test {
    use near_sdk::{json_types::Base58PublicKey, serde_json::json}; //, U128};
    use near_sdk_sim::near_crypto::{InMemorySigner, KeyType};
    // use std::convert::TryInto;

    use super::*;
    use near_sdk_sim::{
        call, deploy, init_simulator, to_yocto, view, ContractAccount, UserAccount,
    };

    // Load in contract bytes
    near_sdk_sim::lazy_static! {
      static ref MUSEUM_WASM_BYTES: &'static [u8] = include_bytes!("../../build/release/museum.wasm").as_ref();
    }

    // ------------------------------------------------------------------------
    // setup meme contract
    // ------------------------------------------------------------------------
    fn initMuseum() -> (UserAccount, ContractAccount<MuseumContract>) {
        let master_account = init_simulator(None);

        let museum_contract = deploy!(
            // Contract Proxy
            contract: MuseumContract,
            // Contract account id
            contract_id: "museum",
            // Bytes of contract
            bytes: &MUSEUM_WASM_BYTES,
            // User deploying the contract,
            signer_account: master_account
        );

        (master_account, museum_contract)
    }

    // ------------------------------------------------------------------------
    // test add meme to museum
    // ------------------------------------------------------------------------
    #[test]
    fn test_add_meme() {
        let (master_account, museum) = initMuseum();

        // ----------------------------
        // setup accounts
        // ----------------------------

        // an owner will be able to manage the museum
        let owner = master_account.create_user("alice".to_string(), to_yocto("100"));

        // a contributor will be able to add memes
        let contributor = master_account.create_user("bob".to_string(), to_yocto("100"));

        // ----------------------------
        // initialize museum
        // ----------------------------
        println!("---------------------------------------");
        println!("---- INIT MUSEUM ----------------------");
        println!("---------------------------------------");
        println!("");

        let name = "meme museum";

        let res = call!(
            master_account,
            museum.init(&name, vec![&owner.account_id()]),
            deposit = to_yocto("3")
        );

        println!("{:#?}\n", res);
        res.assert_success(); // museum has been initialized

        // ----------------------------
        // add contributor to museum
        // ----------------------------
        println!("---------------------------------------");
        println!("---- ADD CONTRIBUTOR ------------------");
        println!("---------------------------------------");
        println!("");

        let res = call!(owner, museum.add_contributor(&contributor.account_id()));

        println!("{:#?}\n", res);
        res.assert_success(); // contributor has been added

        // ----------------------------
        // add meme
        // ----------------------------
        println!("---------------------------------------");
        println!("---- CREATE MEME ----------------------");
        println!("---------------------------------------");
        println!("");

        let name = "usain";
        let title = "usain refrain";
        let data = "https://9gag.com/gag/ayMDG8Y";
        let category = 0; // Category.A

        let res = call!(
            contributor,
            museum.add_meme(&name, &title, &data, category),
            deposit = to_yocto("3")
        );

        println!("{:#?}\n", res.promise_results());
        res.assert_success(); // meme has been added

        let meme = near_sdk_sim::ContractAccount::<MemeContract> {
            user_account: museum
                .user_account
                .switch_signer(contributor.signer.clone()),
            contract: MemeContract {
                account_id: "usain.museum".to_string(),
            },
        };

        // ----------------------------
        // call meme for metadata
        // ----------------------------
        println!("---------------------------------------");
        println!("---- VERIFY MEME ----------------------");
        println!("---------------------------------------");
        println!("");

        let res = view!(meme.get_meme());
        println!("{:#?}\n", res.unwrap_json_value());
    }
}

'''
'''--- simulation/src/meme.rs ---
use std::fmt::Debug;

use near_sdk::near_bindgen;

#[near_bindgen]
pub struct Meme {}

#[near_bindgen]
impl Meme {
    // ------------------------------------------------------------------------
    // initialization
    // ------------------------------------------------------------------------

    pub fn init(title: &str, data: &str, category: u8) {}

    // pub fn get_meme() -> Meme {}
    pub fn get_meme() {}

    // ------------------------------------------------------------------------
    // voting
    // ------------------------------------------------------------------------

    pub fn vote(value: i8) {}

    pub fn batch_vote(value: i8, is_batch: bool) {}

    // pub fn get_recent_votes() -> Vec<Vote> {}
    pub fn get_recent_votes() {}

    // pub fn get_vote_score() -> i32 {}
    pub fn get_vote_score() {}

    // ------------------------------------------------------------------------
    // comments
    // ------------------------------------------------------------------------

    pub fn add_comment(text: &str) {}

    // pub fn get_recent_comments() -> Array<Comment> {}
    pub fn get_recent_comments() {}

    // ------------------------------------------------------------------------
    // donations
    // ------------------------------------------------------------------------

    pub fn donate() {}

    // pub fn get_donations_total() -> U128 {}
    pub fn get_donations_total() {}

    // pub fn get_recent_donations(): Array<Donation> {
    pub fn get_recent_donations() {}

    pub fn release_donations(account: &str) {}

    pub fn on_donations_released() {}
}

'''
'''--- simulation/src/museum.rs ---
use near_sdk::json_types::U128;
use near_sdk::near_bindgen;

#[near_bindgen]
pub struct Museum {}

#[near_bindgen]
impl Museum {
    // ------------------------------------------------------------------------
    // initialization
    // ------------------------------------------------------------------------

    pub fn init(name: &str, owners: Vec<&str>) {}

    // pub fn get_museum() -> Museum
    pub fn get_museum() {}

    // ------------------------------------------------------------------------
    // self-service methods
    // ------------------------------------------------------------------------

    // pub fn get_owner_list() -> AccountId[]
    pub fn get_owner_list() {}

    // pub fn get_meme_list() -> AccountId[]
    pub fn get_meme_list() {}

    // pub fn get_meme_count() -> u32
    pub fn get_meme_count() {}

    pub fn add_myself_as_contributor() {}

    pub fn remove_myself_as_contributor() {}

    pub fn add_meme(meme: &str, title: &str, data: &str, category: u8) {}

    // ------------------------------------------------------------------------
    // owner methods
    // ------------------------------------------------------------------------

    pub fn add_contributor(account: &str) {}

    pub fn remove_contributor(account: &str) {}

    pub fn add_owner(account: &str) {}

    pub fn remove_owner(account: &str) {}

    pub fn remove_meme(meme: &str) {}

    pub fn on_meme_removed(meme: &str) {}

    pub fn museum_to_meme_proxy(meme: &str, view_fn: &str) {}
}

'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/meme/README.md ---
# Meme Contract

**NOTE**

If you try to call a method which requires a signature from a valid account, you will see this error:

```txt
"error": "wasm execution failed with error: FunctionCallError(HostError(ProhibitedInView ..."
```

This will happen anytime you try using `near view ...` when you should be using `near call ...`.  So it's important to pay close attention in the following examples as to which is being used, a `view` or a `call` (aka. "change") method.

----

## deployment

```sh
near dev-deploy ./build/release/meme.wasm
```

## initialization

`init(title: string, data: string, category: Category): void`

```sh
# anyone can initialize meme (so this must be done by the museum at deploy-time)
near call dev-1614603380541-7288163 init '{"title": "hello world", "data": "https://9gag.com/gag/ayMDG8Y", "category": 0}' --account_id dev-1614603380541-7288163 --amount 3
```

## view methods

`get_meme(): Meme`

```sh
# anyone can read meme metadata
near view dev-1614603380541-7288163 get_meme
```

```js
{
  creator: 'dev-1614603380541-7288163',
  created_at: '1614603702927464728',
  vote_score: 4,
  total_donations: '0',
  title: 'hello world',
  data: 'https://9gag.com/gag/ayMDG8Y',
  category: 0
}
```

`get_recent_votes(): Array<Vote>`

```sh
# anyone can request a list of recent votes
near view dev-1614603380541-7288163 get_recent_votes
```

```js
[
  {
    created_at: '1614603886399296553',
    value: 1,
    voter: 'dev-1614603380541-7288163'
  },
  {
    created_at: '1614603988616406809',
    value: 1,
    voter: 'sherif.testnet'
  },
  {
    created_at: '1614604214413823755',
    value: 2,
    voter: 'batch-dev-1614603380541-7288163'
  },
  [length]: 3
]
```

`get_vote_score(): i32`

```sh
near view dev-1614603380541-7288163 get_vote_score
```

```js
4
```

`get_donations_total(): u128`

```sh
near view dev-1614603380541-7288163 get_donations_total
```

```js
'5000000000000000000000000'
```

`get_recent_donations(): Array<Donation>`

```sh
near view dev-1614603380541-7288163 get_recent_donations
```

```js
[
  {
    amount: '5000000000000000000000000',
    donor: 'sherif.testnet',
    created_at: '1614604980292030188'
  },
  [length]: 1
]
```

## change methods

`vote(value: i8): void`

```sh
# user votes for meme
near call dev-1614603380541-7288163 vote '{"value": 1}' --account_id sherif.testnet
```

`batch_vote(value: i8, is_batch: bool = true): void`

```sh
# only the meme contract can call this method
near call dev-1614603380541-7288163 batch_vote '{"value": 2}' --account_id dev-1614603380541-7288163
```

`add_comment(text: string): void`

```sh
near call dev-1614603380541-7288163 add_comment '{"text":"i love this meme"}' --account_id sherif.testnet
```

`get_recent_comments(): Array<Comment>`

```sh
near view dev-1614603380541-7288163 get_recent_comments
```

```js
[
  {
    created_at: '1614604543670811624',
    author: 'sherif.testnet',
    text: 'i love this meme'
  },
  [length]: 1
]
```

`donate(): void`

```sh
near call dev-1614603380541-7288163 donate --account_id sherif.testnet --amount 5
```

`release_donations(account: AccountId): void`

```sh
near call dev-1614603380541-7288163 release_donations '{"account":"sherif.testnet"}' --account_id dev-1614603380541-728816
```

This method automatically calls `on_donations_released` which logs *"Donations were released"*

'''
'''--- src/meme/__tests__/README.md ---
# Unit Tests for `Meme` Contract

## Usage

```sh
yarn test:unit -f meme
```

## Output

*Note: the tests marked with `Todo` must be verified using simulation tests because they involve cross-contract calls (which can not be verified using unit tests).*

```txt
[Describe]: meme initialization

 [Success]: ✔ creates a new meme with proper metadata
 [Success]: ✔ prevents double initialization
 [Success]: ✔ requires title not to be blank
 [Success]: ✔ requires a minimum balance

[Describe]: meme voting

 [Success]: ✔ allows individuals to vote
 [Success]: ✔ prevents vote automation for individuals
 [Success]: ✔ prevents any user from voting more than once

[Describe]: meme captures votes

 [Success]: ✔ captures all votes
 [Success]: ✔ calculates a running vote score
 [Success]: ✔ returns a list of recent votes

 [Success]: ✔ allows groups to vote

[Describe]: meme comments

 [Success]: ✔ captures comments
 [Success]: ✔ rejects comments that are too long
 [Success]: ✔ captures multiple comments

[Describe]: meme donations

 [Success]: ✔ captures donations
[Describe]: captures donations

 [Success]: ✔ captures all donations
 [Success]: ✔ calculates a running donations total
 [Success]: ✔ returns a list of recent donations

    [Todo]: releases donations

    [File]: src/meme/__tests__/index.unit.spec.ts
  [Groups]: 7 pass, 7 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 18 pass,  0 fail, 18 total
    [Time]: 46.469ms
```

'''
'''--- src/meme/__tests__/index.unit.spec.ts ---
import { VMContext, u128, PersistentVector, PersistentSet } from "near-sdk-as";
import * as util from "../../utils";
import * as model from "../assembly/models";
import * as contract from "../assembly";

/**
 * == CONFIG VALUES ============================================================
 */
const TITLE = "usain refrain";
const DATA = "https://9gag.com/gag/ayMDG8Y";
const CATEGORY = util.Category.A;
const MUSEUM_ACCOUNT_ID = "museum";
const CREATOR_ACCOUNT_ID = "alice";
const CONTRIBUTOR_ACCOUNT_ID = "bob";
const ONE_NEAR = u128.from('1000000000000000000000000');
const ATTACHED_DEPOSIT = u128.mul(ONE_NEAR, u128.from(10));

/**
 * == HELPER FUNCTIONS =========================================================
 */
const useMuseumAsPredecessor = (): void => {
  VMContext.setPredecessor_account_id(MUSEUM_ACCOUNT_ID);
};

const useContributorAsPredecessor = (): void => {
  VMContext.setPredecessor_account_id(CONTRIBUTOR_ACCOUNT_ID);
};

const attachMinBalance = (): void => {
  VMContext.setAttached_deposit(util.MIN_ACCOUNT_BALANCE);
};

const doInitialize = (): void => {
  attachMinBalance();
  useMuseumAsPredecessor();
  contract.init(TITLE, DATA, CATEGORY);
}

const comments = (): PersistentVector<model.Comment> => {
  return new PersistentVector<model.Comment>("c");
};

const votes = (): PersistentVector<model.Vote> => {
  return new PersistentVector<model.Vote>("v");
};

const voters = (): PersistentSet<util.AccountId> => {
  return new PersistentSet<util.AccountId>("vs");
};

const donations = (): PersistentVector<model.Donation> => {
  return new PersistentVector<model.Donation>("d");
};

/**
 * == UNIT TESTS ==============================================================
 */

describe("meme initialization", () => {
  beforeEach(useMuseumAsPredecessor)

  it("creates a new meme with proper metadata", () => {
    attachMinBalance()

    contract.init(TITLE, DATA, CATEGORY);
    const m = contract.get_meme()

    expect(m.title).toBe(TITLE)
    expect(m.data).toBe(DATA)
    expect(m.category).toBe(CATEGORY)
    expect(m.total_donations).toBe(u128.Zero)
    expect(m.vote_score).toBe(0)
  });

  it("prevents double initialization", () => {
    attachMinBalance()

    contract.init(TITLE, DATA, CATEGORY);

    expect(() => {
      contract.init(TITLE, DATA, CATEGORY);
    }).toThrow("Contract is already initialized")
  });

  it("requires title not to be blank", () => {
    attachMinBalance()

    expect(() => {
      contract.init("", DATA, CATEGORY);
    }).toThrow("Meme title may not be blank")
  });

  it("requires a minimum balance", () => {
    expect(() => {
      contract.init(TITLE, DATA, CATEGORY);
    }).toThrow("Minimum account balance must be attached to initialize this contract (3 NEAR)")
  });

});

describe("meme voting", () => {
  beforeEach(doInitialize)

  it("allows individuals to vote", () => {
    useContributorAsPredecessor()

    expect(votes.length).toBe(0)
    contract.vote(1)
    expect(votes().length).toBe(1)
  });

  it("prevents vote automation for individuals", () => {
    expect(() => {
      contract.vote(1)
    }).toThrow("Users must vote directly")
  })

  it("prevents any user from voting more than once", () => {
    useContributorAsPredecessor()
    contract.vote(1)

    expect(() => {
      contract.vote(1)
    }).toThrow("Voter has already voted")
  });

  describe("meme captures votes", () => {
    beforeEach(() => {
      VMContext.setSigner_account_id(CREATOR_ACCOUNT_ID)
      VMContext.setPredecessor_account_id(CREATOR_ACCOUNT_ID)
      contract.vote(1)

      VMContext.setSigner_account_id(CONTRIBUTOR_ACCOUNT_ID)
      VMContext.setPredecessor_account_id(CONTRIBUTOR_ACCOUNT_ID)
      contract.vote(1)
    })

    it("captures all votes", () => {
      expect(votes().length).toBe(2)
      expect(voters().values().length).toBe(2)
    });

    it("calculates a running vote score", () => {
      expect(contract.get_vote_score()).toBe(2)
    });

    it("returns a list of recent votes", () => {
      expect(contract.get_recent_votes().length).toBe(2)
    })
  })

  it("allows groups to vote", () => {
    VMContext.setSigner_account_id(CREATOR_ACCOUNT_ID)
    VMContext.setPredecessor_account_id(CREATOR_ACCOUNT_ID)

    contract.batch_vote(3)

    expect(votes().length).toBe(1)
    expect(voters().values()[0].startsWith("batch-")).toBeTruthy()
  });
});

describe("meme comments", () => {
  beforeEach(doInitialize)

  beforeEach(() => {
    VMContext.setSigner_account_id(CONTRIBUTOR_ACCOUNT_ID)
    VMContext.setPredecessor_account_id(CONTRIBUTOR_ACCOUNT_ID)
  })

  it("captures comments", () => {
    contract.add_comment("i love this meme!")
    expect(comments().length).toBe(1)
  })

  it("rejects comments that are too long", () => {
    expect(() => {
      // AssemblyScript doesn't support closures as of time of writing
      const TOO_LONG_TEXT = "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore, doloremque. Quod maiores consectetur praesentium, aperiam repellendus facere velit dolorum vel corporis nisi pariatur asperiores animi quibusdam soluta deserunt nam? Repudiandae quidem quos expedita, vero, obcaecati ex, incidunt sequi porro corporis unde omnis ducimus tempora earum excepturi atque ea aliquid aliquam voluptates necessitatibus sit nostrum iure? Velit adipisci hic molestiae iure minima sint illum ex mollitia vitae consequuntur deserunt sit placeat, obcaecati quasi fugit odit aspernatur animi repellendus fugiat at dignissimos nihil!";

      contract.add_comment(TOO_LONG_TEXT)
    }).toThrow("Comment is too long, must be less than 500")
  });

  it("captures multiple comments", () => {
    VMContext.setSigner_account_id(CREATOR_ACCOUNT_ID)
    VMContext.setPredecessor_account_id(CREATOR_ACCOUNT_ID)
    contract.add_comment("i love this")

    VMContext.setSigner_account_id(CONTRIBUTOR_ACCOUNT_ID)
    VMContext.setPredecessor_account_id(CONTRIBUTOR_ACCOUNT_ID)
    contract.add_comment("i don't like it")

    expect(contract.get_recent_comments().length).toBe(2)
  });
})

describe("meme donations", () => {
  beforeEach(doInitialize)

  it("captures donations  ", () => {
    VMContext.setAttached_deposit(ATTACHED_DEPOSIT)
    VMContext.setSigner_account_id(CREATOR_ACCOUNT_ID)
    VMContext.setPredecessor_account_id(CREATOR_ACCOUNT_ID)

    contract.donate()
    expect(contract.get_meme().total_donations).toBe(ATTACHED_DEPOSIT)
  })

  describe("captures donations", () => {

    beforeEach(() => {
      VMContext.setAttached_deposit(ATTACHED_DEPOSIT)

      VMContext.setSigner_account_id(CREATOR_ACCOUNT_ID)
      VMContext.setPredecessor_account_id(CREATOR_ACCOUNT_ID)
      contract.donate()

      VMContext.setSigner_account_id(CONTRIBUTOR_ACCOUNT_ID)
      VMContext.setPredecessor_account_id(CONTRIBUTOR_ACCOUNT_ID)
      contract.donate()
    })

    it("captures all donations", () => {
      expect(donations().length).toBe(2)
    });

    it("calculates a running donations total", () => {
      const twice_attached_deposit = u128.mul(u128.from(2), ATTACHED_DEPOSIT)
      expect(contract.get_donations_total()).toBe(twice_attached_deposit)
    });

    it("returns a list of recent donations", () => {
      expect(contract.get_recent_donations().length).toBe(2)
    })
  })

  // we have to use simulation tests for cross-contract calls
  xit("releases donations", () => { })
})

'''
'''--- src/meme/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/meme/assembly/index.ts ---
import {
  u128,
  context,
  storage,
  logging,
  ContractPromiseBatch,
} from "near-sdk-as";

import { MEME_KEY, XCC_GAS, MIN_ACCOUNT_BALANCE, MAX_COMMENT_LENGTH, AccountId, Category } from "../../utils";
import { Comment, Vote, Meme, Donation } from "./models";

/**
 * == PUBLIC METHODS ==========================================================
 *
 * The contract's public API.
 */

/**
 * Initialize meme with basic metadata
 *
 * @param title the name of the meme
 * @param data the data containing some unique identifier of the meme used for rendering
 * @param category the category of the meme
 */
export function init(title: string, data: string, category: Category): void {
  // contract may only be initialized once
  assert(!is_initialized(), "Contract is already initialized.");

  // storing meme metadata requires some storage staking (balance locked to offset cost of data storage)
  assert(
    u128.ge(context.attachedDeposit, MIN_ACCOUNT_BALANCE),
    "Minimum account balance must be attached to initialize this contract (3 NEAR)"
  );

  // title has to be at least 1 character
  assert(title.length > 0, "Meme title may not be blank");

  // create the meme using incoming metadata
  Meme.create(title, data, category)
}

/**
 * Return the meme
 */
export function get_meme(): Meme {
  assert_contract_is_initialized()
  return Meme.get()
}

// ----------------------------------------------------------------------------
// Voting
// ----------------------------------------------------------------------------

/**
 * Register a single vote, up or down, for the meme
 *
 * @param value the value of the vote, up vote is +1 and down vote is -1
 */
export function vote(value: i8): void {
  assert_contract_is_initialized()
  assert(context.sender == context.predecessor, "Users must vote directly")
  assert(value == 1 || value == -1, "Invalid vote, must be -1 or 1")

  // register the vote
  batch_vote(value, false)
}

/**
 * Register a batched vote where several votes are captured together
 *
 * @param value the value of the batched vote, max possible batch score is +/- 127
 * @param isGroup
 */
export function batch_vote(value: i8, is_batch: bool = true): void {
  // register the vote
  if (is_batch) {
    assert(context.predecessor == context.contractName, "Batch votes may only be made by the Meme account")
  }

  const voter = is_batch ? "batch-" + context.predecessor : context.predecessor
  Meme.add_vote(voter, value)
}

/**
 * Get a list ofrecent votes
 */
export function get_recent_votes(): Array<Vote> {
  assert_contract_is_initialized()
  return Meme.recent_votes()
}

/**
 * Get the current vote score
 */
export function get_vote_score(): i32 {
  assert_contract_is_initialized()
  return Meme.get().vote_score
}

// ----------------------------------------------------------------------------
// Comments
// ----------------------------------------------------------------------------

/**
 * Add a comment
 *
 * @param text the text of the comment, max comment length of MAX_COMMENT_LENGTH
 */
export function add_comment(text: string): void {
  assert_contract_is_initialized()
  assert(context.sender == context.predecessor, "Users must comment directly")
  assert_reasonable_comment_length(text)
  Meme.add_comment(text)
}

/**
 * Get a list o recent comments
 */
export function get_recent_comments(): Array<Comment> {
  assert_contract_is_initialized()
  return Meme.recent_comments()
}

// ----------------------------------------------------------------------------
// Donations
// ----------------------------------------------------------------------------

/**
 * Donate tokens to the contract
 */
export function donate(): void {
  assert_contract_is_initialized()
  assert(context.sender == context.predecessor, "Users must donate directly")
  assert(context.attachedDeposit > u128.Zero, "Donor must attach some money")

  Meme.add_donation()
}

/**
 * Get a list of donations
 */
export function get_donations_total(): u128 {
  assert_contract_is_initialized()
  return Meme.get().total_donations
}

/**
 * Get a list o recent comments
 */
export function get_recent_donations(): Array<Donation> {
  assert_contract_is_initialized()
  return Meme.recent_donations()
}

/**
 * Transfer all donations to a specified account
 *
 * @param account NEAR account to receive donations after release
 */
export function release_donations(account: AccountId): void {
  assert_contract_is_initialized()
  assert_signed_by_creator()

  // transfer funds to provided account and call ourselves back once transfer is complete
  ContractPromiseBatch.create(account)
    .transfer(Meme.get().total_donations)
    .then(context.contractName).function_call("on_donations_released", "{}", u128.Zero, XCC_GAS)
}

/**
 * Callback method invoked once donation release is complete
 */
export function on_donations_released(): void {
  logging.log("Donations were released")
}

/**
 * == PRIVATE FUNCTIONS ========================================================
 *
 * Helper functions that are not part of the contract interface
 */

/**
 * Manage comment properties
 */
function assert_reasonable_comment_length(text: string): void {
  assert(text.length < MAX_COMMENT_LENGTH, "Comment is too long, must be less than " + MAX_COMMENT_LENGTH.toString())
}

/**
 * Indicate whether contract caller is the creator
 */
function is_creator(): bool {
  return context.predecessor == Meme.get().creator
}

function assert_signed_by_creator(): void {
  assert(is_creator(), "This method can only be called by the meme creator")
}

/**
 * Track whether or not the meme has been initialized.
 */
function is_initialized(): bool {
  return storage.hasKey(MEME_KEY);
}

function assert_contract_is_initialized(): void {
  assert(is_initialized(), "Contract must be initialized first.");
}

'''
'''--- src/meme/assembly/models.ts ---
import {
  u128,
  context,
  storage,
  PersistentVector,
  PersistentSet
} from "near-sdk-as";

import { MEME_KEY, PAGE_SIZE, Category, AccountId, Money, Timestamp } from "../../utils";

@nearBindgen
export class Comment {
  created_at: Timestamp = context.blockTimestamp;
  author: AccountId = context.predecessor;

  constructor(
    public text: string
  ) { }
}

@nearBindgen
export class Vote {
  created_at: Timestamp = context.blockTimestamp;

  constructor(
    public value: i8,
    public voter: AccountId
  ) { }
}

@nearBindgen
export class Donation {
  // by default, without a constructor, all fields are public
  // so these instance fields will be set from the context
  // and then available on the public interface
  amount: Money = context.attachedDeposit;
  donor: AccountId = context.predecessor;
  created_at: Timestamp = context.blockTimestamp;
}

@nearBindgen
export class Meme {
  creator: AccountId = context.predecessor;
  created_at: Timestamp = context.blockTimestamp;
  vote_score: i32 = 0;
  total_donations: u128 = u128.Zero;

  constructor(
    public title: string,
    public data: string,
    public category: Category,
  ) { }

  // ----------------------------------------------------------------------------
  // Basic functions
  // ----------------------------------------------------------------------------

  static create(title: string, data: string, category: Category): void {
    // data has to have identifier from valid content provider
    assert(is_valid_meme_data(data), "Data is not valid, must start with valid 9gag.com URL")

    // save the meme to storage
    const meme = new Meme(title, data, category)
    this.set(meme)
  }

  static get(): Meme {
    return storage.getSome<Meme>(MEME_KEY)
  }

  static set(meme: Meme): void {
    storage.set(MEME_KEY, meme)
  }

  // ----------------------------------------------------------------------------
  // Voting
  // ----------------------------------------------------------------------------
  static add_vote(voter: string, value: i8): void {
    // allow each account to vote only once
    assert(!voters.has(voter), "Voter has already voted")
    // fetch meme from storage
    const meme = this.get()
    // calculate the new score for the meme
    meme.vote_score = meme.vote_score + value
    // save it back to storage
    this.set(meme)
    // remember the voter has voted
    voters.add(voter)
    // add the new Vote
    votes.push(new Vote(value, voter))
  }

  static get_votes_count(): u32 {
    return votes.length
  }

  static recent_votes(count: i32 = PAGE_SIZE): Vote[] {
    return votes.get_last(count)
  }

  // ----------------------------------------------------------------------------
  // Comments
  // ----------------------------------------------------------------------------
  static add_comment(text: string): void {
    comments.push(new Comment(text))
  }

  static get_comments_count(): u32 {
    return comments.length
  }

  static recent_comments(count: i32 = PAGE_SIZE): Comment[] {
    return comments.get_last(count)
  }

  // ----------------------------------------------------------------------------
  // Donations
  // ----------------------------------------------------------------------------
  static add_donation(): void {
    // fetch meme from storage
    const meme = this.get()
    // record the donation
    meme.total_donations = u128.add(meme.total_donations, context.attachedDeposit);
    // save it back to storage
    this.set(meme)
    // add the new Donation
    donations.push(new Donation())
  }

  static get_donations_count(): u32 {
    return donations.length
  }

  static recent_donations(count: i32 = PAGE_SIZE): Donation[] {
    return donations.get_last(count)
  }
}

/**
 * Handle validation and extraction of meme data
 */
function is_valid_meme_data(data: string): bool {
  return data.startsWith("https://9gag.com")
}

// DEPRECATED: decided against this
// to simplify rendering especially if we add more valid prefixes
function extract_identifier(data: string): string {
  const gag_id = data.split("/").pop()
  assert(gag_id.length < 20, "9gag.com ID is too long")
  return gag_id
}

/**
 * setup a generic subclass instead of duplicating the get_last method
 */
class Vector<T> extends PersistentVector<T> {
  /**
   * this method isn't normally available on a PersistentVector
   * so we add it here to make our lives easier when returning the
   * last `n` items for comments, votes and donations
   * @param count
   */
  get_last(count: i32): Array<T> {
    const n = min(count, this.length);
    const startIndex = this.length - n;
    const result = new Array<T>();
    for (let i = startIndex; i < this.length; i++) {
      const entry = this[i];
      result.push(entry);
    }
    return result;
  }
}

const comments = new Vector<Comment>("c");
const votes = new Vector<Vote>("v");
const voters = new PersistentSet<AccountId>("vs");
const donations = new Vector<Donation>("d");

'''
'''--- src/museum/README.md ---
# Museum Contract

**NOTE**

If you try to call a method which requires a signature from a valid account, you will see this error:

```txt
"error": "wasm execution failed with error: FunctionCallError(HostError(ProhibitedInView ..."
```

This will happen anytime you try using `near view ...` when you should be using `near call ...`.  So it's important to pay close attention in the following examples as to which is being used, a `view` or a `call` (aka. "change") method.

----

## environment

```sh
# contract source code
export WASM_FILE=./build/release/museum.wasm

# system accounts
export CONTRACT_ACCOUNT=# NEAR account where the contract will live
export MASTER_ACCOUNT=$CONTRACT_ACCOUNT # can be any NEAR account that controls CONTRACT_ACCOUNT

# user accounts
export OWNER_ACCOUNT=# NEAR account that will control the museum
export CONTRIBUTOR_ACCOUNT=# NEAR account that will contribute memes

# configuration metadata
export MUSEUM_NAME="The Meme Museum" # a name for the museum itself, just metadata
export ATTACHED_TOKENS=3 # minimum tokens to attach to the museum initialization method (for storage)
export ATTACHED_GAS="300000000000000" # maximum allowable attached gas is 300Tgas (300 "teragas", 300 x 10^12)
```

## deployment

**Approach #1**: using `near dev-deploy` for developer convenience

This contract can be deployed to a temporary development account that's automatically generated:

```sh
near dev-deploy $WASM_FILE
export CONTRACT_ACCOUNT=# the account that appears as a result of running this command
```

The result of executing the above command will be a temporary `dev-###-###` account and related `FullAccess` keys with the contract deployed (to this same account).

**Approach #2**: using `near deploy` for more control

Alternatively, the contract can be deployed to a specific account for which a `FullAccess` key is available.  This account must be created and funded first.

```sh
near create-account $CONTRACT_ACCOUNT --masterAccount $MASTER_ACCOUNT
near deploy $WASM_FILE
```

This manual deployment method is the only way to deploy a contract to a specific account.  It's important to consider initializing the contract in the same step.  This is clarified below in the "initialization" section.

## initialization

`init(name: string, owners: AccountId[]): void`

**Approach #1**: initialize after `dev-deploy`

After `near dev-deploy` we can initialize the contract

```sh
# initialization method arguments
# '{"name":"The Meme Museum", "owners": ["<owner-account-id>"]}'
export INIT_METHOD_ARGS="'{\"name\":\"$MUSEUM_NAME\", \"owners\": [\"$OWNER_ACCOUNT\"]}'"

# initialize contract
near call $CONTRACT_ACCOUNT init $INIT_METHOD_ARGS --account_id $CONTRACT_ACCOUNT --amount $ATTACHED_TOKENS
```

**Approach #2**: deploy and initialize in a single step

Or we can initialize at the same time as deploying.  This is particularly useful for production deployments where an adversarial validator may try to front-run your contract initialization unless you bundle the `FunctionCall` action to `init()` as part of the transaction to `DeployContract`.

```sh
# initialization method arguments
# '{"name":"The Meme Museum", "owners": ["<owner-account-id>"]}'
export INIT_METHOD_ARGS="'{\"name\":\"$MUSEUM_NAME\", \"owners\": [\"$OWNER_ACCOUNT\"]}'"

# deploy AND initialize contract in a single step
near deploy $CONTRACT_ACCOUNT $WASM_FILE --initFunction init --initArgs $INIT_METHOD_ARGS --account_id $CONTRACT_ACCOUNT --initDeposit $ATTACHED_TOKENS
```

## view methods

`get_museum(): Museum`

```sh
near view $CONTRACT_ACCOUNT get_museum
```

```js
{ created_at: '1614636541756865886', name: 'The Meme Museum' }
```

`get_owner_list(): AccountId[]`

```sh
near view $CONTRACT_ACCOUNT get_owner_list
```

```js
[ '<owner-account-id>', [length]: 1 ]
```

`get_meme_list(): AccountId[]`

```sh
near view $CONTRACT_ACCOUNT get_meme_list
```

```js
[ 'usain', [length]: 1 ]
```

`get_meme_count(): u32`

```sh
near view $CONTRACT_ACCOUNT get_meme_count
```

```js
1
```

## change methods

### contributor methods

`add_myself_as_contributor(): void`

```sh
near call $CONTRACT_ACCOUNT add_myself_as_contributor --account_id $CONTRIBUTOR_ACCOUNT
```

`remove_myself_as_contributor(): void`

```sh
near call $CONTRACT_ACCOUNT remove_myself_as_contributor --account_id $CONTRIBUTOR_ACCOUNT
```

`add_meme(meme: AccountId, title: string, data: string, category: Category): void`

```sh
near call $CONTRACT_ACCOUNT add_meme '{"meme":"usain", "title": "usain refrain","data":"https://9gag.com/gag/ayMDG8Y", "category": 0 }' --account_id $CONTRIBUTOR_ACCOUNT --amount $ATTACHED_TOKENS --gas $ATTACHED_GAS
```

`on_meme_created(meme: AccountId): void`

This method is called automatically by `add_meme()` as a confirmation of meme account creation.

### owner methods

`add_contributor(account: AccountId): void`

```sh
# initialization method arguments
# '{"account":"<contributor-account-id>"}'
export METHOD_ARGS="'{\"account\":\"$CONTRIBUTOR_ACCOUNT\"}'"
near call $CONTRACT_ACCOUNT add_contributor $METHOD_ARGS --account_id $OWNER_ACCOUNT
```

`remove_contributor(account: AccountId): void`

```sh
near call $CONTRACT_ACCOUNT remove_contributor '{"account":"<contributor-account-id>"}' --account_id $OWNER_ACCOUNT
```

`add_owner(account: AccountId): void`

```sh
near call $CONTRACT_ACCOUNT add_owner '{"account":"<new-owner-account-id>"}' --account_id $OWNER_ACCOUNT
```

`remove_owner(account: AccountId): void`

```sh
near call $CONTRACT_ACCOUNT remove_owner '{"account":"<some-owner-account-id>"}' --account_id $OWNER_ACCOUNT
```

`remove_meme(meme: AccountId): void`

```sh
near call $CONTRACT_ACCOUNT remove_meme '{"meme":"usain"}' --account_id $OWNER_ACCOUNT
```

`on_meme_removed(meme: AccountId): void`

This method is called automatically by `remove_meme()` as a confirmation of meme account deletion.

'''
'''--- src/museum/__tests__/README.md ---
# Unit Tests for `Museum` Contract

## Usage

```sh
yarn test:unit -f museum
```

## Output

*Note: the tests marked with `Todo` must be verified using simulation tests because they involve cross-contract calls (which can not be verified using unit tests).*

```txt
[Describe]: museum initialization

 [Success]: ✔ creates a new museum with proper metadata
 [Success]: ✔ prevents double initialization
 [Success]: ✔ requires title not to be blank
 [Success]: ✔ requires a minimum balance

[Describe]: Museum self-service methods

 [Success]: ✔ returns a list of owners
 [Success]: ✔ returns a list of memes
 [Success]: ✔ returns a count of memes
 [Success]: ✔ allows users to add / remove themselves as contributors
    [Todo]: allows whitelisted contributors to create a meme

[Describe]: Museum owner methods

 [Success]: ✔ allows owners to whitelist a contributor
 [Success]: ✔ allows owners to remove a contributor
 [Success]: ✔ allows owners to add a new owner
 [Success]: ✔ allows owners to remove an owner
    [Todo]: allows owners to remove a meme

    [File]: src/museum/__tests__/index.unit.spec.ts
  [Groups]: 4 pass, 4 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 12 pass,  0 fail, 12 total
    [Time]: 29.181ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: ✔ PASS
   [Files]: 1 total
  [Groups]: 4 count, 4 pass
   [Tests]: 12 pass, 0 fail, 12 total
    [Time]: 8846.571ms
✨  Done in 9.51s.
```

'''
'''--- src/museum/__tests__/index.unit.spec.ts ---
import { VMContext, PersistentSet } from "near-sdk-as";
import * as util from "../../utils";
import * as contract from "../assembly";

/**
 * == CONFIG VALUES ============================================================
 */
const NAME = "usain";
const MUSEUM_ACCOUNT_ID = "museum";
const OWNER_ACCOUNT_ID = "alice";
const CONTRIBUTOR_ACCOUNT_ID = "bob";

/**
 * == HELPER FUNCTIONS =========================================================
 */
const useMuseumAsPredecessor = (): void => {
  VMContext.setPredecessor_account_id(MUSEUM_ACCOUNT_ID);
};

const useAdminAsPredecessor = (): void => {
  VMContext.setPredecessor_account_id(OWNER_ACCOUNT_ID);
};

const useContributorAsPredecessor = (): void => {
  VMContext.setPredecessor_account_id(CONTRIBUTOR_ACCOUNT_ID);
};

const attachMinBalance = (): void => {
  VMContext.setAttached_deposit(util.MIN_ACCOUNT_BALANCE);
};

const doInitialize = (): void => {
  attachMinBalance();
  useMuseumAsPredecessor();
  contract.init(NAME, [OWNER_ACCOUNT_ID])
}

const memes = (): PersistentSet<util.AccountId> => {
  return new PersistentSet<util.AccountId>("m")
};

const contributors = (): PersistentSet<util.AccountId> => {
  return new PersistentSet<util.AccountId>("c");
};

const owners = (): PersistentSet<util.AccountId> => {
  return new PersistentSet<util.AccountId>("o");
};

/**
 * == UNIT TESTS ==============================================================
 */

describe("museum initialization", () => {
  beforeEach(useMuseumAsPredecessor)

  it("creates a new museum with proper metadata", () => {
    attachMinBalance()

    contract.init(NAME, [OWNER_ACCOUNT_ID])
    const m = contract.get_museum()

    expect(m.name).toBe(NAME)
    expect(owners().size).toBe(1)
  });

  it("prevents double initialization", () => {
    attachMinBalance()

    contract.init(NAME, [OWNER_ACCOUNT_ID])

    expect(() => {
      contract.init(NAME, [OWNER_ACCOUNT_ID])
    }).toThrow("Contract is already initialized")
  });

  it("requires title not to be blank", () => {
    attachMinBalance()

    expect(() => {
      contract.init("", [OWNER_ACCOUNT_ID])
    }).toThrow("Museum name may not be blank")
  });

  it("requires a minimum balance", () => {
    expect(() => {
      contract.init(NAME, [OWNER_ACCOUNT_ID])
    }).toThrow("Minimum account balance must be attached to initialize this contract (3 NEAR)")
  });

});

describe("Museum self-service methods", () => {
  beforeEach(doInitialize)

  it("returns a list of owners", () => {
    expect(contract.get_owner_list().length).toBe(1)
  })

  it("returns a list of memes", () => {
    memes().add(NAME) // can't actually create a meme using unit tests due to cross-contract call
    expect(contract.get_meme_list()[0]).toBe(NAME)
  })

  it("returns a count of memes", () => {
    memes().add(NAME) // can't actually create a meme using unit tests due to cross-contract call
    expect(contract.get_meme_count()).toBe(1)
  })

  it("allows users to add / remove themselves as contributors", () => {
    useContributorAsPredecessor()

    contract.add_myself_as_contributor()
    expect(contributors().values().length).toBe(1)
    expect(contributors().values().includes(CONTRIBUTOR_ACCOUNT_ID)).toBeTruthy()

    contract.remove_myself_as_contributor()
    expect(contributors().values().length).toBe(0)
  })

  // we have to use simulation tests for cross-contract calls
  xit("allows whitelisted contributors to create a meme", () => { })
})

describe("Museum owner methods", () => {
  beforeEach(doInitialize)
  beforeEach(useAdminAsPredecessor)

  it("allows owners to whitelist a contributor", () => {
    contract.add_contributor(CONTRIBUTOR_ACCOUNT_ID)
    expect(contributors().values().length).toBe(1)
  })

  it("allows owners to remove a contributor", () => {
    contract.add_contributor(CONTRIBUTOR_ACCOUNT_ID)
    expect(contributors().values().length).toBe(1)

    contract.remove_contributor(CONTRIBUTOR_ACCOUNT_ID)
    expect(contributors().values().length).toBe(0)
  })

  it("allows owners to add a new owner", () => {
    contract.add_owner(CONTRIBUTOR_ACCOUNT_ID)
    expect(owners().values().length).toBe(2) // original owner was already there
  })

  it("allows owners to remove an owner", () => {
    contract.add_owner(CONTRIBUTOR_ACCOUNT_ID)
    expect(owners().values().length).toBe(2) // original owner was already there

    contract.remove_owner(CONTRIBUTOR_ACCOUNT_ID)
    expect(owners().values().length).toBe(1)
  })

  // we have to use simulation tests for cross-contract calls
  xit("allows owners to remove a meme", () => { })
})

'''
'''--- src/museum/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/museum/assembly/index.ts ---
import { ContractPromiseBatch, context, base58, u128, env, storage, logging, ContractPromise } from "near-sdk-as"
import { MIN_ACCOUNT_BALANCE, AccountId, Category, MUSEUM_KEY, XCC_GAS } from "../../utils";
import { Museum, MemeInitArgs, MemeNameAsArg } from "./models";

// import meme contract bytecode as StaticArray
const CODE = includeBytes("../../../build/release/meme.wasm")

export function init(name: string, owners: AccountId[]): void {
  // contract may only be initialized once
  assert(!is_initialized(), "Contract is already initialized.");

  // storing meme metadata requires some storage staking (balance locked to offset cost of data storage)
  assert(
    u128.ge(context.attachedDeposit, MIN_ACCOUNT_BALANCE),
    "Minimum account balance must be attached to initialize this contract (3 NEAR)"
  );

  // Must have least 1 owner account
  assert(owners.length > 0, "Must specify at least 1 owner");

  // create the museum using incoming metadata
  Museum.create(name, owners)

  logging.log("museum was created")
}

export function get_museum(): Museum {
  assert_contract_is_initialized()
  return Museum.get()
}

export function get_owner_list(): AccountId[] {
  assert_contract_is_initialized()
  return Museum.get_owner_list()
}

export function get_meme_list(): AccountId[] {
  assert_contract_is_initialized()
  return Museum.get_meme_list()
}

export function get_meme_count(): u32 {
  assert_contract_is_initialized()
  return Museum.get_meme_count()
}

/**
 * Manage your status as a contributor
 */
export function add_myself_as_contributor(): void {
  assert_contract_is_initialized()
  Museum.add_contributor(context.predecessor)
}

export function remove_myself_as_contributor(): void {
  assert_contract_is_initialized()
  Museum.remove_contributor(context.predecessor)
}

/**
 * Add your meme
 */
export function add_meme(
  meme: AccountId,
  title: string,
  data: string,
  category: Category
): void {
  assert_contract_is_initialized()
  assert_signed_by_contributor_or_owner()

  // storing meme metadata requires some storage staking (balance locked to offset cost of data storage)
  assert(
    u128.ge(context.attachedDeposit, MIN_ACCOUNT_BALANCE),
    "Minimum account balance must be attached to initialize a meme (3 NEAR)"
  );

  const accountId = full_account_for(meme)

  assert(env.isValidAccountID(accountId), "Meme name must be valid NEAR account name")
  assert(!Museum.has_meme(accountId), "Meme name already exists")

  logging.log("attempting to create meme")

  let promise = ContractPromiseBatch.create(accountId)
    .create_account()
    .deploy_contract(Uint8Array.wrap(changetype<ArrayBuffer>(CODE)))
    .add_full_access_key(base58.decode(context.senderPublicKey))

  promise.function_call(
    "init",
    new MemeInitArgs(title, data, category),
    context.attachedDeposit,
    XCC_GAS
  )

  promise.then(context.contractName).function_call(
    "on_meme_created",
    new MemeNameAsArg(meme),
    u128.Zero,
    XCC_GAS
  )
}

export function on_meme_created(meme: AccountId): void {
  let results = ContractPromise.getResults();
  let memeCreated = results[0];

  // Verifying the remote contract call succeeded.
  // https://nomicon.io/RuntimeSpec/Components/BindingsSpec/PromisesAPI.html?highlight=promise#returns-3
  switch (memeCreated.status) {
    case 0:
      // promise result is not complete
      logging.log("Meme creation for [ " + full_account_for(meme) + " ] is pending")
      break;
    case 1:
      // promise result is complete and successful
      logging.log("Meme creation for [ " + full_account_for(meme) + " ] succeeded")
      Museum.add_meme(meme)
      break;
    case 2:
      // promise result is complete and failed
      logging.log("Meme creation for [ " + full_account_for(meme) + " ] failed")
      break;

    default:
      logging.log("Unexpected value for promise result [" + memeCreated.status.toString() + "]");
      break;
  }
}

/*
 * Governance methods reserved for 101Labs and NEAR admins
 */
export function add_contributor(account: AccountId): void {
  assert_contract_is_initialized()
  assert_signed_by_owner()

  Museum.add_contributor(account)

  logging.log("contributor was added")
}

export function remove_contributor(account: AccountId): void {
  assert_contract_is_initialized()
  assert_signed_by_owner()

  Museum.remove_contributor(account)
}

export function add_owner(account: AccountId): void {
  assert_contract_is_initialized()
  assert_signed_by_owner()

  Museum.add_owner(account)
}

export function remove_owner(account: AccountId): void {
  assert_contract_is_initialized()
  assert_signed_by_owner()

  Museum.remove_owner(account)
}

export function remove_meme(meme: AccountId): void {
  assert_contract_is_initialized()
  assert_signed_by_owner()

  ContractPromiseBatch.create(full_account_for(meme))
    .delete_account(context.contractName)
    .then(context.contractName)
    .function_call(
      "on_meme_removed",
      new MemeNameAsArg(meme),
      u128.Zero,
      XCC_GAS
    )
}

export function on_meme_removed(meme: AccountId): void {
  // TODO: confirm that promise was successful
  logging.log("[ " + full_account_for(meme) + " ] was removed")
  Museum.remove_meme(meme)
}

/**
 * == PRIVATE FUNCTIONS ========================================================
 *
 * Helper functions that are not part of the contract interface
 */

/**
 * Track whether or not the meme has been initialized.
 */

function is_initialized(): bool {
  return storage.hasKey(MUSEUM_KEY);
}

function assert_contract_is_initialized(): void {
  assert(is_initialized(), "Contract must be initialized first.");
}

/**
 * Indicate whether contract caller is the creator
 */
function is_owner(): bool {
  return Museum.has_owner(context.predecessor)
}

function is_contributor(): bool {
  return Museum.is_contributor(context.predecessor)
}

function assert_signed_by_owner(): void {
  assert(is_owner(), "This method can only be called by a museum owner")
}

function assert_signed_by_contributor_or_owner(): void {
  assert(is_contributor() || is_owner(), "This method can only be called by a museum contributor or owner")
}

function full_account_for(meme: string): string {
  return meme + "." + context.contractName
}

function remaining_gas(): u64 {
  return env.prepaid_gas() - (2 * env.used_gas())
}

'''
'''--- src/museum/assembly/models.ts ---
import { context, PersistentSet, storage } from "near-sdk-as"
import { Meme } from "../../meme/assembly/models";
import { MUSEUM_KEY, AccountId, Timestamp, Category } from "../../utils";

@nearBindgen
export class Museum {
  created_at: Timestamp = context.blockTimestamp;

  constructor(
    public name: string,

  ) { }

  // ----------------------------------------------------------------------------
  // Basic functions
  // ----------------------------------------------------------------------------

  static create(name: string, new_owners: AccountId[]): void {
    assert(name.length > 0, "Museum name may not be blank")

    // save the meme to storage
    this.set(new Museum(name))

    // capture owners
    for (let i = 0; i < new_owners.length; i++) {
      owners.add(new_owners[i])
    }
  }

  static get(): Museum {
    return storage.getSome<Museum>(MUSEUM_KEY)
  }

  static set(meme: Museum): void {
    storage.set(MUSEUM_KEY, meme)
  }

  // ----------------------------------------------------------------------------
  // Memes
  // ----------------------------------------------------------------------------

  static add_meme(accountId: AccountId): void {
    memes.add(accountId)
  }

  static remove_meme(accountId: AccountId): void {
    memes.delete(accountId)
  }

  static has_meme(accountId: AccountId): bool {
    return memes.has(accountId)
  }

  static get_meme_list(): string[] {
    return memes.values()
  }

  static get_meme_count(): u32 {
    return memes.size
  }

  // ----------------------------------------------------------------------------
  // Contributors
  // ----------------------------------------------------------------------------

  static add_contributor(account: AccountId): void {
    contributors.add(account)
  }

  static remove_contributor(account: AccountId): void {
    contributors.delete(account)
  }

  static is_contributor(account: AccountId): bool {
    return contributors.has(account)
  }

  // ----------------------------------------------------------------------------
  // Owners
  // ----------------------------------------------------------------------------

  static add_owner(account: AccountId): void {
    owners.add(account)
  }

  static remove_owner(account: AccountId): void {
    owners.delete(account)
  }

  static has_owner(account: AccountId): bool {
    return owners.has(account)
  }

  static get_owner_list(): AccountId[] {
    return owners.values()
  }
}

const memes = new PersistentSet<AccountId>("m")
const contributors = new PersistentSet<AccountId>("c")
const owners = new PersistentSet<AccountId>("o")

@nearBindgen
export class MemeInitArgs {
  constructor(
    public title: string,
    public data: string,
    public category: Category
  ) { }
}

@nearBindgen
export class MemeNameAsArg {
  constructor(
    public meme: string
  ) { }
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128 } from 'near-sdk-as';

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from('1000000000000000000000000');
export const XCC_GAS = 20000000000000;
export const MIN_ACCOUNT_BALANCE = u128.mul(ONE_NEAR, u128.from(3));

// common keys for singlton instances and initialization
export const MEME_KEY = "state"
export const MUSEUM_KEY = "state"

// size constraints
export const PAGE_SIZE = 10
export const MAX_COMMENT_LENGTH = 500

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Money in NEAR is a u128.
 */
export type Money = u128;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * Category for grouping memes
 */
export enum Category {
  A = 0 as i8,
  B = 1 as i8,
  C = 2 as i8,
  D = 4 as i8,
}

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

'''