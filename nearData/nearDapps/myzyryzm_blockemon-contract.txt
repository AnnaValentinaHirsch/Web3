*GitHub Repository "myzyryzm/blockemon-contract"*

'''--- README.md ---
<!-- @format -->

# blockemon-contract

## Set Up

`yarn` : installs all the relevant node modules \
`yarn build` : creates the out/main.wasm file \
`yarn test` : runs the main.spec.ts file in assembly/\_\_tests\_\_

## NEAR

`near dev-deploy out/main.wasm` : deploys the contract

### View Methods

`near view $CONTRACT getAllBlockemon` : returns a list of all blockemon\
`near view $CONTRACT getBlockemonById '{"id": $POKEMON_ID}'` : gets a blockemon by id\
`near view $CONTRACT getUserBlockemon '{"owner": $OWNER_NAME}'` : gets all blockemon for a specific account

### Change Methods

`near call $CONTRACT createBlockemon '{"nickname": $POKEMON_NAME}' --account_id $YOUR_ACCOUNT` : creates a blockemon with the specified name and assigns the owner of the blockemon to $YOUR_ACCOUNT\
`near call $CONTRACT deleteBlockemon '{"id": $POKEMON_ID}' --account_id $YOUR_ACCOUNT` : deletes a blockemon with the specified id\
`near call $CONTRACT transferBlockemon '{"newOwner": $OWNER_ACCOUNT, "id": $POKEMON_ID}' --account_id $YOUR_ACCOUNT` : transfers a blockemon from $YOUR_ACCOUNT to $OWNER_ACCOUNT\

'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports');
'''
'''--- asconfig.js ---
/** @format */

const compile = require('near-sdk-as/compiler').compile

compile(
    'assembly/main.ts', // input file
    'out/main.wasm', // output file
    [
        '--debug',
        '--measure', // Shows compiler runtime
        '--validate', // Validate the generated wasm module
    ],
    {
        verbose: true, // Output the cli args passed to asc
    }
)

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/helpers.ts ---
/** @format */

import { base64, context, math, storage } from 'near-sdk-as'
import {
    MonkeySpecies,
    monkeySpeciesIdMap,
    monkeyIdMap,
    Monkey,
    monkeyIdOwnerMap,
    MonkeyIdList,
    orderedMonkeyIdList,
    orderedMonkeySpeciesIdList,
    EscrowMonkeyIds,
    monkeyEscrowMap,
} from './models'

// GENERAL

/**
 * Has contract been initialized
 */
export function assertHasInit(): void {
    assert(storage.hasKey('init'), 'contract not initialized')
}

export function isCEO(): bool {
    return storage.get<string>('ceo') == context.sender
}

/**
 * If the user interacting with the contract the ceo
 */
export function assertIsCEO(): void {
    assert(isCEO(), 'User is not ceo')
}

/**
 * returns true if the context.sender is the owner of the blockemon
 * @param monkey
 */
export function assertIsOwner(monkey: Monkey): void {
    assert(
        monkey.owner == context.sender,
        'The blockemon does not belong to ' + context.sender
    )
}

/**
 * Checks to see if the context.sender
 * @param monkey
 */
export function assertCanTransfer(monkey: Monkey): void {
    // if not the owner of the monkey then we need to check
    if (monkey.owner !== context.sender) {
        const escrowIds: EscrowMonkeyIds = monkeyEscrowMap.getSome(monkey.id)
        assert(escrowIds.id.includes(context.sender))
    }
}

/**
 * returns a random number between 0 and 99
 * @returns
 */
export function randomNumber(): i32 {
    return math.hash32Bytes(math.randomBuffer(4)) % 100
}

// MONKEY SPECIES

/**
 * Creates a new monkey species
 * @param id
 * @param maxMonkeys
 * @returns the newly created MonkeySpecies
 */
export function addNewMonkeySpecies(id: u64, maxMonkeys: u64): MonkeySpecies {
    assert(
        !monkeySpeciesIdMap.contains(id),
        'Cannot create monkey species with that id'
    )
    const species = new MonkeySpecies(id, maxMonkeys)
    monkeySpeciesIdMap.set(species.id, species)
    addMonkeySpeciesToGlobalList(id)
    return species
}

export function getAllMonkeySpeciesIds(): Array<u64> {
    const monkeyIdList = orderedMonkeySpeciesIdList.get('all')
    return monkeyIdList ? monkeyIdList.id : new Array<u64>()
}

export function addMonkeySpeciesToGlobalList(speciesId: u64): void {
    const monkeyIds = getAllMonkeyIds()
    assert(
        !monkeyIds.includes(speciesId),
        'Error: Trying to add monkey to monkey id list that already exists'
    )
    monkeyIds.push(speciesId)
    const monkeyIdList = new MonkeyIdList(monkeyIds)
    orderedMonkeySpeciesIdList.set('all', monkeyIdList)
}

// MONKEY

/**
 * Creates a new monkey
 * @param id
 * @param speciesId
 * @param owner
 * @returns
 */
export function addNewMonkey(id: u64, speciesId: u64, owner: string): Monkey {
    assert(!monkeyIdMap.contains(id), 'Error: monkey with id already exists')
    const species = monkeySpeciesIdMap.getSome(speciesId)
    const monkey: Monkey = new Monkey(id, speciesId, owner)
    assert(
        species.numberIssued < species.maxMonkeys,
        'Error: all monkeys of this species have been issued'
    )
    addMonkeyToOwner(monkey, owner)
    addMonkeyToGlobalList(monkey.id)
    return monkey
}

/**
 * Gets all the monkey ids for a specified owner
 * @param owner
 * @returns
 */
export function getMonkeyIdsForOwner(owner: string): Array<u64> {
    const monkeyIdList = monkeyIdOwnerMap.get(owner)
    return !monkeyIdList ? new Array<u64>() : monkeyIdList.id
}

/**
 * Adds a monkey to the monkey owner map
 * @param monkeyId
 * @param owner
 */
export function addMonkeyToOwner(monkey: Monkey, owner: string): void {
    monkey.owner = owner
    const monkeyId = monkey.id
    const monkeyIds = getMonkeyIdsForOwner(owner)
    monkeyIds.push(monkeyId)
    monkeyIdOwnerMap.set(owner, new MonkeyIdList(monkeyIds))
}

/**
 * removes a monkey from the specified owner
 * @param monkeyId
 * @param owner
 */
export function removeMonkeyFromOwner(monkey: Monkey, owner: string): void {
    const monkeyId = monkey.id
    const monkeyIds = getMonkeyIdsForOwner(owner)
    for (let i = 0; i < monkeyIds.length; i++) {
        if (monkeyId === monkeyIds[i]) {
            monkeyIds.splice(i, 1)
            break
        }
    }
    monkeyIdOwnerMap.set(owner, new MonkeyIdList(monkeyIds))
}

// ALL MONKEYS

/**
 * adds a monkey to the orderedMonkeyIdList
 * @param monkeyId
 */
export function addMonkeyToGlobalList(monkeyId: u64): void {
    const monkeyIds = getAllMonkeyIds()
    assert(
        !monkeyIds.includes(monkeyId),
        'Error: Trying to add monkey to monkey id list that already exists'
    )
    monkeyIds.push(monkeyId)
    const monkeyIdList = new MonkeyIdList(monkeyIds)
    orderedMonkeyIdList.set('all', monkeyIdList)
}

/**
 * Deletes a blockemon from the ordered blockemon list with the given id.
 * @param id
 */
export function deleteFromMonkeyBlockemonList(id: u64): void {
    const globalIds = getAllMonkeyIds()
    for (let i = 0; i < globalIds.length; i++) {
        if (id == globalIds[i]) {
            globalIds.splice(i, 1)
            break
        }
    }
    orderedMonkeyIdList.set('all', new MonkeyIdList(globalIds))
}

/**
 *
 * @returns all the monkey ids from the monkeyid list
 */
export function getAllMonkeyIds(): Array<u64> {
    const monkeyIdList = orderedMonkeyIdList.get('all')
    return monkeyIdList ? monkeyIdList.id : new Array<u64>()
}

export function monkeyById(id: u64): Monkey {
    return monkeyIdMap.getSome(id)
}

'''
'''--- assembly/main.ts ---
/** @format */

import { context, base64, math, storage } from 'near-sdk-as'
import {
    Monkey,
    monkeyIdMap,
    MonkeySpecies,
    monkeySpeciesIdMap,
    orderedMonkeyIdList,
    orderedMonkeySpeciesIdList,
} from './models'
import {
    assertHasInit,
    assertIsCEO,
    isCEO,
    addNewMonkeySpecies,
    addNewMonkey,
    monkeyById,
    assertCanTransfer,
    addMonkeyToOwner,
    removeMonkeyFromOwner,
    assertIsOwner,
    deleteFromMonkeyBlockemonList,
    getMonkeyIdsForOwner,
    getAllMonkeyIds,
} from './helpers'

/************************/
/* INITIALIZE CONTRACT */
/**********************/

/**
 * Creates the contract
 */
export function initializeContract(): string {
    assert(!storage.hasKey('init'), 'Already initialized')
    storage.set<string>('init', '1')
    storage.set<string>('ceo', context.sender)
    return context.sender
}

/*******************/
/* CHANGE METHODS */
/*****************/

/**
 * Create a monkey species with an auto generated id
 * @param maxMonkeys
 * @returns
 */
export function createMonkeySpecies(maxMonkeys: u64): MonkeySpecies {
    assertHasInit()
    assertIsCEO()
    const speciesIdList = orderedMonkeySpeciesIdList.get('all')
    let numSpecies: u64 = 0
    if (speciesIdList) {
        numSpecies = speciesIdList.id.length as u64
    }
    let speciesDex = numSpecies + 1
    while (monkeySpeciesIdMap.contains(speciesDex)) {
        speciesDex++
    }

    const species = addNewMonkeySpecies(speciesDex, maxMonkeys)
    return species
}

/**
 * Create a monkey species with a specified id.
 * @param id
 * @param maxMonkeys
 * @returns
 */
export function createMonkeySpeciesWithId(
    id: u64,
    maxMonkeys: u64
): MonkeySpecies {
    assertHasInit()
    assertIsCEO()
    assert(
        !monkeySpeciesIdMap.contains(id),
        'Error: specified id already exists'
    )
    const species = addNewMonkeySpecies(id, maxMonkeys)
    return species
}

/**
 * Creates a monkey with an auto generated id
 * @param speciesId
 * @param owner
 * @returns
 */
export function createMonkey(speciesId: u64, owner: string): Monkey {
    assertHasInit()
    assertIsCEO()
    const monkeyIdList = orderedMonkeyIdList.get('all')
    let numMonkeys: u64 = 0
    if (monkeyIdList) {
        numMonkeys = monkeyIdList.id.length as u64
    }
    let monkeyId = numMonkeys + 1
    while (monkeyIdMap.contains(monkeyId)) {
        monkeyId++
    }
    const monkey = addNewMonkey(monkeyId, speciesId, owner)
    return monkey
}

/**
 * Creats a monkey by specifying the id
 * @param id
 * @param speciesId
 * @param owner
 * @returns
 */
export function createMonkeyWithId(
    id: u64,
    speciesId: u64,
    owner: string
): Monkey {
    assertHasInit()
    assertIsCEO()
    assert(
        !monkeyIdMap.contains(id),
        'Error: monkey with specified id already exists'
    )
    const monkey = addNewMonkey(id, speciesId, owner)
    return monkey
}

export function transferMonkey(newOwner: string, id: u64): Monkey {
    assertHasInit()
    const monkey = monkeyById(id)
    assertCanTransfer(monkey)
    removeMonkeyFromOwner(monkey, monkey.owner)
    addMonkeyToOwner(monkey, newOwner)
    return monkey
}

export function deleteMonkey(id: u64): void {
    assertHasInit()
    const monkey = monkeyById(id)
    assertIsOwner(monkey)
    removeMonkeyFromOwner(monkey, monkey.owner)
    deleteFromMonkeyBlockemonList(id)
    monkeyIdMap.delete(id)
}

/*****************/
/* VIEW METHODS */
/****************/

/**
 * Gets the list of monkeys for a the sender's account.
 * @param owner
 * @returns
 */
export function getUserMonkeys(): Monkey[] {
    assertHasInit()
    const monkeyIds = getMonkeyIdsForOwner(context.sender)
    let monkeyList = new Array<Monkey>()
    const numIds = monkeyIds.length
    for (let i = 0; i < numIds; i++) {
        const id = monkeyIds[i]
        if (monkeyIdMap.contains(id)) {
            monkeyList.push(monkeyIdMap.getSome(id))
        }
    }
    return monkeyList
}

/**
 * Gets a monkey by a specified id. CEO can get any monkey but users can only get monkey they own.
 * @param id
 * @returns
 */
export function getMonkeyById(id: u64): Monkey {
    assertHasInit()
    const monkey = monkeyById(id)
    if (isCEO()) {
        return monkey
    }
    assertIsOwner(monkey)
    return monkey
}

/**
 * Gets all monkeys. Only available for CEO.
 * @returns
 */
export function getAllMonkeys(): Monkey[] {
    assertHasInit()
    assertIsCEO()
    const allMonkeyIds = getAllMonkeyIds().reverse()
    const numberOfBlockemon = allMonkeyIds.length
    const result = new Array<Monkey>(numberOfBlockemon)
    for (let i = 0; i < numberOfBlockemon; i++) {
        result[i] = monkeyById(allMonkeyIds[i])
    }
    return result
}

'''
'''--- assembly/models.ts ---
/** @format */

import { PersistentMap } from 'near-sdk-as'

@nearBindgen
export class MonkeyIdList {
    constructor(public id: Array<u64>) {}
}

@nearBindgen
export class EscrowMonkeyIds {
    constructor(public id: Array<string>) {}
}

@nearBindgen
export class Monkey {
    speed: u64
    physical: u64
    special: u64
    stamina: u64
    health: u64
    distanceTraveled: u64
    coinsCollected: u64
    constructor(public id: u64, public speciesId: u64, public owner: string) {}
}

// mapping of monkey

// genes
// 3 => AA | 2 => Aa | 1 => aa
@nearBindgen
export class MonkeySpecies {
    numberIssued: u64
    constructor(public id: u64, public maxMonkeys: u64) {}
}

// key => Monkey.id; value => Monkey
export const monkeyIdMap = new PersistentMap<u64, Monkey>('mon')

// key => owner; value => list of Monkey.id the owner has access to
export const monkeyIdOwnerMap = new PersistentMap<string, MonkeyIdList>('own')

// key => 'all'; value => list of all the monkey ids
export const orderedMonkeyIdList = new PersistentMap<string, MonkeyIdList>(
    'oml'
)

// key => MonkeySpecies.id; value => MonkeySpecies
export const monkeySpeciesIdMap = new PersistentMap<u64, MonkeySpecies>('ms')

// key => 'all'; value => list of all the monkey species ids
export const orderedMonkeySpeciesIdList = new PersistentMap<
    string,
    MonkeyIdList
>('omsl')

// key => Monkey.id; value => list of account ids other than the owner account and the contract account that can transfer
export const monkeyEscrowMap = new PersistentMap<u64, EscrowMonkeyIds>('e')

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- package.json ---
{
    "name": "blockemon",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "build": "node asconfig.js",
        "test": "asp --nologo"
    },
    "dependencies": {
        "@types/node": "^14.14.36",
        "assemblyscript": "^0.9.4",
        "near-sdk-as": "^0.3.1",
        "prettier": "^2.2.1"
    }
}

'''