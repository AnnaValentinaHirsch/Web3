*GitHub Repository "3DevBusiness812/Near-ERC-20-connector"*

'''--- eNear/hardhat.config.js ---
require('dotenv').config();
require("@nomiclabs/hardhat-waffle");
require("@nomiclabs/hardhat-etherscan");
require('solidity-coverage');
require('hardhat-gas-reporter');
require('@nomiclabs/hardhat-solhint');
require('./scripts/1_deploy_eNear');
require('./scripts/2_pause_e_near_method');

/**
 * Read env variable looking for rpc endpoint to be used. Set this variable using:
 *
 * export MAINNET_RPC_ENDPOINT=...
 * export ROPSTEN_RPC_ENDPOINT=...
 *
 * @param {string} network
 * @returns {string[]} List of private keys to be used to deploy and submit.
 */
function rpc_endpoint(network) {
  return process.env[`${network.toUpperCase()}_RPC_ENDPOINT`] || '';
}

/**
 * Read env variable looking for private keys to be used. Set this variable using:
 *
 * export MAINNET_PRIVATE_KEY=...
 * export ROPSTEN_PRIVATE_KEY=...
 *
 * @param {string} network
 * @returns {string[]} List of private keys to be used to deploy and submit.
 */
function accounts(network) {
  let result = process.env[`${network.toUpperCase()}_PRIVATE_KEY`];
  if (result === undefined) {
    result = [];
  } else {
    result = [result];
  }
  return result;
}

module.exports = {
  solidity: {
    version: "0.8.11",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  gasReporter: {
    currency: 'USD',
    enabled: false,
    gasPrice: 50
  },
  networks: {
    // Arguments are taken from env variables
    // See here for more details: https://hardhat.org/tutorial/deploying-to-a-live-network.html
    ropsten: {
      // ROPSTEN_RPC_ENDPOINT
      url: rpc_endpoint('ropsten'),
      // ROPSTEN_PRIVATE_KEY
      accounts: accounts('ropsten')
    },
    mainnet: {
      // MAINNET_RPC_ENDPOINT
      url: rpc_endpoint('mainnet'),
      // MAINNET_PRIVATE_KEY
      accounts: accounts('mainnet')
    }
  },
  etherscan: {
    apiKey: process.env['ETHERSCAN_API_KEY'] || ''
  }
};

'''
'''--- eNear/scripts/1_deploy_eNear.js ---
task("deploy-enear", "Deploys eNear to the desired network")
  .addParam('tokenName', 'Token Name for ERC20')
  .addParam('tokenSymbol', 'Token Symbol for ERC20')
  .addParam('nearConnector', 'Near Connector Account ID')
  .addParam('nearProver', 'Near on ETH prover address')
  .addParam('blockHeight', 'Min block acceptance height')
  .addParam('ethAdmin', 'Eth admin controlled address')
  .addParam('pausedFlags', 'Paused flags')
  .setAction(async taskArgs => {
    const {
      tokenName,
      tokenSymbol,
      nearConnector,
      nearProver,
      blockHeight,
      ethAdmin,
      pausedFlags
    } = taskArgs

    const [deployer] = await ethers.getSigners()
    const deployerAddress = await deployer.getAddress()
    console.log(
      "Deploying eNear contract with the account:",
      deployerAddress
    )

    const eNearFactory = await ethers.getContractFactory("eNear")
    const eNear = await eNearFactory.deploy(
      tokenName,
      tokenSymbol,
      Buffer.from(nearConnector, 'utf-8'),
      nearProver,
      blockHeight,
      ethAdmin,
      pausedFlags
    )

    await eNear.deployed()

    console.log('eNear deployed at', eNear.address)
    console.log('Done')
  })

'''
'''--- eNear/scripts/2_pause_e_near_method.js ---
let adminControlledABI;

try {
    adminControlledABI = require('../artifacts/contracts/eNear.sol/eNear.json').abi
} catch (e) {}

task("pause-enear", "Pauses any method on a deployed eNear contract")
  .addParam('eNearContractAddress', 'Address of deployed eNear contract')
  .addParam('pausedFlags', 'Bitwise value specifying which functions are paused')
  .setAction(async taskArgs => {
    const {
      eNearContractAddress,
      pausedFlags
    } = taskArgs

    if (adminControlledABI === undefined) {
      console.log("Compile contract first with `yarn compile`");
      return;
    }

    const [deployer] = await ethers.getSigners()
    const deployerAddress = await deployer.getAddress()
    console.log(
      "Pause eNear method(s) with the account:",
      deployerAddress
    )

    const eNear = new ethers.Contract(
      eNearContractAddress,
      adminControlledABI,
      deployer
    )

    await eNear.adminPause(pausedFlags)

    console.log('Done')
  })

'''
'''--- eNear/test/eNear.test.js ---
const { expect } = require('chai');

const { serialize } = require('rainbow-bridge-lib/rainbow/borsh.js');
const { borshifyOutcomeProof } = require('rainbow-bridge-lib/rainbow/borshify-proof.js');

const { ethers } = require('hardhat');

const proof_template = require('./proof_template.json');

const SCHEMA = {
  'MigrateNearToEthereum': {
    kind: 'struct', fields: [
      ['flag', 'u8'],
      ['amount', 'u128'],
      ['recipient', [20]],
    ]
  }
};

const UNPAUSED_ALL = 0
const PAUSED_FINALISE_FROM_NEAR = 1 << 0
const PAUSED_XFER_TO_NEAR = 1 << 1

describe('eNear contract', () => {
  let deployer;
  let eNearAdmin;
  let alice;
  let bob;
  let nearProver;
  let eNear;

  const ERC20_NAME = 'eNear';
  const ERC20_SYMBOL = 'eNear';

  const ONE_HUNDRED_TOKENS = ethers.BigNumber.from(100).mul(ethers.BigNumber.from(10).pow(ethers.BigNumber.from(24)))

  beforeEach(async () => {
    [deployer, eNearAdmin, alice, bob] = await ethers.getSigners();

    nearProverMockContractFactory = await ethers.getContractFactory('NearProverMock')
    nearProver = await nearProverMockContractFactory.connect(deployer).deploy();

    // Proofs coming from blocks below this value should be rejected
    minBlockAcceptanceHeight = 0;

    eNearContractFactory = await ethers.getContractFactory('eNearMock');
    eNear = await eNearContractFactory
      .connect(deployer)
      .deploy(
        ERC20_NAME,
        ERC20_SYMBOL,
        Buffer.from('eNearBridge', 'utf-8'),
        nearProver.address,
        minBlockAcceptanceHeight,
        eNearAdmin.address,
        UNPAUSED_ALL
    );
  });

  describe('transferToNear()', () => {
    it('Burns eNear when transferring to near', async () => {
      // check supply zero and balance zero
      expect(await eNear.totalSupply()).to.equal(0)
      expect(await eNear.balanceOf(alice.address)).to.equal(0)

      // mint some tokens to account bridging
      await eNear.mintTo(alice.address, ONE_HUNDRED_TOKENS)

      // check supply and balance
      expect(await eNear.totalSupply()).to.equal(ONE_HUNDRED_TOKENS)
      expect(await eNear.balanceOf(alice.address)).to.equal(ONE_HUNDRED_TOKENS)

      // call xfer to near
      await expect(
        eNear
          .connect(alice)
          .transferToNear(ONE_HUNDRED_TOKENS, 'vince.near')
      )
        .to
        .emit(eNear, 'TransferToNearInitiated')
        .withArgs(alice.address, ONE_HUNDRED_TOKENS, 'vince.near');

      // check supply zero and balance zero
      expect(await eNear.totalSupply()).to.equal(0)
      expect(await eNear.balanceOf(alice.address)).to.equal(0)
    })
  })

  describe('finaliseNearToEthTransfer()', () => {
    it('Mints eNear after bridging Near', async () => {
      let proof = JSON.parse(JSON.stringify(proof_template));

      const amount = ethers.utils.parseUnits('1', '24');
      proof.outcome_proof.outcome.status.SuccessValue = serialize(SCHEMA, 'MigrateNearToEthereum', {
        flag: 0,
        amount: amount.toString(),
        recipient: ethers.utils.arrayify(bob.address),
      }).toString('base64');

      const receiverBalance = await eNear.balanceOf(bob.address);

      await eNear.finaliseNearToEthTransfer(borshifyOutcomeProof(proof), 1099);

      const newReceiverBalance = await eNear.balanceOf(bob.address);
      expect(newReceiverBalance.sub(receiverBalance).toString()).to.be.equal(amount.toString());
    });

    it('Reverts when reusing proof event', async () => {
      let proof = JSON.parse(JSON.stringify(proof_template));

      const amount = ethers.utils.parseUnits('1', '24');
      proof.outcome_proof.outcome.status.SuccessValue = serialize(SCHEMA, 'MigrateNearToEthereum', {
        flag: 0,
        amount: amount.toString(),
        recipient: ethers.utils.arrayify(bob.address),
      }).toString('base64');

      await eNear.finaliseNearToEthTransfer(borshifyOutcomeProof(proof), 1099);

      await expect(
        eNear.finaliseNearToEthTransfer(borshifyOutcomeProof(proof), 1099)
      )
        .to
        .be
        .revertedWith("The burn event proof cannot be reused");
    })

    it('Reverts when event comes from the wrong executor', async () => {
      let proof = JSON.parse(JSON.stringify(proof_template));
      proof.outcome_proof.outcome.executor_id = 'eNearBridgeInvalid'

      const amount = ethers.utils.parseUnits('1', '24');
      proof.outcome_proof.outcome.status.SuccessValue = serialize(SCHEMA, 'MigrateNearToEthereum', {
        flag: 0,
        amount: amount.toString(),
        recipient: ethers.utils.arrayify(bob.address),
      }).toString('base64');

      await expect(
        eNear.finaliseNearToEthTransfer(borshifyOutcomeProof(proof), 1099)
      )
        .to
        .be
        .revertedWith("Can only unlock tokens from the linked proof producer on Near blockchain");
    })

    it('Reverts if flag is not zero', async () => {
      let proof = JSON.parse(JSON.stringify(proof_template));

      const amount = ethers.utils.parseUnits('1', '24');
      proof.outcome_proof.outcome.status.SuccessValue = serialize(SCHEMA, 'MigrateNearToEthereum', {
        flag: 3,
        amount: amount.toString(),
        recipient: ethers.utils.arrayify(bob.address),
      }).toString('base64');

      await expect(
        eNear.finaliseNearToEthTransfer(borshifyOutcomeProof(proof), 1099)
      )
        .to
        .be
        .revertedWith("ERR_NOT_WITHDRAW_RESULT");
    })
  })
})

'''