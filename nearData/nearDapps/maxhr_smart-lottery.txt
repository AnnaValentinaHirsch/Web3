*GitHub Repository "maxhr/smart-lottery"*

'''--- README.md ---
# Smart Lottery on chain

This is a mono-repo for a smart contract on multiple blockchains. It aims to compare a (kind of) minumum viable code, for an actually useful smart-contract, on different blockchains.

The contracts implement a lottery logic with these features:
- A user can deposit tokens into the contract (`deposit` function)
- A random number can be generated on chain (`get_random_seed` function)
- The `trigger_lottery` function is triggered by external events
    - A real-world-time interval
    - A cross-chain event - when a certain sum of players reached _across all chains_
- The `share_prize` function transfers token to winners
    - For a single-chain lottery winners chosen from one chain
    - An multi-chain lottery - tokens across multiple chains are shared between winners on those chains, with price conversions and cross-chain value transfer

| Chain     | `deposit`      | `get_random_seed` | `trigger_lottery` | `share_prize` |
|-----------|----------------|-------------------|--------------|---------------|
| Ethereum  |                |                   |              |               |
| Cosmos    |                |                   |              |               |
| Solana    | wip            |                   |              |               |
| Cardano   |                |                   |              |               |
| Polkadot  | ✅              |                   |              |               |
| Near      | ✅              |                   |              |               |
| BSC       |                |                   |              |               |
| Harmony   |                |                   |              |               |
|           |                |                   |              |               |

'''
'''--- near-smart-lottery/Cargo.toml ---
[package]
name = "smart-lottery"
version = "0.1.0"
authors = ["Max Harpunsky <max@maxistyping.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.6"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- near-smart-lottery/README.md ---
# Rust Smart Contract Template

## Getting started

To get started with this template:

1. Click the "Use this template" button to create a new repo based on this template
2. Update line 2 of `Cargo.toml` with your project name
3. Update line 4 of `Cargo.toml` with your project author names
4. Set up the [prerequisites](https://github.com/near/near-sdk-rs#pre-requisites)
5. Begin writing your smart contract in `src/lib.rs`
6. Test the contract 

    `cargo test -- --nocapture`

8. Build the contract

    `RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release`

**Get more info at:**

* [Rust Smart Contract Quick Start](https://docs.near.org/docs/develop/contracts/rust/intro)
* [Rust SDK Book](https://www.near-sdk.io/)

'''
'''--- near-smart-lottery/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
# cp target/wasm32-unknown-unknown/release/*.wasm ./res/
#

'''
'''--- near-smart-lottery/deploy.sh ---
#!/bin/bash
set -e

./test.sh

./build.sh

near deploy --wasmFile target/wasm32-unknown-unknown/release/smart_lottery.wasm --accountId smartlottery.testnet
'''
'''--- near-smart-lottery/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance,
    collections::{ UnorderedMap },
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct SmartLottery {
    participants: UnorderedMap<AccountId, Balance>,
    prize_pool: Balance,
}

#[near_bindgen]
impl SmartLottery {

    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(env::is_valid_account_id(owner_id.as_bytes()), "Invalid owner account");
        assert!(!env::state_exists(), "Already initialized");
        Self {
            prize_pool: 0,
            participants: UnorderedMap::new(b"credits".to_vec()),
        }
    }

    #[payable]
    pub fn deposit(&mut self) {
        let account_id = env::signer_account_id();
        let deposit = env::attached_deposit();
        let mut credits = self.participants.get(&account_id).unwrap_or(0);
        credits = credits + deposit;
        self.participants.insert(&account_id, &credits);
        // env::log_str(&format!("==== {:?}", self.participants));
        self.prize_pool += deposit;
    }

    pub fn get_random_seed(&mut self) -> u8 {
        let rand: u8 = *env::random_seed().get(0).unwrap();
        rand
    }

    pub fn get_grand_prize(&self) -> Balance {
        self.prize_pool
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, AccountId, Balance, VMContext};
 
    fn get_context(signer_account_id: AccountId, attached_deposit: Balance) -> VMContext {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(signer_account_id.clone())
            .signer_account_id(signer_account_id.clone())
            .attached_deposit(attached_deposit.clone())
            .predecessor_account_id(accounts(1).clone())
            .account_balance(0)
            .build();
        builder.context
    }

    #[test]
    fn play() {
        let context1 = get_context(accounts(1), 115);
        testing_env!(context1);
        let mut contract = SmartLottery {
            participants: UnorderedMap::new(b"credits".to_vec()),
            prize_pool: 0,
        };
        contract.deposit();
        assert_eq!(115, contract.get_grand_prize().clone());
        assert_eq!(contract.participants.get(&accounts(1)), Some(115u128));

        let context2 = get_context(accounts(2), 23);
        testing_env!(context2);
        contract.deposit();
        assert_eq!(115 + 23, contract.get_grand_prize().clone());
        assert_eq!(contract.participants.get(&accounts(2)), Some(23u128));

        let context2a = get_context(accounts(2), 2);
        testing_env!(context2a);
        contract.deposit();
        assert_eq!(115 + 23 + 2, contract.get_grand_prize().clone());
        assert_eq!(contract.participants.get(&accounts(2)), Some(23u128 + 2u128));

        assert_eq!(contract.participants.len(), 2);
    }

}

'''
'''--- near-smart-lottery/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''
'''--- solana-smart-lottery/Anchor.toml ---
[features]
seeds = false
[programs.localnet]
solana_smart_lottery = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/Users/max/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

'''
'''--- solana-smart-lottery/Cargo.toml ---
[workspace]
members = [
    "programs/*"
]

'''
'''--- solana-smart-lottery/migrations/deploy.ts ---
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@project-serum/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};

'''
'''--- solana-smart-lottery/package.json ---
{
    "dependencies": {
        "@project-serum/anchor": "^0.22.0"
    },
    "devDependencies": {
        "chai": "^4.3.4",
        "mocha": "^9.0.3",
        "ts-mocha": "^8.0.0",
        "@types/mocha": "^9.0.0",
        "typescript": "^4.3.5"
    }
}

'''
'''--- solana-smart-lottery/programs/solana-smart-lottery/Cargo.toml ---
[package]
name = "solana-smart-lottery"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "solana_smart_lottery"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = "0.22.0"

'''
'''--- solana-smart-lottery/programs/solana-smart-lottery/Xargo.toml ---
[target.bpfel-unknown-unknown.dependencies.std]
features = []

'''
'''--- solana-smart-lottery/programs/solana-smart-lottery/src/lib.rs ---
use anchor_lang::prelude::*;
use std::collections::{HashMap};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod solana_smart_lottery {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let smart_lottery = &mut ctx.accounts.smart_lottery;
        smart_lottery.authority = ctx.accounts.authtority.key();
        smart_lottery.prize_pool = 0;
        smart_lottery.participants = HashMap::new();
        Ok(())
    }

    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
        let smart_lottery = &mut ctx.accounts.smart_lottery;
        smart_lottery.prize_pool += amount;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = smart_lottery, space = 48)]
    pub smart_lottery: Account<'info, SmartLottery>,
    pub authtority: Signer<'info>,
    pub system_program: Program<'info, System>,

}

#[derive(Accounts)]
pub struct Deposit<'info> {
    #[account(mut, has_one = authority)]
    pub smart_lottery: Account<'info, SmartLottery>,
    pub authority: Signer<'info>,
}

#[account]
pub struct SmartLottery {
    pub authority: Pubkey,
    pub participants: HashMap<Pubkey, u64>,
    pub prize_pool: u64,
}

'''
'''--- solana-smart-lottery/tests/solana-smart-lottery.ts ---
import * as anchor from "@project-serum/anchor";
import { Program } from "@project-serum/anchor";
import { Keypair, SystemProgram } from "@solana/web3.js";
import { SolanaSmartLottery } from "../target/types/solana_smart_lottery";

describe("solana-smart-lottery", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.SolanaSmartLottery as Program<SolanaSmartLottery>;
  const smartLottery = Keypair.generate();

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.rpc.initialize({
      accounts: {
        smartLottery: smartLottery.publicKey,
        authtority: program.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [smartLottery],
    });
    console.log("Your transaction signature", tx);
  });
});

'''
'''--- solana-smart-lottery/tsconfig.json ---
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}

'''
'''--- substrate_smart_lottery/Cargo.toml ---
[package]
name = "smart_lottery"
version = "0.1.0"
authors = ["Max Harpunsky max@maxistyping.com"]
edition = "2021"
rust-version = "1.56.1"

[dependencies]
ink_primitives = { version = "3.0.0-rc9", default-features = false }
ink_metadata = { version = "3.0.0-rc9", default-features = false, features = ["derive"], optional = true }
ink_env = { version = "3.0.0-rc9", default-features = false }
ink_storage = { version = "3.0.0-rc9", default-features = false }
ink_lang = { version = "3.0.0-rc9", default-features = false }

# frame-support = { version = "3.0.0", default-features = false }

scale-info = { version = "2", default-features = false, features = ["derive"], optional = true }
scale = { package = "parity-scale-codec", version = "3", default-features = false, features = ["derive", "full"] }

[lib]
name = "smart_lottery"
path = "lib.rs"
crate-type = [
	# Used for normal contract Wasm blobs.
	"cdylib",
]

[features]
default = ["std"]
std = [
    "ink_metadata/std",
    "ink_env/std",
    "ink_storage/std",
    "ink_primitives/std",
    "scale/std",
    "scale-info/std",
    # "frame-support/std",
]
ink-as-dependency = []

'''
'''--- substrate_smart_lottery/lib.rs ---
#![cfg_attr(not(feature = "std"), no_std)]

use ink_env::Environment;
use ink_lang as ink;

#[ink::chain_extension]
pub trait FetchRandom {
    type ErrorCode = RandomReadErr;

    /// Note: this gives the operation a corresponding `func_id` (1101 in this case),
    /// and the chain-side chain extension will get the `func_id` to do further operations.
    #[ink(extension = 1101, returns_result = false)]
    fn fetch_random(subject: [u8; 32]) -> [u8; 32];
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, scale::Encode, scale::Decode)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub enum RandomReadErr {
    FailGetRandomSource,
}

impl ink_env::chain_extension::FromStatusCode for RandomReadErr {
    fn from_status_code(status_code: u32) -> Result<(), Self> {
        match status_code {
            0 => Ok(()),
            1 => Err(Self::FailGetRandomSource),
            _ => panic!("encountered unknown status code"),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub enum CustomEnvironment {}

impl Environment for CustomEnvironment {
    const MAX_EVENT_TOPICS: usize =
        <ink_env::DefaultEnvironment as Environment>::MAX_EVENT_TOPICS;

    type AccountId = <ink_env::DefaultEnvironment as Environment>::AccountId;
    type Balance = <ink_env::DefaultEnvironment as Environment>::Balance;
    type Hash = <ink_env::DefaultEnvironment as Environment>::Hash;
    type BlockNumber = <ink_env::DefaultEnvironment as Environment>::BlockNumber;
    type Timestamp = <ink_env::DefaultEnvironment as Environment>::Timestamp;

    type ChainExtension = FetchRandom;
}

#[ink::contract(env = crate::CustomEnvironment)]
pub mod smart_lottery {
    use super::RandomReadErr;

    use ink_storage::{
        traits::SpreadAllocate,
        Mapping,
    };

    #[ink(storage)]
    #[derive(SpreadAllocate)]
    pub struct SmartLottery {
        participants: Mapping<AccountId, (i32, Balance)>,
        prize_pool: Balance,
    }

    #[ink(event)]
    pub struct Lottery {
        #[ink(topic)]
        winner: AccountId,
        prize: Balance,
    }

    impl SmartLottery {
        #[ink(constructor)]
        pub fn default() -> Self {
            ink_lang::utils::initialize_contract(|contract| {
                Self::new_init(contract)
            })
        }
        
        fn new_init(&mut self) {}

        #[ink(message)]
        pub fn play(&mut self, number: i32, amount: Balance) {
            let caller = self.env().caller();
            if self.participants.get(&caller) != None {
                return
            }
            self.prize_pool += amount;
            self.participants.insert(caller, &(number, amount));
        }

        #[ink(message)]
        pub fn get_my_play(&self) -> (i32, Balance) {
            let caller = self.env().caller();
            let caller_play = self.participants.get(&caller).unwrap_or((0, 0u128));
            caller_play
        }

        #[ink(message)]
        pub fn get_caller(&self) -> AccountId {
            self.env().caller()
        }

        #[ink(message)]
        pub fn get_pool(&self) -> Balance {
            self.prize_pool
        }
    }

    #[cfg(test)]
    mod tests {
        /// Imports all the definitions from the outer scope so we can use them here.
        use super::*;

        /// Imports `ink_lang` so we can use `#[ink::test]`.
        use ink_lang as ink;

        #[ink::test]
        fn basic_acceptance() {
            let mut smart_lottery = SmartLottery::default();
            assert_eq!(smart_lottery.get_pool(), 0);
            smart_lottery.play(55, 1000);
            assert_eq!(smart_lottery.get_pool(), 1000);
            assert_eq!(smart_lottery.get_my_play(), (55, 1000));
            smart_lottery.play(407, 55);
            assert_eq!(smart_lottery.get_my_play(), (55, 1000));
            
        }

    }
}

'''