*GitHub Repository "NEAR-Analytics/near-townhall"*

'''--- Ideas.js ---
// This widget is deprecated in favor of:
return (
    <Widget src="near-analytics.near/widget/townhall-board.pages.Feed" props={props} />
  );

'''
'''--- extra_components/featured_communities.js ---
{/* <div class="h5 pb-3">Featured Communities</div>
<div class="row">
  {Object.entries(communities).map(([label, community]) => {
    return (
      <div class="col">
        {widget(
          "components.community.FeaturedCommunity",
          {
            label,
            ...community,
          },
          label
        )}
      </div>
    );
  })}
</div> */}
'''
'''--- readme.md ---

'''
'''--- townhall-board.components.community.FeaturedCommunity.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

const Hover = styled.div`
  &:hover {
    box-shadow: 0px 1px 3px rgba(16, 24, 40, 0.1),
      0px 1px 2px rgba(16, 24, 40, 0.06);
  }
`;

return (
  <Hover className="card">
    <a
      href={href("community.Overview", {
        label: props.label,
      })}
      class="text-decoration-none text-reset"
    >
      <img src={props.cover} class="card-img-top"></img>
      <div class="h5 pt-3 ps-3">{props.title}</div>
      <div class="ps-3 pb-2 text-secondary">{props.desc}</div>
    </a>
  </Hover>
);
'''
'''--- townhall-board.components.community.FeedHeader.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

/* INCLUDE: "shared/mocks" */
const communities = {
  "zero-knowledge": {
    overviewId: 397,
    eventsId: 401,

    icon: "https://ipfs.near.social/ipfs/bafkreiajwq6ep3n7veddozji2djv5vviyisabhycbweslvpwhsoyuzcwi4",

    cover:
      "https://ipfs.near.social/ipfs/bafkreihgxg5kwts2juldaeasveyuddkm6tcabmrat2aaq5u6uyljtyt7lu",

    title: "Zero Knowledge",
    desc: "Building a zero knowledge ecosystem on NEAR.",
    telegram: "NearZeroKnowledge",
  },

  protocol: {
    overviewId: 412,
    eventsId: 413,

    icon: "https://ipfs.near.social/ipfs/bafkreidpitdafcnhkp4uyomacypdgqvxr35jtfnbxa5s6crby7qjk2nv5a",

    cover:
      "https://ipfs.near.social/ipfs/bafkreicg4svzfz5nvllomsahndgm7u62za4sib4mmbygxzhpcl4htqwr4a",

    title: "Protocol",
    desc: "Supporting the ongoing innovation of the NEAR Protocol.",

    integrations: {
      github: {
        boards: {
          "18855b9c9f2-216091d-6484800b-42593f54-6102b48a": {
            id: "18855b9c9f2-216091d-6484800b-42593f54-6102b48a",

            columns: {
              "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630": {
                id: "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630",

                description:
                  "NEPs that need a moderator review or author revision.",

                labelSearchTerms: ["WG-protocol", "S-draft"],
                title: "üìÑ Draft",
              },

              "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9": {
                description:
                  "NEPS that need a review by Subject Matter Experts.",

                labelSearchTerms: ["WG-protocol", "S-review"],
                title: "üëÄ Review",
                id: "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9",
              },

              "18877dd71e5-47d177b8-5505178-640a5937--17968e87": {
                description:
                  "NEPS in the final review stage that need the work group voting indications.",

                labelSearchTerms: ["WG-protocol", "S-voting"],
                title: "‚úî Voting",
                id: "18877dd71e5-47d177b8-5505178-640a5937--17968e87",
              },

              "18877e14753--5b0ca250-1edea464-523fd579--5ebde527": {
                description:
                  "NEPS that were reviewed and approved by a work group.",

                labelSearchTerms: ["WG-protocol", "S-approved"],
                title: "‚úÖ Approved NEPs",
                id: "18877e14753--5b0ca250-1edea464-523fd579--5ebde527",
              },

              "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81": {
                description:
                  "NEPS that were reviewed and approved by a work group or NEP moderators.",

                labelSearchTerms: ["WG-protocol", "A-NEP-GrammarFix"],
                title: "üîß Approved Fixes",
                id: "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81",
              },

              "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be": {
                description:
                  "NEPs that were retracted by the author or had no activity for over two months.",

                labelSearchTerms: ["WG-protocol", "S-retracted"],
                title: "‚ùå RETRACTED",
                id: "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be",
              },
            },

            dataTypesIncluded: { Issue: false, PullRequest: true },
            description: "Latest NEAR Enhancement Proposals by status",
            repoURL: "https://github.com/near/NEPs",
            ticketState: "all",
            title: "NEAR Protocol NEPs",
          },
        },
      },
    },

    telegram: "NEAR_Protocol_Community_Group",
  },

  tooling: {
    overviewId: 416,
    eventsId: 417,

    icon: "https://ipfs.near.social/ipfs/bafkreie2eaj5czmpfe6pe53kojzcspgozebdsonffwvbxtpuipnwahybvi",

    cover:
      "https://ipfs.near.social/ipfs/bafkreiehzr7z2fhoqqmkt3z667wubccbch6sqtsnvd6msodyzpnf72cszy",

    title: "Tooling",
    desc: "Supporting the ongoing innovation of tooling.",

    integrations: {
      github: {
        boards: {
          "18855b9c9f2-216091d-6484800b-42593f54-6102b48a": {
            id: "18855b9c9f2-216091d-6484800b-42593f54-6102b48a",

            columns: {
              "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630": {
                id: "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630",

                description:
                  "NEPs that need a moderator review or author revision.",

                labelSearchTerms: ["WG-tools", "S-draft"],
                title: "üìÑ Draft",
              },

              "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9": {
                description:
                  "NEPS that need a review by Subject Matter Experts.",

                labelSearchTerms: ["WG-tools", "S-review"],
                title: "üëÄ Review",
                id: "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9",
              },

              "18877dd71e5-47d177b8-5505178-640a5937--17968e87": {
                description:
                  "NEPS in the final review stage that need the work group voting indications.",

                labelSearchTerms: ["WG-tools", "S-voting"],
                title: "‚úî Voting",
                id: "18877dd71e5-47d177b8-5505178-640a5937--17968e87",
              },

              "18877e14753--5b0ca250-1edea464-523fd579--5ebde527": {
                description:
                  "NEPS that were reviewed and approved by a work group.",

                labelSearchTerms: ["WG-tools", "S-approved"],
                title: "‚úÖ Approved NEPs",
                id: "18877e14753--5b0ca250-1edea464-523fd579--5ebde527",
              },

              "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81": {
                description:
                  "NEPS that were reviewed and approved by a work group or NEP moderators.",

                labelSearchTerms: ["WG-tools", "A-NEP-GrammarFix"],
                title: "üîß Approved Fixes",
                id: "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81",
              },

              "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be": {
                description:
                  "NEPs that were retracted by the author or had no activity for over two months.",

                labelSearchTerms: ["WG-tools", "S-retracted"],
                title: "‚ùå RETRACTED",
                id: "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be",
              },
            },

            dataTypesIncluded: { Issue: false, PullRequest: true },
            description: "Latest NEAR Enhancement Proposals by status",
            repoURL: "https://github.com/near/NEPs",
            ticketState: "all",
            title: "NEAR Tooling NEPs",
          },
        },
      },
    },

    telegram: "NEAR_Tools_Community_Group",
  },

  "contract-standards": {
    overviewId: 414,
    eventsId: 415,

    icon: "https://ipfs.near.social/ipfs/bafkreiepgdnu7soc6xgbyd4adicbf3eyxiiwqawn6tguaix6aklfpir634",

    cover:
      "https://ipfs.near.social/ipfs/bafkreiaowjqxds24fwcliyriintjd4ucciprii2rdxjmxgi7f5dmzuscey",

    title: "Contract Standards",
    desc: "Coordinating the contribution to the NEAR dapp standards.",

    integrations: {
      github: {
        boards: {
          "18855b9c9f2-216091d-6484800b-42593f54-6102b48a": {
            id: "18855b9c9f2-216091d-6484800b-42593f54-6102b48a",

            columns: {
              "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630": {
                id: "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630",

                description:
                  "NEPs that need a moderator review or author revision.",

                labelSearchTerms: ["WG-contract-standards", "S-draft"],
                title: "üìÑ Draft",
              },

              "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9": {
                description:
                  "NEPS that need a review by Subject Matter Experts.",

                labelSearchTerms: ["WG-contract-standards", "S-review"],
                title: "üëÄ Review",
                id: "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9",
              },

              "18877dd71e5-47d177b8-5505178-640a5937--17968e87": {
                description:
                  "NEPS in the final review stage that need the work group voting indications.",

                labelSearchTerms: ["WG-contract-standards", "S-voting"],
                title: "‚úî Voting",
                id: "18877dd71e5-47d177b8-5505178-640a5937--17968e87",
              },

              "18877e14753--5b0ca250-1edea464-523fd579--5ebde527": {
                description:
                  "NEPS that were reviewed and approved by a work group.",

                labelSearchTerms: ["WG-contract-standards", "S-approved"],
                title: "‚úÖ Approved NEPs",
                id: "18877e14753--5b0ca250-1edea464-523fd579--5ebde527",
              },

              "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81": {
                description:
                  "NEPS that were reviewed and approved by a work group or NEP moderators.",

                labelSearchTerms: ["WG-contract-standards", "A-NEP-GrammarFix"],
                title: "üîß Approved Fixes",
                id: "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81",
              },

              "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be": {
                description:
                  "NEPs that were retracted by the author or had no activity for over two months.",

                labelSearchTerms: ["WG-contract-standards", "S-retracted"],
                title: "‚ùå RETRACTED",
                id: "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be",
              },
            },

            dataTypesIncluded: { Issue: false, PullRequest: true },
            description: "Latest NEAR Enhancement Proposals by status",
            repoURL: "https://github.com/near/NEPs",
            ticketState: "all",
            title: "NEAR Contract Standards NEPs",
          },
        },
      },
    },

    telegram: "nearnft",
  },
};
/* END_INCLUDE: "shared/mocks" */

const Gradient = styled.div`
   {
    margin-top: -25px;
    margin-bottom: 25px;
    height: 250px;
    text-align: center;
    background: radial-gradient(
      circle,
      rgba(29, 55, 57, 1) 30%,
      rgba(24, 24, 24, 1) 80%
    );

    font-family: Arial, sans-serif;
  }

  .text-primary-gradient {
    color: #53fdca;
    -webkit-text-fill-color: transparent;
    background-image: linear-gradient(#8e76ba, #1ed2f0);
    -webkit-background-clip: text;
    background-clip: text;
  }

  .subtitle-above {
    font-size: 18px;
    letter-spacing: 1px;
    font-family: Courier, monospace;
  }

  .subtitle-below {
    font-size: 16px;
  }

  .slogan {
    font-weight: 600;
    font-size: 60px;
  }
`;

return (
  <>
    <Gradient className="d-flex flex-column justify-content-center">
      <div class="subtitle-above text-white opacity-75 mb-2">
        A decentralized community of
      </div>
      <h1 class="mb-3 text-white slogan">
        <span class="text-primary-gradient">NEAR </span>Developers
      </h1>
      <div class="subtitle-below text-white opacity-75">
        Share your ideas, match solutions, and access support and funding.
      </div>
    </Gradient>
    <div class="h5 pb-3">Featured Communities</div>
    <div class="row">
      {Object.entries(communities).map(([label, community]) => {
        return (
          <div class="col">
            {widget(
              "components.community.FeaturedCommunity",
              {
                label,
                ...community,
              },
              label
            )}
          </div>
        );
      })}
    </div>
    <div class="h5 pb-3 pt-5">Activity</div>
  </>
);
'''
'''--- townhall-board.components.layout.Banner.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

const Banner = styled.div`
   {
    height: 62px;
    background: #181818;
    margin-top: -24px;
    padding: 16px 20px;

    img {
      height: 30px;
    }

    margin-bottom: 25px;
  }
`;

return (
  <>
    <Banner className="d-flex justify-content-between">
      <a href={href("Feed")}>
        <img src="https://ipfs.near.social/ipfs/bafkreibjsn3gswlcc5mvgkfv7ady2lzkd2htm55l472suarbd34qryh2uy"></img>
      </a>
      <div>
        <a
          href="https://www.neardevgov.org/blog/near-developer-dao"
          class="text-white me-2"
        >
          Developer DAO
        </a>

        <div class="btn-group" role="group">
          <button
            type="button"
            class="btn btn-outline-light rounded-circle"
            style={{
              width: "30px",
              height: "30px",
              padding: "6px 0px",
              borderWidth: "0.5px",
              lineHeight: "0px",
            }}
            data-bs-toggle="dropdown"
            aria-expanded="false"
          >
            <i class="bi bi-question-lg"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end">
            <li>
              <a
                target="_blank"
                class="dropdown-item"
                href="https://github.com/near/devgigsboard-widgets/issues/new?assignees=&labels=bug&template=bug_report.md&title="
              >
                Report a bug
              </a>
            </li>
            <li>
              <a
                target="_blank"
                class="dropdown-item"
                href="https://github.com/near/devgigsboard-widgets/issues/new?assignees=&labels=enhancement&template=feature-request.md&title="
              >
                Suggest an improvement
              </a>
            </li>
          </ul>
        </div>
      </div>
    </Banner>
  </>
);
'''
'''--- townhall-board.components.layout.Controls.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

return (
  <div class="d-flex flex-row-reverse">
    <a
      class="btn btn-light"
      style={{
        backgroundColor: "#0C7283",
        color: "#f3f3f3",
      }}
      href={href("Create", { labels: props.labels })}
    >
      <i class="bi bi-plus-circle-fill"></i>
      Submit Idea / Solution
    </a>
  </div>
);
'''
'''--- townhall-board.components.layout.Page.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

return (
  <>
    {widget("components.layout.Banner")}
    {props.header}
    {props.children}
  </>
);
'''
'''--- townhall-board.components.posts.List.js ---
// This component implementation was forked from [IndexFeed], but it does not fully implement lazy loading.
// While this component uses InfiniteScroll, it still loads the whole list of Post IDs in one view call.
// The contract will need to be extended with pagination support, yet, even in the current state the page loads much faster.
// [IndexFeed]: https://near.social/#/mob.near/widget/WidgetSource?src=mob.near/widget/IndexFeed

/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

initState({
  period: "week",
});

function defaultRenderItem(postId, additionalProps) {
  if (!additionalProps) {
    additionalProps = {};
  }
  // It is important to have a non-zero-height element as otherwise InfiniteScroll loads too many items on initial load
  return (
    <div style={{ minHeight: "150px" }}>
      {widget(
        `components.posts.Post`,
        {
          id: postId,
          expandable: true,
          defaultExpanded: false,
          isInList: true,
          ...additionalProps,
        },
        postId
      )}
    </div>
  );
}

const renderItem = props.renderItem ?? defaultRenderItem;

const cachedRenderItem = (item, i) => {
  if (props.searchResult && props.searchResult.keywords[item]) {
    return renderItem(item, {
      searchKeywords: props.searchResult.keywords[item],
    });
  }

  const key = JSON.stringify(item);

  if (!(key in state.cachedItems)) {
    state.cachedItems[key] = renderItem(item);
    State.update();
  }
  return state.cachedItems[key];
};

const initialRenderLimit = props.initialRenderLimit ?? 3;
const addDisplayCount = props.nextLimit ?? initialRenderLimit;

function getPostsByLabel() {
  let postIds = Near.view(
    nearNFDevsContractAccountId,
    "get_posts_by_label",
    {
      label: props.label,
    }
  );
  if (postIds) {
    postIds.reverse();
  }
  return postIds;
}

function getPostsByAuthor() {
  let postIds = Near.view(
    nearNFDevsContractAccountId,
    "get_posts_by_author",
    {
      author: props.author,
    }
  );
  if (postIds) {
    postIds.reverse();
  }
  return postIds;
}

function intersectPostsWithLabel(postIds) {
  if (props.label) {
    let postIdLabels = getPostsByLabel();
    if (postIdLabels === null) {
      // wait until postIdLabels are loaded
      return null;
    }
    postIdLabels = new Set(postIdLabels);
    return postIds.filter((id) => postIdLabels.has(id));
  }
  return postIds;
}

function intersectPostsWithAuthor(postIds) {
  if (props.author) {
    let postIdsByAuthor = getPostsByAuthor();
    if (postIdsByAuthor == null) {
      // wait until postIdsByAuthor are loaded
      return null;
    } else {
      postIdsByAuthor = new Set(postIdsByAuthor);
      return postIds.filter((id) => postIdsByAuthor.has(id));
    }
  }
  return postIds;
}

const ONE_DAY = 60 * 60 * 24 * 1000;
const ONE_WEEK = 60 * 60 * 24 * 1000 * 7;
const ONE_MONTH = 60 * 60 * 24 * 1000 * 30;

function getHotnessScore(post) {
  //post.id - shows the age of the post, should grow exponentially, since newer posts are more important
  //post.likes.length - linear value
  const age = Math.pow(post.id, 5);
  const comments = post.comments;
  const commentAge = comments.reduce((sum, age) => sum + Math.pow(age, 5), 0);
  const totalAge = age + commentAge;
  //use log functions to make likes score and exponentially big age score close to each other
  return Math.log10(post.likes.length) + Math.log(Math.log10(totalAge));
}

const getPeriodText = (period) => {
  let text = "Last 24 hours";
  if (period === "week") {
    text = "Last week";
  }
  if (period === "month") {
    text = "Last month";
  }
  return text;
};

const findHottestsPosts = (postIds, period) => {
  let allPosts;
  if (!state.allPosts) {
    allPosts = Near.view("near-analytics.near", "get_posts");
    if (!allPosts) {
      return [];
    }
    State.update({ allPosts });
  } else {
    allPosts = state.allPosts;
  }
  let postIdsSet = new Set(postIds);
  let posts = allPosts.filter((post) => postIdsSet.has(post.id));

  let periodTime = ONE_DAY;
  if (period === "week") {
    periodTime = ONE_WEEK;
  }
  if (period === "month") {
    periodTime = ONE_MONTH;
  }
  const periodLimitedPosts = posts.filter((post) => {
    const timestamp = post.snapshot.timestamp / 1000000;
    return Date.now() - timestamp < periodTime;
  });
  const modifiedPosts = periodLimitedPosts.map((post) => {
    const comments =
      Near.view("near-analytics.near", "get_children_ids", {
        post_id: post.id,
      }) || [];
    post = { ...post, comments };
    return {
      ...post,
      postScore: getHotnessScore(post),
    };
  });
  modifiedPosts.sort((a, b) => b.postScore - a.postScore);
  return modifiedPosts.map((post) => post.id);
};

let postIds;
if (props.searchResult) {
  postIds = props.searchResult.postIds;
  postIds = intersectPostsWithLabel(postIds);
  postIds = intersectPostsWithAuthor(postIds);
} else if (props.label) {
  postIds = getPostsByLabel();
  postIds = intersectPostsWithAuthor(postIds);
} else if (props.author) {
  postIds = getPostsByAuthor();
} else if (props.recency == "all") {
  postIds = Near.view(nearNFDevsContractAccountId, "get_all_post_ids");
  if (postIds) {
    postIds.reverse();
  }
} else {
  postIds = Near.view(nearNFDevsContractAccountId, "get_children_ids");
  if (postIds) {
    postIds.reverse();
  }
}

if (props.recency == "hot") {
  postIds = findHottestsPosts(postIds, state.period);
}

const loader = (
  <div className="loader" key={"loader"}>
    <span
      className="spinner-grow spinner-grow-sm me-1"
      role="status"
      aria-hidden="true"
    />
    Loading ...
  </div>
);

if (postIds === null) {
  return loader;
}
const initialItems = postIds;
//const initialItems = postIds.map(postId => ({ id: postId, ...Near.view(nearNFDevsContractAccountId, "get_post", { post_id: postId }) }));

// const computeFetchFrom = (items, limit) => {
//   if (!items || items.length < limit) {
//     return false;
//   }
//   const blockHeight = items[items.length - 1].blockHeight;
//   return index.options.order === "desc" ? blockHeight - 1 : blockHeight + 1;
// };

// const mergeItems = (newItems) => {
//   const items = [
//     ...new Set([...newItems, ...state.items].map((i) => JSON.stringify(i))),
//   ].map((i) => JSON.parse(i));
//   items.sort((a, b) => a.blockHeight - b.blockHeight);
//   if (index.options.order === "desc") {
//     items.reverse();
//   }
//   return items;
// };

const jInitialItems = JSON.stringify(initialItems);
if (state.jInitialItems !== jInitialItems) {
  // const jIndex = JSON.stringify(index);
  // if (jIndex !== state.jIndex) {
  State.update({
    jIndex,
    jInitialItems,
    items: initialItems,
    fetchFrom: false,
    //nextFetchFrom: computeFetchFrom(initialItems, index.options.limit),
    nextFetchFrom: false,
    displayCount: initialRenderLimit,
    cachedItems: {},
  });
  // } else {
  //   State.update({
  //     jInitialItems,
  //     items: mergeItems(initialItems),
  //   });
  // }
}

if (state.fetchFrom) {
  console.log("TODO: fetchFrom");
  // const limit = addDisplayCount;
  // const newItems = Social.index(
  //   index.action,
  //   index.key,
  //   Object.assign({}, index.options, {
  //     from: state.fetchFrom,
  //     subscribe: undefined,
  //     limit,
  //   })
  // );
  // if (newItems !== null) {
  //   State.update({
  //     items: mergeItems(newItems),
  //     fetchFrom: false,
  //     nextFetchFrom: computeFetchFrom(newItems, limit),
  //   });
  // }
}

const makeMoreItems = () => {
  State.update({
    displayCount: state.displayCount + addDisplayCount,
  });
  if (
    state.items.length - state.displayCount < addDisplayCount * 2 &&
    !state.fetchFrom &&
    state.nextFetchFrom &&
    state.nextFetchFrom !== state.fetchFrom
  ) {
    State.update({
      fetchFrom: state.nextFetchFrom,
    });
  }
};

const fetchMore =
  props.manual &&
  (state.fetchFrom && state.items.length < state.displayCount
    ? loader
    : state.displayCount < state.items.length && (
        <div key={"loader more"}>
          <a href="javascript:void" onClick={(e) => makeMoreItems()}>
            {props.loadMoreText ?? "Load more..."}
          </a>
        </div>
      ));

const items = state.items ? state.items.slice(0, state.displayCount) : [];

console.log(items);
const renderedItems = items.map(cachedRenderItem);

const Head =
  props.recency == "hot" ? (
    <div class="row">
      <div class="fs-5 col-6 align-self-center">
        <i class="bi-fire"></i>
        <span>Hottest Posts</span>
      </div>
      <div class="col-6 dropdown d-flex justify-content-end">
        <a
          class="btn btn-secondary dropdown-toggle"
          href="#"
          role="button"
          id="dropdownMenuLink"
          data-bs-toggle="dropdown"
          aria-expanded="false"
        >
          {getPeriodText(state.period)}
        </a>

        <ul class="dropdown-menu" aria-labelledby="dropdownMenuLink">
          <li>
            <button
              class="dropdown-item"
              onClick={() => {
                State.update({ period: "day" });
              }}
            >
              {getPeriodText("day")}
            </button>
          </li>
          <li>
            <button
              class="dropdown-item"
              onClick={() => {
                State.update({ period: "week" });
              }}
            >
              {getPeriodText("week")}
            </button>
          </li>
          <li>
            <button
              class="dropdown-item"
              onClick={() => {
                State.update({ period: "month" });
              }}
            >
              {getPeriodText("month")}
            </button>
          </li>
        </ul>
      </div>
    </div>
  ) : (
    <></>
  );

return (
  <>
    {Head}
    {state.items.length > 0 ? (
      <InfiniteScroll
        pageStart={0}
        loadMore={makeMoreItems}
        hasMore={state.displayCount < state.items.length}
        loader={loader}
      >
        {renderedItems}
      </InfiniteScroll>
    ) : (
      <p class="text-secondary">
        No posts {props.searchResult ? "matches search" : ""}
        {props.recency == "hot"
          ? " in " + getPeriodText(state.period).toLowerCase()
          : ""}
      </p>
    )}
  </>
);
'''
'''--- townhall-board.components.posts.Post.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */
/* INCLUDE: "shared/lib/gui" */
const Card = styled.div`
  &:hover {
    box-shadow: rgba(3, 102, 214, 0.3) 0px 0px 0px 3px;
  }
`;

const CompactContainer = styled.div`
  width: fit-content !important;
  max-width: 100%;
`;
/* END_INCLUDE: "shared/lib/gui" */

const postId = props.post.id ?? (props.id ? parseInt(props.id) : 0);
const post =
  props.post ??
  Near.view(nearNFDevsContractAccountId, "get_post", { post_id: postId });
if (!post) {
  return <div>Loading ...</div>;
}

const snapshot = post.snapshot;
// If this post is displayed under another post. Used to limit the size.
const isUnderPost = props.isUnderPost ? true : false;
const parentId = Near.view(nearNFDevsContractAccountId, "get_parent_id", {
  post_id: postId,
});

const childPostIdsUnordered =
  Near.view(nearNFDevsContractAccountId, "get_children_ids", {
    post_id: postId,
  }) ?? [];

const childPostIds = props.isPreview ? [] : childPostIdsUnordered.reverse();
const expandable = props.isPreview ? false : props.expandable ?? false;
const defaultExpanded = expandable ? props.defaultExpanded : true;

function readableDate(timestamp) {
  var a = new Date(timestamp);
  return a.toDateString() + " " + a.toLocaleTimeString();
}

const timestamp = readableDate(
  snapshot.timestamp ? snapshot.timestamp / 1000000 : Date.now()
);

const postSearchKeywords = props.searchKeywords ? (
  <div style={{ "font-family": "monospace" }} key="post-search-keywords">
    <span>Found keywords: </span>
    {props.searchKeywords.map((label) => {
      return <span class="badge text-bg-info me-1">{label}</span>;
    })}
  </div>
) : (
  <div key="post-search-keywords"></div>
);

const searchKeywords = props.searchKeywords ? (
  <div class="mb-1" key="search-keywords">
    <small class="text-muted">{postSearchKeywords}</small>
  </div>
) : (
  <div key="search-keywords"></div>
);

const linkToParent =
  isUnderPost || !parentId ? (
    <div key="link-to-parent"></div>
  ) : (
    <div className="card-header" key="link-to-parent">
      <a href={href("Post", { id: parentId })}>
        <i class="bi bi-arrow-90deg-up"></i>Go to parent{" "}
      </a>
    </div>
  );

const allowedToEdit =
  !props.isPreview &&
  Near.view(nearNFDevsContractAccountId, "is_allowed_to_edit", {
    post_id: postId,
    editor: context.accountId,
  });

const btnEditorWidget = (postType, name) => {
  return (
    <li>
      <a
        class="dropdown-item"
        data-bs-toggle="collapse"
        href={`#collapse${postType}Editor${postId}`}
        role="button"
        aria-expanded="false"
        aria-controls={`collapse${postType}Editor${postId}`}
      >
        {name}
      </a>
    </li>
  );
};

const editControl = allowedToEdit ? (
  <div class="btn-group" role="group">
    <a
      class="card-link px-2"
      role="button"
      title="Edit post"
      data-bs-toggle="dropdown"
      aria-expanded="false"
      type="button"
    >
      <div class="bi bi-pencil-square"></div>
    </a>
    <ul class="dropdown-menu">
      {btnEditorWidget("Idea", "Edit as an idea")}
      {btnEditorWidget("Submission", "Edit as a solution")}
      {btnEditorWidget("Attestation", "Edit as an attestation")}
      {btnEditorWidget("Sponsorship", "Edit as a sponsorship")}
      {btnEditorWidget("Comment", "Edit as a comment")}
    </ul>
  </div>
) : (
  <div></div>
);

const shareButton = props.isPreview ? (
  <div></div>
) : (
  <a
    class="card-link"
    href={href("Post", { id: postId })}
    role="button"
    target="_blank"
    title="Open in new tab"
  >
    <div class="bi bi-share"></div>
  </a>
);

const header = (
  <div className="card-header" key="header">
    <small class="text-muted">
      <div class="row justify-content-between">
        <div class="col-4">
          <Widget
            src={`neardevgov.near/widget/ProfileLine`}
            props={{ accountId: post.author_id }}
          />
        </div>
        <div class="col-5">
          <div class="d-flex justify-content-end">
            {editControl}
            {timestamp}
            <div class="bi bi-clock-history px-2"></div>
            {shareButton}
          </div>
        </div>
      </div>
    </small>
  </div>
);

const emptyIcons = {
  Idea: "bi-lightbulb",
  Comment: "bi-chat",
  Submission: "bi-rocket",
  Attestation: "bi-check-circle",
  Sponsorship: "bi-cash-coin",
  Github: "bi-github",
  Like: "bi-heart",
  Reply: "bi-reply",
};

const fillIcons = {
  Idea: "bi-lightbulb-fill",
  Comment: "bi-chat-fill",
  Submission: "bi-rocket-fill",
  Attestation: "bi-check-circle-fill",
  Sponsorship: "bi-cash-coin",
  Github: "bi-github",
  Like: "bi-heart-fill",
  Reply: "bi-reply-fill",
};

// Trigger saving this widget.

const borders = {
  Idea: "border-secondary",
  Comment: "border-secondary",
  Submission: "border-secondary",
  Attestation: "border-secondary",
  Sponsorship: "border-secondary",
  Github: "border-secondary",
};

const containsLike = props.isPreview
  ? false
  : post.likes.find((l) => l.author_id == context.accountId);
const likeBtnClass = containsLike ? fillIcons.Like : emptyIcons.Like;
// This must be outside onLike, because Near.view returns null at first, and when the view call finished, it returns true/false.
// If checking this inside onLike, it will give `null` and we cannot tell the result is true or false.
let grantNotify = Near.view("social.near", "is_write_permission_granted", {
  predecessor_id: nearNFDevsContractAccountId,
  key: context.accountId + "/index/notify",
});
if (grantNotify === null) {
  return;
}
const onLike = () => {
  if (!context.accountId) {
    return;
  }
  let likeTxn = [
    {
      contractName: nearNFDevsContractAccountId,
      methodName: "add_like",
      args: {
        post_id: postId,
      },
      deposit: Big(10).pow(21).mul(2),
      gas: Big(10).pow(12).mul(100),
    },
  ];

  if (grantNotify === false) {
    likeTxn.unshift({
      contractName: "social.near",
      methodName: "grant_write_permission",
      args: {
        predecessor_id: nearNFDevsContractAccountId,
        keys: [context.accountId + "/index/notify"],
      },
      deposit: Big(10).pow(23),
      gas: Big(10).pow(12).mul(30),
    });
  }
  Near.call(likeTxn);
};

const btnCreatorWidget = (postType, icon, name, desc) => {
  return (
    <li class="py-1">
      <a
        class="dropdown-item text-decoration-none d-flex align-items-center lh-sm"
        style={{ color: "rgb(55,109,137)" }}
        data-bs-toggle="collapse"
        href={`#collapse${postType}Creator${postId}`}
        role="button"
        aria-expanded="false"
        aria-controls={`collapse${postType}Creator${postId}`}
      >
        <i class={`bi ${icon}`} style={{ fontSize: "1.5rem" }}>
          {" "}
        </i>
        <div class="ps-2 text-wrap" style={{ width: "18rem" }}>
          <div>{name}</div>
          <small class="fw-light text-secondary">{desc}</small>
        </div>
      </a>
    </li>
  );
};

const buttonsFooter = props.isPreview ? null : (
  <div class="row" key="buttons-footer">
    <div class="col-8">
      <div class="btn-group" role="group" aria-label="Basic outlined example">
        <button
          type="button"
          class="btn btn-outline-primary"
          style={{ border: "0px" }}
          onClick={onLike}
        >
          <i class={`bi ${likeBtnClass}`}> </i>
          {post.likes.length == 0
            ? "Like"
            : widget("components.layout.LikeButton.Faces", {
                likesByUsers: Object.fromEntries(
                  post.likes.map(({ author_id }) => [author_id, ""])
                ),
              })}
        </button>
        <div class="btn-group" role="group">
          <button
            type="button"
            class="btn btn-outline-primary"
            style={{ border: "0px" }}
            data-bs-toggle="dropdown"
            aria-expanded="false"
          >
            <i class={`bi ${emptyIcons.Reply}`}> </i> Reply
          </button>
          <ul class="dropdown-menu">
            {btnCreatorWidget(
              "Idea",
              emptyIcons.Idea,
              "Idea",
              "Get feedback from the community about a problem, opportunity, or need."
            )}
            {btnCreatorWidget(
              "Submission",
              emptyIcons.Submission,
              "Solution",
              "Provide a specific proposal or implementation to an idea, optionally requesting funding."
            )}
            {btnCreatorWidget(
              "Attestation",
              emptyIcons.Attestation,
              "Attestation",
              "Formally review or validate a solution as a recognized expert."
            )}
            {btnCreatorWidget(
              "Sponsorship",
              emptyIcons.Sponsorship,
              "Sponsorship",
              "Offer to fund projects, events, or proposals that match your needs."
            )}
            <li>
              <hr class="dropdown-divider" />
            </li>
            {btnCreatorWidget(
              "Comment",
              emptyIcons.Comment,
              "Comment",
              "Ask a question, provide information, or share a resource that is relevant to the thread."
            )}
          </ul>
        </div>
        <button
          type="button"
          class="btn btn-outline-primary"
          style={{ border: "0px" }}
          data-bs-toggle="collapse"
          href={`#collapseChildPosts${postId}`}
          aria-expanded={defaultExpanded}
          aria-controls={`collapseChildPosts${postId}`}
        >
          <i class="bi bi-arrows-expand"> </i>{" "}
          {`Expand Replies (${childPostIds.length})`}
        </button>
      </div>
    </div>
  </div>
);

const CreatorWidget = (postType) => {
  return (
    <div
      class="collapse"
      id={`collapse${postType}Creator${postId}`}
      data-bs-parent={`#accordion${postId}`}
    >
      {widget("components.posts.PostEditor", {
        postType,
        parentId: postId,
        mode: "Create",
      })}
    </div>
  );
};

const EditorWidget = (postType) => {
  return (
    <div
      class="collapse"
      id={`collapse${postType}Editor${postId}`}
      data-bs-parent={`#accordion${postId}`}
    >
      {widget("components.posts.PostEditor", {
        postType,
        postId,
        mode: "Edit",
        author_id: post.author_id,
        labels: post.snapshot.labels,
        name: post.snapshot.name,
        description: post.snapshot.description,
        amount: post.snapshot.amount,
        token: post.snapshot.sponsorship_token,
        supervisor: post.snapshot.supervisor,
        githubLink: post.snapshot.github_link,
      })}
    </div>
  );
};

const editorsFooter = props.isPreview ? null : (
  <div class="row" id={`accordion${postId}`} key="editors-footer">
    {CreatorWidget("Comment")}
    {EditorWidget("Comment")}
    {CreatorWidget("Idea")}
    {EditorWidget("Idea")}
    {CreatorWidget("Submission")}
    {EditorWidget("Submission")}
    {CreatorWidget("Attestation")}
    {EditorWidget("Attestation")}
    {CreatorWidget("Sponsorship")}
    {EditorWidget("Sponsorship")}
    {CreatorWidget("Github")}
    {EditorWidget("Github")}
  </div>
);

const renamedPostType =
  snapshot.post_type == "Submission" ? "Solution" : snapshot.post_type;

const postLabels = post.snapshot.labels ? (
  <div class="card-title" key="post-labels">
    {post.snapshot.labels.map((label) => {
      return (
        <a href={href("Feed", { label }, label)}>
          <span class="badge text-bg-primary me-1">{label}</span>
        </a>
      );
    })}
  </div>
) : (
  <div key="post-labels"></div>
);

const postTitle =
  snapshot.post_type == "Comment" ? (
    <div key="post-title"></div>
  ) : (
    <h5 class="card-title" key="post-title">
      <div className="row justify-content-between">
        <div class="col-9">
          <i class={`bi ${emptyIcons[snapshot.post_type]}`}> </i>
          {renamedPostType}: {snapshot.name}
        </div>
      </div>
    </h5>
  );

const postExtra =
  snapshot.post_type == "Sponsorship" ? (
    <div key="post-extra">
      <h6 class="card-subtitle mb-2 text-muted">
        Maximum amount: {snapshot.amount} {snapshot.sponsorship_token}
      </h6>
      <h6 class="card-subtitle mb-2 text-muted">
        Supervisor:{" "}
        <Widget
          src={`neardevgov.near/widget/ProfileLine`}
          props={{ accountId: snapshot.supervisor }}
        />
      </h6>
    </div>
  ) : (
    <div></div>
  );

const postsList =
  props.isPreview || childPostIds.length == 0 ? (
    <div key="posts-list"></div>
  ) : (
    <div class="row" key="posts-list">
      <div
        class={`collapse ${defaultExpanded ? "show" : ""}`}
        id={`collapseChildPosts${postId}`}
      >
        {childPostIds.map((childId) =>
          widget(
            "components.posts.Post",
            { id: childId, isUnderPost: true },
            `subpost${childId}of${postId}`
          )
        )}
      </div>
    </div>
  );

const limitedMarkdown = styled.div`
  max-height: 20em;
`;

const clampMarkdown = styled.div`
  .clamp {
    -webkit-mask-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 1),
      rgba(0, 0, 0, 0)
    );
    mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0));
  }
`;

// Determine if located in the post page.
const isInList = props.isInList;
const contentArray = snapshot.description.split("\n");
const needClamp = isInList && contentArray.length > 5;

initState({
  clamp: needClamp,
});

const clampedContent = needClamp
  ? contentArray.slice(0, 5).join("\n")
  : snapshot.description;

const onMention = (accountId) => (
  <span key={accountId} className="d-inline-flex" style={{ fontWeight: 500 }}>
    <Widget
      src="neardevgov.near/widget/ProfileLine"
      props={{
        accountId: accountId.toLowerCase(),
        hideAccountId: true,
        tooltip: true,
      }}
    />
  </span>
);

// Should make sure the posts under the currently top viewed post are limited in size.
const descriptionArea = isUnderPost ? (
  <limitedMarkdown className="overflow-auto" key="description-area">
    <Markdown
      class="card-text"
      text={snapshot.description}
      onMention={onMention}
    />
  </limitedMarkdown>
) : (
  <clampMarkdown>
    <div class={state.clamp ? "clamp" : ""}>
      <Markdown
        class="card-text"
        text={state.clamp ? clampedContent : snapshot.description}
        onMention={onMention}
        key="description-area"
      ></Markdown>
    </div>
    {state.clamp ? (
      <div class="d-flex justify-content-center">
        <a
          class="btn btn-link text-secondary"
          onClick={() => State.update({ clamp: false })}
        >
          Read More
        </a>
      </div>
    ) : (
      <></>
    )}
  </clampMarkdown>
);

return (
  <Card className={`card my-2 ${borders[snapshot.post_type]}`}>
    {linkToParent}
    {header}
    <div className="card-body">
      {searchKeywords}
      {postLabels}
      {postTitle}
      {postExtra}
      {descriptionArea}
      {buttonsFooter}
      {editorsFooter}
      {postsList}
    </div>
  </Card>
);

'''
'''--- townhall-board.components.posts.PostEditor.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

const postType = props.postType ?? "Sponsorship";
const parentId = props.parentId ?? null;
const postId = props.postId ?? null;
const mode = props.mode ?? "Create";

const referralLabels = props.referral ? [`referral:${props.referral}`] : [];
const labelStrings = (props.labels ?? []).concat(referralLabels);
const labels = labelStrings.map((s) => {
  return { name: s };
});

initState({
  author_id: context.accountId,
  // Should be a list of objects with field "name".
  labels,
  // Should be a list of labels as strings.
  // Both of the label structures should be modified together.
  labelStrings,
  postType,
  name: props.name ?? "",
  description: props.description ?? "",
  amount: props.amount ?? "0",
  token: props.token ?? "Near",
  supervisor: props.supervisor ?? "",
  githubLink: props.githubLink ?? "",
  warning: "",
});

let fields = {
  Comment: ["description"],
  Idea: ["name", "description"],
  Submission: ["name", "description"],
  Attestation: ["name", "description"],
  Sponsorship: [
    "name",
    "description",
    "amount",
    "sponsorship_token",
    "supervisor",
  ],
  Github: ["githubLink", "name", "description"],
}[postType];

// This must be outside onClick, because Near.view returns null at first, and when the view call finished, it returns true/false.
// If checking this inside onClick, it will give `null` and we cannot tell the result is true or false.
let grantNotify = Near.view("social.near", "is_write_permission_granted", {
  predecessor_id: nearNFDevsContractAccountId,
  key: context.accountId + "/index/notify",
});
if (grantNotify === null) {
  return;
}
const onSubmit = () => {
  let labels = state.labelStrings;
  var body = {
    Comment: { description: state.description, comment_version: "V2" },
    Idea: {
      name: state.name,
      description: state.description,
      idea_version: "V1",
    },
    Submission: {
      name: state.name,
      description: state.description,
      submission_version: "V1",
    },
    Attestation: {
      name: state.name,
      description: state.description,
      attestation_version: "V1",
    },
    Sponsorship: {
      name: state.name,
      description: state.description,
      amount: state.amount,
      sponsorship_token: state.token,
      supervisor: state.supervisor,
      sponsorship_version: "V1",
    },
    Github: {
      name: state.name,
      description: state.description,
      github_version: "V0",
      github_link: state.githubLink,
    },
  }[postType];
  body["post_type"] = postType;
  if (!context.accountId) {
    return;
  }
  let txn = [];
  if (mode == "Create") {
    txn.push({
      contractName: nearNFDevsContractAccountId,
      methodName: "add_post",
      args: {
        parent_id: parentId,
        labels,
        body,
      },
      deposit: Big(10).pow(21).mul(2),
      gas: Big(10).pow(12).mul(100),
    });
  } else if (mode == "Edit") {
    txn.push({
      contractName: nearNFDevsContractAccountId,
      methodName: "edit_post",
      args: {
        id: postId,
        labels,
        body,
      },
      deposit: Big(10).pow(21).mul(2),
      gas: Big(10).pow(12).mul(100),
    });
  }
  if (mode == "Create" || mode == "Edit") {
    if (grantNotify === false) {
      txn.unshift({
        contractName: "social.near",
        methodName: "grant_write_permission",
        args: {
          predecessor_id: nearNFDevsContractAccountId,
          keys: [context.accountId + "/index/notify"],
        },
        deposit: Big(10).pow(23),
        gas: Big(10).pow(12).mul(30),
      });
    }
    Near.call(txn);
  }
};

const normalizeLabel = (label) =>
  label
    .replaceAll(/[- \.]/g, "_")
    .replaceAll(/[^\w]+/g, "")
    .replaceAll(/_+/g, "-")
    .replace(/^-+/, "")
    .replace(/-+$/, "")
    .toLowerCase()
    .trim("-");

const checkLabel = (label) => {
  Near.asyncView(nearNFDevsContractAccountId, "is_allowed_to_use_labels", {
    editor: context.accountId,
    labels: [label],
  }).then((allowed) => {
    if (allowed) {
      State.update({ warning: "" });
    } else {
      State.update({
        warning:
          'The label "' +
          label +
          '" is protected and can only be added by moderators',
      });
      return;
    }
  });
};

const setLabels = (labels) => {
  labels = labels.map((o) => {
    o.name = normalizeLabel(o.name);
    return o;
  });
  if (labels.length < state.labels.length) {
    let oldLabels = new Set(state.labels.map((label) => label.name));
    for (let label of labels) {
      oldLabels.delete(label.name);
    }
    let removed = oldLabels.values().next().value;
    Near.asyncView(
      nearNFDevsContractAccountId,
      "is_allowed_to_use_labels",
      { editor: context.accountId, labels: [removed] }
    ).then((allowed) => {
      if (allowed) {
        let labelStrings = labels.map(({ name }) => name);
        State.update({ labels, labelStrings });
      } else {
        State.update({
          warning:
            'The label "' +
            removed +
            '" is protected and can only be updated by moderators',
        });
        return;
      }
    });
  } else {
    let labelStrings = labels.map((o) => {
      return o.name;
    });
    State.update({ labels, labelStrings });
  }
};
const existingLabelStrings =
  Near.view(nearNFDevsContractAccountId, "get_all_allowed_labels", {
    editor: context.accountId,
  }) ?? [];
const existingLabelSet = new Set(existingLabelStrings);
const existingLabels = existingLabelStrings.map((s) => {
  return { name: s };
});

const labelEditor = (
  <div className="col-lg-12  mb-2">
    Labels:
    <Typeahead
      multiple
      labelKey="name"
      onInputChange={checkLabel}
      onChange={setLabels}
      options={existingLabels}
      placeholder="near.social, widget, NEP, standard, protocol, tool"
      selected={state.labels}
      positionFixed
      allowNew={(results, props) => {
        return (
          !existingLabelSet.has(props.text) &&
          props.selected.filter((selected) => selected.name === props.text)
            .length == 0 &&
          Near.view(
            nearNFDevsContractAccountId,
            "is_allowed_to_use_labels",
            { editor: context.accountId, labels: [props.text] }
          )
        );
      }}
    />
  </div>
);

const githubLinkDiv = fields.includes("githubLink") ? (
  <div className="col-lg-12  mb-2">
    Github Issue URL:
    <input
      type="text"
      value={state.githubLink}
      onChange={(event) => State.update({ githubLink: event.target.value })}
    />
  </div>
) : null;

const nameDiv = fields.includes("name") ? (
  <div className="col-lg-6  mb-2">
    Title:
    <input
      type="text"
      value={state.name}
      onChange={(event) => State.update({ name: event.target.value })}
    />
  </div>
) : null;

const descriptionDiv = fields.includes("description") ? (
  <div className="col-lg-12  mb-2">
    Description:
    <br />
    <textarea
      value={state.description}
      type="text"
      rows={6}
      className="form-control"
      onChange={(event) => State.update({ description: event.target.value })}
    />
  </div>
) : null;

const amountDiv = fields.includes("amount") ? (
  <div className="col-lg-6  mb-2">
    Amount:
    <input
      type="text"
      value={state.amount}
      onChange={(event) => State.update({ amount: event.target.value })}
    />
  </div>
) : null;

const tokenDiv = fields.includes("sponsorship_token") ? (
  <div className="col-lg-6  mb-2">
    Tokens:
    <input
      type="text"
      value={state.token}
      onChange={(event) => State.update({ token: event.target.value })}
    />
  </div>
) : null;

const supervisorDiv = fields.includes("supervisor") ? (
  <div className="col-lg-6 mb-2">
    Supervisor:
    <input
      type="text"
      value={state.supervisor}
      onChange={(event) => State.update({ supervisor: event.target.value })}
    />
  </div>
) : null;

const disclaimer = (
  <p>
    <i>
      * Note, all projects that were granted sponsorships are required to pass
      KYC to receive the funding.
    </i>
  </p>
);

const renamedPostType = postType == "Submission" ? "Solution" : postType;
// Below there is a weird code with fields.includes("githubLink") ternary operator.
// This is to hack around rendering bug of near.social.
return (
  <div className="card">
    <div className="card-header">
      {mode} {renamedPostType}
    </div>

    <div class="card-body">
      {state.warning ? (
        <div
          class="alert alert-warning alert-dismissible fade show"
          role="alert"
        >
          {state.warning}
          <button
            type="button"
            class="btn-close"
            data-bs-dismiss="alert"
            aria-label="Close"
            onClick={() => State.update({ warning: "" })}
          ></button>
        </div>
      ) : (
        <></>
      )}
      {fields.includes("githubLink") ? (
        <div className="row">
          {githubLinkDiv}
          {labelEditor}
          {nameDiv}
          {descriptionDiv}
        </div>
      ) : (
        <div className="row">
          {labelEditor}
          {nameDiv}
          {amountDiv}
          {tokenDiv}
          {supervisorDiv}
          {descriptionDiv}
        </div>
      )}

      <a className="btn btn-outline-primary mb-2" onClick={onSubmit}>
        Submit
      </a>
      {disclaimer}
    </div>
    <div class="card-footer">
      Preview:
      {widget("components.posts.Post", {
        isPreview: true,
        id: 0, // irrelevant
        post: {
          author_id: state.author_id,
          likes: [],
          snapshot: {
            editor_id: state.editor_id,
            labels: state.labelStrings,
            post_type: postType,
            name: state.name,
            description: state.description,
            amount: state.amount,
            sponsorship_token: state.token,
            supervisor: state.supervisor,
            github_link: state.githubLink,
          },
        },
      })}
    </div>
  </div>
);
'''
'''--- townhall-board.components.posts.Search.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

//////////////////////////////////////////////////////////////////////
///STOPWORDS//////////////////////////////////////////////////////////
const stopWords = [
  "about",
  "above",
  "after",
  "again",
  "against",
  "all",
  "and",
  "any",
  "are",
  "because",
  "been",
  "before",
  "being",
  "below",
  "between",
  "both",
  "but",
  "can",
  "cannot",
  "could",
  "did",
  "does",
  "doing",
  "down",
  "during",
  "each",
  "etc",
  "few",
  "for",
  "from",
  "further",
  "had",
  "has",
  "have",
  "having",
  "her",
  "hers",
  "herself",
  "him",
  "himself",
  "his",
  "how",
  "into",
  "its",
  "itself",
  "just",
  "more",
  "most",
  "myself",
  "nor",
  "not",
  "now",
  "off",
  "once",
  "only",
  "other",
  "our",
  "ours",
  "ourselves",
  "out",
  "over",
  "own",
  "same",
  "she",
  "should",
  "some",
  "still",
  "such",
  "than",
  "that",
  "the",
  "their",
  "theirs",
  "them",
  "themselves",
  "then",
  "there",
  "these",
  "they",
  "this",
  "those",
  "through",
  "too",
  "under",
  "until",
  "very",
  "was",
  "were",
  "what",
  "when",
  "where",
  "which",
  "while",
  "who",
  "whom",
  "why",
  "will",
  "with",
  "you",
  "your",
  "yours",
  "yourself",
  "yourselves",
  "www",
  "http",
  "com",
];

const stopWordsDictionary = {};
for (let i = 0; i < stopWords.length; i++) {
  stopWordsDictionary[stopWords[i]] = true;
}

function isStopWord(word) {
  return stopWordsDictionary.hasOwnProperty(word.toLowerCase());
}
//////////////////////////////////////////////////////////////////////
///SYNONYMS///////////////////////////////////////////////////////////
const synonyms = {
  ether: "ethereum",
  eth: "ethereum",
  either: "ethereum",
  app: "application",
  cryptocyrrency: "crypto",
  developerdao: "devdao",
  dev: "develop",
  doc: "document",
  lib: "librari",
  saw: "see",
  seen: "see",
  tweet: "twitter",
  paid: "pai",
  src: "sourc",
};

const applySynonym = (word) => {
  if (synonyms.hasOwnProperty(word.toLowerCase())) {
    return synonyms[word];
  }
  return word;
};
//////////////////////////////////////////////////////////////////////
///STEMMING///////////////////////////////////////////////////////////
const step2list = {
  ational: "ate",
  tional: "tion",
  enci: "ence",
  anci: "ance",
  izer: "ize",
  bli: "ble",
  alli: "al",
  entli: "ent",
  eli: "e",
  ousli: "ous",
  ization: "ize",
  ation: "ate",
  ator: "ate",
  alism: "al",
  iveness: "ive",
  fulness: "ful",
  ousness: "ous",
  aliti: "al",
  iviti: "ive",
  biliti: "ble",
  logi: "log",
};

/** @type {Record<string, string>} */
const step3list = {
  icate: "ic",
  ative: "",
  alize: "al",
  iciti: "ic",
  ical: "ic",
  ful: "",
  ness: "",
};

const gt0 = /^([^aeiou][^aeiouy]*)?([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)/;
const eq1 =
  /^([^aeiou][^aeiouy]*)?([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)([aeiouy][aeiou]*)?$/;
const gt1 =
  /^([^aeiou][^aeiouy]*)?(([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)){2,}/;
const vowelInStem = /^([^aeiou][^aeiouy]*)?[aeiouy]/;
const consonantLike = /^([^aeiou][^aeiouy]*)[aeiouy][^aeiouwxy]$/;

// Exception expressions.
const sfxLl = /ll$/;
const sfxE = /^(.+?)e$/;
const sfxY = /^(.+?)y$/;
const sfxIon = /^(.+?(s|t))(ion)$/;
const sfxEdOrIng = /^(.+?)(ed|ing)$/;
const sfxAtOrBlOrIz = /(at|bl|iz)$/;
const sfxEED = /^(.+?)eed$/;
const sfxS = /^.+?[^s]s$/;
const sfxSsesOrIes = /^.+?(ss|i)es$/;
const sfxMultiConsonantLike = /([^aeiouylsz])\1$/;
const step2 =
  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
const step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
const step4 =
  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;

/**
 * Get the stem from a given value.
 *
 * @param {string} value
 *   Value to stem.
 * @returns {string}
 *   Stem for `value`
 */
// eslint-disable-next-line complexity
function stemmer(value) {
  let result = value.toLowerCase();

  // Exit early.
  if (result.length < 3) {
    return result;
  }

  /** @type {boolean} */
  let firstCharacterWasLowerCaseY = false;

  // Detect initial `y`, make sure it never matches.
  if (
    result.codePointAt(0) === 121 // Lowercase Y
  ) {
    firstCharacterWasLowerCaseY = true;
    result = "Y" + result.slice(1);
  }

  // Step 1a.
  if (sfxSsesOrIes.test(result)) {
    // Remove last two characters.
    result = result.slice(0, -2);
  } else if (sfxS.test(result)) {
    // Remove last character.
    result = result.slice(0, -1);
  }

  /** @type {RegExpMatchArray|null} */
  let match;

  // Step 1b.
  if ((match = sfxEED.exec(result))) {
    if (gt0.test(match[1])) {
      // Remove last character.
      result = result.slice(0, -1);
    }
  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {
    result = match[1];

    if (sfxAtOrBlOrIz.test(result)) {
      // Append `e`.
      result += "e";
    } else if (sfxMultiConsonantLike.test(result)) {
      // Remove last character.
      result = result.slice(0, -1);
    } else if (consonantLike.test(result)) {
      // Append `e`.
      result += "e";
    }
  }

  // Step 1c.
  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {
    // Remove suffixing `y` and append `i`.
    result = match[1] + "i";
  }

  // Step 2.
  if ((match = step2.exec(result)) && gt0.test(match[1])) {
    result = match[1] + step2list[match[2]];
  }

  // Step 3.
  if ((match = step3.exec(result)) && gt0.test(match[1])) {
    result = match[1] + step3list[match[2]];
  }

  // Step 4.
  if ((match = step4.exec(result))) {
    if (gt1.test(match[1])) {
      result = match[1];
    }
  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {
    result = match[1];
  }

  // Step 5.
  if (
    (match = sfxE.exec(result)) &&
    (gt1.test(match[1]) ||
      (eq1.test(match[1]) && !consonantLike.test(match[1])))
  ) {
    result = match[1];
  }

  if (sfxLl.test(result) && gt1.test(result)) {
    result = result.slice(0, -1);
  }

  // Turn initial `Y` back to `y`.
  if (firstCharacterWasLowerCaseY) {
    result = "y" + result.slice(1);
  }

  return result;
}

//////////////////////////////////////////////////////////////////////
///SPELLCHECK/////////////////////////////////////////////////////////
function levenshteinDistance(s, t, threshold) {
  const BIG_NUMBER = 10000;
  if (s == null || t == null) {
    return BIG_NUMBER;
  }
  if (threshold < 0) {
    return BIG_NUMBER;
  }
  let n = s.length;
  let m = t.length;
  if (Math.abs(n - m) >= threshold) {
    return BIG_NUMBER;
  }

  // if one string is empty, the edit distance is necessarily the length of the other
  if (n == 0) {
    return m <= threshold ? m : BIG_NUMBER;
  } else if (m == 0) {
    return n <= threshold ? n : BIG_NUMBER;
  }

  if (n > m) {
    // swap the two strings to consume less memory
    let temp = s;
    s = t;
    t = temp;
    let tempSize = n;
    n = m;
    m = tempSize;
  }

  let p = Array.from({ length: n + 1 }, () => 0); // 'previous' cost array, horizontally
  let d = Array.from({ length: n + 1 }, () => 0); // cost array, horizontally
  let _d; // placeholder to assist in swapping p and d

  // fill in starting table values
  const boundary = Math.min(n, threshold) + 1;
  for (let i = 0; i < boundary; i++) {
    p[i] = i;
  }
  // these fills ensure that the value above the rightmost entry of our
  // stripe will be ignored in following loop iterations
  for (let i = boundary; i < p.length; i++) {
    p[i] = BIG_NUMBER;
  }
  for (let i = 0; i < d.length; i++) {
    d[i] = BIG_NUMBER;
  }

  // iterates through t
  for (let j = 1; j <= m; j++) {
    const t_j = t.charAt(j - 1); // jth character of t
    d[0] = j;

    // compute stripe indices, constrain to array size
    const min = Math.max(1, j - threshold);
    const max = j > BIG_NUMBER - threshold ? n : Math.min(n, j + threshold);

    // the stripe may lead off of the table if s and t are of different sizes
    if (min > max) {
      return BIG_NUMBER;
    }

    // ignore entry left of leftmost
    if (min > 1) {
      d[min - 1] = BIG_NUMBER;
    }

    // iterates through [min, max] in s
    for (let i = min; i <= max; i++) {
      if (s.charAt(i - 1) == t_j) {
        // diagonally left and up
        d[i] = p[i - 1];
      } else {
        // 1 + minimum of cell to the left, to the top, diagonally left and up
        d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
      }
    }

    // copy current distance counts to 'previous row' distance counts
    _d = p;
    p = d;
    d = _d;
  }
  // we don't need to check for threshold here because we did it inside the loop
  return p[n] <= threshold ? p[n] : BIG_NUMBER;
}

const spellcheckQueryProcessing = (query, dictionary) => {
  // Split text document into words
  const words = stemAndFilterQuery(query);
  const dictionaryArray = Object.keys(dictionary);
  // Iterate over each word in the text
  for (let i = 0; i < words.length; i++) {
    let word = words[i].toLowerCase().replace(/[^a-z0-9]/g, "");

    // If the word is not in the dictionary, find the closest match
    if (!dictionary.hasOwnProperty(word)) {
      let closestMatch = undefined;
      let closestDistance = word.length;
      let allowedDistance = Math.min(word.length - 1, 3);
      // Iterate over each word in the dictionary
      if (word.length > 1) {
        for (let j = 0; j < dictionaryArray.length; j++) {
          let dictWord = dictionaryArray[j];
          let distance = levenshteinDistance(word, dictWord, allowedDistance);

          // If the distance is less than the closest distance, update the closest match
          if (distance <= allowedDistance && distance < closestDistance) {
            closestMatch = dictWord;
            closestDistance = distance;
          }
        }
      }
      // Replace the misspelled word with the closest match
      words[i] = closestMatch;
    }
  }
  return words.filter((word) => !!word);
};

//////////////////////////////////////////////////////////////////////
///INDEXER&SEARCH/////////////////////////////////////////////////////
const fillDictionaryWith = (dict, text, id) => {
  let word = "";
  for (let i = 0; i < text.length; i++) {
    const char = text.charAt(i);
    const nextChar = text.charAt(i + 1);
    if (/\w/.test(char) || (char === "." && /\w/.test(nextChar))) {
      word += char.toLowerCase();
    } else if (word.length > 0) {
      const processedWord = applySynonym(stemmer(word));
      if (processedWord.length > 1 && !isStopWord(processedWord)) {
        const oldValue = dict[processedWord] || [];
        dict[processedWord] = [...oldValue, id];
      }
      word = "";
    }
  }
  const processedWord = applySynonym(stemmer(word));
  if (processedWord.length > 1 && !isStopWord(processedWord)) {
    const oldValue = dict[stemmer(processedWord)] || [];
    dict[stemmer(processedWord)] = [...oldValue, id];
  }
  return dict;
};

const buildIndex = (posts) => {
  let index = {};

  posts.forEach((post) => {
    const title = post.snapshot.name;
    const labels = post.snapshot.labels.join(" ");
    const text = post.snapshot.description;
    const postType = post.snapshot.post_type;
    const authorId = post.author_id;
    const postText = `${authorId} ${postType} ${title} ${labels} ${text}`;
    index = fillDictionaryWith(index, postText, post.id);
  });
  return index;
};

const stemAndFilterQuery = (query) => {
  return Object.keys(fillDictionaryWith({}, query));
};

const sortSearchResult = (searchResult) => {
  // create a map to count the frequency of each element
  const freq = new Map();
  for (const num of searchResult) {
    freq.set(num, (freq.get(num) || 0) + 1);
  }

  // define a custom comparison function to sort the array
  function compare(a, b) {
    // compare the frequency of the two elements
    const freqDiff = freq.get(b) - freq.get(a);
    if (freqDiff !== 0) {
      return freqDiff; // if they have different frequency, sort by frequency
    } else {
      return 0; // if they have the same frequency, leave as it is. Will be sorted by search term, by date
    }
  }

  // sort the array using the custom comparison function
  searchResult.sort(compare);
  return searchResult.filter(
    (elem, index) => searchResult.indexOf(elem) === index
  );
};

const search = (processedQueryArray, index) => {
  return sortSearchResult(
    processedQueryArray.flatMap((queryWord) => {
      const termSearchRes = index[queryWord].reverse();
      const termSortedSearchRes = sortSearchResult(termSearchRes);
      return termSortedSearchRes;
    })
  );
};

//////////////////////////////////////////////////////////////////////
///UI&UX//////////////////////////////////////////////////////////////
//Run search and spelling computation every time the search bar modified
//but no more frequent than 1 time per 1.5 seconds
const amountOfResultsToShowFirst = 5;

const buildPostsIndex = () => {
  return Near.asyncView("near-analytics.near", "get_posts").then((posts) => {
    const index = buildIndex(posts);
    const data = posts.reduce((acc, post) => {
      acc[post.id] = post;
      return acc;
    }, {});
    return { index, data };
  });
};

const getProcessedPostsCached = () => {
  return useCache(() => buildPostsIndex(), "processedPostsCached");
};

if (!state.interval) {
  let termStorage = "";
  Storage.privateSet("term", "");
  setInterval(() => {
    const currentInput = Storage.privateGet("term");
    if (currentInput !== termStorage) {
      termStorage = currentInput;
      computeResults(termStorage);
    }
  }, 1500);
  State.update({
    interval: true,
  });
}

const computeResults = (term) => {
  const start = new Date().getTime();
  const processedPostsCached = useCache(
    () =>
      buildPostsIndex().then((processedPosts) => {
        // Run query first time posts retrieved
        const query = term;
        const processedQuery = spellcheckQueryProcessing(
          query,
          processedPosts.index
        );
        const searchResult = search(processedQuery, processedPosts.index);
        console.log(processedQuery);
        console.log(searchResult);
        State.update({
          searchResult,
          shownSearchResults: searchResult.slice(0, amountOfResultsToShowFirst),
          processedQuery,
          loading: false,
        });
        return processedPosts;
      }),
    "processedPostsCached"
  );
  if (processedPostsCached) {
    // Run query every other time after data retrieved and cached
    const query = term;
    const processedQuery = spellcheckQueryProcessing(
      query,
      processedPostsCached.index
    );
    const searchResult = search(processedQuery, processedPostsCached.index);
    console.log(processedQuery);
    console.log(searchResult);
    State.update({
      searchResult,
      shownSearchResults: searchResult.slice(0, 10),
      processedQuery,
      loading: false,
    });
  }
  const end = new Date().getTime();
  console.log("search time: ", end - start);
};

const updateInput = (term) => {
  Storage.privateSet("term", term);
  State.update({
    term,
    loading: true,
  });
};

const getSearchResultsKeywordsFor = (postId) => {
  const index = getProcessedPostsCached().index;
  return state.processedQuery.filter((queryWord) => {
    return index[queryWord].includes(postId);
  });
};

const showMoreSearchResults = () => {
  const shownSearchResults = state.shownSearchResults || [];
  const newShownSearchResults = state.searchResult.slice(
    0,
    shownSearchResults.length + amountOfResultsToShowFirst
  );
  State.update({ shownSearchResults: newShownSearchResults });
};

return (
  <>
    <div className="d-flex flex-row gap-4">
      <div className="d-flex flex-row position-relative w-25">
        <div className="position-absolute d-flex ps-3 flex-column h-100 justify-center">
          {state.loading ? (
            <span
              className="spinner-grow spinner-grow-sm m-auto"
              role="status"
              aria-hidden="true"
            />
          ) : (
            <i class="bi bi-search m-auto"></i>
          )}
        </div>
        <input
          type="search"
          className="ps-5 form-control border border-0 bg-light"
          value={state.term ?? ""}
          onChange={(e) => updateInput(e.target.value)}
          placeholder={props.placeholder ?? `Search Posts`}
        />
      </div>
      <div class="dropdown">
        <button
          class="btn btn-light dropdown-toggle"
          type="button"
          data-bs-toggle="dropdown"
          aria-expanded="false"
        >
          Sort
        </button>
        <ul class="dropdown-menu px-2 shadow">
          <li>
            <a
              style={{ borderRadius: "5px" }}
              class="dropdown-item link-underline link-underline-opacity-0"
              href={href("Feed")}
            >
              Latest
            </a>
          </li>
          <li>
            <a
              style={{ borderRadius: "5px" }}
              class="dropdown-item link-underline link-underline-opacity-0"
              href={href("Feed", { recency: "hot" })}
            >
              Hottest
            </a>
          </li>
          <li>
            <a
              style={{ borderRadius: "5px" }}
              class="dropdown-item link-underline link-underline-opacity-0"
              href={href("Feed", { recency: "all" })}
            >
              All replies
            </a>
          </li>
        </ul>
      </div>
      <div class="dropdown">
        {widget("components.layout.SearchByAuthor", {
          authorQuery: props.authorQuery,
          onSearchAuthor: props.onSearchAuthor,
        })}
      </div>
      <div>
        {widget("components.layout.SearchByLabel", {
          labelQuery: props.labelQuery,
          onSearchLabel: props.onSearchLabel,
        })}
      </div>
      <div className="d-flex flex-row-reverse flex-grow-1">
        {props.children}
      </div>
    </div>
    {state.processedQuery &&
      state.processedQuery.length > 0 &&
      state.term.toLowerCase().trim() !== state.processedQuery.join(" ") && (
        <div class="mb-2" style={{ "font-family": "monospace" }}>
          Looking for
          <strong>{state.processedQuery.join(" ")}</strong>:
        </div>
      )}
    {state.term && state.term.length > 1 && state.searchResult
      ? widget("components.posts.List", {
          searchResult: {
            postIds: state.searchResult,
            keywords: Object.fromEntries(
              state.searchResult.map((postId) => {
                return [postId, getSearchResultsKeywordsFor(postId)];
              })
            ),
          },
          recency: props.recency,
          label: props.label,
          author: props.author,
        })
      : widget("components.posts.List", {
          recency: props.recency,
          label: props.label,
          author: props.author,
        })}
  </>
);
'''
'''--- townhall-board.pages.Create.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

const parentId = props.parentId ?? null;
const postId = props.postId ?? null;
const mode = props.mode ?? "Create";

const referralLabels = props.referral ? [`referral:${props.referral}`] : [];
const labelStrings = (props.labels ? props.labels.split(",") : []).concat(
  referralLabels
);
const labels = labelStrings.map((s) => {
  return { name: s };
});

initState({
  seekingFunding: false,
  //
  author_id: context.accountId,
  // Should be a list of objects with field "name".
  labels,
  // Should be a list of labels as strings.
  // Both of the label structures should be modified together.
  labelStrings,
  postType: "Idea",
  name: props.name ?? "",
  description: props.description ?? "",
  amount: props.amount ?? "",
  token: props.token ?? "NEAR",
  supervisor: props.supervisor ?? "neardevgov.near",
  githubLink: props.githubLink ?? "",
  warning: "",
});

// This must be outside onClick, because Near.view returns null at first, and when the view call finished, it returns true/false.
// If checking this inside onClick, it will give `null` and we cannot tell the result is true or false.
let grantNotify = Near.view("social.near", "is_write_permission_granted", {
  predecessor_id: nearNFDevsContractAccountId,
  key: context.accountId + "/index/notify",
});
if (grantNotify === null) {
  return;
}

const onSubmit = () => {
  let labels = state.labelStrings;

  let body = {
    name: state.name,
    description: generateDescription(
      state.description,
      state.amount,
      state.token,
      state.supervisor
    ),
  };

  if (state.postType === "Solution") {
    body = {
      ...body,
      post_type: "Submission",
      submission_version: "V1",
    };
  } else {
    // Idea
    body = {
      ...body,
      post_type: "Idea",
      idea_version: "V1",
    };
  }

  if (!context.accountId) return;

  let txn = [];
  if (mode == "Create") {
    txn.push({
      contractName: nearNFDevsContractAccountId,
      methodName: "add_post",
      args: {
        parent_id: parentId,
        labels,
        body: body,
      },
      deposit: Big(10).pow(21).mul(2),
      gas: Big(10).pow(12).mul(100),
    });
  } else if (mode == "Edit") {
    txn.push({
      contractName: nearNFDevsContractAccountId,
      methodName: "edit_post",
      args: {
        id: postId,
        labels,
        body: body,
      },
      deposit: Big(10).pow(21).mul(2),
      gas: Big(10).pow(12).mul(100),
    });
  }
  if (mode == "Create" || mode == "Edit") {
    if (grantNotify === false) {
      txn.unshift({
        contractName: "social.near",
        methodName: "grant_write_permission",
        args: {
          predecessor_id: nearNFDevsContractAccountId,
          keys: [context.accountId + "/index/notify"],
        },
        deposit: Big(10).pow(23),
        gas: Big(10).pow(12).mul(30),
      });
    }
    Near.call(txn);
  }
};

const onIdeaClick = () => {
  State.update({ postType: "Idea", seekingFunding: false });
};

const onSolutionClick = () => {
  State.update({ postType: "Solution" });
};

const normalizeLabel = (label) =>
  label
    .replaceAll(/[- \.]/g, "_")
    .replaceAll(/[^\w]+/g, "")
    .replaceAll(/_+/g, "-")
    .replace(/^-+/, "")
    .replace(/-+$/, "")
    .toLowerCase()
    .trim("-");

const checkLabel = (label) => {
  Near.asyncView(nearNFDevsContractAccountId, "is_allowed_to_use_labels", {
    editor: context.accountId,
    labels: [label],
  }).then((allowed) => {
    if (allowed) {
      State.update({ warning: "" });
    } else {
      State.update({
        warning:
          'The label "' +
          label +
          '" is protected and can only be added by moderators',
      });
      return;
    }
  });
};

const setLabels = (labels) => {
  labels = labels.map((o) => {
    o.name = normalizeLabel(o.name);
    return o;
  });
  if (labels.length < state.labels.length) {
    let oldLabels = new Set(state.labels.map((label) => label.name));
    for (let label of labels) {
      oldLabels.delete(label.name);
    }
    let removed = oldLabels.values().next().value;
    Near.asyncView(
      nearNFDevsContractAccountId,
      "is_allowed_to_use_labels",
      { editor: context.accountId, labels: [removed] }
    ).then((allowed) => {
      if (allowed) {
        let labelStrings = labels.map(({ name }) => name);
        State.update({ labels, labelStrings });
      } else {
        State.update({
          warning:
            'The label "' +
            removed +
            '" is protected and can only be updated by moderators',
        });
        return;
      }
    });
  } else {
    let labelStrings = labels.map((o) => {
      return o.name;
    });
    State.update({ labels, labelStrings });
  }
};
const existingLabelStrings =
  Near.view(nearNFDevsContractAccountId, "get_all_allowed_labels", {
    editor: context.accountId,
  }) ?? [];
const existingLabelSet = new Set(existingLabelStrings);
const existingLabels = existingLabelStrings.map((s) => {
  return { name: s };
});

const labelEditor = (
  <div className="col-lg-12 mb-2">
    <p className="fs-6 fw-bold mb-1">Labels</p>
    <Typeahead
      multiple
      labelKey="name"
      onInputChange={checkLabel}
      onChange={setLabels}
      options={existingLabels}
      placeholder="near.social, widget, NEP, standard, protocol, tool"
      selected={state.labels}
      positionFixed
      allowNew={(results, props) => {
        return (
          !existingLabelSet.has(props.text) &&
          props.selected.filter((selected) => selected.name === props.text)
            .length == 0 &&
          Near.view(
            nearNFDevsContractAccountId,
            "is_allowed_to_use_labels",
            { editor: context.accountId, labels: [props.text] }
          )
        );
      }}
    />
  </div>
);

const nameDiv = (
  <div className="col-lg-6 mb-2">
    <p className="fs-6 fw-bold mb-1">Title</p>
    <input
      type="text"
      value={state.name}
      onChange={(event) => State.update({ name: event.target.value })}
    />
  </div>
);

const descriptionDiv = (
  <div className="col-lg-12 mb-2">
    <p className="fs-6 fw-bold mb-1">Description</p>
    <textarea
      value={state.description}
      type="text"
      rows={6}
      className="form-control"
      onChange={(event) => State.update({ description: event.target.value })}
    />
  </div>
);

const isFundraisingDiv = (
  // This is jank with just btns and not radios. But the radios were glitchy af
  <>
    <div class="mb-2">
      <p class="fs-6 fw-bold mb-1">
        Are you seeking funding for your solution?
        <span class="text-muted fw-normal">(Optional)</span>
      </p>
      <div class="form-check form-check-inline">
        <label class="form-check-label">
          <button
            className="btn btn-light p-0"
            style={{
              backgroundColor: state.seekingFunding ? "#0C7283" : "inherit",
              color: "#f3f3f3",
              border: "solid #D9D9D9",
              borderRadius: "100%",
              height: "20px",
              width: "20px",
            }}
            onClick={() => State.update({ seekingFunding: true })}
          />
          Yes
        </label>
      </div>
      <div class="form-check form-check-inline">
        <label class="form-check-label">
          <button
            className="btn btn-light p-0"
            style={{
              backgroundColor: !state.seekingFunding ? "#0C7283" : "inherit",
              color: "#f3f3f3",
              border: "solid #D9D9D9",
              borderRadius: "100%",
              height: "20px",
              width: "20px",
            }}
            onClick={() => State.update({ seekingFunding: false })}
          />
          No
        </label>
      </div>
    </div>
  </>
);

const fundraisingDiv = (
  <div class="d-flex flex-column mb-2">
    <div className="col-lg-6  mb-2">
      Currency
      <select
        onChange={(event) => State.update({ token: event.target.value })}
        class="form-select"
        aria-label="Default select example"
      >
        <option selected value="NEAR">
          NEAR
        </option>
        <option value="USDC">USDC</option>
        <option value="USD">USD</option>
      </select>
    </div>
    <div className="col-lg-6 mb-2">
      Requested amount <span class="text-muted fw-normal">(Numbers Only)</span>
      <input
        type="number"
        value={parseInt(state.amount) > 0 ? state.amount : ""}
        min={0}
        onChange={(event) =>
          State.update({
            amount: Number(
              event.target.value.toString().replace(/e/g, "")
            ).toString(),
          })
        }
      />
    </div>
    <div className="col-lg-6 mb-2">
      <p class="mb-1">
        Requested sponsor <span class="text-muted fw-normal">(Optional)</span>
      </p>
      <p style={{ fontSize: "13px" }} class="m-0 text-muted fw-light">
        If you are requesting funding from a specific sponsor, please enter
        their username.
      </p>
      <div class="input-group flex-nowrap">
        <span class="input-group-text" id="addon-wrapping">
          @
        </span>
        <input
          type="text"
          class="form-control"
          placeholder="Enter username"
          value={state.supervisor}
          onChange={(event) => State.update({ supervisor: event.target.value })}
        />
      </div>
    </div>
  </div>
);

function generateDescription(text, amount, token, supervisor) {
  const funding = `###### Requested amount: ${amount} ${token}\n###### Requested sponsor: @${supervisor}\n`;
  if (amount > 0 && token && supervisor) return funding + text;
  return text;
}

return (
  <div class="bg-light d-flex flex-column flex-grow-1">
    {widget("components.layout.Banner")}
    <div class="mx-5 mb-5">
      <div aria-label="breadcrumb">
        <ol class="breadcrumb">
          <li class="breadcrumb-item">
            <a
              style={{
                color: "#3252A6",
              }}
              className="fw-bold"
              href={href("Feed")}
            >
              DevHub
            </a>
          </li>
          <li class="breadcrumb-item active" aria-current="page">
            Create new
          </li>
        </ol>
      </div>
      <h4>Create a new post</h4>
      <p>{state.seekingFunding}</p>
      <div class="card border-light">
        <div class="card-body">
          <p class="card-title fw-bold fs-6">What do you want to create?</p>
          <div class="d-flex flex-row gap-2">
            <button
              onClick={onIdeaClick}
              type="button"
              class={`btn btn-outline-secondary`}
              style={
                state.postType === "Idea"
                  ? {
                      backgroundColor: "#0C7283",
                      color: "#f3f3f3",
                    }
                  : {}
              }
            >
              <i class="bi bi-lightbulb"></i>
              Idea
            </button>
            <button
              onClick={onSolutionClick}
              type="button"
              class={`btn btn-outline-secondary`}
              style={
                state.postType !== "Idea"
                  ? {
                      backgroundColor: "#0C7283",
                      color: "#f3f3f3",
                    }
                  : {}
              }
            >
              <i class="bi bi-rocket"></i>
              Solution
            </button>
          </div>
          <p class="text-muted w-75 my-1">
            {state.postType === "Idea"
              ? "Get feedback from the community about a problem, opportunity, or need."
              : "Provide a specific proposal or implementation to an idea, optionally requesting funding. If your solution relates to an existing idea, please reply to the original post with a solution."}
          </p>
          {state.warning && (
            <div
              class="alert alert-warning alert-dismissible fade show"
              role="alert"
            >
              {state.warning}
              <button
                type="button"
                class="btn-close"
                data-bs-dismiss="alert"
                aria-label="Close"
                onClick={() => State.update({ warning: "" })}
              ></button>
            </div>
          )}
          <div className="row">
            {nameDiv}
            {descriptionDiv}
            {labelEditor}
            {state.postType === "Solution" && isFundraisingDiv}
            {state.seekingFunding && fundraisingDiv}
          </div>
          <button
            style={{
              width: "7rem",
              backgroundColor: "#0C7283",
              color: "#f3f3f3",
            }}
            className="btn btn-light mb-2 p-3"
            onClick={onSubmit}
          >
            Submit
          </button>
        </div>
        <div class="bg-light d-flex flex-row p-1 border-bottom"></div>
        <div class="card-body">
          <p class="text-muted m-0">Preview</p>
          <div>
            {widget("components.posts.Post", {
              isPreview: true,
              id: 0, // irrelevant
              post: {
                author_id: state.author_id,
                likes: [],
                snapshot: {
                  editor_id: state.editor_id,
                  labels: state.labelStrings,
                  post_type: state.postType,
                  name: state.name,
                  description: generateDescription(
                    state.description,
                    state.amount,
                    state.token,
                    state.supervisor
                  ),
                  github_link: state.githubLink,
                },
              },
            })}
          </div>
        </div>
      </div>
    </div>
  </div>
);

'''
'''--- townhall-board.pages.Feed.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

State.init({
  propsLabel: props.label,
  label: props.label,
  author: props.author,
});

// When rerendered with different props, State will be preserved, so we need to update the state when we detect that the props have changed.
if (props.label !== state.propsLabel) {
  State.update({
    propsLabel: props.label,
    label: props.label,
  });
}

const onSearchLabel = (label) => {
  State.update({ label });
};

const onSearchAuthor = (author) => {
  State.update({ author });
};

return widget("components.layout.Page", {
  header: widget("components.community.FeedHeader"),
  children: widget("components.posts.Search", {
    children: widget("components.layout.Controls"),
    recency: props.recency,
    label: state.label,
    author: state.author,
    //
    labelQuery: { label: state.label },
    onSearchLabel,
    //
    authorQuery: { author: state.author },
    onSearchAuthor,
  }),
});

'''
'''--- townhall-board.pages.Post.js ---
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

return widget("components.layout.Page", {
  children: widget("components.posts.Post", {
    id: props.id,
  }),
});

'''
'''--- townhall-board.pages.community.Overview.js ---
// townhall-board.pages.community.Overview
/* INCLUDE: "common.jsx" */
const nearNFDevsContractAccountId =
  props.nearNFDevsContractAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

const nearNFDevsWidgetsAccountId =
  props.nearNFDevsWidgetsAccountId ||
  (context.widgetSrc ?? "near-analytics.near").split("/", 1)[0];

function widget(widgetName, widgetProps, key) {
  widgetProps = {
    ...widgetProps,
    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,
    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,
    referral: props.referral,
  };

  return (
    <Widget
      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}
      props={widgetProps}
      key={key}
    />
  );
}

function href(widgetName, linkProps) {
  linkProps = { ...linkProps };

  if (props.nearNFDevsContractAccountId) {
    linkProps.nearNFDevsContractAccountId =
      props.nearNFDevsContractAccountId;
  }

  if (props.nearNFDevsWidgetsAccountId) {
    linkProps.nearNFDevsWidgetsAccountId =
      props.nearNFDevsWidgetsAccountId;
  }

  if (props.referral) {
    linkProps.referral = props.referral;
  }

  const linkPropsQuery = Object.entries(linkProps)
    .filter(([_key, nullable]) => (nullable ?? null) !== null)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${
    linkPropsQuery ? "?" : ""
  }${linkPropsQuery}`;
}
/* END_INCLUDE: "common.jsx" */

/* INCLUDE: "shared/mocks" */
const communities = {
  "zero-knowledge": {
    overviewId: 397,
    eventsId: 401,

    icon: "https://ipfs.near.social/ipfs/bafkreiajwq6ep3n7veddozji2djv5vviyisabhycbweslvpwhsoyuzcwi4",

    cover:
      "https://ipfs.near.social/ipfs/bafkreihgxg5kwts2juldaeasveyuddkm6tcabmrat2aaq5u6uyljtyt7lu",

    title: "Zero Knowledge",
    desc: "Building a zero knowledge ecosystem on NEAR.",
    telegram: "NearZeroKnowledge",
  },

  protocol: {
    overviewId: 412,
    eventsId: 413,

    icon: "https://ipfs.near.social/ipfs/bafkreidpitdafcnhkp4uyomacypdgqvxr35jtfnbxa5s6crby7qjk2nv5a",

    cover:
      "https://ipfs.near.social/ipfs/bafkreicg4svzfz5nvllomsahndgm7u62za4sib4mmbygxzhpcl4htqwr4a",

    title: "Protocol",
    desc: "Supporting the ongoing innovation of the NEAR Protocol.",

    integrations: {
      github: {
        boards: {
          "18855b9c9f2-216091d-6484800b-42593f54-6102b48a": {
            id: "18855b9c9f2-216091d-6484800b-42593f54-6102b48a",

            columns: {
              "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630": {
                id: "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630",

                description:
                  "NEPs that need a moderator review or author revision.",

                labelSearchTerms: ["WG-protocol", "S-draft"],
                title: "üìÑ Draft",
              },

              "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9": {
                description:
                  "NEPS that need a review by Subject Matter Experts.",

                labelSearchTerms: ["WG-protocol", "S-review"],
                title: "üëÄ Review",
                id: "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9",
              },

              "18877dd71e5-47d177b8-5505178-640a5937--17968e87": {
                description:
                  "NEPS in the final review stage that need the work group voting indications.",

                labelSearchTerms: ["WG-protocol", "S-voting"],
                title: "‚úî Voting",
                id: "18877dd71e5-47d177b8-5505178-640a5937--17968e87",
              },

              "18877e14753--5b0ca250-1edea464-523fd579--5ebde527": {
                description:
                  "NEPS that were reviewed and approved by a work group.",

                labelSearchTerms: ["WG-protocol", "S-approved"],
                title: "‚úÖ Approved NEPs",
                id: "18877e14753--5b0ca250-1edea464-523fd579--5ebde527",
              },

              "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81": {
                description:
                  "NEPS that were reviewed and approved by a work group or NEP moderators.",

                labelSearchTerms: ["WG-protocol", "A-NEP-GrammarFix"],
                title: "üîß Approved Fixes",
                id: "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81",
              },

              "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be": {
                description:
                  "NEPs that were retracted by the author or had no activity for over two months.",

                labelSearchTerms: ["WG-protocol", "S-retracted"],
                title: "‚ùå RETRACTED",
                id: "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be",
              },
            },

            dataTypesIncluded: { Issue: false, PullRequest: true },
            description: "Latest NEAR Enhancement Proposals by status",
            repoURL: "https://github.com/near/NEPs",
            ticketState: "all",
            title: "NEAR Protocol NEPs",
          },
        },
      },
    },

    telegram: "NEAR_Protocol_Community_Group",
  },

  tooling: {
    overviewId: 416,
    eventsId: 417,

    icon: "https://ipfs.near.social/ipfs/bafkreie2eaj5czmpfe6pe53kojzcspgozebdsonffwvbxtpuipnwahybvi",

    cover:
      "https://ipfs.near.social/ipfs/bafkreiehzr7z2fhoqqmkt3z667wubccbch6sqtsnvd6msodyzpnf72cszy",

    title: "Tooling",
    desc: "Supporting the ongoing innovation of tooling.",

    integrations: {
      github: {
        boards: {
          "18855b9c9f2-216091d-6484800b-42593f54-6102b48a": {
            id: "18855b9c9f2-216091d-6484800b-42593f54-6102b48a",

            columns: {
              "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630": {
                id: "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630",

                description:
                  "NEPs that need a moderator review or author revision.",

                labelSearchTerms: ["WG-tools", "S-draft"],
                title: "üìÑ Draft",
              },

              "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9": {
                description:
                  "NEPS that need a review by Subject Matter Experts.",

                labelSearchTerms: ["WG-tools", "S-review"],
                title: "üëÄ Review",
                id: "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9",
              },

              "18877dd71e5-47d177b8-5505178-640a5937--17968e87": {
                description:
                  "NEPS in the final review stage that need the work group voting indications.",

                labelSearchTerms: ["WG-tools", "S-voting"],
                title: "‚úî Voting",
                id: "18877dd71e5-47d177b8-5505178-640a5937--17968e87",
              },

              "18877e14753--5b0ca250-1edea464-523fd579--5ebde527": {
                description:
                  "NEPS that were reviewed and approved by a work group.",

                labelSearchTerms: ["WG-tools", "S-approved"],
                title: "‚úÖ Approved NEPs",
                id: "18877e14753--5b0ca250-1edea464-523fd579--5ebde527",
              },

              "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81": {
                description:
                  "NEPS that were reviewed and approved by a work group or NEP moderators.",

                labelSearchTerms: ["WG-tools", "A-NEP-GrammarFix"],
                title: "üîß Approved Fixes",
                id: "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81",
              },

              "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be": {
                description:
                  "NEPs that were retracted by the author or had no activity for over two months.",

                labelSearchTerms: ["WG-tools", "S-retracted"],
                title: "‚ùå RETRACTED",
                id: "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be",
              },
            },

            dataTypesIncluded: { Issue: false, PullRequest: true },
            description: "Latest NEAR Enhancement Proposals by status",
            repoURL: "https://github.com/near/NEPs",
            ticketState: "all",
            title: "NEAR Tooling NEPs",
          },
        },
      },
    },

    telegram: "NEAR_Tools_Community_Group",
  },

  "contract-standards": {
    overviewId: 414,
    eventsId: 415,

    icon: "https://ipfs.near.social/ipfs/bafkreiepgdnu7soc6xgbyd4adicbf3eyxiiwqawn6tguaix6aklfpir634",

    cover:
      "https://ipfs.near.social/ipfs/bafkreiaowjqxds24fwcliyriintjd4ucciprii2rdxjmxgi7f5dmzuscey",

    title: "Contract Standards",
    desc: "Coordinating the contribution to the NEAR dapp standards.",

    integrations: {
      github: {
        boards: {
          "18855b9c9f2-216091d-6484800b-42593f54-6102b48a": {
            id: "18855b9c9f2-216091d-6484800b-42593f54-6102b48a",

            columns: {
              "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630": {
                id: "18855f4a93e-76a9b704-14c3ebdb-1e6c0f05-22653630",

                description:
                  "NEPs that need a moderator review or author revision.",

                labelSearchTerms: ["WG-contract-standards", "S-draft"],
                title: "üìÑ Draft",
              },

              "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9": {
                description:
                  "NEPS that need a review by Subject Matter Experts.",

                labelSearchTerms: ["WG-contract-standards", "S-review"],
                title: "üëÄ Review",
                id: "18877dc932c-c309c28--4b95e909--220e9bbb--51ff54c9",
              },

              "18877dd71e5-47d177b8-5505178-640a5937--17968e87": {
                description:
                  "NEPS in the final review stage that need the work group voting indications.",

                labelSearchTerms: ["WG-contract-standards", "S-voting"],
                title: "‚úî Voting",
                id: "18877dd71e5-47d177b8-5505178-640a5937--17968e87",
              },

              "18877e14753--5b0ca250-1edea464-523fd579--5ebde527": {
                description:
                  "NEPS that were reviewed and approved by a work group.",

                labelSearchTerms: ["WG-contract-standards", "S-approved"],
                title: "‚úÖ Approved NEPs",
                id: "18877e14753--5b0ca250-1edea464-523fd579--5ebde527",
              },

              "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81": {
                description:
                  "NEPS that were reviewed and approved by a work group or NEP moderators.",

                labelSearchTerms: ["WG-contract-standards", "A-NEP-GrammarFix"],
                title: "üîß Approved Fixes",
                id: "18877e2f94c-4cc0ff57--1fb016c6--39ce0459-23922e81",
              },

              "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be": {
                description:
                  "NEPs that were retracted by the author or had no activity for over two months.",

                labelSearchTerms: ["WG-contract-standards", "S-retracted"],
                title: "‚ùå RETRACTED",
                id: "18877e40c46--76d23f4d-578f24a8--2cfcd190--74aa77be",
              },
            },

            dataTypesIncluded: { Issue: false, PullRequest: true },
            description: "Latest NEAR Enhancement Proposals by status",
            repoURL: "https://github.com/near/NEPs",
            ticketState: "all",
            title: "NEAR Contract Standards NEPs",
          },
        },
      },
    },

    telegram: "nearnft",
  },
};
/* END_INCLUDE: "shared/mocks" */

if (!props.label) {
  return (
    <div class="alert alert-danger" role="alert">
      Error: label is required
    </div>
  );
}

const community = communities[props.label];

const overviewPost = Near.view(nearNFDevsContractAccountId, "get_post", {
  post_id: community.overviewId,
});
if (!overviewPost) {
  return <div>Loading ...</div>;
}

const onMention = (accountId) => (
  <span key={accountId} className="d-inline-flex" style={{ fontWeight: 500 }}>
    <Widget
      src="neardevgov.near/widget/ProfileLine"
      props={{
        accountId: accountId.toLowerCase(),
        hideAccountId: true,
        tooltip: true,
      }}
    />
  </span>
);

const Overview = (
  <div>
    <Markdown
      class="card-text"
      text={overviewPost.snapshot.description}
      onMention={onMention}
    ></Markdown>
  </div>
);

return widget("components.community.Layout", {
  label: props.label,
  tab: "Overview",
  children: Overview,
});

'''