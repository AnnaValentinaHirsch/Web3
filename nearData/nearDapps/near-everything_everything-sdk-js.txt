*GitHub Repository "near-everything/everything-sdk-js"*

'''--- .eslintrc.js ---
module.exports = {
    "env": {
        "browser": true,
        "es2021": true
    },
    "extends": "eslint:recommended",
    "overrides": [
    ],
    "parserOptions": {
        "ecmaVersion": "latest",
        "sourceType": "module"
    },
    "rules": {
    }
}

'''
'''--- README.md ---
<div id="top"></div>

<!-- PROJECT SHIELDS -->

[![MIT License][license-shield]][license-url]

<!-- PROJECT LOGO -->
<br />
<div align="center">
  <a href="https://github.com/near-everything/everything-sdk-js">
    <img src="./everything.png" alt="Logo" width="80" height="80">
  </a>

<h2 align="center"><strong>everything</strong> sdk js</h3>

  <p align="center">
    a javascript sdk for connecting applications, marketplaces, and services to the inventory of <strong>everything</strong> and its ecosystem.
    <br />
    <!-- <a href="https://documentation.everything.dev"><strong>Explore the docs »</strong></a> -->
    <!-- <br /> -->
    <br />
    <a href="https://everything.dev">learn more</a>
    ·
    <a href="https://github.com/near-everything/everything-sdk-js/issues">report bug</a>
    ·
    <a href="https://github.com/near-everything/everything-sdk-js/issues">request feature</a>
  </p>
</div>

<!-- ABOUT THE PROJECT -->

## about

**everything** is a framework for putting it all together; it provides methods for creating and querying data in both Web2 and Web3 in order to foster opinionated development of real world applications, marketplaces, and services for the interconnected economy of tomorrow.

SDK development funded by [Mintbase Grant Program](https://github.com/near-everything/mintbase-grants-program)

<p align="right">(<a href="#top">back to top</a>)</p>

<!-- USAGE -->

## usage

The methods provided in this SDK require Auth0 integration for connecting to **everything** and Mintbase integration for connected to [NEAR Protocol](https://near.org).

### Setting up Auth0

Follow the steps in [Auth0 Documentation](https://auth0.com/docs/get-started) for your specific application.

_IN PROGRESS_: We are working to create a custom SSO login that can be available in development of your own apps to generate your own AUTH0_CLIENT_SECRET. Unfortunately, until then, the same AUTH0_CLIENT_SECRET must be shared across all participating applications. If you want to develop a participating application, please reach out to elliot@everything.dev.

</br>

### Setting up Mintbase

Follow the steps in [Mintbase Documentation](https://docs.mintbase.io/dev/getting-started) for your specific application.

</br>

### Using the SDK

With Auth0 and Mintbase configured and integrated, you can now use the available SDK methods.

Visit the corresponding documentation:

[Creating Things and Minting References](./packages/sdk/src/thing/)

[Creating Media and Associating Tagss](./packages/sdk/src/media/)

[Reading Data](./packages/data/src)

</br>
<!-- TESTING -->

## testing

### Unit tests

1. Clone the repo
2. Install packages

``` bash
npm install
```

3. Run tests (this will run tests from all packages)

``` bash
npm test
```

### Interactive testing (playground)

1. Run the Dockerfile

``` bash
docker-compose up
```

This will automatically set up the environment, start any necessary mock services, and run the tests. View the terminal to see test results.

2. Open the [playground](http://localhost:8000) in browser to interact with the SDK methods or query data

_IN PROGRESS_: Local is currently not connecting to the everything api because I don't want to move it to the mono repo...
A live version of the app can be used [here](https://playground.everything.dev) which is connected to test environemnt.

</br>

<!-- CONTRIBUTING -->

## contributing

To run the project in development:

1. Clone the repository
2. Start the development playground and enable change watching and hot-reload.

``` bash
npm run dev
```

3. Make changes, write tests, and then open a pull request for review.

Thanks for contributing!

</br>

<!-- LICENSE -->

## license

distributed under the MIT License. see `LICENSE` for more information.

<p align="right">(<a href="#top">back to top</a>)</p>

<!-- MARKDOWN LINKS & IMAGES -->
<!-- https://www.markdownguide.org/basic-syntax/#reference-style-links -->

[license-shield]: https://img.shields.io/github/license/near-everything/everything-sdk-js.svg?style=for-the-badge
[license-url]: https://github.com/near-everything/everything-sdk-js/blob/main/LICENSE
'''
'''--- docker-compose.yml ---
version: "3.9"
services:
  everything-sdk:
    build: .
    ports:
      - "8000:3000"
'''
'''--- lerna.json ---
{
  "$schema": "node_modules/lerna/schemas/lerna-schema.json",
  "useWorkspaces": true,
  "version": "0.0.0"
}

'''
'''--- package.json ---
{
  "name": "everything-sdk-js",
  "version": "0.0.1",
  "description": "javascript sdk for interacting with everything",
  "scripts": {
    "dev": "lerna run watch --stream & cd playgrounds/react && npm run dev",
    "build": "lerna run build --sort",
    "test": "lerna run test --stream",
    "mock:api": "PORT=4050 graphql-faker ./mock/faker-schema.graphql",
    "start": "cd playgrounds/react && npm run start"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/near-everything/everything-sdk-js.git"
  },
  "author": "@elliotBraem",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/near-everything/everything-sdk-js/issues"
  },
  "homepage": "https://github.com/near-everything/everything-sdk-js#readme",
  "devDependencies": {
    "eslint": "^8.28.0",
    "graphql-faker": "^2.0.0-rc.25",
    "lerna": "^6.1.0",
    "prettier": "2.8.0"
  },
  "resolutions": {
    "react": "^17.0.1",
    "react-dom": "^17.0.1"
  },
  "workspaces": [
    "packages/*",
    "playgrounds/*"
  ]
}

'''
'''--- packages/data/.eslintrc.js ---
const path = require('path');
module.exports = {
  "extends": "../../.eslintrc.json",
}
'''
'''--- packages/data/README.md ---
# @everything-sdk-js/data

Provides methods for reading data from the [everything mesh]().

_IN PROGRESS_: currently reading data directly from everything api or mintbase indexer, mesh in development

</br>
</br>

## available methods

### getThings

``` js
  const { data, error} = await getThings();
```

Fetches all available thing data from the mesh. This includes all public blockchain data from the [Mintbase Indexer](https://docs.mintbase.io/dev/read-data/mintbase-graph), all public data from everything cloud storage, and any available data from access token (if provided).

</br>

---

### getThingById

``` js
  const { data, error} = await getThingById(thingId);
```

Fetches all available data for provided thing Id from the mesh. This includes any public blockchain data from the [Mintbase Indexer](https://docs.mintbase.io/dev/read-data/mintbase-graph), any public data from everything cloud storage, and any available data from access token (if provided).

</br>

---

### getThingsByOwner

``` js
  const { data, error} = await getThingsByOwner(ownerId);
```

Fetches all available thing data for provided owner Id from the mesh. This includes any public blockchain data from the [Mintbase Indexer](https://docs.mintbase.io/dev/read-data/mintbase-graph), any public data from everything cloud storage, and any available data from access token (if provided).

</br>

---

### getAttributes

``` js
  const { data, error} = await getAttributes();
```

Fetches all available attributes for describing things from the mesh.

</br>

---

### getAttributeById

``` js
  const { data, error} = await getAttributeById(attributeId);
```

Fetches all data from the mesh associated with provided attributeId.

</br>
'''
'''--- packages/data/jest.config.ts ---
/*
 * For a detailed explanation regarding each configuration property and type check, visit:
 * https://jestjs.io/docs/configuration
 */

export default {
  // All imported modules in your tests should be mocked automatically
  // automock: false,

  // Stop running tests after `n` failures
  // bail: 0,

  // The directory where Jest should store its cached dependency information
  // cacheDirectory: "/private/var/folders/hl/1w1xt9zs65j76fb84dj7_kq40000gn/T/jest_dx",

  // Automatically clear mock calls, instances, contexts and results before every test
  clearMocks: true,

  // Indicates whether the coverage information should be collected while executing the test
  collectCoverage: true,

  // An array of glob patterns indicating a set of files for which coverage information should be collected
  // collectCoverageFrom: undefined,

  // The directory where Jest should output its coverage files
  coverageDirectory: "coverage",

  // An array of regexp pattern strings used to skip coverage collection
  coveragePathIgnorePatterns: [
    "/node_modules/",
    "/dist/"
  ],

  // Indicates which provider should be used to instrument code for coverage
  coverageProvider: "v8",

  // A list of reporter names that Jest uses when writing coverage reports
  // coverageReporters: [
  //   "json",
  //   "text",
  //   "lcov",
  //   "clover"
  // ],

  // An object that configures minimum threshold enforcement for coverage results
  // coverageThreshold: undefined,

  // A path to a custom dependency extractor
  // dependencyExtractor: undefined,

  // Make calling deprecated APIs throw helpful error messages
  // errorOnDeprecated: false,

  // The default configuration for fake timers
  // fakeTimers: {
  //   "enableGlobally": false
  // },

  // Force coverage collection from ignored files using an array of glob patterns
  // forceCoverageMatch: [],

  // A path to a module which exports an async function that is triggered once before all test suites
  // globalSetup: undefined,

  // A path to a module which exports an async function that is triggered once after all test suites
  // globalTeardown: undefined,

  // A set of global variables that need to be available in all test environments
  // globals: {},

  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.
  // maxWorkers: "50%",

  // An array of directory names to be searched recursively up from the requiring module's location
  // moduleDirectories: [
  //   "node_modules"
  // ],

  // An array of file extensions your modules use
  // moduleFileExtensions: [
  //   "js",
  //   "mjs",
  //   "cjs",
  //   "jsx",
  //   "ts",
  //   "tsx",
  //   "json",
  //   "node"
  // ],

  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
  // moduleNameMapper: {},

  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
  modulePathIgnorePatterns: ['/dist/'],

  // Activates notifications for test results
  // notify: false,

  // An enum that specifies notification mode. Requires { notify: true }
  // notifyMode: "failure-change",

  // A preset that is used as a base for Jest's configuration
  preset: 'ts-jest',

  // Run tests from one or more projects
  // projects: undefined,

  // Use this configuration option to add custom reporters to Jest
  // reporters: undefined,

  // Automatically reset mock state before every test
  // resetMocks: false,

  // Reset the module registry before running each individual test
  // resetModules: false,

  // A path to a custom resolver
  // resolver: undefined,

  // Automatically restore mock state and implementation before every test
  // restoreMocks: false,

  // The root directory that Jest should scan for tests and modules within
  // rootDir: undefined,

  // A list of paths to directories that Jest should use to search for files in
  // roots: [
  //   "<rootDir>"
  // ],

  // Allows you to use a custom runner instead of Jest's default test runner
  // runner: "jest-runner",

  // The paths to modules that run some code to configure or set up the testing environment before each test
  // setupFiles: [],

  // A list of paths to modules that run some code to configure or set up the testing framework before each test
  // setupFilesAfterEnv: [],

  // The number of seconds after which a test is considered as slow and reported as such in the results.
  // slowTestThreshold: 5,

  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
  // snapshotSerializers: [],

  // The test environment that will be used for testing
  testEnvironment: 'node',

  // Options that will be passed to the testEnvironment
  // testEnvironmentOptions: {},

  // Adds a location field to test results
  // testLocationInResults: false,

  // The glob patterns Jest uses to detect test files
  // testMatch: [
  //   "**/__tests__/**/*.[jt]s?(x)",
  //   "**/?(*.)+(spec|test).[tj]s?(x)"
  // ],

  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
  // testPathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // The regexp pattern or array of patterns that Jest uses to detect test files
  // testRegex: [],

  // This option allows the use of a custom results processor
  // testResultsProcessor: undefined,

  // This option allows use of a custom test runner
  // testRunner: "jest-circus/runner",

  // A map from regular expressions to paths to transformers
  // transform: undefined,

  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
  // transformIgnorePatterns: [
  //   "/node_modules/",
  //   "\\.pnp\\.[^\\/]+$"
  // ],

  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
  // unmockedModulePathPatterns: undefined,

  // Indicates whether each individual test should be reported during the run
  // verbose: undefined,

  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
  // watchPathIgnorePatterns: [],

  // Whether to use watchman for file crawling
  // watchman: true,
};

'''
'''--- packages/data/package.json ---
{
  "name": "@everything-sdk-js/data",
  "version": "0.0.1",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "watch": "tsc && tsc --watch"
  },
  "author": "@near-everything",
  "license": "MIT",
  "type": "module",
  "devDependencies": {
    "@babel/preset-env": "^7.20.2",
    "@types/jest": "^29.2.3",
    "babel-jest": "^29.3.1",
    "graphql": "^16.6.0",
    "graphql-request": "^5.0.0",
    "jest": "^29.3.1",
    "ts-jest": "^29.0.3",
    "ts-node": "^10.9.1",
    "typescript": "^4.9.3"
  }
}

'''
'''--- packages/data/src/api/getAttributeById/getAttributeById.mock.ts ---
export const attributeByIdMock = {
  'attribute': {
    'id': 1,
    'name': 'Brand'
  }
};
'''
'''--- packages/data/src/api/getAttributeById/getAttributeById.query.ts ---
import { gql } from 'graphql-request';

export const attributeByIdQuery = gql`
  query attributeById($attributeId: Int!) {
    attribute(id: $attributeId) {
      name
      relationships {
        edges {
          node {
            option {
              id
              value
            }
          }
        }
      }
    }
  }
`
'''
'''--- packages/data/src/api/getAttributeById/getAttributeById.test.ts ---
import { getAttributeById } from './getAttributeById';
import { AttributeByIdResults } from './getAttributeById.types';

import { attributeByIdMock } from './getAttributeById.mock';
import { GraphQLClient } from 'graphql-request';
import { GraphqlFetchingError } from '../../graphql/fetch';

jest.mock('graphql-request');

describe('getAttributeById', () => {
  afterAll(() => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return attribute by id data', async () => {
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<AttributeByIdResults> => Promise.resolve(attributeByIdMock),
    }));

    const result = await getAttributeById(1);

    expect(result?.data?.attribute.id).toBe(
      1
    );
  });

  it('should handle errors', async () => {
    jest.spyOn(console, 'error').mockImplementation(() => {
      // console.log('Suppressed console error.');
    });

    const errMessage = 'exploded';
    const exploded = new GraphqlFetchingError(errMessage);
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<AttributeByIdResults> => Promise.reject(exploded),
    }));
    const result = await getAttributeById(123);
    expect(result?.error).toEqual(exploded);
  });
});
'''
'''--- packages/data/src/api/getAttributeById/getAttributeById.ts ---
import { fetchEverything, GraphqlFetchingError } from '../../graphql/fetch';
import { attributeByIdQuery } from './getAttributeById.query';
import { AttributeByIdResults } from './getAttributeById.types';

interface AttributeByIdData {
  data?: AttributeByIdResults | null;
  error: undefined | GraphqlFetchingError;
}

/**
 * Makes a request to mesh api for attribute by id data
 * @returns data available from provided attribute id  {@link AttributeByIdData}
 */
export const getAttributeById = async (
  attributeId: number
): Promise<AttributeByIdData> => {
  const fetchData = async (): Promise<AttributeByIdData> => {
    const { data, error } = await fetchEverything<AttributeByIdResults>({
      query: attributeByIdQuery,
      variables: {
        attributeId
      },
    });

    if (error) {
      console.error('Error fetching attribute', error.message);
    }

    return { data, error };
  };

  return fetchData();
};
'''
'''--- packages/data/src/api/getAttributeById/getAttributeById.types.ts ---
export interface Attribute {
  id: number;
  name: string;
}

export interface AttributeByIdResults {
  attribute: Attribute;
}
'''
'''--- packages/data/src/api/getAttributes/getAttributes.mock.ts ---
export const attributesMock = {
  'attributes': {
    'edges': [
      {
        'node': {
          'id': 1
        }
      }
    ]
  }
};
'''
'''--- packages/data/src/api/getAttributes/getAttributes.query.ts ---
import { gql } from 'graphql-request';

export const attributesQuery = gql`
  query getAttributes {
    attributes {
      edges {
        node {
          id
          name
        }
      }
    }
  }
`
'''
'''--- packages/data/src/api/getAttributes/getAttributes.test.ts ---
import { getAttributes } from './getAttributes';
import { AttributesResults } from './getAttributes.types';

import { GraphQLClient } from 'graphql-request';
import { GraphqlFetchingError } from '../../graphql/fetch';
import { attributesMock } from './getAttributes.mock';

jest.mock('graphql-request');

describe('getAttributes', () => {
  afterAll(() => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return attributes data', async () => {
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<AttributesResults> => Promise.resolve(attributesMock),
    }));

    const result = await getAttributes();

    expect(result?.data?.attributes.edges[0].node.id).toBe(
      1
    );
  });

  it('should handle errors', async () => {
    jest.spyOn(console, 'error').mockImplementation(() => {
      console.log('Suppressed console error.');
    });

    const errMessage = 'exploded';
    const exploded = new GraphqlFetchingError(errMessage);
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<AttributesResults> => Promise.reject(exploded),
    }));
    const result = await getAttributes();
    expect(result?.error).toEqual(exploded);
  });
});
'''
'''--- packages/data/src/api/getAttributes/getAttributes.ts ---
import { fetchEverything, GraphqlFetchingError } from '../../graphql/fetch';
import { attributesQuery } from './getAttributes.query';
import { AttributesResults } from './getAttributes.types';

interface AttributesData {
  data?: AttributesResults | null;
  error: undefined | GraphqlFetchingError;
}

/**
 * Makes a request to mesh api for all attribute data
 * @returns available attributes for describing things  {@link AttributesData}
 */
export const getAttributes = async (): Promise<AttributesData> => {
  const fetchData = async (): Promise<AttributesData> => {
    const { data, error } = await fetchEverything<AttributesResults>({
      query: attributesQuery
    });

    if (error) {
      console.error('Error fetching attributes', error.message);
    }

    return { data, error };
  };

  const res = await fetchData();

  return { data: res.data, error: res.error };
};
'''
'''--- packages/data/src/api/getAttributes/getAttributes.types.ts ---
export interface Attributes {
  edges: Edges[];
}

export interface Edges {
  node: Node;
}

export interface Node {
  id: number;
}

export interface AttributesResults {
  attributes: Attributes;
}
'''
'''--- packages/data/src/api/getListings/getListings.query.ts ---
import { gql } from 'graphql-request';

export const listingsQuery = gql`
  query listings {
    listings {
      price
      metadata_id
      nft_contract_id
      token_id
      listed_by
      thing {
        id
        tags {
          media {
            mediaUrl
          }
        }
        characteristics {
          nodes {
            attribute {
              name
            }
            option {
              value
            }
          }
        }
      }
    }
  }
`
'''
'''--- packages/data/src/api/getListings/getListingsByLister.query.ts ---
import { gql } from 'graphql-request';

export const listingsByListerQuery = gql`
  query activeListingsByLister($listerId: String!) {
    activeListingsByLister(listerId: $listerId) {
      price
      metadata_id
      nft_contract_id
      token_id
      thing {
        id
        tags {
          media {
            mediaUrl
          }
        }
      }
    }
  }
`
'''
'''--- packages/data/src/api/getListings/minter.query.ts ---
import { gql } from 'graphql-request';

export const minterQuery = gql`
  query minter($minterId: String!) {
    minter(minterId: $minterId) {
      minter_id
  }
}
`
'''
'''--- packages/data/src/api/getThingById/getThingById.mock.ts ---
export const thingByIdMock = {
  'things': {
    'edges': [
      {
        'node': {
          'id': 1
        }
      }
    ]
  }
};
'''
'''--- packages/data/src/api/getThingById/getThingById.query.ts ---
import { gql } from 'graphql-request';

export const thingByIdQuery = gql`
  query thingById($thingId: String!) {
    thing(id: $thingId) {
      id
      characteristics {
        attributeId
        optionId
      }
      nft {
        nft_contract_id
        token_id
        listings {
          price
        }
      }
      tags {
        media {
          mediaUrl
        }
      }
    }
  }
`
'''
'''--- packages/data/src/api/getThingById/getThingById.test.ts ---
import { getThingById } from './getThingById';
import { ThingByIdResults } from './getThingById.types';

import { thingByIdMock } from './getThingById.mock';
import { GraphQLClient } from 'graphql-request';
import { GraphqlFetchingError } from '../../graphql/fetch';

jest.mock('graphql-request');

describe('getThingById', () => {
  afterAll(() => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return thing by id data', async () => {
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<ThingByIdResults> => Promise.resolve(thingByIdMock),
    }));

    const result = await getThingById('1');

    expect(result?.data?.things.edges[0].node.id).toBe(
      1
    );
  });

  it('should handle errors', async () => {
    jest.spyOn(console, 'error').mockImplementation(() => {
      // console.log('Suppressed console error.');
    });

    const errMessage = 'exploded';
    const exploded = new GraphqlFetchingError(errMessage);
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<ThingByIdResults> => Promise.reject(exploded),
    }));
    const result = await getThingById('123')
    expect(result?.error).toEqual(exploded);
  });
});
'''
'''--- packages/data/src/api/getThingById/getThingById.ts ---
import { fetchEverything, GraphqlFetchingError } from '../../graphql/fetch';
import { thingByIdQuery } from './getThingById.query';
import { ThingByIdResults } from './getThingById.types';

interface ThingByIdData {
  data?: ThingByIdResults | null;
  error: undefined | GraphqlFetchingError;
}

/**
 * Makes a request to mesh api for thing by id
 * @returns data available from provided thing id {@link ThingByIdData}
 */
export const getThingById = async (
  thingId: string | number
): Promise<ThingByIdData> => {
  const fetchData = async (): Promise<ThingByIdData> => {
    const { data, error } = await fetchEverything<ThingByIdResults>({
      query: thingByIdQuery,
      variables: {
        thingId
      },
    });

    if (error) {
      console.error('Error fetching thing', error.message);
    }

    return { data, error };
  };

  return fetchData();
};
'''
'''--- packages/data/src/api/getThingById/getThingById.types.ts ---
export interface Things {
  edges: Edges[];
}

export interface Edges {
  node: Node;
}

export interface Node {
  id: number;
}

export interface ThingByIdResults {
  things: Things;
}
'''
'''--- packages/data/src/api/getThings/getThings.mock.ts ---
export const thingsMock = {
  'things': {
    'edges': [
      {
        'node': {
          'id': 1
        }
      }
    ]
  }
};
'''
'''--- packages/data/src/api/getThings/getThings.query.ts ---
import { gql } from 'graphql-request';

export const thingsQuery = gql`
  query things {
    things {
      id
      characteristics {
        nodes {
          attributeId
          optionId
        }
      }
      nft {
        nft_contract_id
        token_id
        listings {
          price
        }
      }
      tags {
        media {
          mediaUrl
        }
      }
    }
  }
`
'''
'''--- packages/data/src/api/getThings/getThings.test.ts ---
import { getThings } from './getThings';
import { ThingsResults } from './getThings.types';

import { GraphQLClient } from 'graphql-request';
import { GraphqlFetchingError } from '../../graphql/fetch';
import { thingsMock } from './getThings.mock';

jest.mock('graphql-request');

describe('getThings', () => {
  afterAll(() => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return all things', async () => {
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<ThingsResults> => Promise.resolve(thingsMock),
    }));

    const result = await getThings();

    expect(result?.data?.things.edges[0].node.id).toBe(
      1
    );
  });

  it('should handle errors', async () => {
    jest.spyOn(console, 'error').mockImplementation(() => {
      // console.log('Suppressed console error.');
    });

    const errMessage = 'exploded';
    const exploded = new GraphqlFetchingError(errMessage);
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<ThingsResults> => Promise.reject(exploded),
    }));
    const result = await getThings();
    expect(result?.error).toEqual(exploded);
  });
});
'''
'''--- packages/data/src/api/getThings/getThings.ts ---
import { fetchEverything, GraphqlFetchingError } from '../../graphql/fetch';
import { thingsQuery } from './getThings.query';
import { ThingsResults } from './getThings.types';

interface ThingsData {
  data?: ThingsResults | null;
  error: undefined | GraphqlFetchingError;
}

/**
 * Makes a request to mesh api for all thing data
 * @returns tokens publically available on blockchain and any data exposed to user {@link ThingsData}
 */
export const getThings = async (): Promise<ThingsData> => {
  const fetchData = async (): Promise<ThingsData> => {
    const { data, error } = await fetchEverything<ThingsResults>({
      query: thingsQuery
    });

    if (error) {
      console.error('Error fetching things', error.message);
    }

    return { data, error };
  };

  return fetchData();
};
'''
'''--- packages/data/src/api/getThings/getThings.types.ts ---
export interface Things {
  edges: Edges[];
}

export interface Edges {
  node: Node;
}

export interface Node {
  id: number;
}

export interface ThingsResults {
  things: Things;
}
'''
'''--- packages/data/src/api/getThingsByOwner/getThingsByOwner.mock.ts ---
export const thingsByOwnerMock = {
  'things': {
    'edges': [
      {
        'node': {
          'id': 1
        }
      }
    ]
  }
};
'''
'''--- packages/data/src/api/getThingsByOwner/getThingsByOwner.query.ts ---
import { gql } from 'graphql-request';

export const thingsByOwnerQuery = gql`
  query thingsByOwner($ownerId: String!) {
    things(condition: { ownerId: $ownerId }) {
      id
      characteristics {
        edges {
          node {
            attributeId
            optionId
          }
        }
      }
      nft {
        nft_contract_id
        token_id
        listings {
          price
          unlisted_at
        }
      }
      tags {
        media {
          mediaUrl
        }
      }
    }
  }
`
'''
'''--- packages/data/src/api/getThingsByOwner/getThingsByOwner.test.ts ---
import { getThingsByOwner } from './getThingsByOwner';
import { ThingsByOwnerResults } from './getThingsByOwner.types';

import { thingsByOwnerMock } from './getThingsByOwner.mock';
import { GraphQLClient } from 'graphql-request';
import { GraphqlFetchingError } from '../../graphql/fetch';

jest.mock('graphql-request');

describe('getThingsByOwner', () => {
  afterAll(() => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return things by owner data', async () => {
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<ThingsByOwnerResults> => Promise.resolve(thingsByOwnerMock),
    }));

    const result = await getThingsByOwner('1');

    expect(result?.data?.things.edges[0].node.id).toBe(
      1
    );
  });

  it('should handle errors', async () => {
    jest.spyOn(console, 'error').mockImplementation(() => {
      // console.log('Suppressed console error.');
    });

    const errMessage = 'exploded';
    const exploded = new GraphqlFetchingError(errMessage);
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<ThingsByOwnerResults> => Promise.reject(exploded),
    }));
    const result = await getThingsByOwner('123');
    expect(result?.error).toEqual(exploded);
  });
});
'''
'''--- packages/data/src/api/getThingsByOwner/getThingsByOwner.ts ---
import { fetchEverything, GraphqlFetchingError } from '../../graphql/fetch';
import { thingsByOwnerQuery } from './getThingsByOwner.query';
import { ThingsByOwnerResults } from './getThingsByOwner.types';

interface ThingsByOwnerData {
  data?: ThingsByOwnerResults | null;
  error: undefined | GraphqlFetchingError;
}

/**
 * Makes a request to mesh api for all things by owner data
 * @returns all things with matching ownerId {@link ThingsByOwnerData}
 */
export const getThingsByOwner = async (
  ownerId: string
): Promise<ThingsByOwnerData> => {
  const fetchData = async (): Promise<ThingsByOwnerData> => {
    const { data, error } = await fetchEverything<ThingsByOwnerResults>({
      query: thingsByOwnerQuery,
      variables: {
        ownerId
      },
    });

    if (error) {
      console.error('Error fetching things by owner', error.message);
    }

    return { data, error };
  };

  return fetchData();
};
'''
'''--- packages/data/src/api/getThingsByOwner/getThingsByOwner.types.ts ---
export interface Things {
  edges: Edges[];
}

export interface Edges {
  node: Node;
}

export interface Node {
  id: number;
}

export interface ThingsByOwnerResults {
  things: Things;
}
'''
'''--- packages/data/src/api/index.ts ---
export * from './getThings/getThings';
export * from './getThingById/getThingById';
export * from './getThingsByOwner/getThingsByOwner';
export * from './getAttributes/getAttributes';
export * from './getAttributeById/getAttributeById';
export * from './getListings/getListings.query';
export * from './getListings/getListingsByLister.query';
export * from './getListings/minter.query';
'''
'''--- packages/data/src/constants.ts ---
export const GRAPHQL_ENDPOINT = "/api/graphql";
'''
'''--- packages/data/src/graphql/fetch.test.ts ---
import { GraphQLClient, gql } from 'graphql-request';
import { fetchEverything } from './fetch';

jest.mock('graphql-request');

type FakeData = {
  foo: string;
}

const fakeQuery = gql`query data(){}`;

describe('graphql/fetch', () => {
  it('returns data prop of type T when things go well', async () => {
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<FakeData> => Promise.resolve({ foo: 'bar' }),
    }));
    const { data, error } = await fetchEverything<FakeData>({ query: fakeQuery });
    expect(data).toBeDefined();
    expect(error).not.toBeDefined();
    expect(data?.foo).toBe('bar');
  });

  it('returns error in error prop', async () => {
    const boom = 'boom!';
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<FakeData> => Promise.reject(new Error(boom)),
    }));
    const { data, error } = await fetchEverything<FakeData>({ query: fakeQuery });
    expect(data).not.toBeDefined();
    expect(error).toBeDefined();
    expect(error?.message).toBe(boom);
  });
});
'''
'''--- packages/data/src/graphql/fetch.ts ---
import { DocumentNode } from 'graphql';
import { GraphQLClient, Variables } from 'graphql-request';
import { GRAPHQL_ENDPOINT } from '../constants';

export class GraphqlFetchingError extends Error {
  constructor(msg: string) {
    super();
    this.message = msg;
  }
}

export type GqlFetchResult<T> = {
  data?: T;
  error?: GraphqlFetchingError;
}

export const fetchEverything = async <T, V = Record<string, unknown>>({
  query,
  variables,
}: {
  query: DocumentNode | string;
  variables?: Variables;
}) => {
  try {
    const client = new GraphQLClient(GRAPHQL_ENDPOINT);
    return { data: await client.request<T>(query, variables) };
  } catch (error: any) {
    return {
      error: new GraphqlFetchingError(error.message),
    };
  }
};
'''
'''--- packages/data/src/graphql/index.ts ---
export * from "./fetch";
'''
'''--- packages/data/src/index.ts ---
export * from "./constants";
export * from './graphql/index';
export * from './api/index';

'''
'''--- packages/data/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es6",
    "module": "esnext",
    "sourceMap": true,
    "outDir": "dist",
    "strict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true
  },
  "include": [
    "./src"
  ]
}
'''
'''--- packages/react/.eslintrc.js ---
const path = require('path');
module.exports = {
  "extends": "../../.eslintrc.json",
}
'''
'''--- packages/react/README .md ---
# @everything-sdk-js/react

Provides react components for interacting with the sdk.

_IN PROGRESS_:

- EverythingProvider which simplifies setup
- useCreator hook for easy, opinionated use of sdk methods 
'''
'''--- packages/react/package.json ---
{
  "name": "@everything-sdk-js/react",
  "version": "0.0.1",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "build": "rollup -c --bundleConfigAsCjs",
    "watch": "rollup -c -w"
  },
  "author": "@near-everything",
  "license": "MIT",
  "type": "module",
  "devDependencies": {
    "@rollup/plugin-commonjs": "^23.0.3",
    "@rollup/plugin-json": "^5.0.2",
    "@rollup/plugin-node-resolve": "^15.0.1",
    "@rollup/plugin-terser": "^0.1.0",
    "@types/react": "^18.0.26",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "rollup": "^3.5.1",
    "rollup-plugin-peer-deps-external": "^2.2.4",
    "rollup-plugin-typescript2": "^0.34.1",
    "typescript": "^4.9.3"
  },
  "peerDependencies": {
    "next": ">=10"
  },
  "dependencies": {
    "@auth0/nextjs-auth0": "^2.0.1"
  }
}

'''
'''--- packages/react/rollup.config.js ---
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import typescript from 'rollup-plugin-typescript2';
import terser from '@rollup/plugin-terser';
import external from 'rollup-plugin-peer-deps-external';
import json from '@rollup/plugin-json';

export default {
    input: 'src/index.ts',
    output: {
        dir: "dist",
        format: "esm",
        sourcemap: true
    },
    plugins: [
        external(),
        resolve(),
        commonjs(),
        typescript({ tsconfig: './tsconfig.json' }),
        terser(),
        json()
    ]
}
'''
'''--- packages/react/src/index.ts ---
export * from "./EverythingContext";
// export * from "./hooks/useCreator";
'''
'''--- packages/react/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es6",
    "module": "esnext",
    "jsx": "react",
    "sourceMap": true,
    "outDir": "dist",
    "strict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
  }
}
'''
'''--- packages/sdk/.eslintrc.js ---
const path = require('path');
module.exports = {
  "extends": "../../.eslintrc.json",
}
'''
'''--- packages/sdk/README.md ---
# @everything-sdk-js/sdk

Provides methods for creating data with **everything**.

_IN PROGRESS_: Methods for proposing attributes, proposing options, creating characteristics, and updating existing data. Will also offer methods for deleting data.

## Thing

See [methods](./src/thing/) for creating things and minting references.

## Media

See [methods](./src/media/) for creating media and associating tags.

'''
'''--- packages/sdk/jest.config.ts ---
/*
 * For a detailed explanation regarding each configuration property and type check, visit:
 * https://jestjs.io/docs/configuration
 */

export default {
  // All imported modules in your tests should be mocked automatically
  // automock: false,

  // Stop running tests after `n` failures
  // bail: 0,

  // The directory where Jest should store its cached dependency information
  // cacheDirectory: "/private/var/folders/hl/1w1xt9zs65j76fb84dj7_kq40000gn/T/jest_dx",

  // Automatically clear mock calls, instances, contexts and results before every test
  clearMocks: true,

  // Indicates whether the coverage information should be collected while executing the test
  collectCoverage: true,

  // An array of glob patterns indicating a set of files for which coverage information should be collected
  // collectCoverageFrom: undefined,

  // The directory where Jest should output its coverage files
  coverageDirectory: "coverage",

  // An array of regexp pattern strings used to skip coverage collection
  coveragePathIgnorePatterns: [
    "/node_modules/",
    "/dist/"
  ],

  // Indicates which provider should be used to instrument code for coverage
  coverageProvider: "v8",

  // A list of reporter names that Jest uses when writing coverage reports
  // coverageReporters: [
  //   "json",
  //   "text",
  //   "lcov",
  //   "clover"
  // ],

  // An object that configures minimum threshold enforcement for coverage results
  // coverageThreshold: undefined,

  // A path to a custom dependency extractor
  // dependencyExtractor: undefined,

  // Make calling deprecated APIs throw helpful error messages
  // errorOnDeprecated: false,

  // The default configuration for fake timers
  // fakeTimers: {
  //   "enableGlobally": false
  // },

  // Force coverage collection from ignored files using an array of glob patterns
  // forceCoverageMatch: [],

  // A path to a module which exports an async function that is triggered once before all test suites
  // globalSetup: undefined,

  // A path to a module which exports an async function that is triggered once after all test suites
  // globalTeardown: undefined,

  // A set of global variables that need to be available in all test environments
  // globals: {},

  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.
  // maxWorkers: "50%",

  // An array of directory names to be searched recursively up from the requiring module's location
  // moduleDirectories: [
  //   "node_modules"
  // ],

  // An array of file extensions your modules use
  // moduleFileExtensions: [
  //   "js",
  //   "mjs",
  //   "cjs",
  //   "jsx",
  //   "ts",
  //   "tsx",
  //   "json",
  //   "node"
  // ],

  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
  // moduleNameMapper: {},

  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
  modulePathIgnorePatterns: ['/dist/'],

  // Activates notifications for test results
  // notify: false,

  // An enum that specifies notification mode. Requires { notify: true }
  // notifyMode: "failure-change",

  // A preset that is used as a base for Jest's configuration
  preset: 'ts-jest',

  // Run tests from one or more projects
  // projects: undefined,

  // Use this configuration option to add custom reporters to Jest
  // reporters: undefined,

  // Automatically reset mock state before every test
  // resetMocks: false,

  // Reset the module registry before running each individual test
  // resetModules: false,

  // A path to a custom resolver
  // resolver: undefined,

  // Automatically restore mock state and implementation before every test
  // restoreMocks: false,

  // The root directory that Jest should scan for tests and modules within
  // rootDir: undefined,

  // A list of paths to directories that Jest should use to search for files in
  // roots: [
  //   "<rootDir>"
  // ],

  // Allows you to use a custom runner instead of Jest's default test runner
  // runner: "jest-runner",

  // The paths to modules that run some code to configure or set up the testing environment before each test
  // setupFiles: [],

  // A list of paths to modules that run some code to configure or set up the testing framework before each test
  // setupFilesAfterEnv: [],

  // The number of seconds after which a test is considered as slow and reported as such in the results.
  // slowTestThreshold: 5,

  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
  // snapshotSerializers: [],

  // The test environment that will be used for testing
  testEnvironment: 'node',

  // Options that will be passed to the testEnvironment
  // testEnvironmentOptions: {},

  // Adds a location field to test results
  // testLocationInResults: false,

  // The glob patterns Jest uses to detect test files
  // testMatch: [
  //   "**/__tests__/**/*.[jt]s?(x)",
  //   "**/?(*.)+(spec|test).[tj]s?(x)"
  // ],

  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
  // testPathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // The regexp pattern or array of patterns that Jest uses to detect test files
  // testRegex: [],

  // This option allows the use of a custom results processor
  // testResultsProcessor: undefined,

  // This option allows use of a custom test runner
  // testRunner: "jest-circus/runner",

  // A map from regular expressions to paths to transformers
  // transform: undefined,

  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
  // transformIgnorePatterns: [
  //   "/node_modules/",
  //   "\\.pnp\\.[^\\/]+$"
  // ],

  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
  // unmockedModulePathPatterns: undefined,

  // Indicates whether each individual test should be reported during the run
  // verbose: undefined,

  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
  // watchPathIgnorePatterns: [],

  // Whether to use watchman for file crawling
  // watchman: true,
};

'''
'''--- packages/sdk/package.json ---
{
  "name": "@everything-sdk-js/sdk",
  "version": "0.0.1",
  "description": "",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "watch": "tsc && tsc --watch"
  },
  "author": "@near-everything",
  "license": "MIT",
  "type": "module",
  "devDependencies": {
    "@babel/preset-env": "^7.20.2",
    "@types/jest": "^29.2.3",
    "babel-jest": "^29.3.1",
    "graphql": "^16.6.0",
    "graphql-request": "^5.0.0",
    "jest": "^29.3.1",
    "ts-jest": "^29.0.3",
    "ts-node": "^10.9.1",
    "typescript": "^4.9.3",
    "uuidv4": "^6.2.13"
  },
  "dependencies": {
    "@mintbase-js/sdk": "^0.1.0-alpha-10",
    "@mintbase-js/storage": "^0.1.0-alpha-10",
    "@near-wallet-selector/core": "^7.3.0"
  }
}

'''
'''--- packages/sdk/src/characteristic/characteristic.d.ts ---
interface Characteristic {
  attributeId: number,
  optionId: number
}
'''
'''--- packages/sdk/src/constants.ts ---
export const STORAGE_TYPE = {
  OFFLINE: 'OFFLINE',
  CLOUD: 'CLOUD',
  BLOCKCHAIN: 'BLOCKCHAIN'
}

export const GRAPHQL_ENDPOINT = "/api/graphql";
export const MEDIA_UPLOAD_ENDPOINT = `${process.env.EVERYTHING_API}/api/file/upload`;

export const USER_NOT_PROVIDED = "user not provided";
export const MINT_ARGS_NOT_PROVIDED = "mint args not provided";
export const WALLET_NOT_PROVIDED = "wallet not provided";
export const NOT_VALID_UUID = "not a valid uuid";
'''
'''--- packages/sdk/src/index.ts ---
export * from "./constants";

export * from "./thing/createThing";
export * from "./thing/mintThing";
export * from "./thing/buyThing";

export * from "./media/createMedia";

export * from "./utils/index";
'''
'''--- packages/sdk/src/media/README.md ---
# Media

Provides methods for creating Media in everything.
Media can be uploaded to either everything cloud storage or [Arweave](https://www.arweave.org) via the [Mintbase SDK](https://github.com/Mintbase/mintbase-js).
Then records of the Media and associated Tags to the provided thingId are created in cloud storage.

</br>
</br>

## available methods

### createMediaOnCloud

Uploads array of files to everything cloud storage. 
Will automatically create Media and associated Tags from the provided thingId.

**Requires user to be connected to everything via Auth0.**

Currently only supports image/jpeg and image/png file types.

``` js
  // grab user from Auth0 (example using useUser from AuthContext for Next.js)
  const { user } = useUser();

  // files for upload
  const files: File[] = ....;
  
  // thingId should be provided and valid
  const args: CreateMediaCloudArgs = {
    user,
    thingId
  }

  try {
    // returns urls, but no further action required
    const { urls } = await createMediaOnCloud(files, args);
  } catch(error) {
    // handle error in creating media
  }
```

</br>

---

### createMediaOnBlockchain

Uploads array of files to [Arweave](https://www.arweave.org) via [Mintbase SDK](https://github.com/Mintbase/mintbase-js). 
Will automatically create Media and associated Tags from the provided thingId.

``` js
  // files for upload
  const files: File[] = ....;
  
  // thingId should be provided and valid
  const args: CreateMediaBlockchainArgs = {
    thingId
  }

  try {
    // returns urls, but no further action required
    const { urls } = await createMediaOnBlockchain(files, args);
  } catch(error) {
    // handle error in creating media
  }
```

</br>

'''
'''--- packages/sdk/src/media/createMedia.mutation.ts ---
import { gql } from 'graphql-request';

export const createMediaMutation = gql`
  mutation createMedia($input: CreateMediaInput!) {
    createMedia(input: $input) {
      media {
        id
      }
    }
  }
`
'''
'''--- packages/sdk/src/media/createMedia.test.ts ---
// import { uploadFile } from "@mintbase-js/storage";
// import { MEDIA_UPLOAD_ENDPOINT } from "../constants";
// import { fetchEverything } from "../utils";
// import { createMediaOnBlockchain, createMediaOnCloud, uploadFilesToCloud } from "./createMedia";

// jest.mock('../utils');
// jest.mock("@mintbase-js/storage")

// const user = {
//   email: "test@me.com",
//   sub: "everything|12345"
// }

// const wallet = {
//   id: "test-wallet.testnet"
// }

// const thingId = "thing123";
// File = jest.fn() as jest.Mock;
// const FormDataMock: jest.Mock<FormData> = jest.fn().mockImplementation(() => {
//   const formData = {
//     append: jest.fn()
//   };
//   return formData;
// });

// FormData = FormDataMock;

// const files = [
//   new File([new ArrayBuffer(1)], 'file.jpg')
// ]

// describe('createMediaOnCloud should', () => {
//   const cloudArgs = {
//     user,
//     thingId: "123-abc"
//   };

//   beforeEach(() => {
//     jest.spyOn(global.console, 'error').mockImplementation(() => null);
//   })

//   afterEach(() => {
//     jest.resetAllMocks();
//   });

//   test("call the everything api with correct arguments and return urls", async () => {
//     const fetchMock = jest.spyOn(global, "fetch").mockImplementation(
//       jest.fn(() =>
//         Promise.resolve({ ok: true, json: () => Promise.resolve({ data: { urls: "https://example.com/file" } }) })
//       ) as jest.Mock
//     );
//     const response = await createMediaOnCloud(files, cloudArgs);
//     expect(fetchMock).toHaveBeenCalled();
//     expect(fetchMock).toHaveBeenCalledWith(
//       MEDIA_UPLOAD_ENDPOINT,
//       expect.any(Object)
//     )
//   });

//   test("throw error if 400 status", async () => {
//     const fetchMock = jest.spyOn(global, "fetch").mockImplementation(
//       jest.fn(() =>
//         Promise.resolve({ ok: false, status: 400, json: () => Promise.resolve({ errorCode: 405, errorMessage: "oops" }) })
//       ) as jest.Mock
//     );
//     await expect(async () => {
//       await uploadFilesToCloud(FormDataMock())
//     }).rejects.toThrow("Upload to everything was unsuccessful: 405, oops");
//   });

//   test("throw error if 500 status", async () => {
//     jest.spyOn(global, "fetch").mockImplementation(
//       jest.fn(() =>
//         Promise.resolve({ ok: false, status: 500, json: () => Promise.resolve({ errorMessage: "oops" }) })
//       ) as jest.Mock
//     );
//     await expect(async () => {
//       await uploadFilesToCloud(FormDataMock())
//     }).rejects.toThrow("Error occurred during upload: oops");
//   });

//   test("throw error if other status", async () => {
//     jest.spyOn(global, 'fetch').mockImplementation(
//       jest.fn(() =>
//         Promise.resolve({ ok: false, status: 450, json: () => Promise.resolve({ errorMessage: "oops" }) })
//       ) as jest.Mock
//     );
//     await expect(async () => {
//       await uploadFilesToCloud(FormDataMock())
//     }).rejects.toThrow("An error has occured: 450");
//   });
// });

// describe('createMediaOnBlockchain should', () => {
//   const blockchainArgs = {
//     thingId,
//   };
//   test("call uploadFile for each file", async () => {
//     (fetchEverything as jest.Mock).mockImplementation(() => {
//       return {
//         data: { createMedia: { media: { id: "id" } } }
//       }
//     });
//     (uploadFile as jest.Mock).mockImplementation(() => {
//       return {
//         id: "media123"
//       }
//     });
//     const response = await createMediaOnBlockchain(files, blockchainArgs);
//     expect(uploadFile).toHaveBeenCalled();
//     expect(fetchEverything).toHaveBeenCalled();
//     expect(response).toEqual({ urls: ["https://arweave.net/media123"] });
//   });

//   test("throw error if mutation fails", async () => {
//     jest.spyOn(global.console, 'error').mockImplementation(() => null);
//     (fetchEverything as jest.Mock).mockImplementation(() => {
//       return {
//         error: { message: "ohhh nooo" }
//       }
//     });
//     await expect(async () => {
//       await createMediaOnBlockchain(files, blockchainArgs)
//     }).rejects.toThrow("ohhh nooo");
//   });
// });

'''
'''--- packages/sdk/src/media/createMedia.ts ---
import { uploadFile } from "@mintbase-js/storage";
import { MEDIA_UPLOAD_ENDPOINT } from "../constants";
import { fetchEverything } from "../utils";
import { createMediaMutation } from "./createMedia.mutation";

type CreateMediaCloudArgs = {
  user: any,
  thingId: string
}

type CreateMediaResponse = {
  urls: string[]
}

type CloudError = {
  message: string
}

/**
 * Uploads array of files to cloud storage (everything api)
 * Constructs FormData for upload
 * @param files list of files to upload
 * @param args {@link CreateMediaCloudArgs}
 * @returns list of urls {@link CreateMediaResponse}
 */
export async function createMediaOnCloud(files: File[], args: CreateMediaCloudArgs): Promise<CreateMediaResponse> {

  // construct form data for multipart/form-data
  const formData = new FormData();
  formData.append("thingId", args.thingId);
  formData.append("userId", args.user.sub);
  for (let i = 0; i < files.length; i++) {
    formData.append("files", files[i]);
  }

  try {
    const response = await uploadFilesToCloud(formData);
    return response;
  } catch (error: unknown) {
    console.error(`Error creating media: ${(error as CloudError).message}`)
    throw error;
  }
}

/**
 * Sends request to everything api for file upload
 * @param formData prepared form data, contains thingId and files
 * @returns list of urls {@link CreateMediaResponse}
 */
export async function uploadFilesToCloud(
  formData: FormData
): Promise<CreateMediaResponse> {
  // TODO: This will require an access token
  const response = await fetch(MEDIA_UPLOAD_ENDPOINT, {
    method: "POST",
    body: formData
  })
  const data = await response.json();
  if (!response.ok) {
    if (response.status === 400) {
      // Successful upload to object storage, but failure creating references in database
      throw new Error(`Upload to everything was unsuccessful: ${data.errorCode}, ${data.errorMessage}`);
    } else if (response.status === 500) {
      // Unsuccessful upload to object storage
      throw new Error(`Error occurred during upload: ${data.errorMessage}`);
    } else {
      throw new Error(`An error has occured: ${response.status}`);
    }
  }
  return data;
}

type CreateMediaBlockchainArgs = {
  thingId: string
}

/**
 * Uploads array of files to blockchain storage (Arweave)
 * @param files list of files to upload
 * @param args {@link CreateMediaBlockchainArgs}
 * @returns list of urls {@link CreateMediaResponse}
 */
export async function createMediaOnBlockchain(files: File[], args: CreateMediaBlockchainArgs): Promise<CreateMediaResponse> {
  const urls: string[] = [];
  
  // upload each file individually to arweave via Mintbase SDK
  for (let i = 0; i < files.length; i++) {
    const response = await uploadFile(files[i]); //  + '-' + files[i].originalname
    // construct url
    const url = `https://arweave.net/${response.id}`;
    // prepare url for response
    urls.push(url);
    const variables = {
      input: {
        url,
        thingId: args.thingId
      }
    }
    // send url to everything api to construct Media objects and tags
    const { error } = await fetchEverything({ query: createMediaMutation, variables });
    if (error) {
      console.error("Error creating media", error.message);
      throw new Error(`Error creating media ${error.message}`)
    }
  }
  const response = {
    urls
  }
  return response;
}

'''
'''--- packages/sdk/src/media/media.d.ts ---
interface CreateMediaResponse {
  data?: any | null;
  error: undefined | Error;
}

export type CreateMediaArgs = {
  thingId?: string,
  files: any[],
  storage: string[]
};
'''
'''--- packages/sdk/src/thing/README.md ---
# Thing

Provides methods for creating Things in everything.
Things are uploaded to everything cloud storage.

_IN PROGRESS_: More options in progress, Arweave upload in development, will offer offline storage.

</br>
</br>

## available methods

### createThing

Creates a Thing on the specified storage service (currently only supports cloud storage).

Will return a thingId.

**Requires user to be connected to everything via Auth0.**

Currently only supports image/jpeg and image/png file types.

``` js
  // grab user from Auth0 (example using useUser from UserProvider from Auth0/next.js)
  const { user } = useUser();

  // files for upload
  const files: File[] = ....;
  
  // thingId should be provided and valid
  const args: CreateMediaCloudArgs = {
    user,
    thingId
  }

  try {
    // returns urls, but no further action required
    const { urls } = await createThing(files, args);
  } catch(error) {
    // handle error in creating media
  }
```

</br>

---

### mintThing

Provided an id for an existing Thing, will mint reference on [NEAR Protocol](https://near.org) via [Mintbase SDK](https://github.com/Mintbase/mintbase-js). Can be used for history of ownership and marketplace transactions.

**Requires user to be connected to NEAR.**

``` js
  // need wallet and owner account id (example using useWallet from Mintbase WalletContextProvider)
  const { selector, activeAccountId } = useWallet();
  
  const wallet = await selector.wallet();

  // thingId should be provided and valid
  const args: CreateThingBlockchainArgs = {
    wallet,
    ownerId: activeAccountId,
    nftContractId: "everything.mintspace2.testnet" // generate your own on Mintbase
  }

  try {
    // returns final execution outcome, but no further action required
    const response = await mintThing(thingId, args);
  } catch(error) {
    // handle error in minting thing
  }
```

</br>

'''
'''--- packages/sdk/src/thing/buyThing.test.ts ---
import { isUuid, uuid } from "uuidv4";
import { NOT_VALID_UUID, STORAGE_TYPE, USER_NOT_PROVIDED } from "../constants";
import { fetchEverything } from "../utils";
import { createThing, createThingOnCloud } from "./createThing";
import { createThingMutation } from "./createThing.mutation";

jest.mock('../utils');
jest.mock('uuidv4');

const user = {
  email: "test@me.com",
  sub: "everything|12345"
}

const characteristics = [
  {
    attributeId: 1,
    optionId: 1
  }
]

describe("createThing should", () => {

  afterEach(() => jest.resetAllMocks());

  beforeEach(() => {
    (uuid as jest.Mock).mockImplementation(() => 'uuid');
    (isUuid as jest.Mock).mockImplementation(() => true);
  });

  test("call createThingOnCloud when storage includes CLOUD", async () => {
    const thingArgs = {
      storage: [STORAGE_TYPE.CLOUD],
      user,
      characteristics
    };
    (fetchEverything as jest.Mock).mockImplementation(() => {
      return {
        data: null,
        error: undefined
      }
    });
    const response = await createThing(thingArgs);
    expect(fetchEverything).toHaveBeenCalled();
    expect(response).toEqual({ thingId: "uuid" })
  });

  test("throw error if cloud and user not provided", async () => {
    await expect(async () => {
      const thingArgs = {
        storage: [STORAGE_TYPE.CLOUD],
        characteristics
      }
      await createThing(thingArgs)
    }).rejects.toThrow(USER_NOT_PROVIDED);
  });
});

describe("createThingOnCloud should", () => {
  afterEach(() => jest.resetAllMocks());

  beforeEach(() => {
    (isUuid as jest.Mock).mockImplementation(() => true);
  });

  const cloudArgs = {
    user,
    characteristics
  }

  test("throw error if uuid is not valid", async () => {
    (isUuid as jest.Mock).mockImplementation(() => false);
    await expect(async () => {
      await createThingOnCloud("uuid", cloudArgs)
    }).rejects.toThrow(NOT_VALID_UUID);
  });

  test("call fetchEverything with the correct arguments", async () => {
    (fetchEverything as jest.Mock).mockImplementation(() => {
      return {
        data: { createThing: { thing: { id: "uuid" } } }
      }
    });
    const { data } = await createThingOnCloud("uuid", cloudArgs)
    expect(fetchEverything).toHaveBeenCalled();
    expect(fetchEverything).toHaveBeenCalledWith({
      query: createThingMutation,
      variables: { input: { thingId: "uuid", ownerId: user.sub, characteristics } }
    });
    expect(data).toEqual({ createThing: { thing: { id: "uuid" } } })
  });

  test("throw error if fetchEverything fails", async () => {
    jest.spyOn(global.console, 'error').mockImplementation(() => null);
    (fetchEverything as jest.Mock).mockImplementation(() => {
      return {
        error: { message: "ohhh nooo" }
      }
    });
    const { error } = await createThingOnCloud("uuid", cloudArgs);
    expect(error).toEqual({ message: "ohhh nooo" });
  });
})
'''
'''--- packages/sdk/src/thing/buyThing.ts ---

import { buy, execute } from '@mintbase-js/sdk';
import { Wallet } from '@near-wallet-selector/core';
import { USER_NOT_PROVIDED } from "../constants";
import { fetchEverything, GraphqlFetchingError } from "../utils";
import { updateThingMutation } from './updateThing.mutation';

export type BuyThingCloudResults = {
  data: any | null,
  error: undefined | GraphqlFetchingError
}

export type BuyThingArgs = {
  thingId: string,
  user?: any,
  price: string,
  contractId: string,
  tokenId: string,
  referrerId: string,
  wallet: Wallet,
};

/**
 * Buy a Thing from marketplace
 * @param args {@link BuyThingArgs}
 */
export async function buyThing(args: BuyThingArgs): Promise<void> {
  // confirm user provided
  if (!args.user) {
    throw new Error(USER_NOT_PROVIDED);
  }

  const variables = {
    input: {
      id: args.thingId,
      patch: {
        ownerId: args.user.sub,
      }
    },
  };
  // create request to api to set owner
  const { data, error } = await fetchEverything({ query: updateThingMutation, variables });
  if (error) {
    console.error("Error updating thing, cancelling buy", error.message);
    return;
  } else {
    // check if price is greater
    const buyArgs = {
      price: args.price,
      nftContractId: args.contractId,
      tokenId: args.tokenId,
      referrerId: args.referrerId,
      marketId: "market-v2-beta.mintspace2.testnet",
    };
    await execute({ wallet: args.wallet }, buy(buyArgs));
  }
}
'''
'''--- packages/sdk/src/thing/createThing.mutation.ts ---
import { gql } from 'graphql-request';

export const createThingMutation = gql`
  mutation createThing($input: CreateThingInput!) {
    createThing(input: $input) {
      thing {
        id
      }
    }
  }
`
'''
'''--- packages/sdk/src/thing/createThing.test.ts ---
import { isUuid, uuid } from "uuidv4";
import { NOT_VALID_UUID, STORAGE_TYPE, USER_NOT_PROVIDED } from "../constants";
import { fetchEverything } from "../utils";
import { createThing, createThingOnCloud } from "./createThing";
import { createThingMutation } from "./createThing.mutation";

jest.mock('../utils');
jest.mock('uuidv4');

const user = {
  email: "test@me.com",
  sub: "everything|12345"
}

const characteristics = [
  {
    attributeId: 1,
    optionId: 1
  }
]

describe("createThing should", () => {

  afterEach(() => jest.resetAllMocks());

  beforeEach(() => {
    (uuid as jest.Mock).mockImplementation(() => 'uuid');
    (isUuid as jest.Mock).mockImplementation(() => true);
  });

  test("call createThingOnCloud when storage includes CLOUD", async () => {
    const thingArgs = {
      storage: [STORAGE_TYPE.CLOUD],
      user,
      characteristics
    };
    (fetchEverything as jest.Mock).mockImplementation(() => {
      return {
        data: null,
        error: undefined
      }
    });
    const response = await createThing(thingArgs);
    expect(fetchEverything).toHaveBeenCalled();
    expect(response).toEqual({ thingId: "uuid" })
  });

  test("throw error if cloud and user not provided", async () => {
    await expect(async () => {
      const thingArgs = {
        storage: [STORAGE_TYPE.CLOUD],
        characteristics
      }
      await createThing(thingArgs)
    }).rejects.toThrow(USER_NOT_PROVIDED);
  });
});

describe("createThingOnCloud should", () => {
  afterEach(() => jest.resetAllMocks());

  beforeEach(() => {
    (isUuid as jest.Mock).mockImplementation(() => true);
  });

  const cloudArgs = {
    user,
    characteristics
  }

  test("throw error if uuid is not valid", async () => {
    (isUuid as jest.Mock).mockImplementation(() => false);
    await expect(async () => {
      await createThingOnCloud("uuid", cloudArgs)
    }).rejects.toThrow(NOT_VALID_UUID);
  });

  test("call fetchEverything with the correct arguments", async () => {
    (fetchEverything as jest.Mock).mockImplementation(() => {
      return {
        data: { createThing: { thing: { id: "uuid" } } }
      }
    });
    const { data } = await createThingOnCloud("uuid", cloudArgs)
    expect(fetchEverything).toHaveBeenCalled();
    expect(fetchEverything).toHaveBeenCalledWith({
      query: createThingMutation,
      variables: { input: { thingId: "uuid", ownerId: user.sub, characteristics } }
    });
    expect(data).toEqual({ createThing: { thing: { id: "uuid" } } })
  });

  test("throw error if fetchEverything fails", async () => {
    jest.spyOn(global.console, 'error').mockImplementation(() => null);
    (fetchEverything as jest.Mock).mockImplementation(() => {
      return {
        error: { message: "ohhh nooo" }
      }
    });
    const { error } = await createThingOnCloud("uuid", cloudArgs);
    expect(error).toEqual({ message: "ohhh nooo" });
  });
})
'''
'''--- packages/sdk/src/thing/createThing.ts ---

import { isUuid, uuid } from 'uuidv4';
import { NOT_VALID_UUID, STORAGE_TYPE, USER_NOT_PROVIDED } from "../constants";
import { fetchEverything, GraphqlFetchingError } from "../utils";
import { createThingMutation } from "./createThing.mutation";

export type CreateThingCloudResults = {
  data: any | null,
  error: undefined | GraphqlFetchingError
}

export type CreateThingArgs = {
  storage: string[],
  user?: any,
  characteristics: Characteristic[],
};

export type CreateThingCloudArgs = {
  user: any,
  characteristics: Characteristic[]
};

export type CreateThingResponse = {
  thingId: string
}

/**
 * Create a Thing on the specified storage service
 * Storage options: cloud
 * @param args {@link CreateThingArgs}
 * @returns thingId
 */
export async function createThing(args: CreateThingArgs): Promise<CreateThingResponse> {
  const thingId = uuid();

  // create on cloud
  if (args.storage.includes(STORAGE_TYPE.CLOUD)) {
    // confirm user provided
    if (!args.user) {
      throw new Error(USER_NOT_PROVIDED);
    }

    const cloudArgs: CreateThingCloudArgs = {
      user: args.user,
      characteristics: args.characteristics
    }
    await createThingOnCloud(thingId, cloudArgs);
  }

  const response = { thingId }
  
  return response;
}

/**
 * Create a Thing on cloud storage (everything api)
 * @param thingId
 * @param args {@link CreateThingCloudArgs}
 */
export async function createThingOnCloud(thingId: string, args: CreateThingCloudArgs): Promise<CreateThingCloudResults> { // create type
  if (!isUuid(thingId)) {
    throw new Error(NOT_VALID_UUID);
  }

  // TODO: confirm that the thing does not exist
  // if it does, throw error

  const variables = {
    input: {
      thingId: thingId,
      ownerId: args.user.sub,
      characteristics: args.characteristics,
    },
  };
  // create request to api
  const { data, error } = await fetchEverything({ query: createThingMutation, variables });
  // not expecting any response that isn't an error (what if attribute_id is not valid?)
  if (error) {
    console.error("Error creating thing", error.message);
  }
  return { data, error };
}
'''
'''--- packages/sdk/src/thing/mintThing.test.ts ---
import { execute, mint } from "@mintbase-js/sdk";
import { isUuid } from "uuidv4";
import { NOT_VALID_UUID } from "../constants";
import { mintThing } from "./mintThing";

jest.mock('@mintbase-js/sdk');
jest.mock('uuidv4');

const mockNearSelectorWallet = {
  signAndSendTransaction: jest.fn(),
  signAndSendTransactions: jest.fn(),
};

describe("mintThing should", () => {
  afterEach(() => jest.resetAllMocks());

  beforeEach(() => {
    (isUuid as jest.Mock).mockImplementation(() => true);
  });

  const thingArgs = {
    wallet: mockNearSelectorWallet as any,
    ownerId: "alice.testnet",
    nftContractId: "everything.test"
  }

  test("throw error if uuid is not valid", async () => {
    (isUuid as jest.Mock).mockImplementation(() => false);
    await expect(async () => {
      await mintThing("uuid", thingArgs)
    }).rejects.toThrow(NOT_VALID_UUID);
  });

  test("throw error if thing exists on chain", () => {
    // TODO
  });

  test("call execute and mint with the correct arguments", async () => {
    (mint as jest.Mock).mockImplementationOnce(() => (
      "mock mint"
    ));
    await mintThing("uuid", thingArgs);
    expect(mint).toHaveBeenCalled();
    expect(mint).toHaveBeenCalledWith({ nftContractId: thingArgs.nftContractId, reference: "uuid", ownerId: thingArgs.ownerId });
    expect(execute).toHaveBeenCalledWith("mock mint", { wallet: mockNearSelectorWallet });
  });
})
'''
'''--- packages/sdk/src/thing/mintThing.ts ---
import { execute, mint, MintArgs } from "@mintbase-js/sdk";
import { AccountId } from "@mintbase-js/sdk/lib/v1";
import { FinalExecutionOutcome, Wallet } from "@near-wallet-selector/core";
import { isUuid } from "uuidv4";
import { NOT_VALID_UUID } from "../constants";

export type CreateThingBlockchainArgs = {
  wallet: Wallet,
  ownerId: AccountId,
  nftContractId: AccountId
}

/**
 * mints a reference on chain for the provided thing id
 * @param thingId 
 * @param args {@link CreateThingBlockchainArgs}
 * @returns a result for single transactions of {@link FinalExecutionOutcome}
 */
export async function mintThing(thingId: string, args: CreateThingBlockchainArgs): Promise<void | FinalExecutionOutcome | FinalExecutionOutcome[]> {
  if (!isUuid(thingId)) {
    throw new Error(NOT_VALID_UUID);
  }

  // NOTE: the below code works, but I don't know why I want my reference to be anything more than the thing id (yet)  

  // const metadata = JSON.stringify({
  //   extra: thingId
  // });
  // const file = new File([metadata], `${thingId}.json`, {
  //   type: "application/json"
  // });
  // const response = await uploadFile(file);
  // const url = `https://arweave.net/${response.id}`;

  const mintArgs: MintArgs = {
    nftContractId: args.nftContractId,
    reference: thingId,
    ownerId: args.ownerId,
  }

  // create reference on blockchain
  return execute({ wallet: args.wallet }, mint(mintArgs));
}
'''
'''--- packages/sdk/src/thing/thing.d.ts ---

'''
'''--- packages/sdk/src/thing/updateThing.mutation.ts ---
import { gql } from 'graphql-request';

export const updateThingMutation = gql`
  mutation updateThing($input: UpdateThingInput!) {
    updateThing(input: $input) {
      thing {
        id
      }
    }
  }
`
'''
'''--- packages/sdk/src/utils/fetch.test.ts ---
import { GraphQLClient, gql } from 'graphql-request';
import { fetchEverything } from './fetch';

jest.mock('graphql-request');

type FakeData = {
  foo: string;
}

const fakeQuery = gql`query data(){}`;

describe('graphql/fetch', () => {
  it('returns data prop of type T when things go well', async () => {
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<FakeData> => Promise.resolve({ foo: 'bar' }),
    }));
    const { data, error } = await fetchEverything<FakeData>({ query: fakeQuery });
    expect(data).toBeDefined();
    expect(error).not.toBeDefined();
    expect(data?.foo).toBe('bar');
  });

  it('returns error in error prop', async () => {
    const boom = 'boom!';
    (GraphQLClient as jest.Mock).mockImplementationOnce(() => ({
      request: (): Promise<FakeData> => Promise.reject(new Error(boom)),
    }));
    const { data, error } = await fetchEverything<FakeData>({ query: fakeQuery });
    expect(data).not.toBeDefined();
    expect(error).toBeDefined();
    expect(error?.message).toBe(boom);
  });
});
'''
'''--- packages/sdk/src/utils/fetch.ts ---
import { DocumentNode } from 'graphql';
import { GraphQLClient, Variables } from 'graphql-request';
import { GRAPHQL_ENDPOINT } from '../constants';

export class GraphqlFetchingError extends Error {
  constructor(msg: string) {
    super();
    this.message = msg;
  }
}

export type GqlFetchResult<T> = {
  data?: T;
  error?: GraphqlFetchingError;
}

export const fetchEverything = async <T, V = Record<string, unknown>>({
  query,
  variables,
}: {
  query: DocumentNode | string;
  variables?: Variables;
}) => {
  try {
    const client = new GraphQLClient(GRAPHQL_ENDPOINT);
    return { data: await client.request<T>(query, variables) };
  } catch (error: any) {
    return {
      error: new GraphqlFetchingError(error.message),
    };
  }
};
'''
'''--- packages/sdk/src/utils/index.ts ---
export * from "./fetch";
'''
'''--- packages/sdk/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es6",
    "module": "esnext",
    "sourceMap": true,
    "outDir": "dist",
    "strict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true
  },
  "include": [
    "./src"
  ]
}
'''
'''--- playgrounds/react/.eslintrc.json ---
{
  "extends": "next/core-web-vitals"
}

'''
'''--- playgrounds/react/README.md ---
# everything playground

This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
```

'''
'''--- playgrounds/react/components/CreatableSelect.js ---
import React from "react";
import { components } from "react-select";
import Creatable from "react-select/creatable";

const CreatableSelect = React.forwardRef(function CreatableSelect(props, ref) {
  const { ...other } = props;
  const Input = ({ ...rest }) => <components.Input {...rest} />;

  const customStyles = {
    control: (base) => ({
      ...base,
      background: "#1f2937",
      color: "#9ca3af",
      border: 0,
      boxShadow: "none"
    }),
    menu: base => ({
      ...base,
      // override border radius to match the box
      borderRadius: 0,
      // kill the gap
      marginTop: 0,
      color: "#1f2937",
      fontWeight: 600,
      background: "9ca3af"
    }),
    menuList: base => ({
      ...base,
      // kill the white space on first and last option
      padding: 0
    }),
    placeholder: base => ({
      ...base,
      color: "#9ca3af",
      fontWeight: 600
    }),
    singleValue: base => ({
      ...base,
      color: "#fff",
    }),
    input: base => ({
      ...base,
      color: "#9ca3af"
    })
  };

  return (
    <>
      <Creatable
        className="react-select-container"
        classNamePrefix="react-select"
        isClearable
        components={{ Input, DropdownIndicator: null }}
        ref={ref}
        {...other}
        styles={customStyles}
      />
    </>
  );
});

export default CreatableSelect;

'''
'''--- playgrounds/react/components/Create/CreateThing/AttributeField.js ---
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { gql, GraphQLClient } from "graphql-request";
import React, { useState } from "react";
import CreatableSelect from "../../CreatableSelect";

const AttributeField = React.forwardRef(function AttributeField(
  { attributeId, setAttributeOption, value },
  ref
) {
  const { data, isLoading, isError } = useQuery(
    ["attributeById", attributeId],
    async () => {
      const graphqlClient = new GraphQLClient("/api/graphql");
      const attribute = await graphqlClient.request(
        gql`
          query attributeById($attributeId: Int!) {
            attribute(id: $attributeId) {
              name
              relationships {
                edges {
                  node {
                    option {
                      id
                      value
                    }
                  }
                }
              }
            }
          }
        `,
        { attributeId }
      );
      return attribute;
    },
    {
      enabled: !!attributeId,
    }
  );
  const proposeOption = useMutation((newOption) => {
    const graphqlClient = new GraphQLClient("/api/graphql");
    return graphqlClient.request(
      gql`
        mutation proposeOption($value: String!, $attributeId: Int!) {
          proposeOption(input: { value: $value, attributeId: $attributeId }) {
            option {
              id
              value
            }
          }
        }
      `,
      {
        value: newOption.value,
        attributeId: newOption.attributeId,
      }
    );
  });
  const [loading, setLoading] = useState(false);
  const queryClient = useQueryClient();

  const prepareOptions = () => {
    return data?.attribute?.relationships?.edges?.map((option) => ({
      value: option?.node?.option?.id,
      label: option?.node?.option?.value,
    }));
  };
  const handleOnChange = (value) => {
    if (!value) {
      value = {};
    }
    value.attributeId = attributeId;
    setAttributeOption(value);
  };

  const handleProposeOption = (value) => {
    proposeOption.mutate(
      { value: value, attributeId: attributeId },
      {
        onSuccess: async (response) => {
          setLoading(true);
          const {
            proposeOption: { option },
          } = response;
          setAttributeOption({
            value: option.id,
            label: option.value,
            attributeId: attributeId,
          });
          await queryClient.refetchQueries(["attributeById", attributeId]);
          setLoading(false);
        },
        onError: (error) => {
          console.log(error.message);
        },
      }
    );
  };

  return (
    <>
      {loading ? (
        <>Loading</>
      ) : (
        <CreatableSelect
          options={prepareOptions()}
          isDisabled={isLoading || isError}
          isLoading={isLoading}
          onChange={handleOnChange}
          onCreateOption={handleProposeOption}
          defaultValue={value}
          value={value}
          placeholder={`${data?.attribute?.name}`}
          ref={ref}
        />
      )}
    </>
  );
});

export default AttributeField;

'''
'''--- playgrounds/react/components/Layout/Footer.js ---

function Footer() {
  return (
    <footer className="footer grid-flow-col items-center p-4 text-neutral-content">
      <div className="items-center grid-flow-col text-xs">
        <p>copyright © 2022 everything labs llc. all rights reserved.</p>
      </div>
    </footer>
  );
}

export default Footer;

'''
'''--- playgrounds/react/components/Layout/Header.js ---
import Link from "next/link";

function Header() {
  return (
    <div className="navbar">
      <Link href="/" passHref><button className="btn btn-ghost normal-case text-xl">everything</button></Link>
    </div>
  );
}

export default Header;

'''
'''--- playgrounds/react/components/Layout/index.js ---
import Footer from "./Footer";
import Header from "./Header";

function Layout({ children }) {
  return (
    <div className="flex flex-col min-h-screen">
      <Header />
      <div className="flex flex-1 flex-col">{children}</div>
      <Footer />
    </div>
  );
}

export default Layout;

'''
'''--- playgrounds/react/components/SingleSelect.js ---
import React from "react";
import { components } from "react-select";
import Select from "react-select";

const SingleSelect = React.forwardRef(function SingleSelect(props, ref) {
  const { ...other } = props;
  const Input = ({ ...rest }) => <components.Input {...rest} />;

  const customStyles = {
    control: (base) => ({
      ...base,
      background: "#1f2937",
      color: "#9ca3af",
      border: 0,
      boxShadow: "none"
    }),
    menu: base => ({
      ...base,
      // override border radius to match the box
      borderRadius: 0,
      // kill the gap
      marginTop: 0,
      color: "#1f2937",
      fontWeight: 600,
      background: "9ca3af"
    }),
    menuList: base => ({
      ...base,
      // kill the white space on first and last option
      padding: 0
    }),
    placeholder: base => ({
      ...base,
      color: "#9ca3af",
      fontWeight: 600
    }),
    singleValue: base => ({
      ...base,
      color: "#fff",
    }),
    input: base => ({
      ...base,
      color: "#9ca3af"
    })
  };

  return (
    <>
      <Select
      
        className="react-select-container"
        classNamePrefix="react-select"
        components={{ Input }}
        ref={ref}
        {...other}
        styles={customStyles}
      />
    </>
  );
});

export default SingleSelect;

'''
'''--- playgrounds/react/next.config.js ---
/** @type {import('next').NextConfig} */
require('dotenv').config();
const nextConfig = {
  reactStrictMode: true,
  env: {
    MINTBASE_API_KEY: process.env.MINTBASE_API_KEY,
    NEAR_NETWORK: process.env.NEAR_NETWORK,
    NEAR_DATA_ENV: process.env.NEAR_DATA_ENV,
    EVERYTHING_API: process.env.EVERYTHING_API
  },
  webpack: (config) =>{
    config.resolve.fallback = { fs: false };

    return config;
  },
  images: {
    domains: ["everything-1.s3.us-east-1.amazonaws.com", "localhost", "placeimg.com", "arweave.net"],
  },
};

module.exports = nextConfig;

'''
'''--- playgrounds/react/package.json ---
{
  "name": "everything-react-playground",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "PORT=3050 next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@auth0/nextjs-auth0": "^2.0.0",
    "@everything-sdk-js/data": "*",
    "@everything-sdk-js/react": "*",
    "@everything-sdk-js/sdk": "*",
    "@mintbase-js/data": "^0.1.0-alpha-10",
    "@mintbase-js/react": "^0.1.0-alpha-10",
    "@mintbase-js/sdk": "^0.1.0-alpha-9",
    "@near-wallet-selector/core": "^7.3.0",
    "@near-wallet-selector/modal-ui": "^7.3.0",
    "@tanstack/react-query": "^4.19.1",
    "@types/react": "^18.0.26",
    "daisyui": "^2.42.1",
    "eslint": "8.28.0",
    "eslint-config-next": "13.0.5",
    "graphql-request": "^5.0.0",
    "next": "13.0.5",
    "next-http-proxy-middleware": "^1.2.5",
    "next-transpile-modules": "^10.0.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-dropzone": "^14.2.3",
    "react-select": "^5.7.0",
    "react-spinners": "^0.13.7",
    "react-webcam": "^7.0.1",
    "sharp": "^0.31.3",
    "swiper": "^8.4.5"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.13",
    "postcss": "^8.4.19",
    "tailwindcss": "^3.2.4"
  }
}

'''
'''--- playgrounds/react/pages/_app.js ---
import { UserProvider } from "@auth0/nextjs-auth0/client";
import { EverythingProvider } from "@everything-sdk-js/react";
import {
  QueryClient,
  QueryClientProvider
} from "@tanstack/react-query";
import { useState } from "react";
import "swiper/css";
import "swiper/css/effect-cards";
import "swiper/css/navigation";
import "swiper/css/pagination";
import { WalletContextProvider } from "@mintbase-js/react";
import "../styles/globals.css";

function App({ Component, pageProps }) {
  const [queryClient] = useState(() => new QueryClient());
  const getLayout = Component.getLayout || ((page) => page);

  return (
    <>
      <UserProvider>
        <WalletContextProvider>
          <EverythingProvider>
            <QueryClientProvider client={queryClient}>
              {getLayout(<Component {...pageProps} />)}
            </QueryClientProvider>
          </EverythingProvider>
        </WalletContextProvider>
      </UserProvider>
    </>
  );
}

export default App;

'''
'''--- playgrounds/react/pages/api/auth/[...auth0].js ---
import { handleAuth } from "@auth0/nextjs-auth0";

export default handleAuth();
'''
'''--- playgrounds/react/pages/api/graphql.js ---
import { getAccessToken } from "@auth0/nextjs-auth0";
import httpProxyMiddleware from "next-http-proxy-middleware";

// Middleware to automatically attach access tokens to graphQL requests going to the API
export default async function handler(req, res) {
  const { accessToken } = await getAccessToken(req, res);
  
  return httpProxyMiddleware(req, res, {
    target: process.env.NEXT_PUBLIC_EVERYTHING_API_URL,
    pathRewrite: [
      {
        patternStr: "^/api/graphql",
        replaceStr: "",
      },
    ],
    changeOrigin: true,
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });
}

'''
'''--- playgrounds/react/pages/create/index.js ---
import Head from "next/head";
import { useState } from "react";
import Collapse from "../../components/Collapse";
import Layout from "../../components/Layout";
import CreateMedia from "../../components/Create/CreateMedia";
import CreateThing from "../../components/Create/CreateThing";
import MintThing from "../../components/Create/MintThing";

export default function Create() {
  const [showCreateThing, setShowCreateThing] = useState(true);
  const [showCreateMedia, setShowCreateMedia] = useState(true);
  const [showMintThing, setShowMintThing] = useState(true);
  const [defaultThingId, setDefaultThingId] = useState("");

  return (
    <>
      <Head>
        <title>everything create</title>
        <meta name="description" content="playground for everything sdk js" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="flex flex-col items-center h-full w-full">
        <p className="text-4xl m-8">create</p>
        <div className="flex flex-col gap-4 w-3/4">
          <Collapse
            tabIndex={0}
            title={"create thing"}
            checked={showCreateThing}
            setChecked={setShowCreateThing}
          >
            <CreateThing setDefaultThingId={setDefaultThingId} />
          </Collapse>
          <Collapse
            tabIndex={1}
            title={"create media"}
            checked={showCreateMedia}
            setChecked={setShowCreateMedia}
          >
            <CreateMedia defaultThingId={defaultThingId} />
          </Collapse>
          <Collapse
            tabIndex={2}
            title={"mint thing"}
            checked={showMintThing}
            setChecked={setShowMintThing}
          >
            <MintThing defaultThingId={defaultThingId} />
          </Collapse>
        </div>
      </main>
    </>
  );
}

Create.getLayout = function getLayout(page) {
  return <Layout>{page}</Layout>;
};

'''
'''--- playgrounds/react/pages/explore/index.js ---
import Head from "next/head";
import { useEffect, useState } from "react";
import Request, { options } from "../../components/Explore/Request";
import Response from "../../components/Explore/Response";
import Layout from "../../components/Layout";

export default function Explore() {
  const [query, setQuery] = useState(0);
  const [param, setParam] = useState("");
  const [data, setData] = useState("");
  const [error, setError] = useState("");

  useEffect(() => {
    setData("");
    setError("");
  }, [query]);

  const runQuery = async () => {
    const { data, error } = await options[query].fn(param);
    setData(data);
    setError(error);
  };

  return (
    <>
      <Head>
        <title>everything explore</title>
        <meta name="description" content="explore for everything sdk js" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="flex flex-col items-center h-full w-full">
        <p className="text-4xl m-8">explore</p>
        <div className="w-1/2">
          <Request
            query={query}
            setQuery={setQuery}
            param={param}
            setParam={setParam}
            runQuery={runQuery}
          />
          <br />
          <div className="h-96">
            <Response data={data} error={error} />
          </div>
        </div>
      </main>
    </>
  );
}

Explore.getLayout = function getLayout(page) {
  return <Layout>{page}</Layout>;
};

'''
'''--- playgrounds/react/pages/index.js ---
import { useUser } from "@auth0/nextjs-auth0/client";
import "@near-wallet-selector/modal-ui/styles.css";
import Head from "next/head";
import Link from "next/link";
import { useWallet } from "@mintbase-js/react";
import Layout from "../components/Layout";

export default function Home() {
  const { connect, disconnect, activeAccountId, isWalletSelectorSetup } =
    useWallet();
  const { user, isLoading } = useUser();

  return (
    <>
      <Head>
        <title>everything sdk js</title>
        <meta name="description" content="example app for everything sdk js" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="flex flex-col items-center h-full w-full">
        <br />
        <br />
        <div className="card w-3/4 bg-base-100 shadow-xl">
          <div className="card-body">
            <h2 className="card-title">connect to use the tools</h2>
            <div className="divider"></div>
            <div className="flex grid-cols-2 gap-4 w-full">
              <div className="flex flex-1 flex-col text-center">
                <p className="text-xl">everything</p>
                <div>
                  {isLoading ? null : (
                    <>
                      {user ? (
                        <>
                          <p className="mb-2">
                            you are logged in as {user.nickname}
                          </p>
                          <Link href="/api/auth/logout">
                            <button className="btn normal-case">
                              disconnect
                            </button>
                          </Link>
                        </>
                      ) : (
                        <>
                          <p className="mb-2">you are not logged in</p>
                          <Link href="/api/auth/login">
                            <button className="btn normal-case">connect</button>
                          </Link>
                        </>
                      )}
                    </>
                  )}
                </div>
              </div>
              <div className="flex flex-1 flex-col text-center">
                <p className="text-xl">NEAR</p>
                <div>
                  {isWalletSelectorSetup ? (
                    <div>
                      {activeAccountId ? (
                        <>
                          <p className="mb-2">
                            you are logged in as {activeAccountId}
                          </p>
                          <button
                            className="btn normal-case"
                            onClick={disconnect}
                          >
                            disconnect
                          </button>
                        </>
                      ) : (
                        <>
                          <p className="mb-2">you are not connected to NEAR</p>
                          <button className="btn normal-case" onClick={connect}>
                            connect
                          </button>
                        </>
                      )}
                    </div>
                  ) : (
                    <div>Waiting for wallet selector components...</div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
        <br />
        <div className="flex flex-col sm:flex-row grid-cols-3 gap-4 w-3/4 justify-center">
          <div className="card flex-1 bg-base-100 shadow-xl">
            <Link href="/create">
              <div className="card-body">
                <h2 className="card-title">create &rarr;</h2>
                <p>create things and media</p>
              </div>
            </Link>
          </div>
          <div className="card flex-1 bg-base-100 shadow-xl">
            <Link href="/explore">
              <div className="card-body">
                <h2 className="card-title">explore &rarr;</h2>
                <p>use the query tool to fetch data</p>
              </div>
            </Link>
          </div>
          <div className="card flex-1 bg-base-100 shadow-xl">
            <Link href="/transact">
              <div className="card-body">
                <h2 className="card-title">transact &rarr;</h2>
                <p>test a sample marketplace</p>
              </div>
            </Link>
          </div>
        </div>
      </main>
    </>
  );
}

Home.getLayout = function getLayout(page) {
  return <Layout>{page}</Layout>;
};

'''
'''--- playgrounds/react/pages/transact/index.js ---
import Head from "next/head";
import Box from "../../components/Box";
import Layout from "../../components/Layout";
import EcosystemMarket from "../../components/Transact/EcosystemMarket";
import EverythingMarket from "../../components/Transact/EverythingMarket";
import PersonalMarket from "../../components/Transact/PersonalMarket";
import PersonalWallet from "../../components/Transact/PersonalWallet";

export default function Transact() {
  return (
    <>
      <Head>
        <title>everything transact</title>
        <meta
          name="description"
          content="sample marketplace for everything sdk js"
        />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="flex flex-col flex-1 items-center">
        <div className="flex flex-1 gap-2 md:w-4/5 mt-8">
          {/* <div className="flex mb-2 h-32 w-full">
            <Box>
              <button className="btn" onClick={handleDepositStorage}>
                deposit storage
              </button>
            </Box>
          </div> */}
          <div className="flex flex-1 flex-col">
            <Box>
              <PersonalWallet />
            </Box>
          </div>
          <div className="flex flex-1 flex-col gap-2">
            <Box>
              <PersonalMarket />
            </Box>
            <Box>
              <EcosystemMarket />
            </Box>
            <Box>
              <EverythingMarket />
            </Box>
          </div>
        </div>
      </main>
    </>
  );
}

Transact.getLayout = function getLayout(page) {
  return <Layout>{page}</Layout>;
};

'''
'''--- playgrounds/react/postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

'''
'''--- playgrounds/react/styles/globals.css ---
html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
  body {
    color: white;
    background: black;
  }
}

@tailwind base;
@tailwind components;
@tailwind utilities;

#media-container {
  height: 384px;
  width: 512px;
}

video {
  height: 100%;
  width: 100%;
}

.swiper {
  width: 100%;
  height: 100%;
}

.swiper-slide {
  text-align: center;
  font-size: 18px;
  background: #1f2937;
  border-radius: 0 0 1rem 1rem;

  /* Center slide text vertically */
  display: -webkit-box;
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
  -webkit-box-align: center;
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

.swiper-slide img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 0 0 1rem 1rem;
}

.swiper-pagination-bullet {
  width: 36px;
  height: 36px;
  opacity: 1;
  background: rgba(255, 255, 255, 0.2);
}

.swiper-pagination-bullet-active {
  color: #fff;
  background: #007aff;
  background: rgba(255, 255, 255, 0.6);
}
'''
'''--- playgrounds/react/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [require("daisyui")],
}
'''