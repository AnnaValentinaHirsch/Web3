*GitHub Repository "JorgeCuauro/NearP2PBackend"*

'''--- Cargo.toml ---
[package]
name = "near-p2-p"
version = "0.1.0"
authors = ["NEAR Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "=4.0.0-pre.9"
serde = { version = "1.0" }
serde_json = "1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- README.md ---
**NEAR-Dex**

It’s all about to create a Peer to Peer (P2P) DAPP to allow change your’s NEAR tokens in a easy, secure and fast way.

A Decentralized Wallet that will provide P2P like Binance or Airtm where you can change your available Crypto’s in local money, fiat, other cryptos. Using your services online that are available already.

The idea is similiar to our friend @FritzWorm NearWalletDapp 5.

**Issue & Solution :thinking:**

At the moment people ask where they can change their NEAR and do not get a way to do it quickly and transparently.

This P2P feature will ease the process where people come into crypto, will help them in daily basic sending money/remittances and NEAR protocol will get a lot of transactions and volume helping REF Finance with liquidity from investors that will come with the mass adoption.

**The process**

We must take into account several points of utmost importance that will guarantee the security and transparency of the portal.

    * User reputation.
    * Smart contract to guarantee the transparency of each request.
    * Broker Near account that will be responsible for showing the available balance.
    * There will be a maximum amount of transactions depending on the amounts to be mobilized.

**User experience**

    * The user login into the near-dex, they can login using the near wallet account.
    * Then, click on P2P going to the Offers. It is a search for offers of FIAT vs CRYPTO.
    * The user can filter the available payment options like local bank, zelle, airtm, american bank, paypal, etc.
    * In the list of offers you will see the minimum and maximum amounts per user additional to the reputation.
    * Open new transaction and wait comunication via mail, chat and text messages.
    * The user wait for that messages, check the deposit and close the transaction.
    * Finally gives feedback on the transaction.
    * The user can leave their available balance on the platform for future operations.

If the transaction does not culminate for any reason within the established time range, it will move to a mediation process where it is necessary to intervene to complete the process successfully and avoid any possibility of fraud.

**Some Info About**

https://www.canva.com/design/DAExsPCMuI0/_08KII_0aQ9ynw7zYJ3ZXQ/view?utm_content=DAExsPCMuI0&utm_campaign=designshare&utm_medium=link&utm_source=publishsharelink

## Screens

A design was made to log into the application, validating that the user has a Near wallet user, and then enter.

![Login](https://user-images.githubusercontent.com/96194326/147897410-59ac6149-c1bf-4ad7-8a79-decfaf546162.png)

>Login

![Connect with Near](https://user-images.githubusercontent.com/96194326/147897597-59a943e4-34ff-4496-a222-006334ccaed9.jpeg)

>Connect with NEAR

In this screen it is possible to indicate if it is going to be imported to a different account.

![Connecting with](https://user-images.githubusercontent.com/96194326/147897797-643ddaae-6176-4165-b84f-b2967b128545.png)
>Connecting to the selected account 

![Wallet](https://user-images.githubusercontent.com/9405072/157555575-48d36153-368e-4892-a9bd-edd89b8be415.png)
>Wallet

![Trade - p2p](https://user-images.githubusercontent.com/9405072/157557098-334c0716-de78-4314-86da-51de5449960d.png)
>List of purchase and sale of cryptocurrencies

![Terms and conditions - Sell](https://user-images.githubusercontent.com/9405072/157559250-611bd816-974d-48e5-a16b-51dab6c594b9.png)
>Sale order

![Account data](https://user-images.githubusercontent.com/9405072/157559296-ee28037e-40f5-479a-ba25-299d5d690f56.png)
>Account data

---
Site Testnet NETWORK: Testnet

https://testnet.nearp2p.com/#/login

Site Mainnet NETWORK: Mainnet

https://app.nearp2p.com/#/login

'''
'''--- package-lock.json ---
{
  "name": "NearP2PBackend",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {}
}

'''
'''--- package.json ---
{}

'''
'''--- src/buy.rs ---
use crate::*;

#[near_bindgen]
impl NearP2P {
    /// Returns the order object loaded in contract
    /// Params: campo: String, valor: String
    /*pub fn get_offers_buy(self, amount: Option<U128>,
        fiat_method: Option<i128>,
        payment_method: Option<i128>,
        is_merchant: Option<bool>,
        owner_id: Option<AccountId>,
        status: Option<i8>,
        offer_id: Option<i128>,
        asset: Option<String>,
        signer_id: Option<AccountId>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> SearchOfferObject {
        if self.offers_buy.len() > 0 {
            search_offer(self.offers_buy, amount, fiat_method, payment_method, is_merchant, owner_id, status, offer_id, asset, signer_id, from_index, limit)
        } else {
            SearchOfferObject {
                total_index: 0,
                data: [].to_vec(),
            }
        }
    }*/

    /// Set the offer buy object into the contract
    /// Params: owner_id: String, asset: String, exchange_rate: String, amount: String
    /// min_limit: String, max_limit: String, payment_method_id: String, status: i8
    /// This is a list of offers for buying operations, will be called by the user
    #[payable]
    pub fn set_offers_buy(&mut self
        , asset: String
        , exchange_rate: String
        , amount: U128
        , min_limit: U128
        , max_limit: U128
        , payment_method: Vec<PaymentMethodsOfferObject>
        , fiat_method: i128
        , time: i64
        , terms_conditions: String
    ) -> Promise {
        require!(env::attached_deposit() >= 100000000000000000000000, "you have to deposit a minimum 0.1 Near");
        
        let merchant = self.merchant.get(&env::signer_account_id()).expect("the user is not in the list of users");
        
        #[warn(unused_assignments)]
        let contract_name = self.contract_list.get(&env::signer_account_id()).expect("the user does not have a sub contract deployed");
        
        require!(contract_name.type_contract != 2, "must have a deployed a merchant contract");

        if asset == "NEAR".to_string() {
            ext_subcontract::block_balance_near(
                amount,
                contract_name.contract.clone(),
                0,
                GAS_FOR_BLOCK,
            ).then(
                int_buy::on_set_offers_buy(merchant.is_merchant
                , env::signer_account_id()
                , asset
                , exchange_rate
                , amount
                , min_limit
                , max_limit
                , payment_method
                , fiat_method
                , time
                , terms_conditions
                , env::current_account_id()
                , 0
                , Gas(15_000_000_000_000)
            ))
        } else {
            let contract_ft = self.ft_token_list.get(&asset).expect("El ft_token subministrado en la oferta es incorrecto");

            ext_subcontract::block_balance_token(
                contract_ft.contract,
                asset.clone(),
                amount,
                contract_name.contract.clone(),
                0,
                GAS_FOR_BLOCK,
            ).then(
                int_buy::on_set_offers_buy(merchant.is_merchant
                , env::signer_account_id()
                , asset
                , exchange_rate
                , amount
                , min_limit
                , max_limit
                , payment_method
                , fiat_method
                , time
                , terms_conditions
                , env::current_account_id()
                , 0
                , Gas(15_000_000_000_000)
            ))
        }
    }

    pub fn on_set_offers_buy(&mut self, merchant: bool
        , owner_id: AccountId
        , asset: String
        , exchange_rate: String
        , amount: U128
        , min_limit: U128
        , max_limit: U128
        , payment_method: Vec<PaymentMethodsOfferObject>
        , fiat_method: i128
        , time: i64
        , terms_conditions: String
    ) -> i128 {
        assert!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error bloquear balance token".as_ref());
        }

        
        
        if near_sdk::serde_json::from_slice::<bool>(&result.unwrap()).expect("bool") { 
            self.offer_buy_id += 1;
            let offer_buy_id = self.offer_buy_id;

            let data = OfferObject {
                offer_id: offer_buy_id,
                owner_id: owner_id.clone(),
                asset: asset.clone(),
                exchange_rate: exchange_rate.clone(),
                amount: amount.0,
                remaining_amount: amount.0,
                min_limit: min_limit.0,
                max_limit: max_limit.0,
                payment_method: payment_method.clone(),
                fiat_method: fiat_method,
                is_merchant: merchant,
                time: time,
                terms_conditions: terms_conditions.clone(),
                status: 1,
            };

            self.offers_buy.insert(&offer_buy_id, &data);

            env::log_str(
                &json!({
                    "type": "set_offers_buy",
                    "params": {
                        "offer_id": offer_buy_id.to_string(),
                        "owner_id": owner_id.clone(),
                        "asset": asset.clone(),
                        "exchange_rate": exchange_rate.clone(),
                        "amount": amount,
                        "remaining_amount": amount,
                        "min_limit": min_limit,
                        "max_limit": max_limit,
                        "payment_method": payment_method.clone(),
                        "fiat_method": fiat_method.to_string(),
                        "is_merchant": merchant,
                        "time": time.to_string(),
                        "terms_conditions": terms_conditions.clone(),
                        "status": "1".to_string(),
                    }
                }).to_string(),
            );

            self.offer_buy_id

        } else {
            env::panic_str("el balance en la subcuenta es menor al amount suministrado")
        }
        
    }

    /*#[warn(dead_code)]
    #[payable]
    pub fn put_offers_buy(&mut self, offer_id: i128
        , asset: Option<String>
        , exchange_rate: Option<String>
        , remaining_amount: Option<U128>
        , min_limit: Option<U128>
        , max_limit: Option<U128>
        , payment_method: Option<Vec<PaymentMethodsOfferObject>>
        , fiat_method: Option<i128>
        , time: Option<i64>
        , terms_conditions: Option<String>
    ) {
        let attached_deposit = env::attached_deposit();
        assert!(
            attached_deposit >= 1,
            "you have to deposit a minimum of one yoctoNear"
        );

        let offer = self.offers_buy.iter().position(|x| x.offer_id == offer_id && x.owner_id == env::signer_account_id()).expect("Offer not found");
        
        if remaining_amount.is_some() {
            if remaining_amount.unwrap().0 < self.offers_buy[offer].remaining_amount {
                let diff_return = self.offers_buy[offer].remaining_amount - remaining_amount.unwrap().0;

                #[warn(unused_assignments)]
                let contract_name: AccountId = AccountId::new_unchecked(self.contract_list.get(&self.offers_buy[offer].owner_id.clone()).expect("the user does not have a sub contract deployed").to_string());
                
                let contract_ft: Option<AccountId>;
                let fee_deducted: u128;
                let operation_amount: u128;
                if self.offers_buy[offer].asset == "USDC".to_string() {
                    contract_ft = Some(AccountId::new_unchecked(CONTRACT_USDC.to_string()));
                    fee_deducted = 0;
                    operation_amount = diff_return;
                } else {
                    contract_ft = None;
                    fee_deducted = 0;
                    operation_amount = diff_return;
                }   
                
                ext_subcontract::transfer(
                    self.offers_buy[offer].owner_id.clone(),
                    operation_amount,
                    fee_deducted,
                    contract_ft,
                    contract_name,
                    1,
                    GAS_FOR_TRANSFER,
                ).then(
                    int_buy::on_put_offers_buy(offer_id
                    , offer
                    , asset
                    , exchange_rate
                    , remaining_amount
                    , min_limit
                    , max_limit
                    , payment_method
                    , fiat_method
                    , time
                    , terms_conditions
                    , env::current_account_id()
                    , 0
                    , BASE_GAS
                ));

            } else if remaining_amount.unwrap().0 > self.offers_buy[offer].remaining_amount {
                assert!(
                    remaining_amount.unwrap().0 <= self.offers_buy[offer].amount,
                    "the remaining amount is greater than the original amount of the offer, original amount {}, remaining amount {}.",
                    self.offers_buy[offer].amount, remaining_amount.unwrap().0
                );  
            }
        } else {
            self.offers_buy_internal(offer_id
                , offer
                , asset
                , exchange_rate
                , Some(U128(self.offers_buy[offer].remaining_amount))
                , min_limit
                , max_limit
                , payment_method
                , fiat_method
                , time
                , terms_conditions
            );
        }
    }
    

    #[private]
    fn on_put_offers_buy(&mut self, offer_id: i128
        , offer: usize
        , asset: Option<String>
        , exchange_rate: Option<String>
        , remaining_amount: Option<U128>
        , min_limit: Option<U128>
        , max_limit: Option<U128>
        , payment_method: Option<Vec<PaymentMethodsOfferObject>>
        , fiat_method: Option<i128>
        , time: Option<i64>
        , terms_conditions: Option<String>
    ) {
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error al devolver el saldo restantes".as_ref());
        }
        self.offers_buy_internal(offer_id
            , offer
            , asset
            , exchange_rate
            , remaining_amount
            , min_limit
            , max_limit
            , payment_method
            , fiat_method
            , time
            , terms_conditions
        );
    }

    #[private]
    fn offers_buy_internal(&mut self, offer_id: i128
        , offer: usize
        , asset: Option<String>
        , exchange_rate: Option<String>
        , remaining_amount: Option<U128>
        , min_limit: Option<U128>
        , max_limit: Option<U128>
        , payment_method: Option<Vec<PaymentMethodsOfferObject>>
        , fiat_method: Option<i128>
        , time: Option<i64>
        , terms_conditions: Option<String>
    ) -> OfferObject {
        if asset.is_some() {
            self.offers_buy[offer].asset = asset.unwrap();
        }
        if exchange_rate.is_some() {
            self.offers_buy[offer].exchange_rate = exchange_rate.unwrap();
        }
        if remaining_amount.is_some() {
            self.offers_buy[offer].remaining_amount = remaining_amount.unwrap().0;
        }
        if min_limit.is_some() {
            self.offers_buy[offer].min_limit = min_limit.unwrap().0;
        }
        if max_limit.is_some() {
            self.offers_buy[offer].max_limit = max_limit.unwrap().0;
        }
        if payment_method.is_some() {
            self.offers_buy[offer].payment_method = payment_method.unwrap().iter().map(|x| PaymentMethodsOfferObject {id: x.id, payment_method: x.payment_method.clone()}).collect();
        }
        if fiat_method.is_some() {
            self.offers_buy[offer].fiat_method = fiat_method.unwrap();
        }
        if time.is_some() {
            self.offers_buy[offer].time = time.unwrap();
        }
        if terms_conditions.is_some() {
            self.offers_buy[offer].terms_conditions = terms_conditions.unwrap();
        }

        env::log_str("Offer updated");
        OfferObject {
            offer_id: offer_id,
            owner_id: self.offers_buy[offer].owner_id.clone(),
            asset: String::from(self.offers_buy[offer].asset.clone()),
            exchange_rate: String::from(self.offers_buy[offer].exchange_rate.clone()),
            amount: self.offers_buy[offer].amount,
            remaining_amount: self.offers_buy[offer].remaining_amount,
            min_limit: self.offers_buy[offer].min_limit,
            max_limit: self.offers_buy[offer].max_limit,
            payment_method: self.offers_buy[offer].payment_method.iter().map(|x| PaymentMethodsOfferObject {id: x.id, payment_method: x.payment_method.clone()}).collect(),
            fiat_method: self.offers_buy[offer].fiat_method,
            is_merchant: self.offers_buy[offer].is_merchant,
            time: self.offers_buy[offer].time,
            terms_conditions: String::from(self.offers_buy[offer].terms_conditions.clone()),
            status: self.offers_buy[offer].status,
        }
    }*/
    
    #[payable]
    pub fn delete_offers_buy(&mut self, offer_id: i128) {
        let offer = self.offers_buy.get(&offer_id).expect("Offer not found");
        
        assert!(offer.owner_id == env::signer_account_id(), "the user is not the creator of this offer");

        #[warn(unused_assignments)]
        let contract_name = self.contract_list.get(&offer.owner_id.clone()).expect("the user does not have a sub contract deployed");
        require!(contract_name.type_contract != 2, "must have a contract as a deployed merchant");

        let contract_ft: Option<AccountId>;
        let ft_token: String;
        
        if offer.asset == "NEAR".to_string() {
            contract_ft = None;
            ft_token = "NEAR".to_string();
        } else {
            contract_ft = Some(self.ft_token_list.get(&offer.asset.clone()).expect("El ft_token subministrado en la oferta es incorrecto").contract);
            ft_token = "USDC".to_string();
        }   
        
        ext_subcontract::transfer(
            offer.owner_id.clone(),
            U128(offer.remaining_amount),
            U128(0u128),
            contract_ft,
            false,
            ft_token,
            contract_name.contract.clone(),
            1,
            GAS_FOR_TRANSFER,
        ).then(int_buy::on_delete_offers_buy(
            offer_id,
            env::current_account_id(),
            0,
            Gas(80_000_000_000_000),
        ));
    }

    #[private]
    pub fn on_delete_offers_buy(&mut self, offer_buy_id: i128) {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error al eliminar".as_ref());
        }
        
        self.offers_buy.remove(&offer_buy_id);
        
        env::log_str(
            &json!({
                "type": "delete_offers_buy",
                "params": {
                    "offer_id": offer_buy_id.to_string(),
                }
            }).to_string(),
        );
    }

}
'''
'''--- src/dispute.rs ---
use crate::*;

#[near_bindgen]
impl NearP2P {
    pub fn set_disputer(&mut self, disputer: AccountId) -> AccountId {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        self.disputer = disputer;
        self.disputer.clone()
    }

    /// dispute order into the contract
    /// Params: offer_type: 1 = sell, 2 = buy
    // #[payable]
    pub fn order_dispute(&mut self, offer_type: i8, order_id: i128) {
        // assert_one_yocto();
        if offer_type == 1 {
            let mut order = self.orders_sell.get(&order_id).expect("Order Sell not found");
            if order.status != 3 {
                if order.owner_id == env::signer_account_id() {
                    order.status = 3;
                    order.confirmation_owner_id = 2;

                    env::log_str(
                        &json!({
                            "type": "order_dispute_owner",
                            "params": {
                                "offer_type": offer_type.to_string(),
                                "order_id": order_id.to_string(),
                                "confirmation_owner_id": "2".to_string(),
                                "status": order.status.to_string(),
                            }
                        }).to_string(),
                    );
                } else if order.signer_id == env::signer_account_id() {
                    order.status = 3;
                    order.confirmation_signer_id = 2;

                    env::log_str(
                        &json!({
                            "type": "order_dispute_signer",
                            "params": {
                                "offer_type": offer_type.to_string(),
                                "order_id": order_id.to_string(),
                                "confirmation_signer_id": "2".to_string(),
                                "status": order.status.to_string(),
                            }
                        }).to_string(),
                    );
                } else {
                    env::panic_str("Server internar error, signer not found");  
                }

                self.orders_sell.insert(&order_id, &order);

            } else {
                env::panic_str("The sales order is already in dispute");
            }
        } else if offer_type == 2 {
            let mut order = self.orders_buy.get(&order_id).expect("Order buy not found");
            if order.status != 3 {
                if order.owner_id == env::signer_account_id() {
                    order.status = 3;
                    order.confirmation_owner_id = 2;
                    env::log_str(
                        &json!({
                            "type": "order_dispute_owner",
                            "params": {
                                "offer_type": offer_type.to_string(),
                                "order_id": order_id.to_string(),
                                "confirmation_owner_id": "2".to_string(),
                                "status": order.status.to_string(),
                            }
                        }).to_string(),
                    );
                } else if order.signer_id == env::signer_account_id() {
                    order.status = 3;
                    order.confirmation_signer_id = 2;

                    env::log_str(
                        &json!({
                            "type": "order_dispute_signer",
                            "params": {
                                "offer_type": offer_type.to_string(),
                                "order_id": order_id.to_string(),
                                "confirmation_signer_id": "2".to_string(),
                                "status": order.status.to_string(),
                            }
                        }).to_string(),
                    );
                } else {
                    env::panic_str("Server internar error, signer not found");  
                }
                self.orders_buy.insert(&order_id, &order);
            } else {
                env::panic_str("The sales order is already in dispute");
            }
        }  else {
            env::panic_str("Invalid offer type");
        }
    }
    
    pub fn dispute(&mut self, offer_type: i8, order_id: i128, token: String) {
        if KEY_TOKEN == token {
            if offer_type == 1 {
                let mut order = self.orders_sell.get(&order_id).expect("Order Sell not found");
                if order.status != 3 {
                    order.status = 3;
                    order.confirmation_owner_id = 2;
                    order.confirmation_signer_id = 2;

                    self.orders_sell.insert(&order_id, &order);

                    env::log_str("Order sell in dispute");
                } else {
                    env::panic_str("The sales order is already in dispute");
                }
            } else if offer_type == 2 {
                let mut order = self.orders_buy.get(&order_id).expect("Order buy not found");
                if order.status != 3 {
                    order.status = 3;
                    order.confirmation_owner_id = 2;
                    order.confirmation_signer_id = 2;

                    self.orders_buy.insert(&order_id, &order);

                    env::log_str("Order buy in dispute");
                } else {
                    env::panic_str("The sales order is already in dispute");
                }
            }  else {
                env::panic_str("Invalid offer type");
            }
        } else {
            env::panic_str("Invalid Key_token");
        }
    }

    pub fn resolve_dispute(&mut self,
        confirmation: bool,
        offer_type: i8,
        order_id: i128
    ) {
        require!(self.disputer == env::signer_account_id(), "Only disputer");
        let contract_ft: Option<AccountId>;
        let ft_token: String;
        let mut status: i8;
        match confirmation {
            true => {
                match offer_type {
                    1 => {
                        let order = self.orders_sell.get(&order_id).expect("Order Sell not found");
                        
                        status = order.status;
                        if order.status == 1 {
                            status = 2;
                        }
                        
                        let offer = self.offers_sell.get(&order.offer_id).expect("Offer sell not found");
        
                        #[warn(unused_assignments)]
                        let contract_name = self.contract_list.get(&order.signer_id).expect("the user does not have a sub contract deployed");
        
                        match offer.asset.as_str(){
                            "NEAR" => {
                                contract_ft = None;
                                ft_token = "NEAR".to_string();
                            },
                            _=> {
                                contract_ft = Some(self.ft_token_list.get(&offer.asset.clone()).expect("El ft_token subministrado en la oferta es incorrecto").contract);//Some(AccountId::new_unchecked(CONTRACT_USDC.to_string()));
                                ft_token = offer.asset.clone();
                            },
                        };
                        
                        ext_subcontract::transfer(
                            order.owner_id.clone(),
                            U128(order.operation_amount),
                            U128(order.fee_deducted),
                            contract_ft,
                            false,
                            ft_token,
                            contract_name.contract.clone(),
                            2,
                            GAS_FOR_TRANSFER,
                        ).then(int_process::on_confirmation(
                            status,
                            1,
                            /*ContractList{contract: contract_name.contract.clone(), type_contract: contract_name.type_contract.clone()},
                            self.orders_sell[i].signer_id.clone(),*/
                            order.clone(),
                            false,
                            order.confirmation_owner_id,
                            order.confirmation_signer_id,
                            1,
                            env::current_account_id(),
                            0,
                            BASE_GAS,
                        ));
                
                    }, 
                    2 => {
                        let order = self.orders_buy.get(&order_id).expect("Order buy not found");
                        
                        status = order.status;
                        if order.status == 1 {
                            status = 2;
                        }
        
                        let offer = self.offers_buy.get(&order.offer_id).expect("Offer buy not found");
        
                        #[warn(unused_assignments)]
                        let contract_name = self.contract_list.get(&order.owner_id).expect("the user does not have a sub contract deployed");
                        
                        match offer.asset.as_str(){
                            "NEAR" => {
                                contract_ft = None;
                                ft_token = "NEAR".to_string();
                            },
                            _=> {
                                contract_ft = Some(self.ft_token_list.get(&offer.asset.clone()).expect("El ft_token subministrado en la oferta es incorrecto").contract);
                                ft_token = offer.asset.clone();
                            },
                        };
                        
                        ext_subcontract::transfer(
                            order.signer_id.clone(),
                            U128(order.operation_amount),
                            U128(order.fee_deducted),
                            contract_ft,
                            false,
                            ft_token,
                            contract_name.contract.clone(),
                            2,
                            GAS_FOR_TRANSFER,
                        ).then(int_process::on_confirmation(
                            status,
                            2,
                            /*ContractList{contract: contract_name.contract.clone(), type_contract: contract_name.type_contract.clone()},
                            self.orders_buy[i].owner_id.clone(),*/
                            order.clone(),
                            false,
                            order.confirmation_owner_id,
                            order.confirmation_signer_id,
                            1,
                            env::current_account_id(),
                            0,
                            BASE_GAS,
                        ));
                    },
                    _=> env::panic_str("Invalid offer type"),
                }
            },
            _=> {
                match offer_type {
                    1 => {
                        let order = self.orders_sell.get(&order_id).expect("Order Sell not found");
                        
                        let offer = self.offers_sell.get(&order.offer_id).expect("Offer Sell not found");
                        status = order.status;
                        if order.status == 1 || order.status == 2 {
                            status = 4;
                        }

                        #[warn(unused_assignments)]
                        let contract_name = self.contract_list.get(&order.signer_id).expect("the user does not have a sub contract deployed");

                        match offer.asset.as_str(){
                            "NEAR" => {
                                contract_ft = None;
                                ft_token = "NEAR".to_string();
                            },
                            _=> {
                                contract_ft = Some(self.ft_token_list.get(&offer.asset.clone()).expect("El ft_token subministrado en la oferta es incorrecto").contract);
                                ft_token = offer.asset.clone();
                            },
                        };
                        
                        ext_subcontract::transfer(
                            order.signer_id.clone(),
                            U128(order.operation_amount),
                            U128(0),
                            contract_ft,
                            false,
                            ft_token,
                            contract_name.contract.clone(),
                            1,
                            GAS_FOR_TRANSFER,
                        ).then(int_process::on_confirmation(
                            status,
                            1,
                            /*ContractList{contract: contract_name.contract.clone(), type_contract: contract_name.type_contract.clone()},
                            self.orders_sell[i].signer_id.clone(),*/
                            order.clone(),
                            false,
                            order.confirmation_owner_id,
                            order.confirmation_signer_id,
                            3,
                            env::current_account_id(),
                            0,
                            GAS_ON_CONFIRMATION,
                        ));
                    },
                    2 => {
                        let order = self.orders_buy.get(&order_id).expect("Order buy not found");

                        let offer = self.offers_buy.get(&order.offer_id).expect("Offer buy not found");
                        status = order.status;
                        if order.status == 1 || order.status == 2 {
                            status = 4;
                        }

                        #[warn(unused_assignments)]
                        let contract_name = self.contract_list.get(&order.owner_id).expect("the user does not have a sub contract deployed");

                        match offer.asset.as_str(){
                            "NEAR" => {
                                contract_ft = None;
                                ft_token = "NEAR".to_string();
                            },
                            _=> {
                                contract_ft = Some(self.ft_token_list.get(&offer.asset.clone()).expect("El ft_token subministrado en la oferta es incorrecto").contract);
                                ft_token = offer.asset.clone();
                            },
                        };

                        ext_subcontract::transfer(
                            order.owner_id.clone(),
                            U128(order.operation_amount),
                            U128(0),
                            contract_ft,
                            false,
                            ft_token,
                            contract_name.contract.clone(),
                            1,
                            GAS_FOR_TRANSFER,
                        ).then(int_process::on_confirmation(
                            status,
                            2,
                            /*ContractList{contract: contract_name.contract.clone(), type_contract: contract_name.type_contract.clone()},
                            self.orders_buy[i].owner_id.clone(),*/
                            order.clone(),
                            false,
                            order.confirmation_owner_id,
                            order.confirmation_signer_id,
                            3,
                            env::current_account_id(),
                            0,
                            BASE_GAS,
                        ));
                    },
                    _=> env::panic_str("Invalid offer type"),
                }
            },
        }
        
    }
}
'''
'''--- src/external.rs ---
use crate::*;

#[ext_contract(ext_usdc)]
trait ExtTranferUsdc {
    fn ft_transfer(&mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>
    );

    fn storage_deposit(&mut self, registration_only: bool,
        account_id: AccountId);

    fn ft_balance_of(self, account_id: String);
}

#[ext_contract(ext_subcontract)]
trait ExtSubContract {
    fn new(
        owner_id: AccountId,
        user_admin: AccountId, 
        vault: AccountId
    );

    fn transfer(&mut self,
        receiver_id: AccountId,
        operation_amount: U128,
        fee_deducted: U128,
        contract_ft: Option<AccountId>,
        retiro: bool,
        ft_token: String,
    );

    fn get_balance_near(self, balance: String) -> Balance;

    fn get_balance_block_token(self, ft_token: String) -> Balance;

    fn get_balance_block_total(self) -> Balance;

    fn delete_contract(&mut self);

    fn block_balance_near(&mut self, amount: U128) -> bool;

    fn block_balance_token(&mut self,
        contract_ft: AccountId,
        ft_token: String,
        amount: U128
    ) -> bool;

}
'''
'''--- src/internal.rs ---
use crate::*;

#[ext_contract(int_sub_contract)]
trait IntSubContract {
    //fn on_ft_balance_of(&mut self);

    fn on_delete_contract(&mut self,
        signer_id: AccountId,
        sub_contract: AccountId
    );
    
    fn on_delete_contract_list(&mut self,
        signer_id: AccountId
    );

    fn on_delete_withdraw_near(&mut self,
        sub_contract: AccountId,
        signer_id: AccountId
    ) -> Promise;
    
    fn on_withdraw_near(&mut self,
        sub_contract: AccountId,
        signer_id: AccountId
    ) -> Promise;

    fn on_withdraw_token_block(&mut self,
        sub_contract: AccountId,
        signer_id: AccountId,
        ft_token: String,
    ) -> Promise;

    fn on_withdraw_token(&mut self,
        sub_contract: AccountId,
        signer_id: AccountId,
        ft_token: String,
        balance_general: U128,
    ) -> Promise;

    fn on_listar_token_activo(&mut self, signer_id: AccountId, ft_token: String);
}

#[ext_contract(int_buy)]
trait IntBuy {
    fn on_set_offers_buy(&mut self, merchant: bool
        , owner_id: AccountId
        , asset: String
        , exchange_rate: String
        , amount:  U128
        , min_limit: U128
        , max_limit: U128
        , payment_method: Vec<PaymentMethodsOfferObject>
        , fiat_method: i128
        , time: i64
        , terms_conditions: String
    ) -> i128;

    /*fn on_put_offers_buy(&mut self, offer_id: i128
        , offer: usize
        , asset: Option<String>
        , exchange_rate: Option<String>
        , remaining_amount: Option<U128>
        , min_limit: Option<U128>
        , max_limit: Option<U128>
        , payment_method: Option<Vec<PaymentMethodsOfferObject>>
        , fiat_method: Option<i128>
        , time: Option<i64>
        , terms_conditions: Option<String>
    );*/

    fn on_delete_offers_buy(&mut self, offer_buy_id: i128);
}

#[ext_contract(int_offer)]
trait IntOffer {
    fn on_accept_offer_sell(&mut self, offer: OfferObject
        , amount: U128
        , payment_method: i128
        , datetime: String
        , rate: f64
        , referente: Option<AccountId>
    );

    /*fn on_delete_contract_user(&mut self, signer_id: AccountId, sub_contract: AccountId);

    fn on_delete_contract_list_user(&mut self, signer_id: AccountId);*/
}

#[ext_contract(int_process)]
trait IntProcess {
    fn on_confirmation(&mut self,
        status: i8,
        order_type: i8,
        /*data_contract: ContractList, 
        signer_id: AccountId,*/
        order: OrderObject,
        confirmacion: bool,
        confirmation_owner_id: i8,
        confirmation_signer_id: i8,
        confirmation_current: i8,
    );
}
'''
'''--- src/lib.rs ---
/*
NEAR-Dex

It’s all about to create a Peer to Peer (P2P) DAPP to allow change your’s NEAR tokens in a easy, 
secure and fast way.
A Decentralized Wallet that will provide P2P like Binance or Airtm where you can change your 
available Crypto’s in local money, fiat, other cryptos. Using your services online that are available already.
The idea is similiar to our friend @FritzWorm NearWalletDapp 5.

Issue & Solution thinking

At the moment people ask where they can change their NEAR and do not get a way to do it quickly and transparently.
This P2P feature will ease the process where people come into crypto, will help them in daily basic s
ending money/remittances and NEAR protocol will get a lot of transactions and volume helping REF Finance with 
liquidity from investors that will come with the mass adoption.
The process
prueba
MIT license
Develop by GlobalDv @2022
*/

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use serde::Serialize;
use serde::Deserialize;
use near_sdk::{env, near_bindgen, AccountId, Promise, assert_one_yocto, ext_contract, Gas, promise_result_as_success, require, 
                serde_json::json, BorshStorageKey, PanicOnDefault}; // json_types::U128, 
use near_sdk::json_types::U128;
use std::collections::HashMap;
//near_sdk::setup_alloc!();

use near_sdk::collections::{LazyOption, UnorderedMap, UnorderedSet};

const KEY_TOKEN: &str = "qbogcyqiqO7Utwqm3VgKhxrmQIc0ROjj";
const FEE_TRANSACTION_NEAR: u128 = 30; // 0.003%

//const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_TRANSFER: Gas = Gas(25_000_000_000_000);
const GAS_FOR_BLOCK: Gas = Gas(30_000_000_000_000);
const GAS_ON_WITHDRAW_NEAR: Gas = Gas(40_000_000_000_000);
const GAS_ON_WITHDRAW_TOKEN_BLOCK: Gas = Gas(80_000_000_000_000);
const GAS_ON_WITHDRAW_TOKEN: Gas = Gas(45_000_000_000_000);
const GAS_ON_CONFIRMATION: Gas = Gas(50_000_000_000_000);
const GAS_ON_ACCEPT_OFFER_SELL: Gas = Gas(40_000_000_000_000);
const BASE_GAS: Gas = Gas(3_000_000_000_000);

//const CONSUMO_STORAGE_NEAR_SUBCONTRACT: u128 = 1412439322253799699999999;
//const CONTRACT_USDC: &str = "usdc.fakes.testnet"; // "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near";

//const INITIAL_BALANCE: Balance = 2_50_000_000_000_000_000_000_000; // 1e24yN, 0.25N
//const INITIAL_BALANCE: Balance = 1_080_000_000_000_000_000_000_000; // 1e24yN, 0.25N
const CODE: &[u8] = include_bytes!("./wasm/subcontract_p2_p_v19.wasm");
/////////////////////////////////////////////////////////////////////////////////////////////////
/// Objects Definition///////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

use crate::external::*;
use crate::internal::*;

mod external;
mod internal;
mod subcontract;
mod sell;
mod buy;
mod offer;
mod process;
mod dispute;

/*
User UserObject: Struct for the user that contains info about the logged user.
This object contains, user_id, name, last_name, phone, email, country
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct UserObject {
    user_id: AccountId,
    name: String,
    last_name: String,
    phone: String,
    email: String,
    country: String,
    mediator: bool,
    is_active: bool,
    campo1: String,
    campo2: String,
    campo3: String,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ObjectReferidos {
    wallet: AccountId,
    referente: Option<AccountId>,
    referidos: Vec<AccountId>
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PaymentMethodsOfferObject {
    id: String,
    payment_method: String,
}

/*
User OfferObject: Struct for offer that will be listed.
This object contains, order_id, owner_id, asset, exchange_rate, email, country
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct OfferObject {
    offer_id: i128,
    owner_id: AccountId,
    asset: String, // NEAR, USD
    exchange_rate: String,
    amount: u128,
    remaining_amount: u128,
    min_limit: u128,
    max_limit: u128,
    payment_method: Vec<PaymentMethodsOfferObject>, // Info concerning to payment asociated to payment contract
    fiat_method: i128,
    is_merchant: bool,
    time: i64,
    terms_conditions: String,
    status: i8, // 1: active, 2: closed
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct OrderObject {
    offer_id: i128,
    order_id: i128,
    owner_id: AccountId,
    asset: String,
    signer_id: AccountId,
    exchange_rate: String,
    operation_amount: u128,
    amount_delivered: u128,
    fee_deducted: u128,
    payment_method: i128, // Info concerning to payment asociated to payment contract
    fiat_method: i128,
    confirmation_owner_id: i8,
    confirmation_signer_id: i8,
    confirmation_current: i8,
    referente: Option<AccountId>,
    time: i64,
    datetime: String,
    terms_conditions: String,
    status: i8, // 1 = pending, 2 = completed, 3 = disputed
}

/*
User MerchantObject: Struct for Merchants.
This object contains, user_id, total_orders, orders_completed, percentaje_completion, badge
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct MerchantObject {
    user_id: AccountId,
    total_orders: i64,
    orders_completed: i64,
    percentaje_completion: f64, // pioasjoidjasoi
    badge: String, //Badge that represent a merchant verified
    is_merchant: bool,
}

/*
User PaymentMethodsObject: Struct for Payments.
This object contains, id, payment_method, input1, input2, input3, input4, input5
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PaymentMethodsObject {
    id: i128,
    payment_method: String,
    input1: String,
    input2: String,
    input3: String,
    input4: String,
    input5: String,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PaymentMethodUserObject {
    user_id: AccountId,
    payment_method_id: i128,
    payment_method: String,
    desc1: String,
    input1: String,
    desc2: String,
    input2: String,
    desc3: String,
    input3: String,
    desc4: String,
    input4: String,
    desc5: String,
    input5: String,
}

/*
User FiatMethodsObject: Struct for Fiat list.
This object contains, id, fiat_method, flagcdn
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FiatMethodsObject {
    id: i128,
    fiat_method: String,
    flagcdn: String,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SearchOfferObject {
    total_index: i128,
    data: Vec<OfferObject>,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SearchOrderObject {
    total_index: i128,
    data: Vec<OrderObject>,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractList {
    contract: AccountId,
    type_contract: i8,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FtData {
    contract: AccountId,
    min_limit: u128,
}
//////////////////////////////////////////////////////////////////////////////////////////////////
/// Objects Definition////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/// 

/*
Near P2P Struct
*/
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
//#[serde(crate = "near_sdk::serde")]
pub struct NearP2P {
    owner_id: AccountId,
    // Users
    pub users: UnorderedMap<AccountId, UserObject>,
    ///Offer object
    pub offers_sell: UnorderedMap<i128, OfferObject>,
    ///Offer Sell Id
    pub offer_sell_id: i128,
    ///Offer object
    pub offers_buy: UnorderedMap<i128, OfferObject>,
    ///Order Buy Id
    pub offer_buy_id: i128,
    //Order object
    pub orders_sell: UnorderedMap<i128, OrderObject>,
    //Order object
    pub order_sell_id: i128,
    //Order object
    pub orders_buy: UnorderedMap<i128, OrderObject>,
    //Order object
    pub order_buy_id: i128,
    ///Merchant object
    pub merchant: UnorderedMap<AccountId, MerchantObject>,
    ///Payment Method object
    pub payment_method: UnorderedMap<i128, PaymentMethodsObject>,
    ///Payment Method object
    pub payment_method_user: UnorderedMap<String, PaymentMethodUserObject>,
    // Payment Method Id
    pub payment_method_id: i128,
    ///Payment Method object
    pub fiat_method: UnorderedMap<i128, FiatMethodsObject>,
    // Payment Method Id
    pub fiat_method_id: i128,

    pub vault: AccountId,

    pub administrators: UnorderedSet<AccountId>,

    pub contract_list: UnorderedMap<AccountId, ContractList>,

    pub ft_token_list: UnorderedMap<String, FtData>,

    pub activate_token_list: UnorderedMap<AccountId, Vec<String>>,

    pub disputer: AccountId,

    pub referidos: UnorderedMap<AccountId, ObjectReferidos>,
    
    pub porcentaje_referente: u128,
    
    pub porcentaje_referido: u128
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    KeyUsers,
    KeyOffersSell,
    KeyOffersBuy,
    KeyOrdersSell,
    KeyOrdersBuy,
    KeyMerchant,
    KeyPaymentMethod,
    KeyPaymentMethodUser,
    KeyFiatMethod,
    KeyAdministrators,
    KeyContractList,
    KeyFtLlist,
    KeyActivateTokenList,
    KeyReferidos,
}

/// Initializing deafult impl
/// We are using default inizialization for the structs
/*impl Default for NearP2P {
    fn default() -> Self {
        Self {
            users: UnorderedMap::new(StorageKey::KeyUsers),
            offers_sell: UnorderedMap::new(StorageKey::KeyOffersSell),
            offer_sell_id: 0,
            offers_buy: UnorderedMap::new(StorageKey::KeyOffersBuy),
            offer_buy_id: 0,
            orders_sell: UnorderedMap::new(StorageKey::KeyOrdersSell),
            order_sell_id: 0,
            orders_buy: UnorderedMap::new(StorageKey::KeyOrdersBuy),
            order_buy_id: 0,
            merchant: UnorderedMap::new(StorageKey::KeyMerchant),
            payment_method: UnorderedMap::new(StorageKey::KeyPaymentMethod),
            payment_method_user: UnorderedMap::new(StorageKey::KeyPaymentMethodUser),
            payment_method_id: 0,
            fiat_method: UnorderedMap::new(StorageKey::KeyFiatMethod),
            fiat_method_id: 0,
            vault: AccountId::new_unchecked("nearp2p.testnet".to_string()),
            administrators: UnorderedSet::new(StorageKey::KeyAdministrators)
            contract_list: UnorderedMap::new(StorageKey::KeyContractList),
            activate_token_list: UnorderedMap::new(StorageKey::KeyActivateTokenList),
            disputer: AccountId::new_unchecked("nearp2p.sputnikv2.testnet".to_string()),
            referidos: UnorderedMap::new(StorageKey::KeyReferidos),
            porcentaje_referente: 42000,
            porcentaje_referido: 5000,
        }
    }
}*/

/// Implementing Struct
#[near_bindgen]
impl NearP2P {
    /// Initializing contract
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner_id: owner_id,
            users: UnorderedMap::new(StorageKey::KeyUsers),
            offers_sell: UnorderedMap::new(StorageKey::KeyOffersSell),
            offer_sell_id: 0,
            offers_buy: UnorderedMap::new(StorageKey::KeyOffersBuy),
            offer_buy_id: 0,
            orders_sell: UnorderedMap::new(StorageKey::KeyOrdersSell),
            order_sell_id: 0,
            orders_buy: UnorderedMap::new(StorageKey::KeyOrdersBuy),
            order_buy_id: 0,
            merchant: UnorderedMap::new(StorageKey::KeyMerchant),
            payment_method: UnorderedMap::new(StorageKey::KeyPaymentMethod),
            payment_method_user: UnorderedMap::new(StorageKey::KeyPaymentMethodUser),
            payment_method_id: 0,
            fiat_method: UnorderedMap::new(StorageKey::KeyFiatMethod),
            fiat_method_id: 0,
            vault: AccountId::new_unchecked("nearp2p.testnet".to_string()),
            administrators: UnorderedSet::new(StorageKey::KeyAdministrators),
            contract_list: UnorderedMap::new(StorageKey::KeyContractList),
            ft_token_list: UnorderedMap::new(StorageKey::KeyFtLlist),
            activate_token_list: UnorderedMap::new(StorageKey::KeyActivateTokenList),
            disputer: AccountId::new_unchecked("nearp2p.sputnikv2.testnet".to_string()),
            referidos: UnorderedMap::new(StorageKey::KeyReferidos),
            porcentaje_referente: 42000,
            porcentaje_referido: 5000,
        }
    }
    /*pub fn prueba_balance(&mut self, account_id: String) -> Promise {
        let nft_contract: AccountId = CONTRACT_USDC.parse().unwrap();
        let gas_internal: Gas = Gas(1_000_000_000_000);
        ext_usdc::ft_balance_of(
            account_id,
            nft_contract,
            0,
            BASE_GAS,
        )
        .then(int_sub_contract::on_ft_balance_of(
            env::current_account_id(),
            0,
            gas_internal,
        ))
    }

    #[private]
    pub fn on_ft_balance_of(&mut self) -> String {
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("balance is None".as_ref());
        }
        let ret = near_sdk::serde_json::from_slice::<String>(&result.unwrap()).expect("balance is None");
        return ret;
    }*/
    pub fn set_ft_token(&mut self, asset: String, data: FtData) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        
        self.ft_token_list.insert(&asset, &data);

        env::log_str(
            &json!({
                "type": "set_ft_token",
                "params": {
                    "asset": asset.clone(),
                    "contract": data.contract.to_string(),
                    "min_limit": data.min_limit.to_string(),
                }
            }).to_string(),
        );
    }

    pub fn add_referido(&mut self, referente: AccountId) {
        let signer_id: AccountId = env::signer_account_id();
        let valid = self.referidos.get(&signer_id.clone());

        require!(signer_id.clone() != referente.clone(), "El referente no se puede auto referir");
        
        require!(valid.is_none(), format!("La cuenta '{}' ya fue agregada", signer_id.clone()).to_string());
        
        self.referidos.insert(&signer_id.clone(), &ObjectReferidos {
            wallet: signer_id.clone(),
            referente: Some(referente.clone()),
            referidos: Vec::new(),
        });

        let referente_add = self.referidos.get(&referente.clone());

        let mut referido: Vec<AccountId>;

        if referente_add.is_none() {
            referido = Vec::new();
            referido.push(signer_id.clone());
            
            self.referidos.insert(&referente.clone(), &ObjectReferidos {
                wallet: referente.clone(),
                referente: None,
                referidos: referido,
            });
        } else {
            let mut referido_add = self.referidos.get(&referente.clone()).expect("error").clone();
            referido_add.referidos.push(signer_id.clone());
            self.referidos.insert(&referente.clone(), &referido_add);
        }

        env::log_str(
            &json!({
                "type": "add_referido",
                "params": {
                    "referido": signer_id.clone(),
                    "referente": referente.clone(),
                }
            }).to_string(),
        );
    }
    
   
    pub fn set_admin(&mut self, user_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        
        if self.administrators.contains(&user_id) {
            env::panic_str("the user is already in the list of administrators");  
        } else {
            self.administrators.insert(&user_id);
        }
    }

    pub fn delete_admin(&mut self, user_id: AccountId) {      
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        
        if self.administrators.contains(&user_id) {
            env::panic_str("the user is already in the list of administrators");  
        } else {
            self.administrators.remove(&user_id);
        }
    }

    pub fn update_vault(&mut self, account_id: AccountId) {      
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        
        self.vault = account_id;
    }

    /// Returns the users object loaded in contract
    /// Params: user_id: AccountId
    /*pub fn get_user(self, 
        user_id: Option<AccountId>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<UserObject> {
        if self.users.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.users.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            if user_id.is_some() {
                let user = user_id.unwrap().clone();
                self.users.iter().filter(|x| x.user_id == user.to_string())
                .skip(start_index as usize)
                .take(limit)
                .map(|x| x.clone()).collect()
            } else {
                self.users.iter()
                .skip(start_index as usize)
                .take(limit)
                .map(|x| x.clone()).collect()
            }
        } else {
            [].to_vec()
        }
    }*/

    pub fn delete_user_admin(&mut self, user_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        if self.users.get(&user_id).is_some() {
            self.users.remove(&user_id);
        }
        
        if self.merchant.get(&user_id).is_some() {
            self.merchant.remove(&user_id);
        }
    }

    /// Set the users object into the contract
    /// Params: user_id: String, name: String
    /// last_name: String, phone: String, email: String, country: String
    pub fn set_user(&mut self,
        name: String,
        last_name: String,
        phone: String,
        email: String,
        country: String,
        campo1: String,
        campo2: String,
        campo3: String,
    ) -> String {
        if self.users.get(&env::signer_account_id()).is_some() {
            env::panic_str("profile already exists");
        }

        let data_user = UserObject {
            user_id: env::signer_account_id(),
            name: name.to_string(),
            last_name: last_name.to_string(),
            phone: phone.to_string(),
            email: email.to_string(),
            country: country.to_string(),
            mediator: false,
            is_active: true,
            campo1: campo1.to_string(),
            campo2: campo2.to_string(),
            campo3: campo3.to_string(),
        };
        self.users.insert(&env::signer_account_id(), &data_user);
        
        let data_merchant = MerchantObject {
            user_id: env::signer_account_id(),
            total_orders: 0,
            orders_completed: 0,
            percentaje_completion: 0.0,
            badge: "".to_string(),
            is_merchant: false,
        };
        self.merchant.insert(&env::signer_account_id(), &data_merchant);
       
        // set_merchant(user_id: user_id.to_string(), total_orders: 0, orders_completed: 0 , badge: "".to_string());
        env::log_str(
            &json!({
                "type": "set_user",
                "params": {
                    "user_id": env::signer_account_id().to_string(),
                    "name": name.to_string(),
                    "last_name": last_name.to_string(),
                    "phone": phone.to_string(),
                    "email": email.to_string(),
                    "country": country.to_string(),
                    "mediator": false,
                    "is_active": true,
                    "badge": "".to_string(),
                    "is_merchant": false,
                    "campo1": campo1.to_string(),
                    "campo2": campo2.to_string(),
                    "campo3": campo3.to_string(),
                }
            }).to_string(),
        );
        env::signer_account_id().to_string()
    }

    pub fn set_user_admin(&mut self,
        user_id: AccountId,
        name: String,
        last_name: String,
        phone: String,
        email: String,
        country: String,
        campo1: String,
        campo2: String,
        campo3: String,
    ) -> String {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        if self.users.get(&user_id).is_some() {
            env::panic_str("profile already exists");
        }
        
        let data_user = UserObject {
            user_id: user_id.clone(),
            name: name.to_string(),
            last_name: last_name.to_string(),
            phone: phone.to_string(),
            email: email.to_string(),
            country: country.to_string(),
            mediator: false,
            is_active: true,
            campo1: campo1.to_string(),
            campo2: campo2.to_string(),
            campo3: campo3.to_string(),
        };
        self.users.insert(&user_id, &data_user);
        
        let data_merchant = MerchantObject {
            user_id: user_id.clone(),
            total_orders: 0,
            orders_completed: 0,
            percentaje_completion: 0.0,
            badge: "".to_string(),
            is_merchant: false,
        };
        self.merchant.insert(&user_id, &data_merchant);
       // set_merchant(user_id: user_id.to_string(), total_orders: 0, orders_completed: 0 , badge: "".to_string());
       
       env::log_str(
            &json!({
                "type": "set_user_admin",
                "params": {
                    "user_id": user_id.to_string(),
                    "name": name.to_string(),
                    "last_name": last_name.to_string(),
                    "phone": phone.to_string(),
                    "email": email.to_string(),
                    "country": country.to_string(),
                    "mediator": false,
                    "is_active": true,
                    "badge": "".to_string(),
                    "is_merchant": false,
                    "campo1": campo1.to_string(),
                    "campo2": campo2.to_string(),
                    "campo3": campo3.to_string(),
                }
            }).to_string(),
        );
        user_id.to_string()
    }
    
    /// Set the users object into the contract
    /// Params: user_id: String, name: String
    /// name: String, last_name: String, phone: String, email: String, country: String
    pub fn put_user(&mut self, name: String
        , last_name: String
        , phone: String
        , email: String
        , country: String) {
        
        let mut users = self.users.get(&env::signer_account_id()).expect("user does not exist");
        
        users.name = name.to_string();
        users.last_name = last_name.to_string();
        users.phone = phone.to_string();
        users.email = email.to_string();
        users.country = country.to_string();
        
        self.users.insert(&env::signer_account_id(), &users);
            
        env::log_str(
            &json!({
                "type": "put_user",
                "params": {
                    "user_id": env::signer_account_id().to_string(),
                    "name": name.to_string(),
                    "last_name": last_name.to_string(),
                    "phone": phone.to_string(),
                    "email": email.to_string(),
                    "country": country.to_string(),
                    "mediator": users.mediator,
                    "is_active": users.is_active,
                }
            }).to_string(),
        );
    }

    pub fn put_users(&mut self, user_id: AccountId
        , name: String
        , last_name: String
        , phone: String
        , email: String
        , country: String
        , mediator: bool
        , is_active: bool
    ) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        
        let mut users = self.users.get(&user_id).expect("user does not exist");
        
        users.name = name.to_string();
        users.last_name = last_name.to_string();
        users.phone = phone.to_string();
        users.email = email.to_string();
        users.country = country.to_string();
        users.mediator = mediator;
        users.is_active = is_active;

        self.users.insert(&user_id, &users);
                            
        env::log_str(
            &json!({
                "type": "put_users",
                "params": {
                    "user_id": user_id.to_string(),
                    "name": name.to_string(),
                    "last_name": last_name.to_string(),
                    "phone": phone.to_string(),
                    "email": email.to_string(),
                    "country": country.to_string(),
                    "mediator": mediator,
                    "is_active": is_active,
                }
            }).to_string(),
        );
    }

    /// Returns the merchant object loaded in contract
    /*pub fn get_merchant(self,
        user_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<MerchantObject> {
        if self.merchant.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.merchant.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            if user_id.to_string() == "%".to_string() {
                self.merchant.iter()  // Return all merchants
                .skip(start_index as usize)
                .take(limit) 
                .map(|x| x.clone()).collect()
            } else {
                self.merchant.iter().filter(|x| x.user_id == user_id)
                .skip(start_index as usize)
                .take(limit)
                .map(|x| x.clone()).collect()                
            }
        } else {
            [].to_vec()
        }
    }*/

    /// Set the merchant object into the contract
    /// Params: user_id: String, total_orders: i128, orders_completed: i128
    /// badge: String
    pub fn put_merchant(&mut self, user_id: AccountId
        , total_orders: i64
        , orders_completed: i64 
        , badge: String
        , is_merchant: bool
    ) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        let mut merchant = self.merchant.get(&user_id).expect("Merchant not found");

        merchant.total_orders = total_orders;
        merchant.orders_completed = orders_completed;
        merchant.percentaje_completion = (orders_completed as f64 / total_orders as f64) * 100.0;
        merchant.badge = badge.to_string();
        merchant.is_merchant = is_merchant;

        self.merchant.insert(&user_id, &merchant);   
        
        env::log_str(
            &json!({
                "type": "put_merchant",
                "params": {
                    "user_id": user_id.to_string(),
                    "total_orders": total_orders.to_string(),
                    "orders_completed": orders_completed.to_string(),
                    "percentaje_completion": merchant.percentaje_completion.to_string(),
                    "badge": badge.to_string(),
                    "is_merchant": is_merchant,
                }
            }).to_string(),
        );
    }

    /// Returns the Payment Method object loaded in contract
    /*pub fn get_payment_method(&self,
        from_index: Option<U128>,
        limit: Option<u64>
    ) -> Vec<PaymentMethodsObject> {
        if self.payment_method.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.payment_method.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            self.payment_method.iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|x| x.clone()).collect()
        } else {
            [].to_vec()
        }
    }*/

    /// Set the Payment Method object into the contract
    /// Params: payment_method_id: String, input1: String, input2: String
    /// input3: String, input4: String, input5: String
    /// List of payment methods, will be called by the user
    /// It is used to filter wich oayment method is offering for trading
    pub fn set_payment_method(&mut self, payment_method: String
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) -> i128 {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        self.payment_method_id += 1;
        let data = PaymentMethodsObject {
            id: self.payment_method_id,
            payment_method: payment_method.clone(),
            input1: input1.clone(),
            input2: input2.clone(),
            input3: input3.clone(),
            input4: input4.clone(),
            input5: input5.clone(),
        };
        
        self.payment_method.insert(&self.payment_method_id, &data);
        
        env::log_str(
            &json!({
                "type": "set_payment_method",
                "params": {
                    "id": self.payment_method_id.to_string(),
                    "payment_method": payment_method.clone(),
                    "input1": input1.clone(),
                    "input2": input2.clone(),
                    "input3": input3.clone(),
                    "input4": input4.clone(),
                    "input5": input5.clone(),
                }
            }).to_string(),
        );
        
        self.payment_method_id
    }

     /// put the Payment Method object into the contract
    /// Params: id: i128, payment_method: String, input1: String, input2: String
    /// input3: String, input4: String, input5: String
    pub fn put_payment_method(&mut self, id: i128
        , payment_method: String
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        //self.payment_method[0].payment_method = String::from("Transferencia Bancaria 2");
        let mut pm = self.payment_method.get(&id).expect("el metodo que intenta actualizr no existe");

        pm.payment_method = payment_method.clone();
        pm.input1 = input1.to_string();
        pm.input2 = input2.to_string();
        pm.input3 = input3.to_string();
        pm.input4 = input4.to_string();
        pm.input5 = input5.to_string();
        
        self.payment_method.insert(&id, &pm.clone());

        /*for i in 0..self.payment_method_user.len() {
            if self.payment_method_user.get(i).unwrap().payment_method_id == id {
                self.payment_method_user[i].payment_method = payment_method.to_string();
                self.payment_method_user[i].desc1 = input1.to_string();
                self.payment_method_user[i].desc2 = input2.to_string();
                self.payment_method_user[i].desc3 = input3.to_string();
                self.payment_method_user[i].desc4 = input4.to_string();
                self.payment_method_user[i].desc5 = input5.to_string();
            }
        }*/
        env::log_str(
            &json!({
                "type": "put_payment_method",
                "params": {
                    "id": id.to_string(),
                    "payment_method": payment_method.to_string(),
                    "input1": input1.to_string(),
                    "input2": input2.to_string(),
                    "input3": input3.to_string(),
                    "input4": input4.to_string(),
                    "input5": input5.to_string(),
                }
            }).to_string(),
        );
        //self.merchant.get(0).unwrap().user_id.clone()
        //self.payment_method
    }

    /// delete the Payment Method object into the contract
    /// Params: id: i128
    pub fn delete_payment_method(&mut self, id: i128) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        
        self.payment_method.remove(&id).expect("Payment method does not exist");
            
        /*let data = self.payment_method_user.iter().find(|(_k, x)| x.payment_method_id == id).expect("Payment method in users does not exist").collect();

        for(let i++; i < data; i++) {
            self.payment_method_user.remove(&format!("{}:{}", data[i].)
        }
        self.payment_method_user.iter().find(|(_k, x)| x.payment_method_id == id).collect().id.to_string());
      */      
        env::log_str(
            &json!({
                "type": "delete_payment_method",
                "params": {
                    "id": id.to_string(),
                }
            }).to_string(),
        );
        //self.merchant.get(0).unwrap().user_id.clone()
        //self.payment_method
    }
    
    /// Returns the Fiat Method object loaded in contract
    /*pub fn get_fiat_method(&self,
        from_index: Option<U128>,
        limit: Option<u64>
    ) -> Vec<FiatMethodsObject> {
        if self.fiat_method.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.fiat_method.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            self.fiat_method.iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|x| x.clone()).collect()
        } else {
            [].to_vec()
        }
    }*/

    /// Set the Fiat Method object into the contract
    /// Params: fiat_method_id: String, flagcdn: String
    /// List of fiat methods, will be called by the user
    pub fn set_fiat_method(&mut self, fiat_method: String, flagcdn: String) -> i128 {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        self.fiat_method_id += 1;
        let data = FiatMethodsObject {
            id: self.fiat_method_id,
            fiat_method: fiat_method.clone(),
            flagcdn: flagcdn.clone(),
        };
        
        self.fiat_method.insert(&self.fiat_method_id, &data);
        
        env::log_str(
            &json!({
                "type": "set_fiat_method",
                "params": {
                    "id": self.fiat_method_id.to_string(),
                    "fiat_method": fiat_method.clone(),
                    "flagcdn": flagcdn.clone(),
                }
            }).to_string(),
        );
        
        self.fiat_method_id
    }

    /// Put the Fiat Method object into the contract
    /// Params: id: i128, fiat_method: String, flagcdn: String
    pub fn put_fiat_method(&mut self, id: i128
        , fiat_method: String, flagcdn: String
    ) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        
        let mut fiat = self.fiat_method.get(&id).expect("Fiat method does not exist");
        fiat.fiat_method = fiat_method.to_string();
        fiat.flagcdn = flagcdn.to_string();
        
        self.fiat_method.insert(&id, &fiat);

        env::log_str(
            &json!({
                "type": "put_fiat_method",
                "params": {
                    "id": id.to_string(),
                    "fiat_method": fiat_method.clone(),
                    "flagcdn": flagcdn.clone(),
                }
            }).to_string(),
        );
    }

    /// Delete the Fiat Method object into the contract
    /// Params: id: i128
    pub fn delete_fiat_method(&mut self, id: i128) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        self.fiat_method.remove(&id).expect("Fiat method does not exist");
        
        env::log_str(
            &json!({
                "type": "delete_fiat_method",
                "params": {
                    "id": id.to_string(),
                }
            }).to_string(),
        );
    }

     /// Returns the users object loaded in contract
    /* pub fn get_payment_method_user(self, user_id: AccountId, method_id: Option<i128>) -> Vec<PaymentMethodUserObject> {
        if self.payment_method_user.len() > 0 {
            let mut result: Vec<PaymentMethodUserObject> = Vec::new();
            if self.payment_method_user.len() > 0 {
                for i in 0..self.payment_method_user.len() {
                    if method_id.is_some() {
                        if self.payment_method_user.get(i).unwrap().payment_method_id == method_id.unwrap() && self.payment_method_user.get(i).unwrap().user_id == user_id {
                            result.push(PaymentMethodUserObject {
                                user_id: self.payment_method_user[i].user_id.clone(),
                                payment_method_id: self.payment_method_user[i].payment_method_id,
                                payment_method: self.payment_method_user[i].payment_method.to_string(),
                                desc1: self.payment_method_user[i].desc1.to_string(),
                                input1: self.payment_method_user[i].input1.to_string(),
                                desc2: self.payment_method_user[i].desc2.to_string(),
                                input2: self.payment_method_user[i].input2.to_string(),
                                desc3: self.payment_method_user[i].desc3.to_string(),
                                input3: self.payment_method_user[i].input3.to_string(),
                                desc4: self.payment_method_user[i].desc4.to_string(),
                                input4: self.payment_method_user[i].input4.to_string(),
                                desc5: self.payment_method_user[i].desc5.to_string(),
                                input5: self.payment_method_user[i].input5.to_string(),
                            });
                        }
                    } else {
                        if self.payment_method_user.get(i).unwrap().user_id == user_id {
                            result.push(PaymentMethodUserObject {
                                user_id: self.payment_method_user[i].user_id.clone(),
                                payment_method_id: self.payment_method_user[i].payment_method_id,
                                payment_method: self.payment_method_user[i].payment_method.to_string(),
                                desc1: self.payment_method_user[i].desc1.to_string(),
                                input1: self.payment_method_user[i].input1.to_string(),
                                desc2: self.payment_method_user[i].desc2.to_string(),
                                input2: self.payment_method_user[i].input2.to_string(),
                                desc3: self.payment_method_user[i].desc3.to_string(),
                                input3: self.payment_method_user[i].input3.to_string(),
                                desc4: self.payment_method_user[i].desc4.to_string(),
                                input4: self.payment_method_user[i].input4.to_string(),
                                desc5: self.payment_method_user[i].desc5.to_string(),
                                input5: self.payment_method_user[i].input5.to_string(),
                            });
                        }
                    }
                }
                result
            } else {
                result
            }
        } else {
            [].to_vec()
        }
    }*/
    
    //Set the Payment Method User object into the contract
    pub fn set_payment_method_user(&mut self, payment_method_id: i128
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) -> String {
        let id = format!("{}:{}", env::signer_account_id(), payment_method_id).to_string();
        assert!(self.payment_method_user.get(&id.clone()).is_none(),"Repeated payment methods are not allowed");
        
        let pm = self.payment_method.get(&payment_method_id).expect("Payment method does not exist");
        
        let data = PaymentMethodUserObject {
            user_id: env::signer_account_id(),
            payment_method_id: payment_method_id,
            payment_method: pm.payment_method.to_string(),
            desc1: pm.input1.to_string(),
            input1: input1.clone(),
            desc2: pm.input2.to_string(),
            input2: input2.clone(),
            desc3: pm.input3.to_string(),
            input3: input3.clone(),
            desc4: pm.input4.to_string(),
            input4: input4.clone(),
            desc5: pm.input5.to_string(),
            input5: input5.clone(),
        };

        self.payment_method_user.insert(&id.clone(), &data.clone());

        env::log_str(
            &json!({
                "type": "set_payment_method_user",
                "params": {
                    "user_id": env::signer_account_id(),
                    "payment_method_id": payment_method_id.to_string(),
                    "payment_method": pm.payment_method.to_string(),
                    "desc1": pm.input1.to_string(),
                    "input1": input1.clone(),
                    "desc2": pm.input2.to_string(),
                    "input2": input2.clone(),
                    "desc3": pm.input3.to_string(),
                    "input3": input3.clone(),
                    "desc4": pm.input4.to_string(),
                    "input4": input4.clone(),
                    "desc5": pm.input5.to_string(),
                    "input5": input5.clone(),
                }
            }).to_string(),
        );
        
        payment_method_id.to_string()
    }

    //Set the Payment Method User object into the contract
    pub fn set_payment_method_user_admin(&mut self, user_id: AccountId
        , payment_method_id: i128
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) -> String {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        let id = format!("{}:{}", user_id.clone(), payment_method_id).to_string();

        self.payment_method_user.get(&id).expect("Repeated payment methods are not allowed");
        
        let pm = self.payment_method.get(&payment_method_id).expect("Payment method does not exist");
        
        let data = PaymentMethodUserObject {
            user_id: user_id.clone(),
            payment_method_id: payment_method_id,
            payment_method: pm.payment_method.to_string(),
            desc1: pm.input1.to_string(),
            input1: input1.clone(),
            desc2: pm.input2.to_string(),
            input2: input2.clone(),
            desc3: pm.input3.to_string(),
            input3: input3.clone(),
            desc4: pm.input4.to_string(),
            input4: input4.clone(),
            desc5: pm.input5.to_string(),
            input5: input5.clone(),
        };

        self.payment_method_user.insert(&id, &data);

        env::log_str(
            &json!({
                "type": "set_payment_method_user_admin",
                "params": {
                    "user_id": user_id,
                    "payment_method_id": payment_method_id.to_string(),
                    "payment_method": pm.payment_method.to_string(),
                    "desc1": pm.input1.to_string(),
                    "input1": input1.clone(),
                    "desc2": pm.input2.to_string(),
                    "input2": input2.clone(),
                    "desc3": pm.input3.to_string(),
                    "input3": input3.clone(),
                    "desc4": pm.input4.to_string(),
                    "input4": input4.clone(),
                    "desc5": pm.input5.to_string(),
                    "input5": input5.clone(),
                }
            }).to_string(),
        );
        
        payment_method_id.to_string()    
    }

    /// put the Payment Method object into the contract
    pub fn put_payment_method_user(&mut self, payment_method_id: i128
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) {
        let id = format!("{}:{}", env::signer_account_id(), payment_method_id).to_string();

        let mut pmu = self.payment_method_user.get(&id.clone()).expect("payment method user does not exist");
            
        pmu.input1 = input1.to_string();
        pmu.input2 = input2.to_string();
        pmu.input3 = input3.to_string();
        pmu.input4 = input4.to_string();
        pmu.input5 = input5.to_string();
           
        self.payment_method_user.insert(&id.clone(), &pmu);

        env::log_str(
            &json!({
                "type": "put_payment_method_user",
                "params": {
                    "user_id": env::signer_account_id(),
                    "payment_method_id": payment_method_id.to_string(),
                    "input1": input1.to_string(),
                    "input2": input2.to_string(),
                    "input3": input3.to_string(),
                    "input4": input4.to_string(),
                    "input5": input5.to_string(),
                }
            }).to_string(),
        );
    }

    /// delete the Payment Method user object into the contract
    pub fn delete_payment_method_user(&mut self, payment_method_id: i128) {
        let id = format!("{}:{}", env::signer_account_id(), payment_method_id).to_string();
            
        self.payment_method_user.remove(&id).expect("payment method user does not exist");
            
        env::log_str(
            &json!({
                "type": "delete_payment_method_user",
                "params": {
                    "user_id": env::signer_account_id(),
                    "payment_method_id": payment_method_id.to_string(),
                }
            }).to_string(),
        );
    }

    pub fn get_order_sell(self,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> SearchOrderObject {
        if self.orders_sell.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.orders_sell.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            SearchOrderObject {
                total_index: self.orders_sell.len() as i128,
                data: self.orders_sell.iter()
                .skip(start_index as usize)
                .take(limit)
                .map(|(_k, r)| r.clone()).collect(),
            }
        } else {
            SearchOrderObject {
                total_index: 0,
                data: [].to_vec(),
            }
        }
    }

    pub fn get_order_buy(self,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> SearchOrderObject {
        if self.orders_buy.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.orders_buy.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            SearchOrderObject {
                total_index: self.orders_buy.len() as i128,
                data: self.orders_buy.iter()
                .skip(start_index as usize)
                .take(limit)
                .map(|(_k, r)| r.clone()).collect(),
            }
        } else {
            SearchOrderObject {
                total_index: 0,
                data: [].to_vec(),
            }
        }
    }

}

/*fn search_offer(data: Vec<OfferObject>,
    amount: Option<U128>,
    fiat_method: Option<i128>,
    payment_method: Option<i128>,
    is_merchant: Option<bool>,
    owner_id: Option<AccountId>,
    status: Option<i8>,
    offer_id: Option<i128>,
    asset: Option<String>,
    signer_id: Option<AccountId>,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> SearchOfferObject {

    
    let mut result: Vec<OfferObject> = data;

    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    assert!(
        (result.len() as u128) > start_index,
        "Out of bounds, please use a smaller from_index."
    );
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    assert_ne!(limit, 0, "Cannot provide limit of 0.");

    if signer_id.is_some() {
        result = result.iter().filter(|x| x.owner_id != AccountId::new_unchecked(signer_id.as_ref().unwrap().to_string()))
                    .map(|r| r.clone()).collect();
    }
    if fiat_method.is_some() {
        result = result.iter().filter(|x| x.fiat_method == fiat_method.unwrap())
                    .map(|r| r.clone()).collect();
    }
    if payment_method.is_some() {
        result = result.iter().filter(|x| x.payment_method.iter().filter(|z| z.id.parse::<i128>().unwrap() == payment_method.unwrap()).count() > 0 )
                    .map(|r| r.clone()).collect();
    }
    if is_merchant.is_some() {
        result = result.iter().filter(|x| x.is_merchant == is_merchant.unwrap())
                    .map(|r| r.clone()).collect();
    }
    if owner_id.is_some() {
        result = result.iter().filter(|x| x.owner_id == AccountId::new_unchecked(owner_id.as_ref().unwrap().to_string()))
                    .map(|r| r.clone()).collect();
    }
    if status.is_some() {
        result = result.iter().filter(|x| x.status == status.unwrap())
                    .map(|r| r.clone()).collect();
    }
    if offer_id.is_some() {
        result = result.iter().filter(|x| x.offer_id == offer_id.unwrap())
                    .map(|r| r.clone()).collect();
    }
    if asset.is_some() {
        result = result.iter().filter(|x| x.asset == asset.as_ref().unwrap().to_string())
                    .map(|r| r.clone()).collect();
    }

    if amount.is_some() {
        result = result.iter().filter(|x| x.amount >= amount.unwrap().0)
                .map(|r| r.clone()).collect();
        /*if asset.is_some() {
            if asset.as_ref().unwrap().to_string() == "NEAR" {
                let monto: u128 = (amount.unwrap().0 * 1000000000000000000000000) as u128;
                result = result.iter().filter(|x| x.amount >= monto)
                        .map(|r| r.clone()).collect();
            } else {
                result = result.iter().filter(|x| x.amount >= amount.unwrap().0)
                        .map(|r| r.clone()).collect();
            }
        }*/
    }

    SearchOfferObject {
        total_index: result.len() as i128,
        data: result.iter()
        .skip(start_index as usize)
        .take(limit)
        .map(|r| r.clone()).collect(),
    }
}*/

/*fn search_order(data: Vec<OrderObject>,
    order_id: Option<i128>,
    offer_id: Option<i128>,
    owner_id: Option<AccountId>,
    signer_id: Option<AccountId>,
    status: Option<i8>,
    asset: Option<String>,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> SearchOrderObject {
    let mut result: Vec<OrderObject> = data;

    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    assert!(
        (result.len() as u128) > start_index,
        "Out of bounds, please use a smaller from_index."
    );
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    assert_ne!(limit, 0, "Cannot provide limit of 0.");
    
    if order_id.is_some() {
        result = result.iter().filter(|x| x.order_id == order_id.unwrap())
                    .map(|r| r.clone()).collect();
    }
    
    if offer_id.is_some() {
        result = result.iter().filter(|x| x.offer_id == offer_id.unwrap())
                    .map(|r| r.clone()).collect();
    }

    if owner_id.is_some() {
        let user = owner_id.unwrap().clone();
        result = result.iter().filter(|x| x.owner_id == AccountId::new_unchecked(user.to_string()))
                    .map(|r| r.clone()).collect();
    }
    
    if signer_id.is_some() {
        let user = signer_id.unwrap().clone();
        result = result.iter().filter(|x| x.signer_id == AccountId::new_unchecked(user.to_string()))
                    .map(|r| r.clone()).collect();
    }
    
    if status.is_some() {
        result = result.iter().filter(|x| x.status == status.unwrap())
                    .map(|r| r.clone()).collect();
    }

    if asset.is_some() {
        result = result.iter().filter(|x| x.asset == asset.as_ref().unwrap().clone())
                    .map(|r| r.clone()).collect();
    }

    SearchOrderObject {
        total_index: result.len() as i128,
        data: result.iter()
        .skip(start_index as usize)
        .take(limit)
        .map(|r| r.clone()).collect(),
    }
}*/

/*
fn search_order_history(data: Vec<OrderObject>,
    user_id: Option<AccountId>,
    order_id: Option<i128>,
    status: Option<i8>,
    asset: Option<String>,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> SearchOrderObject {
    let mut result: Vec<OrderObject> = data.iter()
    .map(|s| s.clone()).collect();

    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    assert!(
        (result.len() as u128) > start_index,
        "Out of bounds, please use a smaller from_index."
    );
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    assert_ne!(limit, 0, "Cannot provide limit of 0.");

    if status.is_some() {
        result = result.iter().filter(|s| s.status == status.unwrap())
                .map(|s| s.clone()).collect();
    }

    if user_id.is_some() {
        let user = user_id.unwrap().clone();
        result = result.iter().filter(|s| s.owner_id == AccountId::new_unchecked(user.to_string()) || s.signer_id == AccountId::new_unchecked(user.to_string()))
                .map(|s| s.clone()).collect();
    }

    if order_id.is_some() {
        result = result.iter().filter(|s| s.order_id == order_id.unwrap())
                .map(|s| s.clone()).collect();
    } 

    if asset.is_some() {
        result = result.iter().filter(|s| s.asset == asset.as_ref().unwrap().clone())
                .map(|s| s.clone()).collect();
    }

    SearchOrderObject {
        total_index: result.len() as i128,
        data: result.iter().rev()
        .skip(start_index as usize)
        .take(limit)
        .map(|s| s.clone()).collect(),
    }
}*/

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // part of writing unit tests is setting up a mock context
    // in this example, this is only needed for env::log in the contract
    // this is also a useful list to peek at when wondering what's available in env::*
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "robert.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn set_order() {
        let context = get_context(vec![], false);
        testing_env!(context);
        //let attached_deposit = env::attached_deposit();
        let mut contract = NearP2P::default();
        let account_id = "p2p-testnet.testnet".to_string();
        let asset = "NEAR".to_string();
        let price = "14.5".to_string();
        let amount = "100".to_string();
        let min_limit = "10".to_string();
        let max_limit = "100".to_string();
        let order_type = 1;
        let payment_method = 1;
        let orders_completed = 0;
        let percentaje_completion = 0;
        let badge = "super star".to_string();
        //contract.set_offers(account_id, asset, price, amount, min_limit, max_limit, order_type, payment_method, orders_completed, percentaje_completion, badge);
        //assert_eq!(contract.get_offers().len(), 1);
    }

    #[test]
    fn test_lock() {
        let context = get_context(vec![], false);
        testing_env!(context);
        //let attached_deposit = env::attached_deposit();
        let mut contract = NearP2P::default();
        let escrow_account_id = env::predecessor_account_id();
        let account_id = "p2p-testnet.testnet".to_string();
        //contract.lock(account_id.to_string());
        //print!("Locked balance: {}", contract.get_locked_balance(account_id.to_string(), escrow_account_id));
    }
    
}

'''
'''--- src/libcopyprod.rs ---
/*
NEAR-Dex

It’s all about to create a Peer to Peer (P2P) DAPP to allow change your’s NEAR tokens in a easy, 
secure and fast way.
A Decentralized Wallet that will provide P2P like Binance or Airtm where you can change your 
available Crypto’s in local money, fiat, other cryptos. Using your services online that are available already.
The idea is similiar to our friend @FritzWorm NearWalletDapp 5.

Issue & Solution thinking

At the moment people ask where they can change their NEAR and do not get a way to do it quickly and transparently.
This P2P feature will ease the process where people come into crypto, will help them in daily basic s
ending money/remittances and NEAR protocol will get a lot of transactions and volume helping REF Finance with 
liquidity from investors that will come with the mass adoption.
The process
prueba
MIT license
Develop by GlobalDv @2022
*/

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use serde::Serialize;
use serde::Deserialize;
use near_sdk::{env, near_bindgen, AccountId, Promise, assert_one_yocto, ext_contract, Gas, promise_result_as_success, require,
                serde_json::json}; // json_types::U128, 
use near_sdk::json_types::U128;
use std::collections::HashMap;
//near_sdk::setup_alloc!();

const KEY_TOKEN: &str = "OzhQbGSPa63uohj6VTXBV5KbUm2x0Q3i";
const FEE_TRANSACTION_NEAR: u128 = 30; // 0.003%

//const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_TRANSFER: Gas = Gas(25_000_000_000_000);
const GAS_FOR_BLOCK: Gas = Gas(30_000_000_000_000);
const GAS_ON_WITHDRAW_NEAR: Gas = Gas(40_000_000_000_000);
const GAS_ON_WITHDRAW_TOKEN_BLOCK: Gas = Gas(80_000_000_000_000);
const GAS_ON_WITHDRAW_TOKEN: Gas = Gas(45_000_000_000_000);
const GAS_ON_CONFIRMATION: Gas = Gas(50_000_000_000_000);
const GAS_ON_ACCEPT_OFFER_SELL: Gas = Gas(40_000_000_000_000);
const BASE_GAS: Gas = Gas(3_000_000_000_000);

//const CONSUMO_STORAGE_NEAR_SUBCONTRACT: u128 = 1412439322253799699999999;
const CONTRACT_USDC: &str = "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near";

//const INITIAL_BALANCE: Balance = 2_50_000_000_000_000_000_000_000; // 1e24yN, 0.25N
//const INITIAL_BALANCE: Balance = 1_080_000_000_000_000_000_000_000; // 1e24yN, 0.25N
const CODE: &[u8] = include_bytes!("./wasm/subcontract_p2_p_v19.wasm");
/////////////////////////////////////////////////////////////////////////////////////////////////
/// Objects Definition///////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

use crate::external::*;
use crate::internal::*;

mod external;
mod internal;
mod subcontract;
mod sell;
mod buy;
mod offer;
mod process;
mod dispute;
/*
User UserObject: Struct for the user that contains info about the logged user.
This object contains, user_id, name, last_name, phone, email, country
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct UserObject {
    user_id: String,
    name: String,
    last_name: String,
    phone: String,
    email: String,
    country: String,
    mediator: bool,
    is_active: bool,
    campo1: String,
    campo2: String,
    campo3: String,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PaymentMethodsOfferObject {
    id: String,
    payment_method: String,
}

/*
User OfferObject: Struct for offer that will be listed.
This object contains, order_id, owner_id, asset, exchange_rate, email, country
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct OfferObject {
    offer_id: i128,
    owner_id: AccountId,
    asset: String, // NEAR, USD
    exchange_rate: String,
    amount: u128,
    remaining_amount: u128,
    min_limit: u128,
    max_limit: u128,
    payment_method: Vec<PaymentMethodsOfferObject>, // Info concerning to payment asociated to payment contract
    fiat_method: i128,
    is_merchant: bool,
    time: i64,
    terms_conditions: String,
    status: i8, // 1: active, 2: closed
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct OrderObject {
    offer_id: i128,
    order_id: i128,
    owner_id: AccountId,
    asset: String,
    signer_id: AccountId,
    exchange_rate: String,
    operation_amount: u128,
    amount_delivered: u128,
    fee_deducted: u128,
    payment_method: i128, // Info concerning to payment asociated to payment contract
    fiat_method: i128,
    confirmation_owner_id: i8,
    confirmation_signer_id: i8,
    confirmation_current: i8,
    time: i64,
    datetime: String,
    terms_conditions: String,
    status: i8, // 1 = pending, 2 = completed, 3 = disputed
}

/*
User MerchantObject: Struct for Merchants.
This object contains, user_id, total_orders, orders_completed, percentaje_completion, badge
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct MerchantObject {
    user_id: AccountId,
    total_orders: i64,
    orders_completed: i64,
    percentaje_completion: f64, // pioasjoidjasoi
    badge: String, //Badge that represent a merchant verified
    is_merchant: bool,
}

/*
User PaymentMethodsObject: Struct for Payments.
This object contains, id, payment_method, input1, input2, input3, input4, input5
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PaymentMethodsObject {
    id: i128,
    payment_method: String,
    input1: String,
    input2: String,
    input3: String,
    input4: String,
    input5: String,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PaymentMethodUserObject {
    user_id: AccountId,
    payment_method_id: i128,
    payment_method: String,
    desc1: String,
    input1: String,
    desc2: String,
    input2: String,
    desc3: String,
    input3: String,
    desc4: String,
    input4: String,
    desc5: String,
    input5: String,
}

/*
User FiatMethodsObject: Struct for Fiat list.
This object contains, id, fiat_method, flagcdn
*/
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FiatMethodsObject {
    id: i128,
    fiat_method: String,
    flagcdn: String,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SearchOfferObject {
    total_index: i128,
    data: Vec<OfferObject>,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SearchOrderObject {
    total_index: i128,
    data: Vec<OrderObject>,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractList {
    contract: AccountId,
    type_contract: i8,
}

//////////////////////////////////////////////////////////////////////////////////////////////////
/// Objects Definition////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/// 

/*
Near P2P Struct
*/
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NearP2P {
    // Users
    pub users: Vec<UserObject>,
    ///Offer object
    pub offers_sell: Vec<OfferObject>,
    ///Offer Sell Id
    pub offer_sell_id: i128,
    ///Offer object
    pub offers_buy: Vec<OfferObject>,
    ///Order Buy Id
    pub offer_buy_id: i128,
    //Order object
    pub orders_sell: Vec<OrderObject>,
    //Order object
    pub order_sell_id: i128,
    //Order object
    pub orders_buy: Vec<OrderObject>,
    //Order object
    pub order_buy_id: i128,
    //Order History sell
    pub order_history_sell: Vec<OrderObject>,
    //Order History buy
    pub order_history_buy: Vec<OrderObject>,
    ///Merchant object
    pub merchant: Vec<MerchantObject>,
    ///Payment Method object
    pub payment_method: Vec<PaymentMethodsObject>,
    ///Payment Method object
    pub payment_method_user: Vec<PaymentMethodUserObject>,
    // Payment Method Id
    pub payment_method_id: i128,
    ///Payment Method object
    pub fiat_method: Vec<FiatMethodsObject>,
    // Payment Method Id
    pub fiat_method_id: i128,

    pub vault: AccountId,

    pub administrators: Vec<AccountId>,

    pub contract_list: HashMap<AccountId, ContractList>,

    pub activate_token_list: HashMap<AccountId, Vec<String>>,

    pub disputer: AccountId,
}

/// Initializing deafult impl
/// We are using default inizialization for the structs
impl Default for NearP2P {
    fn default() -> Self {
        Self {
            users: vec![UserObject {
                user_id: "andresdom.near".to_string(),
                name: "Andrés".to_string(),
                last_name: "Dominguez".to_string(),
                phone: "U2FsdGVkX1/dUbQwXTwTZuFJx6dwYQsf97Y1h61BCsM=".to_string(),
                email: "U2FsdGVkX1/0L7cmUr2e/SCTmgCWZGEW/WFAi3ZP/bCtQlBdhgvF4l3Xr6MbdBk/".to_string(),
                country: "Venezuela".to_string(),
                mediator: true,
                is_active: true,
                campo1: "".to_string(),
                campo2: "".to_string(),
                campo3: "".to_string(),
            }],
            offers_sell: Vec::new(),
            offer_sell_id: 0,
            offers_buy: Vec::new(),
            offer_buy_id: 0,
            orders_sell: Vec::new(),
            order_sell_id: 0,
            orders_buy: Vec::new(),
            order_buy_id: 0,
            order_history_sell: Vec::new(),
            order_history_buy: Vec::new(),
            merchant: vec![MerchantObject {
                user_id: AccountId::new_unchecked("andresdom.near".to_string()),
                total_orders: 1,
                orders_completed: 1,
                percentaje_completion: 0.0,
                badge: "check-circle".to_string(),
                is_merchant: true,
            }],
            payment_method: Vec::new(),
            payment_method_user: Vec::new(),
            payment_method_id: 0,
            fiat_method: Vec::new(),
            fiat_method_id: 0,
            vault: AccountId::new_unchecked("vault.nearp2pdex.near".to_string()),
            administrators: vec![
                AccountId::new_unchecked("andresdom.near".to_string()),
                AccountId::new_unchecked("maruja.near".to_string()),
                AccountId::new_unchecked("hrpalencia.near".to_string()),
                AccountId::new_unchecked("gperez83.near".to_string()),
                AccountId::new_unchecked("jochando.near".to_string()),
                AccountId::new_unchecked("adminp2p.near".to_string()),
                        ],
            contract_list: HashMap::new(),
            activate_token_list: HashMap::new(),
            disputer: AccountId::new_unchecked("near-p2p.sputnik-dao.near".to_string()),
        }
    }
}

/// Implementing Struct
#[near_bindgen]
impl NearP2P {
    /*pub fn prueba_balance(&mut self, account_id: String) -> Promise {
        let nft_contract: AccountId = CONTRACT_USDC.parse().unwrap();
        let gas_internal: Gas = Gas(1_000_000_000_000);
        ext_usdc::ft_balance_of(
            account_id,
            nft_contract,
            0,
            BASE_GAS,
        )
        .then(int_sub_contract::on_ft_balance_of(
            env::current_account_id(),
            0,
            gas_internal,
        ))
    }

    #[private]
    pub fn on_ft_balance_of(&mut self) -> String {
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("balance is None".as_ref());
        }
        let ret = near_sdk::serde_json::from_slice::<String>(&result.unwrap()).expect("balance is None");
        return ret;
    }*/

    
   
    pub fn set_admin(&mut self, user_id: AccountId) {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        let valid = self.administrators.iter().find(|&x| x == &user_id);
        if valid.is_some() {
            env::panic_str("the user is already in the list of administrators");
        }
        self.administrators.push(user_id);
    }

    pub fn delete_admin(&mut self, user_id: AccountId) {      
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        let index = self.administrators.iter().position(|x| x == &AccountId::new_unchecked(user_id.to_string())).expect("the user is not in the list of administrators");
        self.administrators.remove(index);
    }

    pub fn update_vault(&mut self, account_id: AccountId) {      
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        self.vault = account_id;
    }

    /// Returns the users object loaded in contract
    /// Params: user_id: AccountId
    pub fn get_user(self, 
        user_id: Option<AccountId>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<UserObject> {
        if self.users.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.users.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            if user_id.is_some() {
                let user = user_id.unwrap().clone();
                self.users.iter().filter(|x| x.user_id == user.to_string())
                .skip(start_index as usize)
                .take(limit)
                .map(|x| x.clone()).collect()
            } else {
                self.users.iter()
                .skip(start_index as usize)
                .take(limit)
                .map(|x| x.clone()).collect()
            }
        } else {
            [].to_vec()
        }
    }

    pub fn delete_user_admin(&mut self, user_id: String) {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        
        let index = self.users.iter().position(|x| x.user_id == user_id.to_string());

        if index.is_some() {
            self.users.remove(index.unwrap());
        }

        let index2 = self.merchant.iter().position(|x| x.user_id == AccountId::new_unchecked(user_id.clone()));
        
        if index2.is_some() {
            self.merchant.remove(index2.unwrap());
        }
    }

    /// Set the users object into the contract
    /// Params: user_id: String, name: String
    /// last_name: String, phone: String, email: String, country: String
    pub fn set_user(&mut self,
        name: String,
        last_name: String,
        phone: String,
        email: String,
        country: String,
        campo1: String,
        campo2: String,
        campo3: String,
    ) -> String {
        let user = self.users.iter().find(|x| x.user_id == env::signer_account_id().to_string());
        if user.is_some() {
            env::panic_str("profile already exists");
        }
        let data = UserObject {
            user_id: env::signer_account_id().to_string(),
            name: name.to_string(),
            last_name: last_name.to_string(),
            phone: phone.to_string(),
            email: email.to_string(),
            country: country.to_string(),
            mediator: false,
            is_active: true,
            campo1: campo1.to_string(),
            campo2: campo2.to_string(),
            campo3: campo3.to_string(),
        };
        self.users.push(data);
        let data2 = MerchantObject {
            user_id: env::signer_account_id(),
            total_orders: 0,
            orders_completed: 0,
            percentaje_completion: 0.0,
            badge: "".to_string(),
            is_merchant: false,
        };
        self.merchant.push(data2);
       // set_merchant(user_id: user_id.to_string(), total_orders: 0, orders_completed: 0 , badge: "".to_string());
        env::log_str(
            &json!({
                "type": "set_user",
                "params": {
                    "user_id": env::signer_account_id().to_string(),
                    "name": name.to_string(),
                    "last_name": last_name.to_string(),
                    "phone": phone.to_string(),
                    "email": email.to_string(),
                    "country": country.to_string(),
                    "mediator": false,
                    "is_active": true,
                    "badge": "".to_string(),
                    "is_merchant": false,
                    "campo1": campo1.to_string(),
                    "campo2": campo2.to_string(),
                    "campo3": campo3.to_string(),
                }
            }).to_string(),
        );
        env::signer_account_id().to_string()
    }

    pub fn set_user_admin(&mut self,
        user_id: String,
        name: String,
        last_name: String,
        phone: String,
        email: String,
        country: String,
        campo1: String,
        campo2: String,
        campo3: String,
    ) -> String {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        let user = self.users.iter().find(|x| x.user_id == user_id.to_string());
        if user.is_some() {
            env::panic_str("profile already exists");
        }
        let data = UserObject {
            user_id: user_id.clone(),
            name: name.to_string(),
            last_name: last_name.to_string(),
            phone: phone.to_string(),
            email: email.to_string(),
            country: country.to_string(),
            mediator: false,
            is_active: true,
            campo1: campo1.to_string(),
            campo2: campo2.to_string(),
            campo3: campo3.to_string(),
        };
        self.users.push(data);
        let data2 = MerchantObject {
            user_id: AccountId::new_unchecked(user_id.clone()),
            total_orders: 0,
            orders_completed: 0,
            percentaje_completion: 0.0,
            badge: "".to_string(),
            is_merchant: false,
        };
        self.merchant.push(data2);
       // set_merchant(user_id: user_id.to_string(), total_orders: 0, orders_completed: 0 , badge: "".to_string());
        env::log_str(
            &json!({
                "type": "set_user_admin",
                "params": {
                    "user_id": user_id.to_string(),
                    "name": name.to_string(),
                    "last_name": last_name.to_string(),
                    "phone": phone.to_string(),
                    "email": email.to_string(),
                    "country": country.to_string(),
                    "mediator": false,
                    "is_active": true,
                    "badge": "".to_string(),
                    "is_merchant": false,
                    "campo1": campo1.to_string(),
                    "campo2": campo2.to_string(),
                    "campo3": campo3.to_string(),
                }
            }).to_string(),
        );
        user_id.to_string()
    }
    
    /// Set the users object into the contract
    /// Params: user_id: String, name: String
    /// name: String, last_name: String, phone: String, email: String, country: String
    pub fn put_user(&mut self, name: String
        , last_name: String
        , phone: String
        , email: String
        , country: String) {
        
        let i = self.users.iter().position(|x| x.user_id == env::signer_account_id().to_string()).expect("user does not exist");
        self.users[i].name = name.to_string();
        self.users[i].last_name = last_name.to_string();
        self.users[i].phone = phone.to_string();
        self.users[i].email = email.to_string();
        self.users[i].country = country.to_string();
        self.users[i].mediator = self.users[i].mediator;
        self.users[i].is_active = self.users[i].is_active;
            
        env::log_str(
            &json!({
                "type": "put_user",
                "params": {
                    "user_id": env::signer_account_id().to_string(),
                    "name": name.to_string(),
                    "last_name": last_name.to_string(),
                    "phone": phone.to_string(),
                    "email": email.to_string(),
                    "country": country.to_string(),
                    "mediator": self.users[i].mediator,
                    "is_active": self.users[i].is_active,
                }
            }).to_string(),
        );
    }

    pub fn put_users(&mut self, user_id: AccountId
        , name: String
        , last_name: String
        , phone: String
        , email: String
        , country: String
        , mediator: bool
        , is_active: bool
    ) {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        let i = self.users.iter().position(|x| x.user_id == user_id.to_string()).expect("user does not exist");
        self.users[i].name = name.to_string();
        self.users[i].last_name = last_name.to_string();
        self.users[i].phone = phone.to_string();
        self.users[i].email = email.to_string();
        self.users[i].country = country.to_string();
        self.users[i].mediator = mediator;
        self.users[i].is_active = is_active;
                            
        env::log_str(
            &json!({
                "type": "put_users",
                "params": {
                    "user_id": user_id.to_string(),
                    "name": name.to_string(),
                    "last_name": last_name.to_string(),
                    "phone": phone.to_string(),
                    "email": email.to_string(),
                    "country": country.to_string(),
                    "mediator": mediator,
                    "is_active": is_active,
                }
            }).to_string(),
        );
    }

    /// Returns the merchant object loaded in contract
    pub fn get_merchant(self,
        user_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<MerchantObject> {
        if self.merchant.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.merchant.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            if user_id.to_string() == "%".to_string() {
                self.merchant.iter()  // Return all merchants
                .skip(start_index as usize)
                .take(limit) 
                .map(|x| x.clone()).collect()
            } else {
                self.merchant.iter().filter(|x| x.user_id == user_id)
                .skip(start_index as usize)
                .take(limit)
                .map(|x| x.clone()).collect()                
            }
        } else {
            [].to_vec()
        }
    }

    /// Set the merchant object into the contract
    /// Params: user_id: String, total_orders: i128, orders_completed: i128
    /// badge: String
    pub fn put_merchant(&mut self, user_id: AccountId
        , total_orders: i64
        , orders_completed: i64 
        , badge: String
        , is_merchant: bool
    ) {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
            
        let i = self.merchant.iter().position(|x| x.user_id == user_id).expect("Merchant not found");
        self.merchant[i].total_orders = total_orders;
        self.merchant[i].orders_completed = orders_completed;
        self.merchant[i].percentaje_completion = (orders_completed as f64 / total_orders as f64) * 100.0;
        self.merchant[i].badge = badge.to_string();
        self.merchant[i].is_merchant = is_merchant;

        env::log_str(
            &json!({
                "type": "put_merchant",
                "params": {
                    "user_id": user_id.to_string(),
                    "total_orders": total_orders.to_string(),
                    "orders_completed": orders_completed.to_string(),
                    "percentaje_completion": self.merchant[i].percentaje_completion.to_string(),
                    "badge": badge.to_string(),
                    "is_merchant": is_merchant,
                }
            }).to_string(),
        );
    }

    /// Returns the Payment Method object loaded in contract
    pub fn get_payment_method(&self,
        from_index: Option<U128>,
        limit: Option<u64>
    ) -> Vec<PaymentMethodsObject> {
        if self.payment_method.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.payment_method.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            self.payment_method.iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|x| x.clone()).collect()
        } else {
            [].to_vec()
        }
    }

    /// Set the Payment Method object into the contract
    /// Params: payment_method_id: String, input1: String, input2: String
    /// input3: String, input4: String, input5: String
    /// List of payment methods, will be called by the user
    /// It is used to filter wich oayment method is offering for trading
    pub fn set_payment_method(&mut self, payment_method: String
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) -> i128 {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        self.payment_method_id += 1;
        let data = PaymentMethodsObject {
            id: self.payment_method_id,
            payment_method: payment_method.clone(),
            input1: input1.clone(),
            input2: input2.clone(),
            input3: input3.clone(),
            input4: input4.clone(),
            input5: input5.clone(),
        };
        env::log_str(
            &json!({
                "type": "set_payment_method",
                "params": {
                    "id": self.payment_method_id.to_string(),
                    "payment_method": payment_method.clone(),
                    "input1": input1.clone(),
                    "input2": input2.clone(),
                    "input3": input3.clone(),
                    "input4": input4.clone(),
                    "input5": input5.clone(),
                }
            }).to_string(),
        );
        self.payment_method.push(data);
        self.payment_method_id
    }

     /// put the Payment Method object into the contract
    /// Params: id: i128, payment_method: String, input1: String, input2: String
    /// input3: String, input4: String, input5: String
    pub fn put_payment_method(&mut self, id: i128
        , payment_method: String
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        //self.payment_method[0].payment_method = String::from("Transferencia Bancaria 2");
        for i in 0..self.payment_method.len() {
            if self.payment_method.get(i).unwrap().id == id {
                self.payment_method[i].payment_method = payment_method.to_string();
                self.payment_method[i].input1 = input1.to_string();
                self.payment_method[i].input2 = input2.to_string();
                self.payment_method[i].input3 = input3.to_string();
                self.payment_method[i].input4 = input4.to_string();
                self.payment_method[i].input5 = input5.to_string();
                break;
            }
        }
        for i in 0..self.payment_method_user.len() {
            if self.payment_method_user.get(i).unwrap().payment_method_id == id {
                self.payment_method_user[i].payment_method = payment_method.to_string();
                self.payment_method_user[i].desc1 = input1.to_string();
                self.payment_method_user[i].desc2 = input2.to_string();
                self.payment_method_user[i].desc3 = input3.to_string();
                self.payment_method_user[i].desc4 = input4.to_string();
                self.payment_method_user[i].desc5 = input5.to_string();
            }
        }
        env::log_str(
            &json!({
                "type": "put_payment_method",
                "params": {
                    "id": id.to_string(),
                    "payment_method": payment_method.to_string(),
                    "input1": input1.to_string(),
                    "input2": input2.to_string(),
                    "input3": input3.to_string(),
                    "input4": input4.to_string(),
                    "input5": input5.to_string(),
                }
            }).to_string(),
        );
        //self.merchant.get(0).unwrap().user_id.clone()
        //self.payment_method
    }

    /// delete the Payment Method object into the contract
    /// Params: id: i128
    pub fn delete_payment_method(&mut self, id: i128) {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        let mut index = self.payment_method.iter().position(|x| x.id == id).expect("Payment method does not exist");
        self.payment_method.remove(index);
            
        index = self.payment_method_user.iter().position(|x| x.payment_method_id == id).expect("Payment method does not exist");
        self.payment_method_user.remove(index);
            
        env::log_str(
            &json!({
                "type": "delete_payment_method",
                "params": {
                    "id": id.to_string(),
                }
            }).to_string(),
        );
        //self.merchant.get(0).unwrap().user_id.clone()
        //self.payment_method
    }
    
    /// Returns the Fiat Method object loaded in contract
    pub fn get_fiat_method(&self,
        from_index: Option<U128>,
        limit: Option<u64>
    ) -> Vec<FiatMethodsObject> {
        if self.fiat_method.len() > 0 {
            let start_index: u128 = from_index.map(From::from).unwrap_or_default();
            assert!(
                (self.fiat_method.len() as u128) > start_index,
                "Out of bounds, please use a smaller from_index."
            );
            let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
            assert_ne!(limit, 0, "Cannot provide limit of 0.");

            self.fiat_method.iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|x| x.clone()).collect()
        } else {
            [].to_vec()
        }
    }

    /// Set the Fiat Method object into the contract
    /// Params: fiat_method_id: String, flagcdn: String
    /// List of fiat methods, will be called by the user
    pub fn set_fiat_method(&mut self, fiat_method: String, flagcdn: String) -> i128 {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        self.fiat_method_id += 1;
        let data = FiatMethodsObject {
            id: self.fiat_method_id,
            fiat_method: fiat_method.clone(),
            flagcdn: flagcdn.clone(),
        };
        env::log_str(
            &json!({
                "type": "set_fiat_method",
                "params": {
                    "id": self.fiat_method_id.to_string(),
                    "fiat_method": fiat_method.clone(),
                    "flagcdn": flagcdn.clone(),
                }
            }).to_string(),
        );
        self.fiat_method.push(data);
        self.fiat_method_id
    }

    /// Put the Fiat Method object into the contract
    /// Params: id: i128, fiat_method: String, flagcdn: String
    pub fn put_fiat_method(&mut self, id: i128
        , fiat_method: String, flagcdn: String
    ) {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        let i = self.fiat_method.iter().position(|x| x.id == id).expect("Fiat method does not exist");
        self.fiat_method[i].fiat_method = fiat_method.to_string();
        self.fiat_method[i].flagcdn = flagcdn.to_string();
        
        env::log_str(
            &json!({
                "type": "put_fiat_method",
                "params": {
                    "id": id.to_string(),
                    "fiat_method": fiat_method.clone(),
                    "flagcdn": flagcdn.clone(),
                }
            }).to_string(),
        );
    }

    /// Delete the Fiat Method object into the contract
    /// Params: id: i128
    pub fn delete_fiat_method(&mut self, id: i128) {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        let i = self.fiat_method.iter().position(|x| x.id == id).expect("Fiat method does not exist");
        self.fiat_method.remove(i);
        
        env::log_str(
            &json!({
                "type": "delete_fiat_method",
                "params": {
                    "id": id.to_string(),
                }
            }).to_string(),
        );
    }

     /// Returns the users object loaded in contract
     pub fn get_payment_method_user(self, user_id: AccountId, method_id: Option<i128>) -> Vec<PaymentMethodUserObject> {
        if self.payment_method_user.len() > 0 {
            let mut result: Vec<PaymentMethodUserObject> = Vec::new();
            if self.payment_method_user.len() > 0 {
                for i in 0..self.payment_method_user.len() {
                    if method_id.is_some() {
                        if self.payment_method_user.get(i).unwrap().payment_method_id == method_id.unwrap() && self.payment_method_user.get(i).unwrap().user_id == user_id {
                            result.push(PaymentMethodUserObject {
                                user_id: self.payment_method_user[i].user_id.clone(),
                                payment_method_id: self.payment_method_user[i].payment_method_id,
                                payment_method: self.payment_method_user[i].payment_method.to_string(),
                                desc1: self.payment_method_user[i].desc1.to_string(),
                                input1: self.payment_method_user[i].input1.to_string(),
                                desc2: self.payment_method_user[i].desc2.to_string(),
                                input2: self.payment_method_user[i].input2.to_string(),
                                desc3: self.payment_method_user[i].desc3.to_string(),
                                input3: self.payment_method_user[i].input3.to_string(),
                                desc4: self.payment_method_user[i].desc4.to_string(),
                                input4: self.payment_method_user[i].input4.to_string(),
                                desc5: self.payment_method_user[i].desc5.to_string(),
                                input5: self.payment_method_user[i].input5.to_string(),
                            });
                        }
                    } else {
                        if self.payment_method_user.get(i).unwrap().user_id == user_id {
                            result.push(PaymentMethodUserObject {
                                user_id: self.payment_method_user[i].user_id.clone(),
                                payment_method_id: self.payment_method_user[i].payment_method_id,
                                payment_method: self.payment_method_user[i].payment_method.to_string(),
                                desc1: self.payment_method_user[i].desc1.to_string(),
                                input1: self.payment_method_user[i].input1.to_string(),
                                desc2: self.payment_method_user[i].desc2.to_string(),
                                input2: self.payment_method_user[i].input2.to_string(),
                                desc3: self.payment_method_user[i].desc3.to_string(),
                                input3: self.payment_method_user[i].input3.to_string(),
                                desc4: self.payment_method_user[i].desc4.to_string(),
                                input4: self.payment_method_user[i].input4.to_string(),
                                desc5: self.payment_method_user[i].desc5.to_string(),
                                input5: self.payment_method_user[i].input5.to_string(),
                            });
                        }
                    }
                }
                result
            } else {
                result
            }
        } else {
            [].to_vec()
        }
    }
    
    //Set the Payment Method User object into the contract
    pub fn set_payment_method_user(&mut self, payment_method_id: i128
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) -> String {
        let duplicado  = self.payment_method_user.iter().find(|x| x.payment_method_id == payment_method_id && x.user_id == env::signer_account_id());
        
        if duplicado.is_none() {
            let index2 = self.payment_method.iter().position(|x| x.id == payment_method_id).expect("Payment method does not exist");
            
            let data = PaymentMethodUserObject {
                user_id: env::signer_account_id(),
                payment_method_id: payment_method_id,
                payment_method: self.payment_method[index2].payment_method.to_string(),
                desc1: self.payment_method[index2].input1.to_string(),
                input1: input1.clone(),
                desc2: self.payment_method[index2].input2.to_string(),
                input2: input2.clone(),
                desc3: self.payment_method[index2].input3.to_string(),
                input3: input3.clone(),
                desc4: self.payment_method[index2].input4.to_string(),
                input4: input4.clone(),
                desc5: self.payment_method[index2].input5.to_string(),
                input5: input5.clone(),
            };

            env::log_str(
                &json!({
                    "type": "set_payment_method_user",
                    "params": {
                        "user_id": env::signer_account_id(),
                        "payment_method_id": payment_method_id.to_string(),
                        "payment_method": self.payment_method[index2].payment_method.to_string(),
                        "desc1": self.payment_method[index2].input1.to_string(),
                        "input1": input1.clone(),
                        "desc2": self.payment_method[index2].input2.to_string(),
                        "input2": input2.clone(),
                        "desc3": self.payment_method[index2].input3.to_string(),
                        "input3": input3.clone(),
                        "desc4": self.payment_method[index2].input4.to_string(),
                        "input4": input4.clone(),
                        "desc5": self.payment_method[index2].input5.to_string(),
                        "input5": input5.clone(),
                    }
                }).to_string(),
            );

            self.payment_method_user.push(data);
            
            payment_method_id.to_string()
        } else {
            env::panic_str("Repeated payment methods are not allowed");
        }
    }

    //Set the Payment Method User object into the contract
    pub fn set_payment_method_user_admin(&mut self, user_id: AccountId
        , payment_method_id: i128
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) -> String {
        self.administrators.iter().find(|&x| x == &env::signer_account_id()).expect("Only administrators");
        let duplicado  = self.payment_method_user.iter().find(|x| x.payment_method_id == payment_method_id && x.user_id == user_id.clone());
        
        if duplicado.is_none() {
            let index2 = self.payment_method.iter().position(|x| x.id == payment_method_id).expect("Payment method does not exist");
            
            let data = PaymentMethodUserObject {
                user_id: user_id.clone(),
                payment_method_id: payment_method_id,
                payment_method: self.payment_method[index2].payment_method.to_string(),
                desc1: self.payment_method[index2].input1.to_string(),
                input1: input1.clone(),
                desc2: self.payment_method[index2].input2.to_string(),
                input2: input2.clone(),
                desc3: self.payment_method[index2].input3.to_string(),
                input3: input3.clone(),
                desc4: self.payment_method[index2].input4.to_string(),
                input4: input4.clone(),
                desc5: self.payment_method[index2].input5.to_string(),
                input5: input5.clone(),
            };

            env::log_str(
                &json!({
                    "type": "set_payment_method_user_admin",
                    "params": {
                        "user_id": user_id,
                        "payment_method_id": payment_method_id.to_string(),
                        "payment_method": self.payment_method[index2].payment_method.to_string(),
                        "desc1": self.payment_method[index2].input1.to_string(),
                        "input1": input1.clone(),
                        "desc2": self.payment_method[index2].input2.to_string(),
                        "input2": input2.clone(),
                        "desc3": self.payment_method[index2].input3.to_string(),
                        "input3": input3.clone(),
                        "desc4": self.payment_method[index2].input4.to_string(),
                        "input4": input4.clone(),
                        "desc5": self.payment_method[index2].input5.to_string(),
                        "input5": input5.clone(),
                    }
                }).to_string(),
            );

            self.payment_method_user.push(data);
            
            payment_method_id.to_string()
        } else {
            env::panic_str("Repeated payment methods are not allowed");
        }
    }

    /// put the Payment Method object into the contract
    pub fn put_payment_method_user(&mut self, payment_method_id: i128
        , input1: String
        , input2: String
        , input3: String
        , input4: String
        , input5: String
    ) {
        let i = self.payment_method_user.iter().position(|x| x.payment_method_id == payment_method_id && x.user_id == env::signer_account_id()).expect("payment method user does not exist");
            
        self.payment_method_user[i].input1 = input1.to_string();
        self.payment_method_user[i].input2 = input2.to_string();
        self.payment_method_user[i].input3 = input3.to_string();
        self.payment_method_user[i].input4 = input4.to_string();
        self.payment_method_user[i].input5 = input5.to_string();
            
        env::log_str(
            &json!({
                "type": "put_payment_method_user",
                "params": {
                    "user_id": env::signer_account_id(),
                    "payment_method_id": payment_method_id.to_string(),
                    "input1": input1.to_string(),
                    "input2": input2.to_string(),
                    "input3": input3.to_string(),
                    "input4": input4.to_string(),
                    "input5": input5.to_string(),
                }
            }).to_string(),
        );
    }

    /// delete the Payment Method user object into the contract
    pub fn delete_payment_method_user(&mut self, payment_method_id: i128) {
        let i = self.payment_method_user.iter().position(|x| x.payment_method_id == payment_method_id && x.user_id == env::signer_account_id()).expect("payment method user does not exist");    
        self.payment_method_user.remove(i);
            
        env::log_str(
            &json!({
                "type": "delete_payment_method_user",
                "params": {
                    "user_id": env::signer_account_id(),
                    "payment_method_id": payment_method_id.to_string(),
                }
            }).to_string(),
        );
    }

    pub fn get_order_sell(self,
        order_id: Option<i128>,
        offer_id: Option<i128>,
        owner_id: Option<AccountId>,
        signer_id: Option<AccountId>,
        status: Option<i8>,
        asset: Option<String>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> SearchOrderObject {
        if self.orders_sell.len() > 0 {
            search_order(self.orders_sell, order_id, offer_id, owner_id, signer_id, status, asset, from_index, limit)
        } else {
            SearchOrderObject {
                total_index: 0,
                data: [].to_vec(),
            }
        }
    }

    pub fn get_order_buy(self,
        order_id: Option<i128>,
        offer_id: Option<i128>,
        owner_id: Option<AccountId>,
        signer_id: Option<AccountId>,
        status: Option<i8>,
        asset: Option<String>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> SearchOrderObject {
        if self.orders_buy.len() > 0 {
            search_order(self.orders_buy, order_id, offer_id, owner_id, signer_id, status, asset, from_index, limit)
        } else {
            SearchOrderObject {
                total_index: 0,
                data: [].to_vec(),
            }
        }
    }
    
    pub fn get_order_history_sell(self,
        user_id: Option<AccountId>,
        order_id: Option<i128>,
        status: Option<i8>,
        asset: Option<String>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> SearchOrderObject {
        if self.order_history_sell.len() > 0 {
            search_order_history(self.order_history_sell, user_id, order_id, status, asset, from_index, limit)
        } else {
            SearchOrderObject {
                total_index: 0,
                data: [].to_vec(),
            }
        }
    }

    pub fn get_order_history_buy(self,
        user_id: Option<AccountId>,
        order_id: Option<i128>,
        status: Option<i8>,
        asset: Option<String>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> SearchOrderObject {
        if self.order_history_buy.len() > 0 {
            search_order_history(self.order_history_buy, user_id, order_id, status, asset, from_index, limit)
        } else {
            SearchOrderObject {
                total_index: 0,
                data: [].to_vec(),
            }
        }
    }

}

fn search_offer(data: Vec<OfferObject>,
    amount: Option<U128>,
    fiat_method: Option<i128>,
    payment_method: Option<i128>,
    is_merchant: Option<bool>,
    owner_id: Option<AccountId>,
    status: Option<i8>,
    offer_id: Option<i128>,
    asset: Option<String>,
    signer_id: Option<AccountId>,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> SearchOfferObject {

    
    let mut result: Vec<OfferObject> = data;

    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    assert!(
        (result.len() as u128) > start_index,
        "Out of bounds, please use a smaller from_index."
    );
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    assert_ne!(limit, 0, "Cannot provide limit of 0.");

    if signer_id.is_some() {
        result = result.iter().filter(|x| x.owner_id != AccountId::new_unchecked(signer_id.as_ref().unwrap().to_string()))
                    .map(|r| r.clone()).collect();
    }
    if fiat_method.is_some() {
        result = result.iter().filter(|x| x.fiat_method == fiat_method.unwrap())
                    .map(|r| r.clone()).collect();
    }
    if payment_method.is_some() {
        result = result.iter().filter(|x| x.payment_method.iter().filter(|z| z.id.parse::<i128>().unwrap() == payment_method.unwrap()).count() > 0 )
                    .map(|r| r.clone()).collect();
    }
    if is_merchant.is_some() {
        result = result.iter().filter(|x| x.is_merchant == is_merchant.unwrap())
                    .map(|r| r.clone()).collect();
    }
    if owner_id.is_some() {
        result = result.iter().filter(|x| x.owner_id == AccountId::new_unchecked(owner_id.as_ref().unwrap().to_string()))
                    .map(|r| r.clone()).collect();
    }
    if status.is_some() {
        result = result.iter().filter(|x| x.status == status.unwrap())
                    .map(|r| r.clone()).collect();
    }
    if offer_id.is_some() {
        result = result.iter().filter(|x| x.offer_id == offer_id.unwrap())
                    .map(|r| r.clone()).collect();
    }
    if asset.is_some() {
        result = result.iter().filter(|x| x.asset == asset.as_ref().unwrap().to_string())
                    .map(|r| r.clone()).collect();
    }

    if amount.is_some() {
        result = result.iter().filter(|x| x.amount >= amount.unwrap().0)
                .map(|r| r.clone()).collect();
        /*if asset.is_some() {
            if asset.as_ref().unwrap().to_string() == "NEAR" {
                let monto: u128 = (amount.unwrap().0 * 1000000000000000000000000) as u128;
                result = result.iter().filter(|x| x.amount >= monto)
                        .map(|r| r.clone()).collect();
            } else {
                result = result.iter().filter(|x| x.amount >= amount.unwrap().0)
                        .map(|r| r.clone()).collect();
            }
        }*/
    }

    SearchOfferObject {
        total_index: result.len() as i128,
        data: result.iter()
        .skip(start_index as usize)
        .take(limit)
        .map(|r| r.clone()).collect(),
    }
}

fn search_order(data: Vec<OrderObject>,
    order_id: Option<i128>,
    offer_id: Option<i128>,
    owner_id: Option<AccountId>,
    signer_id: Option<AccountId>,
    status: Option<i8>,
    asset: Option<String>,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> SearchOrderObject {
    let mut result: Vec<OrderObject> = data;

    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    assert!(
        (result.len() as u128) > start_index,
        "Out of bounds, please use a smaller from_index."
    );
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    assert_ne!(limit, 0, "Cannot provide limit of 0.");
    
    if order_id.is_some() {
        result = result.iter().filter(|x| x.order_id == order_id.unwrap())
                    .map(|r| r.clone()).collect();
    }
    
    if offer_id.is_some() {
        result = result.iter().filter(|x| x.offer_id == offer_id.unwrap())
                    .map(|r| r.clone()).collect();
    }

    if owner_id.is_some() {
        let user = owner_id.unwrap().clone();
        result = result.iter().filter(|x| x.owner_id == AccountId::new_unchecked(user.to_string()))
                    .map(|r| r.clone()).collect();
    }
    
    if signer_id.is_some() {
        let user = signer_id.unwrap().clone();
        result = result.iter().filter(|x| x.signer_id == AccountId::new_unchecked(user.to_string()))
                    .map(|r| r.clone()).collect();
    }
    
    if status.is_some() {
        result = result.iter().filter(|x| x.status == status.unwrap())
                    .map(|r| r.clone()).collect();
    }

    if asset.is_some() {
        result = result.iter().filter(|x| x.asset == asset.as_ref().unwrap().clone())
                    .map(|r| r.clone()).collect();
    }

    SearchOrderObject {
        total_index: result.len() as i128,
        data: result.iter()
        .skip(start_index as usize)
        .take(limit)
        .map(|r| r.clone()).collect(),
    }
}

fn search_order_history(data: Vec<OrderObject>,
    user_id: Option<AccountId>,
    order_id: Option<i128>,
    status: Option<i8>,
    asset: Option<String>,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> SearchOrderObject {
    let mut result: Vec<OrderObject> = data.iter()
    .map(|s| s.clone()).collect();

    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    assert!(
        (result.len() as u128) > start_index,
        "Out of bounds, please use a smaller from_index."
    );
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    assert_ne!(limit, 0, "Cannot provide limit of 0.");

    if status.is_some() {
        result = result.iter().filter(|s| s.status == status.unwrap())
                .map(|s| s.clone()).collect();
    }

    if user_id.is_some() {
        let user = user_id.unwrap().clone();
        result = result.iter().filter(|s| s.owner_id == AccountId::new_unchecked(user.to_string()) || s.signer_id == AccountId::new_unchecked(user.to_string()))
                .map(|s| s.clone()).collect();
    }

    if order_id.is_some() {
        result = result.iter().filter(|s| s.order_id == order_id.unwrap())
                .map(|s| s.clone()).collect();
    } 

    if asset.is_some() {
        result = result.iter().filter(|s| s.asset == asset.as_ref().unwrap().clone())
                .map(|s| s.clone()).collect();
    }

    SearchOrderObject {
        total_index: result.len() as i128,
        data: result.iter().rev()
        .skip(start_index as usize)
        .take(limit)
        .map(|s| s.clone()).collect(),
    }
}

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // part of writing unit tests is setting up a mock context
    // in this example, this is only needed for env::log in the contract
    // this is also a useful list to peek at when wondering what's available in env::*
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "robert.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn set_order() {
        let context = get_context(vec![], false);
        testing_env!(context);
        //let attached_deposit = env::attached_deposit();
        let mut contract = NearP2P::default();
        let account_id = "p2p-testnet.testnet".to_string();
        let asset = "NEAR".to_string();
        let price = "14.5".to_string();
        let amount = "100".to_string();
        let min_limit = "10".to_string();
        let max_limit = "100".to_string();
        let order_type = 1;
        let payment_method = 1;
        let orders_completed = 0;
        let percentaje_completion = 0;
        let badge = "super star".to_string();
        //contract.set_offers(account_id, asset, price, amount, min_limit, max_limit, order_type, payment_method, orders_completed, percentaje_completion, badge);
        //assert_eq!(contract.get_offers().len(), 1);
    }

    #[test]
    fn test_lock() {
        let context = get_context(vec![], false);
        testing_env!(context);
        //let attached_deposit = env::attached_deposit();
        let mut contract = NearP2P::default();
        let escrow_account_id = env::predecessor_account_id();
        let account_id = "p2p-testnet.testnet".to_string();
        //contract.lock(account_id.to_string());
        //print!("Locked balance: {}", contract.get_locked_balance(account_id.to_string(), escrow_account_id));
    }
    
}

'''
'''--- src/offer.rs ---
use crate::*;

#[near_bindgen]
impl NearP2P {
    /*pub fn desplegar(&mut self) {
        let signer: AccountId = AccountId::new_unchecked(env::signer_account_id().as_str().split('.').collect::<Vec<&str>>()[0].to_string());
        let subaccount_id: AccountId = AccountId::new_unchecked(
        format!("2{}.{}", signer, env::current_account_id())
        );
        Promise::new(subaccount_id.clone())
            .create_account()
            .transfer(1600000000000000000000000)
            .deploy_contract(CODE.to_vec())
            .then(ext_subcontract::new(
                env::current_account_id(),
                env::current_account_id(),
                AccountId::new_unchecked("vault.nearp2pdex.near".to_string()),
                subaccount_id.clone(),
                0,
                BASE_GAS,
            ));

            ext_usdc::storage_deposit(
                true,
                subaccount_id.clone(),
                AccountId::new_unchecked(CONTRACT_USDC.to_string()),
                100000000000000000000000,
                BASE_GAS,
            );
    }

  

    #[payable]
    pub fn transferir(&mut self, sub_contract: AccountId) -> Promise {
        ext_subcontract::transfer(
            env::signer_account_id(),
            U128(1000000000000000000),                            
            U128(0),
            None,
            true,
            "NEAR".to_string(),
            sub_contract,
            1,
            Gas(3_000_000_000_000),
        )
    }

    #[payable]
    pub fn transferir2(&mut self, sub_contract: AccountId) -> Promise {
        ext_usdc::ft_transfer(
            sub_contract,
            U128(1000000),
            None,
            AccountId::new_unchecked(CONTRACT_USDC.to_string()),
            1,
            BASE_GAS,
        )
    }*/

    
    /// accept offer into the contract
    /// Params: offer_type: 1 = sell, 2 = buy
    #[payable]
    pub fn accept_offer(&mut self, offer_type: i8
        , offer_id: i128
        , amount: U128
        , payment_method: i128
        , datetime: String
        , rate: f64
    ) {
        let attached_deposit = env::attached_deposit();
        let result_referente = self.referidos.get(&env::signer_account_id());
        let mut referente: Option<AccountId> = None;
        
        if result_referente.is_some() {
            referente = result_referente.expect("error").referente.clone();
        }

        if offer_type == 1 {
            require!(attached_deposit >= 1, "you have to deposit a minimum one YoctoNEAR");

            let offer = self.offers_sell.get(&offer_id).expect("Offer sell not found");
            let signer_id = env::signer_account_id();
            require!(offer.owner_id != signer_id, "you can not accept your own offer");

            #[warn(unused_assignments)]
            let contract_name = self.contract_list.get(&signer_id).expect("the user does not have a sub contract deployed");
            
            match offer.asset.as_str() {
                "NEAR" => {
                    ext_subcontract::block_balance_near(
                        amount,
                        contract_name.contract.clone(),
                        0,
                        GAS_FOR_BLOCK,
                    ).then(
                        int_offer::on_accept_offer_sell(
                            offer
                            , amount
                            , payment_method
                            , datetime
                            , rate
                            , referente.clone()
                            , env::current_account_id()
                            , 0
                            , GAS_ON_ACCEPT_OFFER_SELL
                    ));
                }, 
                _=> {
                    let contract_ft = self.ft_token_list.get(&offer.asset).expect("El ft_token subministrado en la oferta es incorrecto");
                    
                    ext_subcontract::block_balance_token(
                        contract_ft.contract,
                        offer.asset.clone(),
                        amount,
                        contract_name.contract.clone(),
                        0,
                        GAS_FOR_BLOCK,
                    ).then(
                        int_offer::on_accept_offer_sell(
                            offer.clone()
                            , amount
                            , payment_method
                            , datetime
                            , rate
                            , referente.clone()
                            , env::current_account_id()
                            , 0
                            , GAS_ON_ACCEPT_OFFER_SELL
                    ));
                },
                _=> env::panic_str("The requested asset does not exist")
            };
        } else if offer_type == 2 {
            require!(attached_deposit >= 1, "you have to deposit a minimum of one YoctoNear");

            let mut offer = self.offers_buy.get(&offer_id).expect("Offer buy not found");
            
            require!(offer.owner_id != env::signer_account_id(), "you can not accept your own offer");
            require!(offer.remaining_amount >= amount.0, "the quantity is greater than the offer buy amount");
            
                
            let remaining: u128 = offer.remaining_amount - amount.0;
            if remaining <= 0 {
                offer.status = 2;
            }

            if offer.max_limit > remaining {
                offer.max_limit = remaining;
            }
            if offer.min_limit > remaining {
                match offer.asset.as_str() {
                    "NEAR" => offer.min_limit = 1000000000000000000000000,
                    _=> {
                        let contract_ft = self.ft_token_list.get(&offer.asset).expect("El ft_token subministrado en la oferta es incorrecto");
                        offer.min_limit = contract_ft.min_limit; //1000000
                    }
                };
            }

            let fee: u128 = (amount.0 * FEE_TRANSACTION_NEAR) / 100000;
            //let fee_deducted = amount - fee;
            offer.remaining_amount = remaining;

            self.offers_buy.insert(&offer_id, &offer.clone());

            self.order_buy_id += 1;
            let data = OrderObject {
                offer_id: offer_id,
                order_id: self.order_buy_id,
                owner_id: offer.owner_id.clone(),
                asset: offer.asset.clone(),
                signer_id: env::signer_account_id(),
                exchange_rate: rate.to_string(),
                operation_amount: amount.0,
                amount_delivered: amount.0 - fee,
                fee_deducted: fee,
                payment_method: payment_method,
                fiat_method: offer.fiat_method,
                confirmation_owner_id: 0,
                confirmation_signer_id: 0,
                confirmation_current: 0,
                referente: referente.clone(),
                time: offer.time,
                datetime: datetime.clone(),
                terms_conditions: offer.terms_conditions.clone(),
                status: 1,
            };

            self.orders_buy.insert(&self.order_buy_id, &data);

            let amount_delivered: U128 = U128(amount.0 - fee);

            env::log_str(
                &json!({
                    "type": "accept_offer_buy",
                    "params": {
                        "offer_id": offer_id.to_string(),
                        "order_id": self.order_buy_id.to_string(),
                        "owner_id": offer.owner_id.clone(),
                        "asset": offer.asset.clone(),
                        "signer_id": env::signer_account_id(),
                        "exchange_rate": rate.to_string(),
                        "operation_amount": amount,
                        "amount_delivered": amount_delivered,
                        "fee_deducted": U128(fee),
                        "payment_method": payment_method.to_string(),
                        "fiat_method": offer.fiat_method.to_string(),
                        "confirmation_owner_id": "0".to_string(),
                        "confirmation_signer_id": "0".to_string(),
                        "confirmation_current": "0".to_string(),
                        "referente": referente.clone(),
                        "time": offer.time.to_string(),
                        "datetime": datetime.clone(),
                        "terms_conditions": offer.terms_conditions.clone(),
                        "status": "1".to_string(),
                    }
                }).to_string(),
            );
            
            //actualizar total ordenes owner_id
            /*let mut index = self.merchant.iter().position(|x| x.user_id == self.offers_buy[offer].owner_id.clone()).expect("owner not merchant");
            self.merchant[index].total_orders += 1;
            self.merchant[index].percentaje_completion = (self.merchant[index].orders_completed as f64 / self.merchant[index].total_orders as f64) * 100.0;
            index = self.merchant.iter().position(|x| x.user_id == env::signer_account_id().clone()).expect("owner not merchant");
            self.merchant[index].total_orders += 1;
            self.merchant[index].percentaje_completion = (self.merchant[index].orders_completed as f64 / self.merchant[index].total_orders as f64) * 100.0;*/

        }   else {
            //require!(attached_deposit >= 1, "you have to deposit a minimum of one YoctoNear");
            env::panic_str("Invalid offer type");
        }
    }

    #[private]
    pub fn on_accept_offer_sell(&mut self, mut offer: OfferObject
        , amount: U128
        , payment_method: i128
        , datetime: String
        , rate: f64
        , referente: Option<AccountId>
    ) {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
       
        
        let valid: bool = near_sdk::serde_json::from_slice::<bool>(&result.unwrap()).expect("bool");
        require!(valid, "No balance");

        let remaining: u128 = offer.remaining_amount - amount.0;
        if remaining <= 0 {
            offer.status = 2;
        }
        
        if offer.max_limit > remaining {
            offer.max_limit = remaining;
        }
        if offer.min_limit > remaining {
            match offer.asset.as_str() {
                "NEAR" => offer.min_limit = 1000000000000000000000000,
                _=> offer.min_limit = 1000000,
            };
        }
        
        let fee: u128 = (amount.0 * FEE_TRANSACTION_NEAR) / 100000;

        offer.remaining_amount = remaining;

        self.offers_sell.insert(&offer.offer_id, &offer);
        
        
        self.order_sell_id += 1;
        let data = OrderObject {
            offer_id: offer.offer_id,
            order_id: self.order_sell_id,
            owner_id: offer.owner_id.clone(),
            asset: offer.asset.clone(),
            signer_id: env::signer_account_id(),
            exchange_rate: rate.to_string(),
            operation_amount: amount.0,
            amount_delivered: amount.0 - fee,
            fee_deducted: fee,
            payment_method: payment_method,
            fiat_method: offer.fiat_method,
            confirmation_owner_id: 0,
            confirmation_signer_id: 0,
            confirmation_current: 0,
            referente: referente.clone(),
            time: offer.time,
            datetime: datetime.clone(),
            terms_conditions: offer.terms_conditions.to_string(),
            status: 1,
        };
        
        let amount_delivered: U128 = U128(amount.0 - fee);
       
        self.orders_sell.insert(&self.order_sell_id, &data);
       
        env::log_str(
            &json!({
                "type": "accept_offer_sell",
                "params": {
                    "offer_id": offer.offer_id.to_string(),
                    "order_id": self.order_sell_id.to_string(),
                    "owner_id": offer.owner_id.clone(),
                    "asset": offer.asset.clone(),
                    "signer_id": env::signer_account_id(),
                    "exchange_rate": rate.to_string(),
                    "operation_amount": amount,
                    "amount_delivered": amount_delivered,
                    "fee_deducted": U128(fee),
                    "payment_method": payment_method.to_string(),
                    "fiat_method": offer.fiat_method.to_string(),
                    "confirmation_owner_id": "0".to_string(),
                    "confirmation_signer_id": "0".to_string(),
                    "confirmation_current": "0".to_string(),
                    "referente": referente.clone(),
                    "time": offer.time.to_string(),
                    "datetime": datetime.clone(),
                    "terms_conditions": offer.terms_conditions.clone(),
                    "status": "1".to_string(),
                }
            }).to_string(),
        );

        //actualizar total ordenes owner_id
        /*let mut index = self.merchant.iter().position(|x| x.user_id == self.offers_sell[offer].owner_id.clone()).expect("owner not merchant");
        self.merchant[index].total_orders += 1;
        self.merchant[index].percentaje_completion = (self.merchant[index].orders_completed as f64 / self.merchant[index].total_orders as f64) * 100.0;
        index = self.merchant.iter().position(|x| x.user_id == env::signer_account_id().clone()).expect("owner not merchant");
        self.merchant[index].total_orders += 1;
        self.merchant[index].percentaje_completion = (self.merchant[index].orders_completed as f64 / self.merchant[index].total_orders as f64) * 100.0;*/
    }
}
'''
'''--- src/process.rs ---
use crate::*;

#[near_bindgen]
impl NearP2P {
    /// confirmation order into the contract
    /// Params: offer_type: 1 = sell, 2 = buy
    // #[payable]

    pub fn delete_order(&mut self, offer_type: i8, order_id: i128) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        if offer_type == 1{
            self.orders_sell.remove(&order_id).expect("Order Sell not found");
        } else if offer_type == 2 {
            self.orders_buy.remove(&order_id).expect("Order Sell not found");
        } else {
            env::panic_str("offer type no found");
        }
        
    }

    pub fn order_confirmation(&mut self, offer_type: i8, order_id: i128) {
        require!(env::attached_deposit() >= 1, "Requires attached deposit of at least 1 yoctoNEAR");
        let contract_ft: Option<AccountId>;
        let ft_token: String;
        let mut status: i8;
        if offer_type == 1 {
            let mut order = self.orders_sell.get(&order_id).expect("Order Sell not found");
            if order.owner_id == env::signer_account_id() {
                order.confirmation_owner_id = 1;
                if order.status == 1 {
                    order.status = 2;
                }
                self.orders_sell.insert(&order_id, &order);

                env::log_str(
                    &json!({
                        "type": "order_confirmation_owner",
                        "params": {
                            "offer_type": offer_type.to_string(),
                            "order_id": order_id.to_string(),
                            "confirmation_owner_id": "1".to_string(),
                            "status": order.status.to_string(),
                        }
                    }).to_string(),
                );
            } else if order.signer_id == env::signer_account_id() { 
                status = order.status;
                if order.status == 1 {
                    status = 2;
                }

                let offer = self.offers_sell.get(&order.offer_id).expect("Offer sell not found");

                #[warn(unused_assignments)]
                let contract_name = self.contract_list.get(&order.signer_id).expect("the user does not have a sub contract deployed");

                match offer.asset.as_str(){
                    "NEAR" => {
                        contract_ft = None;
                        ft_token = "NEAR".to_string();
                    },
                    _=> {
                        contract_ft = Some(self.ft_token_list.get(&offer.asset).expect("El asset subministrado en la oferta es incorrecto").contract); //Some(AccountId::new_unchecked(CONTRACT_USDC.to_string()));
                        ft_token = offer.asset;
                    },
                };
                
                ext_subcontract::transfer(
                    order.owner_id.clone(),
                    U128(order.operation_amount),
                    U128(order.fee_deducted),
                    contract_ft,
                    false,
                    ft_token,
                    contract_name.contract.clone(),
                    2,
                    GAS_FOR_TRANSFER,
                ).then(int_process::on_confirmation(
                    status,
                    1,
                    /*ContractList{contract: contract_name.contract.clone(), type_contract: contract_name.type_contract.clone()},
                    self.orders_sell[i].signer_id.clone(),*/
                    order.clone(),
                    true,
                    order.confirmation_owner_id,
                    1,
                    order.confirmation_current,
                    env::current_account_id(),
                    0,
                    GAS_ON_CONFIRMATION,
                ));
            } else {
                env::panic_str("Server internar error, signer not found");
            }
        } else if offer_type == 2 {
            let mut order = self.orders_buy.get(&order_id).expect("Order buy not found");
            
            if order.signer_id == env::signer_account_id() {
                order.confirmation_signer_id = 1;
                if order.status == 1 {
                    order.status = 2;
                }

                self.orders_buy.insert(&order_id, &order);

                env::log_str(
                    &json!({
                        "type": "order_confirmation_signer",
                        "params": {
                            "offer_type": offer_type.to_string(),
                            "order_id": order_id.to_string(),
                            "confirmation_signer_id": "1".to_string(),
                            "status": order.status.to_string(),
                        }
                    }).to_string(),
                );
            } else if order.owner_id == env::signer_account_id() {
                status = order.status;
                if order.status == 1 {
                    status = 2;
                }

                let offer = self.offers_buy.get(&order.offer_id).expect("Offer buy not found");

                #[warn(unused_assignments)]
                let contract_name = self.contract_list.get(&order.owner_id).expect("the user does not have a sub contract deployed");
               
                match offer.asset.as_str(){
                    "NEAR" => {
                        contract_ft = None;
                        ft_token = "NEAR".to_string();
                    },
                    _=> {
                        contract_ft = Some(self.ft_token_list.get(&offer.asset).expect("El asset subministrado en la oferta es incorrecto").contract); //Some(AccountId::new_unchecked(CONTRACT_USDC.to_string()));
                        ft_token = offer.asset;
                    },
                };
                
                ext_subcontract::transfer(
                    order.signer_id.clone(),
                    U128(order.operation_amount),
                    U128(order.fee_deducted),
                    contract_ft,
                    false,
                    ft_token,
                    contract_name.contract.clone(),
                    2,
                    GAS_FOR_TRANSFER,
                ).then(int_process::on_confirmation(
                    status,
                    2,
                    /*ContractList{contract: contract_name.contract.clone(), type_contract: contract_name.type_contract.clone()},
                    self.orders_buy[i].owner_id.clone(),*/
                    order.clone(),
                    true,
                    1,
                    order.confirmation_signer_id,
                    order.confirmation_current,
                    env::current_account_id(),
                    0,
                    GAS_ON_CONFIRMATION,
                ));
            } else {
                env::panic_str("Server internar error, signer not found");
            }
        }  else {
            env::panic_str("Invalid offer type");
        }
    }

    // #[payable]
    pub fn cancel_order(&mut self, offer_type: i8, order_id: i128) {
        assert_one_yocto();
        let contract_ft: Option<AccountId>;
        let ft_token: String;
        let mut status: i8;
        if offer_type == 1 {
            let mut order = self.orders_sell.get(&order_id).expect("Order Sell not found");
            
            if order.owner_id == env::signer_account_id() {
                let offer = self.offers_sell.get(&order.offer_id).expect("Offer Sell not found");
                
                status = order.status;
                if order.status == 1 || order.status == 2 {
                    status = 4;
                }

                #[warn(unused_assignments)]
                let contract_name = self.contract_list.get(&order.signer_id).expect("the user does not have a sub contract deployed");

                match offer.asset.as_str(){
                    "NEAR" => {
                        contract_ft = None;
                        ft_token = "NEAR".to_string();
                    },
                    _=> {
                        contract_ft = Some(self.ft_token_list.get(&offer.asset).expect("El asset subministrado en la oferta es incorrecto").contract); //Some(AccountId::new_unchecked(CONTRACT_USDC.to_string()));
                        ft_token = offer.asset;
                    },
                };
                
                ext_subcontract::transfer(
                    order.signer_id.clone(),
                    U128(order.operation_amount),
                    U128(0),
                    contract_ft,
                    false,
                    ft_token,
                    contract_name.contract.clone(),
                    1,
                    GAS_FOR_TRANSFER,
                ).then(int_process::on_confirmation(
                    status,
                    1,
                    /*ContractList{contract: contract_name.contract.clone(), type_contract: contract_name.type_contract.clone()},
                    self.orders_sell[i].signer_id.clone(),*/
                    order.clone(),
                    false,
                    3,
                    order.confirmation_signer_id,
                    order.confirmation_current,
                    env::current_account_id(),
                    0,
                    GAS_ON_CONFIRMATION,
                ));
                
            } else if order.signer_id == env::signer_account_id() {
                order.confirmation_signer_id = 3;
                if order.status == 1 || order.status == 2 {
                    order.status = 4;
                }

                self.orders_sell.insert(&order_id, &order);

                env::log_str(
                    &json!({
                        "type": "cancel_order_signer",
                        "params": {
                            "offer_type": offer_type.to_string(),
                            "order_id": order_id.to_string(),
                            "confirmation_signer_id": "3".to_string(),
                            "status": order.status.to_string(),
                        }
                    }).to_string(),
                );
            } else {
                env::panic_str("Server internar error, signer not found");  
            }
        } else if offer_type == 2 {
            let mut order = self.orders_buy.get(&order_id).expect("Order buy not found");

            if order.owner_id == env::signer_account_id() {
                order.confirmation_owner_id = 3;
                if order.status == 1 || order.status == 2 {
                    order.status = 4;
                }

                self.orders_sell.insert(&order_id, &order);

                env::log_str(
                    &json!({
                        "type": "cancel_order_owner",
                        "params": {
                            "offer_type": offer_type.to_string(),
                            "order_id": order_id.to_string(),
                            "confirmation_owner_id": "3".to_string(),
                            "status": order.status.to_string(),
                        }
                    }).to_string(),
                );
            } else if order.signer_id == env::signer_account_id() {
                let offer = self.offers_buy.get(&order.offer_id).expect("Offer buy not found");
                
                status = order.status;
                if order.status == 1 || order.status == 2 {
                    status = 4;
                }

                #[warn(unused_assignments)]
                let contract = self.contract_list.get(&order.owner_id).expect("the user does not have a sub contract deployed");

                match offer.asset.as_str(){
                    "NEAR" => {
                        contract_ft = None;
                        ft_token = "NEAR".to_string();
                    },
                    _=> {
                        contract_ft = Some(self.ft_token_list.get(&offer.asset).expect("El asset subministrado en la oferta es incorrecto").contract); //Some(AccountId::new_unchecked(CONTRACT_USDC.to_string()));
                        ft_token = offer.asset;
                    },
                };

                ext_subcontract::transfer(
                    order.owner_id.clone(),
                    U128(order.operation_amount),
                    U128(0),
                    contract_ft,
                    false,
                    ft_token,
                    contract.contract.clone(),
                    1,
                    GAS_FOR_TRANSFER,
                ).then(int_process::on_confirmation(
                    status,
                    2,
                    /*ContractList{contract: contract.contract.clone(), type_contract: contract.type_contract.clone()},
                    self.orders_buy[i].owner_id.clone(),*/
                    order.clone(),
                    false,
                    order.confirmation_owner_id,
                    3,
                    order.confirmation_current,
                    env::current_account_id(),
                    0,
                    GAS_ON_CONFIRMATION,
                ));

            } else {
                env::panic_str("Server internar error, signer not found");  
            }
        }  else {
            env::panic_str("Invalid offer type");
        }
    }

    #[private]
    pub fn on_confirmation(&mut self,
        status: i8,
        order_type: i8,
        /*data_contract: ContractList,
        signer_id: AccountId,*/
        mut order: OrderObject,
        confirmacion: bool,
        confirmation_owner_id: i8,
        confirmation_signer_id: i8,
        confirmation_current: i8,
    ) {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("balance is None".as_ref());
        }

        order.status = status;
        order.confirmation_owner_id = confirmation_owner_id;
        order.confirmation_signer_id = confirmation_signer_id;
        order.confirmation_current = confirmation_current;

        if order_type == 1 {
            /*if confirmacion == true {
                self.orders_sell_completed(index);
            }*/
            self.orders_sell.remove(&order.order_id);
            
            env::log_str(
                &json!({
                    "type": "on_confirmation_sell",
                    "params": {
                        "offer_id": order.offer_id.to_string(),
                        "order_id": order.order_id.to_string(),
                        "owner_id": order.owner_id.clone(),
                        "asset": order.asset.clone(),
                        "signer_id": order.signer_id.clone(),
                        "exchange_rate": order.exchange_rate.clone(),
                        "operation_amount": order.operation_amount.to_string(),
                        "amount_delivered": order.amount_delivered.to_string(),
                        "fee_deducted": order.fee_deducted.to_string(),
                        "payment_method": order.payment_method.to_string(),
                        "fiat_method": order.fiat_method.to_string(),
                        "confirmation_owner_id": order.confirmation_owner_id.to_string(),
                        "confirmation_signer_id": order.confirmation_signer_id.to_string(),
                        "confirmation_current": order.confirmation_current.to_string(),
                        "referente": order.referente.clone(),
                        "porcentaje_referente": self.porcentaje_referente.to_string(),
                        "porcentaje_referido": self.porcentaje_referido.to_string(),
                        "time": order.time.to_string(),
                        "datetime": order.datetime.clone(),
                        "terms_conditions": order.terms_conditions.clone(),
                        "status": order.status.to_string(),
                        "confirmacion": confirmacion,
                    }
                }).to_string(),
            );

            /*if data_contract.type_contract == 2 {
                ext_subcontract::get_balance_block_total(
                    data_contract.contract.clone(),
                    0,
                    BASE_GAS,
                ).then(int_offer::on_delete_contract_user(
                    signer_id,
                    data_contract.contract,
                    env::current_account_id(),
                    0,
                    Gas(20_000_000_000_000),
                ));
            }*/ 
        } else if order_type == 2 {
            /*if confirmacion  == true {
                self.orders_buy_completed(index);
            }*/
            
            self.orders_buy.remove(&order.order_id);   

            env::log_str(
                &json!({
                    "type": "on_confirmation_buy",
                    "params": {
                        "offer_id": order.offer_id.to_string(),
                        "order_id": order.order_id.to_string(),
                        "owner_id": order.owner_id.clone(),
                        "asset": order.asset.clone(),
                        "signer_id": order.signer_id.clone(),
                        "exchange_rate": order.exchange_rate.clone(),
                        "operation_amount": order.operation_amount.to_string(),
                        "amount_delivered": order.amount_delivered.to_string(),
                        "fee_deducted": order.fee_deducted.to_string(),
                        "payment_method": order.payment_method.to_string(),
                        "fiat_method": order.fiat_method.to_string(),
                        "confirmation_owner_id": order.confirmation_owner_id.to_string(),
                        "confirmation_signer_id": order.confirmation_signer_id.to_string(),
                        "confirmation_current": order.confirmation_current.to_string(),
                        "referente": order.referente.clone(),
                        "porcentaje_referente": self.porcentaje_referente.to_string(),
                        "porcentaje_referido": self.porcentaje_referido.to_string(),
                        "time": order.time.to_string(),
                        "datetime": order.datetime.clone(),
                        "terms_conditions": order.terms_conditions.clone(),
                        "status": order.status.to_string(),
                        "confirmacion": confirmacion,
                    }
                }).to_string(),
            );
        }   
    }

    /*#[private]
    pub fn on_delete_contract_user(&mut self, signer_id: AccountId, sub_contract: AccountId) {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error check balance blocked".as_ref());
        }
        let balance_block = near_sdk::serde_json::from_slice::<u128>(&result.unwrap()).expect("u128");
        //require!(balance_block <= 0, "You still have operations in progress, finish all the operations to be able to delete the contract");
        
        if balance_block <= 0 {
            ext_subcontract::delete_contract(
                sub_contract.clone(),
                0,
                Gas(5_000_000_000_000),
            ).then(int_offer::on_delete_contract_list_user(
                signer_id,
                env::current_account_id(),
                0,
                Gas(5_000_000_000_000),
            ));
            env::log_str("delete")
        } else {
            env::log_str("no delete")
        }

    }

    #[private]
    pub fn on_delete_contract_list_user(&mut self, signer_id: AccountId) {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error al eliminar la cuenta".as_ref());
        }
        self.contract_list.remove(&signer_id);
    }*/

    /*#[private]
    fn orders_sell_completed(&mut self, index_order: usize) {
        let mut index = self.merchant.iter().position(|x| x.user_id == self.orders_sell[index_order].owner_id.clone()).expect("owner not merchant");
        self.merchant[index].orders_completed += 1;
        self.merchant[index].percentaje_completion = (self.merchant[index].orders_completed as f64 / self.merchant[index].total_orders as f64) * 100.0;
        index = self.merchant.iter().position(|x| x.user_id == self.orders_sell[index_order].signer_id.clone()).expect("owner not merchant");
        self.merchant[index].orders_completed += 1;
        self.merchant[index].percentaje_completion = (self.merchant[index].orders_completed as f64 / self.merchant[index].total_orders as f64) * 100.0;
    }

    #[private]
    fn orders_buy_completed(&mut self, index_order: usize) {
        let mut index = self.merchant.iter().position(|x| x.user_id == self.orders_buy[index_order].owner_id.clone()).expect("owner not merchant");
        self.merchant[index].orders_completed += 1;
        self.merchant[index].percentaje_completion = (self.merchant[index].orders_completed as f64 / self.merchant[index].total_orders as f64) * 100.0;
        index = self.merchant.iter().position(|x| x.user_id == self.orders_buy[index_order].signer_id.clone()).expect("owner not merchant");
        self.merchant[index].orders_completed += 1;
        self.merchant[index].percentaje_completion = (self.merchant[index].orders_completed as f64 / self.merchant[index].total_orders as f64) * 100.0;
    }*/
}
'''
'''--- src/sell.rs ---
use crate::*;

#[near_bindgen]
impl NearP2P {
    /// Returns the order object loaded in contract
    /// Params: campo: String, valor: String
    /*pub fn get_offers_sell(self, amount: Option<U128>,
        fiat_method: Option<i128>,
        payment_method: Option<i128>,
        is_merchant: Option<bool>,
        owner_id: Option<AccountId>,
        status: Option<i8>,
        offer_id: Option<i128>,
        asset: Option<String>,
        signer_id: Option<AccountId>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> SearchOfferObject {
        if self.offers_sell.len() > 0 {
            search_offer(self.offers_sell, amount, fiat_method, payment_method, is_merchant, owner_id, status, offer_id, asset, signer_id, from_index, limit)
        } else {
            SearchOfferObject {
                total_index: 0,
                data: [].to_vec(),
            }
        }
    }*/

    /// Set the offer sell object into the contract
    /// Params: owner_id: String, asset: String, exchange_rate: String, amount: String
    /// min_limit: String, max_limit: String, payment_method_id: String, status: i8
    /// This is a list of offers for sellings operations, will be called by the user
    #[payable]
    pub fn set_offers_sell(&mut self
        , asset: String
        , exchange_rate: String
        , amount: U128
        , min_limit: U128
        , max_limit: U128
        , payment_method: Vec<PaymentMethodsOfferObject>
        , fiat_method: i128
        , time: i64
        , terms_conditions: String
    ) -> i128 {
        require!(env::attached_deposit() >= 100000000000000000000000, "you have to deposit a minimum 0.1 Near");
        let merchant = self.merchant.get(&env::signer_account_id()).expect("the user is not in the list of users");
        
        self.offer_sell_id += 1;
        
        let offer_sell_id = self.offer_sell_id;

        let data = OfferObject {
            offer_id: offer_sell_id,
            owner_id: env::signer_account_id(),
            asset: asset.clone(),
            exchange_rate: exchange_rate.clone(),
            amount: amount.0,
            remaining_amount: amount.0,
            min_limit: min_limit.0,
            max_limit: max_limit.0,
            payment_method: payment_method.clone(),
            fiat_method: fiat_method,
            is_merchant: merchant.is_merchant,
            time: time,
            terms_conditions: terms_conditions.clone(),
            status: 1,
        };

        self.offers_sell.insert(&offer_sell_id, &data);

        //let fiat_method_string: String = fiat_method.to_string();

        env::log_str(
            &json!({
                "type": "set_offers_sell",
                "params": {
                    "offer_id": offer_sell_id.to_string(),
                    "owner_id": env::signer_account_id(),
                    "asset": asset.to_string(),
                    "exchange_rate": exchange_rate.to_string(),
                    "amount": amount,
                    "remaining_amount": amount,
                    "min_limit": min_limit,
                    "max_limit": max_limit,
                    "payment_method": payment_method.clone(),
                    "fiat_method": fiat_method.to_string(),
                    "is_merchant": merchant.is_merchant,
                    "time": time.to_string(),
                    "terms_conditions": terms_conditions.to_string(),
                    "status": "1".to_string(),
                }
            }).to_string(),
        );
       
        self.offer_sell_id
    }

    /*#[payable]
    pub fn put_offers_sell(&mut self, offer_id: i128
        , asset: Option<String>
        , exchange_rate: Option<String>
        , remaining_amount: Option<U128>
        , min_limit: Option<U128>
        , max_limit: Option<U128>
        , payment_method: Option<Vec<PaymentMethodsOfferObject>>
        , fiat_method: Option<i128>
        , time: Option<i64>
        , terms_conditions: Option<String>
    ) -> OfferObject {
        let offer = self.offers_sell.iter().position(|x| x.offer_id == offer_id && x.owner_id == env::signer_account_id()).expect("Offer not found");
        if asset.is_some() {
            self.offers_sell[offer].asset = asset.unwrap();
        }
        if exchange_rate.is_some() {
            self.offers_sell[offer].exchange_rate = exchange_rate.unwrap();
        }
        if remaining_amount.is_some() {
            self.offers_sell[offer].remaining_amount = remaining_amount.unwrap().0;
        }
        if min_limit.is_some() {
            self.offers_sell[offer].min_limit = min_limit.unwrap().0;
        }
        if max_limit.is_some() {
            self.offers_sell[offer].max_limit = max_limit.unwrap().0;
        }
        if payment_method.is_some() {
            self.offers_sell[offer].payment_method = payment_method.unwrap().iter().map(|x| PaymentMethodsOfferObject {id: x.id, payment_method: x.payment_method.clone()}).collect();
        }
        if fiat_method.is_some() {
            self.offers_sell[offer].fiat_method = fiat_method.unwrap();
        }
        if time.is_some() {
            self.offers_sell[offer].time = time.unwrap();
        }
        if terms_conditions.is_some() {
            self.offers_sell[offer].terms_conditions = terms_conditions.unwrap();
        }
        
        env::log_str("Offer updated");
        OfferObject {
            offer_id: offer_id,
            owner_id: self.offers_sell[offer].owner_id.clone(),
            asset: String::from(self.offers_sell[offer].asset.clone()),
            exchange_rate: String::from(self.offers_sell[offer].exchange_rate.clone()),
            amount: self.offers_sell[offer].amount,
            remaining_amount: self.offers_sell[offer].remaining_amount,
            min_limit: self.offers_sell[offer].min_limit,
            max_limit: self.offers_sell[offer].max_limit,
            payment_method: self.offers_sell[offer].payment_method.iter().map(|x| PaymentMethodsOfferObject {id: x.id, payment_method: x.payment_method.clone()}).collect(),
            fiat_method: self.offers_sell[offer].fiat_method,
            is_merchant: self.offers_sell[offer].is_merchant,
            time: self.offers_sell[offer].time,
            terms_conditions: String::from(self.offers_sell[offer].terms_conditions.clone()),
            status: self.offers_sell[offer].status,
        }
    }*/

    #[payable]
    pub fn delete_offers_sell(&mut self, offer_id: i128) {
        assert_one_yocto();
        let offer = self.offers_sell.get(&offer_id).expect("Offer not found");
        
        assert!(offer.owner_id == env::signer_account_id(), "the user is not the creator of this offer");

        self.offers_sell.remove(&offer_id).expect("Offer not found");
        
        env::log_str(
            &json!({
                "type": "delete_offers_sell",
                "params": {
                    "offer_id": offer_id.to_string(),
                }
            }).to_string(),
        );
    }
}
'''
'''--- src/subcontract.rs ---
use crate::*;

#[near_bindgen]
impl NearP2P {
    //send Near
    #[payable]
    pub fn deposit(&mut self, sub_contract: AccountId) -> Promise {
        let attached_deposit = env::attached_deposit();
        assert!(
            attached_deposit >= 1,
            "Requires attached deposit of at least 1 yoctoNEAR",
        );
        //let sub_contract = self.contract_list.get(&env::signer_account_id()).expect("the user does not have contract deployed");
        Promise::new(sub_contract).transfer(attached_deposit)
    }

    pub fn listar_subcuenta(&mut self, account_id: AccountId, subcuenta: AccountId, type_contract: i8) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        self.contract_list.insert(&account_id, &ContractList{ contract: subcuenta, type_contract: type_contract});
    }

    /*#[payable]
    pub fn activar_subcuenta_usdc(&mut self, subaccount_id: AccountId) -> Promise {
        ext_usdc::storage_deposit(
            true,
            subaccount_id,
            AccountId::new_unchecked(CONTRACT_USDC.to_string()),
            100000000000000000000000,
            BASE_GAS,
        )
    }*/

    #[payable]
    pub fn activar_subcuenta_ft(&mut self, subaccount_id: AccountId, asset: String) -> Promise {
        assert!(
            env::attached_deposit() >= 100000000000000000000000,
            "Requires attached deposit of at least 100000000000000000000000 yoctoNEAR",
        );
        
        let contract_ft = self.ft_token_list.get(&asset).expect("The asset supplied in the offer is incorrect");

        let token_activos = self.activate_token_list.get(&env::signer_account_id()).or(Some([].to_vec())).unwrap();

        //assert!(token_activos.iter().find(|&x| x == &asset).is_s(), "The token is already active");

        ext_usdc::storage_deposit(
            true,
            subaccount_id,
            contract_ft.contract,
            100000000000000000000000,
            BASE_GAS,
        ).then(int_sub_contract::on_listar_token_activo(
            env::signer_account_id(),
            asset,
            env::current_account_id(),
            0,
            Gas(10_000_000_000_000)
        ))
    }

    #[payable]
    pub fn create_subcontract_merchant(&mut self) -> Promise {
        let attached_deposit = env::attached_deposit();
        assert!(
            attached_deposit >= 1485000000000000000000000,
            "Requires attached deposit of at least 1485000000000000000000000 yoctoNEAR",
        );
        let signer: AccountId = AccountId::new_unchecked(env::signer_account_id().as_str().split('.').collect::<Vec<&str>>()[0].to_string());
        let subaccount_id: AccountId = AccountId::new_unchecked(
        format!("{}.{}", signer, env::current_account_id())
        );
        let result = Promise::new(subaccount_id.clone())
            .create_account()
            .transfer(env::attached_deposit())
            .deploy_contract(CODE.to_vec())
            .then(ext_subcontract::new(
                env::signer_account_id(),
                env::current_account_id(),
                AccountId::new_unchecked("nearp2p.testnet".to_string()),
                subaccount_id.clone(),
                0,
                BASE_GAS,
            ));

            self.contract_list.insert(&env::signer_account_id(), &ContractList{ contract: subaccount_id.clone(), type_contract: 1 });

            //let verificar_token = self.activate_token_list.get(&env::signer_account_id());

            //if verificar_token.is_none() || verificar_token.unwrap().get(verificar_token.unwrap().iter().position(|x| *x == "USDC".to_string()).unwrap() as usize).is_none() {
            /*if verificar_token.is_none() {
                ext_usdc::storage_deposit(
                    true,
                    subaccount_id,
                    AccountId::new_unchecked(CONTRACT_USDC.to_string()),
                    100000000000000000000000,
                    BASE_GAS,
                ).then(int_sub_contract::on_listar_token_activo(
                    env::signer_account_id(),
                    "USDC".to_string(),
                    env::current_account_id(),
                    0,
                    Gas(10_000_000_000_000),
                ));
            } else {
                Promise::new(env::signer_account_id()).transfer(100000000000000000000000);
            }*/  

        result
    }

    pub fn delete_user_contract_list(&mut self, user_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");
        self.contract_list.remove(&user_id);
    }

    #[payable]
    pub fn create_subcontract_user(&mut self) -> Promise {
        require!(env::attached_deposit() >= 1, "You have to deposit a minimum 1 YoctoNear");
        let signer: AccountId = AccountId::new_unchecked(env::signer_account_id().as_str().split('.').collect::<Vec<&str>>()[0].to_string());
        let subaccount_id: AccountId = AccountId::new_unchecked(
        format!("{}.{}", signer, env::current_account_id())
        );
        let result = Promise::new(subaccount_id.clone())
        .create_account()
        .transfer(1485000000000000000000000)
        .deploy_contract(CODE.to_vec())
        .then(ext_subcontract::new(
            env::current_account_id(),
            env::current_account_id(),
            AccountId::new_unchecked("nearp2p.testnet".to_string()),
            subaccount_id.clone(),
            0,
            BASE_GAS,
        ));

        self.contract_list.insert(&env::signer_account_id(), &ContractList{ contract: subaccount_id.clone(), type_contract: 2 });
        
        /*let verificar_token = self.activate_token_list.get(&env::signer_account_id());

        //if verificar_token.is_none() || verificar_token.unwrap().get(verificar_token.unwrap().iter().position(|x| *x == "USDC".to_string()).unwrap() as usize).is_none() {
        if verificar_token.is_none() {
            ext_usdc::storage_deposit(
                true,
                subaccount_id,
                AccountId::new_unchecked(CONTRACT_USDC.to_string()),
                100000000000000000000000,
                BASE_GAS,
            ).then(int_sub_contract::on_listar_token_activo(
                env::signer_account_id(),
                "USDC".to_string(),
                env::current_account_id(),
                0,
                Gas(10_000_000_000_000)
            ));
        } else {
            Promise::new(env::signer_account_id()).transfer(100000000000000000000000);
        }*/

        result
    }
    
    #[private]
    pub fn on_listar_token_activo(&mut self, signer_id: AccountId, ft_token: String) {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error activate ft_token".as_ref());
        }
        //let listar_token_activo = self.activate_token_list.get(&signer_id);

        /*if listar_token_activo.is_some() {
            let mut tokens: Vec<String> = listar_token_activo.unwrap().iter().map(|x| x.clone()).collect::<Vec<String>>();
            tokens.push(ft_token);
            self.activate_token_list.insert(signer_id, tokens);
        } else {*/
        self.activate_token_list.insert(&signer_id, &vec![ft_token]);
        //}
    }

    pub fn get_token_activo(self, user_id: AccountId) -> bool {
        let tokens = self.activate_token_list.get(&user_id);
        if tokens.is_none() {
            false
        } else {
            true
        }  
    }

    /*pub fn deploy_subcontract(&mut self) -> Promise {
        let contract = self.contract_list.get(&env::signer_account_id()).expect("the user does not have contract deployed");
        Promise::new(AccountId::new_unchecked(contract.to_string())).add_full_access_key(env::signer_account_pk()).deploy_contract(CODE.to_vec())
        .then(Promise::new(AccountId::new_unchecked(contract.to_string())).delete_key(env::signer_account_pk()))
    }*/
    pub fn get_subcontract(self, user_id: AccountId) -> bool {
        let contract = self.contract_list.get(&user_id);
        if contract.is_some() {
            true
        } else if contract.is_none() {
            false
        } else {
            false
        }
    }

    pub fn get_subcontract_type(self, user_id: AccountId) -> i8 {
        let contract = self.contract_list.get(&user_id);
        if contract.is_some() {
            contract.unwrap().type_contract
        } else if contract.is_none() {
            0
        } else {
            0
        }
    }

    // #[payable]
    pub fn delete_contract(&mut self) {
        // let attached_deposit = env::attached_deposit();
        // assert!(
           // attached_deposit >= 1,
           // "you have to deposit a minimum of one yoctoNear"
        // );

        let contract = self.contract_list.get(&env::signer_account_id()).expect("the user does not have contract deployed");
        ext_subcontract::get_balance_block_total(
            contract.contract.clone(),
            0,
            BASE_GAS,
        ).then(int_sub_contract::on_delete_contract(
            env::signer_account_id(),
            contract.contract.clone(),
            env::current_account_id(),
            0,
            Gas(140_000_000_000_000),
        ));
    }

    
    pub fn delete_contract_admin(&mut self, user_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.administrators.contains(&env::signer_account_id()), "Only administrator");

        let contract = self.contract_list.get(&user_id).expect("the user does not have contract deployed");
        ext_subcontract::get_balance_block_total(
            contract.contract.clone(),
            0,
            BASE_GAS,
        ).then(int_sub_contract::on_delete_contract(
            user_id,
            contract.contract.clone(),
            env::current_account_id(),
            0,
            Gas(140_000_000_000_000),
        ));
    }

    #[private]
    pub fn on_delete_contract(&mut self, signer_id: AccountId, sub_contract: AccountId) {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error check balance blocked".as_ref());
        }
        let balance_block = near_sdk::serde_json::from_slice::<u128>(&result.unwrap()).expect("u128");
        
        if !self.administrators.contains(&env::signer_account_id()) {
            require!(balance_block <= 0, "You still have operations in progress, finish all the operations to be able to delete the contract");
        }

        ext_subcontract::get_balance_near(
            "libre".to_string(),
            sub_contract.clone(),
            0,
            BASE_GAS,
        ).then(int_sub_contract::on_delete_withdraw_near(
            sub_contract.clone(),
            signer_id.clone(),
            env::current_account_id(),
            0,
            Gas(100_000_000_000_000),
        ));
    }

    #[private]
    pub fn on_delete_withdraw_near(&mut self,
        sub_contract: AccountId,
        signer_id: AccountId
    ) -> Promise {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error Balance NEAR".as_ref());
        }
        
        let amount_withdraw: u128 = near_sdk::serde_json::from_slice::<u128>(&result.unwrap()).expect("u128");
        //env::log_str(format!("{}",amount_withdraw).as_str());
        //require!(amount_withdraw > 0, "No balance available to withdraw");
        
        if amount_withdraw > 0 {
            ext_subcontract::transfer(
                signer_id.clone(),
                U128(amount_withdraw),
                U128(0),
                None,
                true,
                "NEAR".to_string(),
                sub_contract.clone(),
                1,
                GAS_FOR_TRANSFER,
            );
        }

        ext_subcontract::delete_contract(
            sub_contract.clone(),
            0,
            BASE_GAS,
        ).then(int_sub_contract::on_delete_contract_list(
            signer_id,
            env::current_account_id(),
            0,
            Gas(25_000_000_000_000),
        ))
    }

    #[private]
    pub fn on_delete_contract_list(&mut self, signer_id: AccountId) {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error al eliminar la cuenta".as_ref());
        }
        self.contract_list.remove(&signer_id);
    }

    #[payable]
    pub fn withdraw(&mut self, ft_token: String) -> Promise {
        assert!(
            env::attached_deposit() >= 1,
            "Requires attached deposit of at least 1 yoctoNEAR",
        );
        //let contract: AccountId = AccountId::new_unchecked("pruebaa.globaldv.testnet".to_string());
        let contract = self.contract_list.get(&env::signer_account_id()).expect("the user does not have contract deployed");
        match ft_token.as_ref() {
            "NEAR" => { 
                ext_subcontract::get_balance_near(
                    "libre".to_string(),
                    contract.contract.clone(),
                    0,
                    BASE_GAS,
                ).then(int_sub_contract::on_withdraw_near(
                    contract.contract.clone(),
                    env::signer_account_id(),
                    env::current_account_id(),
                    0,
                    GAS_ON_WITHDRAW_NEAR,
                ))
            },
            _=> {
                let contract_ft = self.ft_token_list.get(&ft_token).expect("El ft_token subministrado es incorrecto");

                ext_usdc::ft_balance_of(
                    contract.contract.to_string(),
                    contract_ft.contract, //AccountId::new_unchecked(CONTRACT_USDC.to_string()),
                    0,
                    Gas(30_000_000_000_000),
                ).then(int_sub_contract::on_withdraw_token_block(
                    contract.contract.clone(),
                    env::signer_account_id(),
                    ft_token.clone(),
                    env::current_account_id(),
                    0,
                    GAS_ON_WITHDRAW_TOKEN_BLOCK,
                ))
            },
            _=> env::panic_str("ft_token not found")

        }
    }

    #[private]
    pub fn on_withdraw_near(&mut self,
        sub_contract: AccountId,
        signer_id: AccountId
    ) -> Promise {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error Balance NEAR".as_ref());
        }
        
        let amount_withdraw: u128 = near_sdk::serde_json::from_slice::<u128>(&result.unwrap()).expect("u128");
        env::log_str(format!("{}",amount_withdraw).as_str());
        require!(amount_withdraw > 0, "No balance available to withdraw");
        
        ext_subcontract::transfer(
            signer_id,
            U128(amount_withdraw),
            U128(0),
            None,
            true,
            "NEAR".to_string(),
            sub_contract,
            1,
            GAS_FOR_TRANSFER,
        )
    }

    #[private]
    pub fn on_withdraw_token_block(&mut self,
        sub_contract: AccountId,
        signer_id: AccountId,
        ft_token: String,
    ) -> Promise {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");

        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error balance token general".as_ref());
        }
        
        let balannce_general: U128 = near_sdk::serde_json::from_slice::<U128>(&result.unwrap()).expect("U128");

        ext_subcontract::get_balance_block_token(
            ft_token.clone(),
            sub_contract.clone(),
            0,
            BASE_GAS,
        ).then(int_sub_contract::on_withdraw_token(
            sub_contract,
            signer_id,
            ft_token,
            balannce_general,
            env::current_account_id(),
            0,
            GAS_ON_WITHDRAW_TOKEN,
        ))
    }

    #[private]
    pub fn on_withdraw_token(&mut self,
        sub_contract: AccountId,
        signer_id: AccountId,
        ft_token: String,
        balance_general: U128,
    ) -> Promise {
        require!(env::predecessor_account_id() == env::current_account_id(), "Only administrators");
        let result = promise_result_as_success();
        if result.is_none() {
            env::panic_str("Error withdraw token".as_ref());
        }
        
        let balannce_block: u128 = near_sdk::serde_json::from_slice::<u128>(&result.unwrap()).expect("u128");
        let amount_withdraw: u128 = balance_general.0 - balannce_block;
        
        require!(amount_withdraw > 0, "No balance available to withdraw");

        let contract_ft = self.ft_token_list.get(&ft_token.clone()).expect("El ft_token subministrado es incorrecto");

        ext_subcontract::transfer(
            signer_id,
            U128(amount_withdraw),
            U128(0u128),
            Some(contract_ft.contract), //Some(AccountId::new_unchecked(CONTRACT_USDC.to_string())),
            true,
            ft_token,
            sub_contract,
            1,
            GAS_FOR_TRANSFER,
        )

    }

}
'''