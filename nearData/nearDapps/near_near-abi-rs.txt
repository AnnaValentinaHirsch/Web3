*GitHub Repository "near/near-abi-rs"*

'''--- .github/check_metaschema_compatibility.py ---
import glob
import re
import semver
import subprocess

metaschema_file_version_pattern = "^metaschema/near-abi-(\d+\.\d+\.\d+)-schema\.json$"
rust_schema_version_pattern = "^pub const SCHEMA_VERSION: &str = \"(\d+\.\d+\.\d+)\";$"

persisted_semvers = []
for metaschema in glob.glob("metaschema/near-abi-*.*.*-schema.json"):
    persisted_semver = semver.VersionInfo.parse(
        re.match(metaschema_file_version_pattern, metaschema).group(1)
    )
    persisted_semvers.append(persisted_semver)
persisted_semvers.sort()
last_persisted_semver = persisted_semvers[-1]
print("Last persisted ABI schema version:", last_persisted_semver)

current_semver = None
with open("near-abi/src/lib.rs", "r") as sources:
    for line in sources.readlines():
        match = re.match(rust_schema_version_pattern, line)
        if match is not None:
            current_semver = semver.VersionInfo.parse(match.group(1))
            break
if current_semver is None:
    print("Could not parse the current ABI schema version. Have you changed the way SCHEMA_VERSION is exposed?")
    exit(1)
print("Current ABI schema version:", current_semver)

if (current_semver.major > last_persisted_semver.major or
        (current_semver.major == 0 and
         last_persisted_semver.major == 0 and
         current_semver.minor > last_persisted_semver.minor)):
    print("Current ABI schema is allowed to make breaking changes against ",
          last_persisted_semver)
    exit(0)
else:
    result = subprocess.run(
        ["jsonschemacompat",
         "metaschema/near-abi-" + str(last_persisted_semver) + "-schema.json",
         "metaschema/near-abi-current-schema.json"]
    )
    exit(result.returncode)

'''
'''--- .github/workflows/rust.yml ---
name: CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  msrv-check:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v4

      - name: Get MSRV
        run: |
          RUST_MSRV="$(sed -n 's/rust-version *= *"\(.*\)"/\1/p' near-abi/Cargo.toml)"
          echo "RUST_MSRV=$RUST_MSRV" >> $GITHUB_ENV

      - name: "Install ${{ env.RUST_MSRV }} toolchain (MSRV)"
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: ${{ env.RUST_MSRV }}
          default: true

      - name: downgrade `toml_datetime` crate to support older Rust toolchain
        if: ${{ env.RUST_MSRV }} == '1.66.0' 
        run: |
          cargo update -p borsh --precise 1.1.0
          cargo update -p toml_edit --precise 0.20.2
          cargo update -p toml_datetime --precise 0.6.3

      - run: cargo check

  tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v4

      - name: Run Tests
        run: cargo test

  lint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v4

      - name: Check Formatting
        run: cargo fmt -- --check

      - name: Check Clippy
        run: cargo clippy --tests -- -Dclippy::all

  check-metaschema:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v4

      - name: Install json-schema-compatibility-checker
        run: |
          wget https://github.com/itegulov/json-schema-compatibility-checker/releases/download/v0.1.0/jsonschemacompat_0.1.0_all.deb
          sudo apt install ./jsonschemacompat_0.1.0_all.deb

      - name: Generate Current ABI Meta-schema
        run: cargo run --package metaschema-gen > tmp.json

      - name: Check that Current Meta-schema is Up-to-date
        run: diff tmp.json metaschema/near-abi-current-schema.json

      - name: Check that Meta-schema is Backward Compatible
        run: pip install semver && python .github/check_metaschema_compatibility.py

  release-plz:
    runs-on: ubuntu-latest
    needs: [msrv-check, tests, lint, check-metaschema]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.MY_GITHUB_TOKEN }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://release-plz.ieni.dev/docs/github/trigger
          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- CHANGELOG.md ---
## [Unreleased]

## [0.3.0] - 2022-11-02

### Added
- Derived `schemars::JsonSchema` for ABI models. https://github.com/near/near-abi-rs/pull/11, https://github.com/near/near-abi-rs/pull/16, https://github.com/near/near-abi-rs/pull/19

### Fixed
- Skip `wasm_hash` serialization if it is empty. https://github.com/near/near-abi-rs/pull/17

### Changed
- Replaced `is_view`, `is_init`, `is_payable`, `is_private` function fields with `kind` and `modifiers`. https://github.com/near/near-abi-rs/pull/20

## [0.2.0] - 2022-09-21

### Changed
- Included optional build information into metadata. https://github.com/near/near-abi-rs/pull/8
- Consolidated function parameters' serialization type into one place per function. https://github.com/near/near-abi-rs/pull/9

[unreleased]: https://github.com/near/near-abi-rs/compare/v0.2.0...HEAD
[0.2.0]: https://github.com/near/near-abi-rs/compare/v0.1.0-pre.0...v0.2.0
[0.1.0-pre.0]: https://github.com/near/near-abi-rs/releases/tag/v0.1.0-pre.0

'''
'''--- CONTRIBUTING.md ---
# Contributing to near-sdk-rs

Thank you for your interest in contributing to NEAR! We appreciate any type of contribution.

If you have any questions about contributing, or about the project in general, please ask in our [rust-support Discord channel](https://discord.gg/cKRZCqD2b2).

## Development

### Commits

Please use descriptive PR titles. We loosely follow the [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/) style, but this is not a requirement to follow exactly. PRs will be addressed more quickly if it is clear what the intention is.

### Before opening a PR

Ensure the following are satisfied before opening a PR:
- Code is formatted with `rustfmt` by running `cargo fmt`
- Run `clippy`
  - The exact command run by the CI is `cargo clippy --tests -- -Dclippy::all`
- Run tests with `cargo test`
- If you have changed the ABI models' structure:
  - Re-generate metaschema by running `cargo run --package metaschema-gen > metaschema/near-abi-current-schema.json`
  - Make sure that the change is backwards compatible to the previous ABI schema format or bump the `SCHEMA_VERSION`
- Ensure any new functionality is adequately tested
- If any new public types or functions are added, ensure they have appropriate [rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) documentation

'''
'''--- Cargo.toml ---
[workspace]
members = [
    "near-abi",
    "metaschema"
]
resolver = "2"

'''
'''--- README.md ---
<div align="center">

  <h1><code>near-abi-rs</code></h1>

  <p>
    <strong>Rust library providing NEAR ABI models.</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-abi-rs/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-abi-rs/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-abi"><img src="https://img.shields.io/crates/v/near-abi.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-abi"><img src="https://img.shields.io/crates/d/near-abi.svg?style=flat-square" alt="Download" /></a>
    <a href="https://docs.rs/near-abi"><img src="https://docs.rs/near-abi/badge.svg" alt="Reference Documentation" /></a>
  </p>

  <h3>
      <a href="https://github.com/near/abi">NEAR ABI</a>
      <span> | </span>
      <a href="https://docs.rs/near-abi">Reference Documentation</a>
      <span> | </span>
      <a href="#contributing">Contributing</a>
  </h3>
</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Overview

‚ùó **Warning: ABI is still in early stages of development so expect breaking changes to this library until we reach 1.0**

This library is meant to serve as an unopinionated reference for Rust models of the [NEAR ABI](https://github.com/near/abi).

## ABI Metaschema

This repo also contains meta [JSON Schemas](https://json-schema.org/) of ABI. These schemas can be found in the [`metaschema`](/metaschema) folder: `near-abi-${version}-schema.json` for a specific ABI schema version or `near-abi-current-schema.json` for what is currently in the `main` branch of the repository.

Metaschemas describe the properties of ABI schema format and allow anyone to validate whether a JSON file is a valid NEAR ABI. For example, one could use an online validator like https://www.jsonschemavalidator.net/ or a library such as [ajv](https://github.com/ajv-validator/ajv).

## Contributing

If you are interested in contributing, please look at the [contributing guidelines](CONTRIBUTING.md).

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- metaschema/Cargo.toml ---
[package]
name = "metaschema-gen"
version = "0.1.0"
edition = "2021"
rust-version = "1.56.0"
license = "MIT OR Apache-2.0"
publish = false

[dependencies]
anyhow = "1"
near-abi = { path = "../near-abi" }
schemars = { version = "0.8.11", features = ["impl_json_schema"] }
serde_json = "1"

'''
'''--- metaschema/near-abi-0.2.0-schema.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "AbiRoot",
  "description": "Contract ABI.",
  "type": "object",
  "required": [
    "body",
    "metadata",
    "schema_version"
  ],
  "properties": {
    "body": {
      "description": "Core ABI information (functions and types).",
      "allOf": [
        {
          "$ref": "#/definitions/AbiBody"
        }
      ]
    },
    "metadata": {
      "description": "Metadata information about the contract.",
      "allOf": [
        {
          "$ref": "#/definitions/AbiMetadata"
        }
      ]
    },
    "schema_version": {
      "description": "Semver of the ABI schema format.",
      "type": "string"
    }
  },
  "additionalProperties": false,
  "definitions": {
    "AbiBody": {
      "description": "Core ABI information.",
      "type": "object",
      "required": [
        "functions",
        "root_schema"
      ],
      "properties": {
        "functions": {
          "description": "ABIs of all contract's functions.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiFunction"
          }
        },
        "root_schema": {
          "description": "Root JSON Schema containing all types referenced in the functions.",
          "allOf": [
            {
              "$ref": "#/definitions/RootSchema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiBorshParameter": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "type_schema": true
      }
    },
    "AbiFunction": {
      "description": "ABI of a single function.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "callbacks": {
          "description": "Type identifiers of the callbacks of the function.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiType"
          }
        },
        "callbacks_vec": {
          "description": "Type identifier of the vararg callbacks of the function.",
          "anyOf": [
            {
              "$ref": "#/definitions/AbiType"
            },
            {
              "type": "null"
            }
          ]
        },
        "doc": {
          "description": "Human-readable documentation parsed from the source file.",
          "type": [
            "string",
            "null"
          ]
        },
        "is_init": {
          "description": "Whether function can be used to initialize the state.",
          "type": "boolean"
        },
        "is_payable": {
          "description": "Whether function is accepting $NEAR.",
          "type": "boolean"
        },
        "is_private": {
          "description": "Whether function can only accept calls from self (current account).",
          "type": "boolean"
        },
        "is_view": {
          "description": "Whether function does not modify the state.",
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "params": {
          "description": "Type identifiers of the function parameters.",
          "allOf": [
            {
              "$ref": "#/definitions/AbiParameters"
            }
          ]
        },
        "result": {
          "description": "Return type identifier.",
          "anyOf": [
            {
              "$ref": "#/definitions/AbiType"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiJsonParameter": {
      "description": "Information about a single named JSON function parameter.",
      "type": "object",
      "required": [
        "name",
        "type_schema"
      ],
      "properties": {
        "name": {
          "description": "Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).",
          "type": "string"
        },
        "type_schema": {
          "description": "JSON Subschema that represents this type (can be an inline primitive, a reference to the root schema and a few other corner-case things).",
          "allOf": [
            {
              "$ref": "#/definitions/Schema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiMetadata": {
      "type": "object",
      "properties": {
        "authors": {
          "description": "The authors of the smart contract.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "build": {
          "description": "The information about how this contract was built.",
          "anyOf": [
            {
              "$ref": "#/definitions/BuildInfo"
            },
            {
              "type": "null"
            }
          ]
        },
        "name": {
          "description": "The name of the smart contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "version": {
          "description": "The version of the smart contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "wasm_hash": {
          "description": "The SHA-256 hash of the contract WASM code in Base58 format.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "AbiParameters": {
      "description": "A list of function parameters sharing the same serialization type.",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "args",
            "serialization_type"
          ],
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AbiJsonParameter"
              }
            },
            "serialization_type": {
              "type": "string",
              "enum": [
                "json"
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "args",
            "serialization_type"
          ],
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AbiBorshParameter"
              }
            },
            "serialization_type": {
              "type": "string",
              "enum": [
                "borsh"
              ]
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AbiType": {
      "anyOf": [
        {
          "description": "A JSON Schema.",
          "anyOf": [
            {
              "description": "A trivial boolean JSON Schema.\n\nThe schema `true` matches everything (always passes validation), whereas the schema `false` matches nothing (always fails validation).",
              "type": "boolean"
            },
            {
              "description": "A JSON Schema object.",
              "allOf": [
                {
                  "$ref": "#/definitions/SchemaObject"
                }
              ]
            }
          ]
        },
        true
      ]
    },
    "BuildInfo": {
      "type": "object",
      "required": [
        "builder",
        "compiler"
      ],
      "properties": {
        "builder": {
          "description": "The build tool (versioned) that was used to build the contract.",
          "type": "string"
        },
        "compiler": {
          "description": "The compiler (versioned) that was used to build the contract.",
          "type": "string"
        },
        "image": {
          "description": "The docker image (versioned) where the contract was built.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "InstanceType": {
      "description": "The possible types of values in JSON Schema documents.\n\nSee [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
      "type": "string",
      "enum": [
        "null",
        "boolean",
        "object",
        "array",
        "number",
        "string",
        "integer"
      ]
    },
    "RootSchema": {
      "description": "The root object of a JSON Schema document.",
      "type": "object",
      "properties": {
        "$id": {
          "description": "The `$id` keyword.\n\nSee [JSON Schema 8.2.2. The \"$id\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2).",
          "type": [
            "string",
            "null"
          ]
        },
        "$ref": {
          "description": "The `$ref` keyword.\n\nSee [JSON Schema 8.2.4.1. Direct References with \"$ref\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.4.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "$schema": {
          "description": "The `$schema` keyword.\n\nSee [JSON Schema 8.1.1. The \"$schema\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.1.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "additionalItems": {
          "description": "The `additionalItems` keyword.\n\nSee [JSON Schema 9.3.1.2. \"additionalItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "additionalProperties": {
          "description": "The `additionalProperties` keyword.\n\nSee [JSON Schema 9.3.2.3. \"additionalProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "allOf": {
          "description": "The `allOf` keyword.\n\nSee [JSON Schema 9.2.1.1. \"allOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.1).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "anyOf": {
          "description": "The `anyOf` keyword.\n\nSee [JSON Schema 9.2.1.2. \"anyOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.2).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "const": {
          "description": "The `const` keyword.\n\nSee [JSON Schema Validation 6.1.3. \"const\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.3)"
        },
        "contains": {
          "description": "The `contains` keyword.\n\nSee [JSON Schema 9.3.1.4. \"contains\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "default": {
          "description": "The `default` keyword.\n\nSee [JSON Schema Validation 9.2. \"default\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.2)."
        },
        "definitions": {
          "description": "The `definitions` keyword.\n\nIn JSON Schema draft 2019-09 this was replaced by $defs, but in Schemars this is still serialized as `definitions` for backward-compatibility.\n\nSee [JSON Schema 8.2.5. Schema Re-Use With \"$defs\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.5), and [JSON Schema (draft 07) 9. Schema Re-Use With \"definitions\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-9).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "deprecated": {
          "description": "The `deprecated` keyword.\n\nSee [JSON Schema Validation 9.3. \"deprecated\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.3).",
          "type": "boolean"
        },
        "description": {
          "description": "The `description` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "else": {
          "description": "The `else` keyword.\n\nSee [JSON Schema 9.2.2.3. \"else\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "enum": {
          "description": "The `enum` keyword.\n\nSee [JSON Schema Validation 6.1.2. \"enum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.2)",
          "type": [
            "array",
            "null"
          ],
          "items": true
        },
        "examples": {
          "description": "The `examples` keyword.\n\nSee [JSON Schema Validation 9.5. \"examples\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5).",
          "type": "array",
          "items": true
        },
        "exclusiveMaximum": {
          "description": "The `exclusiveMaximum` keyword.\n\nSee [JSON Schema Validation 6.2.3. \"exclusiveMaximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.3).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "exclusiveMinimum": {
          "description": "The `exclusiveMinimum` keyword.\n\nSee [JSON Schema Validation 6.2.5. \"exclusiveMinimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.5).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "format": {
          "description": "The `format` keyword.\n\nSee [JSON Schema Validation 7. A Vocabulary for Semantic Content With \"format\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7).",
          "type": [
            "string",
            "null"
          ]
        },
        "if": {
          "description": "The `if` keyword.\n\nSee [JSON Schema 9.2.2.1. \"if\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "items": {
          "description": "The `items` keyword.\n\nSee [JSON Schema 9.3.1.1. \"items\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "maxItems": {
          "description": "The `maxItems` keyword.\n\nSee [JSON Schema Validation 6.4.1. \"maxItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxLength": {
          "description": "The `maxLength` keyword.\n\nSee [JSON Schema Validation 6.3.1. \"maxLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxProperties": {
          "description": "The `maxProperties` keyword.\n\nSee [JSON Schema Validation 6.5.1. \"maxProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maximum": {
          "description": "The `maximum` keyword.\n\nSee [JSON Schema Validation 6.2.2. \"maximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.2).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "minItems": {
          "description": "The `minItems` keyword.\n\nSee [JSON Schema Validation 6.4.2. \"minItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minLength": {
          "description": "The `minLength` keyword.\n\nSee [JSON Schema Validation 6.3.2. \"minLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minProperties": {
          "description": "The `minProperties` keyword.\n\nSee [JSON Schema Validation 6.5.2. \"minProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minimum": {
          "description": "The `minimum` keyword.\n\nSee [JSON Schema Validation 6.2.4. \"minimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.4).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "multipleOf": {
          "description": "The `multipleOf` keyword.\n\nSee [JSON Schema Validation 6.2.1. \"multipleOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.1).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "not": {
          "description": "The `not` keyword.\n\nSee [JSON Schema 9.2.1.4. \"not\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "oneOf": {
          "description": "The `oneOf` keyword.\n\nSee [JSON Schema 9.2.1.3. \"oneOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.3).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "pattern": {
          "description": "The `pattern` keyword.\n\nSee [JSON Schema Validation 6.3.3. \"pattern\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.3).",
          "type": [
            "string",
            "null"
          ]
        },
        "patternProperties": {
          "description": "The `patternProperties` keyword.\n\nSee [JSON Schema 9.3.2.2. \"patternProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.2).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "properties": {
          "description": "The `properties` keyword.\n\nSee [JSON Schema 9.3.2.1. \"properties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.1).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "propertyNames": {
          "description": "The `propertyNames` keyword.\n\nSee [JSON Schema 9.3.2.5. \"propertyNames\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.5).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "readOnly": {
          "description": "The `readOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        },
        "required": {
          "description": "The `required` keyword.\n\nSee [JSON Schema Validation 6.5.3. \"required\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.3).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "then": {
          "description": "The `then` keyword.\n\nSee [JSON Schema 9.2.2.2. \"then\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "title": {
          "description": "The `title` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The `type` keyword.\n\nSee [JSON Schema Validation 6.1.1. \"type\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.1) and [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_InstanceType"
            },
            {
              "type": "null"
            }
          ]
        },
        "uniqueItems": {
          "description": "The `uniqueItems` keyword.\n\nSee [JSON Schema Validation 6.4.3. \"uniqueItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.3).",
          "type": [
            "boolean",
            "null"
          ]
        },
        "writeOnly": {
          "description": "The `writeOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        }
      },
      "additionalProperties": true
    },
    "Schema": {
      "description": "A JSON Schema.",
      "anyOf": [
        {
          "description": "A trivial boolean JSON Schema.\n\nThe schema `true` matches everything (always passes validation), whereas the schema `false` matches nothing (always fails validation).",
          "type": "boolean"
        },
        {
          "description": "A JSON Schema object.",
          "allOf": [
            {
              "$ref": "#/definitions/SchemaObject"
            }
          ]
        }
      ]
    },
    "SchemaObject": {
      "description": "A JSON Schema object.",
      "type": "object",
      "properties": {
        "$id": {
          "description": "The `$id` keyword.\n\nSee [JSON Schema 8.2.2. The \"$id\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2).",
          "type": [
            "string",
            "null"
          ]
        },
        "$ref": {
          "description": "The `$ref` keyword.\n\nSee [JSON Schema 8.2.4.1. Direct References with \"$ref\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.4.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "additionalItems": {
          "description": "The `additionalItems` keyword.\n\nSee [JSON Schema 9.3.1.2. \"additionalItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "additionalProperties": {
          "description": "The `additionalProperties` keyword.\n\nSee [JSON Schema 9.3.2.3. \"additionalProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "allOf": {
          "description": "The `allOf` keyword.\n\nSee [JSON Schema 9.2.1.1. \"allOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.1).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "anyOf": {
          "description": "The `anyOf` keyword.\n\nSee [JSON Schema 9.2.1.2. \"anyOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.2).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "const": {
          "description": "The `const` keyword.\n\nSee [JSON Schema Validation 6.1.3. \"const\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.3)"
        },
        "contains": {
          "description": "The `contains` keyword.\n\nSee [JSON Schema 9.3.1.4. \"contains\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "default": {
          "description": "The `default` keyword.\n\nSee [JSON Schema Validation 9.2. \"default\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.2)."
        },
        "deprecated": {
          "description": "The `deprecated` keyword.\n\nSee [JSON Schema Validation 9.3. \"deprecated\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.3).",
          "type": "boolean"
        },
        "description": {
          "description": "The `description` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "else": {
          "description": "The `else` keyword.\n\nSee [JSON Schema 9.2.2.3. \"else\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "enum": {
          "description": "The `enum` keyword.\n\nSee [JSON Schema Validation 6.1.2. \"enum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.2)",
          "type": [
            "array",
            "null"
          ],
          "items": true
        },
        "examples": {
          "description": "The `examples` keyword.\n\nSee [JSON Schema Validation 9.5. \"examples\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5).",
          "type": "array",
          "items": true
        },
        "exclusiveMaximum": {
          "description": "The `exclusiveMaximum` keyword.\n\nSee [JSON Schema Validation 6.2.3. \"exclusiveMaximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.3).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "exclusiveMinimum": {
          "description": "The `exclusiveMinimum` keyword.\n\nSee [JSON Schema Validation 6.2.5. \"exclusiveMinimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.5).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "format": {
          "description": "The `format` keyword.\n\nSee [JSON Schema Validation 7. A Vocabulary for Semantic Content With \"format\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7).",
          "type": [
            "string",
            "null"
          ]
        },
        "if": {
          "description": "The `if` keyword.\n\nSee [JSON Schema 9.2.2.1. \"if\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "items": {
          "description": "The `items` keyword.\n\nSee [JSON Schema 9.3.1.1. \"items\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "maxItems": {
          "description": "The `maxItems` keyword.\n\nSee [JSON Schema Validation 6.4.1. \"maxItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxLength": {
          "description": "The `maxLength` keyword.\n\nSee [JSON Schema Validation 6.3.1. \"maxLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxProperties": {
          "description": "The `maxProperties` keyword.\n\nSee [JSON Schema Validation 6.5.1. \"maxProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maximum": {
          "description": "The `maximum` keyword.\n\nSee [JSON Schema Validation 6.2.2. \"maximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.2).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "minItems": {
          "description": "The `minItems` keyword.\n\nSee [JSON Schema Validation 6.4.2. \"minItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minLength": {
          "description": "The `minLength` keyword.\n\nSee [JSON Schema Validation 6.3.2. \"minLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minProperties": {
          "description": "The `minProperties` keyword.\n\nSee [JSON Schema Validation 6.5.2. \"minProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minimum": {
          "description": "The `minimum` keyword.\n\nSee [JSON Schema Validation 6.2.4. \"minimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.4).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "multipleOf": {
          "description": "The `multipleOf` keyword.\n\nSee [JSON Schema Validation 6.2.1. \"multipleOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.1).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "not": {
          "description": "The `not` keyword.\n\nSee [JSON Schema 9.2.1.4. \"not\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "oneOf": {
          "description": "The `oneOf` keyword.\n\nSee [JSON Schema 9.2.1.3. \"oneOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.3).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "pattern": {
          "description": "The `pattern` keyword.\n\nSee [JSON Schema Validation 6.3.3. \"pattern\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.3).",
          "type": [
            "string",
            "null"
          ]
        },
        "patternProperties": {
          "description": "The `patternProperties` keyword.\n\nSee [JSON Schema 9.3.2.2. \"patternProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.2).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "properties": {
          "description": "The `properties` keyword.\n\nSee [JSON Schema 9.3.2.1. \"properties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.1).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "propertyNames": {
          "description": "The `propertyNames` keyword.\n\nSee [JSON Schema 9.3.2.5. \"propertyNames\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.5).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "readOnly": {
          "description": "The `readOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        },
        "required": {
          "description": "The `required` keyword.\n\nSee [JSON Schema Validation 6.5.3. \"required\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.3).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "then": {
          "description": "The `then` keyword.\n\nSee [JSON Schema 9.2.2.2. \"then\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "title": {
          "description": "The `title` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The `type` keyword.\n\nSee [JSON Schema Validation 6.1.1. \"type\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.1) and [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_InstanceType"
            },
            {
              "type": "null"
            }
          ]
        },
        "uniqueItems": {
          "description": "The `uniqueItems` keyword.\n\nSee [JSON Schema Validation 6.4.3. \"uniqueItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.3).",
          "type": [
            "boolean",
            "null"
          ]
        },
        "writeOnly": {
          "description": "The `writeOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        }
      },
      "additionalProperties": true
    },
    "SingleOrVec_for_InstanceType": {
      "description": "A type which can be serialized as a single item, or multiple items.\n\nIn some contexts, a `Single` may be semantically distinct from a `Vec` containing only item.",
      "anyOf": [
        {
          "$ref": "#/definitions/InstanceType"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/InstanceType"
          }
        }
      ]
    },
    "SingleOrVec_for_Schema": {
      "description": "A type which can be serialized as a single item, or multiple items.\n\nIn some contexts, a `Single` may be semantically distinct from a `Vec` containing only item.",
      "anyOf": [
        {
          "$ref": "#/definitions/Schema"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Schema"
          }
        }
      ]
    }
  }
}

'''
'''--- metaschema/near-abi-0.2.1-schema.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "AbiRoot",
  "description": "Contract ABI.",
  "type": "object",
  "required": [
    "body",
    "metadata",
    "schema_version"
  ],
  "properties": {
    "body": {
      "description": "Core ABI information (functions and types).",
      "allOf": [
        {
          "$ref": "#/definitions/AbiBody"
        }
      ]
    },
    "metadata": {
      "description": "Metadata information about the contract.",
      "allOf": [
        {
          "$ref": "#/definitions/AbiMetadata"
        }
      ]
    },
    "schema_version": {
      "description": "Semver of the ABI schema format.",
      "type": "string"
    }
  },
  "additionalProperties": false,
  "definitions": {
    "AbiBody": {
      "description": "Core ABI information.",
      "type": "object",
      "required": [
        "functions",
        "root_schema"
      ],
      "properties": {
        "functions": {
          "description": "ABIs of all contract's functions.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiFunction"
          }
        },
        "root_schema": {
          "description": "Root JSON Schema containing all types referenced in the functions.",
          "allOf": [
            {
              "$ref": "#/definitions/RootSchema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiBorshParameter": {
      "description": "Information about a single named Borsh function parameter.",
      "type": "object",
      "required": [
        "name",
        "type_schema"
      ],
      "properties": {
        "name": {
          "description": "Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).",
          "type": "string"
        },
        "type_schema": {
          "description": "Inline Borsh schema that represents this type."
        }
      },
      "additionalProperties": false
    },
    "AbiFunction": {
      "description": "ABI of a single function.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "callbacks": {
          "description": "Type identifiers of the callbacks of the function.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiType"
          }
        },
        "callbacks_vec": {
          "description": "Type identifier of the vararg callbacks of the function.",
          "anyOf": [
            {
              "$ref": "#/definitions/AbiType"
            },
            {
              "type": "null"
            }
          ]
        },
        "doc": {
          "description": "Human-readable documentation parsed from the source file.",
          "type": [
            "string",
            "null"
          ]
        },
        "is_init": {
          "description": "Whether function can be used to initialize the state.",
          "type": "boolean"
        },
        "is_payable": {
          "description": "Whether function is accepting $NEAR.",
          "type": "boolean"
        },
        "is_private": {
          "description": "Whether function can only accept calls from self (current account).",
          "type": "boolean"
        },
        "is_view": {
          "description": "Whether function does not modify the state.",
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "params": {
          "description": "Type identifiers of the function parameters.",
          "allOf": [
            {
              "$ref": "#/definitions/AbiParameters"
            }
          ]
        },
        "result": {
          "description": "Return type identifier.",
          "anyOf": [
            {
              "$ref": "#/definitions/AbiType"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiJsonParameter": {
      "description": "Information about a single named JSON function parameter.",
      "type": "object",
      "required": [
        "name",
        "type_schema"
      ],
      "properties": {
        "name": {
          "description": "Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).",
          "type": "string"
        },
        "type_schema": {
          "description": "JSON Subschema that represents this type (can be an inline primitive, a reference to the root schema and a few other corner-case things).",
          "allOf": [
            {
              "$ref": "#/definitions/Schema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiMetadata": {
      "type": "object",
      "properties": {
        "authors": {
          "description": "The authors of the smart contract.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "build": {
          "description": "The information about how this contract was built.",
          "anyOf": [
            {
              "$ref": "#/definitions/BuildInfo"
            },
            {
              "type": "null"
            }
          ]
        },
        "name": {
          "description": "The name of the smart contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "version": {
          "description": "The version of the smart contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "wasm_hash": {
          "description": "The SHA-256 hash of the contract WASM code in Base58 format.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "AbiParameters": {
      "description": "A list of function parameters sharing the same serialization type.",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "args",
            "serialization_type"
          ],
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AbiJsonParameter"
              }
            },
            "serialization_type": {
              "type": "string",
              "enum": [
                "json"
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "args",
            "serialization_type"
          ],
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AbiBorshParameter"
              }
            },
            "serialization_type": {
              "type": "string",
              "enum": [
                "borsh"
              ]
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AbiType": {
      "description": "Information about a single type (e.g. return type).",
      "oneOf": [
        {
          "required": [
            "serialization_type",
            "type_schema"
          ],
          "properties": {
            "serialization_type": {
              "type": "string",
              "enum": [
                "json"
              ]
            },
            "type_schema": {
              "$ref": "#/definitions/Schema"
            }
          },
          "additionalProperties": false
        },
        {
          "required": [
            "serialization_type",
            "type_schema"
          ],
          "properties": {
            "serialization_type": {
              "type": "string",
              "enum": [
                "borsh"
              ]
            },
            "type_schema": {}
          },
          "additionalProperties": false
        }
      ]
    },
    "BuildInfo": {
      "type": "object",
      "required": [
        "builder",
        "compiler"
      ],
      "properties": {
        "builder": {
          "description": "The build tool (versioned) that was used to build the contract.",
          "type": "string"
        },
        "compiler": {
          "description": "The compiler (versioned) that was used to build the contract.",
          "type": "string"
        },
        "image": {
          "description": "The docker image (versioned) where the contract was built.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "InstanceType": {
      "description": "The possible types of values in JSON Schema documents.\n\nSee [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
      "type": "string",
      "enum": [
        "null",
        "boolean",
        "object",
        "array",
        "number",
        "string",
        "integer"
      ]
    },
    "RootSchema": {
      "description": "The root object of a JSON Schema document.",
      "type": "object",
      "properties": {
        "$id": {
          "description": "The `$id` keyword.\n\nSee [JSON Schema 8.2.2. The \"$id\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2).",
          "type": [
            "string",
            "null"
          ]
        },
        "$ref": {
          "description": "The `$ref` keyword.\n\nSee [JSON Schema 8.2.4.1. Direct References with \"$ref\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.4.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "$schema": {
          "description": "The `$schema` keyword.\n\nSee [JSON Schema 8.1.1. The \"$schema\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.1.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "additionalItems": {
          "description": "The `additionalItems` keyword.\n\nSee [JSON Schema 9.3.1.2. \"additionalItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "additionalProperties": {
          "description": "The `additionalProperties` keyword.\n\nSee [JSON Schema 9.3.2.3. \"additionalProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "allOf": {
          "description": "The `allOf` keyword.\n\nSee [JSON Schema 9.2.1.1. \"allOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.1).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "anyOf": {
          "description": "The `anyOf` keyword.\n\nSee [JSON Schema 9.2.1.2. \"anyOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.2).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "const": {
          "description": "The `const` keyword.\n\nSee [JSON Schema Validation 6.1.3. \"const\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.3)"
        },
        "contains": {
          "description": "The `contains` keyword.\n\nSee [JSON Schema 9.3.1.4. \"contains\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "default": {
          "description": "The `default` keyword.\n\nSee [JSON Schema Validation 9.2. \"default\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.2)."
        },
        "definitions": {
          "description": "The `definitions` keyword.\n\nIn JSON Schema draft 2019-09 this was replaced by $defs, but in Schemars this is still serialized as `definitions` for backward-compatibility.\n\nSee [JSON Schema 8.2.5. Schema Re-Use With \"$defs\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.5), and [JSON Schema (draft 07) 9. Schema Re-Use With \"definitions\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-9).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "deprecated": {
          "description": "The `deprecated` keyword.\n\nSee [JSON Schema Validation 9.3. \"deprecated\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.3).",
          "type": "boolean"
        },
        "description": {
          "description": "The `description` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "else": {
          "description": "The `else` keyword.\n\nSee [JSON Schema 9.2.2.3. \"else\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "enum": {
          "description": "The `enum` keyword.\n\nSee [JSON Schema Validation 6.1.2. \"enum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.2)",
          "type": [
            "array",
            "null"
          ],
          "items": true
        },
        "examples": {
          "description": "The `examples` keyword.\n\nSee [JSON Schema Validation 9.5. \"examples\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5).",
          "type": "array",
          "items": true
        },
        "exclusiveMaximum": {
          "description": "The `exclusiveMaximum` keyword.\n\nSee [JSON Schema Validation 6.2.3. \"exclusiveMaximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.3).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "exclusiveMinimum": {
          "description": "The `exclusiveMinimum` keyword.\n\nSee [JSON Schema Validation 6.2.5. \"exclusiveMinimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.5).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "format": {
          "description": "The `format` keyword.\n\nSee [JSON Schema Validation 7. A Vocabulary for Semantic Content With \"format\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7).",
          "type": [
            "string",
            "null"
          ]
        },
        "if": {
          "description": "The `if` keyword.\n\nSee [JSON Schema 9.2.2.1. \"if\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "items": {
          "description": "The `items` keyword.\n\nSee [JSON Schema 9.3.1.1. \"items\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "maxItems": {
          "description": "The `maxItems` keyword.\n\nSee [JSON Schema Validation 6.4.1. \"maxItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxLength": {
          "description": "The `maxLength` keyword.\n\nSee [JSON Schema Validation 6.3.1. \"maxLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxProperties": {
          "description": "The `maxProperties` keyword.\n\nSee [JSON Schema Validation 6.5.1. \"maxProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maximum": {
          "description": "The `maximum` keyword.\n\nSee [JSON Schema Validation 6.2.2. \"maximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.2).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "minItems": {
          "description": "The `minItems` keyword.\n\nSee [JSON Schema Validation 6.4.2. \"minItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minLength": {
          "description": "The `minLength` keyword.\n\nSee [JSON Schema Validation 6.3.2. \"minLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minProperties": {
          "description": "The `minProperties` keyword.\n\nSee [JSON Schema Validation 6.5.2. \"minProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minimum": {
          "description": "The `minimum` keyword.\n\nSee [JSON Schema Validation 6.2.4. \"minimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.4).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "multipleOf": {
          "description": "The `multipleOf` keyword.\n\nSee [JSON Schema Validation 6.2.1. \"multipleOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.1).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "not": {
          "description": "The `not` keyword.\n\nSee [JSON Schema 9.2.1.4. \"not\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "oneOf": {
          "description": "The `oneOf` keyword.\n\nSee [JSON Schema 9.2.1.3. \"oneOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.3).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "pattern": {
          "description": "The `pattern` keyword.\n\nSee [JSON Schema Validation 6.3.3. \"pattern\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.3).",
          "type": [
            "string",
            "null"
          ]
        },
        "patternProperties": {
          "description": "The `patternProperties` keyword.\n\nSee [JSON Schema 9.3.2.2. \"patternProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.2).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "properties": {
          "description": "The `properties` keyword.\n\nSee [JSON Schema 9.3.2.1. \"properties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.1).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "propertyNames": {
          "description": "The `propertyNames` keyword.\n\nSee [JSON Schema 9.3.2.5. \"propertyNames\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.5).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "readOnly": {
          "description": "The `readOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        },
        "required": {
          "description": "The `required` keyword.\n\nSee [JSON Schema Validation 6.5.3. \"required\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.3).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "then": {
          "description": "The `then` keyword.\n\nSee [JSON Schema 9.2.2.2. \"then\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "title": {
          "description": "The `title` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The `type` keyword.\n\nSee [JSON Schema Validation 6.1.1. \"type\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.1) and [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_InstanceType"
            },
            {
              "type": "null"
            }
          ]
        },
        "uniqueItems": {
          "description": "The `uniqueItems` keyword.\n\nSee [JSON Schema Validation 6.4.3. \"uniqueItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.3).",
          "type": [
            "boolean",
            "null"
          ]
        },
        "writeOnly": {
          "description": "The `writeOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        }
      },
      "additionalProperties": true
    },
    "Schema": {
      "description": "A JSON Schema.",
      "anyOf": [
        {
          "description": "A trivial boolean JSON Schema.\n\nThe schema `true` matches everything (always passes validation), whereas the schema `false` matches nothing (always fails validation).",
          "type": "boolean"
        },
        {
          "description": "A JSON Schema object.",
          "allOf": [
            {
              "$ref": "#/definitions/SchemaObject"
            }
          ]
        }
      ]
    },
    "SchemaObject": {
      "description": "A JSON Schema object.",
      "type": "object",
      "properties": {
        "$id": {
          "description": "The `$id` keyword.\n\nSee [JSON Schema 8.2.2. The \"$id\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2).",
          "type": [
            "string",
            "null"
          ]
        },
        "$ref": {
          "description": "The `$ref` keyword.\n\nSee [JSON Schema 8.2.4.1. Direct References with \"$ref\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.4.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "additionalItems": {
          "description": "The `additionalItems` keyword.\n\nSee [JSON Schema 9.3.1.2. \"additionalItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "additionalProperties": {
          "description": "The `additionalProperties` keyword.\n\nSee [JSON Schema 9.3.2.3. \"additionalProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "allOf": {
          "description": "The `allOf` keyword.\n\nSee [JSON Schema 9.2.1.1. \"allOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.1).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "anyOf": {
          "description": "The `anyOf` keyword.\n\nSee [JSON Schema 9.2.1.2. \"anyOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.2).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "const": {
          "description": "The `const` keyword.\n\nSee [JSON Schema Validation 6.1.3. \"const\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.3)"
        },
        "contains": {
          "description": "The `contains` keyword.\n\nSee [JSON Schema 9.3.1.4. \"contains\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "default": {
          "description": "The `default` keyword.\n\nSee [JSON Schema Validation 9.2. \"default\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.2)."
        },
        "deprecated": {
          "description": "The `deprecated` keyword.\n\nSee [JSON Schema Validation 9.3. \"deprecated\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.3).",
          "type": "boolean"
        },
        "description": {
          "description": "The `description` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "else": {
          "description": "The `else` keyword.\n\nSee [JSON Schema 9.2.2.3. \"else\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "enum": {
          "description": "The `enum` keyword.\n\nSee [JSON Schema Validation 6.1.2. \"enum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.2)",
          "type": [
            "array",
            "null"
          ],
          "items": true
        },
        "examples": {
          "description": "The `examples` keyword.\n\nSee [JSON Schema Validation 9.5. \"examples\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5).",
          "type": "array",
          "items": true
        },
        "exclusiveMaximum": {
          "description": "The `exclusiveMaximum` keyword.\n\nSee [JSON Schema Validation 6.2.3. \"exclusiveMaximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.3).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "exclusiveMinimum": {
          "description": "The `exclusiveMinimum` keyword.\n\nSee [JSON Schema Validation 6.2.5. \"exclusiveMinimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.5).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "format": {
          "description": "The `format` keyword.\n\nSee [JSON Schema Validation 7. A Vocabulary for Semantic Content With \"format\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7).",
          "type": [
            "string",
            "null"
          ]
        },
        "if": {
          "description": "The `if` keyword.\n\nSee [JSON Schema 9.2.2.1. \"if\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "items": {
          "description": "The `items` keyword.\n\nSee [JSON Schema 9.3.1.1. \"items\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "maxItems": {
          "description": "The `maxItems` keyword.\n\nSee [JSON Schema Validation 6.4.1. \"maxItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxLength": {
          "description": "The `maxLength` keyword.\n\nSee [JSON Schema Validation 6.3.1. \"maxLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxProperties": {
          "description": "The `maxProperties` keyword.\n\nSee [JSON Schema Validation 6.5.1. \"maxProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maximum": {
          "description": "The `maximum` keyword.\n\nSee [JSON Schema Validation 6.2.2. \"maximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.2).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "minItems": {
          "description": "The `minItems` keyword.\n\nSee [JSON Schema Validation 6.4.2. \"minItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minLength": {
          "description": "The `minLength` keyword.\n\nSee [JSON Schema Validation 6.3.2. \"minLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minProperties": {
          "description": "The `minProperties` keyword.\n\nSee [JSON Schema Validation 6.5.2. \"minProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minimum": {
          "description": "The `minimum` keyword.\n\nSee [JSON Schema Validation 6.2.4. \"minimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.4).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "multipleOf": {
          "description": "The `multipleOf` keyword.\n\nSee [JSON Schema Validation 6.2.1. \"multipleOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.1).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "not": {
          "description": "The `not` keyword.\n\nSee [JSON Schema 9.2.1.4. \"not\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "oneOf": {
          "description": "The `oneOf` keyword.\n\nSee [JSON Schema 9.2.1.3. \"oneOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.3).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "pattern": {
          "description": "The `pattern` keyword.\n\nSee [JSON Schema Validation 6.3.3. \"pattern\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.3).",
          "type": [
            "string",
            "null"
          ]
        },
        "patternProperties": {
          "description": "The `patternProperties` keyword.\n\nSee [JSON Schema 9.3.2.2. \"patternProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.2).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "properties": {
          "description": "The `properties` keyword.\n\nSee [JSON Schema 9.3.2.1. \"properties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.1).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "propertyNames": {
          "description": "The `propertyNames` keyword.\n\nSee [JSON Schema 9.3.2.5. \"propertyNames\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.5).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "readOnly": {
          "description": "The `readOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        },
        "required": {
          "description": "The `required` keyword.\n\nSee [JSON Schema Validation 6.5.3. \"required\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.3).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "then": {
          "description": "The `then` keyword.\n\nSee [JSON Schema 9.2.2.2. \"then\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "title": {
          "description": "The `title` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The `type` keyword.\n\nSee [JSON Schema Validation 6.1.1. \"type\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.1) and [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_InstanceType"
            },
            {
              "type": "null"
            }
          ]
        },
        "uniqueItems": {
          "description": "The `uniqueItems` keyword.\n\nSee [JSON Schema Validation 6.4.3. \"uniqueItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.3).",
          "type": [
            "boolean",
            "null"
          ]
        },
        "writeOnly": {
          "description": "The `writeOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        }
      },
      "additionalProperties": true
    },
    "SingleOrVec_for_InstanceType": {
      "description": "A type which can be serialized as a single item, or multiple items.\n\nIn some contexts, a `Single` may be semantically distinct from a `Vec` containing only item.",
      "anyOf": [
        {
          "$ref": "#/definitions/InstanceType"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/InstanceType"
          }
        }
      ]
    },
    "SingleOrVec_for_Schema": {
      "description": "A type which can be serialized as a single item, or multiple items.\n\nIn some contexts, a `Single` may be semantically distinct from a `Vec` containing only item.",
      "anyOf": [
        {
          "$ref": "#/definitions/Schema"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Schema"
          }
        }
      ]
    }
  }
}

'''
'''--- metaschema/near-abi-0.3.0-schema.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "AbiRoot",
  "description": "Contract ABI.",
  "type": "object",
  "required": [
    "body",
    "metadata",
    "schema_version"
  ],
  "properties": {
    "body": {
      "description": "Core ABI information (functions and types).",
      "allOf": [
        {
          "$ref": "#/definitions/AbiBody"
        }
      ]
    },
    "metadata": {
      "description": "Metadata information about the contract.",
      "allOf": [
        {
          "$ref": "#/definitions/AbiMetadata"
        }
      ]
    },
    "schema_version": {
      "description": "Semver of the ABI schema format.",
      "type": "string"
    }
  },
  "additionalProperties": false,
  "definitions": {
    "AbiBody": {
      "description": "Core ABI information.",
      "type": "object",
      "required": [
        "functions",
        "root_schema"
      ],
      "properties": {
        "functions": {
          "description": "ABIs of all contract's functions.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiFunction"
          }
        },
        "root_schema": {
          "description": "Root JSON Schema containing all types referenced in the functions.",
          "allOf": [
            {
              "$ref": "#/definitions/RootSchema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiBorshParameter": {
      "description": "Information about a single named Borsh function parameter.",
      "type": "object",
      "required": [
        "name",
        "type_schema"
      ],
      "properties": {
        "name": {
          "description": "Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).",
          "type": "string"
        },
        "type_schema": {
          "description": "Inline Borsh schema that represents this type."
        }
      },
      "additionalProperties": false
    },
    "AbiFunction": {
      "description": "ABI of a single function.",
      "type": "object",
      "required": [
        "kind",
        "name"
      ],
      "properties": {
        "callbacks": {
          "description": "Type identifiers of the callbacks of the function.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiType"
          }
        },
        "callbacks_vec": {
          "description": "Type identifier of the vararg callbacks of the function.",
          "anyOf": [
            {
              "$ref": "#/definitions/AbiType"
            },
            {
              "type": "null"
            }
          ]
        },
        "doc": {
          "description": "Human-readable documentation parsed from the source file.",
          "type": [
            "string",
            "null"
          ]
        },
        "kind": {
          "description": "Function kind that regulates whether the function has to be invoked from a transaction.",
          "allOf": [
            {
              "$ref": "#/definitions/AbiFunctionKind"
            }
          ]
        },
        "modifiers": {
          "description": "List of modifiers affecting the function.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiFunctionModifier"
          }
        },
        "name": {
          "type": "string"
        },
        "params": {
          "description": "Type identifiers of the function parameters.",
          "allOf": [
            {
              "$ref": "#/definitions/AbiParameters"
            }
          ]
        },
        "result": {
          "description": "Return type identifier.",
          "anyOf": [
            {
              "$ref": "#/definitions/AbiType"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiFunctionKind": {
      "description": "Function kind regulates whether this function's invocation requires a transaction (so-called call functions) or not (view functions).",
      "type": "string",
      "enum": [
        "view",
        "call"
      ]
    },
    "AbiFunctionModifier": {
      "description": "Function can have multiple modifiers that can change its semantics.",
      "oneOf": [
        {
          "description": "Init functions can be used to initialize the state of the contract.",
          "type": "string",
          "enum": [
            "init"
          ]
        },
        {
          "description": "Private functions can only be called from the contract containing them. Usually, when a contract has to have a callback for a remote cross-contract call, this callback method should only be called by the contract itself.",
          "type": "string",
          "enum": [
            "private"
          ]
        },
        {
          "description": "Payable functions can accept token transfer together with the function call. This is done so that contracts can define a fee in tokens that needs to be payed when they are used.",
          "type": "string",
          "enum": [
            "payable"
          ]
        }
      ]
    },
    "AbiJsonParameter": {
      "description": "Information about a single named JSON function parameter.",
      "type": "object",
      "required": [
        "name",
        "type_schema"
      ],
      "properties": {
        "name": {
          "description": "Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).",
          "type": "string"
        },
        "type_schema": {
          "description": "JSON Subschema that represents this type (can be an inline primitive, a reference to the root schema and a few other corner-case things).",
          "allOf": [
            {
              "$ref": "#/definitions/Schema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiMetadata": {
      "type": "object",
      "properties": {
        "authors": {
          "description": "The authors of the smart contract.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "build": {
          "description": "The information about how this contract was built.",
          "anyOf": [
            {
              "$ref": "#/definitions/BuildInfo"
            },
            {
              "type": "null"
            }
          ]
        },
        "name": {
          "description": "The name of the smart contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "version": {
          "description": "The version of the smart contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "wasm_hash": {
          "description": "The SHA-256 hash of the contract WASM code in Base58 format.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "AbiParameters": {
      "description": "A list of function parameters sharing the same serialization type.",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "args",
            "serialization_type"
          ],
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AbiJsonParameter"
              }
            },
            "serialization_type": {
              "type": "string",
              "enum": [
                "json"
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "args",
            "serialization_type"
          ],
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AbiBorshParameter"
              }
            },
            "serialization_type": {
              "type": "string",
              "enum": [
                "borsh"
              ]
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AbiType": {
      "description": "Information about a single type (e.g. return type).",
      "oneOf": [
        {
          "required": [
            "serialization_type",
            "type_schema"
          ],
          "properties": {
            "serialization_type": {
              "type": "string",
              "enum": [
                "json"
              ]
            },
            "type_schema": {
              "$ref": "#/definitions/Schema"
            }
          },
          "additionalProperties": false
        },
        {
          "required": [
            "serialization_type",
            "type_schema"
          ],
          "properties": {
            "serialization_type": {
              "type": "string",
              "enum": [
                "borsh"
              ]
            },
            "type_schema": {}
          },
          "additionalProperties": false
        }
      ]
    },
    "BuildInfo": {
      "type": "object",
      "required": [
        "builder",
        "compiler"
      ],
      "properties": {
        "builder": {
          "description": "The build tool (versioned) that was used to build the contract.",
          "type": "string"
        },
        "compiler": {
          "description": "The compiler (versioned) that was used to build the contract.",
          "type": "string"
        },
        "image": {
          "description": "The docker image (versioned) where the contract was built.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "InstanceType": {
      "description": "The possible types of values in JSON Schema documents.\n\nSee [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
      "type": "string",
      "enum": [
        "null",
        "boolean",
        "object",
        "array",
        "number",
        "string",
        "integer"
      ]
    },
    "RootSchema": {
      "description": "The root object of a JSON Schema document.",
      "type": "object",
      "properties": {
        "$id": {
          "description": "The `$id` keyword.\n\nSee [JSON Schema 8.2.2. The \"$id\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2).",
          "type": [
            "string",
            "null"
          ]
        },
        "$ref": {
          "description": "The `$ref` keyword.\n\nSee [JSON Schema 8.2.4.1. Direct References with \"$ref\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.4.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "$schema": {
          "description": "The `$schema` keyword.\n\nSee [JSON Schema 8.1.1. The \"$schema\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.1.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "additionalItems": {
          "description": "The `additionalItems` keyword.\n\nSee [JSON Schema 9.3.1.2. \"additionalItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "additionalProperties": {
          "description": "The `additionalProperties` keyword.\n\nSee [JSON Schema 9.3.2.3. \"additionalProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "allOf": {
          "description": "The `allOf` keyword.\n\nSee [JSON Schema 9.2.1.1. \"allOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.1).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "anyOf": {
          "description": "The `anyOf` keyword.\n\nSee [JSON Schema 9.2.1.2. \"anyOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.2).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "const": {
          "description": "The `const` keyword.\n\nSee [JSON Schema Validation 6.1.3. \"const\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.3)"
        },
        "contains": {
          "description": "The `contains` keyword.\n\nSee [JSON Schema 9.3.1.4. \"contains\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "default": {
          "description": "The `default` keyword.\n\nSee [JSON Schema Validation 9.2. \"default\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.2)."
        },
        "definitions": {
          "description": "The `definitions` keyword.\n\nIn JSON Schema draft 2019-09 this was replaced by $defs, but in Schemars this is still serialized as `definitions` for backward-compatibility.\n\nSee [JSON Schema 8.2.5. Schema Re-Use With \"$defs\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.5), and [JSON Schema (draft 07) 9. Schema Re-Use With \"definitions\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-9).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "deprecated": {
          "description": "The `deprecated` keyword.\n\nSee [JSON Schema Validation 9.3. \"deprecated\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.3).",
          "type": "boolean"
        },
        "description": {
          "description": "The `description` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "else": {
          "description": "The `else` keyword.\n\nSee [JSON Schema 9.2.2.3. \"else\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "enum": {
          "description": "The `enum` keyword.\n\nSee [JSON Schema Validation 6.1.2. \"enum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.2)",
          "type": [
            "array",
            "null"
          ],
          "items": true
        },
        "examples": {
          "description": "The `examples` keyword.\n\nSee [JSON Schema Validation 9.5. \"examples\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5).",
          "type": "array",
          "items": true
        },
        "exclusiveMaximum": {
          "description": "The `exclusiveMaximum` keyword.\n\nSee [JSON Schema Validation 6.2.3. \"exclusiveMaximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.3).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "exclusiveMinimum": {
          "description": "The `exclusiveMinimum` keyword.\n\nSee [JSON Schema Validation 6.2.5. \"exclusiveMinimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.5).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "format": {
          "description": "The `format` keyword.\n\nSee [JSON Schema Validation 7. A Vocabulary for Semantic Content With \"format\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7).",
          "type": [
            "string",
            "null"
          ]
        },
        "if": {
          "description": "The `if` keyword.\n\nSee [JSON Schema 9.2.2.1. \"if\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "items": {
          "description": "The `items` keyword.\n\nSee [JSON Schema 9.3.1.1. \"items\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "maxItems": {
          "description": "The `maxItems` keyword.\n\nSee [JSON Schema Validation 6.4.1. \"maxItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxLength": {
          "description": "The `maxLength` keyword.\n\nSee [JSON Schema Validation 6.3.1. \"maxLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxProperties": {
          "description": "The `maxProperties` keyword.\n\nSee [JSON Schema Validation 6.5.1. \"maxProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maximum": {
          "description": "The `maximum` keyword.\n\nSee [JSON Schema Validation 6.2.2. \"maximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.2).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "minItems": {
          "description": "The `minItems` keyword.\n\nSee [JSON Schema Validation 6.4.2. \"minItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minLength": {
          "description": "The `minLength` keyword.\n\nSee [JSON Schema Validation 6.3.2. \"minLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minProperties": {
          "description": "The `minProperties` keyword.\n\nSee [JSON Schema Validation 6.5.2. \"minProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minimum": {
          "description": "The `minimum` keyword.\n\nSee [JSON Schema Validation 6.2.4. \"minimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.4).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "multipleOf": {
          "description": "The `multipleOf` keyword.\n\nSee [JSON Schema Validation 6.2.1. \"multipleOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.1).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "not": {
          "description": "The `not` keyword.\n\nSee [JSON Schema 9.2.1.4. \"not\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "oneOf": {
          "description": "The `oneOf` keyword.\n\nSee [JSON Schema 9.2.1.3. \"oneOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.3).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "pattern": {
          "description": "The `pattern` keyword.\n\nSee [JSON Schema Validation 6.3.3. \"pattern\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.3).",
          "type": [
            "string",
            "null"
          ]
        },
        "patternProperties": {
          "description": "The `patternProperties` keyword.\n\nSee [JSON Schema 9.3.2.2. \"patternProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.2).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "properties": {
          "description": "The `properties` keyword.\n\nSee [JSON Schema 9.3.2.1. \"properties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.1).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "propertyNames": {
          "description": "The `propertyNames` keyword.\n\nSee [JSON Schema 9.3.2.5. \"propertyNames\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.5).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "readOnly": {
          "description": "The `readOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        },
        "required": {
          "description": "The `required` keyword.\n\nSee [JSON Schema Validation 6.5.3. \"required\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.3).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "then": {
          "description": "The `then` keyword.\n\nSee [JSON Schema 9.2.2.2. \"then\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "title": {
          "description": "The `title` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The `type` keyword.\n\nSee [JSON Schema Validation 6.1.1. \"type\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.1) and [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_InstanceType"
            },
            {
              "type": "null"
            }
          ]
        },
        "uniqueItems": {
          "description": "The `uniqueItems` keyword.\n\nSee [JSON Schema Validation 6.4.3. \"uniqueItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.3).",
          "type": [
            "boolean",
            "null"
          ]
        },
        "writeOnly": {
          "description": "The `writeOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        }
      },
      "additionalProperties": true
    },
    "Schema": {
      "description": "A JSON Schema.",
      "anyOf": [
        {
          "description": "A trivial boolean JSON Schema.\n\nThe schema `true` matches everything (always passes validation), whereas the schema `false` matches nothing (always fails validation).",
          "type": "boolean"
        },
        {
          "description": "A JSON Schema object.",
          "allOf": [
            {
              "$ref": "#/definitions/SchemaObject"
            }
          ]
        }
      ]
    },
    "SchemaObject": {
      "description": "A JSON Schema object.",
      "type": "object",
      "properties": {
        "$id": {
          "description": "The `$id` keyword.\n\nSee [JSON Schema 8.2.2. The \"$id\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2).",
          "type": [
            "string",
            "null"
          ]
        },
        "$ref": {
          "description": "The `$ref` keyword.\n\nSee [JSON Schema 8.2.4.1. Direct References with \"$ref\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.4.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "additionalItems": {
          "description": "The `additionalItems` keyword.\n\nSee [JSON Schema 9.3.1.2. \"additionalItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "additionalProperties": {
          "description": "The `additionalProperties` keyword.\n\nSee [JSON Schema 9.3.2.3. \"additionalProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "allOf": {
          "description": "The `allOf` keyword.\n\nSee [JSON Schema 9.2.1.1. \"allOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.1).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "anyOf": {
          "description": "The `anyOf` keyword.\n\nSee [JSON Schema 9.2.1.2. \"anyOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.2).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "const": {
          "description": "The `const` keyword.\n\nSee [JSON Schema Validation 6.1.3. \"const\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.3)"
        },
        "contains": {
          "description": "The `contains` keyword.\n\nSee [JSON Schema 9.3.1.4. \"contains\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "default": {
          "description": "The `default` keyword.\n\nSee [JSON Schema Validation 9.2. \"default\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.2)."
        },
        "deprecated": {
          "description": "The `deprecated` keyword.\n\nSee [JSON Schema Validation 9.3. \"deprecated\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.3).",
          "type": "boolean"
        },
        "description": {
          "description": "The `description` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "else": {
          "description": "The `else` keyword.\n\nSee [JSON Schema 9.2.2.3. \"else\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "enum": {
          "description": "The `enum` keyword.\n\nSee [JSON Schema Validation 6.1.2. \"enum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.2)",
          "type": [
            "array",
            "null"
          ],
          "items": true
        },
        "examples": {
          "description": "The `examples` keyword.\n\nSee [JSON Schema Validation 9.5. \"examples\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5).",
          "type": "array",
          "items": true
        },
        "exclusiveMaximum": {
          "description": "The `exclusiveMaximum` keyword.\n\nSee [JSON Schema Validation 6.2.3. \"exclusiveMaximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.3).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "exclusiveMinimum": {
          "description": "The `exclusiveMinimum` keyword.\n\nSee [JSON Schema Validation 6.2.5. \"exclusiveMinimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.5).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "format": {
          "description": "The `format` keyword.\n\nSee [JSON Schema Validation 7. A Vocabulary for Semantic Content With \"format\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7).",
          "type": [
            "string",
            "null"
          ]
        },
        "if": {
          "description": "The `if` keyword.\n\nSee [JSON Schema 9.2.2.1. \"if\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "items": {
          "description": "The `items` keyword.\n\nSee [JSON Schema 9.3.1.1. \"items\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "maxItems": {
          "description": "The `maxItems` keyword.\n\nSee [JSON Schema Validation 6.4.1. \"maxItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxLength": {
          "description": "The `maxLength` keyword.\n\nSee [JSON Schema Validation 6.3.1. \"maxLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxProperties": {
          "description": "The `maxProperties` keyword.\n\nSee [JSON Schema Validation 6.5.1. \"maxProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maximum": {
          "description": "The `maximum` keyword.\n\nSee [JSON Schema Validation 6.2.2. \"maximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.2).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "minItems": {
          "description": "The `minItems` keyword.\n\nSee [JSON Schema Validation 6.4.2. \"minItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minLength": {
          "description": "The `minLength` keyword.\n\nSee [JSON Schema Validation 6.3.2. \"minLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minProperties": {
          "description": "The `minProperties` keyword.\n\nSee [JSON Schema Validation 6.5.2. \"minProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minimum": {
          "description": "The `minimum` keyword.\n\nSee [JSON Schema Validation 6.2.4. \"minimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.4).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "multipleOf": {
          "description": "The `multipleOf` keyword.\n\nSee [JSON Schema Validation 6.2.1. \"multipleOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.1).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "not": {
          "description": "The `not` keyword.\n\nSee [JSON Schema 9.2.1.4. \"not\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "oneOf": {
          "description": "The `oneOf` keyword.\n\nSee [JSON Schema 9.2.1.3. \"oneOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.3).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "pattern": {
          "description": "The `pattern` keyword.\n\nSee [JSON Schema Validation 6.3.3. \"pattern\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.3).",
          "type": [
            "string",
            "null"
          ]
        },
        "patternProperties": {
          "description": "The `patternProperties` keyword.\n\nSee [JSON Schema 9.3.2.2. \"patternProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.2).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "properties": {
          "description": "The `properties` keyword.\n\nSee [JSON Schema 9.3.2.1. \"properties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.1).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "propertyNames": {
          "description": "The `propertyNames` keyword.\n\nSee [JSON Schema 9.3.2.5. \"propertyNames\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.5).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "readOnly": {
          "description": "The `readOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        },
        "required": {
          "description": "The `required` keyword.\n\nSee [JSON Schema Validation 6.5.3. \"required\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.3).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "then": {
          "description": "The `then` keyword.\n\nSee [JSON Schema 9.2.2.2. \"then\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "title": {
          "description": "The `title` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The `type` keyword.\n\nSee [JSON Schema Validation 6.1.1. \"type\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.1) and [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_InstanceType"
            },
            {
              "type": "null"
            }
          ]
        },
        "uniqueItems": {
          "description": "The `uniqueItems` keyword.\n\nSee [JSON Schema Validation 6.4.3. \"uniqueItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.3).",
          "type": [
            "boolean",
            "null"
          ]
        },
        "writeOnly": {
          "description": "The `writeOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        }
      },
      "additionalProperties": true
    },
    "SingleOrVec_for_InstanceType": {
      "description": "A type which can be serialized as a single item, or multiple items.\n\nIn some contexts, a `Single` may be semantically distinct from a `Vec` containing only item.",
      "anyOf": [
        {
          "$ref": "#/definitions/InstanceType"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/InstanceType"
          }
        }
      ]
    },
    "SingleOrVec_for_Schema": {
      "description": "A type which can be serialized as a single item, or multiple items.\n\nIn some contexts, a `Single` may be semantically distinct from a `Vec` containing only item.",
      "anyOf": [
        {
          "$ref": "#/definitions/Schema"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Schema"
          }
        }
      ]
    }
  }
}

'''
'''--- metaschema/near-abi-current-schema.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "AbiRoot",
  "description": "Contract ABI.",
  "type": "object",
  "required": [
    "body",
    "metadata",
    "schema_version"
  ],
  "properties": {
    "body": {
      "description": "Core ABI information (functions and types).",
      "allOf": [
        {
          "$ref": "#/definitions/AbiBody"
        }
      ]
    },
    "metadata": {
      "description": "Metadata information about the contract.",
      "allOf": [
        {
          "$ref": "#/definitions/AbiMetadata"
        }
      ]
    },
    "schema_version": {
      "description": "Semver of the ABI schema format.",
      "type": "string"
    }
  },
  "additionalProperties": false,
  "definitions": {
    "AbiBody": {
      "description": "Core ABI information.",
      "type": "object",
      "required": [
        "functions",
        "root_schema"
      ],
      "properties": {
        "functions": {
          "description": "ABIs of all contract's functions.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiFunction"
          }
        },
        "root_schema": {
          "description": "Root JSON Schema containing all types referenced in the functions.",
          "allOf": [
            {
              "$ref": "#/definitions/RootSchema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiBorshParameter": {
      "description": "Information about a single named Borsh function parameter.",
      "type": "object",
      "required": [
        "name",
        "type_schema"
      ],
      "properties": {
        "name": {
          "description": "Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).",
          "type": "string"
        },
        "type_schema": {
          "description": "Inline Borsh schema that represents this type."
        }
      },
      "additionalProperties": false
    },
    "AbiFunction": {
      "description": "ABI of a single function.",
      "type": "object",
      "required": [
        "kind",
        "name"
      ],
      "properties": {
        "callbacks": {
          "description": "Type identifiers of the callbacks of the function.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiType"
          }
        },
        "callbacks_vec": {
          "description": "Type identifier of the vararg callbacks of the function.",
          "anyOf": [
            {
              "$ref": "#/definitions/AbiType"
            },
            {
              "type": "null"
            }
          ]
        },
        "doc": {
          "description": "Human-readable documentation parsed from the source file.",
          "type": [
            "string",
            "null"
          ]
        },
        "kind": {
          "description": "Function kind that regulates whether the function has to be invoked from a transaction.",
          "allOf": [
            {
              "$ref": "#/definitions/AbiFunctionKind"
            }
          ]
        },
        "modifiers": {
          "description": "List of modifiers affecting the function.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AbiFunctionModifier"
          }
        },
        "name": {
          "type": "string"
        },
        "params": {
          "description": "Type identifiers of the function parameters.",
          "allOf": [
            {
              "$ref": "#/definitions/AbiParameters"
            }
          ]
        },
        "result": {
          "description": "Return type identifier.",
          "anyOf": [
            {
              "$ref": "#/definitions/AbiType"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiFunctionKind": {
      "description": "Function kind regulates whether this function's invocation requires a transaction (so-called call functions) or not (view functions).",
      "type": "string",
      "enum": [
        "view",
        "call"
      ]
    },
    "AbiFunctionModifier": {
      "description": "Function can have multiple modifiers that can change its semantics.",
      "oneOf": [
        {
          "description": "Init functions can be used to initialize the state of the contract.",
          "type": "string",
          "enum": [
            "init"
          ]
        },
        {
          "description": "Private functions can only be called from the contract containing them. Usually, when a contract has to have a callback for a remote cross-contract call, this callback method should only be called by the contract itself.",
          "type": "string",
          "enum": [
            "private"
          ]
        },
        {
          "description": "Payable functions can accept token transfer together with the function call. This is done so that contracts can define a fee in tokens that needs to be payed when they are used.",
          "type": "string",
          "enum": [
            "payable"
          ]
        }
      ]
    },
    "AbiJsonParameter": {
      "description": "Information about a single named JSON function parameter.",
      "type": "object",
      "required": [
        "name",
        "type_schema"
      ],
      "properties": {
        "name": {
          "description": "Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).",
          "type": "string"
        },
        "type_schema": {
          "description": "JSON Subschema that represents this type (can be an inline primitive, a reference to the root schema and a few other corner-case things).",
          "allOf": [
            {
              "$ref": "#/definitions/Schema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AbiMetadata": {
      "type": "object",
      "properties": {
        "authors": {
          "description": "The authors of the smart contract.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "build": {
          "description": "The information about how this contract was built.",
          "anyOf": [
            {
              "$ref": "#/definitions/BuildInfo"
            },
            {
              "type": "null"
            }
          ]
        },
        "name": {
          "description": "The name of the smart contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "version": {
          "description": "The version of the smart contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "wasm_hash": {
          "description": "The SHA-256 hash of the contract WASM code in Base58 format.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "AbiParameters": {
      "description": "A list of function parameters sharing the same serialization type.",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "args",
            "serialization_type"
          ],
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AbiJsonParameter"
              }
            },
            "serialization_type": {
              "type": "string",
              "enum": [
                "json"
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "args",
            "serialization_type"
          ],
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AbiBorshParameter"
              }
            },
            "serialization_type": {
              "type": "string",
              "enum": [
                "borsh"
              ]
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AbiType": {
      "description": "Information about a single type (e.g. return type).",
      "oneOf": [
        {
          "required": [
            "serialization_type",
            "type_schema"
          ],
          "properties": {
            "serialization_type": {
              "type": "string",
              "enum": [
                "json"
              ]
            },
            "type_schema": {
              "$ref": "#/definitions/Schema"
            }
          },
          "additionalProperties": false
        },
        {
          "required": [
            "serialization_type",
            "type_schema"
          ],
          "properties": {
            "serialization_type": {
              "type": "string",
              "enum": [
                "borsh"
              ]
            },
            "type_schema": {}
          },
          "additionalProperties": false
        }
      ]
    },
    "BuildInfo": {
      "type": "object",
      "required": [
        "builder",
        "compiler"
      ],
      "properties": {
        "builder": {
          "description": "The build tool (versioned) that was used to build the contract.",
          "type": "string"
        },
        "compiler": {
          "description": "The compiler (versioned) that was used to build the contract.",
          "type": "string"
        },
        "image": {
          "description": "The docker image (versioned) where the contract was built.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "InstanceType": {
      "description": "The possible types of values in JSON Schema documents.\n\nSee [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
      "type": "string",
      "enum": [
        "null",
        "boolean",
        "object",
        "array",
        "number",
        "string",
        "integer"
      ]
    },
    "RootSchema": {
      "description": "The root object of a JSON Schema document.",
      "type": "object",
      "properties": {
        "$id": {
          "description": "The `$id` keyword.\n\nSee [JSON Schema 8.2.2. The \"$id\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2).",
          "type": [
            "string",
            "null"
          ]
        },
        "$ref": {
          "description": "The `$ref` keyword.\n\nSee [JSON Schema 8.2.4.1. Direct References with \"$ref\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.4.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "$schema": {
          "description": "The `$schema` keyword.\n\nSee [JSON Schema 8.1.1. The \"$schema\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.1.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "additionalItems": {
          "description": "The `additionalItems` keyword.\n\nSee [JSON Schema 9.3.1.2. \"additionalItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "additionalProperties": {
          "description": "The `additionalProperties` keyword.\n\nSee [JSON Schema 9.3.2.3. \"additionalProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "allOf": {
          "description": "The `allOf` keyword.\n\nSee [JSON Schema 9.2.1.1. \"allOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.1).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "anyOf": {
          "description": "The `anyOf` keyword.\n\nSee [JSON Schema 9.2.1.2. \"anyOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.2).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "const": {
          "description": "The `const` keyword.\n\nSee [JSON Schema Validation 6.1.3. \"const\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.3)"
        },
        "contains": {
          "description": "The `contains` keyword.\n\nSee [JSON Schema 9.3.1.4. \"contains\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "default": {
          "description": "The `default` keyword.\n\nSee [JSON Schema Validation 9.2. \"default\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.2)."
        },
        "definitions": {
          "description": "The `definitions` keyword.\n\nIn JSON Schema draft 2019-09 this was replaced by $defs, but in Schemars this is still serialized as `definitions` for backward-compatibility.\n\nSee [JSON Schema 8.2.5. Schema Re-Use With \"$defs\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.5), and [JSON Schema (draft 07) 9. Schema Re-Use With \"definitions\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-9).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "deprecated": {
          "description": "The `deprecated` keyword.\n\nSee [JSON Schema Validation 9.3. \"deprecated\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.3).",
          "type": "boolean"
        },
        "description": {
          "description": "The `description` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "else": {
          "description": "The `else` keyword.\n\nSee [JSON Schema 9.2.2.3. \"else\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "enum": {
          "description": "The `enum` keyword.\n\nSee [JSON Schema Validation 6.1.2. \"enum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.2)",
          "type": [
            "array",
            "null"
          ],
          "items": true
        },
        "examples": {
          "description": "The `examples` keyword.\n\nSee [JSON Schema Validation 9.5. \"examples\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5).",
          "type": "array",
          "items": true
        },
        "exclusiveMaximum": {
          "description": "The `exclusiveMaximum` keyword.\n\nSee [JSON Schema Validation 6.2.3. \"exclusiveMaximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.3).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "exclusiveMinimum": {
          "description": "The `exclusiveMinimum` keyword.\n\nSee [JSON Schema Validation 6.2.5. \"exclusiveMinimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.5).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "format": {
          "description": "The `format` keyword.\n\nSee [JSON Schema Validation 7. A Vocabulary for Semantic Content With \"format\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7).",
          "type": [
            "string",
            "null"
          ]
        },
        "if": {
          "description": "The `if` keyword.\n\nSee [JSON Schema 9.2.2.1. \"if\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "items": {
          "description": "The `items` keyword.\n\nSee [JSON Schema 9.3.1.1. \"items\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "maxItems": {
          "description": "The `maxItems` keyword.\n\nSee [JSON Schema Validation 6.4.1. \"maxItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxLength": {
          "description": "The `maxLength` keyword.\n\nSee [JSON Schema Validation 6.3.1. \"maxLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxProperties": {
          "description": "The `maxProperties` keyword.\n\nSee [JSON Schema Validation 6.5.1. \"maxProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maximum": {
          "description": "The `maximum` keyword.\n\nSee [JSON Schema Validation 6.2.2. \"maximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.2).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "minItems": {
          "description": "The `minItems` keyword.\n\nSee [JSON Schema Validation 6.4.2. \"minItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minLength": {
          "description": "The `minLength` keyword.\n\nSee [JSON Schema Validation 6.3.2. \"minLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minProperties": {
          "description": "The `minProperties` keyword.\n\nSee [JSON Schema Validation 6.5.2. \"minProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minimum": {
          "description": "The `minimum` keyword.\n\nSee [JSON Schema Validation 6.2.4. \"minimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.4).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "multipleOf": {
          "description": "The `multipleOf` keyword.\n\nSee [JSON Schema Validation 6.2.1. \"multipleOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.1).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "not": {
          "description": "The `not` keyword.\n\nSee [JSON Schema 9.2.1.4. \"not\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "oneOf": {
          "description": "The `oneOf` keyword.\n\nSee [JSON Schema 9.2.1.3. \"oneOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.3).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "pattern": {
          "description": "The `pattern` keyword.\n\nSee [JSON Schema Validation 6.3.3. \"pattern\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.3).",
          "type": [
            "string",
            "null"
          ]
        },
        "patternProperties": {
          "description": "The `patternProperties` keyword.\n\nSee [JSON Schema 9.3.2.2. \"patternProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.2).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "properties": {
          "description": "The `properties` keyword.\n\nSee [JSON Schema 9.3.2.1. \"properties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.1).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "propertyNames": {
          "description": "The `propertyNames` keyword.\n\nSee [JSON Schema 9.3.2.5. \"propertyNames\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.5).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "readOnly": {
          "description": "The `readOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        },
        "required": {
          "description": "The `required` keyword.\n\nSee [JSON Schema Validation 6.5.3. \"required\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.3).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "then": {
          "description": "The `then` keyword.\n\nSee [JSON Schema 9.2.2.2. \"then\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "title": {
          "description": "The `title` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The `type` keyword.\n\nSee [JSON Schema Validation 6.1.1. \"type\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.1) and [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_InstanceType"
            },
            {
              "type": "null"
            }
          ]
        },
        "uniqueItems": {
          "description": "The `uniqueItems` keyword.\n\nSee [JSON Schema Validation 6.4.3. \"uniqueItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.3).",
          "type": [
            "boolean",
            "null"
          ]
        },
        "writeOnly": {
          "description": "The `writeOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        }
      },
      "additionalProperties": true
    },
    "Schema": {
      "description": "A JSON Schema.",
      "anyOf": [
        {
          "description": "A trivial boolean JSON Schema.\n\nThe schema `true` matches everything (always passes validation), whereas the schema `false` matches nothing (always fails validation).",
          "type": "boolean"
        },
        {
          "description": "A JSON Schema object.",
          "allOf": [
            {
              "$ref": "#/definitions/SchemaObject"
            }
          ]
        }
      ]
    },
    "SchemaObject": {
      "description": "A JSON Schema object.",
      "type": "object",
      "properties": {
        "$id": {
          "description": "The `$id` keyword.\n\nSee [JSON Schema 8.2.2. The \"$id\" Keyword](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2).",
          "type": [
            "string",
            "null"
          ]
        },
        "$ref": {
          "description": "The `$ref` keyword.\n\nSee [JSON Schema 8.2.4.1. Direct References with \"$ref\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.4.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "additionalItems": {
          "description": "The `additionalItems` keyword.\n\nSee [JSON Schema 9.3.1.2. \"additionalItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "additionalProperties": {
          "description": "The `additionalProperties` keyword.\n\nSee [JSON Schema 9.3.2.3. \"additionalProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "allOf": {
          "description": "The `allOf` keyword.\n\nSee [JSON Schema 9.2.1.1. \"allOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.1).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "anyOf": {
          "description": "The `anyOf` keyword.\n\nSee [JSON Schema 9.2.1.2. \"anyOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.2).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "const": {
          "description": "The `const` keyword.\n\nSee [JSON Schema Validation 6.1.3. \"const\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.3)"
        },
        "contains": {
          "description": "The `contains` keyword.\n\nSee [JSON Schema 9.3.1.4. \"contains\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "default": {
          "description": "The `default` keyword.\n\nSee [JSON Schema Validation 9.2. \"default\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.2)."
        },
        "deprecated": {
          "description": "The `deprecated` keyword.\n\nSee [JSON Schema Validation 9.3. \"deprecated\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.3).",
          "type": "boolean"
        },
        "description": {
          "description": "The `description` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "else": {
          "description": "The `else` keyword.\n\nSee [JSON Schema 9.2.2.3. \"else\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.3).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "enum": {
          "description": "The `enum` keyword.\n\nSee [JSON Schema Validation 6.1.2. \"enum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.2)",
          "type": [
            "array",
            "null"
          ],
          "items": true
        },
        "examples": {
          "description": "The `examples` keyword.\n\nSee [JSON Schema Validation 9.5. \"examples\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5).",
          "type": "array",
          "items": true
        },
        "exclusiveMaximum": {
          "description": "The `exclusiveMaximum` keyword.\n\nSee [JSON Schema Validation 6.2.3. \"exclusiveMaximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.3).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "exclusiveMinimum": {
          "description": "The `exclusiveMinimum` keyword.\n\nSee [JSON Schema Validation 6.2.5. \"exclusiveMinimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.5).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "format": {
          "description": "The `format` keyword.\n\nSee [JSON Schema Validation 7. A Vocabulary for Semantic Content With \"format\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7).",
          "type": [
            "string",
            "null"
          ]
        },
        "if": {
          "description": "The `if` keyword.\n\nSee [JSON Schema 9.2.2.1. \"if\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "items": {
          "description": "The `items` keyword.\n\nSee [JSON Schema 9.3.1.1. \"items\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.1.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "maxItems": {
          "description": "The `maxItems` keyword.\n\nSee [JSON Schema Validation 6.4.1. \"maxItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxLength": {
          "description": "The `maxLength` keyword.\n\nSee [JSON Schema Validation 6.3.1. \"maxLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maxProperties": {
          "description": "The `maxProperties` keyword.\n\nSee [JSON Schema Validation 6.5.1. \"maxProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.1).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "maximum": {
          "description": "The `maximum` keyword.\n\nSee [JSON Schema Validation 6.2.2. \"maximum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.2).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "minItems": {
          "description": "The `minItems` keyword.\n\nSee [JSON Schema Validation 6.4.2. \"minItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minLength": {
          "description": "The `minLength` keyword.\n\nSee [JSON Schema Validation 6.3.2. \"minLength\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minProperties": {
          "description": "The `minProperties` keyword.\n\nSee [JSON Schema Validation 6.5.2. \"minProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.2).",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "minimum": {
          "description": "The `minimum` keyword.\n\nSee [JSON Schema Validation 6.2.4. \"minimum\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.4).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "multipleOf": {
          "description": "The `multipleOf` keyword.\n\nSee [JSON Schema Validation 6.2.1. \"multipleOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.2.1).",
          "type": [
            "number",
            "null"
          ],
          "format": "double"
        },
        "not": {
          "description": "The `not` keyword.\n\nSee [JSON Schema 9.2.1.4. \"not\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.4).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "oneOf": {
          "description": "The `oneOf` keyword.\n\nSee [JSON Schema 9.2.1.3. \"oneOf\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.1.3).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Schema"
          }
        },
        "pattern": {
          "description": "The `pattern` keyword.\n\nSee [JSON Schema Validation 6.3.3. \"pattern\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.3.3).",
          "type": [
            "string",
            "null"
          ]
        },
        "patternProperties": {
          "description": "The `patternProperties` keyword.\n\nSee [JSON Schema 9.3.2.2. \"patternProperties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.2).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "properties": {
          "description": "The `properties` keyword.\n\nSee [JSON Schema 9.3.2.1. \"properties\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.1).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Schema"
          }
        },
        "propertyNames": {
          "description": "The `propertyNames` keyword.\n\nSee [JSON Schema 9.3.2.5. \"propertyNames\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.3.2.5).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "readOnly": {
          "description": "The `readOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        },
        "required": {
          "description": "The `required` keyword.\n\nSee [JSON Schema Validation 6.5.3. \"required\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.5.3).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "then": {
          "description": "The `then` keyword.\n\nSee [JSON Schema 9.2.2.2. \"then\"](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-9.2.2.2).",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "title": {
          "description": "The `title` keyword.\n\nSee [JSON Schema Validation 9.1. \"title\" and \"description\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.1).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The `type` keyword.\n\nSee [JSON Schema Validation 6.1.1. \"type\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.1.1) and [JSON Schema 4.2.1. Instance Data Model](https://tools.ietf.org/html/draft-handrews-json-schema-02#section-4.2.1).",
          "anyOf": [
            {
              "$ref": "#/definitions/SingleOrVec_for_InstanceType"
            },
            {
              "type": "null"
            }
          ]
        },
        "uniqueItems": {
          "description": "The `uniqueItems` keyword.\n\nSee [JSON Schema Validation 6.4.3. \"uniqueItems\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-6.4.3).",
          "type": [
            "boolean",
            "null"
          ]
        },
        "writeOnly": {
          "description": "The `writeOnly` keyword.\n\nSee [JSON Schema Validation 9.4. \"readOnly\" and \"writeOnly\"](https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.4).",
          "type": "boolean"
        }
      },
      "additionalProperties": true
    },
    "SingleOrVec_for_InstanceType": {
      "description": "A type which can be serialized as a single item, or multiple items.\n\nIn some contexts, a `Single` may be semantically distinct from a `Vec` containing only item.",
      "anyOf": [
        {
          "$ref": "#/definitions/InstanceType"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/InstanceType"
          }
        }
      ]
    },
    "SingleOrVec_for_Schema": {
      "description": "A type which can be serialized as a single item, or multiple items.\n\nIn some contexts, a `Single` may be semantically distinct from a `Vec` containing only item.",
      "anyOf": [
        {
          "$ref": "#/definitions/Schema"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Schema"
          }
        }
      ]
    }
  }
}

'''
'''--- metaschema/src/main.rs ---
use near_abi::AbiRoot;

fn main() -> anyhow::Result<()> {
    let mut gen = schemars::gen::SchemaGenerator::default();
    let schema = gen.root_schema_for::<AbiRoot>();
    println!("{}", serde_json::to_string_pretty(&schema)?);
    Ok(())
}

'''
'''--- near-abi/CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.4.3](https://github.com/near/near-abi-rs/compare/near-abi-v0.4.2...near-abi-v0.4.3) - 2024-04-30

### Other
- borsh update up to `<1.6.0` ([#34](https://github.com/near/near-abi-rs/pull/34))

## [0.4.2](https://github.com/near/near-abi-rs/compare/near-abi-v0.4.1...near-abi-v0.4.2) - 2024-01-21

### Other
- `borsh` version range update ([#31](https://github.com/near/near-abi-rs/pull/31))

## [0.4.1](https://github.com/near/near-abi-rs/compare/near-abi-v0.4.0...near-abi-v0.4.1) - 2023-10-30

### Other
- pin `borsh` version to avoid compile errors ([#28](https://github.com/near/near-abi-rs/pull/28))

'''
'''--- near-abi/Cargo.toml ---
[package]
name = "near-abi"
version = "0.4.3"
edition = "2021"
rust-version = "1.66.0"
license = "MIT OR Apache-2.0"
readme = "../README.md"
repository = "https://github.com/near/near-abi-rs"
description = "NEAR smart contract ABI primitives"

[dependencies]
borsh = { version = ">=1.1.0,<1.6.0", features = ["unstable__schema", "derive"] }
semver = "1"
serde = { version = "1", features = ["derive"] }
schemars = { version = "0.8.11", features = ["impl_json_schema"] }

[dev-dependencies]
serde_json = "1"
insta = "1.29.0"

[features]
__chunked-entries = []

'''
'''--- near-abi/src/lib.rs ---
use borsh::schema::{
    BorshSchemaContainer, Declaration, Definition, DiscriminantValue, Fields, VariantName,
};
use schemars::schema::{RootSchema, Schema};
use schemars::JsonSchema;
use semver::Version;
use serde::{de, Deserialize, Deserializer, Serialize};
use std::collections::{BTreeMap, HashMap};

#[doc(hidden)]
#[cfg(feature = "__chunked-entries")]
#[path = "private.rs"]
pub mod __private;

// Keep in sync with SCHEMA_VERSION below.
const SCHEMA_SEMVER: Version = Version {
    major: 0,
    minor: 4,
    patch: 0,
    pre: semver::Prerelease::EMPTY,
    build: semver::BuildMetadata::EMPTY,
};

/// Current version of the ABI schema format.
pub const SCHEMA_VERSION: &str = "0.4.0";

/// Contract ABI.
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct AbiRoot {
    /// Semver of the ABI schema format.
    #[serde(deserialize_with = "ensure_current_version")]
    pub schema_version: String,
    /// Metadata information about the contract.
    pub metadata: AbiMetadata,
    /// Core ABI information (functions and types).
    pub body: AbiBody,
}

fn ensure_current_version<'de, D: Deserializer<'de>>(d: D) -> Result<String, D::Error> {
    let unchecked = String::deserialize(d)?;
    let version = Version::parse(&unchecked)
        .map_err(|_| de::Error::custom("expected `schema_version` to be a valid semver value"))?;
    if version.major != SCHEMA_SEMVER.major || version.minor != SCHEMA_SEMVER.minor {
        if version < SCHEMA_SEMVER {
            return Err(de::Error::custom(format!(
                "expected `schema_version` to be ~{}.{}, but got {}: consider re-generating your ABI file with a newer version of SDK and cargo-near",
                SCHEMA_SEMVER.major, SCHEMA_SEMVER.minor, version
            )));
        } else {
            return Err(de::Error::custom(format!(
                "expected `schema_version` to be ~{}.{}, but got {}: consider upgrading near-abi to a newer version",
                SCHEMA_SEMVER.major, SCHEMA_SEMVER.minor, version
            )));
        }
    }
    Ok(unchecked)
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq, Default, JsonSchema)]
pub struct BuildInfo {
    /// The compiler (versioned) that was used to build the contract.
    pub compiler: String,
    /// The build tool (versioned) that was used to build the contract.
    pub builder: String,
    /// The docker image (versioned) where the contract was built.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq, Default, JsonSchema)]
pub struct AbiMetadata {
    /// The name of the smart contract.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The version of the smart contract.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// The authors of the smart contract.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub authors: Vec<String>,
    /// The information about how this contract was built.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub build: Option<BuildInfo>,
    /// The SHA-256 hash of the contract WASM code in Base58 format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wasm_hash: Option<String>,
    /// Other arbitrary metadata.
    #[serde(default, flatten, skip_serializing_if = "HashMap::is_empty")]
    pub other: HashMap<String, String>,
}

/// Core ABI information.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct AbiBody {
    /// ABIs of all contract's functions.
    pub functions: Vec<AbiFunction>,
    /// Root JSON Schema containing all types referenced in the functions.
    pub root_schema: RootSchema,
}

/// ABI of a single function.
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct AbiFunction {
    pub name: String,
    /// Human-readable documentation parsed from the source file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub doc: Option<String>,
    /// Function kind that regulates whether the function has to be invoked from a transaction.
    pub kind: AbiFunctionKind,
    /// List of modifiers affecting the function.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub modifiers: Vec<AbiFunctionModifier>,
    /// Type identifiers of the function parameters.
    #[serde(default, skip_serializing_if = "AbiParameters::is_empty")]
    pub params: AbiParameters,
    /// Type identifiers of the callbacks of the function.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub callbacks: Vec<AbiType>,
    /// Type identifier of the vararg callbacks of the function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callbacks_vec: Option<AbiType>,
    /// Return type identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub result: Option<AbiType>,
}

/// Function kind regulates whether this function's invocation requires a transaction (so-called
/// call functions) or not (view functions).
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq, JsonSchema)]
#[serde(rename_all = "lowercase")]
pub enum AbiFunctionKind {
    View,
    Call,
}

/// Function can have multiple modifiers that can change its semantics.
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq, JsonSchema)]
#[serde(rename_all = "lowercase")]
pub enum AbiFunctionModifier {
    /// Init functions can be used to initialize the state of the contract.
    Init,
    /// Private functions can only be called from the contract containing them. Usually, when a
    /// contract has to have a callback for a remote cross-contract call, this callback method
    /// should only be called by the contract itself.
    Private,
    /// Payable functions can accept token transfer together with the function call.
    /// This is done so that contracts can define a fee in tokens that needs to be payed when
    /// they are used.
    Payable,
}

/// A list of function parameters sharing the same serialization type.
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, JsonSchema)]
#[serde(tag = "serialization_type")]
#[serde(rename_all = "lowercase")]
#[serde(deny_unknown_fields)]
pub enum AbiParameters {
    Json { args: Vec<AbiJsonParameter> },
    Borsh { args: Vec<AbiBorshParameter> },
}

impl Default for AbiParameters {
    fn default() -> Self {
        // JSON was picked arbitrarily for the default value, but generally it does not matter
        // whether this is JSON or Borsh.
        AbiParameters::Json { args: Vec::new() }
    }
}

impl AbiParameters {
    pub fn is_empty(&self) -> bool {
        match self {
            Self::Json { args } => args.is_empty(),
            Self::Borsh { args } => args.is_empty(),
        }
    }
}

/// Information about a single named JSON function parameter.
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct AbiJsonParameter {
    /// Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).
    pub name: String,
    /// JSON Subschema that represents this type (can be an inline primitive, a reference to the root schema and a few other corner-case things).
    pub type_schema: Schema,
}

/// Information about a single named Borsh function parameter.
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct AbiBorshParameter {
    /// Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).
    pub name: String,
    /// Inline Borsh schema that represents this type.
    #[serde(with = "BorshSchemaContainerDef")]
    pub type_schema: BorshSchemaContainer,
}

impl JsonSchema for AbiBorshParameter {
    fn schema_name() -> String {
        "AbiBorshParameter".to_string()
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> Schema {
        let mut name_schema_object = <String as JsonSchema>::json_schema(gen).into_object();
        name_schema_object.metadata().description =
            Some("Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`).".to_string());

        let mut type_schema_object = Schema::Bool(true).into_object();
        type_schema_object.metadata().description =
            Some("Inline Borsh schema that represents this type.".to_string());

        let mut schema_object = schemars::schema::SchemaObject {
            instance_type: Some(schemars::schema::InstanceType::Object.into()),
            ..Default::default()
        };
        schema_object.metadata().description =
            Some("Information about a single named Borsh function parameter.".to_string());
        let object_validation = schema_object.object();
        object_validation
            .properties
            .insert("name".to_string(), name_schema_object.into());
        object_validation
            .properties
            // TODO: Narrow to BorshSchemaContainer once it derives JsonSchema
            .insert("type_schema".to_string(), type_schema_object.into());
        object_validation.required.insert("name".to_string());
        object_validation.required.insert("type_schema".to_string());
        object_validation.additional_properties =
            Some(schemars::schema::Schema::Bool(false).into());
        schema_object.into()
    }
}

/// Information about a single type (e.g. return type).
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
#[serde(tag = "serialization_type")]
#[serde(rename_all = "lowercase")]
#[serde(deny_unknown_fields)]
pub enum AbiType {
    Json {
        /// JSON Subschema that represents this type (can be an inline primitive, a reference to the root schema and a few other corner-case things).
        type_schema: Schema,
    },
    Borsh {
        /// Inline Borsh schema that represents this type.
        #[serde(with = "BorshSchemaContainerDef")]
        type_schema: BorshSchemaContainer,
    },
}

impl JsonSchema for AbiType {
    fn schema_name() -> String {
        "AbiType".to_string()
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> Schema {
        let mut json_abi_type = schemars::schema::SchemaObject::default();
        let json_abi_schema = json_abi_type.object();
        json_abi_schema
            .properties
            .insert("serialization_type".to_string(), {
                let schema = <String as JsonSchema>::json_schema(gen);
                let mut schema = schema.into_object();
                schema.enum_values = Some(vec!["json".into()]);
                schema.into()
            });
        json_abi_schema
            .properties
            .insert("type_schema".to_string(), gen.subschema_for::<Schema>());
        json_abi_schema
            .required
            .insert("serialization_type".to_string());
        json_abi_schema.required.insert("type_schema".to_string());
        json_abi_schema.additional_properties = Some(schemars::schema::Schema::Bool(false).into());

        let mut borsh_abi_type = schemars::schema::SchemaObject::default();
        let borsh_abi_schema = borsh_abi_type.object();
        borsh_abi_schema
            .properties
            .insert("serialization_type".to_string(), {
                let schema = <String as JsonSchema>::json_schema(gen);
                let mut schema = schema.into_object();
                schema.enum_values = Some(vec!["borsh".into()]);
                schema.into()
            });
        borsh_abi_schema
            .properties
            // TODO: Narrow to BorshSchemaContainer once it derives JsonSchema
            .insert(
                "type_schema".to_string(),
                schemars::schema::SchemaObject::default().into(),
            );
        borsh_abi_schema
            .required
            .insert("serialization_type".to_string());
        borsh_abi_schema.required.insert("type_schema".to_string());
        borsh_abi_schema.additional_properties = Some(schemars::schema::Schema::Bool(false).into());

        let mut schema_object = schemars::schema::SchemaObject {
            subschemas: Some(Box::new(schemars::schema::SubschemaValidation {
                one_of: Some(vec![
                    json_abi_type.into(),
                    borsh_abi_type.into(), // TODO: Narrow to BorshSchemaContainer once it derives JsonSchema
                ]),
                ..Default::default()
            })),
            ..Default::default()
        };
        schema_object.metadata().description =
            Some("Information about a single type (e.g. return type).".to_string());
        schema_object.into()
    }
}

#[derive(Serialize, Deserialize)]
#[serde(remote = "BorshSchemaContainer")]
struct BorshSchemaContainerDef {
    #[serde(getter = "borsh_serde::getters::declaration")]
    declaration: Declaration,
    #[serde(with = "borsh_serde", getter = "borsh_serde::getters::definitions")]
    definitions: BTreeMap<Declaration, Definition>,
}

impl From<BorshSchemaContainerDef> for BorshSchemaContainer {
    fn from(value: BorshSchemaContainerDef) -> Self {
        Self::new(value.declaration, value.definitions)
    }
}

/// This submodules follows <https://serde.rs/remote-derive.html> to derive Serialize/Deserialize for
/// `BorshSchemaContainer` parameters. The top-level serialization type is `BTreeMap<Declaration, Definition>`
/// for the sake of being easily plugged into `BorshSchemaContainerDef` (see its parameters).
mod borsh_serde {
    use super::*;
    use serde::ser::SerializeMap;
    use serde::{Deserializer, Serializer};
    pub mod getters {
        use super::*;

        pub fn declaration(obj: &BorshSchemaContainer) -> &Declaration {
            obj.declaration()
        }

        pub fn definitions(obj: &BorshSchemaContainer) -> BTreeMap<Declaration, Definition> {
            let definitions: BTreeMap<Declaration, Definition> = obj
                .definitions()
                .map(|(k, v)| (k.clone(), v.clone()))
                .collect();
            definitions
        }
    }

    #[derive(Serialize, Deserialize)]
    #[serde(remote = "Definition")]
    enum DefinitionDef {
        Primitive(u8),
        Sequence {
            length_width: u8,
            length_range: core::ops::RangeInclusive<u64>,
            elements: Declaration,
        },
        #[serde(with = "transparent")]
        Tuple {
            elements: Vec<Declaration>,
        },
        Enum {
            tag_width: u8,
            variants: Vec<(DiscriminantValue, VariantName, Declaration)>,
        },
        #[serde(with = "transparent_fields")]
        Struct {
            fields: Fields,
        },
    }

    #[derive(Serialize, Deserialize)]
    struct HelperDefinition(#[serde(with = "DefinitionDef")] Definition);

    /// #[serde(transparent)] does not support enum variants, so we have to use a custom ser/de impls for now.
    /// See <https://github.com/serde-rs/serde/issues/2092>.
    mod transparent {
        use serde::{Deserialize, Deserializer, Serialize, Serializer};

        pub fn serialize<T, S>(field: &T, serializer: S) -> Result<S::Ok, S::Error>
        where
            T: Serialize,
            S: Serializer,
        {
            serializer.serialize_some(&field)
        }

        pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
        where
            T: Deserialize<'de>,
            D: Deserializer<'de>,
        {
            T::deserialize(deserializer)
        }
    }

    /// Since `Fields` itself does not implement `Serialization`/`Deserialization`, we can't use
    /// `transparent` in combination with `#[serde(with = "...")]. Instead we have do it in this
    /// roundabout way.
    mod transparent_fields {
        use borsh::schema::{Declaration, FieldName, Fields};
        use serde::{Deserialize, Deserializer, Serialize, Serializer};

        #[derive(Serialize, Deserialize)]
        #[serde(remote = "Fields", untagged)]
        enum FieldsDef {
            NamedFields(Vec<(FieldName, Declaration)>),
            UnnamedFields(Vec<Declaration>),
            Empty,
        }

        #[derive(Serialize, Deserialize)]
        struct HelperFields(#[serde(with = "FieldsDef")] Fields);

        pub fn serialize<S>(fields: &Fields, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            HelperFields(fields.clone()).serialize(serializer)
        }

        pub fn deserialize<'de, D>(deserializer: D) -> Result<Fields, D::Error>
        where
            D: Deserializer<'de>,
        {
            Ok(HelperFields::deserialize(deserializer)?.0)
        }
    }

    pub fn serialize<S>(
        map: &BTreeMap<Declaration, Definition>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut map_ser = serializer.serialize_map(Some(map.len()))?;
        for (k, v) in map {
            map_ser.serialize_entry(k, &HelperDefinition(v.clone()))?;
        }
        map_ser.end()
    }

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<BTreeMap<Declaration, Definition>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let map = BTreeMap::<Declaration, HelperDefinition>::deserialize(deserializer)?;
        Ok(map
            .into_iter()
            .map(|(k, HelperDefinition(v))| (k, v))
            .collect())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use borsh::BorshSchema;

    fn get_definitions(type_schema: &BorshSchemaContainer) -> BTreeMap<Declaration, Definition> {
        let definitions: BTreeMap<Declaration, Definition> = type_schema
            .definitions()
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect();
        definitions
    }

    #[test]
    fn test_serde_abitype_borsh_array() {
        let abi_type = AbiType::Borsh {
            type_schema: borsh::schema_container_of::<[u32; 2]>(),
        };
        let expected_json_str = serde_json::to_string_pretty(&abi_type).unwrap();
        insta::assert_snapshot!(expected_json_str);

        if let AbiType::Borsh { type_schema } = serde_json::from_str(&expected_json_str).unwrap() {
            assert_eq!(type_schema.declaration(), "[u32; 2]");
            let definitions = get_definitions(&type_schema);
            assert_eq!(definitions.len(), 2);
            assert_eq!(
                definitions.get("[u32; 2]").unwrap(),
                &Definition::Sequence {
                    length_width: 0,
                    length_range: 2..=2,
                    elements: "u32".to_string()
                }
            );

            assert_eq!(definitions.get("u32").unwrap(), &Definition::Primitive(4));
        } else {
            panic!("Unexpected serialization type")
        }
    }

    #[test]
    fn test_serde_abitype_borsh_sequence() {
        let abi_type = AbiType::Borsh {
            type_schema: borsh::schema_container_of::<Vec<u32>>(),
        };
        let expected_json_str = serde_json::to_string_pretty(&abi_type).unwrap();
        insta::assert_snapshot!(expected_json_str);

        if let AbiType::Borsh { type_schema } = serde_json::from_str(&expected_json_str).unwrap() {
            assert_eq!(type_schema.declaration(), "Vec<u32>");
            let definitions = get_definitions(&type_schema);
            assert_eq!(definitions.len(), 2);
            assert_eq!(
                definitions.get("Vec<u32>").unwrap(),
                &Definition::Sequence {
                    length_width: Definition::DEFAULT_LENGTH_WIDTH,
                    length_range: Definition::DEFAULT_LENGTH_RANGE,
                    elements: "u32".to_string()
                }
            );
            assert_eq!(definitions.get("u32").unwrap(), &Definition::Primitive(4));
        } else {
            panic!("Unexpected serialization type")
        }
    }

    #[test]
    fn test_serde_abitype_borsh_tuple() {
        let abi_type = AbiType::Borsh {
            type_schema: borsh::schema_container_of::<(u32, u32)>(),
        };
        let expected_json_str = serde_json::to_string_pretty(&abi_type).unwrap();
        insta::assert_snapshot!(expected_json_str);

        if let AbiType::Borsh { type_schema } = serde_json::from_str(&expected_json_str).unwrap() {
            assert_eq!(type_schema.declaration(), "(u32, u32)");
            let definitions = get_definitions(&type_schema);
            assert_eq!(definitions.len(), 2);
            assert_eq!(
                definitions.get("(u32, u32)").unwrap(),
                &Definition::Tuple {
                    elements: vec!["u32".to_string(), "u32".to_string()]
                }
            );
            assert_eq!(definitions.get("u32").unwrap(), &Definition::Primitive(4));
        } else {
            panic!("Unexpected serialization type")
        }
    }

    #[test]
    fn test_serde_abitype_borsh_enum() {
        #[derive(BorshSchema)]
        enum Either {
            _Left(u32),
            _Right(u32),
        }
        let abi_type = AbiType::Borsh {
            type_schema: borsh::schema_container_of::<Either>(),
        };
        let expected_json_str = serde_json::to_string_pretty(&abi_type).unwrap();
        insta::assert_snapshot!(expected_json_str);

        if let AbiType::Borsh { type_schema } = serde_json::from_str(&expected_json_str).unwrap() {
            assert_eq!(type_schema.declaration(), "Either");
            let definitions = get_definitions(&type_schema);
            assert_eq!(definitions.len(), 4);
            assert_eq!(
                definitions.get("Either").unwrap(),
                &Definition::Enum {
                    tag_width: 1,
                    variants: vec![
                        (0, "_Left".to_string(), "Either_Left".to_string()),
                        (1, "_Right".to_string(), "Either_Right".to_string())
                    ]
                }
            );
        } else {
            panic!("Unexpected serialization type")
        }
    }

    #[test]
    fn test_serde_abitype_borsh_struct_named() {
        #[derive(BorshSchema)]
        struct Pair {
            _first: u32,
            _second: u32,
        }
        let abi_type = AbiType::Borsh {
            type_schema: borsh::schema_container_of::<Pair>(),
        };
        let expected_json_str = serde_json::to_string_pretty(&abi_type).unwrap();
        insta::assert_snapshot!(expected_json_str);

        if let AbiType::Borsh { type_schema } = serde_json::from_str(&expected_json_str).unwrap() {
            assert_eq!(type_schema.declaration(), "Pair");
            let definitions = get_definitions(&type_schema);
            assert_eq!(definitions.len(), 2);
            assert_eq!(
                definitions.get("Pair").unwrap(),
                &Definition::Struct {
                    fields: Fields::NamedFields(vec![
                        ("_first".to_string(), "u32".to_string()),
                        ("_second".to_string(), "u32".to_string())
                    ])
                }
            );
        } else {
            panic!("Unexpected serialization type")
        }
    }

    #[test]
    fn test_serde_abitype_borsh_struct_unnamed() {
        #[derive(BorshSchema)]
        struct Pair(u32, u32);
        let abi_type = AbiType::Borsh {
            type_schema: borsh::schema_container_of::<Pair>(),
        };
        let expected_json_str = serde_json::to_string_pretty(&abi_type).unwrap();
        insta::assert_snapshot!(expected_json_str);

        if let AbiType::Borsh { type_schema } = serde_json::from_str(&expected_json_str).unwrap() {
            assert_eq!(type_schema.declaration(), "Pair");
            let definitions = get_definitions(&type_schema);
            assert_eq!(definitions.len(), 2);
            assert_eq!(
                definitions.get("Pair").unwrap(),
                &Definition::Struct {
                    fields: Fields::UnnamedFields(vec!["u32".to_string(), "u32".to_string()])
                }
            );
        } else {
            panic!("Unexpected serialization type")
        }
    }

    #[test]
    fn test_serde_abitype_borsh_struct_empty() {
        #[derive(BorshSchema)]
        struct Unit;
        let abi_type = AbiType::Borsh {
            type_schema: borsh::schema_container_of::<Unit>(),
        };
        let expected_json_str = serde_json::to_string_pretty(&abi_type).unwrap();
        insta::assert_snapshot!(expected_json_str);

        if let AbiType::Borsh { type_schema } = serde_json::from_str(&expected_json_str).unwrap() {
            assert_eq!(type_schema.declaration(), "Unit");
            let definitions = get_definitions(&type_schema);
            assert_eq!(definitions.len(), 1);
            assert_eq!(
                definitions.get("Unit").unwrap(),
                &Definition::Struct {
                    fields: Fields::Empty
                }
            );
        } else {
            panic!("Unexpected serialization type")
        }
    }

    #[test]
    fn test_de_error_abitype_unknown_fields() {
        let json = r#"
          {
            "serialization_type": "borsh",
            "extra": "blah-blah",
            "type_schema": {
              "declaration": "Unit",
              "definitions": {
                "Unit": {
                  "Struct": null
                }
              }
            }
          }
        "#;
        serde_json::from_str::<AbiType>(json)
            .expect_err("Expected deserialization to fail due to unknown field");
    }

    #[test]
    fn test_serde_abiborshparameter_struct_empty() {
        #[derive(BorshSchema)]
        struct Unit;
        let expected_param = AbiBorshParameter {
            name: "foo".to_string(),
            type_schema: borsh::schema_container_of::<Unit>(),
        };

        let expected_json_str = serde_json::to_string_pretty(&expected_param).unwrap();
        insta::assert_snapshot!(expected_json_str);

        let param = serde_json::from_str::<AbiBorshParameter>(&expected_json_str).unwrap();
        assert_eq!(param.name, "foo");
        assert_eq!(param.type_schema.declaration(), "Unit");
        let definitions = get_definitions(&param.type_schema);
        assert_eq!(definitions.len(), 1);
        assert_eq!(
            definitions.get("Unit").unwrap(),
            &Definition::Struct {
                fields: Fields::Empty
            }
        );
    }

    #[test]
    fn test_de_error_abiborshparameter_unknown_fields() {
        let json = r#"
          {
            "name": "foo",
            "extra": "blah-blah",
            "type_schema": {
              "declaration": "Unit",
              "definitions": {
                "Unit": {
                  "Struct": null
                }
              }
            }
          }
        "#;
        serde_json::from_str::<AbiBorshParameter>(json)
            .expect_err("Expected deserialization to fail due to unknown field");
    }

    #[test]
    fn test_de_abiroot_correct_version() {
        let json = format!(
            r#"
            {{
                "schema_version": "{}",
                "metadata": {{}},
                "body": {{
                    "functions": [],
                    "root_schema": {{}}
                }}
            }}
            "#,
            SCHEMA_VERSION
        );
        let abi_root = serde_json::from_str::<AbiRoot>(&json).unwrap();
        assert_eq!(abi_root.schema_version, SCHEMA_VERSION);
    }

    #[test]
    fn test_de_error_abiroot_older_version() {
        let json = r#"
          {
            "schema_version": "0.0.1",
            "metadata": {},
            "body": {
                "functions": [],
                "root_schema": {}
            }
          }
        "#;
        let err = serde_json::from_str::<AbiRoot>(json)
            .expect_err("Expected deserialization to fail due to schema version mismatch");
        assert!(err.to_string().contains(
            "got 0.0.1: consider re-generating your ABI file with a newer version of SDK and cargo-near"
        ));
    }

    #[test]
    fn test_de_error_abiroot_newer_version() {
        let json = r#"
          {
            "schema_version": "99.99.99",
            "metadata": {},
            "body": {
                "functions": [],
                "root_schema": {}
            }
          }
        "#;
        let err = serde_json::from_str::<AbiRoot>(json)
            .expect_err("Expected deserialization to fail due to schema version mismatch");
        assert!(err
            .to_string()
            .contains("got 99.99.99: consider upgrading near-abi to a newer version"));
    }
}

'''
'''--- near-abi/src/private.rs ---
use super::{
    ensure_current_version, AbiBody, AbiFunction, AbiMetadata, AbiRoot, RootSchema, SCHEMA_VERSION,
};
use serde::{Deserialize, Serialize};
use std::fmt;

/// Core ABI information, with schema version and identity hash.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ChunkedAbiEntry {
    /// Semver of the ABI schema format.
    #[serde(deserialize_with = "ensure_current_version")]
    pub schema_version: String,
    #[serde(flatten)]
    pub body: AbiBody,
}

impl ChunkedAbiEntry {
    pub fn new(functions: Vec<AbiFunction>, root_schema: RootSchema) -> ChunkedAbiEntry {
        Self {
            schema_version: SCHEMA_VERSION.to_string(),
            body: AbiBody {
                functions,
                root_schema,
            },
        }
    }

    pub fn combine<I: IntoIterator<Item = ChunkedAbiEntry>>(
        entries: I,
    ) -> Result<ChunkedAbiEntry, AbiCombineError> {
        let mut schema_version = None;
        let mut functions = Vec::<AbiFunction>::new();

        let mut gen = schemars::gen::SchemaGenerator::default();
        let definitions = gen.definitions_mut();

        let mut unexpected_versions = std::collections::BTreeSet::new();

        for entry in entries {
            if let Some(ref schema_version) = schema_version {
                // should probably only disallow major version mismatch
                if schema_version != &entry.schema_version {
                    unexpected_versions.insert(entry.schema_version.clone());
                    continue;
                }
            } else {
                schema_version = Some(entry.schema_version);
            }

            // Update resulting JSON Schema
            definitions.extend(entry.body.root_schema.definitions.to_owned());

            // Update resulting function list
            functions.extend(entry.body.functions);
        }

        if !unexpected_versions.is_empty() {
            return Err(AbiCombineError {
                kind: AbiCombineErrorKind::SchemaVersionConflict {
                    expected: schema_version.unwrap(),
                    found: unexpected_versions.into_iter().collect(),
                },
            });
        }

        // Sort the function list for readability
        functions.sort_by(|x, y| x.name.cmp(&y.name));

        Ok(ChunkedAbiEntry {
            schema_version: schema_version.unwrap(),
            body: AbiBody {
                functions,
                root_schema: gen.into_root_schema_for::<String>(),
            },
        })
    }

    pub fn into_abi_root(self, metadata: AbiMetadata) -> AbiRoot {
        AbiRoot {
            schema_version: self.schema_version,
            metadata,
            body: self.body,
        }
    }
}

#[derive(Eq, Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct AbiCombineError {
    #[serde(flatten)]
    kind: AbiCombineErrorKind,
}

impl AbiCombineError {
    pub fn kind(&self) -> &AbiCombineErrorKind {
        &self.kind
    }
}

impl std::error::Error for AbiCombineError {}
impl fmt::Display for AbiCombineError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.kind.fmt(f)
    }
}

#[derive(Eq, Clone, Debug, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum AbiCombineErrorKind {
    SchemaVersionConflict {
        expected: String,
        found: Vec<String>,
    },
}

impl fmt::Display for AbiCombineErrorKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::SchemaVersionConflict { expected, found } => format!(
                "ABI schema version conflict: expected {}, found {}",
                expected,
                found.join(", ")
            )
            .fmt(f),
        }
    }
}

'''