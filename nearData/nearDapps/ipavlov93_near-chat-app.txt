*GitHub Repository "ipavlov93/near-chat-app"*

'''--- Cargo.toml ---
[workspace]
members = [
    "contracts/package",
    "contracts/router",
    "contracts/chat"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- README.md ---
## Near Chat Application

This is [NCD] demo project. No production use intended.

### Diagram

![img.png](img.png)
[Excalidraw](https://excalidraw.com/) used to draw diagram.

## Concepts

Chat implementation based on NEAR protocol. It's text chat for whitelisted NEAR accounts and public text channel for the whole world.

These power concepts make dApp oriented for any community or organization.

### Who This Is For

- Developers new to the NEAR Protocol looking for a learning sandbox
- Developers looking for inspiration

## File Structure

This contract is designed to be self-contained and so may be extracted into your own projects and used as a starting point.  If you do decide to use this code, please pay close attention to all top level files including:

- Rust artifacts
  - `Cargo.toml`: Rust project dependencies and configuration
  - `Cargo.lock`: version-locked list of Rust project dependencies

## Build Contracts

You will need [Rust] with `wasm32-unknown-unknown` [target] installed.

Build contracts using script `compile.js`
```
node compile.js
```
or using [cargo]
```
cargo build --target wasm32-unknown-unknown --release
```

## Tests

Run smart contract with [cargo] 
```
cargo test
```

## Run locally
Start up front-end (see [readme](./src/))

[Rust]: https://www.rust-lang.org/
[target]: https://github.com/near/near-sdk-rs#pre-requisites
[cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html
[NCD]: https://www.near.university/courses/near-certified-developer
[smart contract]: https://docs.near.org/docs/develop/contracts/overview

'''
'''--- compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder â€“
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contracts/README.md ---
Contracts
==================

[Smart contracts] are written in [Rust]. Directory contains `chat-space` smart contract crates.

[Rust]: https://www.rust-lang.org/
[Smart contracts]: https://docs.near.org/docs/develop/contracts/overview

'''
'''--- contracts/chat/Cargo.toml ---
[package]
name = "chat-space"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
schemars = "*"
bincode = "*"
chat-space-package = { path = "../package", default-features = false }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contracts/chat/README.md ---
Chat Smart Contract
==================

A [smart contract] is written in [Rust]. It implements immutable chat that's stored in blockchain.

The [smart contract] provided here enable users to chat. Common chat very similar to Slack `general` channel where members can send messages, and it guarantees that it will never be changed. Contract can be used like text channel and chat at the same time. Any NEAR account can be added to whitelist during contract initialization. Only whitelisted users can execute `call` contract methods.

This version of contract doesn't support update and delete `call` for whitelist and messages. And the main thing is app powered by the NEAR protocol, so identity tools are built in.

### Key benefits
1. dApp is easy to use
2. messages are immutable
3. chat looks like text channel for anyone (chat is visible through blockchain)

[Rust]: https://www.rust-lang.org/
[smart contract]: https://docs.near.org/docs/develop/contracts/overview

'''
'''--- contracts/chat/src/contract.rs ---
//! This contract implements immutable chat that's stored in blockchain.
//!
//! The contract provides methods to [send_message], [get_messages], [is_whitelisted_account].
//!
//! [send_message]: struct.Chat.html#method.send_message
//! [get_messages]: struct.Chat.html#method.get_messages
//! [is_whitelisted_account]: struct.Chat.html#method.is_whitelisted_account

use near_sdk::json_types::{ValidAccountId, U64};
use near_sdk::{env, near_bindgen};

use chat_space_package::pagination::calculate_pagination_range;

use crate::message::{validate_message, Message, Messages};
use crate::*;

near_sdk::setup_alloc!();

#[near_bindgen]
impl Chat {
    /// # Description
    /// Check does whitelist contain given account
    /// # Params
    /// * **account_id** is a string of type [`ValidAccountId`] contains validated account.
    pub fn is_whitelisted_account(&self, account_id: ValidAccountId) -> bool {
        self.whitelist.contains(&account_id.into())
    }

    /// # Description
    /// Publishes given message to storage if it's valid. Sender account must be whitelisted
    /// # Params
    /// * **text_message** is a string text message.
    pub fn send_message(&mut self, text_message: String) {
        let account_id = env::signer_account_id();

        // check whitelist
        assert!(self.whitelist.contains(&account_id), "Not enough rights");

        assert!(validate_message(text_message.clone()), "Invalid message");

        let message = Message {
            text: text_message,
            sender: env::signer_account_id(),
            created_at: env::block_timestamp(),
        };
        self.messages.push(&message);
    }

    /// # Description
    /// Returns message batch with [`MAX_LIMIT`] maximum length
    /// # Params
    /// * **page** is a page number for pagination.
    pub fn get_messages(&self, page: u64, mut limit: u64) -> Messages {
        let total = self.messages.len();

        if limit > MAX_LIMIT {
            limit = MAX_LIMIT
        }

        let (offset, mut last_message_index) = calculate_pagination_range(page, limit);
        if last_message_index > total {
            last_message_index = total;
        }

        let mut messages: Vec<Message> = Vec::new();
        for index in offset..last_message_index {
            messages.push(self.messages.get(index).unwrap())
        }

        Messages {
            total: U64::from(total),
            messages,
        }
    }
}

'''
'''--- contracts/chat/src/lib.rs ---
pub mod contract;
pub mod message;
mod testing;

use crate::message::Message;
use chat_space_package::accounts_whitelist::WhitelistAccounts;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupSet, Vector};
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey};

/// # Pagination settings
/// The maximum amount of messages per page. Message amount that can be read at once
pub(crate) const MAX_LIMIT: u64 = 100;

/// This is an enum that contains storage keys
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    MessagesKey,
    WhitelistedAccountsKey,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Chat {
    /// This is a vector that contains account messages
    messages: Vector<Message>,
    /// This is a set that contains allowed account keys to make contract calls
    whitelist: LookupSet<AccountId>,
}

impl Default for Chat {
    fn default() -> Self {
        env::panic(b"The contract should be initialized before usage")
    }
}

#[near_bindgen]
impl Chat {
    /// # Description
    /// Creates the contract and inits whitelist
    /// # Params
    /// * **accounts** is an object of type [`WhitelistAccounts`] contains valid accounts.
    #[init]
    pub fn new(accounts: WhitelistAccounts) -> Self {
        assert!(!env::state_exists(), "Already initialized");

        // whitelist should store only valid accounts
        let mut whitelist = LookupSet::new(StorageKeys::WhitelistedAccountsKey);
        for account in accounts.accounts.iter() {
            whitelist.insert(account.as_ref());
        }

        Self {
            whitelist,
            messages: Vector::new(StorageKeys::MessagesKey),
        }
    }
}

'''
'''--- contracts/chat/src/message.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Timestamp};
use schemars::JsonSchema;

/// # Validation settings
/// The minimum message length
const MIN_MSG_LENGTH: usize = 4;
/// The maximum message length
const MAX_MSG_LENGTH: usize = 1000;

/// # Description
/// Message is supposed to store only `text` actually.
/// Sender and sending date could be easily found in final tx.
/// Dropping these fields here will help to minify storage consumption by the contract.
/// Indexing data by separated backend service will help to optimise search.
#[derive(
    Clone, Debug, PartialEq, Serialize, Deserialize, BorshDeserialize, BorshSerialize, JsonSchema,
)]
#[serde(crate = "near_sdk::serde")]
pub struct Message {
    pub text: String,
    pub sender: AccountId,
    pub created_at: Timestamp,
}

/// # Description
/// Pagination messages
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Messages {
    pub total: U64,
    pub messages: Vec<Message>,
}

/// # Description
/// Checks input message length
pub fn validate_message(message: String) -> bool {
    if message.len() < MIN_MSG_LENGTH || message.len() > MAX_MSG_LENGTH {
        return false;
    }
    true
}

'''
'''--- contracts/chat/src/testing.rs ---
// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use std::convert::TryInto;

    use near_sdk::json_types::ValidAccountId;
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, MockedBlockchain, VMContext};

    use crate::WhitelistAccounts;
    use crate::{Chat, MAX_LIMIT};

    // part of writing unit tests is setting up a mock context
    fn get_context(
        is_view: bool,
        signer: ValidAccountId,
        current_account_id: ValidAccountId,
    ) -> VMContext {
        VMContextBuilder::new()
            .block_timestamp(100)
            .current_account_id(current_account_id)
            .signer_account_id(signer)
            .is_view(is_view)
            .build()
    }

    #[test]
    fn whitelist_account_should_send_message() {
        // test accounts
        let account = alice().clone();
        let whitelisted_account = bob().clone();
        let owner = carol().clone();

        // set up the mock context into the testing environment
        let context = get_context(
            false,
            whitelisted_account.clone().try_into().unwrap(),
            owner.clone().try_into().unwrap(),
        );
        testing_env!(context.clone());

        let mut whitelist = WhitelistAccounts::default();

        whitelist
            .accounts
            .push(ValidAccountId::try_from(whitelisted_account.clone().to_string()).unwrap());
        // init a contract
        let mut contract = Chat::new(whitelist);
        assert_eq!(
            contract.is_whitelisted_account(owner.try_into().unwrap()),
            false
        );
        assert_eq!(
            contract.is_whitelisted_account(account.try_into().unwrap()),
            false
        );
        assert_eq!(
            contract.is_whitelisted_account(whitelisted_account.try_into().unwrap()),
            true
        );

        let msg = "first msg".to_string();
        contract.send_message(msg);
    }

    #[test]
    #[should_panic(expected = "Invalid message")]
    fn sending_invalid_message() {
        let whitelisted_account = bob().clone();

        // set up the mock context into the testing environment
        let context = get_context(
            false,
            bob().clone().try_into().unwrap(),
            bob().clone().try_into().unwrap(),
        );
        testing_env!(context.clone());

        let mut whitelist = WhitelistAccounts::default();

        whitelist
            .accounts
            .push(ValidAccountId::try_from(whitelisted_account.to_string()).unwrap());
        // init a contract
        let mut contract = Chat::new(whitelist);

        let msg = "msg".to_string();
        contract.send_message(msg);
    }

    #[test]
    #[should_panic(expected = "Not enough rights")]
    fn sending_restricted() {
        // test accounts
        let account = alice().clone();
        let whitelisted_account = bob().clone();
        let owner = carol().clone();

        let context = get_context(
            false,
            account.clone().try_into().unwrap(),
            owner.clone().try_into().unwrap(),
        );
        testing_env!(context.clone());
        let mut whitelist = WhitelistAccounts::default();
        whitelist
            .accounts
            .push(ValidAccountId::try_from(whitelisted_account.to_string()).unwrap());
        let mut contract = Chat::new(whitelist);

        let msg = "first msg".to_string();
        contract.send_message(msg);
    }

    #[test]
    fn should_get_pagination_messages() {
        let whitelisted_account = bob().clone();

        // set up the mock context into the testing environment
        let context = get_context(
            false,
            bob().clone().try_into().unwrap(),
            bob().clone().try_into().unwrap(),
        );
        testing_env!(context.clone());

        // init a contract
        let mut whitelist = WhitelistAccounts::default();
        whitelist
            .accounts
            .push(ValidAccountId::try_from(whitelisted_account.to_string()).unwrap());
        let mut contract = Chat::new(whitelist);

        // empty chat
        let res = contract.get_messages(0, MAX_LIMIT);
        assert_eq!(res.total.0, 0);
        assert_eq!(res.messages.len(), 0);

        // sent fake messages
        let msg_number = 2;
        for i in 1..msg_number + 1 {
            let msg = format!("msg {} from {}", i, whitelisted_account);
            contract.send_message(msg);
        }

        let res = contract.get_messages(0, MAX_LIMIT);
        assert_eq!(res.total.0, msg_number);
        assert_eq!(res.messages.len(), msg_number as usize);

        let res = contract.get_messages(1, MAX_LIMIT);
        assert_eq!(res.messages.len(), msg_number as usize);

        let res = contract.get_messages(2, MAX_LIMIT);
        assert_eq!(res.messages.len(), 0);

        // sent fake messages again
        let additional_msg_number = MAX_LIMIT * 2;
        for i in 1..additional_msg_number + 1 {
            let msg = format!("msg {} from {}", i, whitelisted_account);
            contract.send_message(msg);
        }

        let res = contract.get_messages(0, MAX_LIMIT);
        assert_eq!(res.total.0, msg_number + additional_msg_number);
        assert_eq!(res.messages.len(), MAX_LIMIT as usize);

        let res = contract.get_messages(1, MAX_LIMIT);
        assert_eq!(res.messages.len(), MAX_LIMIT as usize);
        let res = contract.get_messages(2, MAX_LIMIT);
        assert_eq!(res.messages.len(), MAX_LIMIT as usize);
        let res = contract.get_messages(3, MAX_LIMIT);
        assert_eq!(res.messages.len(), msg_number as usize);
        let res = contract.get_messages(4, MAX_LIMIT);
        assert_eq!(res.messages.len(), 0);
    }
}

'''
'''--- contracts/package/Cargo.toml ---
[package]
name = "chat-space-package"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contracts/package/README.md ---
Package
==================

Crate contains methods that can be used by contracts.
'''
'''--- contracts/package/src/accounts_whitelist.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(
    Debug, Default, PartialEq, Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize,
)]
#[serde(crate = "near_sdk::serde")]
pub struct WhitelistAccounts {
    pub accounts: Vec<ValidAccountId>,
}

'''
'''--- contracts/package/src/lib.rs ---
pub mod accounts_whitelist;
pub mod pagination;

'''
'''--- contracts/package/src/pagination.rs ---
//! The package provides utils methods than can be used by contracts.

/// # Description
/// Calculates start and final element indexes
/// # Params
/// * **page** is a page number of type [`u64`]
/// * **limit** is a limit number per page of type [`u64`]
pub fn calculate_pagination_range(page: u64, limit: u64) -> (u64, u64) {
    let mut offset = 0;
    if page > 1 {
        offset = (page - 1) * limit;
    }

    (offset, offset + limit)
}

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn should_calculate() {
        let limit = 100;
        assert_eq!(calculate_pagination_range(0, limit), (0, limit));
        assert_eq!(calculate_pagination_range(1, limit), (0, limit));
        assert_eq!(calculate_pagination_range(2, limit), (100, 200));
    }
}

'''
'''--- contracts/router/Cargo.toml ---
[package]
name = "chat-space-router"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
chat-space-package = { path = "../package", default-features = false }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contracts/router/README.md ---
Router Smart Contract
==================

A [smart contract] is written in [Rust]. It implements accounts cache that's stored in blockchain. In context of chats contracts it'll store their account ids. Only owner can execute `call` contract methods.

This version of contract support add and delete chat methods. Preferably, next release should implement factory contract for chats using callbacks and cross-contract calls.

[Rust]: https://www.rust-lang.org/
[smart contract]: https://docs.near.org/docs/develop/contracts/overview

'''
'''--- contracts/router/src/account.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;

/// # Description
/// Pagination account ids
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Accounts {
    pub total: U64,
    pub accounts: Vec<AccountId>,
}

'''
'''--- contracts/router/src/contract.rs ---
//! This contract implements accounts cache that's stored in blockchain.
//!
//! The contract provides methods to [add_chat], [delete_chat], [get_chat_accounts].
//!
//! [add_chat]: struct.Router.html#method.add_chat
//! [delete_chat]: struct.Router.html#method.delete_chat
//! [get_chat_accounts]: struct.Router.html#method.get_chat_accounts

use chat_space_package::pagination::calculate_pagination_range;
use near_sdk::json_types::U64;
use near_sdk::{near_bindgen, AccountId};

use crate::account::Accounts;
use crate::Router;
use crate::*;

near_sdk::setup_alloc!();

#[near_bindgen]
impl Router {
    /// # Description
    /// Owner adds given chat account id if it hasn't already exist
    /// # Params
    /// * **account_id** is account of type [`ValidAccountId`] contains validated account id.
    pub fn add_chat(&mut self, account_id: ValidAccountId) {
        // check ownership
        self.assert_owner();
        for chat in self.chat_accounts.iter() {
            assert_ne!(
                chat.to_string(),
                account_id.to_string(),
                "Account id already exists"
            );
        }
        self.chat_accounts.push(&account_id.into());
    }

    /// # Description
    /// Owner deletes chat account by index.
    /// Be aware that last element will be stored at given index position after deleting.
    /// # Params
    /// * **account_id** is a chat account index of type [`U64`].
    pub fn delete_chat(&mut self, index: U64) -> AccountId {
        // check ownership
        self.assert_owner();

        if self.chat_accounts.len() > index.0 {
            return self.chat_accounts.swap_remove(index.0)
        }
        AccountId::new()
    }

    /// # Description
    /// Returns chat accounts batch with [`MAX_LIMIT`] maximum length
    /// # Params
    /// * **page** is a page number for pagination.
    pub fn get_chat_accounts(&self, page: u64, mut limit: u64) -> Accounts {
        let total = self.chat_accounts.len();

        if limit > MAX_LIMIT {
            limit = MAX_LIMIT
        }

        let (offset, mut last_account_index) = calculate_pagination_range(page, limit);
        if last_account_index > total {
            last_account_index = total;
        }

        let mut accounts: Vec<AccountId> = Vec::new();
        for index in offset..last_account_index {
            accounts.push(self.chat_accounts.get(index).unwrap())
        }

        Accounts {
            total: U64::from(total),
            accounts,
        }
    }
}

'''
'''--- contracts/router/src/lib.rs ---
pub mod account;
pub mod contract;
pub mod owner;
mod testing;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey};

/// # Pagination settings
/// The maximum amount of messages per page. Message amount that can be read at once
pub(crate) const MAX_LIMIT: u64 = 100;

/// This is an enum that contains storage keys.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    ChatAccounts,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Router {
    /// owner of this contract
    owner_id: AccountId,
    /// Chat contract account ids
    chat_accounts: Vector<AccountId>,
}

impl Default for Router {
    fn default() -> Self {
        env::panic(b"The contract should be initialized before usage")
    }
}

#[near_bindgen]
impl Router {
    /// # Description
    /// Creates the contract and inits whitelist
    /// # Params
    /// * **owner_id** is a string of type [`ValidAccountId`] contains valid account.
    #[init]
    pub fn new(owner_id: ValidAccountId) -> Router {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner_id: owner_id.into(),
            chat_accounts: Vector::new(StorageKeys::ChatAccounts),
        }
    }
}

'''
'''--- contracts/router/src/owner.rs ---
use crate::Router;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{env, AccountId};

impl Router {
    /// Set the owner of this contract
    /// # Params
    /// * **owner_id** is a string of type [`ValidAccountId`] contains valid account.
    pub fn set_owner(&mut self, owner_id: ValidAccountId) {
        self.assert_owner();
        self.owner_id = owner_id.into();
    }

    /// Get the owner of this contract
    pub fn get_owner(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Check a caller account id is the owner of this contract
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Can only be called by owner"
        );
    }
}

'''
'''--- contracts/router/src/testing.rs ---
#[cfg(test)]
mod tests {
    use near_sdk::{MockedBlockchain, testing_env, VMContext};
    use near_sdk::json_types::{U64, ValidAccountId};
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::test_utils::VMContextBuilder;

    use crate::{MAX_LIMIT, Router};

    // part of writing unit tests is setting up a mock context
    fn get_context(
        is_view: bool,
        signer: ValidAccountId,
        current_account_id: ValidAccountId,
        predecessor_account_id: ValidAccountId,
    ) -> VMContext {
        VMContextBuilder::new()
            .block_timestamp(100)
            .current_account_id(current_account_id)
            .predecessor_account_id(predecessor_account_id)
            .signer_account_id(signer)
            .is_view(is_view)
            .build()
    }

    #[test]
    fn should_add_and_delete_chat() {
        let owner = carol().clone();

        // set up the mock context into the testing environment
        let context = get_context(
            false,
            owner.clone().try_into().unwrap(),
            owner.clone().try_into().unwrap(),
            owner.clone().try_into().unwrap(),
        );
        testing_env!(context.clone());

        // init a contract
        let mut contract =
            Router::new(ValidAccountId::try_from(owner.clone().to_string()).unwrap());

        // adding account ids
        let number = 5;
        for i in 0..number {
            contract.add_chat(ValidAccountId::try_from(format!("{}.near", i)).unwrap());
        }
        let res = contract.get_chat_accounts(1, MAX_LIMIT);
        assert_eq!(res.total.0, number);
        assert_eq!(res.accounts.len(), number as usize);

        // deleting element that doesn't exist
        let element = contract.delete_chat(U64::from(number));
        assert_eq!(element, "");
        assert_eq!(res.total.0, number);

        // deleting element
        let index = 1;
        let element = contract.delete_chat(U64::from(index));
        assert_eq!(element, format!("{}.near", index));

        // length changed and last element filled into given index position
        let res = contract.get_chat_accounts(1, MAX_LIMIT);
        assert_eq!(res.total.0, number - 1);
        assert_eq!(res.accounts.len(), (number - 1) as usize);
        assert_eq!(
            res.accounts.get(index as usize).unwrap(),
            &format!("{}.near", number - 1)
        );
    }

    #[test]
    #[should_panic(expected = "Can only be called by owner")]
    fn should_panic_delete_chat() {
        let account = alice().clone();
        let owner = carol().clone();

        // set up the mock context into the testing environment
        let context = get_context(
            false,
            account.clone().try_into().unwrap(),
            owner.clone().try_into().unwrap(),
            account.clone().try_into().unwrap(),
        );
        testing_env!(context.clone());

        // init a contract
        let mut contract =
            Router::new(ValidAccountId::try_from(owner.clone().to_string()).unwrap());

        // try to delete account
        contract.delete_chat(U64::from(0));
    }

    #[test]
    #[should_panic(expected = "Can only be called by owner")]
    fn should_panic_add_chat() {
        let account = alice().clone();
        let owner = carol().clone();

        // set up the mock context into the testing environment
        let context = get_context(
            false,
            account.clone().try_into().unwrap(),
            owner.clone().try_into().unwrap(),
            account.clone().try_into().unwrap(),
        );
        testing_env!(context.clone());

        // init a contract
        let mut contract =
            Router::new(ValidAccountId::try_from(owner.clone().to_string()).unwrap());

        // try to add fake account
        contract.add_chat(ValidAccountId::try_from(bob()).unwrap());
    }

    #[test]
    fn should_get_pagination_accounts() {
        let owner = carol().clone();

        // set up the mock context into the testing environment
        let context = get_context(
            false,
            owner.clone().try_into().unwrap(),
            owner.clone().try_into().unwrap(),
            owner.clone().try_into().unwrap(),
        );
        testing_env!(context.clone());

        // init a contract
        let mut contract =
            Router::new(ValidAccountId::try_from(owner.clone().to_string()).unwrap());

        // empty router
        let res = contract.get_chat_accounts(0, MAX_LIMIT);
        assert_eq!(res.total.0, 0);
        assert_eq!(res.accounts.len(), 0);

        // add fake accounts
        let accounts_number = 2;
        for i in 1..accounts_number + 1 {
            contract.add_chat(ValidAccountId::try_from(format!("{}.near", i)).unwrap());
        }

        let res = contract.get_chat_accounts(0, MAX_LIMIT);
        assert_eq!(res.total.0, accounts_number);
        assert_eq!(res.accounts.len(), accounts_number as usize);

        let res = contract.get_chat_accounts(1, MAX_LIMIT);
        assert_eq!(res.accounts.len(), accounts_number as usize);

        let res = contract.get_chat_accounts(2, MAX_LIMIT);
        assert_eq!(res.accounts.len(), 0);

        // add fake accounts again
        let additional_accounts_number = accounts_number * 2;
        let total = additional_accounts_number + accounts_number;
        for i in accounts_number + 1..total + 1 {
            contract.add_chat(ValidAccountId::try_from(format!("{}.near", i)).unwrap());
        }

        let res = contract.get_chat_accounts(0, MAX_LIMIT);
        assert_eq!(res.total.0, accounts_number + additional_accounts_number);
        assert_eq!(res.accounts.len(), total as usize);

        let res = contract.get_chat_accounts(1, MAX_LIMIT);
        assert_eq!(res.accounts.len(), total as usize);

        let res = contract.get_chat_accounts(1, accounts_number);
        assert_eq!(res.accounts.len(), accounts_number as usize);
        let res = contract.get_chat_accounts(2, accounts_number);
        assert_eq!(res.accounts.len(), accounts_number as usize);
        let res = contract.get_chat_accounts(3, accounts_number);
        assert_eq!(res.accounts.len(), accounts_number as usize);
        let res = contract.get_chat_accounts(4, accounts_number);
        assert_eq!(res.accounts.len(), 0);
    }
}

'''
'''--- package.json ---
{
  "scripts": {
    "build": "node compile.js"
  },
  "devDependencies": {
    "shelljs": "^0.8.5"
  }
}

'''
'''--- src/.eslintrc.json ---
{
  "parser": "@typescript-eslint/parser",
  "env": {
    "browser": true,
    "es2022": true,
    "node": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:@typescript-eslint/recommended",
    "prettier"
  ],
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    },
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": ["react", "react-hooks", "@typescript-eslint", "prettier"],
  "rules": {
    "react/jsx-uses-react": "off",
    "react/react-in-jsx-scope": "off",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}

'''
'''--- src/.prettierrc.json ---
{
  "semi": false,
  "tabWidth": 2,
  "printWidth": 100,
  "jsxSingleQuote": true,
  "singleQuote": true,
  "trailingComma": "none",
  "arrowParens": "avoid",
  "bracketSpacing": true
}
'''
'''--- src/README.md ---
# Near Chat Application

Example chat front-end application. Uses NEAR [contract](../contract/) as a back-end.
So, it provides an ability for near account to send message to selected chat contact and getting messages for any user.

## Deployment

To start server locally:

```shell
yarn dev
```

To build app for production:
```shell
yarn build
```

## Possible NEAR platform improvements

1. No out-of-the box event notifications through WebSockets.
   With such a feature added this app could dynamically update UI with new messages.

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

'''
'''--- src/package.json ---
{
  "name": "near-chat-frontend",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@heroicons/react": "^1.0.6",
    "bootstrap": "^5.1.3",
    "buffer": "^6.0.3",
    "mobx": "^6.5.0",
    "mobx-react-lite": "^3.4.0",
    "near-api-js": "^0.44.2",
    "near-units": "^0.1.9",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "web-vitals": "^2.1.4"
  },
  "devDependencies": {
    "@types/node": "^17.0.35",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^5.25.0",
    "@vitejs/plugin-react": "^1.3.0",
    "autoprefixer": "^10.4.7",
    "eslint": "^8.16.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-prettier": "^4.0.0",
    "eslint-plugin-react": "^7.30.0",
    "eslint-plugin-react-hooks": "^4.5.0",
    "husky": "^8.0.1",
    "postcss": "^8.4.14",
    "prettier": "^2.6.2",
    "prettier-plugin-tailwindcss": "^0.1.11",
    "tailwindcss": "^3.0.24",
    "typescript": "^4.6.3",
    "vite": "^2.9.9"
  }
}

'''
'''--- src/postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
}

'''
'''--- src/src/baseTypes/user.ts ---
type User = {
  loggedIn: boolean
  accountId: string
  balance: string
}

type userContextType = {
  user: User
  setUser: React.Dispatch<React.SetStateAction<User>>
}

export type { User, userContextType }

'''
'''--- src/src/components/ChatArea/MessagesArea/Bubble/index.ts ---
export { default } from './Bubble'

'''
'''--- src/src/components/ChatArea/MessagesArea/index.ts ---
export {default} from './MessagesArea'
'''
'''--- src/src/components/ChatArea/SendArea/index.ts ---
export { default } from './SendArea'

'''
'''--- src/src/components/ChatArea/index.ts ---
export { default } from './ChatArea'

'''
'''--- src/src/components/NavBar/ChatsList/Item/index.ts ---
export {default} from './Item'
'''
'''--- src/src/components/NavBar/ChatsList/index.ts ---
export {default} from './ChatsList'
'''
'''--- src/src/components/NavBar/index.ts ---
export { default } from './NavBar'

'''
'''--- src/src/contexts/userContext.ts ---
import { createContext } from 'react'
import { User, userContextType } from '@baseTypes/user'

export const userContext = createContext({} as userContextType)

/**
 * function returns userState with default type values
 *
 ****
 * 
 ** {string} accountId - User's NEAR wallet (account) Id
 ** {number} balance - Wallet balance
 ** {boolean} loggedIn - User login status
 */
export const createInitialUserState = () =>
  ({
    accountId: '',
    balance: '',
    loggedIn: false
  } as User)

'''
'''--- src/src/index.css ---
@tailwind base;
@tailwind utilities;
@tailwind components;

@layer base {
  /* TODO: fullfill other styles */
  .light-scheme,
  .auto-scheme {
    --color-bg-base: #f1f5f9;
    --color-bg-bar: #14b8a6;
    --color-bg-chatArea: #2596be;
    --color-bg-bubble: #119c8c;

    --color-text-base: #1e293b;
    --color-text-invert: #f1f5f9;

    --color-border-base: #f1f5f9;
    --border-skin-invert: #1e293b;
  }

  .dark-scheme {
    --color-bg-base: #1e293b;
    --color-bg-bar: #14b8a6;
    --color-bg-chatArea: #ccfbf1;
    --color-bg-bubble: #119c8c;

    --color-text-base: #f1f5f9;
    --color-text-invert: #1e293b;

    --color-border-base: #1e293b;
  }

  @media (prefers-color-scheme: dark) {
    .auto-scheme {
      --color-bg-base: #1e293b;

      --color-text-base: #f1f5f9;
      --color-text-invert: #1e293b;

      --color-border-base: #1e293b;
    }
  }
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu',
    'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
}

'''
'''--- src/src/near/connect.ts ---
import {ConnectConfig, Contract, keyStores, Near, utils, WalletConnection} from 'near-api-js'
import Account from '@store/Account'
import {Buffer} from 'buffer'

const defaultRouterContract = 'dev-1653632038900-21214400306009'

window.Buffer = Buffer

type walletInfo = {
    accountId: any
    balance: string
}

export const near = new Near({
    headers: {},
    networkId: 'testnet',
    keyStore: new keyStores.BrowserLocalStorageKeyStore(),
    nodeUrl: 'https://rpc.testnet.near.org',
    walletUrl: 'https://wallet.testnet.near.org',
    helperUrl: 'https://helper.testnet.near.org',
    explorerUrl: 'https://explorer.testnet.near.org'
} as ConnectConfig)

export const wallet = new WalletConnection(near, 'nixchat-wow')

export const connectWallet = async () => {
    return await wallet.requestSignIn()
}

export const getWalletBalance = async () => {
    const balance = (await wallet.account().state()).amount
    return utils.format.formatNearAmount(balance) as string
}

export const formatBalanceToHuman = (balance: string) => {
    const numberBalance = Number(balance)

    return numberBalance.toFixed(3)
}

const chatMethodOptions = {
    viewMethods: ['get_messages', 'is_whitelisted_account'],
    changeMethods: ['send_message']
}

const routerMethodOptions = {
    viewMethods: ['get_chat_accounts'],
    changeMethods: []
}

// prettier-ignore
export const routerContract = new Contract(
    wallet.account(),
    defaultRouterContract,
    routerMethodOptions
)

const params = {
    page: 1,
    limit: 10
}

export const isWhitelistedAccount = async (chatContract: string) : Promise<boolean> => {
    if (wallet.getAccountId() !== '') {
        const res: boolean = await (new Contract(
            wallet.account(),
            chatContract || Account.State,
            chatMethodOptions
        ) as any).is_whitelisted_account({account_id: wallet.getAccountId()})
        return res
    }
    return false
}

export const getMessages = async (chatContract: string) => {
    // "as eny" assertion to ignore typescript error "Property does not exist on type"
    const messages: fetchedMessages = await (new Contract(
        wallet.account(),
        chatContract,
        chatMethodOptions
    ) as any).get_messages(params)
    return messages
}

export const sendMessage = async (chatContract: string, text: string) => {
    // "as eny" assertion to ignore typescript error "Property does not exist on type"
    await (new Contract(
        wallet.account(),
        chatContract,
        chatMethodOptions
    ) as any).send_message({
        text_message: text
    })
}

export const getChatAccounts = async () => {
    // "as eny" assertion to ignore typescript error "Property does not exist on type"
    const accounts: fetchedAccounts = await (routerContract as any).get_chat_accounts(params)
    return accounts
}

export type Message = {
    text: string
    sender: string
    created_at: number
}

export type fetchedMessages = {
    messages: Message[]
    total: string
}

export type fetchedAccounts = {
    accounts: string[]
    total: string
}

export const getInitialMessages = (): fetchedMessages => {
    return {
        total: '0',
        messages: []
    }
}

export const getInitialAccounts = (): fetchedAccounts => {
    return {
        total: '0',
        accounts: []
        // accounts: [defaultChatContract, 'dev-1653565385351-13217791340282']
    }
}

'''
'''--- src/src/store/Account.ts ---
import { makeAutoObservable } from 'mobx'

class Account {
  State = ''

  constructor() {
    makeAutoObservable(this)
  }

  setAccountId(account: string) {
    this.State = account
  }
}

export default new Account()

'''
'''--- src/src/vite-env.d.ts ---
/// <reference types="vite/client" />

'''
'''--- src/tailwind.config.js ---
module.exports = {
  content: ['./src/**/*.{ts,tsx}'],
  theme: {
    extend: {
      backgroundColor: {
        skin: {
          base: 'var(--color-bg-base)',
          bar: 'var(--color-bg-bar)',
          input: 'var(--color-bg-input)',
          chatArea: 'var(--color-bg-chatArea)',
          bubble: 'var(--color-bg-bubble)'
        }
      },
      textColor: {
        skin: {
          base: 'var(--color-text-base)',
          invert: 'var(--color-text-invert)'
        }
      },
      borderColor: {
        skin: {
          base: 'var(--color-border-base)',
          invert: 'var(--color-border-invert)'
        }
      }
    }
  },
  plugins: [
    ({ addVariant }) => {
      addVariant('children', '& > *')
    }
  ]
}

'''
'''--- src/tsconfig.json ---
{
  "compilerOptions": {
    "target": "esNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "paths": {
      "@components/*": ["./src/components/*"],
      "@baseTypes/*": ["./src/baseTypes/*"],
      "@near/*": ["./src/near/*"],
      "@contexts/*": ["./src/contexts/*"],
      "@store/*": ["./src/store/*"],
      "@/*": ["./src/*"]
    }
  },
  "include": ["src", "tailwind.config.js"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

'''
'''--- src/tsconfig.node.json ---
{
  "compilerOptions": {
    "composite": true,
    "module": "esnext",
    "moduleResolution": "node"
  },
  "include": ["vite.config.ts"]
}

'''
'''--- src/vite.config.ts ---
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import * as path from 'path'

const rootDir = path.resolve(__dirname)

// https://vitejs.dev/config/
export default defineConfig({
  define: {
    global: 'window',
    'process.env': {}
  },
  plugins: [react()],
  resolve: {
    alias: [
      {
        find: '@',
        replacement: path.resolve(rootDir, 'src/')
      },
      {
        find: '@components',
        replacement: path.resolve(rootDir, 'src/components')
      },
      {
        find: '@baseTypes',
        replacement: path.resolve(rootDir, 'src/baseTypes')
      },
      {
        find: '@near',
        replacement: path.resolve(rootDir, 'src/near')
      },
      {
        find: '@contexts',
        replacement: path.resolve(rootDir, 'src/contexts')
      },
      {
        find: '@store',
        replacement: path.resolve(rootDir, 'src/store')
      }
    ]
  }
})

'''