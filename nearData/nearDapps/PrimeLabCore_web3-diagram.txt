*GitHub Repository "PrimeLabCore/web3-diagram"*

'''--- Cargo.toml ---
[workspace]

members = [
    "example",
    "scanner-syn",
    "mermaid-markdown-api",
    "cargo-diagram"
]

'''
'''--- README.md ---
# Web3 Diagram

## **This is a cargo utility that allows developers to generate visualizations depicting data flows within their NEAR Rust smart contracts.**

<br>

### Which problem does it solve?
**Provides the ability to generate representations of methods to allow for anyone to quickly understand how the contract works.**

<br>

### Who can use this?
**Smart contract developers use it to generate the images, but the images can help anyone trying to understand whatâ€™s going on.**

<br>

## Key Features

| Feature | Description |
| ----------- | ----------- |
| View Functions | Near smart contract view only functions |
| Mutation | Near smart contract mutable functions |
| Process | Helper or utility functions, also functions out of smart contract scope |
| Events | Functions that falls into near event [standard]([https://link](https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/event.rs)) |
| View Trait Impl | View only functions but trait implamentation |
| Mutation Trait Impl | Mutable functions but trait implamentation |
| Payable | Functions that except Near |
| Initializers | Smart contract initializer functions |

<br>

# Installation
## Install Rust
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
<br>

## Install cli with [brew](https://brew.sh/)

```bash
brew install mermaid-cli
```

<br>

## Install web3d diagram utility

```bash
cargo install web3d 
```

<br>
   

## Install [node](https://gist.github.com/tomysmile/da3cb8194ec8f0e4df86#install-node)

```bash
brew install node
```

<br>

## Web3 Utility Usage

### 1) Clone raffle smart contract from near examples

```bash
git clone git@github.com:near-examples/rust-ft-raffle.git
```

<br>

### 2) Go to the root directory
```bash
cd rust-ft-raffle
```

### 3) Run utility againt cloned smart contract and open in web browser
```bash
web3d -O --input raffle.md
```

<br>

## Options

| Key/Command | Description |
| ----------- | ----------- |
| -b, --backgroundColor | Background color. Example: transparent, red, '#F0F0F0'. Optional. Default: white |
| -h, --help | Print help information |
| -H, --height | Height of the page. Optional. Default: 600 |
| -i, --input  | Markdown file name |
| -o, --output | Output file name. It should be either md, svg, png or pdf. Optional. Default:'./res/input_file_name.svg' |
| -O, --openb | Should open output file in browser |
| -q, --quiet | Suppress log output |
| -w, --width | Width of the page. Optional. Default: 800 |
'''
'''--- cargo-diagram/Cargo.toml ---
[package]
name = "web3d"
version = "0.1.0"
edition = "2021"
authors = ["PrimeLab <support@primelab.io>"]
repository = "https://github.com/NearPrime/web3-diagram/"
license = "MIT OR Apache-2.0"
homepage = "https://primelab.io/"
description = """
Creating diagrams for near smart contracts
"""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
clap = { version = "3.1.6", features = ["derive"] }
subprocess = "0.2.8"
minidom = "0.14.0"

usvg = "0.22.0"
resvg = "0.22.0"
svg2pdf = "0.3.0"
tiny-skia = "0.6.3"
scanner-syn = { path = "../scanner-syn", version = "0.1.0" }
mermaid-markdown-api={path = "../mermaid-markdown-api", version = "0.1.0"}

'''
'''--- cargo-diagram/src/main.rs ---
//! The command line tool which creates diagrams from markdown files.
//! Based on [mermaid-cli](https://github.com/mermaid-js/mermaid-cli).
//!
//! In order to create a diagram one must provide the full path to the input file.
//! Optional parameters are output, format, scale, height, width, background color, quiet.
//!
//! For more detailed info run with `--help` or `-h` flag.
pub mod svg;
use minidom;
use svg::{load_from_data, load_from_path};
//use scanner_syn;
use minidom::Element;
use std::io::{Error, ErrorKind, self};
use std::path::{Path, PathBuf};
use usvg::{Node, NodeExt};

use clap::Parser;
use subprocess::{Popen, PopenConfig, Redirection};
// use scanner_syn::contract_descriptor::{ContractDescriptor, DefaultContractDescriptor};

use mermaid_markdown_api::scanner_pipeline::ScannerPipeline;
use mermaid_markdown_api::syntax::FlowDirection;
use scanner_syn::contract_descriptor::{ContractDescriptor, DefaultContractDescriptor};
use std::env;
use std::fs::{self, File};

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Cli {
    /// Path to the markdown file with the input data
    #[clap(short, long = "input", parse(from_os_str), value_name = "FILE")]
    input_file: PathBuf,
    /// Output file. It should be either md, svg, png or pdf. Optional. Default: \"./res/name_of_the_input_file.svg\
    #[clap(short, long, parse(from_os_str), value_name = "FILE")]
    output_file: Option<PathBuf>,
    /// Scale factor. Optional. Default: 1
    #[clap(short, long, value_name = "SCALE")]
    scale: Option<String>,
    /// Height of the page. Optional. Default: 600
    #[clap(short, long, value_name = "HEIGHT")]
    height: Option<String>,
    /// Width of the page. Optional. Default: 800
    #[clap(short, long, value_name = "WIDTH")]
    width: Option<String>,
    /// Background color. Example: transparent, red, '#F0F0F0'. Optional. Default: white
    #[clap(short, long, value_name = "COLOR")]
    background_color: Option<String>,
    /// Should open output file in browser
    #[clap(short = 'O', long)]
    openb: bool,
    /// Suppress log output
    #[clap(short, long)]
    quiet: bool,
}

impl Cli {
    /// Method to pass arguments to the mermaid-cli
    ///
    /// Returns created file path
    fn pass_to_mmdc(&self) -> Result<PathBuf, subprocess::PopenError> {
        let input_file_path: PathBuf = create_markdown_file(self.input_file.clone()).unwrap();

        let mut command = vec!["mmdc", "-i", input_file_path.to_str().unwrap()];

        let output_path = if let Some(output_file) = &self.output_file {
            output_file.clone()
        } else {
            let mut output_path = input_file_path.clone();
            output_path.set_extension("svg");
            output_path
        };
        // Set the output file
        command.push("-o");
        command.push(output_path.to_str().unwrap());

        // Check if the scale is provided
        if let Some(scale) = &self.scale {
            if !self.quiet {
                println!("Set the scale: {}", scale);
            };
            command.push("-s");
            command.push(scale);
        };
        // Check if the height is provided
        if let Some(height) = &self.height {
            if !self.quiet {
                println!("Set the height: {}", height);
            };
            command.push("-h");
            command.push(height);
        };
        // Check if the width is provided
        if let Some(width) = &self.width {
            if !self.quiet {
                println!("Set the width: {}", width);
            };
            command.push("-w");
            command.push(width);
        };
        // Check if the background color is provided
        if let Some(background_color) = &self.background_color {
            if !self.quiet {
                println!("Set the background color: {}", background_color);
            };
            command.push("-b");
            command.push(background_color);
        };
        if self.quiet {
            command.push("-q");
        }

        // Call mermaid-cli with the constracted command, create svg file
        let mut mmdc = Popen::create(
            &command,
            PopenConfig {
                stdout: Redirection::Pipe,
                ..PopenConfig::default()
            },
        )?;
        println!("Adding logo");

        let _ = mmdc.wait();
        // self.add_logo(output_path.clone());
        Ok(output_path)
    }
    fn add_logo(&self, output_path: PathBuf) {
        let tree = load_from_path(output_path.as_path()).unwrap();
        let logo_data = include_bytes!("logo.svg");

        let logo_tree = load_from_data(logo_data).unwrap();

        let mut tree_root = tree.root();
        let logo_root = logo_tree.root();

        tree_root.prepend(logo_root);

        // println!("{:?}", tree_root.into());
        // File::create(&output_path)
        //     .unwrap()

        //     .write_all(tree.root().())
        //     .unwrap();
    }
}

fn main() -> Result<(), subprocess::PopenError> {
    let args = Cli::parse();
    let output_path = args.pass_to_mmdc()?;

    // println!(
    //     "{}",
    //     args.input_file.into_os_string().into_string().unwrap()
    // );

    if args.openb {
        open_output_file_in_browser(output_path);
    }
    Ok(())
}

/// Function opens output file in web browser
///
/// # Arguments
///
/// * `output_path` - Output file path to open in browser
fn open_output_file_in_browser(output_path: PathBuf) {
    println!("opening {:?}", output_path.to_str().unwrap());
    let command = vec!["open", "-a", "Google Chrome", output_path.to_str().unwrap()];

    let mut executor = Popen::create(
        &command,
        PopenConfig {
            stdout: Redirection::Pipe,
            ..PopenConfig::default()
        },
    )
    .unwrap();

    let _ = executor
        .wait()
        .expect("Could not open file in google chrome, try open it manualiy");
}

/// Function creates markdown file with specified file name
///
/// # Arguments
///
/// * `file_name` - Markdown file name
fn create_markdown_file(file_name: PathBuf) -> Result<PathBuf, std::io::Error> {
    let mut current_dir = env::current_dir().expect("Can not resolve current directory");
   
    if current_dir.ends_with("res") || current_dir.ends_with("src"){
        current_dir.pop();
    }
    if !does_folder_exist_in_directory("src",current_dir.clone()).unwrap(){
        panic!("You are not in crate dir");
    }

    let desc = DefaultContractDescriptor::new();
    let contract_info = desc.get_contract_info_for_crate(current_dir.clone().to_str());
    let markdown = ScannerPipeline::from(contract_info, FlowDirection::TD);
    //println!("{:?}", markdown.content);

    if !current_dir.ends_with("res") {
        current_dir.push("res/");
    }
    std::fs::create_dir_all(current_dir.clone())?;
    current_dir.push(file_name);
    fs::write(current_dir.clone(), markdown.content).expect("Unable to write file");
    Ok(current_dir.clone())
}
fn does_folder_exist_in_directory(folder:&str,directory_path:PathBuf) -> io::Result<bool> {
    let mut dir=directory_path.clone();
    dir.push(folder);
    let metadata = fs::metadata(dir).expect("You are not in crate directory!");
    Ok(metadata.is_dir())
}
'''
'''--- cargo-diagram/src/svg.rs ---
fn with_svg_options<T>(callback: impl FnOnce(usvg::OptionsRef<'_>) -> T) -> T {
    let mut options = usvg::Options::default();
    options.fontdb.load_system_fonts();
    let options_ref = options.to_ref();

    callback(options_ref)
}

#[cfg(not(target_arch = "wasm32"))]
pub fn load_from_path(path: &std::path::Path) -> Result<usvg::Tree, std::io::Error> {
    let svg_data = std::fs::read(path)?;

    with_svg_options(|options| {
        usvg::Tree::from_data(&svg_data, &options)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))
    })
}

pub fn load_from_data(slice: &[u8]) -> Result<usvg::Tree, usvg::Error> {
    with_svg_options(|options| usvg::Tree::from_data(slice, &options))
}

'''
'''--- do-build.sh ---
cargo build --workspace --release
'''
'''--- do-docs.sh ---
cargo doc --workspace 
'''
'''--- do-run.sh ---
set -e
cargo build --workspace --release 
cd ./example
../target/release/web3d -O --input diagram.md
'''
'''--- example/Cargo.toml ---
[package]
name = "example"
version = "0.1.0"
edition = "2018"

# [lib]
# crate-type = ["cdylib"]
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0-pre.7"
scanner-syn = {path = "../scanner-syn"}
mermaid-markdown-api={path = "../mermaid-markdown-api"}
serde = "1"
serde_json = "1"
'''
'''--- example/example.sh ---
set -e
cd ../
cargo build --release
cd ./example
../target/release/cargo-diagram -O --input diagram.md
'''
'''--- example/src/events.rs ---
use std::fmt::Display;

use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "standard")]
#[serde(rename_all = "snake_case")]
pub enum NearEvent {
    Nep171(Nep171Event),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Nep171Event {
    pub version: String,
    #[serde(flatten)]
    pub event_kind: Nep171EventKind,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
pub enum Nep171EventKind {
    NftMint(Vec<NftMintData>),
    NftTransfer(Vec<NftTransferData>),
    NftBurn(Vec<NftBurnData>),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NftMintData {
    pub owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NftTransferData {
    pub authorized_id: Option<String>,
    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NftBurnData {
    pub authorized_id: Option<String>,
    pub owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

impl Display for NearEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&format!("EVENT_JSON:{}", self.to_json_string()))
    }
}

impl NearEvent {
    pub fn new_171(version: String, event_kind: Nep171EventKind) -> Self {
        NearEvent::Nep171(Nep171Event {
            version,
            event_kind,
        })
    }

    pub fn new_171_v1(event_kind: Nep171EventKind) -> Self {
        NearEvent::new_171("1.0.0".to_string(), event_kind)
    }

    pub fn nft_burn(data: Vec<NftBurnData>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftBurn(data))
    }
    pub fn nft_transfer(data: Vec<NftTransferData>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftTransfer(data))
    }

    pub fn nft_mint(data: Vec<NftMintData>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftMint(data))
    }

    pub(crate) fn to_json_string(&self) -> String {
        serde_json::to_string(self).unwrap()
    }

    pub fn log(&self) {
        near_sdk::env::log_str(&self.to_string());
    }

    pub fn log_nft_mint(owner_id: String, token_ids: Vec<String>, memo: Option<String>) {
        NearEvent::log_nft_mints(vec![NftMintData {
            owner_id,
            token_ids,
            memo,
        }]);
    }

    pub fn log_nft_mints(data: Vec<NftMintData>) {
        NearEvent::nft_mint(data).log();
    }

    pub fn log_nft_transfer(
        old_owner_id: String,
        new_owner_id: String,
        token_ids: Vec<String>,
        memo: Option<String>,
        authorized_id: Option<String>,
    ) {
        NearEvent::log_nft_transfers(vec![NftTransferData {
            authorized_id,
            old_owner_id,
            new_owner_id,
            token_ids,
            memo,
        }]);
    }

    pub fn log_nft_transfers(data: Vec<NftTransferData>) {
        NearEvent::nft_transfer(data).log();
    }

    pub fn log_nft_burn(
        owner_id: String,
        token_ids: Vec<String>,
        memo: Option<String>,
        authorized_id: Option<String>,
    ) {
        NearEvent::log_nft_burns(vec![NftBurnData {
            owner_id,
            authorized_id,
            token_ids,
            memo,
        }]);
    }

    pub fn log_nft_burns(data: Vec<NftBurnData>) {
        NearEvent::nft_burn(data).log();
    }
}

'''
'''--- example/src/lib.rs ---
pub use near_sdk::borsh;
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
pub use near_sdk::near_bindgen;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pub count: u64,
}

#[near_bindgen]
impl Contract {
    // TODO: init method is broken
    #[init]
    pub fn new(count: u64) -> Self {
        Self { count }
    }

    pub fn add(&mut self, amount: u64) {
        if amount == 2 {
            self.count = SomeStruct::add_two(self.count);
        }
        self.add_amount(amount);
    }

    pub fn show_amount(self) -> u64 {
        self.display();
        self.count
    }
    fn display(&self){

    }

    #[payable]
    pub fn pay(&mut self, amount: u64) {
        self.count += amount;
    }

    fn add_amount(&mut self, amount: u64) {
        self.count += amount;
    }
}

#[near_bindgen]
pub struct SomeStruct {}
#[near_bindgen]
impl SomeStruct {
    pub fn add_two(count: u64) -> u64 {
        count + 2
    }
}

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
       
    }
'''
'''--- example/src/main.rs ---
mod events;
mod lib;
mod some_fancy_impl;
use mermaid_markdown_api::scanner_pipeline::ScannerPipeline;
use mermaid_markdown_api::syntax::FlowDirection;
use scanner_syn::contract_descriptor::{ContractDescriptor, DefaultContractDescriptor};
fn main() {
  

    let desc = DefaultContractDescriptor::new();
    let contract_info = desc.get_contract_info_for_crate(Some("."));
    let markdown = ScannerPipeline::from(contract_info, FlowDirection::TD);
    println!("{:?}", markdown.content);
}

'''
'''--- example/src/some_fancy_impl.rs ---
mod helpers;
mod trait_impl;

'''
'''--- example/src/some_fancy_impl/helpers.rs ---
use crate::lib::*;

#[near_bindgen]
impl Contract {
    pub fn multiply(&mut self, num: u64) {
        self.count *= num;
    }
}

struct ExampleStruct;
impl ExampleStruct {
    pub fn foo(bar: Vec<u8>) -> usize {
        bar.len()
    }
}

pub fn bar() {
    todo!();
}

'''
'''--- example/src/some_fancy_impl/trait_impl.rs ---
use crate::lib::*;

pub trait SomeTrait {
    fn view_trait_fn(&self) -> u64;
    fn call_trait_fn(&mut self);
}

#[near_bindgen]
impl SomeTrait for Contract {
    fn view_trait_fn(&self) -> u64 {
        self.count * 10
    }

    fn call_trait_fn(&mut self) {
        self.count += 1;
    }
}

'''
'''--- mermaid-markdown-api/Cargo.toml ---
[package]
name = "mermaid-markdown-api"
version = "0.1.0"
edition = "2021"
authors = ["Nicholas Vincent <support@primelab.io>"]
description = "Generating markdown for mermaid diagrams"
homepage = "https://primelab.io/"
license = "MIT OR Apache-2.0"
repository = "https://github.com/NearPrime/web3-diagram"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
strum = "0.24"
strum_macros = "0.24"
enum-as-inner = "0.4.0"
scanner-syn = {path = "../scanner-syn", version = "0.1.0"}
'''
'''--- mermaid-markdown-api/src/lib.rs ---
pub mod md_api;
pub mod objects;
pub mod scanner_pipeline;
pub mod syntax;
extern crate strum;
#[macro_use]
extern crate strum_macros;

'''
'''--- mermaid-markdown-api/src/md_api.rs ---
use crate::objects::node::Node;
use crate::syntax::{CoreSyntaxFunctions, FlowDirection};

pub struct MdAPI<T: CoreSyntaxFunctions> {
    schema: T,
    hierarchy_root: Node,
}

impl<T: CoreSyntaxFunctions> MdAPI<T> {
    pub fn new(
        flow_direction: FlowDirection,
        hierarchy_root: Node,
    ) -> Self {
        MdAPI {
            schema: T::new(flow_direction),
            hierarchy_root,
        }
    }

    pub fn parse_hierarchy(&mut self) -> String {
        self.hierarchy_root.traverse(&mut self.schema);

        self.schema.return_schema()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::objects::connection::{Connection, ConnectionType};
    use crate::objects::node::{ActionType, ScopeType};
    use crate::syntax::flow_chart::FlowChart;

    #[test]
    fn it_works() {
        let hierarchy_tree_root = Node {
            name: "function_a".to_string(),
            scope: ScopeType::Public,
            action: ActionType::Mutation,
            connections: vec![
                Connection {
                    connection_type: ConnectionType::Emission,
                    node: Node {
                        name: "function_a_event".to_string(),
                        scope: ScopeType::Public,
                        action: ActionType::Event,
                        connections: vec![],
                    },
                },
                Connection {
                    connection_type: ConnectionType::DirectConnection,
                    node: Node {
                        name: "function_b_private".to_string(),
                        scope: ScopeType::Private,
                        action: ActionType::Mutation,
                        connections: vec![],
                    },
                },
            ],
        };

        let mut api = MdAPI::<FlowChart>::new(FlowDirection::TD, hierarchy_tree_root);

        let result = api.parse_hierarchy();

        let expected_string = r#"flowchart TD
	function_a{{function_a}}:::Public --> function_a_event>function_a_event]:::Public
	function_a{{function_a}}:::Public --> function_b_private{{function_b_private}}:::Private"#;

        assert_eq!(result, expected_string);
    }
}

'''
'''--- mermaid-markdown-api/src/objects/connection.rs ---
use crate::objects::node::Node;
use crate::objects::DiagramObject;
use crate::syntax::CoreSyntaxFunctions;

pub enum ConnectionType {
    DirectConnection,
    CrossContractConnection,
    Emission,
}

pub struct Connection {
    pub connection_type: ConnectionType,
    pub node: Node,
}

impl<T: CoreSyntaxFunctions> DiagramObject<T> for Connection {
    fn add_object_to_schema(
        &self,
        schema: &mut T,
        _id: Option<&str>,
        extra_length_num: Option<u8>,
    ) {
        let config = schema.build_connection_config(self, extra_length_num);
        schema.add_connection(config);
    }
}

// TODO: Extra length
// TODO: Separate via generic vs param

'''
'''--- mermaid-markdown-api/src/objects/mod.rs ---
use crate::syntax::CoreSyntaxFunctions;

pub mod connection;
pub mod node;

pub trait DiagramObject<T: CoreSyntaxFunctions> {
    fn add_object_to_schema(
        &self,
        schema: &mut T,
        id: Option<&str>,
        extra_length_num: Option<u8>,
    );
}

// TODO: Maybe make a switch on a passed argument enum repesenting the syntax to generate the config file
// TODO: String to ENUM and what that allows for configuration objects

'''
'''--- mermaid-markdown-api/src/objects/node.rs ---
use crate::objects::connection::Connection;
use crate::objects::DiagramObject;
use crate::syntax::CoreSyntaxFunctions;
use std::collections::VecDeque;
use strum_macros::AsRefStr;

#[derive(AsRefStr, Debug)]
pub enum ScopeType {
    Private,
    Public,
    Trait,
    Payable,
    Contract,
    Initializer,
}

#[derive(AsRefStr, Debug)]
pub enum ActionType {
    None,
    Mutation,
    View,
    Process,
    Event,
}

pub struct Node {
    pub name: String,
    pub scope: ScopeType,
    pub action: ActionType,
    pub connections: Vec<Connection>,
}

impl<T: CoreSyntaxFunctions> DiagramObject<T> for Node {
    fn add_object_to_schema(
        &self,
        schema: &mut T,
        id: Option<&str>,
        _extra_length_num: Option<u8>,
    ) {
        let config = schema.build_node_config(self, id);
        schema.add_node(config);
    }
}

impl Node {
    fn parse_node(
        &self,
        schema: &mut impl CoreSyntaxFunctions,
    ) {
        for connection in &self.connections {
            self.add_object_to_schema(schema, None, None);
            connection.add_object_to_schema(schema, None, None);
            connection.node.add_object_to_schema(schema, None, None);
            schema.add_linebreak(None);
        }
    }
    pub fn traverse(
        &self,
        schema: &mut impl CoreSyntaxFunctions,
    ) {
        let mut queue = VecDeque::new();
        queue.push_back(self);

        while let Some(node) = queue.pop_front() {
            node.parse_node(schema);
            for connection in &node.connections {
                queue.push_back(&connection.node);
            }
        }
    }
}

'''
'''--- mermaid-markdown-api/src/scanner_pipeline.rs ---
use crate::{
    md_api::MdAPI,
    objects::{
        connection::{self, Connection, ConnectionType},
        node::{ActionType, Node, ScopeType},
    },
    syntax::{flow_chart::FlowChart, FlowDirection},
};
use scanner_syn::contract_descriptor::{
    ContractDescriptor, ContractInfo, DefaultContractDescriptor, FunctionInfo,
};
use std::{
    ops::{Deref, DerefMut},
    vec::Vec,
};
struct Connections(Vec<Connection>);
impl Deref for Connections {
    type Target = Vec<Connection>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Connections {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Into<ScopeType> for FunctionInfo {
    fn into(self) -> ScopeType {
        if self.is_public && !self.is_init && !self.is_payable {
            return ScopeType::Public
        }
        if !self.is_public {
            return ScopeType::Private
        }
        if self.is_trait_impl {
            return ScopeType::Trait
        }
        if self.is_init {
            return ScopeType::Initializer
        }
        if self.is_payable {
            return ScopeType::Payable
        } else {
            ScopeType::Public
        }
    }
}
impl Into<ActionType> for FunctionInfo {
    fn into(self) -> ActionType {
        if self.is_event {
            ActionType::Event
        } else if self.is_mutable {
            ActionType::Mutation
        } else if self.is_process {
            ActionType::Process
        } else if self.is_view {
            ActionType::View
        } else {
            ActionType::None
        }
    }
}
impl Into<ConnectionType> for FunctionInfo {
    fn into(self) -> ConnectionType {
        if self.is_event {
            ConnectionType::Emission
        } else if self.is_trait_impl {
            ConnectionType::CrossContractConnection
        } else {
            ConnectionType::DirectConnection
        }
    }
}

impl From<Option<Vec<FunctionInfo>>> for Connections {
    fn from(val: Option<Vec<FunctionInfo>>) -> Self {
        if val.is_some() {
            let finfo = val.unwrap();
            if !finfo.is_empty() {
                let inner = finfo
                    .into_iter()
                    .map(|ifn| -> Connection {
                        Connection {
                            connection_type: ifn.clone().into(),
                            node: Node {
                                name: ifn.name.clone(),
                                scope: ifn.clone().into(),
                                action: ifn.clone().into(),
                                connections: Connections::from(ifn.clone().inner_calls).0,
                            },
                        }
                    })
                    .collect();
                return Connections(inner);
            }
        }
        Connections(Vec::new())
    }
}

pub struct ScannerPipeline {
    pub content: String,
}
impl ScannerPipeline {
    pub fn from(contract: ContractInfo, flow_direction: FlowDirection) -> ScannerPipeline {
        let mut hierarchy_tree_root = Node {
            name: "Contract".to_string(),
            scope: ScopeType::Contract,
            action: ActionType::None,
            connections: Vec::new(),
        };
        contract
            .contract_metadata
            .into_iter()
            .enumerate()
            .for_each(|(_, value)| {
                hierarchy_tree_root
                    .connections
                    .extend(Connections::from(Some(value.fns)).0);
            });

        let mut api = MdAPI::<FlowChart>::new(flow_direction, hierarchy_tree_root);
        let mut result = api.parse_hierarchy();

        result.push_str("\n\tclassDef Public-Mutation fill:#12A5F1,stroke:#333,stroke-width:2px;");
        result.push_str("\n\tclassDef Public-View fill:#12A5F1,stroke:#333,stroke-width:2px;");
        result.push_str("\n\tclassDef Private-View fill:#858585,stroke:#333,stroke-width:2px;");

        result.push_str("\n\tclassDef Private-Mutation fill:#858585,stroke:#333,stroke-width:1px;");
        result.push_str("\n\tclassDef Public-Event fill:#FFDF80,stroke:#333,stroke-width:2px,stroke-dasharray: 4 4;");
        result.push_str("\n\tclassDef Private-Event fill:#FFDF80,stroke:#333,stroke-width:1px,stroke-dasharray: 4 4;");
        result.push_str("\n\tclassDef Private-None fill:#858585,stroke:#333,stroke-width:1px;");
        result.push_str("\n\tclassDef Private-Process fill:#858585,stroke:#333,stroke-width:1px;");
        result.push_str("\n\tclassDef Public-Process fill:#858585,stroke:#333,stroke-width:2px;");
        result.push_str("\n\tclassDef Public-None fill:#858585,stroke:#333,stroke-width:2px;");
        result.push_str("\n\tclassDef Initializer-None fill:#FFA080,stroke:#333,stroke-width:2px;");
        result.push_str("\n\tclassDef Payable-None fill:#6AA84F,stroke:#333,stroke-width:2px;");
        result.push_str("\n\tclassDef Payable-Mutation fill:#6AA84F,stroke:#333,stroke-width:2px;");
        result.push_str("\n\tclassDef Contract-None fill:#C2D5E3,stroke:#333,stroke-width:2px;");

        ScannerPipeline { content: result }
    }
}

'''
'''--- mermaid-markdown-api/src/syntax/flow_chart.rs ---
use crate::objects::connection::{Connection, ConnectionType};
use crate::objects::node::{ActionType, Node};
use crate::syntax::{CoreSyntaxFunctions, FlowDirection, SyntaxConfigFile};
use enum_as_inner::EnumAsInner;
use strum::EnumProperty;
use strum_macros::EnumProperty;

/// The various different shapes enabled by this syntax.
#[derive(EnumProperty, Debug)]
pub enum Shape {
    #[strum(props(Left = "((", Right = "))"))]
    Circle,
    #[strum(props(Left = "{{", Right = "}}"))]
    Hexagon,
    #[strum(props(Left = "[", Right = "]"))]
    Rectangle,
    #[strum(props(Left = ">", Right = "]"))]
    Flag,
}

/// The various different line types enabled by this syntax.
#[derive(EnumProperty, Debug)]
pub enum LineType {
    #[strum(props(Complete = "--", Addition = "-"))]
    Solid,
    #[strum(props(Left = "-.", Right = ".-", Addition = "."))]
    Dashed,
}

/// The various different arrow types enabled by this syntax.
#[derive(AsRefStr, EnumProperty, Debug, Clone, Copy)]
pub enum ArrowType {
    #[strum(props(Left = "<", Right = ">"))]
    Standard,
    #[strum(props(Left = "x", Right = "x"))]
    X,
    #[strum(props(Left = "o", Right = "o"))]
    O,
}

/// The various different arrow directions enabled by this syntax.
#[derive(AsRefStr, Debug)]
pub enum ArrowDirection {
    BiDirectional,
    Left,
    Right,
    None,
}

/// An enum representation of either a [NodeConfig] or a [ConnectionConfig].
#[derive(EnumProperty, EnumAsInner, Debug)]
pub enum ObjectConfig<'a> {
    NodeConfig(NodeConfig<'a>),
    ConnectionConfig(ConnectionConfig),
}

/// A struct representing the possible attributes for a [Node].
#[derive(Debug)]
pub struct NodeConfig<'a> {
    /// The ID that will be assigned to this node
    pub id: &'a str,
    /// An optional class name to assign to the node
    pub class: Option<String>,
    /// The shape of the node
    pub shape: Shape,
    /// The text to be displayed within the node
    pub inner_text: &'a str,
}

/// A struct representing the possible attributes for a [Connection].
#[derive(Debug)]
pub struct ConnectionConfig {
    /// The enum representation of the type of line you want
    pub line_type: LineType,
    /// The enum representation of the type of arrow you want
    pub arrow_type: ArrowType,
    /// The enum representation of the direction you want the arrows to point
    pub arrow_direction: ArrowDirection,
    /// An optional amount of additional flags to increase line length
    pub extra_length_num: Option<u8>,
}

/// This is the root struct for an individual flow chart.
pub struct FlowChart {
    /// This is the data location of the string data for the markdown
    data: String,
}

impl FlowChart {
    /// Creates a [Mermaid.js Dotted/Dashed Line](https://mermaid-js.github.io/mermaid/#/flowchart?id=dotted-link) with the supplied attributes & appends it to the current data of the flow chart struct (i.e. `self.data`).
    ///
    /// # Arguments
    ///
    /// * `extra_length_num` - An optional amount of additional flags to increase line length
    fn add_dashed_line(
        &mut self,
        extra_length_num: Option<u8>,
    ) {
        // Push the left half of the dashed line flag
        self.data
            .push_str(LineType::Dashed.get_str("Left").unwrap());

        // Check to see if an additional length was requested
        if let Some(extra_length_num) = extra_length_num {
            // Range over `extra_length_num` to add the appropriate number of length additions
            for _ in 0..extra_length_num {
                // Add in a `.`
                self.data
                    .push_str(LineType::Dashed.get_str("Addition").unwrap());
            }
        }

        // Push the right half of the dashed line flag
        self.data
            .push_str(LineType::Dashed.get_str("Right").unwrap());
    }

    /// Creates a [Mermaid.js Solid Line](https://mermaid-js.github.io/mermaid/#/flowchart?id=a-link-with-arrow-head) with the supplied attributes & appends it to the current data of the flow chart struct (i.e. `self.data`).
    ///
    /// # Arguments
    ///
    /// * `extra_length_num` - An optional amount of additional flags to increase line length
    fn add_solid_line(
        &mut self,
        extra_length_num: Option<u8>,
    ) {
        // Push the main portion of the solid line flag
        self.data
            .push_str(LineType::Solid.get_str("Complete").unwrap());

        // Check to see if an additional length was requested
        if let Some(extra_length_num) = extra_length_num {
            // Range over `extra_length_num` to add the appropriate number of length additions
            for _ in 0..extra_length_num {
                // Add in a `-`
                self.data
                    .push_str(LineType::Solid.get_str("Addition").unwrap());
            }
        }
    }

    /// Creates a [Mermaid.js Connection Line with no arrow](https://mermaid-js.github.io/mermaid/#/flowchart?id=links-between-nodes) with the supplied attributes & appends it to the current data of the flow chart struct (i.e. `self.data`).
    ///
    /// # Arguments
    ///
    /// * `line_type` - The enum representation of the line type you want
    /// * `extra_length_num` - An optional amount of additional flags to increase line length
    fn add_line(
        &mut self,
        line_type: LineType,
        extra_length_num: Option<u8>,
    ) {
        match line_type {
            LineType::Solid => self.add_solid_line(extra_length_num),
            LineType::Dashed => self.add_dashed_line(extra_length_num),
        }
    }

    /// Creates a [Mermaid.js Arrow](https://mermaid-js.github.io/mermaid/#/flowchart?id=new-arrow-types) with the supplied attributes & appends it to the current data of the flow chart struct (i.e. `self.data`).
    ///
    /// # Arguments
    ///
    /// * `arrow_type` - The enum representation of the arrow type you want
    /// * `arrow_direction` - The enum representation of the direction you want the arrow to
    fn add_arrow(
        &mut self,
        arrow_type: ArrowType,
        arrow_direction: ArrowDirection,
    ) {
        // Get the `arrow_direction` as a str to use as the key for the `ArrowType` enum property to then add the correct arrow flag
        self.data
            .push_str(arrow_type.get_str(arrow_direction.as_ref()).unwrap())
    }

    /// Determines which [Shape] to put in a [NodeConfig].
    ///
    /// # Arguments
    ///
    /// * `node` - The [Node] that is being represented
    fn get_shape_from_node(
        &self,
        node: &Node,
    ) -> Shape {
        match node.action {
            ActionType::Mutation => Shape::Hexagon,
            ActionType::View => Shape::Circle,
            ActionType::Process => Shape::Rectangle,
            ActionType::Event => Shape::Flag,
            ActionType::None => Shape::Rectangle,
        }
    }

    /// Determines which [LineType] & [ArrowType] to put in a [ConnectionConfig].
    ///
    /// # Arguments
    ///
    /// * `connection` - The [Connection] that is being represented
    fn get_line_and_arrow_type_from_connection(
        &self,
        connection: &Connection,
    ) -> (LineType, ArrowType, ArrowDirection) {
        match connection.connection_type {
            ConnectionType::DirectConnection => {
                (LineType::Solid, ArrowType::Standard, ArrowDirection::Right)
            }
            ConnectionType::CrossContractConnection => {
                (LineType::Dashed, ArrowType::Standard, ArrowDirection::Right)
            }
            ConnectionType::Emission => {
                (LineType::Dashed, ArrowType::O, ArrowDirection::None)
            }
        }
    }
}

impl CoreSyntaxFunctions for FlowChart {
    fn new(direction: FlowDirection) -> Self {
        // Instantiate the starting point for the diagram schema
        let mut schema_root = "flowchart ".to_string();

        // Add in `direction`
        schema_root.push_str(direction.as_ref());

        // Instantiate `FlowChart`
        let mut result = FlowChart { data: schema_root };

        // Add a new line
        result.add_linebreak(None);

        result
    }

    fn add_node(
        &mut self,
        node_config: SyntaxConfigFile,
    ) {
        let node_config: NodeConfig = node_config
            .into_flow_chart()
            .unwrap()
            .into_node_config()
            .unwrap();

        // Push the ID
        self.data.push_str(node_config.id);

        // Push the left shape flag
        self.data
            .push_str(node_config.shape.get_str("Left").unwrap());

        // Push the inner text
        self.data.push_str(node_config.inner_text);

        // Push the left shape flag
        self.data
            .push_str(node_config.shape.get_str("Right").unwrap());

        // If a class name was passed push it to `self.data`
        if let Some(class) = node_config.class {
            self.data.push_str(":::");
            self.data.push_str(class.as_str());
        }
    }

    fn add_connection(
        &mut self,
        connection_config: SyntaxConfigFile,
    ) {
        // Unwrap the `SyntaxConfigFile` into the needed `ConnectionConfig`
        let connection_config: ConnectionConfig = connection_config
            .into_flow_chart()
            .unwrap()
            .into_connection_config()
            .unwrap();

        // Push a preceding space
        self.data.push(' ');

        // Depending on the arrow direction wanted make calls to `self.add_arrow` & `self.add_line`
        match connection_config.arrow_direction {
            ArrowDirection::BiDirectional => {
                self.add_arrow(connection_config.arrow_type, ArrowDirection::Left);
                self.add_line(
                    connection_config.line_type,
                    connection_config.extra_length_num,
                );
                self.add_arrow(connection_config.arrow_type, ArrowDirection::Right)
            }
            ArrowDirection::Left => {
                self.add_arrow(
                    connection_config.arrow_type,
                    connection_config.arrow_direction,
                );
                self.add_line(
                    connection_config.line_type,
                    connection_config.extra_length_num,
                )
            }
            ArrowDirection::Right => {
                self.add_line(
                    connection_config.line_type,
                    connection_config.extra_length_num,
                );
                self.add_arrow(
                    connection_config.arrow_type,
                    connection_config.arrow_direction,
                )
            }
            ArrowDirection::None => {
                self.add_line(
                    connection_config.line_type,
                    connection_config.extra_length_num,
                );
            }
        }

        // Push a trailing space
        self.data.push(' ');
    }

    fn add_linebreak(
        &mut self,
        num_of_indents: Option<u8>,
    ) {
        // Get the number of indents to use
        let number_of_indents = num_of_indents.unwrap_or(1);

        // Add the new line
        self.data += "\n";

        // Range over `number_of_indents` to add the appropriate number of tabs
        for _ in 0..number_of_indents {
            // Add in a tab
            self.data += "\t";
        }
    }

    fn build_node_config<'a>(
        &self,
        node: &'a Node,
        id: Option<&'a str>,
    ) -> SyntaxConfigFile<'a> {
        if let Some(id) = id {
           
            // If an ID was passed use it
            SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
                id,
                class: Some(format!("{}-{}",node.scope.as_ref(),node.action.as_ref())),
                shape: self.get_shape_from_node(node),
                inner_text: &node.name,
            }))
        } else {
            // Else use the Node's name
            SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
                id: &node.name,
                class: Some(format!("{}-{}",node.scope.as_ref(),node.action.as_ref())),
                shape: self.get_shape_from_node(node),
                inner_text: &node.name,
            }))
        }
    }

    fn build_connection_config<'a>(
        &self,
        connection: &'a Connection,
        extra_length_num: Option<u8>,
    ) -> SyntaxConfigFile<'a> {
        let (line_type, arrow_type, arrow_direction) =
            self.get_line_and_arrow_type_from_connection(connection);

        SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
            line_type,
            arrow_type,
            arrow_direction,
            extra_length_num,
        }))
    }

    fn return_schema(&self) -> String {
        self.data.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_creates_a_circle() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Circle,
            inner_text: "inner text",
        }));

        // Add the node to check afterwards
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A((inner text))";

        println!("{}", flow_chart.data);

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_creates_a_rectangle() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Rectangle,
            inner_text: "inner text",
        }));

        // Add the node to check afterwards
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A[inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_creates_a_hexagon() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Hexagon,
            inner_text: "inner text",
        }));

        // Add the node to check afterwards
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A{{inner text}}";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_creates_a_flag() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the node to check afterwards
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_right_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::Standard,
                arrow_direction: ArrowDirection::Right,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] -..-> B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_no_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::Standard,
                arrow_direction: ArrowDirection::None,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] -..- B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_left_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::Standard,
                arrow_direction: ArrowDirection::Left,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] <-..- B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_bidirectional_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::Standard,
                arrow_direction: ArrowDirection::BiDirectional,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] <-..-> B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_right_o_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::O,
                arrow_direction: ArrowDirection::Right,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] -..-o B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_left_o_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::O,
                arrow_direction: ArrowDirection::Left,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] o-..- B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_bidirectional_o_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::O,
                arrow_direction: ArrowDirection::BiDirectional,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] o-..-o B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_right_x_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::X,
                arrow_direction: ArrowDirection::Right,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] -..-x B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_left_x_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::X,
                arrow_direction: ArrowDirection::Left,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] x-..- B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_bidirectional_x_arrow() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::X,
                arrow_direction: ArrowDirection::BiDirectional,
                extra_length_num: None,
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] x-..-x B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }

    #[test]
    fn it_adds_a_dashed_line_with_bidirectional_x_arrow_and_extra_length() {
        // Instantiate the flow chart
        let mut flow_chart = FlowChart::new(FlowDirection::TD);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "A",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the beginning node
        flow_chart.add_node(node_config);

        let connection_config =
            SyntaxConfigFile::FlowChart(ObjectConfig::ConnectionConfig(ConnectionConfig {
                line_type: LineType::Dashed,
                arrow_type: ArrowType::X,
                arrow_direction: ArrowDirection::BiDirectional,
                extra_length_num: Some(1),
            }));

        // Add the line to check afterwards
        flow_chart.add_connection(connection_config);

        let node_config = SyntaxConfigFile::FlowChart(ObjectConfig::NodeConfig(NodeConfig {
            id: "B",
            class: None,
            shape: Shape::Flag,
            inner_text: "inner text",
        }));

        // Add the trailing node
        flow_chart.add_node(node_config);

        // The string we are expecting
        let expected = r"flowchart TD
	A>inner text] x-...-x B>inner text]";

        assert_eq!(flow_chart.data, expected);
    }
}

'''
'''--- mermaid-markdown-api/src/syntax/mod.rs ---
use crate::objects::connection::Connection;
use crate::objects::node::Node;
use crate::syntax::flow_chart::ObjectConfig;
use enum_as_inner::EnumAsInner;
// TODO:
pub mod flow_chart;

/// An Enum representing the possible options for the direction of flow for the diagram.
#[derive(AsRefStr)]
pub enum FlowDirection {
    /// top to bottom
    TB,
    /// top-down (same as top to bottom)
    TD,
    /// bottom to top
    BT,
    /// right to left
    BL,
    /// left to right
    LR,
}

/// An enum representation of the available syntax's.
#[derive(EnumProperty, EnumAsInner, Debug)]
pub enum SyntaxConfigFile<'a> {
    FlowChart(ObjectConfig<'a>),
}

pub trait CoreSyntaxFunctions {
    /// Returns a `FlowChart` struct to allow you to build the necessary markdown text.
    ///
    /// # Arguments
    ///
    /// * `direction` - The enum representation of the flow direction of the diagram
    ///
    /// # Examples
    ///
    /// ```
    /// use mermaid_markdown_api::syntax::flow_chart::FlowChart;
    /// use mermaid_markdown_api::syntax::{CoreSyntaxFunctions, FlowDirection};
    ///
    /// let mut flow_chart = FlowChart::new(FlowDirection::TD);
    /// ```
    fn new(direction: FlowDirection) -> Self;

    /// Creates a [Mermaid.js Node](https://mermaid-js.github.io/mermaid/#/flowchart?id=a-node-default) with the supplied [configuration](NodeConfig) & appends it to the current data of the flow chart struct (i.e. `self.data`).
    ///
    /// # Arguments
    /// * `node_config` - [NodeConfig]
    ///
    /// # Examples
    ///
    /// ```
    /// use mermaid_markdown_api::syntax::flow_chart::{FlowChart, NodeConfig, Shape};
    /// use mermaid_markdown_api::syntax::{CoreSyntaxFunctions, FlowDirection, SyntaxConfigFile};
    ///
    /// let mut flow_chart = FlowChart::new(FlowDirection::TD);
    ///
    /// let node_config =  SyntaxConfigFile::FlowChart(ConfigFile::NodeConfig(NodeConfig {
    ///   id: "A",
    ///   class: None,
    ///   shape: Shape::Circle,
    ///   inner_text: "inner text",
    /// }));
    ///
    /// flow_chart.add_node(node_config);
    /// ```
    fn add_node(
        &mut self,
        node_config: SyntaxConfigFile,
    );

    /// Creates a [Mermaid.js Connection](https://mermaid-js.github.io/mermaid/#/flowchart?id=links-between-nodes) with the supplied [configuration] & appends it to the current data of the flow chart struct (i.e. `self.data`).
    ///
    /// # Arguments
    /// * `connection_config` - [ConnectionConfig]
    ///
    /// # Examples
    ///
    /// ```
    /// use mermaid_markdown_api::syntax::flow_chart::{ArrowDirection, ArrowType, ConnectionConfig, FlowChart, LineType, NodeConfig, Shape};
    /// use mermaid_markdown_api::syntax::{CoreSyntaxFunctions, FlowDirection, SyntaxConfigFile};
    /// let mut flow_chart = FlowChart::new(FlowDirection::TD);
    ///
    /// let node_config =  SyntaxConfigFile::FlowChart(ConfigFile::NodeConfig(NodeConfig {
    ///   id: "A",
    ///   class: None,
    ///   shape: Shape::Circle,
    ///   inner_text: "inner text",
    /// }));
    ///
    /// let connection_config = SyntaxConfigFile::FlowChart(ConfigFile::ConnectionConfig(ConnectionConfig {
    ///   line_type: LineType::Dashed,
    ///   arrow_type: ArrowType::Standard,
    ///   arrow_direction: ArrowDirection::Right,
    ///   extra_length_num: None,
    /// }));
    ///
    /// flow_chart.add_node(node_config);
    /// flow_chart.add_connection(connection_config);
    /// ```
    fn add_connection(
        &mut self,
        connection_config: SyntaxConfigFile,
    );

    /// Appends a linebreak & the preceding whitespace to the current data of the flow chart struct (i.e. `self.data`).
    ///
    /// # Arguments
    ///
    /// * `num_of_indents` - Optional number of indents to insert once the new line is added (default it 1)
    ///
    /// # Examples
    ///
    /// ```
    /// use mermaid_markdown_api::syntax::flow_chart::FlowChart;
    /// use mermaid_markdown_api::syntax::{CoreSyntaxFunctions, FlowDirection};
    /// let mut flow_chart = FlowChart::new(FlowDirection::TD);
    ///
    /// flow_chart.add_linebreak(None);
    /// ```
    fn add_linebreak(
        &mut self,
        num_of_indents: Option<u8>,
    );

    /// This method creates a [NodeConfig] referencing data from a supplied [Node].
    ///
    /// # Arguments
    ///
    /// * `node` - The [Node] that is going to determine the configuration
    ///
    /// # Examples
    ///
    /// ```
    /// use mermaid_markdown_api::objects::node::{ActionType, Node, ScopeType};
    /// use mermaid_markdown_api::syntax::{CoreSyntaxFunctions, FlowDirection};
    /// use mermaid_markdown_api::syntax::flow_chart::FlowChart;
    /// let mut flow_chart = FlowChart::new(FlowDirection::TD);
    ///
    /// let node = Node {
    ///     name: "function_a".to_string(),
    ///     scope: ScopeType::Public,
    ///     action: ActionType::Mutation,
    ///     connections: vec![],
    /// };
    ///
    /// let node_config = flow_chart.build_node_config(&node);
    /// ```
    fn build_node_config<'a>(
        &self,
        node: &'a Node,
        id: Option<&'a str>,
    ) -> SyntaxConfigFile<'a>;

    /// This method creates a [ConnectionConfig] referencing data from a supplied [Connection].
    ///
    /// # Arguments
    ///
    /// * `connection` - The [Connection] that is going to determine the configuration
    ///
    /// # Examples
    ///
    /// ```
    /// use mermaid_markdown_api::objects::connection::{Connection, ConnectionType};
    /// use mermaid_markdown_api::objects::node::{ActionType, Node, ScopeType};
    /// use mermaid_markdown_api::syntax::{CoreSyntaxFunctions, FlowDirection};
    /// use mermaid_markdown_api::syntax::flow_chart::FlowChart;
    /// let mut flow_chart = FlowChart::new(FlowDirection::TD);
    ///
    /// let connection = Connection {
    ///     connection_type: ConnectionType::DirectConnection,
    ///     node: Node {
    ///         name: "function_a".to_string(),
    ///         scope: ScopeType::Public,
    ///         action: ActionType::Mutation,
    ///         connections: vec![],
    ///     }
    /// };
    ///
    /// let connection_config = flow_chart.build_connection_config(&connection);
    /// ```
    fn build_connection_config<'a>(
        &self,
        connection: &'a Connection,
        extra_length_num: Option<u8>,
    ) -> SyntaxConfigFile<'a>;

    /// This method returns a clone of `self.data`.
    ///
    /// # Examples
    ///
    /// ```
    /// use mermaid_markdown_api::objects::node::{ActionType, Node, ScopeType};
    /// use mermaid_markdown_api::syntax::{CoreSyntaxFunctions, FlowDirection};
    /// use mermaid_markdown_api::syntax::flow_chart::FlowChart;
    /// let mut flow_chart = FlowChart::new(FlowDirection::TD);
    ///
    /// let node = Node {
    ///     name: "function_a".to_string(),
    ///     scope: ScopeType::Public,
    ///     action: ActionType::Mutation,
    ///     connections: vec![],
    /// };
    ///
    /// let node_config = flow_chart.build_node_config(&node);
    ///
    /// flow_chart.add_node(node_config);
    ///
    /// let markdown_string = flow_chart.return_schema();
    /// ```
    fn return_schema(&self) -> String;
}

'''
'''--- scanner-syn/Cargo.toml ---
# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
#
# When uploading crates to the registry Cargo will automatically
# "normalize" Cargo.toml files for maximal compatibility
# with all versions of Cargo and also rewrite `path` dependencies
# to registry (e.g., crates.io) dependencies.
#
# If you are reading this file be aware that the original Cargo.toml
# will likely look very different (and much more reasonable).
# See Cargo.toml.orig for the original contents.

[package]
edition = "2018"
name = "scanner-syn"
version = "0.1.0"
authors = ["PrimeLab <support@primelab.io>"]
description = "Scanning near smart contract with syn"
homepage = "https://primelab.io/"
categories = ["wasm"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/NearPrime/web3-diagram"

[lib]
proc-macro = false
[dependencies.Inflector]
version = "0.11.4"
features = []
default-features = false

[dependencies.proc-macro2]
version = "1.0"

[dependencies.quote]
version = "1.0"

[dependencies.syn]
version = "1"
features = ["full", "fold", "extra-traits", "visit"]

[dependencies.walkdir]
version = "2.3.2"
'''
'''--- scanner-syn/src/contract_descriptor.rs ---
use proc_macro2::{Ident, Span};
use std::io::Read;
use std::iter::IntoIterator;

use std::{fs::File, path::Path};
use syn::{Item, ItemStruct};

use crate::core_impl::*;
use proc_macro2::TokenStream;
use quote::quote;
use syn::__private::ToTokens;
use syn::visit::Visit;
use walkdir::WalkDir;

///Function information from the code scanned by ContractDescriptor
#[derive(Clone, Default, Debug)]
pub struct FunctionInfo {
    pub name: String,
    /// Whether method is exported
    pub is_public: bool,
    /// Whether this is a trait implementation.
    pub is_trait_impl: bool,
    /// Whether method does not modify the state.
    pub is_init: bool,
    /// Whether method is test method
    pub is_test: bool,
    /// Whether method accepting $NEAR.
    pub is_payable: bool,
    /// Whether method does not modify the state.
    pub is_view: bool,
    /// Whether method can modify the state.
    pub is_mutable: bool,
    /// Whether method doesn't return a value.
    pub is_process: bool,
    /// Whether method can accept calls from self (current account)
    pub is_private_cccalls: bool,
    /// Whether `impl` section decorated with `#[near_bindgen]`
    pub is_out_of_contract_scope: bool,
    /// Whether method is part of `NearEvent` trait
    pub is_event: bool,
    ///functions are being called by this function
    pub inner_calls: Option<Vec<FunctionInfo>>,
}
///Contract information from the code scanned by ContractDescriptor
pub struct ContractInfo {
    pub contract_metadata: Vec<ContractDescriptorMeta>,
}
#[derive(Debug)]
pub struct ContractDescriptorMeta {
    pub fns: Vec<FunctionInfo>,
    pub connections: Option<Vec<FunctionInfo>>,
    pub tokens: Option<TokenStream>,
}

///Trait for converting tokenstream to extended one
impl ToTokens for FunctionInfo {
    ///Function extends TokenStream with FunctionInfo
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let name: &str = &self.name;
        let is_public: bool = self.is_public;
        let is_trait_impl: bool = self.is_trait_impl;
        let is_init: bool = self.is_init;
        let is_payable: bool = self.is_payable;
        let is_view: bool = self.is_view;
        let is_mutable: bool = self.is_mutable;
        let is_process: bool = self.is_process;
        let is_private_cccalls: bool = self.is_private_cccalls;
        let is_out_of_contract_scope: bool = self.is_out_of_contract_scope;
        let is_event: bool = self.is_event;
        tokens.extend(quote! {
            FunctionInfo {
                name: #name,
                is_public: #is_public,
                is_trait_impl: #is_trait_impl,
                is_init: #is_init,
                is_payable: #is_payable,
                is_view: #is_view,
                is_mutable: #is_mutable,
                is_process: #is_process,
                is_private_cccalls: #is_private_cccalls,
                is_out_of_contract_scope: #is_out_of_contract_scope,
                is_event: #is_event
            }
        });
    }

    ///Converts to TokenStream
    fn to_token_stream(&self) -> TokenStream {
        let mut tokens = TokenStream::new();
        self.to_tokens(&mut tokens);
        tokens
    }

    ///gets the token stream
    fn into_token_stream(self) -> TokenStream
    where
        Self: Sized,
    {
        self.to_token_stream()
    }
}
///Trait near smart contracts descriptor
pub trait ContractDescriptor {
    ///Gets the contract information inside the current crate
    fn get_contract_info_for_crate(&self,root:Option<&str>) -> ContractInfo;
    fn get_tokens_from_file_path(&self, file_path: &Path) -> ContractDescriptorMeta;
    fn get_tokens_from_source(&self, src: String) -> ContractDescriptorMeta;
}

///Default Near contract descriptor
pub struct DefaultContractDescriptor;

///Implementation of Near contract descriptor
impl DefaultContractDescriptor {
    pub fn new() -> Self {
        Self {}
    }
    pub fn version()-> String{
        String::from("0.0.1")
    }
    fn get_inner_calls(
        &self,
        fn_name: String,
        connections: Vec<FunctionInfo>,
        fns: Vec<FunctionInfo>,
    ) -> Option<Vec<FunctionInfo>> {
        let mut def=fn_name;
        if def=="def_ault"{
            def=def.replace("def_ault", "default");
        }

        let con_info = connections
            .into_iter()
            .find(|el| def == el.name)
            .unwrap();

        let mut fn_iter = fns.into_iter();

        let inner_calls = con_info
            .inner_calls
            .unwrap()
            .into_iter()
            .filter_map(|ic| -> Option<FunctionInfo> {
                fn_iter.find(|f| f.name == ic.name && !f.is_payable && !f.is_init)
            })
            .collect::<Vec<_>>();

        if inner_calls.len() > 0 {
            Some(inner_calls)
        } else {
            None
        }
    }
    fn resolve_call_hierarchy(
        &self,
        metadata: ContractDescriptorMeta,
        fns: Vec<FunctionInfo>,
    ) -> ContractDescriptorMeta {
        let iiter = fns;
        let connections = metadata.connections.unwrap();
        //print!("{:?}",connections);
        let result = metadata
            .fns
            .iter()
            .map(|f_info| FunctionInfo {
                inner_calls: self.get_inner_calls(
                    f_info.name.clone(),
                    connections.clone(),
                    iiter.clone(),
                ),
                ..f_info.clone()
            })
            .collect::<Vec<FunctionInfo>>();

        ContractDescriptorMeta {
            fns: result,
            connections: None,
            tokens: None,
        }
    }

    fn metadata(&self, item: proc_macro2::TokenStream) -> syn::Result<ContractDescriptorMeta> {
        if let Ok(input) = syn::parse2::<syn::File>(item) {
            let mut visitor = MetadataVisitor::new();
            visitor.visit_file(&input);
            let connections = visitor.get_connections();
            let fns = visitor.generate_metadata_method().unwrap();
            syn::Result::Ok(ContractDescriptorMeta {
                fns,
                connections: Some(connections),
                tokens: None,
            })
        } else {
            syn::__private::Err(syn::Error::new(
                Span::call_site(),
                "Failed to parse code decorated with `metadataa!{}` macro. Only valid Rust is supported.",
            ))
        }
    }
    
}

///Implement contract descriptor trait for DefaultContractDescriptor
impl ContractDescriptor for DefaultContractDescriptor {
    fn get_contract_info_for_crate(&self,root:Option<&str>) -> ContractInfo {
        let mut contract_metadata: Vec<ContractDescriptorMeta> = vec![];
        let mut fns: Vec<FunctionInfo> = vec![];
        // Walk into every dir to find every `rs` file
        let root_path=root.unwrap_or(".");
        for entry in WalkDir::new(root_path).into_iter().filter_map(|e| {
            let dir = e.unwrap().clone();
            if !dir.path().to_str().unwrap().contains("test") {
                return Some(dir);
            }
            None
        }) {
            if entry.path().extension().map(|s| s == "rs").unwrap_or(false) {
                //println!("\n{}", entry.path().display());
                let metadata = self.get_tokens_from_file_path(entry.path());
                //println!("\n{:?}", metadata.connections);
                let scoped_fns = metadata.fns.clone();
                fns.extend(scoped_fns);
                contract_metadata.push(metadata);
            }
        }

        let resolved = contract_metadata
            .into_iter()
            .map(|m| self.resolve_call_hierarchy(m, fns.clone()))
            .collect();

        //println!("\n{:?}", resolved);
        ContractInfo {
            contract_metadata: resolved,
        }
    }

    fn get_tokens_from_file_path(&self, file_path: &Path) -> ContractDescriptorMeta {
        let mut file = File::open(file_path).expect("Unable to open file");
        let mut src = String::new();
        file.read_to_string(&mut src).expect("Unable to read file");
        self.get_tokens_from_source(src)
    }

    fn get_tokens_from_source(&self, src: String) -> ContractDescriptorMeta {
        let syntax = syn::parse_file(&src).expect("Unable to parse file");
        self.metadata(syntax.to_token_stream()).unwrap()
    }
}

'''
'''--- scanner-syn/src/core_impl/code_generator/attr_sig_info.rs ---
use proc_macro2::TokenStream as TokenStream2;

use crate::core_impl::info_extractor::{
    ArgInfo, AttrSigInfo, BindgenArgType, InputStructType, SerializerType,
};
use quote::quote;

impl AttrSigInfo {
    /// Create struct representing input arguments.
    /// * input_struct_type represents whether the input structure will be used for serialization
    ///     (e.g. for a promise input) or deserialization (e.g. for a method input).
    /// Each argument is getting converted to a field in a struct. Specifically argument:
    /// `ATTRIBUTES ref mut binding @ SUBPATTERN : TYPE` is getting converted to:
    /// `binding: SUBTYPE,` where `TYPE` is one of the following: `& SUBTYPE`, `&mut SUBTYPE`,
    /// and `SUBTYPE` is one of the following: `[T; n]`, path like
    /// `std::collections::HashMap<SUBTYPE, SUBTYPE>`, or tuple `(SUBTYPE0, SUBTYPE1, ...)`.
    /// # Example
    /// ```ignore
    /// struct Input {
    ///   arg0: Vec<String>,
    ///   arg1: [u64; 10],
    ///   arg2: (u64, Vec<String>),
    /// }
    /// ```
    pub fn input_struct(&self, input_struct_type: InputStructType) -> TokenStream2 {
        let args: Vec<_> = self.input_args().collect();
        assert!(
            !args.is_empty(),
            "Can only generate input struct for when input args are specified"
        );
        let attribute = match input_struct_type {
            InputStructType::Serialization => match &self.input_serializer {
                SerializerType::JSON => quote! {
                    #[derive(near_sdk::serde::Serialize)]
                    #[serde(crate = "near_sdk::serde")]
                },
                SerializerType::Borsh => {
                    quote! {
                        #[derive(near_sdk::borsh::BorshSerialize)]
                    }
                }
            },
            InputStructType::Deserialization => match &self.input_serializer {
                SerializerType::JSON => quote! {
                    #[derive(near_sdk::serde::Deserialize)]
                    #[serde(crate = "near_sdk::serde")]
                },
                SerializerType::Borsh => {
                    quote! {
                        #[derive(near_sdk::borsh::BorshDeserialize)]
                    }
                }
            },
        };
        let mut fields = TokenStream2::new();
        for arg in args {
            let ArgInfo { ty, ident, .. } = &arg;
            fields.extend(quote! {
                #ident: #ty,
            });
        }
        quote! {
            #attribute
            struct Input {
                #fields
            }
        }
    }

    /// Create pattern that decomposes input struct using correct mutability modifiers.
    /// # Example:
    /// ```ignore
    /// Input {
    ///     arg0,
    ///     mut arg1,
    ///     arg2
    /// }
    /// ```
    pub fn decomposition_pattern(&self) -> TokenStream2 {
        let args: Vec<_> = self.input_args().collect();
        assert!(
            !args.is_empty(),
            "Can only generate decomposition pattern for when input args are specified."
        );
        let mut fields = TokenStream2::new();
        for arg in args {
            let ArgInfo {
                mutability, ident, ..
            } = &arg;
            fields.extend(quote! {
            #mutability #ident,
            });
        }
        quote! {
            Input {
                #fields
            }
        }
    }

    /// Create expression that constructs the struct.
    /// # Example:
    /// ```ignore
    /// Input {
    ///     arg0,
    ///     arg1,
    ///     arg2,
    /// }
    /// ```
    pub fn constructor_expr(&self) -> TokenStream2 {
        let args: Vec<_> = self.input_args().collect();
        assert!(
            !args.is_empty(),
            "Can only generate constructor expression for when input args are specified."
        );
        let mut fields = TokenStream2::new();
        for arg in args {
            let ArgInfo { ident, .. } = &arg;
            fields.extend(quote! {
            #ident,
            });
        }
        quote! {
            Input {
                #fields
            }
        }
    }

    /// Create a sequence of arguments that can be used to call the method or the function
    /// of the smart contract.
    ///
    /// # Example:
    /// ```ignore
    /// a, &b, &mut c,
    /// ```
    pub fn arg_list(&self) -> TokenStream2 {
        let mut result = TokenStream2::new();
        for arg in &self.args {
            let ArgInfo {
                reference,
                mutability,
                ident,
                ..
            } = &arg;
            result.extend(quote! {
                #reference #mutability #ident,
            });
        }
        result
    }

    /// Create a sequence of patterns and types to be used in the method signature.
    ///
    /// # Example:
    /// ```ignore
    /// a: u64, b: &mut T, ref mut c: Vec<String>,
    /// ```
    pub fn pat_type_list(&self) -> TokenStream2 {
        let mut result = TokenStream2::new();
        for arg in self.input_args() {
            let ArgInfo { original, .. } = &arg;
            result.extend(quote! {
                #original,
            });
        }
        result
    }

    /// Create code that deserializes arguments that were decorated with `#[callback*]`
    pub fn callback_deserialization(&self) -> TokenStream2 {
        self.args
            .iter()
            .filter(|arg| {
                matches!(
                    arg.bindgen_ty,
                    BindgenArgType::CallbackArg | BindgenArgType::CallbackResultArg
                )
            })
            .enumerate()
            .fold(TokenStream2::new(), |acc, (idx, arg)| {
                let idx = idx as u64;
                let ArgInfo { mutability, ident, ty, bindgen_ty, serializer_ty, .. } = arg;
                match &bindgen_ty {
                    BindgenArgType::CallbackArg => {
                        let error_msg = format!("Callback computation {} was not successful", idx);
                        let read_data = quote! {
                            let data: Vec<u8> = match near_sdk::env::promise_result(#idx) {
                                near_sdk::PromiseResult::Successful(x) => x,
                                _ => near_sdk::env::panic_str(#error_msg)
                            };
                        };
                        let invocation = deserialize_data(serializer_ty);
                        quote! {
                            #acc
                            #read_data
                            let #mutability #ident: #ty = #invocation;
                        }
                    }
                    BindgenArgType::CallbackResultArg => {
                        let deserialize = deserialize_data(serializer_ty);
                        let result = quote! {
                            match near_sdk::env::promise_result(#idx) {
                                near_sdk::PromiseResult::Successful(data) => Ok(#deserialize),
                                near_sdk::PromiseResult::NotReady => Err(near_sdk::PromiseError::NotReady),
                                near_sdk::PromiseResult::Failed => Err(near_sdk::PromiseError::Failed),
                            }
                        };
                        quote! {
                            #acc
                            let #mutability #ident: #ty = #result;
                        }
                    }
                    _ => unreachable!()
                }
            })
    }

    /// Create code that deserializes arguments that were decorated with `#[callback_vec]`.
    pub fn callback_vec_deserialization(&self) -> TokenStream2 {
        self
            .args
            .iter()
            .filter(|arg| matches!(arg.bindgen_ty, BindgenArgType::CallbackArgVec))
            .fold(TokenStream2::new(), |acc, arg| {
                let ArgInfo { mutability, ident, ty, .. } = arg;
                let invocation = deserialize_data(&arg.serializer_ty);
                quote! {
                #acc
                let #mutability #ident: #ty = (0..near_sdk::env::promise_results_count())
                .map(|i| {
                    let data: Vec<u8> = match near_sdk::env::promise_result(i) {
                        near_sdk::PromiseResult::Successful(x) => x,
                        _ => near_sdk::env::panic_str(&format!("Callback computation {} was not successful", i)),
                    };
                    #invocation
                }).collect();
            }
            })
    }
}

pub fn deserialize_data(ty: &SerializerType) -> TokenStream2 {
    match ty {
        SerializerType::JSON => quote! {
            near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON")
        },
        SerializerType::Borsh => quote! {
            near_sdk::borsh::BorshDeserialize::try_from_slice(&data).expect("Failed to deserialize callback using Borsh")
        },
    }
}

'''
'''--- scanner-syn/src/core_impl/code_generator/impl_item_method_info.rs ---
use crate::core_impl::info_extractor::{
    AttrSigInfo, ImplItemMethodInfo, InputStructType, MethodType, SerializerType,
};
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{ReturnType, Signature};

impl ImplItemMethodInfo {
    /// Generate wrapper method for the given method of the contract.
    pub fn method_wrapper(&self) -> TokenStream2 {
        let ImplItemMethodInfo {
            attr_signature_info,
            struct_type,
            ..
        } = self;
        // Args provided by `env::input()`.
        let has_input_args = attr_signature_info.input_args().next().is_some();

        let panic_hook = quote! {
            near_sdk::env::setup_panic_hook();
        };
        let arg_struct;
        let arg_parsing;
        if has_input_args {
            arg_struct = attr_signature_info.input_struct(InputStructType::Deserialization);
            let decomposition = attr_signature_info.decomposition_pattern();
            let serializer_invocation = match attr_signature_info.input_serializer {
                SerializerType::JSON => quote! {
                    near_sdk::serde_json::from_slice(
                        &near_sdk::env::input().expect("Expected input since method has arguments.")
                    ).expect("Failed to deserialize input from JSON.")
                },
                SerializerType::Borsh => quote! {
                    near_sdk::borsh::BorshDeserialize::try_from_slice(
                        &near_sdk::env::input().expect("Expected input since method has arguments.")
                    ).expect("Failed to deserialize input from Borsh.")
                },
            };
            arg_parsing = quote! {
                let #decomposition : Input = #serializer_invocation ;
            };
        } else {
            arg_struct = TokenStream2::new();
            arg_parsing = TokenStream2::new();
        };

        let callback_deser = attr_signature_info.callback_deserialization();
        let callback_vec_deser = attr_signature_info.callback_vec_deserialization();

        let arg_list = attr_signature_info.arg_list();
        let AttrSigInfo {
            non_bindgen_attrs,
            ident,
            receiver,
            returns,
            result_serializer,
            method_type,
            is_payable,
            is_private,
            ..
        } = attr_signature_info;
        let deposit_check = if *is_payable || matches!(method_type, &MethodType::View) {
            // No check if the method is payable or a view method
            quote! {}
        } else {
            // If method is not payable, do a check to make sure that it doesn't consume deposit
            let error = format!("Method {} doesn't accept deposit", ident);
            quote! {
                if near_sdk::env::attached_deposit() != 0 {
                    near_sdk::env::panic_str(#error);
                }
            }
        };
        let is_private_check = if *is_private {
            let error = format!("Method {} is private", ident);
            quote! {
                if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
                    near_sdk::env::panic_str(#error);
                }
            }
        } else {
            quote! {}
        };
        let body = if matches!(method_type, &MethodType::Init) {
            if matches!(returns, ReturnType::Default) {
                return syn::Error::new(
                    ident.span(),
                    "Init methods must return the contract state",
                )
                .to_compile_error();
            }
            quote! {
                if near_sdk::env::state_exists() {
                    near_sdk::env::panic_str("The contract has already been initialized");
                }
                let contract = #struct_type::#ident(#arg_list);
                near_sdk::env::state_write(&contract);
            }
        } else if matches!(method_type, &MethodType::InitIgnoreState) {
            if matches!(returns, ReturnType::Default) {
                return syn::Error::new(
                    ident.span(),
                    "Init methods must return the contract state",
                )
                .to_compile_error();
            }
            quote! {
                let contract = #struct_type::#ident(#arg_list);
                near_sdk::env::state_write(&contract);
            }
        } else {
            let contract_deser;
            let method_invocation;
            let contract_ser;
            if let Some(receiver) = receiver {
                let mutability = &receiver.mutability;
                contract_deser = quote! {
                    let #mutability contract: #struct_type = near_sdk::env::state_read().unwrap_or_default();
                };
                method_invocation = quote! {
                    contract.#ident(#arg_list)
                };
                if matches!(method_type, &MethodType::Regular) {
                    contract_ser = quote! {
                        near_sdk::env::state_write(&contract);
                    };
                } else {
                    contract_ser = TokenStream2::new();
                }
            } else {
                contract_deser = TokenStream2::new();
                method_invocation = quote! {
                    #struct_type::#ident(#arg_list)
                };
                contract_ser = TokenStream2::new();
            }
            match returns {
                ReturnType::Default => quote! {
                    #contract_deser
                    #method_invocation;
                    #contract_ser
                },
                ReturnType::Type(_, _) => {
                    let value_ser = match result_serializer {
                        SerializerType::JSON => quote! {
                            let result = near_sdk::serde_json::to_vec(&result).expect("Failed to serialize the return value using JSON.");
                        },
                        SerializerType::Borsh => quote! {
                            let result = near_sdk::borsh::BorshSerialize::try_to_vec(&result).expect("Failed to serialize the return value using Borsh.");
                        },
                    };
                    quote! {
                    #contract_deser
                    let result = #method_invocation;
                    #value_ser
                    near_sdk::env::value_return(&result);
                    #contract_ser
                    }
                }
            }
        };
        let non_bindgen_attrs = non_bindgen_attrs
            .iter()
            .fold(TokenStream2::new(), |acc, value| {
                quote! {
                    #acc
                    #value
                }
            });
        quote! {
            #non_bindgen_attrs
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn #ident() {
                #panic_hook
                #is_private_check
                #deposit_check
                #arg_struct
                #arg_parsing
                #callback_deser
                #callback_vec_deser
                #body
            }
        }
    }

    pub fn marshal_method(&self) -> TokenStream2 {
        let ImplItemMethodInfo {
            attr_signature_info,
            ..
        } = self;
        let has_input_args = attr_signature_info.input_args().next().is_some();

        let pat_type_list = attr_signature_info.pat_type_list();
        let serialize_args = if has_input_args {
            match &attr_signature_info.input_serializer {
                SerializerType::Borsh => crate::TraitItemMethodInfo::generate_serialier(
                    attr_signature_info,
                    &attr_signature_info.input_serializer,
                ),
                SerializerType::JSON => json_serialize(attr_signature_info),
            }
        } else {
            quote! {
             let args = vec![];
            }
        };

        let AttrSigInfo {
            non_bindgen_attrs,
            ident,
            // receiver,
            // returns,
            // result_serializer,
            // is_init,
            method_type,
            original_sig,
            ..
        } = attr_signature_info;
        let return_ident = quote! { -> near_sdk::PendingContractTx };
        let params = quote! {
            &self, #pat_type_list
        };
        let ident_str = ident.to_string();
        let is_view = if matches!(method_type, MethodType::View) {
            quote! {true}
        } else {
            quote! {false}
        };

        let non_bindgen_attrs = non_bindgen_attrs
            .iter()
            .fold(TokenStream2::new(), |acc, value| {
                quote! {
                    #acc
                    #value
                }
            });
        let Signature { generics, .. } = original_sig;
        quote! {
            #[cfg(not(target_arch = "wasm32"))]
            #non_bindgen_attrs
            pub fn #ident#generics(#params) #return_ident {
                #serialize_args
                near_sdk::PendingContractTx::new_from_bytes(self.account_id.clone(), #ident_str, args, #is_view)
            }
        }
    }
}

fn json_serialize(attr_signature_info: &AttrSigInfo) -> TokenStream2 {
    let args: TokenStream2 = attr_signature_info
        .input_args()
        .fold(None, |acc: Option<TokenStream2>, value| {
            let ident = &value.ident;
            let ident_str = ident.to_string();
            Some(match acc {
                None => quote! { #ident_str: #ident },
                Some(a) => quote! { #a, #ident_str: #ident },
            })
        })
        .unwrap();
    quote! {
      let args = near_sdk::serde_json::json!({#args}).to_string().into_bytes();
    }
}

'''
'''--- scanner-syn/src/core_impl/code_generator/item_impl_info.rs ---
use crate::ItemImplInfo;
use proc_macro2::TokenStream as TokenStream2;
use syn::Ident;

impl ItemImplInfo {
    /// Generate the code that wraps
    pub fn wrapper_code(&self) -> TokenStream2 {
        let mut res = TokenStream2::new();
        for method in &self.methods {
            if method.is_public || self.is_trait_impl {
                res.extend(method.method_wrapper());
            }
        }
        res
    }

    pub fn marshall_code(&self) -> TokenStream2 {
        use quote::{format_ident, quote, ToTokens};
        let orig_name = self.ty.clone().into_token_stream();
        let mut name = quote! {Contract};
        if let Ok(input) = syn::parse::<Ident>(orig_name.into()) {
            let new_name = format_ident!("{}Contract", input);
            name = quote! {#new_name};
        };
        let mut res = TokenStream2::new();
        for method in &self.methods {
            if method.is_public || self.is_trait_impl {
                res.extend(method.marshal_method());
            }
        }
        quote! {
         #[cfg(not(target_arch = "wasm32"))]
         impl #name {
           #res
         }
        }
    }
}
// Rustfmt removes comas.
#[rustfmt::skip]
#[cfg(test)]
mod tests {
    use syn::{Type, ImplItemMethod, parse_quote};
    use quote::quote;
    use crate::core_impl::info_extractor::ImplItemMethodInfo;

    #[test]
    fn trait_implt() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("fn method(&self) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method, false, true, impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method();
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn no_args_no_return_no_mut() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("pub fn method(&self) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true, impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method();
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn owned_no_args_no_return_no_mut() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("pub fn method(self) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method, false, true, impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method();
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn mut_owned_no_args_no_return() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("pub fn method(mut self) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                let mut contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method();
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn no_args_no_return_mut() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("pub fn method(&mut self) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::attached_deposit() != 0 {
                    near_sdk::env::panic_str("Method method doesn't accept deposit");
                }
                let mut contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method();
                near_sdk::env::state_write(&contract);
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn arg_no_return_no_mut() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("pub fn method(&self, k: u64) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                #[derive(near_sdk :: serde :: Deserialize)]
                #[serde(crate = "near_sdk::serde")]
                struct Input {
                    k: u64,
                }
                let Input { k, }: Input = near_sdk::serde_json::from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from JSON.");
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method(k, );
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn args_no_return_mut() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod =
            syn::parse_str("pub fn method(&mut self, k: u64, m: Bar) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
                #[cfg(target_arch = "wasm32")]
                #[no_mangle]
                pub extern "C" fn method() {
                    near_sdk::env::setup_panic_hook();
                    if near_sdk::env::attached_deposit() != 0 {
                        near_sdk::env::panic_str("Method method doesn't accept deposit");
                    }
                    #[derive(near_sdk :: serde :: Deserialize)]
                    #[serde(crate = "near_sdk::serde")]
                    struct Input {
                        k: u64,
                        m: Bar,
                    }
                    let Input { k, m, }: Input = near_sdk::serde_json::from_slice(
                        &near_sdk::env::input().expect("Expected input since method has arguments.")
                    )
                    .expect("Failed to deserialize input from JSON.");
                    let mut contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                    contract.method(k, m, );
                    near_sdk::env::state_write(&contract);
                }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn args_return_mut() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod =
            syn::parse_str("pub fn method(&mut self, k: u64, m: Bar) -> Option<u64> { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
                #[cfg(target_arch = "wasm32")]
                #[no_mangle]
                pub extern "C" fn method() {
                    near_sdk::env::setup_panic_hook();
                    if near_sdk::env::attached_deposit() != 0 {
                        near_sdk::env::panic_str("Method method doesn't accept deposit");
                    }
                    #[derive(near_sdk :: serde :: Deserialize)]
                    #[serde(crate = "near_sdk::serde")]
                    struct Input {
                        k: u64,
                        m: Bar,
                    }
                    let Input { k, m, }: Input = near_sdk::serde_json::from_slice(
                        &near_sdk::env::input().expect("Expected input since method has arguments.")
                    )
                    .expect("Failed to deserialize input from JSON.");
                    let mut contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                    let result = contract.method(k, m, );
                    let result =
                        near_sdk::serde_json::to_vec(&result).expect("Failed to serialize the return value using JSON.");
                    near_sdk::env::value_return(&result);
                    near_sdk::env::state_write(&contract);
                }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn args_return_ref() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod =
            syn::parse_str("pub fn method(&self) -> &Option<u64> { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                let result = contract.method();
                let result =
                    near_sdk::serde_json::to_vec(&result).expect("Failed to serialize the return value using JSON.");
                near_sdk::env::value_return(&result);
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn arg_ref() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("pub fn method(&self, k: &u64) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
                #[cfg(target_arch = "wasm32")]
                #[no_mangle]
                pub extern "C" fn method() {
                    near_sdk::env::setup_panic_hook();
                    #[derive(near_sdk :: serde :: Deserialize)]
                    #[serde(crate = "near_sdk::serde")]
                    struct Input {
                        k: u64,
                    }
                    let Input { k, }: Input = near_sdk::serde_json::from_slice(
                        &near_sdk::env::input().expect("Expected input since method has arguments.")
                    )
                    .expect("Failed to deserialize input from JSON.");
                    let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                    contract.method(&k, );
                }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn arg_mut_ref() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod =
            syn::parse_str("pub fn method(&self, k: &mut u64) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                #[derive(near_sdk :: serde :: Deserialize)]
                #[serde(crate = "near_sdk::serde")]
                struct Input {
                    k: u64,
                }
                let Input { mut k, }: Input = near_sdk::serde_json::from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from JSON.");
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method(&mut k, );
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn callback_args() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[private] pub fn method(&self, #[callback_unwrap] x: &mut u64, y: String, #[callback_unwrap] z: Vec<u8>) { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
                    near_sdk::env::panic_str("Method method is private");
                }
                #[derive(near_sdk :: serde :: Deserialize)]
                #[serde(crate = "near_sdk::serde")]
                struct Input {
                    y: String,
                }
                let Input { y, }: Input = near_sdk::serde_json::from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from JSON.");
                let data: Vec<u8> = match near_sdk::env::promise_result(0u64) {
                    near_sdk::PromiseResult::Successful(x) => x,
                    _ => near_sdk::env::panic_str("Callback computation 0 was not successful")
                };
                let mut x: u64 =
                    near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON");
                let data: Vec<u8> = match near_sdk::env::promise_result(1u64) {
                    near_sdk::PromiseResult::Successful(x) => x,
                    _ => near_sdk::env::panic_str("Callback computation 1 was not successful")
                };
                let z: Vec<u8> =
                    near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON");
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method(&mut x, y, z, );
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn callback_args_only() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[private] pub fn method(&self, #[callback_unwrap] x: &mut u64, #[callback_unwrap] y: String) { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
                    near_sdk::env::panic_str("Method method is private");
                }
                let data: Vec<u8> = match near_sdk::env::promise_result(0u64) {
                    near_sdk::PromiseResult::Successful(x) => x,
                    _ => near_sdk::env::panic_str("Callback computation 0 was not successful")
                };
                let mut x: u64 =
                    near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON");
                let data: Vec<u8> = match near_sdk::env::promise_result(1u64) {
                    near_sdk::PromiseResult::Successful(x) => x,
                    _ => near_sdk::env::panic_str("Callback computation 1 was not successful")
                };
                let y: String =
                    near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON");
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method(&mut x, y, );
            }
        );

        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn callback_args_results() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[private] pub fn method(&self, #[callback_result] x: &mut Result<u64, PromiseError>, #[callback_result] y: Result<String, PromiseError>) { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
                    near_sdk::env::panic_str("Method method is private");
                }
                let mut x: Result<u64, PromiseError> = match near_sdk::env::promise_result(0u64) {
                    near_sdk::PromiseResult::Successful(data) => Ok(near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON")),
                    near_sdk::PromiseResult::NotReady => Err(near_sdk::PromiseError::NotReady),
                    near_sdk::PromiseResult::Failed => Err(near_sdk::PromiseError::Failed),
                };
                let y: Result<String, PromiseError> = match near_sdk::env::promise_result(1u64) {
                    near_sdk::PromiseResult::Successful(data) => Ok(near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON")),
                    near_sdk::PromiseResult::NotReady => Err(near_sdk::PromiseError::NotReady),
                    near_sdk::PromiseResult::Failed => Err(near_sdk::PromiseError::Failed),
                };
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method(&mut x, y, );
            }
        );

        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn callback_args_vec() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[private] pub fn method(&self, #[callback_vec] x: Vec<String>, y: String) { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
                    near_sdk::env::panic_str("Method method is private");
                }
                #[derive(near_sdk :: serde :: Deserialize)]
                #[serde(crate = "near_sdk::serde")]
                struct Input {
                    y: String,
                }
                let Input { y, }: Input = near_sdk::serde_json::from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from JSON.");
                let x: Vec<String> = (0..near_sdk::env::promise_results_count())
                    .map(|i| {
                        let data: Vec<u8> = match near_sdk::env::promise_result(i) {
                            near_sdk::PromiseResult::Successful(x) => x,
                            _ => near_sdk::env::panic_str(&format!("Callback computation {} was not successful", i)),
                        };
                        near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON")
                    })
                    .collect();
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method(x, y, );
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn simple_init() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[init]
            pub fn method(k: &mut u64) -> Self { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::attached_deposit() != 0 {
                    near_sdk::env::panic_str("Method method doesn't accept deposit");
                }
                #[derive(near_sdk :: serde :: Deserialize)]
                #[serde(crate = "near_sdk::serde")]
                struct Input {
                    k: u64,
                }
                let Input { mut k, }: Input = near_sdk::serde_json::from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from JSON.");
                if near_sdk::env::state_exists() {
                    near_sdk::env::panic_str("The contract has already been initialized");
                }
                let contract = Hello::method(&mut k,);
                near_sdk::env::state_write(&contract);
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn init_no_return() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[init]
            pub fn method(k: &mut u64) { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            compile_error! { "Init methods must return the contract state" }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn init_ignore_state() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[init(ignore_state)]
            pub fn method(k: &mut u64) -> Self { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::attached_deposit() != 0 {
                    near_sdk::env::panic_str("Method method doesn't accept deposit");
                }
                #[derive(near_sdk :: serde :: Deserialize)]
                #[serde(crate = "near_sdk::serde")]
                struct Input {
                    k: u64,
                }
                let Input { mut k, }: Input = near_sdk::serde_json::from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from JSON.");
                let contract = Hello::method(&mut k,);
                near_sdk::env::state_write(&contract);
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn init_payable() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[init]
            #[payable]
            pub fn method(k: &mut u64) -> Self { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                #[derive(near_sdk :: serde :: Deserialize)]
                #[serde(crate = "near_sdk::serde")]
                struct Input {
                    k: u64,
                }
                let Input { mut k, }: Input = near_sdk::serde_json::from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from JSON.");
                if near_sdk::env::state_exists() {
                    near_sdk::env::panic_str("The contract has already been initialized");
                }
                let contract = Hello::method(&mut k,);
                near_sdk::env::state_write(&contract);
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn args_return_mut_borsh() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[result_serializer(borsh)]
            pub fn method(&mut self, #[serializer(borsh)] k: u64, #[serializer(borsh)]m: Bar) -> Option<u64> { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::attached_deposit() != 0 {
                    near_sdk::env::panic_str("Method method doesn't accept deposit");
                }
                #[derive(near_sdk :: borsh :: BorshDeserialize)]
                struct Input {
                    k: u64,
                    m: Bar,
                }
                let Input { k, m, }: Input = near_sdk::borsh::BorshDeserialize::try_from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from Borsh.");
                let mut contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                let result = contract.method(k, m, );
                let result = near_sdk::borsh::BorshSerialize::try_to_vec(&result)
                    .expect("Failed to serialize the return value using Borsh.");
                near_sdk::env::value_return(&result);
                near_sdk::env::state_write(&contract);
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn callback_args_mixed_serialization() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = parse_quote! {
            #[private] pub fn method(&self, #[callback_unwrap] #[serializer(borsh)] x: &mut u64, #[serializer(borsh)] y: String, #[callback_unwrap] #[serializer(json)] z: Vec<u8>) { }
        };
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
                    near_sdk::env::panic_str("Method method is private");
                }
                #[derive(near_sdk :: borsh :: BorshDeserialize)]
                struct Input {
                    y: String,
                }
                let Input { y, }: Input = near_sdk::borsh::BorshDeserialize::try_from_slice(
                    &near_sdk::env::input().expect("Expected input since method has arguments.")
                )
                .expect("Failed to deserialize input from Borsh.");
                let data: Vec<u8> = match near_sdk::env::promise_result(0u64) {
                    near_sdk::PromiseResult::Successful(x) => x,
                    _ => near_sdk::env::panic_str("Callback computation 0 was not successful")
                };
                let mut x: u64 = near_sdk::borsh::BorshDeserialize::try_from_slice(&data)
                    .expect("Failed to deserialize callback using Borsh");
                let data: Vec<u8> = match near_sdk::env::promise_result(1u64) {
                    near_sdk::PromiseResult::Successful(x) => x,
                    _ => near_sdk::env::panic_str("Callback computation 1 was not successful")
                };
                let z: Vec<u8> =
                    near_sdk::serde_json::from_slice(&data).expect("Failed to deserialize callback using JSON");
                let contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method(&mut x, y, z, );
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn no_args_no_return_mut_payable() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("#[payable] pub fn method(&mut self) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn method() {
                near_sdk::env::setup_panic_hook();
                let mut contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.method();
                near_sdk::env::state_write(&contract);
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn private_method() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("#[private] pub fn private_method(&mut self) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.method_wrapper();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn private_method() {
                near_sdk::env::setup_panic_hook();
                if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
                    near_sdk::env::panic_str("Method private_method is private");
                }
                if near_sdk::env::attached_deposit() != 0 {
                    near_sdk::env::panic_str("Method private_method doesn't accept deposit");
                }
                let mut contract: Hello = near_sdk::env::state_read().unwrap_or_default();
                contract.private_method();
                near_sdk::env::state_write(&contract);
            }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn marshall_one_arg() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str("pub fn method(&self, k: String) { }").unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,  false, true,impl_type).unwrap();
        let actual = method_info.marshal_method();
        let expected = quote!(
                #[cfg(not(target_arch = "wasm32"))]
                pub fn method(&self, k: String,) -> near_sdk::PendingContractTx {
                  let args = near_sdk::serde_json::json!({ "k": k })
                  .to_string()
                  .into_bytes();
                  near_sdk::PendingContractTx::new_from_bytes(self.account_id.clone(), "method", args, true)
                }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }

    #[test]
    fn marshall_borsh() {
        let impl_type: Type = syn::parse_str("Hello").unwrap();
        let mut method: ImplItemMethod = syn::parse_str(r#"
          pub fn borsh_test(&mut self, #[serializer(borsh)] a: String) {}
        "#).unwrap();
        let method_info = ImplItemMethodInfo::new(&mut method,false, true,impl_type).unwrap();
        let actual = method_info.marshal_method();
        let expected = quote!(
                #[cfg(not(target_arch = "wasm32"))]
                pub fn borsh_test(&self, a: String,) -> near_sdk::PendingContractTx {
                  #[derive(near_sdk :: borsh :: BorshSerialize)]
                  struct Input {
                      a: String,
                  }
                  let args = Input { a, };
                  let args = near_sdk::borsh::BorshSerialize::try_to_vec(&args)
                      .expect("Failed to serialize the cross contract args using Borsh.");
                  near_sdk::PendingContractTx::new_from_bytes(self.account_id.clone(), "borsh_test", args, false)
                }
        );
        assert_eq!(expected.to_string(), actual.to_string());
    }
}

'''
'''--- scanner-syn/src/core_impl/code_generator/item_struct_info.rs ---
use syn::ItemStruct;

pub fn generate_proxy_struct(input: &ItemStruct) -> proc_macro2::TokenStream {
    use quote::{format_ident, quote};
    let ident = &input.ident;
    let new_name = format_ident!("{}Contract", ident);
    let name = quote! {#new_name};
    quote! {
         #[cfg(not(target_arch = "wasm32"))]
         pub struct #name {
            pub account_id: near_sdk::AccountId,
          }
    }
}

'''
'''--- scanner-syn/src/core_impl/code_generator/item_trait_info.rs ---
use crate::core_impl::info_extractor::ItemTraitInfo;
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;

impl ItemTraitInfo {
    /// Generate code that wrapps external calls.
    pub fn wrapped_module(&self) -> TokenStream2 {
        let mut result = TokenStream2::new();
        for method in &self.methods {
            result.extend(method.method_wrapper());
        }
        let mod_name = &self.mod_name;
        quote! {
           pub mod #mod_name {
                use super::*;
                use near_sdk::{Gas, Balance, AccountId, Promise};
                #result
            }
        }
    }
}

// Rustfmt removes comas.
#[rustfmt::skip]
#[cfg(test)]
mod tests {
    use syn::ItemTrait;
    use quote::quote;
    use crate::core_impl::info_extractor::ItemTraitInfo;

    #[test]
    fn standard() {
        let mut t: ItemTrait = syn::parse2(
            quote!{
                    pub trait ExternalCrossContract {
                        fn merge_sort(&self, arr: Vec<u8>) -> PromiseOrValue<Vec<u8>>;
                        fn merge(
                            &self,
                            #[callback_unwrap]
                            #[serializer(borsh)]
                            data0: Vec<u8>,
                            #[callback_unwrap]
                            #[serializer(borsh)]
                            data1: Vec<u8>,
                        ) -> Vec<u8>;
                    }
            }
        ).unwrap();
        let info = ItemTraitInfo::new(&mut t, None).unwrap();
        let actual = info.wrapped_module();

        let expected = quote! {
            pub mod external_cross_contract {
                use super::*;
                use near_sdk::{Gas, Balance, AccountId, Promise};
                pub fn merge_sort(
                    arr: Vec<u8>,
                    __account_id: AccountId,
                    __balance: near_sdk::Balance,
                    __gas: near_sdk::Gas
                ) -> near_sdk::Promise {
                    #[derive(near_sdk :: serde :: Serialize)]
                    #[serde(crate = "near_sdk::serde")]
                    struct Input {
                        arr: Vec<u8>,
                    }
                    let args = Input { arr, };
                    let args = near_sdk::serde_json::to_vec(&args)
                        .expect("Failed to serialize the cross contract args using JSON.");
                    near_sdk::Promise::new(__account_id).function_call(
                        "merge_sort".to_string(),
                        args,
                        __balance,
                        __gas,
                    )
                }
                pub fn merge(__account_id: AccountId, __balance: near_sdk::Balance, __gas: near_sdk::Gas) -> near_sdk::Promise {
                    let args = vec![];
                    near_sdk::Promise::new(__account_id).function_call(
                        "merge".to_string(),
                        args,
                        __balance,
                        __gas,
                    )
                }
            }
        };
        assert_eq!(actual.to_string(), expected.to_string());
    }

    #[test]
    fn serialize_with_borsh() {
        let mut t: ItemTrait = syn::parse2(
            quote!{
              trait TestExt {
                #[result_serializer(borsh)]
                fn test(#[serializer(borsh)] v: Vec<String>) -> Vec<String>;
              }
            }
        ).unwrap();
        let info = ItemTraitInfo::new(&mut t, None).unwrap();
        let actual = info.wrapped_module();

        let expected = quote! {
          pub mod test_ext {
            use super::*;
            use near_sdk::{Gas, Balance, AccountId, Promise};
            pub fn test(
                v: Vec<String>,
                __account_id: AccountId,
                __balance: near_sdk::Balance,
                __gas: near_sdk::Gas
            ) -> near_sdk::Promise {
                #[derive(near_sdk :: borsh :: BorshSerialize)]
                struct Input {
                    v: Vec<String>,
                }
                let args = Input { v, };
                let args = near_sdk::borsh::BorshSerialize::try_to_vec(&args)
                    .expect("Failed to serialize the cross contract args using Borsh.");
                near_sdk::Promise::new(__account_id).function_call(
                    "test".to_string(),
                    args,
                    __balance,
                    __gas,
                )
            }
        }
        };
        assert_eq!(actual.to_string(), expected.to_string());
    }
}

'''
'''--- scanner-syn/src/core_impl/code_generator/mod.rs ---
mod attr_sig_info;
pub use attr_sig_info::*;

mod impl_item_method_info;
pub use impl_item_method_info::*;

mod item_trait_info;
pub use item_trait_info::*;

mod trait_item_method_info;
pub use trait_item_method_info::*;

mod item_impl_info;
pub use item_impl_info::*;

mod item_struct_info;
pub use item_struct_info::*;

'''
'''--- scanner-syn/src/core_impl/code_generator/trait_item_method_info.rs ---
use crate::core_impl::{
    info_extractor::{InputStructType, SerializerType, TraitItemMethodInfo},
    AttrSigInfo,
};
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;

impl TraitItemMethodInfo {
    /// Generate code that wraps the method.
    pub fn method_wrapper(&self) -> TokenStream2 {
        let ident = &self.attr_sig_info.ident;
        let ident_byte_str = &self.ident_byte_str;
        let pat_type_list = self.attr_sig_info.pat_type_list();
        let serialize = TraitItemMethodInfo::generate_serialier(
            &self.attr_sig_info,
            &self.attr_sig_info.result_serializer,
        );
        quote! {
            pub fn #ident(#pat_type_list __account_id: AccountId, __balance: near_sdk::Balance, __gas: near_sdk::Gas) -> near_sdk::Promise {
                #serialize
                near_sdk::Promise::new(__account_id)
                .function_call(
                    #ident_byte_str.to_string(),
                    args,
                    __balance,
                    __gas,
                )
            }
        }
    }

    pub fn generate_serialier(
        attr_sig_info: &AttrSigInfo,
        serializer: &SerializerType,
    ) -> TokenStream2 {
        let has_input_args = attr_sig_info.input_args().next().is_some();
        if !has_input_args {
            return quote! { let args = vec![]; };
        }
        let struct_decl = attr_sig_info.input_struct(InputStructType::Serialization);
        let constructor_call = attr_sig_info.constructor_expr();
        let constructor = quote! { let args = #constructor_call; };
        let value_ser = match serializer {
            SerializerType::JSON => quote! {
                let args = near_sdk::serde_json::to_vec(&args).expect("Failed to serialize the cross contract args using JSON.");
            },
            SerializerType::Borsh => quote! {
                let args = near_sdk::borsh::BorshSerialize::try_to_vec(&args).expect("Failed to serialize the cross contract args using Borsh.");
            },
        };

        quote! {
          #struct_decl
          #constructor
          #value_ser
        }
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/arg_info.rs ---
use crate::core_impl::info_extractor::serializer_attr::SerializerAttr;
use crate::core_impl::info_extractor::SerializerType;
use quote::ToTokens;
use syn::{spanned::Spanned, Attribute, Error, Ident, Pat, PatType, Token, Type};

pub enum BindgenArgType {
    /// Argument that we read from `env::input()`.
    Regular,
    /// An argument that we read from a single `env::promise_result()`.
    CallbackArg,
    /// An argument that we read from a single `env::promise_result()` which handles the error.
    CallbackResultArg,
    /// An argument that we read from all `env::promise_result()`.
    CallbackArgVec,
}

/// A single argument of a function after it was processed by the bindgen.
pub struct ArgInfo {
    /// Attributes not related to bindgen.
    pub non_bindgen_attrs: Vec<Attribute>,
    /// The `binding` part of `ref mut binding @ SUBPATTERN: TYPE` argument.
    pub ident: Ident,
    /// Whether pattern has a preceded `ref`.
    pub pat_reference: Option<Token![ref]>,
    /// Whether pattern has a preceded `mut`.
    pub pat_mutability: Option<Token![mut]>,
    /// Whether the `TYPE` starts with `&`.
    pub reference: Option<Token![&]>,
    /// Whether `TYPE` starts with `&mut`. Can only be set together with the `reference`.
    pub mutability: Option<Token![mut]>,
    /// The `TYPE` stripped of `&` and `mut`.
    pub ty: Type,
    /// Bindgen classification of argument type, based on what attributes it has.
    pub bindgen_ty: BindgenArgType,
    /// Type of serializer that we use for this argument.
    pub serializer_ty: SerializerType,
    /// The original `PatType` of the argument.
    pub original: PatType,
}

impl ArgInfo {
    /// Extract near-sdk specific argument info.
    pub fn new(original: &mut PatType) -> syn::Result<Self> {
        let mut non_bindgen_attrs = vec![];
        let pat_reference;
        let pat_mutability;
        let ident;
        match original.pat.as_ref() {
            Pat::Ident(pat_ident) => {
                pat_reference = pat_ident.by_ref;
                pat_mutability = pat_ident.mutability;
                ident = pat_ident.ident.clone();
            }
            _ => {
                return Err(Error::new(
                    original.span(),
                    "Only identity patterns are supported in function arguments.",
                ));
            }
        };
        let (reference, mutability, ty) = match original.ty.as_ref() {
            x @ Type::Array(_) | x @ Type::Path(_) | x @ Type::Tuple(_) => {
                (None, None, (*x).clone())
            }
            Type::Reference(r) => (Some(r.and_token), r.mutability, (*r.elem.as_ref()).clone()),
            _ => return Err(Error::new(original.span(), "Unsupported argument type.")),
        };
        // In the absence of callback attributes this is a regular argument.
        let mut bindgen_ty = BindgenArgType::Regular;
        // In the absence of serialization attributes this is a JSON serialization.
        let mut serializer_ty = SerializerType::JSON;
        for attr in &mut original.attrs {
            let attr_str = attr.path.to_token_stream().to_string();
            match attr_str.as_str() {
                "callback" | "callback_unwrap" => {
                    bindgen_ty = BindgenArgType::CallbackArg;
                }
                "callback_result" => {
                    bindgen_ty = BindgenArgType::CallbackResultArg;
                }
                "callback_vec" => {
                    bindgen_ty = BindgenArgType::CallbackArgVec;
                }
                "serializer" => {
                    let serializer: SerializerAttr = syn::parse2(attr.tokens.clone())?;
                    serializer_ty = serializer.serializer_type;
                }
                _ => {
                    non_bindgen_attrs.push((*attr).clone());
                }
            }
        }

        original.attrs.retain(|attr| {
            let attr_str = attr.path.to_token_stream().to_string();
            attr_str != "callback"
                && attr_str != "callback_vec"
                && attr_str != "serializer"
                && attr_str != "callback_result"
                && attr_str != "callback_unwrap"
        });

        Ok(Self {
            non_bindgen_attrs,
            ident,
            pat_reference,
            pat_mutability,
            reference,
            mutability,
            ty,
            bindgen_ty,
            serializer_ty,
            original: original.clone(),
        })
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/attr_sig_info.rs ---
use super::{ArgInfo, BindgenArgType, InitAttr, MethodType, SerializerAttr, SerializerType};
use proc_macro2::Span;
use quote::ToTokens;
use syn::spanned::Spanned;
use syn::{Attribute, Error, FnArg, Ident, Receiver, ReturnType, Signature};

/// Information extracted from method attributes and signature.
pub struct AttrSigInfo {
    /// The name of the method.
    pub ident: Ident,
    /// Attributes not related to bindgen.
    pub non_bindgen_attrs: Vec<Attribute>,
    /// All arguments of the method.
    pub args: Vec<ArgInfo>,
    /// Describes the type of the method.
    pub method_type: MethodType,
    /// Whether method accepting $NEAR.
    pub is_payable: bool,
    ///Whether method is test method
    pub is_test:bool,
    /// Whether method can accept calls from self (current account)
    pub is_private: bool,
    /// The serializer that we use for `env::input()`.
    pub input_serializer: SerializerType,
    /// The serializer that we use for the return type.
    pub result_serializer: SerializerType,
    /// The receiver, like `mut self`, `self`, `&mut self`, `&self`, or `None`.
    pub receiver: Option<Receiver>,
    /// What this function returns.
    pub returns: ReturnType,
    /// The original method signature.
    pub original_sig: Signature,
}

impl AttrSigInfo {
    /// Process the method and extract information important for near-sdk.
    pub fn new(
        original_attrs: &mut Vec<Attribute>,
        original_sig: &mut Signature,
    ) -> syn::Result<Self> {
        if original_sig.asyncness.is_some() {
            return Err(Error::new(
                original_sig.span(),
                "Contract API is not allowed to be async.",
            ));
        }
        if original_sig.abi.is_some() {
            return Err(Error::new(
                original_sig.span(),
                "Contract API is not allowed to have binary interface.",
            ));
        }
        if original_sig.variadic.is_some() {
            return Err(Error::new(
                original_sig.span(),
                "Contract API is not allowed to have variadic arguments.",
            ));
        }

        let ident = original_sig.ident.clone();
        let mut non_bindgen_attrs = vec![];
        let mut args = vec![];
        let mut method_type = MethodType::Regular;
        let mut is_payable = false;
        let mut is_private = false;
        let mut is_test = false;

        // By the default we serialize the result with JSON.
        let mut result_serializer = SerializerType::JSON;

        let mut payable_attr = None;
        for attr in original_attrs.iter() {

            let attr_str = attr.path.to_token_stream().to_string();
                             

            match attr_str.as_str() {
                "init" => {
                    let init_attr: InitAttr = syn::parse2(attr.tokens.clone())?;
                    if init_attr.ignore_state {
                        method_type = MethodType::InitIgnoreState;
                    } else {
                        method_type = MethodType::Init;
                    }
                }
                "payable" => {
                    payable_attr = Some(attr);
                    is_payable = true;
                }
                "private" => {
                    is_private = true;
                }
                "test"=>{
                    is_test=true;
                }
                "result_serializer" => {
                    let serializer: SerializerAttr = syn::parse2(attr.tokens.clone())?;
                    result_serializer = serializer.serializer_type;
                }
                _ => {
                    non_bindgen_attrs.push((*attr).clone());
                }
            }
        }

        let mut receiver = None;
        for fn_arg in &mut original_sig.inputs {
            match fn_arg {
                FnArg::Receiver(r) => receiver = Some((*r).clone()),
                FnArg::Typed(pat_typed) => {
                    args.push(ArgInfo::new(pat_typed)?);
                }
            }
        }

        if let Some(ref receiver) = receiver {
            if matches!(method_type, MethodType::Regular) {
                if receiver.mutability.is_none() || receiver.reference.is_none() {
                    method_type = MethodType::View;
                }
            } else {
                return Err(Error::new(
                    payable_attr.span(),
                    "Init methods can't have `self` attribute",
                ));
            }
        };

        if let Some(payable_attr) = payable_attr {
            if matches!(method_type, MethodType::View) {
                return Err(Error::new(
                    payable_attr.span(),
                    "Payable method must be mutable (not view)",
                ));
            }
        }

        *original_attrs = non_bindgen_attrs.clone();
        let returns = original_sig.output.clone();

        let mut result = Self {
            ident,
            non_bindgen_attrs,
            args,
            input_serializer: SerializerType::JSON,
            method_type,
            is_payable,
            is_private,
            is_test,
            result_serializer,
            receiver,
            returns,
            original_sig: original_sig.clone(),
        };

        let input_serializer = if result
            .input_args()
            .all(|arg: &ArgInfo| arg.serializer_ty == SerializerType::JSON)
        {
            SerializerType::JSON
        } else if result
            .input_args()
            .all(|arg| arg.serializer_ty == SerializerType::Borsh)
        {
            SerializerType::Borsh
        } else {
            return Err(Error::new(
                Span::call_site(),
                "Input arguments should be all of the same serialization type.",
            ));
        };
        result.input_serializer = input_serializer;
           
        Ok(result)
    }

    /// Only get args that correspond to `env::input()`.
    pub fn input_args(&self) -> impl Iterator<Item = &ArgInfo> {
        self.args
            .iter()
            .filter(|arg| matches!(arg.bindgen_ty, BindgenArgType::Regular))
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/impl_item_method_info.rs ---
use crate::core_impl::info_extractor::AttrSigInfo;
use syn::{ImplItemMethod, Type, Visibility};

/// Information extracted from `ImplItemMethod`.
pub struct ImplItemMethodInfo {
    /// Information on the attributes and the signature of the method.
    pub attr_signature_info: AttrSigInfo,
    /// Whether method has `pub` modifier.
    pub is_public: bool,
    /// Whether method is part of trait implementation.
    pub is_trait_impl: bool,
    /// Whether method is part of `impl` section decorated with `#[near_bindgen]`
    pub has_near_sdk_attr: bool,
    /// The type of the contract struct.
    pub struct_type: Type,
}

impl ImplItemMethodInfo {
    /// Process the method and extract information important for near-sdk.
    pub fn new(
        original: &mut ImplItemMethod,
        is_trait_impl: bool,
        has_near_sdk_attr: bool,
        struct_type: Type,
    ) -> syn::Result<Self> {
        let ImplItemMethod { attrs, sig, .. } = original;
        // TODO:
        // let mut functions_called = vec![];
        // statements_parser::parse_statements(&block.stmts, &mut functions_called);
        let attr_signature_info = AttrSigInfo::new(attrs, sig)?;
        let is_public = matches!(original.vis, Visibility::Public(_));
        Ok(Self {
            attr_signature_info,
            is_public,
            is_trait_impl,
            has_near_sdk_attr,
            struct_type,
        })
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/init_attr.rs ---
use proc_macro2::Ident;
use syn::parse::{Parse, ParseStream};
use syn::token::Paren;
use syn::Error;

pub struct InitAttr {
    pub ignore_state: bool,
}

impl Parse for InitAttr {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let ignore_state = if input.peek(Paren) {
            let content;
            let _paren_token = syn::parenthesized!(content in input);
            let ident: Ident = content.parse()?;
            match ident.to_string().as_str() {
                "ignore_state" => true,
                _ => return Err(Error::new(input.span(), "Unsupported init attribute.")),
            }
        } else {
            false
        };
        Ok(Self { ignore_state })
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/item_fn_info.rs ---
use crate::core_impl::info_extractor::AttrSigInfo;
use syn::ItemFn;

/// Information extracted from `ItemFn`.
pub struct ItemFnInfo {
    /// Information on the attributes and the signature of the function.
    pub attr_signature_info: AttrSigInfo,
}

impl ItemFnInfo {
    /// Process the function and extract important information.
    pub fn new(original: &mut ItemFn) -> syn::Result<Self> {
        let x = AttrSigInfo::new(&mut original.attrs, &mut original.sig)?;
        Ok(Self {
            attr_signature_info: x,
        })
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/item_impl_info.rs ---
use crate::ImplItemMethodInfo;
use syn::spanned::Spanned;
use syn::{Error, ImplItem, ItemImpl, Type};

/// Information extracted from `impl` section.
pub struct ItemImplInfo {
    /// Whether this is a trait implementation.
    pub is_trait_impl: bool,
    /// Whether `impl` section decorated with `#[near_bindgen]`
    pub has_near_sdk_attr: bool,
    /// The type for which this `impl` is written.
    pub ty: Type,
    /// Info extracted for each method.
    pub methods: Vec<ImplItemMethodInfo>,
}

impl ItemImplInfo {
    pub fn new(original: &mut ItemImpl, has_near_sdk_attr: bool) -> syn::Result<Self> {
        if !original.generics.params.is_empty() {
            return Err(Error::new(
                original.generics.params.span(),
                "Impl type parameters are not supported for smart contracts.",
            ));
        }
        let is_trait_impl = original.trait_.is_some();
        let ty = (*original.self_ty.as_ref()).clone();

        let mut methods = vec![];
        for subitem in &mut original.items {
            if let ImplItem::Method(m) = subitem {
                let method_info =
                    ImplItemMethodInfo::new(m, is_trait_impl, has_near_sdk_attr, ty.clone())?;
                methods.push(method_info);
            }
        }
        Ok(Self {
            is_trait_impl,
            has_near_sdk_attr,
            ty,
            methods,
        })
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/item_trait_info.rs ---
use super::TraitItemMethodInfo;
use inflector::Inflector;
use syn::spanned::Spanned;
use syn::{Error, Ident, ItemTrait, TraitItem};

/// Information extracted from `ItemTrait`.
pub struct ItemTraitInfo {
    /// The name of the module that will be used to generate the module.
    pub mod_name: Ident,
    /// Information extracted from the methods.
    pub methods: Vec<TraitItemMethodInfo>,
    /// The original AST.
    pub original: ItemTrait,
}

impl ItemTraitInfo {
    pub fn new(original: &mut ItemTrait, mod_name_override: Option<Ident>) -> syn::Result<Self> {
        let mod_name = mod_name_override.unwrap_or({
            let res = original.ident.to_string().to_snake_case();
            Ident::new(&res, original.span())
        });

        let mut methods = vec![];
        for item in &mut original.items {
            match item {
                TraitItem::Type(_) => {
                    return Err(Error::new(
                        item.span(),
                        "Traits for external contracts do not support associated trait types yet.",
                    ))
                }
                TraitItem::Method(method) => {
                    methods.push(TraitItemMethodInfo::new(method)?);
                    if method.default.is_some() {
                        return Err(Error::new(
                            method.span(),
                            "Traits that are used to describe external contract should not include
                             default implementations because this is not a valid use case of traits
                             to describe external contracts.",
                        ));
                    }
                }
                _ => {}
            }
        }
        Ok(Self {
            original: original.clone(),
            mod_name,
            methods,
        })
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/mod.rs ---
mod serializer_attr;
pub use serializer_attr::SerializerAttr;

mod arg_info;
pub use arg_info::{ArgInfo, BindgenArgType};

mod attr_sig_info;
pub use attr_sig_info::AttrSigInfo;

mod impl_item_method_info;
pub use impl_item_method_info::ImplItemMethodInfo;

mod trait_item_method_info;
pub use trait_item_method_info::*;

mod item_trait_info;
pub use item_trait_info::ItemTraitInfo;

mod item_impl_info;

mod item_fn_info;
pub use item_fn_info::*;

mod init_attr;
pub use init_attr::InitAttr;

mod statements_parser;
pub use statements_parser::parse_statements;

pub use item_impl_info::ItemImplInfo;

/// Type of serialization we use.
#[derive(PartialEq, Eq)]
#[allow(clippy::upper_case_acronyms)]
pub enum SerializerType {
    JSON,
    Borsh,
}

/// Type of the method.
#[derive(PartialEq, Eq)]
pub enum MethodType {
    Regular,
    View,
    Init,
    InitIgnoreState,
}

/// Whether the input struct is used for serialization or deserialization.
#[derive(PartialEq, Eq)]
pub enum InputStructType {
    Serialization,
    Deserialization,
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/serializer_attr.rs ---
use super::SerializerType;
use proc_macro2::Ident;
use syn::parse::{Parse, ParseStream};
use syn::{parenthesized, Error};

pub struct SerializerAttr {
    #[allow(dead_code)]
    paren_token: syn::token::Paren,
    pub serializer_type: SerializerType,
}

impl Parse for SerializerAttr {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let content;
        let paren_token = parenthesized!(content in input);
        let ident: Ident = content.parse()?;
        let serializer_type = match ident.to_string().as_str() {
            "borsh" => SerializerType::Borsh,
            "json" => SerializerType::JSON,
            _ => return Err(Error::new(input.span(), "Unsupported serializer type.")),
        };
        Ok(Self {
            paren_token,
            serializer_type,
        })
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/statements_parser.rs ---
use syn::{Expr, Ident, Stmt};

// Extracting information from statements of block
pub fn parse_statements(stmts: &[Stmt], functions_called: &mut Vec<Ident>) {
    for st in stmts {
        match st {
            Stmt::Local(l) => {
                if let Some((_, expr)) = &l.init {
                    parse_expr(expr.as_ref(), functions_called);
                }
            }
            Stmt::Item(it) => parse_item(it, functions_called),
            Stmt::Expr(expr) => parse_expr(expr, functions_called),
            Stmt::Semi(_, _) => todo!(),
        }
    }
}

fn parse_item(it: &syn::Item, functions_called: &mut Vec<Ident>) {
    match it {
        syn::Item::Const(c) => parse_expr(c.expr.as_ref(), functions_called),
        syn::Item::Static(s) => parse_expr(s.expr.as_ref(), functions_called),
        syn::Item::Fn(_) => todo!(), // TODO: discuss if we show it in diagram
        // TODO: probably skip those:
        syn::Item::ForeignMod(_) => todo!(),
        syn::Item::Mod(_) => todo!(),

        syn::Item::Enum(_)
        | syn::Item::ExternCrate(_)
        | syn::Item::Impl(_)
        | syn::Item::Macro(_)
        | syn::Item::Macro2(_)
        | syn::Item::Struct(_)
        | syn::Item::Trait(_)
        | syn::Item::TraitAlias(_)
        | syn::Item::Type(_)
        | syn::Item::Union(_)
        | syn::Item::Use(_)
        | syn::Item::Verbatim(_) => {}
        _ => {}
    }
}

fn parse_expr(expr: &Expr, functions_called: &mut Vec<Ident>) {
    match expr {
        syn::Expr::Array(_) => todo!(),
        syn::Expr::Assign(_) => todo!(),
        syn::Expr::AssignOp(_) => todo!(),
        syn::Expr::Async(_) => todo!(),
        syn::Expr::Await(_) => todo!(),
        syn::Expr::Binary(_) => todo!(),
        syn::Expr::Block(b) => {
            parse_statements(&b.block.stmts, functions_called);
        }
        syn::Expr::Box(_) => todo!(),
        syn::Expr::Break(_) => todo!(),

        // TODO: Kinda hard, can get even more complex,
        // if we try to check use(in cases of functions with same name from different modules/impls/etc)
        syn::Expr::Call(c) => todo!(),

        syn::Expr::Cast(_) => todo!(),
        syn::Expr::Closure(_) => todo!(),
        syn::Expr::Continue(_) => todo!(),
        syn::Expr::Field(_) => todo!(),
        syn::Expr::ForLoop(_) => todo!(),
        syn::Expr::Group(_) => todo!(),
        syn::Expr::If(_) => todo!(),
        syn::Expr::Index(_) => todo!(),
        syn::Expr::Let(_) => todo!(),
        syn::Expr::Lit(_) => todo!(),
        syn::Expr::Loop(_) => todo!(),
        syn::Expr::Macro(_) => todo!(),
        syn::Expr::Match(_) => todo!(),
        syn::Expr::MethodCall(_) => todo!(),
        syn::Expr::Paren(_) => todo!(),
        syn::Expr::Path(_) => todo!(),
        syn::Expr::Range(_) => todo!(),
        syn::Expr::Reference(_) => todo!(),
        syn::Expr::Repeat(_) => todo!(),
        syn::Expr::Return(_) => todo!(),
        syn::Expr::Struct(_) => todo!(),
        syn::Expr::Try(_) => todo!(),
        syn::Expr::TryBlock(_) => todo!(),
        syn::Expr::Tuple(_) => todo!(),
        syn::Expr::Type(_) => todo!(),
        syn::Expr::Unary(_) => todo!(),
        syn::Expr::Unsafe(_) => todo!(),
        syn::Expr::Verbatim(_) => todo!(),
        syn::Expr::While(_) => todo!(),
        syn::Expr::Yield(_) => todo!(),
        _ => todo!(),
    }
}

'''
'''--- scanner-syn/src/core_impl/info_extractor/trait_item_method_info.rs ---
use super::AttrSigInfo;
use syn::spanned::Spanned;
use syn::{Error, LitStr, TraitItemMethod};

/// Information extracted from trait method.
pub struct TraitItemMethodInfo {
    /// Attributes and signature information.
    pub attr_sig_info: AttrSigInfo,
    /// The original AST of the trait item method.
    pub original: TraitItemMethod,
    /// String representation of method name, e.g. `"my_method"`.
    pub ident_byte_str: LitStr,
}

impl TraitItemMethodInfo {
    pub fn new(original: &mut TraitItemMethod) -> syn::Result<Self> {
        if original.default.is_some() {
            return Err(Error::new(
                original.span(),
                "Traits that are used to describe external contract should not include\
                 default implementations because this is not a valid use case of traits\
                 to describe external contracts.",
            ));
        }

        let TraitItemMethod { attrs, sig, .. } = original;

        let attr_sig_info = AttrSigInfo::new(attrs, sig)?;

        let ident_byte_str =
            LitStr::new(&attr_sig_info.ident.to_string(), attr_sig_info.ident.span());

        Ok(Self {
            attr_sig_info,
            original: original.clone(),
            ident_byte_str,
        })
    }
}

'''
'''--- scanner-syn/src/core_impl/metadata/metadata_generator.rs ---
use crate::{
    contract_descriptor::FunctionInfo,
    core_impl::{metadata::type_is_event, AttrSigInfo},
    BindgenArgType, ImplItemMethodInfo, InputStructType, MethodType, SerializerType,
};

use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::ReturnType;

impl ImplItemMethodInfo {
    /// A public method that creates info about the method.
    ///
    /// # Returns
    ///
    /// * The struct that contains information about the method.
    pub fn metadata_struct(&self) -> FunctionInfo {
        let mut method_name_str = self.attr_signature_info.ident.to_string();
        if method_name_str=="default"{
            method_name_str=method_name_str.replace("default", "def_ault");
        }
        let is_event = type_is_event(&self.struct_type);
        if !is_event && !self.has_near_sdk_attr {
            let function_info = FunctionInfo {
                name: method_name_str,
                is_process: matches!(self.attr_signature_info.returns, ReturnType::Default),
                is_out_of_contract_scope: true,
                ..Default::default()
            };
            return function_info;
        }
        let is_view = matches!(&self.attr_signature_info.method_type, &MethodType::View);
        let is_public = self.is_public || (self.is_trait_impl && self.has_near_sdk_attr);
        let is_payable = self.attr_signature_info.is_payable;
        let is_test = self.attr_signature_info.is_test;

        let is_private_cccalls = self.attr_signature_info.is_private;
        let mut is_process = false;
        let is_init = matches!(
            &self.attr_signature_info.method_type,
            &MethodType::Init | &MethodType::InitIgnoreState
        );
        let mut is_mutable = false;
        let receiver = &self.attr_signature_info.receiver;

        if let Some(receiver) = receiver {
            is_mutable = !(receiver.mutability.is_none() || receiver.reference.is_none());
        }
        let _args = if self.attr_signature_info.input_args().next().is_some() {
            let input_struct = self
                .attr_signature_info
                .input_struct(InputStructType::Deserialization);
            // If input args are JSON then we need to additionally specify schema for them.
            let additional_schema = match &self.attr_signature_info.input_serializer {
                SerializerType::Borsh => TokenStream2::new(),
                SerializerType::JSON => quote! {
                    #[derive(borsh::BorshSchema)]
                },
            };

            quote! {
                {
                    #additional_schema
                    #[allow(dead_code)]
                    #input_struct
                    Some(Input::schema_container())
                }
            }
        } else {
            quote! {
                 None
            }
        };
        let _callbacks: Vec<_> = self
            .attr_signature_info
            .args
            .iter()
            .filter(|arg| matches!(arg.bindgen_ty, BindgenArgType::CallbackArg))
            .map(|arg| {
                let ty = &arg.ty;
                quote! {
                    #ty::schema_container()
                }
            })
            .collect();
        let _callbacks_vec = match self
            .attr_signature_info
            .args
            .iter()
            .filter(|arg| matches!(arg.bindgen_ty, BindgenArgType::CallbackArgVec))
            .last()
        {
            None => {
                quote! {
                    None
                }
            }
            Some(arg) => {
                let ty = &arg.ty;
                quote! {
                    Some(#ty::schema_container())
                }
            }
        };
        let _result = match &self.attr_signature_info.returns {
            ReturnType::Default => {
                is_process = true;
                quote! {
                    None
                }
            }
            ReturnType::Type(_, ty) => {
                quote! {
                    Some(#ty::schema_container())
                }
            }
        };

        FunctionInfo {
            name: method_name_str,
            is_public,
            is_trait_impl: self.is_trait_impl,
            is_init,
            is_payable,
            is_view,
            is_mutable,
            is_process,
            is_private_cccalls,
            is_out_of_contract_scope: false,
            is_event,
            is_test,
            inner_calls: None,
        }
    }
}

/// A public function that creates info about the function.
///
/// # Arguments
///
/// * `sig_info`: The parsed information from this function.
///
/// # Returns
///
/// * The `FunctionInfo` struct that contains information about the function.
pub fn metadata_fn_struct(sig_info: &AttrSigInfo) -> FunctionInfo {
    let method_name_str = sig_info.ident.to_string();

    FunctionInfo {
        name: method_name_str,
        is_process: matches!(sig_info.returns, ReturnType::Default),
        is_out_of_contract_scope: true,
        is_test: sig_info.is_test,
        is_payable: sig_info.is_payable,
        is_public: !sig_info.is_private,
        ..Default::default()
    }
}

'''
'''--- scanner-syn/src/core_impl/metadata/metadata_visitor.rs ---
//! We use `#![metadata]` attribute to generate metadata from the methods in the module
//! it decorates. Note, that this in an inner attribute. For it to work we should be
//! able to visit every method in the module intended to be a contract method.
//! For this we implement the visitor.
use std::collections::HashMap;

use crate::contract_descriptor::FunctionInfo;
use crate::{ItemFnInfo, ItemImplInfo};

use proc_macro2::TokenStream;
use quote::{quote, ToTokens};
use syn::visit::Visit;
use syn::{Error, Expr, ExprCall, ExprMethodCall, Ident, ImplItemMethod, ItemFn, ItemImpl};

use super::metadata_generator::metadata_fn_struct;

/// Information relevant to metadata extracted from the `impl` section decorated with `#[near_bindgen]`.
#[derive(Default)]
pub struct MetadataVisitor {
    impl_item_infos: Vec<ItemImplInfo>,
    fn_items_infos: Vec<ItemFnInfo>,
    /// Errors that occurred while extracting the data.
    connections: Vec<(TokenStream, Vec<TokenStream>)>,
    errors: Vec<Error>,
}

impl<'ast> Visit<'ast> for MetadataVisitor {
    /// A method that will visit every impl block in a file.
    /// It's getting called by the syn crate with filled arguments.
    ///
    /// # Arguments
    ///
    /// * `i`: The impl block tree.
    ///
    /// In result this method will add information about this method
    /// or add the errors that occurred while extracting the data.
    fn visit_item_impl(&mut self, i: &'ast ItemImpl) {
        // Marking impl blocks with `near_bindgen`
        let has_near_sdk_attr = i
            .attrs
            .iter()
            .any(|attr| attr.path.to_token_stream().to_string().as_str() == "near_bindgen");
        match ItemImplInfo::new(&mut i.clone(), has_near_sdk_attr) {
            Ok(info) => self.impl_item_infos.push(info),
            Err(err) => self.errors.push(err),
        }
        syn::visit::visit_item_impl(self, i);
    }

    /// A method that will visit every function in a file.
    /// It's getting called by the syn crate with filled arguments.
    ///
    /// # Arguments
    ///
    /// * `i`: The function tree.
    ///
    /// In result this method will add information about this function
    /// or add the errors that occurred while extracting the data.
    fn visit_item_fn(&mut self, i: &'ast ItemFn) {
        match ItemFnInfo::new(&mut i.clone()) {
            Ok(info) => self.fn_items_infos.push(info),
            Err(err) => self.errors.push(err),
        }
        self.connections
            .push((i.sig.ident.to_token_stream(), vec![]));
        syn::visit::visit_item_fn(self, i);
    }

    fn visit_impl_item_method(&mut self, i: &'ast ImplItemMethod) {
        self.connections
            .push((i.sig.ident.to_token_stream(), vec![]));
        syn::visit::visit_impl_item_method(self, i);
    }

    // TODO: find a way to not parse all(59) ways we can call a function
    fn visit_expr_call(&mut self, i: &'ast ExprCall) {
        let (_name, functions) = self.connections.last_mut().expect("Not stable way");
        functions.push(i.func.to_token_stream());
        syn::visit::visit_expr_call(self, i);
    }

    fn visit_expr_method_call(&mut self, i: &'ast ExprMethodCall) {
        let (_name, functions) = self.connections.last_mut().expect("Not stable way");
        functions.push(i.method.to_token_stream());
        syn::visit::visit_expr_method_call(self, i);
    }
}

impl MetadataVisitor {
    pub fn new() -> Self {
        Default::default()
    }

    /// A method that uses extracted information about current project.
    ///
    /// # Returns
    ///
    /// * The information about every method/function in this file
    pub fn generate_metadata_method(&self) -> syn::Result<Vec<FunctionInfo>> {
        if !self.errors.is_empty() {
            return Err(self.errors[0].clone());
        }
        let mut methods: Vec<FunctionInfo> = self
            .impl_item_infos
            .iter()
            .flat_map(|i| &i.methods)
            .map(|m| m.metadata_struct())
            .filter(|f| !f.is_test)
            .collect();
        let functions: Vec<FunctionInfo> = self
            .fn_items_infos
            .iter()
            .map(|s| metadata_fn_struct(&s.attr_signature_info))
            .filter(|f| !f.is_test)
            .collect();

        methods.extend(functions);

        Ok(methods)
    }

    pub fn get_connections(&self) -> Vec<FunctionInfo> {
        self.connections
            .iter()
            .map(|(m, c)| {
                let ident: Ident = syn::parse2(m.to_owned()).unwrap();
                let exps: Vec<FunctionInfo> = c
                    .iter()
                    .filter_map(|fs| {
                        let ident: Result<Ident, Error> = syn::parse2(fs.to_owned());
                        if ident.is_ok() {
                            return Some(FunctionInfo {
                                name: ident.unwrap().to_string(),
                                ..Default::default()
                            });
                        }
                        let exp: Result<Box<Expr>, Error> = syn::parse2(fs.to_owned());
                        if exp.is_ok() {
                            match *exp.unwrap() {
                                Expr::Path(p) => {
                                    return Some(FunctionInfo {
                                        name: p.path.segments.last().unwrap().ident.to_string(),
                                        ..Default::default()
                                    })
                                }
                                _ => return None,
                            }
                        }
                        None
                    })
                    .collect();

                let fni = FunctionInfo {
                    name: ident.to_string(),
                    inner_calls: Some(exps),
                    ..Default::default()
                };

                fni
            })
            .collect()
    }
}

#[rustfmt::skip]
#[cfg(test)]
mod tests {
    use quote::quote;
    use super::*;

    #[test]
    fn several_methods() {
        let code = quote! {
            #[near_bindgen]
            impl Hello {
                pub fn f1(&self) { }
                pub fn f2(&mut self, arg0: FancyStruct, arg1: u64) { }
            }

            #[near_bindgen]
            impl SomeTrait for Hello {
                fn f3(&mut self, arg0: FancyStruct, arg1: u64) -> Result<IsOk, Error> { }
            }
        };

        let file: syn::File = syn::parse2(code).unwrap();

        let mut visitor = MetadataVisitor::new();
        visitor.visit_file(&file);

        let actual = visitor.generate_metadata_method().unwrap();
        let expected = quote!(
            #[cfg(target_arch = "wasm32")]
            #[no_mangle]
            pub extern "C" fn metadata() {
                near_sdk::env::setup_panic_hook();
                use borsh::*;
                let metadata = near_sdk::Metadata::new(vec![
                    near_sdk::MethodMetadata {
                        name: "f1".to_string(),
                        is_view: true,
                        is_init: false,
                        args: None,
                        callbacks: vec![],
                        callbacks_vec: None,
                        result: None
                    },
                    near_sdk::MethodMetadata {
                        name: "f2".to_string(),
                        is_view: false,
                        is_init: false,
                        args: {
                            #[derive(borsh::BorshSchema)]
                            #[allow(dead_code)]
                            #[derive(near_sdk :: serde :: Deserialize)]
                            #[serde(crate = "near_sdk::serde")]
                            struct Input {
                                arg0: FancyStruct,
                                arg1: u64,
                            }
                            Some(Input::schema_container())
                        },
                        callbacks: vec![],
                        callbacks_vec: None,
                        result: None
                    },
                    near_sdk::MethodMetadata {
                        name: "f3".to_string(),
                        is_view: false,
                        is_init: false,
                        args: {
                            #[derive(borsh::BorshSchema)]
                            #[allow(dead_code)]
                            #[derive(near_sdk :: serde :: Deserialize)]
                            #[serde(crate = "near_sdk::serde")]
                            struct Input {
                                arg0: FancyStruct,
                                arg1: u64,
                            }
                            Some(Input::schema_container())
                        },
                        callbacks: vec![],
                        callbacks_vec: None,
                        result: Some(Result < IsOk, Error > ::schema_container())
                    }
                ]);
                let data = near_sdk::borsh::BorshSerialize::try_to_vec(&metadata)
                    .expect("Failed to serialize the metadata using Borsh");
                near_sdk::env::value_return(&data);
            }
        );
        assert_eq!(expected.to_string(), 
        quote! {
            #(#actual),*
        }.to_string());
    }
}

'''
'''--- scanner-syn/src/core_impl/metadata/mod.rs ---
pub mod metadata_generator;
pub mod metadata_visitor;

use syn::{Path, Type};

pub(crate) fn path_is_event(path: &Path) -> bool {
    path.leading_colon.is_none()
        && path.segments.len() == 1
        && path.segments.iter().next().unwrap().ident == "NearEvent"
}

/// Equivalent to `path_is_result` except that it works on `Type` values.
pub(crate) fn type_is_event(ty: &Type) -> bool {
    match ty {
        Type::Path(type_path) if type_path.qself.is_none() => path_is_event(&type_path.path),
        _ => false,
    }
}

'''
'''--- scanner-syn/src/core_impl/mod.rs ---
mod code_generator;
mod info_extractor;
mod metadata;
pub use code_generator::*;
pub use info_extractor::*;
pub use metadata::metadata_visitor::MetadataVisitor;

'''
'''--- scanner-syn/src/lib.rs ---
#![recursion_limit = "128"]
extern crate proc_macro;

mod core_impl;
use self::core_impl::*;
pub mod contract_descriptor;

'''