*GitHub Repository "isabella232/near-protocol-contracts"*

'''--- LICENSE.md ---
MIT License

Copyright (c) 2020 SmartContract Chainlink Limited SEZC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'''
'''--- README.md ---
# Integrating NEAR and Chainlink

This repository serves to demonstrate how a smart contract on NEAR can access off-chain data using an incentivized oracle solution with fungible tokens as payments. This repository is in continual development and tracking issues [here](https://github.com/smartcontractkit/near-protocol-contracts/issues).

There are a number of subdirectories in the project that represent the moving pieces of a simple oracle system. 

- Client Contract (The contract that wants a token price from an off-chain API)
- Oracle Contract (An on-chain smart contract that accepts a fungible token payment and stores a request to be processed off-chain)
- Oracle Node (An off-chain machine continuously polling the Oracle Contract on NEAR, and fulfilling requests) 
    - **Note**: code for the Oracle Node is not included in this repository, but one can use an oracle protocol like Chainlink
- Fungible Token (The token paid by the Client Contract to the Oracle Contract in exchange for getting an answer to the Client's request)

![Chainlink and NEAR diagram](assets/chainlink-diagram.png)

## Get NEAR-CLI, Rust, and set up testnet accounts

We'll be using [NEAR CLI](https://docs.near.org/docs/development/near-cli), a command line tool that makes things simpler. Please have [NodeJS version 12 or greater](https://nodejs.org/en/download/package-manager/). Then install globally with:

```bash
npm install -g near-cli
```

These smart contracts are written in Rust. Please follow these directions to get Rust going on your local machine.

Install Rustup:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

([Official documentation](https://www.rust-lang.org/tools/install))

Follow the directions which includes running:

```bash
source $HOME/.cargo/env
```

Add wasm target to your toolchain:

```bash
rustup target add wasm32-unknown-unknown
```

([Info on wasm32-unknown-unknown](https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/webassembly-support.html))

Rust is now ready on your machine.

Next, create a NEAR testnet account with [Wallet](https://wallet.testnet.near.org).

Set an environment variable to use in these examples. For instance, if your test account is `oracle.testnet` set it like so in your terminal:

```bash
export NEAR_ACCT=oracle.testnet
```

(**Windows users**: please look into using `set` instead of `export`, surrounding the environment variable in `%` instead of beginning with `$`, and using escaped double-quotes `\"` where necessary instead of the single-quotes provided in these instructions.)

Create sub-accounts::

```bash
near create-account oracle.$NEAR_ACCT --masterAccount $NEAR_ACCT
near create-account client.$NEAR_ACCT --masterAccount $NEAR_ACCT
near create-account oracle-node.$NEAR_ACCT --masterAccount $NEAR_ACCT
near create-account near-link.$NEAR_ACCT --masterAccount $NEAR_ACCT
```

We've gone over the different roles earlier, but let's focus on what will happen to get a request fulfilled.

**Client Contract** will call the **Oracle Contract** to make a request for external data.
**Client Contract** gives the **Oracle Contract** an allowance to take NEAR LINK from it. Before officially adding the request, it will `transfer_from` to capture the payment, keeping track of this amount in the `withdrawable_token` state variable.
The **Oracle Node** will be continuously polling the state of its **Oracle Contract** using the paginated `get_requests` function.
The **Oracle Node** will get the API results needed, and send back the answer to the **Oracle Contract**.
The **Oracle Contract** makes a cross-contract call to the callback address (NEAR account) at the callback method provided. It has now fulfilled the request and removes it from state.

## Build, deploy, and initialize

Let's begin!

Build the oracle, client, and NEAR LINK contracts with:

```bash
./build
```

Run all tests:

```bash
./test
```

Then deploy and instantiate like soâ€¦

NEAR LINK

```bash
near deploy --accountId near-link.$NEAR_ACCT --wasmFile near-link-token/res/near_link_token.wasm --initFunction new --initArgs '{"owner_id": "near-link.'$NEAR_ACCT'", "total_supply": "1000000"}'
```

Oracle contract

```bash
near deploy --accountId oracle.$NEAR_ACCT --wasmFile oracle/res/oracle.wasm --initFunction new --initArgs '{"link_id": "near-link.'$NEAR_ACCT'", "owner_id": "oracle.'$NEAR_ACCT'"}'
```

Client contract

```bash
near deploy --accountId client.$NEAR_ACCT --wasmFile client/res/client.wasm --initFunction new --initArgs '{"oracle_account": "oracle.'$NEAR_ACCT'"}'
```

## Minor housekeeping

Before the **oracle node** can fulfill the request, they must be authorized. We might as well do this from the get-go.

```bash
near call oracle.$NEAR_ACCT add_authorization '{"node": "oracle-node.'$NEAR_ACCT'"}' --accountId oracle.$NEAR_ACCT
```

(Optional) Check authorization to confirm:

```bash
near view oracle.$NEAR_ACCT is_authorized '{"node": "oracle-node.'$NEAR_ACCT'"}'
```

## Give fungible tokens and set allowances

Give 50 NEAR LINK to client:

```bash
near call near-link.$NEAR_ACCT transfer '{"new_owner_id": "client.'$NEAR_ACCT'", "amount": "50"}' --accountId near-link.$NEAR_ACCT --amount .0365
```

**Note**: above, we use the `amount` flag in order to pay for the state required. (See more about [state staking here](https://docs.near.org/docs/concepts/storage))

(Optional) Check balance to confirm:

```bash
near view near-link.$NEAR_ACCT get_balance '{"owner_id": "client.'$NEAR_ACCT'"}'
```

**client contract** gives **oracle contract** allowance to spend 20 NEAR LINK on their behalf:

```bash
near call near-link.$NEAR_ACCT inc_allowance '{"escrow_account_id": "oracle.'$NEAR_ACCT'", "amount": "20"}' --accountId client.$NEAR_ACCT --amount .0696
```

(Optional) Check allowance to confirm:

```bash
near view near-link.$NEAR_ACCT get_allowance '{"owner_id": "client.'$NEAR_ACCT'", "escrow_account_id": "oracle.'$NEAR_ACCT'"}'
```

## Make a request

Let's make a request to a Chainlink node and request an ETH-USD price:

- Packed JSON arguments: `{"get":"https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD","path":"USD","times":100}`
- Base64 encoded arguments: `eyJnZXQiOiJodHRwczovL21pbi1hcGkuY3J5cHRvY29tcGFyZS5jb20vZGF0YS9wcmljZT9mc3ltPUVUSCZ0c3ltcz1VU0QiLCJwYXRoIjoiVVNEIiwidGltZXMiOjEwMH0=`

We'll show two ways to have the client contract send the oracle contract a request. First, we'll directly call the oracle contract using the key pair (i.e. keys) from the client contract.

1. **Client contract** makes a direct request to **oracle contract** with payment of 10 NEAR LINK. We can do this because we have the key pair for the client contract.

```bash
near call oracle.$NEAR_ACCT request '{"payment": "10", "spec_id": "dW5pcXVlIHNwZWMgaWQ=", "callback_address": "client.'$NEAR_ACCT'", "callback_method": "token_price_callback", "nonce": "1", "data_version": "1", "data": "eyJnZXQiOiJodHRwczovL21pbi1hcGkuY3J5cHRvY29tcGFyZS5jb20vZGF0YS9wcmljZT9mc3ltPUVUSCZ0c3ltcz1VU0QiLCJwYXRoIjoiVVNEIiwidGltZXMiOjEwMH0="}' --accountId client.$NEAR_ACCT --gas 300000000000000
```

2. **Any NEAR account** calls the **client contract**, providing request arguments. Upon receiving this, the **client contract** sends a cross-contract call to the **oracle contract** to store the request. (Payment and other values are hardcoded here, the nonce is automatically incremented. This assumes that the **client contract** contract only wants to use one oracle contract.)

```bash
near call client.$NEAR_ACCT get_token_price '{"symbol": "eyJnZXQiOiJodHRwczovL21pbi1hcGkuY3J5cHRvY29tcGFyZS5jb20vZGF0YS9wcmljZT9mc3ltPUVUSCZ0c3ltcz1VU0QiLCJwYXRoIjoiVVNEIiwidGltZXMiOjEwMH0=", "spec_id": "dW5pcXVlIHNwZWMgaWQ="}' --accountId client.$NEAR_ACCT --gas 300000000000000
```

## View pending requests

The oracle node is continually polling the state of the **oracle contract** to see the paginated request _summary_. This shows which accounts have requests pending and the total amount of pending requests:

```bash
near view oracle.$NEAR_ACCT get_requests_summary '{"max_num_accounts": "10"}'
```

**Note**: aside from `get_requests_summary` there is also `get_requests_summary_from`. Since the [`TreeMap` data structure](https://docs.rs/near-sdk/1.0.0/near_sdk/collections/struct.TreeMap.html) is ordered, the former will list the first N (`max_num_accounts`). Usage of `get_requests_summary_from` is for paging, providing a window of results to return. Please see function details for parameters and usage.

For folks who prefer to see a more low-level approach to hitting the RPC, here's the [curl](https://en.wikipedia.org/wiki/CURL) command performing the same query:

```bash
curl -d '{"jsonrpc": "2.0", "method": "query", "id": "chainlink", "params": {"request_type": "call_function", "finality": "final", "account_id": "oracle.'$NEAR_ACCT'", "method_name": "get_requests_summary", "args_base64": "eyJtYXhfbnVtX2FjY291bnRzIjogIjEwIn0="}}' -H 'Content-Type: application/json' https://rpc.testnet.near.org
```

The above will return something like:

```json
{
  "jsonrpc": "2.0",
  "result": {
    "result": [
      91,
      123,
      34,
      97,
      99,
      99,
      111,
      117,
      110,
      116,
      34,
      58,
      34,
      99,
      108,
      105,
      101,
      110,
      116,
      46,
      100,
      101,
      109,
      111,
      46,
      116,
      101,
      115,
      116,
      110,
      101,
      116,
      34,
      44,
      34,
      116,
      111,
      116,
      97,
      108,
      95,
      114,
      101,
      113,
      117,
      101,
      115,
      116,
      115,
      34,
      58,
      49,
      125,
      93
    ],
    "logs": [],
    "block_height": 10551293,
    "block_hash": "Ljh67tYk5bGXPu9TamJNG4vHp18cEBDxebKHpEUeZEo"
  },
  "id": "chainlink"
}
```

We'll outline a quick way to see the results if the machine has [Python installed](https://docs.python-guide.org/starting/install3/osx/). Copy the value of the innermost `result` key, which is an array of unsigned 8-bit integers.

Open the Python REPL with the command `python` and see the prompt with `>>>`.

Enter the below replacing BYTE_ARRAY with the the innermost result value (including the square brackets):

```python
res = BYTE_ARRAY
```

then:

```python
''.join(chr(x) for x in res)
```

and python will print something like:

```text
'[{"account":"client.demo.testnet","total_requests":1}]'
```

The previous command (calling the method `get_requests_summary`) is useful if there has been significant scaling from many client accounts/contracts. To see the individual requests for a particular user, use the following command:

```bash
near view oracle.$NEAR_ACCT get_requests '{"account": "client.'$NEAR_ACCT'", "max_requests": "10"}'
```

The **oracle node** uses the passed request arguments to fetch the price of (for example) Basic Attention Token (BAT) and finds it is at \$0.19 per token.
The data `0.19` as a `Vec<u8>` is `MTkuMQ==`

There's a third method to get all the requests, ordered by account name and nonce, where a specified maximum number of results is provided.

```bash
near view oracle.$NEAR_ACCT get_all_requests '{"max_num_accounts": "100", "max_requests": "100"}'
```

## Fulfill the request

**Oracle Node** uses its NEAR account keys to fulfill the request:

```bash
near call oracle.$NEAR_ACCT fulfill_request '{"account": "client.'$NEAR_ACCT'", "nonce": "0", "data": "MTkuMQ=="}' --accountId oracle-node.$NEAR_ACCT --gas 300000000000000
```

(Optional) Check the **client contract** for the values it has saved:

```bash
near view client.$NEAR_ACCT get_received_vals '{"max": "100"}'
```

## Check final balance/allowance

(Optional) Check the balance of **client contract**:

```bash
near view near-link.$NEAR_ACCT get_balance '{"owner_id": "client.'$NEAR_ACCT'"}'
```

Expect `40`

(Optional) Check the allowance of **oracle contract**:

```bash
near view near-link.$NEAR_ACCT get_allowance '{"owner_id": "client.'$NEAR_ACCT'", "escrow_account_id": "oracle.'$NEAR_ACCT'"}'
```

Expect `10`

The oracle node and oracle contract are assumed to be owned by the same person/entity. The oracle contract has "withdrawable tokens" that can be taken when it's most convenient. Some oracles may choose to transfer these tokens immediately after fulfillment. Here we are using the withdrawable pattern, where gas is conserved by not transferring after each request fulfillment.

Also, when the feature of cancelling requests is implemented, the withdrawable tokens is used to ensure the correct amount of fungible tokens can be withdrawn without interfering with possible cancellations within a given period.

## Withdraw tokens

(Optional) Check the withdrawable tokens on the oracle contract with this command:

```bash
near view oracle.$NEAR_ACCT get_withdrawable_tokens
```

(Optional) Check the fungible token balance of the client and the base account we'll be extracting to it. (This is the original account we set the `NEAR_ACCT` environment variable to, for demonstration purposes)

```bash
near view near-link.$NEAR_ACCT get_balance '{"owner_id": "oracle.'$NEAR_ACCT'"}'
near view near-link.$NEAR_ACCT get_balance '{"owner_id": "'$NEAR_ACCT'"}'
```

Finally, withdraw the fungible tokens from the oracle contract into the oracle node, the base account, who presumably owns both the oracle node and oracle contract.

```bash
near call oracle.$NEAR_ACCT withdraw '{"recipient": "oracle-node.'$NEAR_ACCT'", "amount": "10"}' --accountId oracle.$NEAR_ACCT --gas 300000000000000
```

You may use the previous two `get_balance` view methods to confirm that the fungible tokens have indeed been withdrawn.

## Notes

The client is responsible for making sure there is enough allowance for fungible token transfers. It may be advised to add a cushion in addition to expected fungible token transfers as duplicate requests will also decrease allowance.

**Scenario**: a client accidentally sends the same request or a request with the same nonce. The fungible token transfer occurs, decrementing the allowance on the fungible token contract. Then it is found that it's a duplicate, and the fungible tokens are returned. In this case, the allowance will not be increased as this can only be done by the client itself.

One way to handle this is for the client to have logic to increase the allowance if it receives the response indicating a duplicate request has been sent. Another way might be to increase the allowance before each request. Again, this decision is up to the owner of the client contract.

## Outstanding work

There are various issues opened in this repository. As mentioned early in this document, this is an ever-growing repository. Soon we'll implement using the expiration to allow the client contract to cancel their request and receive the tokens back if it's within the window. There's also work in terms of setting up the [PreCoordinator](https://github.com/smartcontractkit/chainlink/blob/develop/evm-contracts/src/v0.5/PreCoordinator.sol) and whatnot.

Contributors are welcome to get involved!

'''
'''--- client/Cargo.toml ---
[package]
name = "client"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.45"
near-sdk = "0.11.0"
borsh = "0.6.0"
wee_alloc = { version = "0.4.5", default-features = false, features = [] }
base64 = "0.12.1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

[workspace]
members = []

'''
'''--- client/src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::{env, ext_contract, near_bindgen, AccountId};
use near_sdk::collections::TreeMap;
use base64::{decode};
use std::str;
use near_sdk::json_types::U128;
use std::collections::HashMap;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;
const SINGLE_CALL_GAS: u64 = 200_000_000_000_000;

pub type Base64String = String;

#[ext_contract(ext_oracle)]
pub trait ExtOracleContract {
    fn request(&mut self, payment: U128, spec_id: Base64String, callback_address: AccountId, callback_method: String, nonce: U128, data_version: U128, data: Base64String);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
struct ClientContract {
    // Note: for this simple demo we'll store the oracle node in state like this
    // There's no reason why client contracts can't call various oracle contracts.
    oracle_account: AccountId,
    nonce: u128,
    received: TreeMap<u128, String>,
}

impl Default for ClientContract {
    fn default() -> Self {
        panic!("Oracle client should be initialized before usage")
    }
}

#[near_bindgen]
impl ClientContract {
    #[allow(dead_code)]
    #[init]
    pub fn new(oracle_account: AccountId) -> Self {
        Self {
            oracle_account,
            nonce: 0_u128,
            received: TreeMap::new(b"r".to_vec()),
        }
    }

    /// symbol: Base64-encoded token symbol
    #[allow(dead_code)] // This function gets called from the oracle
    pub fn get_token_price(&mut self, symbol: String, spec_id: Base64String) -> U128 {
        // For the sake of demo, a few hardcoded values
        let payment = U128(10);
        self.nonce += 1;
        let nonce: U128 = self.nonce.into();

        ext_oracle::request(payment, spec_id, env::current_account_id(), "token_price_callback".to_string(), nonce, U128(1), symbol, &self.oracle_account, 0, SINGLE_CALL_GAS);
        U128(self.nonce)
    }

    #[allow(dead_code)] // This function gets called from the oracle
    pub fn token_price_callback(&mut self, nonce: U128, answer: Base64String) {
        let base64_price = match str::from_utf8(answer.as_bytes()) {
            Ok(val) => val,
            Err(_) => env::panic(b"Invalid UTF-8 sequence provided from oracle contract."),
        };
        let decoded_price_vec = decode(base64_price).unwrap();
        let price_readable = match str::from_utf8(decoded_price_vec.as_slice()) {
            Ok(val) => val,
            Err(_) => env::panic(b"Invalid UTF-8 sequence in Base64 decoded value."),
        };
        env::log(format!("Client contract received price: {:?}", price_readable).as_bytes());
        self.received.insert(&nonce.0, &price_readable.to_string());
    }

    // using String instead of U128 because
    // the trait `std::cmp::Eq` is not implemented for `near_sdk::json_types::integers::U128`
    #[allow(dead_code)]
    pub fn get_received_vals(&self, max: U128) -> HashMap<String, String> {
        let mut counter: u128 = 0;
        let mut result: HashMap<String, String> = HashMap::new();
        for answer in self.received.iter() {
            if counter == max.0 || counter > self.received.len() as u128 {
                break;
            }
            result.insert(answer.0.to_string(), answer.1);
            counter += 1;
        }
        result
    }

    #[allow(dead_code)]
    pub fn get_received_val(&self, nonce: U128) -> String {
        let nonce_u128: u128 = nonce.into();
        self.received.get(&nonce_u128).unwrap_or("-1".to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{MockedBlockchain, StorageUsage};
    use near_sdk::{testing_env, VMContext};
    use base64::{encode};

    fn link() -> AccountId { "link_near".to_string() }

    fn alice() -> AccountId { "alice_near".to_string() }

    fn bob() -> AccountId { "bob_near".to_string() }
    fn oracle() -> AccountId { "oracle.testnet".to_string() }

    fn get_context(signer_account_id: AccountId, storage_usage: StorageUsage) -> VMContext {
        VMContext {
            current_account_id: alice(),
            signer_account_id,
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: alice(),
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            epoch_height: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
        }
    }

    #[test]
    fn test_token_price() {
        let context = get_context(alice(), 0);
        testing_env!(context);
        let mut contract = ClientContract::new(oracle() );
        let mut returned_nonce = contract.get_token_price("eyJnZXQiOiJodHRwczovL21pbi1hcGkuY3J5cHRvY29tcGFyZS5jb20vZGF0YS9wcmljZT9mc3ltPUVUSCZ0c3ltcz1VU0QiLCJwYXRoIjoiVVNEIiwidGltZXMiOjEwMH0".to_string(), "dW5pcXVlIHNwZWMgaWQ=".to_string());
        assert_eq!(U128(1), returned_nonce);
        returned_nonce = contract.get_token_price("eyJnZXQiOiJodHRwczovL21pbi1hcGkuY3J5cHRvY29tcGFyZS5jb20vZGF0YS9wcmljZT9mc3ltPUVUSCZ0c3ltcz1VU0QiLCJwYXRoIjoiVVNEIiwidGltZXMiOjEwMH0".to_string(), "dW5pcXVlIHNwZWMgaWQ=".to_string());
        assert_eq!(U128(2), returned_nonce);
    }
}

'''
'''--- near-link-token/Cargo.toml ---
[package]
name = "near-link-token"
version = "0.2.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "*", features = ["derive"] }
serde_json = "*"
near-sdk = "0.11.0"
borsh = "*"
wee_alloc = { version = "0.4.5", default-features = false, features = [] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- near-link-token/README.md ---
# Fungible token

Example implementation of a Fungible Token Standard (NEP#21).

NOTES:

- The maximum balance value is limited by U128 (2\*\*128 - 1).
- JSON calls should pass U128 as a base-10 string. E.g. "100".
- The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
  abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
- This contract doesn't optimize the amount of storage, since any account can create unlimited
  amount of allowances to other accounts. It's unclear how to address this issue unless, this
  contract limits the total number of different allowances possible at the same time.
  And even if it limits the total number, it's still possible to transfer small amounts to
  multiple accounts.

## Building

To build run:

```bash
./build
```

## Testing

To test run:

```bash
cargo test --package fungible-token -- --nocapture
```

'''
'''--- near-link-token/src/lib.rs ---
/**
* Fungible Token implementation with JSON serialization.
* NOTES:
*  - The maximum balance value is limited by U128 (2**128 - 1).
*  - JSON calls should pass U128 as a base-10 string. E.g. "100".
*  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
*    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
*  - The contract tracks the change in storage before and after the call. If the storage increases,
*    the contract requires the caller of the contract to attach enough deposit to the function call
*    to cover the storage cost.
*    This is done to prevent a denial of service attack on the contract by taking all available storage.
*    If the storage decreases, the contract will issue a refund for the cost of the released storage.
*    The unused tokens from the attached deposit are also refunded, so it's safe to
*    attach more deposit than required.
*  - To prevent the deployed contract from being modified or deleted, it should not have any access
*    keys on its account.
*/
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, Promise, StorageUsage};

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

/// Price per 1 byte of storage from mainnet genesis config.
const STORAGE_PRICE_PER_BYTE: Balance = 100000000000000000000;

/// Contains balance and allowances information for one account.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    /// Current account balance.
    pub balance: Balance,
    /// Escrow Account ID hash to the allowance amount.
    /// Allowance is the amount of tokens the Escrow Account ID can spent on behalf of the account
    /// owner.
    pub allowances: UnorderedMap<Vec<u8>, Balance>,
}

impl Account {
    /// Initializes a new Account with 0 balance and no allowances for a given `account_hash`.
    pub fn new(account_hash: Vec<u8>) -> Self {
        Self { balance: 0, allowances: UnorderedMap::new(account_hash) }
    }

    /// Sets allowance for account `escrow_account_id` to `allowance`.
    pub fn set_allowance(&mut self, escrow_account_id: &AccountId, allowance: Balance) {
        let escrow_hash = env::sha256(escrow_account_id.as_bytes());
        if allowance > 0 {
            self.allowances.insert(&escrow_hash, &allowance);
        } else {
            self.allowances.remove(&escrow_hash);
        }
    }

    /// Returns the allowance of account `escrow_account_id`.
    pub fn get_allowance(&self, escrow_account_id: &AccountId) -> Balance {
        let escrow_hash = env::sha256(escrow_account_id.as_bytes());
        self.allowances.get(&escrow_hash).unwrap_or(0)
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct FungibleToken {
    /// sha256(AccountID) -> Account details.
    pub accounts: UnorderedMap<Vec<u8>, Account>,

    /// Total supply of the all token.
    pub total_supply: Balance,
}

impl Default for FungibleToken {
    fn default() -> Self {
        panic!("Fun token should be initialized before usage")
    }
}

#[near_bindgen]
impl FungibleToken {
    /// Initializes the contract with the given total supply owned by the given `owner_id`.
    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128) -> Self {
        let total_supply = total_supply.into();
        assert!(!env::state_exists(), "Already initialized");
        let mut ft = Self { accounts: UnorderedMap::new(b"a".to_vec()), total_supply };
        let mut account = ft.get_account(&owner_id);
        account.balance = total_supply;
        ft.set_account(&owner_id, &account);
        ft
    }

    /// Increments the `allowance` for `escrow_account_id` by `amount` on the account of the caller of this contract
    /// (`predecessor_id`) who is the balance owner.
    /// Requirements:
    /// * Caller of the method has to attach deposit enough to cover storage difference at the
    ///   fixed storage price defined in the contract.
    #[payable]
    pub fn inc_allowance(&mut self, escrow_account_id: AccountId, amount: U128) {
        let initial_storage = env::storage_usage();
        assert!(
            env::is_valid_account_id(escrow_account_id.as_bytes()),
            "Escrow account ID is invalid"
        );
        let owner_id = env::predecessor_account_id();
        assert_ne!(escrow_account_id, owner_id, "Can not increment allowance for yourself");
        let mut account = self.get_account(&owner_id);
        let current_allowance = account.get_allowance(&escrow_account_id);
        account.set_allowance(&escrow_account_id, current_allowance.saturating_add(amount.0));
        self.set_account(&owner_id, &account);
        self.refund_storage(initial_storage);
    }

    /// Decrements the `allowance` for `escrow_account_id` by `amount` on the account of the caller of this contract
    /// (`predecessor_id`) who is the balance owner.
    /// Requirements:
    /// * Caller of the method has to attach deposit enough to cover storage difference at the
    ///   fixed storage price defined in the contract.
    #[payable]
    pub fn dec_allowance(&mut self, escrow_account_id: AccountId, amount: U128) {
        let initial_storage = env::storage_usage();
        assert!(
            env::is_valid_account_id(escrow_account_id.as_bytes()),
            "Escrow account ID is invalid"
        );
        let owner_id = env::predecessor_account_id();
       assert_ne!(escrow_account_id, owner_id, "Can not decrement allowance for yourself");
        let mut account = self.get_account(&owner_id);
        let current_allowance = account.get_allowance(&escrow_account_id);
        account.set_allowance(&escrow_account_id, current_allowance.saturating_sub(amount.0));
        self.set_account(&owner_id, &account);
        self.refund_storage(initial_storage);
    }

    /// Transfers the `amount` of tokens from `owner_id` to the `new_owner_id`.
    /// Requirements:
    /// * `amount` should be a positive integer.
    /// * `owner_id` should have balance on the account greater or equal than the transfer `amount`.
    /// * If this function is called by an escrow account (`owner_id != predecessor_account_id`),
    ///   then the allowance of the caller of the function (`predecessor_account_id`) on
    ///   the account of `owner_id` should be greater or equal than the transfer `amount`.
    /// * Caller of the method has to attach deposit enough to cover storage difference at the
    ///   fixed storage price defined in the contract.
    #[payable]
    pub fn transfer_from(&mut self, owner_id: AccountId, new_owner_id: AccountId, amount: U128) {
        let initial_storage = env::storage_usage();
        assert!(
            env::is_valid_account_id(new_owner_id.as_bytes()),
            "New owner's account ID is invalid"
        );
        let amount = amount.into();
        if amount == 0 {
            env::panic(b"Can't transfer 0 tokens");
        }
        assert_ne!(
            owner_id, new_owner_id,
            "The new owner should be different from the current owner"
        );
        // Retrieving the account from the state.
        let mut account = self.get_account(&owner_id);

        // Checking and updating unlocked balance
        if account.balance < amount {
            env::panic(b"Not enough balance");
        }
        account.balance -= amount;

        // If transferring by escrow, need to check and update allowance.
        let escrow_account_id = env::predecessor_account_id();
        if escrow_account_id != owner_id {
            let allowance = account.get_allowance(&escrow_account_id);
            if allowance < amount {
                env::panic(b"Not enough allowance");
            }
            account.set_allowance(&escrow_account_id, allowance - amount);
        }

        // Saving the account back to the state.
        self.set_account(&owner_id, &account);

        // Deposit amount to the new owner and save the new account to the state.
        let mut new_account = self.get_account(&new_owner_id);
        new_account.balance += amount;
        self.set_account(&new_owner_id, &new_account);
        self.refund_storage(initial_storage);
    }

    /// Transfer `amount` of tokens from the caller of the contract (`predecessor_id`) to
    /// `new_owner_id`.
    /// Act the same was as `transfer_from` with `owner_id` equal to the caller of the contract
    /// (`predecessor_id`).
    /// Requirements:
    /// * Caller of the method has to attach deposit enough to cover storage difference at the
    ///   fixed storage price defined in the contract.
    #[payable]
    pub fn transfer(&mut self, new_owner_id: AccountId, amount: U128) {
        // NOTE: New owner's Account ID checked in transfer_from.
        // Storage fees are also refunded in transfer_from.
        self.transfer_from(env::predecessor_account_id(), new_owner_id, amount);
    }

    /// Returns total supply of tokens.
    pub fn get_total_supply(&self) -> U128 {
        self.total_supply.into()
    }

    /// Returns balance of the `owner_id` account.
    pub fn get_balance(&self, owner_id: AccountId) -> U128 {
        self.get_account(&owner_id).balance.into()
    }

    /// Returns current allowance of `escrow_account_id` for the account of `owner_id`.
    ///
    /// NOTE: Other contracts should not rely on this information, because by the moment a contract
    /// receives this information, the allowance may already be changed by the owner.
    /// So this method should only be used on the front-end to see the current allowance.
    pub fn get_allowance(&self, owner_id: AccountId, escrow_account_id: AccountId) -> U128 {
        assert!(
            env::is_valid_account_id(escrow_account_id.as_bytes()),
            "Escrow account ID is invalid"
        );
        self.get_account(&owner_id).get_allowance(&escrow_account_id).into()
    }
}

impl FungibleToken {
    /// Helper method to get the account details for `owner_id`.
    fn get_account(&self, owner_id: &AccountId) -> Account {
        assert!(env::is_valid_account_id(owner_id.as_bytes()), "Owner's account ID is invalid");
        let account_hash = env::sha256(owner_id.as_bytes());
        self.accounts.get(&account_hash).unwrap_or_else(|| Account::new(account_hash))
    }

    /// Helper method to set the account details for `owner_id` to the state.
    fn set_account(&mut self, owner_id: &AccountId, account: &Account) {
        let account_hash = env::sha256(owner_id.as_bytes());
        if account.balance > 0 || !account.allowances.is_empty() {
            self.accounts.insert(&account_hash, &account);
        } else {
            self.accounts.remove(&account_hash);
        }
    }

    fn refund_storage(&self, initial_storage: StorageUsage) {
        let current_storage = env::storage_usage();
        let attached_deposit = env::attached_deposit();
        let refund_amount = if current_storage > initial_storage {
            let required_deposit =
                Balance::from(current_storage - initial_storage) * STORAGE_PRICE_PER_BYTE;
            assert!(
                required_deposit <= attached_deposit,
                "The required attached deposit is {}, but the given attached deposit is is {}",
                required_deposit,
                attached_deposit,
            );
            attached_deposit - required_deposit
        } else {
            attached_deposit
                + Balance::from(initial_storage - current_storage) * STORAGE_PRICE_PER_BYTE
        };
        if refund_amount > 0 {
            env::log(format!("Refunding {} tokens for storage", refund_amount).as_bytes());
            Promise::new(env::predecessor_account_id()).transfer(refund_amount);
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    use super::*;

    fn alice() -> AccountId {
        "alice.near".to_string()
    }
    fn bob() -> AccountId {
        "bob.near".to_string()
    }
    fn carol() -> AccountId {
        "carol.near".to_string()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: alice(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1_000_000_000_000_000_000_000_000_000u128,
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn test_new() {
        let context = get_context(carol());
        testing_env!(context);
        let total_supply = 1_000_000_000_000_000u128;
        let contract = FungibleToken::new(bob(), total_supply.into());
        assert_eq!(contract.get_total_supply().0, total_supply);
        assert_eq!(contract.get_balance(bob()).0, total_supply);
    }

    #[test]
    #[should_panic]
    fn test_new_twice_fails() {
        let context = get_context(carol());
        testing_env!(context);
        let total_supply = 1_000_000_000_000_000u128;
        {
            let _contract = FungibleToken::new(bob(), total_supply.into());
        }
        FungibleToken::new(bob(), total_supply.into());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.storage_usage = env::storage_usage();

        context.attached_deposit = 1000 * STORAGE_PRICE_PER_BYTE;
        testing_env!(context.clone());
        let transfer_amount = total_supply / 3;
        contract.transfer(bob(), transfer_amount.into());
        context.storage_usage = env::storage_usage();
        context.account_balance = env::account_balance();

        context.is_view = true;
        context.attached_deposit = 0;
        testing_env!(context.clone());
        assert_eq!(contract.get_balance(carol()).0, (total_supply - transfer_amount));
        assert_eq!(contract.get_balance(bob()).0, transfer_amount);
    }

    #[test]
    #[should_panic(expected = "The new owner should be different from the current owner")]
    fn test_transfer_fail_self() {
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.storage_usage = env::storage_usage();

        context.attached_deposit = 1000 * STORAGE_PRICE_PER_BYTE;
        testing_env!(context.clone());
        let transfer_amount = total_supply / 3;
        contract.transfer(carol(), transfer_amount.into());
    }

    #[test]
    #[should_panic(expected = "Can not increment allowance for yourself")]
    fn test_self_inc_allowance_fail() {
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        testing_env!(context.clone());
        contract.inc_allowance(carol(), (total_supply / 2).into());
    }

    #[test]
    #[should_panic(expected = "Can not decrement allowance for yourself")]
    fn test_self_dec_allowance_fail() {
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        testing_env!(context.clone());
        contract.dec_allowance(carol(), (total_supply / 2).into());
    }

    #[test]
    fn test_saturating_dec_allowance() {
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        testing_env!(context.clone());
        contract.dec_allowance(bob(), (total_supply / 2).into());
        assert_eq!(contract.get_allowance(carol(), bob()), 0.into())
    }

    #[test]
    fn test_saturating_inc_allowance() {
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = std::u128::MAX;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        testing_env!(context.clone());
        contract.inc_allowance(bob(), total_supply.into());
        contract.inc_allowance(bob(), total_supply.into());
        assert_eq!(contract.get_allowance(carol(), bob()), std::u128::MAX.into())
    }

    #[test]
    #[should_panic(
        expected = "The required attached deposit is 33100000000000000000000, but the given attached deposit is is 0"
    )]
    fn test_self_allowance_fail_no_deposit() {
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.attached_deposit = 0;
        testing_env!(context.clone());
        contract.inc_allowance(bob(), (total_supply / 2).into());
    }

    #[test]
    fn test_carol_escrows_to_bob_transfers_to_alice() {
        // Acting as carol
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.storage_usage = env::storage_usage();

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_total_supply().0, total_supply);

        let allowance = total_supply / 3;
        let transfer_amount = allowance / 3;
        context.is_view = false;
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        testing_env!(context.clone());
        contract.inc_allowance(bob(), allowance.into());
        context.storage_usage = env::storage_usage();
        context.account_balance = env::account_balance();

        context.is_view = true;
        context.attached_deposit = 0;
        testing_env!(context.clone());
        assert_eq!(contract.get_allowance(carol(), bob()).0, allowance);

        // Acting as bob now
        context.is_view = false;
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        context.predecessor_account_id = bob();
        testing_env!(context.clone());
        contract.transfer_from(carol(), alice(), transfer_amount.into());
        context.storage_usage = env::storage_usage();
        context.account_balance = env::account_balance();

        context.is_view = true;
        context.attached_deposit = 0;
        testing_env!(context.clone());
        assert_eq!(contract.get_balance(carol()).0, total_supply - transfer_amount);
        assert_eq!(contract.get_balance(alice()).0, transfer_amount);
        assert_eq!(contract.get_allowance(carol(), bob()).0, allowance - transfer_amount);
    }

    #[test]
    fn test_carol_escrows_to_bob_locks_and_transfers_to_alice() {
        // Acting as carol
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.storage_usage = env::storage_usage();

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_total_supply().0, total_supply);

        let allowance = total_supply / 3;
        let transfer_amount = allowance / 3;
        context.is_view = false;
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        testing_env!(context.clone());
        contract.inc_allowance(bob(), allowance.into());
        context.storage_usage = env::storage_usage();
        context.account_balance = env::account_balance();

        context.is_view = true;
        context.attached_deposit = 0;
        testing_env!(context.clone());
        assert_eq!(contract.get_allowance(carol(), bob()).0, allowance);
        assert_eq!(contract.get_balance(carol()).0, total_supply);

        // Acting as bob now
        context.is_view = false;
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        context.predecessor_account_id = bob();
        testing_env!(context.clone());
        contract.transfer_from(carol(), alice(), transfer_amount.into());
        context.storage_usage = env::storage_usage();
        context.account_balance = env::account_balance();

        context.is_view = true;
        context.attached_deposit = 0;
        testing_env!(context.clone());
        assert_eq!(contract.get_balance(carol()).0, (total_supply - transfer_amount));
        assert_eq!(contract.get_balance(alice()).0, transfer_amount);
        assert_eq!(contract.get_allowance(carol(), bob()).0, allowance - transfer_amount);
    }

    #[test]
    fn test_self_allowance_set_for_refund() {
        let mut context = get_context(carol());
        testing_env!(context.clone());
        let total_supply = 1_000_000_000_000_000u128;
        let mut contract = FungibleToken::new(carol(), total_supply.into());
        context.storage_usage = env::storage_usage();

        let initial_balance = context.account_balance;
        let initial_storage = context.storage_usage;
        context.attached_deposit = STORAGE_PRICE_PER_BYTE * 1000;
        testing_env!(context.clone());
        contract.inc_allowance(bob(), (total_supply / 2).into());
        context.storage_usage = env::storage_usage();
        context.account_balance = env::account_balance();
        assert_eq!(
            context.account_balance,
            initial_balance
                + Balance::from(context.storage_usage - initial_storage) * STORAGE_PRICE_PER_BYTE
        );

        let initial_balance = context.account_balance;
        let initial_storage = context.storage_usage;
        testing_env!(context.clone());
        context.attached_deposit = 0;
        testing_env!(context.clone());
        contract.dec_allowance(bob(), (total_supply / 2).into());
        context.storage_usage = env::storage_usage();
        context.account_balance = env::account_balance();
        assert!(context.storage_usage < initial_storage);
        assert!(context.account_balance < initial_balance);
        assert_eq!(
            context.account_balance,
            initial_balance
                - Balance::from(initial_storage - context.storage_usage) * STORAGE_PRICE_PER_BYTE
        );
    }
}

'''
'''--- oracle/Cargo.toml ---
[package]
name = "oracle"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.45"
near-sdk = "0.11.0"
borsh = "0.6.1"
wee_alloc = "0.4.5"
base64 = "0.12.1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

[workspace]
members = []

'''
'''--- oracle/README.md ---
# Oracle

The [Chainlink Oracle contract](https://github.com/smartcontractkit/chainlink/blob/develop/evm-contracts/src/v0.6/Oracle.sol) ported to Rust.

## Testing
To test run:
```bash
cargo test --package oracle -- --nocapture
```

'''
'''--- oracle/src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Serialize, Deserialize};
use near_sdk::collections::{TreeMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::{AccountId, env, near_bindgen, PromiseResult};
use serde_json::json;
use std::str;
use std::collections::HashMap;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

const EXPIRY_TIME: u64 = 5 * 60 * 1_000_000_000;

// max gas: 300_000_000_000_000

const MINIMUM_CONSUMER_GAS_LIMIT: u64 = 1_000_000_000;
const SINGLE_CALL_GAS: u64 = 50_000_000_000_000; // 5 x 10^13
const TRANSFER_FROM_NEAR_COST: u128 = 36_500_000_000_000_000_000_000; // 365 x 10^20

pub type Base64String = String;

#[derive(Default, BorshDeserialize, BorshSerialize, Debug, Clone)]
#[derive(Serialize, Deserialize)]
pub struct OracleRequest {
    caller_account: AccountId,
    request_spec: Base64String,
    callback_address: AccountId,
    callback_method: String,
    data: Base64String,
    payment: u128,
    expiration: u64
}

#[derive(Serialize, Deserialize)]
pub struct SummaryJSON {
    account: AccountId,
    total_requests: u16, // TODO: choosing u16? need to enforce if so
}

#[derive(Serialize, Deserialize)]
pub struct RequestsJSON {
    nonce: U128,
    request: OracleRequest,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Oracle {
    pub owner: AccountId,
    pub link_account: AccountId,
    pub withdrawable_tokens: u128,
    pub nonces: TreeMap<AccountId, U128>,
    pub requests: TreeMap<AccountId, TreeMap<u128, OracleRequest>>,
    pub authorized_nodes: UnorderedSet<AccountId>,
}

impl Default for Oracle {
    fn default() -> Self {
        panic!("Oracle should be initialized before usage")
    }
}

#[near_bindgen]
impl Oracle {
    /// Initializes the contract with the given total supply owned by the given `owner_id` and `withdrawable_tokens`
    #[init]
    pub fn new(link_id: AccountId, owner_id: AccountId) -> Self {
        assert!(env::is_valid_account_id(owner_id.as_bytes()), "Owner's account ID is invalid");
        assert!(env::is_valid_account_id(link_id.as_bytes()), "Link token account ID is invalid");
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner: owner_id,
            link_account: link_id,
            withdrawable_tokens: 0_u128,
            nonces: TreeMap::new(b"nonces".to_vec()),
            requests: TreeMap::new(b"requests".to_vec()),
            authorized_nodes: UnorderedSet::new(b"authorized_nodes".to_vec()),
        }
    }

    /// This is the entry point that will use the escrow transfer_from.
    /// Afterwards, it essentially calls itself (store_request) which stores the request in state.
    pub fn request(&mut self, payment: U128, spec_id: Base64String, callback_address: AccountId, callback_method: String, nonce: U128, data_version: U128, data: Base64String) {
        self._check_callback_address(&callback_address);
        let nonce_u128: u128 = nonce.into();

        let entry_option = self.requests.get(&env::predecessor_account_id());
        if entry_option.is_some() {
            // Ensure there isn't already the same nonce
            let nonce_entry = entry_option.unwrap();
            if nonce_entry.contains_key(&nonce_u128) {
                env::panic(b"Existing account and nonce in requests");
            }
        }

        let last_nonce_option: Option<U128> = self.get_nonce(env::predecessor_account_id());
        if last_nonce_option.is_some() {
            let last_nonce_u128: u128 = last_nonce_option.unwrap().into();
            assert!(last_nonce_u128 < nonce_u128, format!("Invalid, already used nonce: {:?}", nonce_u128));
        }
        let has_nonce_option = self.nonces.get(&env::predecessor_account_id());
        let transfer_cost = if has_nonce_option.is_some() {
            0u128
        } else {
            TRANSFER_FROM_NEAR_COST
        };
        // first transfer token
        let promise_transfer_tokens = env::promise_create(
            self.link_account.clone(),
            b"transfer_from",
            json!({
                "owner_id": env::predecessor_account_id(),
                "new_owner_id": env::current_account_id(),
                "amount": payment,
            }).to_string().as_bytes(),
            transfer_cost,
            SINGLE_CALL_GAS,
        );

        // call this contract's request function after the transfer
        let promise_call_self_request = env::promise_then(
            promise_transfer_tokens,
            env::current_account_id(),
            b"store_request",
            json!({
                "sender": env::predecessor_account_id(),
                "payment": payment,
                "spec_id": spec_id,
                "callback_address": callback_address,
                "callback_method": callback_method,
                "nonce": nonce,
                "data_version": data_version,
                "data": data
            }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS
        );

        env::promise_return(promise_call_self_request);
    }

    /// Accounts/contracts should call request, which in turn calls this contract via a promise
    #[allow(unused_variables)] // for data_version, which is also not used in Solidity as I understand
    pub fn store_request(&mut self, sender: AccountId, payment: U128, spec_id: Base64String, callback_address: AccountId, callback_method: String, nonce: U128, data_version: U128, data: Base64String) {
        // this method should only ever be called from this contract
        self._only_owner_predecessor();

        // TODO: fix this "if" workaround until I can figure out how to write tests with promises
        if cfg!(target_arch = "wasm32") {
            assert_eq!(env::promise_results_count(), 1);
            // ensure successful promise, meaning tokens are transferred
            match env::promise_result(0) {
                PromiseResult::Successful(_) => {},
                PromiseResult::Failed => env::panic(b"The promise failed. See receipt failures."),
                PromiseResult::NotReady => env::panic(b"The promise was not ready."),
            };
        }

        // cast arguments in order to be formatted
        let payment_u128: u128 = payment.into();
        let nonce_u128: u128 = nonce.into();
        let expiration: u64 = env::block_timestamp() + EXPIRY_TIME;

        // store request
        let oracle_request = OracleRequest {
            caller_account: sender.clone(),
            request_spec: spec_id,
            callback_address,
            callback_method,
            data,
            payment: payment_u128,
            expiration,
        };

        // Insert request and commitment into state.
        /*
          account =>
            nonce => { Request }
        */
        let nonce_request_entry = self.requests.get(&sender);
        let mut nonce_request = if nonce_request_entry.is_none() {
            TreeMap::new(sender.clone().into_bytes())
        } else {
            nonce_request_entry.unwrap()
        };
        nonce_request.insert(&nonce_u128, &oracle_request);
        self.requests.insert(&sender.clone(), &nonce_request);
        self.nonces.insert(&sender.clone(), &nonce.clone());
        env::log(format!("Inserted request with\nKey: {:?}\nValue: {:?}", nonce_u128.clone(), oracle_request.clone()).as_bytes());
    }

    /// Note that the request_id here is String instead of Vec<u8> as might be expected from the Solidity contract
    pub fn fulfill_request(&mut self, account: AccountId, nonce: U128, data: Base64String) {
        self._only_authorized_node();

        // TODO: this is probably going to be too low at first, adjust
        assert!(env::prepaid_gas() - env::used_gas() > MINIMUM_CONSUMER_GAS_LIMIT, "Must provide consumer enough gas");

        // Get the request
        let account_requests = self.requests.get(&account);
        if account_requests.is_none() {
            env::panic(b"Did not find the account to fulfill.");
        }
        let nonce_u128: u128 = nonce.into();
        let request_option = account_requests.unwrap().get(&nonce_u128);
        if request_option.is_none() {
            env::panic(b"Did not find the request (nonce) to fulfill.");
        }
        let request = request_option.unwrap();

        let promise_perform_callback = env::promise_create(
            request.callback_address,
            request.callback_method.as_bytes(),
            json!({
                "nonce": nonce.clone(),
                "answer": data
            }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS
        );

        let promise_post_callback = env::promise_then(
            promise_perform_callback,
            env::current_account_id(),
            b"fulfillment_post_callback",
            json!({
                "account": account,
                "nonce": nonce
            }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS
        );

        env::promise_return(promise_post_callback);
    }

    pub fn fulfillment_post_callback(&mut self, account: AccountId, nonce: U128) {
        self._only_owner_predecessor();
        // TODO: fix this "if" workaround until I can figure out how to write tests with promises
        if cfg!(target_arch = "wasm32") {
            assert_eq!(env::promise_results_count(), 1);
            // ensure successful promise, meaning tokens are transferred
            match env::promise_result(0) {
                PromiseResult::Successful(_) => {},
                PromiseResult::Failed => env::panic(b"(fulfillment_post_callback) The promise failed. See receipt failures."),
                PromiseResult::NotReady => env::panic(b"The promise was not ready."),
            };
        }
        // Remove request from state
        let mut account_requests = self.requests.get(&account).unwrap();
        let nonce_u128: u128 = nonce.into();
        let payment = account_requests.get(&nonce_u128).unwrap().payment;
        account_requests.remove(&nonce_u128);
        // Must overwrite the new TreeMap with the account key
        self.requests.insert(&account, &account_requests);
        env::log(b"Request has completed successfully and been removed.");
        self.withdrawable_tokens += payment;
    }

    pub fn is_authorized(&self, node: AccountId) -> bool {
        self.authorized_nodes.contains(&node)
    }

    pub fn add_authorization(&mut self, node: AccountId) {
        self._only_owner();
        assert!(env::is_valid_account_id(node.as_bytes()), "Account ID is invalid");
        self.authorized_nodes.insert(&node);
    }

    pub fn remove_authorization(&mut self, node: AccountId) {
        self._only_owner();

        self.authorized_nodes.remove(&node);
    }

    pub fn withdraw(&mut self, recipient: AccountId, amount: U128) {
        self._only_owner();
        assert!(
            env::is_valid_account_id(recipient.as_bytes()),
            "Recipient account ID is invalid."
        );
        let amount_u128: u128 = amount.into();
        self._has_available_funds(amount_u128);

        let promise_withdraw = env::promise_create(
            self.link_account.clone(),
            b"transfer",
            json!({
                "owner_id": env::current_account_id(),
                "new_owner_id": recipient.clone(),
                "amount": amount.clone(),
            }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );

        // call this contract's panic function after refunding
        let promise_decrement_withdrawable = env::promise_then(
            promise_withdraw,
            env::current_account_id(),
            b"post_withdraw",
            json!({
                "amount": amount.clone()
            }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS * 2
        );

        env::promise_return(promise_decrement_withdrawable);
    }

    pub fn post_withdraw(&mut self, amount: U128) {
        self._only_owner_predecessor();
        assert_eq!(env::promise_results_count(), 1);
        match env::promise_result(0) {
            PromiseResult::Successful(_) => {},
            PromiseResult::Failed => env::panic(b"(post_withdraw) The promise failed. See receipt failures."),
            PromiseResult::NotReady => env::panic(b"The promise was not ready."),
        };

        let amount_u128: u128 = amount.into();
        self.withdrawable_tokens -= amount_u128.clone();
        env::log(b"Decremented withdrawable tokens")
    }

    /// Get up to first 65K accounts that have their own associated nonces => requests
    pub fn get_requests_summary(&self, max_num_accounts: U64) -> Vec<SummaryJSON> {
        let mut counter: u64 = 0;
        let max_num_accounts_u64: u64 = max_num_accounts.into();
        let mut result: Vec<SummaryJSON> = Vec::with_capacity(max_num_accounts_u64 as usize);

        for req in self.requests.iter() {
            self._request_summary_iterate(&max_num_accounts_u64, req, &mut result, &mut counter);
        }

        result
    }

    pub fn get_requests_summary_from(&self, from_account: AccountId, max_num_accounts: U64) -> Vec<SummaryJSON> {
        let mut counter: u64 = 0;
        let max_num_accounts_u64: u64 = max_num_accounts.into();
        let mut result: Vec<SummaryJSON> = Vec::with_capacity(max_num_accounts_u64 as usize);

        for req in self.requests.iter_from(from_account) {
            self._request_summary_iterate(&max_num_accounts_u64, req, &mut result, &mut counter);
        }

        result
    }

    /// Helper function while iterating through request summaries
    fn _request_summary_iterate(&self, max_num_accounts: &u64, req: (AccountId, TreeMap<u128, OracleRequest>), result: &mut Vec<SummaryJSON>, counter: &mut u64) {
        if *counter == *max_num_accounts || *counter > self.requests.len() {
            return
        }
        let account = req.0;
        let total_requests = req.1.len() as u16;
        result.push(SummaryJSON {
            account,
            total_requests
        });

        *counter += 1;
    }

    pub fn get_requests(&self, account: AccountId, max_requests: U64) -> Vec<RequestsJSON> {
        let max_requests_u64: u64 = max_requests.into();
        if !self.requests.contains_key(&account) {
            env::panic(format!("Account {} has no requests.", account).as_bytes());
        }
        let mut counter: u64 = 0;
        let mut result: Vec<RequestsJSON> = Vec::with_capacity(max_requests_u64 as usize);
        let account_requests_map = self.requests.get(&account).unwrap();

        for req in account_requests_map.iter() {
            self._request_iterate(&max_requests_u64, req, &mut result, &mut counter);
        }

        result
    }

    /// Helper function while iterating through account requests
    fn _request_iterate(&self, max_requests: &u64, req: (u128, OracleRequest), result: &mut Vec<RequestsJSON>, counter: &mut u64) {
        if *counter == *max_requests || *counter > self.requests.len() {
            return
        }
        let nonce = req.0;
        let oracle_request = req.1;
        result.push(RequestsJSON {
            nonce: U128(nonce),
            request: oracle_request,
        });

        *counter += 1;
    }

    pub fn get_all_requests(&self, max_num_accounts: U64, max_requests: U64) -> HashMap<AccountId, Vec<RequestsJSON>> {
        let max_requests_u64: u64 = max_requests.into();
        let max_num_accounts_u64: u64 = max_num_accounts.into();
        let mut account_counter: u64 = 0;
        let mut result: HashMap<AccountId, Vec<RequestsJSON>> = HashMap::new();

        for account_requests in self.requests.iter() {
            if account_counter == max_num_accounts_u64 || account_counter > self.requests.len() {
                break
            }
            let mut requests: Vec<RequestsJSON> = Vec::new();
            let mut request_counter: u64 = 0;
            for nonce_request in account_requests.1.iter() {
                if request_counter == max_requests_u64 || request_counter > account_requests.1.len() {
                    break
                }
                let req = RequestsJSON {
                    nonce: U128(nonce_request.0),
                    request: nonce_request.1
                };
                requests.push(req);
                request_counter += 1;
            }
            result.insert(account_requests.0.clone(), requests);
            account_counter += 1;
        }
        result
    }

    pub fn get_nonce(&self, account: AccountId) -> Option<U128> {
        self.nonces.get(&account)
    }

    pub fn get_nonces(&self) -> HashMap<AccountId, U128> {
        let mut result: HashMap<AccountId, U128> = HashMap::new();
        for nonce in self.nonces.iter() {
            result.insert(nonce.0.clone(), nonce.1.clone());
        }
        result
    }

    pub fn get_withdrawable_tokens(&self) -> u128 {
        self.withdrawable_tokens
    }

    pub fn reset(&mut self) {
        self._only_owner();
        self.requests.clear();
        env::log(b"Commitments and requests are cleared.");
    }

    /// Can be called after a cross-contract call before enforcing a panic
    pub fn panic(&mut self, error_message: String) {
        self._only_owner_predecessor();
        env::panic(error_message.as_bytes());
    }

    fn _has_available_funds(&mut self, amount: u128) {
        assert!(self.withdrawable_tokens >= amount, "Amount requested is greater than withdrawable balance.");
    }

    fn _only_owner(&mut self) {
        assert_eq!(env::signer_account_id(), env::current_account_id(), "Only contract owner can call this method.");
    }

    /// This is a helper function with the promises happening.
    /// The predecessor will be this account calling itself after transferring
    /// fungible tokens. Used for functions called via promises where we
    /// do not want end user accounts calling them directly.
    fn _only_owner_predecessor(&mut self) {
        assert_eq!(env::predecessor_account_id(), env::current_account_id(), "Only contract owner can sign transactions for this method.");
    }

    fn _only_authorized_node(&mut self) {
        assert!(self.authorized_nodes.contains(&env::signer_account_id()) || env::signer_account_id() == env::current_account_id(),
            "Not an authorized node to fulfill requests.");
    }

    fn _check_callback_address(&mut self, callback_address: &AccountId) {
        assert_ne!(callback_address, &self.link_account, "Cannot callback to LINK.");
        assert_ne!(callback_address, &env::current_account_id(), "Callback address cannot be the oracle contract.");
    }

    /// This method is not compile to the smart contract. It is used in tests only.
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_all_authorizations(&self) -> Vec<AccountId> {
        let nodes_vectorized = self.authorized_nodes.as_vector();
        let length = nodes_vectorized.len();
        let mut ret = Vec::new();
        for idx in 0..length {
            ret.push(nodes_vectorized.get(idx).unwrap());
        }
        ret
    }

    /// This method is not compile to the smart contract. It is used in tests only.
    #[cfg(not(target_arch = "wasm32"))]
    pub fn test_callback(&self, data: Vec<u8>) {
        println!("Received test callback with data: {:?}", data);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{MockedBlockchain, StorageUsage};
    use near_sdk::{testing_env, VMContext};
    use base64::{encode};

    fn link() -> AccountId { "link_near".to_string() }
    fn alice() -> AccountId { "alice_near".to_string() }
    fn bob() -> AccountId { "bob_near".to_string() }

    fn get_context(signer_account_id: AccountId, storage_usage: StorageUsage) -> VMContext {
        VMContext {
            current_account_id: alice(),
            signer_account_id,
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: alice(),
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            epoch_height: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
        }
    }

    #[test]
    fn make_request_validate_commitment() {
        let context = get_context(alice(), 0);
        testing_env!(context);
        let mut contract = Oracle::new(link(), alice(), );
        let sender = alice();
        let payment_json: U128 = 51319_u128.into();
        let spec_id = encode("unique spec id".to_string());
        let nonce = 1_u128;
        let nonce_json: U128 = nonce.into();
        let data_version_json: U128 = 131_u128.into();
        let data = encode("BAT".to_string());
        contract.store_request( sender, payment_json, spec_id, "callback.sender.testnet".to_string(), "my_callback_fn".to_string(), nonce_json, data_version_json, data);

        // second validate the serialized requests
        let max_requests: U64 = 1u64.into();
        let serialized_output = contract.get_requests(alice(), max_requests);
        let expiration_string = contract.requests.get(&alice()).unwrap().get(&nonce).unwrap().expiration.to_string();
        let expected_before_expiration = "[{\"nonce\":\"1\",\"request\":{\"caller_account\":\"alice_near\",\"request_spec\":\"dW5pcXVlIHNwZWMgaWQ=\",\"callback_address\":\"callback.sender.testnet\",\"callback_method\":\"my_callback_fn\",\"data\":\"QkFU\",\"payment\":51319,\"expiration\":";
        let expected_after_expiration = "}}]";
        let expected_result = format!("{}{}{}", expected_before_expiration, expiration_string, expected_after_expiration);
        let output_string = serde_json::to_string(serialized_output.as_slice());
        assert_eq!(expected_result, output_string.unwrap());
    }

    #[test]
    #[should_panic(
        expected = "Existing account and nonce in requests"
    )]
    fn make_duplicate_request() {
        let mut context = get_context(alice(), 0);
        context.attached_deposit = TRANSFER_FROM_NEAR_COST;
        testing_env!(context.clone());
        let mut contract = Oracle::new(link(), alice());
        let payment: U128 = 6_u128.into();
        let spec_id = encode("unique spec id".to_string());
        let callback_address = "callback.testnet".to_string();
        let callback_method = "test_callback".to_string();
        let nonce: U128 = 1_u128.into();
        let data_version: U128 = 131_u128.into();
        let data = encode("BAT".to_string());

        contract.request(payment.clone(), spec_id.clone(), callback_address.clone(), callback_method.clone(), nonce.clone(), data_version.clone(), data.clone());
        context.prepaid_gas = 10u64.pow(18);
        contract.store_request(alice(), payment.clone(), spec_id.clone(), callback_address.clone(), callback_method.clone(), nonce.clone(), data_version.clone(), data.clone());
        testing_env!(context.clone());

        contract.request(payment.clone(), spec_id.clone(), callback_address.clone(), callback_method.clone(), nonce.clone(), data_version.clone(), data.clone());
        contract.store_request(alice(), payment, spec_id, callback_address, callback_method, nonce, data_version, data);
    }

    #[test]
    #[should_panic(
        expected = "Invalid, already used nonce: 7"
    )]
    fn make_invalid_nonce_request() {
        let mut context = get_context(alice(), 0);
        context.attached_deposit = TRANSFER_FROM_NEAR_COST;
        testing_env!(context.clone());
        let mut contract = Oracle::new(link(), alice());
        let payment: U128 = 6_u128.into();
        let spec_id = encode("unique spec id".to_string());
        let callback_address = "callback.testnet".to_string();
        let callback_method = "test_callback".to_string();
        let data_version: U128 = 131_u128.into();
        let data = encode("BAT".to_string());

        contract.request(payment.clone(), spec_id.clone(), callback_address.clone(), callback_method.clone(), 8_u128.into(), data_version.clone(), data.clone());
        context.prepaid_gas = 10u64.pow(18);
        contract.store_request(alice(), payment.clone(), spec_id.clone(), callback_address.clone(), callback_method.clone(), 8_u128.into(), data_version.clone(), data.clone());
        testing_env!(context.clone());

        let default: U128 = 0_u128.into();
        let current_nonce: u128 = contract.get_nonce(alice()).unwrap_or(default).into();
        assert_eq!(current_nonce, 8_u128.into());

        let current_mapped_nonce: U128 = *contract.get_nonces().get(&alice()).clone().unwrap_or(&default);
        assert_eq!(current_mapped_nonce, 8_u128.into());

        contract.request(payment.clone(), spec_id.clone(), callback_address.clone(), callback_method.clone(), 7_u128.into(), data_version.clone(), data.clone());
        contract.store_request(alice(), payment, spec_id, callback_address, callback_method, 7_u128.into(), data_version, data);
    }

    #[test]
    fn check_authorization() {
        let context = get_context(alice(), 0);
        testing_env!(context);
        let mut contract = Oracle::new(link(), alice());
        let mut authorizations = contract.get_all_authorizations();
        let empty_vec: Vec<AccountId> = Vec::new();
        assert_eq!(empty_vec, authorizations);
        contract.add_authorization(alice());
        authorizations = contract.get_all_authorizations();
        let only_alice: Vec<AccountId> = vec![alice()];
        assert_eq!(only_alice, authorizations);
        contract.add_authorization(bob());
        let bob_is_authorized = contract.is_authorized(bob());
        assert_eq!(true, bob_is_authorized);
        contract.remove_authorization(bob());
        assert_eq!(only_alice, authorizations);
    }

    #[test]
    fn multiple_requests_to_json() {
        // Context: Alice
        let mut context = get_context(alice(), 0);
        testing_env!(context);
        // Set up contract
        let mut contract = Oracle::new(link(), alice());
        // Alice stores two requests
        contract.store_request( alice(), 6_u128.into(), "unique-id".to_string(), "callback.testnet".to_string(), "test_callback".to_string(), 1_u128.into(), 131_u128.into(), "BAT".to_string());
        contract.store_request( alice(), 6_u128.into(), "unique-id".to_string(), "callback.testnet".to_string(), "test_callback".to_string(), 2_u128.into(), 131_u128.into(), "NEAR".to_string());
        // Context: Bob
        context = get_context(bob(), env::storage_usage());
        testing_env!(context);
        contract.store_request( bob(), 6_u128.into(), "unique-id".to_string(), "callback.testnet".to_string(), "test_callback".to_string(), 1_u128.into(), 131_u128.into(), "BAT".to_string());
        // Context: Link
        context = get_context(link(), env::storage_usage());
        testing_env!(context);
        contract.store_request( link(), 6_u128.into(), "unique-id".to_string(), "callback.testnet".to_string(), "test_callback".to_string(), 1_u128.into(), 131_u128.into(), "BAT".to_string());

        let max_num_accounts: U64 = 2u64.into();
        let mut json_result = contract.get_requests_summary(max_num_accounts);
        let mut output_string = serde_json::to_string(json_result.as_slice());
        let mut expected_result = "[{\"account\":\"alice_near\",\"total_requests\":2},{\"account\":\"bob_near\",\"total_requests\":1}]";
        assert_eq!(output_string.unwrap(), expected_result);

        // now start after "alice_near"
        json_result = contract.get_requests_summary_from(alice(), max_num_accounts);
        expected_result = "[{\"account\":\"bob_near\",\"total_requests\":1},{\"account\":\"link_near\",\"total_requests\":1}]";
        output_string = serde_json::to_string(json_result.as_slice());
        assert_eq!(output_string.unwrap(), expected_result);
    }

    #[test]
    fn add_request_fulfill() {
        let mut context = get_context(alice(), 0);
        context.attached_deposit = TRANSFER_FROM_NEAR_COST;
        testing_env!(context);
        let mut contract = Oracle::new(link(), alice());
        // make request
        let payment: U128 = 6_u128.into();
        let spec_id = encode("unique spec id".to_string());
        let callback_address = "callback.testnet".to_string();
        let callback_method = "test_callback".to_string();
        let nonce= 1_u128;
        let nonce_json: U128 = nonce.into();
        let data_version: U128 = 131_u128.into();
        let data = encode("BAT".to_string());

        println!("Number of requests: {}", contract.requests.len());
        contract.request(payment.clone(), spec_id.clone(), callback_address.clone(), callback_method.clone(), nonce_json.clone(), data_version, data.clone());
        contract.store_request(alice(), payment, spec_id, callback_address.clone(), callback_method.clone(), nonce_json.clone(), data_version, data.clone());
        let max_num_accounts: U64 = 1u64.into();
        println!("{}", serde_json::to_string(contract.get_requests_summary(max_num_accounts).as_slice()).unwrap());
        // authorize bob
        contract.add_authorization(bob());

        // fulfill request
        let context = get_context(bob(), env::storage_usage());
        testing_env!(context);
        contract.fulfill_request(alice(), 1.into(), data);
    }
}
'''