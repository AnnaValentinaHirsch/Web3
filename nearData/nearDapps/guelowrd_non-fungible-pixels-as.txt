*GitHub Repository "guelowrd/non-fungible-pixels-as"*

'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports');
module.exports.include.push("contract/__tests__/index.unit.spec.ts");
'''
'''--- asconfig.json ---
{
  "workspaces": [
    "contract"
  ]
}
'''
'''--- contract/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- contract/__tests__/index.unit.spec.ts ---
import { VMContext } from "near-sdk-as";
import { Token, TokenEdition } from "../assembly/model";
import { createToken, getAllCreators, getAllEditionIds, getAllOwners, getAllTokenIds, getCreatorTokenIds, getEditionTokenId, getOwnerEditionIds, getTokenCreator, getTokenData, getTokenHeight, getTokenMaxNumberOfEditions, getTokenMintPrice, getTokenName, getTokenNumberOfMintedEditions, getTokenWidth, getTotalNumberOfTokens, getTotalNumberOfTokensCreated, mintToken } from "../assembly/index";
import { toYocto } from "../utils";

const token_id = "64291eaa92ff7a285bf5db0664576a1d6d74d51a7e3f8f849718a46838cda7";
const token_name = "TestToken";
const wallet_id = "nfp-test.testnet";
const mint_price = 1.234;

describe("Check token creation", () => {
    VMContext.setSigner_account_id(wallet_id);
    let tokenData = "0,255,0,123,0,0,0,255,0";
    let token: Token = createToken(token_name, 2, mint_price, tokenData, 3, 3);
    expect(token.getTokenId()).toStrictEqual(token_id);
    expect(getTokenName(token_id)).toStrictEqual(token_name);
    expect(getTokenCreator(token_id)).toStrictEqual(wallet_id);
    expect(getTokenMintPrice(token_id)).toStrictEqual(mint_price);
    expect(getTokenMaxNumberOfEditions(token_id)).toStrictEqual(2);
    expect(getTokenWidth(token_id)).toStrictEqual(3);
    expect(getTokenHeight(token_id)).toStrictEqual(3);
    expect(getTokenNumberOfMintedEditions(token_id)).toStrictEqual(0);
    expect(getTokenData(token_id).length).toStrictEqual(tokenData.split(',').length);
    expect(getTokenData(token_id).join(',')).toStrictEqual(tokenData);
    expect(getTotalNumberOfTokens()).toStrictEqual(1);
    expect(getTotalNumberOfTokensCreated()).toStrictEqual(1);
    expect(getAllCreators().length).toStrictEqual(1);
    expect(getAllCreators()[0]).toStrictEqual(wallet_id);
    expect(getAllTokenIds().length).toStrictEqual(1);
    expect(getAllTokenIds()[0]).toStrictEqual(token_id);
    expect(getCreatorTokenIds(wallet_id).length).toStrictEqual(1);
    expect(getCreatorTokenIds(wallet_id)[0]).toStrictEqual(token_id);
});

describe("Check token minting", () => {
    VMContext.setSigner_account_id(wallet_id);
    VMContext.setAttached_deposit(toYocto(mint_price));
    let mint0: TokenEdition = mintToken(token_id);
    let mint0_id = "bd9db3aa79845e1ad9768e1fbdac986ffa3b4a5ae4b542477f7a9f392d8e94";
    expect(mint0.getEditionId()).toStrictEqual(mint0_id);
    expect(getEditionTokenId(mint0_id)).toStrictEqual(token_id);
    expect(getTokenNumberOfMintedEditions(token_id)).toStrictEqual(1);
    expect(getAllEditionIds().length).toStrictEqual(1);
    expect(getAllEditionIds()[0]).toStrictEqual(mint0_id);
    expect(getOwnerEditionIds(wallet_id).length).toStrictEqual(1);
    expect(getOwnerEditionIds(wallet_id)[0]).toStrictEqual(mint0_id);    
    VMContext.setAttached_deposit(toYocto(mint_price));
    let mint1: TokenEdition = mintToken(token_id);
    let mint1_id = "394d9717f461c56c318cb6b25577b29c399dfbbe46637dedaa76a5c19b885d52";
    expect(mint1.getEditionId()).toStrictEqual(mint1_id);
    expect(getEditionTokenId(mint1_id)).toStrictEqual(token_id);
    expect(getTokenNumberOfMintedEditions(token_id)).toStrictEqual(2);
    expect(getAllEditionIds().length).toStrictEqual(2);
    expect(getAllEditionIds()[1]).toStrictEqual(mint1_id);
    expect(getOwnerEditionIds(wallet_id).length).toStrictEqual(2);
    expect(getOwnerEditionIds(wallet_id)[1]).toStrictEqual(mint1_id);    
    expect(getAllOwners().length).toStrictEqual(1);
    expect(getAllOwners()[0]).toStrictEqual(wallet_id);        
});
'''
'''--- contract/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- contract/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}
'''
'''--- contract/assembly/index.ts ---
import { Context, logging, PersistentVector, storage } from "near-sdk-as";
import { stringsToSha256, toYocto } from "../utils";
import { allCreators, allEditionIds, allEditionIdsByOwner, allEditionsById, allEditionsByToken, allOwners, allTokenIds, allTokenIdsByCreator, allTokensById, Token, TokenEdition } from "./model";

// This is a key in storage used to track the current number of tokens (to set IDs)
export const TOTAL_SUPPLY = 's'
// This is a key in storage used to track tokens data / tokens editions (to navigate through them)
const TOKEN_DATA = 'd'

////////////////////
// CHANGE METHODS //
////////////////////

/*
 * Creates a new token.
 */
export function createToken(name: string, nbEditions: u16, mintPrice: number, dataAsString: string, width: u8, height: u8): Token {
  let dataStrAsArr: string[] = dataAsString.split(',');
  let dataAsArray: Array<u8> = new Array<u8>();
  for (let i:i32 = 0; i < dataAsArray.length; ++i) {
    let d: u8 = parseInt(dataStrAsArr[i]) as u8;
    dataAsArray.push(d);
  }
  let arr = dataAsString.split(',');
  for (let i:i32 = 0; i < arr.length; i++) {
    dataAsArray.push(parseInt(arr[i]) as u8);
  }
  return init(name, nbEditions, mintPrice, dataAsArray, width, height);
}

/*
 * Mints a new edition of an existing token.
 */
 export function mintToken(token_id: string): TokenEdition {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);  
  return token!.mint();
}

//////////////////
// VIEW METHODS //
//////////////////

/*
 * Returns the token with a given id (returns null if no such id).
 */
export function getToken(token_id: string): Token | null {
  return allTokensById.get(token_id);
}

/*
 * Returns all the ids of all the tokens.
 */
export function getAllTokenIds(): Array<string> {
  let ret = new Array<string>();
  for (let i=0, length=allTokenIds.length; i<length; ++i) {
    ret.push(allTokenIds[i])
  }
  return ret;
}

/*
* Returns the current id counter (which SHOULD BE the number of all tokens ever created, assuming no deletion).
*/
export function getTotalNumberOfTokensCreated(): u64 {
  return storage.getPrimitive<u64>(TOTAL_SUPPLY, 0);
}

/*
* Returns the current id counter (which IS EXACTLY the number of tokens created and stored).
*/
export function getTotalNumberOfTokens(): u64 {
  return allTokensById.length;
}

/*
 * Returns the data (as an array) of a given token.
 */
 export function getTokenData(token_id: string): Array<u8> {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);
  return token!.getTokenData();
}

/*
 * Returns the width (number of pixels) of a given token.
 */
export function getTokenWidth(token_id: string): u8 {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);
  return token!.getWidth();
}

/*
 * Returns the height (number of pixels of a given token.
 */
export function getTokenHeight(token_id: string): u8 {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);
  return token!.getHeight();
}  

/*
 * Returns the name of a given token.
 */
 export function getTokenName(token_id: string): string {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);
  return token!.getName();
}

/*
 * Returns the mint price of a given token.
 */
export function getTokenMintPrice(token_id: string): number {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);
  return token!.getMintPrice();
}

/*
 * Returns the creator wallet of a given token.
 */
export function getTokenCreator(token_id: string): string {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);
  return token!.getCreator();
}

/*
 * Returns the maximum number of mintable editions of a given token.
 */
export function getTokenMaxNumberOfEditions(token_id: string): u64 {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);
  return token!.getNbEditions();
}

/*
 * Returns the number of already minted editions of a given token.
 */
 export function getTokenNumberOfMintedEditions(token_id: string): u64 {
  let token = getToken(token_id);
  assert(token != null, `Could not find token with id ${token_id}!`);
  return token!.getNbMints();
}

/*
 * Returns the edition with the given id (returns null if no such id).
 */
export function getEdition(edition_id: string): TokenEdition | null {
  return allEditionsById.get(edition_id);
}

/*
 * Returns all the ids of all the minted token editions.
 */
export function getAllEditionIds(): Array<string> {
  let ret = new Array<string>();
  for (let i=0, length=allEditionIds.length; i<length; ++i) {
    ret.push(allEditionIds[i])
  }
  return ret;
}

/*
 * Returns the token id of a given minted edition.
 */
export function getEditionTokenId(edition_id: string): string {
  let edition = getEdition(edition_id);
  assert(edition != null, `Could not find mint with id ${edition_id}!`);
  return edition!.getTokenId();
}

/*
 * Returns the ids of the tokens created by a given creator.
 */
export function getCreatorTokenIds(creator: string): Array<string> {
  let tokenIds = allTokenIdsByCreator.get(creator);
  assert(tokenIds != null && tokenIds.length > 0, `Could not find any tokens for creator ${creator}!`);
  return tokenIds!;
}

/*
 * Returns the ids of the minted editions owned by a given owner.
 */
export function getOwnerEditionIds(owner: string): Array<string> {
  let editionIds = allEditionIdsByOwner.get(owner);
  assert(editionIds != null && editionIds.length > 0, `Could not find any minted editions for owner ${owner}!`);
  return editionIds!;
}

/*
 * Returns all the creators of tokens.
 */
export function getAllCreators(): Array<string> {
  let ret = new Array<string>();
  for (let i=0, length=allCreators.length; i<length; ++i) {
    ret.push(allCreators[i])
  }
  return ret;
}

/*
 * Returns all the owners of minted editions.
 */
export function getAllOwners(): Array<string> {
  let ret = new Array<string>();
  for (let i=0, length=allOwners.length; i<length; ++i) {
    ret.push(allOwners[i])
  }
  return ret;
}

export function whatsyoursha(input: string): string {
  return stringsToSha256([input]);
}

//////////////////////
// INTERNAL METHODS //
//////////////////////

function init(name: string, nbEditions: u16, mintPrice: number, dataAsArray: Array<u8>, width: u8, height: u8): Token {
  logging.log(`Starting creating token ${name}...`);
  verifyData(dataAsArray, width, height);
  verifyMintPrice(mintPrice);
  let token_id = verifyNameAndGetTokenId(name);
  let id = getHowmaniethAndIncrementCounter();
  let tokenData = makeTokenDataAsPersistentVector(dataAsArray, width, height, id);
  let initToken = new Token(token_id, id, name, nbEditions, Context.sender, toYocto(mintPrice), tokenData, width, height);
  addTokenToAllMaps(token_id, initToken);
  return initToken;
}

function makeTokenDataAsPersistentVector(dataAsArray: Array<u8>, width: u8, height: u8, id: u64): PersistentVector<u8> {
  let data_id = [TOKEN_DATA, id.toString()].join('|');
  let tokenData = new PersistentVector<u8>(data_id);
  for (let p: u16 = 0; p < width*height; ++p) {
      tokenData.push(dataAsArray[p]);
  }
  return tokenData;
}

function verifyData(dataAsArray: Array<u8>, width: u8, height: u8): void {
  assert(dataAsArray.length == width*height, "Token data doesn't contain width*height elements!");
}

function verifyMintPrice(mintPrice: number): void {
  assert(floor(mintPrice*1000) == mintPrice*1000, "Mint price * 1000 must be an integer");
}

function verifyNameAndGetTokenId(name: string): string {
  assert(!name.includes('|'), "Token name cannot contain '|', the pipe character is forbidden!");
  let id = storage.getPrimitive<u64>(TOTAL_SUPPLY, 0);
  let idStr = id.toString();
  let token_id = stringsToSha256([name, idStr]);
  assert(allTokensById.get(token_id) == null, "Token name already exists!");
  return token_id;
}

function getHowmaniethAndIncrementCounter(): u64 {
  let id = storage.getPrimitive<u64>(TOTAL_SUPPLY, 0);
  storage.set<u64>(TOTAL_SUPPLY, id + 1);
  return id;
}

function addTokenToAllMaps(token_id: string, token: Token): void {
  let creator = token.getCreator();
  allTokensById.set(token_id, token);
  allTokenIds.push(token_id);
  let prevTokens = allTokenIdsByCreator.get(creator);
  if (prevTokens == null) {
    allTokenIdsByCreator.set(creator, [token_id]);
    allCreators.push(creator);
  } else {
    prevTokens.push(token_id);
    allTokenIdsByCreator.set(creator, prevTokens);
  }
  allEditionsByToken.set(token_id, new Array<TokenEdition>());
}
'''
'''--- contract/assembly/model.ts ---
import { Context, ContractPromiseBatch, PersistentUnorderedMap, PersistentVector, u128 } from "near-sdk-as"
import { stringsToSha256, asNEAR } from "../utils";

///////////////////////
// Types and storage //
///////////////////////

// This is a key in storage used to track all tokens / tokens editions (to navigate through them)
const ALL_TOKENS_BY_ID = 'a'
const ALL_TOKEN_IDS = 'i'
const ALL_EDITIONS_BY_TOKEN = 'b'
const ALL_TOKEN_IDS_BY_CREATOR = 'c'
const ALL_EDITIONS_BY_ID = 'e'
const ALL_EDITION_IDS = 'j'
const ALL_EDITION_IDS_BY_OWNER = 'o'
const ALL_CREATORS = 'f'
const ALL_OWNERS = 'p'

// This is a key in storage used to track tokens 
export const allTokensById = new PersistentUnorderedMap<string, Token>(ALL_TOKENS_BY_ID);
export const allTokenIds = new PersistentVector<string>(ALL_TOKEN_IDS);
export const allEditionsByToken = new PersistentUnorderedMap<string, Array<TokenEdition>>(ALL_EDITIONS_BY_TOKEN);
export const allEditionsById = new PersistentUnorderedMap<string, TokenEdition>(ALL_EDITIONS_BY_ID);
export const allTokenIdsByCreator = new PersistentUnorderedMap<string, Array<string>>(ALL_TOKEN_IDS_BY_CREATOR);
export const allEditionIds = new PersistentVector<string>(ALL_EDITION_IDS);
export const allEditionIdsByOwner = new PersistentUnorderedMap<string, Array<string>>(ALL_EDITION_IDS_BY_OWNER);
export const allCreators = new PersistentVector<string>(ALL_CREATORS);
export const allOwners = new PersistentVector<string>(ALL_OWNERS);

@nearBindgen
export class Token {
  constructor(
    private token_id: string,
    private howManieth: u64,
    private name: string, 
    private nbEditions: u16,
    private creator: string,
    private mintPrice: u128,
    private tokenData: PersistentVector<u8>,
    private width: u8,
    private height: u8
  ) {}

  mint(): TokenEdition {
    assert(Context.accountBalance >= this.mintPrice, `Account balance must be higher than mint price ${asNEAR(this.mintPrice)}Ⓝ!`);
    assert(Context.attachedDeposit >= this.mintPrice, `Attached deposit must be higher than mint price ${asNEAR(this.mintPrice)}Ⓝ!`);
    assert(this.getNbMints() < this.nbEditions, `Token cannot be minted anymore, max number of ${this.nbEditions.toString()} editions have already been minted!`)
    const to_creator = ContractPromiseBatch.create(this.creator);
    to_creator.transfer(this.mintPrice);
    let prevEditions = allEditionsByToken.get(this.token_id)!;
    let edition_id = stringsToSha256([this.name, this.howManieth.toString(), prevEditions.length.toString()]);
    let owner = Context.sender;
    let edition = new TokenEdition(this.token_id, edition_id, owner);
    prevEditions.push(edition);
    allEditionsByToken.set(this.token_id, prevEditions);
    allEditionsById.set(edition_id, edition);
    allEditionIds.push(edition_id);
    let prevOwnersEditions = allEditionIdsByOwner.get(owner);
    if (prevOwnersEditions == null) {
      allEditionIdsByOwner.set(owner, [edition_id]);
      allOwners.push(owner);
    } else {
      prevOwnersEditions.push(edition_id);
      allEditionIdsByOwner.set(owner, prevOwnersEditions);
    }    
    return edition;
  }

  getTokenId(): string {
    return this.token_id;
  }

  getName(): string {
    return this.name;
  }

  getHowManieth(): u64 {
    return this.howManieth;
  }

  getNbEditions(): u16 {
    return this.nbEditions;
  }

  getNbMints(): u16 {
    return u16(allEditionsByToken.get(this.token_id)!.length);
  }

  getCreator(): string {
    return this.creator;
  }

  getMintPrice(): number {
    return parseFloat(asNEAR(this.mintPrice));
  }

  getTokenData(): Array<u8> {
    let tokenData = new Array<u8>();
    for (let p: u16 = 0; p < this.width*this.height; ++p) {
      tokenData.push(this.tokenData[p]);
    }
    return tokenData;
  } 

  getWidth(): u8 {
    return this.width;
  }

  getHeight(): u8 {
    return this.height;
  }
}

@nearBindgen
export class TokenEdition {
  constructor(
    private token_id: string,
    private tokenedition_id: string,
    private owner_id: string
  ) {}

  getTokenId(): string {
    return this.token_id;
  }

  getEditionId(): string {
    return this.tokenedition_id;
  }

  getOwner(): string {
    return this.owner_id;
  }  
}
'''
'''--- contract/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
}
'''
'''--- contract/utils.ts ---
import { math, u128 } from "near-sdk-as";

export const ONE_MILLINEAR = u128.from("1000000000000000000000");
/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
 export function asNEAR(amount: u128): string {
  let u128amt = u128.div(amount, ONE_MILLINEAR).toString();
  return (parseFloat(u128amt)/1000).toString();
  }
  
  /**
   * @function toYocto
   * @param amount {number} - Amount to convert (amount*1000 must be an integer)
   * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
   *
   * @example
   *
   *    toYocto(7)
   *    // => 7000000000000000000000000
   */
  export function toYocto(amount: number): u128 {
    let amountx1000 = 1000*amount;
    return u128.mul(ONE_MILLINEAR, u128.from(amountx1000));
  }

  /**
   * @function stringsToSha256
   * @param values {Array<string>}  - List of infos as strings
   * @returns {string}              - SHA256 hash of the input as strings
   *
   * @example
   *
   *    stringsToSha256(["NFT", "0", "0"])
   *    // => a091bb74baa72ecd427e817493596d83411c83aeae53b6907e9f7a37fd3167
   */
  export function stringsToSha256(values: Array<string>): string {
    let value = values.join('|');
    let buffer = new ArrayBuffer(value.length * 2); // 2 bytes per char
    let view = Uint8Array.wrap(buffer);
    for (let i = 0, length = value.length; i < length; i++) {
      view[i] = value.charCodeAt(i);
    }
    let hashArray = math.sha256(view);
    let hashHex: string = '';
    for (let i = 0, length = hashArray.length; i < length; i++) {
      hashHex += hashArray[i].toString(16).slice(-2);
    }    
    return hashHex;
}
'''
'''--- package.json ---
{
  "name": "non-fungible-pixels-as",
  "version": "0.0.1",
  "description": "Basic NFT implementation with on-chain content (aka \"Non Fungible Pixels\")",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "author": "gl@arrozestudios.pt",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.2.1"
  },
  "dependencies": {
    "source-map-support": "^0.5.21"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e
echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build:release

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo ---------------------------------------------------------
echo

# comment the line below to deploy the other example contract
near dev-deploy ./build/release/contract.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
echo ---------------------------------------------------------
echo

exit 0
'''
'''--- scripts/2.create-token.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1

# [ -z "$1" ] && echo "Add your token's name!" && exit 1
# [ -z "$2" ] && echo "Add your token's max number of editions!" && exit 1
# [ -z "$3" ] && echo "Add your token's mint price!" && exit 1
# [ -z "$4" ] && echo "Add your token's data (pixels value between 0 and 255, comma separated)!" && exit 1
# [ -z "$5" ] && echo "Add your token's width (nb pixels)!" && exit 1
# [ -z "$6" ] && echo "Add your token's height (nb pixels)!" && exit 1

echo
echo "We are about to create a new token! Be ready..."
echo

near call $CONTRACT createToken --accountId $BENEFICIARY '{"name": "TestToken", "nbEditions": 2, "mintPrice": 2.345, "dataAsString": "0,0,0,255", "width": 2, "height": 2}'
# near view $CONTRACT getTokenCreator '{"name": "TestNFP001" }'

exit 0
'''
'''--- scripts/3.clean-up.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0
'''