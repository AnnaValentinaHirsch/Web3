*GitHub Repository "kaito2001/near-arbitrage"*

'''--- README.md ---
# near-arbitrage

## factory
near dev-deploy res/token_factory.wasm
FACTORY_ID=dttfactory.testnet
TOKEN1=dtt.dev-1656188046462-83531633920883
TOKEN2=dtt1.dev-1656188046462-83531633920883
TOKEN3=dtt2.dev-1656188046462-83531633920883
TOKEN4=dtt3.dev-1656188046462-83531633920883
TOKEN5=dtt4.dev-1656188046462-83531633920883
near call $FACTORY_ID new --account-id $FACTORY_ID
near call $FACTORY_ID storage_deposit --account-id $FACTORY_ID --deposit 50
near call $FACTORY_ID create_token "{"args": {"owner_id":\"$FACTORY_ID\", "total_supply": "100000000000", "can_faucet": true, "metadata": {"spec": "ft-1.0.0","name": "DTT Token","symbol": "DTT","decimals": 2}}}" --account-id $FACTORY_ID --gas 200000000000000
near call $FACTORY_ID create_token "{\"args\": {\"owner_id\":\"$FACTORY_ID\", \"total_supply\": \"100000000000\", \"can_faucet\": true, \"metadata\": {\"spec\": \"ft-1.0.0\",\"name\": \"DTT Token1\",\"symbol\": \"DTT1\",\"decimals\": 2}}}" --account-id $FACTORY_ID --gas 200000000000000
near call $FACTORY_ID create_token "{\"args\": {\"owner_id\":\"$FACTORY_ID\", \"total_supply\": \"100000000000\", \"can_faucet\": true, \"metadata\": {\"spec\": \"ft-1.0.0\",\"name\": \"DTT Token2\",\"symbol\": \"DTT2\",\"decimals\": 2}}}" --account-id $FACTORY_ID --gas 200000000000000
near call $FACTORY_ID create_token "{\"args\": {\"owner_id\":\"$FACTORY_ID\", \"total_supply\": \"100000000000\", \"can_faucet\": true, \"git remote add origin git@github.com:kaito2001/Near-Arbitrage.git
git branch -M main
git push -u origin mainmetadata\": {\"spec\": \"ft-1.0.0\",\"name\": \"DTT Token3\",\"symbol\": \"DTT3\",\"decimals\": 2}}}" --account-id $FACTORY_ID --gas 200000000000000
near call $FACTORY_ID create_token "{\"args\": {\"owner_id\":\"$FACTORY_ID\", \"total_supply\": \"100000000000\", \"can_faucet\": true, \"metadata\": {\"spec\": \"ft-1.0.0\",\"name\": \"DTT Token4\",\"symbol\": \"DTT4\",\"decimals\": 2}}}" --account-id $FACTORY_ID --gas 200000000000000
near call $TOKEN1 faucet --account-id $FACTORY_ID

## ref-exchange
near dev-deploy res/ref_exchange_release.wasm
CONTRACT_ID=dev-1656234694287-14038558864682
USER_ID=dev-1656188046462-83531633920883
near call $DEX1 new "{\"owner_id\": \"$USER_ID\", \"exchange_fee\": 0, \"referral_fee\": 0}" --accountId $DEX1 && near call $DEX2 new "{\"owner_id\": \"$USER_ID\", \"exchange_fee\": 0, \"referral_fee\": 0}" --accountId $DEX2 && near call $DEX3 new "{\"owner_id\": \"$USER_ID\", \"exchange_fee\": 0, \"referral_fee\": 0}" --accountId $DEX3 && near call $DEX4 new "{\"owner_id\": \"$USER_ID\", \"exchange_fee\": 0, \"referral_fee\": 0}" --accountId $DEX4 && near call $DEX5 new "{\"owner_id\": \"$USER_ID\", \"exchange_fee\": 0, \"referral_fee\": 0}" --accountId $DEX5

near call $CONTRACT_ID extend_whitelisted_tokens "{\"tokens\": [\"$TOKEN3\", \"$TOKEN4\", \"$TOKEN5\"]}" --accountId $CONTRACT_ID --depositYocto 1
near call $CONTRACT_ID storage_deposit --accountId $USER_ID --deposit 1
near call $TOKEN1 storage_deposit "{\"account_id\": \"$CONTRACT_ID\"}" --accountId $CONTRACT_ID --deposit 0.125
near call $TOKEN2 storage_deposit "{\"account_id\": \"$CONTRACT_ID\"}" --accountId $CONTRACT_ID --deposit 0.125
near call $TOKEN3 storage_deposit "{\"account_id\": \"$CONTRACT_ID\"}" --accountId $CONTRACT_ID --deposit 0.125
near call $TOKEN4 storage_deposit "{\"account_id\": \"$CONTRACT_ID\"}" --accountId $CONTRACT_ID --deposit 0.125
near call $TOKEN5 storage_deposit "{\"account_id\": \"$CONTRACT_ID\"}" --accountId $CONTRACT_ID --deposit 0.125
near call $CONTRACT_ID register_tokens "{\"token_ids\": [\"$TOKEN3\", \"$TOKEN4\", \"$TOKEN5\"]}" --accountId $USER_ID --depositYocto 1

near call $TOKEN1 ft_transfer_call "{\"receiver_id\": \"$CONTRACT_ID\", \"amount\": \"10000000\", \"msg\": \"\"}" --accountId $USER_ID --depositYocto 1 --gas 200000000000000
near call $TOKEN2 ft_transfer_call "{\"receiver_id\": \"$CONTRACT_ID\", \"amount\": \"2000000\", \"msg\": \"\"}" --accountId $USER_ID --depositYocto 1 --gas 200000000000000
near call $CONTRACT_ID add_simple_pool "{\"tokens\": [\"$TOKEN3\", \"$TOKEN5\"], \"fee\": 0}" --accountId $USER_ID --deposit 0.1
near call $CONTRACT_ID add_liquidity '{"pool_id": 6, "amounts": ["1000000", "1400000"]}' --accountId $USER_ID --deposit 1

## Arbitrage
near dev-deploy res/arbitrage.wasm
ARBITRAGE_ID=dev-1657604972480-41950724296317
near call $ARBITRAGE_ID new --account-id $ARBITRAGE_ID
near call $ARBITRAGE_ID add_dexs "{\"dexs\": [\"$DEX1\", \"$DEX2\", \"$DEX3\", \"$DEX4\", \"$DEX5\"]}" --account-id $ARBITRAGE_ID --depositYocto 1
near call $TOKEN2 storage_deposit --account-id $ARBITRAGE_ID --deposit 0.25 && near call $TOKEN5 storage_deposit --account-id $ARBITRAGE_ID --deposit 0.25 && near call $TOKEN1 faucet --account-id $ARBITRAGE_ID && near call $TOKEN5 faucet --account-id $ARBITRAGE_ID && near call $CONTRACT_ID storage_deposit --account-id $ARBITRAGE_ID --deposit 1 && near call $TOKEN1 ft_transfer_call "{\"receiver_id\": \"$CONTRACT_ID\", \"amount\": \"100000\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN5 ft_transfer_call "{\"receiver_id\": \"$CONTRACT_ID\", \"amount\": \"100000\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000

near call $TOKEN1 ft_transfer_call "{\"receiver_id\": \"$ARBITRAGE_ID\", \"amount\": \"1000\", \"msg\": \"{\"dex_id\":\"$CONTRACT_ID\", \"actions\": [{\"pool_id\": 0, \"token_in\": \"$TOKEN1\", \"amount_in\": \"1000\", \"token_out\": \"$TOKEN2\", \"min_amount_out\": \"1\"}]}\"}" --accountId $USER_ID --depositYocto 1 --gas 300000000000000

'''
'''--- contracts/arbitrage/Cargo.toml ---
[package]
name = "arbitrage"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contracts/arbitrage/build.bat ---
@echo off

title Arbitrage build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\arbitrage.wasm %CD%\res /Y
pause

'''
'''--- contracts/arbitrage/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/factory.wasm
'''
'''--- contracts/arbitrage/neardev/dev-account.env ---
CONTRACT_NAME=dev-1657604972480-41950724296317
'''
'''--- contracts/arbitrage/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::U128;
use near_sdk::{
    env, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault, PromiseResult, serde_json, assert_one_yocto, Promise
};
use crate::utils::{ext_dex, ext_self, ext_ft, XCC_GAS, GAS_FOR_FT_TRANSFER, GAS_FOR_WITHDRAW};
mod token_receiver;
mod utils;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Dexs
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Action {
    pub pool_id: u64,
    pub token_in: AccountId,
    pub amount_in: Option<U128>,
    pub token_out: AccountId,
    pub min_amount_out: U128,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner: AccountId,
    pub dexs: UnorderedSet<AccountId>
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            owner: env::predecessor_account_id(),
            dexs: UnorderedSet::new(StorageKey::Dexs),
        }
    }

    #[payable]
    pub fn add_dexs(&mut self, dexs: Vec<AccountId>) {
        assert_one_yocto();
        assert!(self.is_owner(), "Not owner");
        for dex in dexs {
            self.dexs.insert(&dex);
        }
    }

    #[payable]
    pub fn ft_deposit(&mut self, ft_account: AccountId) -> Promise {
        assert!(env::attached_deposit() >= 1250000000000000000000, "You need attach more yocto");
        ext_ft::ext(ft_account)
        .with_attached_deposit(1250000000000000000000)
        .with_static_gas(GAS_FOR_FT_TRANSFER)
        .storage_deposit(
            env::predecessor_account_id(),
            true,
        )
    }

    pub fn get_dexs(&self, from_index: u64, limit: u64) -> Vec<AccountId> {
        let dexs = self.dexs.as_vector();
        (from_index..std::cmp::min(from_index + limit, dexs.len()))
            .map(|index| dexs.get(index).unwrap())
            .collect()
    }

    #[private]
    pub fn callback_after_swap(
        &mut self,
        sender_id: AccountId,
        dex_id: AccountId,
        token_out: AccountId
    ) {
        assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULTS");
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(amount) = serde_json::from_slice::<U128>(&val) {
                    ext_dex::ext(dex_id)
                    .with_attached_deposit(1)
                    .with_static_gas(GAS_FOR_WITHDRAW)
                    .withdraw(token_out.clone(), amount, None);
                    ext_ft::ext(token_out)
                    .with_attached_deposit(1)
                    .with_static_gas(GAS_FOR_FT_TRANSFER)
                    .ft_transfer(sender_id, amount, None);
                } else {
                    env::panic_str("ERR_WRONG_VAL_RECEIVED")
                }
            }
            PromiseResult::Failed => env::panic_str("ERR_CALL_FAILED"),
        }
    }
}

impl Contract {
    pub fn is_owner(&self) -> bool {
        return self.owner == env::predecessor_account_id(); 
    }
}
pub(crate) fn xcc_actions(
        dex_id: AccountId,
        sender_id: AccountId,
        token_in: AccountId,
        amount_in: Balance,
        actions: Vec<Action>
    ) {
        let token_out: AccountId = actions[actions.len() -1].token_out.clone();
        ext_ft::ext(token_in)
        .with_attached_deposit(1)
        .with_static_gas(GAS_FOR_FT_TRANSFER)
        .ft_transfer_call(dex_id.clone(), U128(amount_in), None, String::from(""));
        ext_dex::ext(dex_id.clone())
            .with_static_gas(XCC_GAS)
            .with_attached_deposit(1)
            .swap(actions, None)
            .then(
                ext_self::ext(env::current_account_id())
                .callback_after_swap(sender_id.clone(), dex_id, token_out.clone())
            );
    }
'''
'''--- contracts/arbitrage/src/token_receiver.rs ---
use crate::*;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, serde_json, PromiseOrValue, AccountId};
use near_sdk::json_types::U128;

/// Message parameters to receive via token function call.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Execute {
        pub dex_id: AccountId,
        pub actions: Vec<Action>
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Callback on receiving tokens by this contract.
    /// `msg` format is either "" for deposit or `TokenReceiverMessage`.
    #[allow(unreachable_code)]
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_in = env::predecessor_account_id();
        if msg.is_empty() {
            PromiseOrValue::Value(amount)
        } else {
            let message =
                serde_json::from_str::<Execute>(&msg).expect("Wrong format!");
                xcc_actions(
                    message.dex_id,
                    sender_id,
                    token_in,
                    amount.0,
                    message.actions
                );
                PromiseOrValue::Value(U128(0))
            }

    }
}
'''
'''--- contracts/arbitrage/src/utils.rs ---
use near_sdk::{ext_contract, Gas, AccountId, Promise};
use near_sdk::json_types::U128;
use near_contract_standards::storage_management::StorageBalance;
use crate::Action;
pub const GAS_FOR_FT_TRANSFER: Gas = Gas(5_000_000_000_000);
pub const GAS_FOR_WITHDRAW: Gas = Gas(50_000_000_000_000);
pub const XCC_GAS: Gas = Gas(10_000_000_000_000);

#[ext_contract(ext_ft)]
pub trait FungibleToken {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> U128;
    fn storage_deposit(account_id: AccountId, registration_only: bool) -> StorageBalance;
}

#[ext_contract(ext_dex)]
pub trait Dex {
    fn swap(&mut self, actions: Vec<Action>, referral_id: Option<AccountId>) -> U128;
    fn withdraw(
        &mut self,
        token_id: AccountId,
        amount: U128,
        unregister: Option<bool>,
    ) -> Promise;
}

#[ext_contract(ext_self)]
pub trait ContractActions {
    fn callback_after_swap(
        sender_id: AccountId,
        dex_id: AccountId,
        token_out: AccountId
    );
}
'''
'''--- contracts/factory/Cargo.toml ---
[package]
name = "token-factory"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contracts/factory/build.bat ---
@echo off

title Token Factory build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- contracts/factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/factory.wasm
'''
'''--- contracts/factory/neardev/dev-account.env ---
CONTRACT_NAME=dev-1656188046462-83531633920883
'''
'''--- contracts/factory/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;
use near_sdk::{
    env, near_bindgen, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault, Promise,
};

near_sdk::setup_alloc!();

const FT_CODE: &[u8] = include_bytes!("../ft-builds/ft.wasm");
const FT_FAUCET_CODE: &[u8] = include_bytes!("../ft-builds/ft_faucet.wasm");

const EXTRA_BYTES: usize = 10000;
const GAS: Gas = 100_000_000_000_000; //100000000000000
type TokenId = String;

pub fn is_valid_token_id(token_id: &TokenId) -> bool {
    for c in token_id.as_bytes() {
        match c {
            b'0'..=b'9' | b'a'..=b'z' => (),
            _ => return false,
        }
    }
    true
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Tokens,
    StorageDeposits,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenFactory {
    pub tokens: UnorderedMap<TokenId, TokenArgs>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub storage_balance_cost: Balance,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenArgs {
    owner_id: ValidAccountId,
    total_supply: U128,
    metadata: FungibleTokenMetadata,
    can_faucet: bool
}

#[near_bindgen]
impl TokenFactory {
    #[init]
    pub fn new() -> Self {
        let mut storage_deposits = LookupMap::new(StorageKey::StorageDeposits);

        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = "a".repeat(64);
        storage_deposits.insert(&tmp_account_id, &0);
        let storage_balance_cost =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;
        storage_deposits.remove(&tmp_account_id);

        Self {
            tokens: UnorderedMap::new(StorageKey::Tokens),
            storage_deposits,
            storage_balance_cost,
        }
    }

    fn get_min_attached_balance(&self, args: &TokenArgs) -> u128 {
        if args.can_faucet {
        return ((FT_FAUCET_CODE.len() + EXTRA_BYTES + args.try_to_vec().unwrap().len() * 2) as Balance
            * STORAGE_PRICE_PER_BYTE)
            .into();
        }
        ((FT_CODE.len() + EXTRA_BYTES + args.try_to_vec().unwrap().len() * 2) as Balance
            * STORAGE_PRICE_PER_BYTE)
            .into()
    }

    pub fn get_required_deposit(&self, args: TokenArgs, account_id: ValidAccountId) -> U128 {
        let args_deposit = self.get_min_attached_balance(&args);
        if let Some(previous_balance) = self.storage_deposits.get(account_id.as_ref()) {
            args_deposit.saturating_sub(previous_balance).into()
        } else {
            (self.storage_balance_cost + args_deposit).into()
        }
    }

    #[payable]
    pub fn storage_deposit(&mut self) {
        let account_id = env::predecessor_account_id();
        let deposit = env::attached_deposit();
        if let Some(previous_balance) = self.storage_deposits.get(&account_id) {
            self.storage_deposits
                .insert(&account_id, &(previous_balance + deposit));
        } else {
            assert!(deposit >= self.storage_balance_cost, "Deposit is too low");
            self.storage_deposits
                .insert(&account_id, &(deposit - self.storage_balance_cost));
        }
    }

    pub fn get_number_of_tokens(&self) -> u64 {
        self.tokens.len()
    }

    pub fn get_tokens(&self, from_index: u64, limit: u64) -> Vec<(AccountId, TokenArgs)> {
        let keys = self.tokens.keys_as_vector();
        let tokens = self.tokens.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, self.tokens.len()))
            .map(|index| (keys.get(index).unwrap(), tokens.get(index).unwrap()))
            .collect()
    }

    pub fn get_token(&self, token_id: TokenId) -> Option<TokenArgs> {
        self.tokens.get(&token_id)
    }

    pub fn storage_balance_of(&self, account_id: ValidAccountId) -> U128 {
        U128(self.storage_deposits.get(account_id.as_ref()).unwrap_or(0))
    }

    #[payable]
    pub fn create_token(&mut self, args: TokenArgs) -> Promise {
        if env::attached_deposit() > 0 {
            self.storage_deposit();
        }
        args.metadata.assert_valid();
        let token_id = args.metadata.symbol.to_ascii_lowercase();
        assert!(is_valid_token_id(&token_id), "Invalid Symbol");
        let token_account_id = format!("{}.{}", token_id, env::current_account_id());
        assert!(
            env::is_valid_account_id(token_account_id.as_bytes()),
            "Token Account ID is invalid"
        );

        let account_id = env::predecessor_account_id();

        let required_balance = self.get_min_attached_balance(&args);
        let user_balance = self.storage_deposits.get(&account_id).unwrap_or(0);
        assert!(
            user_balance >= required_balance,
            "Not enough required balance"
        );
        self.storage_deposits
            .insert(&account_id, &(user_balance - required_balance));

        let initial_storage_usage = env::storage_usage();

        assert!(
            self.tokens.insert(&token_id, &args).is_none(),
            "Token ID is already taken"
        );

        let storage_balance_used =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;

        if args.can_faucet {
            return Promise::new(token_account_id)
            .create_account()
            .transfer(required_balance - storage_balance_used)
            .deploy_contract(FT_FAUCET_CODE.to_vec())
            .function_call(b"new".to_vec(), serde_json::to_vec(&args).unwrap(), 0, GAS);
        }
        Promise::new(token_account_id)
            .create_account()
            .transfer(required_balance - storage_balance_used)
            .deploy_contract(FT_CODE.to_vec())
            .function_call(b"new".to_vec(), serde_json::to_vec(&args).unwrap(), 0, GAS)
    }
}

'''
'''--- contracts/ft/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- contracts/ft/build.bat ---
@echo off

title Token build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- contracts/ft/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue, assert_one_yocto};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Example NEAR fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial tokens supply is minted"),
        }
        .emit();
        this
    }

    #[payable]
    pub fn faucet(&mut self) {
        assert_one_yocto();
        let receiver_id = env::predecessor_account_id();
        let faucet_amount = 1000 * 10u128.pow(self.metadata.get().unwrap().decimals as u32);
        self.token.internal_deposit(&receiver_id, faucet_amount.into());
        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &receiver_id,
            amount: &U128(faucet_amount),
            memo: Some("Faucet tokens is minted"),
        }
        .emit();
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}
'''
'''--- setup.md ---
TOKEN1=fsweat.v4.ftfactory.testnet
TOKEN2=fflux.v4.ftfactory.testnet
TOKEN3=faur.v4.ftfactory.testnet
TOKEN4=fusdt.v4.ftfactory.testnet
TOKEN5=fusdc.v4.ftfactory.testnet
TOKEN6=fbtc.v4.ftfactory.testnet
TOKEN7=foct.v4.ftfactory.testnet

FACTORY_ID=v4.ftfactory.testnet
USER_ID=hub.dexgateway.testnet
ARBITRAGE_ID=hub.dexgateway.testnet
ARBITRAGE=hub.dexgateway.testnet
DEX1=dexv1.dexgateway.testnet
DEX2=dexv2.dexgateway.testnet
DEX3=dexv3.dexgateway.testnet

VAL1="1000000000000000000000"
VAL2="200000000000000000000000000000"
VAL3="30000000000000000000000000"
VAL4="40000000000000000000000000"
VAL5="30000000000000000000000000"
VAL6="2000000000000000"
VAL7="20000000000000000000000000000000"

VAL12="500000000000000000000"
VAL24="50000000000000000000000000000"
VAL34="7500000000000000000000000"
VAL42="2000000000000000000000000"
VAL58="3750000000000000000000000"
VAL64="500000000000000"
VAL74="5000000000000000000000000000000"

VAL14="200000000000000000000"
VAL22="80000000000000000000000000000"
VAL44="8000000000000000000000000"
VAL54="7000000000000000000000000"
VAL72="8000000000000000000000000000000"

VAL32="1200000000000000000000000"

near call $TOKEN1 storage_deposit "{\"account_id\": \"$DEX1\"}" --accountId $DEX1 --deposit 0.00125 && near call $TOKEN2 storage_deposit "{\"account_id\": \"$DEX1\"}" --accountId $DEX1 --deposit 0.00125 && near call $TOKEN3 storage_deposit "{\"account_id\": \"$DEX1\"}" --accountId $DEX1 --deposit 0.00125 && near call $TOKEN4 storage_deposit "{\"account_id\": \"$DEX1\"}" --accountId $DEX1 --deposit 0.00125 && near call $TOKEN5 storage_deposit "{\"account_id\": \"$DEX1\"}" --accountId $DEX1 --deposit 0.00125 && near call $TOKEN6 storage_deposit "{\"account_id\": \"$DEX1\"}" --accountId $DEX1 --deposit 0.00125 && near call $TOKEN7 storage_deposit "{\"account_id\": \"$DEX1\"}" --accountId $DEX1 --deposit 0.00125

near call $TOKEN1 storage_deposit "{\"account_id\": \"$DEX2\"}" --accountId $DEX2 --deposit 0.00125 && near call $TOKEN2 storage_deposit "{\"account_id\": \"$DEX2\"}" --accountId $DEX2 --deposit 0.00125 && near call $TOKEN3 storage_deposit "{\"account_id\": \"$DEX2\"}" --accountId $DEX2 --deposit 0.00125 && near call $TOKEN4 storage_deposit "{\"account_id\": \"$DEX2\"}" --accountId $DEX2 --deposit 0.00125 && near call $TOKEN5 storage_deposit "{\"account_id\": \"$DEX2\"}" --accountId $DEX2 --deposit 0.00125 && near call $TOKEN6 storage_deposit "{\"account_id\": \"$DEX2\"}" --accountId $DEX2 --deposit 0.00125 && near call $TOKEN7 storage_deposit "{\"account_id\": \"$DEX2\"}" --accountId $DEX2 --deposit 0.00125

near call $TOKEN1 storage_deposit "{\"account_id\": \"$DEX3\"}" --accountId $DEX3 --deposit 0.00125 && near call $TOKEN2 storage_deposit "{\"account_id\": \"$DEX3\"}" --accountId $DEX3 --deposit 0.00125 && near call $TOKEN3 storage_deposit "{\"account_id\": \"$DEX3\"}" --accountId $DEX3 --deposit 0.00125 && near call $TOKEN4 storage_deposit "{\"account_id\": \"$DEX3\"}" --accountId $DEX3 --deposit 0.00125 && near call $TOKEN5 storage_deposit "{\"account_id\": \"$DEX3\"}" --accountId $DEX3 --deposit 0.00125 && near call $TOKEN6 storage_deposit "{\"account_id\": \"$DEX3\"}" --accountId $DEX3 --deposit 0.00125 && near call $TOKEN7 storage_deposit "{\"account_id\": \"$DEX3\"}" --accountId $DEX3 --deposit 0.00125 

near call $TOKEN1 storage_deposit "{\"account_id\": \"$ARBITRAGE\"}" --accountId $ARBITRAGE --deposit 0.00125 && near call $TOKEN2 storage_deposit "{\"account_id\": \"$ARBITRAGE\"}" --accountId $ARBITRAGE --deposit 0.00125 && near call $TOKEN3 storage_deposit "{\"account_id\": \"$ARBITRAGE\"}" --accountId $ARBITRAGE --deposit 0.00125 && near call $TOKEN4 storage_deposit "{\"account_id\": \"$ARBITRAGE\"}" --accountId $ARBITRAGE --deposit 0.00125 && near call $TOKEN5 storage_deposit "{\"account_id\": \"$ARBITRAGE\"}" --accountId $ARBITRAGE --deposit 0.00125 && near call $TOKEN6 storage_deposit "{\"account_id\": \"$ARBITRAGE\"}" --accountId $ARBITRAGE --deposit 0.00125 && near call $TOKEN7 storage_deposit "{\"account_id\": \"$ARBITRAGE\"}" --accountId $ARBITRAGE --deposit 0.00125

 near call $DEX1 storage_deposit --accountId $ARBITRAGE_ID --deposit 8 && near call $DEX2 storage_deposit --accountId $ARBITRAGE_ID --deposit 8 && near call $DEX3 storage_deposit --accountId $ARBITRAGE_ID --deposit 8 && near call $DEX1 register_tokens "{\"token_ids\": [\"$TOKEN1\", \"$TOKEN2\", \"$TOKEN3\", \"$TOKEN4\", \"$TOKEN5\", \"$TOKEN6\", \"$TOKEN7\"]}" --accountId $USER_ID --depositYocto 1 && near call $DEX2 register_tokens "{\"token_ids\": [\"$TOKEN1\", \"$TOKEN2\", \"$TOKEN3\", \"$TOKEN4\", \"$TOKEN5\", \"$TOKEN6\", \"$TOKEN7\"]}" --accountId $USER_ID --depositYocto 1 && near call $DEX3 register_tokens "{\"token_ids\": [\"$TOKEN1\", \"$TOKEN2\", \"$TOKEN3\", \"$TOKEN4\", \"$TOKEN5\", \"$TOKEN6\", \"$TOKEN7\"]}" --accountId $USER_ID --depositYocto 1

near call $DEX1 register_tokens "{\"token_ids\": [\"$TOKEN1\", \"$TOKEN2\", \"$TOKEN3\", \"$TOKEN4\", \"$TOKEN5\", \"$TOKEN6\", \"$TOKEN7\"]}" --accountId $ARBITRAGE_ID --depositYocto 1 && near call $DEX2 register_tokens "{\"token_ids\": [\"$TOKEN1\", \"$TOKEN2\", \"$TOKEN3\", \"$TOKEN4\", \"$TOKEN5\", \"$TOKEN6\", \"$TOKEN7\"]}" --accountId $ARBITRAGE_ID --depositYocto 1 && near call $DEX3 register_tokens "{\"token_ids\": [\"$TOKEN1\", \"$TOKEN2\", \"$TOKEN3\", \"$TOKEN4\", \"$TOKEN5\", \"$TOKEN6\", \"$TOKEN7\"]}" --accountId $ARBITRAGE_ID --depositYocto 1

near call $TOKEN1 ft_transfer_call "{\"receiver_id\": \"$DEX1\", \"amount\": \"$VAL1\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN2 ft_transfer_call "{\"receiver_id\": \"$DEX1\", \"amount\": \"$VAL2\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN3 ft_transfer_call "{\"receiver_id\": \"$DEX1\", \"amount\": \"$VAL3\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN4 ft_transfer_call "{\"receiver_id\": \"$DEX1\", \"amount\": \"$VAL4\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN5 ft_transfer_call "{\"receiver_id\": \"$DEX1\", \"amount\": \"$VAL5\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN6 ft_transfer_call "{\"receiver_id\": \"$DEX1\", \"amount\": \"$VAL6\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN7 ft_transfer_call "{\"receiver_id\": \"$DEX1\", \"amount\": \"$VAL7\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000

near call $TOKEN1 ft_transfer_call "{\"receiver_id\": \"$DEX2\", \"amount\": \"$VAL1\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN2 ft_transfer_call "{\"receiver_id\": \"$DEX2\", \"amount\": \"$VAL2\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN3 ft_transfer_call "{\"receiver_id\": \"$DEX2\", \"amount\": \"$VAL3\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN4 ft_transfer_call "{\"receiver_id\": \"$DEX2\", \"amount\": \"$VAL4\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN5 ft_transfer_call "{\"receiver_id\": \"$DEX2\", \"amount\": \"$VAL5\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN6 ft_transfer_call "{\"receiver_id\": \"$DEX2\", \"amount\": \"$VAL6\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN7 ft_transfer_call "{\"receiver_id\": \"$DEX2\", \"amount\": \"$VAL7\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000

near call $TOKEN1 ft_transfer_call "{\"receiver_id\": \"$DEX3\", \"amount\": \"$VAL1\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN2 ft_transfer_call "{\"receiver_id\": \"$DEX3\", \"amount\": \"$VAL2\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN3 ft_transfer_call "{\"receiver_id\": \"$DEX3\", \"amount\": \"$VAL3\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN4 ft_transfer_call "{\"receiver_id\": \"$DEX3\", \"amount\": \"$VAL4\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN5 ft_transfer_call "{\"receiver_id\": \"$DEX3\", \"amount\": \"$VAL5\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN6 ft_transfer_call "{\"receiver_id\": \"$DEX3\", \"amount\": \"$VAL6\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000 && near call $TOKEN7 ft_transfer_call "{\"receiver_id\": \"$DEX3\", \"amount\": \"$VAL7\", \"msg\": \"\"}" --accountId $ARBITRAGE_ID --depositYocto 1 --gas 200000000000000

near call $DEX1 add_simple_pool "{\"tokens\": [\"$TOKEN1\", \"$TOKEN2\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_simple_pool "{\"tokens\": [\"$TOKEN3\", \"$TOKEN4\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_simple_pool "{\"tokens\": [\"$TOKEN4\", \"$TOKEN5\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_simple_pool "{\"tokens\": [\"$TOKEN5\", \"$TOKEN6\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_simple_pool "{\"tokens\": [\"$TOKEN6\", \"$TOKEN7\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_simple_pool "{\"tokens\": [\"$TOKEN7\", \"$TOKEN3\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1  && near call $DEX1 add_simple_pool "{\"tokens\": [\"$TOKEN2\", \"$TOKEN5\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1

near call $DEX2 add_simple_pool "{\"tokens\": [\"$TOKEN1\", \"$TOKEN2\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_simple_pool "{\"tokens\": [\"$TOKEN1\", \"$TOKEN4\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_simple_pool "{\"tokens\": [\"$TOKEN3\", \"$TOKEN7\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_simple_pool "{\"tokens\": [\"$TOKEN3\", \"$TOKEN6\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_simple_pool "{\"tokens\": [\"$TOKEN4\", \"$TOKEN5\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_simple_pool "{\"tokens\": [\"$TOKEN5\", \"$TOKEN6\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1

near call $DEX3 add_simple_pool "{\"tokens\": [\"$TOKEN1\", \"$TOKEN2\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_simple_pool "{\"tokens\": [\"$TOKEN2\", \"$TOKEN4\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_simple_pool "{\"tokens\": [\"$TOKEN2\", \"$TOKEN5\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_simple_pool "{\"tokens\": [\"$TOKEN3\", \"$TOKEN6\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_simple_pool "{\"tokens\": [\"$TOKEN4\", \"$TOKEN7\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_simple_pool "{\"tokens\": [\"$TOKEN5\", \"$TOKEN6\"], \"fee\": 0}" --accountId $ARBITRAGE_ID --deposit 0.1

near call $DEX1 add_liquidity "{\"pool_id\": 0, \"amounts\": [\"$VAL12\", \"$VAL24\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_liquidity "{\"pool_id\": 1, \"amounts\": [\"$VAL34\", \"$VAL42\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_liquidity "{\"pool_id\": 2, \"amounts\": [\"$VAL42\", \"$VAL58\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_liquidity "{\"pool_id\": 3, \"amounts\": [\"$VAL58\", \"$VAL64\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_liquidity "{\"pool_id\": 4, \"amounts\": [\"$VAL64\", \"$VAL74\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_liquidity "{\"pool_id\": 5, \"amounts\": [\"$VAL74\", \"$VAL34\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX1 add_liquidity "{\"pool_id\": 6, \"amounts\": [\"$VAL24\", \"$VAL58\"]}" --accountId $ARBITRAGE_ID --deposit 0.1

near call $DEX2 add_liquidity "{\"pool_id\": 0, \"amounts\": [\"$VAL12\", \"$VAL24\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 1, \"amounts\": [\"$VAL34\", \"$VAL42\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 2, \"amounts\": [\"$VAL42\", \"$VAL58\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 3, \"amounts\": [\"$VAL58\", \"$VAL64\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 4, \"amounts\": [\"$VAL64\", \"$VAL74\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 5, \"amounts\": [\"$VAL74\", \"$VAL34\"]}" --accountId $ARBITRAGE_ID --deposit 0.1

near call $DEX2 add_liquidity "{\"pool_id\": 0, \"amounts\": [\"$VAL14\", \"$VAL22\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 1, \"amounts\": [\"$VAL14\", \"$VAL44\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 2, \"amounts\": [\"$VAL34\", \"$VAL72\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 3, \"amounts\": [\"$VAL34\", \"$VAL64\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 4, \"amounts\": [\"$VAL44\", \"$VAL54\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX2 add_liquidity "{\"pool_id\": 5, \"amounts\": [\"$VAL54\", \"$VAL64\"]}" --accountId $ARBITRAGE_ID --deposit 0.1

near call $DEX3 add_liquidity "{\"pool_id\": 0, \"amounts\": [\"$VAL12\", \"$VAL54\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 1, \"amounts\": [\"$VAL24\", \"$VAL44\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 2, \"amounts\": [\"$VAL24\", \"$VAL54\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 3, \"amounts\": [\"$VAL32\", \"$VAL64\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 4, \"amounts\": [\"$VAL44\", \"$VAL72\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 5, \"amounts\": [\"$VAL54\", \"$VAL64\"]}" --accountId $ARBITRAGE_ID --deposit 0.1

near call $ARBITRAGE_ID add_dexs "{\"dexs\": [\"$DEX1\", \"$DEX2\", \"$DEX3\"]}" --account-id $ARBITRAGE_ID --depositYocto 1
'''
'''--- test.md ---
near call $DEX3 add_liquidity "{\"pool_id\": 0, \"amounts\": [\"$VAL12\", \"$VAL24\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 1, \"amounts\": [\"$VAL34\", \"$VAL42\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 2, \"amounts\": [\"$VAL42\", \"$VAL58\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 3, \"amounts\": [\"$VAL58\", \"$VAL64\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 4, \"amounts\": [\"$VAL64\", \"$VAL74\"]}" --accountId $ARBITRAGE_ID --deposit 0.1 && near call $DEX3 add_liquidity "{\"pool_id\": 5, \"amounts\": [\"$VAL74\", \"$VAL34\"]}" --accountId $ARBITRAGE_ID --deposit 0.1
'''
'''--- ui/changelog.md ---
## 1.0.0 initial release
- Implement basic features and smart contracts.
'''
'''--- ui/jsconfig.json ---
{
  "compilerOptions": {
    "baseUrl": "."
  }
}

'''
'''--- ui/next.config.js ---
module.exports = {
  reactStrictMode: true,
  env: {
    mongodburl: "your Mongo DB atlas URL",
  }
};
'''
'''--- ui/package.json ---
{
  "name": "near-arbitrage",
  "version": "5.0.0",
  "private": true,
  "scripts": {
    "clean": "rm -rf ./build/",
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "post-update": "echo \"codesandbox preview only, need an update\" && yarn upgrade --latest"
  },
  "dependencies": {
    "@chakra-ui/icons": "^2.0.2",
    "@chakra-ui/react": "^2.2.1",
    "@emotion/cache": "latest",
    "@emotion/react": "latest",
    "@emotion/server": "latest",
    "@emotion/styled": "latest",
    "ethers": "^5.7.2",
    "formik": "^2.2.9",
    "framer-motion": "^6.3.15",
    "googleapis": "^95.0.0",
    "mini-svg-data-uri": "^1.4.4",
    "near-api-js": "^0.41.0",
    "next": "latest",
    "pg": "^8.7.3",
    "prop-types": "latest",
    "react": "latest",
    "react-dom": "latest",
    "react-dropzone": "^14.2.1"
  },
  "devDependencies": {
    "eslint": "latest",
    "eslint-config-next": "latest"
  }
}
'''
'''--- ui/src/createEmotionCache.js ---
import createCache from '@emotion/cache';

// prepend: true moves MUI styles to the top of the <head> so they're loaded first.
// It allows developers to easily override MUI styles with other styling solutions, like CSS modules.
export default function createEmotionCache() {
  return createCache({ key: 'css', prepend: true });
}

'''
'''--- ui/src/middleware/postgres.js ---
const {Pool} =  require('pg');

const connectDB = (handler) => async (req, res) => {
  const pool = new Pool({
    user: "public_readonly",
    host: "testnet.db.explorer.indexer.near.dev",
    database: "testnet_explorer",
    password: "nearprotocol"
  });
  return handler(req, res, pool);
};

export default connectDB;

'''
'''--- ui/src/state/actions.js ---
import BN from "bn.js";
import {
    parseNearAmount,
    factoryId,
    arbitrageId
} from "./near";
import { transactions } from "near-api-js";
import { loadRequiredDeposit } from "./views";

export const createNewFT = async (account, args) => {
    const amount = await loadRequiredDeposit(account, account.accountId, args);
    console.log(args)
    let actions = [
        transactions.functionCall(
            "create_token",
            Buffer.from(JSON.stringify({ args: args })),
            200000000000000,
            "0"
        ),
    ];
    if (amount) {
        actions.unshift(
            transactions.functionCall(
                "storage_deposit",
                {},
                10000000000000,
                new BN(amount).add(new BN("1000000"))
            )
        );
    }
    const result = await account.signAndSendTransaction({
        receiverId: factoryId,
        actions: actions,
    });
    return result;
};

export const faucetFT = async (account, seed_id) => {
    account
        .viewFunction(seed_id, "storage_balance_of", {
            account_id: account.accountId,
        }).then(res => {
            let actions = [
                transactions.functionCall(
                    "faucet",
                    { receiver_id: account.accountId },
                    10000000000000,
                    "1"
                ),
            ];
            if (!res) {
                actions.unshift(
                    transactions.functionCall(
                        "storage_deposit",
                        { account_id: account.accountId },
                        10000000000000,
                        parseNearAmount('0.125')
                    )
                );
            }
            account.signAndSendTransaction({
                receiverId: seed_id,
                actions: actions,
            });
        })
};

export const depositFT = async (account, seed_id) => {
    await account.functionCall(
        seed_id,
        "storage_deposit",
        {},
        200000000000000,
        parseNearAmount("0.1250001")
    );
};

export const swapAction = async (account, dex, actions, tokenIn, amountIn) => {
    let msg = JSON.stringify({
        dex_id: dex,
        actions: actions
    });
    let tokenOut = actions[actions.length - 1].token_out;
    account
        .viewFunction(tokenOut, "storage_balance_of", {
            account_id: account.accountId,
        }).then(async res => {
            if (!res) {
                await account.functionCall(
                    tokenOut,
                    "storage_deposit",
                    {},
                    200000000000000,
                    parseNearAmount("0.1250001")
                );
            } else {
                await account.functionCall(
                    tokenIn,
                    "ft_transfer_call",
                    Buffer.from(JSON.stringify({
                        receiver_id: arbitrageId,
                        amount: amountIn.toString(),
                        msg: msg
                    })),
                    300000000000000,
                    1
                );
            }
        })
}

'''
'''--- ui/src/state/app.js ---
import { State } from './provider';

import { arbitrageId, initNear } from './near';

const initialState = {
	app: {
		mounted: false,
	},
	near: {
		initialized: false,
	},
	dexs: {
		list: [],
		mounted: false
	},
	tokens: {
		list: [],
		mounted: false
	},
	pools: {
		list: [],
		mounted: false
	},
	contractAccount: {},
	tokenMatrix : {}
};

export const { appStore, AppProvider } = State(initialState, 'app');

export const onAppMount = () => async ({ dispatch }) => {
	dispatch(initNear());
};

export const mountDexs = () => async ({ update, getState }) => {
	const { app, contractAccount } = await getState();
	if (app.mounted) {
		contractAccount
			.viewFunction(arbitrageId, "get_dexs", {
				from_index: 0,
				limit: 100
			}).then(res => {
				update('dexs', { mounted: true, list: res })
			});
	}
}

export const mountPools = (dex_id) => async ({ update, getState }) => {
	const { app, contractAccount } = await getState();
	if (app.mounted) {
		let pools = await contractAccount
			.viewFunction(dex_id, "get_pools", {
				from_index: 0,
				limit: 100
			});
		let tokenMatrix = {};
		let tokenSet = new Set();
		let matrixP = new Promise((resolve, _) => {
			pools.forEach((item, index, array) => {
				let token1 = item.token_account_ids[0];
				let token2 = item.token_account_ids[1];
				tokenSet.add(token1);
				tokenSet.add(token2);
				if (tokenMatrix.hasOwnProperty(token1)) {
					if (tokenMatrix[token1].hasOwnProperty(token2)) {
						tokenMatrix[token1][token2].push(index);
					} else {
						tokenMatrix[token1][token2] = [index];
					}
				} else {
					tokenMatrix[token1] = {};
					tokenMatrix[token1][token2] = [index];
				}

				if (tokenMatrix.hasOwnProperty(token2)) {
					if (tokenMatrix[token2].hasOwnProperty(token1)) {
						tokenMatrix[token2][token1].push(index);
					} else {
						tokenMatrix[token2][token1] = [index];
					}
				} else {
					tokenMatrix[token2] = {};
					tokenMatrix[token2][token1] = [index];
				}
				if( index == array.length -1) resolve();
			});
		});
		matrixP.then(() => {
			update('tokenMatrix', tokenMatrix);
			update('tokens', { list: Array.from(tokenSet), mounted:true})
		})
		update('pools', { mounted: true, list: pools })
	}
}

export const getSteps = (tokenIn, tokenOut, tokenMatrix) => {
	let par = {};
	let visit = [tokenIn];
	let q = [tokenIn];
	while (q.length) {
        let u = q[0];
		q.shift();
		let ku = Object.keys(tokenMatrix[u]);
		for (let v =0; v < ku.length; v++) {
			if (!visit.includes(ku[v])) {
				par[ku[v]] = u;
				visit.push(ku[v]);
				q.push(ku[v]);
			}
		}
	}
	if (!visit.includes(tokenOut)) return [];
	let steps = [];
	while(tokenOut != tokenIn) {
		steps.push(tokenOut);
		tokenOut = par[tokenOut];
	}
	steps.push(tokenIn)
	steps.reverse();
	return steps;
}
'''
'''--- ui/src/state/near.js ---
import * as nearAPI from 'near-api-js';

export const arbitrageId = "hub.dexgateway.testnet";
export const factoryId = "v4.ftfactory.testnet";

export const {
	utils: {
		format: {
			formatNearAmount, parseNearAmount
		}
	}
} = nearAPI;

const getWallet = async() => {
	const keyStores = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
	const near = await nearAPI.connect({
		networkId: "testnet",
		deps: {
			keyStore: keyStores
		},
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
		});
	const wallet = new nearAPI.WalletConnection(near);
		
	const contractAccount = new nearAPI.Account(near.connection, arbitrageId);
	return { near, wallet, contractAccount };
}

export const initNear = () => async ({ update }) => {
	const { near, wallet, contractAccount } = await getWallet();
	wallet.signIn = () => {
		wallet.requestSignIn(arbitrageId, 'Near arbitrage');
	};
	const signOut = wallet.signOut;
	wallet.signOut = () => {
		signOut.call(wallet);
		update('wallet.signedIn', false);
		update('', { account: null });
	};

	wallet.signedIn = wallet.isSignedIn();

	let account;
	if (wallet.signedIn) {
		account = wallet.account();
		wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 4);
		await update('', { near, wallet, contractAccount, account });
	}

	await update('', { near, wallet, contractAccount, account });
	await update('app', { mounted: true });
};

export const updateWallet = () => async ({ update, getState }) => {
	const { wallet } = await getState();
	wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 2);
	await update('', { wallet });
};
'''
'''--- ui/src/state/provider.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		if (path.length === 0) {
			return { ...state, ...newState };
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- ui/src/state/views.js ---
import { BigNumber, ethers } from "ethers";
import { factoryId, arbitrageId } from "../state/near";

export const getDexs = async (
    contractAccount,
    from_index,
    limit
) => {
    let data = await contractAccount
        .viewFunction(arbitrageId, "get_dexs", {
            from_index: from_index,
            limit: limit,
        })
        .catch((e) => {
            console.log(e);
        });
    return data;
};

export const getPools = async (
    contractAccount,
    from_index,
    limit
) => {
    let data = await contractAccount
        .viewFunction(arbitrageId, "get_dexs", {
            from_index: from_index,
            limit: limit,
        })
        .catch((e) => {
            console.log(e);
        });
    return data;
};

export const loadFungibleTokens = async (
    contractAccount,
    from_index,
    limit
) => {
    let data = await contractAccount
        .viewFunction(factoryId, "get_tokens", {
            from_index: from_index,
            limit: limit,
        })
        .catch((e) => {
            console.log(e);
        });
    return data;
};

export const loadFungibleToken = (contractAccount, ft) => {
    return contractAccount
        .viewFunction(ft, "ft_metadata", {})
        .catch((e) => {
            console.log(e);
        });
};

export const loadNumberTokens = async (contractAccount) => {
    let data = await contractAccount
        .viewFunction(factoryId, "get_number_of_tokens")
        .catch((e) => {
            console.log(e);
            return 0;
        });
    return data ? data : 0;
};

export const loadRequiredDeposit = async (
    contractAccount,
    account_id,
    args
) => {
    let data = await contractAccount
        .viewFunction(factoryId, "get_required_deposit", {
            args: args,
            account_id: account_id,
        })
        .catch((e) => {
            console.log(e);
            return 0;
        });
    return data ? data : 0;
};

export const ftStorage = async (contractAccount, seed_id, account_id) => {
    let data = await contractAccount
        .viewFunction(seed_id, "storage_balance_of", {
            account_id: account_id,
        })
        .catch((e) => {
            return 0;
        });
    return data ? data.total : 0;
};

export const loadFTMeta = async (contractAccount, tokens) => {
    let promises = [];
    tokens.forEach(item => {
        promises.push(contractAccount.viewFunction(item, 'ft_metadata'));
    })
    let result = await Promise.all(promises);
    return result;
};

export const loadBalance = async (account, tokenId) => {
    let balance = await account.viewFunction(tokenId, 'ft_balance_of', {account_id: account.accountId});
    let {decimals} = await account.viewFunction(tokenId, 'ft_metadata', { account_id: account.accountId });

    return parseFloat(ethers.utils.formatUnits(BigNumber.from(balance), decimals)).toFixed(4);
};

export const loadPools = async (account, dex) => {
    let pools = await account.viewFunction(dex, 'get_pools', { from_index: 0, limit:10 });

    return pools;
};

'''