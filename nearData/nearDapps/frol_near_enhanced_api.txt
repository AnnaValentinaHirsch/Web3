*GitHub Repository "frol/near_enhanced_api"*

'''--- Cargo.toml ---
[package]
name = "near-enhanced-api"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
publish = false
rust-version = "1.61.0"
edition = "2021"

[dependencies]
actix-web = "4.0.1"
actix-http = "3.0.4"
actix-cors = "0.6.1"
borsh = { version = "0.9.1" }
derive_more = "0.99.9"
dotenv = "0.15.0"
futures = "0.3.5"
hex = "0.4"
num-traits = "0.2.15"
paperclip = { version = "0.7.0", features = ["v2", "v3", "actix4"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
strum = { version = "0.24", features = ["derive"] }
sqlx = { version = "0.5.13", features = ["runtime-tokio-native-tls", "postgres", "bigdecimal", "json"] }
tokio = { version = "1.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = "0.2"
validator = "0.12"

near-primitives = "0.14.0"
near-jsonrpc-client = "0.4.0-beta.0"
near-jsonrpc-primitives = "0.14.0"

[dev-dependencies]
insta = "1"

'''
'''--- DB_DESIGN.md ---
# DB Enhancement Proposals

We have found some issues in Indexer DB.
In order to provide all the desired features to the API, we have some required and some aspirational changes.

## New requirements for any assets__* table:
1. enumeration column that goes through all the events. Required for all endpoints with pagination.  
   Let's say we can have max 10_000 of all the events per chunk  
   max 1000 of different standards  
   max 10_000 chunks  
We take timestamp in milliseconds to have more available slots for storing the info.  
We also multiply timestamp to a big number, so that we have 10^35 in general.  
It will allow us to change the format further without breaking the compatibility.  
   The formula:
```
timestamp_millis * 100_000_000_000 * 100_000_000_000 + chunk_index * 10_000_000 + assets_type * 10_000 + index_of_event
```
It gives us the number like this:
```
16565042430000000000000000030070027 -> 10^35
```
Major thing: it fits into `i128` (10^38).

## New requirements for assets__fungible_token_events table:
1. Change old/new account_id to affected/involved account_id.
2. Add absolute value column. Required for balance request.
3. Rename it to something_with_coins, add coin_id column (later we will also store MT there).

## New requirements for account_changes and balances table:
1. Change the table so that we have the same enumeration column. Required for native_history (pagination)  
   Let's say we can have max 1_000_000 of balance changing actions per chunk  
   max 10_000 chunks  
   The formula:
```
timestamp_millis * 10_000_000_000 * 1_000_000_000_000 + chunk_index * 1_000_000 + index_in_chunk
```
It gives us the number like this:
```
16565042430000000000000000003000027 -> 10^35
```
Major thing: it fits into `i128` (10^38).

## Ideas how to make the queries faster:
1. Add table with the NEAR balance daily by account_id. Will speed up native_balance
2. Add table with the FT balance daily by account_id. Will speed up coin_balances
3. Add table with the MT balance daily by account_id. Will speed up coin_balances
4. Add table with the NFT countings daily by account_id. Will speed up nft_collection_overview
5. check_account_exists already works faster in Aurora DB. This will speed up all the endpoints a bit
6. Add table with FT, MT, NFT contract metadatas by timestamp. I'd prefer to check this once in an hour. Do we want to add something like "enforce checking new metadata"? Will speed up all the places where we provide metadata (almost all endpoints)
7. Add table with MT, NFT tokens metadata.

'''
'''--- README.md ---
# NEAR Enhanced API

API for providing useful information about NEAR blockchain.  
Still under heavy development.

### Phase 1 goals: [development goes here now]
- Provide NEAR balances information, recent history
- Provide FT balances information, recent FT coin history for the contracts implementing Events NEP
- Provide NFT information and recent history for the contracts implementing Events NEP
- Provide corresponding Metadata for FT, NFT contracts, NFT items
- [aspirational] Collect usage statistics which could help us to prioritize next steps

Note, Phase 1 will **not** provide pagination through all the history.  
Phase 1 also does **not** provide the information about contracts which are not upgraded to Events NEP.

If you are interested in a more detailed development status, use `git clone` and search for `TODO PHASE 1`.  
See also our thoughts about the proposed [DB design](DB_DESIGN.md) which will help us to achieve Phase 2 goals.

### Future plans. Phase 2 goals:
- Provide pagination for all existing endpoints where applicable
- Support contracts which are not upgraded to Events NEP, such as `wrap.near`, `aurora`
- Add reconciliation logic
- [aspirational] Show data from failed receipts in the history
- [aspirational] Support MT contracts 
- [aspirational] Support of querying the balance/history info by symbol (e.g. `GET "/accounts/{account_id}/coins/USN"`) 

### Future plans. Phase 3+ goals:
- Make wrappers around existing RPC endpoints for the general blockchain info (blocks, chunks, transactions, etc.)

## How to run it yourself

You need to create `.env` file with 3 variables: `DATABASE_URL`, `DATABASE_URL_BALANCES`, `RPC_URL`.  
`DATABASE_URL_BALANCES` is a temp solution with the new table, it's under development.

All the other stuff is super standard for Rust world.  
To modify and then review tests, use `cargo insta review`.

'''
'''--- src/config.rs ---
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Config {
    pub addr: String,
    pub cors_allowed_origins: Vec<String>,
    #[serde(default)]
    pub limits: LimitsConfig,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            addr: "0.0.0.0:3050".to_owned(),
            cors_allowed_origins: vec!["*".to_owned()],
            limits: LimitsConfig::default(),
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct LimitsConfig {
    pub input_payload_max_size: usize,
}

impl Default for LimitsConfig {
    fn default() -> Self {
        Self {
            input_payload_max_size: 10 * 1024 * 1024,
        }
    }
}

'''
'''--- src/db_helpers.rs ---
use sqlx::{postgres::PgRow, Arguments};

use crate::{errors, types, BigDecimal};

const DB_RETRY_COUNT: usize = 1;
const INTERVAL: std::time::Duration = std::time::Duration::from_millis(100);
const MAX_DELAY_TIME: std::time::Duration = std::time::Duration::from_secs(120);

// temp solution to pass 2 different connection pools
pub struct DBWrapper {
    pub pool: sqlx::Pool<sqlx::Postgres>,
}

#[derive(sqlx::FromRow)]
struct BlockView {
    pub block_height: BigDecimal,
    pub block_timestamp: BigDecimal,
}

#[derive(sqlx::FromRow)]
struct ActionKindView {
    pub action_kind: String,
}

#[derive(sqlx::FromRow)]
pub(crate) struct AccountId {
    pub account_id: String,
}

pub(crate) struct Block {
    pub timestamp: u64,
    pub height: u64,
}

impl TryFrom<&BlockView> for Block {
    type Error = errors::Error;

    fn try_from(block: &BlockView) -> crate::Result<Self> {
        Ok(Self {
            timestamp: types::numeric::to_u64(&block.block_timestamp)?,
            height: types::numeric::to_u64(&block.block_height)?,
        })
    }
}

// TODO PHASE 2+ we are loosing +1 second here, it's painful. It could be computed much easier in Aurora DB
pub(crate) async fn does_account_exist(
    pool: &sqlx::Pool<sqlx::Postgres>,
    account_id: &near_primitives::types::AccountId,
    block_timestamp: u64,
) -> crate::Result<bool> {
    // for the given timestamp, account exists if
    // 1. we have at least 1 row at action_receipt_actions table
    // 2. last successful action_kind != DELETE_ACCOUNT
    let query = r"
        SELECT action_kind::text
        FROM action_receipt_actions JOIN execution_outcomes ON action_receipt_actions.receipt_id = execution_outcomes.receipt_id
        WHERE receipt_predecessor_account_id = $1
            AND action_receipt_actions.receipt_included_in_block_timestamp <= $2::numeric(20, 0)
            AND execution_outcomes.status IN ('SUCCESS_VALUE', 'SUCCESS_RECEIPT_ID')
        ORDER BY receipt_included_in_block_timestamp DESC, index_in_action_receipt DESC
        LIMIT 1
     ";
    Ok(select_retry_or_panic::<ActionKindView>(
        pool,
        query,
        &[account_id.to_string(), block_timestamp.to_string()],
    )
    .await?
    .first()
    .map(|kind| kind.action_kind != "DELETE_ACCOUNT")
    .unwrap_or_else(|| false))
}

pub(crate) async fn get_block_from_params(
    pool: &sqlx::Pool<sqlx::Postgres>,
    params: &types::query_params::BlockParams,
) -> crate::Result<Block> {
    if let Some(block_height) = params.block_height {
        match select_retry_or_panic::<BlockView>(
            pool,
            "SELECT block_height, block_timestamp FROM blocks WHERE block_height = $1::numeric(20, 0)",
            &[block_height.0.to_string()],
                    )
            .await?
            .first() {
            None => Err(errors::ErrorKind::DBError(format!("block_height {} is not found", block_height.0)).into()),
            Some(block) => Ok(Block::try_from(block)?)
        }
    } else if let Some(block_timestamp) = params.block_timestamp_nanos {
        match select_retry_or_panic::<BlockView>(
            pool,
            r"SELECT block_height, block_timestamp
              FROM blocks
              WHERE block_timestamp <= $1::numeric(20, 0)
              ORDER BY block_timestamp DESC
              LIMIT 1",
            &[block_timestamp.0.to_string()],
        )
        .await?
        .first()
        {
            None => get_first_block(pool).await,
            Some(block) => Ok(Block::try_from(block)?),
        }
    } else {
        get_last_block(pool).await
    }
}

async fn get_first_block(pool: &sqlx::Pool<sqlx::Postgres>) -> crate::Result<Block> {
    match select_retry_or_panic::<BlockView>(
        pool,
        r"SELECT block_height, block_timestamp
          FROM blocks
          ORDER BY block_timestamp
          LIMIT 1",
        &[],
    )
    .await?
    .first()
    {
        None => Err(errors::ErrorKind::DBError("blocks table is empty".to_string()).into()),
        Some(block) => Ok(Block::try_from(block)?),
    }
}

pub(crate) async fn get_last_block(pool: &sqlx::Pool<sqlx::Postgres>) -> crate::Result<Block> {
    match select_retry_or_panic::<BlockView>(
        pool,
        r"SELECT block_height, block_timestamp
          FROM blocks
          ORDER BY block_timestamp DESC
          LIMIT 1",
        &[],
    )
    .await?
    .first()
    {
        None => Err(errors::ErrorKind::DBError("blocks table is empty".to_string()).into()),
        Some(block) => Ok(Block::try_from(block)?),
    }
}

pub(crate) async fn select_retry_or_panic<T: Send + Unpin + for<'r> sqlx::FromRow<'r, PgRow>>(
    pool: &sqlx::Pool<sqlx::Postgres>,
    query: &str,
    substitution_items: &[String],
) -> Result<Vec<T>, errors::ErrorKind> {
    let mut interval = INTERVAL;
    let mut retry_attempt = 0usize;

    tracing::info!(
        target: crate::LOGGER_MSG,
        "DB request:\n{}\nParams:{}",
        query,
        substitution_items.join(", ")
    );

    loop {
        if retry_attempt == DB_RETRY_COUNT {
            return Err(errors::ErrorKind::DBError(format!(
                "Failed to perform query to database after {} attempts. Stop trying.",
                DB_RETRY_COUNT
            )));
        }
        retry_attempt += 1;

        let mut args = sqlx::postgres::PgArguments::default();
        for item in substitution_items {
            args.add(item);
        }

        match sqlx::query_as_with::<_, T, _>(query, args)
            .fetch_all(pool)
            .await
        {
            Ok(res) => return Ok(res),
            Err(async_error) => {
                tracing::warn!(
                    target: crate::LOGGER_MSG,
                    "Error occurred during {:#?}:\nFailed SELECT:\n{}Params:{}\n Retrying in {} milliseconds...",
                    async_error,
                    query,
                    substitution_items.join(", "),
                    interval.as_millis(),
                );
                tokio::time::sleep(interval).await;
                if interval < MAX_DELAY_TIME {
                    interval *= 2;
                }
            }
        }
    }
}

'''
'''--- src/errors.rs ---
use paperclip::actix::{api_v2_errors, Apiv2Schema};

use near_jsonrpc_client::errors::JsonRpcError;
use near_jsonrpc_primitives::types::query::RpcQueryError;

#[derive(Debug, strum::EnumIter)]
pub enum ErrorKind {
    DBError(String),
    InvalidInput(String),
    InternalError(String),
    ContractError(String),
    RPCError(String),
}

/// Instead of utilizing HTTP status codes to describe node errors (which often
/// do not have a good analog), rich errors are returned using this object.
#[api_v2_errors(
    code = 500,
    description = "See the inner `code` value to get more details"
)]
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct Error {
    /// Code is a network-specific error code. If desired, this code can be
    /// equivalent to an HTTP status code.
    pub code: u32,

    /// Message is a network-specific error message.
    pub message: String,

    /// An error is retriable if the same request may succeed if submitted
    /// again.
    pub retriable: bool,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let retriable = if self.retriable { " (retriable)" } else { "" };
        write!(f, "Error #{}{}: {}", self.code, retriable, self.message)
    }
}

impl Error {
    pub fn from_error_kind(err: ErrorKind) -> Self {
        match err {
            ErrorKind::DBError(message) => Self {
                code: 500,
                message: format!("DB Error: {}", message),
                retriable: true,
            },
            ErrorKind::InvalidInput(message) => Self {
                code: 400,
                message: format!("Invalid Input: {}", message),
                retriable: false,
            },
            ErrorKind::InternalError(message) => Self {
                code: 500,
                message: format!("Internal Error: {}", message),
                retriable: true,
            },
            ErrorKind::ContractError(message) => Self {
                code: 500,
                message: format!("Contract Error: {}", message),
                retriable: true,
            },
            ErrorKind::RPCError(message) => Self {
                code: 500,
                message: format!("RPC error: {}", message),
                retriable: true,
            },
        }
    }
}

impl<T> From<T> for Error
where
    T: Into<ErrorKind>,
{
    fn from(err: T) -> Self {
        Self::from_error_kind(err.into())
    }
}

impl actix_web::ResponseError for Error {
    fn error_response(&self) -> actix_web::HttpResponse {
        let data = paperclip::actix::web::Json(self);
        actix_web::HttpResponse::InternalServerError().json(data)
    }
}

impl From<JsonRpcError<RpcQueryError>> for ErrorKind {
    fn from(error: JsonRpcError<RpcQueryError>) -> Self {
        Self::RPCError(format!("{:#?}", error))
    }
}

impl From<serde_json::Error> for ErrorKind {
    fn from(error: serde_json::Error) -> Self {
        Self::InternalError(format!("Serialization failure: {:#?}", error))
    }
}

impl From<near_primitives::account::id::ParseAccountError> for ErrorKind {
    fn from(error: near_primitives::account::id::ParseAccountError) -> Self {
        Self::InternalError(format!("Could not parse account: {:#?}", error))
    }
}

'''
'''--- src/main.rs ---
use actix_cors::Cors;
use actix_web::{App, HttpServer, ResponseError};
use paperclip::actix::{web, OpenApiExt};
pub(crate) use sqlx::types::BigDecimal;

// todo . instead of account_id error
// todo add status

mod config;
mod db_helpers;
mod errors;
mod modules;
mod rpc_helpers;
mod types;

pub(crate) const LOGGER_MSG: &str = "near_enhanced_api";

pub(crate) type Result<T> = std::result::Result<T, errors::Error>;

fn get_cors(cors_allowed_origins: &[String]) -> Cors {
    let mut cors = Cors::permissive();
    if cors_allowed_origins != ["*".to_string()] {
        for origin in cors_allowed_origins {
            cors = cors.allowed_origin(origin);
        }
    }
    cors.allowed_methods(vec!["GET"])
        .allowed_headers(vec![
            actix_web::http::header::AUTHORIZATION,
            actix_web::http::header::ACCEPT,
        ])
        .allowed_header(actix_web::http::header::CONTENT_TYPE)
        .max_age(3600)
}

async fn playground_ui() -> impl actix_web::Responder {
    actix_web::HttpResponse::Ok()
        .insert_header(actix_web::http::header::ContentType::html())
        .body(
            r#"<!doctype html>
                <html lang="en">
                  <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
                    <title>NEAR Enhanced API powered by Pagoda - Playground</title>
                    <!-- Embed elements Elements via Web Component -->
                    <script src="https://unpkg.com/@stoplight/elements/web-components.min.js"></script>
                    <link rel="stylesheet" href="https://unpkg.com/@stoplight/elements/styles.min.css">
                  </head>
                  <body>

                    <elements-api
                      apiDescriptionUrl="/api/spec/v3.json"
                      router="hash"
                      layout="sidebar"
                    />

                  </body>
                </html>"#,
        )
}

#[tokio::main]
async fn main() {
    dotenv::dotenv().ok();

    let env_filter = tracing_subscriber::EnvFilter::new(
        "near=info,near_jsonrpc_client=warn,near_enhanced_api=debug",
    );
    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();

    let db_url = &std::env::var("DATABASE_URL").expect("failed to get database url");
    let pool = sqlx::PgPool::connect(db_url)
        .await
        .expect("failed to connect to the database");

    let url_balances = &std::env::var("DATABASE_URL_BALANCES").expect("failed to get database url");
    let pool_balances = sqlx::PgPool::connect(url_balances)
        .await
        .expect("failed to connect to the balances database");

    let rpc_url = &std::env::var("RPC_URL").expect("failed to get RPC url");
    let rpc_client = near_jsonrpc_client::JsonRpcClient::connect(rpc_url);

    let config::Config {
        addr,
        cors_allowed_origins,
        limits,
    } = config::Config::default();
    let api_server_public_host =
        std::env::var("API_SERVER_PUBLIC_HOST").unwrap_or_else(|_| addr.clone());

    let server = HttpServer::new(move || {
        let json_config = web::JsonConfig::default()
            .limit(limits.input_payload_max_size)
            .error_handler(|err, _req| {
                let error_message = err.to_string();
                actix_web::error::InternalError::from_response(
                    err,
                    errors::Error::from_error_kind(errors::ErrorKind::InvalidInput(error_message))
                        .error_response(),
                )
                .into()
            });

        let mut spec = paperclip::v2::models::DefaultApiRaw::default();
        spec.schemes
            .insert(paperclip::v2::models::OperationProtocol::Https);
        spec.schemes
            .insert(paperclip::v2::models::OperationProtocol::Http);
        spec.host = Some(api_server_public_host.clone());
        spec.base_path = Some("/".to_string());
        spec.tags = vec![
            paperclip::v2::models::Tag {
                name: "Accounts".to_string(),
                description: Some("Most common actions with accounts in NEAR".to_string()),
                external_docs: None,
            },
            paperclip::v2::models::Tag {
                name: "Standards".to_string(),
                description: Some(
                    "Manipulate with NEAR Enhancement Proposal (NEP) Standards".to_string(),
                ),
                external_docs: None,
            },
        ];
        spec.info = paperclip::v2::models::Info {
            version: "0.1".into(),
            title: "NEAR Enhanced API powered by Pagoda".into(),
            ..Default::default()
        };

        let mut app = App::new()
            .app_data(json_config)
            .wrap(actix_web::middleware::Logger::default())
            .app_data(web::Data::new(pool.clone()))
            .app_data(web::Data::new(db_helpers::DBWrapper {
                pool: pool_balances.clone(),
            }))
            .app_data(web::Data::new(rpc_client.clone()))
            .wrap(get_cors(&cors_allowed_origins))
            .route("/", actix_web::web::get().to(playground_ui))
            .wrap_api_with_spec(spec);

        app = app.configure(modules::coin::register_services);
        app = app.configure(modules::nft::register_services);

        app.with_json_spec_at("/api/spec/v2.json")
            .with_json_spec_v3_at("/api/spec/v3.json")
            .build()
    })
    .bind(addr)
    .unwrap()
    .shutdown_timeout(5)
    .run();

    server.await.expect("Something went wrong with the server");
}

'''
'''--- src/modules/coin/data_provider/balance.rs ---
use crate::modules::coin;
use crate::{db_helpers, errors, rpc_helpers, types};
use std::str::FromStr;

pub(crate) async fn get_near_balance(
    pool: &sqlx::Pool<sqlx::Postgres>,
    block: &db_helpers::Block,
    account_id: &near_primitives::types::AccountId,
) -> crate::Result<coin::schemas::NearBalanceResponse> {
    let balances =
        db_helpers::select_retry_or_panic::<super::models::AccountChangesBalance>(
            pool,
            r"
                WITH t AS (
                    SELECT affected_account_nonstaked_balance + affected_account_staked_balance balance
                    FROM account_changes
                    WHERE affected_account_id = $1 AND changed_in_block_timestamp <= $2::numeric(20, 0)
                    ORDER BY changed_in_block_timestamp DESC
                )
                SELECT * FROM t LIMIT 1
            ",
            &[account_id.to_string(), block.timestamp.to_string()],
        ).await?;

    match balances.first() {
        Some(balance) => Ok(coin::schemas::NearBalanceResponse {
            balance: types::numeric::to_u128(&balance.balance)?.into(),
            metadata: super::metadata::get_near_metadata(),
            block_timestamp_nanos: block.timestamp.into(),
            block_height: block.height.into(),
        }),
        None => Err(errors::ErrorKind::DBError(format!(
            "Could not find the data in account_changes table for account_id {}",
            account_id
        ))
        .into()),
    }
}

// TODO PHASE 2 pagination (recently updated go first), by artificial index added to assets__fungible_token_events
pub(crate) async fn get_coin_balances(
    pool: &sqlx::Pool<sqlx::Postgres>,
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    block: &db_helpers::Block,
    account_id: &near_primitives::types::AccountId,
    pagination: &types::query_params::Pagination,
) -> crate::Result<Vec<coin::schemas::Coin>> {
    let query = r"
        SELECT DISTINCT emitted_by_contract_account_id account_id
        FROM assets__fungible_token_events
        WHERE (token_old_owner_account_id = $1 OR token_new_owner_account_id = $1)
            AND emitted_at_block_timestamp <= $2::numeric(20, 0)
        ORDER BY emitted_by_contract_account_id
        LIMIT $3::numeric(20, 0)
    ";
    let contracts = db_helpers::select_retry_or_panic::<db_helpers::AccountId>(
        pool,
        query,
        &[
            account_id.to_string(),
            block.timestamp.to_string(),
            pagination.limit.to_string(),
        ],
    )
    .await?;

    let mut balances: Vec<coin::schemas::Coin> = vec![];
    for contract in contracts {
        if let Ok(contract_id) = near_primitives::types::AccountId::from_str(&contract.account_id) {
            balances.append(
                &mut get_coin_balances_by_contract(rpc_client, block, &contract_id, account_id)
                    .await?,
            );
        }
    }
    Ok(balances)
}

// TODO PHASE 2 change RPC call to DB call by adding absolute amount values to assets__fungible_token_events
// TODO PHASE 2 add metadata tables to the DB, with periodic autoupdate
pub(crate) async fn get_coin_balances_by_contract(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    block: &db_helpers::Block,
    contract_id: &near_primitives::types::AccountId,
    account_id: &near_primitives::types::AccountId,
) -> crate::Result<Vec<coin::schemas::Coin>> {
    let (balance, metadata) = (
        get_ft_balance_by_contract(
            rpc_client,
            contract_id.clone(),
            account_id.clone(),
            block.height,
        )
        .await?,
        super::metadata::get_ft_contract_metadata(rpc_client, contract_id.clone(), block.height)
            .await?,
    );

    Ok(vec![coin::schemas::Coin {
        standard: "nep141".to_string(),
        contract_account_id: Some(contract_id.clone().into()),
        balance: balance.into(),
        metadata: coin::schemas::CoinMetadata {
            name: metadata.name,
            symbol: metadata.symbol,
            icon: metadata.icon,
            decimals: metadata.decimals,
        },
    }])
}

pub(crate) async fn get_ft_balance_by_contract(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    account_id: near_primitives::types::AccountId,
    block_height: u64,
) -> crate::Result<u128> {
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "ft_balance_of",
        serde_json::json!({ "account_id": account_id }),
    );
    let response =
        rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id).await?;
    Ok(serde_json::from_slice::<types::U128>(&response.result)?.0)
}

impl From<coin::schemas::NearBalanceResponse> for coin::schemas::Coin {
    fn from(near_coin: coin::schemas::NearBalanceResponse) -> Self {
        coin::schemas::Coin {
            standard: "nearprotocol".to_string(),
            balance: near_coin.balance,
            contract_account_id: None,
            metadata: near_coin.metadata,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_near_balance() {
        let pool = init_db().await;
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("tomato.near").unwrap();
        let balance = get_near_balance(&pool, &block, &account).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_coin_balances() {
        let pool = init_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("patagonita.near").unwrap();
        let pagination = types::query_params::Pagination { limit: 10 };
        let balance = get_coin_balances(&pool, &rpc_client, &block, &account, &pagination).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_coin_balances_empty() {
        let pool = init_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("olga.near").unwrap();
        let pagination = types::query_params::Pagination { limit: 10 };
        let balance = get_coin_balances(&pool, &rpc_client, &block, &account, &pagination)
            .await
            .unwrap();
        assert!(balance.is_empty());
    }

    #[tokio::test]
    async fn test_coin_balances_by_contract() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("nexp.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("patagonita.near").unwrap();

        let balance = get_coin_balances_by_contract(&rpc_client, &block, &contract, &account).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_coin_balances_by_contract_no_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("olga.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("patagonita.near").unwrap();

        let balance = get_coin_balances_by_contract(&rpc_client, &block, &contract, &account).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_coin_balances_by_contract_other_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("comic.paras.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("patagonita.near").unwrap();

        let balance = get_coin_balances_by_contract(&rpc_client, &block, &contract, &account).await;
        insta::assert_debug_snapshot!(balance);
    }
}

'''
'''--- src/modules/coin/data_provider/history.rs ---
use std::str::FromStr;

use crate::modules::coin;
use crate::{db_helpers, errors, types};

// TODO PHASE 2 pagination by artificial index added to balance_changes
pub(crate) async fn get_near_history(
    balances_pool: &sqlx::Pool<sqlx::Postgres>,
    account_id: &near_primitives::types::AccountId,
    pagination: &types::query_params::HistoryPagination,
) -> crate::Result<Vec<coin::schemas::HistoryItem>> {
    let query = r"
        SELECT
            involved_account_id,
            delta_nonstaked_amount + delta_staked_amount delta_balance,
            absolute_nonstaked_amount + absolute_staked_amount balance,
            cause,
            block_timestamp block_timestamp_nanos
        FROM balance_changes
        WHERE affected_account_id = $1 AND block_timestamp < $2::numeric(20, 0)
        ORDER BY block_timestamp DESC
        LIMIT $3::numeric(20, 0)
    ";

    let history_info = db_helpers::select_retry_or_panic::<super::models::NearHistoryInfo>(
        balances_pool,
        query,
        &[
            account_id.to_string(),
            pagination.block_timestamp.to_string(),
            pagination.limit.to_string(),
        ],
    )
    .await?;

    let mut result: Vec<coin::schemas::HistoryItem> = vec![];
    for history in history_info {
        result.push(history.try_into()?);
    }
    Ok(result)
}

// TODO PHASE 2 pagination by artificial index added to assets__fungible_token_events
// TODO PHASE 2 change RPC call to DB call by adding absolute amount values to assets__fungible_token_events
// TODO PHASE 2 make the decision about separate FT/MT tables or one table. Pagination implementation depends on this
pub(crate) async fn get_coin_history(
    pool: &sqlx::Pool<sqlx::Postgres>,
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: &near_primitives::types::AccountId,
    account_id: &near_primitives::types::AccountId,
    pagination: &types::query_params::HistoryPagination,
) -> crate::Result<Vec<coin::schemas::HistoryItem>> {
    // this is temp solution before we make changes to the DB
    let mut last_balance = super::balance::get_ft_balance_by_contract(
        rpc_client,
        contract_id.clone(),
        account_id.clone(),
        pagination.block_height,
    )
    .await?;
    let metadata = coin::schemas::CoinMetadata::from(
        super::metadata::get_ft_contract_metadata(
            rpc_client,
            contract_id.clone(),
            pagination.block_height,
        )
        .await?,
    );

    let account_id = account_id.to_string();
    let query = r"
        SELECT -- blocks.block_height,
               blocks.block_timestamp,
               assets__fungible_token_events.amount::numeric(45, 0),
               assets__fungible_token_events.event_kind::text,
               assets__fungible_token_events.token_old_owner_account_id old_owner_id,
               assets__fungible_token_events.token_new_owner_account_id new_owner_id
        FROM assets__fungible_token_events
            JOIN blocks ON assets__fungible_token_events.emitted_at_block_timestamp = blocks.block_timestamp
            JOIN execution_outcomes ON assets__fungible_token_events.emitted_for_receipt_id = execution_outcomes.receipt_id
        WHERE emitted_by_contract_account_id = $1
            AND execution_outcomes.status IN ('SUCCESS_VALUE', 'SUCCESS_RECEIPT_ID')
            AND (token_old_owner_account_id = $2 OR token_new_owner_account_id = $2)
            AND emitted_at_block_timestamp <= $3::numeric(20, 0)
        ORDER BY emitted_at_block_timestamp desc
        LIMIT $4::numeric(20, 0)
    ";
    let history_info = db_helpers::select_retry_or_panic::<super::models::CoinHistoryInfo>(
        pool,
        query,
        &[
            contract_id.to_string(),
            account_id.clone(),
            pagination.block_timestamp.to_string(),
            pagination.limit.to_string(),
        ],
    )
    .await?;

    let mut result: Vec<coin::schemas::HistoryItem> = vec![];
    for db_info in history_info {
        let mut delta: i128 = types::numeric::to_i128(&db_info.amount)?;
        let balance = last_balance;
        // TODO PHASE 2 maybe we want to change assets__fungible_token_events also to affected/involved?
        let involved_account_id = if account_id == db_info.old_owner_id {
            delta = -delta;
            types::account_id::extract_account_id(&db_info.new_owner_id)?
        } else if account_id == db_info.new_owner_id {
            types::account_id::extract_account_id(&db_info.old_owner_id)?
        } else {
            return Err(
                errors::ErrorKind::InternalError(
                    format!("The account {} should be sender or receiver ({}, {}). If you see this, please create the issue",
                            account_id, db_info.old_owner_id, db_info.new_owner_id)).into(),
            );
        };

        // TODO PHASE 2 this strange error will go away after we add absolute amounts to the DB
        if (last_balance as i128) - delta < 0 {
            return Err(errors::ErrorKind::InternalError(format!(
                "Balance could not be negative: account {}, contract {}",
                account_id, contract_id
            ))
            .into());
        }
        last_balance = ((last_balance as i128) - delta) as u128;

        result.push(coin::schemas::HistoryItem {
            cause: db_info.event_kind.clone(),
            involved_account_id: involved_account_id.map(|id| id.into()),
            delta_balance: delta.into(),
            balance: balance.into(),
            coin_metadata: metadata.clone(),
            block_timestamp_nanos: types::numeric::to_u64(&db_info.block_timestamp)?.into(),
            // block_height: types::numeric::to_u64(&db_info.block_height)?.into(),
        });
    }
    Ok(result)
}

impl TryFrom<super::models::NearHistoryInfo> for coin::schemas::HistoryItem {
    type Error = errors::Error;

    fn try_from(info: super::models::NearHistoryInfo) -> crate::Result<Self> {
        let involved_account_id: Option<types::AccountId> =
            if let Some(account_id) = info.involved_account_id {
                Some(near_primitives::types::AccountId::from_str(&account_id)?.into())
            } else {
                None
            };
        Ok(Self {
            involved_account_id,
            delta_balance: types::numeric::to_i128(&info.delta_balance)?.into(),
            balance: types::numeric::to_u128(&info.balance)?.into(),
            cause: info.cause,
            coin_metadata: super::get_near_metadata(),
            block_timestamp_nanos: types::numeric::to_u64(&info.block_timestamp_nanos)?.into(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;

    #[tokio::test]
    async fn test_near_history() {
        let block = get_block();
        // Using the other pool because we have this table at the other DB
        dotenv::dotenv().ok();
        let url_balances =
            &std::env::var("DATABASE_URL_BALANCES").expect("failed to get database url");
        let pool = sqlx::PgPool::connect(url_balances)
            .await
            .expect("failed to connect to the balances database");
        let account = near_primitives::types::AccountId::from_str("vasya.near").unwrap();
        let pagination = types::query_params::HistoryPagination {
            block_height: block.height,
            block_timestamp: block.timestamp,
            limit: 10,
        };

        let balance = get_near_history(&pool, &account, &pagination).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_coin_history() {
        let pool = init_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("usn").unwrap();
        let account = near_primitives::types::AccountId::from_str("pushxo.near").unwrap();
        let pagination = types::query_params::HistoryPagination {
            block_height: block.height,
            block_timestamp: block.timestamp,
            limit: 10,
        };

        let balance = get_coin_history(&pool, &rpc_client, &contract, &account, &pagination).await;
        insta::assert_debug_snapshot!(balance);
    }
}

'''
'''--- src/modules/coin/data_provider/metadata.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};

use crate::modules::coin;
use crate::{rpc_helpers, types};

pub(crate) async fn get_ft_contract_metadata(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    block_height: u64,
) -> crate::Result<coin::schemas::FtContractMetadata> {
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "ft_metadata",
        serde_json::json!({}),
    );
    let response =
        rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id).await?;

    let metadata = serde_json::from_slice::<FtMetadata>(&response.result)?;
    Ok(coin::schemas::FtContractMetadata {
        spec: metadata.spec,
        name: metadata.name,
        symbol: metadata.symbol,
        icon: metadata.icon,
        decimals: metadata.decimals,
        reference: metadata.reference,
        reference_hash: types::vector::base64_to_string(&metadata.reference_hash)?,
    })
}

pub(crate) fn get_near_metadata() -> coin::schemas::CoinMetadata {
    coin::schemas::CoinMetadata {
        name: "NEAR blockchain native token".to_string(),
        symbol: "NEAR".to_string(),
        // TODO PHASE 2 re-check the icon. It's the best I can find
        icon: Some("https://raw.githubusercontent.com/near/near-wallet/7ef3c824404282b76b36da2dff4f3e593e7f928d/packages/frontend/src/images/near.svg".to_string()),
        decimals: 24,
    }
}

// Taken from https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/fungible_token/metadata.rs
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
pub struct FtMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<types::vector::Base64VecU8>,
    pub decimals: u8,
}

impl From<coin::schemas::FtContractMetadata> for coin::schemas::CoinMetadata {
    fn from(metadata: coin::schemas::FtContractMetadata) -> Self {
        coin::schemas::CoinMetadata {
            name: metadata.name,
            symbol: metadata.symbol,
            icon: metadata.icon,
            decimals: metadata.decimals,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_ft_contract_metadata() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("usn").unwrap();

        let metadata = get_ft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_ft_contract_metadata_no_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("olga.near").unwrap();

        let metadata = get_ft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_ft_contract_metadata_other_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("comic.paras.near").unwrap();

        let metadata = get_ft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }
}

'''
'''--- src/modules/coin/data_provider/mod.rs ---
mod balance;
mod history;
mod metadata;
mod models;

pub(crate) use balance::{get_coin_balances, get_coin_balances_by_contract, get_near_balance};
pub(crate) use history::{get_coin_history, get_near_history};
pub(crate) use metadata::{get_ft_contract_metadata, get_near_metadata};

'''
'''--- src/modules/coin/data_provider/models.rs ---
use crate::BigDecimal;

#[derive(sqlx::FromRow)]
pub(crate) struct AccountChangesBalance {
    pub balance: BigDecimal,
}

#[derive(sqlx::FromRow)]
pub(crate) struct NearHistoryInfo {
    pub involved_account_id: Option<String>,
    pub delta_balance: BigDecimal,
    pub balance: BigDecimal,
    pub cause: String,
    // pub index: super::types::U128,
    pub block_timestamp_nanos: BigDecimal,
    // pub block_height: super::types::U64,
}

#[derive(sqlx::FromRow)]
pub(crate) struct CoinHistoryInfo {
    // todo add status, add symbol
    // pub block_height: BigDecimal,
    pub block_timestamp: BigDecimal,
    pub amount: BigDecimal,
    pub event_kind: String,
    pub old_owner_id: String,
    pub new_owner_id: String,
}

'''
'''--- src/modules/coin/mod.rs ---
use paperclip::actix::web;

mod data_provider;
mod resources;
mod schemas;

pub(crate) fn register_services(app: &mut web::ServiceConfig) {
    app.service(
        web::resource("/accounts/{account_id}/coins/NEAR")
            .route(web::get().to(resources::get_near_balance)),
    )
    .service(
        web::resource("/accounts/{account_id}/coins")
            .route(web::get().to(resources::get_coin_balances)),
    )
    .service(
        web::resource("/accounts/{account_id}/coins/{contract_account_id}")
            .route(web::get().to(resources::get_coin_balances_by_contract)),
    )
    .service(
        web::resource("/accounts/{account_id}/coins/NEAR/history")
            .route(web::get().to(resources::get_near_history)),
    )
    .service(
        web::resource("/accounts/{account_id}/coins/{contract_account_id}/history")
            .route(web::get().to(resources::get_coin_history)),
    )
    .service(
        web::resource("/nep141/metadata/{contract_account_id}")
            .route(web::get().to(resources::get_ft_contract_metadata)),
    );
}

'''
'''--- src/modules/coin/resources.rs ---
use paperclip::actix::{
    api_v2_operation,
    web::{self, Json},
};
use validator::HasLen;

use super::schemas;
use crate::modules::coin::data_provider;
use crate::{db_helpers, errors, modules, types};

#[api_v2_operation]
/// Get user's NEAR balance
///
/// This endpoint returns the NEAR balance of the given account_id
/// for the given timestamp/block_height.
pub async fn get_near_balance(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    request: web::Path<schemas::BalanceRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::NearBalanceResponse>> {
    types::query_params::check_block_params(&block_params)?;
    let block = db_helpers::get_block_from_params(&pool, &block_params).await?;
    modules::check_account_exists(&pool, &request.account_id.0, block.timestamp).await?;

    Ok(Json(
        super::data_provider::get_near_balance(&pool, &block, &request.account_id.0).await?,
    ))
}

#[api_v2_operation]
/// Get user's coin balances
///
/// This endpoint returns all the countable coin balances (including NEAR, FTs, later will add MTs)
/// of the given account_id, for the given timestamp/block_height.
///
/// **Limitations**
/// * For now, we support only the balance for NEAR and FT contracts which implement Events NEP.
///   We work on the solution to support the other FT contracts, including `wrap.near` and bridged tokens.
/// * We are in the process of supporting Multi Token balances.
/// * We provide only up to 100 items, where recently updated data goes first.
///   Full-featured pagination will be provided later.
pub async fn get_coin_balances(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::BalanceRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
    // TODO PHASE 2 pagination by index (recently updated go first)
    pagination_params: web::Query<types::query_params::PaginationParams>,
) -> crate::Result<Json<schemas::CoinBalancesResponse>> {
    types::query_params::check_limit(pagination_params.limit)?;
    let mut pagination = types::query_params::Pagination::from(pagination_params.0);
    let block = db_helpers::get_block_from_params(&pool, &block_params).await?;
    modules::check_account_exists(&pool, &request.account_id.0, block.timestamp).await?;

    let mut balances: Vec<schemas::Coin> = vec![];
    balances.push(
        data_provider::get_near_balance(&pool, &block, &request.account_id.0)
            .await?
            .into(),
    );
    pagination.limit -= 1;

    if pagination.limit > 0 {
        let ft_balances = &mut data_provider::get_coin_balances(
            &pool,
            &rpc_client,
            &block,
            &request.account_id.0,
            &pagination,
        )
        .await?;
        balances.append(ft_balances);
        pagination.limit -= ft_balances.length() as u32;
    }

    Ok(Json(schemas::CoinBalancesResponse {
        balances,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation]
/// Get user's coin balances by contract
///
/// This endpoint returns all the countable coin balances of the given account_id,
/// for the given contract and timestamp/block_height.
/// For FT contract, the response has only 1 item in the list.
/// For MT contracts, there could be several balances (MT support is not ready yet).
///
/// **Limitations**
/// * For now, we support only the balance for FT contracts which implement Events NEP.
///   We work on the solution to support the other FT contracts, including `wrap.near` and bridged tokens.
/// * We are in the process of supporting Multi Token balances.
pub async fn get_coin_balances_by_contract(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::BalanceByContractRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::CoinBalancesResponse>> {
    if request.contract_account_id.to_string() == "near" {
        return Err(errors::ErrorKind::InvalidInput(
            "For native balance, please use NEAR (uppercase)".to_string(),
        )
        .into());
    }
    types::query_params::check_block_params(&block_params)?;
    let block = db_helpers::get_block_from_params(&pool, &block_params).await?;
    modules::check_account_exists(&pool, &request.account_id.0, block.timestamp).await?;

    let balances = data_provider::get_coin_balances_by_contract(
        &rpc_client,
        &block,
        &request.contract_account_id.0,
        &request.account_id.0,
    )
    .await?;

    Ok(Json(schemas::CoinBalancesResponse {
        balances,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation]
/// Get user's NEAR history
///
/// This endpoint returns the history of operations with NEAR coin
/// for the given account_id, timestamp/block_height.
///
/// **Limitations**
/// * We provide only up to 100 items, where recent updates go first.
///   Full-featured pagination will be provided later.
pub async fn get_near_history(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    pool_balances: web::Data<db_helpers::DBWrapper>,
    request: web::Path<schemas::BalanceRequest>,
    pagination_params: web::Query<types::query_params::HistoryPaginationParams>,
) -> crate::Result<Json<schemas::HistoryResponse>> {
    let block = db_helpers::get_last_block(&pool).await?;
    modules::check_account_exists(&pool, &request.account_id.0, block.timestamp).await?;
    let pagination =
        modules::check_and_get_history_pagination_params(&pool, pagination_params.0).await?;

    Ok(Json(schemas::HistoryResponse {
        history: data_provider::get_near_history(
            &pool_balances.pool,
            &request.account_id,
            &pagination,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation]
/// Get user's coin history by contract
///
/// This endpoint returns the history of coin operations (FT, other standards)
/// for the given account_id, contract_id, timestamp/block_height.
///
/// **Limitations**
/// * For now, we support only FT contracts which implement Events NEP.
///   We work on the solution to support the other FT contracts, including `wrap.near` and bridged tokens.
/// * We are in the process of supporting Multi Token history.
/// * We provide only up to 100 items, where recent updates go first.
///   Full-featured pagination will be provided later.
pub async fn get_coin_history(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::HistoryRequest>,
    pagination_params: web::Query<types::query_params::HistoryPaginationParams>,
) -> crate::Result<Json<schemas::HistoryResponse>> {
    if request.contract_account_id.to_string() == "near" {
        return Err(errors::ErrorKind::InvalidInput(
            "For native history, please use NEAR (uppercase)".to_string(),
        )
        .into());
    }
    let pagination =
        modules::check_and_get_history_pagination_params(&pool, pagination_params.0).await?;
    modules::check_account_exists(&pool, &request.account_id.0, pagination.block_timestamp).await?;

    Ok(Json(schemas::HistoryResponse {
        history: data_provider::get_coin_history(
            &pool,
            &rpc_client,
            &request.contract_account_id.0,
            &request.account_id.0,
            &pagination,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(pagination.block_timestamp),
        block_height: types::U64::from(pagination.block_height),
    }))
}

#[api_v2_operation]
/// Get FT contract metadata
///
/// This endpoint returns the metadata for given FT contract and timestamp/block_height.
///
/// **Limitations**
/// * For now, we support only FT contracts which implement Events NEP.
///   We work on the solution to support the other FT contracts, including `wrap.near` and bridged tokens.
pub async fn get_ft_contract_metadata(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::ContractMetadataRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::FtContractMetadataResponse>> {
    types::query_params::check_block_params(&block_params)?;
    let block = db_helpers::get_block_from_params(&pool, &block_params).await?;

    Ok(Json(schemas::FtContractMetadataResponse {
        metadata: data_provider::get_ft_contract_metadata(
            &rpc_client,
            request.contract_account_id.0.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

'''
'''--- src/modules/coin/schemas.rs ---
use paperclip::actix::Apiv2Schema;

use crate::types;

// *** Requests ***

// move to coins
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct BalanceRequest {
    pub account_id: types::AccountId,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct BalanceByContractRequest {
    pub account_id: types::AccountId,
    pub contract_account_id: types::AccountId,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryRequest {
    pub account_id: types::AccountId,
    pub contract_account_id: types::AccountId,
}

// duplicate in each folder
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct ContractMetadataRequest {
    pub contract_account_id: types::AccountId,
}

// *** Responses ***

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NearBalanceResponse {
    /// Sum of staked and nonstaked balances
    pub balance: types::U128,
    pub metadata: CoinMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

/// This response gives the information about all the available balances for the user.
/// The answer gives the list of NEAR, FT balances, could be used for Multi Tokens.
/// For MTs and other standards, balances could have multiple entries for one contract.
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct CoinBalancesResponse {
    pub balances: Vec<Coin>,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

/// This response provides the coin history (NEAR or by contract).
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryResponse {
    pub history: Vec<HistoryItem>,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct FtContractMetadataResponse {
    pub metadata: FtContractMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

// ---

/// This type describes general coin information.
/// It is used for NEAR, FT balances, could be used for Multi Tokens.
///
/// For MTs and other standards, we could have multiple coins for one contract.
/// For NEAR and FTs, coin_metadata contains general metadata (the only available option, though).
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct Coin {
    /// "nearprotocol" for NEAR, "nep141" for FT
    pub standard: String,
    pub balance: types::U128,
    /// null for NEAR, not null otherwise
    pub contract_account_id: Option<types::AccountId>,
    pub metadata: CoinMetadata,
    // TODO PHASE 1 (idea) I think it would be great to add here the info about last update moment. Timestamp, later also index
    // I'm already doing it at NftCollectionByContract
}

/// This type describes the history of coin movements for the given user.
/// Coins could be NEAR, FT, it could be also later used for Multi Tokens.
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryItem {
    // TODO PHASE 2 add index here
    // pub index: types::U128,
    // TODO PHASE 1 (idea) do we want to add here tx_hash/receipt_id? We may want to add it at many places
    pub involved_account_id: Option<types::AccountId>,
    pub delta_balance: types::I128,
    pub balance: types::U128,
    pub cause: String,
    pub coin_metadata: CoinMetadata,
    pub block_timestamp_nanos: types::U64,
    // TODO PHASE 2 add this when we have all the data in the same DB. Now we can't join with blocks
    // pub block_height: types::U64,
}

/// This type describes general Metadata info, collecting the most important fields from different standards in the one format.
/// `decimals` may contain `0` if it's not applicable (e.g. if it's general MT metadata)
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct CoinMetadata {
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub decimals: u8,
}

/// The type for FT Contract Metadata. Inspired by
/// https://nomicon.io/Standards/Tokens/FungibleToken/Metadata
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct FtContractMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
    pub decimals: u8,
}

'''
'''--- src/modules/mod.rs ---
use crate::{db_helpers, errors, types};

pub(crate) mod coin;
pub(crate) mod nft;

pub(crate) async fn check_account_exists(
    pool: &sqlx::Pool<sqlx::Postgres>,
    account_id: &near_primitives::types::AccountId,
    block_timestamp: u64,
) -> crate::Result<()> {
    if !db_helpers::does_account_exist(pool, account_id, block_timestamp).await? {
        Err(errors::ErrorKind::InvalidInput(format!(
            "account_id {} does not exist at block_timestamp {}",
            account_id, block_timestamp
        ))
        .into())
    } else {
        Ok(())
    }
}

pub(crate) async fn check_and_get_history_pagination_params(
    pool: &sqlx::Pool<sqlx::Postgres>,
    pagination_params: types::query_params::HistoryPaginationParams,
) -> crate::Result<types::query_params::HistoryPagination> {
    types::query_params::check_limit(pagination_params.limit)?;
    let pagination = types::query_params::Pagination::from(pagination_params);
    // if pagination_params.after_block_height.is_some() && pagination_params.after_timestamp_nanos.is_some() {
    //     return Err(errors::ErrorKind::InvalidInput(
    //         "Both block_height and block_timestamp_nanos found. Please provide only one of values"
    //             .to_string(),
    //     )
    //         .into());
    // }
    // TODO PHASE 2 take the block from pagination_params
    let block = db_helpers::get_last_block(pool).await?;
    Ok(types::query_params::HistoryPagination {
        block_height: block.height,
        block_timestamp: block.timestamp,
        limit: pagination.limit,
    })
}

#[cfg(test)]
mod tests {
    use crate::db_helpers;

    pub(crate) async fn init_db() -> sqlx::Pool<sqlx::Postgres> {
        dotenv::dotenv().ok();
        let db_url = &std::env::var("DATABASE_URL").expect("failed to get database url");

        sqlx::PgPool::connect(db_url)
            .await
            .expect("failed to connect to the database")
    }

    pub(crate) fn init_rpc() -> near_jsonrpc_client::JsonRpcClient {
        dotenv::dotenv().ok();
        let rpc_url = &std::env::var("RPC_URL").expect("failed to get RPC url");
        let connector = near_jsonrpc_client::JsonRpcClient::new_client();
        connector.connect(rpc_url)
    }

    pub(crate) fn get_block() -> db_helpers::Block {
        db_helpers::Block {
            timestamp: 1655571176644255779,
            height: 68000000,
        }
    }
}

'''
'''--- src/modules/nft/data_provider/history.rs ---
use crate::modules::nft;
use crate::{db_helpers, errors, types};

// TODO PHASE 2 pagination by artificial index added to assets__non_fungible_token_events
pub(crate) async fn get_nft_history(
    pool: &sqlx::Pool<sqlx::Postgres>,
    contract_id: &near_primitives::types::AccountId,
    token_id: &str,
    pagination: &types::query_params::HistoryPagination,
) -> crate::Result<Vec<nft::schemas::HistoryItem>> {
    let query = r"
        SELECT event_kind::text action_kind,
               token_old_owner_account_id old_account_id,
               token_new_owner_account_id new_account_id,
               emitted_at_block_timestamp block_timestamp_nanos,
               block_height
        FROM assets__non_fungible_token_events
            JOIN blocks ON assets__non_fungible_token_events.emitted_at_block_timestamp = blocks.block_timestamp
            JOIN execution_outcomes ON assets__non_fungible_token_events.emitted_for_receipt_id = execution_outcomes.receipt_id
        WHERE token_id = $1
            AND emitted_by_contract_account_id = $2
            AND emitted_at_block_timestamp < $3::numeric(20, 0)
            AND execution_outcomes.status IN ('SUCCESS_VALUE', 'SUCCESS_RECEIPT_ID')
        ORDER BY emitted_at_block_timestamp DESC
        LIMIT $4::numeric(20, 0)
    ";
    let history_items = db_helpers::select_retry_or_panic::<super::models::NftHistoryInfo>(
        pool,
        query,
        &[
            token_id.to_string(),
            contract_id.to_string(),
            pagination.block_timestamp.to_string(),
            pagination.limit.to_string(),
        ],
    )
    .await?;

    let mut result: Vec<nft::schemas::HistoryItem> = vec![];
    for history in history_items {
        result.push(history.try_into()?);
    }
    Ok(result)
}

impl TryFrom<super::models::NftHistoryInfo> for nft::schemas::HistoryItem {
    type Error = errors::Error;

    fn try_from(info: super::models::NftHistoryInfo) -> crate::Result<Self> {
        Ok(Self {
            cause: info.action_kind,
            old_account_id: types::account_id::extract_account_id(&info.old_account_id)?
                .map(|account| account.into()),
            new_account_id: types::account_id::extract_account_id(&info.new_account_id)?
                .map(|account| account.into()),
            block_timestamp_nanos: types::numeric::to_u64(&info.block_timestamp_nanos)?.into(),
            block_height: types::numeric::to_u64(&info.block_height)?.into(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_nft_history() {
        let pool = init_db().await;
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("x.paras.near").unwrap();
        let token = "293708:1";
        let pagination = types::query_params::HistoryPagination {
            block_height: block.height,
            block_timestamp: block.timestamp,
            limit: 10,
        };

        let history = get_nft_history(&pool, &contract, token, &pagination).await;
        insta::assert_debug_snapshot!(history);
    }

    #[tokio::test]
    async fn test_nft_history_with_no_failed_receipts_in_result() {
        let pool = init_db().await;
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("thebullishbulls.near").unwrap();
        let token = "1349";
        let pagination = types::query_params::HistoryPagination {
            block_height: block.height,
            block_timestamp: block.timestamp,
            limit: 10,
        };

        let history = get_nft_history(&pool, &contract, token, &pagination).await;
        insta::assert_debug_snapshot!(history);
    }

    #[tokio::test]
    async fn test_nft_history_nft_does_not_exist() {
        let pool = init_db().await;
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("x.paras.near").unwrap();
        let token = "no_such_token";
        let pagination = types::query_params::HistoryPagination {
            block_height: block.height,
            block_timestamp: block.timestamp,
            limit: 10,
        };

        let history = get_nft_history(&pool, &contract, token, &pagination)
            .await
            .unwrap();
        assert!(history.is_empty());
    }
}

'''
'''--- src/modules/nft/data_provider/metadata.rs ---
use crate::modules::nft;
use crate::{errors, rpc_helpers, types};
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};

pub(crate) async fn get_nft_contract_metadata(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    block_height: u64,
) -> crate::Result<nft::schemas::NftContractMetadata> {
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "nft_metadata",
        serde_json::json!({}),
    );
    let response = match rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id)
        .await
    {
        Ok(response) => response,
        Err(err) => {
            println!("{}", err.message);
            if err
                .message
                .contains("called `Option::unwrap()` on a `None` value")
            {
                return Err(errors::ErrorKind::ContractError(
                    "The contract did not provide NFT Metadata which is a required part of NFT NEP 171".to_string(),
                )
                    .into());
            }
            return Err(err);
        }
    };

    nft::schemas::NftContractMetadata::try_from(serde_json::from_slice::<NFTContractMetadata>(
        &response.result,
    )?)
}

// Metadata is the required part of the standard.
// Unfortunately, some contracts (e.g. `nft.nearapps.near`) do not implement it.
// We should give at least anything for such contracts when we serve the overview information.
pub(crate) fn get_default_nft_contract_metadata() -> nft::schemas::NftContractMetadata {
    nft::schemas::NftContractMetadata {
        spec: "nft-1.0.0".to_string(),
        name: "The contract did not provide the metadata".to_string(),
        symbol: "The contract did not provide the symbol".to_string(),
        icon: None,
        base_uri: None,
        reference: None,
        reference_hash: None,
    }
}

// Taken from https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/metadata.rs
/// Metadata for the NFT contract itself.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized data_provider assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<types::vector::Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

impl TryFrom<NFTContractMetadata> for nft::schemas::NftContractMetadata {
    type Error = errors::Error;

    fn try_from(metadata: NFTContractMetadata) -> crate::Result<Self> {
        Ok(Self {
            spec: metadata.spec,
            name: metadata.name,
            symbol: metadata.symbol,
            icon: metadata.icon,
            base_uri: metadata.base_uri,
            reference: metadata.reference,
            reference_hash: types::vector::base64_to_string(&metadata.reference_hash)?,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_nft_contract_metadata() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("comic.paras.near").unwrap();

        let metadata = get_nft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_nft_contract_metadata_no_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("olga.near").unwrap();

        let metadata = get_nft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_nft_contract_metadata_other_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("usn").unwrap();

        let metadata = get_nft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_nft_contract_metadata_broken_contract() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("nft.nearapps.near").unwrap();

        let metadata = get_nft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }
}

'''
'''--- src/modules/nft/data_provider/mod.rs ---
mod history;
mod metadata;
mod models;
mod nft_info;

pub(crate) use history::get_nft_history;
pub(crate) use metadata::get_nft_contract_metadata;
pub(crate) use nft_info::{get_nft, get_nfts_by_contract, get_nfts_count};

'''
'''--- src/modules/nft/data_provider/models.rs ---
use crate::BigDecimal;

#[derive(sqlx::FromRow)]
pub(crate) struct NftHistoryInfo {
    pub action_kind: String,
    pub old_account_id: String,
    pub new_account_id: String,
    // pub index: super::types::U128,
    pub block_timestamp_nanos: BigDecimal,
    pub block_height: BigDecimal,
}

#[derive(sqlx::FromRow)]
pub(crate) struct NftCount {
    pub contract_id: String,
    pub count: i64,
    pub last_updated_at_timestamp: BigDecimal,
}

'''
'''--- src/modules/nft/data_provider/nft_info.rs ---
use std::str::FromStr;

use crate::modules::nft;
use crate::{db_helpers, errors, rpc_helpers, types};
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};

// TODO PHASE 2 pagination by artificial index added to assets__non_fungible_token_events
pub(crate) async fn get_nfts_count(
    pool: &sqlx::Pool<sqlx::Postgres>,
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    block: &db_helpers::Block,
    account_id: &near_primitives::types::AccountId,
    pagination_params: types::query_params::PaginationParams,
) -> crate::Result<Vec<nft::schemas::NftCount>> {
    let query = r"
        WITH relevant_events AS (
            SELECT emitted_at_block_timestamp, token_id, emitted_by_contract_account_id, token_old_owner_account_id, token_new_owner_account_id
            FROM assets__non_fungible_token_events
                JOIN execution_outcomes ON assets__non_fungible_token_events.emitted_for_receipt_id = execution_outcomes.receipt_id
            WHERE
                -- if it works slow, we need to create table daily_nft_count_by_contract_and_user, and this query will run only over the last day
                -- emitted_at_block_timestamp > start_of_day AND
                emitted_at_block_timestamp <= $2::numeric(20, 0)
                AND execution_outcomes.status IN ('SUCCESS_VALUE', 'SUCCESS_RECEIPT_ID')
                AND (token_new_owner_account_id = $1 OR token_old_owner_account_id = $1)
        ),
        outgoing_events_count AS (
            SELECT emitted_by_contract_account_id, count(*) * -1 cnt FROM relevant_events
            WHERE token_old_owner_account_id = $1
            GROUP BY emitted_by_contract_account_id
        ),
        ingoing_events_count AS (
            SELECT emitted_by_contract_account_id, count(*) cnt FROM relevant_events
            WHERE token_new_owner_account_id = $1
            GROUP BY emitted_by_contract_account_id
        ),
        counts AS (
            SELECT ingoing_events_count.emitted_by_contract_account_id,
                -- coalesce changes null to the given parameter
                coalesce(ingoing_events_count.cnt, 0) + coalesce(outgoing_events_count.cnt, 0) cnt
            FROM ingoing_events_count FULL JOIN outgoing_events_count
                ON ingoing_events_count.emitted_by_contract_account_id = outgoing_events_count.emitted_by_contract_account_id
        ),
        counts_with_timestamp AS (
            SELECT distinct ON (counts.emitted_by_contract_account_id) counts.emitted_by_contract_account_id contract_id,
                cnt count,
                emitted_at_block_timestamp last_updated_at_timestamp
            FROM counts JOIN relevant_events ON counts.emitted_by_contract_account_id = relevant_events.emitted_by_contract_account_id
            WHERE cnt > 0
            ORDER BY counts.emitted_by_contract_account_id, emitted_at_block_timestamp DESC
        )
        SELECT * FROM counts_with_timestamp
        -- WHERE last_updated_at_timestamp < $3::numeric(20, 0) -- phase 2 pagination will be covered here
        ORDER BY last_updated_at_timestamp DESC
        LIMIT $3::numeric(20, 0)
    ";

    let pagination = types::query_params::Pagination::from(pagination_params);
    let info_by_contract = db_helpers::select_retry_or_panic::<super::models::NftCount>(
        pool,
        query,
        &[
            account_id.to_string(),
            block.timestamp.to_string(),
            pagination.limit.to_string(),
        ],
    )
    .await?;

    let mut result: Vec<nft::schemas::NftCount> = vec![];
    for info in info_by_contract {
        if let Ok(contract_id) = near_primitives::types::AccountId::from_str(&info.contract_id) {
            let metadata = super::metadata::get_nft_contract_metadata(
                rpc_client,
                contract_id.clone(),
                block.height,
            )
            .await
            .unwrap_or_else(|_| super::metadata::get_default_nft_contract_metadata());
            result.push(nft::schemas::NftCount {
                contract_account_id: contract_id.into(),
                nft_count: info.count as u32,
                last_updated_at_timestamp_nanos: types::numeric::to_u128(
                    &info.last_updated_at_timestamp,
                )?
                .into(),
                contract_metadata: metadata,
            });
        }
    }
    Ok(result)
}

pub(crate) async fn get_nfts_by_contract(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    account_id: near_primitives::types::AccountId,
    block_height: u64,
    limit: u32,
) -> crate::Result<Vec<nft::schemas::Nft>> {
    // TODO PHASE 2 pagination
    // RPC supports pagination, but the order is defined by the each contract and we can't control it.
    // For now, we are ready to serve only the first page
    // Later, I feel we need to load NFT (each token) metadata to the DB,
    // right after that we can stop using RPC here.
    // Or, maybe we want to delegate this task fully to the contracts?
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "nft_tokens_for_owner",
        // https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration
        serde_json::json!({ "account_id": account_id, "from_index": "0", "limit": limit }),
    );
    let response =
        rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id).await?;

    let tokens = serde_json::from_slice::<Vec<Token>>(&response.result)?;
    let mut result = vec![];
    for token in tokens {
        result.push(nft::schemas::Nft::try_from(token)?);
    }
    Ok(result)
}

pub(crate) async fn get_nft(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    token_id: String,
    block_height: u64,
) -> crate::Result<nft::schemas::Nft> {
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "nft_token",
        serde_json::json!({ "token_id": token_id }),
    );
    let response =
        rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id).await?;

    match serde_json::from_slice::<Option<Token>>(&response.result)? {
        None => Err(errors::ErrorKind::InvalidInput(format!(
            "Token `{}` does not exist in contract `{}`, block_height {}",
            token_id, contract_id, block_height
        ))
        .into()),
        Some(token) => nft::schemas::Nft::try_from(token),
    }
}

// Taken from https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/token.rs
/// Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
pub type TokenId = String;

/// In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Token {
    pub token_id: TokenId,
    pub owner_id: types::AccountId,
    pub metadata: Option<TokenMetadata>,
    pub approved_account_ids: Option<std::collections::HashMap<types::AccountId, u64>>,
}

/// Metadata on the individual token level.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, BorshDeserialize, BorshSerialize)]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed data_provider
    pub media_hash: Option<types::vector::Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<String>, // ISO 8601 datetime when token was issued or minted
    pub expires_at: Option<String>, // ISO 8601 datetime when token expires
    pub starts_at: Option<String>, // ISO 8601 datetime when token starts being valid
    pub updated_at: Option<String>, // ISO 8601 datetime when token was last updated
    pub extra: Option<String>, // anything extra the NFT wants to data_provider on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<types::vector::Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

impl TryFrom<Token> for nft::schemas::Nft {
    type Error = errors::Error;

    fn try_from(token: Token) -> crate::Result<Self> {
        let metadata = token.metadata.ok_or_else(|| {
            errors::ErrorKind::ContractError(
                "The contract did not provide NFT Metadata which is a required part of NFT NEP 171"
                    .to_string(),
            )
        })?;

        Ok(Self {
            token_id: token.token_id,
            owner_account_id: token.owner_id.0.to_string(),
            metadata: nft::schemas::NftMetadata {
                title: metadata.title,
                description: metadata.description,
                media: metadata.media,
                media_hash: types::vector::base64_to_string(&metadata.media_hash)?,
                copies: metadata.copies,
                issued_at: metadata.issued_at,
                expires_at: metadata.expires_at,
                starts_at: metadata.starts_at,
                updated_at: metadata.updated_at,
                extra: metadata.extra,
                reference: metadata.reference,
                reference_hash: types::vector::base64_to_string(&metadata.reference_hash)?,
            },
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;

    #[tokio::test]
    async fn test_nfts_count() {
        let pool = init_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("blondjesus.near").unwrap();
        let pagination = types::query_params::PaginationParams { limit: Some(10) };

        let nft_count = get_nfts_count(&pool, &rpc_client, &block, &account, pagination).await;
        insta::assert_debug_snapshot!(nft_count);
    }

    #[tokio::test]
    async fn test_nfts_count_empty() {
        let pool = init_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("frol.near").unwrap();
        let pagination = types::query_params::PaginationParams { limit: None };

        let nft_count = get_nfts_count(&pool, &rpc_client, &block, &account, pagination)
            .await
            .unwrap();
        assert!(nft_count.is_empty());
    }

    #[tokio::test]
    async fn test_nfts_count_with_contracts_with_no_metadata() {
        let pool = init_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("vlad.near").unwrap();
        let pagination = types::query_params::PaginationParams { limit: Some(10) };

        let nft_count = get_nfts_count(&pool, &rpc_client, &block, &account, pagination).await;
        insta::assert_debug_snapshot!(nft_count);
    }

    #[tokio::test]
    async fn test_nfts_count_with_no_failed_receipts_in_result() {
        let pool = init_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("kbneoburner3.near").unwrap();
        let pagination = types::query_params::PaginationParams { limit: None };

        let nft_count = get_nfts_count(&pool, &rpc_client, &block, &account, pagination).await;
        insta::assert_debug_snapshot!(nft_count);
    }

    #[tokio::test]
    async fn test_nfts_by_contract() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract =
            near_primitives::types::AccountId::from_str("billionairebullsclub.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("olenavorobei.near").unwrap();

        let nfts = get_nfts_by_contract(&rpc_client, contract, account, block.height, 4).await;
        insta::assert_debug_snapshot!(nfts);
    }

    #[tokio::test]
    async fn test_nft() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("x.paras.near").unwrap();
        let token = "415815:1".to_string();

        let nft = get_nft(&rpc_client, contract, token, block.height).await;
        insta::assert_debug_snapshot!(nft);
    }

    #[tokio::test]
    async fn test_nft_does_not_exist() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("x.paras.near").unwrap();
        let token = "no_such_token".to_string();

        let nft = get_nft(&rpc_client, contract, token, block.height).await;
        insta::assert_debug_snapshot!(nft);
    }
}

'''
'''--- src/modules/nft/mod.rs ---
use paperclip::actix::web;

mod data_provider;
mod resources;
mod schemas;

pub(crate) fn register_services(app: &mut web::ServiceConfig) {
    app.service(
        web::resource("/accounts/{account_id}/NFT")
            .route(web::get().to(resources::get_nft_collection_overview)),
    )
    .service(
        web::resource("/accounts/{account_id}/NFT/{contract_account_id}")
            .route(web::get().to(resources::get_nft_collection_by_contract)),
    )
    .service(
        web::resource("/NFT/{contract_account_id}/{token_id}")
            .route(web::get().to(resources::get_nft)),
    )
    .service(
        web::resource("/NFT/{contract_account_id}/{token_id}/history")
            .route(web::get().to(resources::get_nft_history)),
    )
    .service(
        web::resource("/nep171/metadata/{contract_account_id}")
            .route(web::get().to(resources::get_nft_contract_metadata)),
    );
}

'''
'''--- src/modules/nft/resources.rs ---
use paperclip::actix::{
    api_v2_operation,
    web::{self, Json},
};

use crate::{db_helpers, modules, types};

use super::schemas;

#[api_v2_operation]
/// Get user's NFT collection overview
///
/// For the given account_id and timestamp/block_height, this endpoint returns
/// the number of NFTs grouped by contract_id, together with the corresponding NFT contract metadata.
/// NFT contract is presented if the account_id has at least one NFT there.
///
/// `block_timestamp_nanos` helps you to choose the moment of time, we fix the blockchain state at that time.
///
/// **Limitations**
/// * We provide only up to 100 items, where recently updated data goes first.
///   Full-featured pagination will be provided later.
pub async fn get_nft_collection_overview(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::NftCountsRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
    pagination_params: web::Query<types::query_params::PaginationParams>,
) -> crate::Result<Json<schemas::NftCountsResponse>> {
    types::query_params::check_limit(pagination_params.limit)?;
    types::query_params::check_block_params(&block_params)?;
    let block = db_helpers::get_block_from_params(&pool, &block_params).await?;
    modules::check_account_exists(&pool, &request.account_id.0, block.timestamp).await?;

    Ok(Json(schemas::NftCountsResponse {
        // TODO PHASE 2 We can data_provider metadata in the DB and update once in 10 minutes
        nft_counts: super::data_provider::get_nfts_count(
            &pool,
            &rpc_client,
            &block,
            &request.account_id.0,
            pagination_params.0,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation]
/// Get user's NFT collection by contract
///
/// This endpoint returns the list of NFTs, each of them contains all the detailed NFT information,
/// for the given account_id, NFT contract_id, timestamp/block_height.
/// You can copy the token_id from this response and then ask for NFT history.
///
/// **Limitations**
/// * We provide only up to 100 items.
///   Full-featured pagination will be provided later.
pub async fn get_nft_collection_by_contract(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::NftCollectionRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
    pagination_params: web::Query<types::query_params::PaginationParams>,
) -> crate::Result<Json<schemas::NftsResponse>> {
    types::query_params::check_limit(pagination_params.limit)?;
    types::query_params::check_block_params(&block_params)?;
    let block = db_helpers::get_block_from_params(&pool, &block_params).await?;
    modules::check_account_exists(&pool, &request.account_id.0, block.timestamp).await?;
    let pagination = types::query_params::Pagination::from(pagination_params.0);

    Ok(Json(schemas::NftsResponse {
        nfts: super::data_provider::get_nfts_by_contract(
            &rpc_client,
            request.contract_account_id.0.clone(),
            request.account_id.0.clone(),
            block.height,
            pagination.limit,
        )
        .await?,
        contract_metadata: super::data_provider::get_nft_contract_metadata(
            &rpc_client,
            request.contract_account_id.0.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation]
/// Get NFT
///
/// This endpoint returns the NFT detailed information
/// for the given token_id, NFT contract_id, timestamp/block_height.
pub async fn get_nft(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::NftRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::NftResponse>> {
    types::query_params::check_block_params(&block_params)?;
    let block = db_helpers::get_block_from_params(&pool, &block_params).await?;

    Ok(Json(schemas::NftResponse {
        nft: super::data_provider::get_nft(
            &rpc_client,
            request.contract_account_id.0.clone(),
            request.token_id.clone(),
            block.height,
        )
        .await?,
        contract_metadata: super::data_provider::get_nft_contract_metadata(
            &rpc_client,
            request.contract_account_id.0.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation]
/// Get NFT history
///
/// This endpoint returns the history of operations for the given NFT and timestamp/block_height.
/// Keep in mind, it does not related to a concrete account_id; the whole history is shown.
///
/// **Limitations**
/// * For now, we support only NFT contracts which implement Events NEP.
/// * We provide only up to 100 items, where recent updates go first.
///   Full-featured pagination will be provided later.
pub async fn get_nft_history(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::NftRequest>,
    pagination_params: web::Query<types::query_params::HistoryPaginationParams>,
) -> crate::Result<Json<schemas::HistoryResponse>> {
    let block = db_helpers::get_last_block(&pool).await?;
    let pagination =
        modules::check_and_get_history_pagination_params(&pool, pagination_params.0).await?;

    Ok(Json(schemas::HistoryResponse {
        history: super::data_provider::get_nft_history(
            &pool,
            &request.contract_account_id.0,
            &request.token_id,
            &pagination,
        )
        .await?,
        nft: super::data_provider::get_nft(
            &rpc_client,
            request.contract_account_id.0.clone(),
            request.token_id.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation]
/// Get NFT contract metadata
///
/// This endpoint returns the metadata for given NFT contract and timestamp/block_height.
/// Keep in mind, this is contract-wide metadata. Each NFT also has its own metadata.
pub async fn get_nft_contract_metadata(
    pool: web::Data<sqlx::Pool<sqlx::Postgres>>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    request: web::Path<schemas::MetadataRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::MetadataResponse>> {
    types::query_params::check_block_params(&block_params)?;
    let block = db_helpers::get_block_from_params(&pool, &block_params).await?;

    Ok(Json(schemas::MetadataResponse {
        metadata: super::data_provider::get_nft_contract_metadata(
            &rpc_client,
            request.contract_account_id.0.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

'''
'''--- src/modules/nft/schemas.rs ---
use paperclip::actix::Apiv2Schema;

use crate::types;

// *** Requests ***

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftCountsRequest {
    pub account_id: types::AccountId,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftCollectionRequest {
    pub account_id: types::AccountId,
    pub contract_account_id: types::AccountId,
}

// duplicate in each folder
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct MetadataRequest {
    pub contract_account_id: types::AccountId,
}

/// `token_id` is available at `NftCollectionByContractResponse`
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftRequest {
    pub contract_account_id: types::AccountId,
    pub token_id: String,
}

// *** Responses ***

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftCountsResponse {
    pub nft_counts: Vec<NftCount>,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftsResponse {
    pub nfts: Vec<Nft>,
    pub contract_metadata: NftContractMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftResponse {
    pub nft: Nft,
    pub contract_metadata: NftContractMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryResponse {
    pub history: Vec<HistoryItem>,
    pub nft: Nft,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct MetadataResponse {
    pub metadata: NftContractMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

// ---

/// This type describes the history of NFT movements.
/// Note, it's not attached to any user, it's the whole history of NFT movements.
/// `cause` is one of ["mint", "transfer", "burn"]
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryItem {
    // todo add status
    pub cause: String,
    pub old_account_id: Option<types::AccountId>,
    pub new_account_id: Option<types::AccountId>,
    // TODO PHASE 2 add index here
    // pub index: types::U128,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftCount {
    pub contract_account_id: types::AccountId,
    pub nft_count: u32,
    // TODO PHASE 1 naming.
    pub last_updated_at_timestamp_nanos: types::U128,
    pub contract_metadata: NftContractMetadata,
}

/// The type for Non Fungible Token Contract Metadata. Inspired by
/// https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized data_provider assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<String>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

/// The type for Non Fungible Token. Inspired by
/// https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct Nft {
    pub token_id: String,
    pub owner_account_id: String,
    pub metadata: NftMetadata,
    // TODO PHASE 1 do we want to show them? People often put here weird things
    // pub approved_account_ids: Option<std::collections::HashMap<AccountId, u64>>,
}

/// The type for Non Fungible Token Metadata. Inspired by
/// https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed data_provider
    pub media_hash: Option<String>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<String>, // ISO 8601 datetime when token was issued or minted
    pub expires_at: Option<String>, // ISO 8601 datetime when token expires
    pub starts_at: Option<String>, // ISO 8601 datetime when token starts being valid
    pub updated_at: Option<String>, // ISO 8601 datetime when token was last updated
    pub extra: Option<String>, // anything extra the NFT wants to data_provider on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<String>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

'''
'''--- src/rpc_helpers.rs ---
use near_jsonrpc_primitives::types::query::{QueryResponseKind, RpcQueryError};

use crate::errors;

pub(crate) fn get_function_call_request(
    block_height: u64,
    account_id: near_primitives::types::AccountId,
    method_name: &str,
    args: serde_json::Value,
) -> near_jsonrpc_client::methods::query::RpcQueryRequest {
    near_jsonrpc_client::methods::query::RpcQueryRequest {
        block_reference: near_primitives::types::BlockReference::BlockId(
            near_primitives::types::BlockId::Height(block_height),
        ),
        request: near_primitives::views::QueryRequest::CallFunction {
            account_id,
            method_name: method_name.to_string(),
            args: near_primitives::types::FunctionArgs::from(args.to_string().into_bytes()),
        },
    }
}

pub(crate) async fn wrapped_call(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    request: near_jsonrpc_client::methods::query::RpcQueryRequest,
    block_height: u64,
    contract_id: &near_primitives::types::AccountId,
) -> crate::Result<near_primitives::views::CallResult> {
    tracing::info!(
        target: crate::LOGGER_MSG,
        "RPC request: {:?}\nTo contract:{}, block {}",
        request,
        contract_id,
        block_height
    );
    match rpc_client.call(request).await {
        Ok(response) => match response.kind {
            QueryResponseKind::CallResult(result) => Ok(result),
            _ => Err(errors::ErrorKind::RPCError(
                "Unexpected type of the response after CallFunction request".to_string(),
            )
            .into()),
        },
        Err(x) => {
            if let Some(RpcQueryError::ContractExecutionError { vm_error, .. }) = x.handler_error()
            {
                if vm_error.contains("CodeDoesNotExist") || vm_error.contains("MethodNotFound") {
                    return Err(errors::ErrorKind::InvalidInput(format!(
                        "The account `{}` does not implement any suitable contract at block {}",
                        contract_id, block_height
                    ))
                    .into());
                }
            }
            Err(x.into())
        }
    }
}

'''
'''--- src/types/account_id.rs ---
use std::fmt;
use std::str::FromStr;

use derive_more::{AsRef, Deref, From, FromStr, Into};
use paperclip::v2::{models::DataType, schema::TypedData};
use serde::{Deserialize, Serialize};

#[derive(
    Eq,
    Ord,
    Hash,
    Clone,
    PartialEq,
    PartialOrd,
    From,
    Into,
    AsRef,
    Deref,
    FromStr,
    Serialize,
    Deserialize,
)]
#[serde(transparent)]
pub struct AccountId(pub(crate) near_primitives::types::AccountId);

impl fmt::Debug for AccountId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.0, f)
    }
}

impl TypedData for AccountId {
    fn data_type() -> DataType {
        DataType::String
    }
}

pub(crate) fn extract_account_id(
    account_id: &str,
) -> crate::Result<Option<near_primitives::types::AccountId>> {
    Ok(if account_id.is_empty() {
        None
    } else {
        Some(near_primitives::types::AccountId::from_str(account_id)?)
    })
}

'''
'''--- src/types/mod.rs ---
pub(crate) mod account_id;
pub(crate) mod numeric;
pub mod query_params;
pub(crate) mod vector;

pub(crate) use account_id::AccountId;
pub(crate) use numeric::{I128, U128, U64};

'''
'''--- src/types/numeric.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use num_traits::cast::ToPrimitive;
use paperclip::v2::{models::DataType, schema::TypedData};
use serde::{Deserialize, Deserializer, Serialize, Serializer};

use crate::{errors, BigDecimal};

pub(crate) fn to_u128(x: &BigDecimal) -> crate::Result<u128> {
    x.to_string().parse().map_err(|e| {
        errors::ErrorKind::InternalError(format!("Failed to parse u128 {}: {}", x, e)).into()
    })
}

pub(crate) fn to_i128(x: &BigDecimal) -> crate::Result<i128> {
    x.to_string().parse().map_err(|e| {
        errors::ErrorKind::InternalError(format!("Failed to parse i128 {}: {}", x, e)).into()
    })
}

pub(crate) fn to_u64(x: &BigDecimal) -> crate::Result<u64> {
    x.to_u64().ok_or_else(|| {
        errors::ErrorKind::InternalError(format!("Failed to parse u64 {}", x)).into()
    })
}

// Taken from https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/json_types/integers.rs
macro_rules! impl_str_type {
    ($iden: ident, $ty: tt) => {
        #[derive(
            Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, BorshDeserialize, BorshSerialize,
        )]
        pub struct $iden(pub $ty);

        impl From<$ty> for $iden {
            fn from(v: $ty) -> Self {
                Self(v)
            }
        }

        impl From<$iden> for $ty {
            fn from(v: $iden) -> $ty {
                v.0
            }
        }

        impl Serialize for $iden {
            fn serialize<S>(
                &self,
                serializer: S,
            ) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
            where
                S: Serializer,
            {
                serializer.serialize_str(&self.0.to_string())
            }
        }

        impl<'de> Deserialize<'de> for $iden {
            fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
            where
                D: Deserializer<'de>,
            {
                let s: String = Deserialize::deserialize(deserializer)?;
                Ok(Self(str::parse::<$ty>(&s).map_err(|err| {
                    serde::de::Error::custom(err.to_string())
                })?))
            }
        }

        impl TypedData for $iden {
            fn data_type() -> DataType {
                DataType::String
            }
        }
    };
}

impl_str_type!(U128, u128);
impl_str_type!(U64, u64);
impl_str_type!(I128, i128);

'''
'''--- src/types/query_params.rs ---
use crate::{errors, types};
use paperclip::actix::Apiv2Schema;

const DEFAULT_PAGE_LIMIT: u32 = 20;
const MAX_PAGE_LIMIT: u32 = 100;

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct BlockParams {
    pub block_timestamp_nanos: Option<types::U64>,
    pub block_height: Option<types::U64>,
}

// Designed to use together with BlockParams
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct PaginationParams {
    // TODO PHASE 2 add index parameter
    // pub without_updates_after_index: Option<super::types::U128>,
    /// Maximum available limit 100
    pub limit: Option<u32>,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryPaginationParams {
    // pub after_timestamp_nanos: Option<super::types::U64>,
    // pub after_block_height: Option<super::types::U64>,
    // I can, but I decided not to add fields above because people will start using it in production
    // assuming it should give the valid pagination.
    // It won't: we will have issues on the boards because we may have many lines at the same block_height.
    // I want to add fields above to provide the functionality to load the history from the given moment, without knowing the index.
    // But I will add them only at the same moment with the indexes, so that the users can use both mechanisms and paginate properly.
    // TODO PHASE 2 add index parameter
    // pub after_index: Option<super::types::U128>,
    pub limit: Option<u32>,
}

// Helper for parsing the data from user
pub(crate) struct Pagination {
    pub limit: u32,
}

impl From<PaginationParams> for Pagination {
    fn from(params: PaginationParams) -> Self {
        Self {
            limit: params.limit.unwrap_or(DEFAULT_PAGE_LIMIT),
        }
    }
}

impl From<HistoryPaginationParams> for Pagination {
    fn from(params: HistoryPaginationParams) -> Self {
        Self {
            limit: params.limit.unwrap_or(DEFAULT_PAGE_LIMIT),
        }
    }
}

pub(crate) struct HistoryPagination {
    // start_after. Not including this!
    pub block_height: u64,
    pub block_timestamp: u64,
    // TODO PHASE 2 add index parameter
    // pub index: u128,
    pub limit: u32,
}

pub(crate) fn check_block_params(params: &BlockParams) -> crate::Result<()> {
    if params.block_height.is_some() && params.block_timestamp_nanos.is_some() {
        Err(errors::ErrorKind::InvalidInput(
            "Both block_height and block_timestamp_nanos found. Please provide only one of values"
                .to_string(),
        )
        .into())
    } else {
        Ok(())
    }
}

pub(crate) fn check_limit(limit_param: Option<u32>) -> crate::Result<()> {
    if let Some(limit) = limit_param {
        if limit > MAX_PAGE_LIMIT || limit == 0 {
            return Err(errors::ErrorKind::InvalidInput(format!(
                "Limit should be in range [1, {}]",
                MAX_PAGE_LIMIT
            ))
            .into());
        }
    }
    Ok(())
}

'''
'''--- src/types/vector.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};

// Taken from https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/json_types/vector.rs
/// Helper class to serialize/deserialize `Vec<u8>` to base64 string.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
pub struct Base64VecU8(pub Vec<u8>);

impl From<Vec<u8>> for Base64VecU8 {
    fn from(v: Vec<u8>) -> Self {
        Self(v)
    }
}

impl From<Base64VecU8> for Vec<u8> {
    fn from(v: Base64VecU8) -> Vec<u8> {
        v.0
    }
}

pub(crate) fn base64_to_string(value: &Option<Base64VecU8>) -> crate::Result<Option<String>> {
    Ok(if let Some(v) = value {
        Some(serde_json::to_string(&v)?)
    } else {
        None
    })
}

'''