*GitHub Repository "JuEnPeHa/global_near_form"*

'''--- Cargo.toml ---
[package]
name = "global_near_form_nit"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.9"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- src/insert_functions.rs ---
use crate::*;

pub(crate) fn hash_course_type(course_type: &u8) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(course_type.to_string().as_bytes()));
    hash
}

pub(crate) fn hash_teacher_id(teacher_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(teacher_id.as_bytes()));
    hash
}

// pub(crate) fn get_type_of_course<String>(course: String) -> u8 {
//     let answer_nit = "&global_near_form::questions::AnswerNIT".to_string();
//     let answer_nbd = "&global_near_form::questions::AnswerNBD".to_string();
//     match type_of_course(&course) {
//         answer_nit => 0,
//         answer_nbd => 1,
//         _ => env::panic_str("Unknown course type"),
//     }
// }

// pub(crate) fn type_of_course<T>(_: &T) -> String {
//     let tipo = std::any::type_name::<T>().to_string();
//     env::log_str(&tipo);
//     tipo
// }

pub trait AnsweringNIT {
    fn answer_nit(
        &mut self,
        answer_rating: String,
        fr_p: AccountId,
        mo_p: AccountId,
        tu_p: AccountId,
        we_p: AccountId,
        th_p: AccountId,
        nit_p: AccountId,
        com_fr: String,
        com_mo: String,
        com_tu: String,
        com_we: String,
        com_th: String,
        com_nit: String,
    ) -> FormId;
}

#[near_bindgen]
impl AnsweringNIT for Contract {
    #[payable]
    fn answer_nit(
        &mut self,
        answer_rating: String,
        fr_p: AccountId,
        mo_p: AccountId,
        tu_p: AccountId,
        we_p: AccountId,
        th_p: AccountId,
        nit_p: AccountId,
        com_fr: String,
        com_mo: String,
        com_tu: String,
        com_we: String,
        com_th: String,
        com_nit: String,
    ) -> FormId {
        let student = env::signer_account_id();
        let student_name = env::signer_account_id();

        let mut form_id = self.answer_nit.len().to_string();
        form_id.push_str(DELIMITER_NIT);
        form_id.push_str(&student_name.to_string());

        let form_id_cloned = form_id.clone();

        let ratings_str: Vec<&str> = answer_rating.split(" ").collect();
        let ratings_num: Vec<u8> = ratings_str
            .iter()
            .map(|x| x.parse::<u8>().unwrap())
            .collect();

        let answer: AnswerNIT = AnswerNIT {
            student,
            form_id: form_id_cloned,
            friday_professor: fr_p.clone(),
            monday_professor: mo_p.clone(),
            tuesday_professor: tu_p.clone(),
            wednesday_professor: we_p.clone(),
            thursday_professor: th_p.clone(),
            nit_main_professor: nit_p.clone(),
            answer_friday_class: ratings_num[0],
            answer_monday_class: ratings_num[1],
            answer_tuesday_class: ratings_num[2],
            answer_wednesday_class: ratings_num[3],
            answer_thursday_class: ratings_num[4],
            answer_nit_main_class: ratings_num[5],
            comment_friday_class: com_fr,
            comment_monday_class: com_mo,
            comment_tuesday_class: com_tu,
            comment_wednesday_class: com_we,
            comment_thursday_class: com_th,
            comment_main_class: com_nit,
        };

        let type_course: u8 = 0; // 0 = NIT
                                 //env::log_str(type_course.to_string().as_str());

        //assert_one_yocto();
        require!(
            !self.accounts_already_answered_nit.contains(&student_name),
            format!("You already answered the NIT form")
        );
        // assert!(
        //     !self.accounts_already_answered_nit.contains(&student_name),
        //     "You have already answered this form"
        // );
        self.accounts_already_answered_nit.insert(&student_name);

        self.answer_nit.insert(&form_id, &answer);
        self.storage_deposits
            .insert(&student_name, &STORAGE_PER_FORM);
        //Promise::new(env::current_account_id()).transfer(Balance::from(STORAGE_PER_FORM.clone()));

        let by_account_id = self.by_account_id.get(&student_name);
        if let Some(by_account_id) = by_account_id {
            let mut by_account_id = by_account_id;
            by_account_id.form_id_nit.push_str(&form_id);
            //by_account_id.insert(&form_id, &type_course);
            self.by_account_id.insert(&student_name, &by_account_id);
            //by_account_id
        } else {
            self.by_account_id.insert(
                &student_name,
                &StudentAccount {
                    balance: env::account_balance(),
                    locked_balance: env::account_locked_balance(),
                    nonce: env::block_height(),
                    public_key: env::signer_account_pk(),
                    used_gas: env::used_gas(),
                    form_id_nit: form_id.clone(),
                    form_id_nbd: "".to_string(),
                },
            );
            //bydfds
        };

        let mut by_course_type = self.by_course_type.get(&type_course).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByCourseTypeInner {
                    course_type_hash: hash_course_type(&type_course),
                }
                .try_to_vec()
                .unwrap(),
            )
            // let mut set = UnorderedSet::new();
            // set.insert(&form_id);
            // self.by_course_type.insert(&CourseType::NIT, &set);
            // self.by_course_type.get(&CourseType::NIT).unwrap()
        });
        by_course_type.insert(&form_id);
        self.by_course_type.insert(&type_course, &by_course_type);

        let mut by_teacher_friday = self.by_teacher_id.get(&fr_p).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByTeacherIdInner {
                    teacher_id_hash: hash_teacher_id(&fr_p),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        by_teacher_friday.insert(&form_id);
        self.by_teacher_id.insert(&fr_p, &by_teacher_friday);

        let mut by_teacher_monday = self.by_teacher_id.get(&mo_p).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByTeacherIdInner {
                    teacher_id_hash: hash_teacher_id(&mo_p),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        by_teacher_monday.insert(&form_id);
        self.by_teacher_id.insert(&mo_p, &by_teacher_monday);

        let mut by_teacher_tuesday = self.by_teacher_id.get(&tu_p).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByTeacherIdInner {
                    teacher_id_hash: hash_teacher_id(&tu_p),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        by_teacher_tuesday.insert(&form_id);
        self.by_teacher_id.insert(&tu_p, &by_teacher_tuesday);

        let mut by_teacher_wednesday = self.by_teacher_id.get(&we_p).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByTeacherIdInner {
                    teacher_id_hash: hash_teacher_id(&we_p),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        by_teacher_wednesday.insert(&form_id);
        self.by_teacher_id.insert(&we_p, &by_teacher_wednesday);

        let mut by_teacher_thursday = self.by_teacher_id.get(&th_p).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByTeacherIdInner {
                    teacher_id_hash: hash_teacher_id(&th_p),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        by_teacher_thursday.insert(&form_id);
        self.by_teacher_id.insert(&th_p, &by_teacher_thursday);

        let mut by_teacher_nit = self.by_teacher_id.get(&nit_p).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByTeacherIdInner {
                    teacher_id_hash: hash_teacher_id(&nit_p),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        by_teacher_nit.insert(&form_id);
        self.by_teacher_id.insert(&nit_p, &by_teacher_nit);

        form_id
    }
}

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, BorshStorageKey, CryptoHash, Gas,
    PanicOnDefault, Promise, PublicKey,
};

pub use crate::questions::*;
pub use crate::view_functions::*;
mod insert_functions;
mod questions;
mod view_functions;
mod modifier_functions;

const STORAGE_PER_FORM: u128 = 100 * env::STORAGE_PRICE_PER_BYTE;
const DELIMITER_NIT: &str = ":NIT:";
//const _DELIMITER_NBD: &str = ":NBD:";

pub type FormId = String;

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    AnswerNITStorageKeySet,
    // AnswerNBDStorageKeySet,
    AnswerNITStorageKeyMap,
    // AnswerNBDStorageKeyMap,
    StorageDeposits,
    QuestionNIT,
    // QuestionNBD,
    ByAccountId,
    ByAccountIdInner { account_id_hash: CryptoHash },
    ByCourseType,
    ByCourseTypeInner { course_type_hash: CryptoHash },
    ByTeacherId,
    ByTeacherIdInner { teacher_id_hash: CryptoHash },
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    //pub self_contract_id: AccountId,
    pub question_nit: LazyOption<QuestionNIT>,
    // pub question_nbd: LazyOption</*QuestionNBD*/ QuestionNIT>,
    pub by_account_id: LookupMap<AccountId, StudentAccount>,
    pub accounts_already_answered_nit: UnorderedSet<AccountId>,
    // pub accounts_already_answered_nbd: UnorderedSet<AccountId>,
    pub storage_deposits: UnorderedMap<AccountId, Balance>,

    pub answer_nit: UnorderedMap<FormId, AnswerNIT>,
    // pub answer_nbd: UnorderedMap<FormId, /*AnswerNBD*/ AnswerNIT>,
    pub by_course_type: LookupMap<u8, UnorderedSet<FormId>>,

    pub by_teacher_id: LookupMap<AccountId, UnorderedSet<FormId>>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta() -> Self {
        let owner_id = env::signer_account_id();
        Self::new(
            owner_id,
            QuestionNIT {
                question_friday_class: String::from(
                    "¿Cómo calificarías al profesor / la profesora del taller de Introducción a NEAR?",
                ),
                comment_friday_class: String::from(
                    "Cualquier comentario o sugerencia para el profesor / la profesora es bien recibido",
                ),
                friday_professor: vec![AccountId::new_unchecked("fritzwagner.near".to_string())],
                question_monday_class: String::from(
                    "¿Cómo calificarías al profesor / la profesora del taller de Introducción a las dApps?",
                ),
                comment_monday_class: String::from(
                    "Cualquier comentario o sugerencia para el profesor / la profesora es bien recibido",
                ),
                monday_professor: vec![AccountId::new_unchecked("ramgor.near".to_string())],
                question_tuesday_class: String::from(
                    "¿Cómo calificarías al profesor / la profesora del taller de Introducción a los NFTs?",
                ),
                comment_tuesday_class: String::from(
                    "Cualquier comentario o sugerencia para el profesor / la profesora es bien recibido",
                ),
                tuesday_professor: vec![AccountId::new_unchecked("alecaseg.near".to_string())],
                question_wednesday_class: String::from(
                    "¿Cómo calificarías al profesor / la profesora del taller de Introducción al Ecommerce?",
                ),
                comment_wednesday_class: String::from(
                    "Cualquier comentario o sugerencia para el profesor / la profesora es bien recibido",
                ),
                wednesday_professor: vec![AccountId::new_unchecked(
                    "luisaponte99.near".to_string(),
                )],
                question_thursday_class: String::from(
                    "¿Cómo calificarías al profesor / la profesora del taller de Introducción al Desarrollo?",
                ),
                comment_thursday_class: String::from(
                    "Cualquier comentario o sugerencia para el profesor / la profesora es bien recibido",
                ),
                thursday_professor: vec![AccountId::new_unchecked("jeph.near".to_string())],
                question_nit_main_class: String::from(
                    "¿Cómo calificarías al profesor / la profesora de la semana del NIT?",
                ),
                comment_main_class: String::from(
                    "Cualquier comentario o sugerencia para el profesor / la profesora es bien recibido",
                ),
                nit_main_professor: vec![AccountId::new_unchecked("maruja.near".to_string())],
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, question_nit: QuestionNIT) -> Self {
        require!(!env::state_exists(), "Contract already initialized");
        let this = Self {
            owner_id,
            //self_contract_id: env::current_account_id(),
            question_nit: LazyOption::new(
                StorageKey::QuestionNIT.try_to_vec().unwrap(),
                Some(&question_nit),
            ),
            // question_nbd: LazyOption::new(
            //     StorageKey::QuestionNBD.try_to_vec().unwrap(),
            //     Some(/*&question_nbd*/ &question_nit),
            // ),
            by_account_id: LookupMap::new(StorageKey::ByAccountId.try_to_vec().unwrap()),
            accounts_already_answered_nit: UnorderedSet::new(
                StorageKey::AnswerNITStorageKeySet.try_to_vec().unwrap(),
            ),
            // accounts_already_answered_nbd: UnorderedSet::new(
            //     StorageKey::AnswerNBDStorageKeySet.try_to_vec().unwrap(),
            // ),
            storage_deposits: UnorderedMap::new(StorageKey::StorageDeposits.try_to_vec().unwrap()),

            answer_nit: UnorderedMap::new(StorageKey::AnswerNITStorageKeyMap.try_to_vec().unwrap()),
            // answer_nbd: UnorderedMap::new(StorageKey::AnswerNBDStorageKeyMap.try_to_vec().unwrap()),
            by_course_type: LookupMap::new(StorageKey::ByCourseType.try_to_vec().unwrap()),

            by_teacher_id: LookupMap::new(StorageKey::ByTeacherId.try_to_vec().unwrap()),
        };
        this
    }
}

'''
'''--- src/modifier_functions.rs ---
use crate::*;

pub trait ModifierFunctions {
    fn delete_answer_nit(&mut self, form_id: FormId);
}

#[near_bindgen]
impl ModifierFunctions for Contract {
    fn delete_answer_nit(&mut self, form_id: FormId) {
        let student_account: AccountId = AccountId::new_unchecked(form_id.split(DELIMITER_NIT).collect::<Vec<&str>>()[1].to_string());
        let form: Option<AnswerNIT> = self.answer_nit.get(&form_id);
        if let Some(form) = form {
                self.answer_nit.remove(&form.form_id);
                self.accounts_already_answered_nit.remove(&form.student);

                let mut by_teacher_friday = self.by_teacher_id.get(&form.friday_professor).unwrap();
                by_teacher_friday.remove(&form.form_id);
                self.by_teacher_id.insert(&form.friday_professor, &by_teacher_friday);

                let mut by_teacher_monday = self.by_teacher_id.get(&form.monday_professor).unwrap();
                by_teacher_monday.remove(&form.form_id);
                self.by_teacher_id.insert(&form.monday_professor, &by_teacher_monday);

                let mut by_teacher_tuesday = self.by_teacher_id.get(&form.tuesday_professor).unwrap();
                by_teacher_tuesday.remove(&form.form_id);
                self.by_teacher_id.insert(&form.tuesday_professor, &by_teacher_tuesday);

                let mut by_teacher_wednesday = self.by_teacher_id.get(&form.wednesday_professor).unwrap();
                by_teacher_wednesday.remove(&form.form_id);
                self.by_teacher_id.insert(&form.wednesday_professor, &by_teacher_wednesday);

                let mut by_teacher_thursday = self.by_teacher_id.get(&form.thursday_professor).unwrap();
                by_teacher_thursday.remove(&form.form_id);
                self.by_teacher_id.insert(&form.thursday_professor, &by_teacher_thursday);

                let mut by_teacher_nit = self.by_teacher_id.get(&form.nit_main_professor).unwrap();
                by_teacher_nit.remove(&form.form_id);
                self.by_teacher_id.insert(&form.nit_main_professor, &by_teacher_nit);

        } else {
            env::panic_str("Form not found");
        }
        let type_course: u8 = 0; // 0 = NIT
        //self.answer_nit.remove(&form_id);

        self.storage_deposits.remove(&student_account);
        self.by_account_id.remove(&student_account);

        let mut by_course_type = self.by_course_type.get(&type_course).unwrap();
        by_course_type.remove(&form_id);
        self.by_course_type.insert(&type_course, &by_course_type);

    }
}
'''
'''--- src/questions.rs ---
use crate::*;

pub(crate) fn assert_signer_is_owner(owner_id: AccountId) {
    let signer = env::signer_account_id();
    if signer != owner_id {
        env::panic_str("Only the owner can call this function");
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StudentAccount {
    pub balance: Balance,
    pub locked_balance: Balance,
    pub nonce: u64,
    pub public_key: PublicKey,
    pub used_gas: Gas,
    pub form_id_nit: FormId,
    pub form_id_nbd: FormId,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AnswerNIT {
    //pub nonce: U64,
    pub student: AccountId,
    pub form_id: FormId,

    pub answer_friday_class: u8,
    pub friday_professor: AccountId,
    pub comment_friday_class: String,

    pub answer_monday_class: u8,
    pub monday_professor: AccountId,
    pub comment_monday_class: String,

    pub answer_tuesday_class: u8,
    pub tuesday_professor: AccountId,
    pub comment_tuesday_class: String,

    pub answer_wednesday_class: u8,
    pub wednesday_professor: AccountId,
    pub comment_wednesday_class: String,

    pub answer_thursday_class: u8,
    pub thursday_professor: AccountId,
    pub comment_thursday_class: String,

    pub answer_nit_main_class: u8,
    pub nit_main_professor: AccountId,
    pub comment_main_class: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct QuestionNIT {
    //pub nonce: String,
    pub question_friday_class: String,
    pub friday_professor: Vec<AccountId>,
    pub comment_friday_class: String,
    pub question_monday_class: String,
    pub monday_professor: Vec<AccountId>,
    pub comment_monday_class: String,
    pub question_tuesday_class: String,
    pub tuesday_professor: Vec<AccountId>,
    pub comment_tuesday_class: String,
    pub question_wednesday_class: String,
    pub wednesday_professor: Vec<AccountId>,
    pub comment_wednesday_class: String,
    pub question_thursday_class: String,
    pub thursday_professor: Vec<AccountId>,
    pub comment_thursday_class: String,
    pub question_nit_main_class: String,
    pub nit_main_professor: Vec<AccountId>,
    pub comment_main_class: String,
}

pub trait QuestionNITExt {
    fn questions_nit(&self) -> QuestionNIT;

    fn set_friday_professor(&mut self, professor: AccountId);
    fn delete_friday_professor(&mut self, professor: AccountId);
    fn set_monday_professor(&mut self, professor: AccountId);
    fn delete_monday_professor(&mut self, professor: AccountId);
    fn set_tuesday_professor(&mut self, professor: AccountId);
    fn delete_tuesday_professor(&mut self, professor: AccountId);
    fn set_wednesday_professor(&mut self, professor: AccountId);
    fn delete_wednesday_professor(&mut self, professor: AccountId);
    fn set_thursday_professor(&mut self, professor: AccountId);
    fn delete_thursday_professor(&mut self, professor: AccountId);
    fn set_nit_main_professor(&mut self, professor: AccountId);
    fn delete_nit_main_professor(&mut self, professor: AccountId);

    fn get_question_friday_class(&self) -> String;
    fn change_question_friday_class(&mut self, question: String);
    fn get_question_monday_class(&self) -> String;
    fn change_question_monday_class(&mut self, question: String);
    fn get_question_tuesday_class(&self) -> String;
    fn change_question_tuesday_class(&mut self, question: String);
    fn get_question_wednesday_class(&self) -> String;
    fn change_question_wednesday_class(&mut self, question: String);
    fn get_question_thursday_class(&self) -> String;
    fn change_question_thursday_class(&mut self, question: String);
    fn get_question_nit_main_class(&self) -> String;
    fn change_question_nit_main_class(&mut self, question: String);
    fn get_friday_professor(&self) -> Vec<AccountId>;
    fn get_monday_professor(&self) -> Vec<AccountId>;
    fn get_tuesday_professor(&self) -> Vec<AccountId>;
    fn get_wednesday_professor(&self) -> Vec<AccountId>;
    fn get_thursday_professor(&self) -> Vec<AccountId>;
    fn get_nit_main_professor(&self) -> Vec<AccountId>;
    fn get_comment_friday_class(&self) -> String;
    fn change_comment_friday_class(&mut self, comment: String);
    fn get_comment_monday_class(&self) -> String;
    fn change_comment_monday_class(&mut self, comment: String);
    fn get_comment_tuesday_class(&self) -> String;
    fn change_comment_tuesday_class(&mut self, comment: String);
    fn get_comment_wednesday_class(&self) -> String;
    fn change_comment_wednesday_class(&mut self, comment: String);
    fn get_comment_thursday_class(&self) -> String;
    fn change_comment_thursday_class(&mut self, comment: String);
    fn get_comment_main_class(&self) -> String;
    fn change_comment_main_class(&mut self, comment: String);
}

#[near_bindgen]
impl QuestionNITExt for Contract {
    fn questions_nit(&self) -> QuestionNIT {
        self.question_nit.get().unwrap()
    }

    fn get_friday_professor(&self) -> Vec<AccountId> {
        self.question_nit.get().unwrap().friday_professor
    }
    fn set_friday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.friday_professor.retain(|x| x != &professor);
        question_nit.friday_professor.push(professor);
        self.question_nit.set(&question_nit);
    }
    fn delete_friday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.friday_professor.retain(|x| x != &professor);
        self.question_nit.set(&question_nit);
    }

    fn get_monday_professor(&self) -> Vec<AccountId> {
        self.question_nit.get().unwrap().monday_professor
    }
    fn set_monday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.monday_professor.retain(|x| x != &professor);
        question_nit.monday_professor.push(professor);
        self.question_nit.set(&question_nit);
    }
    fn delete_monday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.monday_professor.retain(|x| x != &professor);
        self.question_nit.set(&question_nit);
    }

    fn get_tuesday_professor(&self) -> Vec<AccountId> {
        self.question_nit.get().unwrap().tuesday_professor
    }
    fn set_tuesday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.tuesday_professor.retain(|x| x != &professor);
        question_nit.tuesday_professor.push(professor);
        self.question_nit.set(&question_nit);
    }
    fn delete_tuesday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.tuesday_professor.retain(|x| x != &professor);
        self.question_nit.set(&question_nit);
    }

    fn get_wednesday_professor(&self) -> Vec<AccountId> {
        self.question_nit.get().unwrap().wednesday_professor
    }
    fn set_wednesday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.wednesday_professor.retain(|x| x != &professor);
        question_nit.wednesday_professor.push(professor);
        self.question_nit.set(&question_nit);
    }
    fn delete_wednesday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.wednesday_professor.retain(|x| x != &professor);
        self.question_nit.set(&question_nit);
    }

    fn get_thursday_professor(&self) -> Vec<AccountId> {
        self.question_nit.get().unwrap().thursday_professor
    }
    fn set_thursday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.thursday_professor.retain(|x| x != &professor);
        question_nit.thursday_professor.push(professor);
        self.question_nit.set(&question_nit);
    }
    fn delete_thursday_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.thursday_professor.retain(|x| x != &professor);
        self.question_nit.set(&question_nit);
    }

    fn get_nit_main_professor(&self) -> Vec<AccountId> {
        self.question_nit.get().unwrap().nit_main_professor
    }
    fn set_nit_main_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.nit_main_professor.retain(|x| x != &professor);
        question_nit.nit_main_professor.push(professor);
        self.question_nit.set(&question_nit);
    }
    fn delete_nit_main_professor(&mut self, professor: AccountId) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.nit_main_professor.retain(|x| x != &professor);
        self.question_nit.set(&question_nit);
    }

    fn get_question_friday_class(&self) -> String {
        self.question_nit.get().unwrap().question_friday_class
    }
    fn get_question_monday_class(&self) -> String {
        self.question_nit.get().unwrap().question_monday_class
    }
    fn get_question_tuesday_class(&self) -> String {
        self.question_nit.get().unwrap().question_tuesday_class
    }
    fn get_question_wednesday_class(&self) -> String {
        self.question_nit.get().unwrap().question_wednesday_class
    }
    fn get_question_thursday_class(&self) -> String {
        self.question_nit.get().unwrap().question_thursday_class
    }
    fn get_question_nit_main_class(&self) -> String {
        self.question_nit.get().unwrap().question_nit_main_class
    }

    fn get_comment_friday_class(&self) -> String {
        self.question_nit.get().unwrap().comment_friday_class
    }
    fn get_comment_monday_class(&self) -> String {
        self.question_nit.get().unwrap().comment_monday_class
    }
    fn get_comment_tuesday_class(&self) -> String {
        self.question_nit.get().unwrap().comment_tuesday_class
    }
    fn get_comment_wednesday_class(&self) -> String {
        self.question_nit.get().unwrap().comment_wednesday_class
    }
    fn get_comment_thursday_class(&self) -> String {
        self.question_nit.get().unwrap().comment_thursday_class
    }
    fn get_comment_main_class(&self) -> String {
        self.question_nit.get().unwrap().comment_main_class
    }

    fn change_question_friday_class(&mut self, question_friday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.question_friday_class = question_friday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_question_monday_class(&mut self, question_monday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.question_monday_class = question_monday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_question_tuesday_class(&mut self, question_tuesday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.question_tuesday_class = question_tuesday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_question_wednesday_class(&mut self, question_wednesday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.question_wednesday_class = question_wednesday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_question_thursday_class(&mut self, question_thursday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.question_thursday_class = question_thursday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_question_nit_main_class(&mut self, question_nit_main_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.question_nit_main_class = question_nit_main_class;
        self.question_nit.set(&question_nit);
    }

    fn change_comment_friday_class(&mut self, comment_friday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.comment_friday_class = comment_friday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_comment_monday_class(&mut self, comment_monday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.comment_monday_class = comment_monday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_comment_tuesday_class(&mut self, comment_tuesday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.comment_tuesday_class = comment_tuesday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_comment_wednesday_class(&mut self, comment_wednesday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.comment_wednesday_class = comment_wednesday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_comment_thursday_class(&mut self, comment_thursday_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.comment_thursday_class = comment_thursday_class;
        self.question_nit.set(&question_nit);
    }
    fn change_comment_main_class(&mut self, comment_main_class: String) {
        assert_signer_is_owner(self.owner_id.clone());
        let mut question_nit = self.questions_nit();
        question_nit.comment_main_class = comment_main_class;
        self.question_nit.set(&question_nit);
    }
}

'''
'''--- src/view_functions.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn get_number_answers(&self) -> U64 {
        U64(
            self.accounts_already_answered_nit.len() as u64, /*+ self.accounts_already_answered_nbd.len() as u64*/
        )
    }

    pub fn get_accounts_already_answered(&self) -> Vec<AccountId> {
        self.accounts_already_answered_nit.iter().collect()
    }

    pub fn get_number_answers_nit(&self) -> U64 {
        U64(self.accounts_already_answered_nit.len() as u64)
    }
    /*
    pub fn get_number_answers_nbd(&self) -> U64 {
        U64(self.accounts_already_answered_nbd.len() as u64)
    }*/

    pub fn get_answer_by_form_id_nit(&self, form_id: FormId) -> Option<AnswerNIT> {
        self.answer_nit.get(&form_id)
    }

    pub fn get_answers_nit(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<AnswerNIT> {
        let by_course_type = self.by_course_type.get(&0u8);
        let answers = if let Some(by_course_type) = by_course_type {
            by_course_type
        } else {
            UnorderedSet::new(b"a")
        };
        let keys = answers.as_vector();
        let start = u128::from(from_index.unwrap_or(U128(0)));
        keys.iter()
            .skip(start as usize)
            .take(limit.unwrap_or(100) as usize)
            .map(|key| self.answer_nit.get(&key).unwrap())
            .collect::<Vec<AnswerNIT>>()
    }

    pub fn get_answers_by_teacher_id(
        &self,
        teacher_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<AnswerNIT> {
        let by_teacher_id = self.by_teacher_id.get(&teacher_id);
        let answers = if let Some(by_teacher_id) = by_teacher_id {
            by_teacher_id
        } else {
            UnorderedSet::new(b"b")
        };
        let keys = answers.as_vector();
        let start = u128::from(from_index.unwrap_or(U128(0)));
        keys.iter()
            .skip(start as usize)
            .take(limit.unwrap_or(100) as usize)
            .map(|key| self.answer_nit.get(&key).unwrap())
            .collect::<Vec<AnswerNIT>>()
    }

    pub fn get_student_account(&self, student_account: AccountId) -> Option<StudentAccount> {
        self.by_account_id.get(&student_account)
    }

    pub fn get_number_teacher_clases(&self, teacher_id: AccountId) -> U64 {
        let by_teacher_id = self.by_teacher_id.get(&teacher_id);
        let answers = if let Some(by_teacher_id) = by_teacher_id {
            by_teacher_id
        } else {
            UnorderedSet::new(b"c")
        };
        U64(answers.len() as u64)
    }

    // pub fn get_answer_by_form_id_nbd(
    //     &self,
    //     form_id: FormId
    // ) -> Option<AnswerNBD> {
    //     self.answer_nbd.get(&form_id)
    // }
}

'''