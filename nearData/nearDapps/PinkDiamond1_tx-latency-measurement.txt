*GitHub Repository "PinkDiamond1/tx-latency-measurement"*

'''--- README.md ---
# Transaction Latency Measurement

### 1) Introduction 
Using this repo, you can measure transaction latency on differenct blockchain platforms(ex: Solana mainnet-beta, Avalanche C-chain, Polygon PoS, and Klaytn). Transaction latency is measured by sending a simple value transfer transaction through public RPC url provided by each chain. Each subdirectory is for each different blockchain platform. Codes for other chains will be updated.

### 2) Prerequisite
This project uses NodeJS v16.14.2.

### 3) Getting Started
1. Open terminal 
2. Clone the repo by running `https://github.com/klaytn/tx-latency-measurement.git`
3. `cd tx-latency-measurement/{BlockchainName}-tx-latency-measurement` by selecting which blockchain you want to measure.  
4. Run `npm install` to install node packages.
5. Copy and paste `.env.template` file. Then rename it to `.env` and update variables with your Private key, url of blockchain explorer, and public rpc url.
6. Run `node sendtx_{BlockchainName}.js`. 

### 4) Simple Test with Testnet (Klaytn) 
1. Open terminal 
2. Clone the repo by running `https://github.com/klaytn/tx-latency-measurement.git`
3. Run `npm install` to install node packages. 
```
cd tx-latency-measurement/klaytn-tx-latency-measurement
npm install
```
3. Copy and paste `.env.template` file. Then rename it to `.env`. 
```shell
cp .env.template .env
```
4. Update `.env` and make sure PRIVATE_KEY and S3_BUCKET is empty as below: 
```
PRIVATE_KEY=
CAVER_URL=https://public-node-api.klaytnapi.com/v1/baobab
S3_BUCKET=
```
5. Run `node sendtx_klaytn.js`. Then the output will give you new Private Key and Address. 
```shell
starting tx latency measurement... start time = 1661338618926
Private key is not defined. Use this new private key({NEW_PRIVATE_KEY}).
Get test KLAY from the faucet: https://baobab.wallet.klaytn.foundation/faucet
Your Klaytn address = {NEW_ADDRESS}
```
-   With `NEW_ADDRESS`, get test KLAY from faucet page.
-  Update PRIVATE_KEY in .env file with this `NEW_PRIVATE_KEY`. 
6. Run `node sendtx_klaytn.js`. You can see the result as below:
```
starting tx latency measurement... start time = 1661339036754
failed to s3.upload! Printing instead! undefined bucket name
{"executedAt":1661339056756,"txhash":"0x78273bf3015cffc003b09908b322562eda5d830b455ae1c80b7a090d3b60a43b","startTime":1661339057100,"endTime":1661339059192,"chainId":1001,"latency":2092,"error":"","txFee":0.00105,"txFeeInUSD":0.00026812274999999996,"resourceUsedOfLatestBlock":38800,"numOfTxInLatestBlock":1,"pingTime":24}
```

### 5) List of Blockchain Platforms 
(unchecked: to be updated)
- [x] Klaytn
- [x] Polygon PoS
- [x] Avalanche C-chain 
- [x] Solana
- [x] Near Protocol 
- [x] EOS 
- [x] Fantom
- [x] Polkadot
- [ ] Cosmos
- [x] BNB
- [x] Hedera
- [x] Elrond
- [x] Harmony

'''
'''--- avalanche-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "avalanche": "^3.13.3",
    "aws-sdk": "^2.1114.0",
    "axios": "^0.26.1",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.0",
    "ethers": "^5.6.4",
    "moment": "^2.29.2",
    "parquetjs-lite": "^0.8.7"
  }
}

'''
'''--- avalanche-tx-latency-measurement/sendtx_avalanche.js ---
// Avalanche C-chain transaction latency measurement. 
// Reference of Sending Transaction using Javascript: https://docs.avax.network/quickstart/sending-transactions-with-dynamic-fees-using-javascript/
const ethers = require('ethers');
const Avalanche = require('avalanche').Avalanche;
const AWS = require('aws-sdk');
const parquet = require('parquetjs-lite');
const moment = require('moment');
const fs = require('fs');
const axios = require('axios');
const CoinGecko = require('coingecko-api');
require('dotenv').config();

var address = ""; 
var wallet;

const nodeURL = process.env.PUBLIC_RPC_URL;
const HTTPSProvider = new ethers.providers.JsonRpcProvider(nodeURL);

const chainId = process.env.CHAIN_ID;
const avalanche = new Avalanche(process.env.AVALANCHE_HOST, undefined, 'https', chainId);
const cchain = avalanche.CChain();

const CoinGeckoClient = new CoinGecko(); 
var PrevNonce = null; 

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })

    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')

    var filename = `${datestring}_${data.chainId}.parquet`

    // create new ParquetWriter that writes to 'filename'
    var writer = await parquet.ParquetWriter.openFile(schema, filename);

    await writer.appendRow(data)

    await writer.close()

    return filename;
}

async function sendSlackMsg(msg) {
  axios.post(process.env.SLACK_API_URL, {
      'channel':process.env.SLACK_CHANNEL,
      'mrkdown':true,
      'text':msg
  }, {
      headers: {
          'Content-type':'application/json',
          'Authorization':`Bearer ${process.env.SLACK_AUTH}`
      }
  })
}

async function uploadToS3(data){
    if(process.env.S3_BUCKET === "") {
        throw ("undefined bucket name");
    }
    const s3 = new AWS.S3();
    const filename = await makeParquetFile(data)
    const param = {
      'Bucket':process.env.S3_BUCKET,
      'Key':filename,
      'Body':fs.createReadStream(filename),
      'ContentType':'application/octet-stream'
    }
    await s3.upload(param).promise()
    fs.unlinkSync(filename) 
}
  
// Function to estimate max fee and max priority fee
const calcFeeData = async (maxFeePerGas = undefined, maxPriorityFeePerGas = undefined) => {
    // Get Base Fee: this value is just an estimate
    const baseFee = parseInt(await cchain.getBaseFee(), 16) / 1e9;

    // Calc MaxPriorityFeePerGas and MaxFeePerGas
    maxPriorityFeePerGas = maxPriorityFeePerGas == undefined ? parseInt(await cchain.getMaxPriorityFeePerGas(), 16) / 1e9 : maxPriorityFeePerGas;
    maxFeePerGas = maxFeePerGas == undefined ? 2 * baseFee + maxPriorityFeePerGas : maxFeePerGas;

    if(maxFeePerGas < maxPriorityFeePerGas) {
        throw("Error: Max fee per gas cannot be less than max priority fee per gas");
    }

    return {
        maxFeePerGas: maxFeePerGas.toString(),
        maxPriorityFeePerGas: maxPriorityFeePerGas.toString()
    };
}

// Function to send AVAX
const sendAvax = async (amount, to, maxFeePerGas = undefined, maxPriorityFeePerGas = undefined, nonce = undefined) => {
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: chainId,
        latency:0,
        error:'',
        txFee: 0.0, 
        txFeeInUSD: 0.0, 
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0 
    }

    try{
        const balance = await HTTPSProvider.getBalance(address) // getAssetBalance
        if(balance*(10**(-18)) < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_AVAX))
        {
            // console.log(`Current balance of ${address} is less than ${process.env.BALANCE_ALERT_CONDITION_IN_AVAX} AVAX! balance=${balance*(10**(-18))}`)
            sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/address/${address}|${address}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_AVAX} AVAX! balance=${balance*(10**(-18))} AVAX`)
        }

        const latestNonce = await HTTPSProvider.getTransactionCount(address);
        if (latestNonce == PrevNonce) 
        {
            // console.log(`Nonce ${latestNonce} = ${PrevNonce}`)
            return;
        }

        // Measure latency of getBlockNumber
        const startGetBlockNumber = new Date().getTime()
        const latestBlockNumber = await HTTPSProvider.getBlockNumber()
        const endGetBlockNumber = new Date().getTime()
        data.pingTime = endGetBlockNumber - startGetBlockNumber
        
        // Get latest block for Network congestion info  
        await HTTPSProvider.getBlock(latestBlockNumber).then((res)=>{
            data.numOfTxInLatestBlock = res.transactions.length
            data.resourceUsedOfLatestBlock = Number(res.gasUsed)
        });
        
        // If the max fee or max priority fee is not provided, then it will automatically calculate using CChain APIs
        ({ maxFeePerGas, maxPriorityFeePerGas } = await calcFeeData(maxFeePerGas, maxPriorityFeePerGas));
        maxFeePerGas = ethers.utils.parseUnits(maxFeePerGas, "gwei");
        maxPriorityFeePerGas = ethers.utils.parseUnits(maxPriorityFeePerGas, "gwei");

        // Type 2 transaction is for EIP1559
        const tx = {
            type: 2,
            nonce: latestNonce,
            to, 
            maxPriorityFeePerGas,
            maxFeePerGas,
            value: ethers.utils.parseEther(amount),
            chainId,
        };
        tx.gasLimit = await HTTPSProvider.estimateGas(tx);

        // Sign transaction
        const signedTx = await wallet.signTransaction(tx); //serialized (unsigned tx, signature) : rlp encoded (unsigned tx , signature)
        data.txhash = ethers.utils.keccak256(signedTx);

        // Write starttime 
        const start = new Date().getTime()
        data.startTime = start

        // Sending a signed transaction and waiting for its inclusion
        const signature = await (await HTTPSProvider.sendTransaction(signedTx)).wait(); //default confirmation number = 1
        PrevNonce = latestNonce

        // Calculate latency 
        const end = new Date().getTime()
        data.endTime = end
        data.latency = end-start

        // Get tx Fee and tx Fee in USD 
        var AVAXtoUSD;
        await CoinGeckoClient.simple.price({
            ids: ["avalanche-2"],
            vs_currencies: ["usd"]
        }).then((response)=>{
            AVAXtoUSD= response.data["avalanche-2"]["usd"]
        })
        data.txFee = ethers.utils.formatEther(signature.effectiveGasPrice) * signature.gasUsed;
        data.txFeeInUSD = data.txFee  * AVAXtoUSD;
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    } catch(err){
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    }
    try{
        await uploadToS3(data)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))
    }
};

async function main(){
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)

    if(process.env.SIGNER_PRIVATE_KEY === "") {
        const wallet = ethers.Wallet.createRandom()
        console.log(`Private key is not defined. Use this new private key(${wallet.privateKey}).`)
        console.log(`Get test AVAX from the faucet: https://faucet.avax.network/`)
        console.log(`Your Avalanche address = ${wallet.address}`)
        return
    }

    const privateKey = process.env.SIGNER_PRIVATE_KEY;
    wallet = new ethers.Wallet(privateKey);
    address = wallet.address;

    // run sendTx every SEND_TX_INTERVAL(sec).
    const interval = eval(process.env.SEND_TX_INTERVAL)
        setInterval(()=>{
        sendAvax("0.0", address);
    }, interval)
}

main();
'''
'''--- bnb-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "aws-sdk": "^2.1134.0",
    "axios": "^0.27.2",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.1",
    "moment": "^2.29.3",
    "parquetjs-lite": "^0.8.7",
    "web3": "^1.7.3"
  }
}

'''
'''--- bnb-tx-latency-measurement/sendtx_bnb.js ---
// BNB transaction latency measurement.
// Web3 connection reference: https://docs.binance.org/smart-chain/developer/create-wallet.html#connect-to-bsc-network 

const Web3 = require('web3');
const fs = require('fs')
const AWS = require('aws-sdk')
const parquet = require('parquetjs-lite')
const moment = require('moment');
const axios = require('axios');
const CoinGecko = require('coingecko-api');
const CoinGeckoClient = new CoinGecko(); 
require('dotenv').config();

const web3 = new Web3(process.env.PUBLIC_RPC_URL_WEB3);
const privateKey = process.env.SIGNER_PRIVATE_KEY;
var PrevNonce = null;

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })
  
    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')
  
    var filename = `${datestring}_${data.chainId}.parquet`
  
    // create new ParquetWriter that writes to 'filename'
    var writer = await parquet.ParquetWriter.openFile(schema, filename);
  
    await writer.appendRow(data)
  
    await writer.close()
  
    return filename;
}
  
async function sendSlackMsg(msg) {
    axios.post(process.env.SLACK_API_URL, {
        'channel':process.env.SLACK_CHANNEL,
        'mrkdown':true,
        'text':msg
    }, {
        headers: {
            'Content-type':'application/json',
            'Authorization':`Bearer ${process.env.SLACK_AUTH}`
        }
    })
}
  
async function uploadToS3(data){
    if(process.env.S3_BUCKET === "") {
        throw "undefined bucket name"
    }

    const s3 = new AWS.S3();
    const filename = await makeParquetFile(data)
    const param = {
        'Bucket':process.env.S3_BUCKET,
        'Key':filename,
        'Body':fs.createReadStream(filename),
        'ContentType':'application/octet-stream'
    }
    await s3.upload(param).promise()
  
    fs.unlinkSync(filename) 
}

async function sendTx(){
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: 0,
        latency:0,
        error:'',
        txFee: 0.0, 
        txFeeInUSD: 0.0, 
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0 
    }
    
    try{
        const signer = web3.eth.accounts.privateKeyToAccount(
            privateKey
        );
        const balance = await web3.eth.getBalance(signer.address)

        if(balance*(10**(-18)) < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_BNB))
        {
            sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/address/${signer.address}|${signer.address}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_BNB} BNB! balance=${balance*(10**(-18))} BNB`)
        }

        await web3.eth.net.getId().then((id)=>{
            data.chainId = id
        })
        const startGetBlock = new Date().getTime()
        const latestBlockNumber = await web3.eth.getBlockNumber();
        const endGetBlock = new Date().getTime()
        data.pingTime = endGetBlock - startGetBlock
        await web3.eth.getBlock(latestBlockNumber).then((blockInfo)=>{
            data.resourceUsedOfLatestBlock = blockInfo.gasUsed
            data.numOfTxInLatestBlock = blockInfo.transactions.length
        })

        const gasPrice = await web3.eth.getGasPrice(); //in Wei 
        const latestNonce = await web3.eth.getTransactionCount(signer.address);
        if (latestNonce == PrevNonce) 
        {
            // console.log(`Nonce ${latestNonce} = ${PrevNonce}`)
            return;
        }

        const rawTx = {
            from: signer.address, 
            to: signer.address,
            value: Web3.utils.toHex(Web3.utils.toWei("0", 'ether')),
            gasLimit: Web3.utils.toHex(21000),
            gasPrice: Web3.utils.toHex(gasPrice),
            nonce: Web3.utils.toHex(latestNonce)
        }

        var RLPEncodedTx;
        await web3.eth.accounts.signTransaction(rawTx, privateKey)
        .then((result)=>
        {   
            RLPEncodedTx = result.rawTransaction // RLP encoded transaction & already HEX value
            data.txhash = result.transactionHash // the transaction hash of the RLP encoded transaction.
        })
        
        const originalPrevNonce = PrevNonce
        // Send signed transaction (ref: https://web3js.readthedocs.io/en/v1.2.11/callbacks-promises-events.html#promievent)
        const start = new Date().getTime()
        data.startTime = start
        await web3.eth
        .sendSignedTransaction(RLPEncodedTx)
        .on('sent', function(){
            PrevNonce = latestNonce
        })
        .on('error', function(err){
            PrevNonce = originalPrevNonce
        })
        .then(function(receipt){
            // will be fired once the receipt is mined
            data.txhash = receipt.transactionHash
            const end = new Date().getTime()
            data.endTime = end
            data.latency = end-start
            const gasPriceInBNB = web3.utils.fromWei(gasPrice)
            data.txFee = receipt.gasUsed * gasPriceInBNB
        });

        // Calculate Transaction Fee and Get Tx Fee in USD 
        var BNBtoUSD; 
        await CoinGeckoClient.simple.price({
            ids: ["binancecoin"],
            vs_currencies: ["usd"]
        }).then((response)=>{
            BNBtoUSD = response.data["binancecoin"]["usd"]
        })
        data.txFeeInUSD = data.txFee * BNBtoUSD 
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)

    } catch(err){
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    }
    try{
        await uploadToS3(data)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))
    }
}

async function main(){
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)

    if(privateKey === "") {
        const account =  web3.eth.accounts.create(web3.utils.randomHex(32));
        console.log(`Private key is not defined. Use this new private key(${account.privateKey}).`)
        console.log(`Get test BNB from the faucet: https://testnet.binance.org/faucet-smart`)
        console.log(`Your BNB Smart Chain address = ${account.address}`)
        return
    }

    // run sendTx every SEND_TX_INTERVAL
    const interval = eval(process.env.SEND_TX_INTERVAL)
    setInterval(()=>{
      sendTx()
    }, interval)
}

main();
'''
'''--- elrond-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "@babel/runtime": "^7.18.9",
    "@elrondnetwork/elrond-core-js": "^2.1.0",
    "@elrondnetwork/erdjs": "^10.2.4",
    "@elrondnetwork/erdjs-network-providers": "^0.1.5",
    "@elrondnetwork/erdjs-walletcore": "^1.0.0",
    "aws-sdk": "^2.1135.0",
    "axios": "^0.27.2",
    "browserify": "^17.0.0",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.1",
    "moment": "^2.29.3",
    "parquetjs-lite": "^0.8.7"
  }
}

'''
'''--- elrond-tx-latency-measurement/sendtx_elrond.js ---
// Elrond transaction latency measurement.
// API reference: https://api.elrond.com/
// Reference for signing transaction: https://github.com/ElrondNetwork/elrond-sdk-erdjs/blob/a9b33e90ba7df70e11898cc0b8149966a0a61f29/src/transaction.local.net.spec.ts

const { ApiNetworkProvider } = require("@elrondnetwork/erdjs-network-providers");
const { TokenPayment, TransactionWatcher } = require("@elrondnetwork/erdjs/out");
const { Transaction, Address } = require("@elrondnetwork/erdjs");
const { UserSigner, UserSecretKey } = require("@elrondnetwork/erdjs-walletcore");
const core = require("@elrondnetwork/elrond-core-js");
const fs = require('fs');
const AWS = require('aws-sdk');
const parquet = require('parquetjs-lite');
const moment = require('moment');
const axios = require("axios");
const CoinGecko = require('coingecko-api');
const CoinGeckoClient = new CoinGecko(); 
require('dotenv').config();

const networkProvider = new ApiNetworkProvider(process.env.PUBLIC_API_URL, {timeout : 5000});
var signer;

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })
  
    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')
  
    var filename = `${datestring}_${data.chainId}.parquet`
  
    // create new ParquetWriter that writes to 'filename'
    var writer = await parquet.ParquetWriter.openFile(schema, filename);
  
    await writer.appendRow(data)
  
    await writer.close()
  
    return filename;
}
  
async function sendSlackMsg(msg) {
    axios.post(process.env.SLACK_API_URL, {
        'channel':process.env.SLACK_CHANNEL,
        'mrkdown':true,
        'text':msg
    }, {
        headers: {
            'Content-type':'application/json',
            'Authorization':`Bearer ${process.env.SLACK_AUTH}`
        }
    })
}
  
async function uploadToS3(data){
    if(process.env.S3_BUCKET === "") {
        throw "undefined bucket name"
    }

    const s3 = new AWS.S3();
    const filename = await makeParquetFile(data)
    const param = {
        'Bucket':process.env.S3_BUCKET,
        'Key':filename,
        'Body':fs.createReadStream(filename),
        'ContentType':'application/octet-stream'
    }
    await s3.upload(param).promise()
  
    fs.unlinkSync(filename) 
}

async function sendTx(){
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: process.env.CHAIN_ID,
        latency:0,
        error:'',
        txFee: 0.0, 
        txFeeInUSD: 0.0, 
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0 
    }

    try{
        const address = signer.getAddress()

        const account = await networkProvider.getAccount(address);
        const balance = account.balance.toNumber()*(10**(-18))

        if(balance < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_EGLD))
        {
            sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/accounts/${address.toString()}|${address.toString()}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_EGLD} EGLD! balance=${balance} EGLD`)
        }

        const networkConfig = await networkProvider.getNetworkConfig();

        const startGetBlock = new Date().getTime()
        const networkStatus = await networkProvider.getNetworkStatus();
        const endGetBlock = new Date().getTime()
        data.pingTime = endGetBlock - startGetBlock
        
        // blocks from different shard(currently 3 shards) are included in metachain block (hyperblock)
        var gasUsed = 0.0; 
        var txCount = 0; 
        const metachainShardId = 4294967295;
        let response = await axios.get(process.env.PUBLIC_API_URL + `/blocks?nonce=${networkStatus.HighestFinalNonce}&shard=${metachainShardId}`,{
            headers:{
                "Content-Type": "application/json"
            }
        });
        
        //Calc reference: https://explorer.elrond.com/blocks/562f5a24b79f2b383881c1e42f2759d90ad47458187c4af92e03af8d45fcad49 
        gasUsed += response.data[0].gasConsumed - response.data[0].gasRefunded - response.data[0].gasPenalized; 
        txCount += response.data[0].txCount;

        let hyperblockInfo = await axios.get(process.env.PUBLIC_API_URL + `/blocks/${response.data[0].hash}`,{
            headers:{
                "Content-Type": "application/json"
            }
        });
        
        for await(blockhash of hyperblockInfo.data.notarizedBlocksHashes)
        {
            let shardBlockInfo = await axios.get(process.env.PUBLIC_API_URL + `/blocks/${blockhash}`,{
                headers:{
                    "Content-Type": "application/json"
                }
            });
            gasUsed += (Number(shardBlockInfo.data.gasConsumed) - Number(shardBlockInfo.data.gasRefunded) - Number(shardBlockInfo.data.gasPenalized))
            txCount += shardBlockInfo.data.txCount
        }
        data.resourceUsedOfLatestBlock = gasUsed
        data.numOfTxInLatestBlock = txCount

        // Create Transaction
        let tx = new Transaction({
            sender: address,
            receiver: address,
            gasLimit : 50000,
            value: TokenPayment.egldFromAmount(0),
            chainID: networkConfig.ChainID,
            nonce: account.nonce
        })
        
        // Sign Transaction
        await signer.sign(tx);
        
        let watcher = new TransactionWatcher(networkProvider);
        const start = new Date().getTime()
        data.startTime = start
        const txHash = await networkProvider.sendTransaction(tx);       

        // Wait for transaction completion (Ref: https://docs.elrond.com/sdk-and-tools/erdjs/erdjs-cookbook/)
        await watcher.awaitCompleted(tx);
        const end = new Date().getTime()
        data.endTime = end
        data.latency = end-start
        data.txhash = txHash

        // Get gasPrice and gasUsed of transaction
        let txDetails = await axios.get(process.env.PUBLIC_API_URL + `/transactions/${txHash}`, {
            headers:{
                "Content-Type": "application/json"
            }
        })
        data.txFee = txDetails.data.gasPrice * txDetails.data.gasUsed * (10**(-18))

        // Calculate Transaction Fee and Get Tx Fee in USD 
        var EGLDtoUSD; 
        await CoinGeckoClient.simple.price({
            ids: ["elrond-erd-2"],
            vs_currencies: ["usd"]
        }).then((response)=>{
            EGLDtoUSD = response.data["elrond-erd-2"]["usd"]
        })
        data.txFeeInUSD = data.txFee * EGLDtoUSD 
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)

    } catch(err){
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    }
    try{
        await uploadToS3(data)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))
    }
}

async function main(){
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)

    if (process.env.SIGNER_SECRET_KEY === ""){
        let account = new core.account();
        let mnemonic = account.generateMnemonic();
        let privateKeyHex = account.privateKeyFromMnemonic(mnemonic, false, "0", "");
        let privateKey = Buffer.from(privateKeyHex, "hex");
        account.generateKeyFileFromPrivateKey(privateKey, 'password');
        const address = new UserSigner(UserSecretKey.fromString(privateKeyHex)).getAddress().bech32()
        console.log(`Private Key is not defined. Use this new private key (${privateKeyHex})`)
        console.log(`Get test dEGLD from the faucet: https://r3d4.fr/faucet`)
        console.log(`Your Elrond address = ${address}`)
        console.log(`OR you can create wallet account from Devnet Wallet: https://devnet-wallet.elrond.com/`)
        return; 
    }
    
    signer = new UserSigner(UserSecretKey.fromString(process.env.SIGNER_SECRET_KEY))

    // run sendTx every SEND_TX_INTERVAL
    const interval = eval(process.env.SEND_TX_INTERVAL)
    setInterval(()=>{
      sendTx()
    }, interval)
}

main();
'''
'''--- eos-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "aws-sdk": "^2.1131.0",
    "axios": "^0.27.2",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.0",
    "eosjs": "^22.1.0",
    "moment": "^2.29.3",
    "node-fetch": "^2.6.7",
    "parquetjs-lite": "^0.8.7"
  }
}

'''
'''--- eos-tx-latency-measurement/sendtx_eos.js ---
// EOS transaction latency measurement. 
// Reference of Sending Token using EOSJS library: https://developers.eos.io/manuals/eosjs/latest/how-to-guides/how-to-transfer-an-eosio-token 

const { JsonRpc, Api } = require('eosjs');
const { JsSignatureProvider } = require('eosjs/dist/eosjs-jssig'); // development only
const { TextEncoder, TextDecoder } = require('util');
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));

const AWS = require('aws-sdk');
const parquet = require('parquetjs-lite');
const moment = require('moment');
const axios = require('axios');
const CoinGecko = require('coingecko-api');
const fs = require('fs');
const CoinGeckoClient = new CoinGecko();  

require("dotenv").config();

const defaultPrivateKey = process.env.SINGER_PRIVATE_KEY;
const signatureProvider = new JsSignatureProvider([defaultPrivateKey]);

const rpc = new JsonRpc(process.env.PUBLIC_RPC_URL, {fetch});
const api = new Api({rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder()});
const accountId = process.env.ACCOUNT_ID;
const receiverId = process.env.RECEIVER_ID;

async function makeParquetFile(data) {
  var schema = new parquet.ParquetSchema({
      executedAt:{type:'TIMESTAMP_MILLIS'},
      txhash:{type:'UTF8'},
      startTime:{type:'TIMESTAMP_MILLIS'},
      endTime:{type:'TIMESTAMP_MILLIS'},
      chainId:{type:'INT64'},
      latency:{type:'INT64'},
      error:{type:'UTF8'},
      txFee:{type:'DOUBLE'},
      txFeeInUSD:{type:'DOUBLE'},
      resourceUsedOfLatestBlock:{type:'INT64'},
      numOfTxInLatestBlock:{type:'INT64'},
      pingTime:{type:'INT64'}
  })

  var d = new Date()
  //20220101_032921
  var datestring = moment().format('YYYYMMDD_HHmmss')

  var filename = `${datestring}_${data.chainId}.parquet`

  // create new ParquetWriter that writes to 'filename'
  var writer = await parquet.ParquetWriter.openFile(schema, filename);

  await writer.appendRow(data)
  writer.close()
  return filename;
}  

async function sendSlackMsg(msg) {
  axios.post(process.env.SLACK_API_URL, {
      'channel':process.env.SLACK_CHANNEL,
      'mrkdown':true,
      'text':msg
  }, {
      headers: {
          'Content-type':'application/json',
          'Authorization':`Bearer ${process.env.SLACK_AUTH}`
      }
  })
}

async function uploadToS3(data){
  const s3 = new AWS.S3();
  const filename = await makeParquetFile(data)
  const param = {
    'Bucket':process.env.S3_BUCKET,
    'Key':filename,
    'Body':fs.createReadStream(filename),
    'ContentType':'application/octet-stream'
  }
  await s3.upload(param).promise()

  fs.unlinkSync(filename) 
}  

async function sendTx(){
  var data = {
    executedAt: new Date().getTime(),
    txhash: '',
    startTime: 0,
    endTime: 0,
    chainId: process.env.CHAIN_ID,
    latency:0,
    error:'',
    txFee: 0.0,
    txFeeInUSD: 0.0,
    resourceUsedOfLatestBlock: 0,
    numOfTxInLatestBlock: 0,
    pingTime:0
  }
  
  try{
    const info = await rpc.get_info();

    // Get latest block & measure pingTime 
    const startGetBlock = new Date().getTime()
    const blockInfo = await rpc.get_block(info.head_block_num)// head_block_num = Highest block number on the chain
    const endGetBlock = new Date().getTime()
    data.pingTime = endGetBlock - startGetBlock

    var cpuUsed = 0; 
    for(let i = 0; i < blockInfo.transactions.length; i++){
      cpuUsed += Number(blockInfo.transactions[i].cpu_usage_us)
    }
    data.resourceUsedOfLatestBlock = cpuUsed;
    data.numOfTxInLatestBlock = blockInfo.transactions.length;
    
    const accountInfo = await rpc.get_account(accountId);

    // Calculate CPU price using cpu_limit and staked balance 
    const cpuPrice = Number(accountInfo.total_resources.cpu_weight.split(' ')[0]) / Number(accountInfo.cpu_limit.max) 

    // Check if balance is enough
    const balance = Number(accountInfo.core_liquid_balance.split(' ')[0]); // in TNT(=Temporary Network Token (TNT))    
    if(balance < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_EOS))
    {
      //testnet : https://testnet.eos.io/blockchain-accounts/{accountId}
      sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/blockchain-accounts/${accountId}|${accountId}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_EOS} EOS! balance=${balance} EOS`)
    }
    
    //not broadcast, sign transaction. 
    const signedTx = await api.transact({
      actions: [{
        account: "eosio.token",
        name: "transfer",
        authorization: [{
          actor: accountId,
          permission: "active",
        }],
        data: {
          from: accountId,
          to: receiverId,
          quantity: "0.0001 TNT", //Should be changed to EOS from TNT when using Mainnet.  
          memo: ""
        }
      }]
    }, {
      blocksBehind: 3,
      expireSeconds: 200,
      broadcast: false
    });
    //Send Transaction and Measure Latency 
    const start = new Date().getTime()
    data.startTime = start
    const result = await rpc.send_transaction(signedTx);
    const end = new Date().getTime()
    data.latency = end - start 
    data.txhash = result.transaction_id
    data.endTime = end 
  
    // Calculate CPU fee and CPU fee in USD 
    data.txFee = cpuPrice * result.processed.receipt.cpu_usage_us;
    var EOStoUSD;
    await CoinGeckoClient.simple.price({
      ids: ["eos"],
      vs_currencies: ["usd"]
    }).then((response)=>{
      EOStoUSD = response.data["eos"]["usd"]
    })
    data.txFeeInUSD = data.txFee * EOStoUSD 
    console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
  } catch(err){
      console.log("failed to execute.", err.toString())
      data.error = err.toString()
      console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
  }
  try{
      await uploadToS3(data)
  } catch(err){
      console.log('failed to s3.upload', err.toString())
  }
}

async function main(){
  const start = new Date().getTime()
  console.log(`starting tx latency measurement... start time = ${start}`)

  // run sendTx every SEND_TX_INTERVAL
  const interval = eval(process.env.SEND_TX_INTERVAL)
  setInterval(()=>{
    sendTx()
  }, interval)

}

main();
'''
'''--- fantom-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "aws-sdk": "^2.1132.0",
    "axios": "^0.27.2",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.1",
    "moment": "^2.29.3",
    "parquetjs-lite": "^0.8.7",
    "web3": "^1.7.3"
  }
}

'''
'''--- fantom-tx-latency-measurement/sendtx_fantom.js ---
// Fantom transaction latency measurement. 
// Reference of Sending Transaction using Javascript: https://github.com/Fantom-foundation/fantom-web3-wallet/blob/master/index.js

const Web3 = require('web3');
const fs = require('fs')
const AWS = require('aws-sdk')
const parquet = require('parquetjs-lite')
const moment = require('moment');
const axios = require('axios');
const CoinGecko = require('coingecko-api');
const CoinGeckoClient = new CoinGecko(); 

require('dotenv').config();

const web3 = new Web3(new Web3.providers.HttpProvider(process.env.PUBLIC_RPC_URL_WEB3));
const privateKey = process.env.SIGNER_PRIVATE_KEY;
var PrevNonce = null;

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })
  
    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')
  
    var filename = `${datestring}_${data.chainId}.parquet`
  
    // create new ParquetWriter that writes to 'filename'
    var writer = await parquet.ParquetWriter.openFile(schema, filename);
  
    await writer.appendRow(data)
  
    await writer.close()
  
    return filename;
}
  
async function sendSlackMsg(msg) {
    axios.post(process.env.SLACK_API_URL, {
        'channel':process.env.SLACK_CHANNEL,
        'mrkdown':true,
        'text':msg
    }, {
        headers: {
            'Content-type':'application/json',
            'Authorization':`Bearer ${process.env.SLACK_AUTH}`
        }
    })
}
  
async function uploadToS3(data){
    if(process.env.S3_BUCKET === "") {
        throw "undefined bucket name"
    }

    const s3 = new AWS.S3();
    const filename = await makeParquetFile(data)
    const param = {
        'Bucket':process.env.S3_BUCKET,
        'Key':filename,
        'Body':fs.createReadStream(filename),
        'ContentType':'application/octet-stream'
    }
    await s3.upload(param).promise()
  
    fs.unlinkSync(filename) 
}

async function sendTx(){
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: 0,
        latency:0,
        error:'',
        txFee: 0.0, 
        txFeeInUSD: 0.0, 
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0 
    }
    
    try{
        const signer = web3.eth.accounts.privateKeyToAccount(
            process.env.SIGNER_PRIVATE_KEY
        );
        const balance = await web3.eth.getBalance(signer.address)

        if(balance*(10**(-18)) < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_FTM))
        {
            sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/address/${signer.address}|${signer.address}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_FTM} FTM! balance=${balance*(10**(-18))} FTM`)
        }

        await web3.eth.net.getId().then((id)=>{
            data.chainId = id
        })
        const gasPrice = await web3.eth.getGasPrice();
        if (gasPrice * (10**(-9)) > process.env.MAX_GAS_PRICE)
        {
            console.log(`Gas Price ${gasPrice*(10**(-9))} Gwei is bigger than Gas Price limit ${process.env.MAX_GAS_PRICE} Gwei.`)
            return; 
        }

        const latestNonce = await web3.eth.getTransactionCount(signer.address);
        if (latestNonce == PrevNonce) 
        {
        //   console.log(`Nonce ${latestNonce} = ${PrevNonce}`)
          return;
        }

        const startGetBlock = new Date().getTime()
        const latestBlockNumber = await web3.eth.getBlockNumber();
        const endGetBlock = new Date().getTime()
        data.pingTime = endGetBlock - startGetBlock

        await web3.eth.getBlock(latestBlockNumber).then((blockInfo)=>{
            data.resourceUsedOfLatestBlock = blockInfo.gasUsed
            data.numOfTxInLatestBlock = blockInfo.transactions.length
        })

        const rawTx = {
            from: signer.address, 
            to: signer.address,
            value: Web3.utils.toHex(Web3.utils.toWei("0", 'ether')),
            gasLimit: Web3.utils.toHex(21000),
            gasPrice: Web3.utils.toHex(gasPrice),
            nonce: Web3.utils.toHex(latestNonce)
        }

        var RLPEncodedTx;
        await web3.eth.accounts.signTransaction(rawTx, privateKey)
        .then((result)=>
        {   
            RLPEncodedTx = result.rawTransaction // RLP encoded transaction & already HEX value
            data.txhash = result.transactionHash // the transaction hash of the RLP encoded transaction.
        })
        
        const originalPrevNonce = PrevNonce
        // Send signed transaction
        const start = new Date().getTime()
        data.startTime = start
        await web3.eth
        .sendSignedTransaction(RLPEncodedTx)
        .on('sent', function(){
            PrevNonce = latestNonce
        })
        .on('receipt', function(receipt){
            const end = new Date().getTime()
            data.endTime = end
            data.latency = end-start
            data.txFee = receipt.gasUsed * web3.utils.fromWei(receipt.effectiveGasPrice.toString())
        })
        .on('error', function(err){
            PrevNonce = originalPrevNonce
        })

        // Calculate Transaction Fee and Get Tx Fee in USD 
        var FTMtoUSD;
        await CoinGeckoClient.simple.price({
            ids: ["fantom"],
            vs_currencies: ["usd"]
        }).then((response)=>{
            FTMtoUSD = response.data["fantom"]["usd"]
        })
        data.txFeeInUSD = data.txFee * FTMtoUSD
        
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    } catch(err){
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    }
    try{
        await uploadToS3(data)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))
    }

}

async function main(){
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)

    if(privateKey === "") {
        const account = web3.eth.accounts.create(web3.utils.randomHex(32));
        console.log(`Private key is not defined. Use this new private key(${account.privateKey}).`)
        console.log(`Get test FTM from the faucet: https://faucet.fantom.network/`)
        console.log(`Your Fantom address = ${account.address}`)
        return
    }

    // run sendTx every SEND_TX_INTERVAL
    const interval = eval(process.env.SEND_TX_INTERVAL)
    setInterval(()=>{
      sendTx()
    }, interval)
  
}
  
main();
'''
'''--- harmony-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "aws-sdk": "^2.1136.0",
    "axios": "^0.27.2",
    "bn.js": "^5.2.0",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.1",
    "moment": "^2.29.3",
    "parquetjs-lite": "^0.8.7",
    "web3": "^1.7.3"
  }
}

'''
'''--- harmony-tx-latency-measurement/sendtx_harmony.js ---
// Harmony transaction latency measurement.
// Reference of Sending Transaction using Web3.js:https://docs.harmony.one/home/developers/sdk/web3/send-transaction 

const Web3 = require('web3');
const BN = require('bn.js');
const fs = require('fs');
const AWS = require('aws-sdk');
const parquet = require('parquetjs-lite');
const moment = require('moment');
const axios = require('axios');
const CoinGecko = require('coingecko-api');
const CoinGeckoClient = new CoinGecko(); 

require('dotenv').config();
const web3 = new Web3(process.env.PUBLIC_RPC_URL);
const privateKey = process.env.HMY_PRIVATE_KEY;
var prevNonce = null;

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })
  
    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')
  
    var filename = `${datestring}_${data.chainId}.parquet`
  
    // create new ParquetWriter that writes to 'filename'
    var writer = await parquet.ParquetWriter.openFile(schema, filename);
  
    await writer.appendRow(data)
  
    await writer.close()
  
    return filename;
}
  
async function sendSlackMsg(msg) {
    axios.post(process.env.SLACK_API_URL, {
        'channel':process.env.SLACK_CHANNEL,
        'mrkdown':true,
        'text':msg
    }, {
        headers: {
            'Content-type':'application/json',
            'Authorization':`Bearer ${process.env.SLACK_AUTH}`
        }
    })
}
  
async function uploadToS3(data){
    if(process.env.S3_BUCKET === "") {
        throw "undefined bucket name"
    }

    const s3 = new AWS.S3();
    const filename = await makeParquetFile(data)
    const param = {
        'Bucket':process.env.S3_BUCKET,
        'Key':filename,
        'Body':fs.createReadStream(filename),
        'ContentType':'application/octet-stream'
    }
    await s3.upload(param).promise()
  
    fs.unlinkSync(filename) 
}

async function sendTx(){
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: 0,
        latency:0,
        error:'',
        txFee: 0.0,
        txFeeInUSD: 0.0, 
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0
    }

    try{
        const signer = web3.eth.accounts.privateKeyToAccount(privateKey);
        const signerAddress = signer.address;

        const balance = await web3.eth.getBalance(signerAddress);
        if(balance/1e18 < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_ONE))
        {
            sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/address/${signerAddress}|${signerAddress}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_ONE} ONE! balance=${balance/1e18} ONE`)
        }
        await web3.eth.net.getId().then((id)=>{
            data.chainId = id
        })

        const latestNonce = await web3.eth.getTransactionCount(signerAddress);
        if (latestNonce == prevNonce) 
        {
            // console.log(`Nonce ${latestNonce} = ${prevNonce}`)
            return;
        }

        const startGetBlock = new Date().getTime()
        const lastBlockNumber = await web3.eth.getBlockNumber();
        const endGetBlock = new Date().getTime()
        data.pingTime = endGetBlock - startGetBlock
        
        let blockInfo = await web3.eth.getBlock(lastBlockNumber);
        data.resourceUsedOfLatestBlock = blockInfo.gasUsed;
        data.numOfTxInLatestBlock = blockInfo.transactions.length;
        
        const gasPrice = new BN(await web3.eth.getGasPrice()).mul(new BN(1))
        const rawTx = {
            from: signerAddress,
            to:signerAddress,
            value: 0,
            gasLimit: Web3.utils.toHex(21000),
            gasPrice,
            nonce: latestNonce
        }

        var RLPEncodedTx;
        await web3.eth.accounts.signTransaction(rawTx, process.env.HMY_PRIVATE_KEY)
        .then((result)=>
        {   
            RLPEncodedTx = result.rawTransaction // RLP encoded transaction & already HEX value
            data.txhash = result.transactionHash // the transaction hash of the RLP encoded transaction.
        })

        const originalPrevNonce = prevNonce
        // Send Signed transaction        
        const start = new Date().getTime()
        data.startTime = start
        await web3.eth
        .sendSignedTransaction(RLPEncodedTx)
        .on('sent', function(){
            prevNonce = latestNonce
        })
        .on('receipt', function(receipt){
            const end = new Date().getTime()
            data.endTime = end
            data.latency = end-start
            data.txFee = receipt.gasUsed * rawTx.gasPrice/1e18
        })
        .on('error', function(err){
            prevNonce = originalPrevNonce
        })
        
        // Calculate Transaction Fee and Get Tx Fee in USD 
        var ONEtoUSD;
        await CoinGeckoClient.simple.price({
            ids: ["harmony"],
            vs_currencies: ["usd"]
        }).then((response)=>{
            ONEtoUSD = response.data["harmony"]["usd"]
        })
        data.txFeeInUSD = data.txFee * ONEtoUSD
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    } catch(err){
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    }
    try{
        await uploadToS3(data)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))
    }
}

async function main(){
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)

    if(privateKey === "") {
        const account = web3.eth.accounts.create(web3.utils.randomHex(32));
        console.log(`Private key is not defined. Use this new private key(${account.privateKey}).`)
        console.log(`Get test ONE from the faucet: http://dev.faucet.easynode.one/`)
        console.log(`Your Harmony address = ${account.address}`)
        return
    }

    // run sendTx every SEND_TX_INTERVAL
    const interval = eval(process.env.SEND_TX_INTERVAL)
    setInterval(()=>{
      sendTx()
    }, interval)
}
  
main();
'''
'''--- hedera-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "@hashgraph/sdk": "^2.13.1",
    "aws-sdk": "^2.1136.0",
    "axios": "^0.27.2",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.1",
    "moment": "^2.29.3",
    "parquetjs-lite": "^0.8.7"
  }
}

'''
'''--- hedera-tx-latency-measurement/sendtx_hedera.js ---
// Hedera transaction latency measurement.  
// Sending transaction using javascript sdk: https://github.com/hashgraph/hedera-sdk-js/blob/main/examples/transfer-tokens.js
// Fee Calculation: https://docs.hedera.com/guides/mainnet/fees
const fs = require('fs');
const AWS = require('aws-sdk');
const parquet = require('parquetjs-lite');
const axios = require("axios");
const moment = require('moment');
const { TransferTransaction, Client, AccountBalanceQuery, NetworkVersionInfoQuery, Status } = require ("@hashgraph/sdk");
const CoinGecko = require('coingecko-api');
const CoinGeckoClient = new CoinGecko(); 
require('dotenv').config();

//Build your Hedera client: https://docs.hedera.com/guides/docs/sdks/client
const client = process.env.NETWORK === "mainnet" ? Client.forMainnet() : Client.forTestnet(); 

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })
  
    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')
  
    var filename = `${datestring}_${data.chainId}.parquet`
  
    // create new ParquetWriter that writes to 'filename'
    var writer = await parquet.ParquetWriter.openFile(schema, filename);
  
    await writer.appendRow(data)
  
    await writer.close()
  
    return filename;
}
  
async function sendSlackMsg(msg) {
    axios.post(process.env.SLACK_API_URL, {
        'channel':process.env.SLACK_CHANNEL,
        'mrkdown':true,
        'text':msg
    }, {
        headers: {
            'Content-type':'application/json',
            'Authorization':`Bearer ${process.env.SLACK_AUTH}`
        }
    })
}
  
async function uploadToS3(data){
    if(process.env.S3_BUCKET === "") {
        throw "undefined bucket name"
    }

    const s3 = new AWS.S3();
    const filename = await makeParquetFile(data)
    const param = {
        'Bucket':process.env.S3_BUCKET,
        'Key':filename,
        'Body':fs.createReadStream(filename),
        'ContentType':'application/octet-stream'
    }
    await s3.upload(param).promise()
  
    fs.unlinkSync(filename) 
}

async function sendTx(){
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: process.env.CHAIN_ID,
        latency:0,
        error:'',
        txFee: 0.0, 
        txFeeInUSD: 0.0, 
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0 
    }
    
    try{
        const startNetworkInfo = new Date().getTime()
        await new NetworkVersionInfoQuery().execute(client); // Fee for requesting a network version info: $0.001
        const endNetworkInfo = new Date().getTime()
        data.pingTime = endNetworkInfo - startNetworkInfo

        const balance = await new AccountBalanceQuery() // Requesting an account balance is currently free: $0.000
            .setAccountId(client.operatorAccountId)
            .execute(client);
        
        const accountID = client.operatorAccountId.toString()

        if(balance.hbars.toBigNumber().toNumber() < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_HBAR))
        {
            sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/account/${accountID}|${accountID}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_HBAR} HBAR! balance=${balance.hbars.toBigNumber().toNumber()} HBAR`)
        }

        // Create and sign transaction : https://github.com/hashgraph/hedera-sdk-js/blob/main/examples/sign-transaction.js
        // The sender and recipient values must net zero.
        const transferTransaction = await new TransferTransaction()
            .addHbarTransfer(client.operatorAccountId, 10)
            .addHbarTransfer(client.operatorAccountId, -10)
            .freezeWith(client)
            .signWithOperator(client);

        const start = new Date().getTime()
        data.startTime = start
        // Execute transaction and wait until receipt is available. 
        // Fee for transaction: $0.0001
        const txResponse = await transferTransaction.execute(client) 
        const receipt = await txResponse.getReceipt(client);
        var consensusStatus = receipt.status.toString();
        if (consensusStatus == Status.Unknown.toString())
        {
            const receipt1 = await txResponse.getReceipt(client);
            consensusStatus = receipt1.status.toString();
            if (consensusStatus == Status.Unknown.toString())
            {
                const receipt2 = await txResponse.getReceipt(client);
                consensusStatus = receipt2.status.toString();
            }
        }

        if (consensusStatus != Status.Success.toString())
        {
            //throw error
            throw new Error(`Consensus status in transaction receipt is ${consensusStatus}`)
        }
        
        const end = new Date().getTime()
        data.endTime = end
        data.latency = end-start
        data.txhash = txResponse.transactionId.toString()

        const record = await txResponse.getRecord(client); // Fee for getting tx record: $0.0001
        data.txFee = record.transactionFee.toBigNumber().toNumber()

        // Calculate Transaction Fee and Get Tx Fee in USD 
        var HBARtoUSD; 
        await CoinGeckoClient.simple.price({
            ids: ["hedera-hashgraph"],
            vs_currencies: ["usd"]
        }).then((response)=>{
            HBARtoUSD = response.data["hedera-hashgraph"]["usd"]
        })
        data.txFeeInUSD = data.txFee * HBARtoUSD
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)    
    } catch(err){
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    }
    try{
        await uploadToS3(data)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))        
    }
}

async function main(){
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)

    if (process.env.PRIVATE_KEY === ""){
        console.log(`Private key is not defined.`)
        console.log(`Create a new Account on this website: https://portal.hedera.com/register`)
        console.log(`Then update ACCOUNT_ID and PRIVATE_KEY in .env file.`)
        return;
    }

    client.setOperator(process.env.ACCOUNT_ID, process.env.PRIVATE_KEY);

    // run sendTx every SEND_TX_INTERVAL
    const interval = eval(process.env.SEND_TX_INTERVAL)
    setInterval(()=>{
      sendTx()
    }, interval)
}

main();
'''
'''--- klaytn-tx-latency-measurement/package.json ---
{
  "name": "tx-latency-measurement",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "aws-sdk": "^2.1101.0",
    "axios": "^0.26.1",
    "caver-js": "^1.8.0",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.0",
    "moment": "^2.29.1",
    "parquetjs-lite": "^0.8.7"
  }
}

'''
'''--- klaytn-tx-latency-measurement/sendtx_klaytn.js ---
// Klaytn transaction latency measurement. 
// Reference of Sending Transaction using CaverJS: https://docs.kaikas.io/02_api_reference/02_caver_methods
const fs = require('fs')
const Caver = require('caver-js')
const axios = require('axios')
const path = require('path')
var parquet = require('parquetjs-lite');
const AWS = require('aws-sdk');
const moment = require('moment');
const CoinGecko = require('coingecko-api');
const CoinGeckoClient = new CoinGecko(); 

async function uploadToS3(data) {
    if(process.env.S3_BUCKET === "") {
        throw "undefined bucket name"
    }

    const s3 = new AWS.S3();
    const filename = await makeParquetFile(data)

    const param = {
        'Bucket':process.env.S3_BUCKET,
        'Key':filename,
        'Body':fs.createReadStream(filename),
        'ContentType':'application/octet-stream'
    }

    await s3.upload(param).promise()

    fs.unlinkSync(filename)
}

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })

    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')

    var filename = `${datestring}_${data.chainId}.parquet`

    // create new ParquetWriter that writes to 'fruits.parquet`
    var writer = await parquet.ParquetWriter.openFile(schema, filename);

    await writer.appendRow(data)

    await writer.close()

    return filename;
}

function loadConfig() {
    if(process.env.NODE_ENV === undefined) {
        // console.log("using .env")
        require('dotenv').config({path:path.join(__dirname,'.env')})
    } else {
        // console.log(`using .env.${process.env.NODE_ENV}`)
        require('dotenv').config({path:path.join(__dirname,`.env.${process.env.NODE_ENV}`)})
    }
}

async function sendSlackMsg(msg) {
    axios.post(process.env.SLACK_API_URL, {
        'channel':process.env.SLACK_CHANNEL,
        'mrkdown':true,
        'text':msg
    }, {
        headers: {
            'Content-type':'application/json',
            'Authorization':`Bearer ${process.env.SLACK_AUTH}`
        }
    })
}

async function checkBalance(addr) {
    const caver = new Caver(process.env.CAVER_URL)
    const balance = await caver.rpc.klay.getBalance(addr)
    const balanceInKLAY = caver.utils.convertFromPeb(balance, 'KLAY')

    if(parseFloat(balanceInKLAY) < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_KLAY)) {
        sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/account/${addr}|${addr}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_KLAY} KLAY! balance=${balanceInKLAY}`)
    }

}

async function sendTx() {
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: 0,
        latency:0,
        error:'',
        txFee: 0.0, 
        txFeeInUSD: 0.0, 
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0 
    }

    try {
        const caver = new Caver(process.env.CAVER_URL)
        const keyring = caver.wallet.keyring.createFromPrivateKey(process.env.PRIVATE_KEY)

        caver.wallet.add(keyring)

        checkBalance(keyring.address)

        // Create value transfer transaction
        const vt = caver.transaction.valueTransfer.create({
            from: keyring.address,
            to: keyring.address,
            value: 0,
            gas: 25000,
        })

        // Sign to the transaction
        const signed = await caver.wallet.sign(keyring.address, vt)
        const chainId = caver.utils.hexToNumber(signed.chainId)
        data.chainId = chainId

        // Measure latency of getBlock 
        const startGetBlockNumber = new Date().getTime()
        const latestBlockNumber = await caver.klay.getBlockNumber()
        const endGetBlockNumber = new Date().getTime()
        data.pingTime = endGetBlockNumber - startGetBlockNumber

        // Get latest block info 
        const blockInfo = await caver.klay.getBlock(latestBlockNumber)
        data.resourceUsedOfLatestBlock = caver.utils.hexToNumber(blockInfo.gasUsed)
        data.numOfTxInLatestBlock = blockInfo.transactions.length

        const start = new Date().getTime()
        data.startTime = start

        // Send transaction to the Klaytn blockchain platform (Klaytn)
        const receipt = await caver.rpc.klay.sendRawTransaction(signed)
        const end = new Date().getTime()

        data.txhash = receipt.transactionHash
        data.endTime = end
        data.latency = end-start
        
        var KLAYtoUSD;
        await CoinGeckoClient.simple.price({
            ids: ['klay-token'], 
            vs_currencies:['usd']
        }).then((response)=> {
            KLAYtoUSD = response.data['klay-token']['usd']
        })
        data.txFee = caver.utils.convertFromPeb(receipt.gasPrice, 'KLAY') * receipt.gasUsed
        data.txFeeInUSD = KLAYtoUSD * data.txFee
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    } catch (err) {
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    }
    try{
        await uploadToS3(data)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))
    }
}

async function main() {
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)

    if(process.env.PRIVATE_KEY === "") {
        const caver = new Caver(process.env.CAVER_URL)
        const keyring = caver.wallet.keyring.generate()
        console.log(`Private key is not defined. Use this new private key(${keyring.key.privateKey}).`)
        console.log(`Get test KLAY from the faucet: https://baobab.wallet.klaytn.foundation/faucet`)
        console.log(`Your Klaytn address = ${keyring.address}`)
        return
    }

    // run sendTx every 1 min.
    const interval = eval(process.env.SEND_TX_INTERVAL)
    setInterval(()=>{
        sendTx()
    }, interval)

}
loadConfig()
main()
'''
'''--- near-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "aws-sdk": "^2.1130.0",
    "axios": "^0.27.2",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.0",
    "js-sha256": "^0.9.0",
    "moment": "^2.29.3",
    "near-api-js": "^0.44.2",
    "parquetjs-lite": "^0.8.7"
  }
}

'''
'''--- near-tx-latency-measurement/sendtx_near.js ---
// Near Protocol transaction latency measurement. 
// Reference of Sending Transaction using Javascript: https://github.com/near-examples/transaction-examples/blob/master/send-tokens-deconstructed.js  & https://docs.near.org/docs/api/rpc 
const nearAPI = require('near-api-js');
const sha256 = require('js-sha256');
const AWS = require('aws-sdk');
const parquet = require('parquetjs-lite');
const moment = require('moment');
const axios = require('axios');
const CoinGecko = require('coingecko-api');
const fs = require('fs');
const CoinGeckoClient = new CoinGecko(); 
 
//this is required if using a local .env file for private key
require('dotenv').config();

// configure accounts, network, and amount of NEAR to send
// the amount is converted into yoctoNEAR (10^-24) using a near-api-js utility
const sender = process.env.SENDER_ACCOUNT_ID;
const networkId = process.env.NETWORK_ID;
const amount = nearAPI.utils.format.parseNearAmount('0.0');
var PrevNonce = null;

// sets up a NEAR API/RPC provider to interact with the blockchain
const provider = new nearAPI.providers
  .JsonRpcProvider({
      url :`https://rpc.${networkId}.near.org`,
  });

// creates keyPair used to sign transaction
var keyPair;

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })
  
    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')
  
    var filename = `${datestring}_${data.chainId}.parquet`
  
    // create new ParquetWriter that writes to 'filename'
    var writer = await parquet.ParquetWriter.openFile(schema, filename);
  
    await writer.appendRow(data)
    await writer.close()
    return filename;
}  

async function sendSlackMsg(msg) {
    axios.post(process.env.SLACK_API_URL, {
        'channel':process.env.SLACK_CHANNEL,
        'mrkdown':true,
        'text':msg
    }, {
        headers: {
            'Content-type':'application/json',
            'Authorization':`Bearer ${process.env.SLACK_AUTH}`
        }
    })
}
  
async function uploadToS3(data){
    if(process.env.S3_BUCKET === "") {
        throw "undefined bucket name"
    }

    const s3 = new AWS.S3();
    const filename = await makeParquetFile(data)
    const param = {
      'Bucket':process.env.S3_BUCKET,
      'Key':filename,
      'Body':fs.createReadStream(filename),
      'ContentType':'application/octet-stream'
    }
    await s3.upload(param).promise()

    fs.unlinkSync(filename) 
}  

async function sendTx() {
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: process.env.CHAIN_ID,
        latency:0,
        error:'',
        txFee: 0.0, 
        txFeeInUSD: 0.0, 
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0 
    }

    try {
        const accountInfo = await provider.query({
            request_type: "view_account",
            finality: "final",
            account_id: sender,
        });
        const balance = Number(accountInfo.amount) * (10**(-24))
        if(balance < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_NEAR))
        {
            sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/accounts/${sender}|${sender}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_NEAR} NEAR! balance=${balance} NEAR`)
        }

        // gets sender's public key
        const publicKey = keyPair.getPublicKey();

        // gets sender's public key information from NEAR blockchain 
        const accessKey = await provider.query(
            `access_key/${sender}/${publicKey.toString()}`, ''
        );

        // checks to make sure provided key is a full access key
        if(accessKey.permission !== 'FullAccess') {
            return console.log(
                `Account [ ${sender} ] does not have permission to send tokens using key: [ ${publicKey} ]`
            );
        }

        // each transaction requires a unique number or nonce
        // this is created by taking the current nonce and incrementing it
        const nonce = ++accessKey.nonce;
        //check nonce 
        if (nonce == PrevNonce)
        {
            // console.log(`Nonce ${nonce} = ${PrevNonce}`)
            return;
        }

        // constructs actions that will be passed to the createTransaction method below
        const actions = [nearAPI.transactions.transfer(amount)];

        // converts a recent block hash into an array of bytes 
        // this hash was retrieved earlier when creating the accessKey 
        // this is required to prove the tx was recently constructed (within 24hrs)
        const recentBlockHash = nearAPI.utils.serialize.base_decode(accessKey.block_hash);
        const startGetBlock = new Date().getTime()
        const block = await provider.sendJsonRpc(
            'block', 
            [accessKey.block_hash]
        );
        const endGetBlock = new Date().getTime()
        data.pingTime = endGetBlock - startGetBlock

        var chunkList = [] 

        block.chunks.forEach(element => {
            chunkList.push(element.chunk_hash)
            });

        // Get GasUsed and latest block 
        var gasUsed = 0
        var numTx = 0
        for (let i = 0; i < chunkList.length; i++) {
            const chunk = await provider.sendJsonRpc(
                'chunk',
                [chunkList[i]]
            )
            // console.log(chunk, chunk.header.gas_used)
            gasUsed += Number(chunk.header.gas_used)
            numTx += chunk.transactions.length
        }
        data.numOfTxInLatestBlock = numTx
        data.resourceUsedOfLatestBlock = Math.round(gasUsed * (10**(-9)))//in unit of Ggas (10**9) 
        
        // create transaction
        const transaction = nearAPI.transactions.createTransaction(
            sender, 
            publicKey, 
            sender,
            nonce,
            actions,
            recentBlockHash
        );

        // before we can sign the transaction we must perform three steps...
        // 1) serialize the transaction in Borsh
        const serializedTx = nearAPI.utils.serialize.serialize(
            nearAPI.transactions.SCHEMA, 
            transaction
        );
        // 2) hash the serialized transaction using sha256
        const serializedTxHash = new Uint8Array(sha256.sha256.array(serializedTx));
        // 3) create a signature using the hashed transaction
        const signature = keyPair.sign(serializedTxHash);

        // now we can sign the transaction :)
        const signedTransaction = new nearAPI.transactions.SignedTransaction({
            transaction,
            signature: new nearAPI.transactions.Signature({ 
                keyType: transaction.publicKey.keyType, 
                data: signature.signature 
            })
        });

        // send the transaction!
        // encodes signed transaction to serialized Borsh (required for all transactions)
        const signedSerializedTx = signedTransaction.encode();
        // start time 
        const start = new Date().getTime()
        data.startTime = start
        // sends transaction to NEAR blockchain via JSON RPC call and records the result
        const originalPrevNonce = PrevNonce
        PrevNonce = nonce
        const result = await provider.sendJsonRpc(
            'broadcast_tx_commit', 
            [Buffer.from(signedSerializedTx).toString('base64')]
        );

        if (!result.status.hasOwnProperty('SuccessValue')) {
            PrevNonce = originalPrevNonce
            throw new Error("Tx execution was not succeeded.");
        }
        const end = new Date().getTime()
        data.latency = end - start 
        data.txhash = result.transaction.hash
        data.endTime = end

        //calculate TxFee and TxFee in USD
        data.txFee = (Number(result.transaction_outcome.outcome.tokens_burnt) + Number(result.receipts_outcome[0].outcome.tokens_burnt))*(10**(-24))
        var NEARtoUSD;
        await CoinGeckoClient.simple.price({
          ids: ["near"],
          vs_currencies: ["usd"]
        }).then((response)=>{
            NEARtoUSD = response.data["near"]["usd"]
        })
        data.txFeeInUSD = data.txFee * NEARtoUSD
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    } catch(err){
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
    }
    try{
        await uploadToS3(data)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))
    }
}

async function main (){
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)

    if (process.env.SENDER_PRIVATE_KEY === "") {
        console.log(`Private key is not defined.`)
        console.log(`Create a new Account using testnet wallet: https://wallet.testnet.near.org/`)
        console.log(`Then update SENDER_ACCOUNT_ID and SENDER_PRIVATE_KEY in .env file.`)
        return
    }

    keyPair = nearAPI.utils.key_pair.KeyPairEd25519.fromString(process.env.SENDER_PRIVATE_KEY);
    
    // run sendTx every SEND_TX_INTERVAL(sec).
    const interval = eval(process.env.SEND_TX_INTERVAL)
        setInterval(()=>{
        sendTx();
    }, interval)
}
  

// run the function
main();
'''
'''--- polkadot-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "@polkadot/api": "9.2.3",
    "aws-sdk": "^2.1133.0",
    "axios": "^0.27.2",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.1",
    "moment": "^2.29.3",
    "parquetjs-lite": "^0.8.7"
  }
}

'''
'''--- polkadot-tx-latency-measurement/sendtx_polkadot.js ---
// Polkadot transaction latency measurement.
// Reference of Sending Transaction using Javascript:
// 1. Transfer Event: https://polkadot.js.org/docs/api/examples/promise/transfer-events
// 2. Transfer error handling: https://polkadot.js.org/docs/extension/cookbook/
// 3. Listen to New blocks: https://polkadot.js.org/docs/api/examples/promise/listen-to-blocks

const { ApiPromise, WsProvider } = require("@polkadot/api");
const { Keyring } = require('@polkadot/keyring');
const {
    mnemonicGenerate,
} = require('@polkadot/util-crypto');
const fs = require('fs');
const AWS = require('aws-sdk');
const parquet = require('parquetjs-lite');
const moment = require('moment');
const axios = require('axios');
const CoinGecko = require('coingecko-api');

const CoinGeckoClient = new CoinGecko();
require("dotenv").config();
var api= null;

//Construct
const wsProvider = new WsProvider(process.env.NETWORK_ENDPOINT)

async function makeParquetFile(data) {
    var schema = new parquet.ParquetSchema({
        executedAt:{type:'TIMESTAMP_MILLIS'},
        txhash:{type:'UTF8'},
        startTime:{type:'TIMESTAMP_MILLIS'},
        endTime:{type:'TIMESTAMP_MILLIS'},
        chainId:{type:'INT64'},
        latency:{type:'INT64'},
        error:{type:'UTF8'},
        txFee:{type:'DOUBLE'},
        txFeeInUSD:{type:'DOUBLE'},
        resourceUsedOfLatestBlock:{type:'INT64'},
        numOfTxInLatestBlock:{type:'INT64'},
        pingTime:{type:'INT64'}
    })

    var d = new Date()
    //20220101_032921
    var datestring = moment().format('YYYYMMDD_HHmmss')

    var filename = `${datestring}_${data.chainId}.parquet`

    // create new ParquetWriter that writes to 'filename'
    var writer = await parquet.ParquetWriter.openFile(schema, filename);

    await writer.appendRow(data)

    await writer.close()

    return filename;
}

async function sendSlackMsg(msg) {
    axios.post(process.env.SLACK_API_URL, {
        'channel':process.env.SLACK_CHANNEL,
        'mrkdown':true,
        'text':msg
    }, {
        headers: {
            'Content-type':'application/json',
            'Authorization':`Bearer ${process.env.SLACK_AUTH}`
        }
    })
}

async function uploadToS3(data){
    try{
        if(process.env.S3_BUCKET === "") {
            throw "undefined bucket name"
        }

        const s3 = new AWS.S3();
        const filename = await makeParquetFile(data)
        const param = {
        'Bucket':process.env.S3_BUCKET,
        'Key':filename,
        'Body':fs.createReadStream(filename),
        'ContentType':'application/octet-stream'
        }
        await s3.upload(param).promise()
        fs.unlinkSync(filename)
    } catch(err){
        console.log('failed to s3.upload! Printing instead!', err.toString())
        console.log(JSON.stringify(data))
    }
}

async function sendTx(){
    var data = {
        executedAt: new Date().getTime(),
        txhash: '',
        startTime: 0,
        endTime: 0,
        chainId: process.env.CHAIN_ID,
        latency:0,
        error:'',
        txFee: 0.0,
        txFeeInUSD: 0.0,
        resourceUsedOfLatestBlock: 0,
        numOfTxInLatestBlock: 0,
        pingTime:0
    }

    try{
        const keyring = new Keyring({type: 'sr25519'});
        const sender = keyring.addFromMnemonic(process.env.SENDER_MNEMONIC);
        const senderAddress = sender.toJson().address;
        const accountInfo  = await api.query.system.account(senderAddress);
        //Mainnet: (10**(-10)) since Denomination day, Testnet WestEnd: (10**(-12))
        const decimal = process.env.NETWORK_ENDPOINT.includes('westend') ? (10**(-12)): (10**(-10));
        const balance = Number(accountInfo.toJSON().data.free) * decimal

        if(balance < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_DOT))
        {
            sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/account/${senderAddress}|${senderAddress}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_DOT} DOT! balance=${balance} DOT`)
        }

        const startGetBlock = new Date().getTime()
        const unsubscribe = await api.rpc.chain.getFinalizedHead(async (header)=>{
            const endGetBlock = new Date().getTime();
            const latestBlockHash = header.toJSON();
            data.pingTime = endGetBlock - startGetBlock;
            unsubscribe();

            // Calculate the number of transactions and resource used in the latest block.
            const unsubscribeLatestBlockInfo = await api.rpc.chain.getBlock(latestBlockHash, async(latestBlockInfo)=>{
                const transactions = latestBlockInfo.toJSON().block.extrinsics;
                unsubscribeLatestBlockInfo();
                data.numOfTxInLatestBlock = transactions.length;
                var weightUsed = 0
                for await (const tx of transactions)
                {
                    const paymentInfo = await api.call.transactionPaymentApi.queryInfo(tx, 1)
                    weightUsed += Number(paymentInfo.toJSON().weight)
                }
                data.resourceUsedOfLatestBlock = Math.round(weightUsed * (10**(-9)))

                // Create value transfer transaction.
                const transfer = api.tx.balances.transfer(senderAddress, 0);

                // Sign transaction.
                await transfer.signAsync(sender);

                // Send Transaction and wait until the transaction is in block.
                const start = new Date().getTime()
                data.startTime = start
                const unsubscribeTransactionSend = await transfer.send(async (result) => {
                    if(result.isInBlock)
                    {
                        unsubscribeTransactionSend();
                        const end = new Date().getTime()
                        data.endTime = end
                        data.latency = end-start
                        data.txhash = '0x' + Buffer.from(result.txHash).toString('hex')

                        //Calculate tx using BlockHash and txIndex
                        const unsubBlockInfo = await api.rpc.chain.getBlock(result.toHuman().status.InBlock, async (blockInfo)=>{
                            unsubBlockInfo();
                            const feeDetails = await api.rpc.payment.queryFeeDetails(blockInfo.toJSON().block.extrinsics[result.txIndex]); //parameter is BlockHash
                            const inclusionFee = feeDetails.toJSON().inclusionFee;
                            data.txFee = (inclusionFee.baseFee + inclusionFee.lenFee + inclusionFee.adjustedWeightFee)*decimal

                            //Calculate txFee in USD
                            var DOTtoUSD;
                            await CoinGeckoClient.simple.price({
                                ids: ["polkadot"],
                                vs_currencies: ["usd"]
                            }).then((response)=>{
                                DOTtoUSD = response.data["polkadot"]["usd"]
                            })
                            data.txFeeInUSD = data.txFee * DOTtoUSD
                            console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
                            await uploadToS3(data);
                        });
                    }
                })
            });
        });
    } catch(err){
        console.log("failed to execute.", err.toString())
        data.error = err.toString()
        console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
        uploadToS3(data)
    }
}

async function main(){
    const start = new Date().getTime()
    console.log(`starting tx latency measurement... start time = ${start}`)
    api = await ApiPromise.create({provider: wsProvider});

    if (process.env.SENDER_MNEMONIC === ""){
        const newMnemonic = mnemonicGenerate();
        const keyring = new Keyring({type: 'sr25519'});
        const address = keyring.addFromMnemonic(newMnemonic).toJson().address;
        console.log(`MNEMONIC is undefined. Use this new MNEMONIC: ${newMnemonic}`)
        console.log(`Get test DOT from the faucet: https://matrix.to/#/!cJFtAIkwxuofiSYkPN:matrix.org?via=matrix.org&via=matrix.parity.io&via=web3.foundation`)
        console.log(`Your Polkadot address = ${address}`)
        console.log(`To exit, press Ctrl+C.`)
        return;
    }

    // run sendTx every SEND_TX_INTERVAL
    const interval = eval(process.env.SEND_TX_INTERVAL)
    setInterval(()=>{
        sendTx()
    }, interval)
}

main();
'''
'''--- polygon-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "aws-sdk": "^2.1114.0",
    "axios": "^0.26.1",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.0",
    "moment": "^2.29.2",
    "parquetjs-lite": "^0.8.7",
    "web3": "^1.7.3"
  }
}

'''
'''--- polygon-tx-latency-measurement/sendtx_polygon.js ---
// Polygon PoS transaction latency measurement. 
// Reference of Sending Transaction using Javascript: https://docs.polygon.technology/docs/develop/eip1559-transactions/how-to-send-eip1559-transactions/ 
const Web3 = require('web3')
const fs = require('fs')
const AWS = require('aws-sdk')
const parquet = require('parquetjs-lite')
const moment = require('moment');
const axios = require('axios');
const CoinGecko = require('coingecko-api');
require("dotenv").config();

let rpc = process.env.PUBLIC_RPC_URL;
const provider = new Web3.providers.HttpProvider(rpc);
const web3 = new Web3(provider);
const CoinGeckoClient = new CoinGecko();

const privateKey = process.env.SIGNER_PRIVATE_KEY;
var PrevNonce = null; 

async function makeParquetFile(data) {
  var schema = new parquet.ParquetSchema({
      executedAt:{type:'TIMESTAMP_MILLIS'},
      txhash:{type:'UTF8'},
      startTime:{type:'TIMESTAMP_MILLIS'},
      endTime:{type:'TIMESTAMP_MILLIS'},
      chainId:{type:'INT64'},
      latency:{type:'INT64'},
      error:{type:'UTF8'},
      txFee:{type:'DOUBLE'},
      txFeeInUSD:{type:'DOUBLE'},
      resourceUsedOfLatestBlock:{type:'INT64'},
      numOfTxInLatestBlock:{type:'INT64'},
      pingTime:{type:'INT64'}
  })

  var d = new Date()
  //20220101_032921
  var datestring = moment().format('YYYYMMDD_HHmmss')

  var filename = `${datestring}_${data.chainId}.parquet`

  // create new ParquetWriter that writes to 'filename'
  var writer = await parquet.ParquetWriter.openFile(schema, filename);

  await writer.appendRow(data)

  await writer.close()

  return filename;
}

async function sendSlackMsg(msg) {
  axios.post(process.env.SLACK_API_URL, {
      'channel':process.env.SLACK_CHANNEL,
      'mrkdown':true,
      'text':msg
  }, {
      headers: {
          'Content-type':'application/json',
          'Authorization':`Bearer ${process.env.SLACK_AUTH}`
      }
  })
}

async function uploadToS3(data){
  if(process.env.S3_BUCKET === "") {
    throw "undefined bucket name"
  }

  const s3 = new AWS.S3();
  const filename = await makeParquetFile(data)

  const param = {
    'Bucket':process.env.S3_BUCKET,
    'Key':filename,
    'Body':fs.createReadStream(filename),
    'ContentType':'application/octet-stream'
  }

  await s3.upload(param).promise()

  fs.unlinkSync(filename) 
}

async function sendTx(){
  var data = {
    executedAt: new Date().getTime(),
    txhash: '',
    startTime: 0,
    endTime: 0,
    chainId: 0,
    latency:0,
    error:'',
    txFee: 0.0, 
    txFeeInUSD: 0.0, 
    resourceUsedOfLatestBlock: 0,
    numOfTxInLatestBlock: 0,
    pingTime:0 
  }

  try{    
    // Add your private key 
    const signer = web3.eth.accounts.privateKeyToAccount(
      privateKey
    );
    const balance = await web3.eth.getBalance(signer.address); //in wei  

    if(balance*(10**(-18)) < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_MATIC))
    { 
      sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/address/${signer.address}|${signer.address}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_MATIC} MATIC! balance=${balance*(10**(-18))} MATIC`)
    }

    const latestNonce = await web3.eth.getTransactionCount(signer.address)
    if (latestNonce == PrevNonce) 
    {
      // console.log(`Nonce ${latestNonce} = ${PrevNonce}`)
      return;
    }

    const startGetBlock = new Date().getTime()
    const latestBlockNumber = await web3.eth.getBlockNumber();
    const endGetBlock = new Date().getTime()
    data.pingTime = endGetBlock - startGetBlock

    await web3.eth.getBlock(latestBlockNumber).then((result)=>{
      data.resourceUsedOfLatestBlock = result.gasUsed
      data.numOfTxInLatestBlock = result.transactions.length
    })

    // Option 1. Use gasstation https://docs.polygon.technology/docs/develop/tools/polygon-gas-station/ 
    const gasStationResult = await axios.get(process.env.GAS_STATION_URL, {
      headers:{
        "Content-Type": "application/json"
      }
    })
    const maxPriorityFeePerGas = web3.utils.toHex(Math.round(gasStationResult.data.standard.maxPriorityFee * 1e9))
    const maxFeePerGas = web3.utils.toHex(Math.round(gasStationResult.data.standard.maxFee * 1e9))

    // Option 2. Calculate maxPriorityFeePerGas based on Fee History 
    // https://web3js.readthedocs.io/en/v1.5.0/web3-eth.html#getfeehistory
    // await web3.eth.getFeeHistory(10, "latest", [50]).then((result)=>{
    //   baseFee = Number(result.baseFeePerGas[3])// expected base Fee value (in wei)
    //   var sum = 0
    //   result.reward.forEach(element => {
    //     sum += Number(element[0])
    //   });
    //   sum /= 10 
    //   maxPriorityFeePerGas = web3.utils.toHex(Math.round(sum).toString())//in wei 
    // });

    //create value transfer transaction (EIP-1559) 
    const tx = {
      type: 2,
      nonce: latestNonce,
      from: signer.address,
      to:  signer.address,
      value: web3.utils.toHex(web3.utils.toWei("0", "ether")),
      gas: 21000,
      maxPriorityFeePerGas, // 2.5 Gwei is a default 
      maxFeePerGas // default maxFeePerGas = (2 * block.baseFeePerGas) + maxPriorityFeePerGas 
    }

    //Sign to the transaction
    var RLPEncodedTx;
    await web3.eth.accounts.signTransaction(tx, privateKey)
    .then((result) => {
      RLPEncodedTx = result.rawTransaction // RLP encoded transaction & already HEX value
      data.txhash = result.transactionHash // the transaction hash of the RLP encoded transaction.
    });
 
    await web3.eth.net.getId().then((result)=>{
      data.chainId = result 
    })
    const start = new Date().getTime()
    data.startTime = start 

    const originalPrevNonce = PrevNonce

    // Send signed transaction
    await web3.eth
    .sendSignedTransaction(RLPEncodedTx) // Signed transaction data in HEX format 
    .on('sent', function(){
      PrevNonce = latestNonce
    })
    .on('receipt', function(receipt){
      data.txhash = receipt.transactionHash
      const end = new Date().getTime()
      data.endTime = end
      data.latency = end-start
      data.txFee = receipt.gasUsed * web3.utils.fromWei(receipt.effectiveGasPrice.toString())
    })
    .on('error', function(err){
      PrevNonce = originalPrevNonce
    })

    // Calculate Transaction Fee and Get Tx Fee in USD 
    var MATICtoUSD;
    await CoinGeckoClient.simple.price({
      ids: ["matic-network"],
      vs_currencies: ["usd"]
    }).then((response)=>{
      MATICtoUSD = response.data["matic-network"]["usd"]
    })
    data.txFeeInUSD = data.txFee * MATICtoUSD 

    // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
  } catch(err){
    console.log("failed to execute.", err.toString())
    data.error = err.toString()
    // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
  }
  try{
    await uploadToS3(data)
  } catch(err){
    console.log('failed to s3.upload! Printing instead!', err.toString())
    console.log(JSON.stringify(data))
  }
}

async function main(){
  const start = new Date().getTime()
  console.log(`starting tx latency measurement... start time = ${start}`)
  
  if(privateKey === "") {
    const account = web3.eth.accounts.create(web3.utils.randomHex(32));
    console.log(`Private key is not defined. Use this new private key(${account.privateKey}).`)
    console.log(`Get test MATIC from the faucet: https://faucet.polygon.technology/`)
    console.log(`Your Polygon address = ${account.address}`)
    return
  }

  // run sendTx every SEND_TX_INTERVAL
  const interval = eval(process.env.SEND_TX_INTERVAL)
  setInterval(()=>{
    sendTx()
  }, interval)

}

main();
'''
'''--- solana-tx-latency-measurement/package.json ---
{
  "dependencies": {
    "@solana/web3.js": "^1.39.1",
    "aws-sdk": "^2.1116.0",
    "axios": "^0.27.2",
    "base-58": "^0.0.1",
    "coingecko-api": "^1.0.10",
    "dotenv": "^16.0.0",
    "moment": "^2.29.3",
    "parquetjs-lite": "^0.8.7"
  }
}

'''
'''--- solana-tx-latency-measurement/sendtx_solana.js ---
// Solana transaction latency measurement. 
// Reference of Sending Transaction using SolanaJS: https://docs.solana.com/developing/clients/javascript-api 
const web3 = require("@solana/web3.js");
const Base58 = require('base-58');
const parquet = require('parquetjs-lite');
const moment = require('moment');
const AWS = require('aws-sdk');
const fs = require('fs');
const axios = require('axios');
const CoinGecko = require('coingecko-api');
const CoinGeckoClient = new CoinGecko();

require('dotenv').config();
var keypair = ""
const connection = new web3.Connection(web3.clusterApiUrl(process.env.CLUSTER_NAME), 'confirmed'); //To use mainnet, use 'mainnet-beta'

async function makeParquetFile(data) {
  var schema = new parquet.ParquetSchema({
      executedAt:{type:'TIMESTAMP_MILLIS'},
      txhash:{type:'UTF8'},
      startTime:{type:'TIMESTAMP_MILLIS'},
      endTime:{type:'TIMESTAMP_MILLIS'},
      chainId:{type:'INT64'},
      latency:{type:'INT64'},
      error:{type:'UTF8'},
      txFee:{type:'DOUBLE'},
      txFeeInUSD:{type:'DOUBLE'},
      resourceUsedOfLatestBlock:{type:'INT64'},
      numOfTxInLatestBlock:{type:'INT64'},
      pingTime:{type:'INT64'}
  })

  var d = new Date()
  //20220101_032921
  var datestring = moment().format('YYYYMMDD_HHmmss')

  var filename = `${datestring}_${data.chainId}.parquet`

  // create new ParquetWriter that writes to 'filename'
  var writer = await parquet.ParquetWriter.openFile(schema, filename);

  await writer.appendRow(data)

  await writer.close()

  return filename;
}

async function uploadToS3(data){
  if(process.env.S3_BUCKET === "") {
    throw "undefind bucket name."
  }
  const s3 = new AWS.S3();
  const filename = await makeParquetFile(data)
  const param = {
    'Bucket':process.env.S3_BUCKET,
    'Key':filename,
    'Body':fs.createReadStream(filename),
    'ContentType':'application/octet-stream'
  }
  await s3.upload(param).promise()
  fs.unlinkSync(filename) 
}

async function sendSlackMsg(msg) {
  axios.post(process.env.SLACK_API_URL, {
      'channel':process.env.SLACK_CHANNEL,
      'mrkdown':true,
      'text':msg
  }, {
      headers: {
          'Content-type':'application/json',
          'Authorization':`Bearer ${process.env.SLACK_AUTH}`
      }
  })
}

async function sendZeroSol(){
  var data = {
    executedAt: new Date().getTime(),
    txhash: '', // Solana has no txHash. Instead, it uses tx signature. 
    startTime: 0,
    endTime: 0,
    chainId: process.env.CHAIN_ID, //Solana has no chainId. 
    latency:0,
    error:'',
    txFee: 0.0, 
    txFeeInUSD: 0.0, 
    resourceUsedOfLatestBlock: 0,
    numOfTxInLatestBlock: 0,
    pingTime:0
  } 

  try{
    //check balance 
    const balance = await connection.getBalance(keypair.publicKey)
    if(balance*(10**(-9)) < parseFloat(process.env.BALANCE_ALERT_CONDITION_IN_SOL))
    { 
      sendSlackMsg(`Current balance of <${process.env.SCOPE_URL}/address/${keypair.publicKey}?cluster=${process.env.CLUSTER_NAME}|${keypair.publicKey}> is less than ${process.env.BALANCE_ALERT_CONDITION_IN_SOL} SOL! balance=${balance*(10**(-9))} SOL`)
    }
  
    const startGetBlockHash = new Date().getTime();
    var blockhash;
    await connection.getLatestBlockhashAndContext().then(async (result)=>{
      // Measure Latency for getLatestBlock
      const endGetBlockHash = new Date().getTime()
      data.pingTime = endGetBlockHash - startGetBlockHash; 
      blockhash = result.value.blockhash
      // Get the number of processed transactions 
      await connection.getBlock(result.context.slot).then((response)=>{
        data.numOfTxInLatestBlock = response.transactions.length
      });
      // Get the number of Singatures in the block 
      await connection.getBlockSignatures(result.context.slot).then((res)=>{
        data.resourceUsedOfLatestBlock = res.signatures.length
      })
    })

    const instruction = web3.SystemProgram.transfer({
      fromPubkey: keypair.publicKey,
      toPubkey: keypair.publicKey, 
      lamports: 0, 
    });

    const tx = new web3.Transaction({
      recentBlockhash: blockhash,
      feePayer: keypair.publicKey
    }).add(instruction);
    tx.sign(keypair)

    // Write starttime 
    const start = new Date().getTime()
    data.startTime = start

    // Send signed transaction and wait til confirmation
    const signature = await web3.sendAndConfirmRawTransaction(
      connection,
      tx.serialize(), // tx serialized in wire format 
    )

    // Calc latency 
    const end = new Date().getTime()
    data.endTime = end
    data.latency = end-start
    data.txhash = signature // same with base58.encode(tx.signature)

    var SOLtoUSD;
    await CoinGeckoClient.simple.price({
      ids: ['solana'],
      vs_currencies: ['usd']
    }).then((response)=>{
      SOLtoUSD = response.data['solana']['usd']
    })

    const response = await connection.getFeeForMessage(
      tx.compileMessage(),
      'confirmed',
    );
    const feeInLamports = response.value;

    data.txFee = feeInLamports * 10**(-9)
    data.txFeeInUSD = SOLtoUSD * data.txFee
    // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
  } catch(err){
    console.log("failed to execute.", err.toString())
    data.error = err.toString()
    // console.log(`${data.executedAt},${data.chainId},${data.txhash},${data.startTime},${data.endTime},${data.latency},${data.txFee},${data.txFeeInUSD},${data.resourceUsedOfLatestBlock},${data.numOfTxInLatestBlock},${data.pingTime},${data.error}`)
  }
  try{
    await uploadToS3(data)
  } catch(err){
    console.log('failed to s3.upload! Printing instead!', err.toString())
    console.log(JSON.stringify(data))
  }
}

async function main (){
  const start = new Date().getTime()
  console.log(`starting tx latency measurement... start time = ${start}`)
  var privKey = process.env.SIGNER_PRIVATE_KEY
  if(privKey === "") {
    let account = web3.Keypair.generate();
    privKey = Base58.encode(account.secretKey)
    console.log(`Private key is not defined. Use this new private key(${privKey}).`)
    console.log(`Get test sol from the faucet: https://solfaucet.com/)`)
    console.log(`Your Solana address = ${account.publicKey.toBase58()}`)
    return
  }
  keypair = web3.Keypair.fromSecretKey(Base58.decode(privKey)); //Base58 encoded private key (64 byte)-> generate keypair

  // run sendTx every SEND_TX_INTERVAL(sec).
  const interval = eval(process.env.SEND_TX_INTERVAL)
      setInterval(()=>{
      sendZeroSol();
  }, interval)
}

main();
'''