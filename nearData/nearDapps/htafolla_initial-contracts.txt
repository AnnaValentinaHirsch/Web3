*GitHub Repository "htafolla/initial-contracts"*

'''--- README.md ---
# Initial contracts

*In the process of refactoring to add more contracts here*

- [Staking Pool / Delegation contract](./staking-pool/)
- [[WIP] Lockup / Vesting contract](./lockup/)

'''
'''--- lockup/Cargo.toml ---
[package]
name = "lockup-contract"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "*", features = ["derive"] }
serde_json = "*"
near-sdk = "0.9.2"
borsh = "*"
uint = { version = "0.8.2", default-features = false }
wee_alloc = { version = "0.4.5", default-features = false, features = [] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- lockup/README.md ---
# Lockup / Vesting contract

*Work in progress.*

'''
'''--- lockup/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/lockup_contract.wasm res/

'''
'''--- lockup/src/lib.rs ---
//! A smart contract that allows tokens lockup.

use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base58PublicKey, U128, U64};
use near_sdk::{env, ext_contract, near_bindgen, AccountId, Promise, PromiseResult};
use serde::{Deserialize, Serialize};
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

pub type WrappedTimestamp = U64;
pub type WrappedBalance = U128;

pub type ProposalId = u64;
pub type VoteIndex = u64;

/// Method names allowed for the owner's access keys.
const OWNER_KEY_ALLOWED_METHODS: &[u8] =
    b"vote,select_staking_pool,unselect_staking_pool,deposit_to_staking_pool,withdraw_from_staking_pool,stake,unstake,check_transfers_vote,transfer";
/// Method names allowed for the NEAR Foundation access key in case of vesting schedule that
/// can be terminated by foundation.
const FOUNDATION_KEY_ALLOWED_METHODS: &[u8] =
    b"terminate_vesting,resolve_deficit,withdraw_unvested_amount";

/// Indicates there are no deposit for a cross contract call for better readability.
const NO_DEPOSIT: u128 = 0;

/// The contract keeps at least 30 NEAR in the account to avoid being transferred out to cover
/// contract code storage and some internal state.
const MIN_BALANCE_FOR_STORAGE: u128 = 30_000_000_000_000_000_000_000_000;

pub mod gas {
    pub mod whitelist {
        /// Gas attached to the promise to check whether the given staking pool Account ID is
        /// whitelisted.
        /// Requires 100e12 (no external calls).
        pub const IS_WHITELISTED: u64 = 100_000_000_000_000;
    }

    pub mod staking_pool {
        /// The amount of gas required for a voting through a staking pool.
        /// Requires 100e12 for execution + 200e12 for attaching to a call on the voting contract.
        pub const VOTE: u64 = 300_000_000_000_000;

        /// The amount of gas required to get total user balance from the staking pool.
        /// Requires 100e12 for local processing.
        pub const GET_TOTAL_USER_BALANCE: u64 = 100_000_000_000_000;

        /// Gas attached to deposit call on the staking pool contract.
        /// Requires 100e12 for local updates.
        pub const DEPOSIT: u64 = 100_000_000_000_000;

        /// Gas attached to withdraw call on the staking pool contract.
        /// Requires 100e12 for execution + 200e12 for transferring amount to us.
        pub const WITHDRAW: u64 = 300_000_000_000_000;

        /// Gas attached to stake call on the staking pool contract.
        /// Requires 100e12 for execution + 200e12 for staking call.
        pub const STAKE: u64 = 300_000_000_000_000;

        /// Gas attached to unstake call on the staking pool contract.
        /// Requires 100e12 for execution + 200e12 for staking call.
        pub const UNSTAKE: u64 = 300_000_000_000_000;
    }

    pub mod voting {
        /// Gas attached to the promise to check whether transfers were enabled on the voting
        /// contract.
        /// Requires 100e12 (no external calls).
        pub const GET_RESULT: u64 = 100_000_000_000_000;
    }

    pub mod callbacks {
        /// Gas attached to the inner callback for processing whitelist check results.
        /// Requires 100e12 for local execution.
        pub const ON_WHITELIST_IS_WHITELISTED: u64 = 100_000_000_000_000;

        /// Gas attached to the inner callback for processing result of the call to get balance on
        /// the staking pool balance.
        /// Requires 100e12 for local updates.
        pub const ON_STAKING_POOL_GET_TOTAL_USER_BALANCE: u64 = 100_000_000_000_000;

        /// Gas attached to the inner callback for processing result of the deposit call to the
        /// staking pool.
        /// Requires 100e12 for local updates.
        pub const ON_STAKING_POOL_DEPOSIT: u64 = 100_000_000_000_000;

        /// Gas attached to the inner callback for processing result of the withdraw call to the
        /// staking pool.
        /// Requires 100e12 for local updates.
        pub const ON_STAKING_POOL_WITHDRAW: u64 = 100_000_000_000_000;

        /// Gas attached to the inner callback for processing result of the stake call to the
        /// staking pool.
        pub const ON_STAKING_POOL_STAKE: u64 = 100_000_000_000_000;

        /// Gas attached to the inner callback for processing result of the unstake call  to the
        /// staking pool.
        /// Requires 100e12 for local updates.
        pub const ON_STAKING_POOL_UNSTAKE: u64 = 100_000_000_000_000;

        /// Gas attached to the inner callback for processing result of the checking result for
        /// transfer voting call to the voting contract.
        /// Requires 100e12 for local updates.
        pub const ON_VOTING_GET_RESULT: u64 = 100_000_000_000_000;

        /// Gas attached to the inner callback for processing result of the withdrawal of the
        /// terminated unvested balance.
        /// Requires 100e12 for local updates.
        pub const ON_WITHDRAW_UNVESTED_AMOUNT: u64 = 100_000_000_000_000;
    }
}

/// Contains information about token lockups.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
pub struct LockupInformation {
    /// The amount in yacto-NEAR tokens locked for this account.
    pub lockup_amount: WrappedBalance,
    /// The timestamp in nanoseconds when the lockup amount of tokens will be available.
    pub lockup_timestamp: WrappedTimestamp,

    /// Information about vesting if the lockup schedule includes vesting.
    /// `Some` means there is vesting information available.
    /// `None` means the lockup balance is unaffected by vesting.
    pub vesting_information: Option<VestingInformation>,
}

impl LockupInformation {
    pub fn assert_valid(&self) {
        assert!(
            self.lockup_amount.0 > 0,
            "Lockup amount has to be positive number"
        );
        match &self.vesting_information {
            Some(VestingInformation::Vesting(vesting_schedule)) => vesting_schedule.assert_valid(),
            Some(VestingInformation::Terminating(_termination_information)) => {
                panic!("The contract should not be initialized in termination stage")
            }
            None => (),
        };
    }
}

/// Describes the status of transactions with the staking pool contract or terminated unvesting
/// amount withdrawal.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq)]
pub enum TransactionStatus {
    /// There are no transactions in progress.
    Idle,
    /// There is a transaction in progress.
    Busy,
}

/// Contains information about current stake and delegation.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingInformation {
    /// The Account ID of the staking pool contract.
    pub staking_pool_account_id: AccountId,

    /// Contains status whether there is a transaction in progress.
    pub status: TransactionStatus,

    /// The minimum amount of tokens that were deposited from this account to the staking pool.
    /// The actual amount might be higher due to stake rewards. This contract can't track stake
    /// rewards on the staking pool reliably without querying it.
    pub deposit_amount: WrappedBalance,

    /// The minimum amount of tokens that were staked on the staking pool.
    /// The actual amount might be higher due to stake rewards. This contract can't track stake
    /// rewards on the staking pool reliably without querying it.
    pub stake_amount: WrappedBalance,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
pub struct VestingSchedule {
    /// The timestamp in nanosecond when the vesting starts. E.g. the start date of employment.
    pub start_timestamp: WrappedTimestamp,
    /// The timestamp in nanosecond when the first part of lockup tokens becomes vested.
    /// The remaining tokens will vest continuously until they are fully vested.
    /// Example: a 1 year of employment at which moment the 1/4 of tokens become vested.
    pub cliff_timestamp: WrappedTimestamp,
    /// The timestamp in nanosecond when the vesting ends.
    pub end_timestamp: WrappedTimestamp,
}

impl VestingSchedule {
    pub fn assert_valid(&self) {
        assert!(
            self.start_timestamp.0 <= self.cliff_timestamp.0,
            "Cliff timestamp can't be earlier than vesting start timestamp"
        );
        assert!(
            self.cliff_timestamp.0 <= self.end_timestamp.0,
            "Cliff timestamp can't be later than vesting end timestamp"
        );
        assert!(
            self.start_timestamp.0 < self.end_timestamp.0,
            "The total vesting time should be positive"
        );
    }
}

/// Contains information about vesting for contracts that contain vesting schedule and termination information.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
pub enum VestingInformation {
    /// The vesting is going on schedule.
    /// Once the vesting is completed `VestingInformation` is removed.
    Vesting(VestingSchedule),
    /// The information about the early termination of the vesting schedule.
    /// It means the termination of the vesting is currently in progress.
    /// Once the unvested amount is transferred out, `VestingInformation` is removed.
    Terminating(TerminationInformation),
}

/// Contains information about early termination of the vesting schedule.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
pub struct TerminationInformation {
    /// The amount of tokens that are unvested and has to be transferred back to NEAR Foundation.
    /// These tokens are effectively locked and can't be transferred out and can't be restaked.
    pub unvested_amount: WrappedBalance,

    /// The status of the withdrawal. When the unvested amount is in progress of withdrawal the
    /// status will be marked as busy, to avoid withdrawing the funds twice.
    pub status: TransactionStatus,
}

/// Contains information about voting on enabling transfers.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
pub struct TransferVotingInformation {
    /// The proposal ID to vote on transfers.
    pub transfer_proposal_id: ProposalId,

    /// Vote index indicating that the transfers are enabled.
    pub enable_transfers_vote_index: VoteIndex,

    /// Voting contract account ID
    pub voting_contract_account_id: AccountId,
}

impl TransferVotingInformation {
    pub fn assert_valid(&self) {
        assert!(
            env::is_valid_account_id(self.voting_contract_account_id.as_bytes()),
            "Voting contract account ID is invalid"
        );
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LockupContract {
    /// Information about lockup schedule and the amount.
    pub lockup_information: LockupInformation,

    /// Account ID of the staking pool whitelist contract.
    pub staking_pool_whitelist_account_id: AccountId,

    /// Information about staking and delegation.
    /// `Some` means the staking information is available and the staking pool contract is selected.
    /// `None` means there is no staking pool selected.
    pub staking_information: Option<StakingInformation>,

    /// Information about transfer voting. At the launch transfers are disabled, once transfers are
    /// enabled, they can't be disabled and don't need to be checked again.
    /// `Some` means transfers are disabled. `TransferVotingInformation` contains information
    /// required to check whether transfers were voted to be enabled.
    /// If transfers are disabled, every transfer attempt will try to first pull the results
    /// of transfer voting from the voting contract using transfer proposal ID.
    pub transfer_voting_information: Option<TransferVotingInformation>,
}

impl Default for LockupContract {
    fn default() -> Self {
        env::panic(b"The contract is not initialized.");
    }
}

fn assert_self() {
    assert_eq!(env::predecessor_account_id(), env::current_account_id());
}

fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}

#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    fn vote(&mut self, proposal_id: ProposalId, vote: VoteIndex);

    fn get_total_user_balance(&self, account_id: AccountId) -> WrappedBalance;

    fn deposit(&mut self);

    fn withdraw(&mut self, amount: WrappedBalance);

    fn stake(&mut self, amount: WrappedBalance);

    fn unstake(&mut self, amount: WrappedBalance);
}

#[ext_contract(ext_whitelist)]
pub trait ExtStakingPoolWhitelist {
    fn is_whitelisted(&self, staking_pool_account_id: AccountId) -> bool;
}

#[ext_contract(ext_voting)]
pub trait ExtVotingContract {
    fn get_result(&self, proposal_id: ProposalId) -> Option<VoteIndex>;
}

#[ext_contract(ext_self)]
pub trait ExtLockupContract {
    fn on_whitelist_is_whitelisted(
        &mut self,
        #[callback] is_whitelisted: bool,
        staking_pool_account_id: AccountId,
    ) -> bool;

    fn on_staking_pool_get_total_user_balance(
        &mut self,
        #[callback] total_balance: WrappedBalance,
    ) -> bool;

    fn on_staking_pool_deposit(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_withdraw(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_stake(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_unstake(&mut self, amount: WrappedBalance) -> bool;

    fn on_voting_get_result(&mut self, #[callback] vote_index: Option<VoteIndex>) -> bool;

    fn on_withdraw_unvested_amount(
        &mut self,
        amount: WrappedBalance,
        receiver_id: AccountId,
    ) -> bool;
}

#[near_bindgen]
impl LockupContract {
    /// Initializes lockup contract.
    /// - `lockup_information` - information about the lockup amount and the release timestamp.
    /// - `staking_pool_whitelist_account_id` - the Account ID of the staking pool whitelist contract.
    /// - `vesting_schedule` - if `Some` contains vesting schedule.
    /// - `transfer_voting_information` - if `Some` means transfers are disabled and can only be
    ///   enabled by voting on the proposal.
    /// - `owner_public_keys`
    #[init]
    pub fn new(
        lockup_information: LockupInformation,
        staking_pool_whitelist_account_id: AccountId,
        transfer_voting_information: Option<TransferVotingInformation>,
        owner_public_keys: Vec<Base58PublicKey>,
        foundation_public_keys: Vec<Base58PublicKey>,
    ) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        assert!(
            env::is_valid_account_id(staking_pool_whitelist_account_id.as_bytes()),
            "The staking pool whitelist account ID is invalid"
        );
        lockup_information.assert_valid();
        if !foundation_public_keys.is_empty() {
            assert!(
                lockup_information.vesting_information.is_some(),
                "Foundation keys can't be added without vesting schedule"
            )
        }
        assert!(
            !owner_public_keys.is_empty(),
            "At least one owner's public key has to be provided"
        );
        if let Some(transfer_voting_information) = transfer_voting_information.as_ref() {
            transfer_voting_information.assert_valid();
        }
        let account_id = env::current_account_id();
        for public_key in owner_public_keys {
            Promise::new(account_id.clone()).add_access_key(
                public_key.into(),
                0,
                account_id.clone(),
                OWNER_KEY_ALLOWED_METHODS.to_vec(),
            );
        }
        for public_key in foundation_public_keys {
            Promise::new(account_id.clone()).add_access_key(
                public_key.into(),
                0,
                account_id.clone(),
                FOUNDATION_KEY_ALLOWED_METHODS.to_vec(),
            );
        }
        Self {
            lockup_information,
            staking_information: None,
            staking_pool_whitelist_account_id,
            transfer_voting_information,
        }
    }

    /*******************/
    /* Owner's Methods */
    /*******************/

    /// OWNER'S METHOD
    /// Vote on given proposal ID with a selected vote index.
    /// The owner has to first delegate the stake to some staking pool contract before voting on
    /// a proposal.
    pub fn vote(&mut self, proposal_id: ProposalId, vote: VoteIndex) -> Promise {
        assert_self();
        self.assert_staking_pool_is_idle();
        env::log(format!("Voting for proposal {} with vote {}", proposal_id, vote).as_bytes());
        ext_staking_pool::vote(
            proposal_id,
            vote,
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::VOTE,
        )
    }

    /// OWNER'S METHOD
    /// Selects staking pool contract at the given account ID. The staking pool first has to be
    /// checked against the staking pool whitelist contract.
    pub fn select_staking_pool(&mut self, staking_pool_account_id: AccountId) -> Promise {
        assert_self();
        assert!(
            env::is_valid_account_id(staking_pool_account_id.as_bytes()),
            "The staking pool account ID is invalid"
        );
        self.assert_staking_pool_is_not_selected();

        env::log(
            format!(
                "Selecting staking pool @{}. Going to check whitelist first.",
                staking_pool_account_id
            )
            .as_bytes(),
        );

        ext_whitelist::is_whitelisted(
            staking_pool_account_id.clone(),
            &self.staking_pool_whitelist_account_id,
            NO_DEPOSIT,
            gas::whitelist::IS_WHITELISTED,
        )
        .then(ext_self::on_whitelist_is_whitelisted(
            staking_pool_account_id,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::callbacks::ON_WHITELIST_IS_WHITELISTED,
        ))
    }

    /// OWNER'S METHOD
    /// Tries to unselect staking pool. It requires verifying that there are no deposits left on the
    /// current selected staking pool.
    pub fn unselect_staking_pool(&mut self) -> Promise {
        assert_self();
        self.assert_staking_pool_is_idle();
        self.assert_no_deficit();
        // NOTE: This is best effort checks. There is still some balance might be left on the
        // staking pool, which is validated below.
        assert_eq!(
            self.staking_information.as_ref().unwrap().deposit_amount.0,
            0,
            "There is still a deposit on the staking pool"
        );
        assert_eq!(
            self.staking_information.as_ref().unwrap().stake_amount.0,
            0,
            "There is still a stake on the staking pool"
        );

        env::log(
            format!(
                "Unselecting current staking pool @{}. Going to check current deposits first.",
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_status(TransactionStatus::Busy);

        ext_staking_pool::get_total_user_balance(
            env::current_account_id(),
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::GET_TOTAL_USER_BALANCE,
        )
        .then(ext_self::on_staking_pool_get_total_user_balance(
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::callbacks::ON_STAKING_POOL_GET_TOTAL_USER_BALANCE,
        ))
    }

    /// OWNER'S METHOD
    /// Deposits the given extra amount to the staking pool
    pub fn deposit_to_staking_pool(&mut self, amount: WrappedBalance) -> Promise {
        assert_self();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        self.assert_no_deficit();
        assert!(
            self.get_liquid_balance().0 >= amount.0,
            "The balance that can be deposited to the staking pool is lower than the extra amount"
        );

        env::log(
            format!(
                "Depositing {} to the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_status(TransactionStatus::Busy);

        ext_staking_pool::deposit(
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            amount.0,
            gas::staking_pool::DEPOSIT,
        )
        .then(ext_self::on_staking_pool_deposit(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::callbacks::ON_STAKING_POOL_DEPOSIT,
        ))
    }

    /// OWNER'S METHOD
    /// Withdraws the given amount from the staking pool
    pub fn withdraw_from_staking_pool(&mut self, amount: WrappedBalance) -> Promise {
        assert_self();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        let deficit = self.get_terminated_unvested_balance_deficit().0;
        if deficit > 0 {
            // The owner should not withdraw less than the deficit to avoid blocking operations
            // on the pool.
            assert!(
                amount.0 > deficit,
                "Can't withdraw less than the terminated unvested balance deficit"
            );
            // Need to verify that the withdrawal amount is not larger than known unstaked balance.
            // It's possible that the withdrawal can still succeed otherwise, but since it would
            // require blocking the staking pool is better to avoid such operation until the deficit
            // is resolved.
            assert!(
                self.get_known_unstaked_balance().0 >= amount.0,
                "Trying to withdraw more than known unstaked balance during terminated unvested balance deficit"
            );
        }

        env::log(
            format!(
                "Withdrawing {} from the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_status(TransactionStatus::Busy);

        ext_staking_pool::withdraw(
            amount,
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::WITHDRAW,
        )
        .then(ext_self::on_staking_pool_withdraw(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::callbacks::ON_STAKING_POOL_WITHDRAW,
        ))
    }

    /// OWNER'S METHOD
    /// Stakes the given extra amount at the staking pool
    pub fn stake(&mut self, amount: WrappedBalance) -> Promise {
        assert_self();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        self.assert_no_deficit();

        env::log(
            format!(
                "Staking {} at the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_status(TransactionStatus::Busy);

        ext_staking_pool::stake(
            amount,
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::STAKE,
        )
        .then(ext_self::on_staking_pool_stake(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::callbacks::ON_STAKING_POOL_STAKE,
        ))
    }

    /// OWNER'S METHOD
    /// Unstakes the given amount at the staking pool
    pub fn unstake(&mut self, amount: WrappedBalance) -> Promise {
        assert_self();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        let deficit = self.get_terminated_unvested_balance_deficit().0;
        if deficit > 0 {
            // During deficit the contract only allows to unstake known amount to avoid blocking the
            // contract with failed call.
            assert!(
                amount.0 <= self.staking_information.as_ref().unwrap().stake_amount.0,
                "Can't unstake the amount larger than known staked amount during terminated unvested balance deficit"
            );
            // During deficit the contract shouldn't allow to unstake more tokens than needed to
            // avoid blocking the pool.
            let unstaked_balance = self.get_known_unstaked_balance().0;
            assert!(
                deficit > unstaked_balance,
                "Can't unstake more tokens until the terminated unvested balance deficit is returned back to the account"
            );
            let need_to_unstake = deficit - unstaked_balance;
            assert!(
                amount.0 >= need_to_unstake,
                format!(
                    "Can't unstake less than the required amount of {} to cover terminated unvested balance deficit of {}",
                    need_to_unstake,
                    deficit
                )
            )
        }

        env::log(
            format!(
                "Unstaking {} at the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_status(TransactionStatus::Busy);

        ext_staking_pool::unstake(
            amount,
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::UNSTAKE,
        )
        .then(ext_self::on_staking_pool_unstake(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::callbacks::ON_STAKING_POOL_UNSTAKE,
        ))
    }

    /// OWNER'S METHOD
    /// Calls voting contract to validate if the transfers were enabled by voting. Once transfers
    /// are enabled, they can't be disabled anymore.
    pub fn check_transfers_vote(&mut self) -> Promise {
        assert_self();
        self.assert_transfers_disabled();

        let transfer_voting_information = self.transfer_voting_information.as_ref().unwrap();

        env::log(
            format!(
                "Checking that transfers are enabled (proposal {}) at the voting contract @{}",
                transfer_voting_information.transfer_proposal_id,
                transfer_voting_information.voting_contract_account_id,
            )
            .as_bytes(),
        );

        ext_voting::get_result(
            transfer_voting_information.transfer_proposal_id,
            &transfer_voting_information.voting_contract_account_id,
            NO_DEPOSIT,
            gas::voting::GET_RESULT,
        )
        .then(ext_self::on_voting_get_result(
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::callbacks::ON_VOTING_GET_RESULT,
        ))
    }

    /// OWNER'S METHOD
    /// Transfers the given extra amount to the given receiver account ID.
    /// This requires transfers to be enabled within the voting contract.
    pub fn transfer(&mut self, amount: WrappedBalance, receiver_id: AccountId) -> Promise {
        assert_self();
        assert!(amount.0 > 0, "Amount should be positive");
        assert!(
            env::is_valid_account_id(receiver_id.as_bytes()),
            "The receiver account ID is invalid"
        );
        self.assert_transfers_enabled();
        self.assert_no_staking_or_idle();
        assert!(
            self.get_liquid_owners_balance().0 >= amount.0,
            "The available liquid balance is smaller than the requested transfer amount"
        );

        env::log(format!("Transferring {} to account @{}", amount.0, receiver_id).as_bytes());

        Promise::new(receiver_id).transfer(amount.0)
    }

    /************************/
    /* Foundation's Methods */
    /************************/

    /// FOUNDATION'S METHOD
    /// Terminates vesting schedule and locks the remaining unvested amount.
    pub fn terminate_vesting(&mut self) {
        assert_self();
        assert_eq!(
            self.get_terminated_unvested_balance().0,
            0,
            "Vesting has been already terminated"
        );
        let unvested_amount = self.get_unvested_amount();
        assert!(unvested_amount.0 > 0, "The account is fully vested");

        env::log(
            format!(
                "Terminating vesting. The remaining unvested balance is {}",
                unvested_amount.0
            )
            .as_bytes(),
        );

        self.lockup_information.vesting_information =
            Some(VestingInformation::Terminating(TerminationInformation {
                unvested_amount,
                status: TransactionStatus::Idle,
            }));
    }

    /// FOUNDATION'S METHOD
    /// When the vesting is terminated and there are deficit of the tokens on the account, the
    /// deficit amount of tokens has to be unstaked and withdrawn from the staking pool.
    pub fn resolve_deficit(&mut self) -> Promise {
        assert_self();
        self.assert_staking_pool_is_idle();
        self.assert_termination_is_idle();

        let deficit = self.get_terminated_unvested_balance_deficit().0;
        assert!(deficit > 0, "There are no unvested balance deficit");

        let unstaked_balance = self.get_known_unstaked_balance().0;

        if unstaked_balance < deficit {
            let need_to_unstake = deficit - unstaked_balance;
            env::log(
                format!(
                    "Trying to unstake {} to be able to withdraw termination unvested balance deficit of {}",
                    need_to_unstake,
                    deficit,
                )
                    .as_bytes(),
            );
            self.unstake(need_to_unstake.into())
        } else {
            env::log(
                format!(
                    "Trying to withdraw {} to cover the termination unvested balance deficit",
                    deficit
                )
                .as_bytes(),
            );

            self.withdraw_from_staking_pool(deficit.into())
        }
    }

    /// FOUNDATION'S METHOD
    /// Withdraws the unvested amount from the early termination of the vesting schedule.
    pub fn withdraw_unvested_amount(&mut self, receiver_id: AccountId) -> Promise {
        assert_self();
        assert!(
            env::is_valid_account_id(receiver_id.as_bytes()),
            "The receiver account ID is invalid"
        );
        self.assert_termination_is_idle();

        let amount = self.get_terminated_unvested_balance();
        assert!(
            self.get_account_balance().0 >= amount.0,
            "The account doesn't have enough balance to withdraw the unvested amount"
        );

        env::log(
            format!(
                "Withdrawing {} terminated unvested balance to account @{}",
                amount.0, receiver_id
            )
            .as_bytes(),
        );

        self.set_terminating_status(TransactionStatus::Busy);

        Promise::new(receiver_id.clone()).transfer(amount.0).then(
            ext_self::on_withdraw_unvested_amount(
                amount,
                receiver_id,
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::callbacks::ON_WITHDRAW_UNVESTED_AMOUNT,
            ),
        )
    }

    /***********/
    /* Getters */
    /***********/

    /// The amount of tokens that can be deposited to the staking pool or transferred out.
    /// It excludes tokens that are locked due to early termination of the vesting schedule.
    pub fn get_liquid_balance(&self) -> WrappedBalance {
        self.get_account_balance()
            .0
            .saturating_sub(self.get_terminated_unvested_balance().0)
            .into()
    }

    /// The amount of tokens that are not going to be vested, because the vesting schedule was
    /// terminated earlier.
    pub fn get_terminated_unvested_balance(&self) -> WrappedBalance {
        if let Some(VestingInformation::Terminating(TerminationInformation {
            unvested_amount,
            ..
        })) = &self.lockup_information.vesting_information
        {
            *unvested_amount
        } else {
            0.into()
        }
    }

    /// The amount of tokens missing from the account balance that are required to cover
    /// the unvested balance from the early-terminated vesting schedule.
    pub fn get_terminated_unvested_balance_deficit(&self) -> WrappedBalance {
        self.get_terminated_unvested_balance()
            .0
            .saturating_sub(self.get_account_balance().0)
            .into()
    }

    /// Get the amount of tokens that are locked in this account due to lockup or vesting.
    pub fn get_locked_amount(&self) -> WrappedBalance {
        if self.lockup_information.lockup_timestamp.0 > env::block_timestamp() {
            // The entire balance is still locked before the lockup timestamp.
            return self.lockup_information.lockup_amount;
        }
        self.get_unvested_amount()
    }

    /// Get the amount of tokens that are locked in this account due to vesting.
    pub fn get_unvested_amount(&self) -> WrappedBalance {
        let block_timestamp = env::block_timestamp();
        let lockup_amount = self.lockup_information.lockup_amount.0;
        if let Some(vesting_information) = &self.lockup_information.vesting_information {
            match vesting_information {
                VestingInformation::Vesting(vesting_schedule) => {
                    if block_timestamp < vesting_schedule.cliff_timestamp.0 {
                        // Before the cliff, nothing is vested
                        lockup_amount.into()
                    } else if block_timestamp >= vesting_schedule.end_timestamp.0 {
                        // After the end, everything is vested
                        0.into()
                    } else {
                        // cannot overflow since block_timestamp >= vesting_schedule.end_timestamp
                        let time_left =
                            U256::from(vesting_schedule.end_timestamp.0 - block_timestamp);
                        // The total time is positive. Checked at the contract initialization.
                        let total_time = U256::from(
                            vesting_schedule.end_timestamp.0 - vesting_schedule.start_timestamp.0,
                        );
                        let unvested_amount = U256::from(lockup_amount) * time_left / total_time;
                        // The unvested amount can't be larger than lockup_amount because the
                        // time_left is smaller than total_time.
                        unvested_amount.as_u128().into()
                    }
                }
                VestingInformation::Terminating(termination_information) => {
                    // It's safe to subtract, because terminated amount can't be larger.
                    (lockup_amount - termination_information.unvested_amount.0).into()
                }
            }
        } else {
            // Everything is vested and unlocked
            0.into()
        }
    }

    /// The balance of the account owner. It includes vested and extra tokens that may have been
    /// deposited to this account.
    /// NOTE: Some of this tokens may be deposited to the staking pool.
    /// Also it doesn't account for tokens locked for the contract storage.
    pub fn get_owners_balance(&self) -> WrappedBalance {
        (env::account_balance() + self.get_known_deposited_balance().0)
            .saturating_sub(self.get_locked_amount().0)
            .into()
    }

    /// The amount of tokens the owner can transfer now from the account.
    pub fn get_liquid_owners_balance(&self) -> WrappedBalance {
        std::cmp::min(self.get_owners_balance().0, self.get_liquid_balance().0).into()
    }

    /*************/
    /* Callbacks */
    /*************/

    /// Called after a given `staking_pool_account_id` was checked in the whitelist.
    pub fn on_whitelist_is_whitelisted(
        &mut self,
        #[callback] is_whitelisted: bool,
        staking_pool_account_id: AccountId,
    ) -> bool {
        assert_self();
        assert!(
            is_whitelisted,
            "The given staking pool account ID is not whitelisted"
        );
        self.assert_staking_pool_is_not_selected();
        self.staking_information = Some(StakingInformation {
            staking_pool_account_id,
            status: TransactionStatus::Idle,
            deposit_amount: 0.into(),
            stake_amount: 0.into(),
        });
        true
    }

    /// Called after there was a request to unselect current staking pool.
    pub fn on_staking_pool_get_total_user_balance(
        &mut self,
        #[callback] total_balance: WrappedBalance,
    ) -> bool {
        assert_self();
        if total_balance.0 > 0 {
            // There is still positive balance on the staking pool. Can't unselect the pool.
            self.set_staking_status(TransactionStatus::Idle);
            false
        } else {
            self.staking_information = None;
            true
        }
    }

    /// Called after a deposit amount was transferred out of this account to the staking pool
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_deposit(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let deposit_succeeded = is_promise_success();
        self.set_staking_status(TransactionStatus::Idle);

        if deposit_succeeded {
            self.staking_information.as_mut().unwrap().deposit_amount.0 += amount.0;
            env::log(
                format!(
                    "The deposit of {} to @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "The deposit of {} to @{} has failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        deposit_succeeded
    }

    /// Called after the given amount was requested to transfer out from the staking pool to this
    /// account.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_withdraw(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let withdraw_succeeded = is_promise_success();
        self.set_staking_status(TransactionStatus::Idle);

        if withdraw_succeeded {
            {
                let staking_information = self.staking_information.as_mut().unwrap();
                // Due to staking rewards the deposit amount can become negative.
                staking_information.deposit_amount.0 = staking_information
                    .deposit_amount
                    .0
                    .saturating_sub(amount.0);
            }
            env::log(
                format!(
                    "The withdrawal of {} from @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "The withdrawal of {} from @{} failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        withdraw_succeeded
    }

    /// Called after the extra amount stake was staked in the staking pool contract.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_stake(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let stake_succeeded = is_promise_success();
        self.set_staking_status(TransactionStatus::Idle);

        if stake_succeeded {
            {
                let staking_information = self.staking_information.as_mut().unwrap();
                staking_information.stake_amount.0 += amount.0;
                staking_information.deposit_amount.0 = std::cmp::max(
                    staking_information.deposit_amount.0,
                    staking_information.stake_amount.0,
                );
            }
            env::log(
                format!(
                    "Staking of {} at @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "Staking {} at @{} has failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        stake_succeeded
    }

    /// Called after the extra amount stake was staked in the staking pool contract.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_unstake(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let unstake_succeeded = is_promise_success();
        self.set_staking_status(TransactionStatus::Idle);

        if unstake_succeeded {
            {
                let staking_information = self.staking_information.as_mut().unwrap();
                if amount.0 > staking_information.stake_amount.0 {
                    staking_information.deposit_amount.0 +=
                        amount.0 - staking_information.stake_amount.0;
                    staking_information.stake_amount.0 = 0;
                } else {
                    staking_information.stake_amount.0 -= amount.0;
                }
            }
            env::log(
                format!(
                    "Unstaking of {} at @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "Unstaking {} at @{} has failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        unstake_succeeded
    }

    /// Called after the extra amount stake was staked in the staking pool contract.
    /// This method needs to update staking pool status.
    pub fn on_voting_get_result(&mut self, #[callback] vote_index: Option<VoteIndex>) -> bool {
        assert_self();
        self.assert_transfers_disabled();

        let expected_vote_index = self
            .transfer_voting_information
            .as_ref()
            .unwrap()
            .enable_transfers_vote_index;

        if let Some(vote_index) = vote_index {
            assert_eq!(vote_index, expected_vote_index, "The enable transfers proposal has been resolved to a different vote. Transfers will never be enabled.");
            env::log(b"Transfers has been successfully enabled");
            self.transfer_voting_information = None;
            true
        } else {
            env::log(b"Voting on enabling transfers doesn't have a majority vote yet");
            false
        }
    }

    /// Called after the foundation tried to withdraw the unvested amount from the account.
    pub fn on_withdraw_unvested_amount(
        &mut self,
        amount: WrappedBalance,
        receiver_id: AccountId,
    ) -> bool {
        assert_self();

        let withdraw_succeeded = is_promise_success();
        if withdraw_succeeded {
            self.lockup_information.vesting_information = None;
            env::log(
                format!(
                    "The withdrawal of the terminated unvested amount of {} to @{} succeeded",
                    amount.0, receiver_id,
                )
                .as_bytes(),
            );
        } else {
            self.set_terminating_status(TransactionStatus::Idle);
            env::log(
                format!(
                    "The withdrawal of the terminated unvested amount of {} to @{} failed",
                    amount.0, receiver_id,
                )
                .as_bytes(),
            );
        }
        withdraw_succeeded
    }

    /********************/
    /* Internal methods */
    /********************/

    /// The balance of the account excluding the storage staking balance.
    /// NOTE: The storage staking balance can't be transferred out without deleting this contract.
    fn get_account_balance(&self) -> WrappedBalance {
        env::account_balance()
            .saturating_sub(MIN_BALANCE_FOR_STORAGE)
            .into()
    }

    fn get_known_unstaked_balance(&self) -> WrappedBalance {
        self.staking_information
            .as_ref()
            .map(|info| {
                // Known deposit is always greater or equal to the known stake.
                info.deposit_amount.0 - info.stake_amount.0
            })
            .unwrap_or(0)
            .into()
    }

    /// The amount of tokens that were deposited to the staking pool.
    /// NOTE: The actual balance can be larger than this known deposit balance due to staking
    /// rewards acquired on the staking pool.
    fn get_known_deposited_balance(&self) -> WrappedBalance {
        self.staking_information
            .as_ref()
            .map(|info| info.deposit_amount.0)
            .unwrap_or(0)
            .into()
    }

    fn set_staking_status(&mut self, status: TransactionStatus) {
        self.staking_information
            .as_mut()
            .expect("Staking pool should be selected")
            .status = status;
    }

    fn set_terminating_status(&mut self, status: TransactionStatus) {
        if let Some(VestingInformation::Terminating(termination_information)) =
            self.lockup_information.vesting_information.as_mut()
        {
            termination_information.status = status;
        } else {
            unreachable!("The vesting information is not at the terminating stage");
        }
    }

    fn assert_no_deficit(&self) {
        assert_eq!(
            self.get_terminated_unvested_balance_deficit().0, 0,
            "All normal staking pool operations are blocked until the terminated unvested balance deficit is returned to the account"
        );
    }

    fn assert_transfers_enabled(&self) {
        assert!(
            self.transfer_voting_information.is_none(),
            "Transfers are disabled"
        );
    }

    fn assert_transfers_disabled(&self) {
        assert!(
            self.transfer_voting_information.is_some(),
            "Transfers are already enabled"
        );
    }

    fn assert_no_staking_or_idle(&self) {
        if let Some(staking_information) = &self.staking_information {
            match staking_information.status {
                TransactionStatus::Idle => (),
                TransactionStatus::Busy => {
                    env::panic(b"Contract is currently busy with another operation")
                }
            };
        }
    }

    fn assert_termination_is_idle(&self) {
        if let Some(VestingInformation::Terminating(termination_information)) =
            &self.lockup_information.vesting_information
        {
            match termination_information.status {
                TransactionStatus::Idle => (),
                TransactionStatus::Busy => {
                    env::panic(b"Contract is currently busy with termination withdrawal")
                }
            };
        } else {
            env::panic(b"There are no termination in progress");
        }
    }

    fn assert_staking_pool_is_idle(&self) {
        assert!(
            self.staking_information.is_some(),
            "Staking pool is not selected"
        );
        match self.staking_information.as_ref().unwrap().status {
            TransactionStatus::Idle => (),
            TransactionStatus::Busy => {
                env::panic(b"Contract is currently busy with another operation")
            }
        };
    }

    fn assert_staking_pool_is_not_selected(&self) {
        assert!(
            self.staking_information.is_none(),
            "Staking pool is already selected"
        );
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::{testing_env, MockedBlockchain, VMContext};
    use std::convert::TryInto;

    pub type AccountId = String;

    pub const LOCKUP_NEAR: u128 = 1000;
    pub const GENESIS_TIME_IN_DAYS: u64 = 500;
    pub const YEAR: u64 = 365;
    pub const ALMOST_HALF_YEAR: u64 = YEAR / 2;

    pub fn system_account() -> AccountId {
        "system".to_string()
    }

    pub fn account_owner() -> AccountId {
        "account_owner".to_string()
    }

    pub fn non_owner() -> AccountId {
        "non_owner".to_string()
    }

    pub fn to_yocto(near_balance: u128) -> u128 {
        near_balance * 10u128.pow(24)
    }

    pub fn to_ts(num_days: u64) -> u64 {
        // 2018-08-01 UTC in nanoseconds
        1533081600_000_000_000 + num_days * 86400_000_000_000
    }

    pub fn assert_almost_eq_with_max_delta(left: u128, right: u128, max_delta: u128) {
        assert!(
            std::cmp::max(left, right) - std::cmp::min(left, right) < max_delta,
            format!(
                "Left {} is not even close to Right {} within delta {}",
                left, right, max_delta
            )
        );
    }

    pub fn assert_almost_eq(left: u128, right: u128) {
        assert_almost_eq_with_max_delta(left, right, to_yocto(10));
    }

    pub fn get_context(
        predecessor_account_id: AccountId,
        account_balance: u128,
        account_locked_balance: u128,
        block_timestamp: u64,
        is_view: bool,
    ) -> VMContext {
        VMContext {
            current_account_id: account_owner(),
            signer_account_id: predecessor_account_id.clone(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 1,
            block_timestamp,
            epoch_height: 1,
            account_balance,
            account_locked_balance,
            storage_usage: 10u64.pow(6),
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(15),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
        }
    }

    fn public_key(byte_val: u8) -> Base58PublicKey {
        let mut pk = vec![byte_val; 33];
        pk[0] = 0;
        Base58PublicKey(pk)
    }

    fn lockup_only_setup() -> (VMContext, LockupContract) {
        let context = get_context(
            system_account(),
            to_yocto(LOCKUP_NEAR),
            0,
            to_ts(GENESIS_TIME_IN_DAYS),
            false,
        );
        testing_env!(context.clone());
        // Contract Setup:
        // - Now is genesis time.
        // - Lockup amount is 1000 near tokens.
        // - Lockup for 1 year.
        // - Owner has 2 keys
        let contract = LockupContract::new(
            LockupInformation {
                lockup_amount: to_yocto(LOCKUP_NEAR).into(),
                lockup_timestamp: to_ts(GENESIS_TIME_IN_DAYS + YEAR).into(),
                vesting_information: None,
            },
            AccountId::from("whitelist"),
            None,
            vec![public_key(1), public_key(2)],
            vec![],
        );
        (context, contract)
    }

    #[test]
    fn test_lockup_only_basic() {
        let (mut context, contract) = lockup_only_setup();
        // Checking initial values at genesis time
        context.is_view = true;
        testing_env!(context.clone());

        assert_eq!(contract.get_owners_balance().0, 0);

        // Checking values in 1 day after genesis time
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 1);

        assert_eq!(contract.get_owners_balance().0, 0);

        // Checking values next day after lockup timestamp
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        testing_env!(context.clone());

        assert_almost_eq(contract.get_owners_balance().0, to_yocto(LOCKUP_NEAR));
    }

    /*
    #[test]
    fn test_lockup_only_transferrable_with_different_stakes() {
        let (mut context, contract) = lockup_only_setup();

        // Staking everything at the genesis
        context.account_locked_balance = to_yocto(999);
        context.account_balance = to_yocto(1);

        // Checking values in 1 day after genesis time
        context.is_view = true;

        for stake in &[1, 10, 100, 500, 999, 1001, 1005, 1100, 1500, 1999, 3000] {
            let stake = *stake;
            context.account_locked_balance = to_yocto(stake);
            let balance_near = std::cmp::max(1000u128.saturating_sub(stake), 1);
            context.account_balance = to_yocto(balance_near);
            let extra_balance_near = stake + balance_near - 1000;

            context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 1);
            testing_env!(context.clone());

            assert_eq!(
                contract.get_owners_balance().0,
                to_yocto(extra_balance_near)
            );

            // Checking values next day after lockup timestamp
            context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
            testing_env!(context.clone());

            assert_almost_eq(
                contract.get_owners_balance().0,
                to_yocto(LOCKUP_NEAR + extra_balance_near),
            );
        }
    }
    */

    #[test]
    fn test_lockup_only_transfer_call_by_owner() {
        let (mut context, mut contract) = lockup_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.is_view = true;
        testing_env!(context.clone());
        assert_almost_eq(contract.get_owners_balance().0, to_yocto(LOCKUP_NEAR));

        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        assert_eq!(env::account_balance(), to_yocto(LOCKUP_NEAR));
        contract.transfer(to_yocto(100).into(), non_owner());
        assert_almost_eq(env::account_balance(), to_yocto(LOCKUP_NEAR - 100));
    }

    /*
    #[test]
    fn test_lockup_only_stake_call_by_owner() {
        let (mut context, mut contract) = lockup_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.is_view = true;
        testing_env!(context.clone());
        assert_almost_eq(contract.get_owners_balance().0, to_yocto(LOCKUP_NEAR));

        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        assert_eq!(env::account_balance(), to_yocto(LOCKUP_NEAR));
        contract.stake(to_yocto(100).into(), public_key(10).try_into().unwrap());
        assert_almost_eq(env::account_balance(), to_yocto(LOCKUP_NEAR));
    }

    #[test]
    fn test_lockup_only_transfer_by_non_owner() {
        let (mut context, mut contract) = lockup_only_setup();

        context.predecessor_account_id = non_owner();
        context.signer_account_id = non_owner();
        context.signer_account_pk = public_key(5).try_into().unwrap();
        testing_env!(context.clone());

        std::panic::catch_unwind(move || {
            contract.transfer(to_yocto(100).into(), non_owner());
        })
        .unwrap_err();
    }

    #[test]
    fn test_lockup_only_stake_by_non_owner() {
        let (mut context, mut contract) = lockup_only_setup();

        context.predecessor_account_id = non_owner();
        context.signer_account_id = non_owner();
        context.signer_account_pk = public_key(5);
        testing_env!(context.clone());

        std::panic::catch_unwind(move || {
            contract.stake(to_yocto(100).into(), public_key(4).try_into().unwrap());
        })
        .unwrap_err();
    }
    */
}

'''
'''--- staking-pool/Cargo.toml ---
[package]
name = "staking-pool"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
serde = { version = "*", features = ["derive"] }
serde_json = "*"
borsh = "*"
near-sdk = "0.9.2"
uint = { version = "0.8.3", default-features = false }
wee_alloc = { version = "0.4.5", default-features = false, features = [] }

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }
near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }
near-runtime-standalone = { git = "https://github.com/nearprotocol/nearcore.git" }

'''
'''--- staking-pool/README.md ---
# Staking / Delegation contract

This contract provides a way for other users to delegate funds to a single validation node.

Implements the https://github.com/nearprotocol/NEPs/pull/27 standard.

There are three different roles:
- The staking pool contract account `my_validator`. A key-less account with the contract that pools funds.
- The owner of the staking contract `owner`. Owner runs the validator node on behalf of the staking pool account.
- Delegator accounts `user1`, `user2`, etc. Accounts that want to stake their funds with the pool.

The owner can setup such contract and validate on behalf of this contract in their node.
Any other user can send their tokens to the contract, which will be pooled together and increase the total stake.
These users accrue rewards (subtracted fees set by the owner).
Then they can unstake and withdraw their balance after some unlocking period.

## Staking pool implementation details

For secure operation of the staking pool, the contract should not have any access keys.
Otherwise the contract account may issue a transaction that can violate the contract guarantees.

After users deposit tokens to the contract, they can stake some or all of them to receive "stake" shares.
The price of a "stake" share can be defined as the total amount of staked tokens divided by the the total amount of "stake" shares.
The number of "stake" shares is always less than the number of the staked tokens, so the price of single "stake" share is not less than `1`.

### Initialization

A contract has to be initialized with the following parameters:
- `owner_id` - `string` the account ID of the contract owner. This account will be able to call owner-only methods. E.g. `owner`
- `stake_public_key` - `string` the initial public key that will be used for staking on behalf of the contract's account in base58 ED25519 curve. E.g. `KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7`
- `reward_fee_fraction` - `json serialized object` the initial value of the fraction of the reward that the owner charges delegators for running the node.
The fraction is defined by the numerator and denumerator with `u32` types. E.g. `{numerator: 10, denominator: 100}` defines `10%` reward fee.
The fraction can be at most `1`. The denumerator can't be `0`.

During the initialization the contract checks validity of the input and initializes the contract.
The contract shouldn't have locked balance during the initialization.

At the initialization the contract allocates one trillion yocto NEAR tokens towards "stake" share price guarantees.
This fund is later used to adjust the the amount of staked and unstaked tokens due to rounding error.
For each stake and unstake action, the contract may spend at most 1 yocto NEAR from this fund (implicitly).

The current total balance (except for the "stake" share price guarantee amount) is converted to shares and will be staked (after the next action).
This balance can never be unstaked or withdrawn from the contract.
It's used to maintain the minimum number of shares, as well as help pay for the potentially growing contract storage.

### Delegator accounts

The contract maintains account information per delegator associated with the hash of the delegator's account ID.

The information contains:
- Unstaked balance of the account.
- Number of "stake" shares.
- The minimum epoch height when the unstaked balance can be withdrawn. Initially zero.

A delegator can do the following actions:

#### Deposit

When a delegator account first deposits funds to the contract, the internal account is created and credited with the
attached amount of unstaked tokens.

#### Stake

When an account wants to stake a given amount, the contract calculates the number of "stake" shares (`num_shares`) and the actual rounded stake amount (`amount`).
The unstaked balance of the account is decreased by `amount`, the number of "stake" shares of the account is increased by `num_shares`.
The contract increases the total number of staked tokens and the total number of "stake" shares. Then the contract restakes.

#### Unstake

When an account wants to unstake a given amount, the contract calculates the number of "stake" shares needed (`num_shares`) and
the actual required rounded unstake amount (`amount`). It's calculated based on the current total price of "stake" shares.
The unstaked balance of the account is increased by `amount`, the number of "stake" shares of the account is decreased by `num_shares`.
The minimum epoch height when the account can withdraw is set to the current epoch height increased by `4`.
The contract decreases the total number of staked tokens and the total number of "stake" shares. Then the contract restakes.

#### Withdraw

When an account wants to withdraw, the contract checks the minimum epoch height of this account and checks the amount.
Then sends the transfer and decreases the unstaked balance of the account.

#### Ping

Calls the internal function to distribute rewards if the blockchain epoch switched. The contract will restake in this case.

### Reward distribution

Before every action the contract calls method `internal_ping`.
This method distributes rewards towards active delegators when the blockchain epoch switches.
The rewards might be given due to staking and also because the contract earns gas fee rebates for every function call.

The method first checks that the current epoch is different from the last epoch, and if it's not changed exits the method.

The reward are computed the following way. The contract keeps track of the last known total account balance.
This balance consist of the initial contract balance, and all delegator account balances (including the owner) and all accumulated rewards.
(Validation rewards are added automatically at the beginning of the epoch, while contract execution gas rebates are added after each transaction)

When the method is called the contract uses the current total account balance (without attached deposit) and the subtracts the last total account balance.
The difference is the total reward that has to be distributed.

The fraction of the reward is awarded to the contract owner. The fraction is configurable by the owner, but can't exceed 1.

The remaining part of the reward is added to the total staked balance. This action increases the price of each "stake" share without
changing the amount of "stake" shares owned by different accounts. Which is effectively distributing the reward based on the number of shares.

The owner's reward is converted into "stake" shares at the new price and added to the owner's account.
It's done similarly to `stake` method but without debiting the unstaked balance of owner's account.

Once the rewards are distributed the contract remembers the new total balance.

## Owner-only methods

Contract owner can do the following:
- Change public staking key. This action restakes with the new key.
- Change reward fee fraction.
- Vote on behalf of the pool. This is needed for the NEAR chain governence, and can be discussed in the following NEP: https://github.com/nearprotocol/NEPs/pull/62

## Staking pool contract guarantees and invariants

This staking pool implementation guarantees the required properties of the staking pool standard:

- The contract can't lose or lock tokens of users.
- If a user deposited X, the user should be able to withdraw at least X.
- If a user successfully staked X, the user can unstake at least X.
- The contract should not lock unstaked funds for longer than 4 epochs after unstake action.

It also has inner invariants:

- The staking pool contract is secure if it doesn't have any access keys.
- The price of a "stake" is always at least `1`.
- The price of a "stake" share never decreases.
- The reward fee is a fraction be from `0` to `1` inclusive.
- The owner can't withdraw funds from other delegators.
- The owner can't delete the staking pool account.

## Pre-requisites

To develop Rust contracts you would need to:
* Install [Rustup](https://rustup.rs/):
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
* Add wasm target to your toolchain:
```bash
rustup target add wasm32-unknown-unknown
```

## Building the contract

```bash
./build.sh
```

## Usage

Commands to deploy and initialize a staking contract:

```bash
near create_account my_validator --masterAccount=owner
near deploy --accountId=my_validator --wasmFile=res/staking_pool.wasm
# Initialize staking pool at account `my_validator` for the owner account ID `owner`, given staking pool and 10% reward fee.
near call my_validator new '{"owner_id": "owner", "stake_public_key": "CE3QAXyVLeScmY9YeEyR3Tw9yXfjBPzFLzroTranYtVb", "reward_fee_fraction": {"numerator": 10, "denominator": 100}}' --account_id owner
# TODO: Delete all access keys from the `my_validator` account
```

As a user, to delegate money:

```bash
near call my_validator deposit '{}' --accountId user1 --amount 100
near call my_validator stake '{"amount": "100000000000000000000000000"}' --accountId user1
```

To update current rewards:

```bash
near call my_validator ping '{}' --accountId user1
```

View methods:

```bash
# User1 total balance
near view my_validator get_account_total_balance '{"account_id": "user1"}'

# User1 staked balance
near view my_validator get_account_staked_balance '{"account_id": "user1"}'

# User1 unstaked balance
near view my_validator get_account_unstaked_balance '{"account_id": "user1"}'

# Whether user1 can withdraw now
near view my_validator is_account_unstaked_balance_available '{"account_id": "user1"}'

# Total staked balance of the entire pool
near view my_validator get_total_staked_balance '{}'

# Owner of the staking pool
near view my_validator get_owner_id '{}'

# Current reward fee
near view my_validator get_reward_fee_fraction '{}'

# Owners balance
near view my_validator get_account_total_balance '{"account_id": "owner"}'
```

To un-delegate, first run `unstake`:

```bash
near call my_validator unstake '{"amount": "100000000000000000000000000"}' --accountId user1
```

And after 3 epochs, run `withdraw`:

```bash
near call my_validator withdraw '{"amount": "100000000000000000000000000"}' --accountId user1
```

## Interface

```rust
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

/// Initializes the contract with the given owner_id, initial staking public key (with ED25519
/// curve) and initial reward fee fraction that owner charges for the validation work.
#[init]
pub fn new(
    owner_id: AccountId,
    stake_public_key: Base58PublicKey,
    reward_fee_fraction: RewardFeeFraction,
);

/// Distributes rewards and restakes if needed.
pub fn ping(&mut self);

/// Deposits the attached amount into the inner account of the predecessor.
#[payable]
pub fn deposit(&mut self);

/// Withdraws the non staked balance for given account.
/// It's only allowed if the `unstake` action was not performed in the recent 3 epochs.
pub fn withdraw(&mut self, amount: U128);

/// Stakes the given amount from the inner account of the predecessor.
/// The inner account should have enough unstaked balance.
pub fn stake(&mut self, amount: U128);

/// Unstakes the given amount from the inner account of the predecessor.
/// The inner account should have enough staked balance.
/// The new total unstaked balance will be available for withdrawal in 3 epochs.
pub fn unstake(&mut self, amount: U128);

/****************/
/* View methods */
/****************/

/// Returns the unstaked balance of the given account.
pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128;

/// Returns the staked balance of the given account.
/// NOTE: This is computed from the amount of "stake" shares the given account has and the
/// current amount of total staked balance and total stake shares on the account.
pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128;

/// Returns the total balance of the given account (including staked and unstaked balances).
pub fn get_account_total_balance(&self, account_id: AccountId) -> U128;

/// Returns `true` if the given account can withdraw tokens in the current epoch.
pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool;

/// Returns the total staking balance.
pub fn get_total_staked_balance(&self) -> U128;

/// Returns account ID of the staking pool owner.
pub fn get_owner_id(&self) -> AccountId;

/// Returns the current reward fee as a fraction.
pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction;

/*******************/
/* Owner's methods */
/*******************/

/// Owner's method.
/// Updates current public key to the new given public key.
pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey);

/// Owner's method.
/// Updates current reward fee fraction to the new given fraction.
pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction);

/// Owner's method.
/// Vote on a given proposal on a given voting contract account ID on behalf of the pool.
/// NOTE: This method allows the owner to call `vote(proposal_id: U64)` on any contract on
/// behalf of this staking pool.
pub fn vote(&mut self, voting_account_id: AccountId, proposal_id: ProposalId) -> Promise;
```

## Migrating from an existing validator or contract
This provides instructions to migrate your staked validator or a validator contract to a new contract

#### Upgrade to the latest near-shell:
```bash
npm install -g near-shell
```
#### Set Environment and Login:

##### If not logged into the browser, recover your account with the seed phrase first
https://wallet.betanet.nearprotocol.com/create/

```bash
#Set the NEAR environment to the target network (betanet,testnet,mainnet)
export NEAR_ENV=betanet

near login
```

#### Unstake and Withdraw:
```bash
#If you staked to your validator unstake, there is no withdraw
near stake nearkat.betanet <staking public key> 0

#If you staked to a contract get the staked balance
near view my_validator get_account_staked_balance '{"account_id": "user1"}'

#Unsake by copying and pasting the staked balance
near call my_validator unstake '{"amount": "100000000000000000000000000"}' --accountId user1

#Wait 4 epochs (12 hours) to withdraw and check if balance is available to withdraw
near view my_validator is_account_unstaked_balance_available '{"account_id": "user1"}'

#If is_account_unstaked_balance_available returns "true" withdraw
near call my_validator withdraw '{"amount": "100000000000000000000000000"}' --accountId user1
```
#### Download new contract with Git:
```bash
mkdir staking-pool

cd staking-pool

git clone https://github.com/near/initial-contracts

cd initial-contracts

cd staking-pool
```
#### Build contract with Rust (This step is optional since the contract is compiled):
##### Install Rust:
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

#Add rust to current shell path
source $HOME/.cargo/env
```
##### Add wasm target to your toolchain:
```bash
rustup target add wasm32-unknown-unknown
```
##### Build:
```bash
./build.sh
```
#### Create a new account to deploy contract to
- Set my_validator to the name you want publicly displayed
- --masterAccount is your account you signed up to StakeWars2 with
```bash
near create_account my_validator --masterAccount=owner
```
#### Deploy the contract to the new account
```bash
near deploy --accountId=my_validator --wasmFile=res/staking_pool.wasm
```
#### Create a new node:

**Note** after you NEAR is unstaked stop your node and create a new one to run as the contract account

##### Stop your node
```bash
nearup stop
```
##### Move your ~/.near/betanet folder, to remove references to any previous validator node
```bash
mv ~/.near/betanet ~/.near/betanet_old
```
##### Launch your new node
With the command nearup betanet. Modify the launch command according to your actual validator configuration (e.g. using --nodocker and --binary-path)

##### Set your validator ID. 
Put your staking pool account (the one we called my_validator in the steps above)

##### Copy your validator public key, or issue the command (before the next step)
```bash
cat ~/.near/betanet/validator_key.json |grep "public_key"
```
#### Initialize staking pool at account `my_validator` for the owner account ID `owner`, given staking pool and 10% reward fee
```bash
near call my_validator new '{"owner_id": "owner", "stake_public_key": "CE3QAXyVLeScmY9YeEyR3Tw9yXfjBPzFLzroTranYtVb", "reward_fee_fraction": {"numerator": 10, "denominator": 100}}' --account_id owner
```
#### Check the current `seat price` to transfer the correct amount to your delegator(s)
```bash
near validators next| grep "seat price"
```
#### Register a delegator account (repeat these steps for additional delegators)
-- https://wallet.betanet.near.org
-- backup your seed phrase
-- transfer NEAR from your MasterAccount to the delegator account

#### Login and authorize the delegator
```bash
near login
```
#### Deposit NEAR from the delegator account to the valdiator contract
```bash
near call my_validator deposit '{}' --accountId user1 --amount 100
```
#### Stake the deposited amount to the validator contract
```bash
near call my_validator stake '{"amount": "100000000000000000000000000"}' --accountId user1
```
#### Check that your validator proposal was (Accepted) or deposit and stake more NEAR
```bash
near proposals | grep my_validator
#After some time check to make sure you're listed
near validators next | grep my_validator
```
## Common errors and resolutions

#### ERROR while adding wasm32 to toolchain: error[E0463]: can't find crate for `core`
You might have a nightly version of cargo, rustc, rustup, update to stable
```bash
rustup update stable

#Install target with stable version of Rustup
rustup +stable target add wasm32-unknown-unknown
```

#### Error:  TypedError: [-32000] Server error: account <accountId> does not exist while viewing
You are not logged in
```bash
near login
```
    
#### Error:  GasExceeded [Error]: Exceeded the prepaid gas
Add additional gas by adding the parameter: --gas 10000000000000000

#### Error: "wasm execution failed with error: FunctionCallError(MethodResolveError(MethodNotFound))"
Your function call is incorrect or your contract is not updated

'''
'''--- staking-pool/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/staking_pool.wasm ./res/

'''
'''--- staking-pool/src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::collections::Map;
use near_sdk::json_types::{Base58PublicKey, U128, U64};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PublicKey,
};
use serde::{Deserialize, Serialize};

use uint::construct_uint;

/// The amount of gas given to complete `internal_after_stake` call.
const VOTE_GAS: u64 = 200_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// Proposal ID for voting contract.
pub type ProposalId = U64;

/// The sha256 hash of the Account ID
pub type AccountHash = Vec<u8>;

/// A type to distinguish between a balance and a staking shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    // TODO: Revert back to 4 once wasm/wasmer bug is fixed.
    // See https://github.com/wasmerio/wasmer/issues/1429
    pub struct U256(8);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. Which will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID hash to the corresponding account.
    pub accounts: Map<AccountHash, Account>,
}

/// Returns sha256 hash of the given account ID.
fn hash_account_id(account_id: &AccountId) -> Vec<u8> {
    env::sha256(account_id.as_bytes())
}

impl Default for StakingContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (U256::from(self.numerator) * U256::from(value) / U256::from(self.denominator)).as_u128()
    }
}

/// Interface for a voting contract.
#[ext_contract(ext_voting)]
pub trait VoteContract {
    /// Votes on the given proposal_id with the given stake.
    fn vote(&mut self, proposal_id: ProposalId, stake: U128);
}

#[near_bindgen]
impl StakingContract {
    /// Initializes the contract with the given owner_id, initial staking public key (with ED25519
    /// curve) and initial reward fee fraction that owner charges for the validation work.
    ///
    /// The entire current balance of this contract will be used to stake. This allows contract to
    /// always maintain staking shares that can't be unstaked or withdrawn.
    /// It prevents inflation the price of the share too much.
    #[init]
    pub fn new(
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        reward_fee_fraction.assert_valid();
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            last_total_balance: account_balance,
            total_staked_balance,
            total_stake_shares: NumStakeShares::from(total_staked_balance),
            reward_fee_fraction,
            accounts: Map::new(b"u".to_vec()),
        };
        // Staking with the current pool to make sure the staking key is valid.
        this.restake();
        this
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();

        let account_id = env::predecessor_account_id();
        let mut account = self.get_account(&account_id);
        let amount = env::attached_deposit();
        account.unstaked += amount;
        self.save_account(&account_id, &account);
        self.last_total_balance += amount;

        env::log(
            format!(
                "@{} deposited {}. New unstaked balance is {}",
                account_id, amount, account.unstaked
            )
            .as_bytes(),
        );

        if need_to_restake {
            self.restake();
        }
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the recent 3 epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let need_to_restake = self.internal_ping();

        let amount = amount.into();
        assert!(amount > 0, "Withdrawal amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.get_account(&account_id);
        assert!(
            account.unstaked >= amount,
            "Not enough unstaked balance to withdraw"
        );
        assert!(
            account.unstaked_available_epoch_height <= env::epoch_height(),
            "The unstaked balance is not yet available due to unstaking delay"
        );
        account.unstaked -= amount;
        self.save_account(&account_id, &account);

        env::log(
            format!(
                "@{} withdrawing {}. New unstaked balance is {}",
                account_id, amount, account.unstaked
            )
            .as_bytes(),
        );

        Promise::new(account_id).transfer(amount);
        self.last_total_balance -= amount;

        if need_to_restake {
            self.restake();
        }
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128) {
        // Stake action always restakes
        let _need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        assert!(amount > 0, "Staking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.get_account(&account_id);

        // Calculate the number of "stake" shares that the account will receive for staking the
        // given amount.
        let num_shares = self.num_shares_from_staked_amount_rounded_down(amount);
        assert!(
            num_shares > 0,
            "The calculated number of \"stake\" shares received for staking should be positive"
        );
        // The amount of tokens the account will be charged from the unstaked balance.
        // Rounded down to avoid overcharging the account to guarantee that the account can always
        // unstake at least the same amount as staked.
        let charge_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);
        assert!(
            charge_amount > 0,
            "Invariant violation. Calculated staked amount be positive, because \"stake\" share price should be at least 1"
        );

        assert!(
            account.unstaked >= charge_amount,
            "Not enough unstaked balance to stake"
        );
        account.unstaked -= charge_amount;
        account.stake_shares += num_shares;
        self.save_account(&account_id, &account);

        // The staked amount that will be added to the total to guarantee the "stake" share price
        // never decreases. The difference between `stake_amount` and `charge_amount` is paid
        // from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let stake_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);

        self.total_staked_balance += stake_amount;
        self.total_stake_shares += num_shares;

        env::log(
            format!(
                "@{} staking {}. Received {} new staking shares. Total {} unstaked balance and {} staking shares",
                account_id, charge_amount, num_shares, account.unstaked, account.stake_shares
            )
            .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );

        self.restake();
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in 3 epochs.
    pub fn unstake(&mut self, amount: U128) {
        // Unstake action always restakes
        let _need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        assert!(amount > 0, "Unstaking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.get_account(&account_id);

        assert!(
            self.total_staked_balance > 0,
            "The contract doesn't have staked balance"
        );
        // Calculate the number of shares required to unstake the given amount.
        // NOTE: The number of shares the account will pay is rounded up.
        let num_shares = self.num_shares_from_staked_amount_rounded_up(amount);
        assert!(
            num_shares > 0,
            "Invariant violation. The calculated number of \"stake\" shares for unstaking should be positive"
        );
        assert!(
            account.stake_shares >= num_shares,
            "Not enough staked balance to unstake"
        );

        // Calculating the amount of tokens the account will receive by unstaking the corresponding
        // number of "stake" shares, rounding up.
        let receive_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);
        assert!(
            receive_amount > 0,
            "Invariant violation. Calculated staked amount be positive, because \"stake\" share price should be at least 1"
        );

        account.stake_shares -= num_shares;
        account.unstaked += receive_amount;
        account.unstaked_available_epoch_height = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK;
        self.save_account(&account_id, &account);

        // The amount tokens that will be unstaked from the total to guarantee the "stake" share
        // price never decreases. The difference between `receive_amount` and `unstake_amount` is
        // paid from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let unstake_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);

        self.total_staked_balance -= unstake_amount;
        self.total_stake_shares -= num_shares;

        env::log(
            format!(
                "@{} unstaking {}. Spent {} staking shares. Total {} unstaked balance and {} staking shares",
                account_id, receive_amount, num_shares, account.unstaked, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );

        self.restake();
    }

    /// Restakes the current `total_staked_balance` again.
    fn restake(&mut self) {
        // Stakes with the staking public key. If the key is invalid the entire function call
        // will be rolled back. See https://github.com/nearprotocol/nearcore/issues/2636
        Promise::new(env::current_account_id())
            .stake(self.total_staked_balance, self.stake_public_key.clone());
    }

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(&account_id).unstaked.into()
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.staked_amount_from_num_shares_rounded_down(self.get_account(&account_id).stake_shares)
            .into()
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        (self.get_account(&account_id).unstaked + self.get_account_staked_balance(account_id).0)
            .into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(&account_id)
            .unstaked_available_epoch_height
            <= env::epoch_height()
    }

    /// Returns the total staking balance.
    pub fn get_total_staked_balance(&self) -> U128 {
        self.total_staked_balance.into()
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        self.reward_fee_fraction.clone()
    }

    /*******************/
    /* Owner's methods */
    /*******************/

    /// Owner's method.
    /// Updates current public key to the new given public key.
    pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Can only be called by the owner"
        );
        // When updating the staking key, the contract has to restake.
        let _need_to_restake = self.internal_ping();
        self.stake_public_key = stake_public_key.into();
        self.restake();
    }

    /// Owner's method.
    /// Updates current reward fee fraction to the new given fraction.
    pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Can only be called by the owner"
        );
        reward_fee_fraction.assert_valid();

        let need_to_restake = self.internal_ping();
        self.reward_fee_fraction = reward_fee_fraction;
        if need_to_restake {
            self.restake();
        }
    }

    /// Owner's method.
    /// Vote on a given proposal with the given stake amount on a given voting contract account ID
    /// on behalf of the pool.
    /// NOTE: This method allows the owner to call `vote(proposal_id: U64, stake: U128)` on any
    /// contract on behalf of this staking pool.
    pub fn vote(
        &mut self,
        voting_account_id: AccountId,
        proposal_id: ProposalId,
        stake: U128,
    ) -> Promise {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Can only be called by the owner"
        );
        assert!(
            env::is_valid_account_id(voting_account_id.as_bytes()),
            "Invalid voting account ID"
        );

        ext_voting::vote(proposal_id, stake, &voting_account_id, NO_DEPOSIT, VOTE_GAS)
    }

    /********************/
    /* Internal methods */
    /********************/

    /// Distributes rewards after the new epoch. It's automatically called before every action.
    /// Returns true if the current epoch height is different from the last epoch height.
    fn internal_ping(&mut self) -> bool {
        // Checking if we need there are rewards to distribute.
        let epoch_height = env::epoch_height();
        if self.last_epoch_height == epoch_height {
            return false;
        }
        self.last_epoch_height = epoch_height;

        // New total amount (both locked and unlocked balances).
        // NOTE: We need to subtract `attached_deposit` in case `ping` called from `deposit` call.
        let total_balance =
            env::account_locked_balance() + env::account_balance() - env::attached_deposit();

        assert!(
            total_balance >= self.last_total_balance,
            "The new total balance should not be less than the old total balance"
        );
        let total_reward = total_balance - self.last_total_balance;
        if total_reward > 0 {
            // The validation fee that the contract owner takes.
            let owners_fee = self.reward_fee_fraction.multiply(total_reward);

            // Distributing the remaining reward to the delegators first.
            let remaining_reward = total_reward - owners_fee;
            self.total_staked_balance += remaining_reward;

            // Now buying "stake" shares for the contract owner at the new shares price.
            let num_shares = self.num_shares_from_staked_amount_rounded_down(owners_fee);
            if num_shares > 0 {
                // Updating owner's inner account
                let owner_id = self.owner_id.clone();
                let mut account = self.get_account(&owner_id);
                account.stake_shares += num_shares;
                self.save_account(&owner_id, &account);
                // Increasing the total amount of "stake" shares.
                self.total_stake_shares += num_shares;
            }
            // Increasing the total staked balance by the owners fee, no matter whether the owner
            // got any shares or not.
            self.total_staked_balance += owners_fee;

            env::log(
                format!(
                    "Epoch {}: Contract received total rewards of {} tokens. New total staked balance is {}. Total number of shares {}",
                    epoch_height, total_reward, self.total_staked_balance, self.total_stake_shares,
                )
                    .as_bytes(),
            );
            if num_shares > 0 {
                env::log(format!("Total rewards fee is {} stake shares.", num_shares).as_bytes());
            }
        }

        self.last_total_balance = total_balance;
        true
    }

    /// Returns the number of "stake" shares rounded down corresponding to the given staked balance
    /// amount.
    ///
    /// price = total_staked / total_shares
    /// Price is fixed
    /// (total_staked + amount) / (total_shares + num_shares) = total_staked / total_shares
    /// (total_staked + amount) * total_shares = total_staked * (total_shares + num_shares)
    /// amount * total_shares = total_staked * num_shares
    /// num_shares = amount * total_shares / total_staked
    fn num_shares_from_staked_amount_rounded_down(&self, amount: Balance) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        (U256::from(self.total_stake_shares) * U256::from(amount)
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the number of "stake" shares rounded up corresponding to the given staked balance
    /// amount.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    fn num_shares_from_staked_amount_rounded_up(&self, amount: Balance) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        ((U256::from(self.total_stake_shares) * U256::from(amount)
            + U256::from(self.total_staked_balance - 1))
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the staked amount rounded down corresponding to the given number of "stake" shares.
    fn staked_amount_from_num_shares_rounded_down(&self, num_shares: NumStakeShares) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        (U256::from(self.total_staked_balance) * U256::from(num_shares)
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Returns the staked amount rounded up corresponding to the given number of "stake" shares.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    fn staked_amount_from_num_shares_rounded_up(&self, num_shares: NumStakeShares) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        ((U256::from(self.total_staked_balance) * U256::from(num_shares)
            + U256::from(self.total_stake_shares - 1))
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Inner method to get the given account or a new default value account.
    fn get_account(&self, account_id: &AccountId) -> Account {
        self.accounts
            .get(&hash_account_id(account_id))
            .unwrap_or_default()
    }

    /// Inner method to get the save the given account for a given account ID.
    /// If the account balances are 0, the account is deleted instead to release storage.
    fn save_account(&mut self, account_id: &AccountId, account: &Account) {
        if account.unstaked > 0 || account.stake_shares > 0 {
            self.accounts.insert(&hash_account_id(account_id), &account);
        } else {
            self.accounts.remove(&hash_account_id(account_id));
        }
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::{testing_env, MockedBlockchain};

    use crate::test_utils::*;

    use super::*;
    use std::convert::TryFrom;

    struct Emulator {
        pub contract: StakingContract,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
    }

    fn zero_fee() -> RewardFeeFraction {
        RewardFeeFraction {
            numerator: 0,
            denominator: 1,
        }
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
            reward_fee_fraction: RewardFeeFraction,
        ) -> Self {
            testing_env!(VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish());
            let contract = StakingContract::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
                reward_fee_fraction,
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;
            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;
        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            testing_env!(VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_deposit_withdraw() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount
        );
        emulator.contract.withdraw(deposit_amount.into());
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            0u128
        );
    }

    #[test]
    fn test_stake_with_fee() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (+ 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        let expected_amount = deposit_amount
            + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
        );
        // Owner got 10% of the rewards
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (another 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);

        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
                + ntoy((yton(expected_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
        // owner earns 10% with the fee and also small percentage from restaking.
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
                + ntoy(10_000)
                + ntoy((10_000u128 * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount / 2
        );
        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    /// Test that two can delegate and then undelegate their funds and rewards at different time.
    #[test]
    fn test_two_delegates() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(alice(), ntoy(1_000_000));
        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(alice(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        emulator.skip_epochs(3);
        emulator.update_context(bob(), ntoy(1_000_000));

        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(bob(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_000_000)
        );
        emulator.skip_epochs(3);
        emulator.update_context(alice(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(alice()).0,
            ntoy(1_060_900) - 1
        );
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_030_000)
        );
    }

    #[test]
    fn test_low_balances() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = 100;
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = initial_balance;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(amount.into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }

    #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}

'''
'''--- staking-pool/src/test_utils.rs ---
use near_sdk::{AccountId, VMContext};
use near_sdk::{Balance, BlockHeight, EpochHeight};

pub fn staking() -> AccountId {
    "staking".to_string()
}

pub fn alice() -> AccountId {
    "alice".to_string()
}
pub fn bob() -> AccountId {
    "bob".to_string()
}
pub fn owner() -> AccountId {
    "owner".to_string()
}

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

/// Rounds to nearest
pub fn yton(yocto_amount: Balance) -> Balance {
    (yocto_amount + (5 * 10u128.pow(23))) / 10u128.pow(24)
}

#[macro_export]
macro_rules! assert_eq_in_near {
    ($a:expr, $b:expr) => {
        assert_eq!(yton($a), yton($b))
    };
    ($a:expr, $b:expr, $c:expr) => {
        assert_eq!(yton($a), yton($b), $c)
    };
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }
}

'''
'''--- staking-pool/test.sh ---
#!/bin/bash

./build.sh
cargo test
'''
'''--- staking-pool/tests/general.rs ---
mod utils;

use near_primitives::types::Balance;
use utils::{init_pool, ntoy, pool_account, wait_epoch, ExternalUser};
#[test]
fn multi_accounts_max_roundtrip() {
    struct AccountStake {
        pub account: ExternalUser,
        pub staked: Balance,
    };
    let initial_pool_balance = ntoy(100);
    let (ref mut runtime, ref root) = init_pool(initial_pool_balance);
    assert_eq!(
        pool_account(runtime).amount + pool_account(runtime).locked,
        initial_pool_balance
    );
    let mut accounts: Vec<AccountStake> = vec![];
    let mut to_spend = 1;
    let mut spent_total = 0;
    let mut acc_no = 0;
    loop {
        to_spend = to_spend * 2;

        acc_no += 1;
        let acc = if let Ok(acc) =
            root.create_external(runtime, format!("account_{}", acc_no), ntoy(30) + to_spend)
        {
            acc
        } else {
            break;
        };
        acc.pool_deposit(runtime, to_spend).unwrap();
        spent_total += to_spend;
        dbg!(spent_total);
        let pool_acc = runtime.view_account(&"pool".into()).unwrap();
        assert_eq!(
            pool_acc.amount + pool_acc.locked,
            initial_pool_balance + spent_total
        );
        acc.pool_stake(runtime, to_spend).unwrap();
        accounts.push(AccountStake {
            account: acc,
            staked: to_spend,
        });
    }

    for AccountStake { account, staked } in &accounts {
        account.pool_unstake(runtime, *staked).unwrap();
    }
    wait_epoch(runtime);
    runtime.produce_block().unwrap();
    for AccountStake { account, staked } in &accounts {
        account.pool_withdraw(runtime, *staked).unwrap();
        assert_eq!(
            account.account(runtime).amount,
            ntoy(30) + *staked,
            "Account: {:?}, staked: {:?}",
            account.account_id(),
            staked
        );
    }

    assert_eq!(
        pool_account(runtime).amount + pool_account(runtime).locked,
        initial_pool_balance
    );
}

'''
'''--- staking-pool/tests/quickcheck.rs ---
extern crate env_logger;
#[allow(unused_imports)]
#[macro_use]
extern crate log;
extern crate quickcheck;
#[macro_use(quickcheck)]
extern crate quickcheck_macros;
mod utils;

use near_primitives::types::{AccountId, Balance};
use near_sdk::json_types::U128;
use serde_json::json;
use utils::{call_pool, init_pool, ntoy, wait_epoch};

use near_runtime_standalone::RuntimeStandalone;

#[allow(dead_code)]
fn check_invariants(_runtime: &mut RuntimeStandalone, _users: &[AccountId]) {}

#[quickcheck]
fn qc_should_stake(initial_balance: Balance) -> bool {
    let (mut runtime, root) = init_pool(23 * 10u128.pow(24));
    let bob = root
        .create_external(&mut runtime, "bob".into(), ntoy(100))
        .unwrap();

    bob.pool_deposit(&mut runtime, initial_balance).unwrap();
    bob.pool_stake(&mut runtime, initial_balance).unwrap();
    let bob_stake: U128 = call_pool(
        &mut runtime,
        "get_account_staked_balance",
        json!({"account_id": "bob"}),
    );

    assert_eq!(bob_stake, initial_balance.into());

    bob.pool_unstake(&mut runtime, initial_balance).unwrap();
    wait_epoch(&mut runtime);
    runtime.produce_block().unwrap();
    let outcome = bob.pool_withdraw(&mut runtime, initial_balance);
    if let Err(outcome) = outcome {
        if initial_balance != 0 {
            panic!("{:?}", outcome);
        }
    };
    assert_eq!(bob.account(&mut runtime).amount, ntoy(100));
    return true;
}

#[quickcheck]
fn qc_test_deposit_withdraw_standalone(inital_balance: Balance) -> bool {
    let deposit_amount = ntoy(inital_balance);
    let (mut runtime, root) = init_pool(ntoy(100));
    let bob = root
        .create_external(&mut runtime, "bob".into(), ntoy(100))
        .unwrap();
    bob.pool_deposit(&mut runtime, deposit_amount).unwrap();
    let _res = bob.get_account_unstaked_balance(&runtime);

    assert_eq!(_res, deposit_amount);
    let outcome = bob.pool_withdraw(&mut runtime, deposit_amount);
    if let Err(outcome) = outcome {
        if deposit_amount != 0 {
            panic!("{:?}", outcome);
        }
    };
    bob.get_account_unstaked_balance(&runtime) == 0u128
}

'''
'''--- staking-pool/tests/utils.rs ---
#![allow(dead_code)]
extern crate staking_pool;

use near_crypto::{InMemorySigner, KeyType, Signer};
use near_primitives::{
    account::{AccessKey, Account},
    errors::{RuntimeError, TxExecutionError},
    hash::CryptoHash,
    transaction::{ExecutionOutcome, ExecutionStatus, Transaction},
    types::{AccountId, Balance},
};
use near_runtime_standalone::{init_runtime_and_signer, RuntimeStandalone};
use near_sdk::json_types::U128;
use serde::de::DeserializeOwned;
use serde_json::json;
use staking_pool::RewardFeeFraction;

pub const POOL_ACCOUNT_ID: &str = "pool";

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

lazy_static::lazy_static! {
    static ref POOL_WASM_BYTES: &'static [u8] = include_bytes!("../res/staking_pool.wasm").as_ref();
}

type TxResult = Result<ExecutionOutcome, ExecutionOutcome>;

fn outcome_into_result(outcome: ExecutionOutcome) -> TxResult {
    match outcome.status {
        ExecutionStatus::SuccessValue(_) => Ok(outcome),
        ExecutionStatus::Failure(_) => Err(outcome),
        ExecutionStatus::SuccessReceiptId(_) => panic!("Unresolved ExecutionOutcome run runitme.resolve(tx) to resolve the filnal outcome of tx"),
        ExecutionStatus::Unknown => unreachable!()
    }
}
pub struct ExternalUser {
    account_id: AccountId,
    signer: InMemorySigner,
}

impl ExternalUser {
    pub fn new(account_id: AccountId, signer: InMemorySigner) -> Self {
        Self { account_id, signer }
    }

    #[allow(dead_code)]
    pub fn account_id(&self) -> &AccountId {
        &self.account_id
    }

    #[allow(dead_code)]
    pub fn signer(&self) -> &InMemorySigner {
        &self.signer
    }

    pub fn account(&self, runtime: &mut RuntimeStandalone) -> Account {
        runtime
            .view_account(&self.account_id)
            .expect("Account should be there")
    }

    pub fn create_external(
        &self,
        runtime: &mut RuntimeStandalone,
        new_account_id: AccountId,
        amount: Balance,
    ) -> Result<ExternalUser, ExecutionOutcome> {
        let new_signer =
            InMemorySigner::from_seed(&new_account_id, KeyType::ED25519, &new_account_id);
        let tx = self
            .new_tx(runtime, new_account_id.clone())
            .create_account()
            .add_key(new_signer.public_key(), AccessKey::full_access())
            .transfer(amount)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx);

        // TODO: this temporary hack, must be rewritten
        if let Err(err) = res.clone() {
            if let RuntimeError::InvalidTxError(tx_err) = err {
                let mut out = ExecutionOutcome::default();
                out.status = ExecutionStatus::Failure(TxExecutionError::InvalidTxError(tx_err));
                return Err(out);
            } else {
                unreachable!();
            }
        } else {
            outcome_into_result(res.unwrap())?;
            runtime.process_all().unwrap();
            Ok(ExternalUser {
                account_id: new_account_id,
                signer: new_signer,
            })
        }
    }

    pub fn pool_init_new(
        &self,
        runtime: &mut RuntimeStandalone,
        amount: Balance,
        reward_fee_fraction: RewardFeeFraction,
    ) -> TxResult {
        let args = json!({
            "owner_id": self.account_id,
            "stake_public_key": "ed25519:3tysLvy7KGoE8pznUgXvSHa4vYyGvrDZFcT8jgb8PEQ6", // not relevant for now
            "reward_fee_fraction": reward_fee_fraction
        })
        .to_string()
        .as_bytes()
        .to_vec();

        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .create_account()
            .transfer(amount)
            .deploy_contract(POOL_WASM_BYTES.to_vec())
            .function_call("new".into(), args, 10000000000000000, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_deposit(&self, runtime: &mut RuntimeStandalone, amount: Balance) -> TxResult {
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("deposit".into(), vec![], 10000000000000000, amount)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_ping(&self, runtime: &mut RuntimeStandalone) -> TxResult {
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("ping".into(), vec![], 10000000000000000, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_stake(&self, runtime: &mut RuntimeStandalone, amount: u128) -> TxResult {
        let args = json!({ "amount": format!("{}", amount) })
            .to_string()
            .as_bytes()
            .to_vec();
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("stake".into(), args, 10000000000000000, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_unstake(&self, runtime: &mut RuntimeStandalone, amount: u128) -> TxResult {
        let args = json!({ "amount": format!("{}", amount) })
            .to_string()
            .as_bytes()
            .to_vec();
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("unstake".into(), args, 10000000000000000, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        let outcome_res = outcome_into_result(res);
        if outcome_res.is_ok() {
            wait_epoch(runtime);
            let total_stake: U128 = call_pool(runtime, "get_total_staked_balance", "");
            let mut pool_account = runtime.view_account(&POOL_ACCOUNT_ID.into()).unwrap();
            pool_account.amount += pool_account.locked - total_stake.0;
            pool_account.locked = total_stake.0;
            runtime.force_account_update(POOL_ACCOUNT_ID.into(), &pool_account);
        }
        outcome_res
    }

    pub fn pool_withdraw(&self, runtime: &mut RuntimeStandalone, amount: u128) -> TxResult {
        let args = json!({ "amount": format!("{}", amount) })
            .to_string()
            .as_bytes()
            .to_vec();
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("withdraw".into(), args, 10000000000000000, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    #[allow(dead_code)]
    pub fn pool_vote(&self, runtime: &mut RuntimeStandalone, amount: u128) -> TxResult {
        let args = json!({ "amount": format!("{}", amount) })
            .to_string()
            .as_bytes()
            .to_vec();
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("withdraw".into(), args, 10000000000000000, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    #[allow(dead_code)]
    pub fn get_account_staked_balance(&self, runtime: &RuntimeStandalone) -> Balance {
        let balance = runtime
            .view_method_call(
                &POOL_ACCOUNT_ID.into(),
                "get_account_staked_balance",
                json!({"account_id": self.account_id})
                    .to_string()
                    .as_bytes(),
            )
            .unwrap()
            .0;
        u128::from(serde_json::from_slice::<U128>(balance.as_slice()).unwrap())
    }

    pub fn get_account_unstaked_balance(&self, runtime: &RuntimeStandalone) -> Balance {
        let balance = runtime
            .view_method_call(
                &POOL_ACCOUNT_ID.into(),
                "get_account_unstaked_balance",
                json!({"account_id": self.account_id})
                    .to_string()
                    .as_bytes(),
            )
            .unwrap()
            .0;
        u128::from(serde_json::from_slice::<U128>(balance.as_slice()).unwrap())
    }

    fn new_tx(&self, runtime: &RuntimeStandalone, receiver_id: AccountId) -> Transaction {
        let nonce = runtime
            .view_access_key(&self.account_id, &self.signer.public_key())
            .unwrap()
            .nonce
            + 1;
        Transaction::new(
            self.account_id.clone(),
            self.signer.public_key(),
            receiver_id,
            nonce,
            CryptoHash::default(),
        )
    }
}

pub fn init_pool(initial_transfer: Balance) -> (RuntimeStandalone, ExternalUser) {
    let (mut runtime, signer) = init_runtime_and_signer(&"root".into());
    let root = ExternalUser::new("root".into(), signer);

    root.pool_init_new(
        &mut runtime,
        initial_transfer,
        RewardFeeFraction {
            numerator: 10,
            denominator: 100,
        },
    )
    .unwrap();
    return (runtime, root);
}

pub fn reward_pool(runtime: &mut RuntimeStandalone, amount: Balance) {
    let mut pool_account = runtime.view_account(&POOL_ACCOUNT_ID.into()).unwrap();
    pool_account.locked += amount;
    runtime.force_account_update(POOL_ACCOUNT_ID.into(), &pool_account);
}

pub fn wait_epoch(runtime: &mut RuntimeStandalone) {
    let epoch_height = runtime.current_block().epoch_height;
    while epoch_height == runtime.current_block().epoch_height {
        runtime.produce_block().unwrap();
    }
}

pub fn call_pool<I: ToString, O: DeserializeOwned>(
    runtime: &mut RuntimeStandalone,
    method: &str,
    args: I,
) -> O {
    call_view(runtime, &POOL_ACCOUNT_ID.into(), method, args)
}

pub fn pool_account(runtime: &mut RuntimeStandalone) -> Account {
    runtime.view_account(&POOL_ACCOUNT_ID.into()).unwrap()
}

fn call_view<I: ToString, O: DeserializeOwned>(
    runtime: &mut RuntimeStandalone,
    account_id: &AccountId,
    method: &str,
    args: I,
) -> O {
    let args = args.to_string();
    let result = runtime
        .view_method_call(account_id, method, args.as_bytes())
        .unwrap()
        .0;
    let output: O = serde_json::from_reader(result.as_slice()).unwrap();
    output
}

'''