*GitHub Repository "kuutamolabs/nixos-anywhere"*

'''--- .github/settings.yml ---
repository:
  # See https://developer.github.com/v3/repos/#edit for all available settings.

  # The name of the repository. Changing this will rename the repository
  name: nixos-anywhere

  # A short description of the repository that will show up on GitHub
  description: install nixos everywhere via ssh

  # A URL with more information about the repository
  homepage: https://numtide.github.io/nixos-anywhere

  # A comma-separated list of topics to set on the repository
  topics: ""

  # Either `true` to make the repository private, or `false` to make it public.
  private: false

  # Either `true` to enable issues for this repository, `false` to disable them.
  has_issues: true

  # Either `true` to enable projects for this repository, or `false` to disable them.
  # If projects are disabled for the organization, passing `true` will cause an API error.
  has_projects: true

  # Either `true` to enable the wiki for this repository, `false` to disable it.
  has_wiki: true

  # Either `true` to enable downloads for this repository, `false` to disable them.
  has_downloads: false

  # Updates the default branch for this repository.
  default_branch: main

  # Either `true` to allow squash-merging pull requests, or `false` to prevent
  # squash-merging.
  allow_squash_merge: true

  # Either `true` to allow merging pull requests with a merge commit, or `false`
  # to prevent merging pull requests with merge commits.
  allow_merge_commit: true

  # Either `true` to allow rebase-merging pull requests, or `false` to prevent
  # rebase-merging.
  allow_rebase_merge: true

  # Either `true` to enable automatic deletion of branches on merge, or `false` to disable
  delete_branch_on_merge: true

  # Either `true` to enable automated security fixes, or `false` to disable
  # automated security fixes.
  enable_automated_security_fixes: true

  # Either `true` to enable vulnerability alerts, or `false` to disable
  # vulnerability alerts.
  enable_vulnerability_alerts: true

# Labels: define labels for Issues and Pull Requests
#
labels:
# NOTE: leave that up to the https://github.com/numtide/.github repo
#   - name: bug
#     color: CC0000
#     description: An issue with the system üêõ.

#   - name: feature
#     # If including a `#`, make sure to wrap it with quotes!
#     color: '#336699'
#     description: New functionality.

#   - name: Help Wanted
#     # Provide a new name to rename an existing label
#     new_name: first-timers-only

# Milestones: define milestones for Issues and Pull Requests
milestones:
#   - title: milestone-title
#     description: milestone-description
#     # The state of the milestone. Either `open` or `closed`
#     state: open

# Collaborators: give specific users access to this repository.
# See https://docs.github.com/en/rest/reference/repos#add-a-repository-collaborator for available options
collaborators:
  # Note: `permission` is only valid on organization-owned repositories.
  # The permission to grant the collaborator. Can be one of:
  # * `pull` - can pull, but not push to or administer this repository.
  # * `push` - can pull and push, but not administer this repository.
  # * `admin` - can pull, push and administer this repository.
  # * `maintain` - Recommended for project managers who need to manage the repository without access to sensitive or destructive actions.
  # * `triage` - Recommended for contributors who need to proactively manage issues and pull requests without write access.
  - username: phaer
    permission: push
  - username: pogobanane
    permission: push

# See https://docs.github.com/en/rest/reference/teams#add-or-update-team-repository-permissions for available options
teams:
  - name: network
    # The permission to grant the team. Can be one of:
    # * `pull` - can pull, but not push to or administer this repository.
    # * `push` - can pull and push, but not administer this repository.
    # * `admin` - can pull, push and administer this repository.
    # * `maintain` - Recommended for project managers who need to manage the repository without access to sensitive or destructive actions.
    # * `triage` - Recommended for contributors who need to proactively manage issues and pull requests without write access.
    permission: maintain

branches:
  - name: main
    # https://docs.github.com/en/rest/reference/repos#update-branch-protection
    # Branch Protection settings. Set to null to disable
    protection:
      # Required. Require at least one approving review on a pull request, before merging. Set to null to disable.
      required_pull_request_reviews:
        # # The number of approvals required. (1-6)
        # required_approving_review_count: 1
        # # Dismiss approved reviews automatically when a new commit is pushed.
        # dismiss_stale_reviews: true
        # # Blocks merge until code owners have reviewed.
        # require_code_owner_reviews: true
        # # Specify which users and teams can dismiss pull request reviews. Pass an empty dismissal_restrictions object to disable. User and team dismissal_restrictions are only available for organization-owned repositories. Omit this parameter for personal repositories.
        # dismissal_restrictions:
        #   users: []
        #   teams: []
      # Required. Require status checks to pass before merging. Set to null to disable
      required_status_checks:
        # Required. Require branches to be up to date before merging.
        strict: true
        # Required. The list of status checks to require in order to merge into this branch
        contexts: [ "bors" ]
      # Required. Enforce all configured restrictions for administrators. Set to true to enforce required status checks for repository administrators. Set to null to disable.
      enforce_admins: false
      # Disabled for bors to work
      required_linear_history: false
      # Required. Restrict who can push to this branch. Team and user restrictions are only available for organization-owned repositories. Set to null to disable.
      restrictions:
        apps: [ "bors" ]
        users: []
        teams: []

'''
'''--- .github/workflows/gh-pages.yml ---
name: github pages

on:
  push:
    branches:
      - main
      - staging
  pull_request:

jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
    steps:
      - uses: actions/checkout@v3

      - uses: cachix/install-nix-action@v18

      - run: nix build .#docs

      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        if: ${{ github.ref == 'refs/heads/main' }}
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./result

'''
'''--- .mergify.yml ---
queue_rules:
  - name: default
    merge_conditions:
      - check-success=buildbot/nix-eval
defaults:
  actions:
    queue:
      allow_merging_configuration_change: true
      method: rebase
pull_request_rules:
  - name: merge using the merge queue
    conditions:
      - base=main
      - label~=merge-queue|dependencies
    actions:
      queue: {}

'''
'''--- CONTRIBUTING.md ---
To run `nixos-anywhere` from the repo:

```console
nix run . -- --help
```

To format the code:

```console
nix fmt
```

To run all tests:

```console
nix flake check -vL
```

To run an individual test:

```
nix build .#checks.x86_64-linux.from-nixos -vL
```

'''
'''--- README.md ---
# nixos-anywhere

**_Install NixOS everywhere via ssh_**

<img src="https://raw.githubusercontent.com/nix-community/nixos-anywhere/main/docs/logo.png" width="150" height="150">

[Documentation Index](docs/INDEX.md)

## README

Setting up a new machine is time-consuming, and becomes complicated when it
needs to be done remotely. If you're installing NixOS, the **nixos-anywhere**
tool allows you to pre-configure the whole process including:

- Disk partitioning and formatting
- Configuring and installing NixOS
- Installing additional files and software

You can then initiate an unattended installation with a single CLI command.
Since **nixos-anywhere** can access the new machine using SSH, it's ideal for
remote installations.

Once you have initiated the command, there is no need to 'babysit' the
installation. It all happens automatically.

You can use the stored configuration to repeat the same installation if you need
to.

## Overview

If you have machines on a mix of platforms, you'll need a common installation
solution that works anywhere. **nixos-anywhere** is ideal in this situation.

**nixos-anywhere** can be used equally well for cloud servers, bare metal
servers such as Hetzner, and local servers accessible via a LAN. You can create
standard configurations, and use the same configuration to create identical
servers anywhere.

You first create Nix configurations to specify partitioning, formatting and
NixOS configurations. Further options can be controlled by a flake and by
run-time switches.

Once the configuration has been created, a single command will:

- Connect to the remote server via SSH
- Detect whether a NixOS installer is present; if not, it will use the Linux
  `kexec` tool to boot into a Nixos installer.
- Use the [disko](https://github.com/nix-community/disko) tool to partition and
  format the hard drive
- Install NixOS
- Optionally install any Nix packages and other software required.
- Optionally copy additional files to the new machine

It's also possible to use **nixos-anywhere** to simplify the installation on a
machine that has no current operating system, first booting from a NixOS
installer image. This feature is described in the
[how-to guide](./docs/howtos/no-os.md#installing-on-a-machine-with-no-operating-system).
It's useful because you can pre-configure your required software and
preferences, and build the new machine with a single command.

**Important Note:** Never use a production server as the target. It will be
completely overwritten and all data lost. This tool should only be used for
commissioning a new computer or repurposing an old machine once all important
data has been migrated.

## Prerequisites

- Source Machine:

  - Can be any machine¬†with Nix installed, e.g. a NixOS machine.
  - Should be able to build nix derivations for the target platform. Otherwise
    `--build-on-remote` can be used.

- Target Machine:

  - Unless you're using the option to boot from a NixOS installer image, or
    providing your own `kexec` image, it must be running x86-64 Linux with kexec
    support. Most `x86_64` Linux systems do have kexec support. By providing
    your own [image](./docs/howtos/custom-kexec.md#using-your-own-kexec-image)
    you can also perform kexec for other architectures eg aarch64
  - The machine must be reachable over the public internet or local network.
    Nixos-anywhere does not support wifi networks. If a VPN is needed, define a
    custom installer via the --kexec flag which connects to your VPN.
  - Must have at least 1.5 GB of RAM, excluding swap.

## How to use nixos-anywhere

The [Quickstart Guide](./docs/quickstart.md) gives more information on how to
run **nixos-anywhere** in its simplest form. For more specific instructions to
suit individual requirements, see the [How To Guide](./docs/howtos/INDEX.md).

## Related Tools

**nixos-anywhere** makes use of the
[disko](https://github.com/nix-community/disko) tool to handle the partitioning
and formatting of the disks.

## Contact

For questions, come join us in the
[nixos-anywhere](https://matrix.to/#/#nixos-anywhere:nixos.org) matrix room.

## Licensing and Contribution details

This software is provided free under the
[MIT Licence](https://opensource.org/licenses/MIT).

---

This project is supported by [Numtide](https://numtide.com/).
![Untitledpng](https://codahosted.io/docs/6FCIMTRM0p/blobs/bl-sgSunaXYWX/077f3f9d7d76d6a228a937afa0658292584dedb5b852a8ca370b6c61dabb7872b7f617e603f1793928dc5410c74b3e77af21a89e435fa71a681a868d21fd1f599dd10a647dd855e14043979f1df7956f67c3260c0442e24b34662307204b83ea34de929d)

We are a team of independent freelancers that love open source. ¬†We help our
customers make their project lifecycles more efficient by:

- Providing and supporting useful tools such as this one
- Building and deploying infrastructure, and offering dedicated DevOps support
- Building their in-house Nix skills, and integrating Nix with their workflows
- Developing additional features and tools
- Carrying out custom research and development.

[Contact us](https://numtide.com/contact) if you have a project in mind, or if
you need help with any of our supported tools, including this one. We'd love to
hear from you.

'''
'''--- docs/INDEX.md ---
# Table of Content: - nixos-anywhere

**_Install NixOS everywhere via ssh_**

<img title="" src="https://raw.githubusercontent.com/nix-community/nixos-anywhere/main/docs/logo.png" alt="" width="149">

- [README](../README.md)
- [Quickstart](./quickstart.md)
- [System Requirements](./requirements.md)
- [How to Guide](./howtos/INDEX.md)
- [Reference](./reference.md)

'''
'''--- docs/SUMMARY.md ---
# Summary: - nixos-anywhere

**_Install NixOS everywhere via ssh_**

<img title="" src="https://raw.githubusercontent.com/nix-community/nixos-anywhere/main/docs/logo.png" alt="" width="149">

The **nixos-anywhere** tool allows you to pre-configure the whole process of
installing NixOS, and run the install remotely with a single CLI command.

Refer to the following documentation for more information.

[System Requirements](./requirements.md): CPU and memory requirements

[Quickstart](./quickstart.md): Instructions for a typical installation

[How to Guide](./howtos/INDEX.md): Instructions for non-typical use cases

- [Installing on a machine with no operating system](./howtos/no-os.md)
- [Using your own kexec image](./howtos/custom-kexec.md)
- [Secrets and full disk encryption](./howtos/secrets.md)
- [Use without flakes](./howtos/use-without-flakes.md)
- [Terraform](./howtos/terraform.md)
- [Nix-channels / `NIX_PATH`](./howtos/nix-path.md)
- [IPv6-only targets](./howtos/ipv6.md)

[Reference](./reference.md): Reference Guide

'''
'''--- docs/book.toml ---
[book]
authors = [ ]
language = "en"
multilingual = false
src = "."
title = "nixos-anywhere - install NixOS everywhere"

'''
'''--- docs/cli.md ---
# CLI

```
Usage: nixos-anywhere [options] ssh-host

Options:

* -f, --flake flake
  set the flake to install the system from
* -s, --store-paths
  set the store paths to the disko-script and nixos-system directly
  if this is give, flake is not needed
* --kexec url
  use another kexec tarball to bootstrap NixOS
* --debug
  enable debug output
```

'''
'''--- docs/howtos.md ---
# How to Guide

'''
'''--- docs/howtos/INDEX.md ---
# How To Guide: nixos-anywhere

**_Install NixOS everywhere via ssh_**

<img title="" src="https://raw.githubusercontent.com/nix-community/nixos-anywhere/main/docs/logo.png" alt="" width="129">

[Documentation Index](./INDEX.md)

## Contents

[Installing on a machine with no operating system](./no-os.md)

[Using your own kexec image](./custom-kexec.md)

[Secrets and full disk encryption](./secrets.md)

[Use without flakes](./use-without-flakes.md)

[Terraform](./terraform.md)

[Nix-channels / `NIX_PATH`](./nix-path.md)

[IPv6-only targets](./ipv6.md)

'''
'''--- docs/howtos/custom-kexec.md ---
# Using your own kexec image

By default, `nixos-anywhere` downloads the kexec image from the
[NixOS images repository](https://github.com/nix-community/nixos-images#kexec-tarballs).

However, you can provide your own `kexec` image file if you need to use a
different one. This is particularly useful for architectures other than `x86_64`
and `aarch64`, since they don't have a pre-build image.

To do this, use the `--kexec` command line switch followed by the path to your
image file. The image will be uploaded prior to execution.

Here's an example command that demonstrates how to use a custom kexec image with
`nixos-anywhere`:

```
nix run github:nix-community/nixos-anywhere -- \
  --kexec "$(nix build --print-out-paths github:nix-community/nixos-images#packages.aarch64-linux.kexec-installer-nixos-unstable-noninteractive)/nixos-kexec-installer-noninteractive-aarch64-linux.tar.gz" \
  --flake 'github:your-user/your-repo#your-system' \
  root@yourip
```

Make sure to replace `github:your-user/your-repo#your-system` with the
appropriate Flake URL representing your NixOS configuration.

The example above assumes that your local machine can build for aarch64 in one
of the following ways:

- Natively

- Through a remote builder

- By emulating the architecture with qemu using the following NixOS
  configuration:

```nix
{
  boot.binfmt.emulatedSystems = [ "aarch64-linux" ];
}
```

'''
'''--- docs/howtos/ipv6.md ---
# NixOS-anywhere on IPv6-only targets

As GitHub engineers still haven't enabled the IPv6 switch, the kexec image
hosted on GitHub, cannot be used unfortunately on IPv6-only hosts. However it is
possible to use an IPv6 proxy for GitHub content like that:

```
nixos-anywhere \
  --kexec https://gh-v6.com/nix-community/nixos-images/releases/download/nixos-unstable/nixos-kexec-installer-noninteractive-x86_64-linux.tar.gz \
...
```

This proxy is hosted by [numtide](https://numtide.com/). It also works for IPv4.

Alternatively it is also possible to reference a local file:

```
nixos-anywhere \
  --kexec ./nixos-kexec-installer-noninteractive-x86_64-linux.tar.gz \
...
```

This tarball will be then uploaded via sftp to the target.

'''
'''--- docs/howtos/nix-path.md ---
# Nix-channels / `NIX_PATH`

nixos-anywhere does not install channels onto the new system by default to save
time and disk space. This for example results in errors like:

```
(stack trace truncated; use '--show-trace' to show the full trace)

error: file 'nixpkgs' was not found in the Nix search path (add it using $NIX_PATH or -I)

at ¬´none¬ª:0: (source not available)
```

when using tools like nix-shell/nix-env that rely on `NIX_PATH` beeing set.

# Solution 1: Set the `NIX_PATH` via nixos configuration (recommended)

Instead of stateful channels, one can also populate the `NIX_PATH` using nixos
configuration instead:

```nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
  # ... other inputs

  outputs = { nixpkgs, ... }:
    {
      nixosConfigurations.yoursystem = nixpkgs.lib.nixosSystem {
        system = "x86_64-linux"; # adapt to your actual system
        modules = [
          # This line will populate NIX_PATH
          { nix.nixPath = [ "nixpkgs=${inputs.nixpkgs}" ]; }
          # ... other modules and your configuration.nix
        ];
      };
    };
}
```

Advantage: This solution will be automatically kept up-to-date everytime the
flake is updated.

In your shell you will see something in your `$NIX_PATH`:

```shellSession
$ echo $NIX_PATH
/root/.nix-defexpr/channels:nixpkgs=/nix/store/8b61j28rpy11dg8hanbs2x710d8w3v0d-source
```

# Solution 2: Manually add the channel

On the installed machine, run:

```shellSession
$ nix-channel --add https://nixos.org/channels/nixos-unstable nixos
$ nix-channel --update
```

'''
'''--- docs/howtos/no-os.md ---
# Installing on a machine with no operating system

If your machine doesn't currently have an operating system installed, you can
still run `nixos-anywhere` remotely to automate the install. To do this, you
would first need to boot the target machine from the standard NixOS installer.
You can either boot from a USB or use `netboot`.

The
[NixOS installation guide](https://nixos.org/manual/nixos/stable/index.html#sec-booting-from-usb)
has detailed instructions on how to boot the installer.

When you run `nixos-anywhere`, it will determine whether a NixOS installer is
present by checking whether the `/etc/os-release` file contains the identifier
`VARIANT=installer`. This identifier is available on releases NixOS 23.05 or
later.

If an installer is detected, `nixos-anywhere` will not attempt to `kexec` into
its own image. This is particularly useful for targets that don't have enough
RAM for `kexec` or don't support `kexec`.

NixOS starts an SSH server on the installer by default, but you need to set a
password in order to access it. To set a password for the `nixos` user, run the
following command in a terminal on the NixOS machine:

```
passwd
```

If you don't know the IP address of the installer on your network, you can find
it by running the following command:

```
$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff
    altname enp0s3
    altname ens3
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute eth0
       valid_lft 86385sec preferred_lft 75585sec
    inet6 fec0::5054:ff:fe12:3456/64 scope site dynamic mngtmpaddr noprefixroute
       valid_lft 86385sec preferred_lft 14385sec
    inet6 fe80::5054:ff:fe12:3456/64 scope link
       valid_lft forever preferred_lft forever
```

This will display the IP addresses assigned to your network interface(s),
including the IP address of the installer. In the example output below, the
installer's IP addresses are `10.0.2.15`, `fec0::5054:ff:fe12:3456`, and
`fe80::5054:ff:fe12:3456%eth0`:

To test if you can connect and your password works, you can use the following
SSH command (replace the IP address with your own):

```
ssh -v nixos@fec0::5054:ff:fe12:3456
```

You can then use the IP address to run `nixos-anywhere` like this:

```
nix run github:nix-community/nixos-anywhere -- --flake '.#myconfig' nixos@fec0::5054:ff:fe12:3456
```

This example assumes a flake in the current directory containing a configuration
named `myconfig`.

'''
'''--- docs/howtos/secrets.md ---
# Secrets and full disk encryption

The `nixos-anywhere` utility offers the capability to install secrets onto a
target machine. This feature is particularly beneficial when you want to
bootstrap secrets management tools such as
[sops-nix](https://github.com/Mic92/sops-nix) or
[agenix](https://github.com/ryantm/agenix), which rely on machine-specific
secrets to decrypt other uploaded secrets.

## Example: Decrypting an OpenSSH Host Key with pass

In this example, we demonstrate how to use a script to decrypt an OpenSSH host
key from the `pass` password manager and subsequently pass it to
`nixos-anywhere` during the installation process:

```bash
#!/usr/bin/env bash

# Create a temporary directory
temp=$(mktemp -d)

# Function to cleanup temporary directory on exit
cleanup() {
  rm -rf "$temp"
}
trap cleanup EXIT

# Create the directory where sshd expects to find the host keys
install -d -m755 "$temp/etc/ssh"

# Decrypt your private key from the password store and copy it to the temporary directory
pass ssh_host_ed25519_key > "$temp/etc/ssh/ssh_host_ed25519_key"

# Set the correct permissions so sshd will accept the key
chmod 600 "$temp/etc/ssh/ssh_host_ed25519_key"

# Install NixOS to the host system with our secrets
nixos-anywhere --extra-files "$temp" --flake '.#your-host' root@yourip
```

## Example: Uploading Disk Encryption Secrets

In a similar vein, `nixos-anywhere` can upload disk encryption secrets, which
are necessary during formatting with disko. Here's an example that demonstrates
how to provide your disk encryption password as a file or via the `pass` utility
to `nixos-anywhere`:

```bash
# Write your disk encryption password to a file
echo "my-super-safe-password" > /tmp/disk-1.key

# Call nixos-anywhere with disk encryption keys
nixos-anywhere \
  --disk-encryption-keys /tmp/disk-1.key /tmp/disk-1.key \
  --disk-encryption-keys /tmp/disk-2.key <(pass my-disk-encryption-password) \
  --flake '.#your-host' \
  root@yourip
```

In the above example, replace `"my-super-safe-password"` with your actual
encryption password, and `my-disk-encryption-password` with the relevant entry
in your pass password store. Also, ensure to replace `'.#your-host'` and
`root@yourip` with your actual flake and IP address, respectively.

## Example: Using existing SSH host keys

If the system contains existing trusted `/etc/ssh/ssh_host_*` SSH host keys and
certificates, `nixos-anywhere` can copy them in case they are necessary during
installation and system activation.

```
nixos-anywhere --copy-host-keys --flake '.#your-host' root@yourip
```

This would copy `/etc/ssh/ssh_host_*` to `/mnt` after kexec but before
installation, ignoring files that already exist in destination.

'''
'''--- docs/howtos/terraform.md ---
# Terraform

The nixos-anywhere terraform modules allow you to use Terraform for installing
and updating NixOS. It simplifies the deployment process by integrating
nixos-anywhere functionality.

Our terraform module requires the
[null](https://registry.terraform.io/providers/hashicorp/null/latest) and
[external](https://registry.terraform.io/providers/hashicorp/external/latest)
provider.

You can get these by from nixpkgs like this:

```nix
nix-shell -p '(pkgs.terraform.withPlugins (p: [ p.null p.external ]))'
```

You can add this expression the `packages` list in your devshell in flake.nix or
in shell.nix.

Checkout out the
[module reference](https://github.com/nix-community/nixos-anywhere/tree/main/terraform)
for examples and module parameter on how to use the modules.

'''
'''--- docs/howtos/use-without-flakes.md ---
# Use without flakes

While `nixos-anywhere` is designed to work optimally with Nix Flakes, it also
supports the traditional approach without flakes. This document outlines how to
use `nixos-anywhere` without relying on flakes. You will need to
[import the disko nixos module](https://github.com/nix-community/disko/blob/master/docs/HowTo.md#installing-nixos-module)
in your NixOS configuration and define disko devices as described in the
[examples](https://github.com/nix-community/disko/tree/master/example).

## Generate Required Store Paths

Before you can use `nixos-anywhere` without flakes, you'll need to manually
generate the paths for the NixOS system toplevel and disk image. The paths are
generated using `nix-build` and are necessary for executing `nixos-anywhere`.

### Generating NixOS System Toplevel:

Execute the following command to generate the store path for the NixOS system
toplevel:

```bash
nix-build -I nixos-config=/etc/nixos/configuration.nix -E '(import <nixpkgs/nixos> {}).config.system.build.toplevel'
```

This will output a path in `/nix/store` that corresponds to the system toplevel,
which includes all the software and configurations for the system. Make note of
this path for later use.

### Generating Disk Image without Dependencies:

To generate the disk image without dependencies, execute:

```bash
nix-build -I nixos-config=/etc/nixos/configuration.nix -E '(import <nixpkgs/nixos> {}).config.system.build.diskoNoDeps'
```

This will also output a script path in `/nix/store` that will format your disk.
Keep this path handy as well.

## Running NixOS-Anywhere

With both paths in hand, you can execute `nixos-anywhere` as follows:

```bash
nixos-anywhere --store-paths /nix/store/[your-toplevel-path] /nix/store/[your-disk-image-path]
```

Replace `[your-toplevel-path]` and `[your-disk-image-path]` with the
corresponding store paths you generated earlier.

'''
'''--- docs/logo.svg ---
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   version="1.1"
   width="512"
   height="512"
   id="svg322"
   sodipodi:docname="logo.svg"
   inkscape:version="1.2.2 (b0a8486541, 2022-12-01)"
   inkscape:export-filename="logo.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:cc="http://creativecommons.org/ns#">
  <defs
     id="defs326">
    <marker
       markerWidth="512"
       markerHeight="512"
       refX="256"
       refY="256"
       orient="auto"
       id="marker11007">
      <path
         d="M 0,0 H 512 V 512 H 0 Z"
         fill="#fbfdfc"
         id="path246" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="namedview324"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="1"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="false"
     inkscape:zoom="2.2304247"
     inkscape:cx="32.280848"
     inkscape:cy="129.79591"
     inkscape:window-width="3840"
     inkscape:window-height="2090"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg322" />
  <path
     d="M0,0 L4,2 L18,10 L27,18 L30,26 L30,34 L27,46 L23,60 L17,73 L8,94 L3,105 L3,116 L7,119 L13,121 L39,126 L55,131 L64,137 L68,142 L70,146 L70,154 L66,162 L57,170 L45,176 L37,179 L20,182 L11,183 L-17,184 L-24,192 L-34,206 L-47,221 L-59,232 L-73,241 L-85,246 L-93,248 L-113,248 L-127,245 L-132,243 L-132,241 L-123,235 L-113,226 L-105,218 L-96,205 L-88,189 L-82,168 L-80,136 L-72,125 L-54,98 L-38,71 L-23,44 L-13,25 L-5,9 Z "
     fill="#517ED0"
     transform="translate(435,104)"
     id="path248" />
  <path
     d="M0,0 L10,1 L19,6 L31,17 L40,26 L49,37 L57,48 L67,62 L75,74 L91,75 L107,78 L127,85 L141,93 L153,105 L160,115 L167,130 L170,139 L171,149 L162,146 L155,143 L138,139 L110,139 L93,143 L87,146 L80,146 L71,144 L57,142 L22,140 L-23,140 L-45,141 L-65,143 L-74,143 L-81,135 L-83,129 L-83,117 L-79,109 L-73,102 L-63,95 L-46,87 L-28,82 L-11,79 L14,79 L11,71 L-2,48 L-10,34 L-14,23 L-14,13 L-11,7 L-5,2 Z "
     fill="#517DD0"
     transform="translate(132,13)"
     id="path250" />
  <path
     d="M0,0 L11,2 L20,5 L29,7 L55,7 L72,4 L80,2 L104,7 L126,9 L142,10 L234,10 L240,14 L245,20 L246,24 L246,33 L241,43 L234,50 L221,58 L205,65 L183,70 L162,73 L151,73 L159,87 L174,112 L179,122 L180,125 L180,136 L175,145 L167,150 L153,150 L143,143 L130,130 L117,113 L107,99 L95,80 L90,76 L71,74 L50,69 L34,62 L23,54 L15,46 L8,34 L2,17 L0,7 Z "
     fill="#4DB0CE"
     transform="translate(213,350)"
     id="path252" />
  <path
     d="M0,0 L2,0 L7,17 L12,30 L21,45 L31,57 L39,64 L46,71 L47,73 L49,89 L54,107 L60,122 L72,147 L83,167 L99,191 L113,212 L117,220 L117,234 L114,240 L111,243 L80,243 L63,231 L50,219 L38,207 L31,199 L30,196 L27,196 L25,200 L11,215 L2,224 L-9,230 L-13,231 L-21,231 L-27,227 L-32,221 L-36,210 L-36,203 L-28,186 L-22,174 L-17,159 L-13,141 L-12,131 L-12,99 L-16,64 L-18,49 L-18,34 L-15,24 L-8,11 Z "
     fill="#517ED0"
     transform="translate(158,269)"
     id="path256" />
  <path
     d="M0,0 L12,1 L28,8 L40,16 L50,24 L65,37 L75,48 L77,51 L79,51 L89,37 L98,27 L107,18 L117,14 L126,14 L134,19 L139,25 L142,32 L142,40 L137,54 L128,74 L123,88 L118,109 L117,117 L117,147 L121,169 L124,181 L124,200 L120,211 L111,225 L106,229 L100,214 L92,199 L80,183 L70,173 L64,168 L62,153 L57,139 L49,123 L34,97 L21,75 L6,53 L-6,36 L-12,26 L-13,23 L-13,11 L-9,5 L-4,1 Z "
     fill="#4EB0CF"
     transform="translate(246,0)"
     id="path258" />
  <path
     d="M0,0 L6,0 L6,2 L11,1 L22,1 L32,6 L41,8 L53,8 L60,16 L62,17 L61,22 L56,28 L54,33 L54,43 L58,45 L58,48 L52,47 L46,42 L46,40 L30,45 L24,53 L24,61 L25,62 L31,62 L35,58 L39,59 L41,62 L43,71 L44,72 L50,72 L53,80 L53,82 L61,80 L65,78 L70,78 L72,80 L82,79 L92,84 L103,95 L106,98 L108,99 L117,100 L123,105 L123,114 L118,128 L110,142 L99,156 L88,165 L77,173 L60,180 L55,180 L56,176 L65,170 L67,166 L67,151 L72,144 L73,141 L73,134 L69,129 L65,127 L55,126 L47,116 L45,112 L45,102 L49,97 L55,94 L55,87 L49,83 L44,78 L34,72 L18,64 L11,58 L4,42 L0,35 L1,26 L2,19 L-2,16 L-8,13 L-9,12 L-9,6 L-6,2 Z "
     fill="#4D99CF"
     transform="translate(223,166)"
     id="path260" />
  <path
     d="M0,0 L9,0 L20,8 L36,14 L44,17 L46,20 L46,27 L42,33 L42,44 L47,49 L46,52 L39,52 L25,46 L15,37 L6,27 L0,17 L-3,10 L-2,2 Z "
     fill="#4FABD1"
     transform="translate(176,284)"
     id="path262"
     style="fill:#4d99cf;fill-opacity:1" />
  <path
     d="M0,0 L14,0 L23,1 L29,5 L30,6 L30,11 L25,10 L24,9 L24,4 L-1,4 Z "
     fill="#438ED7"
     transform="translate(247,157)"
     id="path266" />
  <path
     id="path268"
     transform="translate(203,179)"
     d="m 0,0 3,1 1,8 h 8 v 4 l -2,1 H 2 L -2,9 V 2 Z"
     style="fill:#4d99cf;fill-opacity:1" />
  <path
     id="path288"
     transform="translate(278,222)"
     d="M 0,0 6,1 7,4 9,5 H 2 L -1,3 Z m 0,0 6,1 6,2 8,1 V 7 H 7 L 0,4 Z"
     style="fill:#4d99cf;fill-opacity:1" />
  <path
     d="M0,0 L3,1 L-7,8 L-9,8 L-9,6 L-5,5 L-4,2 Z "
     fill="#6184C5"
     transform="translate(371,336)"
     id="path304"
     style="fill:#517ed0;fill-opacity:1" />
  <path
     id="path314"
     style="fill:#4eb0cf;fill-opacity:1"
     transform="translate(113,201)"
     d="M 0,0 H 2 L 0,4 -2.8602037,5.4301018 -4,6 V 8 L -6,7 Z m 48,-40 h 25 l 14,3 4,2 -1,3 -10,8 -10,11 -9,14 -7,14 -5,17 -2,11 -1,15 -8,10 -12,21 -11,19 -6,10 -11,19 -12,22 -11,21 -9,20 -5,1 -10,-5 -8,-4 -4,-6 -1,-3 v -18 l 6,-26 5,-13 5,-12 6,-13 2,-5 v -6 l -5,-3 -29,-4 -18,-6 -10,-6 -5,-5 -2,-4 V 50 l 7,-8 10,-7 18,-6 10,-2 10,-1 18.016033,-0.600534 L -22,25 l 5,-5 8,-9 7,-9 8,-10 9,-10 9,-9 10,-7 8,-4 z" />
  <metadata
     id="metadata148">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <cc:license
           rdf:resource="http://creativecommons.org/publicdomain/zero/1.0/" />
      </cc:Work>
      <cc:License
         rdf:about="http://creativecommons.org/publicdomain/zero/1.0/">
        <cc:permits
           rdf:resource="http://creativecommons.org/ns#Reproduction" />
        <cc:permits
           rdf:resource="http://creativecommons.org/ns#Distribution" />
        <cc:permits
           rdf:resource="http://creativecommons.org/ns#DerivativeWorks" />
      </cc:License>
    </rdf:RDF>
  </metadata>
</svg>

'''
'''--- docs/quickstart.md ---
# Quickstart Guide: nixos-anywhere

**_Install NixOS everywhere via ssh_**

<img src="https://raw.githubusercontent.com/nix-community/nixos-anywhere/main/docs/logo.png" width="150" height="150">

[Documentation Index](./INDEX.md)

## Introduction

This guide documents a simple installation of NixOS using **nixos-anywhere** on
a target machine running x86_64 Linux with
[kexec](https://man7.org/linux/man-pages/man8/kexec.8.html) support. The example
used in this guide installs NixOS on a Hetzner cloud machine. The configuration
may be different for some other instances. We will be including further examples
in the [How To Guide](./howtos/INDEX.md) as and when they are available.

You will need:

- A [flake](https://nixos.wiki/wiki/Flakes) that controls the actions to be
  performed
- A disk configuration containing details of the file system that will be
  created on the new server.
- A target machine, reachable via SSH, with your SSH public key deployed and and
  the privilege to either login directly as root or to use password-less sudo.

**nixos-anywhere** doesn‚Äôt need to be installed. You can run it directly from
[Numtide's repository on Github.](https://github.com/nix-community/nixos-anywhere)

Details of the flake, the disk configuration and the CLI command are discussed
below.

## Steps required to run nixos-anywhere

1. **Enable Flakes**:

   Ensure that flakes are enabled on your system. To enable flakes, refer to the
   [NixOS Wiki](https://nixos.wiki/wiki/Flakes#enable-flakes).

2. **Initialize a Flake**:

   The easiest way to start is to copy our
   [example flake.nix](https://github.com/nix-community/nixos-anywhere-examples/blob/main/flake.nix)
   into a new directory. This example is tailored for a virtual machine setup
   similar to one on [Hetzner Cloud](https://www.hetzner.com/cloud), so you
   might need to adapt it for your setup.

   **Hardware-Specific Configuration**: If you're not using a virtual machine,
   you'll need to generate a custom hardware configuration with
   `nixos-generate-config`.

- **Get `nixos-generate-config` onto the Target Machine**:

  1. **Option 1**: If NixOS is not installed, boot into an installer without
     first installing NixOS.
  2. **Option 2**: Use the kexec tarball method, as described
     [here](https://github.com/nix-community/nixos-images#kexec-tarballs).

- **Generate Configuration**: Run the following command on the target machine:

  ```bash
  nixos-generate-config --no-filesystems --root /mnt
  ```

  This creates the necessary configuration files under `/mnt/etc/nixos/`, which
  you can then customize as needed and copy them to your local machine in order
  to include them in your flake.

3. **Find SSH Key Line**:\
   if you cloned
   [our nixos-anywhere-example](https://github.com/nix-community/nixos-anywhere-examples/blob/main/configuration.nix)
   you will also replace the SSH key like this: In your configuration, locate
   the line that reads:

   ```bash
   # change this to your ssh key
               "CHANGE"
   ```

   Replace the text `CHANGE` with your own SSH key. This is crucial, as you will
   not be able to log into the target machine post-installation without it.

4. In the same directory, create a file named `disk-config.nix`. This will be
   used to specify the disk layout to the **disko** tool, which nixos-anywhere
   uses to partition, format and mount the disks. Again, for a simple
   installation you can paste the contents from the example
   [here](https://github.com/nix-community/nixos-anywhere-examples/blob/main/disk-config.nix).
   This configures a standard GPT (GUID Partition Table) partition compatible
   with both EFI and BIOS systems, and mounts the disk as `/dev/sda`. If this
   doesn‚Äôt meet your requirements, choose an example that suits your disk layout
   from the
   [disko examples](https://github.com/nix-community/disko/tree/master/example).
   For more information about this configuration, refer to the
   [disko documentation.](https://github.com/nix-community/disko)

5. Run the following command to create the `flake.lock` file:

   ```
   nix flake lock
   ```

   Optionally, you can commit these files to a repo such as Github, or you can
   simply reference your local directory when you run **nixos-anywhere**. This
   example uses a local directory on the source machine.

6. On the target machine, make sure you have access as root via ssh by adding
   your SSH key to the file `authorized_keys` in the directory `/root/.ssh`

7. (Optional) Test your nixos and disko configuration:

   The following command will automatically test your nixos configuration and
   run disko inside a virtual machine, where

   - `<path to configuration>` is the path to the directory or repository
     containing `flake.nix` and `disk-config.nix`

   - `<configuration name>` must match the name that immediately follows the
     text `nixosConfigurations.` in the flake, as indicated by the comment in
     the
     [example](https://github.com/nix-community/nixos-anywhere-examples/blob/main/flake.nix)).

   ```
   nix run github:nix-community/nixos-anywhere -- --flake <path to configuration>#<configuration name> --vm-test
   ```

8. You can now run **nixos-anywhere** from the command line as shown below,
   where:

   - `<path to configuration>` is the path to the directory or repository
     containing `flake.nix` and `disk-config.nix`

   - `<configuration name>` must match the name that immediately follows the
     text `nixosConfigurations.` in the flake, as indicated by the comment in
     the
     [example](https://github.com/nix-community/nixos-anywhere-examples/blob/main/flake.nix)).

   - `<ip address>` is the IP address of the target machine.

     ```
     nix run github:nix-community/nixos-anywhere -- --flake <path to configuration>#<configuration name> root@<ip address>
     ```

     The command would look ¬†like this if you had created your files in a
     directory named `/home/mydir/test` and the IP address of your target
     machine is `37.27.18.135`:

     ```
     nix run github:nix-community/nixos-anywhere -- --flake /home/mydir/test#hetzner-cloud root@37.27.18.135
     ```

     **nixos-anywhere** will then run, showing various output messages at each
     stage. It may take some time to complete, depending on Internet speeds. It
     should finish by showing the messages below before returning to the command
     prompt.

     ```
     Installation finished. No error reported.
     Warning: Permanently added '<ip-address>' (ED25519) to the list of known hosts
     ```

     When this happens, the target server will have been overwritten with a new
     installation of NixOS. Note that the server's public SSH key will have
     changed.

     If you have previously accessed this server using SSH, you may see the
     following message the next time you try to log in to the target.

     ```
     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     @    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
     Someone could be eavesdropping on you right now (man-in-the-middle attack)!
     It is also possible that a host key has just been changed.
     The fingerprint for the ED25519 key sent by the remote host is
     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.
     Please contact your system administrator.
     Add correct host key in ~/.ssh/known_hosts to get rid of this message.
     Offending ECDSA key in ~/.ssh/known_hosts:6
       remove with:
       ssh-keygen -f ~/.ssh/known_hosts" -R "<ip addrress>"
     Host key for <ip_address> has changed and you have requested strict checking.
     Host key verification failed.
     ```

     This is because the `known_hosts` file in the `.ssh` directory now contains
     a mismatch, since the server has been overwritten. To solve this, use a
     text editor to remove the old entry from the `known_hosts` file. The next
     connection attempt will then treat this as a new server.

     The error message line `Offending ECDSA key in ~/.ssh/known_hosts:` gives
     the line number that needs to be removed from the `known_hosts` file.

     The new server's configurations are defined in the flake. `nixos-anywhere`
     does not create `etc/nixos/configuration.nix`, since it expects the server
     to be administered remotely. Any future changes to the configuration should
     be made to the flake, and you would reference this flake when doing the
     nixos-rebuild command or a deployment tool of your choice i.e.
     [colmena](https://github.com/zhaofengli/colmena),
     [nixinate](https://github.com/MatthewCroughan/nixinate).

     This example can be run from the machine itself for updating (replace
     `<URL to your flake>` with your flake i.e. `.#` if your flake is in the
     current directory):

     ```
     nixos-rebuild switch --flake <URL to your flake>
     ```

     You can also run `nixos-rebuild` to update a machine remotly, if you have
     set up an openssh server and your ssh key for the root user:

     ```
     nixos-rebuild switch --flake <URL to your flake> --target-host "root@<ip address>"
     ```

     For more information on different use cases of **nixos-anywhere** please
     refer to the [How to Guide](./howtos/INDEX.md), and for more technical
     information and explanation of known error messages, refer to the
     [Reference Manual](./reference.md).

'''
'''--- docs/reference.md ---
# Reference Manual: nixos-anywhere

**_Install NixOS everywhere via ssh_**

<img title="" src="https://raw.githubusercontent.com/nix-community/nixos-anywhere/main/docs/logo.png" alt="" width="141">

[Documentation Index](./INDEX.md)

TODO: Populate this guide properly

## Contents

[Command Line Usage](#command-line-usage)

[Explanation of known error messages](#explanation-of-known-error-messages)

## Command Line Usage

<!-- `$ bash ./src/nixos-anywhere.sh --help` -->

```
Usage: nixos-anywhere [options] <ssh-host>

Options:

* -f, --flake <flake_uri>
  set the flake to install the system from.
* -i <identity_file>
  selects which SSH private key file to use.
* -p, --ssh-port <ssh_port>
  set the ssh port to connect with
* --ssh-option <ssh_option>
  set an ssh option
* -L, --print-build-logs
  print full build logs
* -s, --store-paths <disko-script> <nixos-system>
  set the store paths to the disko-script and nixos-system directly
  if this is give, flake is not needed
* --no-reboot
  do not reboot after installation, allowing further customization of the target installation.
* --kexec <path>
  use another kexec tarball to bootstrap NixOS
* --post-kexec-ssh-port <ssh_port>
  after kexec is executed, use a custom ssh port to connect. Defaults to 22
* --copy-host-keys
  copy over existing /etc/ssh/ssh_host_* host keys to the installation
* --stop-after-disko
  exit after disko formatting, you can then proceed to install manually or some other way
* --extra-files <file...>
  files to copy into the new nixos installation
* --disk-encryption-keys <remote_path> <local_path>
  copy the contents of the file or pipe in local_path to remote_path in the installer environment,
  after kexec but before installation. Can be repeated.
* --no-substitute-on-destination
  disable passing --substitute-on-destination to nix-copy
* --debug
  enable debug output
* --option <key> <value>
  nix option to pass to every nix related command
* --from <store-uri>
  URL of the source Nix store to copy the nixos and disko closure from
* --build-on-remote
  build the closure on the remote machine instead of locally and copy-closuring it
* --vm-test
  build the system and test the disk configuration inside a VM without installing it to the target.
```

## Explanation of known error messages

TODO: Add additional error messages and meanings. Fill in missing explanations

This section lists known error messages and their explanations. Some
explanations may refer to the following CLI syntax:

`nix run github:nix-community/nixos-anywhere -- --flake <path to configuration>#<configuration name> root@<ip address>`

This list is not comprehensive. It's possible you may encounter errors that
originate from the underlying operating system. These should be documented in
the relevant operating system manual.

| Id | Message                                                                                                                                                      | Explanation                                                                                                                                                                                                                                      |
| -- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1  | Failure unpacking initrd                                                                                                                                     | You don't have enough RAM to hold `kexec`                                                                                                                                                                                                        |
| 2  | Flake <flake_url>¬†does not provide attirbute                                                                                                                 | The configuration name you specified in your flake URI is not defined as a NixOS configuration in your flake eg if your URI was mydir#myconfig, then myconfig should be included in the flake as `nixosConfigurations.myconfig`                  |
| 3  | Please specify the name of the NixOS configuration to be installed, as a URI fragment in the flake-uri.                                                      | As for error #2                                                                                                                                                                                                                                  |
|    | For example, to use the output nixosConfigurations.foo from the flake.nix, append "#foo" to the flake-uri                                                    |                                                                                                                                                                                                                                                  |
| 4  | Retrieving host facts via ssh failed. Check with --debug for the root cause, unless you have done so already                                                 | TODO: Explain                                                                                                                                                                                                                                    |
| 5  | ssh-host must be set                                                                                                                                         | <ip_address>¬†has not been supplied                                                                                                                                                                                                               |
| 6  | <disko_script> and <nixos_system> must be existing store-paths                                                                                               | This occurs if the -s switch has been used to specify the disko script and store path correctly, and the scripts cannot be found at the given URI                                                                                                |
| 7  | flake must be set                                                                                                                                            | This occurs if both the -flake option (use a flake) and the -s option (specify paths directly) have been omitted. Either one or the other must be specified.                                                                                     |
| 8  | no tar command found, but required to unpack kexec tarball                                                                                                   | The destination machine does not have a `tar`¬†command available. This is needed to unpack the `kexec`.                                                                                                                                           |
| 9  | no setsid command found, but required to run the kexec script under a new session                                                                            | The destination machine does not have the `setsid`¬†command available                                                                                                                                                                             |
| 10 | This script requires Linux as the operating system, but got <operating system>                                                                               | The destination machine is not running Linux                                                                                                                                                                                                     |
| 11 | The default kexec image only support x86_64 cpus. Checkout https://github.com/nix-community/nixos-anywhere/#using-your-own-kexec-image for more information. | By default, `nixos-anywhere`¬†uses its own `kexec`¬†image, which will only run on¬†x86_64 CPUs. For other CPU types, you can use your own `kexec`¬†image instead. Refer to the [How To Guide](./howtos#using-your-own-kexec-image)¬†for instructions. |
| 12 | Please specify the name of the NixOS configuration to be installed, as a URI fragment in the flake-uri.                                                      | This is a `disko`¬†error. As for Error #2                                                                                                                                                                                                         |
|    | For example, to use the output diskoConfigurations.foo from the flake.nix, append \"#foo\" to the flake-uri.                                                 |                                                                                                                                                                                                                                                  |
| 13 | mode must be either create, mount or zap_create_mount                                                                                                        | This is a `disko`¬†error. The `disko`¬†switches have not been used correctly. This could happen if you supplied your own `disko`¬†script using the -s option                                                                                        |
| 14 | disko config must be an existing file or flake must be set                                                                                                   | This is a `disko`¬†error. This will happen if the `disko.devices`¬†entry in your flake doesn't match the name of a file in the same location as your flake.                                                                                        |
|    |                                                                                                                                                              |                                                                                                                                                                                                                                                  |
|    |                                                                                                                                                              |                                                                                                                                                                                                                                                  |
|    |                                                                                                                                                              |                                                                                                                                                                                                                                                  |
|    |                                                                                                                                                              |                                                                                                                                                                                                                                                  |

'''
'''--- docs/requirements.md ---
# System Requirements: nixos-anywhere

**_Install NixOS everywhere via ssh_**

<img src="https://raw.githubusercontent.com/nix-community/nixos-anywhere/main/docs/logo.png" width="150" height="150">

[Documentation Index](./INDEX.md)

## Requirements

### Source Machine:

1. **Supported Systems:**
   - Linux or macOS computers with Nix installed.
   - NixOS
   - Windows systems using WSL2.

   _Note_: Should be able to build nix derivations for the target platform.
   Otherwise `--build-on-remote` can be used.

2. **Nix Installation:** If Nix is not yet installed on your system, refer to
   the [nix installation page](https://nixos.org/download#download-nix).

### Destination Machine:

The machine must be reachable over the public internet or local network.
Nixos-anywhere does not support wifi networks. If a VPN is needed, define a
custom installer via the --kexec flag which connects to your VPN.

1. **Direct Boot Option:**
   - Must be already running a NixOS installer.

2. **Alternative Boot Options:** If not booting directly from a NixOS installer
   image:
   - **Architecture & Support:** Must be operating on:
     - x86-64 or aarch64 Linux systems with kexec support. Note: While most
       x86-64 Linux systems support kexec, if you're using an architecture other
       than those mentioned, you may need to specify a
       [different kexec image](./howtos/INDEX.md#using-your-own-kexec-image)
       manually.
   - **Memory Requirements:**
     - At least 1.5 GB of RAM (excluding swap space).

'''
'''--- src/nixos-anywhere.sh ---
#!/usr/bin/env bash
set -euo pipefail

showUsage() {
  cat <<USAGE
Usage: nixos-anywhere [options] <ssh-host>

Options:

* -f, --flake <flake_uri>
  set the flake to install the system from.
* -i <identity_file>
  selects which SSH private key file to use.
* -p, --ssh-port <ssh_port>
  set the ssh port to connect with
* --ssh-option <ssh_option>
  set an ssh option
* -L, --print-build-logs
  print full build logs
* -s, --store-paths <disko-script> <nixos-system>
  set the store paths to the disko-script and nixos-system directly
  if this is give, flake is not needed
* --no-reboot
  do not reboot after installation, allowing further customization of the target installation.
* --kexec <path>
  use another kexec tarball to bootstrap NixOS
* --post-kexec-ssh-port <ssh_port>
  after kexec is executed, use a custom ssh port to connect. Defaults to 22
* --copy-host-keys
  copy over existing /etc/ssh/ssh_host_* host keys to the installation
* --stop-after-disko
  exit after disko formatting, you can then proceed to install manually or some other way
* --extra-files <file...>
  files to copy into the new nixos installation
* --disk-encryption-keys <remote_path> <local_path>
  copy the contents of the file or pipe in local_path to remote_path in the installer environment,
  after kexec but before installation. Can be repeated.
* --no-substitute-on-destination
  disable passing --substitute-on-destination to nix-copy
* --debug
  enable debug output
* --option <key> <value>
  nix option to pass to every nix related command
* --from <store-uri>
  URL of the source Nix store to copy the nixos and disko closure from
* --build-on-remote
  build the closure on the remote machine instead of locally and copy-closuring it
* --vm-test
  build the system and test the disk configuration inside a VM without installing it to the target.
USAGE
}

abort() {
  echo "aborted: $*" >&2
  exit 1
}

step() {
  echo "### $* ###"
}

kexec_url=""
enable_debug=""
maybe_reboot="sleep 6 && reboot"
nix_options=(
  --extra-experimental-features 'nix-command flakes'
  "--no-write-lock-file"
)
substitute_on_destination=y
ssh_private_key_file=
if [ -t 0 ]; then # stdin is a tty, we allow interactive input to ssh i.e. passwords
  ssh_tty_param="-t"
else
  ssh_tty_param="-T"
fi
post_kexec_ssh_port=22

declare -A disk_encryption_keys
declare -a nix_copy_options
declare -a ssh_copy_id_args
declare -a ssh_args

while [[ $# -gt 0 ]]; do
  case "$1" in
  -f | --flake)
    flake=$2
    shift
    ;;
  -i)
    ssh_private_key_file=$2
    shift
    ;;
  -p | --ssh-port)
    ssh_args+=("-p" "$2")
    shift
    ;;
  --ssh-option)
    ssh_args+=("-o" "$2")
    shift
    ;;
  -L | --print-build-logs)
    print_build_logs=y
    ;;
  -s | --store-paths)
    disko_script=$(readlink -f "$2")
    nixos_system=$(readlink -f "$3")
    shift
    shift
    ;;
  -t | --tty)
    echo "the '$1' flag is deprecated, a tty is now detected automatically" >&2
    ;;
  --help)
    showUsage
    exit 0
    ;;
  --kexec)
    kexec_url=$2
    shift
    ;;
  --post-kexec-ssh-port)
    post_kexec_ssh_port=$2
    shift
    ;;
  --copy-host-keys)
    copy_host_keys=y
    ;;
  --debug)
    enable_debug="-x"
    print_build_logs=y
    set -x
    ;;
  --extra-files)
    extra_files=$2
    shift
    ;;
  --disk-encryption-keys)
    disk_encryption_keys["$2"]="$3"
    shift
    shift
    ;;
  --stop-after-disko)
    stop_after_disko=y
    ;;
  --no-reboot)
    maybe_reboot=""
    ;;
  --from)
    nix_copy_options+=("--from" "$2")
    shift
    ;;
  --option)
    key=$2
    shift
    value=$2
    shift
    nix_options+=("--option" "$key" "$value")
    ;;
  --no-substitute-on-destination)
    substitute_on_destination=n
    ;;
  --build-on-remote)
    build_on_remote=y
    ;;
  --vm-test)
    vm_test=y
    ;;
  *)
    if [[ -z ${ssh_connection-} ]]; then
      ssh_connection="$1"
    else
      showUsage
      exit 1
    fi
    ;;
  esac
  shift
done

if [[ ${print_build_logs-n} == "y" ]]; then
  nix_options+=("-L")
fi

if [[ ${substitute_on_destination-n} == "y" ]]; then
  nix_copy_options+=("--substitute-on-destination")
fi

# ssh wrapper
timeout_ssh_() {
  timeout 10 ssh -i "$ssh_key_dir"/nixos-anywhere -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "${ssh_args[@]}" "$ssh_connection" "$@"
}
ssh_() {
  ssh "$ssh_tty_param" -i "$ssh_key_dir"/nixos-anywhere -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "${ssh_args[@]}" "$ssh_connection" "$@"
}

nix_copy() {
  NIX_SSHOPTS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i $ssh_key_dir/nixos-anywhere ${ssh_args[*]}" nix copy \
    "${nix_options[@]}" \
    "${nix_copy_options[@]}" \
    "$@"
}
nix_build() {
  NIX_SSHOPTS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i $ssh_key_dir/nixos-anywhere ${ssh_args[*]}" nix build \
    --print-out-paths \
    --no-link \
    "${nix_options[@]}" \
    "$@"
}

if [[ -z ${vm_test-} ]]; then
  if [[ -z ${ssh_connection-} ]]; then
    abort "ssh-host must be set"
  fi

  # we generate a temporary ssh keypair that we can use during nixos-anywhere
  ssh_key_dir=$(mktemp -d)
  trap 'rm -rf "$ssh_key_dir"' EXIT
  mkdir -p "$ssh_key_dir"
  # ssh-copy-id requires this directory
  mkdir -p "$HOME/.ssh/"
  ssh-keygen -t ed25519 -f "$ssh_key_dir"/nixos-anywhere -P "" -C "nixos-anywhere" >/dev/null
fi

# parse flake nixos-install style syntax, get the system attr
if [[ -n ${flake-} ]]; then
  if [[ $flake =~ ^(.*)\#([^\#\"]*)$ ]]; then
    flake="${BASH_REMATCH[1]}"
    flakeAttr="${BASH_REMATCH[2]}"
  fi
  if [[ -z ${flakeAttr-} ]]; then
    echo "Please specify the name of the NixOS configuration to be installed, as a URI fragment in the flake-uri." >&2
    echo 'For example, to use the output nixosConfigurations.foo from the flake.nix, append "#foo" to the flake-uri.' >&2
    exit 1
  fi
  if [[ ${build_on_remote-n} == "n" ]]; then
    if [[ -n ${vm_test-} ]]; then
      if [[ -n ${extra_files-} ]]; then
        echo "--vm-test is not supported with --extra-files" >&2
        exit 1
      fi
      if [[ -n ${disk_encryption_keys-} ]]; then
        echo "--vm-test is not supported with --disk-encryption-keys" >&2
        exit 1
      fi
      exec nix build \
        --print-out-paths \
        --no-link \
        -L \
        "${nix_options[@]}" \
        "${flake}#nixosConfigurations.\"${flakeAttr}\".config.system.build.installTest"
    fi
    disko_script=$(nix_build "${flake}#nixosConfigurations.\"${flakeAttr}\".config.system.build.diskoScript")
    nixos_system=$(nix_build "${flake}#nixosConfigurations.\"${flakeAttr}\".config.system.build.toplevel")
  fi
elif [[ -n ${disko_script-} ]] && [[ -n ${nixos_system-} ]]; then
  if [[ -n ${vm_test-} ]]; then
    echo "vm-test is not supported with --store-paths" >&2
    echo "Please use --flake instead or build config.system.build.installTest of your nixos configuration manually" >&2
    exit 1
  fi
  if [[ ! -e ${disko_script} ]] || [[ ! -e ${nixos_system} ]]; then
    abort "${disko_script} and ${nixos_system} must be existing store-paths"
  fi
else
  abort "flake must be set"
fi

# overrides -i if passed as an env var
if [[ -n ${SSH_PRIVATE_KEY-} ]]; then
  # $ssh_key_dir is getting deleted on trap EXIT
  ssh_private_key_file="$ssh_key_dir/from-env"
  (
    umask 077
    printf '%s\n' "$SSH_PRIVATE_KEY" >"$ssh_private_key_file"
  )
fi

if [[ -n ${ssh_private_key_file-} ]]; then
  unset SSH_AUTH_SOCK # don't use system agent if key was supplied
  ssh_copy_id_args+=(-o "IdentityFile=${ssh_private_key_file}")
  ssh_copy_id_args+=(-f)
fi

ssh_settings=$(ssh "${ssh_args[@]}" -G "${ssh_connection}")
ssh_host=$(echo "$ssh_settings" | awk '/^hostname / { print $2 }')
ssh_port=$(echo "$ssh_settings" | awk '/^port / { print $2 }')

step Uploading install SSH keys
until
  ssh-copy-id \
    -i "$ssh_key_dir"/nixos-anywhere.pub \
    -o ConnectTimeout=10 \
    -o UserKnownHostsFile=/dev/null \
    -o StrictHostKeyChecking=no \
    "${ssh_copy_id_args[@]}" \
    "${ssh_args[@]}" \
    "$ssh_connection"
do
  sleep 3
done

import_facts() {
  local facts filtered_facts
  if ! facts=$(
    ssh_ -o ConnectTimeout=10 bash -- <<SSH
set -efu ${enable_debug}
has(){
  command -v "\$1" >/dev/null && echo "y" || echo "n"
}
is_nixos=\$(if test -f /etc/os-release && grep -q ID=nixos /etc/os-release; then echo "y"; else echo "n"; fi)
cat <<FACTS
is_os=\$(uname)
is_arch=\$(uname -m)
is_kexec=\$(if test -f /etc/is_kexec; then echo "y"; else echo "n"; fi)
is_nixos=\$is_nixos
is_installer=\$(if [[ "\$is_nixos" == "y" ]] && grep -q VARIANT_ID=installer /etc/os-release; then echo "y"; else echo "n"; fi)
is_container=\$(has systemd-detect-virt && systemd-detect-virt --container || echo "none")
has_tar=\$(has tar)
has_sudo=\$(has sudo)
has_wget=\$(has wget)
has_curl=\$(has curl)
has_setsid=\$(has setsid)
FACTS
SSH
  ); then
    exit 1
  fi
  filtered_facts=$(echo "$facts" | grep -E '^(has|is)_[a-z0-9_]+=\S+')
  if [[ -z $filtered_facts ]]; then
    abort "Retrieving host facts via ssh failed. Check with --debug for the root cause, unless you have done so already"
  fi
  # make facts available in script
  # shellcheck disable=SC2046
  export $(echo "$filtered_facts" | xargs)
}

step Gathering machine facts
import_facts

if [[ ${has_tar-n} == "n" ]]; then
  abort "no tar command found, but required to unpack kexec tarball"
fi

if [[ ${has_setsid-n} == "n" ]]; then
  abort "no setsid command found, but required to run the kexec script under a new session"
fi

maybe_sudo=""
if [[ ${has_sudo-n} == "y" ]]; then
  maybe_sudo="sudo"
fi

if [[ ${is_os-n} != "Linux" ]]; then
  abort "This script requires Linux as the operating system, but got $is_os"
fi

if [[ ${is_kexec-n} == "n" ]] && [[ ${is_installer-n} == "n" ]]; then
  if [[ ${is_container-none} != "none" ]]; then
    echo "WARNING: This script does not support running from a '${is_container}' container. kexec will likely not work" >&2
  fi

  if [[ $kexec_url == "" ]]; then
    case "${is_arch-unknown}" in
    x86_64 | aarch64)
      kexec_url="https://github.com/nix-community/nixos-images/releases/download/nixos-23.11/nixos-kexec-installer-noninteractive-${is_arch}-linux.tar.gz"
      ;;
    *)
      abort "Unsupported architecture: ${is_arch}. Our default kexec images only support x86_64 and aarch64 cpus. Checkout https://github.com/nix-community/nixos-anywhere/#using-your-own-kexec-image for more information."
      ;;
    esac
  fi

  step Switching system into kexec
  ssh_ bash <<SSH
set -efu ${enable_debug}
$maybe_sudo rm -rf /root/kexec
$maybe_sudo mkdir -p /root/kexec
SSH

  if [[ -f $kexec_url ]]; then
    ssh_ "${maybe_sudo} tar -C /root/kexec -xvzf-" <"$kexec_url"
  elif [[ ${has_curl-n} == "y" ]]; then
    ssh_ "curl --fail -Ss -L '${kexec_url}' | ${maybe_sudo} tar -C /root/kexec -xvzf-"
  elif [[ ${has_wget-n} == "y" ]]; then
    ssh_ "wget '${kexec_url}' -O- | ${maybe_sudo} tar -C /root/kexec -xvzf-"
  else
    curl --fail -Ss -L "${kexec_url}" | ssh_ "${maybe_sudo} tar -C /root/kexec -xvzf-"
  fi

  ssh_ <<SSH
TMPDIR=/root/kexec setsid ${maybe_sudo} /root/kexec/kexec/run
SSH

  # use the default SSH port to connect at this point
  for i in "${!ssh_args[@]}"; do
    if [[ ${ssh_args[i]} == "-p" ]]; then
      ssh_args[i + 1]=$post_kexec_ssh_port
      break
    fi
  done

  # wait for machine to become unreachable.
  while timeout_ssh_ -- exit 0; do sleep 1; done

  # After kexec we explicitly set the user to root@
  ssh_connection="root@${ssh_host}"

  # waiting for machine to become available again
  until ssh_ -o ConnectTimeout=10 -- exit 0; do sleep 5; done
fi
for path in "${!disk_encryption_keys[@]}"; do
  step "Uploading ${disk_encryption_keys[$path]} to $path"
  ssh_ "umask 077; cat > $path" <"${disk_encryption_keys[$path]}"
done

if [[ ${build_on_remote-n} == "y" ]]; then
  pubkey=$(ssh-keyscan -p "$ssh_port" -t ed25519 "$ssh_host" 2>/dev/null || {
    echo "ERROR: failed to retrieve host public key for ${ssh_connection}" >&2
    exit 1
  })
  pubkey=$(echo "$pubkey" | sed -e 's/^[^ ]* //' | base64 -w0)
fi

if [[ -n ${disko_script-} ]]; then
  nix_copy --to "ssh://$ssh_connection" "$disko_script"
elif [[ ${build_on_remote-n} == "y" ]]; then
  step Building disko script
  # We need to do a nix copy first because nix build doesn't have --no-check-sigs
  nix_copy --to "ssh-ng://$ssh_connection" "${flake}#nixosConfigurations.\"${flakeAttr}\".config.system.build.diskoScript" \
    --derivation --no-check-sigs
  disko_script=$(
    nix_build "${flake}#nixosConfigurations.\"${flakeAttr}\".config.system.build.diskoScript" \
      --eval-store auto --store "ssh-ng://$ssh_connection?ssh-key=$ssh_key_dir/nixos-anywhere"
  )
fi

step Formatting hard drive with disko
ssh_ "$disko_script"

if [[ ${stop_after_disko-n} == "y" ]]; then
  # Should we also do this for `--no-reboot`?
  echo "WARNING: leaving temporary ssh key at '$ssh_key_dir/nixos-anywhere' to login to the machine" >&2
  trap - EXIT
  exit 0
fi

if [[ -n ${nixos_system-} ]]; then
  step Uploading the system closure
  nix_copy --to "ssh://$ssh_connection?remote-store=local?root=/mnt" "$nixos_system"
elif [[ ${build_on_remote-n} == "y" ]]; then
  step Building the system closure
  # We need to do a nix copy first because nix build doesn't have --no-check-sigs
  nix_copy --to "ssh-ng://$ssh_connection?remote-store=local?root=/mnt" "${flake}#nixosConfigurations.\"${flakeAttr}\".config.system.build.toplevel" \
    --derivation --no-check-sigs
  nixos_system=$(
    nix_build "${flake}#nixosConfigurations.\"${flakeAttr}\".config.system.build.toplevel" \
      --eval-store auto --store "ssh-ng://$ssh_connection?ssh-key=$ssh_key_dir/nixos-anywhere&remote-store=local?root=/mnt"
  )
fi

if [[ -n ${extra_files-} ]]; then
  if [[ -d $extra_files ]]; then
    extra_files="$extra_files/"
  fi
  step Copying extra files
  rsync -rlpv -FF \
    -e "ssh -i \"$ssh_key_dir\"/nixos-anywhere -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no ${ssh_args[*]}" \
    "$extra_files" \
    "${ssh_connection}:/mnt/"
  ssh_ "chmod 755 /mnt" # rsync also changes permissions of /mnt
fi

step Installing NixOS
ssh_ bash <<SSH
set -eu ${enable_debug}
# when running not in nixos we might miss this directory, but it's needed in the nixos chroot during installation
export PATH="\$PATH:/run/current-system/sw/bin"

# needed for installation if initrd-secrets are used
mkdir -p /mnt/tmp
chmod 777 /mnt/tmp
if [[ ${copy_host_keys-n} == "y" ]]; then
  # NB we copy host keys that are in turn copied by kexec installer.
  mkdir -m 755 -p /mnt/etc/ssh
  for p in /etc/ssh/ssh_host_*; do
    # Skip if the source file does not exist (i.e. glob did not match any files)
    # or the destination already exists (e.g. copied with --extra-files).
    if [ ! -e "\$p" -o -e "/mnt/\$p" ]; then
      continue
    fi
    cp -a "\$p" "/mnt/\$p"
  done
fi
nixos-install --no-root-passwd --no-channel-copy --system "$nixos_system"
if command -v zpool >/dev/null; then
  # we always want to export the zfs pools so people can boot from it without force import
  umount -Rv /mnt/
  zpool export -a || true
fi
# We will reboot in background so we can cleanly finish the script before the hosts go down.
# This makes integration into scripts easier
nohup bash -c '${maybe_reboot}' >/dev/null &
SSH

if [[ -n ${maybe_reboot} ]]; then
  step Waiting for the machine to become reachable again
  while timeout_ssh_ -- exit 0; do sleep 1; done
fi

step "Done!"

'''
'''--- terraform/.terraform-docs.yml ---
output:
  mode: inject
  template: |-
    <!-- BEGIN_TF_DOCS -->
    {{ .Content }}
    <!-- END_TF_DOCS -->

'''
'''--- terraform/README.md ---
# NixOS-Anywhere Terraform Modules Overview

The nixos-Anywhere terraform modules allow you to use Terraform for installing
and updating NixOS. It simplifies the deployment process by integrating
nixos-anywhere functionality.

Here's a brief overview of each module:

- **[All-in-One](all-in-one.md)**: This is a consolidated module that first
  installs NixOS using nixos-anywhere and then keeps it updated with
  nixos-rebuild. If you choose this, you won't need additional deployment tools
  like colmena.
- **[Install](install.md)**: This module focuses solely on installing NixOS via
  nixos-anywhere.
- **[NixOS-Rebuild](nixos-rebuild.md)**: Use this module to remotely update an
  existing NixOS machine using nixos-rebuild.
- **[Nix-Build](nix-build.md)**: This is a handy helper module designed to build
  a flake attribute or an attribute from a nix file.

For detailed information and usage examples, click on the respective module
links above.

'''
'''--- terraform/all-in-one.md ---
# All-in-one

Combines the install and nixos-rebuild module in one interface to install NixOS
with nixos-anywhere and than keep it up-to-date with nixos-rebuild.

## Example

```hcl
locals {
  ipv4 = "192.0.2.1"
}

module "deploy" {
  source                 = "github.com/nix-community/nixos-anywhere//terraform/all-in-one"
  # with flakes
  nixos_system_attr      = ".#nixosConfigurations.mymachine.config.system.build.toplevel"
  nixos_partitioner_attr = ".#nixosConfigurations.mymachine.config.system.build.diskoScript"
  # without flakes
  # file can use (pkgs.nixos []) function from nixpkgs
  #file                   = "${path.module}/../.."
  #nixos_system_attr      = "config.system.build.toplevel"
  #nixos_partitioner_attr = "config.system.build.diskoScript"

  target_host            = local.ipv4
  # when instance id changes, it will trigger a reinstall
  instance_id            = local.ipv4
  # useful if something goes wrong
  # debug_logging          = true
  # script is below
  extra_files_script     = "${path.module}/decrypt-ssh-secrets.sh"
  disk_encryption_key_scripts = [{
    path   = "/tmp/secret.key"
    # script is below
    script = "${path.module}/decrypt-zfs-key.sh"
  }]
}
```

_Note:_ You need to mark scripts as executable (`chmod +x`)

### ./decrypt-ssh-secrets.sh

```
#!/usr/bin/env bash

mkdir -p etc/ssh var/lib/secrets

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

umask 0177
sops --extract '["initrd_ssh_key"]' -d "$SCRIPT_DIR/secrets.yaml" >./var/lib/secrets/initrd_ssh_key

# restore umask
umask 0022

for keyname in ssh_host_rsa_key ssh_host_rsa_key.pub ssh_host_ed25519_key ssh_host_ed25519_key.pub; do
  if [[ $keyname == *.pub ]]; then
    umask 0133
  else
    umask 0177
  fi
  sops --extract '["'$keyname'"]' -d "$SCRIPT_DIR/secrets.yaml" >"./etc/ssh/$keyname"
done
```

### ./decrypt-zfs-key.sh

```
#!/usr/bin/env bash

set -euo pipefail

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
cd "$SCRIPT_DIR"
sops --extract '["zfs-key"]' -d "$SCRIPT_DIR/secrets.yaml" >"./etc/ssh/$keyname"
```

<!-- BEGIN_TF_DOCS -->

## Requirements

No requirements.

## Providers

No providers.

## Modules

| Name                                                                                   | Source           | Version |
| -------------------------------------------------------------------------------------- | ---------------- | ------- |
| <a name="module_install"></a> [install](#module_install)                               | ../install       | n/a     |
| <a name="module_nixos-rebuild"></a> [nixos-rebuild](#module_nixos-rebuild)             | ../nixos-rebuild | n/a     |
| <a name="module_partitioner-build"></a> [partitioner-build](#module_partitioner-build) | ../nix-build     | n/a     |
| <a name="module_system-build"></a> [system-build](#module_system-build)                | ../nix-build     | n/a     |

## Resources

No resources.

## Inputs

| Name                                                                                                                  | Description                                                                                                                                                                                                                                               | Type                                                                   | Default  | Required |
| --------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | -------- | :------: |
| <a name="input_debug_logging"></a> [debug\_logging](#input_debug_logging)                                             | Enable debug logging                                                                                                                                                                                                                                      | `bool`                                                                 | `false`  |    no    |
| <a name="input_deployment_ssh_key"></a> [deployment\_ssh\_key](#input_deployment_ssh_key)                             | Content of private key used to deploy to the target\_host after initial installation. To ensure maximum security, it is advisable to connect to your host using ssh-agent instead of relying on this variable                                             | `string`                                                               | `null`   |    no    |
| <a name="input_disk_encryption_key_scripts"></a> [disk\_encryption\_key\_scripts](#input_disk_encryption_key_scripts) | Each of these script files will be executed locally and the output of each of them will be made present at the given path to disko during installation. The keys will be not copied to the final system                                                   | <pre>list(object({<br> path = string<br> script = string<br> }))</pre> | `[]`     |    no    |
| <a name="input_extra_environment"></a> [extra\_environment](#input_extra_environment)                                 | Extra environment variables to be set during installation. This can be usefull to set extra variables for the extra\_files\_script or disk\_encryption\_key\_scripts                                                                                      | `map(string)`                                                          | `{}`     |    no    |
| <a name="input_extra_files_script"></a> [extra\_files\_script](#input_extra_files_script)                             | A script file that prepares extra files to be copied to the target host during installation. The script expected to write all its files to the current directory. This directory is rsynced to the target host during installation to the / directory.    | `string`                                                               | `null`   |    no    |
| <a name="input_file"></a> [file](#input_file)                                                                         | Nix file containing the nixos\_system\_attr and nixos\_partitioner\_attr. Use this if you are not using flake                                                                                                                                             | `string`                                                               | `null`   |    no    |
| <a name="input_install_ssh_key"></a> [install\_ssh\_key](#input_install_ssh_key)                                      | Content of private key used to connect to the target\_host during initial installation                                                                                                                                                                    | `string`                                                               | `null`   |    no    |
| <a name="input_install_user"></a> [install\_user](#input_install_user)                                                | SSH user used to connect to the target\_host, before installing NixOS. If null than the value of `target_host` is used                                                                                                                                    | `string`                                                               | `null`   |    no    |
| <a name="input_instance_id"></a> [instance\_id](#input_instance_id)                                                   | The instance id of the target\_host, used to track when to reinstall the machine                                                                                                                                                                          | `string`                                                               | `null`   |    no    |
| <a name="input_kexec_tarball_url"></a> [kexec\_tarball\_url](#input_kexec_tarball_url)                                | NixOS kexec installer tarball url                                                                                                                                                                                                                         | `string`                                                               | `null`   |    no    |
| <a name="input_nixos_partitioner_attr"></a> [nixos\_partitioner\_attr](#input_nixos_partitioner_attr)                 | Nixos partitioner and mount script i.e. your-flake#nixosConfigurations.your-evaluated-nixos.config.system.build.diskoNoDeps or just your-evaluated.config.system.build.diskNoDeps. `config.system.build.diskNoDeps` is provided by the disko nixos module | `string`                                                               | n/a      |   yes    |
| <a name="input_nixos_system_attr"></a> [nixos\_system\_attr](#input_nixos_system_attr)                                | The nixos system to deploy i.e. your-flake#nixosConfigurations.your-evaluated-nixos.config.system.build.toplevel or just your-evaluated-nixos.config.system.build.toplevel if you are not using flakes                                                    | `string`                                                               | n/a      |   yes    |
| <a name="input_no_reboot"></a> [no\_reboot](#input_no_reboot)                                                         | Do not reboot after installation                                                                                                                                                                                                                          | `bool`                                                                 | `false`  |    no    |
| <a name="input_stop_after_disko"></a> [stop\_after\_disko](#input_stop_after_disko)                                   | Exit after disko formatting                                                                                                                                                                                                                               | `bool`                                                                 | `false`  |    no    |
| <a name="input_target_host"></a> [target\_host](#input_target_host)                                                   | DNS host to deploy to                                                                                                                                                                                                                                     | `string`                                                               | n/a      |   yes    |
| <a name="input_target_port"></a> [target\_port](#input_target_port)                                                   | SSH port used to connect to the target\_host, before installing NixOS                                                                                                                                                                                     | `number`                                                               | `22`     |    no    |
| <a name="input_target_user"></a> [target\_user](#input_target_user)                                                   | SSH user used to connect to the target\_host after installing NixOS. If install\_user is not set than this user is also used before installing.                                                                                                           | `string`                                                               | `"root"` |    no    |

## Outputs

No outputs.

<!-- END_TF_DOCS -->

'''
'''--- terraform/install.md ---
# Install

Install NixOS with nixos-anywhere

## Example

```hcl
locals {
  ipv4 = "192.0.2.1"
}

module "system-build" {
  source            = "github.com/nix-community/nixos-anywhere//terraform/nix-build"
  # with flakes
  attribute         = ".#nixosConfigurations.mymachine.config.system.build.toplevel"
  # without flakes
  # file can use (pkgs.nixos []) function from nixpkgs
  #file              = "${path.module}/../.."
  #attribute         = "config.system.build.toplevel"
}

module "disko" {
  source         = "github.com/nix-community/nixos-anywhere//terraform/nix-build"
  # with flakes
  attribute      = ".#nixosConfigurations.mymachine.config.system.build.diskoScript"
  # without flakes
  # file can use (pkgs.nixos []) function from nixpkgs
  #file           = "${path.module}/../.."
  #attribute      = "config.system.build.diskoScript"
}

module "install" {
  source            = "github.com/nix-community/nixos-anywhere//terraform/install"
  nixos_system      = module.system-build.result.out
  nixos_partitioner = module.disko.result.out
  target_host       = local.ipv4
}
```

<!-- BEGIN_TF_DOCS -->

## Requirements

No requirements.

## Providers

| Name                                                | Version |
| --------------------------------------------------- | ------- |
| <a name="provider_null"></a> [null](#provider_null) | n/a     |

## Modules

No modules..../joerg/.data/nvim/lazy/

## Resources

| Name                                                                                                                | Type     |
| ------------------------------------------------------------------------------------------------------------------- | -------- |
| [null_resource.nixos-remote](https://registry.terraform.io/providers/hashicorp/null/latest/docs/resources/resource) | resource |

## Inputs

| Name                                                                                                                  | Description                                                                                                                                                                                                                                            | Type                                                                   | Default  | Required |
| --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------- | -------- | :------: |
| <a name="input_debug_logging"></a> [debug\_logging](#input_debug_logging)                                             | Enable debug logging                                                                                                                                                                                                                                   | `bool`                                                                 | `false`  |    no    |
| <a name="input_disk_encryption_key_scripts"></a> [disk\_encryption\_key\_scripts](#input_disk_encryption_key_scripts) | Each of these script files will be executed locally and the output of each of them will be made present at the given path to disko during installation. The keys will be not copied to the final system                                                | <pre>list(object({<br> path = string<br> script = string<br> }))</pre> | `[]`     |    no    |
| <a name="input_extra_environment"></a> [extra\_environment](#input_extra_environment)                                 | Extra environment variables to be set during installation. This can be usefull to set extra variables for the extra\_files\_script or disk\_encryption\_key\_scripts                                                                                   | `map(string)`                                                          | `{}`     |    no    |
| <a name="input_extra_files_script"></a> [extra\_files\_script](#input_extra_files_script)                             | A script file that prepares extra files to be copied to the target host during installation. The script expected to write all its files to the current directory. This directory is rsynced to the target host during installation to the / directory. | `string`                                                               | `null`   |    no    |
| <a name="input_instance_id"></a> [instance\_id](#input_instance_id)                                                   | The instance id of the target\_host, used to track when to reinstall the machine                                                                                                                                                                       | `string`                                                               | `null`   |    no    |
| <a name="input_kexec_tarball_url"></a> [kexec\_tarball\_url](#input_kexec_tarball_url)                                | NixOS kexec installer tarball url                                                                                                                                                                                                                      | `string`                                                               | `null`   |    no    |
| <a name="input_nixos_partitioner"></a> [nixos\_partitioner](#input_nixos_partitioner)                                 | nixos partitioner and mount script                                                                                                                                                                                                                     | `string`                                                               | n/a      |   yes    |
| <a name="input_nixos_system"></a> [nixos\_system](#input_nixos_system)                                                | The nixos system to deploy                                                                                                                                                                                                                             | `string`                                                               | n/a      |   yes    |
| <a name="input_no_reboot"></a> [no\_reboot](#input_no_reboot)                                                         | Do not reboot the machine after installation                                                                                                                                                                                                           | `bool`                                                                 | `false`  |    no    |
| <a name="input_ssh_private_key"></a> [ssh\_private\_key](#input_ssh_private_key)                                      | Content of private key used to connect to the target\_host                                                                                                                                                                                             | `string`                                                               | `""`     |    no    |
| <a name="input_stop_after_disko"></a> [stop\_after\_disko](#input_stop_after_disko)                                   | Exit after disko formatting                                                                                                                                                                                                                            | `bool`                                                                 | `false`  |    no    |
| <a name="input_target_host"></a> [target\_host](#input_target_host)                                                   | DNS host to deploy to                                                                                                                                                                                                                                  | `string`                                                               | n/a      |   yes    |
| <a name="input_target_port"></a> [target\_port](#input_target_port)                                                   | SSH port used to connect to the target\_host                                                                                                                                                                                                           | `number`                                                               | `22`     |    no    |
| <a name="input_target_user"></a> [target\_user](#input_target_user)                                                   | SSH user used to connect to the target\_host                                                                                                                                                                                                           | `string`                                                               | `"root"` |    no    |

## Outputs

No outputs.

<!-- END_TF_DOCS -->

'''
'''--- terraform/install/run-nixos-anywhere.sh ---
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
args=()

if [[ ${debug_logging-} == "true" ]]; then
  set -x
  args+=("--debug")
fi
if [[ ${stop_after_disko-} == "true" ]]; then
  args+=("--stop-after-disko")
fi
if [[ ${kexec_tarball_url-} != "" ]]; then
  args+=("--kexec" "${kexec_tarball_url}")
fi
if [[ ${no_reboot-} == "true" ]]; then
  args+=("--no-reboot")
fi
if [[ ${build_on_remote-} == "true" ]]; then
  args+=("--build-on-remote")
fi
if [[ -n ${flake-} ]]; then
  args+=("--flake" "${flake}")
else
  args+=("--store-paths" "${nixos_partitioner}" "${nixos_system}")
fi

tmpdir=$(mktemp -d)
cleanup() {
  rm -rf "${tmpdir}"
}
trap cleanup EXIT

if [[ ${extra_files_script-} != "" ]]; then
  if [[ ! -f ${extra_files_script} ]]; then
    echo "extra_files_script '${extra_files_script}' does not exist"
    exit 1
  fi
  if [[ ! -x ${extra_files_script} ]]; then
    echo "extra_files_script '${extra_files_script}' is not executable"
    exit 1
  fi
  extra_files_script=$(realpath "${extra_files_script}")
  mkdir "${tmpdir}/extra-files"
  pushd "${tmpdir}/extra-files"
  $extra_files_script
  popd
  args+=("--extra-files" "${tmpdir}/extra-files")
fi
args+=("${target_user}@${target_host}")

keyIdx=0
while [[ $# -gt 0 ]]; do
  if [[ ! -f $2 ]]; then
    echo "Script file '$2' does not exist"
    exit 1
  fi
  if [[ ! -x $2 ]]; then
    echo "Script file '$2' is not executable"
    exit 1
  fi
  mkdir "${tmpdir}/keys"
  "$2" >"${tmpdir}/keys/$keyIdx"
  args+=("--disk-encryption-keys" "$1" "${tmpdir}/keys/$keyIdx")
  shift
  shift
  keyIdx=$((keyIdx + 1))
done

nix run --extra-experimental-features 'nix-command flakes' "path:${SCRIPT_DIR}/../..#nixos-anywhere" -- "${args[@]}"

'''
'''--- terraform/nix-build.md ---
# Nix-build

Small helper module to run do build a flake attribute or attribute from a nix
file.

## Example

- See [install](install.md) or [nixos-rebuild](nixos-rebuild.md)

## Requirements

No requirements.

## Providers

| Name                                                            | Version |
| --------------------------------------------------------------- | ------- |
| <a name="provider_external"></a> [external](#provider_external) | n/a     |

## Modules

No modules.

## Resources

| Name                                                                                                                        | Type        |
| --------------------------------------------------------------------------------------------------------------------------- | ----------- |
| [external_external.nix-build](https://registry.terraform.io/providers/hashicorp/external/latest/docs/data-sources/external) | data source |

## Inputs

| Name                                                         | Description                                        | Type     | Default | Required |
| ------------------------------------------------------------ | -------------------------------------------------- | -------- | ------- | :------: |
| <a name="input_attribute"></a> [attribute](#input_attribute) | the attribute to build, can also be a flake        | `string` | n/a     |   yes    |
| <a name="input_file"></a> [file](#input_file)                | the nix file to evaluate, if not run in flake mode | `string` | `null`  |    no    |

## Outputs

| Name                                                  | Description |
| ----------------------------------------------------- | ----------- |
| <a name="output_result"></a> [result](#output_result) | n/a         |

<!-- END_TF_DOCS -->

'''
'''--- terraform/nix-build/nix-build.sh ---
#!/usr/bin/env bash
set -efu

declare file attribute
eval "$(jq -r '@sh "attribute=\(.attribute) file=\(.file)"')"
if [[ -n ${file-} ]] && [[ -e ${file-} ]]; then
  out=$(nix build --no-link --json -f "$file" "$attribute")
  printf '%s' "$out" | jq -c '.[].outputs'
else
  out=$(nix build --no-link --json "$attribute")
  printf '%s' "$out" | jq -c '.[].outputs'
fi

'''
'''--- terraform/nixos-rebuild.md ---
# Nixos-rebuild

Update NixOS machine with nixos-rebuild on a remote machine

## Example

```hcl
locals {
  ipv4 = "192.0.2.1"
}

module "system-build" {
  source              = "github.com/nix-community/nixos-anywhere//terraform/nix-build"
  # with flakes
  attribute           = ".#nixosConfigurations.mymachine.config.system.build.toplevel"
  # without flakes
  # file can use (pkgs.nixos []) function from nixpkgs
  #file                = "${path.module}/../.."
  #attribute           = "config.system.build.toplevel"
}

module "deploy" {
  source       = "github.com/nix-community/nixos-anywhere//terraform/nixos-rebuild"
  nixos_system = module.system-build.result.out
  target_host  = local.ipv4
}
```

<!-- BEGIN_TF_DOCS -->

## Requirements

No requirements.

## Providers

| Name                                                | Version |
| --------------------------------------------------- | ------- |
| <a name="provider_null"></a> [null](#provider_null) | n/a     |

## Modules

No modules.

## Resources

| Name                                                                                                                 | Type     |
| -------------------------------------------------------------------------------------------------------------------- | -------- |
| [null_resource.nixos-rebuild](https://registry.terraform.io/providers/hashicorp/null/latest/docs/resources/resource) | resource |

## Inputs

| Name                                                                                               | Description                                                                                                                                    | Type     | Default  | Required |
| -------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------- | :------: |
| <a name="input_ignore_systemd_errors"></a> [ignore\_systemd\_errors](#input_ignore_systemd_errors) | Ignore systemd errors happening during deploy                                                                                                  | `bool`   | `false`  |    no    |
| <a name="input_nixos_system"></a> [nixos\_system](#input_nixos_system)                             | The nixos system to deploy                                                                                                                     | `string` | n/a      |   yes    |
| <a name="input_ssh_private_key"></a> [ssh\_private\_key](#input_ssh_private_key)                   | Content of private key used to connect to the target\_host. If set to - no key is passed to openssh and ssh will back to its own configuration | `string` | `"-"`    |    no    |
| <a name="input_target_host"></a> [target\_host](#input_target_host)                                | DNS host to deploy to                                                                                                                          | `string` | n/a      |   yes    |
| <a name="input_target_port"></a> [target\_port](#input_target_port)                                | SSH port used to connect to the target\_host                                                                                                   | `number` | `22`     |    no    |
| <a name="input_target_user"></a> [target\_user](#input_target_user)                                | User to deploy as                                                                                                                              | `string` | `"root"` |    no    |

## Outputs

No outputs.

<!-- END_TF_DOCS -->

'''
'''--- terraform/nixos-rebuild/deploy.sh ---
#!/usr/bin/env bash

set -uex -o pipefail

if [ "$#" -ne 5 ]; then
  echo "USAGE: $0 NIXOS_SYSTEM TARGET_USER TARGET_HOST TARGET_PORT IGNORE_SYSTEMD_ERRORS" >&2
  exit 1
fi

NIXOS_SYSTEM=$1
TARGET_USER=$2
TARGET_HOST=$3
TARGET_PORT=$4
IGNORE_SYSTEMD_ERRORS=$5
shift 3

TARGET="${TARGET_USER}@${TARGET_HOST}"

workDir=$(mktemp -d)
trap 'rm -rf "$workDir"' EXIT

sshOpts=(-p "${TARGET_PORT}")
sshOpts+=(-o UserKnownHostsFile=/dev/null)
sshOpts+=(-o StrictHostKeyChecking=no)

set +x
if [[ -n ${SSH_KEY+x} && ${SSH_KEY} != "-" ]]; then
  sshPrivateKeyFile="$workDir/ssh_key"
  # Create the file with 0700 - umask calculation: 777 - 700 = 077
  (
    umask 077
    echo "$SSH_KEY" >"$sshPrivateKeyFile"
  )
  unset SSH_AUTH_SOCK # don't use system agent if key was supplied
  sshOpts+=(-o "IdentityFile=${sshPrivateKeyFile}")
fi
set -x

try=1
until NIX_SSHOPTS="${sshOpts[*]}" nix copy -s --experimental-features nix-command --to "ssh://$TARGET" "$NIXOS_SYSTEM"; do
  if [[ $try -gt 10 ]]; then
    echo "retries exhausted" >&2
    exit 1
  fi
  sleep 10
  try=$((try + 1))
done

switchCommand="nix-env -p /nix/var/nix/profiles/system --set $(printf "%q" "$NIXOS_SYSTEM"); /nix/var/nix/profiles/system/bin/switch-to-configuration switch"
if [[ $TARGET_USER != "root" ]]; then
  switchCommand="sudo bash -c '$switchCommand'"
fi
deploy_status=0
# shellcheck disable=SC2029
ssh "${sshOpts[@]}" "$TARGET" "$switchCommand" || deploy_status="$?"
if [[ $IGNORE_SYSTEMD_ERRORS == "true" && $deploy_status == "4" ]]; then
  exit 0
fi
exit "$deploy_status"

'''
'''--- terraform/update-docs.sh ---
#!/usr/bin/env bash

set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
files=()
find "${SCRIPT_DIR}"/* -type d | while read -r i; do
  module_name=$(basename "$i")
  markdown_file="${SCRIPT_DIR}/${module_name}.md"
  terraform-docs --config "${SCRIPT_DIR}/.terraform-docs.yml" markdown table --output-file "${markdown_file}" --output-mode inject "${module_name}"
  files+=("${markdown_file}")
done
nix fmt -- "${files[@]}"

'''