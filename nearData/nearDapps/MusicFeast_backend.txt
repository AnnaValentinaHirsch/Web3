*GitHub Repository "MusicFeast/backend"*

'''--- README.md ---
# backend
'''
'''--- contract/marketplace/Cargo.toml ---
[package]
name = "music-feast-market"
version = "0.1.0"
authors = ["Irfianto <irfi@paras.id>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.3"
near-contract-standards = "4.0.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- contract/marketplace/src/external.rs ---
use crate::*;

/// external contract calls

#[ext_contract(ext_contract_transfer)]
trait ExtContractTransfer {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        balance: Option<U128>,
        max_len_payout: Option<u32>,
    );
    fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId, approval_id: Option<u64>, memo: Option<String>);
}

'''
'''--- contract/marketplace/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, serde_json::json, AccountId, Balance,
    BorshStorageKey, CryptoHash, Gas, PanicOnDefault, Promise, Timestamp,
};
use near_sdk::{is_promise_success, promise_result_as_success, PromiseOrValue};
use std::collections::HashMap;

use crate::external::*;

mod external;
mod nft_callbacks;

const GAS_FOR_NFT_TRANSFER: Gas = Gas(20_000_000_000_000);
const BASE_GAS: Gas = Gas(5_000_000_000_000);
const GAS_FOR_ROYALTIES: Gas = Gas(BASE_GAS.0 * 10u64);
const GAS_FOR_CALLBACK_FIRST_TRADE: Gas = Gas(30_000_000_000_000);
const GAS_FOR_CALLBACK_SECOND_TRADE: Gas = Gas(80_000_000_000_000);
//const NO_DEPOSIT: Balance = 0;
const MAX_PRICE: Balance = 1_000_000_000 * 10u128.pow(24);
const MAX_TREASURY_PERCENTAGE: u16 = 10_000;

pub const STORAGE_ADD_MARKET_DATA: u128 = 8590000000000000000000;
pub const FIVE_MINUTES: u64 = 300000000000;

pub type PayoutHashMap = HashMap<AccountId, U128>;
pub type ContractAndTokenId = String;
pub type ContractAccountIdTokenId = String;
pub type TokenId = String;
pub type TokenSeriesId = String;
pub type TimestampSec = u32;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: PayoutHashMap,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TransactionFee {
    pub next_fee: Option<u16>,
    pub start_time: Option<TimestampSec>,
    pub current_fee: u16,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Bid {
    pub bidder_id: AccountId,
    pub price: U128,
}

pub type Bids = Vec<Bid>;

fn near_account() -> AccountId {
    AccountId::new_unchecked("near".to_string())
}

const DELIMETER: &str = "||";
const NEAR: &str = "near";

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketDataV1 {
    pub owner_id: AccountId,
    pub approval_id: u64,
    pub nft_contract_id: AccountId,
    pub token_id: TokenId,
    pub ft_token_id: AccountId,
    pub price: u128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketData {
    pub owner_id: AccountId,
    pub approval_id: u64,
    pub nft_contract_id: AccountId,
    pub token_id: TokenId,
    pub ft_token_id: AccountId, // "near" for NEAR token
    pub price: u128,            // if auction, price becomes starting price
    pub bids: Option<Bids>,
    pub started_at: Option<u64>,
    pub ended_at: Option<u64>,
    pub end_price: Option<u128>, // dutch auction
    pub accept_nft_contract_id: Option<String>,
    pub accept_token_id: Option<String>,
    pub is_auction: Option<bool>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct MarketDataTransactionFee {
    pub transaction_fee: UnorderedMap<ContractAndTokenId, u128>
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OfferData {
    pub buyer_id: AccountId,
    pub nft_contract_id: AccountId,
    pub token_id: Option<TokenId>,
    pub token_series_id: Option<TokenId>,
    pub ft_token_id: AccountId, // "near" for NEAR token
    pub price: u128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OfferDataJson {
    buyer_id: AccountId,
    nft_contract_id: AccountId,
    token_id: Option<TokenId>,
    token_series_id: Option<TokenId>,
    ft_token_id: AccountId, // "near" for NEAR token
    price: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct TradeData {
    pub buyer_amount: Option<Balance>,
    pub seller_amount: Option<Balance>,
    pub ft_token_id: Option<String>,
    pub is_active: Option<bool>,
    pub nft_contract_id: AccountId,
    pub token_id: Option<TokenId>,
    pub token_series_id: Option<TokenSeriesId>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketDataJson {
    owner_id: AccountId,
    approval_id: U64,
    nft_contract_id: AccountId,
    token_id: TokenId,
    ft_token_id: AccountId, // "near" for NEAR token
    price: U128,
    bids: Option<Bids>,
    started_at: Option<U64>,
    ended_at: Option<U64>,
    end_price: Option<U128>, // dutch auction
    is_auction: Option<bool>,
    transaction_fee: U128
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ContractV2 {
    pub owner_id: AccountId,
    pub treasury_id: AccountId,
    pub old_market: UnorderedMap<ContractAndTokenId, MarketDataV1>,
    pub market: UnorderedMap<ContractAndTokenId, MarketData>,
    pub approved_ft_token_ids: UnorderedSet<AccountId>,
    pub approved_nft_contract_ids: UnorderedSet<AccountId>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub offers: UnorderedMap<ContractAccountIdTokenId, OfferData>,
    pub paras_nft_contracts: UnorderedSet<AccountId>,
    pub transaction_fee: TransactionFee,
    pub trades: UnorderedMap<ContractAccountIdTokenId, TradeList>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct TradeList {
    pub approval_id: u64,
    pub trade_data: HashMap<ContractAccountIdTokenId, TradeData>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub treasury_id: AccountId,
    pub old_market: UnorderedMap<ContractAndTokenId, MarketDataV1>,
    pub market: UnorderedMap<ContractAndTokenId, MarketData>,
    pub approved_ft_token_ids: UnorderedSet<AccountId>,
    pub approved_nft_contract_ids: UnorderedSet<AccountId>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub offers: UnorderedMap<ContractAccountIdTokenId, OfferData>,
    pub paras_nft_contracts: UnorderedSet<AccountId>,
    pub transaction_fee: TransactionFee,
    pub trades: UnorderedMap<ContractAccountIdTokenId, TradeList>,
    pub market_data_transaction_fee: MarketDataTransactionFee
}

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Market,
    FTTokenIds,
    NFTContractIds,
    StorageDeposits,
    ByOwnerId,
    ByOwnerIdInner {
        account_id_hash: CryptoHash,
    },
    Offers,
    ParasNFTContractIds,
    MarketV2,
    MarketV3,
    OffersV2,
    ParasNFTContractIdsV2,
    Trade,
    MarketDataTransactionFee
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        owner_id: AccountId,
        treasury_id: AccountId,
        approved_ft_token_ids: Option<Vec<AccountId>>,
        approved_nft_contract_ids: Option<Vec<AccountId>>,
        paras_nft_contracts: Option<Vec<AccountId>>,
        current_fee: u16,
    ) -> Self {
        assert!(current_fee < MAX_TREASURY_PERCENTAGE, "fee is higher than {}", MAX_TREASURY_PERCENTAGE);

        let mut this = Self {
            owner_id: owner_id.into(),
            treasury_id: treasury_id.into(),
            old_market: UnorderedMap::new(StorageKey::Market),
            market: UnorderedMap::new(StorageKey::MarketV2),
            approved_ft_token_ids: UnorderedSet::new(StorageKey::FTTokenIds),
            approved_nft_contract_ids: UnorderedSet::new(StorageKey::NFTContractIds),
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
            by_owner_id: LookupMap::new(StorageKey::ByOwnerId),
            offers: UnorderedMap::new(StorageKey::Offers),
            paras_nft_contracts: UnorderedSet::new(StorageKey::ParasNFTContractIds),
            transaction_fee: TransactionFee {
                next_fee: None,
                start_time: None,
                current_fee,
            },
            trades: UnorderedMap::new(StorageKey::Trade),
            market_data_transaction_fee: MarketDataTransactionFee{
                transaction_fee: UnorderedMap::new(StorageKey::MarketDataTransactionFee)
            }
        };

        this.approved_ft_token_ids.insert(&near_account());

        add_accounts(approved_ft_token_ids, &mut this.approved_ft_token_ids);
        add_accounts(
            approved_nft_contract_ids,
            &mut this.approved_nft_contract_ids,
        );
        add_accounts(paras_nft_contracts, &mut this.paras_nft_contracts);

        this
    }

    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let prev: ContractV2 = env::state_read().expect("ERR_NOT_INITIALIZED");
        assert_eq!(
            env::predecessor_account_id(),
            prev.owner_id,
            "Only owner"
        );

        let this = Contract {
            owner_id: prev.owner_id,
            treasury_id: prev.treasury_id,
            old_market: prev.old_market,
            market: prev.market,
            approved_ft_token_ids: prev.approved_ft_token_ids,
            approved_nft_contract_ids: prev.approved_nft_contract_ids,
            storage_deposits: prev.storage_deposits,
            by_owner_id: prev.by_owner_id,
            offers: prev.offers,
            paras_nft_contracts: prev.paras_nft_contracts,
            transaction_fee: prev.transaction_fee,
            trades: prev.trades,
            market_data_transaction_fee: MarketDataTransactionFee{
                transaction_fee: UnorderedMap::new(StorageKey::MarketDataTransactionFee)
            }
        };

        this
    }
    // Changing treasury & ownership

    #[payable]
    pub fn set_treasury(&mut self, treasury_id: AccountId) {
        assert_one_yocto();
        self.assert_owner();
        self.treasury_id = treasury_id;
    }

    #[payable]
    pub fn set_transaction_fee(&mut self, next_fee: u16, start_time: Option<TimestampSec>) {
        assert_one_yocto();
        self.assert_owner();

        assert!(next_fee < MAX_TREASURY_PERCENTAGE, "fee is higher than {}", MAX_TREASURY_PERCENTAGE);

        if start_time.is_none() {
            self.transaction_fee.current_fee = next_fee;
            self.transaction_fee.next_fee = None;
            self.transaction_fee.start_time = None;
            return;
        } else {
            let start_time: TimestampSec = start_time.unwrap();
            assert!(
                start_time > to_sec(env::block_timestamp()),
                "start_time is less than current block_timestamp"
            );
            self.transaction_fee.next_fee = Some(next_fee);
            self.transaction_fee.start_time = Some(start_time);
        }
    }

    pub fn calculate_market_data_transaction_fee(&mut self, nft_contract_id: &AccountId, token_id: &TokenId) -> u128{
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        if let Some(transaction_fee) = self.market_data_transaction_fee.transaction_fee.get(&contract_and_token_id){
            return transaction_fee;
        }

        // fallback to default transaction fee
        self.calculate_current_transaction_fee()
    }

    pub fn calculate_current_transaction_fee(&mut self) -> u128 {
        let transaction_fee: &TransactionFee = &self.transaction_fee;
        if transaction_fee.next_fee.is_some() {
            if to_sec(env::block_timestamp()) >= transaction_fee.start_time.unwrap() {
                self.transaction_fee.current_fee = transaction_fee.next_fee.unwrap();
                self.transaction_fee.next_fee = None;
                self.transaction_fee.start_time = None;
            }
        }
        self.transaction_fee.current_fee as u128
    }

    pub fn get_transaction_fee(&self) -> &TransactionFee {
        &self.transaction_fee
    }

    pub fn get_market_data_transaction_fee (&self, nft_contract_id: &AccountId, token_id: &TokenId) -> u128{
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        if let Some(transaction_fee) = self.market_data_transaction_fee.transaction_fee.get(&contract_and_token_id){
            return transaction_fee;
        }

        // fallback to default transaction fee
        self.transaction_fee.current_fee as u128
    }

    #[payable]
    pub fn transfer_ownership(&mut self, owner_id: AccountId) {
        assert_one_yocto();
        self.assert_owner();
        self.owner_id = owner_id;
    }

    

    // Approved contracts
    #[payable]
    pub fn add_approved_nft_contract_ids(&mut self, nft_contract_ids: Vec<AccountId>) {
        self.assert_owner();
        add_accounts(Some(nft_contract_ids), &mut self.approved_nft_contract_ids);
    }

    #[payable]
    pub fn remove_approved_nft_contract_ids(&mut self, nft_contract_ids: Vec<AccountId>) {
        self.assert_owner();
        remove_accounts(Some(nft_contract_ids), &mut self.approved_nft_contract_ids);
    }

    // Approved paras contracts
    #[payable]
    pub fn add_approved_paras_nft_contract_ids(&mut self, nft_contract_ids: Vec<AccountId>) {
        self.assert_owner();
        add_accounts(Some(nft_contract_ids), &mut self.paras_nft_contracts);
    }

    #[payable]
    pub fn add_approved_ft_token_ids(&mut self, ft_token_ids: Vec<AccountId>) {
        self.assert_owner();
        add_accounts(Some(ft_token_ids), &mut self.approved_ft_token_ids);
    }

    // Buy & Payment

    #[payable]
    pub fn buy(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
        ft_token_id: Option<AccountId>,
        price: Option<U128>,
    ) {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        let market_data: Option<MarketData> =
            if let Some(market_data) = self.old_market.get(&contract_and_token_id) {
                Some(MarketData {
                    owner_id: market_data.owner_id,
                    approval_id: market_data.approval_id,
                    nft_contract_id: market_data.nft_contract_id,
                    token_id: market_data.token_id,
                    ft_token_id: market_data.ft_token_id,
                    price: market_data.price,
                    bids: None,
                    started_at: None,
                    ended_at: None,
                    end_price: None,
                    accept_nft_contract_id: None,
                    accept_token_id: None,
                    is_auction: None,
                })
            } else if let Some(market_data) = self.market.get(&contract_and_token_id) {
                Some(market_data)
            } else {
                env::panic_str(&"Market data does not exist");
            };

        let market_data: MarketData = market_data.expect("Market data does not exist");

        let buyer_id = env::predecessor_account_id();
        let is_auction = market_data.is_auction.unwrap_or(false);

        assert_ne!(
            buyer_id, market_data.owner_id,
            "Cannot buy your own sale"
        );

        // only NEAR supported for now
        assert_eq!(
            market_data.ft_token_id.to_string(),
            NEAR,
            "NEAR support only"
        );

        assert_eq!(is_auction, false, "the NFT is on auction");

        if ft_token_id.is_some() {
            assert_eq!(
                ft_token_id.unwrap().to_string(),
                market_data.ft_token_id.to_string()
            )
        }
        if price.is_some() {
            assert_eq!(price.unwrap().0, market_data.price);
        }

        let price = market_data.price;

        assert_eq!(
            env::attached_deposit(), price,
            "The attached deposit should be exactly the price {}",
            price
        );

        self.internal_process_purchase(nft_contract_id.into(), token_id, buyer_id, price);
    }

    fn internal_process_purchase(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
        buyer_id: AccountId,
        price: u128,
    ) -> Promise {
        let market_data = self
            .internal_delete_market_data(&nft_contract_id, &token_id)
            .expect("Sale does not exist");

        ext_contract_transfer::ext(nft_contract_id)
            .with_attached_deposit(1)
            .with_static_gas(GAS_FOR_NFT_TRANSFER)
            .nft_transfer_payout(
                buyer_id.clone(),
                token_id,
                Some(market_data.approval_id),
                Some(price.into()),
                Some(50u32)
            ).then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_ROYALTIES)
                    .resolve_purchase(
                        buyer_id,
                        market_data,
                        price.into()
                    )
            )

        /*ext_contract_transfer::nft_transfer_payout(
            buyer_id.clone(),
            token_id,
            Some(market_data.approval_id),
            Some(price.into()),
            Some(50u32), // max length payout
            nft_contract_id,
            1,
            GAS_FOR_NFT_TRANSFER,
        )
        .then(ext_self::resolve_purchase(
            buyer_id,
            market_data,
            price.into(),
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_ROYALTIES,
        ))*/
    }

    #[private]
    pub fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        market_data: MarketData,
        price: U128,
    ) -> U128 {
        let payout_option = promise_result_as_success().and_then(|value| {
            let parsed_payout = near_sdk::serde_json::from_slice::<PayoutHashMap>(&value);
            if parsed_payout.is_err() {
                near_sdk::serde_json::from_slice::<Payout>(&value)
                    .ok()
                    .and_then(|payout| {
                        let mut remainder = price.0;
                        for &value in payout.payout.values() {
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        if remainder <= 100 {
                            Some(payout.payout)
                        } else {
                            None
                        }
                    })
            } else {
                parsed_payout
                    .ok()
                    .and_then(|payout| {
                        let mut remainder = price.0;
                        for &value in payout.values() {
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        if remainder <= 100 {
                            Some(payout)
                        } else {
                            None
                        }
                    })
            }
        });
        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            // leave function and return all FTs in ft_resolve_transfer
            if !is_promise_success() {
                if market_data.ft_token_id == near_account() {
                    self.internal_transfer_near(buyer_id.clone(), u128::from(price))
                }
                env::log_str(
                    &json!({
                    "type": "resolve_purchase_fail",
                    "params": {
                        "owner_id": market_data.owner_id,
                        "nft_contract_id": market_data.nft_contract_id,
                        "token_id": market_data.token_id,
                        "ft_token_id": market_data.ft_token_id,
                        "price": price,
                        "buyer_id": buyer_id,
                    }
                })
                        .to_string(),
                );
            } else if market_data.ft_token_id == near_account() {
                let treasury_fee = price.0 * self.calculate_market_data_transaction_fee(&market_data.nft_contract_id, &market_data.token_id) / (MAX_TREASURY_PERCENTAGE as u128);
                let contract_and_token_id = format!("{}{}{}", &market_data.nft_contract_id, DELIMETER, &market_data.token_id);
                self.market_data_transaction_fee.transaction_fee.remove(&contract_and_token_id);

                let price_after = price.0.saturating_sub(treasury_fee);
                if price_after > 0 {
                    self.internal_transfer_near(market_data.owner_id.clone(), price_after);
                }
                if treasury_fee > 0 {
                    self.internal_transfer_near(self.treasury_id.clone(), price.0.min(treasury_fee));
                }

                env::log_str(
                    &json!({
                    "type": "resolve_purchase",
                    "params": {
                        "owner_id": &market_data.owner_id,
                        "nft_contract_id": &market_data.nft_contract_id,
                        "token_id": &market_data.token_id,
                        "ft_token_id": market_data.ft_token_id,
                        "price": price,
                        "buyer_id": buyer_id,
                    }
                })
                        .to_string(),
                );
            }
            return price;
        };

        // Payout (transfer to royalties and seller)
        if market_data.ft_token_id == near_account() {
            let treasury_fee = (price.0 * self.calculate_market_data_transaction_fee(&market_data.nft_contract_id, &market_data.token_id)) / (MAX_TREASURY_PERCENTAGE as u128);
            let contract_and_token_id = format!("{}{}{}", &market_data.nft_contract_id, DELIMETER, &market_data.token_id);
            self.market_data_transaction_fee.transaction_fee.remove(&contract_and_token_id);

            for (receiver_id, amount) in payout {
                if receiver_id == market_data.owner_id {

                    let amount_after = amount.0.saturating_sub(treasury_fee);
                    if amount_after > 0 {
                        self.internal_transfer_near(receiver_id, amount_after);
                    }

                    if treasury_fee > 0 {
                        self.internal_transfer_near(self.treasury_id.clone(), amount.0.min(treasury_fee));
                    }
                } else {
                    self.internal_transfer_near(receiver_id, amount.0);
                }
            }
            env::log_str(
                &json!({
                    "type": "resolve_purchase",
                    "params": {
                        "owner_id": &market_data.owner_id,
                        "nft_contract_id": &market_data.nft_contract_id,
                        "token_id": &market_data.token_id,
                        "ft_token_id": market_data.ft_token_id,
                        "price": price,
                        "buyer_id": buyer_id,
                    }
                })
                .to_string(),
            );

            let seller_contract_account_id_token_id = make_triple(
                &market_data.nft_contract_id,
                &market_data.owner_id,
                &market_data.token_id,
            );
            self.trades.remove(&seller_contract_account_id_token_id);

            return price;
        } else {
            U128(0)
        }
    }

    // Offer

    fn internal_add_offer(
        &mut self,
        nft_contract_id: AccountId,
        token_id: Option<TokenId>,
        token_series_id: Option<TokenId>,
        ft_token_id: AccountId,
        price: U128,
        buyer_id: AccountId,
    ) {
        let token = if token_id.is_some() {
            token_id.as_ref().unwrap().to_string()
        } else {
            token_series_id.as_ref().unwrap().to_string()
        };

        let contract_account_id_token_id = make_triple(&nft_contract_id, &buyer_id, &token);
        self.offers.insert(
            &contract_account_id_token_id,
            &OfferData {
                buyer_id: buyer_id.clone().into(),
                nft_contract_id: nft_contract_id.into(),
                token_id,
                token_series_id,
                ft_token_id: ft_token_id.into(),
                price: price.into(),
            },
        );

        let mut token_ids = self.by_owner_id.get(&buyer_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByOwnerIdInner {
                    account_id_hash: hash_account_id(&buyer_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        token_ids.insert(&contract_account_id_token_id);
        self.by_owner_id.insert(&buyer_id, &token_ids);
    }

    #[payable]
    pub fn add_offer(
        &mut self,
        nft_contract_id: AccountId,
        token_id: Option<TokenId>,
        token_series_id: Option<String>,
        ft_token_id: AccountId,
        price: U128,
    ) {
        let token = if token_id.is_some() {
            token_id.as_ref().unwrap().to_string()
        } else {
            assert!(
                self.paras_nft_contracts.contains(&nft_contract_id),
                "offer series for NFT only"
            );
            token_series_id.as_ref().unwrap().to_string()
        };

        assert_eq!(
            env::attached_deposit(),
            price.0,
            "Attached deposit != price"
        );

        assert_eq!(
            ft_token_id.to_string(),
            "near",
            "Only NEAR is supported"
        );

        assert!(
            self.approved_nft_contract_ids.contains(&nft_contract_id),
            "nft_contract_id is not approved"
        );

        let buyer_id = env::predecessor_account_id();
        let offer_data = self.internal_delete_offer(
            nft_contract_id.clone().into(),
            buyer_id.clone(),
            token.clone(),
        );

        if let Some(offer) = offer_data{
            // refund previous offer
            self.internal_transfer_near(buyer_id.clone(), offer.price);
        }
  
        let storage_amount = self.storage_minimum_balance().0;
        let owner_paid_storage = self.storage_deposits.get(&buyer_id).unwrap_or(0);
        let signer_storage_required =
            (self.get_supply_by_owner_id(buyer_id.clone()).0 + 1) as u128 * storage_amount;

        assert!(
            owner_paid_storage >= signer_storage_required,
            "Insufficient storage paid: {}, for {} offer at {} rate of per offer",
            owner_paid_storage,
            signer_storage_required / storage_amount,
            storage_amount,
        );

        self.internal_add_offer(
            nft_contract_id.clone().into(),
            token_id.clone(),
            token_series_id.clone(),
            ft_token_id.clone(),
            price,
            buyer_id.clone(),
        );

        env::log_str(
            &json!({
                "type": "add_offer",
                "params": {
                    "buyer_id": buyer_id,
                    "nft_contract_id": nft_contract_id,
                    "token_id": token_id,
                    "token_series_id": token_series_id,
                    "ft_token_id": ft_token_id,
                    "price": price,
                }
            })
            .to_string(),
        );
    }

    fn internal_delete_offer(
        &mut self,
        nft_contract_id: AccountId,
        buyer_id: AccountId,
        token_id: TokenId,
    ) -> Option<OfferData> {
        let contract_account_id_token_id = make_triple(&nft_contract_id, &buyer_id, &token_id);
        let offer_data = self.offers.remove(&contract_account_id_token_id);

        match offer_data {
            Some(offer) => {
                let by_owner_id = self
                    .by_owner_id
                    .get(&offer.buyer_id);
                if let Some(mut by_owner_id) = by_owner_id {
                    by_owner_id.remove(&contract_account_id_token_id);
                    if by_owner_id.is_empty() {
                        self.by_owner_id.remove(&offer.buyer_id);
                    } else {
                        self.by_owner_id.insert(&offer.buyer_id, &by_owner_id);
                    }
                }
                return Some(offer);
            }
            None => return None,
        };
    }

    #[payable]
    pub fn delete_offer(
        &mut self,
        nft_contract_id: AccountId,
        token_id: Option<TokenId>,
        token_series_id: Option<String>,
    ) {
        assert_one_yocto();
        let token = if token_id.is_some() {
            token_id.as_ref().unwrap().to_string()
        } else {
            token_series_id.as_ref().unwrap().to_string()
        };

        let buyer_id = env::predecessor_account_id();
        let contract_account_id_token_id = make_triple(&nft_contract_id, &buyer_id, &token);

        let offer_data = self
            .offers
            .get(&contract_account_id_token_id)
            .expect("Offer does not exist");

        if token_id.is_some() {
            assert_eq!(offer_data.token_id.unwrap(), token)
        } else {
            assert_eq!(offer_data.token_series_id.unwrap(), token)
        }

        assert_eq!(
            offer_data.buyer_id, buyer_id,
            "Caller not offer's buyer"
        );

        self.internal_delete_offer(
            nft_contract_id.clone().into(),
            buyer_id.clone(),
            token.clone(),
        )
        .expect("Offer not found");

        self.internal_transfer_near(offer_data.buyer_id, offer_data.price);

        env::log_str(
            &json!({
                "type": "delete_offer",
                "params": {
                    "nft_contract_id": nft_contract_id,
                    "buyer_id": buyer_id,
                    "token_id": token_id,
                    "token_series_id": token_series_id,
                }
            })
            .to_string(),
        );
    }

    pub fn get_offer(
        &self,
        nft_contract_id: AccountId,
        buyer_id: AccountId,
        token_id: Option<TokenId>,
        token_series_id: Option<String>,
    ) -> OfferDataJson {
        let token = if token_id.is_some() {
            token_id.as_ref().unwrap()
        } else {
            token_series_id.as_ref().unwrap()
        };

        let contract_account_id_token_id = make_triple(&nft_contract_id, &buyer_id, &token);

        let offer_data = self
            .offers
            .get(&contract_account_id_token_id)
            .expect("Offer does not exist");

        if token_id.is_some() {
            assert_eq!(offer_data.token_id.as_ref().unwrap(), token);
        } else {
            assert_eq!(offer_data.token_series_id.as_ref().unwrap(), token);
        }

        OfferDataJson {
            buyer_id: offer_data.buyer_id,
            nft_contract_id: offer_data.nft_contract_id,
            token_id: offer_data.token_id,
            token_series_id: offer_data.token_series_id,
            ft_token_id: offer_data.ft_token_id,
            price: U128(offer_data.price),
        }
    }

    fn internal_update_approval_id(&mut self, approval_id: &u64, nft_contract_id: &AccountId, account_id: &AccountId, token_id: &TokenId){
        let contract_account_id_token_id = make_triple(&nft_contract_id, &account_id, &token_id);
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);

        if let Some(mut trade_data) = self.trades.get(&contract_account_id_token_id){
            trade_data.approval_id = approval_id.clone();
            self.trades.insert(&contract_account_id_token_id, &trade_data);
        }

        if let Some(mut market_data) = self.market.get(&contract_and_token_id){
            market_data.approval_id = approval_id.clone();
            self.market.insert(&contract_and_token_id, &market_data);
        }
    }

    fn internal_accept_offer(
        &mut self,
        nft_contract_id: AccountId,
        buyer_id: AccountId,
        token_id: TokenId,
        seller_id: AccountId,
        approval_id: u64,
        price: u128,
    ) -> PromiseOrValue<bool>{
        let contract_account_id_token_id = make_triple(&nft_contract_id, &buyer_id, &token_id);
        let offer_data_raw = self.offers.get(&contract_account_id_token_id); 

        if offer_data_raw.is_none() {
            self.internal_update_approval_id(&approval_id, &nft_contract_id, &seller_id, &token_id);
            env::log_str("Offer does not exist");
            return PromiseOrValue::Value(false);
        }

        self.internal_delete_market_data(&nft_contract_id, &token_id);

        let offer_data = offer_data_raw.unwrap();

        assert_eq!(offer_data.token_id.as_ref().unwrap(), &token_id);
        assert_eq!(offer_data.price, price);

        let offer_data = self
            .internal_delete_offer(
                nft_contract_id.clone().into(),
                buyer_id.clone(),
                token_id.clone(),
            )
            .expect("Offer does not exist");

        PromiseOrValue::Promise(
            ext_contract_transfer::ext(nft_contract_id)
            .with_attached_deposit(1)
            .with_static_gas(GAS_FOR_NFT_TRANSFER)
            .nft_transfer_payout(
                offer_data.buyer_id.clone(),
                token_id.clone(),
                Some(approval_id),
                Some(U128::from(offer_data.price)),
                Some(50u32),
            ).then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_ROYALTIES)
                    .resolve_offer(
                        seller_id,
                        offer_data,
                        token_id,
                    )
            )
        )

        /*PromiseOrValue::Promise(
            ext_contract_transfer::nft_transfer_payout(
                offer_data.buyer_id.clone(),
                token_id.clone(),
                Some(approval_id),
                Some(U128::from(offer_data.price)),
                Some(50u32), // max length payout
                nft_contract_id,
                1,
                GAS_FOR_NFT_TRANSFER,
            )
            .then(ext_self::resolve_offer(
                seller_id,
                offer_data,
                token_id,
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_ROYALTIES,
            ))
        )*/
    }

    fn internal_accept_offer_series(
        &mut self,
        nft_contract_id: AccountId,
        buyer_id: AccountId,
        token_id: TokenId,
        seller_id: AccountId,
        approval_id: u64,
        price: u128,
    ) -> PromiseOrValue<bool> {
        let mut token_id_iter = token_id.split(":");
        let token_series_id: String = token_id_iter.next().unwrap().parse().unwrap();
        let contract_account_id_token_id =
            make_triple(&nft_contract_id, &buyer_id, &token_series_id);

        let offer_data_raw = self.offers.get(&contract_account_id_token_id);
        if offer_data_raw.is_none() {
            self.internal_update_approval_id(&approval_id, &nft_contract_id, &seller_id, &token_id);
            env::log_str("Offer does not exist");
            return PromiseOrValue::Value(false);
        }

        self.internal_delete_market_data(&nft_contract_id, &token_id);

        let offer_data = offer_data_raw.unwrap(); 

        assert_eq!(
            offer_data.token_series_id.as_ref().unwrap(),
            &token_series_id
        );
        assert_eq!(offer_data.price, price);

        self.internal_delete_offer(
            nft_contract_id.clone().into(),
            buyer_id.clone(),
            token_series_id.clone(),
        )
        .expect("Offer does not exist");

        PromiseOrValue::Promise(
            ext_contract_transfer::ext(nft_contract_id)
                .with_attached_deposit(1)
                .with_static_gas(GAS_FOR_NFT_TRANSFER)
                .nft_transfer_payout(
                    offer_data.buyer_id.clone(),
                    token_id.clone(),
                    Some(approval_id),
                    Some(U128::from(offer_data.price)),
                    Some(50u32),
                ).then(
                    ext_self::ext(env::current_account_id())
                        .with_static_gas(GAS_FOR_ROYALTIES)
                        .resolve_offer(
                            seller_id,
                            offer_data,
                            token_id,
                        )
                )
        )

        /*PromiseOrValue::Promise(
            ext_contract_transfer::nft_transfer_payout(
                offer_data.buyer_id.clone(),
                token_id.clone(),
                Some(approval_id),
                Some(U128::from(offer_data.price)),
                Some(50u32), // max length payout
                nft_contract_id,
                1,
                GAS_FOR_NFT_TRANSFER,
            )
            .then(ext_self::resolve_offer(
                seller_id,
                offer_data,
                token_id,
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_ROYALTIES,
            ))
        )*/
    }

    #[private]
    pub fn resolve_offer(
        &mut self,
        seller_id: AccountId,
        offer_data: OfferData,
        token_id: TokenId,
    ) -> U128 {
        let payout_option = promise_result_as_success().and_then(|value| {
            // None means a bad payout from bad NFT contract
            let parsed_payout = near_sdk::serde_json::from_slice::<PayoutHashMap>(&value);
            if parsed_payout.is_err() {
                near_sdk::serde_json::from_slice::<Payout>(&value)
                    .ok()
                    .and_then(|payout| {
                        let mut remainder = offer_data.price;
                        for &value in payout.payout.values() {
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        if remainder <= 100 {
                            Some(payout.payout)
                        } else {
                            None
                        }
                    })
            } else {
                parsed_payout.ok().and_then(|payout| {
                    let mut remainder = offer_data.price;
                    for &value in payout.values() {
                        remainder = remainder.checked_sub(value.0)?;
                    }
                    if remainder <= 100 {
                        Some(payout)
                    } else {
                        None
                    }
                })
            }
        });

        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            if !is_promise_success() {
                if offer_data.ft_token_id == near_account() {
                    self.internal_transfer_near(offer_data.buyer_id.clone(), u128::from(offer_data.price));
                    env::log_str(
                        &json!({
                    "type": "resolve_purchase_fail",
                    "params": {
                        "owner_id": seller_id,
                        "nft_contract_id": offer_data.nft_contract_id,
                        "token_id": token_id,
                        "token_series_id": offer_data.token_series_id,
                        "ft_token_id": offer_data.ft_token_id,
                        "price": offer_data.price.to_string(),
                        "buyer_id": offer_data.buyer_id,
                        "is_offer": true,
                    }
                }).to_string(),
                    );
                }
            } else if offer_data.ft_token_id == near_account() {
                let treasury_fee =
                    offer_data.price as u128 * self.calculate_current_transaction_fee() / (MAX_TREASURY_PERCENTAGE as u128);

                let amount_after = offer_data.price.saturating_sub(treasury_fee);
                if amount_after > 0 {
                    self.internal_transfer_near(seller_id.clone(), amount_after);
                }

                if treasury_fee > 0 {
                    self.internal_transfer_near(self.treasury_id.clone(), offer_data.price.min(treasury_fee));
                }

                env::log_str(
                    &json!({
                    "type": "resolve_purchase",
                    "params": {
                        "owner_id": seller_id,
                        "nft_contract_id": &offer_data.nft_contract_id,
                        "token_id": &token_id,
                        "token_series_id": offer_data.token_series_id,
                        "ft_token_id": offer_data.ft_token_id,
                        "price": offer_data.price.to_string(),
                        "buyer_id": offer_data.buyer_id,
                        "is_offer": true,
                    }
                })
                        .to_string(),
                );
            }
            return offer_data.price.into();
        };

        // Payout (transfer to royalties and seller)
        if offer_data.ft_token_id == near_account() {
            // 5% fee for treasury
            let treasury_fee =
                offer_data.price as u128 * self.calculate_current_transaction_fee() / (MAX_TREASURY_PERCENTAGE as u128);

            for (receiver_id, amount) in payout {
                if receiver_id == seller_id {
                    let amount_after = amount.0.saturating_sub(treasury_fee);
                    if amount_after > 0 {
                        self.internal_transfer_near(receiver_id, amount_after);
                    }
                    if treasury_fee > 0 {
                        self.internal_transfer_near(self.treasury_id.clone(), amount.0.min(treasury_fee));
                    }
                } else {
                    self.internal_transfer_near(receiver_id, amount.0)
                }
            }

            env::log_str(
                &json!({
                    "type": "resolve_purchase",
                    "params": {
                        "owner_id": seller_id,
                        "nft_contract_id": &offer_data.nft_contract_id,
                        "token_id": &token_id,
                        "token_series_id": offer_data.token_series_id,
                        "ft_token_id": offer_data.ft_token_id,
                        "price": offer_data.price.to_string(),
                        "buyer_id": offer_data.buyer_id,
                        "is_offer": true,
                    }
                })
                .to_string(),
            );

            let seller_contract_account_id_token_id =
                make_triple(&offer_data.nft_contract_id, &seller_id, &token_id);
            self.trades.remove(&seller_contract_account_id_token_id);

            return offer_data.price.into();
        } else {
            U128(0)
        }
    }

    // Trade
    fn add_trade(
        &mut self,
        nft_contract_id: AccountId,
        token_id: Option<TokenId>,
        token_series_id: Option<TokenSeriesId>,
        buyer_nft_contract_id: AccountId,
        buyer_id: AccountId,
        buyer_token_id: Option<TokenId>,
        buyer_approval_id: u64,
    ) {
        self.internal_add_trade(
            nft_contract_id.clone().into(),
            token_id.clone(),
            token_series_id.clone(),
            buyer_nft_contract_id.clone().into(),
            buyer_token_id.clone(),
            buyer_id.clone(),
            buyer_approval_id.clone(),
        );

        env::log_str(
            &json!({
                "type": "add_trade",
                "params": {
                    "buyer_id": buyer_id,
                    "nft_contract_id": nft_contract_id,
                    "token_id": token_id,
                    "token_series_id": token_series_id,
                    "buyer_nft_contract_id": buyer_nft_contract_id,
                    "buyer_token_id": buyer_token_id,
                    "buyer_approval_id": buyer_approval_id
                }
            })
            .to_string(),
        );
    }

    fn internal_add_trade(
        &mut self,
        nft_contract_id: AccountId,
        token_id: Option<TokenId>,
        token_series_id: Option<TokenSeriesId>,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: Option<TokenId>,
        buyer_id: AccountId,
        buyer_approval_id: u64,
    ) {
        let token = if token_id.is_some() {
            token_id.as_ref().unwrap().to_string()
        } else {
            assert!(
                self.paras_nft_contracts.contains(&nft_contract_id),
                "trade series for NFT only"
            );
            token_series_id.as_ref().unwrap().to_string()
        };

        let contract_account_id_token_id = make_triple(&nft_contract_id, &buyer_id, &token);
        let buyer_contract_account_id_token_id = make_triple(
            &buyer_nft_contract_id,
            &buyer_id,
            &buyer_token_id
                .as_ref()
                .expect("Buyer token id is not specified"),
        );

        let trade_data = TradeData {
            buyer_amount: None,
            seller_amount: None,
            is_active: None,
            ft_token_id: None,
            nft_contract_id: nft_contract_id.into(),
            token_id,
            token_series_id,
        };
        let mut buyer_trade_list = self
            .trades
            .get(&buyer_contract_account_id_token_id)
            .unwrap_or_else(|| {
                TradeList {
                    approval_id: 0, //init
                    trade_data: HashMap::new(),
                }
            });
        buyer_trade_list.approval_id = buyer_approval_id;
        buyer_trade_list
            .trade_data
            .insert(contract_account_id_token_id.clone(), trade_data);

        self.trades
            .insert(&buyer_contract_account_id_token_id, &buyer_trade_list);

        let mut token_ids = self.by_owner_id.get(&buyer_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByOwnerIdInner {
                    account_id_hash: hash_account_id(&buyer_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        token_ids.insert(&make_key_owner_by_id_trade(contract_account_id_token_id));
        self.by_owner_id.insert(&buyer_id, &token_ids);
    }

    #[payable]
    pub fn delete_trade(
        &mut self,
        nft_contract_id: AccountId,
        token_id: Option<TokenId>,
        token_series_id: Option<TokenSeriesId>,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: TokenId,
    ) {
        assert_one_yocto();
        let token = if token_id.is_some() {
            token_id.as_ref().unwrap().to_string()
        } else {
            token_series_id.as_ref().unwrap().to_string()
        };

        let buyer_id = env::predecessor_account_id();
        let buyer_contract_account_id_token_id =
            make_triple(&buyer_nft_contract_id, &buyer_id, &buyer_token_id);
        let contract_account_id_token_id = make_triple(&nft_contract_id, &buyer_id, &token);

        let trade_list = self
            .trades
            .get(&buyer_contract_account_id_token_id)
            .expect("Trade list does not exist");

        let trade_data = trade_list
            .trade_data
            .get(&contract_account_id_token_id)
            .expect("Trade data does not exist");

        if token_id.is_some() {
            assert_eq!(trade_data.clone().token_id.unwrap(), token)
        } else {
            assert_eq!(trade_data.clone().token_series_id.unwrap(), token)
        }

        self.internal_delete_trade(
            buyer_id.clone(),
            buyer_contract_account_id_token_id,
            contract_account_id_token_id
        )
        .expect("Trade not found");

        env::log_str(
            &json!({
                "type": "delete_trade",
                "params": {
                    "nft_contract_id": nft_contract_id,
                    "buyer_id": buyer_id,
                    "token_id": token_id,
                    "token_series_id": token_series_id,
                    "buyer_nft_contract_id": buyer_nft_contract_id,
                    "buyer_token_id": buyer_token_id
                }
            })
            .to_string(),
        );
    }

    fn internal_delete_trade(
        &mut self,
        buyer_id: AccountId,
        buyer_contract_account_id_token_id: String,
        contract_account_id_token_id: String,
    ) -> Option<TradeData> {
        let mut trade_list = self
            .trades
            .get(&buyer_contract_account_id_token_id)
            .expect("Trade list does not exist");

        let trade_data = trade_list.trade_data.remove(&contract_account_id_token_id).unwrap();

        self.trades
            .insert(&buyer_contract_account_id_token_id, &trade_list);

        let mut by_owner_id = self
            .by_owner_id
            .get(&buyer_id)
            .expect("no market data by account_id");

        by_owner_id.remove(&make_key_owner_by_id_trade(contract_account_id_token_id));

        if by_owner_id.is_empty() {
            self.by_owner_id.remove(&buyer_id);
        } else {
            self.by_owner_id.insert(&buyer_id, &by_owner_id);
        }

        return Some(trade_data);
    }

    pub fn get_trade(
        &self,
        seller_nft_contract_id: AccountId,
        seller_token_id: Option<TokenId>,
        seller_token_series_id: Option<String>,
        buyer_id: AccountId,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: TokenId,
    ) -> TradeData {
        let token = if seller_token_id.is_some() {
            seller_token_id.as_ref().unwrap()
        } else {
            seller_token_series_id.as_ref().unwrap()
        };

        let contract_account_id_token_id = make_triple(&seller_nft_contract_id, &buyer_id, &token);
        let buyer_contract_account_id_token_id =
            make_triple(&buyer_nft_contract_id, &buyer_id, &buyer_token_id);

        let trade_list = self
            .trades
            .get(&buyer_contract_account_id_token_id)
            .expect("Trade list does not exist");

        let trade_data = trade_list
            .trade_data
            .get(&contract_account_id_token_id)
            .expect("Trade data does not exist");

        if seller_token_id.is_some() {
            assert_eq!(trade_data.token_id.as_ref().unwrap(), token);
        } else {
            assert_eq!(trade_data.token_series_id.as_ref().unwrap(), token);
        }

        return trade_data.clone()
    }

    fn internal_accept_trade(
        &mut self,
        nft_contract_id: AccountId,
        buyer_id: AccountId,
        token_id: TokenId,
        seller_id: AccountId,
        approval_id: u64,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: TokenId,
    ) -> Promise {
        let buyer_contract_account_id_token_id =
            make_triple(&buyer_nft_contract_id, &buyer_id, &buyer_token_id);
        let contract_account_id_token_id = make_triple(&nft_contract_id, &buyer_id, &token_id);

        let trade_list = self
            .trades
            .get(&buyer_contract_account_id_token_id)
            .expect("Trade list does not exist");

        trade_list
            .trade_data
            .get(&contract_account_id_token_id)
            .expect("Trade data does not exist");

        self.internal_delete_market_data(&nft_contract_id, &token_id);
        self.internal_delete_market_data(&buyer_nft_contract_id, &buyer_token_id);

        let seller_contract_account_id_token_id =
            make_triple(&nft_contract_id, &seller_id, &token_id);

        if let Some(mut trades) = self.trades.get(&seller_contract_account_id_token_id){
            trades.trade_data.clear();
        }
        if let Some(mut trades) = self.trades.get(&buyer_contract_account_id_token_id){
            trades.trade_data.clear();
        }
        self.trades.remove(&seller_contract_account_id_token_id);
        self.trades.remove(&buyer_contract_account_id_token_id);

        self.trade_swap_nft(
            buyer_id,
            buyer_nft_contract_id,
            buyer_token_id,
            trade_list.approval_id,
            seller_id,
            nft_contract_id,
            token_id,
            approval_id,
        )
    }

    fn internal_accept_trade_series(
        &mut self,
        nft_contract_id: AccountId,
        buyer_id: AccountId,
        token_id: TokenId,
        seller_id: AccountId,
        approval_id: u64,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: TokenId,
    ) -> Promise {
        // Token delimiter : is specific for NFT
        let mut token_id_iter = token_id.split(":");
        let token_series_id: String = token_id_iter.next().unwrap().parse().unwrap();

        let buyer_contract_account_id_token_id =
            make_triple(&buyer_nft_contract_id, &buyer_id, &buyer_token_id);
        let contract_account_id_token_id =
            make_triple(&nft_contract_id, &buyer_id, &token_series_id);

        let trade_list = self
            .trades
            .get(&buyer_contract_account_id_token_id)
            .expect("Trade list does not exist");

        let trade_data = trade_list
            .trade_data
            .get(&contract_account_id_token_id)
            .expect("Trade data does not exist");

        assert_eq!(
            trade_data.token_series_id.as_ref().unwrap(),
            &token_series_id
        );

        self.internal_delete_market_data(&nft_contract_id, &token_id);
        self.internal_delete_market_data(&buyer_nft_contract_id, &buyer_token_id);

        let seller_contract_account_id_token_id =
            make_triple(&nft_contract_id, &seller_id, &token_id);
        self.trades.remove(&seller_contract_account_id_token_id);
        self.trades.remove(&buyer_contract_account_id_token_id);

        self.trade_swap_nft(
            buyer_id,
            buyer_nft_contract_id,
            buyer_token_id,
            trade_list.approval_id,
            seller_id,
            nft_contract_id,
            token_id,
            approval_id,
        )
    }

    fn trade_swap_nft(
        &mut self,
        buyer_id: AccountId,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: TokenId,
        buyer_approval_id: u64,
        seller_id: AccountId,
        seller_nft_contract_id: AccountId,
        seller_token_id: TokenId,
        seller_approval_id: u64,
    ) -> Promise {
        // 1. transfer buyer & seller NFT to marketplace
        // 2. verify that those NFTs is valid and has approval_id
        // 3. if those NFTs is valid then swap token to buyer & seller
        // 4. if failed then rollback the NFT to buyer or seller

        
        ext_contract_transfer::ext(buyer_nft_contract_id.clone())
            .with_attached_deposit(1)
            .with_static_gas(GAS_FOR_NFT_TRANSFER)
            .nft_transfer(
                env::current_account_id(),
                buyer_token_id.clone(),
                Some(buyer_approval_id),
                None,
            ).then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_CALLBACK_FIRST_TRADE)
                    .callback_first_trade(
                        seller_nft_contract_id.clone(),
                        seller_token_id.clone(),
                        seller_approval_id,
                    )
            ).then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_CALLBACK_SECOND_TRADE)
                    .callback_second_trade(
                        buyer_id,
                        buyer_nft_contract_id.clone(),
                        buyer_token_id.clone(),
                        seller_id,
                        seller_nft_contract_id.clone(),
                        seller_token_id.clone(),
                    )
            )
        

        /*ext_contract_transfer::nft_transfer(
            env::current_account_id(),
            buyer_token_id.clone(),
            Some(buyer_approval_id),
            None,
            buyer_nft_contract_id.clone(),
            1,
            GAS_FOR_NFT_TRANSFER,
        )
        .then(ext_self::callback_first_trade(
            seller_nft_contract_id.clone(),
            seller_token_id.clone(),
            seller_approval_id,
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_CALLBACK_FIRST_TRADE,
        ))
        .then(ext_self::callback_second_trade(
            buyer_id,
            buyer_nft_contract_id.clone(),
            buyer_token_id.clone(),
            seller_id,
            seller_nft_contract_id.clone(),
            seller_token_id.clone(),
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_CALLBACK_SECOND_TRADE,
        ))*/
    }

    #[private]
    pub fn callback_first_trade(
        &mut self,
        seller_nft_contract_id: AccountId,
        seller_token_id: TokenId,
        seller_approval_id: u64,
    ) -> Promise {
        if !is_promise_success() {
            env::panic_str(&"buyer's nft failed to trade");
        } else {
            return ext_contract_transfer::ext(seller_nft_contract_id.clone())
                .with_attached_deposit(1)
                .with_static_gas(GAS_FOR_NFT_TRANSFER)
                .nft_transfer(
                    env::current_account_id(),
                    seller_token_id.clone(),
                    Some(seller_approval_id),
                    None,
                );

            /*return ext_contract_transfer::nft_transfer(
                env::current_account_id(),
                seller_token_id.clone(),
                Some(seller_approval_id),
                None,
                seller_nft_contract_id.clone(),
                1,
                GAS_FOR_NFT_TRANSFER,
            );*/
        }
    }

    #[private]
    pub fn callback_second_trade(
        &mut self,
        buyer_id: AccountId,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: TokenId,
        seller_id: AccountId,
        seller_nft_contract_id: AccountId,
        seller_token_id: TokenId,
    ) {
        if !is_promise_success() {
            ext_contract_transfer::ext(buyer_nft_contract_id.clone())
                .with_attached_deposit(1)
                .with_static_gas(GAS_FOR_NFT_TRANSFER)
                .nft_transfer(
                    buyer_id,
                    buyer_token_id,
                    None,
                    None,
                );

            /*ext_contract_transfer::nft_transfer(
                buyer_id,
                buyer_token_id,
                None,
                None,
                buyer_nft_contract_id,
                1,
                GAS_FOR_NFT_TRANSFER,
            );*/

            env::panic_str(&"seller's nft failed to trade, rollback buyer's nft");
        } else {
            self.internal_swap_nft(
                buyer_id,
                buyer_nft_contract_id,
                buyer_token_id,
                seller_id,
                seller_nft_contract_id,
                seller_token_id,
            );
        }
    }

    fn internal_swap_nft(
        &mut self,
        buyer_id: AccountId,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: TokenId,
        seller_id: AccountId,
        seller_nft_contract_id: AccountId,
        seller_token_id: TokenId,
    ) {
        ext_contract_transfer::ext(buyer_nft_contract_id.clone())
            .with_attached_deposit(1)
            .with_static_gas(GAS_FOR_NFT_TRANSFER)
            .nft_transfer(
                seller_id.clone(),
                buyer_token_id.clone(),
                None,
                None,
            )
            .then(ext_contract_transfer::ext(seller_nft_contract_id.clone())
                .with_attached_deposit(1)
                .with_static_gas(GAS_FOR_NFT_TRANSFER)
                .nft_transfer(
                    buyer_id.clone(),
                    seller_token_id.clone(),
                    None,
                    None,
            ));

        /*ext_contract_transfer::nft_transfer(
            seller_id.clone(),
            buyer_token_id.clone(),
            None,
            None,
            buyer_nft_contract_id.clone(),
            1,
            GAS_FOR_NFT_TRANSFER,
        )
        .then(ext_contract_transfer::nft_transfer(
            buyer_id.clone(),
            seller_token_id.clone(),
            None,
            None,
            seller_nft_contract_id.clone(),
            1,
            GAS_FOR_NFT_TRANSFER,
        ));*/

        env::log_str(
            &json!({
                "type": "accept_trade",
                "params": {
                    "sender_id": seller_id,
                    "buyer_id": buyer_id,
                    "nft_contract_id": seller_nft_contract_id,
                    "token_id": seller_token_id,
                    "buyer_nft_contract_id": buyer_nft_contract_id,
                    "buyer_token_id": buyer_token_id,
                }
            })
            .to_string(),
        );
    }

    // Auction bids
    #[payable]
    pub fn add_bid(
        &mut self,
        nft_contract_id: AccountId,
        ft_token_id: AccountId,
        token_id: TokenId,
        amount: U128,
    ) {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        let mut market_data = self
            .market
            .get(&contract_and_token_id)
            .expect("Token id does not exist");

        assert_eq!(market_data.is_auction.unwrap(), true, "not auction");

        let bidder_id = env::predecessor_account_id();
        let current_time = env::block_timestamp();

        assert!(
            current_time >= market_data.started_at.unwrap(),
            "Sale has not started yet"
        );

        assert!(
            current_time <= market_data.ended_at.unwrap(),
            "Sale has ended"
        );

        let remaining_time = market_data.ended_at.unwrap() - current_time;
        if remaining_time <= FIVE_MINUTES {
          let extended_ended_at = market_data.ended_at.unwrap() + FIVE_MINUTES;
          market_data.ended_at = Some(extended_ended_at);

          env::log_str(
            &json!({
                "type": "extend_auction",
                "params": {
                    "nft_contract_id": nft_contract_id,
                    "token_id": token_id,
                    "ended_at": extended_ended_at,
                }
            })
            .to_string(),
          );
        }

        assert_ne!(market_data.owner_id, bidder_id, "Owner cannot bid their own token");

        assert!(
            env::attached_deposit() >= amount.into(),
            "attached deposit is less than amount"
        );

        assert_eq!(ft_token_id.to_string(), "near", "Only support NEAR");

        let new_bid = Bid {
            bidder_id: bidder_id.clone(),
            price: amount.into(),
        };

        let mut bids = market_data.bids.unwrap_or(Vec::new());

        if !bids.is_empty() {
            let current_bid = &bids[bids.len() - 1];

            assert!(
              amount.0 >= current_bid.price.0 + (current_bid.price.0 * 5 / 100),
              "Can't pay less than or equal to current bid price + 5% : {:?}",
              current_bid.price.0 + (current_bid.price.0 * 5 / 100)
            );

            assert!(
                amount.0 >= market_data.price,
                "Can't pay less than starting price: {:?}",
                U128(market_data.price)
            );

            // Retain all elements except account_id
            bids.retain(|bid| {
              if bid.bidder_id == bidder_id {
                // refund
                self.internal_transfer_near(bid.bidder_id.clone(), bid.price.0);
              }

              bid.bidder_id != bidder_id
            });
        } else {
            assert!(
                amount.0 >= market_data.price,
                "Can't pay less than starting price: {:?}",
                market_data.price
            );
        }

        bids.push(new_bid);
        market_data.bids = Some(bids);
        self.market.insert(&contract_and_token_id, &market_data);

        // Remove first element if bids.length >= 100
        let updated_bids = market_data.bids.unwrap_or(Vec::new());
        if updated_bids.len() >= 100 {
          self.internal_cancel_bid(nft_contract_id.clone(), token_id.clone(), updated_bids[0].bidder_id.clone())
        }

        env::log_str(
            &json!({
                "type": "add_bid",
                "params": {
                    "bidder_id": bidder_id,
                    "nft_contract_id": nft_contract_id,
                    "token_id": token_id,
                    "ft_token_id": ft_token_id,
                    "amount": amount,
                }
            })
            .to_string(),
        );
    }

    fn internal_cancel_bid(&mut self, nft_contract_id: AccountId, token_id: TokenId, account_id: AccountId) {
      let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
      let mut market_data = self
        .market
        .get(&contract_and_token_id)
        .expect("Token id does not exist");

      let mut bids = market_data.bids.unwrap();

      assert!(
        !bids.is_empty(),
        "Bids data does not exist"
      );

      // Retain all elements except account_id
      bids.retain(|bid| {
        if bid.bidder_id == account_id {
          // refund
            self.internal_transfer_near(bid.bidder_id.clone(), bid.price.0);
        }

        bid.bidder_id != account_id
      });

      market_data.bids = Some(bids);
      self.market.insert(&contract_and_token_id, &market_data);

      env::log_str(
        &json!({
          "type": "cancel_bid",
          "params": {
            "bidder_id": account_id, "nft_contract_id": nft_contract_id, "token_id": token_id
          }
        })
        .to_string(),
      );
    }

    #[payable]
    pub fn cancel_bid(&mut self, nft_contract_id: AccountId, token_id: TokenId, account_id: AccountId) {
      assert_one_yocto();
      let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
      let market_data = self
        .market
        .get(&contract_and_token_id)
        .expect("Token id does not exist");

      let bids = market_data.bids.unwrap();

      assert!(
        !bids.is_empty(),
        "Bids data does not exist"
      );

      for x in 0..bids.len() {
        if bids[x].bidder_id == account_id {
          assert!(
            [bids[x].bidder_id.clone(), self.owner_id.clone()]
              .contains(&env::predecessor_account_id()),
              "Bidder or owner only"
          );
        }
      }

      self.internal_cancel_bid(nft_contract_id, token_id, account_id);
    }

    #[payable]
    pub fn accept_bid(&mut self, nft_contract_id: AccountId, token_id: TokenId) {
        let predecessor_account_id = env::predecessor_account_id();
        if predecessor_account_id != self.owner_id {
            assert_one_yocto();
        }
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        let mut market_data = self
            .market
            .get(&contract_and_token_id)
            .expect("Token id does not exist");

        assert_eq!(market_data.is_auction.unwrap(), true, "not auction");
        let current_time: u64 = env::block_timestamp();

        assert!(
            [market_data.owner_id.clone(), self.owner_id.clone()]
            .contains(&predecessor_account_id),
            "Seller or owner only"
        );

        if predecessor_account_id == self.owner_id && market_data.ended_at.is_some() {
          assert!(
            current_time >= market_data.ended_at.unwrap(),
            "Auction has not ended yet"
          );
        }

        let mut bids = market_data.bids.unwrap();

        assert!(!bids.is_empty(), "Cannot accept bid with empty bid");

        let selected_bid = bids.remove(bids.len() - 1);

        // refund all except selected bids
        for bid in &bids {
          // refund
            self.internal_transfer_near(bid.bidder_id.clone(), bid.price.0);
        }
        bids.clear();

        market_data.bids = Some(bids);
        self.market.insert(&contract_and_token_id, &market_data);

        self.internal_process_purchase(
            market_data.nft_contract_id,
            token_id,
            selected_bid.bidder_id.clone(),
            selected_bid.price.clone().0,
        );
    }

    #[payable]
    pub fn end_auction(&mut self, nft_contract_id: AccountId, token_id: TokenId) {
      let predecessor_account_id = env::predecessor_account_id();
      if predecessor_account_id != self.owner_id {
          assert_one_yocto();
      }

      let current_time = env::block_timestamp();
      let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, &token_id);
      let mut market_data = self
          .market
          .get(&contract_and_token_id)
          .expect("Market data does not exist");

      assert_eq!(market_data.is_auction.unwrap(), true, "not auction");
      assert!(
        [market_data.owner_id.clone(), self.owner_id.clone()]
          .contains(&predecessor_account_id),
        "Seller or owner only"
      );

      if predecessor_account_id == self.owner_id && market_data.ended_at.is_some() {
        assert!(
          current_time >= market_data.ended_at.unwrap(),
          "Auction has not ended yet (for owner)"
        );
      }

      let mut bids = market_data.bids.unwrap();

      if bids.is_empty() {
        self.internal_delete_market_data(&nft_contract_id, &token_id);

        env::log_str(
            &json!({
                "type": "delete_market_data",
                "params": {
                    "owner_id": market_data.owner_id,
                    "nft_contract_id": nft_contract_id,
                    "token_id": token_id,
                }
            })
            .to_string(),
        );
      } else {
        let selected_bid = bids.remove(bids.len() - 1);

        // refund all except selected bids
        for bid in &bids {
            self.internal_transfer_near(bid.bidder_id.clone(), bid.price.0);
        }

        bids.clear();

        market_data.bids = Some(bids);
        self.market.insert(&contract_and_token_id, &market_data);

        self.internal_process_purchase(
            nft_contract_id,
            token_id,
            selected_bid.bidder_id.clone(),
            selected_bid.price.clone().0
        );
      }
    }

    fn internal_add_market_data(
        &mut self,
        owner_id: AccountId,
        approval_id: u64,
        nft_contract_id: AccountId,
        token_id: TokenId,
        ft_token_id: AccountId,
        price: U128,
        mut started_at: Option<U64>,
        ended_at: Option<U64>,
        end_price: Option<U128>,
        is_auction: Option<bool>,
    ) {
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);

        let bids: Option<Bids> = match is_auction {
            Some(u) => {
                if u {
                    Some(Vec::new())
                } else {
                    None
                }
            }
            None => None,
        };

        let current_time: u64 = env::block_timestamp();

        if let Some(is_auction) = is_auction {
          if let Some(started_at) = started_at {
              assert!(started_at.0 >= current_time);

              if let Some(ended_at) = ended_at {
                assert!(started_at.0 < ended_at.0);
              }
          }

            if is_auction == true {
                if started_at.is_none() {
                    started_at = Some(U64(current_time));
                }

                assert!(ended_at.is_some(), "Ended at is none");

                if let Some(ended_at) = ended_at {
                  assert!(ended_at.0 >= current_time);
                }
            }
        }

        assert!(
            price.0 < MAX_PRICE,
            "price higher than {}",
            MAX_PRICE
        );

        self.market.insert(
            &contract_and_token_id,
            &MarketData {
                owner_id: owner_id.clone().into(),
                approval_id,
                nft_contract_id: nft_contract_id.clone().into(),
                token_id: token_id.clone(),
                ft_token_id: ft_token_id.clone(),
                price: price.into(),
                bids,
                started_at: match started_at {
                    Some(x) => Some(x.0),
                    None => None,
                },
                ended_at: match ended_at {
                    Some(x) => Some(x.0),
                    None => None,
                },
                end_price: match end_price {
                    Some(x) => Some(x.0),
                    None => None,
                },
                accept_nft_contract_id: None,
                accept_token_id: None,
                is_auction,
            },
        );

        let mut token_ids = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByOwnerIdInner {
                    account_id_hash: hash_account_id(&owner_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        token_ids.insert(&contract_and_token_id);

        self.by_owner_id.insert(&owner_id, &token_ids);

        // update offer trade approval_id
        let owner_contract_account_id_token_id =
            make_triple(&nft_contract_id, &owner_id, &token_id);
        let trade_data = self.trades.get(&owner_contract_account_id_token_id);
        if let Some(mut trade_list) = trade_data {
            trade_list.approval_id = approval_id;
            self.trades
                .insert(&owner_contract_account_id_token_id, &trade_list);
        }

        // set market data transaction fee
        let current_transaction_fee = self.calculate_current_transaction_fee();
        self.market_data_transaction_fee.transaction_fee.insert(&contract_and_token_id, &current_transaction_fee);

        env::log_str(
            &json!({
                "type": "add_market_data",
                "params": {
                    "owner_id": owner_id,
                    "approval_id": approval_id,
                    "nft_contract_id": nft_contract_id,
                    "token_id": token_id,
                    "ft_token_id": ft_token_id,
                    "price": price,
                    "started_at": started_at,
                    "ended_at": ended_at,
                    "end_price": end_price,
                    "is_auction": is_auction,
                    "transaction_fee": current_transaction_fee.to_string(),
                }
            })
            .to_string(),
        );
    }

    fn internal_delete_market_data(
        &mut self,
        nft_contract_id: &AccountId,
        token_id: &TokenId,
    ) -> Option<MarketData> {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);

        let market_data: Option<MarketData> =
            if let Some(market_data) = self.old_market.get(&contract_and_token_id) {
                self.old_market.remove(&contract_and_token_id);
                Some(MarketData {
                    owner_id: market_data.owner_id,
                    approval_id: market_data.approval_id,
                    nft_contract_id: market_data.nft_contract_id,
                    token_id: market_data.token_id,
                    ft_token_id: market_data.ft_token_id,
                    price: market_data.price,
                    bids: None,
                    started_at: None,
                    ended_at: None,
                    end_price: None,
                    accept_nft_contract_id: None,
                    accept_token_id: None,
                    is_auction: None,
                })
            } else if let Some(market_data) = self.market.get(&contract_and_token_id) {
                self.market.remove(&contract_and_token_id);

                if let Some(ref bids) = market_data.bids {
                    for bid in bids {
                        self.internal_transfer_near(bid.bidder_id.clone(), bid.price.0);
                    }
                };

                Some(market_data)
            } else {
                None
            };

        market_data.map(|market_data| {
            let by_owner_id = self
                .by_owner_id
                .get(&market_data.owner_id);
            if let Some(mut by_owner_id) = by_owner_id {
                by_owner_id.remove(&contract_and_token_id);
                if by_owner_id.is_empty() {
                self.by_owner_id.remove(&market_data.owner_id);
                } else {
                self.by_owner_id.insert(&market_data.owner_id, &by_owner_id);
                }
            }
            market_data
        })
    }

    #[payable]
    pub fn delete_market_data(&mut self, nft_contract_id: AccountId, token_id: TokenId) {
        let predecessor_account_id = env::predecessor_account_id();
        if predecessor_account_id != self.owner_id {
            assert_one_yocto();
        }

        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        let current_time: u64 = env::block_timestamp();

        let market_data: Option<MarketData> =
            if let Some(market_data) = self.old_market.get(&contract_and_token_id) {
                Some(MarketData {
                    owner_id: market_data.owner_id,
                    approval_id: market_data.approval_id,
                    nft_contract_id: market_data.nft_contract_id,
                    token_id: market_data.token_id,
                    ft_token_id: market_data.ft_token_id,
                    price: market_data.price,
                    bids: None,
                    started_at: None,
                    ended_at: None,
                    end_price: None,
                    accept_nft_contract_id: None,
                    accept_token_id: None,
                    is_auction: None,
                })
            } else if let Some(market_data) = self.market.get(&contract_and_token_id) {
                Some(market_data)
            } else {
                None
            };

        let market_data: MarketData = market_data.expect("Market data does not exist");

        assert!(
            [market_data.owner_id.clone(), self.owner_id.clone()]
                .contains(&predecessor_account_id),
            "Seller or owner only"
        );

        if market_data.is_auction.is_some() && predecessor_account_id == self.owner_id {
          assert!(
            current_time >= market_data.ended_at.unwrap(),
            "Auction has not ended yet"
          );
        }

        self.internal_delete_market_data(&nft_contract_id, &token_id);

        env::log_str(
            &json!({
                "type": "delete_market_data",
                "params": {
                    "owner_id": market_data.owner_id,
                    "nft_contract_id": nft_contract_id,
                    "token_id": token_id,
                }
            })
            .to_string(),
        );
    }

    // Storage

    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        let storage_account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(env::predecessor_account_id);
        let deposit = env::attached_deposit();
        assert!(
            deposit >= STORAGE_ADD_MARKET_DATA,
            "Requires minimum deposit of {}",
            STORAGE_ADD_MARKET_DATA
        );

        let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
        balance += deposit;
        self.storage_deposits.insert(&storage_account_id, &balance);
    }

    #[payable]
    pub fn storage_withdraw(&mut self) {
        assert_one_yocto();
        let owner_id = env::predecessor_account_id();
        let mut amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);
        let market_data_owner = self.by_owner_id.get(&owner_id);
        let len = market_data_owner.map(|s| s.len()).unwrap_or_default();
        let diff = u128::from(len) * STORAGE_ADD_MARKET_DATA;
        amount -= diff;
        if amount > 0 {
            self.internal_transfer_near(owner_id.clone(), amount);
        }
        if diff > 0 {
            self.storage_deposits.insert(&owner_id, &diff);
        }
    }

    pub fn storage_minimum_balance(&self) -> U128 {
        U128(STORAGE_ADD_MARKET_DATA)
    }

    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        self.storage_deposits.get(&account_id).unwrap_or(0).into()
    }

    // View

    pub fn get_market_data(&self, nft_contract_id: AccountId, token_id: TokenId) -> MarketDataJson {
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        let market_data: Option<MarketData> =
            if let Some(market_data) = self.old_market.get(&contract_and_token_id) {
                Some(MarketData {
                    owner_id: market_data.owner_id,
                    approval_id: market_data.approval_id,
                    nft_contract_id: market_data.nft_contract_id,
                    token_id: market_data.token_id,
                    ft_token_id: market_data.ft_token_id,
                    price: market_data.price,
                    bids: None,
                    started_at: None,
                    ended_at: None,
                    end_price: None,
                    accept_nft_contract_id: None,
                    accept_token_id: None,
                    is_auction: None,
                })
            } else if let Some(market_data) = self.market.get(&contract_and_token_id) {
                Some(market_data)
            } else {
                None
            };

        let market_data = market_data.expect("Market data does not exist");

        let price = market_data.price;

        let current_transaction_fee = self.get_market_data_transaction_fee(&market_data.nft_contract_id, &market_data.token_id);

        MarketDataJson {
            owner_id: market_data.owner_id,
            approval_id: market_data.approval_id.into(),
            nft_contract_id: market_data.nft_contract_id,
            token_id: market_data.token_id,
            ft_token_id: market_data.ft_token_id, // "near" for NEAR token
            price: price.into(),
            bids: market_data.bids,
            started_at: market_data.started_at.map(|x| x.into()),
            ended_at: market_data.ended_at.map(|x| x.into()),
            end_price: market_data.end_price.map(|x| x.into()),
            is_auction: market_data.is_auction,
            transaction_fee: current_transaction_fee.into()
        }
    }

    pub fn approved_nft_contract_ids(&self) -> Vec<AccountId> {
        self.approved_nft_contract_ids.to_vec()
    }

    pub fn get_owner(&self) -> AccountId {
        self.owner_id.clone()
    }

    pub fn get_treasury(&self) -> AccountId {
        self.treasury_id.clone()
    }

    pub fn get_supply_by_owner_id(&self, account_id: AccountId) -> U64 {
        self.by_owner_id
            .get(&account_id)
            .map_or(0, |by_owner_id| by_owner_id.len())
            .into()
    }

    // private fn

    fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Owner only"
        )
    }

    fn internal_transfer_near(&self, account_id: AccountId, amount: Balance){
        let balance = env::account_balance();
        if balance < amount {
            env::panic_str(&format!("Not enough balance to transfer near, balance: {}, amount: {}", balance, amount));
        }
        Promise::new(account_id).transfer(amount);
    }
}

pub fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

pub fn hash_contract_account_id_token_id(
    contract_account_id_token_id: &ContractAccountIdTokenId,
) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(contract_account_id_token_id.as_bytes()));
    hash
}

pub fn to_sec(timestamp: Timestamp) -> TimestampSec {
    (timestamp / 10u64.pow(9)) as u32
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        market_data: MarketData,
        price: U128,
    ) -> Promise;

    fn resolve_offer(
        &mut self,
        seller_id: AccountId,
        offer_data: OfferData,
        token_id: TokenId,
    ) -> Promise;

    fn callback_first_trade(
        &mut self,
        seller_nft_contract_id: AccountId,
        seller_token_id: TokenId,
        seller_approval_id: u64,
    ) -> Promise;

    fn callback_second_trade(
        &mut self,
        buyer_id: AccountId,
        buyer_nft_contract_id: AccountId,
        buyer_token_id: TokenId,
        seller_id: AccountId,
        seller_nft_contract_id: AccountId,
        seller_token_id: TokenId,
    ) -> Promise;
}

fn add_accounts(accounts: Option<Vec<AccountId>>, set: &mut UnorderedSet<AccountId>) {
    accounts.map(|ids| {
        ids.iter().for_each(|id| {
            set.insert(id);
        })
    });
}

fn remove_accounts(accounts: Option<Vec<AccountId>>, set: &mut UnorderedSet<AccountId>) {
    accounts.map(|ids| {
        ids.iter().for_each(|id| {
            set.remove(id);
        })
    });
}

fn make_triple(nft_contract_id: &AccountId, buyer_id: &AccountId, token: &str) -> String {
    format!(
        "{}{}{}{}{}",
        nft_contract_id, DELIMETER, buyer_id, DELIMETER, token
    )
}

fn make_key_owner_by_id_trade(contract_account_id_token_id: String) -> String {
    format!("{}{}trade", contract_account_id_token_id, DELIMETER)
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn setup_contract() -> (VMContextBuilder, Contract) {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let contract = Contract::new(
            accounts(0),
            accounts(1),
            None,
            Some(vec![accounts(2)]),
            Some(vec![accounts(2)]),
            500,
        );
        (context, contract)
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let contract = Contract::new(
            accounts(0),
            accounts(1),
            None,
            Some(vec![accounts(2)]),
            Some(vec![accounts(2)]),
            500,
        );
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.get_owner(), accounts(0));
        assert_eq!(contract.get_treasury(), accounts(1));
        assert_eq!(contract.approved_nft_contract_ids(), vec![accounts(2)]);
        assert_eq!(contract.transaction_fee.current_fee, 500);
    }

    #[test]
    fn test_set_treasury() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.set_treasury(accounts(5));
        let new_treasury: AccountId = contract.get_treasury();
        assert_eq!(new_treasury, accounts(5));
    }

    #[test]
    #[should_panic(expected = "Owner only")]
    fn test_invalid_set_treasury() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(1)
            .build());

        contract.set_treasury(accounts(5));
    }

    #[test]
    fn test_transfer_ownership() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.transfer_ownership(accounts(5));
        let new_owner: AccountId = contract.get_owner();
        assert_eq!(new_owner, accounts(5));
    }

    #[test]
    #[should_panic(expected = "Owner only")]
    fn test_invalid_transfer_ownership() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(5))
            .attached_deposit(1)
            .build());

        contract.transfer_ownership(accounts(5));
    }

    #[test]
    fn test_add_approved_nft_contract_ids() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.add_approved_nft_contract_ids(vec![accounts(5)]);
        let approved_nfts = contract.approved_nft_contract_ids();
        assert_eq!(approved_nfts, vec![accounts(2), accounts(5)]);
    }

    #[test]
    fn test_remove_approved_nft_contract_ids() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.add_approved_nft_contract_ids(vec![accounts(5)]);
        contract.remove_approved_nft_contract_ids(vec![accounts(5)]);
        let approved_nfts = contract.approved_nft_contract_ids();
        assert_eq!(approved_nfts, vec![accounts(2)]);
    }

    #[test]
    fn test_internal_add_market_data() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context.predecessor_account_id(accounts(0)).build());

        contract.internal_add_market_data(
            accounts(3),
            1,
            accounts(2),
            "1:1".to_string(),
            near_account(),
            U128::from(1 * 10u128.pow(24)),
            None,
            None,
            None,
            None,
        );

        let market = contract.get_market_data(accounts(2), "1:1".to_string());
        assert_eq!(market.owner_id, accounts(3));
        assert_eq!(market.approval_id, U64::from(1));
        assert_eq!(market.ft_token_id, near_account());
        assert_eq!(market.nft_contract_id, accounts(2));
        assert_eq!(market.owner_id, accounts(3));
        assert_eq!(market.token_id, "1:1".to_string());
        assert_eq!(market.price, U128::from(1 * 10u128.pow(24)));
    }

    #[test]
    #[should_panic(expected = "price higher than 1000000000000000000000000000000000")]
    fn test_invalid_price_higher_than_max_price() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context.predecessor_account_id(accounts(0)).build());

        contract.internal_add_market_data(
            accounts(3),
            1,
            accounts(2),
            "1:1".to_string(),
            near_account(),
            U128::from(1_000_000_000 * 10u128.pow(24)),
            None,
            None,
            None,
            None,
        );
    }

    #[test]
    #[should_panic(expected = "Market data does not exist")]
    fn test_delete_market_data() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context.predecessor_account_id(accounts(0)).build());

        contract.internal_add_market_data(
            accounts(3),
            1,
            accounts(2),
            "1:1".to_string(),
            near_account(),
            U128::from(1 * 10u128.pow(24)),
            None,
            None,
            None,
            None,
        );

        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(1)
            .build());

        contract.delete_market_data(accounts(2), "1:1".to_string());

        contract.get_market_data(accounts(2), "1:1".to_string());
    }

    #[test]
    fn test_storage_deposit() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(STORAGE_ADD_MARKET_DATA)
            .build());

        contract.storage_deposit(None);

        let storage_balance = contract.storage_balance_of(accounts(0)).0;
        assert_eq!(STORAGE_ADD_MARKET_DATA, storage_balance);

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.storage_withdraw();

        let storage_balance = contract.storage_balance_of(accounts(0)).0;
        assert_eq!(0, storage_balance);
    }

    #[test]
    fn test_add_offer() {
        let (mut context, mut contract) = setup_contract();

        let one_near = 10u128.pow(24);

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(one_near)
            .build());

        contract.internal_add_offer(
            accounts(3),
            Some("1:1".to_string()),
            None,
            near_account(),
            U128(one_near),
            accounts(0),
        );

        let offer_data =
            contract.get_offer(accounts(3), accounts(0), Some("1:1".to_string()), None);

        assert_eq!(offer_data.buyer_id, accounts(0));
        assert_eq!(offer_data.price, U128(one_near));
    }

    #[test]
    #[should_panic(expected = "Offer does not exist")]
    fn test_delete_offer() {
        let (mut context, mut contract) = setup_contract();

        let one_near = 10u128.pow(24);

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(one_near)
            .build());

        contract.internal_add_offer(
            accounts(3),
            Some("1:1".to_string()),
            None,
            near_account(),
            U128(one_near),
            accounts(0),
        );

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.delete_offer(accounts(3), Some("1:1".to_string()), None);

        contract.get_offer(accounts(3), accounts(1), Some("1:1".to_string()), None);
    }

    #[test]
    fn test_add_trade() {
        let (mut context, mut contract) = setup_contract();

        let one_near = 10u128.pow(24);

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(one_near)
            .build());

        contract.internal_add_trade(
            accounts(3),
            Some("1:1".to_string()),
            None,
            accounts(1),
            Some("1:2".to_string()),
            accounts(2),
            1,
        );

        let trade_data = contract.get_trade(
            accounts(3),
            Some("1:1".to_string()),
            None,
            accounts(2),
            accounts(1),
            "1:2".to_string(),
        );

        assert_eq!(trade_data.token_id.unwrap().to_string(), "1:1");
        assert_eq!(trade_data.nft_contract_id, accounts(3));
    }

    #[test]
    #[should_panic(expected = "Trade list does not exist")]
    fn test_delete_trade() {
        let (mut context, mut contract) = setup_contract();

        let one_near = 10u128.pow(24);

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(one_near)
            .build());

        contract.internal_add_trade(
            accounts(3),
            Some("1:1".to_string()),
            None,
            accounts(1),
            Some("1:1".to_string()),
            accounts(2),
            1,
        );

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.delete_trade(
            accounts(3),
            Some("1:1".to_string()),
            None,
            accounts(1),
            "1:2".to_string(),
        );
        contract.get_trade(
            accounts(3),
            Some("1:1".to_string()),
            None,
            accounts(1),
            accounts(1),
            "1:2".to_string(),
        );
    }

    #[test]
    fn test_internal_add_market_data_auction() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context.predecessor_account_id(accounts(0)).build());

        contract.internal_add_market_data(
            accounts(3),
            1,
            accounts(2),
            "1:1".to_string(),
            near_account(),
            U128::from(1 * 10u128.pow(24)),
            None,
            Some(U64(1999999952971000000)),
            None,
            Some(true),
        );

        let market = contract.get_market_data(accounts(2), "1:1".to_string());
        assert_eq!(market.is_auction, Some(true));
    }

    #[test]
    #[should_panic(expected = "the NFT is on auction")]
    fn test_bid_invalid_purchase() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context.predecessor_account_id(accounts(0)).build());

        contract.internal_add_market_data(
            accounts(3),
            1,
            accounts(2),
            "1:1".to_string(),
            near_account(),
            U128::from(1 * 10u128.pow(24)),
            None,
            Some(U64(1999999952971000000)),
            None,
            Some(true),
        );

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(10u128.pow(24))
            .build());

        contract.buy(accounts(2), "1:1".to_string(), None, None);
    }

    #[test]
    fn test_add_bid_and_accept() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context.predecessor_account_id(accounts(0)).build());

        contract.internal_add_market_data(
            accounts(1),
            1,
            accounts(2),
            "1:1".to_string(),
            near_account(),
            U128::from(1 * 10u128.pow(24)),
            None,
            Some(U64(1999999952971000000)),
            None,
            Some(true),
        );

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(10u128.pow(24) + 1)
            .build());

        contract.add_bid(
            accounts(2),
            near_account(),
            "1:1".to_string(),
            U128::from(10u128.pow(24) + 1),
        );

        testing_env!(context
            .predecessor_account_id(accounts(4))
            .attached_deposit(10u128.pow(24) + 10u128.pow(24) * 5 / 100 + 1)
            .build());

        contract.add_bid(
            accounts(2),
            near_account(),
            "1:1".to_string(),
            U128::from(10u128.pow(24) + 10u128.pow(24) * 5 / 100 + 1),
        );

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(1)
            .build());

        contract.end_auction(accounts(2), "1:1".to_string());
    }

    #[test]
    fn test_change_transaction_fee_immediately() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.set_transaction_fee(100, None);

        assert_eq!(contract.get_transaction_fee().current_fee, 100);
    }

    #[test]
    fn test_change_transaction_fee_with_time() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        assert_eq!(contract.get_transaction_fee().current_fee, 500);
        assert_eq!(contract.get_transaction_fee().next_fee, None);
        assert_eq!(contract.get_transaction_fee().start_time, None);

        let next_fee: u16 = 100;
        let start_time: Timestamp = 1618109122863866400;
        let start_time_sec: TimestampSec = to_sec(start_time);
        contract.set_transaction_fee(next_fee, Some(start_time_sec));

        assert_eq!(contract.get_transaction_fee().current_fee, 500);
        assert_eq!(contract.get_transaction_fee().next_fee, Some(next_fee));
        assert_eq!(
            contract.get_transaction_fee().start_time,
            Some(start_time_sec)
        );

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .block_timestamp(start_time + 1)
            .build());

        contract.calculate_current_transaction_fee();
        assert_eq!(contract.get_transaction_fee().current_fee, next_fee);
        assert_eq!(contract.get_transaction_fee().next_fee, None);
        assert_eq!(contract.get_transaction_fee().start_time, None);
    }

    #[test]
    fn test_transaction_fee_locked(){
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        assert_eq!(contract.get_transaction_fee().current_fee, 500);
        assert_eq!(contract.get_transaction_fee().next_fee, None);
        assert_eq!(contract.get_transaction_fee().start_time, None);

        let next_fee: u16 = 100;
        let start_time: Timestamp = 1618109122863866400;
        let start_time_sec: TimestampSec = to_sec(start_time);
        contract.set_transaction_fee(next_fee, Some(start_time_sec));

        contract.internal_add_market_data(
            accounts(3),
            1,
            accounts(2),
            "1:1".to_string(),
            near_account(),
            U128::from(1 * 10u128.pow(24)),
            None,
            None,
            None,
            None,
        );

        assert_eq!(contract.get_transaction_fee().current_fee, 500);
        assert_eq!(contract.get_transaction_fee().next_fee, Some(next_fee));
        assert_eq!(
            contract.get_transaction_fee().start_time,
            Some(start_time_sec)
        );

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .block_timestamp(start_time + 1)
            .build());

        contract.calculate_current_transaction_fee();
        assert_eq!(contract.get_transaction_fee().current_fee, next_fee);
        assert_eq!(contract.get_transaction_fee().next_fee, None);
        assert_eq!(contract.get_transaction_fee().start_time, None);

        let market = contract.get_market_data(accounts(2), "1:1".to_string());
        let market_data_transaction_fee: u128 = market.transaction_fee.into();
        assert_eq!(market_data_transaction_fee, 500);
    }

    #[test]
    fn test_audit_issue_1_extra_attached_near_may_be_locked() {}

    #[test]
    fn test_audit_issue_4_denial_of_user_legitimate_request() {}

    #[test]
    fn test_audit_issue_5_improper_market_type_assertion() {}

    #[test]
    fn test_audit_recommendation_3_failure_of_near_transferring_without_enough_balance() {}

}

'''
'''--- contract/marketplace/src/nft_callbacks.rs ---
use crate::*;
/// approval callbacks from NFT Contracts
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketArgs {
    pub market_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub price: Option<U128>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ft_token_id: Option<AccountId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub buyer_id: Option<AccountId>, // offer
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_price: Option<U128>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<U64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ended_at: Option<U64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_auction: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seller_nft_contract_id: Option<AccountId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seller_token_id: Option<TokenId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seller_token_series_id: Option<TokenSeriesId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub buyer_nft_contract_id: Option<AccountId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub buyer_token_id: Option<TokenId>,
}

trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        // enforce cross contract call and owner_id is signer

        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();
        assert_ne!(
            env::current_account_id(), nft_contract_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        assert_eq!(owner_id, signer_id, "owner_id should be signer_id");

        assert!(
            self.approved_nft_contract_ids.contains(&nft_contract_id),
            "nft_contract_id is not approved"
        );

        let MarketArgs {
            market_type,
            price,
            ft_token_id,
            buyer_id,
            started_at,
            ended_at,
            end_price,
            is_auction,
            seller_nft_contract_id,
            seller_token_id,
            seller_token_series_id,
            buyer_nft_contract_id,
            buyer_token_id
        } = near_sdk::serde_json::from_str(&msg).expect("Not valid MarketArgs");

        // replace old approval id on trade
        let buyer_contract_account_id_token_id = make_triple(&nft_contract_id,
                                                             &owner_id,
                                                             &token_id);
        if let Some(mut old_trade) = self.trades.get(&buyer_contract_account_id_token_id){
            old_trade.approval_id = approval_id;
            self.trades.insert(&buyer_contract_account_id_token_id,&old_trade);
        }
        // replace old approval on market
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        if let Some(mut old_market) = self.market.get(&contract_and_token_id){
            old_market.approval_id = approval_id;
            self.market.insert(&contract_and_token_id,&old_market);
        }

        if market_type == "sale" {
            assert!(price.is_some(), "price not specified");

            let storage_amount = self.storage_minimum_balance().0;
            let owner_paid_storage = self.storage_deposits.get(&signer_id).unwrap_or(0);
            let signer_storage_required =
                (self.get_supply_by_owner_id(signer_id).0 + 1) as u128 * storage_amount;

            if owner_paid_storage < signer_storage_required {
                let notif=format!("Insufficient storage paid: {}, for {} sales at {} rate of per sale",
                owner_paid_storage,
                signer_storage_required / storage_amount,
                storage_amount
                );
                env::log_str(&notif);
                return;
            }
            
            self.internal_delete_market_data(&nft_contract_id, &token_id);

            let ft_token_id_res = ft_token_id.unwrap_or(near_account());

            if self.approved_ft_token_ids.contains(&ft_token_id_res) != true {
                env::panic_str(&"ft_token_id not approved");
            }

            self.internal_add_market_data(
                owner_id,
                approval_id,
                nft_contract_id,
                token_id,
                ft_token_id_res,
                price.unwrap(),
                started_at,
                ended_at,
                end_price,
                is_auction,
            );
        } else if market_type == "accept_offer" {
            assert!(buyer_id.is_some(), "Account id is not specified");
            assert!(price.is_some(), "Price is not specified (for check)");

            self.internal_accept_offer(
                nft_contract_id,
                buyer_id.unwrap(),
                token_id,
                owner_id,
                approval_id,
                price.unwrap().0,
            );
        } else if market_type == "accept_offer_paras_series" {
            assert!(buyer_id.is_some(), "Account id is not specified");
            assert!(
                self.paras_nft_contracts.contains(&nft_contract_id),
                "accepting offer series for Paras NFT only"
            );
            assert!(price.is_some(), "Price is not specified (for check)");

            self.internal_accept_offer_series(
                nft_contract_id,
                buyer_id.unwrap(),
                token_id,
                owner_id,
                approval_id,
                price.unwrap().0,
            );
        } else if market_type == "add_trade" {

            let storage_amount = self.storage_minimum_balance().0;
            let owner_paid_storage = self.storage_deposits.get(&signer_id).unwrap_or(0);
            let signer_storage_required =
                (self.get_supply_by_owner_id(signer_id).0 + 1) as u128 * storage_amount;

            if owner_paid_storage < signer_storage_required {
                let notif=format!("Insufficient storage paid: {}, for {} sales at {} rate of per sale",
                                  owner_paid_storage,
                                  signer_storage_required / storage_amount,
                                  storage_amount
                );
                env::log_str(&notif);
                return;
            }

            self.add_trade(
                seller_nft_contract_id.unwrap(),
                seller_token_id,
                seller_token_series_id,
                nft_contract_id,
                owner_id,
                Some(token_id),
                approval_id,
            );
        } else if market_type == "accept_trade" {

            assert!(buyer_id.is_some(), "Account id is not specified");
            assert!(buyer_nft_contract_id.is_some(), "Buyer NFT contract id is not specified");
            assert!(buyer_token_id.is_some(), "Buyer token id is not specified");

            self.internal_accept_trade(
                nft_contract_id,
                buyer_id.unwrap(),
                token_id,
                owner_id,
                approval_id,
                buyer_nft_contract_id.unwrap(),
                buyer_token_id.unwrap()
            );

        } else if market_type == "accept_trade_paras_series" {

            assert!(buyer_id.is_some(), "Account id is not specified");
            assert!(
                self.paras_nft_contracts.contains(&nft_contract_id),
                "accepting offer series for Paras NFT only"
            );
            assert!(buyer_nft_contract_id.is_some(), "Buyer NFT contract id is not specified");
            assert!(buyer_token_id.is_some(), "Buyer token id is not specified");

            self.internal_accept_trade_series(
                nft_contract_id,
                buyer_id.unwrap(),
                token_id,
                owner_id,
                approval_id,
                buyer_nft_contract_id.unwrap(),
                buyer_token_id.unwrap()
            );

        }
    }
}

'''
'''--- contract/nft/Cargo.toml ---
[package]
name = "music-feast-contract"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_with = "1"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- contract/nft/src/event.rs ---
use std::fmt::Display;

use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "standard")]
#[serde(rename_all = "snake_case")]
pub enum NearEvent {
    Nep171(Nep171Event),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Nep171Event {
    pub version: String,
    #[serde(flatten)]
    pub event_kind: Nep171EventKind,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
pub enum Nep171EventKind {
    NftMint(Vec<NftMintData>),
    NftTransfer(Vec<NftTransferData>),
    NftBurn(Vec<NftBurnData>),
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize, Debug)]
pub struct NftMintData {
    pub owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize, Debug)]
pub struct NftTransferData {
    pub authorized_id: Option<String>,
    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize, Debug)]
pub struct NftBurnData {
    pub authorized_id: Option<String>,
    pub owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

impl Display for NearEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&format!("EVENT_JSON:{}", self.to_json_string()))
    }
}

impl NearEvent {
    pub fn new_171(version: String, event_kind: Nep171EventKind) -> Self {
        NearEvent::Nep171(Nep171Event { version, event_kind })
    }

    pub fn new_171_v1(event_kind: Nep171EventKind) -> Self {
        NearEvent::new_171("1.0.0".to_string(), event_kind)
    }

    pub fn nft_burn(data: Vec<NftBurnData>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftBurn(data))
    }
    pub fn nft_transfer(data: Vec<NftTransferData>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftTransfer(data))
    }

    pub fn nft_mint(data: Vec<NftMintData>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftMint(data))
    }

    pub(crate) fn to_json_string(&self) -> String {
        serde_json::to_string(self).unwrap()
    }

    pub fn log(&self) {
        near_sdk::env::log_str(&self.to_string());
    }

    pub fn log_nft_mint(owner_id: String, token_ids: Vec<String>, memo: Option<String>) {
        NearEvent::log_nft_mints(vec![NftMintData { owner_id, token_ids, memo }]);
    }

    pub fn log_nft_mints(data: Vec<NftMintData>) {
        NearEvent::nft_mint(data).log();
    }

    pub fn log_nft_transfer(
        old_owner_id: String,
        new_owner_id: String,
        token_ids: Vec<String>,
        memo: Option<String>,
        authorized_id: Option<String>,
    ) {
        NearEvent::log_nft_transfers(vec![NftTransferData {
            authorized_id,
            old_owner_id,
            new_owner_id,
            token_ids,
            memo,
        }]);
    }

    pub fn log_nft_transfers(data: Vec<NftTransferData>) {
        NearEvent::nft_transfer(data).log();
    }

    pub fn log_nft_burn(
        owner_id: String,
        token_ids: Vec<String>,
        memo: Option<String>,
        authorized_id: Option<String>,
    ) {
        NearEvent::log_nft_burns(vec![NftBurnData { owner_id, authorized_id, token_ids, memo }]);
    }

    pub fn log_nft_burns(data: Vec<NftBurnData>) {
        NearEvent::nft_burn(data).log();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_tokens(s_vec: Vec<&str>) -> Vec<String> {
        s_vec.iter().map(|t| t.to_string()).collect()
    }

    #[test]
    fn nft_mint() {
        let owner_id = "bob".to_string();
        let token_ids = make_tokens(vec!["0", "1"]);
        let mint_log = NftMintData { owner_id, token_ids, memo: None };
        let event_log = NearEvent::nft_mint(vec![mint_log]);
        assert_eq!(
            serde_json::to_string(&event_log).unwrap(),
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"bob","token_ids":["0","1"]}]}"#
        );
    }

    #[test]
    fn nft_mints() {
        let owner_id = "bob".to_string();
        let token_ids = make_tokens(vec!["0", "1"]);
        let mint_log = NftMintData { owner_id, token_ids, memo: None };
        let event_log = NearEvent::nft_mint(vec![
            mint_log,
            NftMintData {
                owner_id: "alice".to_string(),
                token_ids: make_tokens(vec!["2", "3"]),
                memo: Some("has memo".to_string()),
            },
        ]);
        assert_eq!(
            serde_json::to_string(&event_log).unwrap(),
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"bob","token_ids":["0","1"]},{"owner_id":"alice","token_ids":["2","3"],"memo":"has memo"}]}"#
        );
    }

    #[test]
    fn nft_burn() {
        let owner_id = "bob".to_string();
        let token_ids = make_tokens(vec!["0", "1"]);
        let log = NearEvent::nft_burn(vec![NftBurnData {
            owner_id,
            authorized_id: None,
            token_ids,
            memo: None,
        }])
            .to_json_string();
        assert_eq!(
            log,
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_burn","data":[{"owner_id":"bob","token_ids":["0","1"]}]}"#
        );
    }

    #[test]
    fn nft_burns() {
        let owner_id = "bob".to_string();
        let token_ids = make_tokens(vec!["0", "1"]);
        let log = NearEvent::nft_burn(vec![
            NftBurnData {
                owner_id: "alice".to_string(),
                authorized_id: Some("4".to_string()),
                token_ids: make_tokens(vec!["2", "3"]),
                memo: Some("has memo".to_string()),
            },
            NftBurnData { owner_id, authorized_id: None, token_ids, memo: None },
        ])
            .to_json_string();
        assert_eq!(
            log,
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_burn","data":[{"authorized_id":"4","owner_id":"alice","token_ids":["2","3"],"memo":"has memo"},{"owner_id":"bob","token_ids":["0","1"]}]}"#
        );
    }

    #[test]
    fn nft_transfer() {
        let old_owner_id = "bob".to_string();
        let new_owner_id = "alice".to_string();
        let token_ids = make_tokens(vec!["0", "1"]);
        let log = NearEvent::nft_transfer(vec![NftTransferData {
            old_owner_id,
            new_owner_id,
            authorized_id: None,
            token_ids,
            memo: None,
        }])
            .to_json_string();
        assert_eq!(
            log,
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"old_owner_id":"bob","new_owner_id":"alice","token_ids":["0","1"]}]}"#
        );
    }

    #[test]
    fn nft_transfers() {
        let old_owner_id = "bob";
        let new_owner_id = "alice";
        let token_ids = make_tokens(vec!["0", "1"]);
        let log = NearEvent::nft_transfer(vec![
            NftTransferData {
                old_owner_id: new_owner_id.to_string(),
                new_owner_id: old_owner_id.to_string(),
                authorized_id: Some("4".to_string()),
                token_ids: make_tokens(vec!["2", "3"]),
                memo: Some("has memo".to_string()),
            },
            NftTransferData {
                old_owner_id: old_owner_id.to_string(),
                new_owner_id: new_owner_id.to_string(),
                authorized_id: None,
                token_ids,
                memo: None,
            },
        ])
            .to_json_string();
        assert_eq!(
            log,
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"4","old_owner_id":"alice","new_owner_id":"bob","token_ids":["2","3"],"memo":"has memo"},{"old_owner_id":"bob","new_owner_id":"alice","token_ids":["0","1"]}]}"#
        );
    }
}
'''
'''--- contract/nft/src/lib old.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::core::{
    NonFungibleTokenCore, NonFungibleTokenResolver
};

//use near_contract_standards::non_fungible_token::approval::ext_nft_approval_receiver;

use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise,
    Balance, serde_json::json, assert_one_yocto, Gas, ext_contract, PromiseOrValue,
};

use near_sdk::collections::{LazyOption, UnorderedMap, UnorderedSet};

/* custon codigo */
use near_sdk::json_types::{/*ValidAccountId,*/ U128, /*U64*/};

use serde::Serialize;
use serde::Deserialize;
use std::collections::HashMap;
use near_sdk::env::is_valid_account_id;
pub mod event;
pub use event::NearEvent;

pub const TOKEN_DELIMETER: char = ':';
pub const TITLE_DELIMETER: &str = " #";
pub const VAULT_FEE: u128 = 500;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(40_000_000_000_000); //GAS_FOR_NFT_TRANSFER_CALL(30_000_000_000_000) + GAS_FOR_RESOLVE_TRANSFER;
//const GAS_FOR_NFT_APPROVE: Gas = Gas(10_000_000_000_000);
//const GAS_FOR_MINT: Gas = Gas(90_000_000_000_000);
//const NO_DEPOSIT: Balance = 0;
const MAX_PRICE: Balance = 1_000_000_000 * 10u128.pow(24);

pub type TokenSeriesId = String;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

/* codigo customizado */

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolverExt {
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool;
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct TokenSeries {
    desc_series: String,
	metadata: TokenMetadata,
	creator_id: AccountId,
	tokens: UnorderedSet<TokenId>,
    objects_mint: UnorderedSet<String>,
    price: Option<Balance>,
    price_usd: Option<f64>,
    is_mintable: bool,
    royalty: HashMap<AccountId, u32>,
    royalty_buy: HashMap<String, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RoyaltyBuy {
	artist_id: String,
	porcentaje: String,
    amount: String,
    tax: String
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson {
    token_series_id: TokenSeriesId,
	metadata: TokenMetadata,
	creator_id: AccountId,
    royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson2 {
	token_series_id: TokenSeriesId,
    metadata: TokenMetadata,
	creator_id: AccountId,
    price: Option<Balance>,
    is_mintable: bool,
    royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokensView {
	owner_id: String,
    token_id: String
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ArtistObject {
	id: u128,
    name: String,
    next_collection: i128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TypeTokenObject {
	id: u128,
    description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RestrictionsObject {
	id: String,
    token_id_s: u128,
    token_id_r: u128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenCustom {
    token_id: TokenId,
    owner_id: AccountId,
    metadata: Option<TokenMetadata>,
    approved_account_ids: Option<HashMap<AccountId, u64>>,
    royalty: Option<HashMap<AccountId, u32>>
}

/* fin codigo costumizado */

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    /* codigo costumizado */
    owner_id: AccountId,
    list_admin: UnorderedSet<AccountId>,
    list_vip: UnorderedSet<AccountId>,
    maestro_artist: UnorderedMap<u128, ArtistObject>,
    id_artist: u128,
    id_type_token_series: u128,
    type_token_series: UnorderedMap<u128, TypeTokenObject>,
    id_objects: u128,
    id_serie: u128,
    token_series_by_id: UnorderedMap<TokenSeriesId, TokenSeries>,
    restrictions: UnorderedMap<String, RestrictionsObject>,
    vault_id: AccountId,
    black_list_reedemer: UnorderedSet<String>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    /*codigo costumizado*/
    AdminKey,
    VipKey,
    ArtistKey,
    TypeTokenSeriesKey,
    RestrictionsKeys,
    TokenSeriesById,
    TokensBySeriesInner { token_series: String },
    TokensByObjectsInner { token_series: String },
    BlackListReedemerKey,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, vault_id: AccountId,) -> Self {
        Self::new(
            owner_id,
            vault_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Music Feast".to_string(),
                symbol: "MusicFeast".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, vault_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id.clone(),
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            /* codigo costumizado */
            owner_id: owner_id,
            list_admin: UnorderedSet::new(StorageKey::AdminKey),
            list_vip: UnorderedSet::new(StorageKey::VipKey),
            maestro_artist: UnorderedMap::new(StorageKey::ArtistKey),
            id_artist: 0,
            id_type_token_series: 0,
            type_token_series: UnorderedMap::new(StorageKey::TypeTokenSeriesKey),
            id_objects: 0,
            id_serie: 0,
            token_series_by_id: UnorderedMap::new(StorageKey::TokenSeriesById),
            restrictions: UnorderedMap::new(StorageKey::RestrictionsKeys),
            vault_id: vault_id,
            black_list_reedemer: UnorderedSet::new(StorageKey::BlackListReedemerKey),
        }
    }

    /* codigo original */
    /*
    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens.mint(token_id, receiver_id, Some(token_metadata))
    }*/

    /* codigo custom */
    pub fn edit_vault(&mut self, account_id: AccountId){
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.vault_id = account_id;
    }

    // cargar usuarios a la lista de administradores
    // solo los administradores pueden usar esta funcion
    pub fn add_admin(&mut self, account_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.list_admin.insert(&account_id.clone());

        env::log_str(
            &json!({
                "type": "add_admin",
                "params": {
                    "account_id": account_id.to_string()
                }
            })
            .to_string(),
        );

    }

    // cargar usuarios a la lista de administradores
    // solo los administradores pueden usar esta funcion
    pub fn add_vip(&mut self, account_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.list_vip.insert(&account_id.clone());

        env::log_str(
            &json!({
                "type": "add_vip",
                "params": {
                    "account_id": account_id.to_string()
                }
            })
            .to_string(),
        );

    }

    pub fn is_vip(&self, account_id: AccountId) -> bool {
        self.list_vip.contains(&account_id)
    } 

    pub fn add_black_list_reedemer(&mut self, type_token: String) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.black_list_reedemer.insert(&type_token.clone());

        env::log_str(
            &json!({
                "type": "add_black_list_reedemer",
                "params": {
                    "type_token": type_token
                }
            })
            .to_string(),
        );

    }

    pub fn add_artist(&mut self, name: String) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let id_artist: u128 = self.id_artist + 1;

        let data_artist = ArtistObject {
            id: id_artist,
            name: name.clone(),
            next_collection: 1
        };

        self.maestro_artist.insert(&data_artist.id, &data_artist);

        self.id_artist = id_artist;

        env::log_str(
            &json!({
                "type": "add_artist",
                "params": {
                    "id": id_artist.to_string(),
                    "name": name,
                    "collection": 1,
                }
            })
            .to_string(),
        );
    }

    pub fn get_artist(self) -> Vec<ArtistObject> {
        self.maestro_artist.iter().map(|(_k, v)| { v }).collect()
    }

    pub fn add_type_token_series(&mut self, description: String) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let id_type_token: u128 = self.id_type_token_series + 1;

        let data_type_token = TypeTokenObject {
            id: id_type_token,
            description: description.clone(),
        };

        self.type_token_series.insert(&data_type_token.id, &data_type_token);

        self.id_type_token_series = id_type_token;

        env::log_str(
            &json!({
                "type": "add_type_token_series",
                "params": {
                    "id": id_type_token.to_string(),
                    "description": description
                }
            })
            .to_string(),
        );
    }

    pub fn get_type_token_series(self) -> Vec<TypeTokenObject> {
        self.type_token_series.iter().map(|(_k, v)| {v}).collect()
    }

    pub fn add_restriction(&mut self, token_id_s: u128, token_id_r: u128) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        assert!(self.type_token_series.get(&token_id_s).is_some(), "Token_id_s not exist");
        assert!(self.type_token_series.get(&token_id_r).is_some(), "Token_id_r not exist");
        assert!(self.restrictions.get(&token_id_s.to_string()).is_none(), "The requested token already has a constraint.");

        let data_restriction = RestrictionsObject {
            id: token_id_s.to_string(),
            token_id_s: token_id_s,
            token_id_r: token_id_r,
        };

        self.restrictions.insert(&data_restriction.id, &data_restriction);

        env::log_str(
            &json!({
                "type": "add_restriction",
                "params": {
                    "token_id_s": token_id_s.to_string(),
                    "token_id_r": token_id_r.to_string()
                }
            })
            .to_string(),
        );
    }

    pub fn get_restriction(self) -> Vec<RestrictionsObject> {
        self.restrictions.iter().map(|(_k, v)| {v}).collect()
    }

    pub fn next_collection(&mut self, artist_id: u128) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let mut artist = self.maestro_artist.get(&artist_id).expect("artist not exist");

        artist.next_collection += 1;

        self.maestro_artist.insert(&artist_id, &artist);

        env::log_str(
            &json!({
                "type": "next_collection",
                "params": {
                    "artist_is": artist_id.to_string(),
                    "next_collection": artist.next_collection.to_string()
                }
            })
            .to_string(),
        );
    }

   #[payable]
    pub fn update_nft_series(&mut self, 
        token_series_id: TokenSeriesId, 
        title: Option<String>,
        description: Option<String>,
        media: Option<String>,
    ) -> TokenSeriesJson {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");

        //let initial_storage_usage = env::storage_usage();
        

        let mut nft_serie = self.token_series_by_id.get(&token_series_id).expect("tonken serie id not exist");
        if title.is_some() { nft_serie.metadata.title = title; }
        if description.is_some() { nft_serie.metadata.description = description; }
        if media.is_some() { nft_serie.metadata.media = media; }

        self.token_series_by_id.insert(&token_series_id, &nft_serie);

        env::log_str(
            &json!({
                "type": "update_nft_series",
                "params": {
                    "token_series_id": token_series_id,
                    "desc_series": nft_serie.desc_series.clone(),
                    "token_metadata": nft_serie.metadata.clone(),
                    "creator_id": nft_serie.creator_id.clone(),
                    "price": nft_serie.price.unwrap().to_string(),
                    "royalty": nft_serie.royalty.clone()
                }
            })
            .to_string(),
        );

        //refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        TokenSeriesJson {
            token_series_id,
			metadata: nft_serie.metadata.clone(),
			creator_id: nft_serie.creator_id.clone(),
            royalty: nft_serie.royalty,
		}
    }
    pub fn prueba() {
        let price: f64 = 4;
        let tasa: f64 = 2;
        let price_near: f64 = price / tasa;
        let yocto_near: u18 = 1000000000000000000000000;
        let price_yocto: u128 = (price_near * yocto_near) as u128;
        env::log_str(price_yocto.to_string());
    }

    #[payable]
    pub fn nft_series(
        &mut self,
        artist_id: u128,
        type_token_id: u128,
        objects: bool,
        token_metadata: TokenMetadata,
        objects_ids: Option<Vec<String>>,
        price: Option<U128>,
        royalty: Option<HashMap<AccountId, u32>>,
        royalty_buy: Option<HashMap<String, u32>>,
    ) -> TokenSeriesJson {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        let data_artist = self.maestro_artist.get(&artist_id).expect("Artist_id not exist");
        
        let type_token = self.type_token_series.get(&type_token_id).expect("type_token_id not exist");

        let initial_storage_usage = env::storage_usage();
        let caller_id = env::signer_account_id();

        let mut token_series_id: String;

        if objects {
            self.id_objects += 1;
            token_series_id = format!("{}|{}|{}|{}", artist_id, type_token_id, data_artist.next_collection, self.id_objects.to_string());
        } else {
            token_series_id = format!("{}|{}|1", artist_id, type_token_id);
            if type_token_id > 1 && type_token_id <= 6 {
                token_series_id = format!("{}|{}|{}", artist_id, type_token_id, data_artist.next_collection);
            } else if type_token_id > 6 {
                token_series_id = format!("{}|{}|{}|{}", artist_id, type_token_id, data_artist.next_collection, self.id_serie.to_string());
            }
        }

        assert!(
            self.token_series_by_id.get(&token_series_id).is_none(),
            "duplicate token_series_id"
        );

        let title = token_metadata.title.clone();
        assert!(title.is_some(), "token_metadata.title is required");
        
        
        let mut total_perpetual = 0;
        let mut total_accounts = 0;
        let royalty_res_buy =  if let Some(royalty_buy) = royalty_buy {
            for (k, v) in royalty_buy.iter() {
                if self.maestro_artist.get(&*k.parse::<u128>().as_ref().unwrap()).is_none() && *k.parse::<u128>().as_ref().unwrap() > 0 {
                    env::panic_str("Not valid artist_id for royalty");
                };
                total_perpetual += v;
                total_accounts += 1;
            }
            royalty_buy
        } else {
            HashMap::new()
        };

        assert!(total_accounts <= 10, "royalty_buy exceeds 10 accounts");

        assert!(
            total_perpetual <= 10000,
            "Exceeds maximum royalty_buy -> 10000",
        );

        total_perpetual = 0;
        total_accounts = 0;
        let royalty_res: HashMap<AccountId, u32> = if let Some(royalty) = royalty {
            for (k , v) in royalty.iter() {
                if !is_valid_account_id(k.as_bytes()) {
                    env::panic_str("Not valid account_id for royalty");
                };
                total_perpetual += *v;
                total_accounts += 1;
            }
            royalty
        } else {
            HashMap::new()
        };

        assert!(total_accounts <= 10, "royalty exceeds 10 accounts");

        assert!(
            total_perpetual <= 9000,
            "Exceeds maximum royalty -> 9000",
        );

        let price_res: Option<u128> = if price.is_some() {
            assert!(
                price.unwrap().0 < MAX_PRICE,
                "price higher than {}",
                MAX_PRICE
            );
            Some(price.unwrap().0)
        } else {
            None
        };

        if objects_ids.is_some() && objects == false {
            for item in objects_ids.clone().unwrap().iter() {
                assert!(item.split("|").next().unwrap().to_string() == artist_id.to_string(), "The object does not belong to the selected artist");
                self.token_series_by_id.get(&item).expect("token objects series id not exist");
            }
        }

        self.token_series_by_id.insert(&token_series_id, &TokenSeries{
            desc_series: type_token.description.clone(),
            metadata: token_metadata.clone(),
            creator_id: caller_id.clone(),
            tokens: UnorderedSet::new(
                StorageKey::TokensBySeriesInner {
                    token_series: token_series_id.clone(),
                }
                .try_to_vec()
                .unwrap(),
            ),
            objects_mint: UnorderedSet::new(
                StorageKey::TokensByObjectsInner {
                    token_series: token_series_id.clone(),
                }
                .try_to_vec()
                .unwrap(),
            ),
            price: price_res,
            price_usd: Some(4.1),
            is_mintable: true,
            royalty: royalty_res.clone(),
            royalty_buy: royalty_res_buy.clone(),
        });

        if objects_ids.is_some() && objects == false {
            let mut data_serie = self.token_series_by_id.get(&token_series_id).expect("token series id no existe");
            for item in objects_ids.unwrap().iter() {
                data_serie.objects_mint.insert(&item.to_string());
            }   
            self.token_series_by_id.insert(&token_series_id, &data_serie);
        }
        

        env::log_str(
            &json!({
                "type": "nft_create_series",
                "params": {
                    "token_series_id": token_series_id.to_string(),
                    "objects": objects,
                    "desc_series": type_token.description.to_string(),
                    "token_metadata": token_metadata,
                    "creator_id": caller_id.to_string(),
                    "price": price,
                    "royalty": royalty_res
                }
            })
            .to_string(),
        );

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

		TokenSeriesJson{
            token_series_id,
			metadata: token_metadata,
			creator_id: caller_id.into(),
            royalty: royalty_res,
		}
    }

    #[payable]
    pub fn nft_buy(
        &mut self, 
        token_series_id: TokenSeriesId
    ) -> TokenId {
        //token_series_id.split("|").collect::<Vec<&str>>()[2];
        
        /*account_id: TokenSeriesId,
        artist_id: TokenMetadata,
        porcentaje: u32,*/

        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        let price: u128 = token_series.price.expect("not for sale");
        let attached_deposit = env::attached_deposit();
        let receiver_id: AccountId = env::signer_account_id();
        let type_token = token_series_id.split("|").collect::<Vec<&str>>()[1].to_string();

        if self.list_vip.contains(&env::signer_account_id()) && type_token == "1" {
            assert!(
                attached_deposit >= 300000000000000000000000,
                "attached deposit is less than price : {}",
                "300000000000000000000000"    
            );

            let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.clone());

            for item in token_series.objects_mint.iter() {
                self._nft_mint_series(item.to_string(), receiver_id.clone());
            }

            token_id
        } else {    
            assert!(
                attached_deposit >= price,
                "attached deposit is less than price : {}",
                price
            );

            let artist_id = token_series_id.split("|").next().unwrap().to_string();

            let restriction = self.restrictions.get(&token_series.metadata.reference.unwrap().to_string());
            
            if restriction.is_some() {
                let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().expect(
                    "Could not find tokens_per_owner when calling a method on the enumeration standard.",
                );
                let token_set = tokens_per_owner.get(&receiver_id).expect("You do not have the corresponding token to buy the requested token");
                let token_id_r: String = restriction.unwrap().token_id_r.to_string();
                
                let valit_token_owner = token_set
                    .iter()
                    .find(|token_id| token_id.split(":").next().unwrap().to_string() == format!("{}|{}|1",artist_id, token_id_r).to_string());
                assert!(valit_token_owner != None
                    , "You do not have the corresponding token to buy the requested token");
            }

            let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.clone());

            for item in token_series.objects_mint.iter() {
                self._nft_mint_series(item.to_string(), receiver_id.clone());
            }

            //let for_vault = price as u128 * VAULT_FEE / 10_000u128;
            //let price_deducted = price - for_vault;
            //Promise::new(token_series.creator_id).transfer(price_deducted);
            
            Promise::new(self.vault_id.clone()).transfer(price);

            let amount_final: u128 = price - (price * 50)/10000;
            let tax: u128 = (price * 50)/10000;

            let royalty_buy: Vec<RoyaltyBuy> = token_series.royalty_buy.iter().map(|(k, v)| 
                {
                    let mut tax_final: String = "0".to_string();
                    if *k.parse::<u128>().as_ref().unwrap() == 0 || *k == artist_id {
                        tax_final = (tax/2).to_string();
                    }
                    RoyaltyBuy{
                        artist_id: k.clone(),
                        porcentaje: v.to_string(),
                        amount: ((amount_final * (*v as u128))/10000).to_string(),
                        tax: tax_final,
                    }
                }).collect();
            

            env::log_str(
                &json!({
                    "type": "nft_buy",
                    "params": {
                        "artista": artist_id.clone(),
                        "price": price.to_string(),
                        "amount_artist": ((amount_final * 7000)/10000).to_string(), // 70% del artista
                        "amount_musicfeast": ((amount_final * 3000)/10000).to_string(), // 30% musicfeast
                        "tax_artist": (tax/2).to_string(),
                        "tax_musicfeast": (tax/2).to_string(),
                        "royalty": royalty_buy,
                    }
                })
                .to_string(),
            );

            token_id
        }
    }

    pub fn auto_swap_ini(
        &mut self, 
        artist_id: String, 
        amount_near: U128,
        tax_near: U128,
        ft_token: String,
    ) {
        //assert_eq!(env::predecessor_account_id(), self.vault_id.clone(), "no autorizado");
        
        env::log_str(
            &json!({
                "type": "auto_swap_ini",
                "params": {
                    "artista": artist_id.clone(),
                    "amount_near": amount_near.0.to_string(),
                    "tax_near": tax_near.0.to_string(),
                    "ft_token": ft_token,
                }
            })
            .to_string(),
        );
    }

    pub fn auto_swap_end(
        &mut self, 
        artist_id: String,
        amount_near: U128,
        tax_near: U128,
        amount_usd: U128,
        ft_token: String,
    ) {
        //assert_eq!(env::predecessor_account_id(), self.vault_id.clone(), "no autorizado");
        
        env::log_str(
            &json!({
                "type": "auto_swap_end",
                "params": {
                    "artista": artist_id.clone(),
                    "amount_near": amount_near.0.to_string(),
                    "tax_near": tax_near.0.to_string(),
                    "amount_usd": amount_usd.0.to_string(),
                    "ft_token": ft_token,
                }
            })
            .to_string(),
        );
    }

    pub fn auto_swap_error(
        &mut self, 
        artist_id: String, 
        amount_near: U128,
        tax_near: U128,
        arg: String,
    ) {
        //assert_eq!(env::predecessor_account_id(), self.vault_id.clone(), "no autorizado");
        
        env::log_str(
            &json!({
                "type": "auto_swap_error",
                "params": {
                    "artista": artist_id.clone(),
                    "amount_near": amount_near.0.to_string(),
                    "tax_near": tax_near.0.to_string(),
                    "arg": arg
                }
            })
            .to_string(),
        );
    }

    #[payable]
    pub fn nft_mint(
        &mut self, 
        token_series_id: TokenSeriesId, 
        receiver_id: AccountId
    ) -> TokenId {
        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        assert_eq!(env::predecessor_account_id(), token_series.creator_id.clone(), "not creator");
        let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.clone());

        token_id
    }

    
    
    /*#[payable]
    pub fn nft_mint_and_approve(
        &mut self, 
        token_series_id: TokenSeriesId, 
        account_id: AccountId,
        msg: Option<String>,
    ) -> Option<Promise> {
        let initial_storage_usage = env::storage_usage();

        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        assert_eq!(env::predecessor_account_id(), token_series.creator_id.clone(), "not creator");
        let token_id: TokenId = self._nft_mint_series(token_series_id, token_series.creator_id.clone());

        let approvals_by_id = self.tokens.approvals_by_id.as_mut().unwrap();

        let approved_account_ids =
            &mut approvals_by_id.get(&token_id).unwrap_or_else(|| HashMap::new());
        let account_id: AccountId = account_id.into();
        let approval_id: u64 =
            self.tokens.next_approval_id_by_id.as_ref().unwrap().get(&token_id).unwrap_or_else(|| 1u64);
        approved_account_ids.insert(account_id.clone(), approval_id);

        approvals_by_id.insert(&token_id, &approved_account_ids);

        self.tokens.next_approval_id_by_id.as_mut().unwrap().insert(&token_id, &(approval_id + 1));

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        NearEvent::log_nft_mint(
            token_series.creator_id.to_string(),
            vec![token_id.clone()],
            None,
        );

        if let Some(msg) = msg {
            Some(ext_nft_approval_receiver::ext(account_id)
            .with_static_gas(env::prepaid_gas() - GAS_FOR_NFT_APPROVE - GAS_FOR_MINT)
            .nft_on_approve(token_id, token_series.creator_id, approval_id, msg))
            
            /*Some(ext_approval_receiver::nft_on_approve(
                token_id,
                token_series.creator_id,
                approval_id,
                msg,
                &account_id,
                NO_DEPOSIT,
                env::prepaid_gas() - GAS_FOR_NFT_APPROVE - GAS_FOR_MINT,
            ))*/
        } else {
            None
        }
    }*/

    #[payable]
    pub fn put_nft_series_price(&mut self, token_series_id: TokenSeriesId, price: Option<U128>) -> Option<U128> {
        assert_one_yocto();

        let mut token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        assert_eq!(
            env::predecessor_account_id(),
            token_series.creator_id,
            "Creator only"
        );

        assert_eq!(
            token_series.is_mintable,
            true,
            "Token series is not mintable"
        );

        if price.is_none() {
            token_series.price = None;
        } else {
            assert!(
                price.unwrap().0 < MAX_PRICE,
                "Price higher than {}",
                MAX_PRICE
            );
            token_series.price = Some(price.unwrap().0);
        }

        self.token_series_by_id.insert(&token_series_id, &token_series);

        return price;
    }

    fn _nft_mint_series(
        &mut self, 
        token_series_id: TokenSeriesId, 
        receiver_id: AccountId
    ) -> TokenId {
        let mut token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
    
        assert!(
            token_series.is_mintable,
            "Token series is not mintable"
        );

        let num_tokens = token_series.tokens.len();
        let max_copies = token_series.metadata.copies.unwrap_or(u64::MAX);
        
        assert!(num_tokens < max_copies, "Series supply maxed");

        if (num_tokens + 1) >= max_copies {
            token_series.is_mintable = false;
            token_series.price = None;
        }
        
        let token_id = format!("{}{}{}", &token_series_id, TOKEN_DELIMETER, num_tokens + 1);
        token_series.tokens.insert(&token_id);
        self.token_series_by_id.insert(&token_series_id, &token_series);
        let title: String = format!("{} {} {} {} {}", token_series.metadata.title.unwrap().clone(), TITLE_DELIMETER, token_series_id, TITLE_DELIMETER, (num_tokens + 1).to_string());
        
        let token_metadata = Some(TokenMetadata {
            title: Some(title),          
            description: token_series.metadata.description.clone(),   
            media: token_series.metadata.media.clone(),
            media_hash: token_series.metadata.media_hash, 
            copies: token_series.metadata.copies, 
            issued_at: Some(env::block_timestamp().to_string()), 
            expires_at: token_series.metadata.expires_at, 
            starts_at: token_series.metadata.starts_at, 
            updated_at: token_series.metadata.updated_at, 
            extra: token_series.metadata.extra.clone(), 
            reference: token_series.metadata.reference.clone(),
            reference_hash: token_series.metadata.reference_hash, 
        });

        let token_owner_id: AccountId = receiver_id;
      
        self.tokens.internal_mint(token_id.clone(), token_owner_id, token_metadata);

        token_id
    }

    #[payable]
    pub fn nft_burn(&mut self, token_id: TokenId, reedemer: bool) {
        assert_one_yocto();
        
        if reedemer {
            let type_token = token_id.split(":").next().unwrap().to_string().split("|").collect::<Vec<&str>>()[1].to_string();
            assert_eq!(self.black_list_reedemer.contains(&type_token), false, "El token seleccionado no se puede quemar por esta funcion");
        }

        let owner_id = self.tokens.owner_by_id.get(&token_id).unwrap();
        
        assert_eq!(
            owner_id,
            env::predecessor_account_id(),
            "Token owner only"
        );

        if let Some(next_approval_id_by_id) = &mut self.tokens.next_approval_id_by_id {
            next_approval_id_by_id.remove(&token_id);
        }

        if let Some(approvals_by_id) = &mut self.tokens.approvals_by_id {
            approvals_by_id.remove(&token_id);
        }

        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap();
            token_ids.remove(&token_id);
            tokens_per_owner.insert(&owner_id, &token_ids);
        }

        if let Some(token_metadata_by_id) = &mut self.tokens.token_metadata_by_id {
            token_metadata_by_id.remove(&token_id);
        }

        self.tokens.owner_by_id.remove(&token_id);

        NearEvent::log_nft_burn(
            owner_id.to_string(),
            vec![token_id.clone()],
            None,
            None,
        );

        env::log_str(
            &json!({
                "type": "nft_burn",
                "params": {
                    "owner_id": owner_id.clone(),
                    "token_id": token_id.clone(),
                    "reedemer": reedemer
                }
            })
            .to_string(),
        );

    }

    pub fn get_nft_series_copies_availables(&self, token_series_id: TokenSeriesId) -> u64 {
		let token_series = self.token_series_by_id.get(&token_series_id).expect("Series does not exist");
        let copies_availables = token_series.metadata.copies.unwrap() - token_series.tokens.len() as u64 ;
        copies_availables    
	}

    pub fn get_nft_series_single(&self, token_series_id: TokenSeriesId) -> TokenSeriesJson {
		let token_series = self.token_series_by_id.get(&token_series_id).expect("Series does not exist");
		TokenSeriesJson{
            token_series_id,
			metadata: token_series.metadata,
			creator_id: token_series.creator_id,
            royalty: token_series.royalty,
		}
	}

    pub fn get_nft_series(
        &self,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<TokenSeriesJson2> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.token_series_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");

        self.token_series_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_series_id, token_series)| TokenSeriesJson2 {
                token_series_id: token_series_id.clone(),
                metadata: token_series.metadata,
                creator_id: token_series.creator_id,
                price: token_series.price,
                is_mintable: token_series.is_mintable,
                royalty: token_series.royalty
            })
            .collect()
    }

    pub fn nft_token(&self, token_id: TokenId) -> Option<TokenCustom> {
        let owner_id = self.tokens.owner_by_id.get(&token_id)?;
        let approved_account_ids = self
            .tokens
            .approvals_by_id
            .as_ref()
            .and_then(|by_id| by_id.get(&token_id).or_else(|| Some(HashMap::new())));

        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let royalty = self.token_series_by_id.get(&token_series_id).unwrap().royalty;

        let token_metadata = self.tokens.token_metadata_by_id.as_ref().unwrap().get(&token_id).unwrap();

        Some(TokenCustom {
            token_id,
            owner_id,
            metadata: Some(token_metadata),
            approved_account_ids,
            royalty: Some(royalty)
        })
    }

    pub fn nft_transfer_unsafe(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        let sender_id = env::predecessor_account_id();
        let (previous_owner_id, _) = self.tokens.internal_transfer(&sender_id, &receiver_id, &token_id, approval_id, memo.clone());

        let authorized_id : Option<String> = if sender_id != previous_owner_id {
            Some(sender_id.to_string())
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id.to_string(),
            receiver_id.to_string(),
            vec![token_id],
            memo,
            authorized_id,
        );
    }

    #[payable]
    pub fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        self.tokens.nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, memo.clone());
    }

    #[payable]
    pub fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let (previous_owner_id, old_approvals) = self.tokens.internal_transfer(
            &sender_id,
            &receiver_id.clone(),
            &token_id,
            approval_id,
            memo.clone(),
        );

        let authorized_id : Option<String> = if sender_id != previous_owner_id {
            Some(sender_id.to_string())
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id.to_string(),
            receiver_id.to_string(),
            vec![token_id.clone()],
            memo,
            authorized_id,
        );

        // Initiating receiver's call and the callback
        ext_non_fungible_token_receiver::ext(receiver_id.clone())
            .with_static_gas(env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL)
            .nft_on_transfer(
                sender_id,
                previous_owner_id.clone(),
                token_id.clone(),
                msg,
            ).then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .nft_resolve_transfer(
                        previous_owner_id,
                        receiver_id.into(),
                        token_id,
                        old_approvals,
                    )
            ).into()

        /*ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id,
            previous_owner_id.clone(),
            token_id.clone(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL,
        )
        .then(ext_self::nft_resolve_transfer(
            previous_owner_id,
            receiver_id.into(),
            token_id,
            old_approvals,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
        .into()*/

    }

    // CUSTOM enumeration standard modified here because no macro below

    pub fn nft_total_supply(&self) -> U128 {
        (self.tokens.owner_by_id.len() as u128).into()
    }

    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<TokenCustom> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.tokens.owner_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        self.tokens
            .owner_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_id, _)| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_supply_for_owner(self, account_id: AccountId) -> U128 {
        let tokens_per_owner = self.tokens.tokens_per_owner.expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        tokens_per_owner
            .get(&account_id)
            .map(|account_tokens| U128::from(account_tokens.len() as u128))
            .unwrap_or(U128(0))
    }

    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<TokenCustom> {
        let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        let token_set = if let Some(token_set) = tokens_per_owner.get(&account_id) {
            token_set
        } else {
            return vec![];
        };
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            token_set.len() as u128 > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        token_set
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|token_id| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_payout(
        &self, 
        token_id: TokenId,
        balance: U128, 
        max_len_payout: u32
    ) -> Payout{
        let owner_id = self.tokens.owner_by_id.get(&token_id).expect("No token id");
        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let royalty = self.token_series_by_id.get(&token_series_id).expect("no type").royalty;

        assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

        let balance_u128: u128 = balance.into();

        let mut payout: Payout = Payout { payout: HashMap::new() };
        let mut total_perpetual = 0;

        for (k, v) in royalty.iter() {
            if *k != owner_id {
                let key = k.clone();
                payout.payout.insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }
        payout.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));
        payout
    }

    #[payable]
    pub fn nft_transfer_payout(
        &mut self, 
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        balance: Option<U128>,
        max_len_payout: Option<u32>
    ) -> Option<Payout> {
        assert_one_yocto();
        // Transfer
        let previous_token = self.nft_token(token_id.clone()).expect("no token");
        self.tokens.nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, None);

        // Payout calculation
        let previous_owner_id = previous_token.owner_id;
        let mut total_perpetual = 0;
        let payout = if let Some(balance) = balance {
            let balance_u128: u128 = u128::from(balance);
            let mut payout: Payout = Payout { payout: HashMap::new() };

            let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
            let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
            let royalty = self.token_series_by_id.get(&token_series_id).expect("no type").royalty;

            assert!(royalty.len() as u32 <= max_len_payout.unwrap(), "Market cannot payout to that many receivers");
            for (k, v) in royalty.iter() {
                let key = k.clone();
                if key != previous_owner_id {
                    payout.payout.insert(key, royalty_to_payout(*v, balance_u128));
                    total_perpetual += *v;
                }
            }

            assert!(
                total_perpetual <= 10000,
                "Total payout overflow"
            );

            payout.payout.insert(previous_owner_id.clone(), royalty_to_payout(10000 - total_perpetual, balance_u128));
            Some(payout)
        } else {
            None
        };

        payout
    }

}

/* codigo costumizado */
fn royalty_to_payout(a: u32, b: Balance) -> U128 {
    U128(a as u128 * b / 10_000u128)
}

near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool {
        let resp: bool = self.tokens.nft_resolve_transfer(
            previous_owner_id.clone(),
            receiver_id.clone(),
            token_id.clone(),
            approved_account_ids,
        );

        // if not successful, return nft back to original owner
        if !resp {
            NearEvent::log_nft_transfer(
                receiver_id.to_string(),
                previous_owner_id.to_string(),
                vec![token_id],
                None,
                None,
            );
        }

        resp
    }
}

fn refund_deposit(storage_used: u64, extra_spend: Balance) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit() - extra_spend;

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

/*----------- test --------------*/
#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}
'''
'''--- contract/nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::core::{
    NonFungibleTokenCore, NonFungibleTokenResolver
};

//use near_contract_standards::non_fungible_token::approval::ext_nft_approval_receiver;

use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise,
    Balance, serde_json::json, assert_one_yocto, Gas, ext_contract, PromiseOrValue,
};

use near_sdk::collections::{LazyOption, UnorderedMap, UnorderedSet};

/* custon codigo */
use near_sdk::json_types::{/*ValidAccountId,*/ U128, U64};

use serde::Serialize;
use serde::Deserialize;
use std::collections::HashMap;
use near_sdk::env::is_valid_account_id;
pub mod event;
pub use event::NearEvent;

pub const TOKEN_DELIMETER: char = ':';
pub const TITLE_DELIMETER: &str = " #";
pub const VAULT_FEE: u128 = 500;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(40_000_000_000_000); //GAS_FOR_NFT_TRANSFER_CALL(30_000_000_000_000) + GAS_FOR_RESOLVE_TRANSFER;
//const GAS_FOR_NFT_APPROVE: Gas = Gas(10_000_000_000_000);
//const GAS_FOR_MINT: Gas = Gas(90_000_000_000_000);
//const NO_DEPOSIT: Balance = 0;
//const MAX_PRICE: Balance = 1_000_000_000 * 10u128.pow(24);
const CURRENT_TRANSACTION_FEE: Balance = 200;

pub type TokenSeriesId = String;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

/* codigo customizado */

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolverExt {
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool;
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct TokenSeries {
    desc_series: String,
	metadata: TokenMetadata,
	creator_id: AccountId,
	tokens: UnorderedSet<TokenId>,
    objects_mint: UnorderedSet<String>,
    price: Option<f64>,
    is_mintable: bool,
    royalty: HashMap<AccountId, u32>,
    royalty_buy: HashMap<String, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RoyaltyBuy {
	artist_id: String,
	porcentaje: String,
    amount: String,
    amount_usd: String,
    tax: String
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson {
    token_series_id: TokenSeriesId,
	metadata: TokenMetadata,
	creator_id: AccountId,
    royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson2 {
	token_series_id: TokenSeriesId,
    metadata: TokenMetadata,
	creator_id: AccountId,
    price: Option<Balance>,
    price_usd: Option<f64>,
    is_mintable: bool,
    royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson3 {
    token_series_id: TokenSeriesId,
	metadata: TokenMetadata,
	creator_id: AccountId,
    royalty: HashMap<AccountId, u32>,
    transaction_fee: U128
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokensView {
	owner_id: String,
    token_id: String
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ArtistObject {
	id: u128,
    name: String,
    wallet: AccountId,
    next_collection: i128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TypeTokenObject {
	id: u128,
    description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RestrictionsObject {
	id: String,
    token_id_s: u128,
    token_id_r: u128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenCustom {
    token_id: TokenId,
    owner_id: AccountId,
    metadata: Option<TokenMetadata>,
    approved_account_ids: Option<HashMap<AccountId, u64>>,
    royalty: Option<HashMap<AccountId, u32>>
}

/* fin codigo costumizado */

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    /* codigo costumizado */
    owner_id: AccountId,
    list_admin: UnorderedSet<AccountId>,
    list_vip: UnorderedSet<AccountId>,
    maestro_artist: UnorderedMap<u128, ArtistObject>,
    id_artist: u128,
    id_type_token_series: u128,
    type_token_series: UnorderedMap<u128, TypeTokenObject>,
    id_objects: u128,
    id_serie: u128,
    token_series_by_id: UnorderedMap<TokenSeriesId, TokenSeries>,
    restrictions: UnorderedMap<String, RestrictionsObject>,
    vault_id: AccountId,
    black_list_reedemer: UnorderedSet<String>,
    tasa: f64,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    /*codigo costumizado*/
    AdminKey,
    VipKey,
    ArtistKey,
    TypeTokenSeriesKey,
    RestrictionsKeys,
    TokenSeriesById,
    TokensBySeriesInner { token_series: String },
    TokensByObjectsInner { token_series: String },
    BlackListReedemerKey,
    TokensPerOwner { account_hash: Vec<u8> },
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, vault_id: AccountId,) -> Self {
        Self::new(
            owner_id,
            vault_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Music Feast".to_string(),
                symbol: "MusicFeast".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, vault_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id.clone(),
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            /* codigo costumizado */
            owner_id: owner_id,
            list_admin: UnorderedSet::new(StorageKey::AdminKey),
            list_vip: UnorderedSet::new(StorageKey::VipKey),
            maestro_artist: UnorderedMap::new(StorageKey::ArtistKey),
            id_artist: 0,
            id_type_token_series: 0,
            type_token_series: UnorderedMap::new(StorageKey::TypeTokenSeriesKey),
            id_objects: 0,
            id_serie: 0,
            token_series_by_id: UnorderedMap::new(StorageKey::TokenSeriesById),
            restrictions: UnorderedMap::new(StorageKey::RestrictionsKeys),
            vault_id: vault_id,
            black_list_reedemer: UnorderedSet::new(StorageKey::BlackListReedemerKey),
            tasa: 0.0,
        }
    }

    /* codigo original */
    /*
    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens.mint(token_id, receiver_id, Some(token_metadata))
    }*/

    /* codigo custom */
    pub fn edit_vault(&mut self, account_id: AccountId){
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.vault_id = account_id;
    }

    // cargar usuarios a la lista de administradores
    // solo los administradores pueden usar esta funcion
    pub fn add_admin(&mut self, account_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.list_admin.insert(&account_id.clone());

        env::log_str(
            &json!({
                "type": "add_admin",
                "params": {
                    "account_id": account_id.to_string()
                }
            })
            .to_string(),
        );

    }

    // cargar usuarios a la lista de administradores
    // solo los administradores pueden usar esta funcion
    pub fn add_vip(&mut self, account_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.list_vip.insert(&account_id.clone());

        env::log_str(
            &json!({
                "type": "add_vip",
                "params": {
                    "account_id": account_id.to_string()
                }
            })
            .to_string(),
        );

    }

    pub fn is_vip(&self, account_id: AccountId) -> bool {
        self.list_vip.contains(&account_id)
    } 

    pub fn add_black_list_reedemer(&mut self, type_token: String) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.black_list_reedemer.insert(&type_token.clone());

        env::log_str(
            &json!({
                "type": "add_black_list_reedemer",
                "params": {
                    "type_token": type_token
                }
            })
            .to_string(),
        );

    }

    pub fn add_artist(&mut self, name: String, wallet: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let id_artist: u128 = self.id_artist + 1;

        if !is_valid_account_id(wallet.as_bytes()) {
            env::panic_str("Not valid account_id for wallet");
        };

        let data_artist = ArtistObject {
            id: id_artist,
            name: name.clone(),
            wallet: wallet.clone(),
            next_collection: 1
        };

        self.maestro_artist.insert(&data_artist.id, &data_artist);

        self.id_artist = id_artist;

        env::log_str(
            &json!({
                "type": "add_artist",
                "params": {
                    "id": id_artist.to_string(),
                    "name": name,
                    "wallet": wallet.to_string(),
                    "collection": 1,
                }
            })
            .to_string(),
        );
    }

    pub fn update_artist(&mut self, artist_id: u128, name: Option<String>, wallet: Option<AccountId>) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let mut artist = self.maestro_artist.get(&artist_id).expect("artist not exist");

        if name.is_some() {
            artist.name = name.unwrap().clone(); 
        }
        
        if wallet.is_some() {
            if !is_valid_account_id(wallet.as_ref().unwrap().as_bytes()) {
                env::panic_str("Not valid account_id for wallet");
            };
            artist.wallet = wallet.unwrap().clone();
        }

        self.maestro_artist.insert(&artist_id, &artist);

        env::log_str(
            &json!({
                "type": "update_artist",
                "params": {
                    "artist_id": artist_id.to_string(),
                    "name": artist.name.to_string(),
                    "wallet": artist.wallet.to_string(),
                }
            })
            .to_string(),
        );
    }

    pub fn next_collection(&mut self, artist_id: u128) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let mut artist = self.maestro_artist.get(&artist_id).expect("artist not exist");

        artist.next_collection += 1;

        self.maestro_artist.insert(&artist_id, &artist);

        env::log_str(
            &json!({
                "type": "next_collection",
                "params": {
                    "artist_id": artist_id.to_string(),
                    "next_collection": artist.next_collection.to_string()
                }
            })
            .to_string(),
        );
    }

    pub fn get_artist(self) -> Vec<ArtistObject> {
        self.maestro_artist.iter().map(|(_k, v)| { v }).collect()
    }

    pub fn add_type_token_series(&mut self, description: String) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let id_type_token: u128 = self.id_type_token_series + 1;

        let data_type_token = TypeTokenObject {
            id: id_type_token,
            description: description.clone(),
        };

        self.type_token_series.insert(&data_type_token.id, &data_type_token);

        self.id_type_token_series = id_type_token;

        env::log_str(
            &json!({
                "type": "add_type_token_series",
                "params": {
                    "id": id_type_token.to_string(),
                    "description": description
                }
            })
            .to_string(),
        );
    }

    pub fn get_type_token_series(self) -> Vec<TypeTokenObject> {
        self.type_token_series.iter().map(|(_k, v)| {v}).collect()
    }

    pub fn add_restriction(&mut self, token_id_s: u128, token_id_r: u128) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        assert!(self.type_token_series.get(&token_id_s).is_some(), "Token_id_s not exist");
        assert!(self.type_token_series.get(&token_id_r).is_some(), "Token_id_r not exist");
        assert!(self.restrictions.get(&token_id_s.to_string()).is_none(), "The requested token already has a constraint.");

        let data_restriction = RestrictionsObject {
            id: token_id_s.to_string(),
            token_id_s: token_id_s,
            token_id_r: token_id_r,
        };

        self.restrictions.insert(&data_restriction.id, &data_restriction);

        env::log_str(
            &json!({
                "type": "add_restriction",
                "params": {
                    "token_id_s": token_id_s.to_string(),
                    "token_id_r": token_id_r.to_string()
                }
            })
            .to_string(),
        );
    }

    pub fn get_restriction(self) -> Vec<RestrictionsObject> {
        self.restrictions.iter().map(|(_k, v)| {v}).collect()
    }

    pub fn update_tasa(&mut self, tasa: f64) -> f64 {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");        
        assert!(tasa > 0.0, "La tasa debe ser mayor a 0");
        
        self.tasa = tasa;

        env::log_str(
            &json!({
                "type": "update_tasa",
                "params": {
                    "tasa": self.tasa
                }
            })
            .to_string(),
        );
        self.tasa
    }

    pub fn get_tasa(self) -> f64 {
        self.tasa
    }

   #[payable]
    pub fn update_nft_series(&mut self, 
        token_series_id: TokenSeriesId, 
        title: Option<String>,
        description: Option<String>,
        media: Option<String>,
        price: Option<f64>,
        extra: Option<String>,
        royalty: Option<HashMap<AccountId, u32>>,
        royalty_buy: Option<HashMap<String, u32>>,
    ) -> TokenSeriesJson {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");

        //let initial_storage_usage = env::storage_usage();
        

        let mut nft_serie = self.token_series_by_id.get(&token_series_id).expect("tonken serie id not exist");
        if title.is_some() { nft_serie.metadata.title = title; }
        if description.is_some() { nft_serie.metadata.description = description; }
        if media.is_some() { nft_serie.metadata.media = media; }
        if price.is_some() {
            assert_eq!(
                nft_serie.is_mintable,
                true,
                "Token series is not mintable"
            );
            
            if price.unwrap() > 0.0 {
                let porcentaje_adicional: f64 = 1.05;
                let price_final: f64 = price.unwrap() * porcentaje_adicional; 
                nft_serie.price = Some(price_final);
            } else {
                nft_serie.price = None;
            }
        }

        if extra.is_some() { nft_serie.metadata.extra = extra; }

        if royalty_buy.is_some() {
            let mut total_perpetual = 0;
            let mut total_accounts = 0;
            let royalty_buy_res: HashMap<String, u32> = if let Some(royalty_buy) = royalty_buy {
                for (k, v) in royalty_buy.iter() {
                    if self.maestro_artist.get(&*k.parse::<u128>().as_ref().unwrap()).is_none() && *k.parse::<u128>().as_ref().unwrap() > 0 {
                        env::panic_str("Not valid artist_id for royalty");
                    };
                    total_perpetual += v;
                    total_accounts += 1;
                }
                royalty_buy
            } else {
                HashMap::new()
            };

            assert!(total_accounts <= 10, "royalty_buy exceeds 10 accounts");

            assert!(
                total_perpetual <= 10000,
                "Exceeds maximum royalty_buy -> 10000",
            );
            nft_serie.royalty_buy = royalty_buy_res;
        }
        
        if royalty.is_some() {
            let mut total_perpetual = 0;
            let mut total_accounts = 0;
            let royalty_res: HashMap<AccountId, u32> = if let Some(royalty) = royalty {
                for (k , v) in royalty.iter() {
                    if !is_valid_account_id(k.as_bytes()) {
                        env::panic_str("Not valid account_id for royalty");
                    };
                    total_perpetual += *v;
                    total_accounts += 1;
                }
                royalty
            } else {
                HashMap::new()
            };

            assert!(total_accounts <= 10, "royalty exceeds 10 accounts");

            assert!(
                total_perpetual <= 9000,
                "Exceeds maximum royalty -> 9000",
            );
            nft_serie.royalty = royalty_res;
        }

        self.token_series_by_id.insert(&token_series_id, &nft_serie);

        let precio: Option<String> = if nft_serie.price.is_some() {
            Some(nft_serie.price.unwrap().to_string())
        } else {
            None
        };

        env::log_str(
            &json!({
                "type": "update_nft_series",
                "params": {
                    "token_series_id": token_series_id,
                    "desc_series": nft_serie.desc_series.clone(),
                    "token_metadata": nft_serie.metadata.clone(),
                    "creator_id": nft_serie.creator_id.clone(),
                    "price": precio,
                    "royalty": nft_serie.royalty.clone(),
                    "royalty_buy": nft_serie.royalty_buy.clone(),
                }
            })
            .to_string(),
        );

        //refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        TokenSeriesJson {
            token_series_id,
			metadata: nft_serie.metadata.clone(),
			creator_id: nft_serie.creator_id.clone(),
            royalty: nft_serie.royalty,
		}
    }
 

    #[payable]
    pub fn nft_series(
        &mut self,
        artist_id: u128,
        type_token_id: u128,
        //objects: bool,
        token_metadata: TokenMetadata,
        //objects_ids: Option<Vec<String>>,
        price: Option<f64>,
        royalty: Option<HashMap<AccountId, u32>>,
        royalty_buy: Option<HashMap<String, u32>>,
    ) -> TokenSeriesJson {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        assert!((self.tasa > 0.0), "Tasa debe ser mayor a 0");
        let data_artist = self.maestro_artist.get(&artist_id).expect("Artist_id not exist");
        
        let type_token = self.type_token_series.get(&type_token_id).expect("type_token_id not exist");

        let initial_storage_usage = env::storage_usage();
        let caller_id = env::signer_account_id();

        let token_series_id: String;
        
        if type_token_id == 1 {
            token_series_id = format!("{}|{}|1", artist_id, type_token_id);
        } else if type_token_id > 1 && type_token_id <= 6 {
            token_series_id = format!("{}|{}|{}", artist_id, type_token_id, data_artist.next_collection);
        } else if type_token_id == 7 {
            token_series_id = format!("{}|{}|{}|E{}", artist_id, type_token_id, data_artist.next_collection, self.id_serie.to_string());
        } else {
            env::panic_str("contract internal error");
        }
        

        assert!(
            self.token_series_by_id.get(&token_series_id).is_none(),
            "duplicate token_series_id"
        );

        let title = token_metadata.title.clone();
        assert!(title.is_some(), "token_metadata.title is required");
        
        
        let mut total_perpetual = 0;
        let mut total_accounts = 0;
        let royalty_res_buy =  if let Some(royalty_buy) = royalty_buy {
            for (k, v) in royalty_buy.iter() {
                if self.maestro_artist.get(&*k.parse::<u128>().as_ref().unwrap()).is_none() && *k.parse::<u128>().as_ref().unwrap() > 0 {
                    env::panic_str("Not valid artist_id for royalty");
                };
                total_perpetual += v;
                total_accounts += 1;
            }
            royalty_buy
        } else {
            HashMap::new()
        };

        assert!(total_accounts <= 10, "royalty_buy exceeds 10 accounts");

        assert!(
            total_perpetual <= 10000,
            "Exceeds maximum royalty_buy -> 10000",
        );

        total_perpetual = 0;
        total_accounts = 0;
        let royalty_res: HashMap<AccountId, u32> = if let Some(royalty) = royalty {
            for (k , v) in royalty.iter() {
                if !is_valid_account_id(k.as_bytes()) {
                    env::panic_str("Not valid account_id for royalty");
                };
                total_perpetual += *v;
                total_accounts += 1;
            }
            royalty
        } else {
            HashMap::new()
        };

        assert!(total_accounts <= 10, "royalty exceeds 10 accounts");

        assert!(
            total_perpetual <= 9000,
            "Exceeds maximum royalty -> 9000",
        );

        let price_res: Option<f64> = if price.is_some() {
            let porcentaje_adicional: f64 = 1.05;
            let price_final: f64 = price.unwrap() * porcentaje_adicional; 
            Some(price_final)
        } else {
            None
        };

        /*if objects_ids.is_some() && objects == false {
            for item in objects_ids.clone().unwrap().iter() {
                assert!(item.split("|").next().unwrap().to_string() == artist_id.to_string(), "The object does not belong to the selected artist");
                self.token_series_by_id.get(&item).expect("token objects series id not exist");
            }
        }*/

        self.token_series_by_id.insert(&token_series_id, &TokenSeries{
            desc_series: type_token.description.clone(),
            metadata: token_metadata.clone(),
            creator_id: caller_id.clone(),
            tokens: UnorderedSet::new(
                StorageKey::TokensBySeriesInner {
                    token_series: token_series_id.clone(),
                }
                .try_to_vec()
                .unwrap(),
            ),
            objects_mint: UnorderedSet::new(
                StorageKey::TokensByObjectsInner {
                    token_series: token_series_id.clone(),
                }
                .try_to_vec()
                .unwrap(),
            ),
            price: price_res,
            is_mintable: true,
            royalty: royalty_res.clone(),
            royalty_buy: royalty_res_buy.clone(),
        });

        /*if objects_ids.is_some() && objects == false {
            let mut data_serie = self.token_series_by_id.get(&token_series_id).expect("token series id no existe");
            for item in objects_ids.unwrap().iter() {
                data_serie.objects_mint.insert(&item.to_string());
            }   
            self.token_series_by_id.insert(&token_series_id, &data_serie);
        }*/
        

        env::log_str(
            &json!({
                "type": "nft_create_series",
                "params": {
                    "token_series_id": token_series_id.to_string(),
                    "objects": false,//objects,
                    "desc_series": type_token.description.to_string(),
                    "token_metadata": token_metadata,
                    "creator_id": caller_id.to_string(),
                    "price": price_res,
                    "royalty": royalty_res
                }
            })
            .to_string(),
        );

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

		TokenSeriesJson{
            token_series_id,
			metadata: token_metadata,
			creator_id: caller_id.into(),
            royalty: royalty_res,
		}
    }

    #[payable]
    pub fn nft_objects(
        &mut self,
        token_metadata: TokenMetadata,
        token_series_id_assignment: TokenSeriesId
    ) -> String {
        let initial_storage_usage = env::storage_usage();
        let caller_id = env::predecessor_account_id();

        let artist_id = token_series_id_assignment.split("|").collect::<Vec<&str>>()[0].to_string();
        let type_token_id = token_series_id_assignment.split("|").collect::<Vec<&str>>()[1].to_string();
        let collection = token_series_id_assignment.split("|").collect::<Vec<&str>>()[2].to_string();
        let type_token = self.type_token_series.get(&type_token_id.parse::<u128>().as_ref().unwrap()).expect("type_token_id not exist");
        
        let mut data_serie = self.token_series_by_id.get(&token_series_id_assignment.clone()).expect("token_series_id_assignment not valid!");

        self.id_objects += 1;
        let token_object_id: String = format!("{}|{}|{}|O{}", artist_id, type_token_id, collection, self.id_objects.to_string());

        let mut object_metadata: TokenMetadata = token_metadata.clone();
        object_metadata.copies = None;
        object_metadata.title = data_serie.metadata.title.clone();
        object_metadata.description = data_serie.metadata.description.clone();
        object_metadata.media = Some("https://globaldv.mypinata.cloud/ipfs/QmWfV239tGfBLZAU2hMYQnjwHcxMp1UKvHWVurTpS3sNKH".to_string());
        object_metadata.reference = Some(token_series_id_assignment.to_string());

        self.token_series_by_id.insert(&token_object_id, &TokenSeries{
            desc_series: type_token.description.clone(),
            metadata: object_metadata.clone(),
            creator_id: caller_id.clone(),
            tokens: UnorderedSet::new(
                StorageKey::TokensBySeriesInner {
                    token_series: token_object_id.clone(),
                }
                .try_to_vec()
                .unwrap(),
            ),
            objects_mint: UnorderedSet::new(
                StorageKey::TokensByObjectsInner {
                    token_series: token_object_id.clone(),
                }
                .try_to_vec()
                .unwrap(),
            ),
            price: None,
            is_mintable: true,
            royalty: HashMap::new(),
            royalty_buy: HashMap::new(),
        });

        
        //agregando el nft camgeable al evento
        
        data_serie.objects_mint.insert(&token_object_id.clone()); 
        self.token_series_by_id.insert(&token_series_id_assignment.clone(), &data_serie);
        
        
        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        env::log_str(
            &json!({
                "type": "nft_objects",
                "params": {
                    "token_series_id": token_object_id.clone(),
                    "token_metadata": object_metadata.clone(),
                    "desc_series": type_token.description.to_string(),
                    "creator_id": caller_id.to_string(),
                    "objects": true,
                    "price": 0,
                    "royalty": [],
                    "royalty_buy": []
                }
            })
            .to_string(),
        );

		
        token_object_id.to_string()
    }

//near call nft16.musicfeast.testnet nft_buy '{"token_series_id": "11|1|1"}'  --accountId hpalencia.testnet --deposit 1
    #[payable]
    pub fn nft_buy(
        &mut self, 
        token_series_id: TokenSeriesId,
        receiver_id: Option<AccountId>
    ) -> TokenId {
        //token_series_id.split("|").collect::<Vec<&str>>()[2];
        
        /*account_id: TokenSeriesId,
        artist_id: TokenMetadata,
        porcentaje: u32,*/
        let initial_storage_usage = env::storage_usage();
        
        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        let artist_id = token_series_id.split("|").next().unwrap().to_string();
        let price: f64 = token_series.price.expect("not for sale");
        let attached_deposit = env::attached_deposit();
        let receiver_id: AccountId = if let Some(receiver_id) = receiver_id {
            if !is_valid_account_id(receiver_id.as_bytes()) {
                env::panic_str("Not valid account_id for royalty");
            };
            receiver_id
        } else {
            env::predecessor_account_id()
        };
        let type_token = token_series_id.split("|").collect::<Vec<&str>>()[1].to_string();

        let price_near: f64 = price / self.tasa;
        let price_yocto: u128 = (price_near * 10u128.pow(24) as f64) as u128;

        let tax: u128 = (price_yocto * 500)/10000;  //0.5% del precio
        let amount_final: u128 = price_yocto - tax;
        
        let tax_usd: f64 = price * 0.05; //0.5% del precio
        let amount_usd_final: f64 = price - tax_usd;

        let royalty_buy: Vec<RoyaltyBuy> = token_series.royalty_buy.iter().map(|(k, v)| 
            {
                let mut tax_final: String = "0".to_string();
                let mut amount: String = ((amount_final * (*v as u128))/10000).to_string();
                let mut amount_usd: String =  (amount_usd_final * (*v as f64 / 10000.0)).to_string();

                if *k.parse::<u128>().as_ref().unwrap() == 0 {
                    tax_final = (tax/2).to_string();
                }

                if *k == artist_id {
                    amount = (((amount_final * (*v as u128))/10000) + (tax/2)).to_string();
                    amount_usd = ((amount_usd_final * (*v as f64 / 10000.0)) + (tax_usd/2.0)).to_string();
                }

                RoyaltyBuy{
                    artist_id: k.clone(),
                    porcentaje: v.to_string(),
                    amount: amount,
                    amount_usd: amount_usd, 
                    tax: tax_final,
                }
            }).collect();

        if self.list_vip.contains(&env::signer_account_id()) && type_token == "1" {
            assert!(
                attached_deposit >= 5000000000000000000000,
                "attached deposit is less than price : {}",
                "5000000000000000000000"    
            );

            let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.clone());

            for item in token_series.objects_mint.iter() {
                self._nft_mint_series(item.to_string(), receiver_id.clone());
            }

            refund_deposit(env::storage_usage() - initial_storage_usage, 0);

            /*NearEvent::log_nft_mint(
                receiver_id.to_string(),
                vec![token_id.clone()],
                Some(json!({"price": "0"}).to_string())
            );*/

            env::log_str(
                &json!({
                    "type": "nft_buy",
                    "params": {
                        "artista": artist_id.clone(),   
                        "tasa": self.tasa,
                        "price_usd": "0".to_string(),
                        "price": "0".to_string(),
                        //"amount_artist": "0".to_string(), // 70% del artista
                        //"amount_musicfeast": "0".to_string(), // 30% musicfeast
                        //"tax_artist": "0".to_string(),
                        //"tax_musicfeast": "0".to_string(),
                        "royalty": royalty_buy,
                        //"token_series.objects_mint": token_series.objects_mint.iter().map(|v| v.clone()).collect::<Vec<_>>(),
                    }
                })
                .to_string(),
            );

            token_id
        } else {    
            assert!(
                attached_deposit >= (price_yocto + 50_000_000_000_000_000_000_000u128),
                "attached deposit is less than price : {}",
                (price_yocto + 50_000_000_000_000_000_000_000u128)
            );

            let restriction = self.restrictions.get(&token_series.metadata.reference.unwrap().to_string());
            
            if restriction.is_some() {
                let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().expect(
                    "Could not find tokens_per_owner when calling a method on the enumeration standard.",
                );
                let token_set = tokens_per_owner.get(&receiver_id).expect("You do not have the corresponding token to buy the requested token");
                let token_id_r: String = restriction.unwrap().token_id_r.to_string();
                
                let valit_token_owner = token_set
                    .iter()
                    .find(|token_id| token_id.split(":").next().unwrap().to_string() == format!("{}|{}|1",artist_id, token_id_r).to_string());
                assert!(valit_token_owner != None
                    , "You do not have the corresponding token to buy the requested token");
            }

            let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.clone());

            for item in token_series.objects_mint.iter() {
                self._nft_mint_series(item.to_string(), receiver_id.clone());
            }

            //let for_vault = price as u128 * VAULT_FEE / 10_000u128;
            //let price_deducted = price - for_vault;
            //Promise::new(token_series.creator_id).transfer(price_deducted);
            
            Promise::new(self.vault_id.clone()).transfer(price_yocto);
            
            
            refund_deposit(env::storage_usage() - initial_storage_usage, price_yocto);

            /*NearEvent::log_nft_mint(
                receiver_id.to_string(),
                vec![token_id.clone()],
                Some(json!({"price": price.to_string()}).to_string())
            );*/

            env::log_str(
                &json!({
                    "type": "nft_buy",
                    "params": {
                        "artista": artist_id.clone(),   
                        "tasa": self.tasa,
                        "price_usd": price.to_string(),
                        "price": price_yocto.to_string(),
                        //"amount_artist": (((amount_final * 7000)/10000) + (tax/2)).to_string(), // 70% del artista
                        //"amount_musicfeast": ((amount_final * 3000)/10000).to_string(), // 30% musicfeast
                        //"tax_artist": "0",
                        //"tax_musicfeast": (tax/2).to_string(),
                        "royalty": royalty_buy,
                        //"token_series.objects_mint": token_series.objects_mint.iter().map(|v| v.clone()).collect::<Vec<_>>(),
                    }
                })
                .to_string(),
            );

            token_id
        }
    }

    pub fn auto_swap_complete(
        &mut self, 
        artist_id: String,
        amount_near: U128,
        tax_near: U128,
        amount_usd: String,
        ft_token: String,
    ) {
        assert_eq!(env::predecessor_account_id(), self.vault_id.clone(), "no autorizado");
        
        env::log_str(
            &json!({
                "type": "auto_swap_complete",
                "params": {
                    "artista": artist_id.clone(),
                    "amount_near": amount_near.0.to_string(),
                    "tax_near": tax_near.0.to_string(),
                    "amount_usd": amount_usd.to_string(),
                    "ft_token": ft_token,
                }
            })
            .to_string(),
        );
    }

    pub fn auto_swap_ajuste_error(
        &mut self, 
        artist_id: String, 
        amount: String,
        amount_near: String,
        tax_near: U128,
        ft_token: String,
        arg: String,
    ) {
        assert_eq!(env::predecessor_account_id(), self.vault_id.clone(), "no autorizado");
        
        env::log_str(
            &json!({
                "type": "auto_swap_ajuste_error",
                "params": {
                    "artista": artist_id.clone(),
                    "amount": amount.to_string(),
                    "amount_near": amount_near.to_string(),
                    "tax_near": tax_near.0.to_string(),
                    "ft_token": ft_token.to_string(),
                    "arg": arg
                }
            })
            .to_string(),
        );
    }

    pub fn auto_swap_transfer_error(
        &mut self, 
        artist_id: String, 
        amount: String,
        amount_near: String,
        ft_token: String,
        arg: String,
    ) {
        assert_eq!(env::predecessor_account_id(), self.vault_id.clone(), "no autorizado");
        
        env::log_str(
            &json!({
                "type": "auto_swap_transfer_error",
                "params": {
                    "artista": artist_id.clone(),
                    "amount": amount.to_string(),
                    "amount_near": amount_near.to_string(),
                    "ft_token": ft_token.to_string(),
                    "arg": arg
                }
            })
            .to_string(),
        );
    }

    #[payable]
    pub fn nft_mint(
        &mut self, 
        token_series_id: TokenSeriesId, 
        receiver_id: AccountId
    ) -> TokenId {
        let initial_storage_usage = env::storage_usage();

        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        assert_eq!(env::predecessor_account_id(), token_series.creator_id.clone(), "not creator");
        let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.clone());

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        /*NearEvent::log_nft_mint(
            receiver_id.to_string(),
            vec![token_id.clone()],
            None,
        );*/

        token_id
    }

    #[payable]
    pub fn nft_mint_for(
        &mut self, 
        token_series_id: TokenSeriesId,
        nft_quantity: i64,
        receiver_id: AccountId
    ) -> i64 {
        let initial_storage_usage = env::storage_usage();

        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        assert!(nft_quantity <= 40, "No se pueden mintear mas de 40 nft en un solo llamado");
        assert!(env::predecessor_account_id() == token_series.creator_id.clone() || self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        
        for _i in 0..nft_quantity {
            self._nft_mint_series(token_series_id.clone(), receiver_id.clone());
        }

        
        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        nft_quantity
    }

    #[payable]
    pub fn deliver_gift(
        &mut self,
        receiver_id: AccountId
    ) {       
        let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        let token_set = tokens_per_owner.get(&env::predecessor_account_id());

        assert!(token_set.is_some(), "No quedan Nft para regalar");
        
        let first_idx: usize = 0;
        let token_id:TokenId = token_set.unwrap().iter()
            .skip(0 as usize)
            .take(1)
            .map(|token_id| token_id).collect::<Vec<_>>()[first_idx].clone();

        self.tokens.nft_transfer(receiver_id.clone(), token_id , None, None);
        // self.tokens.nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, memo.clone());
    }

    fn _nft_mint_series(
        &mut self, 
        token_series_id: TokenSeriesId, 
        receiver_id: AccountId
    ) -> TokenId {
        let mut token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
    
        assert!(
            token_series.is_mintable,
            "Token series is not mintable"
        );

        let num_tokens = token_series.tokens.len();
        let max_copies = token_series.metadata.copies.unwrap_or(u64::MAX);
        
        assert!(num_tokens < max_copies, "Series supply maxed");

        if (num_tokens + 1) >= max_copies {
            token_series.is_mintable = false;
            token_series.price = None;
        }
        
        let token_id = format!("{}{}{}", &token_series_id, TOKEN_DELIMETER, num_tokens + 1);
        token_series.tokens.insert(&token_id);
        self.token_series_by_id.insert(&token_series_id, &token_series);
        let title: String = format!("{} {} {} {} {}", token_series.metadata.title.unwrap().clone(), TITLE_DELIMETER, token_series_id, TITLE_DELIMETER, (num_tokens + 1).to_string());
        
        let token_metadata = Some(TokenMetadata {
            title: Some(title),          
            description: token_series.metadata.description.clone(),   
            media: token_series.metadata.media.clone(),
            media_hash: token_series.metadata.media_hash, 
            copies: token_series.metadata.copies, 
            issued_at: Some(env::block_timestamp().to_string()), 
            expires_at: token_series.metadata.expires_at, 
            starts_at: token_series.metadata.starts_at, 
            updated_at: token_series.metadata.updated_at, 
            extra: token_series.metadata.extra.clone(), 
            reference: token_series.metadata.reference.clone(),
            reference_hash: token_series.metadata.reference_hash, 
        });

        let token_owner_id: AccountId = receiver_id.clone();
      
        //self.tokens.internal_mint(token_id.clone(), token_owner_id, token_metadata);
        //let owner_id: AccountId = receiver_id.clone();
        self.tokens.owner_by_id.insert(&token_id, &token_owner_id);

        self.tokens
            .token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &token_metadata.as_ref().unwrap()));

        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&token_owner_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(&token_owner_id.as_bytes()),
                })
            });
            token_ids.insert(&token_id);
            tokens_per_owner.insert(&token_owner_id, &token_ids);
        }
        
        NearEvent::log_nft_mint(
            receiver_id.to_string(),
            vec![token_id.clone()],
            None,
        );

        token_id

    }

    #[payable]
    pub fn nft_burn(&mut self, token_id: TokenId, reedemer: bool) {
        assert_one_yocto();
        
        if reedemer {
            let type_token = token_id.to_string().contains("o");
            assert_eq!(type_token, false, "El token seleccionado no se puede quemar por esta funcion");
        }

        let owner_id = self.tokens.owner_by_id.get(&token_id).unwrap();
        
        assert_eq!(
            owner_id,
            env::predecessor_account_id(),
            "Token owner only"
        );

        if let Some(next_approval_id_by_id) = &mut self.tokens.next_approval_id_by_id {
            next_approval_id_by_id.remove(&token_id);
        }

        if let Some(approvals_by_id) = &mut self.tokens.approvals_by_id {
            approvals_by_id.remove(&token_id);
        }

        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap();
            token_ids.remove(&token_id);
            tokens_per_owner.insert(&owner_id, &token_ids);
        }

        if let Some(token_metadata_by_id) = &mut self.tokens.token_metadata_by_id {
            token_metadata_by_id.remove(&token_id);
        }

        self.tokens.owner_by_id.remove(&token_id);

        NearEvent::log_nft_burn(
            owner_id.to_string(),
            vec![token_id.clone()],
            None,
            None,
        );

        env::log_str(
            &json!({
                "type": "nft_burn",
                "params": {
                    "owner_id": owner_id.clone(),
                    "token_id": token_id.clone(),
                    "reedemer": reedemer
                }
            })
            .to_string(),
        );

    }

    pub fn reedemer_approved(&self, token_id: TokenId) {
        assert!(self.owner_id == env::predecessor_account_id() || self.list_admin.contains(&env::predecessor_account_id()), "Only administrator");

        env::log_str(
            &json!({
                "type": "reedemer_approved",
                "params": {
                    "user_id": env::predecessor_account_id(),
                    "token_id": token_id.clone(),
                }
            })
            .to_string(),
        );
    }

    pub fn get_nft_series_copies_availables(&self, token_series_id: TokenSeriesId) -> u64 {
		let token_series = self.token_series_by_id.get(&token_series_id).expect("Series does not exist");
        let copies_availables = token_series.metadata.copies.unwrap() - token_series.tokens.len() as u64 ;
        copies_availables    
	}

    /*pub fn get_nft_series_single(&self, token_series_id: TokenSeriesId) -> TokenSeriesJson {
		let token_series = self.token_series_by_id.get(&token_series_id).expect("Series does not exist");
		TokenSeriesJson{
            token_series_id,
			metadata: token_series.metadata,
			creator_id: token_series.creator_id,
            royalty: token_series.royalty,
		}
	}*/

    pub fn get_nft_series(
        &self,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<TokenSeriesJson2> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.token_series_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");

        self.token_series_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_series_id, token_series)| {
                let mut price_yocto: Option<u128> = None;
                if token_series.price.is_some() {
                    let price_near: f64 = token_series.price.unwrap() / self.tasa;
                    price_yocto = Some((price_near * 10u128.pow(24) as f64) as u128);
                }
                
                TokenSeriesJson2 {
                    token_series_id: token_series_id.clone(),
                    metadata: token_series.metadata,
                    creator_id: token_series.creator_id,
                    price: price_yocto,
                    price_usd: token_series.price,
                    is_mintable: token_series.is_mintable,
                    royalty: token_series.royalty
                }
            })
            .collect()
    }

    pub fn nft_token(&self, token_id: TokenId) -> Option<TokenCustom> {
        let owner_id = self.tokens.owner_by_id.get(&token_id)?;
        let approved_account_ids = self
            .tokens
            .approvals_by_id
            .as_ref()
            .and_then(|by_id| by_id.get(&token_id).or_else(|| Some(HashMap::new())));

        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let royalty = self.token_series_by_id.get(&token_series_id).unwrap().royalty;

        let token_metadata = self.tokens.token_metadata_by_id.as_ref().unwrap().get(&token_id).unwrap();

        Some(TokenCustom {
            token_id,
            owner_id,
            metadata: Some(token_metadata),
            approved_account_ids,
            royalty: Some(royalty)
        })
    }

    pub fn nft_transfer_unsafe(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        let sender_id = env::predecessor_account_id();
        let (previous_owner_id, _) = self.tokens.internal_transfer(&sender_id, &receiver_id, &token_id, approval_id, memo.clone());

        let authorized_id : Option<String> = if sender_id != previous_owner_id {
            Some(sender_id.to_string())
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id.to_string(),
            receiver_id.to_string(),
            vec![token_id],
            memo,
            authorized_id,
        );
    }

    #[payable]
    pub fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        self.tokens.nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, memo.clone());
    }

    #[payable]
    pub fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let (previous_owner_id, old_approvals) = self.tokens.internal_transfer(
            &sender_id,
            &receiver_id.clone(),
            &token_id,
            approval_id,
            memo.clone(),
        );

        let authorized_id : Option<String> = if sender_id != previous_owner_id {
            Some(sender_id.to_string())
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id.to_string(),
            receiver_id.to_string(),
            vec![token_id.clone()],
            memo,
            authorized_id,
        );

        // Initiating receiver's call and the callback
        ext_non_fungible_token_receiver::ext(receiver_id.clone())
            .with_static_gas(env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL)
            .nft_on_transfer(
                sender_id,
                previous_owner_id.clone(),
                token_id.clone(),
                msg,
            ).then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .nft_resolve_transfer(
                        previous_owner_id,
                        receiver_id.into(),
                        token_id,
                        old_approvals,
                    )
            ).into()

        /*ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id,
            previous_owner_id.clone(),
            token_id.clone(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL,
        )
        .then(ext_self::nft_resolve_transfer(
            previous_owner_id,
            receiver_id.into(),
            token_id,
            old_approvals,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
        .into()*/

    }

    // CUSTOM enumeration standard modified here because no macro below

    pub fn nft_total_supply(&self) -> U128 {
        (self.tokens.owner_by_id.len() as u128).into()
    }

    pub fn nft_supply_for_series(&self, token_series_id: TokenSeriesId) -> U64 {
        self.token_series_by_id.get(&token_series_id).expect("Token series not exist").tokens.len().into()
    }

    pub fn nft_get_series_single(&self, token_series_id: TokenSeriesId) -> TokenSeriesJson3 {
		let token_series = self.token_series_by_id.get(&token_series_id).expect("Series does not exist");
        
		TokenSeriesJson3{
            token_series_id,
			metadata: token_series.metadata,
			creator_id: token_series.creator_id,
            royalty: token_series.royalty,
            transaction_fee: U128::from(CURRENT_TRANSACTION_FEE)
		}
	}

    pub fn nft_get_series_price(self, token_series_id: TokenSeriesId) -> Option<U128> {
        let price = self.token_series_by_id.get(&token_series_id).unwrap().price;

        match price {
            Some(p) => {
                let price_near: f64 = p / self.tasa;
                let price_yocto: u128 = (price_near * 10u128.pow(24) as f64) as u128;
                return Some(U128::from(price_yocto + 100_000_000_000_000_000_000_000u128))
                //return Some(U128::from(price_yocto))
            },
            None => return None
        };
    }

    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<TokenCustom> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.tokens.owner_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        self.tokens
            .owner_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_id, _)| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_supply_for_owner(self, account_id: AccountId) -> U128 {
        let tokens_per_owner = self.tokens.tokens_per_owner.expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        tokens_per_owner
            .get(&account_id)
            .map(|account_tokens| U128::from(account_tokens.len() as u128))
            .unwrap_or(U128(0))
    }

    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<TokenCustom> {
        let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        let token_set = if let Some(token_set) = tokens_per_owner.get(&account_id) {
            token_set
        } else {
            return vec![];
        };
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            token_set.len() as u128 > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        token_set
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|token_id| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_payout(
        &self, 
        token_id: TokenId,
        balance: U128, 
        max_len_payout: u32
    ) -> Payout{
        let owner_id = self.tokens.owner_by_id.get(&token_id).expect("No token id");
        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let royalty = self.token_series_by_id.get(&token_series_id).expect("no type").royalty;

        assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

        let balance_u128: u128 = balance.into();

        let mut payout: Payout = Payout { payout: HashMap::new() };
        let mut total_perpetual = 0;

        for (k, v) in royalty.iter() {
            if *k != owner_id {
                let key = k.clone();
                payout.payout.insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }
        payout.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));
        payout
    }

    #[payable]
    pub fn nft_transfer_payout(
        &mut self, 
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        balance: Option<U128>,
        max_len_payout: Option<u32>
    ) -> Option<Payout> {
        assert_one_yocto();
        // Transfer
        let previous_token = self.nft_token(token_id.clone()).expect("no token");
        self.tokens.nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, None);

        // Payout calculation
        let previous_owner_id = previous_token.owner_id;
        let mut total_perpetual = 0;
        let payout = if let Some(balance) = balance {
            let balance_u128: u128 = u128::from(balance);
            let mut payout: Payout = Payout { payout: HashMap::new() };

            let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
            let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
            let royalty = self.token_series_by_id.get(&token_series_id).expect("no type").royalty;

            assert!(royalty.len() as u32 <= max_len_payout.unwrap(), "Market cannot payout to that many receivers");
            for (k, v) in royalty.iter() {
                let key = k.clone();
                if key != previous_owner_id {
                    payout.payout.insert(key, royalty_to_payout(*v, balance_u128));
                    total_perpetual += *v;
                }
            }

            assert!(
                total_perpetual <= 10000,
                "Total payout overflow"
            );

            payout.payout.insert(previous_owner_id.clone(), royalty_to_payout(10000 - total_perpetual, balance_u128));
            Some(payout)
        } else {
            None
        };

        payout
    }

}

/* codigo costumizado */
fn royalty_to_payout(a: u32, b: Balance) -> U128 {
    U128(a as u128 * b / 10_000u128)
}

near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool {
        let resp: bool = self.tokens.nft_resolve_transfer(
            previous_owner_id.clone(),
            receiver_id.clone(),
            token_id.clone(),
            approved_account_ids,
        );

        // if not successful, return nft back to original owner
        if !resp {
            NearEvent::log_nft_transfer(
                receiver_id.to_string(),
                previous_owner_id.to_string(),
                vec![token_id],
                None,
                None,
            );
        }

        resp
    }
}

fn refund_deposit(storage_used: u64, extra_spend: Balance) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit() - extra_spend;

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

/*----------- test --------------*/
#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}
'''
'''--- contract/nft/src/lib_old_old.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::core::{
    NonFungibleTokenCore, NonFungibleTokenResolver
};

//use near_contract_standards::non_fungible_token::approval::ext_nft_approval_receiver;

use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise,
    Balance, serde_json::json, assert_one_yocto, //Gas, ext_contract, PromiseOrValue,
};

use near_sdk::collections::{LazyOption, UnorderedMap, UnorderedSet};

/* custon codigo */
use near_sdk::json_types::{/*ValidAccountId,*/ U128, /*U64*/};

use serde::Serialize;
use serde::Deserialize;
use std::collections::HashMap;
use near_sdk::env::is_valid_account_id;
pub mod event;
pub use event::NearEvent;

pub const TOKEN_DELIMETER: char = ':';
pub const TITLE_DELIMETER: &str = " #";
pub const VAULT_FEE: u128 = 500;

//const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
//const GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(40_000_000_000_000); //GAS_FOR_NFT_TRANSFER_CALL(30_000_000_000_000) + GAS_FOR_RESOLVE_TRANSFER;
//const GAS_FOR_NFT_APPROVE: Gas = Gas(10_000_000_000_000);
//const GAS_FOR_MINT: Gas = Gas(90_000_000_000_000);
//const NO_DEPOSIT: Balance = 0;
const MAX_PRICE: Balance = 1_000_000_000 * 10u128.pow(24);

pub type TokenSeriesId = String;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

/* codigo customizado */

/*#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool;
}*/

#[derive(BorshDeserialize, BorshSerialize)]
pub struct TokenSeries {
    desc_series: String,
	metadata: TokenMetadata,
	creator_id: AccountId,
	tokens: UnorderedSet<TokenId>,
    price: Option<Balance>,
    is_mintable: bool,
    royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson {
    token_series_id: TokenSeriesId,
	metadata: TokenMetadata,
	creator_id: AccountId,
    royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson2 {
	token_series_id: TokenSeriesId,
    metadata: TokenMetadata,
	creator_id: AccountId,
    price: Option<Balance>,
    is_mintable: bool,
    royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokensView {
	owner_id: String,
    token_id: String
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ArtistObject {
	id: u128,
    name: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TypeTokenObject {
	id: u128,
    description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RestrictionsObject {
	id: String,
    token_id_s: u128,
    token_id_r: u128,
}

/* fin codigo costumizado */

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    /* codigo costumizado */
    owner_id: AccountId,
    list_admin: UnorderedSet<AccountId>,
    maestro_artist: UnorderedMap<u128, ArtistObject>,
    id_artist: u128,
    maestro_type_token: UnorderedMap<u128, TypeTokenObject>,
    id_type_token: u128,
    token_series_by_id: UnorderedMap<TokenSeriesId, TokenSeries>,
    restrictions: UnorderedMap<String, RestrictionsObject>,
    vault_id: AccountId,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    /*codigo costumizado*/
    AdminKey,
    ArtistKey,
    TypeTokenKey,
    RestrictionsKeys,
    TokenSeriesById,
    TokensBySeriesInner { token_series: String },
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, vault_id: AccountId,) -> Self {
        Self::new(
            owner_id,
            vault_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Music Feast".to_string(),
                symbol: "MusicFeast".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, vault_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id.clone(),
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            /* codigo costumizado */
            owner_id: owner_id,
            list_admin: UnorderedSet::new(StorageKey::AdminKey),
            maestro_artist: UnorderedMap::new(StorageKey::ArtistKey),
            id_artist: 0,
            maestro_type_token: UnorderedMap::new(StorageKey::TypeTokenKey),
            id_type_token: 0,
            token_series_by_id: UnorderedMap::new(StorageKey::TokenSeriesById),
            restrictions: UnorderedMap::new(StorageKey::RestrictionsKeys),
            vault_id: vault_id,
        }
    }

    /* codigo original */
    /*
    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens.mint(token_id, receiver_id, Some(token_metadata))
    }*/

    /* codigo custom */
    pub fn edit_vault(&mut self, account_id: AccountId){
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.vault_id = account_id;
    }

    // cargar usuarios a la lista de administradores
    // solo los administradores pueden usar esta funcion
    pub fn add_admin(&mut self, account_id: AccountId) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        self.list_admin.insert(&account_id.clone());

        env::log_str(
            &json!({
                "type": "add_admin",
                "params": {
                    "account_id": account_id.to_string()
                }
            })
            .to_string(),
        );

    }

    pub fn add_artist(&mut self, name: String) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let id_artist: u128 = self.id_artist + 1;

        let data_artist = ArtistObject {
            id: id_artist,
            name: name.clone(),
        };

        self.maestro_artist.insert(&data_artist.id, &data_artist);

        self.id_artist = id_artist;

        env::log_str(
            &json!({
                "type": "add_artist",
                "params": {
                    "id": id_artist.to_string(),
                    "name": name
                }
            })
            .to_string(),
        );
    }

    pub fn get_artist(self) -> Vec<ArtistObject> {
        self.maestro_artist.iter().map(|(_k, v)| { v }).collect()
    }

    pub fn add_type_token(&mut self, description: String) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        
        let id_type_token: u128 = self.id_type_token + 1;

        let data_type_token = TypeTokenObject {
            id: id_type_token,
            description: description.clone(),
        };

        self.maestro_type_token.insert(&data_type_token.id, &data_type_token);

        self.id_type_token = id_type_token;

        env::log_str(
            &json!({
                "type": "add_type_token",
                "params": {
                    "id": id_type_token.to_string(),
                    "description": description
                }
            })
            .to_string(),
        );
    }

    pub fn get_type_token(self) -> Vec<TypeTokenObject> {
        self.maestro_type_token.iter().map(|(_k, v)| {v}).collect()
    }

    pub fn add_restriction(&mut self, token_id_s: u128, token_id_r: u128) {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        assert!(self.maestro_type_token.get(&token_id_s).is_some(), "Token_id_s not exist");
        assert!(self.maestro_type_token.get(&token_id_r).is_some(), "Token_id_r not exist");
        assert!(self.restrictions.get(&token_id_s.to_string()).is_none(), "The requested token already has a constraint.");

        let data_restriction = RestrictionsObject {
            id: token_id_s.to_string(),
            token_id_s: token_id_s,
            token_id_r: token_id_r,
        };

        self.restrictions.insert(&data_restriction.id, &data_restriction);

        env::log_str(
            &json!({
                "type": "add_restriction",
                "params": {
                    "token_id_s": token_id_s.to_string(),
                    "token_id_r": token_id_r.to_string()
                }
            })
            .to_string(),
        );
    }

    pub fn get_restriction(self) -> Vec<RestrictionsObject> {
        self.restrictions.iter().map(|(_k, v)| {v}).collect()
    }

    #[payable]
    pub fn nft_series(
        &mut self,
        artist_id: u128,
        token_id: u128,
        token_metadata: TokenMetadata,
        price: Option<U128>,
        royalty: Option<HashMap<AccountId, u32>>,
    ) -> TokenSeriesJson {
        assert!(self.owner_id == env::signer_account_id() || self.list_admin.contains(&env::signer_account_id()), "Only administrator");
        assert!(self.maestro_artist.get(&artist_id).is_some(), "Artist_id not exist");
        
        let type_token = self.maestro_type_token.get(&token_id).expect("Token_id not exist");
        //assert!(self.maestro_type_token.get(&token_id).is_some(), "Token_id not exist");

        let initial_storage_usage = env::storage_usage();
        let caller_id = env::signer_account_id();

        let mut token_series_id = format!("{}|{}", artist_id, token_id);
        if token_id > 6 {
            token_series_id = format!("{}|{}|{}", artist_id, token_id, self.token_series_by_id.len());
        }

        assert!(
            self.token_series_by_id.get(&token_series_id).is_none(),
            "duplicate token_series_id"
        );

        let title = token_metadata.title.clone();
        assert!(title.is_some(), "token_metadata.title is required");
        

        let mut total_perpetual = 0;
        let mut total_accounts = 0;
        let royalty_res: HashMap<AccountId, u32> = if let Some(royalty) = royalty {
            for (k , v) in royalty.iter() {
                if !is_valid_account_id(k.as_bytes()) {
                    env::panic_str("Not valid account_id for royalty");
                };
                total_perpetual += *v;
                total_accounts += 1;
            }
            royalty
        } else {
            HashMap::new()
        };

        assert!(total_accounts <= 10, "royalty exceeds 10 accounts");

        assert!(
            total_perpetual <= 9000,
            "Exceeds maximum royalty -> 9000",
        );

        let price_res: Option<u128> = if price.is_some() {
            assert!(
                price.unwrap().0 < MAX_PRICE,
                "price higher than {}",
                MAX_PRICE
            );
            Some(price.unwrap().0)
        } else {
            None
        };

        self.token_series_by_id.insert(&token_series_id, &TokenSeries{
            desc_series: type_token.description.clone(),
            metadata: token_metadata.clone(),
            creator_id: caller_id.clone(),
            tokens: UnorderedSet::new(
                StorageKey::TokensBySeriesInner {
                    token_series: token_series_id.clone(),
                }
                .try_to_vec()
                .unwrap(),
            ),
            price: price_res,
            is_mintable: true,
            royalty: royalty_res.clone(),
        });

        env::log_str(
            &json!({
                "type": "nft_create_series",
                "params": {
                    "token_series_id": token_series_id.to_string(),
                    "desc_series": type_token.description.to_string(),
                    "token_metadata": token_metadata,
                    "creator_id": caller_id.to_string(),
                    "price": price,
                    "royalty": royalty_res
                }
            })
            .to_string(),
        );

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

		TokenSeriesJson{
            token_series_id,
			metadata: token_metadata,
			creator_id: caller_id.into(),
            royalty: royalty_res,
		}
    }
    

    #[payable]
    pub fn nft_buy(
        &mut self, 
        token_series_id: TokenSeriesId
    ) -> TokenId {
        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        let price: u128 = token_series.price.expect("not for sale");
        let attached_deposit = env::attached_deposit();
        assert!(
            attached_deposit >= price,
            "attached deposit is less than price : {}",
            price
        );
        let receiver_id: AccountId = env::signer_account_id();
        /*
        id: String,
        token_id_s: u128,
        token_id_r: u128,
        */
        let restriction = self.restrictions.get(&token_series.metadata.reference.unwrap().to_string());
        if restriction.is_some() {
            let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().expect(
                "Could not find tokens_per_owner when calling a method on the enumeration standard.",
            );
            let token_set = tokens_per_owner.get(&receiver_id).expect("You do not have the corresponding token to buy the requested token");
            let token_id_r: String = restriction.unwrap().token_id_r.to_string();
            let artist_id = token_series_id.split("|").next().unwrap().to_string();
            let valit_token_owner = token_set
                .iter()
                .find(|token_id| token_id.split(":").next().unwrap().to_string() == format!("{}|{}",artist_id, token_id_r).to_string());
            assert!(valit_token_owner != None
                , "You do not have the corresponding token to buy the requested token");
        }

        let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.clone());

        let for_vault = price as u128 * VAULT_FEE / 10_000u128;
        let price_deducted = price - for_vault;
        Promise::new(token_series.creator_id).transfer(price_deducted);
        Promise::new(self.vault_id.clone()).transfer(for_vault);

        token_id
    }

    #[payable]
    pub fn nft_mint(
        &mut self, 
        token_series_id: TokenSeriesId, 
        receiver_id: AccountId
    ) -> TokenId {
        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        assert_eq!(env::predecessor_account_id(), token_series.creator_id.clone(), "not creator");
        let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.clone());

        /*NearEvent::log_nft_mint(
            receiver_id.to_string(),
            vec![token_id.clone()],
            None,
        );*/

        token_id
    }

    
    
    /*#[payable]
    pub fn nft_mint_and_approve(
        &mut self, 
        token_series_id: TokenSeriesId, 
        account_id: AccountId,
        msg: Option<String>,
    ) -> Option<Promise> {
        let initial_storage_usage = env::storage_usage();

        let token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        assert_eq!(env::predecessor_account_id(), token_series.creator_id.clone(), "not creator");
        let token_id: TokenId = self._nft_mint_series(token_series_id, token_series.creator_id.clone());

        let approvals_by_id = self.tokens.approvals_by_id.as_mut().unwrap();

        let approved_account_ids =
            &mut approvals_by_id.get(&token_id).unwrap_or_else(|| HashMap::new());
        let account_id: AccountId = account_id.into();
        let approval_id: u64 =
            self.tokens.next_approval_id_by_id.as_ref().unwrap().get(&token_id).unwrap_or_else(|| 1u64);
        approved_account_ids.insert(account_id.clone(), approval_id);

        approvals_by_id.insert(&token_id, &approved_account_ids);

        self.tokens.next_approval_id_by_id.as_mut().unwrap().insert(&token_id, &(approval_id + 1));

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        NearEvent::log_nft_mint(
            token_series.creator_id.to_string(),
            vec![token_id.clone()],
            None,
        );

        if let Some(msg) = msg {
            Some(ext_nft_approval_receiver::ext(account_id)
            .with_static_gas(env::prepaid_gas() - GAS_FOR_NFT_APPROVE - GAS_FOR_MINT)
            .nft_on_approve(token_id, token_series.creator_id, approval_id, msg))
            
            /*Some(ext_approval_receiver::nft_on_approve(
                token_id,
                token_series.creator_id,
                approval_id,
                msg,
                &account_id,
                NO_DEPOSIT,
                env::prepaid_gas() - GAS_FOR_NFT_APPROVE - GAS_FOR_MINT,
            ))*/
        } else {
            None
        }
    }*/

    #[payable]
    pub fn put_nft_series_price(&mut self, token_series_id: TokenSeriesId, price: Option<U128>) -> Option<U128> {
        assert_one_yocto();

        let mut token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
        assert_eq!(
            env::predecessor_account_id(),
            token_series.creator_id,
            "Creator only"
        );

        assert_eq!(
            token_series.is_mintable,
            true,
            "Token series is not mintable"
        );

        if price.is_none() {
            token_series.price = None;
        } else {
            assert!(
                price.unwrap().0 < MAX_PRICE,
                "Price higher than {}",
                MAX_PRICE
            );
            token_series.price = Some(price.unwrap().0);
        }

        self.token_series_by_id.insert(&token_series_id, &token_series);

        return price;
    }

    fn _nft_mint_series(
        &mut self, 
        token_series_id: TokenSeriesId, 
        receiver_id: AccountId
    ) -> TokenId {
        let mut token_series = self.token_series_by_id.get(&token_series_id).expect("Token series not exist");
    
        assert!(
            token_series.is_mintable,
            "Token series is not mintable"
        );

        let num_tokens = token_series.tokens.len();
        let max_copies = token_series.metadata.copies.unwrap_or(u64::MAX);
        
        assert!(num_tokens < max_copies, "Series supply maxed");

        if (num_tokens + 1) >= max_copies {
            token_series.is_mintable = false;
            token_series.price = None;
        }
        
        let token_id = format!("{}{}{}", &token_series_id, TOKEN_DELIMETER, num_tokens + 1);
        token_series.tokens.insert(&token_id);
        self.token_series_by_id.insert(&token_series_id, &token_series);
        let title: String = format!("{} {} {}", token_series.metadata.title.unwrap().clone(), TITLE_DELIMETER, (num_tokens + 1).to_string());
        
        let token_metadata = Some(TokenMetadata {
            title: Some(title),          
            description: token_series.metadata.description.clone(),   
            media: token_series.metadata.media.clone(),
            media_hash: token_series.metadata.media_hash, 
            copies: token_series.metadata.copies, 
            issued_at: Some(env::block_timestamp().to_string()), 
            expires_at: token_series.metadata.expires_at, 
            starts_at: token_series.metadata.starts_at, 
            updated_at: token_series.metadata.updated_at, 
            extra: token_series.metadata.extra.clone(), 
            reference: token_series.metadata.reference.clone(),
            reference_hash: token_series.metadata.reference_hash, 
        });

        let token_owner_id: AccountId = receiver_id;
      
        self.tokens.internal_mint(token_id.clone(), token_owner_id, token_metadata);

        token_id
    }

    #[payable]
    pub fn nft_burn(&mut self, token_id: TokenId) {
        assert_one_yocto();
        
        let owner_id = self.tokens.owner_by_id.get(&token_id).unwrap();
        
        assert_eq!(
            owner_id,
            env::predecessor_account_id(),
            "Token owner only"
        );

        if let Some(next_approval_id_by_id) = &mut self.tokens.next_approval_id_by_id {
            next_approval_id_by_id.remove(&token_id);
        }

        if let Some(approvals_by_id) = &mut self.tokens.approvals_by_id {
            approvals_by_id.remove(&token_id);
        }

        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap();
            token_ids.remove(&token_id);
            tokens_per_owner.insert(&owner_id, &token_ids);
        }

        if let Some(token_metadata_by_id) = &mut self.tokens.token_metadata_by_id {
            token_metadata_by_id.remove(&token_id);
        }

        self.tokens.owner_by_id.remove(&token_id);

        NearEvent::log_nft_burn(
            owner_id.to_string(),
            vec![token_id],
            None,
            None,
        );
    }

    pub fn get_nft_series_copies_availables(&self, token_series_id: TokenSeriesId) -> u64 {
		let token_series = self.token_series_by_id.get(&token_series_id).expect("Series does not exist");
        let copies_availables = token_series.metadata.copies.unwrap() - token_series.tokens.len() as u64 ;
        copies_availables    
	}

    pub fn get_nft_series_single(&self, token_series_id: TokenSeriesId) -> TokenSeriesJson {
		let token_series = self.token_series_by_id.get(&token_series_id).expect("Series does not exist");
		TokenSeriesJson{
            token_series_id,
			metadata: token_series.metadata,
			creator_id: token_series.creator_id,
            royalty: token_series.royalty,
		}
	}

    pub fn get_nft_series_list(
        &self,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<TokenSeriesJson2> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.token_series_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");

        self.token_series_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_series_id, token_series)| TokenSeriesJson2 {
                token_series_id: token_series_id.clone(),
                metadata: token_series.metadata,
                creator_id: token_series.creator_id,
                price: token_series.price,
                is_mintable: token_series.is_mintable,
                royalty: token_series.royalty
            })
            .collect()
    }

    pub fn get_nft_series(
        &self,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<TokenSeriesJson> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.token_series_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");

        self.token_series_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_series_id, token_series)| TokenSeriesJson{
                token_series_id,
                metadata: token_series.metadata,
                creator_id: token_series.creator_id,
                royalty: token_series.royalty,
            })
            .collect()
    }

    pub fn get_nft_series_copy(
        &self,
        token_series_id: TokenSeriesId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Token> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        let tokens = self.token_series_by_id.get(&token_series_id).unwrap().tokens;
        assert!(
            (tokens.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");

        tokens
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|token_id| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_token(&self, token_id: TokenId) -> Option<Token> {
        let owner_id = self.tokens.owner_by_id.get(&token_id)?;
        let approved_account_ids = self
            .tokens
            .approvals_by_id
            .as_ref()
            .and_then(|by_id| by_id.get(&token_id).or_else(|| Some(HashMap::new())));

        /*let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let series_metadata = self.token_series_by_id.get(&token_series_id).unwrap().metadata;*/

        let token_metadata = self.tokens.token_metadata_by_id.as_ref().unwrap().get(&token_id).unwrap();

        /*token_metadata.title = Some(format!(
            "{}{}{}",
            series_metadata.title.unwrap(),
            TITLE_DELIMETER,
            token_id_iter.next().unwrap()
        ));

        token_metadata.reference = series_metadata.reference;
        token_metadata.media = series_metadata.media;
        token_metadata.copies = series_metadata.copies;*/

        Some(Token {
            token_id,
            owner_id,
            metadata: Some(token_metadata),
            approved_account_ids,
        })
    }

    pub fn nft_transfer_unsafe(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        let sender_id = env::predecessor_account_id();
        let (previous_owner_id, _) = self.tokens.internal_transfer(&sender_id, &receiver_id, &token_id, approval_id, memo.clone());

        let authorized_id : Option<String> = if sender_id != previous_owner_id {
            Some(sender_id.to_string())
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id.to_string(),
            receiver_id.to_string(),
            vec![token_id],
            memo,
            authorized_id,
        );
    }

    #[payable]
    pub fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        //let sender_id = env::predecessor_account_id();
        //let previous_owner_id = self.tokens.owner_by_id.get(&token_id).expect("Token not found");
        self.tokens.nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, memo.clone());

        /*let authorized_id : Option<String> = if sender_id != previous_owner_id {
            Some(sender_id.to_string())
        } else {
             None
        };*/

        /*NearEvent::log_nft_transfer(
            previous_owner_id.to_string(),
            receiver_id.to_string(),
            vec![token_id],
            memo,
            authorized_id,
        );*/
    }

    /*#[payable]
    pub fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let (previous_owner_id, old_approvals) = self.tokens.internal_transfer(
            &sender_id,
            &receiver_id.clone(),
            &token_id,
            approval_id,
            memo.clone(),
        );

        let authorized_id : Option<String> = if sender_id != previous_owner_id {
            Some(sender_id.to_string())
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id.to_string(),
            receiver_id.to_string(),
            vec![token_id.clone()],
            memo,
            authorized_id,
        );

        // Initiating receiver's call and the callback
        ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id,
            previous_owner_id.clone(),
            token_id.clone(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL,
        )
        .then(ext_self::nft_resolve_transfer(
            previous_owner_id,
            receiver_id.into(),
            token_id,
            old_approvals,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
        .into()

    }*/

    // CUSTOM enumeration standard modified here because no macro below

    pub fn nft_total_supply(&self) -> U128 {
        (self.tokens.owner_by_id.len() as u128).into()
    }

    pub fn nft_tokens2(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<TokensView> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.tokens.owner_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        self.tokens
            .owner_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_id, _)| TokensView { owner_id: self.tokens.owner_by_id.get(&token_id).unwrap().to_string(), token_id: token_id})
            .collect()
    }

    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.tokens.owner_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        self.tokens
            .owner_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_id, _)| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_supply_for_owner(self, account_id: AccountId) -> U128 {
        let tokens_per_owner = self.tokens.tokens_per_owner.expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        tokens_per_owner
            .get(&account_id)
            .map(|account_tokens| U128::from(account_tokens.len() as u128))
            .unwrap_or(U128(0))
    }

    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Token> {
        let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        let token_set = if let Some(token_set) = tokens_per_owner.get(&account_id) {
            token_set
        } else {
            return vec![];
        };
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            token_set.len() as u128 > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        token_set
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|token_id| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_payout(
        &self, 
        token_id: TokenId,
        balance: U128, 
        max_len_payout: u32
    ) -> Payout{
        let owner_id = self.tokens.owner_by_id.get(&token_id).expect("No token id");
        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let royalty = self.token_series_by_id.get(&token_series_id).expect("no type").royalty;

        assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

        let balance_u128: u128 = balance.into();

        let mut payout: Payout = Payout { payout: HashMap::new() };
        let mut total_perpetual = 0;

        for (k, v) in royalty.iter() {
            if *k != owner_id {
                let key = k.clone();
                payout.payout.insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }
        payout.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));
        payout
    }

    #[payable]
    pub fn nft_transfer_payout(
        &mut self, 
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        balance: Option<U128>,
        max_len_payout: Option<u32>
    ) -> Option<Payout> {
        assert_one_yocto();

        //let sender_id = env::predecessor_account_id();
        // Transfer
        let previous_token = self.nft_token(token_id.clone()).expect("no token");
        self.tokens.nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, None);

        // Payout calculation
        let previous_owner_id = previous_token.owner_id;
        let mut total_perpetual = 0;
        let payout = if let Some(balance) = balance {
            let balance_u128: u128 = u128::from(balance);
            let mut payout: Payout = Payout { payout: HashMap::new() };

            let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
            let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
            let royalty = self.token_series_by_id.get(&token_series_id).expect("no type").royalty;

            assert!(royalty.len() as u32 <= max_len_payout.unwrap(), "Market cannot payout to that many receivers");
            for (k, v) in royalty.iter() {
                let key = k.clone();
                if key != previous_owner_id {
                    payout.payout.insert(key, royalty_to_payout(*v, balance_u128));
                    total_perpetual += *v;
                }
            }

            assert!(
                total_perpetual <= 10000,
                "Total payout overflow"
            );

            payout.payout.insert(previous_owner_id.clone(), royalty_to_payout(10000 - total_perpetual, balance_u128));
            Some(payout)
        } else {
            None
        };

        /*let authorized_id : Option<String> = if sender_id != previous_owner_id {
            Some(sender_id.to_string())
        } else {
            None
        };*/

        /*NearEvent::log_nft_transfer(
            previous_owner_id.to_string(),
            receiver_id.to_string(),
            vec![token_id],
            None,
            authorized_id,
        );*/

        payout
    }

}

/* codigo original */
//near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
//near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
//near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

/*#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}*/

/* codigo costumizado */
fn royalty_to_payout(a: u32, b: Balance) -> U128 {
    U128(a as u128 * b / 10_000u128)
}

near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool {
        let resp: bool = self.tokens.nft_resolve_transfer(
            previous_owner_id.clone(),
            receiver_id.clone(),
            token_id.clone(),
            approved_account_ids,
        );

        // if not successful, return nft back to original owner
        if !resp {
            NearEvent::log_nft_transfer(
                receiver_id.to_string(),
                previous_owner_id.to_string(),
                vec![token_id],
                None,
                None,
            );
        }

        resp
    }
}

fn refund_deposit(storage_used: u64, extra_spend: Balance) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit() - extra_spend;

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

/*----------- test --------------*/
#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}
'''
'''--- contract/nft/target/.rustc_info.json ---
{"rustc_fingerprint":9842691794970414368,"outputs":{"931469667778813386":{"success":true,"status":"","code":0,"stdout":"___.exe\nlib___.rlib\n___.dll\n___.dll\n___.lib\n___.dll\nC:\\Users\\hrpal\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\ndebug_assertions\nproc_macro\ntarget_arch=\"x86_64\"\ntarget_endian=\"little\"\ntarget_env=\"msvc\"\ntarget_family=\"windows\"\ntarget_feature=\"fxsr\"\ntarget_feature=\"sse\"\ntarget_feature=\"sse2\"\ntarget_os=\"windows\"\ntarget_pointer_width=\"64\"\ntarget_vendor=\"pc\"\nwindows\n","stderr":""},"17598535894874457435":{"success":true,"status":"","code":0,"stdout":"rustc 1.56.1 (59eed8a2a 2021-11-01)\nbinary: rustc\ncommit-hash: 59eed8a2aac0230a8b53e89d4e99d55912ba6b35\ncommit-date: 2021-11-01\nhost: x86_64-pc-windows-msvc\nrelease: 1.56.1\nLLVM version: 13.0.0\n","stderr":""},"2797684049618456168":{"success":false,"status":"exit code: 1","code":1,"stdout":"","stderr":"error: `-Csplit-debuginfo` is unstable on this platform\n\n"},"15537503139010883884":{"success":true,"status":"","code":0,"stdout":"___.exe\nlib___.rlib\n___.dll\n___.dll\n___.lib\n___.dll\n","stderr":""}},"successes":{}}
'''
'''--- contract/nft/target/wasm32-unknown-unknown/release/.fingerprint/music-feast-contract-0065fb8a7553cef3/lib-music-feast-contract.json ---
{"rustc":3257411903276762393,"features":"[]","target":558941652187687008,"profile":6478233966517336952,"path":17523903030608720598,"deps":[[1191923786548143631,"serde_json",false,1579036848472708942],[3777752360430475968,"near_contract_standards",false,4947362653124026068],[8895610504322883917,"serde",false,5645319548793828294],[14706394349651137205,"near_sdk",false,17754819597059592722],[18358990072766425742,"serde_with",false,6571139206104926364]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/music-feast-contract-0065fb8a7553cef3/dep-lib-music-feast-contract"}}],"rustflags":[],"metadata":14894896775255343796,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- django/backend/__init__.py ---

'''
'''--- django/backend/admin.py ---
from django.contrib import admin
from .models import *

# Register your models here.

admin.site.register(Carousel)
admin.site.register(Artist)
admin.site.register(Home)
admin.site.register(News)
'''
'''--- django/backend/apps.py ---
from django.apps import AppConfig

class BackendConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'backend'

'''
'''--- django/backend/migrations/0001_initial.py ---
# Generated by Django 4.0.4 on 2022-10-05 14:49

from django.db import migrations, models

class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Carousel',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('image', models.ImageField(blank=True, null=True, upload_to='')),
            ],
        ),
    ]

'''
'''--- django/backend/migrations/0002_alter_carousel_image.py ---
# Generated by Django 4.0.4 on 2022-10-05 14:56

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('backend', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='carousel',
            name='image',
            field=models.ImageField(blank=True, null=True, upload_to='images'),
        ),
    ]

'''
'''--- django/backend/migrations/0003_alter_carousel_image.py ---
# Generated by Django 4.0.4 on 2022-10-05 15:07

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('backend', '0002_alter_carousel_image'),
    ]

    operations = [
        migrations.AlterField(
            model_name='carousel',
            name='image',
            field=models.ImageField(blank=True, null=True, upload_to=''),
        ),
    ]

'''
'''--- django/backend/migrations/0004_artist.py ---
# Generated by Django 4.0.4 on 2022-10-05 17:36

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('backend', '0003_alter_carousel_image'),
    ]

    operations = [
        migrations.CreateModel(
            name='Artist',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(default='', max_length=255)),
                ('description', models.CharField(default='', max_length=255)),
                ('image', models.ImageField(blank=True, null=True, upload_to='')),
                ('is_home', models.BooleanField(default=False)),
                ('is_visible', models.BooleanField(default=False)),
                ('comming', models.BooleanField(default=False)),
            ],
        ),
    ]

'''
'''--- django/backend/migrations/0005_news_remove_artist_is_home_artist_about_and_more.py ---
# Generated by Django 4.0.4 on 2022-10-05 20:08

from django.db import migrations, models
import django.db.models.deletion

class Migration(migrations.Migration):

    dependencies = [
        ('backend', '0004_artist'),
    ]

    operations = [
        migrations.CreateModel(
            name='News',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(default='', max_length=255)),
                ('title2', models.CharField(default='', max_length=255)),
                ('description', models.CharField(default='', max_length=255)),
                ('desc_long', models.CharField(default='', max_length=255)),
                ('is_visible', models.BooleanField(default=False)),
            ],
        ),
        migrations.RemoveField(
            model_name='artist',
            name='is_home',
        ),
        migrations.AddField(
            model_name='artist',
            name='about',
            field=models.CharField(default='', max_length=255),
        ),
        migrations.AddField(
            model_name='artist',
            name='discord',
            field=models.CharField(default='', max_length=255),
        ),
        migrations.AddField(
            model_name='artist',
            name='facebook',
            field=models.CharField(default='', max_length=255),
        ),
        migrations.AddField(
            model_name='artist',
            name='instagram',
            field=models.CharField(default='', max_length=255),
        ),
        migrations.AddField(
            model_name='artist',
            name='twitter',
            field=models.CharField(default='', max_length=255),
        ),
        migrations.AddField(
            model_name='carousel',
            name='is_visible',
            field=models.BooleanField(default=False),
        ),
        migrations.CreateModel(
            name='Home',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('artist', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='backend.artist')),
            ],
        ),
    ]

'''
'''--- django/backend/migrations/0006_alter_artist_discord_alter_artist_facebook_and_more.py ---
# Generated by Django 4.0.4 on 2022-10-05 20:25

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('backend', '0005_news_remove_artist_is_home_artist_about_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='artist',
            name='discord',
            field=models.CharField(blank=True, max_length=255, null=True),
        ),
        migrations.AlterField(
            model_name='artist',
            name='facebook',
            field=models.CharField(blank=True, max_length=255, null=True),
        ),
        migrations.AlterField(
            model_name='artist',
            name='instagram',
            field=models.CharField(blank=True, max_length=255, null=True),
        ),
        migrations.AlterField(
            model_name='artist',
            name='twitter',
            field=models.CharField(blank=True, max_length=255, null=True),
        ),
    ]

'''
'''--- django/backend/migrations/__init__.py ---

'''
'''--- django/backend/models.py ---
from email.mime import image
from email.policy import default
from django.db import models

# Create your models here.

class Carousel(models.Model):
    image=models.ImageField(null=True, blank=True)
    is_visible=models.BooleanField(default=False)

class Artist(models.Model):
    name=models.CharField(max_length=255,null=False,blank=False, default="")
    description=models.CharField(max_length=255,null=False,blank=False, default="")
    about=models.CharField(max_length=255,null=False,blank=False, default="")
    image=models.ImageField(null=True, blank=True)
    is_visible=models.BooleanField(default=False)
    comming=models.BooleanField(default=False)
    instagram=models.CharField(max_length=255,null=True,blank=True)
    twitter=models.CharField(max_length=255,null=True,blank=True)
    facebook=models.CharField(max_length=255,null=True,blank=True)
    discord=models.CharField(max_length=255,null=True,blank=True)

class Home(models.Model):
    artist=models.OneToOneField(Artist,on_delete=models.CASCADE)

class News(models.Model):
    title=models.CharField(max_length=255,null=False,blank=False, default="")
    title2=models.CharField(max_length=255,null=False,blank=False, default="")
    description=models.CharField(max_length=255,null=False,blank=False, default="")
    desc_long=models.CharField(max_length=255,null=False,blank=False, default="")
    is_visible=models.BooleanField(default=False)
'''
'''--- django/backend/serializers.py ---
from rest_framework import serializers
from .models import *
from django.contrib.auth.models import User

class CarouselSerializer(serializers.ModelSerializer):
    class Meta:
        model = Carousel
        fields = '__all__'  

class ArtistSerializer(serializers.ModelSerializer):
    class Meta:
        model = Artist
        fields = '__all__'  

class HomeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Home
        fields = '__all__'  

class NewsSerializer(serializers.ModelSerializer):
    class Meta:
        model = News
        fields = '__all__'  
'''
'''--- django/backend/tests.py ---
from django.test import TestCase

# Create your tests here.

'''
'''--- django/backend/urls.py ---
from django.urls import path, include
from rest_framework import routers

from django.urls import path, include
from rest_framework import routers
from .views import *

router = routers.DefaultRouter()
router.register(r'carousel', CarouselVS,basename='carousel')
router.register(r'artist', ArtistVS,basename='artist')
router.register(r'home', HomeVS,basename='home')
router.register(r'news', NewsVS,basename='news')

urlpatterns = [
    path('', include(router.urls)),
    path('get-carousel', get_carousel),
    path('get-artists', get_artists),
    path('get-artists-home', get_artists_home),
    path('get-news', get_news)
]
'''
'''--- django/backend/views.py ---
from copyreg import constructor
from re import search
from rest_framework.authtoken.serializers import AuthTokenSerializer
from rest_framework.authentication import SessionAuthentication,BasicAuthentication,TokenAuthentication
from crypt import crypt
from .serializers import *
from .models import *
from django.contrib.auth import login
import requests
from django_filters import rest_framework as filters
from rest_framework.permissions import IsAdminUser,IsAuthenticated,AllowAny
from rest_framework.response import Response
from rest_framework.authtoken.models import Token
from django.contrib.auth.models import User
from rest_framework import viewsets,status
from rest_framework.decorators import api_view,permission_classes,authentication_classes
from django.views.decorators.csrf import csrf_exempt

# Create your views here.

class CarouselVS(viewsets.ModelViewSet):
    permission_classes=[IsAuthenticated]
    authentication_classes=[TokenAuthentication]
    queryset = Carousel.objects.all()
    serializer_class = CarouselSerializer

@api_view(["GET"])
@csrf_exempt
@authentication_classes([BasicAuthentication])
@permission_classes([AllowAny])
def get_carousel(request):
    carousel = Carousel.objects.filter(is_visible=True)
    serializer = CarouselSerializer(carousel, many=True)
    return Response(serializer.data,status=status.HTTP_200_OK)

class ArtistVS(viewsets.ModelViewSet):
    permission_classes=[IsAuthenticated]
    authentication_classes=[TokenAuthentication]
    queryset = Artist.objects.all()
    serializer_class = ArtistSerializer

@api_view(["GET"])
@csrf_exempt
@authentication_classes([BasicAuthentication])
@permission_classes([AllowAny])
def get_artists(request):
    artists = Artist.objects.filter(is_visible=True)
    serializer = ArtistSerializer(artists, many=True)
    return Response(serializer.data,status=status.HTTP_200_OK)

class HomeVS(viewsets.ModelViewSet):
    permission_classes=[IsAuthenticated]
    authentication_classes=[TokenAuthentication]
    queryset = Home.objects.all()
    serializer_class = HomeSerializer

@api_view(["GET"])
@csrf_exempt
@authentication_classes([BasicAuthentication])
@permission_classes([AllowAny])
def get_artists_home(request):
    home = Home.objects.all()
    artists = HomeSerializer(home, many=True).data
    data = []
    for artist in artists:
        item = Artist.objects.get(id=artist['id'])
        if item.is_visible:
            serializer = ArtistSerializer(item).data
            data.append(serializer)
    return Response(data,status=status.HTTP_200_OK)

class NewsVS(viewsets.ModelViewSet):
    permission_classes=[IsAuthenticated]
    authentication_classes=[TokenAuthentication]
    queryset = News.objects.all()
    serializer_class = NewsSerializer

@api_view(["GET"])
@csrf_exempt
@authentication_classes([BasicAuthentication])
@permission_classes([AllowAny])
def get_news(request):
    news = News.objects.filter(is_visible=True)
    serializer = NewsSerializer(news, many=True)
    return Response(serializer.data,status=status.HTTP_200_OK)
'''
'''--- django/manage.py ---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys

def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'musicfeast.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()

'''
'''--- django/musicfeast/__init__.py ---

'''
'''--- django/musicfeast/asgi.py ---
"""
ASGI config for musicfeast project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'musicfeast.settings')

application = get_asgi_application()

'''
'''--- django/musicfeast/settings.py ---
"""
Django settings for musicfeast project.

Generated by 'django-admin startproject' using Django 3.0.10.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.0/ref/settings/
"""
from decouple import config
import os

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
#SECRET_KEY = '7m37yh%z8e!)60%nx!cma))ldm(6rq0)1b=4k$nqcq%bbl47@j'
SECRET_KEY = config("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'backend',
    'rest_framework',
    'rest_framework.authtoken',
    'corsheaders',
    'django_filters',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.BasicAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ]
}

ROOT_URLCONF = 'musicfeast.urls'

CORS_ALLOW_ALL_ORIGINS=True
CORS_ALLOW_CREDENTIALS=True

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'musicfeast.wsgi.application'

# Database
# https://docs.djangoproject.com/en/3.0/ref/settings/#databases

# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.sqlite3',
#         'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
#     }
# }

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': config("DB_NAME"), 
        'USER': config("DB_USER"), 
        'PASSWORD': config("DB_PASSWORD"),
        'HOST': config("DB_HOST"), 
        'PORT': config("DB_PORT"),
    }
}

# Password validation
# https://docs.djangoproject.com/en/3.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/3.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.0/howto/static-files/
STATIC_URL = '/static/'
STATIC_ROOT = 'static/'
ROOT_URLCONF
# STATIC_URL = '/static_musicfeast/'
# STATIC_ROOT ='static'
# MEDIA_URL = 'media_musicfeast/'
# MEDIA_ROOT = '/musicfeast/static'

'''
'''--- django/musicfeast/urls.py ---
"""musicfeast URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.conf import settings
from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/v1/', include('backend.urls')),
] #+ static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
'''
'''--- django/musicfeast/wsgi.py ---
"""
WSGI config for musicfeast project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'musicfeast.settings')

application = get_wsgi_application()

'''
'''--- django/requirements.txt ---
asgiref==3.4.1
Brotli==1.0.9
certifi==2021.10.8
cffi==1.15.0
charset-normalizer==2.0.12
cryptography==35.0.0
cssselect2==0.5.0
cycler==0.11.0
dj-rest-auth==2.1.11
Django==4.0.4
django-colorfield==0.4.1
django-cors-headers==3.8.0
django-extensions==3.1.5
django-filter==21.1
django-js-asset==1.2.2
django-mptt==0.13.4
django-renderpdf==3.0.1
django-rest-passwordreset==1.2.1
django-simple-history==3.0.0
djangorestframework==3.12.4
djangorestframework-jwt==1.11.0
fonttools==4.29.1
graphviz==0.19.1
greenlet==1.1.2
html5lib==1.1
idna==3.3
kiwisolver==1.4.1
Markdown==3.3.4
matplotlib==3.5.1
numpy==1.23.0
packaging==21.3
pandas==1.4.3
Pillow==8.2.0
# psycopg2==2.9.3
# psycopg2-binary==2.9.3
pycparser==2.21
pydot==1.4.2
pydyf==0.1.2
PyJWT==1.7.1
pyparsing==2.4.7
pyphen==0.12.0
python-dateutil==2.8.2
pytz==2021.1
requests==2.27.1
six==1.16.0
SQLAlchemy==1.4.39
sqlparse==0.4.2
tablib==3.2.0
tinycss2==1.1.1
typing-extensions==3.10.0.2
urllib3==1.26.9
weasyprint==54.2
webencodings==0.5.1
zopfli==0.2.1
sqlalchemy
python-decouple

'''