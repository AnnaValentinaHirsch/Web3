*GitHub Repository "howmarketing/ref-finance-v1"*

'''--- .env ---
NEAR_ENV_TEST=OK
NEAR_ENV=testnet

X_REF_FI_CONTRACT_ID="exchange.ref-dev.testnet"
Y_REF_FI_CONTRACT_ID="v2.ref-finance.near"

X_WRAP_NEAR_CONTRACT_ID="wrap.testnet"
Y_WRAP_NEAR_CONTRACT_ID="wrap.near"

X_Y_REF_ADBOARD_CONTRACT_ID="ref-adboard.near"

X_REF_FARM_CONTRACT_ID="farm110.ref-dev.testnet"
Y_REF_FARM_CONTRACT_ID="v2.ref-farming.near"

X_REF_TOKEN_ID="token.ref-finance.testnet"
Y_REF_TOKEN_ID="token.ref-finance.near"

X_REF_AIRDROP_CONTRACT_ID="locker002.ref-dev.testnet"
Y_REF_AIRDROP_CONTRACT_ID="s01.ref-airdrop.near"

X_Y_POOL_TOKEN_REFRESH_INTERVAL=10

'''
'''--- .postcssrc.json ---
{
  "plugins": {
    "tailwindcss": {}
  }
}

'''
'''--- README.md ---
# ref-ui

This is the front-end for [ref.finance](https://app.ref.finance).

## Quick Start

To run this project locally:

1. Prerequisites: Make sure you've installed [Node.js] ≥ 12
2. Install dependencies: `yarn`
3. Run the local development server connected to `testnet`: `yarn start` (see `package.json` for a full list of `scripts` you can run with `yarn`)

## Architecture

This project consists of three layers:

1. `services` is where communication (via the NEAR RPC API) to smart contracts happen.
2. `state` is where the services are used and connected to react state management
3. `components` and `pages` is where the view is created

## Tests

Tests use [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) and can be run with `yarn test`.

## Code Formatting

This project uses [Prettier](https://prettier.io/) to create consistently styled code.
Prettier can be installed to auto-format on save for most editors. You can also run
`yarn prettier` to check for styling errors and `yarn prettier:fix` to fix styling errors.

'''
'''--- jest.config.js ---
module.exports = {
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
    '^.+\\.jsx?$': 'babel-jest',
  },
  setupFilesAfterEnv: ['./src/setupTests.js'],
};

'''
'''--- netlify.toml ---
[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
  force = false

[[redirects]]
  from = "/pools/*"
  to = "/index.html"
  status = 200
  force = false

[[redirects]]
  from = "/whitelist/*"
  to = "/index.html"
  status = 200
  force = false
'''
'''--- package.json ---
{
  "name": "ref-ui",
  "version": "1.0.0",
  "license": "MIT OR Apache-2.0",
  "scripts": {
    "build": "parcel build src/index.html",
    "start": "parcel src/index.html",
    "start:mainnet": "NEAR_ENV=mainnet parcel src/index.html",
    "start:testnet": "NEAR_ENV=testnet parcel src/index.html",
    "prettier": "prettier --check src",
    "prettier:fix": "prettier --write src",
    "test": "jest test --runInBand",
    "test:watch": "yarn test --watch"
  },
  "devDependencies": {
    "@babel/core": "^7.0.0",
    "@babel/preset-env": "^7.13.15",
    "@babel/preset-react": "^7.13.13",
    "@babel/preset-typescript": "^7.13.0",
    "@emotion/babel-plugin": "^11.3.0",
    "@tailwindcss/postcss7-compat": "^2.1.0",
    "@testing-library/react": "^11.2.6",
    "@testing-library/user-event": "^13.1.5",
    "@types/bn.js": "^5.1.0",
    "@types/jest": "^26.0.22",
    "@types/lodash": "^4.14.171",
    "@types/mathjs": "^6.0.11",
    "@types/react": "^17.0.3",
    "@types/react-burger-menu": "^2.8.0",
    "@types/react-dom": "^17.0.2",
    "@types/react-icons": "^3.0.0",
    "@types/react-modal": "^3.12.0",
    "@types/react-router-dom": "^5.1.7",
    "@types/react-toastify": "^4.1.0",
    "autoprefixer": "^10.2.5",
    "babel-jest": "~26.6.2",
    "jest": "^26.6.3",
    "jest-environment-node": "~26.6.2",
    "parcel-bundler": "1.12.3",
    "postcss": "^8",
    "postcss-modules": "^4.0.0",
    "prettier": "2.3.1",
    "tailwindcss": "npm:@tailwindcss/postcss7-compat",
    "ts-jest": "^26.5.4",
    "typescript": "^4.2"
  },
  "dependencies": {
    "@react-icons/all-files": "^4.1.0",
    "@svgr/parcel-plugin-svgr": "^5.5.0",
    "actionsheet-react": "^1.0.12",
    "axios": "^0.21.1",
    "bignumber.js": "^9.0.1",
    "bn.js": "^5.2.0",
    "borsh": "^0.3.1",
    "dexie": "^3.0.3",
    "html-react-parser": "^1.3.0",
    "locales": "^0.0.2",
    "lodash": "^4.17.21",
    "lzutf8": "^0.6.0",
    "mathjs": "^9.3.0",
    "moment": "^2.29.1",
    "near-api-js": "^0.40.0",
    "react": "^16.0.0 || ^17.0.0",
    "react-burger-menu": "^3.0.6",
    "react-color": "^2.19.3",
    "react-countdown": "^2.3.2",
    "react-dom": "^16.0.0 || ^17.0.0",
    "react-icons": "^4.2.0",
    "react-infinite-scroll-component": "^6.1.0",
    "react-intl": "^5.20.10",
    "react-micro-modal": "^2.0.2",
    "react-modal": "^3.13.1",
    "react-router-dom": "^5.2.0",
    "react-spinners": "^0.11.0",
    "react-toastify": "^8.0.2",
    "react-tooltip": "^4.2.17",
    "recharts": "^2.1.6"
  },
  "browserslist": [
    "last 2 Chrome versions"
  ]
}

'''
'''--- src/__mocks__/fileMock.js ---
// NOTE: This is used to mock resource imports in JSX for tests
module.exports = '';

'''
'''--- src/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: white;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #ff585d;
  --secondary: #0072ce;

  background-color: var(--bg);
  color: var(--fg);
  font-family: 'Open Sans', sans-serif;
  font-size: 16px;
  line-height: 1.3;
}

body {
  margin: 0;
  background: #001220;
  scrollbar-width: thin;
  scrollbar-color: darkgrey transparent;
}

main {
  margin: 0 auto;
}

input {
  margin: 0;
  background-color: transparent;
  display: block;
  width: 100%;
  padding: 0;
  border-width: 0;
}

input:focus {
  outline: none;
  border-width: 0;
}

input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type='number'] {
  -moz-appearance: textfield; /* Firefox */
}

::-webkit-scrollbar {
  width: 4px;
  border-radius: 3px;
}

::-webkit-scrollbar-track {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0);
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(180deg, #00ffd1 0%, #00ba98 100%);
  border-radius: 8px;
}

.gray {
  color: #bdbdbd;
}

.bg-mobile-nav {
  background-color: #001220;
}

.bg-mobile-nav-item {
  background-color: #000b19;
}

.bg-dark {
  background-color: #1d2932;
}

.color-black {
  color: #2d3231;
}

.user .account-name {
  max-width: 150px;
}

.balances .token:first-child {
  padding-top: 0;
}

.balances .token:last-child {
  padding-bottom: 0;
}

#pool-container::-webkit-scrollbar,
.infinite-scroll-component::-webkit-scrollbar {
  display: none;
}

/* Adboard */
.tooltip-content::after {
  content: ' ';
  position: absolute;
  bottom: 100%; /* This will position the arrow at the top of the tooltip */
  left: 50%;
  margin-left: -10px;
  border-width: 10px;
  border-style: solid;
  border-color: transparent transparent rgba(34, 36, 51, 1) transparent; /* This will make the top border black */
}

.hover-trigger .hover-target {
  display: none;
}

.hover-trigger:hover .hover-target {
  display: block;
  margin-left: 29px;
}

.drawboard {
  width: 600px;
  height: 600px;
}

.bucket {
  margin-bottom: 8px;
}

.active-bucket {
  outline: 5px auto !important;
  -moz-outline-radius: 9999px;
}

.compact-picker {
  width: 260px !important;
}

.flexbox-fix {
  display: none !important;
}

.blur {
  background: rgba(0, 0, 0, 0.9);
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.9);
  backdrop-filter: blur(8.5px);
  -webkit-backdrop-filter: blur(8.5px);
}

.tooltip {
  visibility: invisible;
}

.has-tooltip:hover .tooltip {
  visibility: visible;
  z-index: 50;
}

.hide-scrollbar::-webkit-scrollbar {
  width: 0px;
  background: transparent;
}

.hide-scrollbar::-webkit-scrollbar-thum {
  background: transparent;
}

.status-bar {
  font-size: 14px;
  line-height: 32px;
  position: absolute;
  right: 0;
  top: 0;
  padding: 0 2em;
  -webkit-transform-origin: left bottom;
  -moz-transform-origin: left bottom;
  transform-origin: left bottom;
  -webkit-transform: translate(29.29%, -100%) rotate(45deg);
  -moz-transform: translate(29.29%, -100%) rotate(45deg);
  transform: translate(29.29%, -100%) rotate(45deg);
  text-indent: 0;
}

.ended {
  color: #fff;
  background: #75818a;
}

.pending {
  color: #fff;
  background: #59c5a6;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.loadingScreen,
.slick-loader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.4);
  opacity: 0;
  z-index: -1;
  transition: all 0.5s;
  border-radius: 6px;
}

.loadingScreen.active,
.slick-loader.active {
  z-index: 10000;
  opacity: 1;
}

.loadingScreen svg,
.slick-loader svg {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  left: 0;
  right: 0;
  margin: 0 auto;
  width: 200px;
}

.loadingScreen svg path,
.slick-loader svg path {
  animation: spin 1s linear infinite;
  transform-origin: center;
}

.inner-loader svg path {
  animation: spin 1s linear infinite;
  transform-origin: center;
}

.loadingScreen.slick-loader-inner,
.slick-loader.slick-loader-inner {
  position: absolute;
}

.__react_component_tooltip::before,
.__react_component_tooltip::after {
  content: none !important;
}

.filter-blur {
  backdrop-filter: blur(15px);
  -webkit-backdrop-filter: blur(15px);
}
input.normal-input:focus {
  border: 1px solid #00c6a2;
  color: #00c6a2;
}
input.invalid-input:focus {
  border: 1px solid #de5050;
  color: #de5050;
}
input.warn-input:focus {
  border: 1px solid #dea550;
  color: #dea550;
}
.reactTip {
  border-radius: 0.375rem !important;
  padding: 0.44rem 0.75rem !important;
  min-width: 7rem !important;
  opacity: 1 !important;
}
.farmEnded .border-gradientFromHover {
  border-color: #73818b;
}
.farmEnded .text-white {
  color: #73818b;
}
.farmEnded img {
  filter: grayscale(100%);
}

.swap-wrap {
  position: absolute;
  width: 18px;
  height: 18px;
  top: 6px;
  left: 26px;
  perspective: 60vh;
}

.top-ball {
  content: ' ';
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  left: -18px;
  top: 10px;
  border: #88a9a3 solid 1px;
  background: linear-gradient(-166.57deg, #208170 44.85%, #373f5a 100%);
  transform: translateZ(0vh);
  z-index: 2;
  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
}

.bottom-ball {
  opacity: 0.9;
  content: ' ';
  position: absolute;
  width: 98%;
  height: 98%;
  border-radius: 50%;
  right: 10px;
  top: 0;
  background: linear-gradient(262.02deg, #00d6af 2.13%, #1aa289 91.26%);
  transform: translateZ(0vh);
  z-index: 1;
}

@keyframes rotation1 {
  25% {
    left: -18px;
    top: 10px;
    transform: translateZ(-5px);
  }
  50% {
    left: -6px;
    top: 0px;
    transform: translateZ(0vh);
  }
  75% {
    left: -18px;
    top: 10px;
    transform: translateZ(10px);
    z-index: 2;
  }
}

@keyframes rotation2 {
  25% {
    right: 10px;
    top: 0px;
    transform: translateZ(-5px);
    z-index: 2;
  }
  50% {
    right: 20px;
    top: 10px;
    transform: translateZ(0vh);
  }
  75% {
    right: 10px;
    top: 0px;
    transform: translateZ(10px);
  }
}

.menu-max-height {
  max-height: calc(100vh - 80px);
  overflew-y: scroll;
  overflow-x: hidden;
}

.bg-height-full {
  height: calc(100% - 80px);
}

.recharts-text.recharts-cartesian-axis-tick-value {
  font-size: 12px;
}

.circle_process {
  width: 18px;
  height: 18px;
}
.circle_center {
  width: 14px;
  height: 14px;
}
.circle_process .wrapper {
  width: 9px;
  height: 18px;
}
.circle_process .circle {
  width: 18px;
  height: 18px;
  border: 2px solid transparent;
  transform: rotate(-136deg);
}
.circleleft {
  width: 18px;
  height: 18px;
  border: 2px solid transparent;
  transform: rotate(-136deg);
}
.circle_process .rightcircle {
  border-top: 2px solid #00d6af;
  border-right: 2px solid #00d6af;
  right: 0;
  -webkit-animation: circle_right 10s linear 1;
}
.circle_process .leftcircle {
  border-bottom: 2px solid #00d6af;
  border-left: 2px solid #00d6af;
  left: 0;
  -webkit-animation: circle_left 10s linear 1;
}
@-webkit-keyframes circle_right {
  0% {
    -webkit-transform: rotate(-136deg);
  }
  50%,
  100% {
    -webkit-transform: rotate(45deg);
  }
}
@-webkit-keyframes circle_left {
  0%,
  50% {
    -webkit-transform: rotate(-136deg);
  }
  100% {
    -webkit-transform: rotate(45deg);
  }
}

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="icon" href="./assets/favicon.ico" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="./assets/favicon-32x32.png"
    />
    <link rel="apple-touch-icon" href="./assets/favicon.ico" />
    <title>Ref Finance</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="app.pcss" />
  </head>
  <body class="font-sans">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./index.tsx"></script>
  </body>
</html>

'''
'''--- src/locales/en_US.ts ---
const en_US = {
  deposit: 'Deposit',
  Deposit: 'Deposit',
  withdraw: 'Withdraw',
  Withdraw: 'Withdraw',
  withdraw_token: 'Withdraw Token',
  swap: 'Swap',
  Swap: 'Swap',
  exchange_tokens: 'Exchange Tokens',
  pool: 'Pool',
  Pool: 'Pool',
  pools: 'Pools',
  Pools: 'Pools',
  Quiz: 'Quiz',
  no_tokens_deposited: 'No Tokens Deposited',
  view_pools: 'View Pools',
  view_pool: 'View Pool',
  add_token: 'Add Token',
  Add_Token: 'Add Token',
  create_new_pool: 'Create new pool',
  Create_New_Pool: 'Create New Pool',
  your_liquidity: 'Your Liquidity',
  Your_Liquidity: 'Your Liquidity',
  farms: 'Farms',
  Farms: 'Farms',
  airdrop: 'Airdrop',
  Airdrop: 'Airdrop',
  docs: 'Docs',
  Docs: 'Docs',
  community: 'Community',
  Community: 'Community',
  more: 'More',
  More: 'More',
  account: 'Account',
  Account: 'Account',
  New_ui: 'New UI',
  Risk: 'Risks',
  Forum: 'Forum',
  Discord: 'Discord',
  Telegram: 'Telegram',
  Twitter: 'Twitter',
  Medium: 'Medium',
  move_assets_to_from_ethereum: 'Move assets to/from Ethereum',
  rainbow_bridge: 'Rainbow Bridge',
  deposit_to_swap: 'Deposit to Swap',
  connect_to_near: 'Connect to NEAR',
  slippage: 'Slippage tolerance',
  slippage_title: 'Transaction Settings',
  minimum_received: 'Minimum received',
  swap_rate: 'Swap rate',
  pool_fee: 'Pool fee',
  balance: 'Balance',
  from: 'From',
  to: 'To',
  submit: 'Submit',
  wrapnear: 'Wrap NEAR',
  wrapnear_tip_one: 'Wrapping NEAR allows you to trade on REF. Make sure to ',
  wrapnear_tip_two: 'leave 1 NEAR',
  wrapnear_tip_three: ' for gas fees to unwrap your NEAR.',
  wrap_error_msg: 'Not enough balance',
  sign_out: 'Sign Out',
  view_account: 'View Account',
  deposit_to_swap_and_add_liquidity: 'Deposit to swap and add liquidity',
  small_storage_fee_is_applied_of: 'Small storage fee is applied of',
  liquidity: 'Liquidity',
  tokens: 'Tokens',
  fee: 'Fee',
  fees: 'Fees',
  view_detail: 'View detail',
  pool_details: 'Pool details',
  details: 'Details',
  detail: 'Detail',
  liquidity_pools: 'Liquidity Pools',
  minimum_tokens_out: 'Minimum received',
  pair: 'Pair',
  tvl: 'TVL',
  search_pools: 'Search Pool',
  add_liquidity: 'Add Liquidity',
  remove_liquidity: 'Remove Liquidity',
  total_liquidity: 'Total liquidity',
  coming_soon: 'Coming soon',
  accumulated_volume: 'Accumulated Volume',
  underlying_liquidity: 'Underlying liquidity',
  total_shares: 'Total shares',
  my_shares: 'Shares',
  token: 'Token',
  enter_token_address: 'Enter token address',
  you_are_not_providing_liquidity_to_any_pools:
    'You aren’t providing liquidity to any pools',
  remove: 'Remove',
  select: 'Select',
  select_token: 'Select Token',
  basis_points: 'Basis points',
  total_fee: 'Total fee % ',
  protocol_fee_is: 'protocol fee is ',
  start_in: 'Start in',
  start_at: 'Start at',
  started_at: 'Started at',
  start_date: 'Start date',
  end_at: 'End at',
  end_date: 'End date',
  earn: 'Earn',
  ended: 'ENDED',
  pending: 'PENDING',
  rewards_per_week: 'Rewards per week',
  apr: 'APR',
  total_staked: 'Total staked',
  unclaimed_rewards: 'Unclaimed rewards',
  claim: 'Claim',
  claim_all: 'Claim All',
  stake: 'Stake',
  unstake: 'Unstake',
  your_rewards: 'Your rewards',
  your_shares: 'Shares',
  shares_owned: 'Shares Owned',
  stake_your_liquidity_provider_LP_tokens:
    'Stake your Liquidity Provider (LP) tokens',
  go_to_wallet: 'Go to Wallet',
  recent_activity: 'Recent Activity',
  view_all: 'View All',
  cancel: 'Cancel',
  claim_ref_token: 'Claim Ref Token',
  has_no_available_claim: 'has no available claim',
  sorry: 'Sorry',
  total_ref_token: 'Total Ref Token',
  locking_ref_token: 'Locked Ref Token',
  unclaim_ref_token: 'Unclaimed Ref Token',
  unlocked: 'Unlocked',
  locking: 'Locked',
  you_can_claim_from: 'You can claim from',
  you_have_claimed_all_your_rewards: 'You have claimed all your rewards',
  ends_in: 'Ends in',
  days: 'days',
  swap_successful_click_to_view: 'Swap successful. Click to view',
  claim_successful_click_to_view: 'Claim successful. Click to view',
  claim_failed_click_to_view: 'Claim failed. Click to view',
  slippageCopyForMobile:
    'Slippage means the difference between what you expect to get and what you actually get due to other executing first',
  slippageCopy:
    'Slippage means the difference between what <br> you expect to get and what you actually <br> get due to other executing first',
  depositCopy:
    'This deposits your selected tokens into the <br> exchange for swapping or adding to a liquidity pool',
  nearDepositCopy:
    'This first wraps then deposits your Ⓝ into the <br> exchange for swapping or adding to a liquidity pool',
  nearWithdrawCopy:
    'This will first unwrap your Ⓝ then withdraw it from <br> the exchange and move the tokens to your wallet',
  withdrawCopy:
    'This will withdraw your selected tokens from <br> the exchange and deposit them into your wallet',
  registerToken:
    'This registers a new token with the <br> exchange that is not already listed',
  whitelistTokenCopy: 'Add any NEP-141 token',
  addLiquidityPoolCopy:
    'This creates a new liquidity pool for the two tokens selected. The fee is the percentage the pool takes from each transaction',
  swapCopy:
    'Swap exchanges the first selected token with the second <br> selected token.The pools with the highest available liquidity and the lowest exchange fee will be used',
  addTokenCopy: 'Add any NEP-141 token',
  getLPTokenCopy: 'Click here to jump to the corresponding pool',
  airdropCopy:
    ' Please claim your airdrop at least once before the expiration date otherwise your balance would be donated into the treasury',
  farmRewardsCopy: 'Indicative value based on prices and not actual execution',
  totalValueLockedCopy: 'Total Value Locked',
  topPoolsCopy: 'For every pair, only display the highest pool TVL',
  you_do_not_have_enough: "You don't have enough",
  must_provide_at_least_one_token_for: 'Must provide greater than 0 token for',
  is_not_exist: 'is not exist',
  must_input_a_value_greater_than_zero: 'Must input a value greater than 0',
  must_input_a_value_not_greater_than_your_balance:
    'Must input a value not greater than your balance',
  no_pool_available_to_make_a_swap_from:
    'No pool available to make a swap from',
  for_the_amount: 'for the amount',
  no_pool_eng_for_chinese: ' ',
  is_not_a_valid_swap_amount: 'is not a valid swap amount',
  not_nep_address:
    'The address you entered is not a NEP-141 address, please check and enter it again. If it is another mainnet contract, go to Rainbow Bridge for bridging processing',
  not_correct_address:
    'The address you entered is incorrect, please check and enter',
  popular_tokens: 'Popular Tokens',
  asset_label: 'Asset',
  account_label: 'Account',
  total_label: 'Total',
  top_pools: 'Top pools',
  pool_id: 'Pool ID',
  more_pools: 'More pools',
  my_watchlist: 'My Watchlist',
  h24_volume: '24h volume',
  hide_low_tvl_pools: 'Hide low TVL pools',
  watchlist_title: 'My watchlist on the top',
  add_watchlist: 'Add Watchlist',
  remove_watchlist: 'Remove Watchlist',
  my_watchlist_copy: 'Marked pools will appear here',
  search_token: 'Search token',
  language: 'Language',
  deposit_to_add_liquidity: 'Deposit to Add Liquidity',
  slip_wran: 'Be careful, please check the minimum you can receive.',
  slip_invalid: 'The slippage tolerance is invalid.',
  press_enter_to_search: 'Press enter to search',
  click_search_bar_to_search: 'Click search bar to search',
  reward_tokens: 'Reward tokens',
  detail_tip: 'Detail',
  no_data: 'No Data',
  select_balance: 'Select balance',
  selectBalanceCopy:
    'Select [NEAR wallet] to swap directly tokens available in your NEAR wallet',
  near_wallet: 'NEAR wallet',
  ref_account: 'REF account',
  swap_tip: 'Swap from your REF account by selecting REF account in settings',
  attention: 'Attention',
  live: 'Live',
  ended_search: 'Ended',
  staked_only: 'Staked only',
  sort_by: 'Sort by',
  your_farms_rewards: 'Your Farms Rewards',
  your_farms: 'Your farms',
  new: 'New',
  unstake_tip_t: 'you have rewards unclaimed...',
  unstake_tip_m:
    'Unstaking will remove the stake from all active and pending farms of the same pair.',
  unstake_tip_b: 'Do you want to unstake?',
  value_rewards: 'Value of rewards',
  stake_unstake_tip:
    'Staking or unstaking will automatically claim your rewards.',
  over_tip:
    'Due to the limitation of Gas Fee, only 5 items most can be selected at one time',
  no_token_tip: 'No reward token',
  getToken_tip: 'You can claim your rewards or stake your LP Tokens now!',
  in_farm: 'in Farm',
  roi_calculator: 'ROI Calculator',
  lp_staked: 'LP staked',
  usd: 'USD',
  lp_token: 'LP token',
  stake_for: 'Duration',
  day_1: '1D',
  day_2: '7D',
  day_3: '30D',
  day_4: '90D',
  day_5: '1Y',
  cur_apr: 'ROI',
  reward_token: 'Reward tokens',
  get_lp_token: 'Get LP shares',
  calculate_roi: 'ROI calculator',
  rewards_claimed: 'Rewards claimed',
  value_rewards_token: 'Value of rewards',
  all: 'all',
  all_5: '5 tokens per time',
  your_liquidity_positions_will_appear_here:
    'Your liquidity positions will appear here.',
  price_impact: 'Price impact',
};
export default en_US;

'''
'''--- src/locales/zh_CN.ts ---
import React from 'react';

const zh_CN = {
  deposit: '存入',
  Deposit: '存入',
  withdraw: '提取',
  Withdraw: '提取',
  withdraw_token: '提取代币',
  swap: '兑换',
  Swap: '兑换',
  exchange_tokens: '交换代币',
  pool: '流动池',
  Pool: '流动池',
  pools: '流动池',
  Pools: '流动池',
  Quiz: 'Quiz',
  no_tokens_deposited: '无代币存入',
  view_pools: '查看流动池',
  view_pool: '查看流动池',
  add_token: '添加代币',
  Add_Token: '添加代币',
  create_new_pool: '创建流动池',
  Create_New_Pool: '创建流动池',
  your_liquidity: '你的流动性',
  Your_Liquidity: '你的流动性',
  farms: '农场',
  Farms: '农场',
  airdrop: '空投',
  Airdrop: '空投',
  docs: '文档',
  Docs: '文档',
  community: '社区',
  Community: '社区',
  more: '更多',
  More: '更多',
  account: '账号',
  Account: '账号',
  New_ui: 'New UI',
  Risk: 'Risks',
  Forum: '论坛',
  Discord: 'Discord',
  Telegram: 'Telegram',
  Twitter: 'Twitter',
  Medium: 'Medium',
  move_assets_to_from_ethereum: '以太坊资产桥',
  rainbow_bridge: '以太坊资产桥',
  deposit_to_swap: '存入代币进行兑换',
  connect_to_near: '连接钱包',
  slippage: '滑点',
  slippage_title: '交易设置',
  minimum_received: '可收到的最低数额',
  swap_rate: '兑换汇率',
  pool_fee: '手续费',
  balance: '余额',
  from: '从',
  to: '到',
  submit: '提交',
  wrapnear: 'Wrap NEAR',
  wrapnear_tip_one: 'wNEAR支持您在REF中交易，',
  wrapnear_tip_two: '请保留至少1个NEAR，',
  wrapnear_tip_three: '以保障gas费充足。',
  wrap_error_msg: '余额不足',
  sign_out: '退出',
  view_account: '查看账户',
  deposit_to_swap_and_add_liquidity: '存入代币兑换或增加流动性',
  small_storage_fee_is_applied_of: '存入手续费为',
  liquidity: '流动性',
  tokens: '代币',
  fee: '手续费',
  fees: '手续费',
  view_detail: '查看详情',
  pool_details: '资金池详情',
  details: '详情',
  detail: '详情',
  liquidity_pools: '流动性资金池',
  minimum_tokens_out: '最少可获得代币数量',
  pair: '交易对',
  tvl: '总锁定价值',
  search_pools: '搜索资金池',
  add_liquidity: '添加流动性',
  remove_liquidity: '移除流动性',
  total_liquidity: '总流动性',
  coming_soon: '敬请期待',
  connect_to_near_tip: '连接您的钱包以提供流动性并查看您的存款',
  accumulated_volume: '累计成交量',
  underlying_liquidity: '基础流动性',
  total_shares: '份额总量',
  my_shares: '份额',
  token: '代币',
  enter_token_address: '输入代币地址',
  you_are_not_providing_liquidity_to_any_pools: '你未提供任何池子的流动性',
  remove: '移除',
  select: '选择代币',
  select_token: '选择代币',
  basis_points: '基点',
  total_fee: '总费用 % ',
  protocol_fee_is: '协议费为 ',
  start_in: '开始',
  start_at: '开始于',
  started_at: '开始于',
  start_date: '开始时间',
  end_at: '结束于',
  end_date: '结束时间',
  earn: '赚取',
  ended: '已结束',
  pending: '未开始',
  rewards_per_week: '每周奖励总额',
  apr: '年化率',
  total_staked: '质押总金额',
  unclaimed_rewards: '未领取奖励',
  claim: '认领',
  claim_all: '认领全部',
  stake: '质押',
  unstake: '取消质押',
  your_rewards: '你的奖励',
  your_shares: '份额',
  shares_owned: '当前份额',
  stake_your_liquidity_provider_LP_tokens: '质押你的LP代币',
  go_to_wallet: '跳转到钱包',
  recent_activity: '近期操作',
  view_all: '查看全部',
  cancel: '取消',
  claim_ref_token: '认领 REF 代币',
  has_no_available_claim: '无空投额度',
  sorry: '抱歉',
  total_ref_token: 'REF代币总额度',
  locking_ref_token: 'REF代币锁定额度',
  unclaim_ref_token: 'REF代币未领取额度',
  unlocked: '已解锁',
  locking: '锁定中',
  you_can_claim_from: '你可以从如下时间开始认领',
  you_have_claimed_all_your_rewards: '你已经领取了你所有的奖励',
  ends_in: '结束于',
  days: '天后',
  swap_successful_click_to_view: '交易成功，点击查看详情',
  claim_successful_click_to_view: '认领成功，点击查看详情',
  claim_failed_click_to_view: '认领失败，点击查看详情',
  slippageCopyForMobile:
    '滑点是您期望得到的和因先执行的其他交易而实际得到的之间的差异。',
  slippageCopy:
    '滑点是您期望得到的和因先执行的其他交易而实际得到的之间的差异。',
  depositCopy: '将您选择的代币存入，以便进行兑换或添加到流动性池中。',
  nearDepositCopy: '将 Ⓝ 打包存入进行交换或添加到流动性池中',
  nearWithdrawCopy: '将您的 Ⓝ 取出后并将代币移到您的钱包中。',
  withdrawCopy: '取出您选择的代币，并将其存入您的钱包。',
  registerToken: '申请注册一个代币名单以外的新代币。',
  whitelistTokenCopy: '添加NEP-141代币。',
  addLiquidityPoolCopy:
    '为所选的两个代币对创建一个新的流动性池。<br>兑换手续费用是流动池从每笔交易中获得的百分比。',
  swapCopy:
    '兑换交易是将第一个选定的代币交换成第二个选定的代币。<br> 将使用最高流动性和最低交易费用的池。',
  addTokenCopy: '添加NEP-141代币。',
  getLPTokenCopy: '单击此处跳转到相应的池。',
  airdropCopy: '请在截止日期前至少领取一次空投，否则您的余额将捐给财政部。',
  farmRewardsCopy: '这是基于价格的指示性值而非实际结果',
  totalValueLockedCopy: '总锁定价值',
  topPoolsCopy: '对每一个交易对, 只展示最高锁仓量的流动池',
  myWatchList: '我的收藏列表',
  you_do_not_have_enough: '你没有足够的',
  must_provide_at_least_one_token_for: '你提供的币的数量需大于0',
  is_not_exist: '不存在',
  must_input_a_value_greater_than_zero: '必须输入一个大于0的值',
  must_input_a_value_not_greater_than_your_balance:
    '输入的数值不能大于你的余额数量',
  no_pool_available_to_make_a_swap_from: '没有池子能够提供',
  for_the_amount: '数额为',
  no_pool_eng_for_chinese: '的交易',
  is_not_a_valid_swap_amount: '错误的兑换数额',
  not_nep_address:
    '您输入的地址不是NEP-141地址，请检查后再输入。如果是其他主网合约，去彩虹桥进行桥接处理',
  not_correct_address: '您输入的地址不正确，请检查后再输入',
  popular_tokens: '常用代币',
  asset_label: '资产',
  account_label: '账户',
  total_label: '总量',
  top_pools: 'Top pools',
  pool_id: '流动池 ID',
  more_pools: '更多流动池',
  my_watchlist: '我的收藏',
  h24_volume: '24小时交易量',
  volume: '交易量',
  hide_low_tvl_pools: '隐藏低锁仓量资金池',
  watchlist_title: '顶部的我的收藏',
  add_watchlist: '添加到收藏',
  remove_watchlist: '取消收藏',
  my_watchlist_copy: '收藏过的流动池将会出现在这里',
  search_token: '搜索代币',
  language: '语言',
  deposit_to_add_liquidity: '存入代币以添加流动性',
  slip_wran: '注意，请检查您可以收到的最低金额',
  slip_invalid: '请输入有效的值',
  press_enter_to_search: '按下回车以搜索',
  click_search_bar_to_search: '点击搜索图标以搜索',
  reward_tokens: '奖励币',
  detail_tip: '详情',
  no_data: '暂无数据',
  select_balance: '选择资产来源',
  selectBalanceCopy: '选择[NEAR钱包]直接使用你钱包里的资产进行交易',
  near_wallet: 'NEAR钱包',
  ref_account: 'REF账户',
  swap_tip: '如果想从REF账户中兑换可以在设置中选择REF账户',
  attention: '请注意',
  live: '进行',
  ended_search: '结束',
  staked_only: '按质押',
  sort_by: '按排序',
  your_farms_rewards: '你的农场奖励',
  your_farms: '你的农场',
  new: '最新',
  unstake_tip_t: '你有未领取的奖励...',
  unstake_tip_m:
    '取消质押操作会把所有质押从相同交易对的所有进行中和未开始的农场里移除.',
  unstake_tip_b: '你想取消质押吗?',
  value_rewards: '奖励币总价值',
  stake_unstake_tip: '质押或取消质押操作将自动领取奖励',
  over_tip: '因为汽油费的限制一次最多能选择5个代币',
  no_token_tip: '没有可提取的代币',
  getToken_tip: '你可以现在认领你的奖励或质押代币！',
  in_farm: '在农场中',
  roi_calculator: 'ROI 计算器',
  lp_staked: '流动代币质押',
  usd: '美元',
  lp_token: '流动性代币',
  stake_for: '质押时间',
  day_1: '1天',
  day_2: '7天',
  day_3: '30天',
  day_4: '90天',
  day_5: '1年',
  cur_apr: 'ROI',
  reward_token: '奖励代币',
  get_lp_token: '获取流动性代币',
  calculate_roi: 'ROI 计算器',
  rewards_claimed: '可领取的奖励',
  value_rewards_token: '奖励代币的价值',
  all: '全选',
  all_5: '一次可选5种代币',
  your_liquidity_positions_will_appear_here: '你参与的流动池将会出现在这里',
  price_impact: '价格影响',
};
export default zh_CN;

'''
'''--- src/services/SpecialWallet.ts ---
import { baseDecode } from 'borsh';
import { ConnectedWalletAccount, WalletConnection } from 'near-api-js';
import { Action, createTransaction } from 'near-api-js/lib/transaction';
import { PublicKey } from 'near-api-js/lib/utils';

export default class SpecialWallet extends WalletConnection {
  _connectedAccount: SpecialWalletAccount;

  account() {
    if (!this._connectedAccount) {
      this._connectedAccount = new SpecialWalletAccount(
        this,
        this._near.connection,
        this._authData.accountId
      );
    }

    return this._connectedAccount;
  }

  createTransaction({
    receiverId,
    actions,
    nonceOffset = 1,
  }: {
    receiverId: string;
    actions: Action[];
    nonceOffset?: number;
  }) {
    return this._connectedAccount.createTransaction({
      receiverId,
      actions,
      nonceOffset,
    });
  }
}

class SpecialWalletAccount extends ConnectedWalletAccount {
  async sendTransactionWithActions(receiverId: string, actions: Action[]) {
    return this.signAndSendTransaction(receiverId, actions);
  }

  async createTransaction({
    receiverId,
    actions,
    nonceOffset = 1,
  }: {
    receiverId: string;
    actions: Action[];
    nonceOffset?: number;
  }) {
    const localKey = await this.connection.signer.getPublicKey(
      this.accountId,
      this.connection.networkId
    );
    let accessKey = await this.accessKeyForTransaction(
      receiverId,
      actions,
      localKey
    );
    if (!accessKey) {
      throw new Error(
        `Cannot find matching key for transaction sent to ${receiverId}`
      );
    }

    const block = await this.connection.provider.block({ finality: 'final' });
    const blockHash = baseDecode(block.header.hash);

    const publicKey = PublicKey.from(accessKey.public_key);
    const nonce = accessKey.access_key.nonce + nonceOffset;

    return createTransaction(
      this.accountId,
      publicKey,
      receiverId,
      nonce,
      actions,
      blockHash
    );
  }
}

'''
'''--- src/services/__mocks__/SpecialWallet.ts ---
import { ConnectedWalletAccount, WalletConnection } from 'near-api-js';
import { FinalExecutionOutcome } from 'near-api-js/lib/providers';
import { Action, createTransaction } from 'near-api-js/lib/transaction';
import { KeyPair, PublicKey } from 'near-api-js/lib/utils';

const views: { [key: string]: any } = {};

export default class SpecialWallet extends WalletConnection {
  static transactions = jest.fn();

  _connectedAccount: SpecialWalletAccount;

  static addView(contractId: string, methodName: string, result: any) {
    views[`${contractId}-${methodName}`] = result;
  }

  getAccountId() {
    return 'test.near';
  }

  isSignedIn() {
    return true;
  }

  async requestSignTransactions() {}

  account() {
    if (!this._connectedAccount) {
      this._connectedAccount = new SpecialWalletAccount(
        this,
        this._near.connection,
        this._authData.accountId
      );
    }

    return this._connectedAccount;
  }

  createTransaction({
    receiverId,
    actions,
    nonceOffset = 1,
  }: {
    receiverId: string;
    actions: Action[];
    nonceOffset?: number;
  }) {
    return this._connectedAccount.createTransaction({
      receiverId,
      actions,
      nonceOffset,
    });
  }
}

class SpecialWalletAccount extends ConnectedWalletAccount {
  async viewFunction(
    contractId: string,
    methodName: string,
    args: any
  ): Promise<any> {
    const mockResult = views[`${contractId}-${methodName}`];
    return mockResult === undefined ? [] : mockResult;
  }

  async getAccountBalance() {
    return {
      total: '100000000000000000000000000',
      available: '50000000000000000000000000',
      stateStaked: '0',
      staked: '0',
    };
  }

  protected async signAndSendTransaction(
    receiverId: string,
    actions: Action[]
  ): Promise<FinalExecutionOutcome> {
    SpecialWallet.transactions(receiverId, actions);

    return {
      status: {},
      transaction: {},
      transaction_outcome: {
        id: '',
        outcome: {
          logs: [],
          receipt_ids: [],
          gas_burnt: 0,
          status: {},
        },
      },
      receipts_outcome: [],
    };
  }

  async sendTransactionWithActions(receiverId: string, actions: Action[]) {
    return this.signAndSendTransaction(receiverId, actions);
  }

  async createTransaction({
    receiverId,
    actions,
    nonceOffset = 1,
  }: {
    receiverId: string;
    actions: Action[];
    nonceOffset?: number;
  }) {
    SpecialWallet.transactions(receiverId, actions);

    return createTransaction(
      this.accountId,
      KeyPair.fromRandom('ed25519').getPublicKey(),
      receiverId,
      nonceOffset,
      actions,
      new Uint8Array(
        Buffer.from('7nsuuitwS7xcdGnD9JgrE22cRB2vf2VS4yh1N9S71F4d').buffer
      )
    );
  }
}

'''
'''--- src/services/account.ts ---
import { storageDepositAction } from './creators/storage';
import {
  refFarmViewFunction,
  refFiFunctionCall,
  refFiViewFunction,
  wallet,
} from './near';

export const ACCOUNT_MIN_STORAGE_AMOUNT = '0.003';
export interface RefPrice {
  'ref-finance': {
    usd: number;
  };
}

export const initializeAccount = () => {
  return refFiFunctionCall(
    storageDepositAction({
      accountId: wallet.getAccountId(),
      registrationOnly: true,
      amount: ACCOUNT_MIN_STORAGE_AMOUNT,
    })
  );
};

export interface AccountStorageView {
  total: string;
  available: string;
}

export const currentStorageBalance = (
  accountId: string
): Promise<AccountStorageView> => {
  return refFiViewFunction({
    methodName: 'storage_balance_of',
    args: { account_id: accountId },
  });
};

export const currentStorageBalanceOfFarm = (
  accountId: string
): Promise<AccountStorageView> => {
  return refFarmViewFunction({
    methodName: 'storage_balance_of',
    args: { account_id: accountId },
  });
};

'''
'''--- src/services/adboard.ts ---
import axios from 'axios';
import {
  ONE_YOCTO_NEAR,
  REF_FI_CONTRACT_ID,
  wallet,
  getGas,
  getAmount,
  REF_ADBOARD_CONTRACT_ID,
} from './near';

export interface AdboardMetadata {
  token_price: number;
  token_id: string;
  owner: string;
  protected_ts: number;
  frameId: string;
}

export type AdboardFrameData = number[][];

export interface AdboardState {
  framedata: AdboardFrameData;
  metadata: AdboardMetadata[];
}

export const getAdboardState = async (): Promise<AdboardState> => {
  const resp = await axios.get(
    'https://pixelparty.pixeldapps.co/api/getAdboard'
  );
  return { framedata: resp.data.framedata, metadata: resp.data.metadata };
};

export const editFrame = ({
  frameId,
  framedata,
}: {
  frameId: string;
  framedata: AdboardFrameData;
}) => {
  return wallet.account().functionCall(REF_ADBOARD_CONTRACT_ID, 'editFrame', {
    frameId: Number(frameId),
    frameData: framedata,
  });
};

export const buyFrameCall = ({
  frameId,
  tokenId,
  amount,
  receiverId,
  sellTokenId,
  sellPrice,
  poolId,
}: {
  frameId: string;
  tokenId: string;
  amount: string;
  receiverId: string;
  sellTokenId: string;
  sellPrice: string;
  poolId: number;
}) => {
  return wallet.account().functionCall(
    REF_FI_CONTRACT_ID,
    'mft_transfer_call',
    {
      token_id: tokenId,
      amount: amount,
      receiver_id: receiverId,
      msg: frameId + '||' + sellTokenId + '||' + sellPrice + '||' + poolId,
    },
    getGas('300000000000000'),
    getAmount(ONE_YOCTO_NEAR)
  );
};

'''
'''--- src/services/airdrop.ts ---
import {
  getAmount,
  getGas,
  REF_AIRDRAOP_CONTRACT_ID,
  wallet,
} from '~services/near';
import { functionCall } from 'near-api-js/lib/transaction';
import {
  NEW_ACCOUNT_STORAGE_COST,
  WRAP_NEAR_CONTRACT_ID,
} from '~services/wrap-near';
import { ftGetStorageBalance } from '~services/ft-contract';

const AIRDROP_STORAGE_AMOUNT = '0.01';

export interface StatsOptions {
  token_account_id: string;
  skyward_account_id: string;
  claim_expiration_timestamp: string;
  total_balance: number;
  untouched_balance: number;
  total_claimed: number;
}

export interface AccountOptions {
  start_timestamp: string;
  cliff_timestamp: string;
  end_timestamp: string;
  balance: number;
  claimed_balance: number;
}

export interface AirDropViewFunctionOptions {
  methodName: string;
  args?: object;
}

export interface AirDropFunctionCallOptions extends AirDropViewFunctionOptions {
  gas?: string;
  amount?: string;
}

const airdropViewFunction = ({
  methodName,
  args,
}: AirDropViewFunctionOptions) => {
  return wallet
    .account()
    .viewFunction(REF_AIRDRAOP_CONTRACT_ID, methodName, args);
};

interface Transaction {
  receiverId: string;
  functionCalls: AirDropFunctionCallOptions[];
}

const executeMultipleTransactions = async (
  transactions: Transaction[],
  callbackUrl?: string
) => {
  const nearTransactions = await Promise.all(
    transactions.map((t, i) => {
      return wallet.createTransaction({
        receiverId: t.receiverId,
        nonceOffset: i + 1,
        actions: t.functionCalls.map((fc) =>
          functionCall(
            fc.methodName,
            fc.args,
            getGas(fc.gas),
            getAmount(fc.amount)
          )
        ),
      });
    })
  );

  return wallet.requestSignTransactions(nearTransactions, callbackUrl);
};

export const getStats = async (): Promise<StatsOptions> => {
  return airdropViewFunction({
    methodName: 'get_stats',
    args: {},
  });
};

export const getAccount = async (): Promise<AccountOptions> => {
  return airdropViewFunction({
    methodName: 'get_account',
    args: {
      account_id: wallet.getAccountId(),
    },
  });
};

export const claim = async (token_id: string) => {
  const transactions: Transaction[] = [];
  const actions: AirDropFunctionCallOptions[] = [];

  actions.push({
    methodName: 'claim',
    args: {},
    gas: getGas('100000000000000').toString(),
  });

  const balance = await ftGetStorageBalance(token_id);

  if (!balance || balance.total === '0') {
    transactions.push({
      receiverId: token_id,
      functionCalls: [
        {
          methodName: 'storage_deposit',
          args: {},
          gas: '100000000000000',
          amount: NEW_ACCOUNT_STORAGE_COST,
        },
      ],
    });
  }

  transactions.push({
    receiverId: REF_AIRDRAOP_CONTRACT_ID,
    functionCalls: actions,
  });

  return executeMultipleTransactions(transactions);
};

'''
'''--- src/services/api.ts ---
import getConfig from './config';
import { wallet } from './near';
import { toPrecision } from '~utils/numbers';
import { BigNumber } from 'bignumber.js';
import moment from 'moment';

const config = getConfig();
const api_url = 'https://rest.nearapi.org/view';

export interface RefPrice {
  price: string;
}

export interface PoolRPCView {
  id: number;
  token_account_ids: string[];
  token_symbols: string[];
  amounts: string[];
  total_fee: number;
  shares_total_supply: string;
  tvl: number;
  token0_ref_price: string;
  share: string;
}

export const parsePoolView = (pool: any): PoolRPCView => ({
  id: Number(pool.id),
  token_account_ids: pool.token_account_ids,
  token_symbols: pool.token_symbols,
  amounts: pool.amounts,
  total_fee: pool.total_fee,
  shares_total_supply: pool.shares_total_supply,
  tvl: Number(toPrecision(pool.tvl, 2)),
  token0_ref_price: pool.token0_ref_price,
  share: pool.share,
});

export const getPoolBalance = async (pool_id: number) => {
  console.log('getPoolBalance: wallet accound id: ',wallet.getAccountId());
  return await fetch(api_url, {
    method: 'POST',
    body: JSON.stringify({
      rpc_node: config.nodeUrl,
      contract: config.REF_FI_CONTRACT_ID,
      method: 'get_pool_shares',
      params: { account_id: wallet.getAccountId(), pool_id: pool_id },
    }),
    headers: { 'Content-type': 'application/json; charset=UTF-8' },
  })
    .then((res) => res.text())
    .then((balance) => {
      return new BigNumber(balance.toString()).toFixed();
    });
};

export const getPoolsBalances = async (pool_ids: number[]) => {
  return await Promise.all(
    pool_ids.map(async (pool_id) => await getPoolBalance(Number(pool_id)))
  );
};

export const getPools = async (counter: number) => {
  return await fetch(api_url, {
    method: 'POST',
    body: JSON.stringify({
      rpc_node: config.nodeUrl,
      contract: config.REF_FI_CONTRACT_ID,
      method: 'get_pools',
      params: { from_index: counter, limit: 300 },
    }),
    headers: { 'Content-type': 'application/json; charset=UTF-8' },
  })
    .then((res) => res.json())
    .then((pools) => {
      pools.forEach(async (pool: any, i: number) => {
        pool.id = i + counter;
        const pool_balance = await getPoolBalance(Number(pool.id) + counter);
        if (Number(pool_balance) > 0) {
          pools[i].share = pool_balance;
        }
      });
      return pools;
    });
};

export const getUserWalletTokens = async (): Promise<any> => {
  return await fetch(
    config.helperUrl + '/account/' + wallet.getAccountId() + '/likelyTokens',
    {
      method: 'GET',
      headers: { 'Content-type': 'application/json; charset=UTF-8' },
    }
  )
    .then((res) => res.json())
    .then((tokens) => {
      return tokens;
    });
};

export const getCurrentUnixTime = async (): Promise<any> => {
  return await fetch(config.indexerUrl + '/timestamp', {
    method: 'GET',
    headers: { 'Content-type': 'application/json; charset=UTF-8' },
  })
    .then((res) => res.json())
    .then((ts) => {
      return ts.ts;
    })
    .catch(() => {
      return moment().unix();
    });
};

export const currentRefPrice = async (): Promise<any> => {
  return await fetch(
    config.indexerUrl + '/get-token-price?token_id=token.v2.ref-finance.near',
    {
      method: 'GET',
      headers: { 'Content-type': 'application/json; charset=UTF-8' },
    }
  )
    .then((res) => res.json())
    .then((priceBody) => {
      return priceBody.price;
    })
    .catch(() => {
      return '-';
    });
};

export const currentTokensPrice = async (ids: string): Promise<any> => {
  return await fetch(
    config.indexerUrl + '/list-token-price-by-ids?ids=' + ids,
    {
      method: 'GET',
      headers: { 'Content-type': 'application/json; charset=UTF-8' },
    }
  )
    .then((res) => res.json())
    .then((priceBody) => {
      return priceBody;
    })
    .catch(() => {
      return [];
    });
};

'''
'''--- src/services/config.ts ---
export default function getConfig(env: string = process.env.NEAR_ENV) {

    const testnetConfig = {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        explorerUrl: 'https://explorer.testnet.near.org',
        indexerUrl: 'https://dev-indexer.ref-finance.com',
        sodakiApiUrl: 'https://sodaki.com/api',
        REF_FI_CONTRACT_ID:
          process.env.REF_FI_CONTRACT_ID || 'exchange.ref-dev.testnet',
        WRAP_NEAR_CONTRACT_ID:
          process.env.WRAP_NEAR_CONTRACT_ID || 'wrap.testnet',
        REF_ADBOARD_CONTRACT_ID: 'ref-adboard.near',
        REF_FARM_CONTRACT_ID:
          process.env.REF_FARM_CONTRACT_ID || 'farm110.ref-dev.testnet',

        REF_TOKEN_ID: 'token.ref-finance.testnet',
        REF_AIRDROP_CONTRACT_ID: 'locker002.ref-dev.testnet',
        POOL_TOKEN_REFRESH_INTERVAL:
          process.env.POOL_TOKEN_REFRESH_INTERVAL || 10,
      };
      
      const mainnetConfig = {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
        explorerUrl: 'https://explorer.mainnet.near.org',
        indexerUrl: 'https://indexer.ref-finance.net',
        sodakiApiUrl: 'https://sodaki.com/api',
        REF_FI_CONTRACT_ID:
          process.env.REF_FI_CONTRACT_ID || 'v2.ref-finance.near',
        WRAP_NEAR_CONTRACT_ID: process.env.WRAP_NEAR_CONTRACT_ID || 'wrap.near',
        REF_ADBOARD_CONTRACT_ID: 'ref-adboard.near',
        REF_FARM_CONTRACT_ID:
          process.env.REF_FARM_CONTRACT_ID || 'v2.ref-farming.near',
        REF_TOKEN_ID: 'token.ref-finance.near',
        REF_AIRDROP_CONTRACT_ID: 's01.ref-airdrop.near',
        POOL_TOKEN_REFRESH_INTERVAL:
          process.env.POOL_TOKEN_REFRESH_INTERVAL || 10,
      };
      /*
      console.log(`
      ==============================================================
      ENV TEST: 
      NEAR_ENV_TEST: ${process.env.NEAR_ENV_TEST || "not exists"}
      NEAR_ENV: ${process.env.NEAR_ENV || "not exists"}
      REF_FI_CONTRACT_ID: ${process.env.REF_FI_CONTRACT_ID || "not exists"}
      WRAP_NEAR_CONTRACT_ID: ${process.env.WRAP_NEAR_CONTRACT_ID || "not exists"}
      REF_ADBOARD_CONTRACT_ID: ${process.env.REF_ADBOARD_CONTRACT_ID || "not exists"}
      REF_FARM_CONTRACT_ID: ${process.env.REF_FARM_CONTRACT_ID || "not exists"}
      REF_TOKEN_ID: ${process.env.REF_TOKEN_ID || "not exists"}
      REF_AIRDROP_CONTRACT_ID: ${process.env.REF_AIRDROP_CONTRACT_ID || "not exists"}
      POOL_TOKEN_REFRESH_INTERVAL: ${process.env.POOL_TOKEN_REFRESH_INTERVAL || "not exists"}
      ==============================================================
      `);
      */
  
  switch (env) {
    case 'production':
    case 'mainnet':
      return testnetConfig;
    case 'development':
    case 'testnet':
      return testnetConfig;
    default:
      return testnetConfig;
  }
}

'''
'''--- src/services/creators/storage.ts ---
import BN from 'bn.js';
import {
  RefFiFunctionCallOptions,
  REF_FI_CONTRACT_ID,
  REF_FARM_CONTRACT_ID,
  wallet,
  refFiViewFunction,
} from '../near';

export const STORAGE_PER_TOKEN = '0.003';
export const STORAGE_TO_REGISTER_WITH_FT = '0.1';
export const STORAGE_TO_REGISTER_WITH_MFT = '0.1';
export const MIN_DEPOSIT_PER_TOKEN = new BN('3000000000000000000000');
export const MIN_DEPOSIT_PER_TOKEN_FARM = new BN('45000000000000000000000');
export const ONE_MORE_DEPOSIT_AMOUNT = '0.01';

interface StorageDepositActionOptions {
  accountId?: string;
  registrationOnly?: boolean;
  amount: string;
}
export const storageDepositAction = ({
  accountId = wallet.getAccountId(),
  registrationOnly = false,
  amount,
}: StorageDepositActionOptions): RefFiFunctionCallOptions => ({
  methodName: 'storage_deposit',
  args: {
    account_id: accountId,
    registration_only: registrationOnly,
  },
  amount,
});

export const storageDepositForTokenAction = (
  accountId: string = wallet.getAccountId()
): RefFiFunctionCallOptions =>
  storageDepositAction({
    accountId,
    amount: STORAGE_PER_TOKEN,
  });

export const storageDepositForFTAction = () =>
  storageDepositAction({
    accountId: REF_FI_CONTRACT_ID,
    amount: STORAGE_TO_REGISTER_WITH_FT,
  });

export const storageDepositForMFTAction = () =>
  storageDepositAction({
    accountId: REF_FARM_CONTRACT_ID,
    amount: STORAGE_TO_REGISTER_WITH_MFT,
  });

export const needDepositStorage = async (accountId = wallet.getAccountId()) => {
  const storage = await refFiViewFunction({
    methodName: 'get_user_storage_state',
    args: { account_id: accountId },
  });

  return new BN(storage?.deposit).lte(new BN(storage?.usage));
};

'''
'''--- src/services/creators/token.ts ---
import { ONE_YOCTO_NEAR } from '../near';

interface WithdrawActionOptions {
  tokenId: string;
  amount: string;
  unregister?: boolean;
}
export const withdrawAction = ({
  tokenId,
  amount,
  unregister = false,
}: WithdrawActionOptions) => ({
  methodName: 'withdraw',
  args: { token_id: tokenId, amount, unregister },
  gas: '100000000000000',
  amount: ONE_YOCTO_NEAR,
});

export const registerTokenAction = (tokenId: string) => ({
  methodName: 'register_tokens',
  args: { token_ids: [tokenId] },
  // amount: ONE_YOCTO_NEAR,
});

'''
'''--- src/services/farm.ts ---
import {
  refFarmFunctionCall,
  refFarmViewFunction,
  wallet,
  Transaction,
  executeFarmMultipleTransactions,
} from './near';
import { toPrecision, toReadableNumber } from '~utils/numbers';
import { LP_TOKEN_DECIMALS } from '~services/m-token';
import * as math from 'mathjs';
import {
  ftGetTokenMetadata,
  TokenMetadata,
  ftGetStorageBalance,
} from '~services/ft-contract';
import { PoolRPCView, currentTokensPrice } from '~services/api';
import { BigNumber } from 'bignumber.js';
import { getPoolsByIds } from '~services/indexer';
import {
  storageDepositAction,
  STORAGE_TO_REGISTER_WITH_MFT,
} from '../services/creators/storage';
import getConfig from './config';
const config = getConfig();
export const DEFAULT_PAGE_LIMIT = 100;

export interface Seed {
  seed_id: string;
  amount: number;
}

export interface Farm {
  farm_id: string;
  farm_kind: string;
  farm_status: string;
  seed_id: string;
  reward_token: string;
  start_at: number;
  reward_per_session: number;
  session_interval: number;
  total_reward: number;
  cur_round: number;
  last_round: number;
  claimed_reward: number;
  unclaimed_reward: number;
  current_user_reward: number;
}

export interface FarmInfo extends Farm {
  pool: PoolRPCView;
  lpTokenId: string;
  rewardNumber: string;
  userStaked: string;
  rewardsPerWeek: string;
  userRewardsPerWeek: string;
  userUnclaimedReward: string;
  rewardToken: TokenMetadata;
  totalStaked: number;
  apr: string;
  tokenIds: string[];
  show?: boolean;
  seedAmount: string;
}

export const getSeeds = async ({
  page = 1,
  perPage = DEFAULT_PAGE_LIMIT,
}: {
  page?: number;
  perPage?: number;
}): Promise<Record<string, string>> => {
  const index = (page - 1) * perPage;
  const seedDatas = await refFarmViewFunction({
    methodName: 'list_seeds',
    args: { from_index: index, limit: perPage },
  });

  return seedDatas;
};

export const getStakedListByAccountId = async ({
  accountId = wallet.getAccountId(),
}): Promise<Record<string, string>> => {
  const stakedList = await refFarmViewFunction({
    methodName: 'list_user_seeds',
    args: { account_id: accountId },
  });

  return stakedList;
};

export const getLPTokenId = (farm_id: string) => {
  return farm_id.slice(farm_id.indexOf('@') + 1, farm_id.lastIndexOf('#'));
};

export const getFarms = async ({
  page = 1,
  perPage = DEFAULT_PAGE_LIMIT,
  stakedList,
  rewardList,
  tokenPriceList,
  seeds,
}: {
  page?: number;
  perPage?: number;
  stakedList: Record<string, string>;
  rewardList: Record<string, string>;
  tokenPriceList: any;
  seeds: Record<string, string>;
}): Promise<FarmInfo[]> => {
  const index = (page - 1) * perPage;
  const farms: Farm[] = await refFarmViewFunction({
    methodName: 'list_farms',
    args: { from_index: index, limit: perPage },
  });
  const pool_ids = farms.map((f) => {
    return getLPTokenId(f.farm_id);
  });

  let poolList: Record<string, PoolRPCView> = {};
  const pools = await getPoolsByIds({ pool_ids });
  if (pools) {
    poolList = pools.reduce(
      (obj: any, pool: any) => ({ ...obj, [pool.id]: pool }),
      {}
    );
  }

  const tasks = farms.map(async (f) => {
    const pool: PoolRPCView =
      Object.keys(poolList).length === 0
        ? {
            id: 0,
            token_account_ids: ['', ''],
            token_symbols: ['', ''],
            amounts: ['', ''],
            total_fee: 0,
            shares_total_supply: '0',
            tvl: 0,
            token0_ref_price: '0',
            share: '0',
          }
        : poolList[getLPTokenId(f.farm_id)];

    const fi: FarmInfo = await getFarmInfo(
      f,
      pool,
      stakedList[f.seed_id],
      tokenPriceList,
      rewardList[f.reward_token],
      seeds[f.seed_id],
      getLPTokenId(f.farm_id)
    );
    return fi;
  });

  return Promise.all(tasks);
};

export const getFarmInfo = async (
  farm: Farm,
  pool: PoolRPCView,
  staked: string,
  tokenPriceList: any,
  reward: string,
  seed: string,
  lpTokenId: string
): Promise<FarmInfo> => {
  const isSignedIn: boolean = wallet.isSignedIn();
  const { shares_total_supply, tvl, token_account_ids } = pool;
  const poolTvl = tvl;
  const poolSts = Number(toReadableNumber(24, shares_total_supply));
  const userStaked = toReadableNumber(LP_TOKEN_DECIMALS, staked ?? '0');
  const rewardToken = await ftGetTokenMetadata(farm.reward_token);
  const rewardTokenPrice = tokenPriceList
    ? tokenPriceList[rewardToken.id]?.price || 0
    : 0;
  const rewardNumber = toReadableNumber(rewardToken.decimals, reward) ?? '0';
  const seedAmount = seed ?? '0';
  const totalSeed = toReadableNumber(LP_TOKEN_DECIMALS, seedAmount);

  const rewardNumberPerWeek = math.round(
    math.evaluate(
      `(${farm.reward_per_session} / ${farm.session_interval}) * 604800`
    )
  );

  const rewardsPerWeek = toPrecision(
    toReadableNumber(
      rewardToken.decimals,
      new BigNumber(rewardNumberPerWeek.toString()).toFixed()
    ),
    0
  );

  const userRewardNumberPerWeek =
    seedAmount !== '0'
      ? math.round(
          math.evaluate(
            `${rewardNumberPerWeek} * (${staked ?? 0} / ${seedAmount})`
          )
        )
      : 0;

  const userRewardsPerWeek = toReadableNumber(
    rewardToken.decimals,
    userRewardNumberPerWeek.toString()
  );

  let userUnclaimedRewardNumber: string = isSignedIn
    ? await getUnclaimedReward(farm.farm_id)
    : '0';
  // const userUnclaimedReward = toPrecision(
  //   toReadableNumber(rewardToken.decimals, userUnclaimedRewardNumber),
  //   2
  // );
  const userUnclaimedReward = toReadableNumber(
    rewardToken.decimals,
    userUnclaimedRewardNumber
  );

  const totalStaked =
    poolSts === 0
      ? 0
      : Number(
          toPrecision(((Number(totalSeed) * poolTvl) / poolSts).toString(), 1)
        );

  const apr =
    totalStaked === 0
      ? '0'
      : toPrecision(
          (
            (1 / totalStaked) *
            (Number(rewardsPerWeek) * Number(rewardTokenPrice)) *
            52 *
            100
          ).toString(),
          2
        );

  if (farm.farm_status === 'Created') farm.farm_status = 'Pending';

  return {
    ...farm,
    pool,
    lpTokenId,
    rewardNumber,
    userStaked,
    rewardsPerWeek,
    userRewardsPerWeek,
    userUnclaimedReward,
    rewardToken,
    totalStaked,
    apr,
    tokenIds: token_account_ids,
    seedAmount,
  };
};

export const getUnclaimedFarms = async ({
  page = 1,
  perPage = DEFAULT_PAGE_LIMIT,
  stakedList,
  rewardList,
  tokenPriceList,
  seeds,
}: {
  page?: number;
  perPage?: number;
  stakedList: Record<string, string>;
  rewardList: Record<string, string>;
  tokenPriceList: any;
  seeds: Record<string, string>;
}): Promise<FarmInfo[]> => {
  const isSignedIn = wallet.isSignedIn();
  let farms: FarmInfo[] = await getFarms({
    page,
    perPage,
    stakedList,
    rewardList,
    tokenPriceList,
    seeds,
  });
  await Promise.all(
    farms.map(async (farm: any, i: number) => {
      const current_user_reward = isSignedIn
        ? await getUnclaimedReward(farm.farm_id)
        : 0;
      farms[i].current_user_reward = current_user_reward;
    })
  );

  return farms.filter((farm) => {
    return Number(farm.current_user_reward) > 0;
  });
};

export const getFarmsBySeedId = async (seed_id: number): Promise<Farm[]> => {
  const farms: Farm[] = await refFarmViewFunction({
    methodName: 'list_farms_by_seed',
    args: { seed_id: seed_id },
  });

  return farms;
};

export const getFarm = async (id: number): Promise<Farm> => {
  return refFarmViewFunction({
    methodName: 'get_farm',
    args: { farm_id: id },
  });
};

export const getRewards = async ({
  accountId = wallet.getAccountId(),
}): Promise<any> => {
  return refFarmViewFunction({
    methodName: 'list_rewards',
    args: { account_id: accountId },
  });
};

export const getRewardByTokenId = async (
  token_id: string,
  accountId = wallet.getAccountId()
): Promise<any> => {
  return refFarmViewFunction({
    methodName: 'get_reward',
    args: { account_id: accountId, token_id: token_id },
  });
};

export const getUnclaimedReward = async (
  farm_id: string,
  accountId = wallet.getAccountId()
): Promise<any> => {
  return refFarmViewFunction({
    methodName: 'get_unclaimed_reward',
    args: { account_id: accountId, farm_id: farm_id },
  });
};

export const listRewards = async (
  accountId = wallet.getAccountId()
): Promise<any> => {
  return refFarmViewFunction({
    methodName: 'list_rewards',
    args: { account_id: accountId },
  });
};

export const claimRewardByFarm = async (farm_id: string): Promise<any> => {
  return refFarmFunctionCall({
    methodName: 'claim_reward_by_farm',
    args: { farm_id: farm_id },
  });
};

export const claimRewardBySeed = async (seed_id: string): Promise<any> => {
  return refFarmFunctionCall({
    methodName: 'claim_reward_by_seed',
    args: { seed_id: seed_id },
  });
};

export const getAllSinglePriceByTokenIds = async (
  token_ids: string
): Promise<any> => {
  return await currentTokensPrice(token_ids);
};

export const claimAndWithDrawReward = async (
  farmsData: any[]
): Promise<any> => {
  const token_ids: string[] = [];
  const transactions: Transaction[] = [];
  const ftBalanceListPromise: any[] = [];
  farmsData.forEach((farm) => {
    const { userUnclaimedReward, rewardToken } = farm;
    if (Number(userUnclaimedReward) > 0) {
      token_ids.push(rewardToken.id);
    }
  });
  token_ids.forEach((tokenId) => {
    ftBalanceListPromise.push(ftGetStorageBalance(tokenId));
  });
  const ftBalanceList = await Promise.all(ftBalanceListPromise);
  ftBalanceList.forEach((balance, index) => {
    if (!balance || balance.total === '0') {
      transactions.unshift({
        receiverId: token_ids[index],
        functionCalls: [
          storageDepositAction({
            registrationOnly: true,
            amount: STORAGE_TO_REGISTER_WITH_MFT,
          }),
        ],
      });
    }
  });
  if (farmsData.length > 1) {
    transactions.push({
      receiverId: config.REF_FARM_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'claim_and_withdraw_by_seed',
          args: { seed_id: farmsData[0]['seed_id'] },
        },
      ],
    });
  } else {
    transactions.push({
      receiverId: config.REF_FARM_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'claim_and_withdraw_by_farm',
          args: { farm_id: farmsData[0]['farm_id'], withdraw_all_tokens: true },
        },
      ],
    });
  }
  return executeFarmMultipleTransactions(transactions);
};

'''
'''--- src/services/ft-contract.ts ---
import {
  RefFiFunctionCallOptions,
  wallet,
  getGas,
  getAmount,
  RefFiViewFunctionOptions,
} from './near';
import metadataDefaults from '../utils/metadata';
import { storageDepositForFTAction } from './creators/storage';
import db from '../store/RefDatabase';

export const NEAR_ICON =
  'https://near.org/wp-content/themes/near-19/assets/img/brand-icon.png';
const BANANA_ID = 'berryclub.ek.near';
const CHEDDAR_ID = 'token.cheddar.near';
const CUCUMBER_ID = 'farm.berryclub.ek.near';
const HAPI_ID = 'd9c2d319cd7e6177336b0a9c93c21cb48d84fb54.factory.bridge.near';

export const ftFunctionCall = (
  tokenId: string,
  { methodName, args, gas, amount }: RefFiFunctionCallOptions
) => {
  return wallet
    .account()
    .functionCall(tokenId, methodName, args, getGas(gas), getAmount(amount));
};

export const ftViewFunction = (
  tokenId: string,
  { methodName, args }: RefFiViewFunctionOptions
) => {
  return wallet.account().viewFunction(tokenId, methodName, args);
};

export const ftGetBalance = (tokenId: string) => {
  return ftViewFunction(tokenId, {
    methodName: 'ft_balance_of',
    args: { account_id: wallet.getAccountId() },
  });
};

export interface FTStorageBalance {
  total: string;
  available: string;
}
export const ftGetStorageBalance = (
  tokenId: string,
  accountId = wallet.getAccountId()
): Promise<FTStorageBalance | null> => {
  return ftViewFunction(tokenId, {
    methodName: 'storage_balance_of',
    args: { account_id: accountId },
  });
};

export interface TokenMetadata {
  id: string;
  name: string;
  symbol: string;
  decimals: number;
  icon: string;
  ref?: number;
  near?: number;
  total?: number;
  amountLabel?: string;
  amount?: number;
}
export const ftGetTokenMetadata = async (
  id: string
): Promise<TokenMetadata> => {
  try {
    let metadata = await db.allTokens().where({ id: id }).first();
    if (!metadata) {
      metadata = await ftViewFunction(id, {
        methodName: 'ft_metadata',
      });
    }
    if (!metadata?.id) {
        metadata.id = id;
    }
    if (
      !metadata.icon ||
      metadata.icon === NEAR_ICON ||
      metadata.id === BANANA_ID ||
      metadata.id === 'banana.ft-fin.testnet' ||
      metadata.id === CHEDDAR_ID ||
      metadata.id === CUCUMBER_ID ||
      metadata.id === HAPI_ID
    ) {
      metadata.icon = metadataDefaults[id];
    }
    return {
      id,
      ...metadata,
    };
  } catch (err) {
    return {
      id,
      name: id,
      symbol: id?.split('.')[0].slice(0, 8),
      decimals: 6,
      icon: null,
    };
  }
};

export const ftRegisterExchange = async (tokenId: string) => {
  return ftFunctionCall(tokenId, storageDepositForFTAction());
};

'''
'''--- src/services/indexer.ts ---
import getConfig from './config';
import { wallet } from './near';
import _ from 'lodash';
import { parsePoolView, PoolRPCView } from './api';
import moment from 'moment/moment';
import { parseAction } from '~services/transaction';
import { volumeType, TVLType } from '~state/pool';

const config = getConfig();

export const getPoolMonthVolume = async (
  pool_id: string
): Promise<volumeType[]> => {
  return await fetch(config.sodakiApiUrl + `/pool/${pool_id}/volume`, {
    method: 'GET',
  })
    .then((res) => res.json())
    .then((monthVolume) => {
      return monthVolume.slice(0, 60);
    });
};

export const getPoolMonthTVL = async (pool_id: string): Promise<TVLType[]> => {
  return await fetch(config.sodakiApiUrl + `/pool/${pool_id}/tvl`, {
    method: 'GET',
  })
    .then((res) => res.json())
    .then((monthTVL) => {
      return monthTVL.slice(0, 60);
    });
};

export const get24hVolume = async (pool_id: string): Promise<string> => {
  return await fetch(
    config.sodakiApiUrl + `/pool/${pool_id}/rolling24hvolume/sum`,
    {
      method: 'GET',
    }
  )
    .then((res) => res.json())
    .then((monthTVL) => {
      return monthTVL.toString();
    });
};

const parseActionView = async (action: any) => {
  const data = await parseAction(action[3], action[4], action[2]);
  return {
    datetime: moment.unix(action[0] / 1000000000),
    txUrl: config.explorerUrl + '/transactions/' + action[1],
    data: data,
    // status: action[5] === 'SUCCESS_VALUE',
    status: action[6] && action[6].indexOf('SUCCESS') > -1,
  };
};

export const getYourPools = async (): Promise<PoolRPCView[]> => {
  return await fetch(
    config.indexerUrl + '/liquidity-pools/' + wallet.getAccountId(),
    {
      method: 'GET',
      headers: { 'Content-type': 'application/json; charset=UTF-8' },
    }
  )
    .then((res) => res.json())
    .then((pools) => {
      return pools;
    });
};

export const getTopPools = async (args: any): Promise<PoolRPCView[]> => {
  return fetch(config.indexerUrl + '/list-top-pools', {
    method: 'GET',
    headers: { 'Content-type': 'application/json; charset=UTF-8' },
  })
    .then((res) => res.json())
    .then((pools) => {
      pools = pools.map((pool: any) => parsePoolView(pool));
      return _order(args, _search(args, pools));
    })
    .catch(() => {
      return [];
    });
};

export const getPool = async (pool_id: string): Promise<PoolRPCView> => {
  return await fetch(config.indexerUrl + '/get-pool?pool_id=' + pool_id, {
    method: 'GET',
    headers: { 'Content-type': 'application/json; charset=UTF-8' },
  })
    .then((res) => res.json())
    .then((pool) => {
      return parsePoolView(pool);
    });
};

export const getPoolsByIds = async ({
  pool_ids,
}: {
  pool_ids: string[];
}): Promise<PoolRPCView[]> => {
  const ids = pool_ids.join('|');
  return fetch(config.indexerUrl + '/list-pools-by-ids?ids=' + ids, {
    method: 'GET',
    headers: { 'Content-type': 'application/json; charset=UTF-8' },
  })
    .then((res) => res.json())
    .then((pools) => {
      pools = pools.map((pool: any) => parsePoolView(pool));
      return pools;
    })
    .catch(() => {
      return [];
    });
};

export const getTokenPriceList = async (): Promise<any> => {
  return await fetch(config.indexerUrl + '/list-token-price', {
    method: 'GET',
    headers: { 'Content-type': 'application/json; charset=UTF-8' },
  })
    .then((res) => res.json())
    .then((list) => {
      return list;
    });
};

const _search = (args: any, pools: PoolRPCView[]) => {
  if (args.tokenName === '') return pools;
  return _.filter(pools, (pool: PoolRPCView) => {
    return (
      _.includes(
        pool.token_symbols[0].toLowerCase(),
        args.tokenName.toLowerCase()
      ) ||
      _.includes(
        pool.token_symbols[1].toLowerCase(),
        args.tokenName.toLowerCase()
      )
    );
  });
};

const _order = (args: any, pools: PoolRPCView[]) => {
  let column = args.column || 'tvl';
  let order = args.order || 'desc';
  column = args.column === 'fee' ? 'total_fee' : column;
  return _.orderBy(pools, [column], [order]);
};

const _pagination = (args: any, pools: PoolRPCView[]) => {
  return _.slice(
    pools,
    (args.page - 1) * args.perPage,
    args.page * args.perPage
  );
};

export type ActionData = Awaited<ReturnType<typeof parseActionView>>;

type Awaited<T> = T extends Promise<infer P> ? P : never;

export const getLatestActions = async (): Promise<Array<ActionData>> => {
  return await fetch(
    config.indexerUrl + '/latest-actions/' + wallet.getAccountId(),
    {
      method: 'GET',
      headers: { 'Content-type': 'application/json; charset=UTF-8' },
    }
  )
    .then((res) => res.json())
    .then((items) => {
      const tasks = items.map(async (item: any) => await parseActionView(item));

      return Promise.all(tasks);
    });
};

'''
'''--- src/services/m-token.ts ---
import BN from 'bn.js';
import * as math from 'mathjs';
import {
  ONE_YOCTO_NEAR,
  Transaction,
  executeFarmMultipleTransactions,
  REF_FI_CONTRACT_ID,
  REF_FARM_CONTRACT_ID,
  wallet,
} from '../services/near';
import { ftGetStorageBalance, TokenMetadata } from '../services/ft-contract';
import { toNonDivisibleNumber } from '~utils/numbers';
import {
  ACCOUNT_MIN_STORAGE_AMOUNT,
  currentStorageBalanceOfFarm,
} from '../services/account';
import {
  MIN_DEPOSIT_PER_TOKEN,
  storageDepositAction,
  STORAGE_PER_TOKEN,
  STORAGE_TO_REGISTER_WITH_MFT,
  MIN_DEPOSIT_PER_TOKEN_FARM,
} from '../services/creators/storage';
import { WRAP_NEAR_CONTRACT_ID } from '~services/wrap-near';
import { utils } from 'near-api-js';

export const LP_TOKEN_DECIMALS = 24;
export const FARM_STORAGE_BALANCE = '0.045';

export const checkTokenNeedsStorageDeposit = async (page?: string) => {
  let storageNeeded: math.MathType = 0;
  const balance = await currentStorageBalanceOfFarm(wallet.getAccountId());

  if (!balance) {
    storageNeeded = math.add(storageNeeded, Number(ACCOUNT_MIN_STORAGE_AMOUNT));
  }
  if (page && page == 'farm') {
    if (new BN(balance?.available || '0').lt(MIN_DEPOSIT_PER_TOKEN_FARM)) {
      storageNeeded = math.add(storageNeeded, Number(FARM_STORAGE_BALANCE));
    }
  } else {
    if (new BN(balance?.available || '0').lt(MIN_DEPOSIT_PER_TOKEN)) {
      storageNeeded = math.add(storageNeeded, Number(STORAGE_PER_TOKEN));
    }
  }
  return storageNeeded ? storageNeeded.toString() : '';
};

interface StakeOptions {
  token_id: string;
  amount: string;
  msg?: string;
}

export const stake = async ({ token_id, amount, msg = '' }: StakeOptions) => {
  const transactions: Transaction[] = [
    {
      receiverId: REF_FI_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'mft_transfer_call',
          args: {
            receiver_id: REF_FARM_CONTRACT_ID,
            token_id: token_id,
            amount: toNonDivisibleNumber(LP_TOKEN_DECIMALS, amount),
            msg,
          },
          amount: ONE_YOCTO_NEAR,
          gas: '180000000000000',
        },
      ],
    },
  ];

  const neededStorage = await checkTokenNeedsStorageDeposit('farm');
  if (neededStorage) {
    transactions.unshift({
      receiverId: REF_FARM_CONTRACT_ID,
      functionCalls: [storageDepositAction({ amount: FARM_STORAGE_BALANCE })],
    });
  }

  return executeFarmMultipleTransactions(transactions);
};

interface UnstakeOptions {
  seed_id: string;
  amount: string;
  msg?: string;
}
export const unstake = async ({
  seed_id,
  amount,
  msg = '',
}: UnstakeOptions) => {
   
  const transactions: Transaction[] = [
    {
      receiverId: REF_FARM_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'withdraw_seed',
          args: {
            seed_id: seed_id,
            amount: toNonDivisibleNumber(LP_TOKEN_DECIMALS, amount),
            msg,
          },
          amount: ONE_YOCTO_NEAR,
          gas: '200000000000000',
        },
      ],
    },
  ];

  const neededStorage = await checkTokenNeedsStorageDeposit('farm');
  if (neededStorage) {
    transactions.unshift({
      receiverId: REF_FARM_CONTRACT_ID,
      functionCalls: [storageDepositAction({ amount: FARM_STORAGE_BALANCE })],
    });
  }

  return executeFarmMultipleTransactions(transactions);
};

interface WithdrawOptions {
  token_id: string;
  amount: string;
  token: TokenMetadata;
  unregister?: boolean;
}

export const withdrawReward = async ({
  token_id,
  amount,
  token,
  unregister = false,
}: WithdrawOptions) => {
  const transactions: Transaction[] = [];

  const parsedAmount = toNonDivisibleNumber(token.decimals, amount);
  const ftBalance = await ftGetStorageBalance(token_id);

  if (!ftBalance || ftBalance.total === '0') {
    transactions.unshift({
      receiverId: token_id,
      functionCalls: [
        storageDepositAction({
          registrationOnly: true,
          amount: STORAGE_TO_REGISTER_WITH_MFT,
        }),
      ],
    });
  }

  transactions.push({
    receiverId: REF_FARM_CONTRACT_ID,
    functionCalls: [
      {
        methodName: 'withdraw_reward',
        args: { token_id: token_id, amount: parsedAmount, unregister },
        gas: '100000000000000',
        amount: ONE_YOCTO_NEAR,
      },
    ],
  });

  if (token_id === WRAP_NEAR_CONTRACT_ID) {
    transactions.push({
      receiverId: WRAP_NEAR_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'near_withdraw',
          args: { amount: utils.format.parseNearAmount(amount) },
          amount: ONE_YOCTO_NEAR,
        },
      ],
    });
  }

  return executeFarmMultipleTransactions(transactions);
};

export const withdrawAllReward = async (
  checkedList: Record<string, any>,
  unregister = false
) => {
// console.log("withdrawAllReward(checkedList): ",checkedList);
   // return;
  const transactions: Transaction[] = [];
  const token_id_list = Object.keys(checkedList);
  const ftBalancePromiseList: any[] = [];
  const functionCalls: any[] = [];
  token_id_list.forEach((token_id) => {
    const ftBalance = ftGetStorageBalance(token_id);
    ftBalancePromiseList.push(ftBalance);
    functionCalls.push({
      methodName: 'withdraw_reward',
      args: {
        token_id: token_id,
        amount: checkedList[token_id].value,
        unregister,
      },
      gas: '40000000000000',
      amount: ONE_YOCTO_NEAR,
    });
  });
  const resolvedBalanceList = await Promise.all(ftBalancePromiseList);
  resolvedBalanceList.forEach((ftBalance, index) => {
    if (!ftBalance || ftBalance.total === '0') {
      transactions.unshift({
        receiverId: token_id_list[index],
        functionCalls: [
          storageDepositAction({
            registrationOnly: true,
            amount: STORAGE_TO_REGISTER_WITH_MFT,
          }),
        ],
      });
    }
  });

  transactions.push({
    receiverId: REF_FARM_CONTRACT_ID,
    functionCalls,
  });
  return executeFarmMultipleTransactions(transactions);
};

'''
'''--- src/services/mft-contract.ts ---
import { wallet, refFiViewFunction } from './near';

export const mftGetBalance = async (
  token_id: string,
  accountId = wallet.getAccountId()
) => {
  return await refFiViewFunction({
    methodName: 'mft_balance_of',
    args: { account_id: accountId, token_id: token_id },
  });
};

export interface MFTStorageBalance {
  total: string;
  available: string;
}

export const mftGetStorageBalance = async (
  token_id: string,
  accountId = wallet.getAccountId()
): Promise<MFTStorageBalance | null> => {
  return await refFiViewFunction({
    methodName: 'storage_balance_of',
    args: { account_id: accountId },
  });
};

'''
'''--- src/services/near.ts ---
import { Near, keyStores, utils } from 'near-api-js';
import { functionCall } from 'near-api-js/lib/transaction';
import BN from 'bn.js';
import getConfig from './config';
import SpecialWallet from './SpecialWallet';

const config = getConfig();

export const REF_FI_CONTRACT_ID = config.REF_FI_CONTRACT_ID;

export const REF_ADBOARD_CONTRACT_ID = config.REF_ADBOARD_CONTRACT_ID;

export const REF_FARM_CONTRACT_ID = config.REF_FARM_CONTRACT_ID;

export const REF_AIRDRAOP_CONTRACT_ID = config.REF_AIRDROP_CONTRACT_ID;

export const REF_TOKEN_ID = config.REF_TOKEN_ID;

export const LP_STORAGE_AMOUNT = '0.01';

export const ONE_YOCTO_NEAR = '0.000000000000000000000001';

export const near = new Near({
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  ...config,
});
export const wallet = new SpecialWallet(near, config.REF_FI_CONTRACT_ID);

export const getGas = (gas: string) =>
  gas ? new BN(gas) : new BN('100000000000000');
export const getAmount = (amount: string) =>
  amount ? new BN(utils.format.parseNearAmount(amount)) : new BN('0');

export interface RefFiViewFunctionOptions {
  methodName: string;
  args?: object;
}

export interface RefFiFunctionCallOptions extends RefFiViewFunctionOptions {
  gas?: string;
  amount?: string;
}

export const refFiFunctionCall = ({
  methodName,
  args,
  gas,
  amount,
}: RefFiFunctionCallOptions) => {
  return wallet
    .account()
    .functionCall(
      REF_FI_CONTRACT_ID,
      methodName,
      args,
      getGas(gas),
      getAmount(amount)
    );
};

export const refFiViewFunction = ({
  methodName,
  args,
}: RefFiViewFunctionOptions) => {
  return wallet.account().viewFunction(REF_FI_CONTRACT_ID, methodName, args);
};

export const refFiManyFunctionCalls = (
  functionCalls: RefFiFunctionCallOptions[]
) => {
  const actions = functionCalls.map((fc) =>
    functionCall(fc.methodName, fc.args, getGas(fc.gas), getAmount(fc.amount))
  );

  return wallet
    .account()
    .sendTransactionWithActions(REF_FI_CONTRACT_ID, actions);
};

export interface Transaction {
  receiverId: string;
  functionCalls: RefFiFunctionCallOptions[];
}

export const executeMultipleTransactions = async (
  transactions: Transaction[],
  callbackUrl?: string
) => {
  const nearTransactions = await Promise.all(
    transactions.map((t, i) => {
      return wallet.createTransaction({
        receiverId: t.receiverId,
        nonceOffset: i + 1,
        actions: t.functionCalls.map((fc) =>
          functionCall(
            fc.methodName,
            fc.args,
            getGas(fc.gas),
            getAmount(fc.amount)
          )
        ),
      });
    })
  );

  return wallet.requestSignTransactions(nearTransactions, callbackUrl);
};

export const refFarmFunctionCall = ({
  methodName,
  args,
  gas,
  amount,
}: RefFiFunctionCallOptions) => {
    console.log({ 
        account: wallet.account(),
        REF_FARM_CONTRACT_ID,
        methodName,
        args,
        gas: getGas(gas),
        amount: getAmount(amount),
    });
   //  return;
  return wallet
    .account()
    .functionCall(
      REF_FARM_CONTRACT_ID,
      methodName,
      args,
      getGas(gas),
      getAmount(amount)
    );
};

export const refFarmViewFunction = ({
  methodName,
  args,
}: RefFiViewFunctionOptions) => {
  return wallet.account().viewFunction(REF_FARM_CONTRACT_ID, methodName, args);
};

export const refFarmManyFunctionCalls = (
  functionCalls: RefFiFunctionCallOptions[]
) => {
  const actions = functionCalls.map((fc) =>
    functionCall(fc.methodName, fc.args, getGas(fc.gas), getAmount(fc.amount))
  );

  return wallet
    .account()
    .sendTransactionWithActions(REF_FARM_CONTRACT_ID, actions);
};

export const executeFarmMultipleTransactions = async (
  transactions: Transaction[],
  callbackUrl?: string
) => {
  const nearTransactions = await Promise.all(
    transactions.map((t, i) => {
      return wallet.createTransaction({
        receiverId: t.receiverId,
        nonceOffset: i + 1,
        actions: t.functionCalls.map((fc) =>
          functionCall(
            fc.methodName,
            fc.args,
            getGas(fc.gas),
            getAmount(fc.amount)
          )
        ),
      });
    })
  );

  return wallet.requestSignTransactions(nearTransactions, callbackUrl);
};

'''
'''--- src/services/pool.ts ---
import {
  executeMultipleTransactions,
  LP_STORAGE_AMOUNT,
  ONE_YOCTO_NEAR,
  refFiFunctionCall,
  refFiViewFunction,
  REF_FI_CONTRACT_ID,
  Transaction,
  wallet,
  RefFiFunctionCallOptions,
  refFiManyFunctionCalls,
} from './near';
import BN from 'bn.js';
import db from '../store/RefDatabase';
import { ftGetStorageBalance, TokenMetadata } from './ft-contract';
import { toNonDivisibleNumber } from '../utils/numbers';
import {
  needDepositStorage,
  ONE_MORE_DEPOSIT_AMOUNT,
  storageDepositAction,
  storageDepositForFTAction,
} from './creators/storage';
import { getTopPools } from '~services/indexer';
import { PoolRPCView } from './api';
import { checkTokenNeedsStorageDeposit } from '~services/token';

export const DEFAULT_PAGE_LIMIT = 100;

export interface Pool {
  id: number;
  tokenIds: string[];
  supplies: { [key: string]: string };
  fee: number;
  shareSupply: string;
  tvl: number;
  token0_ref_price: string;
}

export const parsePool = (pool: PoolRPCView, id?: number): Pool => ({
  id: id >= 0 ? id : pool.id,
  tokenIds: pool.token_account_ids,
  supplies: pool.amounts.reduce(
    (acc: { [tokenId: string]: string }, amount: string, i: number) => {
      acc[pool.token_account_ids[i]] = amount;
      return acc;
    },
    {}
  ),
  fee: pool.total_fee,
  shareSupply: pool.shares_total_supply,
  tvl: pool.tvl,
  token0_ref_price: pool.token0_ref_price,
});

export const getPools = async ({
  page = 1,
  perPage = DEFAULT_PAGE_LIMIT,
  tokenName = '',
  column = '',
  order = 'desc',
  uniquePairName = false,
}: {
  page?: number;
  perPage?: number;
  tokenName?: string;
  column?: string;
  order?: string;
  uniquePairName?: boolean;
}): Promise<Pool[]> => {
  const poolData: PoolRPCView[] = await getTopPools({
    page,
    perPage,
    tokenName,
    column,
    order,
    uniquePairName,
  });
  if (poolData.length > 0) {
    return poolData.map((rawPool) => parsePool(rawPool));
  } else {
    const rows = await db.queryPools({
      page,
      perPage,
      tokenName,
      column,
      order,
      uniquePairName,
    });
    return rows.map((row) => ({
      id: row.id,
      tokenIds: [row.token1Id, row.token2Id],
      supplies: {
        [row.token1Id]: row.token1Supply,
        [row.token2Id]: row.token2Supply,
      },
      fee: row.fee,
      shareSupply: row.shares,
      tvl: 0,
      token0_ref_price: '0',
    }));
  }
};

export const getPoolsFromCache = async ({
  page = 1,
  perPage = DEFAULT_PAGE_LIMIT,
  tokenName = '',
  column = '',
  order = 'desc',
  uniquePairName = false,
}: {
  page?: number;
  perPage?: number;
  tokenName?: string;
  column?: string;
  order?: string;
  uniquePairName?: boolean;
}) => {
  const rows = await db.queryPools({
    page,
    perPage,
    tokenName,
    column,
    order,
    uniquePairName,
  });
  return rows.map((row) => ({
    id: row.id,
    tokenIds: [row.token1Id, row.token2Id],
    supplies: {
      [row.token1Id]: row.token1Supply,
      [row.token2Id]: row.token2Supply,
    },
    fee: row.fee,
    shareSupply: row.shares,
    tvl: 0,
    token0_ref_price: '0',
  }));
};

export const getPoolsFromIndexer = async ({
  page = 1,
  perPage = DEFAULT_PAGE_LIMIT,
  tokenName = '',
  column = '',
  order = 'desc',
  uniquePairName = false,
}: {
  page?: number;
  perPage?: number;
  tokenName?: string;
  column?: string;
  order?: string;
  uniquePairName?: boolean;
}): Promise<Pool[]> => {
  const poolData: PoolRPCView[] = await getTopPools({
    page,
    perPage,
    tokenName,
    column,
    order,
    uniquePairName,
  });

  return poolData.map((rawPool) => parsePool(rawPool));
};

export const getAllPoolsFromDb = async () => {
  return await db.allPools().toArray();
};

export const getAllWatchListFromDb = async ({
  account = wallet.getAccountId(),
}: {
  account?: string;
}) => {
  return await db
    .allWatchList()
    .where({
      account,
    })
    .toArray();
};

export const getWatchListFromDb = async ({
  pool_id,
  account = wallet.getAccountId(),
}: {
  pool_id: string;
  account?: string;
}) => {
  return await db
    .allWatchList()
    .where({
      pool_id,
      account,
    })
    .toArray();
};

export const addPoolToWatchList = async ({
  pool_id,
  account = wallet.getAccountId(),
}: {
  pool_id: string;
  account?: string;
}) => {
  return await db.watchList.put({
    id: account + '-' + pool_id,
    pool_id,
    account,
    update_time: new Date().getTime(),
  });
};
export const removePoolFromWatchList = async ({
  pool_id,
  account = wallet.getAccountId(),
}: {
  pool_id: string;
  account?: string;
}) => {
  return await db.watchList.delete(account + '-' + pool_id);
};

export const getCachedPoolsByTokenId = async ({
  token1Id,
  token2Id,
}: {
  token1Id: string;
  token2Id: string;
}) => {
  return await db
    .allPools()
    .where({
      token1Id,
      token2Id,
    })
    .toArray();
};

export const getTotalPools = () => {
  return refFiViewFunction({
    methodName: 'get_number_of_pools',
  });
};

export const getAllPools = async (
  page: number = 1,
  perPage: number = DEFAULT_PAGE_LIMIT
): Promise<Pool[]> => {
  const index = (page - 1) * perPage;
  const poolData: PoolRPCView[] = await refFiViewFunction({
    methodName: 'get_pools',
    args: { from_index: index, limit: perPage },
  });

  return poolData.map((rawPool, i) => parsePool(rawPool, i + index));
};

interface GetPoolOptions {
  tokenInId: string;
  tokenOutId: string;
  amountIn: string;
  setLoadingTrigger?: (loadingTrigger: boolean) => void;
  setLoadingData?: (loading: boolean) => void;
  loadingTrigger: boolean;
}

export const getPoolsByTokens = async ({
  tokenInId,
  tokenOutId,
  amountIn,
  setLoadingData,
  setLoadingTrigger,
  loadingTrigger,
}: GetPoolOptions): Promise<Pool[]> => {
  const amountToTrade = new BN(amountIn);
  let filtered_pools;
  const cache = await db.checkPoolsByTokens(tokenInId, tokenOutId);

  if (cache && !loadingTrigger) {
    const cache_pools = await db.getPoolsByTokens(tokenInId, tokenOutId);
    filtered_pools = cache_pools.filter(
      (p) =>
        new BN(p.supplies[tokenInId]).gte(amountToTrade) &&
        p.supplies[tokenOutId]
    );
  } else {
    setLoadingData(true);
    const totalPools = await getTotalPools();
    const pages = Math.ceil(totalPools / DEFAULT_PAGE_LIMIT);
    const pools = (
      await Promise.all([...Array(pages)].map((_, i) => getAllPools(i + 1)))
    ).flat();

    await db.cachePoolsByTokens(pools);
    filtered_pools = pools.filter(
      (p) =>
        new BN(p.supplies[tokenInId]).gte(amountToTrade) &&
        p.supplies[tokenOutId]
    );
  }
  setLoadingTrigger(false);
  setLoadingData(false);
  return filtered_pools;
};

export const getPool = async (id: number): Promise<Pool> => {
  return refFiViewFunction({
    methodName: 'get_pool',
    args: { pool_id: id },
  }).then((pool) => parsePool(pool, id));
};

interface PoolVolumes {
  [tokenId: string]: { input: string; output: string };
}

export type PoolDetails = Pool & { volumes: PoolVolumes };

export const getPoolDetails = async (id: number): Promise<PoolDetails> => {
  const [pool, volumes] = await Promise.all([
    getPool(id),
    refFiViewFunction({
      methodName: 'get_pool_volumes',
      args: { pool_id: id },
    }),
  ]);

  return {
    ...pool,
    volumes: pool.tokenIds.reduce((acc: PoolVolumes, tokenId, i) => {
      acc[tokenId] = volumes[i];
      return acc;
    }, {}),
  };
};

export const getPoolVolumes = async (id: number): Promise<PoolVolumes> => {
  return (await getPoolDetails(id)).volumes;
};

export const getSharesInPool = (id: number): Promise<string> => {
  return refFiViewFunction({
    methodName: 'get_pool_shares',
    args: { pool_id: id, account_id: wallet.getAccountId() },
  });
};

export const canFarm = async (
  pool_id: number,
  withEnded?: boolean
): Promise<Number> => {
  let farms;
  if (!withEnded) {
    farms = (await db.queryFarms()).filter((farm) => farm.status !== 'Ended');
  } else {
    farms = await db.queryFarms();
  }

  const count = farms.reduce((pre, cur) => {
    if (Number(cur.pool_id) === pool_id) return pre + 1;
    return pre;
  }, 0);

  return count;
};

interface AddLiquidityToPoolOptions {
  id: number;
  tokenAmounts: { token: TokenMetadata; amount: string }[];
}

export const addLiquidityToPool = async ({
  id,
  tokenAmounts,
}: AddLiquidityToPoolOptions) => {
  const amounts = tokenAmounts.map(({ token, amount }) =>
    toNonDivisibleNumber(token.decimals, amount)
  );

  const actions: RefFiFunctionCallOptions[] = [
    {
      methodName: 'add_liquidity',
      args: { pool_id: id, amounts },
      amount: LP_STORAGE_AMOUNT,
    },
  ];

  const needDeposit = await checkTokenNeedsStorageDeposit();
  if (needDeposit) {
    actions.unshift(
      storageDepositAction({
        amount: needDeposit,
      })
    );
  }

  return refFiManyFunctionCalls(actions);
};

interface RemoveLiquidityOptions {
  id: number;
  shares: string;
  minimumAmounts: { [tokenId: string]: string };
}
export const removeLiquidityFromPool = async ({
  id,
  shares,
  minimumAmounts,
}: RemoveLiquidityOptions) => {
  const pool = await getPool(id);

  const amounts = pool.tokenIds.map((tokenId) => minimumAmounts[tokenId]);

  const actions: RefFiFunctionCallOptions[] = [
    {
      methodName: 'remove_liquidity',
      args: {
        pool_id: id,
        shares,
        min_amounts: amounts,
      },
      amount: ONE_YOCTO_NEAR,
    },
  ];

  const needDeposit = await checkTokenNeedsStorageDeposit();
  if (needDeposit) {
    actions.unshift(
      storageDepositAction({
        amount: needDeposit,
      })
    );
  }

  return refFiManyFunctionCalls(actions);
};

export const addSimpleLiquidityPool = async (
  tokenIds: string[],
  fee: number
) => {
  const storageBalances = await Promise.all(
    tokenIds.map((id) => ftGetStorageBalance(id, REF_FI_CONTRACT_ID))
  );

  const transactions: Transaction[] = storageBalances
    .reduce((acc, sb, i) => {
      if (!sb || sb.total === '0') acc.push(tokenIds[i]);
      return acc;
    }, [])
    .map((id) => ({
      receiverId: id,
      functionCalls: [storageDepositForFTAction()],
    }));

  transactions.push({
    receiverId: REF_FI_CONTRACT_ID,
    functionCalls: [
      {
        methodName: 'add_simple_pool',
        args: { tokens: tokenIds, fee },
        amount: '0.05',
      },
    ],
  });

  return executeMultipleTransactions(
    transactions,
    `${window.location.origin}/pools/add`
  );
};

'''
'''--- src/services/swap.ts ---
import BN from 'bn.js';
import {
  toNonDivisibleNumber,
  toPrecision,
  toReadableNumber,
} from '../utils/numbers';
import {
  executeMultipleTransactions,
  near,
  ONE_YOCTO_NEAR,
  REF_FI_CONTRACT_ID,
  RefFiFunctionCallOptions,
  refFiManyFunctionCalls,
  Transaction,
  wallet,
} from './near';
import { ftGetStorageBalance, TokenMetadata } from './ft-contract';
import { getPoolsByTokens, Pool } from './pool';
import {
  checkTokenNeedsStorageDeposit,
  getTokenBalance,
  getWhitelistedTokens,
  round,
} from './token';
import { JsonRpcProvider } from 'near-api-js/lib/providers';
import {
  needDepositStorage,
  ONE_MORE_DEPOSIT_AMOUNT,
  storageDepositAction,
  storageDepositForTokenAction,
  STORAGE_TO_REGISTER_WITH_MFT,
} from './creators/storage';
import { registerTokenAction } from './creators/token';
import {
  NEW_ACCOUNT_STORAGE_COST,
  WRAP_NEAR_CONTRACT_ID,
  wnearMetadata,
} from '~services/wrap-near';
import { utils } from 'near-api-js';
import { BigNumber } from 'bignumber.js';

const FEE_DIVISOR = 10000;

interface EstimateSwapOptions {
  tokenIn: TokenMetadata;
  tokenOut: TokenMetadata;
  amountIn: string;
  intl?: any;
  setLoadingData?: (loading: boolean) => void;
  loadingTrigger?: boolean;
  setLoadingTrigger?: (loadingTrigger: boolean) => void;
}

export interface EstimateSwapView {
  estimate: string;
  pool: Pool;
  intl?: any;
}
export const estimateSwap = async ({
  tokenIn,
  tokenOut,
  amountIn,
  intl,
  setLoadingData,
  loadingTrigger,
  setLoadingTrigger,
}: EstimateSwapOptions): Promise<EstimateSwapView> => {
  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);
  if (!parsedAmountIn)
    throw new Error(
      `${amountIn} ${intl.formatMessage({ id: 'is_not_a_valid_swap_amount' })}`
    );

  const pools = await getPoolsByTokens({
    tokenInId: tokenIn.id,
    tokenOutId: tokenOut.id,
    amountIn: parsedAmountIn,
    setLoadingData,
    setLoadingTrigger,
    loadingTrigger,
  });

  if (pools.length < 1) {
    throw new Error(
      `${intl.formatMessage({ id: 'no_pool_available_to_make_a_swap_from' })} ${
        tokenIn.symbol
      } -> ${tokenOut.symbol} ${intl.formatMessage({
        id: 'for_the_amount',
      })} ${amountIn} ${intl.formatMessage({
        id: 'no_pool_eng_for_chinese',
      })}`
    );
  }

  try {
    const estimates = await Promise.all(
      pools.map((pool) => {
        const amount_with_fee = Number(amountIn) * (FEE_DIVISOR - pool.fee);
        const in_balance = toReadableNumber(
          tokenIn.decimals,
          pool.supplies[tokenIn.id]
        );
        const out_balance = toReadableNumber(
          tokenOut.decimals,
          pool.supplies[tokenOut.id]
        );
        const estimate = new BigNumber(
          (
            (amount_with_fee * Number(out_balance)) /
            (FEE_DIVISOR * Number(in_balance) + amount_with_fee)
          ).toString()
        ).toFixed();

        return Promise.resolve(estimate)
          .then((estimate) => ({
            estimate,
            status: 'success',
            pool,
          }))
          .catch(() => ({ status: 'error', estimate: '0', pool }));
      })
    );

    const { estimate, pool } = estimates
      .filter(({ status }) => status === 'success')
      .sort((a, b) => (Number(b.estimate) > Number(a.estimate) ? 1 : -1))[0];

    return {
      estimate: estimate,
      pool,
    };
  } catch (err) {
    throw new Error(
      `${intl.formatMessage({ id: 'no_pool_available_to_make_a_swap_from' })} ${
        tokenIn.symbol
      } -> ${tokenOut.symbol} ${intl.formatMessage({
        id: 'for_the_amount',
      })} ${amountIn} ${intl.formatMessage({
        id: 'no_pool_eng_for_chinese',
      })}`
    );
  }
};

interface SwapOptions extends EstimateSwapOptions {
  pool: Pool;
  minAmountOut: string;
}

interface InstantSwapOption extends SwapOptions {
  useNearBalance: boolean;
}

export const swap = async ({
  useNearBalance,
  pool,
  tokenIn,
  tokenOut,
  amountIn,
  minAmountOut,
}: InstantSwapOption) => {
    console.log("Swap: ",{
        pool,
        useNearBalance,
        tokenIn,
        tokenOut,
        amountIn,
        minAmountOut,
      });
      //return;
  if (pool) {
    if (useNearBalance) {
        console.log("ssssssssssssssssssssssssssssssss");
        /*
        {
        pool,
        tokenIn,
        tokenOut,
        amountIn:"33333",
        minAmountOut:"57000",
      }
        
        */
      await instantSwap({
        pool,
        tokenIn,
        tokenOut,
        amountIn,
        minAmountOut,
      });
    } else {
      await depositSwap({
        pool,
        tokenIn,
        tokenOut,
        amountIn,
        minAmountOut,
      });
    }
  }
};

export const instantSwap = async ({
  pool,
  tokenIn,
  tokenOut,
  amountIn,
  minAmountOut,
}: SwapOptions) => {
  const swapAction = {
    pool_id: pool?.id,
    token_in: tokenIn?.id,
    token_out: tokenOut?.id,
    min_amount_out: round(
      tokenIn.decimals,
      toNonDivisibleNumber(tokenOut.decimals, minAmountOut)
    ),
  };

  const transactions: Transaction[] = [];
  const tokenInActions: RefFiFunctionCallOptions[] = [];
  const tokenOutActions: RefFiFunctionCallOptions[] = [];

  if (wallet.isSignedIn()) {
    const tokenOutRegistered = await ftGetStorageBalance(
      tokenOut.id,
      wallet.getAccountId()
    ).catch(() => {
      throw new Error(`${tokenOut.id} doesn't exist.`);
    });

    if (!tokenOutRegistered || tokenOutRegistered.total === '0') {
      tokenOutActions.push({
        methodName: 'storage_deposit',
        args: {
          registration_only: true,
          account_id: wallet.getAccountId(),
        },
        gas: '30000000000000',
        amount: STORAGE_TO_REGISTER_WITH_MFT,
      });

      transactions.push({
        receiverId: tokenOut.id,
        functionCalls: tokenOutActions,
      });
    }

    tokenInActions.push({
      methodName: 'ft_transfer_call',
      args: {
        receiver_id: REF_FI_CONTRACT_ID,
        amount: toNonDivisibleNumber(tokenIn.decimals, amountIn),
        msg: JSON.stringify({
          force: 0,
          actions: [swapAction],
        }),
      },
      gas: '150000000000000',
      amount: ONE_YOCTO_NEAR,
    });

    transactions.push({
      receiverId: tokenIn.id,
      functionCalls: tokenInActions,
    });

    return executeMultipleTransactions(transactions);
  }
};

export const depositSwap = async ({
  pool,
  tokenIn,
  tokenOut,
  amountIn,
  minAmountOut,
}: SwapOptions) => {
  const swapAction = {
    pool_id: pool.id,
    token_in: tokenIn.id,
    token_out: tokenOut.id,
    amount_in: round(
      tokenIn.decimals,
      toNonDivisibleNumber(tokenIn.decimals, amountIn)
    ),
    min_amount_out: round(
      tokenIn.decimals,
      toNonDivisibleNumber(tokenOut.decimals, minAmountOut)
    ),
  };

  const actions: RefFiFunctionCallOptions[] = [
    {
      methodName: 'swap',
      args: { actions: [swapAction] },
      amount: ONE_YOCTO_NEAR,
    },
  ];

  const whitelist = await getWhitelistedTokens();
  if (!whitelist.includes(tokenOut.id)) {
    actions.unshift(registerTokenAction(tokenOut.id));
  }

  const neededStorage = await checkTokenNeedsStorageDeposit();
  if (neededStorage) {
    actions.unshift(storageDepositAction({ amount: neededStorage }));
  }

  return refFiManyFunctionCalls(actions);
};

export const checkTransaction = (txHash: string) => {
  return (near.connection.provider as JsonRpcProvider).sendJsonRpc(
    'EXPERIMENTAL_tx_status',
    [txHash, wallet.getAccountId()]
  );
};

'''
'''--- src/services/token.ts ---
import BN from 'bn.js';
import * as math from 'mathjs';
import {
  ONE_YOCTO_NEAR,
  refFiFunctionCall,
  RefFiFunctionCallOptions,
  refFiManyFunctionCalls,
  refFiViewFunction,
  Transaction,
  REF_FI_CONTRACT_ID,
  wallet,
  executeMultipleTransactions,
} from './near';
import { ftGetStorageBalance, TokenMetadata } from './ft-contract';
import { ACCOUNT_MIN_STORAGE_AMOUNT, currentStorageBalance } from './account';
import { toNonDivisibleNumber } from '../utils/numbers';
import {
  MIN_DEPOSIT_PER_TOKEN,
  STORAGE_TO_REGISTER_WITH_FT,
  storageDepositAction,
  storageDepositForFTAction,
  needDepositStorage,
  STORAGE_PER_TOKEN,
  ONE_MORE_DEPOSIT_AMOUNT,
} from './creators/storage';
import { unwrapNear, WRAP_NEAR_CONTRACT_ID } from './wrap-near';
import { registerTokenAction } from './creators/token';

export const checkTokenNeedsStorageDeposit = async () => {
  let storageNeeded: math.MathType = 0;

  const needDeposit = await needDepositStorage();
  if (needDeposit) {
    storageNeeded = Number(ONE_MORE_DEPOSIT_AMOUNT);
  } else {
    const balance = await Promise.resolve(
      currentStorageBalance(wallet.getAccountId())
    );

    if (!balance) {
      storageNeeded = math.add(
        storageNeeded,
        Number(ACCOUNT_MIN_STORAGE_AMOUNT)
      );
    }

    if (new BN(balance?.available || '0').lt(MIN_DEPOSIT_PER_TOKEN)) {
      storageNeeded = math.add(storageNeeded, Number(STORAGE_PER_TOKEN));
    }
  }

  return storageNeeded ? storageNeeded.toString() : '';
};

export const registerTokenAndExchange = async (tokenId: string) => {
  const transactions: Transaction[] = [];
  const actions: RefFiFunctionCallOptions[] = [
    {
      methodName: 'register_tokens',
      args: { token_ids: [tokenId] },
      amount: ONE_YOCTO_NEAR,
    },
  ];

  const neededStorage = await checkTokenNeedsStorageDeposit();

  if (neededStorage) {
    actions.unshift(storageDepositAction({ amount: neededStorage }));
  }

  transactions.push({
    receiverId: REF_FI_CONTRACT_ID,
    functionCalls: actions,
  });

  const exchangeBalanceAtFt = await ftGetStorageBalance(
    tokenId,
    REF_FI_CONTRACT_ID
  );
  if (!exchangeBalanceAtFt || exchangeBalanceAtFt.total === '0') {
    transactions.push({
      receiverId: tokenId,
      functionCalls: [storageDepositForFTAction()],
    });
  }

  return executeMultipleTransactions(transactions);
};

export const registerToken = async (tokenId: string) => {
  const registered = await ftGetStorageBalance(
    tokenId,
    REF_FI_CONTRACT_ID
  ).catch(() => {
    throw new Error(`${tokenId} doesn't exist.`);
  });
  if (!registered) throw new Error('No liquidity pools available for token');

  const actions: RefFiFunctionCallOptions[] = [registerTokenAction(tokenId)];

  const neededStorage = await checkTokenNeedsStorageDeposit();
  if (neededStorage) {
    actions.unshift(storageDepositAction({ amount: neededStorage }));
  }

  return refFiManyFunctionCalls(actions);
};

export const unregisterToken = async (tokenId: string) => {
  const actions: RefFiFunctionCallOptions[] = [
    {
      methodName: 'unregister_tokens',
      args: { token_ids: [tokenId] },
      amount: ONE_YOCTO_NEAR,
    },
  ];

  const neededStorage = await checkTokenNeedsStorageDeposit();

  if (neededStorage) {
    actions.unshift(storageDepositAction({ amount: neededStorage }));
  }

  return refFiManyFunctionCalls(actions);
};

interface DepositOptions {
  token: TokenMetadata;
  amount: string;
  msg?: string;
}

export const deposit = async ({ token, amount, msg = '' }: DepositOptions) => {
  const transactions: Transaction[] = [
    {
      receiverId: token.id,
      functionCalls: [
        {
          methodName: 'ft_transfer_call',
          args: {
            receiver_id: REF_FI_CONTRACT_ID,
            amount: toNonDivisibleNumber(token.decimals, amount),
            msg,
          },
          amount: ONE_YOCTO_NEAR,
          gas: '100000000000000',
        },
      ],
    },
  ];

  const neededStorage = await checkTokenNeedsStorageDeposit();
  if (neededStorage) {
    transactions.unshift({
      receiverId: REF_FI_CONTRACT_ID,
      functionCalls: [storageDepositAction({ amount: neededStorage })],
    });
  }

  return executeMultipleTransactions(transactions);
};

interface WithdrawOptions {
  token: TokenMetadata;
  amount: string;
  unregister?: boolean;
}

export const withdraw = async ({
  token,
  amount,
  unregister = false,
}: WithdrawOptions) => {
  if (token.id === WRAP_NEAR_CONTRACT_ID) {
    return unwrapNear(amount);
  }

  const transactions: Transaction[] = [];
  const parsedAmount = toNonDivisibleNumber(token.decimals, amount);
  const ftBalance = await ftGetStorageBalance(token.id);

  transactions.unshift({
    receiverId: REF_FI_CONTRACT_ID,
    functionCalls: [
      {
        methodName: 'withdraw',
        args: { token_id: token.id, amount: parsedAmount, unregister },
        gas: '100000000000000',
        amount: ONE_YOCTO_NEAR,
      },
    ],
  });

  if (!ftBalance || ftBalance.total === '0') {
    transactions.unshift({
      receiverId: token.id,
      functionCalls: [
        storageDepositAction({
          registrationOnly: true,
          amount: STORAGE_TO_REGISTER_WITH_FT,
        }),
      ],
    });
  }

  const neededStorage = await checkTokenNeedsStorageDeposit();
  if (neededStorage) {
    transactions.unshift({
      receiverId: REF_FI_CONTRACT_ID,
      functionCalls: [storageDepositAction({ amount: neededStorage })],
    });
  }

  return executeMultipleTransactions(transactions);
};

export interface TokenBalancesView {
  [tokenId: string]: string;
}

export const getTokenBalances = (): Promise<TokenBalancesView> => {
  return refFiViewFunction({
    methodName: 'get_deposits',
    args: { account_id: wallet.getAccountId() },
  });
};

export const getTokenBalance = (tokenId: string): Promise<number> => {
  return refFiViewFunction({
    methodName: 'get_deposit',
    args: { account_id: wallet.getAccountId(), token_id: tokenId },
  });
};

export const getUserRegisteredTokens = (
  accountId: string = wallet.getAccountId()
): Promise<string[]> => {
  return refFiViewFunction({
    methodName: 'get_user_whitelisted_tokens',
    args: { account_id: accountId },
  });
};

export const getWhitelistedTokens = async (): Promise<string[]> => {
  let userWhitelist = [];
  const globalWhitelist = await refFiViewFunction({
    methodName: 'get_whitelisted_tokens',
  });
  if (wallet.isSignedIn()) {
    userWhitelist = await refFiViewFunction({
      methodName: 'get_user_whitelisted_tokens',
      args: { account_id: wallet.getAccountId() },
    });
  }

  return [...new Set<string>([...globalWhitelist, ...userWhitelist])];
};

export const round = (decimals: number, minAmountOut: string) => {
  return Number.isInteger(Number(minAmountOut))
    ? minAmountOut
    : Math.ceil(
        Math.round(Number(minAmountOut) * Math.pow(10, decimals)) /
          Math.pow(10, decimals)
      ).toString();
};

'''
'''--- src/services/transaction.ts ---
import { ftGetTokenMetadata, TokenMetadata } from '~services/ft-contract';
import { toReadableNumber } from '~utils/numbers';
import { getPoolDetails } from '~services/pool';
import { useIntl } from 'react-intl';

export const parseAction = async (
  methodName: string,
  params: any,
  tokenId?: string
) => {
  switch (methodName) {
    case 'swap': {
      return await parseSwap(params);
    }
    case 'withdraw': {
      return await parseWithdraw(params);
    }
    case 'register_tokens': {
      return parseRegisterTokens(params);
    }
    case 'add_liquidity': {
      return await parseAddLiquidity(params);
    }
    case 'remove_liquidity': {
      return await parseRemoveLiquidity(params);
    }
    case 'add_simple_pool': {
      return await parseAddSimplePool(params);
    }
    case 'storage_deposit': {
      return await parseStorageDeposit();
    }
    case 'mft_transfer_call': {
      return await parseMtfTransferCall(params);
    }
    case 'withdraw_seed': {
      return await parseWithdrawSeed(params);
    }
    case 'claim_reward_by_farm': {
      return await parseClaimRewardByFarm(params);
    }
    case 'claim_reward_by_seed': {
      return await parseClaimRewardBySeed(params);
    }
    case 'withdraw_reward': {
      return await parseWithdrawReward(params);
    }
    case 'near_deposit': {
      return await parseNearDeposit();
    }
    case 'ft_transfer_call': {
      return await parseFtTransferCall(params, tokenId);
    }
    case 'near_withdraw': {
      return await parseNearWithdraw(params);
    }
    default: {
      return await parseDefault();
    }
  }
};

const parseSwap = async (params: any) => {
  const in_token = await ftGetTokenMetadata(params.actions[0].token_in);
  const out_token = await ftGetTokenMetadata(params.actions[0].token_out);

  return {
    Action: 'Swap',
    'Pool Id': params.actions[0].pool_id,
    'Amount In': toReadableNumber(
      in_token.decimals,
      params.actions[0].amount_in
    ),
    'Min Amount Out': toReadableNumber(
      out_token.decimals,
      params.actions[0].min_amount_out
    ),
    'Token In': in_token.symbol,
    'Token Out': out_token.symbol,
  };
};

const parseWithdraw = async (params: any) => {
  const token = await ftGetTokenMetadata(params.token_id);

  return {
    Action: 'Withdraw',
    Amount: toReadableNumber(token.decimals, params.amount),
    Token: token.symbol,
    'Token Address': token.id,
  };
};

const parseRegisterTokens = (params: any) => {
  return {
    Action: 'Register Tokens',
    'Token Ids': params.token_ids.join(','),
  };
};

const parseAddLiquidity = async (params: any) => {
  const pool = await getPoolDetails(params.pool_id);
  const tokens = await Promise.all<TokenMetadata>(
    pool.tokenIds.map((id) => ftGetTokenMetadata(id))
  );

  return {
    Action: 'Add Liquidity',
    'Pool Id': params.pool_id,
    'Amount One': toReadableNumber(tokens[0].decimals, params.amounts[0]),
    'Amount Two': toReadableNumber(tokens[1].decimals, params.amounts[1]),
  };
};

const parseRemoveLiquidity = async (params: any) => {
  const pool = await getPoolDetails(params.pool_id);
  const tokens = await Promise.all<TokenMetadata>(
    pool.tokenIds.map((id) => ftGetTokenMetadata(id))
  );

  return {
    Action: 'Remove Liquidity',
    'Pool Id': params.pool_id,
    'Amount One': toReadableNumber(tokens[0].decimals, params.min_amounts[0]),
    'Amount Two': toReadableNumber(tokens[1].decimals, params.min_amounts[1]),
    Shares: toReadableNumber(24, params.shares),
  };
};

const parseAddSimplePool = async (params: any) => {
  return {
    Action: 'Add Pool',
    Fee: params.fee,
    'Token One': params.tokens[0],
    'Token Two': params.tokens[1],
  };
};

const parseStorageDeposit = async () => {
  return {
    Action: 'Storage Deposit',
  };
};
const parseMtfTransferCall = async (params: any) => {
  const { amount, receiver_id, token_id } = params;
  return {
    Action: 'Stake',
    Amount: toReadableNumber(24, amount),
    'Receiver Id': receiver_id,
    'Token Id': token_id,
  };
};
const parseWithdrawSeed = async (params: any) => {
  const { seed_id, amount } = params;
  return {
    Action: 'Unstake',
    Amount: toReadableNumber(24, amount),
    'Seed Id': seed_id,
  };
};
const parseClaimRewardByFarm = async (params: any) => {
  const { farm_id } = params;
  return {
    Action: 'Claim reward by farm',
    'Farm Id': farm_id,
  };
};
const parseClaimRewardBySeed = async (params: any) => {
  const { seed_id } = params;
  return {
    Action: 'Claim reward by seed',
    'Seed Id': seed_id,
  };
};
const parseWithdrawReward = async (params: any) => {
  const { token_id, amount, unregister } = params;
  const token = await ftGetTokenMetadata(token_id);
  return {
    Action: 'Withdraw reward',
    Amount: toReadableNumber(token.decimals, amount),
    Unregister: unregister,
    'Token Id': token_id,
  };
};
const parseNearDeposit = async () => {
  return {
    Action: 'Near deposit',
  };
};
const parseFtTransferCall = async (params: any, tokenId: string) => {
  const { receiver_id, amount, msg } = params;
  let Action;
  let Amount;
  if (msg) {
    Action = 'Instant swap';
    const actions = JSON.parse(msg).actions[0];
    const { token_in } = actions;
    const token = await ftGetTokenMetadata(token_in);
    Amount = toReadableNumber(token.decimals, amount);
  } else {
    Action = 'Deposit';
    const token = await ftGetTokenMetadata(tokenId);
    Amount = toReadableNumber(token.decimals, amount);
  }
  return {
    Action,
    Amount,
    'Receiver Id': receiver_id,
  };
};
const parseNearWithdraw = async (params: any) => {
  const { amount } = params;
  return {
    Action: 'Near withdraw',
    Amount: toReadableNumber(24, amount),
  };
};

const parseDefault = async () => {
  return {
    Action: 'Not Found',
  };
};

'''
'''--- src/services/wrap-near.ts ---
import { utils } from 'near-api-js';
import getConfig from './config';
import { withdrawAction } from './creators/token';
import { ftGetStorageBalance, TokenMetadata } from './ft-contract';
import {
  executeMultipleTransactions,
  ONE_YOCTO_NEAR,
  RefFiFunctionCallOptions,
  REF_FI_CONTRACT_ID,
  Transaction,
  wallet,
} from './near';
import { checkTokenNeedsStorageDeposit } from './token';
import { storageDepositAction } from '../services/creators/storage';

export const { WRAP_NEAR_CONTRACT_ID } = getConfig();
export const NEW_ACCOUNT_STORAGE_COST = '0.00125';

export const wnearMetadata: TokenMetadata = {
  id: 'wNEAR',
  name: 'wNEAR',
  symbol: 'wNEAR',
  decimals: 24,
  icon: 'https://i.postimg.cc/4xx2KRxt/wNEAR.png',
};

export const nearMetadata: TokenMetadata = {
  id: 'NEAR',
  name: 'NEAR',
  symbol: 'NEAR',
  decimals: 24,
  icon: 'https://near.org/wp-content/themes/near-19/assets/img/brand-icon.png',
};

export const nearDeposit = async (amount: string) => {
  const transactions: Transaction[] = [
    {
      receiverId: WRAP_NEAR_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'near_deposit',
          args: {},
          gas: '50000000000000',
          amount,
        },
      ],
    },
  ];

  return executeMultipleTransactions(transactions);
};

export const nearWithdraw = async (amount: string) => {
  const transactions: Transaction[] = [
    {
      receiverId: WRAP_NEAR_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'near_withdraw',
          args: { amount: utils.format.parseNearAmount(amount) },
          amount: ONE_YOCTO_NEAR,
        },
      ],
    },
  ];

  return executeMultipleTransactions(transactions);
};

export const wrapNear = async (amount: string) => {
  const transactions: Transaction[] = [];
  const neededStorage = await checkTokenNeedsStorageDeposit();
  if (neededStorage) {
    transactions.push({
      receiverId: REF_FI_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'storage_deposit',
          args: {
            account_id: wallet.getAccountId(),
            registration_only: false,
          },
          gas: '30000000000000',
          amount: neededStorage,
        },
      ],
    });
  }

  const actions: RefFiFunctionCallOptions[] = [];
  const balance = await ftGetStorageBalance(WRAP_NEAR_CONTRACT_ID);

  if (!balance || balance.total === '0') {
    actions.push({
      methodName: 'storage_deposit',
      args: {},
      gas: '30000000000000',
      amount: NEW_ACCOUNT_STORAGE_COST,
    });
  }

  actions.push({
    methodName: 'near_deposit',
    args: {},
    gas: '50000000000000',
    amount,
  });

  actions.push({
    methodName: 'ft_transfer_call',
    args: {
      receiver_id: REF_FI_CONTRACT_ID,
      amount: utils.format.parseNearAmount(amount),
      msg: '',
    },
    gas: '50000000000000',
    amount: ONE_YOCTO_NEAR,
  });

  transactions.push({
    receiverId: WRAP_NEAR_CONTRACT_ID,
    functionCalls: actions,
  });

  return executeMultipleTransactions(transactions);
};

export const unwrapNear = async (amount: string) => {
  const transactions: Transaction[] = [];

  const balance = await ftGetStorageBalance(WRAP_NEAR_CONTRACT_ID);

  if (!balance || balance.total === '0') {
    transactions.push({
      receiverId: WRAP_NEAR_CONTRACT_ID,
      functionCalls: [
        {
          methodName: 'storage_deposit',
          args: {},
          gas: '30000000000000',
          amount: NEW_ACCOUNT_STORAGE_COST,
        },
      ],
    });
  }

  transactions.push({
    receiverId: REF_FI_CONTRACT_ID,
    functionCalls: [
      withdrawAction({
        tokenId: WRAP_NEAR_CONTRACT_ID,
        amount: utils.format.parseNearAmount(amount),
      }),
    ],
  });

  transactions.push({
    receiverId: WRAP_NEAR_CONTRACT_ID,
    functionCalls: [
      {
        methodName: 'near_withdraw',
        args: { amount: utils.format.parseNearAmount(amount) },
        amount: ONE_YOCTO_NEAR,
      },
    ],
  });

  const needDeposit = await checkTokenNeedsStorageDeposit();
  if (needDeposit) {
    transactions.unshift({
      receiverId: REF_FI_CONTRACT_ID,
      functionCalls: [storageDepositAction({ amount: needDeposit })],
    });
  }

  return executeMultipleTransactions(transactions);
};

'''
'''--- src/setupTests.js ---
const { REF_FI_CONTRACT_ID } = require('./services/near');
const { default: SpecialWallet } = require('./services/SpecialWallet');
const { WRAP_NEAR_CONTRACT_ID } = require('./services/wrap-near');

jest.mock('./services/SpecialWallet.ts');

expect.extend({
  toHaveTransaction(received, contractId, actions) {
    const matchedActions = SpecialWallet.transactions.mock.calls.reduce(
      (acc, [calledContractId, calledActions]) => {
        if (calledContractId === contractId) {
          acc.push(
            calledActions.map(({ functionCall }) => ({
              methodName: functionCall.methodName,
              args: JSON.parse(functionCall.args.toString()),
              gas: functionCall.gas.toString(),
              amount: functionCall.deposit.toString(),
            }))
          );
        }
        return acc;
      },
      []
    );

    if (matchedActions.length) expect(matchedActions).toContainEqual(actions);
    else expect(actions).toHaveLength(0);

    return { pass: true };
  },
});

beforeEach(() => {
  SpecialWallet.addView(REF_FI_CONTRACT_ID, 'get_user_whitelisted_tokens', [
    WRAP_NEAR_CONTRACT_ID,
    'nDAI',
    'nWETH',
  ]);

  SpecialWallet.addView(REF_FI_CONTRACT_ID, 'get_deposits', {
    nDAI: '50000000000000000',
    nWETH: '60000000000000000',
  });

  SpecialWallet.addView(REF_FI_CONTRACT_ID, 'get_pool', {
    token_account_ids: ['nDAI', 'nWETH'],
    amounts: ['10000000', '500000000000'],
    total_fee: '30',
    shares_total_supply: '2000000000000000000000000',
  });

  SpecialWallet.addView(REF_FI_CONTRACT_ID, 'get_pool_volumes', [0, 0]);
  SpecialWallet.addView(
    REF_FI_CONTRACT_ID,
    'get_pool_shares',
    '1000000000000000000000000'
  );

  SpecialWallet.addView(WRAP_NEAR_CONTRACT_ID, 'ft_metadata', {
    id: WRAP_NEAR_CONTRACT_ID,
    name: 'wrapped NEAR',
    symbol: 'wNEAR',
    decimals: 24,
  });

  SpecialWallet.addView(
    WRAP_NEAR_CONTRACT_ID,
    'ft_balance_of',
    '100000000000000000000000000'
  );

  SpecialWallet.addView(WRAP_NEAR_CONTRACT_ID, 'storage_balance_of', {
    total: '0',
    available: '0',
  });

  SpecialWallet.addView('nDAI', 'ft_metadata', {
    id: 'nDAI',
    name: 'NEAR wrapped DAI',
    symbol: 'nDAI',
    decimals: 6,
  });

  SpecialWallet.addView('nDAI', 'ft_balance_of', '10000000');

  SpecialWallet.addView('nDAI', 'storage_balance_of', {
    total: '0',
    available: '0',
  });

  SpecialWallet.addView('nWETH', 'ft_metadata', {
    id: 'nWETH',
    name: 'NEAR wrapped ETH',
    symbol: 'nWETH',
    decimals: 10,
  });

  SpecialWallet.addView('nWETH', 'ft_balance_of', '50000000000');

  SpecialWallet.addView('nWETH', 'storage_balance_of', {
    total: '0',
    available: '0',
  });
});

afterEach(() => {
  jest.clearAllMocks();
});

'''
'''--- src/state/account.ts ---
import { useEffect, useRef, useState } from 'react';
import { AccountStorageView, currentStorageBalance } from '../services/account';
import { wallet } from '../services/near';
import { currentRefPrice } from '~services/api';

const REFRESH_TIME = 60 * 1000;

export const useCurrentStorageBalance = () => {
  const [storageBalance, setStorageBalance] = useState<AccountStorageView>();
  useEffect(() => {
    currentStorageBalance(wallet.getAccountId())
      .then(setStorageBalance)
      .catch(() => setStorageBalance(null));
  }, [wallet.getAccountId()]);
  return storageBalance;
};

export const useRefPrice = () => {
  const timer = useRef(null);
  const [data, setData] = useState<string>();

  const callback = () =>
    currentRefPrice().then((res) => {
      res && setData(res);
    });

  useEffect(() => {
    callback();

    timer.current = setInterval(callback, REFRESH_TIME);

    return () => {
      clearInterval(timer.current);
    };
  }, []);

  return { data };
};

'''
'''--- src/state/adboard.ts ---
import { useEffect, useState } from 'react';
import metadata from '~utils/metadata';
import { AdboardState, getAdboardState } from '../services/adboard';
import { wallet } from '../services/near';

export const useAdboardState = () => {
  const [loading, setLoading] = useState<boolean>(true);
  const [adboardState, setAdboardState] = useState<AdboardState>();

  useEffect(() => {
    getAdboardState()
      .then(setAdboardState)
      .finally(() => setLoading(false));
  }, []);

  const ownedFrames = adboardState?.metadata.filter(
    (metadata) => metadata.owner === wallet.getAccountId()
  );

  const isOwnFrame = (owner: string) => {
    return owner === wallet.getAccountId();
  };

  return {
    ...adboardState,
    loading,
    ownedFrames,
    isOwnFrame,
  };
};

'''
'''--- src/state/pool.ts ---
import { useEffect, useState, useCallback } from 'react';
import { calculateFairShare, percentLess, toPrecision } from '../utils/numbers';
import { getStakedListByAccountId } from '~services/farm';
import {
  DEFAULT_PAGE_LIMIT,
  getAllPoolsFromDb,
  getAllWatchListFromDb,
  getCachedPoolsByTokenId,
  getPoolDetails,
  getPools,
  getSharesInPool,
  getTotalPools,
  parsePool,
  Pool,
  PoolDetails,
  removeLiquidityFromPool,
} from '../services/pool';
import db, { PoolDb, WatchList } from '~store/RefDatabase';

import { useWhitelistTokens } from './token';
import _, { debounce, min, orderBy } from 'lodash';
import {
  getPoolMonthVolume,
  getPoolMonthTVL,
  getPoolsByIds,
  get24hVolume,
} from '~services/indexer';
import { parsePoolView, PoolRPCView } from '~services/api';

export const usePool = (id: number | string) => {
  const [pool, setPool] = useState<PoolDetails>();
  const [shares, setShares] = useState<string>('0');
  const [stakeList, setStakeList] = useState<Record<string, string>>({});
  useEffect(() => {
    getPoolDetails(Number(id)).then(setPool);
    getSharesInPool(Number(id))
      .then(setShares)
      .catch(() => setShares);

    getStakedListByAccountId({}).then((stakeList) => {
      setStakeList(stakeList);
    });
  }, [id]);

  return { pool, shares, stakeList };
};

interface LoadPoolsOpts {
  accumulate: boolean;
  tokenName?: string;
  sortBy?: string;
  order?: string;
}

export const usePools = (props: {
  searchTrigger?: Boolean;
  tokenName?: string;
  sortBy?: string;
  order?: string;
}) => {
  const [page, setPage] = useState<number>(1);
  const [hasMore, setHasMore] = useState<boolean>(false);
  const [pools, setPools] = useState<Pool[]>([]);
  const [loading, setLoading] = useState(false);

  const tokens = useWhitelistTokens();
  const tokenIds = tokens?.map((t) => t.id);

  const nextPage = () => setPage((page) => page + 1);

  function _loadPools({
    accumulate = true,
    tokenName,
    sortBy,
    order,
  }: LoadPoolsOpts) {
    getPools({
      page,
      tokenName: tokenName,
      column: sortBy,
      order: order,
    })
      .then((pools) => {
        setHasMore(pools.length === DEFAULT_PAGE_LIMIT);
        setPools((currentPools) =>
          pools.reduce<Pool[]>(
            (acc: Pool[], pool) => {
              if (
                acc.some(
                  (p) =>
                    p.fee === pool.fee &&
                    p.tokenIds.includes(pool.tokenIds[0]) &&
                    p.tokenIds.includes(pool.tokenIds[1]) &&
                    p.shareSupply === pool.shareSupply
                )
              )
                return acc;
              acc.push(pool);
              return acc;
            },
            accumulate ? currentPools.slice() : []
          )
        );
      })
      .finally(() => setLoading(false));
  }

  const loadPools = useCallback(debounce(_loadPools, 500), []);

  // const loadPools = debounce(_loadPools, 500);

  useEffect(() => {
    setLoading(true);
    loadPools({
      accumulate: false,
      tokenName: props.tokenName,
      sortBy: props.sortBy,
      order: props.order,
    });
  }, [props.searchTrigger]);

  useEffect(() => {
    setLoading(true);
    loadPools({
      accumulate: false,
      tokenName: props.tokenName,
      sortBy: props.sortBy,
      order: props.order,
    });
  }, [props.sortBy, props.order]);

  useEffect(() => {
    setLoading(true);
    loadPools({
      accumulate: true,
      tokenName: props.tokenName,
      sortBy: props.sortBy,
      order: props.order,
    });
  }, [page]);

  return {
    pools,
    hasMore,
    nextPage,
    loading,
  };
};

export const useMorePoolIds = (props: { topPool: Pool }) => {
  const { topPool } = props;

  const [token1Id, token2Id] = topPool.tokenIds;

  const [ids, setIds] = useState<string[]>();

  useEffect(() => {
    getCachedPoolsByTokenId({
      token1Id,
      token2Id,
    }).then((res) => {
      const idsFromCachePools: string[] = res.map((p) => {
        return p.id.toString();
      });
      setIds(idsFromCachePools);
    });
  }, [topPool?.id]);
  return ids;
};

export const useMorePools = ({
  morePoolIds,
  order,
  sortBy,
}: {
  morePoolIds: string[];
  order: boolean | 'desc' | 'asc';
  sortBy: string;
}) => {
  const [morePools, setMorePools] = useState<PoolRPCView[]>();
  useEffect(() => {
    getPoolsByIds({ pool_ids: morePoolIds }).then((res) => {
      const orderedPools = orderBy(res, [sortBy], [order]);
      setMorePools(orderedPools);
    });
  }, [order, sortBy]);
  return morePools;
};

export const useAllWatchList = () => {
  const [watchList, setWatchList] = useState<WatchList[]>();

  useEffect(() => {
    getAllWatchListFromDb({}).then((watchlist) => {
      setWatchList(_.orderBy(watchlist, 'update_time', 'desc'));
    });
  }, []);

  return watchList;
};

export const useWatchPools = () => {
  const [watchList, setWatchList] = useState<WatchList[]>([]);

  const [watchPools, setWatchPools] = useState<Pool[]>([]);
  useEffect(() => {
    getAllWatchListFromDb({}).then((watchlist) => {
      setWatchList(_.orderBy(watchlist, 'update_time', 'desc'));
    });
  }, []);

  useEffect(() => {
    const ids = watchList.map((watchedPool) => watchedPool.pool_id);
    if (ids.length === 0) return;
    getPoolsByIds({ pool_ids: ids }).then((res) => {
      const resPools = res.map((pool) => parsePool(pool));
      setWatchPools(resPools);
    });
  }, [watchList]);

  return watchPools;
};

export const useAllPools = () => {
  const [allPools, setAllPools] = useState<number>();

  useEffect(() => {
    getTotalPools().then((res) => {
      setAllPools(res);
    });
  }, []);

  return allPools;
};

export const useRemoveLiquidity = ({
  pool,
  shares,
  slippageTolerance,
}: {
  pool: Pool;
  shares: string;
  slippageTolerance: number;
}) => {
  const minimumAmounts = Object.entries(pool.supplies).reduce<{
    [tokenId: string]: string;
  }>((acc, [tokenId, totalSupply]) => {
    acc[tokenId] = toPrecision(
      percentLess(
        slippageTolerance,
        calculateFairShare({
          shareOf: totalSupply,
          contribution: shares,
          totalContribution: pool.shareSupply,
        })
      ),
      0
    );
    return acc;
  }, {});

  const removeLiquidity = () => {
    return removeLiquidityFromPool({
      id: pool.id,
      shares,
      minimumAmounts,
    });
  };

  return {
    removeLiquidity,
    minimumAmounts,
  };
};

export interface volumeType {
  pool_id: string;
  dateString: string;
  fiat_volume: string;
  asset_volume: string;
  volume_dollar: string;
}

export interface volumeDataType {
  pool_id: string;
  dateString: string;
  fiat_volume: string;
  asset_volume: string;
  volume_dollar: number;
}

export const useMonthVolume = (pool_id: string) => {
  const [monthVolumeById, setMonthVolumeById] = useState<volumeDataType[]>();
  useEffect(() => {
    getPoolMonthVolume(pool_id).then((res) => {
      const monthVolume = res
        .map((v, i) => {
          return {
            ...v,
            volume_dollar: Number(v.volume_dollar),
          };
        })
        .reverse();
      setMonthVolumeById(monthVolume);
    });
  }, []);

  return monthVolumeById;
};

export interface TVLType {
  pool_id: string;
  asset_amount: string;
  fiat_amount: string;
  asset_price: string;
  fiat_price: string;
  asset_tvl: string;
  fiat_tvl: string;
  date: string;
}
export interface TVLDataType {
  pool_id: string;
  asset_amount: string;
  fiat_amount: string;
  asset_price: string;
  fiat_price: string;
  asset_tvl: number;
  fiat_tvl: number;
  date: string;
  total_tvl: number;
  scaled_tvl: number;
}

export const useMonthTVL = (pool_id: string) => {
  const [monthTVLById, setMonthTVLById] = useState<TVLDataType[]>();
  useEffect(() => {
    getPoolMonthTVL(pool_id).then((res) => {
      const minDay = _.minBy(res, (o) => {
        return Number(o.asset_tvl) + Number(o.fiat_tvl);
      });
      const minValue = Number(minDay?.asset_tvl) + Number(minDay?.fiat_tvl);

      const monthTVL = res
        .map((v, i) => {
          return {
            ...v,
            asset_tvl: Number(v?.asset_tvl),
            fiat_tvl: Number(v?.fiat_tvl),
            total_tvl: Number(v?.fiat_tvl) + Number(v?.asset_tvl),
            scaled_tvl:
              Number(v?.fiat_tvl) + Number(v?.asset_tvl) - minValue * 0.99,
          };
        })
        .reverse();
      setMonthTVLById(monthTVL);
    });
  }, []);

  return monthTVLById;
};

export const useDayVolume = (pool_id: string) => {
  const [dayVolume, setDayVolume] = useState<string>();
  useEffect(() => {
    get24hVolume(pool_id).then(setDayVolume);
  }, [pool_id]);
  return dayVolume;
};

'''
'''--- src/state/token.ts ---
import { useCallback, useEffect, useRef, useState } from 'react';
import { wallet } from '../services/near';
import {
  ftGetBalance,
  ftGetTokenMetadata,
  TokenMetadata,
} from '../services/ft-contract';
import {
  getWhitelistedTokens,
  getTokenBalances,
  getUserRegisteredTokens,
  TokenBalancesView,
} from '../services/token';
import {
  toPrecision,
  toReadableNumber,
  toRoundedReadableNumber,
} from '~utils/numbers';
import { toRealSymbol } from '~utils/token';

export const useToken = (id: string) => {
  const [token, setToken] = useState<TokenMetadata>();

  useEffect(() => {
    ftGetTokenMetadata(id).then(setToken);
  }, [id]);

  return token;
};

export const useTokens = (ids: string[] = []) => {
  const [tokens, setTokens] = useState<TokenMetadata[]>();

  useEffect(() => {
    Promise.all<TokenMetadata>(ids.map((id) => ftGetTokenMetadata(id))).then(
      setTokens
    );
  }, [ids.join('')]);

  return tokens;
};

export const useWhitelistTokens = (extraTokenIds: string[] = []) => {
  const [tokens, setTokens] = useState<TokenMetadata[]>();

  useEffect(() => {
    getWhitelistedTokens()
      .then((tokenIds) => {
        const allTokenIds = [...new Set([...tokenIds, ...extraTokenIds])];
        return Promise.all(
          allTokenIds.map((tokenId) => ftGetTokenMetadata(tokenId))
        );
      })
      .then(setTokens);
  }, []);

  return tokens;
};

export const useUserRegisteredTokens = () => {
  const [tokens, setTokens] = useState<TokenMetadata[]>();

  useEffect(() => {
    if (wallet.isSignedIn()) {
      getUserRegisteredTokens()
        .then((tokenIds) =>
          Promise.all(tokenIds.map((tokenId) => ftGetTokenMetadata(tokenId)))
        )
        .then(setTokens);
    }
  }, []);

  return tokens;
};

export const useTokenBalances = () => {
  const [balances, setBalances] = useState<TokenBalancesView>();

  useEffect(() => {
    getTokenBalances()
      .then(setBalances)
      .catch(() => setBalances({}));
  }, []);

  return balances;
};

export const getDepositableBalance = async (
  tokenId: string,
  decimals?: number
) => {
  if (tokenId === 'NEAR') {
    if (wallet.isSignedIn()) {
      return wallet
        .account()
        .getAccountBalance()
        .then(({ available }) => {
          return toReadableNumber(decimals, available);
        });
    } else {
      return toReadableNumber(decimals, '0');
    }
  } else if (tokenId) {
    return ftGetBalance(tokenId)
      .then((res) => {
        return toReadableNumber(decimals, res);
      })
      .catch((res) => '0');
  } else {
    return '';
  }
};

export const useTokensData = (
  tokens: TokenMetadata[],
  balances?: TokenBalancesView
) => {
  const [count, setCount] = useState(0);
  const [result, setResult] = useState<TokenMetadata[]>([]);
  const fetchIdRef = useRef(0);
  const setResultAtIndex = (data: TokenMetadata, index: number) => {
    setResult((oldResults) => {
      const newResults = [...oldResults];
      newResults[index] = data;
      return newResults;
    });
    setCount((c) => c + 1);
  };

  const trigger = useCallback(() => {
    if (!!balances) {
      setCount(0);
      setResult([]);
      const currentFetchId = fetchIdRef.current;
      for (let i = 0; i < tokens.length; i++) {
        const index = i;
        const item = tokens[index];
        getDepositableBalance(item.id, item.decimals)
          .then((max: string) => {
            if (currentFetchId !== fetchIdRef.current) {
              throw new Error();
            }
            return max;
          })
          .then((max: string) => {
            const nearCount = toPrecision(max, 3) || '0';
            const refCount = toRoundedReadableNumber({
              decimals: item.decimals,
              number: balances ? balances[item.id] : '0',
            });
            return {
              ...item,
              asset: toRealSymbol(item.symbol),
              near: Number(nearCount.replace(/[\,]+/g, '')),
              ref: Number(toPrecision(refCount, 3).replace(/[\,]+/g, '')),
              total:
                Number(nearCount.replace(/[\,]+/g, '')) +
                Number(toPrecision(refCount, 3).replace(/[\,]+/g, '')),
            };
          })
          .then((d: TokenMetadata) => setResultAtIndex(d, index))
          .catch((err) => {
            console.log(err);
          });
      }
    }
  }, [balances]);

  useEffect(() => {
    trigger();
  }, [tokens, tokens.length]);

  return {
    trigger,
    loading: count < tokens.length,
    tokensData: result,
  };
};

export const useDepositableBalance = (tokenId: string, decimals?: number) => {
  const [depositable, setDepositable] = useState<string>('');
  const [max, setMax] = useState<string>('');
  useEffect(() => {
    if (tokenId === 'NEAR') {
      if (wallet.isSignedIn()) {
        wallet
          .account()
          .getAccountBalance()
          .then(({ available }) => setDepositable(available));
      } else {
        setDepositable('0');
      }
    } else if (tokenId) ftGetBalance(tokenId).then(setDepositable);
  }, [tokenId]);

  useEffect(() => {
    const max = toReadableNumber(decimals, depositable) || '0';
    setMax(max);
  }, [depositable]);

  return max;
};

export const useUnregisteredTokens = () => {
  const [unregisteredTokenIds, setUnregisteredTokenIds] = useState<string[]>(
    []
  );
  const tokens = useTokens(unregisteredTokenIds);

  useEffect(() => {
    Promise.all([getWhitelistedTokens(), getUserRegisteredTokens()])
      .then(([globalTokens, userTokens]) => {
        return globalTokens.filter((token) => !userTokens.includes(token));
      })
      .then(setUnregisteredTokenIds);
  }, []);

  return tokens;
};

export const getExchangeRate = (
  tokens: any,
  pool: any,
  first_token_price: any,
  use_api_price: boolean
) => {
  const first_token_num = toReadableNumber(
    tokens[0].decimals || 24,
    pool.supplies[tokens[0].id]
  );
  const second_token_num = toReadableNumber(
    tokens[1].decimals || 24,
    pool.supplies[tokens[1].id]
  );

  return use_api_price
    ? first_token_price === 'N/A'
      ? 'N/A'
      : Number(first_token_num) === 0
      ? 'N/A'
      : `≈$${(
          (Number(second_token_num) / Number(first_token_num)) *
          first_token_price
        ).toFixed(8)}`
    : Number(first_token_num) === 0
    ? 'N/A'
    : `≈ ${(Number(second_token_num) / Number(first_token_num)).toFixed(2)} ${
        tokens[1].symbol
      }`;
};

'''
'''--- src/store/RefDatabase.ts ---
import Dexie from 'dexie';
import _ from 'lodash';
import moment from 'moment';
import getConfig from '../services/config';

interface Pool {
  id: number;
  token1Id: string;
  token2Id: string;
  token1Supply: string;
  token2Supply: string;
  fee: number;
  shares: string;
}

interface TokenMetadata {
  id: string;
  name: string;
  symbol: string;
  decimals: number;
  icon: string;
}

interface PoolsTokens {
  id: number;
  pool_id: string;
  token1Id: string;
  token2Id: string;
  token1Supply: string;
  token2Supply: string;
  fee: number;
  shares: string;
  update_time: string;
  token0_price: string;
}

export interface PoolDb extends Pool {
  tvl?: string;
}

export interface FarmDexie {
  id: string;
  pool_id: string;
  status: string;
}

export interface WatchList {
  id: string;
  account: string;
  pool_id: string;
  update_time: number;
}

class RefDatabase extends Dexie {
  public pools: Dexie.Table<Pool>;
  public tokens: Dexie.Table<TokenMetadata>;
  public farms: Dexie.Table<FarmDexie>;
  public poolsTokens: Dexie.Table<PoolsTokens>;
  public watchList: Dexie.Table<WatchList>;

  public constructor() {
    super('RefDatabase');

    this.version(5.1).stores({
      pools: 'id, token1Id, token2Id, token1Supply, token2Supply, fee, shares',
      tokens: 'id, name, symbol, decimals, icon',
      farms: 'id, pool_id, status',
      pools_tokens:
        'id, token1Id, token2Id, token1Supply, token2Supply, fee, shares, update_time, token0_price',
      watchList: 'id, account, pool_id, update_time',
    });

    this.pools = this.table('pools');
    this.tokens = this.table('tokens');
    this.farms = this.table('farms');
    this.poolsTokens = this.table('pools_tokens');
    this.watchList = this.table('watchList');
  }

  public allWatchList() {
    return this.watchList;
  }

  public allPools() {
    return this.pools;
  }

  public allTokens() {
    return this.tokens;
  }

  public allFarms() {
    return this.farms;
  }

  public searchPools(args: any, pools: Pool[]): Pool[] {
    if (args.tokenName === '') return pools;
    return _.filter(pools, (pool: Pool) => {
      return (
        _.includes(pool.token1Id, args.tokenName) ||
        _.includes(pool.token2Id, args.tokenName)
      );
    });
  }

  public orderPools(args: any, pools: Pool[]): Pool[] {
    return _.orderBy(pools, [args.column], [args.order]);
  }

  public paginationPools(args: any, pools: Pool[]): Pool[] {
    return _.slice(
      pools,
      (args.page - 1) * args.perPage,
      args.page * args.perPage
    );
  }

  public uniquePools(args: any, pools: Pool[]): Pool[] {
    if (!args.uniquePairName) return pools;
    let obj: any[];
    return pools.reduce(
      (cur: any[], next: { token1Id: any; token2Id: any }) => {
        const pair_name: any = `${next.token1Id}--${next.token1Id}`;
        obj[pair_name] ? '' : (obj[pair_name] = true && cur.push(next));
        return cur;
      },
      []
    );
  }

  public async queryPools(args: any) {
    let pools = await this.allPools().toArray();
    return this.paginationPools(
      args,
      this.orderPools(
        args,
        this.uniquePools(args, this.searchPools(args, pools))
      )
    );
  }

  public searchTokens(args: any, tokens: TokenMetadata[]): TokenMetadata[] {
    if (args.tokenName === '') return tokens;
    return _.filter(tokens, (token: TokenMetadata) => {
      return _.includes(token.name, args.tokenName);
    });
  }

  public async queryTokens(args: any) {
    let tokens = await this.allTokens().toArray();
    return this.searchTokens(args, tokens);
  }

  public async queryFarms() {
    let farms = await this.allFarms().toArray();
    return farms;
  }

  public async cachePoolsByTokens(pools: any) {
    await this.poolsTokens.clear();
    await this.poolsTokens.bulkPut(
      pools.map(
        (pool: {
          id: number;
          tokenIds: string[];
          supplies: any[];
          fee: number;
          shareSupply: string;
          token0_ref_price: string;
        }) => ({
          id: pool.id,
          token1Id: pool.tokenIds[0],
          token2Id: pool.tokenIds[1],
          token1Supply: pool.supplies[pool.tokenIds[0]],
          token2Supply: pool.supplies[pool.tokenIds[1]],
          fee: pool.fee,
          shares: pool.shareSupply,
          update_time: moment().unix(),
          token0_price: pool.token0_ref_price || '0',
        })
      )
    );
  }

  public async checkPoolsByTokens(tokenInId: string, tokenOutId: string) {
    const items = await this.queryPoolsByTokens(tokenInId, tokenOutId);
    return items.length > 0;
  }

  public async getPoolsByTokens(tokenInId: string, tokenOutId: string) {
    const items = await this.queryPoolsByTokens(tokenInId, tokenOutId);

    return items.map((item) => ({
      id: item.id,
      fee: item.fee,
      tokenIds: [item.token1Id, item.token2Id],
      supplies: {
        [item.token1Id]: item.token1Supply,
        [item.token2Id]: item.token2Supply,
      },
      token0_ref_price: item.token0_price,
    }));
  }

  async queryPoolsByTokens(tokenInId: string, tokenOutId: string) {
    let normalItems = await this.poolsTokens
      .where('token1Id')
      .equals(tokenInId.toString())
      .and((item) => item.token2Id === tokenOutId.toString())
      .and(
        (item) =>
          Number(item.update_time) >=
          Number(moment().unix()) -
            Number(getConfig().POOL_TOKEN_REFRESH_INTERVAL)
      )
      .toArray();
    let reverseItems = await this.poolsTokens
      .where('token1Id')
      .equals(tokenOutId.toString())
      .and((item) => item.token2Id === tokenInId.toString())
      .and(
        (item) =>
          Number(item.update_time) >=
          Number(moment().unix()) -
            Number(getConfig().POOL_TOKEN_REFRESH_INTERVAL)
      )
      .toArray();

    return [...normalItems, ...reverseItems];
  }
}

export default new RefDatabase();

'''
'''--- src/utils/AdboardUtil.ts ---
const axios = require('axios').default;
import { compress, decompress } from 'lzutf8';

export class AdboardUtil {
  static PIX_HORIZONTAL_BOXES = 25;
  static PIX_VERTICAL_BOXES = 16;
  static FRAME_COUNT =
    AdboardUtil.PIX_VERTICAL_BOXES * AdboardUtil.PIX_HORIZONTAL_BOXES;
  static PIX_HEIGHT_BOARD = AdboardUtil.PIX_VERTICAL_BOXES * 40;
  static PIX_WIDTH_BOARD = AdboardUtil.PIX_HORIZONTAL_BOXES * 40;
  static HEIGHT_BOXES = 20;
  static LENGTH_BOXES = 20;

  static AdboardData: { framedata: any; metadata: any } = {
    framedata: null,
    metadata: null,
  };
  static DrawboardData: any = [];

  static setStorageData(key: string, data: string) {
    localStorage.setItem(key, compress(data, { outputEncoding: 'Base64' }));
  }

  static getStorageData(key: string, default_value: string) {
    let value = localStorage.getItem(key) || default_value;
    if (value != default_value) {
      return decompress(value, { inputEncoding: 'Base64' });
    }
    return value;
  }

  static compress(data: any) {
    return compress(data, { outputEncoding: 'Base64' });
  }

  static decompressB64(data: string) {
    return decompress(data, { inputEncoding: 'Base64' });
  }

  static async fetchAdboardData() {
    //TODO change this
    let resp = await axios.get('https://near-pixelparty.co/api/getFrameData');
    return resp;
  }

  static colorPalette: any[] = [];

  static initColorPalette() {
    if (AdboardUtil.colorPalette.length == 0) {
      this.colorPalette = this.colorPalette.concat([
        '#F44336',
        '#FFCDD2',
        '#EF9A9A',
        '#E57373',
        '#EF5350',
        '#E53935',
        '#D32F2F',
        '#C62828',
        '#B71C1C',
        '#FF8A80',
        '#FF5252',
        '#FF1744',
        '#D50000',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#E91E63',
        '#F8BBD0',
        '#F48FB1',
        '#F06292',
        '#EC407A',
        '#D81B60',
        '#C2185B',
        '#AD1457',
        '#880E4F',
        '#FF80AB',
        '#FF4081',
        '#F50057',
        '#C51162',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#9C27B0',
        '#E1BEE7',
        '#CE93D8',
        '#BA68C8',
        '#AB47BC',
        '#8E24AA',
        '#7B1FA2',
        '#6A1B9A',
        '#4A148C',
        '#EA80FC',
        '#E040FB',
        '#D500F9',
        '#AA00FF',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#673AB7',
        '#D1C4E9',
        '#B39DDB',
        '#9575CD',
        '#7E57C2',
        '#5E35B1',
        '#512DA8',
        '#4527A0',
        '#311B92',
        '#B388FF',
        '#7C4DFF',
        '#651FFF',
        '#6200EA',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#3F51B5',
        '#C5CAE9',
        '#9FA8DA',
        '#7986CB',
        '#5C6BC0',
        '#3949AB',
        '#303F9F',
        '#283593',
        '#1A237E',
        '#8C9EFF',
        '#536DFE',
        '#3D5AFE',
        '#304FFE',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#2196F3',
        '#BBDEFB',
        '#90CAF9',
        '#64B5F6',
        '#42A5F5',
        '#1E88E5',
        '#1976D2',
        '#1565C0',
        '#0D47A1',
        '#82B1FF',
        '#448AFF',
        '#2979FF',
        '#2962FF',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#03A9F4',
        '#B3E5FC',
        '#81D4FA',
        '#4FC3F7',
        '#29B6F6',
        '#039BE5',
        '#0288D1',
        '#0277BD',
        '#01579B',
        '#80D8FF',
        '#40C4FF',
        '#00B0FF',
        '#0091EA',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#00BCD4',
        '#B2EBF2',
        '#80DEEA',
        '#4DD0E1',
        '#26C6DA',
        '#00ACC1',
        '#0097A7',
        '#00838F',
        '#006064',
        '#84FFFF',
        '#18FFFF',
        '#00E5FF',
        '#00B8D4',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#009688',
        '#B2DFDB',
        '#80CBC4',
        '#4DB6AC',
        '#26A69A',
        '#00897B',
        '#00796B',
        '#00695C',
        '#004D40',
        '#A7FFEB',
        '#64FFDA',
        '#1DE9B6',
        '#00BFA5',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#4CAF50',
        '#C8E6C9',
        '#A5D6A7',
        '#81C784',
        '#66BB6A',
        '#43A047',
        '#388E3C',
        '#2E7D32',
        '#1B5E20',
        '#B9F6CA',
        '#69F0AE',
        '#00E676',
        '#00C853',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#8BC34A',
        '#DCEDC8',
        '#C5E1A5',
        '#AED581',
        '#9CCC65',
        '#7CB342',
        '#689F38',
        '#558B2F',
        '#33691E',
        '#CCFF90',
        '#B2FF59',
        '#76FF03',
        '#64DD17',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#CDDC39',
        '#F0F4C3',
        '#E6EE9C',
        '#DCE775',
        '#D4E157',
        '#C0CA33',
        '#AFB42B',
        '#9E9D24',
        '#827717',
        '#F4FF81',
        '#EEFF41',
        '#C6FF00',
        '#AEEA00',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#FFEB3B',
        '#FFF9C4',
        '#FFF59D',
        '#FFF176',
        '#FFEE58',
        '#FDD835',
        '#FBC02D',
        '#F9A825',
        '#F57F17',
        '#FFFF8D',
        '#FFFF00',
        '#FFEA00',
        '#FFD600',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#FFC107',
        '#FFECB3',
        '#FFE082',
        '#FFD54F',
        '#FFCA28',
        '#FFB300',
        '#FFA000',
        '#FF8F00',
        '#FF6F00',
        '#FFE57F',
        '#FFD740',
        '#FFC400',
        '#FFAB00',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#FF9800',
        '#FFE0B2',
        '#FFCC80',
        '#FFB74D',
        '#FFA726',
        '#FB8C00',
        '#F57C00',
        '#EF6C00',
        '#E65100',
        '#FFD180',
        '#FFAB40',
        '#FF9100',
        '#FF6D00',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#FF5722',
        '#FFCCBC',
        '#FFAB91',
        '#FF8A65',
        '#FF7043',
        '#F4511E',
        '#E64A19',
        '#D84315',
        '#BF360C',
        '#FF9E80',
        '#FF6E40',
        '#FF3D00',
        '#DD2C00',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#795548',
        '#D7CCC8',
        '#BCAAA4',
        '#A1887F',
        '#8D6E63',
        '#6D4C41',
        '#5D4037',
        '#4E342E',
        '#3E2723',
        '#9E9E9E',
        '#FAFAFA',
        '#EEEEEE',
        '#E0E0E0',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#BDBDBD',
        '#616161',
        '#424242',
        '#212121',
        '#607D8B',
        '#B0BEC5',
        '#90A4AE',
        '#78909C',
        '#607D8C',
        '#546E7A',
        '#455A64',
        '#37474F',
        '#263238',
      ]);
      this.colorPalette = this.colorPalette.concat([
        '#000000',
        '#FFFFFF',
        '#01C08B',
      ]);

      AdboardUtil.colorPalette.forEach((el, index) => {
        AdboardUtil.color2byte.set(el.toUpperCase(), index);
      });

      AdboardUtil.colorPalette.forEach((el, index) => {
        AdboardUtil.byte2color.set(index, el.toUpperCase());
      });
    }
  }

  static color2byte = new Map();
  static byte2color = new Map();

  static color_byte(hex: string) {
    return this.color2byte.get(hex.toUpperCase());
  }

  static byte_color(byte: number) {
    return this.byte2color.get(byte).toString().toUpperCase();
  }

  static rgb2hex(rgb: any) {
    rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
    return '#' + this.hex(rgb[1]) + this.hex(rgb[2]) + this.hex(rgb[3]);
  }

  static hex(x: number) {
    var hexDigits = new Array(
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'a',
      'b',
      'c',
      'd',
      'e',
      'f'
    );
    return isNaN(x) ? '00' : hexDigits[(x - (x % 16)) / 16] + hexDigits[x % 16];
  }
}

'''
'''--- src/utils/__tests__/numbers.test.js ---
const {
  toReadableNumber,
  toNonDivisibleNumber,
  toPrecision,
  toRoundedReadableNumber,
  convertToPercentDecimal,
  calculateFeePercent,
  calculateFeeCharge,
  calculateExchangeRate,
  percentOf,
  percentLess,
  percent,
  calculateFairShare,
} = require('../numbers');

describe('toReadableNumber', () => {
  test('single digit', () => {
    expect(toReadableNumber(10, '1')).toEqual('0.0000000001');
  });

  test('to single digit', () => {
    expect(toReadableNumber(12, '1000000000000')).toEqual('1');
  });

  test('small number', () => {
    expect(toReadableNumber(20, '1')).toEqual('0.00000000000000000001');
  });

  test('large number', () => {
    expect(toReadableNumber(20, '1000000000000000000000')).toEqual('10');
  });

  test('large number small decimals', () => {
    expect(toReadableNumber(2, '999900023')).toEqual('9999000.23');
  });

  test('single decimal', () => {
    expect(toReadableNumber(24, '500000000000000000000000')).toEqual('0.5');
  });

  test('big number bigger decimal', () => {
    expect(toReadableNumber(24, '9999988666724')).toEqual(
      '0.000000000009999988666724'
    );
  });
});

describe('toNonDivisibleNumber', () => {
  test('tiny number', () => {
    expect(toNonDivisibleNumber(20, '0.00000000000000000001')).toEqual('1');
  });

  test('large number', () => {
    expect(toNonDivisibleNumber(20, '100000')).toEqual(
      '10000000000000000000000000'
    );
  });

  test('mixed number', () => {
    expect(toNonDivisibleNumber(5, '123.45678')).toEqual('12345678');
  });

  test('overprecise number', () => {
    expect(toNonDivisibleNumber(5, '123.456789')).toEqual('12345678');
  });

  test('zero', () => {
    expect(toNonDivisibleNumber(20, '0')).toEqual('0');
  });

  test('zero decimals', () => {
    expect(toNonDivisibleNumber(0, '5.15')).toEqual('5');
  });
});

describe('toPrecision', () => {
  test('lower precision', () => {
    expect(toPrecision('25.98765432', 2)).toEqual('25.98');
  });

  test('higher precision', () => {
    expect(toPrecision('25.98', 5)).toEqual('25.98');
  });

  test('with commas', () => {
    expect(toPrecision('1234567.98765432', 2, true)).toEqual('1,234,567.98');
  });
});

describe('toRoundedReadableNumber', () => {
  test('low decimals', () => {
    expect(
      toRoundedReadableNumber({
        decimals: 2,
        number: '123456789',
      })
    ).toEqual('1,234,567.89');
  });

  test('high decimals', () => {
    expect(
      toRoundedReadableNumber({
        decimals: 20,
        number: '123456789123456789',
      })
    ).toEqual('0.001234');
  });

  test('high decimals hige precision', () => {
    expect(
      toRoundedReadableNumber({
        decimals: 20,
        number: '123456789123456789',
        precision: 15,
      })
    ).toEqual('0.001234567891234');
  });
});

describe('convertToPercentDecimal', () => {
  test('converts percent to decimal version', () => {
    expect(convertToPercentDecimal(100)).toEqual(1);
    expect(convertToPercentDecimal(90)).toEqual(0.9);
    expect(convertToPercentDecimal(75)).toEqual(0.75);
    expect(convertToPercentDecimal(5)).toEqual(0.05);
    expect(convertToPercentDecimal(0.3)).toEqual(0.003);
    expect(convertToPercentDecimal(0)).toEqual(0);
  });
});

describe('calculateFeePercent', () => {
  test('BPS to fee', () => {
    expect(calculateFeePercent(30)).toEqual(0.3);
    expect(calculateFeePercent(25)).toEqual(0.25);
  });
});

describe('calculateFeeCharge', () => {
  test('calculate fee charge from BPS', () => {
    expect(calculateFeeCharge(30, 100)).toEqual(0.3);
    expect(calculateFeeCharge(30, 30)).toEqual(0.09);
    expect(calculateFeeCharge(30, 12)).toEqual(0.04);
  });
});

describe('calculateExchangeRate', () => {
  test('calculate the exchange rate', () => {
    expect(calculateExchangeRate(30, 100, 100)).toEqual(1);
    expect(calculateExchangeRate(30, 200, 50)).toEqual(0.25);
  });
});

describe('percentOf', () => {
  test('calculate the percent of a number', () => {
    expect(percentOf(50, 100)).toEqual(50);
    expect(percentOf(25, 100)).toEqual(25);
    expect(percentOf(75, 100)).toEqual(75);
  });
});

describe('percentLess', () => {
  test('get a number minus a percent of itself', () => {
    expect(percentLess(50, 100)).toEqual('50');
    expect(percentLess(25, 100)).toEqual('75');
    expect(percentLess(80, 100)).toEqual('20');
  });
});

describe('percent', () => {
  test('get percent givent numerator and denominator', () => {
    expect(percent(50, 100)).toEqual(50);
    expect(percent(25, 100)).toEqual(25);
    expect(percent(75, 100)).toEqual(75);
  });
});

describe('calculateFairShare', () => {
  test('calculate the fair share given total an contribution', () => {
    expect(
      calculateFairShare({
        shareOf: 100,
        contribution: 50,
        totalContribution: 100,
      })
    ).toEqual('50');

    expect(
      calculateFairShare({
        shareOf: 100,
        contribution: 33,
        totalContribution: 100,
      })
    ).toEqual('33');

    expect(
      calculateFairShare({
        shareOf: 1,
        contribution: 33,
        totalContribution: 100,
      })
    ).toEqual('0');
  });
});

'''
'''--- src/utils/device.ts ---
export const isMobile = (): Boolean => {
  return window.screen.width < 1024;
};

export const isPC = (): Boolean => {
  return window.screen.width >= 1024;
};

'''
'''--- src/utils/metadata.ts ---
const icons: { [tokenId: string]: string } = {
	'wrap.near': 'https://i.postimg.cc/4xx2KRxt/wNEAR.png',
	'wrap.testnet': 'https://i.postimg.cc/4xx2KRxt/wNEAR.png',
	'rft.tokenfactory.testnet':
		"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='16 24 248 248' style='background: %23000'%3E%3Cpath d='M164,164v52h52Zm-45-45,20.4,20.4,20.6-20.6V81H119Zm0,18.39V216h41V137.19l-20.6,20.6ZM166.5,81H164v33.81l26.16-26.17A40.29,40.29,0,0,0,166.5,81ZM72,153.19V216h43V133.4l-11.6-11.61Zm0-18.38,31.4-31.4L115,115V81H72ZM207,121.5h0a40.29,40.29,0,0,0-7.64-23.66L164,133.19V162h2.5A40.5,40.5,0,0,0,207,121.5Z' fill='%23fff'/%3E%3Cpath d='M189 72l27 27V72h-27z' fill='%2300c08b'/%3E%3C/svg%3E%0A",
	'6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/4943.png',
	'berryclub.ek.near': 'https://i.postimg.cc/j263fsf6/banana.png',
	'banana.ft-fin.testnet': 'https://i.postimg.cc/j263fsf6/banana.png',
	'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/825.png',
	'1f9840a85d5af5bf1d1762f925bdaddc4201f984.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/7083.png',
	'514910771af9ca656af840dff83e8264ecf986ca.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/1975.png',
	'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/3408.png',
	'2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/3717.png',
	'7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/7278.png',
	'a0b73e1ff0b80914ab6fe0444e65848c4c34450b.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/3635.png',
	'50d1c9771902476076ecfc8b2a83ad6b9355a4c9.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/4195.png',
	'4fabb145d64652a948d72533023f6e7a623c7c53.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/4687.png',
	'6f259637dcd74c767781e37bc6133cd6a68aa161.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/2502.png',
	'6b3595068778dd592e39a122f4f5a5cf09c90fe2.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/6758.png',
	'c011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/2586.png',
	'c944e90c64b2c07662a292be6244bdf05cda44a7.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/6719.png',
	'9f8f72aa9304c8b593d555f12ef6589cc3a579a2.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/1518.png',
	'0bc529c00c6401aef6d220be8c6ea1667f6ad93e.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/5864.png',
	'c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/2396.png',
	'0316eb71485b0ab14103307bf65a021042c6d380.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/6941.png',
	'111111111117dc0aa78b770fa6a738034120c302.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/8104.png',
	'f5cfbc74057c610c8ef151a439252680ac68c6dc.factory.bridge.near': 'https://i.postimg.cc/NMJB3MF8/55sGoBm.png',
	'de30da39c46104798bb5aa3fe8b9e0e1f348163f.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/10052.png',
	'a4ef4b0b23c1fc81d3f9ecf93510e64f58a4a016.factory.bridge.near':
		'https://s2.coinmarketcap.com/static/img/coins/64x64/4222.png',
	'token.cheddar.near': 'https://i.postimg.cc/xk1vJC6x/cheddar.png',
	'farm.berryclub.ek.near': 'https://i.postimg.cc/TLyn0sMn/cucumber.png',
	'd9c2d319cd7e6177336b0a9c93c21cb48d84fb54.factory.bridge.near': 'https://i.postimg.cc/jwGPFhtm/HAPI.png',
};

export default icons;

'''
'''--- src/utils/numbers.ts ---
import BN from 'bn.js';
import * as math from 'mathjs';
import { TokenMetadata } from '~services/ft-contract';
import { Pool } from '~services/pool';

const BPS_CONVERSION = 10000;

const ROUNDING_OFFSETS: BN[] = [];
const BN10 = new BN(10);
for (let i = 0, offset = new BN(5); i < 24; i++, offset = offset.mul(BN10)) {
  ROUNDING_OFFSETS[i] = offset;
}

export const sumBN = (...args: string[]): string => {
  return args
    .reduce((acc, n) => {
      return acc.add(new BN(n));
    }, new BN(0))
    .toString();
};
export const toReadableNumber = (
  decimals: number,
  number: string = '0'
): string => {
  if (!decimals) return number;

  const wholeStr = number.substring(0, number.length - decimals) || '0';
  const fractionStr = number
    .substring(number.length - decimals)
    .padStart(decimals, '0')
    .substring(0, decimals);

  return `${wholeStr}.${fractionStr}`.replace(/\.?0+$/, '');
};

export const toNonDivisibleNumber = (
  decimals: number,
  number: string
): string => {
  if (decimals === null || decimals === undefined) return number;
  const [wholePart, fracPart = ''] = number.split('.');

  return `${wholePart}${fracPart.padEnd(decimals, '0').slice(0, decimals)}`
    .replace(/^0+/, '')
    .padStart(1, '0');
};

export const toPrecision = (
  number: string,
  precision: number,
  withCommas: boolean = false,
  atLeastOne: boolean = true
): string => {
  const [whole, decimal = ''] = number.split('.');

  let str = `${withCommas ? formatWithCommas(whole) : whole}.${decimal.slice(
    0,
    precision
  )}`.replace(/\.$/, '');
  if (atLeastOne && Number(str) === 0 && str.length > 1) {
    var n = str.lastIndexOf('0');
    str = str.slice(0, n) + str.slice(n).replace('0', '1');
  }

  return str;
};

export const toRoundedReadableNumber = ({
  decimals,
  number,
  precision = 6,
  withCommas = true,
}: {
  decimals: number;
  number?: string;
  precision?: number;
  withCommas?: boolean;
}): string => {
  return toPrecision(toReadableNumber(decimals, number), precision, withCommas);
};

export const convertToPercentDecimal = (percent: number) => {
  return math.divide(percent, 100);
};

export const calculateFeePercent = (fee: number) => {
  return math.divide(fee, 100);
};

export const calculateFeeCharge = (fee: number, total: string) => {
  return math.round(
    math.evaluate(`(${fee} / ${BPS_CONVERSION}) * ${total}`),
    2
  );
};

export const calculatePriceImpact = (
  pool: Pool,
  tokenIn: TokenMetadata,
  tokenOut: TokenMetadata,
  tokenInAmount: string
) => {
  const in_balance = toReadableNumber(
    tokenIn.decimals,
    pool.supplies[tokenIn.id]
  );
  const out_balance = toReadableNumber(
    tokenOut.decimals,
    pool.supplies[tokenOut.id]
  );

  const constant_product = math.evaluate(`${in_balance} * ${out_balance}`);

  const marketPrice = math.evaluate(`(${in_balance} / ${out_balance})`);

  const new_in_balance = math.evaluate(`${tokenInAmount} + ${in_balance}`);

  const new_out_balance = math.divide(constant_product, new_in_balance);

  const tokenOutReceived = math.subtract(
    math.evaluate(out_balance),
    new_out_balance
  );

  const newMarketPrice = math.evaluate(
    `${tokenInAmount} / ${tokenOutReceived}`
  );

  const PriceImpact = percent(
    subtraction(newMarketPrice, marketPrice),
    marketPrice
  ).toString();

  return PriceImpact;
};
export const calculateExchangeRate = (
  fee: number,
  from: string,
  to: string
) => {
  return math.round(math.evaluate(`${to} / ${from}`), 4);
};

export const subtraction = (initialValue: string, toBeSubtract: string) => {
  return math.format(math.evaluate(`${initialValue} - ${toBeSubtract}`), {
    notation: 'fixed',
  });
};

export const percentOf = (percent: number, num: number | string) => {
  return math.evaluate(`${convertToPercentDecimal(percent)} * ${num}`);
};

export const percentLess = (percent: number, num: number | string) => {
  return math.format(math.evaluate(`${num} - ${percentOf(percent, num)}`), {
    notation: 'fixed',
  });
};

export function formatWithCommas(value: string): string {
  const pattern = /(-?\d+)(\d{3})/;
  while (pattern.test(value)) {
    value = value.replace(pattern, '$1,$2');
  }
  return value;
}

export const percent = (numerator: string, denominator: string) => {
  return math.evaluate(`(${numerator} / ${denominator}) * 100`);
};

export const calculateFairShare = ({
  shareOf,
  contribution,
  totalContribution,
}: {
  shareOf: string;
  contribution: string;
  totalContribution: string;
}) => {
  return math.format(
    math.evaluate(`(${shareOf} * ${contribution}) / ${totalContribution}`),
    {
      notation: 'fixed',
      precision: 0,
    }
  );
};

export const toInternationalCurrencySystem = (
  labelValue: string,
  percent?: number
) => {
  return Math.abs(Number(labelValue)) >= 1.0e9
    ? (Math.abs(Number(labelValue)) / 1.0e9).toFixed(percent || 2) + 'B'
    : Math.abs(Number(labelValue)) >= 1.0e6
    ? (Math.abs(Number(labelValue)) / 1.0e6).toFixed(percent || 2) + 'M'
    : Math.abs(Number(labelValue)) >= 1.0e3
    ? (Math.abs(Number(labelValue)) / 1.0e3).toFixed(percent || 2) + 'K'
    : Math.abs(Number(labelValue)).toFixed(percent || 2);
};

'''
'''--- src/utils/token.ts ---
export const toRealSymbol = (symbol: string) => {
  if (symbol === 'nWETH' || symbol === 'WETH') return 'wETH';
  return symbol.charAt(0) === 'n' &&
    symbol.charAt(1) === symbol.charAt(1).toUpperCase()
    ? symbol.substring(1)
    : symbol;
};

export const getMftTokenId = (id: string) => {
  return ':' + id;
};

'''
'''--- src/worker.ts ---
import { keyStores, Near } from 'near-api-js';
import db, { FarmDexie } from './store/RefDatabase';
import getConfig from './services/config';
import { TokenMetadata } from '~services/ft-contract';
import { Farm } from '~services/farm';
import { getPoolDetails } from '~services/pool';

const config = getConfig();

const MAX_PER_PAGE = 100;

const near = new Near({
  keyStore: new keyStores.InMemoryKeyStore(),
  ...config,
});

const view = ({
  methodName,
  args = {},
}: {
  methodName: string;
  args?: object;
}) => {
  return near.connection.provider
    .query({
      request_type: 'call_function',
      finality: 'final',
      account_id: config.REF_FI_CONTRACT_ID,
      method_name: methodName,
      args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
    })
    .then(res => {
        const indexResult = 'result' as any;
        return JSON.parse(Buffer.from(res[indexResult]).toString());
    });
};

const farmView = ({
  methodName,
  args = {},
}: {
  methodName: string;
  args?: object;
}) => {
  return near.connection.provider
    .query({
      request_type: 'call_function',
      finality: 'final',
      account_id: config.REF_FARM_CONTRACT_ID,
      method_name: methodName,
      args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
    })
    .then(res => {
        const indexResult = 'result' as any;
        return JSON.parse(Buffer.from(res[indexResult]).toString());
    });
};

const getTotalPools = () => {
  return view({ methodName: 'get_number_of_pools' });
};

const getPools = (page: number) => {
  const index = (page - 1) * MAX_PER_PAGE;

  return view({
    methodName: 'get_pools',
    args: { from_index: index, limit: MAX_PER_PAGE },
  });
};

const getTokens = async () => {
  return await fetch(config.indexerUrl + '/list-token', {
    method: 'GET',
    headers: { 'Content-type': 'application/json; charset=UTF-8' },
  })
    .then((res) => res.json())
    .then((tokens) => {
      return tokens;
    });
};

const getFarms = (page: number) => {
  const index = (page - 1) * MAX_PER_PAGE;

  return farmView({
    methodName: 'list_farms',
    args: { from_index: index, limit: MAX_PER_PAGE },
  });
};

const cachePools = async () => {
  const totalPools = await getTotalPools();
  const pages = Math.ceil(totalPools / MAX_PER_PAGE);
  for (let page = 1; page <= pages; page++) {
    const pools = await getPools(page);
    await db.pools.bulkPut(
      pools.map(
        (
          pool: {
            token_account_ids: any[];
            amounts: any[];
            total_fee: any;
            shares_total_supply: any;
          },
          i: number
        ) => ({
          id: (page - 1) * MAX_PER_PAGE + i,
          token1Id: pool.token_account_ids[0],
          token2Id: pool.token_account_ids[1],
          token1Supply: pool.amounts[0],
          token2Supply: pool.amounts[1],
          fee: pool.total_fee,
          shares: pool.shares_total_supply,
        })
      )
    );
  }
};

const cacheTokens = async () => {
  const tokens = await getTokens();
  const tokenArr = Object.keys(tokens).map((key) => ({
    id: key,
    icon: tokens[key].icon,
    decimals: tokens[key].decimals,
    name: tokens[key].name,
    symbol: tokens[key].symbol,
  }));
  await db.tokens.bulkPut(
    tokenArr.map((token: TokenMetadata) => ({
      id: token.id,
      name: token.name,
      symbol: token.symbol,
      decimals: token.decimals,
      icon: token.icon,
    }))
  );
};

const cacheFarmPools = async () => {
  const farms: Farm[] = await getFarms(1);
  const farmsArr = Object.keys(farms).map((key) => ({
    id: key,
    pool_id: farms[Number(key)].farm_id.slice(
      farms[Number(key)].farm_id.indexOf('@') + 1,
      farms[Number(key)].farm_id.lastIndexOf('#')
    ),
    status: farms[Number(key)].farm_status,
  }));
  await db.farms.bulkPut(
    farmsArr.map((farm: FarmDexie) => ({
      id: farm.id,
      pool_id: farm.pool_id,
      status: farm.status,
    }))
  );
};

run();
type getPoolResponse = {
    token_account_ids: any[];
    amounts: any[];
    total_fee: any;
    shares_total_supply: any;
  };
  async function run() {
	return new Promise(async (resolve, reject) => {

        //const poolDetail = await getPoolDetails(87);
		// Will have return values in the future.
		await cachePools();
		const pools = await (async () =>
			(async ($page?: number | undefined) => {
				const page = $page || 1;
				const pools = (await getPools(page)) as Array<getPoolResponse>;
				if (page < 10) {
					const nextsPagePools = (await getPools(
						page + 1
					)) as Array<getPoolResponse>;
					return pools.concat(nextsPagePools);
				}
				return pools;
			})())();

		await cacheTokens();
		const tokensE = (await getTokens()) as Record<any, any>;
		const tokens = Object.keys(tokensE).map(key => ({
			id: key,
			icon: tokensE[key].icon,
			decimals: tokensE[key].decimals,
			name: tokensE[key].name,
			symbol: tokensE[key].symbol,
		})) as Array<TokenMetadata>;

		await cacheFarmPools();
		const farms = (await (async () =>
			(async ($page?: number | undefined) => {
				const page = $page || 1;
				const items = (await getFarms(page)) as Array<Farm>;
				if (page < 10) {
					const nextPageItems = (await getFarms(
						page + 1
					)) as Array<Farm>;
					return items.concat(nextPageItems);
				}
				return items;
			})())()) as Array<Farm>;
            resolve({pools, tokens, farms, poolDetail});
	}).then(workers => {
		console.log('============== Start to run worker file ===============');
		console.log(workers);
		console.log('============== Stop to run worker file ===============');
	});
}
'''
'''--- tailwind.config.js ---
const colors = require('tailwindcss/colors');
const defaultTheme = require('tailwindcss/defaultTheme');

module.exports = {
  purge: [],
  darkMode: false, // or 'media' or 'class'
  theme: {
    screens: {
      xs: { min: '300px', max: '600px' },
      md: { min: '600px', max: '1024px' },
      lg: { min: '1024px' },
      xl: { min: '1280px' },
      '2xl': { min: '1536px' },
      '3xl': { min: '1792px' },
    },
    boxShadow: { '4xl': '0px 0px 10px 4px rgba(0, 0, 0, 0.35)' },
    extend: {
      backgroundImage: (theme) => ({
        farmSearch: 'linear-gradient(106.25deg, #00FFD1 6.88%, #00BA98 81.93%)',
      }),
      gridTemplateColumns: {
        farmSearch: '2fr 1fr',
        farmContainer: '1fr 4fr',
        farmContainerOther: '1.2fr 3fr'
      },
      colors: {
        primary: '#10B981',
        primaryScale: colors.green,
        secondary: '#F9FAFB',
        secondaryScale: colors.gray,
        darkText: colors.gray['600'],
        inputBg: colors.gray['100'],
        inputText: '#374151',
        hoverGray: '#F3F4F6',
        buttonBg: '#10B981',
        buttonText: '#F9FAFB',
        greenLight: '#00C08B',
        greenOpacity100: 'rgba(2, 109, 97, 1)',
        whiteOpacity85: 'rgba(255, 255, 255, 0.85)',
        blackLight: '#003648',
        greenLight1: '#01C08B',
        cardBg: '#1D2932',
        chartBg: '#001320',
        warn: '#DEA550',
        error: '#DE5050',
        gradientFrom: '#00c6a2',
        gradientTo: '#008b72',
        gradientFromHover: '#00D6AF',
        gradientToHover: '#00967B',
        poolRowHover: '#001320',
        primaryText: '#7E8A93',
        inputDarkBg: 'rgba(0, 0, 0, 0.2)',
        navHighLightBg: '#304452',
        navHighLightText: '#C6D1DA',
        slipBg: '#3e4e59',
        farmText: '#73818B',
        farmSplitLine: '#314351',
        farmDark: '#2B3A44',
        framBorder: '#00C6A2',
        farmSbg: '#2F3D47',
        farmRound: '#B3C2CC',
        farmTopRight: '#008870',
        datebg:'#637684'
      },
      fontFamily: {
        sans: ['Poppins', ...defaultTheme.fontFamily.sans],
      },
    },
    plugins: [],
  },
  variants: {
    extend: {
      opacity: ['disabled'],
      borderWidth: ['hover'],
      cursor: ['disabled'],
      padding: ['last'],
    },
  },
};

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "baseUrl": "./src",
    "paths": {
      "~*": ["./*"]
    },
    "noEmit": true,
    "target": "es6",
    "lib": ["ES2020", "DOM"],
    "module": "commonjs",
    "noImplicitAny": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "esModuleInterop": true,
    "jsx": "react",
    "moduleResolution": "Node",
    "sourceMap": true,
    "forceConsistentCasingInFileNames": true,
    "downlevelIteration": true,
    "skipLibCheck": true, /* Skip type checking of declaration files. */
    "suppressImplicitAnyIndexErrors": true
  },
  "include": ["src/"],
  "exclude": ["node_modules/*", "**/*.spec.ts", "src/index.tsx"]
}

'''