*GitHub Repository "Learn-NEAR/NCD--heritage"*

'''--- README.md ---
# Near-heritage: The spicy hello word

This repository includes a complete project structure for AssemblyScript contracts targeting the NEAR platform. This is an spicy "hello world" in assemblyscript for new developers.

The goal of this project is to have a smart contract where a user adds NEARs to the smart contract for a limit of time and having the restriction that only the selected wallet can unlock these NEARs.

The example here is very basic.  It's a simple contract demonstrating the following concepts:

- a single contract
- basic usage of timestamps
- basic contract storage
- basic usage of VMContext in the unit tests

The goal of this repository is to make it as easy as possible to get started writing unit and simulation tests for AssemblyScript contracts built to work with NEAR Protocol.

## Usage

### Getting started

1. clone this repo to a local folder
2. run `yarn`
3. run `yarn test`

### Top-level `yarn` commands

- run `yarn test` to run all tests
  - (!) be sure to run `yarn build:release` at least once before:
    - run `yarn test:unit` to run only unit tests
    - run `yarn test:simulate` to run only simulation tests
- run `yarn build` to quickly verify build status
- run `yarn clean` to clean up build folder

### Other documentation

- Sample contract and test documentation
  - see `/src/heritage/README` for contract interface
  - see `/src/heritage/__tests__/README` for Sample unit testing details

- Sample contract simulation tests
  - see `/simulation/README` for simulation testing

## The file system

Please note that boilerplate project configuration files have been ommitted from the following lists for simplicity.

### Contracts and Unit Tests

```txt
src
├── heritage                        <-- heritage contract
│   ├── README.md
│   ├── __tests__
│   │   ├── README.md
│   │   └── index.unit.spec.ts
│   └── assembly
│       ├── index.ts
│       └── models.ts
└── utils.ts                      <-- shared contract code
```

### Helper Scripts

```txt
scripts
├── 1.init.sh
├── 2.run.sh
└── README.md                     <-- instructions
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/heritage"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--assemblyscript",
  "version": "0.0.1",
  "description": "Starter project for writing AssemblyScript contracts for NEAR Protocol",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn build:release && yarn test:unit && yarn test:simulate",
    "test:simulate": "cargo test -- --nocapture",
    "clean": "rm -rf ./build && rm -rf ./neardev && rm -rf ./target"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {},
  "dependencies": {
    "near-cli": "^2.0.2",
    "near-sdk-as": "^3.0.0",
    "near-sdk-simulator": "^3.2.1"
  }
}

'''
'''--- scripts/1.init.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER

echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release

echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./build/release/sample.wasm

echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo
echo

exit 0

'''
'''--- scripts/2.run.sh ---
#!/usr/bin/env bash
set -e

echo
echo \$CONTRACT is $CONTRACT
echo \$OWNER is $OWNER
echo

# these functions are all "view" functions so they don't require a signature
near view $CONTRACT showYouKnow     # this one returns false (function return value is void)
near view $CONTRACT showYouKnow2    # this one returns true
near view $CONTRACT sayHello        # this one returns a literal string

# ------------------------
# the next method uses a host function to retrieve the caller's name so it needs to be a CHANGE function (using "call" here)
# you can read more about host function restrictions here: https://docs.near.org/docs/develop/contracts/as/intro#view-and-change-functions
# ----
# near view $CONTRACT sayMyName
# ----
# so this is the solution, to replace "view" with "call" and include a signer
near call $CONTRACT sayMyName --account_id $OWNER
# ------------------------

# ------------------------
# the next method writes to storage.  storage is structured as key-value pairs
near call $CONTRACT saveMyName --account_id $OWNER
# ------------------------

# ------------------------
# these methods use a collection wrapper around blockchain storage
# you can read more about collections here: https://docs.near.org/docs/concepts/data-storage
near call $CONTRACT saveMyMessage '{"message":"hey again"}' --account_id $OWNER
near call $CONTRACT getAllMessages --account_id $OWNER
# ------------------------

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder support a simple demonstration of the contract.

It uses the following setup:

```txt
┌───────────────────────────────────────┬───────────────────────────────────────┐
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                   A                   │                   B                   │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
└───────────────────────────────────────┴───────────────────────────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands
  ```sh
  1.init.sh               # cleanup, compile and deploy contract
  2.run.sh                # call methods on the deployed contract
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linux-watch-command#191068)

'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/heritage/__tests__/README.md ---
## Unit tests

Unit tests can be run from the top level folder using the following command:

```
yarn test:unit
```

### Tests for Contract in `index.unit.spec.ts`

```
[Describe]: Staked class

 [Success]: ✔ should initialize correctly
 [Success]: ✔ owner should be set correctly
 [Success]: ✔ balance should be initialized correctly

[Describe]: Deposit funds

 [Success]: ✔ Can't deposit less than 0 funds
 [Success]: ✔ Can deposit funds
 [Success]: ✔ Can deposit funds and these funds are deposited
 [Success]: ✔ Total fundings in the contract should be ONE NEAR
 [Success]: ✔ Total fundings in the contract should be TWO NEAR
 [Success]: ✔ Alice deposit should be ONE NEAR
 [Success]: ✔ Alice deposit should be ONE NEAR and Bob deposit should be ONE NEAR and total funds should be TWO NEAR

[Describe]: WithDraw funds

 [Success]: ✔ Alice cannot withdraw funds during the locked time
 [Success]: ✔ Alice can withdraw funds after the locked time
 [Success]: ✔ Contract amount should be 0 NEAR after withdraw
 [Success]: ✔ Alice cannot withdraw funds two times
 [Success]: ✔ Bob cannot withdraw funds

    [File]: src/heritage/__tests__/index.unit.spec.ts
  [Groups]: 4 pass, 4 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 15 pass,  0 fail, 15 total
    [Time]: 223.96ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: ✔ PASS
   [Files]: 1 total
  [Groups]: 4 count, 4 pass
   [Tests]: 15 pass, 0 fail, 15 total
    [Time]: 16122.843ms
```

'''
'''--- src/heritage/__tests__/index.unit.spec.ts ---
import {
  initContract,
  deleteContract,
  depositFunds,
  getDepositedFunds,
  getTotalFunds,
  withdrawFunds
} from "../assembly";
import { VMContext, u128 } from "near-sdk-as";

import {Staked} from '../assembly/models';
import { ZERO_NEAR, ONE_NEAR, TWO_NEAR, Timestamp } from "../../utils";

let contract: Staked;
let contract_name = "HeritageContract";
const alice = "alice";
const bob = "bob";
const lockedTimestamp: Timestamp = 1000000; // Unix Timestamp

beforeEach(() => {
  VMContext.setCurrent_account_id(contract_name);
  VMContext.setAccount_balance(ONE_NEAR); 
  VMContext.setSigner_account_id(alice);

  contract = new Staked(alice);

});

describe("Staked class", () => {

  it("should initialize correctly", () => {
      expect(contract).not.toBeNull();
  });

  it("owner should be set correctly", () => {
      expect(contract.account_id).toBe(alice);
  });

  it("balance should be initialized correctly", () => {
      expect(contract.storedTokens).toBe(u128.Zero);
  });
});

describe("Deposit funds", () => {

  beforeEach(() => {
    VMContext.setCurrent_account_id(contract_name);
    VMContext.setAccount_balance(ONE_NEAR); 
    VMContext.setSigner_account_id(alice);
    initContract(alice, lockedTimestamp);

  })

  it("Can't deposit less than 0 funds", () => {
    VMContext.setAttached_deposit(ZERO_NEAR);

      expect(() => {
          depositFunds(alice);
      }).toThrow();
  });

  it("Can deposit funds", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
      expect(() => {
        depositFunds(alice)
      }).not.toThrow();
  });

  it("Can deposit funds and these funds are deposited", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    depositFunds(alice);
    const funds = getDepositedFunds();
    expect(funds.getSome(alice).account_id).toBe(alice);
  });

  it("Total fundings in the contract should be ONE NEAR", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    const storedFundings = depositFunds(alice);
    expect(storedFundings).toBe(ONE_NEAR);
  });

  it("Total fundings in the contract should be TWO NEAR", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    depositFunds(alice);

    VMContext.setAttached_deposit(ONE_NEAR);
    depositFunds(bob);

    const storedFundings = getTotalFunds();

    expect(storedFundings).toBe(TWO_NEAR);
  });

  it("Alice deposit should be ONE NEAR", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    depositFunds(alice);
    const funds = getDepositedFunds();
    expect(funds.getSome(alice).storedTokens).toBe(ONE_NEAR);
  });

  it("Alice deposit should be ONE NEAR and Bob deposit should be ONE NEAR and total funds should be TWO NEAR", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    depositFunds(alice);

    VMContext.setAttached_deposit(ONE_NEAR);
    depositFunds(bob);
    const funds = getDepositedFunds();
    expect(funds.getSome(alice).storedTokens).toBe(ONE_NEAR);
    expect(funds.getSome(bob).storedTokens).toBe(ONE_NEAR);

    const totalFunds = getTotalFunds();
    expect(totalFunds).toBe(TWO_NEAR);
  });
  afterEach(() => {
    deleteContract();
  })

  });
describe("WithDraw funds", () => {

  beforeEach(() => {
    VMContext.setCurrent_account_id(contract_name);
    VMContext.setSigner_account_id(alice);
    initContract(alice, lockedTimestamp);
    VMContext.setAttached_deposit(ONE_NEAR);
    depositFunds(alice);

  });
  
  it("Alice cannot withdraw funds during the locked time", () => {
    VMContext.setBlock_timestamp(0);
    expect(() => { 
      withdrawFunds();
    }).toThrow();
  });

  it("Alice can withdraw funds after the locked time", () => {
      VMContext.setBlock_timestamp(lockedTimestamp + 1); 
      const amount = withdrawFunds();
      expect(amount).toBe(ONE_NEAR);
  });

  it("Contract amount should be 0 NEAR after withdraw", () => {
    VMContext.setBlock_timestamp(lockedTimestamp + 1);
    expect(getTotalFunds()).toBe(ONE_NEAR); 
    
    const amount = withdrawFunds();
    expect(amount).toBe(ONE_NEAR);

    const totalFunds = getTotalFunds();
    expect(totalFunds).toBe(ZERO_NEAR);  
  });  

  it("Alice cannot withdraw funds two times", () => {
    VMContext.setBlock_timestamp(lockedTimestamp + 1); 
    withdrawFunds();
    expect(() => {
      withdrawFunds();
    }).toThrow();
  });

  it("Bob cannot withdraw funds", () => {
    VMContext.setBlock_timestamp(lockedTimestamp + 1); 
    VMContext.setSigner_account_id(bob);
    expect(() => {
      withdrawFunds();
    }).toThrow();
  });
});  

'''
'''--- src/heritage/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/heritage/assembly/index.ts ---
import { context, logging, storage, PersistentUnorderedMap, u128, ContractPromiseBatch } from "near-sdk-as";
import {AccountId, Balance, Amount, Timestamp} from "../../utils";
import {Contract, Staked} from './models';

/**************************/
/* STORAGE AND COLLECTIONS */
/**************************/

const CONTRACT = "Heritage";

/**************************/
/* PUBLIC METHODS */
/**************************/

export function initContract(owner : AccountId, lockedTime: Timestamp): void {
  assert(!storage.hasKey(CONTRACT), 'Already initialized');
  let contract = new Contract(owner, lockedTime);
  _saveContract(contract);
}

export function deleteContract(): void {
  _onlyOwner();
  storage.delete(CONTRACT);
}

export function depositFunds(account: AccountId): Balance{
  _isInit();

  // Check if the users have attached Nears to the transaction
  assert(context.attachedDeposit > u128.Zero, "Deposit should be bigger than 0");
  

  let amount: Amount = context.attachedDeposit;
  let contract: Contract = _getData();
  contract.storedTokens = u128.add(contract.storedTokens, amount);

  let depositor: Staked;

  // Let's check if we are already staking Nears for this account
  if (!contract.depositors.contains(account)){
    depositor = new Staked(account);
  }
  else {
    depositor = contract.depositors.getSome(account);
  }
   
  let storedTokens : Balance = depositor.deposit(amount);
  contract.depositors.set(account, depositor);
  _saveContract(contract);

  return storedTokens;
}

export function withdrawFunds(): Balance {
  _isInit();
  let contract: Contract = _getData();
  assert(contract.lockedTime < context.blockTimestamp, "This user cannot unlock the funding yet");
  assert(contract.depositors.contains(context.sender), "This user is not allowed to call this method" );

  let depositor: Staked = contract.depositors.getSome(context.sender);
  logging.log(depositor);
  let amount: Balance = depositor.storedTokens;

  // Remove balance
  contract.storedTokens = u128.sub(contract.storedTokens, amount);

  ContractPromiseBatch.create(context.sender).transfer(amount);
  contract.depositors.delete(context.sender);

  _saveContract(contract);

  return amount;
}

export function getDepositedFunds(): PersistentUnorderedMap<AccountId, Staked>{
  _isInit();
  let contract: Contract = _getData();
  return contract.depositors;
}

export function getTotalFunds(): Balance{
  let contract: Contract = _getData();
  return contract.storedTokens;
}

// /**************************/
// /* PRIVATE METHODS */
// /**************************/

function _saveContract(contract: Contract) : void {
  storage.set(CONTRACT, contract);
}

function _getData() : Contract {
  return storage.getSome<Contract>(CONTRACT);
}

function _isInit(): void {
  assert(storage.hasKey(CONTRACT), 'The contract should be initialized before usage.')
}

function _onlyOwner(): void{
  assert(context.sender == storage.getSome<Contract>(CONTRACT).owner, "Only the owner can call this method");
}

'''
'''--- src/heritage/assembly/models.ts ---

import {
    context,
    PersistentUnorderedMap,
    u128
} from "near-sdk-as";

import {AccountId, Balance, Amount, Timestamp} from "../../utils";

//To serialize the class
@nearBindgen
export class Contract {
    public owner: AccountId;
    public paused: bool = true;
    public storedTokens: Balance;
    public lockedTime: Timestamp;
    public depositors: PersistentUnorderedMap<AccountId, Staked> = new PersistentUnorderedMap<AccountId, Staked>("d");
  
  
    constructor(owner : AccountId, lockedTime: Timestamp) {
        this.storedTokens = u128.Zero;
        this.owner = owner;
        this.lockedTime = lockedTime;
    }
}

@nearBindgen
export class Staked {
    public storedTokens: Balance;
    public account_id: AccountId;

    constructor(
        account_id : AccountId,
    ) {
        this.storedTokens = u128.Zero;
        this.account_id = account_id;
    }
    @mutateState()
    deposit(amount: Amount): Balance{
        assert(context.attachedDeposit > u128.Zero, "Deposit should be bigger than 0");
        this.storedTokens = u128.add(this.storedTokens, amount);
        return this.storedTokens;
    }
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128 } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ZERO_NEAR = u128.from("0000000000000000000000000");
export const ONE_NEAR = u128.from("1000000000000000000000000");
export const TWO_NEAR = u128.from("2000000000000000000000000");

export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

'''