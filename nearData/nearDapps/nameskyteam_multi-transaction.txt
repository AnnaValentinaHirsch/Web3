*GitHub Repository "nameskyteam/multi-transaction"*

'''--- .changeset/README.md ---
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)

'''
'''--- .changeset/config.json ---
{
  "$schema": "https://unpkg.com/@changesets/config@3.0.0/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "fixed": [],
  "linked": [],
  "access": "public",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}

'''
'''--- .eslintrc.json ---
{
  "root": true,
  "parser": "@typescript-eslint/parser",
  "plugins": [
    "@typescript-eslint"
  ],
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "rules": {
    "eol-last": "error"
  }
}

'''
'''--- .lintstagedrc.js ---
module.exports = {
  "*.ts": () => [
    "pnpm lint",
    "pnpm prettier",
  ],
};

'''
'''--- .prettierrc.json ---
{
  "singleQuote": true,
  "printWidth": 120
}

'''
'''--- README.md ---
# Multi Transaction
Make the construction of the transaction easier on [NEAR](https://near.org) blockchain

## Install
```shell
pnpm add multi-transaction
```

This package includes following sub packages, you can also install with your needs

```shell
pnpm add @multi-transaction/core
```

```shell
pnpm add @multi-transaction/account
```

```shell
pnpm add @multi-transaction/wallet-selector
```

## MultiTransaction
```ts
import { MultiTransaction, Amount, Gas } from 'multi-transaction';
```

```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'bob.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  });
```

More information about [MultiTransaction](packages/core/README.md)

## MultiSendAccount
```ts
import { MultiSendAccount } from 'multi-transaction';
```

```ts
const account = MultiSendAccount.new(connection, 'alice.near');
```

```ts
await account.send(mTransaction);
```

More information about [MultiSendAccount](packages/account/README.md)

## MultiSendWalletSelector
```ts
import { setupMultiSendWalletSelector } from 'multi-transaction';
```

```ts
const selector = await setupMultiSendWalletSelector({
  network: 'mainnet',
  modules: [
    /* wallet modules */
  ],
});
```

```ts
await selector.send(mTransaction);
```

More information about [MultiSendWalletSelector](packages/wallet-selector/README.md)

'''
'''--- package.json ---
{
  "private": true,
  "name": "@multi-transaction/monorepo",
  "scripts": {
    "all": "turbo all --no-daemon",
    "build": "turbo build --no-daemon",
    "lint": "turbo lint --no-daemon",
    "prettier": "turbo prettier --no-daemon",
    "prepare": "husky"
  },
  "dependencies": {
    "@near-js/accounts": "^1.0.4",
    "@near-js/crypto": "^1.2.1",
    "@near-js/transactions": "^1.1.2",
    "@near-js/types": "^0.0.4",
    "@near-js/utils": "^0.1.0",
    "@near-js/wallet-account": "^1.1.1"
  },
  "devDependencies": {
    "@changesets/cli": "^2.27.1",
    "@typescript-eslint/eslint-plugin": "^7.3.1",
    "@typescript-eslint/parser": "^7.3.1",
    "eslint": "^8.57.0",
    "husky": "^9.0.11",
    "lint-staged": "^15.2.2",
    "prettier": "^3.2.5",
    "turbo": "^1.13.0",
    "typescript": "^5.4.3"
  }
}

'''
'''--- packages/account/README.md ---
# Multi Transaction Account
Multi Transaction Account implementation

## Install
```shell
pnpm add @multi-transaction/core @multi-transaction/account
```

## Examples
```ts
import { MultiTransaction, Amount, Gas } from '@multi-transaction/core';
import { MultiSendAccount } from '@multi-transaction/account';
```

```ts
const account = MultiSendAccount.new(connection, 'alice.near');
```

### Send Transaction(s)
```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'bob.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  });

await account.send(mTransaction);
```

### Call Contract Method
```ts
await account.call({
  contractId: 'wrap.near',
  methodName: 'ft_transfer',
  args: {
    receiver_id: 'bob.near',
    amount: Amount.parse('8.88', 'NEAR'),
  },
  attachedDeposit: Amount.ONE_YOCTO,
  gas: Gas.parse('10', 'T'),
});
```

### View Contract Method
```ts
const amount: string = await account.view({
  contractId: 'wrap.near',
  methodName: 'ft_balance_of',
  args: {
    account_id: 'alice.near',
  },
});
```

'''
'''--- packages/account/package.json ---
{
  "name": "@multi-transaction/account",
  "version": "1.2.1",
  "license": "MIT",
  "description": "Multi Transaction Account implementation.",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "commonjs",
  "files": [
    "dist",
    "src"
  ],
  "scripts": {
    "build": "rm -rf dist && tsc",
    "lint": "eslint src/{**,}/*.ts --fix",
    "prettier": "prettier src/{**,}/*.ts --write"
  },
  "dependencies": {
    "@multi-transaction/core": "workspace:*",
    "bn.js": "^5.2.1"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.5"
  }
}

'''
'''--- packages/account/src/MultiSendAccount.ts ---
import { Account, Connection } from '@near-js/accounts';
import { FinalExecutionOutcome } from '@near-js/types';
import {
  MultiTransaction,
  EmptyArgs,
  Send,
  SendOptions,
  SendRawOptions,
  Call,
  CallOptions,
  CallRawOptions,
  View,
  ViewOptions,
  Stringifier,
  Parser,
  BlockQuery,
  SendTransactionError,
  parseOutcomeValue,
  throwReceiptErrorsFromOutcomes,
} from '@multi-transaction/core';
import { parseNearApiJsTransactions } from './utils';

export class MultiSendAccount extends Account implements Send, Call, View {
  private constructor(connection: Connection, accountId: string) {
    super(connection, accountId);
  }

  static new(connection: Connection, accountId = ''): MultiSendAccount {
    return new MultiSendAccount(connection, accountId);
  }

  static fromAccount(account: Account): MultiSendAccount {
    return new MultiSendAccount(account.connection, account.accountId);
  }

  /**
   * Send multiple transactions and return success value of last transaction
   */
  async send<Value>(mTransaction: MultiTransaction, options: MultiSendAccountSendOptions<Value> = {}): Promise<Value> {
    const { parser, ...sendRawOptions } = options;
    const outcomes = await this.sendRaw(mTransaction, sendRawOptions);
    const outcome = outcomes[outcomes.length - 1];
    return parseOutcomeValue(outcome, parser);
  }

  /**
   * Send multiple transactions and return outcomes
   */
  async sendRaw(
    mTransaction: MultiTransaction,
    options: MultiSendAccountSendRawOptions = {},
  ): Promise<FinalExecutionOutcome[]> {
    const { throwReceiptErrors } = options;

    const transactions = parseNearApiJsTransactions(mTransaction);

    if (transactions.length === 0) {
      throw new SendTransactionError('Transaction not found.');
    }

    const outcomes: FinalExecutionOutcome[] = [];

    for (const transaction of transactions) {
      const outcome = await this.signAndSendTransaction({ ...transaction });
      outcomes.push(outcome);
    }

    if (throwReceiptErrors) {
      throwReceiptErrorsFromOutcomes(outcomes);
    }

    return outcomes;
  }

  /**
   * Call a contract method and return success value
   */
  async call<Value, Args = EmptyArgs>(options: MultiSendAccountCallOptions<Value, Args>): Promise<Value> {
    const { parser, ...callRawOptions } = options;
    const outcome = await this.callRaw(callRawOptions);
    return parseOutcomeValue(outcome, parser);
  }

  /**
   * Call a contract method and return outcome
   */
  async callRaw<Args = EmptyArgs>(options: MultiSendAccountCallRawOptions<Args>): Promise<FinalExecutionOutcome> {
    const { contractId, methodName, args, attachedDeposit, gas, stringifier, ...sendRawOptions } = options;

    const mTransaction = MultiTransaction.batch(contractId).functionCall({
      methodName,
      args,
      attachedDeposit,
      gas,
      stringifier,
    });

    const outcomes = await this.sendRaw(mTransaction, sendRawOptions);

    return outcomes[0];
  }

  /**
   * View a contract method and return success value
   */
  async view<Value, Args = EmptyArgs>(options: ViewOptions<Value, Args>): Promise<Value> {
    const {
      contractId,
      methodName,
      args,
      stringifier = Stringifier.json(),
      parser = Parser.json(),
      blockQuery = BlockQuery.OPTIMISTIC,
    } = options;

    return this.viewFunction({
      contractId,
      methodName,
      args: args as object,
      stringify: (args) => stringifier.stringifyOrSkip(args),
      parse: (buffer) => parser.parse(buffer),
      blockQuery: blockQuery.toReference(),
    });
  }
}

export type MultiSendAccountCallOptions<Value, Args> = CallOptions<Value, Args>;

export type MultiSendAccountCallRawOptions<Args> = CallRawOptions<Args>;

export type MultiSendAccountSendOptions<Value> = SendOptions<Value>;

export type MultiSendAccountSendRawOptions = SendRawOptions;

'''
'''--- packages/account/src/index.ts ---
export {
  MultiSendAccount,
  MultiSendAccountSendOptions,
  MultiSendAccountSendRawOptions,
  MultiSendAccountCallOptions,
  MultiSendAccountCallRawOptions,
} from './MultiSendAccount';

'''
'''--- packages/account/src/utils.ts ---
import BN from 'bn.js';
import { PublicKey } from '@near-js/crypto';
import { actionCreators, Action as NearApiJsAction, AccessKey as NearApiJsAccessKey } from '@near-js/transactions';
import { MultiTransaction, Transaction, Action, AccessKey, UnreachableError } from '@multi-transaction/core';

type NearApiJsTransaction = {
  receiverId: string;
  actions: NearApiJsAction[];
};

export function parseNearApiJsTransactions(mTransaction: MultiTransaction): NearApiJsTransaction[] {
  return mTransaction.toTransactions().map((transaction) => parseNearApiJsTransaction(transaction));
}

function parseNearApiJsTransaction(transaction: Transaction): NearApiJsTransaction {
  const { receiverId, actions } = transaction;
  return {
    receiverId,
    actions: actions.map((action) => parseNearApiJsAction(action)),
  };
}

function parseNearApiJsAction(action: Action): NearApiJsAction {
  if (action.type === 'CreateAccount') {
    return actionCreators.createAccount();
  }

  if (action.type === 'DeleteAccount') {
    const { beneficiaryId } = action.params;
    return actionCreators.deleteAccount(beneficiaryId);
  }

  if (action.type === 'AddKey') {
    const { publicKey, accessKey } = action.params;
    return actionCreators.addKey(PublicKey.fromString(publicKey), parseNearApiJsAccessKey(accessKey));
  }

  if (action.type === 'DeleteKey') {
    const { publicKey } = action.params;
    return actionCreators.deleteKey(PublicKey.fromString(publicKey));
  }

  if (action.type === 'DeployContract') {
    const { code } = action.params;
    return actionCreators.deployContract(code);
  }

  if (action.type === 'Stake') {
    const { amount, publicKey } = action.params;
    return actionCreators.stake(new BN(amount), PublicKey.fromString(publicKey));
  }

  if (action.type === 'FunctionCall') {
    const { methodName, args, gas, attachedDeposit } = action.params;
    return actionCreators.functionCall(methodName, args, new BN(gas), new BN(attachedDeposit));
  }

  if (action.type === 'Transfer') {
    const { amount } = action.params;
    return actionCreators.transfer(new BN(amount));
  }

  throw new UnreachableError();
}

function parseNearApiJsAccessKey(accessKey: AccessKey): NearApiJsAccessKey {
  if (accessKey.permission === 'FullAccess') {
    return actionCreators.fullAccessKey();
  } else {
    const { receiverId, methodNames, allowance } = accessKey.permission;
    return actionCreators.functionCallAccessKey(receiverId, methodNames, allowance ? new BN(allowance) : undefined);
  }
}

'''
'''--- packages/account/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "outDir": "dist",
    "importHelpers": false,
    // output .d.ts declaration files for consumers
    "declaration": true,
    // output .js.map sourcemap files for consumers
    "sourceMap": true,
    // match output dir to input dir. e.g. dist/index instead of dist/src/index
    // stricter type-checking for stronger correctness. Recommended by TS
    "strict": true,
    // linter checks for common issues
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    // noUnused* overlap with @typescript-eslint/no-unused-vars, can disable if duplicative
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    // use Node's module resolution algorithm, instead of the legacy TS one
    "moduleResolution": "node",
    // interop between ESM and CJS modules. Recommended by TS
    "esModuleInterop": true,
    // significant perf increase by skipping checking .d.ts files, particularly those in node_modules. Recommended by TS
    "skipLibCheck": true,
    // error out if import and file system have a casing mismatch. Recommended by TS
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}

'''
'''--- packages/core/README.md ---
# Multi Transaction Core
Multi Transaction Core implementation

## Install
```shell
pnpm add @multi-transaction/core
```

## Examples
```ts
import { MultiTransaction, Amount, Gas } from '@multi-transaction/core';
```

### Normal Transaction
One transaction that contains one action
```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'bob.near',
      amount: Amount.parse('8.88', 'NEAR')
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  });
```

### Batch Transaction
One transaction that contains multiple actions
```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'bob.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  })
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'carol.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  });
```

### Multiple Transactions
Multiple transactions and each contains one or more actions
```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'bob.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  })
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'carol.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  })
  .batch('usdt.tether-token.near')
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'david.near',
      amount: Amount.parse('8.88', 'USDT'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  });
```

### Fungible Token Transaction
```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .ft.transfer({
    args: {
      receiver_id: 'bob.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
  });
```

### Non-Fungible Token Transaction
```ts
const mTransaction = MultiTransaction
  .batch('core.namesky.near')
  .nft.transfer({
    args: {
      receiver_id: 'bob.near',
      token_id: 'apple.near',
    },
  });
```

### Storage Management Transaction
```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .storage.deposit({ 
    attachedDeposit: Amount.parse('0.01', 'NEAR'),
  });
```

'''
'''--- packages/core/package.json ---
{
  "name": "@multi-transaction/core",
  "version": "1.2.1",
  "license": "MIT",
  "description": "Multi Transaction Core implementation.",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "commonjs",
  "files": [
    "dist",
    "src"
  ],
  "scripts": {
    "build": "rm -rf dist && tsc",
    "lint": "eslint src/{**,}/*.ts --fix",
    "prettier": "prettier src/{**,}/*.ts --write"
  },
  "dependencies": {
    "bignumber.js": "^9.1.2",
    "borsher": "^3.5.0",
    "buffer": "^6.0.3"
  }
}

'''
'''--- packages/core/src/core/Actions.ts ---
import {
  CreateAccountAction,
  DeleteAccountAction,
  AddKeyAction,
  DeleteKeyAction,
  DeployContractAction,
  StakeAction,
  FunctionCallAction,
  TransferAction,
  DeleteAccountParams,
  AddKeyParams,
  DeleteKeyParams,
  DeployContractParams,
  StakeParams,
  FunctionCallParams,
  TransferParams,
} from '../types';

export class Actions {
  private constructor() {}

  static createAccount(): CreateAccountAction {
    return {
      type: 'CreateAccount',
    };
  }

  static deleteAccount(params: DeleteAccountParams): DeleteAccountAction {
    return {
      type: 'DeleteAccount',
      params,
    };
  }

  static addKey(params: AddKeyParams): AddKeyAction {
    return {
      type: 'AddKey',
      params,
    };
  }

  static deleteKey(params: DeleteKeyParams): DeleteKeyAction {
    return {
      type: 'DeleteKey',
      params,
    };
  }

  static deployContract(params: DeployContractParams): DeployContractAction {
    return {
      type: 'DeployContract',
      params,
    };
  }

  static stake(params: StakeParams): StakeAction {
    return {
      type: 'Stake',
      params,
    };
  }

  static functionCall(params: FunctionCallParams): FunctionCallAction {
    return {
      type: 'FunctionCall',
      params,
    };
  }

  static transfer(params: TransferParams): TransferAction {
    return {
      type: 'Transfer',
      params,
    };
  }
}

'''
'''--- packages/core/src/core/MultiAction.ts ---
import { Actions } from './Actions';
import {
  Amount,
  Gas,
  Stringifier,
  fungibleTokenFunctionCall,
  nonFungibleTokenFunctionCall,
  storageManagementFunctionCall,
} from '../utils';
import {
  EmptyArgs,
  AccessKey,
  Action,
  FunctionCallOptions,
  FungibleTokenFunctionCall,
  NonFungibleTokenFunctionCall,
  StorageManagementFunctionCall,
} from '../types';

export class MultiAction {
  private readonly actions: Action[];

  private constructor() {
    this.actions = [];
  }

  private addActions(actions: Action[]): this {
    this.actions.push(...actions);
    return this;
  }

  static fromActions(actions: Action[]): MultiAction {
    return MultiAction.new().addActions(actions);
  }

  toActions(): Action[] {
    return Array.from(this.actions);
  }

  countActions(): number {
    return this.actions.length;
  }

  extend(mAction: MultiAction): this {
    return this.addActions(mAction.actions);
  }

  static new(): MultiAction {
    return new MultiAction();
  }

  /**
   * Add a CreateAccount Action following previous actions
   */
  createAccount(): this {
    return this.addActions([Actions.createAccount()]);
  }

  /**
   * Add a DeleteAccount Action following previous actions
   */
  deleteAccount(beneficiaryId: string): this {
    return this.addActions([Actions.deleteAccount({ beneficiaryId })]);
  }

  /**
   * Add a AddKey Action following previous actions
   */
  addKey(publicKey: string, accessKey: AccessKey): this {
    return this.addActions([
      Actions.addKey({
        publicKey,
        accessKey,
      }),
    ]);
  }

  /**
   * Add a DeleteKey Action following previous actions
   */
  deleteKey(publicKey: string): this {
    return this.addActions([Actions.deleteKey({ publicKey })]);
  }

  /**
   * Add a DeployContract Action following previous actions
   */
  deployContract(code: Uint8Array): this {
    return this.addActions([Actions.deployContract({ code })]);
  }

  /**
   * Add a Stake Action following previous actions
   */
  stake(amount: string, publicKey: string): this {
    return this.addActions([Actions.stake({ amount, publicKey })]);
  }

  /**
   * Add a FunctionCall Action following previous actions
   */
  functionCall<Args = EmptyArgs>(options: FunctionCallOptions<Args>): this {
    const {
      methodName,
      args = {} as Args,
      attachedDeposit = Amount.ZERO,
      gas = Gas.DEFAULT,
      stringifier = Stringifier.json(),
    } = options;

    return this.addActions([
      Actions.functionCall({
        methodName,
        args: stringifier.stringifyOrSkip(args),
        attachedDeposit,
        gas,
      }),
    ]);
  }

  /**
   * Add a Transfer Action following previous actions
   */
  transfer(amount: string): this {
    return this.addActions([Actions.transfer({ amount })]);
  }

  get ft(): FungibleTokenFunctionCall<this> {
    return fungibleTokenFunctionCall((options) => this.functionCall(options));
  }

  get nft(): NonFungibleTokenFunctionCall<this> {
    return nonFungibleTokenFunctionCall((options) => this.functionCall(options));
  }

  get storage(): StorageManagementFunctionCall<this> {
    return storageManagementFunctionCall((options) => this.functionCall(options));
  }
}

'''
'''--- packages/core/src/core/MultiTransaction.ts ---
import { MultiTransactionError } from '../errors';
import { fungibleTokenFunctionCall, nonFungibleTokenFunctionCall, storageManagementFunctionCall } from '../utils';
import {
  EmptyArgs,
  AccessKey,
  Transaction,
  FunctionCallOptions,
  FungibleTokenFunctionCall,
  NonFungibleTokenFunctionCall,
  StorageManagementFunctionCall,
} from '../types';
import { MultiAction } from './MultiAction';

export class MultiTransaction {
  private readonly transactions: InternalTransaction[];

  private constructor() {
    this.transactions = [];
  }

  private get transaction(): InternalTransaction {
    if (this.transactions.length === 0) {
      throw new MultiTransactionError('Transaction not found. Use `.batch` to add a transaction');
    }
    return this.transactions[this.transactions.length - 1];
  }

  private addTransactions(transactions: InternalTransaction[]): this {
    this.transactions.push(...transactions);
    return this;
  }

  static fromTransactions(transactions: Transaction[]): MultiTransaction {
    return MultiTransaction.new().addTransactions(fromTransactions(transactions));
  }

  toTransactions(): Transaction[] {
    return toTransactions(this.transactions);
  }

  countTransactions(): number {
    return this.transactions.length;
  }

  countActions(): number {
    return this.transaction.mAction.countActions();
  }

  extend(mTransaction: MultiTransaction): this {
    return this.addTransactions(mTransaction.transactions);
  }

  static new(): MultiTransaction {
    return new MultiTransaction();
  }

  /**
   * Create a transaction
   */
  static batch(receiverId: string, signerId?: string): MultiTransaction {
    return MultiTransaction.new().batch(receiverId, signerId);
  }

  /**
   * Add a transaction following previous transactions
   */
  batch(receiverId: string, signerId?: string): this {
    return this.addTransactions([{ signerId, receiverId, mAction: MultiAction.new() }]);
  }

  /**
   * Add actions following previous actions
   */
  addMultiAction(mAction: MultiAction): this {
    this.transaction.mAction.extend(mAction);
    return this;
  }

  /**
   * Add a CreateAccount Action following previous actions
   */
  createAccount(): this {
    this.transaction.mAction.createAccount();
    return this;
  }

  /**
   * Add a DeleteAccount Action following previous actions
   */
  deleteAccount(beneficiaryId: string): this {
    this.transaction.mAction.deleteAccount(beneficiaryId);
    return this;
  }

  /**
   * Add a AddKey Action following previous actions
   */
  addKey(publicKey: string, accessKey: AccessKey): this {
    this.transaction.mAction.addKey(publicKey, accessKey);
    return this;
  }

  /**
   * Add a DeleteKey Action following previous actions
   */
  deleteKey(publicKey: string): this {
    this.transaction.mAction.deleteKey(publicKey);
    return this;
  }

  /**
   * Add a DeployContract Action following previous actions
   */
  deployContract(code: Uint8Array): this {
    this.transaction.mAction.deployContract(code);
    return this;
  }

  /**
   * Add a Stake Action following previous actions
   */
  stake(amount: string, publicKey: string): this {
    this.transaction.mAction.stake(amount, publicKey);
    return this;
  }

  /**
   * Add a FunctionCall Action following previous actions
   */
  functionCall<Args = EmptyArgs>(options: FunctionCallOptions<Args>): this {
    this.transaction.mAction.functionCall(options);
    return this;
  }

  /**
   * Add a Transfer Action following previous actions
   */
  transfer(amount: string): this {
    this.transaction.mAction.transfer(amount);
    return this;
  }

  get ft(): FungibleTokenFunctionCall<this> {
    return fungibleTokenFunctionCall((options) => this.functionCall(options));
  }

  get nft(): NonFungibleTokenFunctionCall<this> {
    return nonFungibleTokenFunctionCall((options) => this.functionCall(options));
  }

  get storage(): StorageManagementFunctionCall<this> {
    return storageManagementFunctionCall((options) => this.functionCall(options));
  }
}

function fromTransactions(transactions: Transaction[]): InternalTransaction[] {
  return transactions.map(({ signerId, receiverId, actions }) => ({
    signerId,
    receiverId,
    mAction: MultiAction.fromActions(actions),
  }));
}

function toTransactions(transactions: InternalTransaction[]): Transaction[] {
  return transactions.map(({ signerId, receiverId, mAction }) => ({
    signerId,
    receiverId,
    actions: mAction.toActions(),
  }));
}

type InternalTransaction = Omit<Transaction, 'actions'> & {
  mAction: MultiAction;
};

'''
'''--- packages/core/src/core/index.ts ---
export * from './Actions';
export * from './MultiAction';
export * from './MultiTransaction';

'''
'''--- packages/core/src/errors/MultiTransactionError.ts ---
export class MultiTransactionError extends Error {
  constructor(message: string) {
    super(message);
  }
}

'''
'''--- packages/core/src/errors/ParseOutcomeError.ts ---
export class ParseOutcomeError extends Error {
  constructor(message: string) {
    super(message);
  }
}

'''
'''--- packages/core/src/errors/ReceiptError.ts ---
export class ReceiptError extends Error {
  constructor(messages: ReceiptErrorMessage[]) {
    super(JSON.stringify(messages));
  }
}

export type ReceiptErrorMessage = {
  index: number;
  kind: {
    ExecutionError: string;
  };
};

'''
'''--- packages/core/src/errors/SendTransactionError.ts ---
export class SendTransactionError extends Error {
  constructor(message: string) {
    super(message);
  }
}

'''
'''--- packages/core/src/errors/UnreachableError.ts ---
export class UnreachableError extends Error {
  constructor() {
    super();
  }
}

'''
'''--- packages/core/src/errors/index.ts ---
export * from './MultiTransactionError';
export * from './ParseOutcomeError';
export * from './ReceiptError';
export * from './UnreachableError';
export * from './SendTransactionError';

'''
'''--- packages/core/src/index.ts ---
import { BigNumber } from 'bignumber.js';
import { Buffer } from 'buffer';
import { MultiAction, MultiTransaction } from './core';
import { SendTransactionError, UnreachableError } from './errors';
import {
  Transaction,
  Action,
  AccessKey,
  Send,
  SendOptions,
  SendRawOptions,
  Call,
  CallOptions,
  CallRawOptions,
  View,
  ViewOptions,
  Numeric,
  EmptyArgs,
  FtTransferArgs,
  FtTransferCallArgs,
  FtBalanceOfArgs,
  FungibleTokenMetadata,
  NftTransferArgs,
  NftTransferCallArgs,
  NftTokenArgs,
  NftApproveArgs,
  NftRevokeArgs,
  NftRevokeAllArgs,
  NftIsApprovedArgs,
  NftTokensArgs,
  NftSupplyForOwnerArgs,
  NftTokensForOwnerArgs,
  Token,
  TokenMetadata,
  NFTContractMetadata,
  StorageDepositArgs,
  StorageWithdrawArgs,
  StorageUnregisterArgs,
  StorageBalanceOfArgs,
  StorageBalance,
  StorageBalanceBounds,
} from './types';
import {
  Units,
  Amount,
  AmountUnits,
  Gas,
  GasUnits,
  BlockQuery,
  BlockQueryProvider,
  BlockWithHeader,
  Parser,
  Stringifier,
  parseOutcomeValue,
  throwReceiptErrorsFromOutcomes,
} from './utils';

BigNumber.config({
  DECIMAL_PLACES: 100,
  ROUNDING_MODE: BigNumber.ROUND_DOWN,
});

export { MultiTransaction, MultiAction, EmptyArgs };
export { Send, SendOptions, SendRawOptions, Call, CallOptions, CallRawOptions, View, ViewOptions };
export {
  BlockQuery,
  BlockQueryProvider,
  BlockWithHeader,
  Stringifier,
  Parser,
  parseOutcomeValue,
  throwReceiptErrorsFromOutcomes,
};
export { Buffer, BigNumber, Numeric, Units, Amount, AmountUnits, Gas, GasUnits };
export { Transaction, Action, AccessKey };
export { SendTransactionError, UnreachableError };
export { FtTransferArgs, FtTransferCallArgs, FtBalanceOfArgs, FungibleTokenMetadata };
export {
  NftTransferArgs,
  NftTransferCallArgs,
  NftTokenArgs,
  NftApproveArgs,
  NftRevokeArgs,
  NftRevokeAllArgs,
  NftIsApprovedArgs,
  NftTokensArgs,
  NftSupplyForOwnerArgs,
  NftTokensForOwnerArgs,
  Token,
  TokenMetadata,
  NFTContractMetadata,
};
export {
  StorageDepositArgs,
  StorageWithdrawArgs,
  StorageUnregisterArgs,
  StorageBalanceOfArgs,
  StorageBalance,
  StorageBalanceBounds,
};
export * from 'borsher';

'''
'''--- packages/core/src/types/Call.ts ---
import { FinalExecutionOutcome } from '@near-js/types';
import { Parser, Stringifier } from '../utils';

export interface Call {
  call<Value, Args>(options: CallOptions<Value, Args>): Promise<Value>;
  callRaw<Args>(options: CallRawOptions<Args>): Promise<FinalExecutionOutcome>;
}

export type CallOptions<Value, Args> = CallRawOptions<Args> & {
  parser?: Parser<Value>;
};

export type CallRawOptions<Args> = {
  contractId: string;
  methodName: string;
  args?: Args;
  attachedDeposit?: string;
  gas?: string;
  stringifier?: Stringifier<Args>;
  throwReceiptErrors?: boolean;
};

'''
'''--- packages/core/src/types/Send.ts ---
import { FinalExecutionOutcome } from '@near-js/types';
import { MultiTransaction } from '../core';
import { Parser } from '../utils';

export interface Send {
  send<Value>(mTransaction: MultiTransaction, options?: SendOptions<Value>): Promise<Value>;
  sendRaw(mTransaction: MultiTransaction, options?: SendRawOptions): Promise<FinalExecutionOutcome[]>;
}

export type SendOptions<Value> = SendRawOptions & {
  parser?: Parser<Value>;
};

export type SendRawOptions = {
  throwReceiptErrors?: boolean;
};

'''
'''--- packages/core/src/types/View.ts ---
import { BlockQuery, Parser, Stringifier } from '../utils';

export interface View {
  view<Value, Args>(options: ViewOptions<Value, Args>): Promise<Value>;
}

export type ViewOptions<Value, Args> = {
  contractId: string;
  methodName: string;
  args?: Args;
  stringifier?: Stringifier<Args>;
  parser?: Parser<Value>;
  blockQuery?: BlockQuery;
};

'''
'''--- packages/core/src/types/common.ts ---
import { BigNumber } from 'bignumber.js';

export type Numeric = BigNumber | string | number;

'''
'''--- packages/core/src/types/function-call.ts ---
import { Stringifier } from '../utils';

export type FunctionCall<T> = <Args = EmptyArgs>(options: FunctionCallOptions<Args>) => T;

export type FunctionCallOptions<Args> = {
  methodName: string;
  args?: Args;
  attachedDeposit?: string;
  gas?: string;
  stringifier?: Stringifier<Args>;
};

export type EmptyArgs = Record<string, never>;

'''
'''--- packages/core/src/types/fungible-token/args.ts ---
export type FtTransferArgs = {
  receiver_id: string;
  amount: string;
  memo?: string;
};

export type FtTransferCallArgs = {
  receiver_id: string;
  amount: string;
  memo?: string;
  msg: string;
};

export type FtBalanceOfArgs = {
  account_id: string;
};

'''
'''--- packages/core/src/types/fungible-token/function-call.ts ---
import { FtTransferArgs, FtTransferCallArgs } from './args';

export type FungibleTokenFunctionCall<T> = {
  /**
   * Add a FunctionCall Action with method `ft_transfer` following previous actions
   */
  transfer: (options: FtTransferOptions) => T;

  /**
   * Add a FunctionCall Action with method `ft_transfer_call` following previous actions
   */
  transfer_call: (options: FtTransferCallOptions) => T;
};

export type FtTransferOptions = {
  args: FtTransferArgs;
  gas?: string;
};

export type FtTransferCallOptions = {
  args: FtTransferCallArgs;
  gas?: string;
};

'''
'''--- packages/core/src/types/fungible-token/index.ts ---
export * from './args';
export * from './value';
export * from './function-call';

'''
'''--- packages/core/src/types/fungible-token/value.ts ---
export type FungibleTokenMetadata = {
  spec: string;
  name: string;
  symbol: string;
  icon?: string;
  reference?: string;
  reference_hash?: string;
  decimals: number;
};

'''
'''--- packages/core/src/types/index.ts ---
export * from './transaction';
export * from './fungible-token';
export * from './storage-management';
export * from './non-fungible-token';
export * from './common';
export * from './function-call';
export * from './View';
export * from './Call';
export * from './Send';

'''
'''--- packages/core/src/types/non-fungible-token/args.ts ---
export type NftTransferArgs = {
  receiver_id: string;
  token_id: string;
  approval_id?: number;
  memo?: string;
};

export type NftTransferCallArgs = {
  receiver_id: string;
  token_id: string;
  approval_id?: number;
  memo?: string;
  msg: string;
};

export type NftTokenArgs = {
  token_id: string;
};

export type NftApproveArgs = {
  token_id: string;
  account_id: string;
  msg?: string;
};

export type NftRevokeArgs = {
  token_id: string;
  account_id: string;
};

export type NftRevokeAllArgs = {
  token_id: string;
};

export type NftIsApprovedArgs = {
  token_id: string;
  approved_account_id: string;
  approval_id?: number;
};

export type NftTokensArgs = {
  from_index?: string;
  limit?: number;
};

export type NftSupplyForOwnerArgs = {
  account_id: string;
};

export type NftTokensForOwnerArgs = {
  account_id: string;
  from_index?: string;
  limit?: number;
};

'''
'''--- packages/core/src/types/non-fungible-token/function-call.ts ---
import { NftTransferArgs, NftTransferCallArgs, NftApproveArgs, NftRevokeArgs, NftRevokeAllArgs } from './args';

export type NonFungibleTokenFunctionCall<T> = {
  /**
   * Add a FunctionCall Action with method `nft_transfer` following previous actions
   */
  transfer: (options: NftTransferOptions) => T;

  /**
   * Add a FunctionCall Action with method `nft_transfer_call` following previous actions
   */
  transfer_call: (options: NftTransferCallOptions) => T;

  /**
   * Add a FunctionCall Action with method `nft_approve` following previous actions
   */
  approve: (options: NftApproveOptions) => T;

  /**
   * Add a FunctionCall Action with method `nft_revoke` following previous actions
   */
  revoke: (options: NftRevokeOptions) => T;

  /**
   * Add a FunctionCall Action with method `nft_revoke_all` following previous actions
   */
  revoke_all: (options: NftRevokeAllOptions) => T;
};

export type NftTransferOptions = {
  args: NftTransferArgs;
  gas?: string;
};

export type NftTransferCallOptions = {
  args: NftTransferCallArgs;
  gas?: string;
};

export type NftApproveOptions = {
  args: NftApproveArgs;
  attachedDeposit?: string;
  gas?: string;
};

export type NftRevokeOptions = {
  args: NftRevokeArgs;
  gas?: string;
};

export type NftRevokeAllOptions = {
  args: NftRevokeAllArgs;
  gas?: string;
};

'''
'''--- packages/core/src/types/non-fungible-token/index.ts ---
export * from './args';
export * from './value';
export * from './function-call';

'''
'''--- packages/core/src/types/non-fungible-token/value.ts ---
export type Token = {
  token_id: string;
  owner_id: string;
  metadata?: TokenMetadata;
  approved_account_ids?: Record<string, number>;
};

export type TokenMetadata = {
  title?: string;
  description?: string;
  media?: string;
  media_hash?: string;
  copies?: number;
  issued_at?: string;
  expires_at?: string;
  starts_at?: string;
  updated_at?: string;
  extra?: string;
  reference?: string;
  reference_hash?: string;
};

export type NFTContractMetadata = {
  spec: string;
  name: string;
  symbol: string;
  icon?: string;
  base_uri?: string;
  reference?: string;
  reference_hash?: string;
};

'''
'''--- packages/core/src/types/storage-management/args.ts ---
export type StorageDepositArgs = {
  account_id?: string;
  registration_only?: boolean;
};

export type StorageWithdrawArgs = {
  amount?: string;
};

export type StorageUnregisterArgs = {
  force?: boolean;
};

export type StorageBalanceOfArgs = {
  account_id: string;
};

'''
'''--- packages/core/src/types/storage-management/function-call.ts ---
import { StorageDepositArgs, StorageWithdrawArgs, StorageUnregisterArgs } from './args';

export type StorageManagementFunctionCall<T> = {
  /**
   * Add a FunctionCall Action with method `storage_deposit` following previous actions
   */
  deposit: (options: StorageDepositOptions) => T;

  /**
   * Add a FunctionCall Action with method `storage_withdraw` following previous actions
   */
  withdraw: (options?: StorageWithdrawOptions) => T;

  /**
   * Add a FunctionCall Action with method `storage_unregister` following previous actions
   */
  unregister: (options?: StorageUnregisterOptions) => T;
};

export type StorageDepositOptions = {
  args?: StorageDepositArgs;
  attachedDeposit: string;
  gas?: string;
};

export type StorageWithdrawOptions = {
  args?: StorageWithdrawArgs;
  gas?: string;
};

export type StorageUnregisterOptions = {
  args?: StorageUnregisterArgs;
  gas?: string;
};

'''
'''--- packages/core/src/types/storage-management/index.ts ---
export * from './args';
export * from './value';
export * from './function-call';

'''
'''--- packages/core/src/types/storage-management/value.ts ---
export type StorageBalance = {
  total: string;
  available: string;
};

export type StorageBalanceBounds = {
  min: string;
  max?: string;
};

'''
'''--- packages/core/src/types/transaction.ts ---
export type Transaction = {
  signerId?: string;
  receiverId: string;
  actions: Action[];
};

export type Action =
  | CreateAccountAction
  | DeleteAccountAction
  | AddKeyAction
  | DeleteKeyAction
  | DeployContractAction
  | StakeAction
  | FunctionCallAction
  | TransferAction;

export type CreateAccountAction = {
  type: 'CreateAccount';
};

export type DeleteAccountAction = {
  type: 'DeleteAccount';
  params: DeleteAccountParams;
};

export type AddKeyAction = {
  type: 'AddKey';
  params: AddKeyParams;
};

export type DeleteKeyAction = {
  type: 'DeleteKey';
  params: DeleteKeyParams;
};

export type DeployContractAction = {
  type: 'DeployContract';
  params: DeployContractParams;
};

export type StakeAction = {
  type: 'Stake';
  params: StakeParams;
};

export type FunctionCallAction = {
  type: 'FunctionCall';
  params: FunctionCallParams;
};

export type TransferAction = {
  type: 'Transfer';
  params: TransferParams;
};

export type DeleteAccountParams = {
  beneficiaryId: string;
};

export type AddKeyParams = {
  publicKey: string;
  accessKey: AccessKey;
};

export type DeleteKeyParams = {
  publicKey: string;
};

export type DeployContractParams = {
  code: Uint8Array;
};

export type StakeParams = {
  amount: string;
  publicKey: string;
};

export type FunctionCallParams = {
  methodName: string;
  args: Uint8Array;
  attachedDeposit: string;
  gas: string;
};

export type TransferParams = {
  amount: string;
};

export type AccessKey = {
  permission: AccessKeyPermission;
  nonce?: number;
};

export type AccessKeyPermission = 'FullAccess' | FunctionCallAccess;

export type FunctionCallAccess = {
  receiverId: string;
  methodNames: string[];
  allowance?: string;
};

'''
'''--- packages/core/src/utils/Amount.ts ---
import { Numeric } from '../types';
import { Units } from './Units';

export class Amount {
  static readonly ZERO = '0';
  static readonly ONE_YOCTO = '1';

  private constructor() {}

  private static unitsToDecimals(units: AmountUnits): number {
    if (units === 'NEAR') {
      return 24;
    }

    if (units === 'USDT') {
      return 6;
    }

    if (units === 'USDC') {
      return 6;
    }

    if (units === 'BTC') {
      return 8;
    }

    if (units === 'ETH') {
      return 18;
    }

    return units;
  }

  /**
   * Parse from specific units and return a fixed string
   * @example
   * const rawAmount = Amount.parse('5', 'NEAR'); // '5000000000000000000000000'
   * @param amount human readable amount
   * @param units units
   */
  static parse(amount: Numeric, units: AmountUnits): string {
    return Units.parse(amount, Amount.unitsToDecimals(units)).toFixed(0);
  }

  /**
   * Format in specific units and return a fixed string
   * @example
   * const humanReadableAmount = Amount.format('5000000000000000000000000', 'NEAR'); // '5'
   * @param amount raw amount
   * @param units units
   * @param decimalPlaces decimal places
   */
  static format(amount: Numeric, units: AmountUnits, decimalPlaces?: number): string {
    amount = Units.format(amount, Amount.unitsToDecimals(units));
    if (decimalPlaces) {
      return amount.toFixed(decimalPlaces);
    } else {
      return amount.toFixed();
    }
  }
}

export type AmountUnits = 'NEAR' | 'USDT' | 'USDC' | 'BTC' | 'ETH' | number;

'''
'''--- packages/core/src/utils/BlockQuery.ts ---
import { BlockReference } from '@near-js/types';

export class BlockQuery {
  private readonly reference: BlockReference;

  private constructor(reference: BlockReference) {
    this.reference = reference;
  }

  static fromReference(reference: BlockReference): BlockQuery {
    return new BlockQuery(reference);
  }

  toReference(): BlockReference {
    return this.reference;
  }

  /**
   * Query at optimistic block
   */
  static get OPTIMISTIC(): BlockQuery {
    return new BlockQuery({ finality: 'optimistic' });
  }

  /**
   * Query at doomslug final block
   */
  static get DOOMSLUG(): BlockQuery {
    return new BlockQuery({ finality: 'near-final' });
  }

  /**
   * Query at final block
   */
  static get FINAL(): BlockQuery {
    return new BlockQuery({ finality: 'final' });
  }

  /**
   * Query at earliest available block
   */
  static get EARLIEST(): BlockQuery {
    return new BlockQuery({ sync_checkpoint: 'earliest_available' });
  }

  /**
   * Query at genesis block
   */
  static get GENESIS(): BlockQuery {
    return new BlockQuery({ sync_checkpoint: 'genesis' });
  }

  /**
   * Query at certain block with block height
   */
  static height(height: number): BlockQuery {
    return new BlockQuery({ blockId: height });
  }

  /**
   * Query at certain block with block hash
   */
  static hash(hash: string): BlockQuery {
    return new BlockQuery({ blockId: hash });
  }

  /**
   * Convert block query to that with certain block height.
   * This is useful when need multiple queries at the same block
   *
   * @example
   * const blockQuery = BlockQuery.FINAL;
   *
   * const supply1: string = await account.view({
   *   contractId: 'wrap.near',
   *   methodName: 'ft_total_supply',
   *   blockQuery
   * });
   *
   * // supply2 may not be equal to supply1 because they may be queried at different block
   * const supply2: string = await account.view({
   *   contractId: 'wrap.near',
   *   methodName: 'ft_total_supply',
   *   blockQuery
   * });
   *
   *@example
   * const blockQuery = await BlockQuery.FINAL.height(provider);
   *
   * const supply1: string = await account.view({
   *   contractId: 'wrap.near',
   *   methodName: 'ft_total_supply',
   *   blockQuery
   * });
   *
   * // supply2 must be equal to supply1 because they are queried at the same block
   * const supply2: string = await account.view({
   *   contractId: 'wrap.near',
   *   methodName: 'ft_total_supply',
   *   blockQuery
   * });
   */
  async height(provider: BlockQueryProvider): Promise<BlockQuery> {
    if ('blockId' in this.reference && typeof this.reference.blockId === 'number') {
      return BlockQuery.height(this.reference.blockId);
    }
    const block = await provider.block(this.toReference());
    return BlockQuery.height(block.header.height);
  }

  /**
   * Convert block query to that with certain block hash.
   * This is useful when need multiple queries at the same block
   *
   * @example
   * const blockQuery = BlockQuery.FINAL;
   *
   * const supply1: string = await account.view({
   *   contractId: 'wrap.near',
   *   methodName: 'ft_total_supply',
   *   blockQuery
   * });
   *
   * // supply2 may not be equal to supply1 because they may be queried at different block
   * const supply2: string = await account.view({
   *   contractId: 'wrap.near',
   *   methodName: 'ft_total_supply',
   *   blockQuery
   * });
   *
   *@example
   * const blockQuery = await BlockQuery.FINAL.hash(provider);
   *
   * const supply1: string = await account.view({
   *   contractId: 'wrap.near',
   *   methodName: 'ft_total_supply',
   *   blockQuery
   * });
   *
   * // supply2 must be equal to supply1 because they are queried at the same block
   * const supply2: string = await account.view({
   *   contractId: 'wrap.near',
   *   methodName: 'ft_total_supply',
   *   blockQuery
   * });
   */
  async hash(provider: BlockQueryProvider): Promise<BlockQuery> {
    if ('blockId' in this.reference && typeof this.reference.blockId === 'string') {
      return BlockQuery.hash(this.reference.blockId);
    }
    const block = await provider.block(this.toReference());
    return BlockQuery.hash(block.header.hash);
  }
}

export type BlockWithHeader = {
  header: {
    height: number;
    hash: string;
  };
};

export interface BlockQueryProvider {
  block(reference: BlockReference): Promise<BlockWithHeader>;
}

'''
'''--- packages/core/src/utils/Gas.ts ---
import { Numeric } from '../types';
import { Units } from './Units';

export class Gas {
  static readonly DEFAULT = '30000000000000';

  private constructor() {}

  private static unitsToDecimals(units: GasUnits): number {
    if (units === 'T') {
      return 12;
    }

    if (units === 'G') {
      return 9;
    }

    if (units === 'M') {
      return 6;
    }

    if (units === 'K') {
      return 3;
    }

    return units;
  }

  /**
   * Parse from specific units and return a fixed string
   * @example
   * const rawGas = Gas.parse('5', 'T'); // '5000000000000'
   * @param gas human readable gas
   * @param units units
   */
  static parse(gas: Numeric, units: GasUnits): string {
    return Units.parse(gas, Gas.unitsToDecimals(units)).toFixed(0);
  }

  /**
   * Format in specific units and return a fixed string
   * @example
   * const humanReadableGas = Gas.format('5000000000000', 'T'); // '5'
   * @param gas raw gas
   * @param units units
   * @param decimalPlaces decimal places
   */
  static format(gas: Numeric, units: GasUnits, decimalPlaces?: number): string {
    gas = Units.format(gas, Gas.unitsToDecimals(units));
    if (decimalPlaces) {
      return gas.toFixed(decimalPlaces);
    } else {
      return gas.toFixed();
    }
  }
}

export type GasUnits = 'T' | 'G' | 'M' | 'K' | number;

'''
'''--- packages/core/src/utils/Parser.ts ---
import { borshDeserialize, BorshSchema } from 'borsher';
import { Buffer } from 'buffer';

export type Parse<T> = (buffer: Uint8Array) => T;

export class Parser<T> {
  parse: Parse<T>;

  private constructor(parse: Parse<T>) {
    this.parse = parse;
  }

  static json<T>(): Parser<T> {
    return new Parser((buffer) => JSON.parse(Buffer.from(buffer).toString()));
  }

  static borsh<T>(schema: BorshSchema): Parser<T> {
    return new Parser((buffer) => borshDeserialize(schema, buffer));
  }

  static custom<T>(parse: Parse<T>): Parser<T> {
    return new Parser(parse);
  }
}

'''
'''--- packages/core/src/utils/Stringifier.ts ---
import { Buffer } from 'buffer';
import { BorshSchema, borshSerialize } from 'borsher';

export type Stringify<T> = (data: T) => Buffer;

export class Stringifier<T> {
  stringify: Stringify<T>;

  private constructor(stringify: Stringify<T>) {
    this.stringify = stringify;
  }

  static json<T>(): Stringifier<T> {
    return new Stringifier((data) => Buffer.from(JSON.stringify(data)));
  }

  static borsh<T>(schema: BorshSchema): Stringifier<T> {
    return new Stringifier((data) => borshSerialize(schema, data));
  }

  static custom<T>(stringify: Stringify<T>): Stringifier<T> {
    return new Stringifier(stringify);
  }

  stringifyOrSkip(data: T | Uint8Array): Buffer {
    if (data instanceof Uint8Array) {
      return Buffer.from(data);
    } else {
      return this.stringify(data);
    }
  }
}

'''
'''--- packages/core/src/utils/Units.ts ---
import { BigNumber } from 'bignumber.js';
import { Numeric } from '../types';

export class Units {
  private constructor() {}

  /**
   * Parse from specific units and return a BigNumber
   * @param n number
   * @param decimals decimals
   */
  static parse(n: Numeric, decimals: number): BigNumber {
    return BigNumber(n).shiftedBy(decimals);
  }

  /**
   * Format in specific units and return a BigNumber
   * @param n number
   * @param decimals decimals
   */
  static format(n: Numeric, decimals: number): BigNumber {
    return BigNumber(n).shiftedBy(-decimals);
  }
}

'''
'''--- packages/core/src/utils/function-call.ts ---
import {
  FunctionCall,
  FungibleTokenFunctionCall,
  NonFungibleTokenFunctionCall,
  StorageManagementFunctionCall,
  FtTransferOptions,
  FtTransferCallOptions,
  NftTransferOptions,
  NftTransferCallOptions,
  NftApproveOptions,
  NftRevokeOptions,
  NftRevokeAllOptions,
  StorageDepositOptions,
  StorageWithdrawOptions,
  StorageUnregisterOptions,
} from '../types';
import { Amount } from './Amount';
import { Gas } from './Gas';

export function fungibleTokenFunctionCall<T>(functionCall: FunctionCall<T>): FungibleTokenFunctionCall<T> {
  const transfer = (options: FtTransferOptions): T => {
    const { args, gas } = options;
    return functionCall({
      methodName: 'ft_transfer',
      args,
      attachedDeposit: Amount.ONE_YOCTO,
      gas,
    });
  };

  const transfer_call = (options: FtTransferCallOptions): T => {
    const { args, gas = Gas.parse(50, 'T') } = options;
    return functionCall({
      methodName: 'ft_transfer_call',
      args,
      attachedDeposit: Amount.ONE_YOCTO,
      gas,
    });
  };

  return { transfer, transfer_call };
}

export function nonFungibleTokenFunctionCall<T>(functionCall: FunctionCall<T>): NonFungibleTokenFunctionCall<T> {
  const transfer = (options: NftTransferOptions): T => {
    const { args, gas } = options;
    return functionCall({
      methodName: 'nft_transfer',
      args,
      attachedDeposit: Amount.ONE_YOCTO,
      gas,
    });
  };

  const transfer_call = (options: NftTransferCallOptions): T => {
    const { args, gas = Gas.parse(50, 'T') } = options;
    return functionCall({
      methodName: 'nft_transfer_call',
      args,
      attachedDeposit: Amount.ONE_YOCTO,
      gas,
    });
  };

  const approve = (options: NftApproveOptions): T => {
    const { args, attachedDeposit = Amount.parse('0.005', 'NEAR'), gas } = options;
    return functionCall({
      methodName: 'nft_approve',
      args,
      attachedDeposit,
      gas,
    });
  };

  const revoke = (options: NftRevokeOptions): T => {
    const { args, gas } = options;
    return functionCall({
      methodName: 'nft_revoke',
      args,
      attachedDeposit: Amount.ONE_YOCTO,
      gas,
    });
  };

  const revoke_all = (options: NftRevokeAllOptions): T => {
    const { args, gas } = options;
    return functionCall({
      methodName: 'nft_revoke_all',
      args,
      attachedDeposit: Amount.ONE_YOCTO,
      gas,
    });
  };

  return { transfer, transfer_call, approve, revoke, revoke_all };
}

export function storageManagementFunctionCall<T>(functionCall: FunctionCall<T>): StorageManagementFunctionCall<T> {
  const deposit = (options: StorageDepositOptions): T => {
    const { args, attachedDeposit, gas } = options;
    return functionCall({
      methodName: 'storage_deposit',
      args,
      attachedDeposit,
      gas,
    });
  };

  const withdraw = (options: StorageWithdrawOptions = {}): T => {
    const { args, gas } = options;
    return functionCall({
      methodName: 'storage_withdraw',
      args,
      attachedDeposit: Amount.ONE_YOCTO,
      gas,
    });
  };

  const unregister = (options: StorageUnregisterOptions = {}): T => {
    const { args, gas } = options;
    return functionCall({
      methodName: 'storage_unregister',
      args,
      attachedDeposit: Amount.ONE_YOCTO,
      gas,
    });
  };

  return { deposit, withdraw, unregister };
}

'''
'''--- packages/core/src/utils/index.ts ---
export * from './Units';
export * from './Amount';
export * from './Gas';
export * from './outcome';
export * from './Stringifier';
export * from './Parser';
export * from './BlockQuery';
export * from './function-call';

'''
'''--- packages/core/src/utils/outcome.ts ---
import { FinalExecutionOutcome, FinalExecutionStatus } from '@near-js/types';
import { parseRpcError } from '@near-js/utils';
import { Buffer } from 'buffer';
import { Parser } from './Parser';
import { ParseOutcomeError, ReceiptErrorMessage, ReceiptError } from '../errors';

export function parseOutcomeValue<Value>(outcome: FinalExecutionOutcome, parser: Parser<Value> = Parser.json()): Value {
  const successValue = (outcome.status as FinalExecutionStatus).SuccessValue;
  if (successValue) {
    const valueRaw = Buffer.from(successValue, 'base64');
    return parser.parse(valueRaw);
  } else if (successValue === '') {
    return undefined as Value;
  } else {
    throw new ParseOutcomeError(`Execution status is Failure`);
  }
}

export function throwReceiptErrorsFromOutcomes(outcomes: FinalExecutionOutcome[]) {
  const errors = outcomes.map((outcome) => getReceiptErrorsFromOutcome(outcome)).flat();
  if (errors.length !== 0) {
    throw new ReceiptError(errors);
  }
}

function getReceiptErrorsFromOutcome(outcome: FinalExecutionOutcome): ReceiptErrorMessage[] {
  const errors: ReceiptErrorMessage[] = [];
  outcome.receipts_outcome.forEach((receipt) => {
    const status = receipt.outcome.status;
    if (typeof status !== 'string' && status.Failure) {
      const serverError = parseRpcError(status.Failure);
      const errorMessage = JSON.parse(serverError.message);
      errors.push(errorMessage);
    }
  });
  return errors;
}

'''
'''--- packages/core/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "outDir": "dist",
    "importHelpers": false,
    // output .d.ts declaration files for consumers
    "declaration": true,
    // output .js.map sourcemap files for consumers
    "sourceMap": true,
    // match output dir to input dir. e.g. dist/index instead of dist/src/index
    // stricter type-checking for stronger correctness. Recommended by TS
    "strict": true,
    // linter checks for common issues
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    // noUnused* overlap with @typescript-eslint/no-unused-vars, can disable if duplicative
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    // use Node's module resolution algorithm, instead of the legacy TS one
    "moduleResolution": "node",
    // interop between ESM and CJS modules. Recommended by TS
    "esModuleInterop": true,
    // significant perf increase by skipping checking .d.ts files, particularly those in node_modules. Recommended by TS
    "skipLibCheck": true,
    // error out if import and file system have a casing mismatch. Recommended by TS
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}

'''
'''--- packages/multi-transaction/README.md ---
# Multi Transaction
Make the construction of the transaction easier on [NEAR](https://near.org) blockchain

## Install
```shell
pnpm add multi-transaction
```

This package includes following sub packages, you can also install with your needs

```shell
pnpm add @multi-transaction/core
```

```shell
pnpm add @multi-transaction/account
```

```shell
pnpm add @multi-transaction/wallet-selector
```

## MultiTransaction
```ts
import { MultiTransaction, Amount, Gas } from 'multi-transaction';
```

```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'bob.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  });
```

More information about [MultiTransaction](../core/README.md)

## MultiSendAccount
```ts
import { MultiSendAccount } from 'multi-transaction';
```

```ts
const account = MultiSendAccount.new(connection, 'alice.near');
```

```ts
await account.send(mTransaction);
```

More information about [MultiSendAccount](../account/README.md)

## MultiSendWalletSelector
```ts
import { setupMultiSendWalletSelector } from 'multi-transaction';
```

```ts
const selector = await setupMultiSendWalletSelector({
  network: 'mainnet',
  modules: [
    /* wallet modules */
  ],
});
```

```ts
await selector.send(mTransaction);
```

More information about [MultiSendWalletSelector](../wallet-selector/README.md)

'''
'''--- packages/multi-transaction/package.json ---
{
  "name": "multi-transaction",
  "version": "11.0.1",
  "license": "MIT",
  "description": "Make construction of transaction easier on NEAR blockchain.",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "commonjs",
  "files": [
    "dist",
    "src"
  ],
  "scripts": {
    "build": "rm -rf dist && tsc",
    "lint": "eslint src/{**,}/*.ts --fix",
    "prettier": "prettier src/{**,}/*.ts --write"
  },
  "dependencies": {
    "@multi-transaction/core": "workspace:*",
    "@multi-transaction/account": "workspace:*",
    "@multi-transaction/wallet-selector": "workspace:*"
  }
}

'''
'''--- packages/multi-transaction/src/index.ts ---
export * from '@multi-transaction/core';
export * from '@multi-transaction/account';
export * from '@multi-transaction/wallet-selector';

'''
'''--- packages/multi-transaction/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "outDir": "dist",
    "importHelpers": false,
    // output .d.ts declaration files for consumers
    "declaration": true,
    // output .js.map sourcemap files for consumers
    "sourceMap": true,
    // match output dir to input dir. e.g. dist/index instead of dist/src/index
    // stricter type-checking for stronger correctness. Recommended by TS
    "strict": true,
    // linter checks for common issues
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    // noUnused* overlap with @typescript-eslint/no-unused-vars, can disable if duplicative
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    // use Node's module resolution algorithm, instead of the legacy TS one
    "moduleResolution": "node",
    // interop between ESM and CJS modules. Recommended by TS
    "esModuleInterop": true,
    // significant perf increase by skipping checking .d.ts files, particularly those in node_modules. Recommended by TS
    "skipLibCheck": true,
    // error out if import and file system have a casing mismatch. Recommended by TS
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}

'''
'''--- packages/wallet-selector/README.md ---
# Multi Transaction Wallet Selector
Multi Transaction Wallet Selector implementation

## Install
```shell
pnpm add @multi-transaction/core @multi-transaction/wallet-selector
```

## Examples
```ts
import { MultiTransaction, Amount, Gas } from '@multi-transaction/core';
import { setupMultiSendWalletSelector } from '@multi-transaction/wallet-selector';
```

```ts
const selector = await setupMultiSendWalletSelector({
  network: 'mainnet',
  modules: [
    /* wallet modules */
  ],
});
```

### Send Transaction(s)
```ts
const mTransaction = MultiTransaction
  .batch('wrap.near')
  .functionCall({
    methodName: 'ft_transfer',
    args: {
      receiver_id: 'bob.near',
      amount: Amount.parse('8.88', 'NEAR'),
    },
    attachedDeposit: Amount.ONE_YOCTO,
    gas: Gas.parse('10', 'T'),
  });

await selector.send(mTransaction);
```

### Call Contract Method
```ts
await selector.call({
  contractId: 'wrap.near',
  methodName: 'ft_transfer',
  args: {
    receiver_id: 'bob.near',
    amount: Amount.parse('8.88', 'NEAR'),
  },
  attachedDeposit: Amount.ONE_YOCTO,
  gas: Gas.parse('10', 'T'),
});
```

### View Contract Method
```ts
const amount: string = await selector.view({
  contractId: 'wrap.near',
  methodName: 'ft_balance_of',
  args: {
    account_id: 'alice.near',
  },
});
```

'''
'''--- packages/wallet-selector/package.json ---
{
  "name": "@multi-transaction/wallet-selector",
  "version": "1.2.1",
  "license": "MIT",
  "description": "Multi Transaction Wallet Selector implementation.",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "commonjs",
  "files": [
    "dist",
    "src"
  ],
  "scripts": {
    "build": "rm -rf dist && tsc",
    "lint": "eslint src/{**,}/*.ts --fix",
    "prettier": "prettier src/{**,}/*.ts --write"
  },
  "dependencies": {
    "@multi-transaction/core": "workspace:*",
    "@near-wallet-selector/core": "^8.9.2"
  }
}

'''
'''--- packages/wallet-selector/src/MultiSendWalletSelector.ts ---
import { FinalExecutionOutcome } from '@near-js/types';
import { WalletSelector, AccountState } from '@near-wallet-selector/core';
import {
  MultiTransaction,
  EmptyArgs,
  Send,
  SendOptions,
  SendRawOptions,
  Call,
  CallOptions,
  CallRawOptions,
  View,
  ViewOptions,
} from '@multi-transaction/core';

export interface MultiSendWalletSelector extends WalletSelector, Send, Call, View {
  /**
   * Account that is login
   */
  getActiveAccount(): AccountState | undefined;

  /**
   * Accounts that have logged in
   */
  getAccounts(): AccountState[];

  /**
   * Is login access key available
   */
  isLoginAccessKeyAvailable(options?: IsLoginAccessKeyAvailableOptions): Promise<boolean>;

  /**
   * Send multiple transactions and return success value of last transaction
   */
  send<Value>(mTransaction: MultiTransaction, options?: MultiSendWalletSelectorSendOptions<Value>): Promise<Value>;

  /**
   * Send multiple transactions and return outcomes
   */
  sendRaw(
    mTransaction: MultiTransaction,
    options?: MultiSendWalletSelectorSendRawOptions,
  ): Promise<FinalExecutionOutcome[]>;

  /**
   * Call a contract method and return success value
   */
  call<Value, Args = EmptyArgs>(options: MultiSendWalletSelectorCallOptions<Value, Args>): Promise<Value>;

  /**
   * Call a contract method and return outcome
   */
  callRaw<Args = EmptyArgs>(options: MultiSendWalletSelectorCallRawOptions<Args>): Promise<FinalExecutionOutcome>;

  /**
   * View a contract method and return success value
   */
  view<Value, Args = EmptyArgs>(options: ViewOptions<Value, Args>): Promise<Value>;
}

export type IsLoginAccessKeyAvailableOptions = {
  accountId?: string;
  requiredAllowance?: string;
};

export type MultiSendWalletSelectorCallOptions<Value, Args> = CallOptions<Value, Args> & {
  walletId?: string;
  callbackUrl?: string;
};

export type MultiSendWalletSelectorCallRawOptions<Args> = CallRawOptions<Args> & {
  walletId?: string;
  callbackUrl?: string;
};

export type MultiSendWalletSelectorSendOptions<Value> = SendOptions<Value> & {
  walletId?: string;
  callbackUrl?: string;
};

export type MultiSendWalletSelectorSendRawOptions = SendRawOptions & {
  walletId?: string;
  callbackUrl?: string;
};

'''
'''--- packages/wallet-selector/src/index.ts ---
export { MultiSendWalletSelectorOptions, setupMultiSendWalletSelector } from './multi-send-wallet-selector';
export {
  IsLoginAccessKeyAvailableOptions,
  MultiSendWalletSelector,
  MultiSendWalletSelectorSendOptions,
  MultiSendWalletSelectorSendRawOptions,
  MultiSendWalletSelectorCallOptions,
  MultiSendWalletSelectorCallRawOptions,
} from './MultiSendWalletSelector';

'''
'''--- packages/wallet-selector/src/multi-send-wallet-selector.ts ---
import { setupWalletSelector, WalletSelector, WalletSelectorParams } from '@near-wallet-selector/core';
import { FinalExecutionOutcome } from '@near-js/types';
import { PublicKey } from '@near-js/crypto';
import { Near } from '@near-js/wallet-account';
import {
  MultiTransaction,
  Amount,
  BlockQuery,
  Stringifier,
  Parser,
  SendTransactionError,
  BigNumber,
  parseOutcomeValue,
  throwReceiptErrorsFromOutcomes,
} from '@multi-transaction/core';
import { MultiSendWalletSelector } from './MultiSendWalletSelector';
import { parseWalletSelectorTransactions } from './utils';

let MULTI_SEND_WALLET_SELECTOR: MultiSendWalletSelector | undefined;

export async function setupMultiSendWalletSelector(
  options: MultiSendWalletSelectorOptions,
): Promise<MultiSendWalletSelector> {
  let allowMultipleSelectors: boolean | undefined;
  let selector: WalletSelector;

  if ('selector' in options) {
    selector = options.selector;
  } else {
    selector = await setupWalletSelector(options);
    allowMultipleSelectors = options.allowMultipleSelectors;
  }

  if (allowMultipleSelectors) {
    return createMultiSendWalletSelector(selector);
  }

  if (!MULTI_SEND_WALLET_SELECTOR) {
    MULTI_SEND_WALLET_SELECTOR = createMultiSendWalletSelector(selector);
  }

  return MULTI_SEND_WALLET_SELECTOR;
}

function createMultiSendWalletSelector(selector: WalletSelector): MultiSendWalletSelector {
  const near = new Near(selector.options.network);

  return {
    ...selector,

    getActiveAccount() {
      return this.store.getState().accounts.find((accountState) => accountState.active);
    },

    getAccounts() {
      return this.store.getState().accounts;
    },

    async isLoginAccessKeyAvailable(options = {}) {
      const { accountId = this.getActiveAccount()?.accountId, requiredAllowance = Amount.parse('0.01', 'NEAR') } =
        options;

      if (!accountId) {
        return false;
      }

      const accountStates = this.getAccounts();
      const accountState = accountStates.find((accountState) => accountState.accountId === accountId);

      const publicKey = accountState?.publicKey;

      if (!publicKey) {
        return false;
      }

      const account = await near.account(accountId);
      const accessKeys = await account.getAccessKeys();
      const accessKey = accessKeys.find((accessKey) => {
        const remotePublicKey = PublicKey.fromString(accessKey.public_key);
        const localPublicKey = PublicKey.fromString(publicKey);
        return remotePublicKey.toString() === localPublicKey.toString();
      });

      if (!accessKey) {
        return false;
      }

      if (accessKey.access_key.permission === 'FullAccess') {
        return true;
      }

      const allowance = accessKey.access_key.permission.FunctionCall.allowance;

      if (!allowance) {
        return true;
      }

      const remainingAllowance = BigNumber(allowance);
      return remainingAllowance.gte(requiredAllowance);
    },

    async send(mTransaction, options = {}) {
      const { parser, ...sendRawOptions } = options;
      const outcomes = await this.sendRaw(mTransaction, sendRawOptions);
      const outcome = outcomes?.[outcomes.length - 1];
      return parseOutcomeValue(outcome, parser);
    },

    async sendRaw(mTransaction, options = {}) {
      const { throwReceiptErrors, walletId, callbackUrl } = options;

      const transactions = parseWalletSelectorTransactions(mTransaction);

      if (transactions.length === 0) {
        throw new SendTransactionError('Transaction not found.');
      }

      const wallet = await this.wallet(walletId);

      let outcomes: FinalExecutionOutcome[] | undefined;

      if (transactions.length === 1) {
        const outcome = await wallet.signAndSendTransaction({
          ...transactions[0],
          callbackUrl,
        });
        if (outcome) {
          outcomes = [outcome];
        }
      } else {
        const res = await wallet.signAndSendTransactions({
          transactions,
          callbackUrl,
        });
        if (res) {
          outcomes = res;
        }
      }

      while (!outcomes) {
        // browser wallet, wait for direction
      }

      if (throwReceiptErrors) {
        throwReceiptErrorsFromOutcomes(outcomes);
      }

      return outcomes;
    },

    async call(options) {
      const { parser, ...callRawOptions } = options;
      const outcome = await this.callRaw(callRawOptions);
      return parseOutcomeValue(outcome, parser);
    },

    async callRaw(options) {
      const { contractId, methodName, args, attachedDeposit, gas, stringifier, ...sendRawOptions } = options;

      const mTransaction = MultiTransaction.batch(contractId).functionCall({
        methodName,
        args,
        attachedDeposit,
        gas,
        stringifier,
      });

      const outcomes = await this.sendRaw(mTransaction, sendRawOptions);

      return outcomes?.[0];
    },

    async view(options) {
      const {
        contractId,
        methodName,
        args,
        stringifier = Stringifier.json(),
        parser = Parser.json(),
        blockQuery = BlockQuery.OPTIMISTIC,
      } = options;

      const viewer = await near.account('');

      return viewer.viewFunction({
        contractId,
        methodName,
        args: args as object,
        stringify: (args) => stringifier.stringifyOrSkip(args),
        parse: (buffer) => parser.parse(buffer),
        blockQuery: blockQuery.toReference(),
      });
    },
  };
}

export type MultiSendWalletSelectorOptions = WalletSelectorParams | { selector: WalletSelector };

'''
'''--- packages/wallet-selector/src/utils.ts ---
import { Action as WalletSelectorAction } from '@near-wallet-selector/core';
import { MultiTransaction, Transaction, Action, UnreachableError } from '@multi-transaction/core';

type WalletSelectorTransaction = {
  signerId?: string;
  receiverId: string;
  actions: WalletSelectorAction[];
};

export function parseWalletSelectorTransactions(mTransaction: MultiTransaction): WalletSelectorTransaction[] {
  return mTransaction.toTransactions().map((transaction) => parseWalletSelectorTransaction(transaction));
}

function parseWalletSelectorTransaction(transaction: Transaction): WalletSelectorTransaction {
  const { signerId, receiverId, actions } = transaction;
  return {
    signerId,
    receiverId,
    actions: actions.map((action) => parseWalletSelectorAction(action)),
  };
}

function parseWalletSelectorAction(action: Action): WalletSelectorAction {
  if (
    action.type === 'CreateAccount' ||
    action.type === 'DeleteAccount' ||
    action.type === 'AddKey' ||
    action.type === 'DeleteKey' ||
    action.type === 'DeployContract'
  ) {
    return action;
  }

  if (action.type === 'Stake') {
    const { amount, publicKey } = action.params;
    return {
      type: action.type,
      params: {
        stake: amount,
        publicKey,
      },
    };
  }

  if (action.type === 'FunctionCall') {
    const { methodName, args, gas, attachedDeposit } = action.params;
    return {
      type: action.type,
      params: {
        methodName,
        args,
        gas,
        deposit: attachedDeposit,
      },
    };
  }

  if (action.type === 'Transfer') {
    const { amount } = action.params;
    return {
      type: action.type,
      params: {
        deposit: amount,
      },
    };
  }

  throw new UnreachableError();
}

'''
'''--- packages/wallet-selector/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "outDir": "dist",
    "importHelpers": false,
    // output .d.ts declaration files for consumers
    "declaration": true,
    // output .js.map sourcemap files for consumers
    "sourceMap": true,
    // match output dir to input dir. e.g. dist/index instead of dist/src/index
    // stricter type-checking for stronger correctness. Recommended by TS
    "strict": true,
    // linter checks for common issues
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    // noUnused* overlap with @typescript-eslint/no-unused-vars, can disable if duplicative
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    // use Node's module resolution algorithm, instead of the legacy TS one
    "moduleResolution": "node",
    // interop between ESM and CJS modules. Recommended by TS
    "esModuleInterop": true,
    // significant perf increase by skipping checking .d.ts files, particularly those in node_modules. Recommended by TS
    "skipLibCheck": true,
    // error out if import and file system have a casing mismatch. Recommended by TS
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}

'''
'''--- turbo.json ---
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "all": {
      "dependsOn": ["lint", "prettier", "build"]
    },
    "build": {
      "dependsOn": ["^build"],
      "cache": false
    },
    "lint": {
      "cache": false
    },
    "prettier": {
      "cache": false
    }
  }
}

'''