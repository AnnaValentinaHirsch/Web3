*GitHub Repository "andreapn1709/whitelist-contract"*

'''--- README.md ---
Whitelist Contract
==================

A [smart contract] written in [AssemblyScript] for an app initialized with [create-near-app].  One of the NEAR Protocol core contracts and part of the complete series covering [NEAR Core Contracts written in AssemblyScript](https://vitalpoint.ai/course/whitelist-contract/) 

Quick Start
===========

Before you compile this code, you will need to install [Node.js] ≥ 12

Exploring The Code
==================

1. The main smart contract code lives in `assembly/index.ts`. You can compile
   it with the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard AssemblyScript tests using [as-pect].
'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__tests__/main.spec.ts ---
import { add_staking_pool, initContract, is_whitelisted } from '../index';
import { storage, Context, VMContext } from "near-sdk-as";
import { AccountId } from '../types'
import { whitelist, WhitelistContract } from '../models';

const account_near: AccountId = 'near'
const account_whitelist: AccountId = 'whitelist'
const account_pool: AccountId = 'pool'
const account_factory: AccountId = 'factory'
let contract: WhitelistContract

beforeEach(() => {
    contract = initContract(account_near)
})

describe("WhiteList", () => {
    it("should be initialized", () => {
        expect(storage.getSome<bool>('init')).toBe(true)
    });

    it("should be able to whitelist", () => {
        expect(is_whitelisted(account_pool)).toBe(false)
        add_staking_pool(account_pool)
        expect(is_whitelisted(account_pool)).toBe(true)
        expect(add_staking_pool(account_pool)).toBe(false)
    })
});

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/index.ts ---
import { storage, env, Context } from 'near-sdk-as'

// Data Models Imports
import { WhitelistContract, whitelist, factory_whitelist } from './models'

// Types Imports
import { AccountId } from './types'

// globals
let contract: WhitelistContract

/*********/
/* Main  */
/*********/

export function initContract(foundation_account_id: AccountId): WhitelistContract {
  /// Initializes the contract with the given NEAR foundation account ID.
  assert(!storage.hasKey('init'), 'Already initialized')
  assert(env.isValidAccountID(foundation_account_id), 'The NEAR Foundation account ID is invalid')
  contract = new WhitelistContract(foundation_account_id, whitelist, factory_whitelist)
  storage.set('init', true)
  return contract
}

/***********/
/* Getters */
/***********/

/// Returns `true` if the given staking pool account ID is whitelisted.
export function is_whitelisted(staking_pool_account_id: AccountId): bool {
  _isInit()
  assert(env.isValidAccountID(staking_pool_account_id), 'The given account ID is invalid')
  return whitelist.has(staking_pool_account_id)
}

/// Returns `true` if the given factory contract account ID is whitelisted.
export function is_factory_whitelisted(factory_account_id: AccountId): bool {
  _isInit()
  assert(env.isValidAccountID(factory_account_id), 'The given account ID is invalid')
  return factory_whitelist.has(factory_account_id)
}

/************************/
/* Factory + Foundation */
/************************/

/// Adds the given staking pool account ID to the whitelist.
/// Returns `true` if the staking pool was not in the whitelist before, `false` otherwise.
/// This method can be called either by the NEAR foundation or by a whitelisted factory.
export function add_staking_pool(staking_pool_account_id: AccountId): bool {
  _isInit()
  assert(env.isValidAccountID(staking_pool_account_id), 'The given account ID is invalid')

  // Can only be called by a whitelisted factory or by the foundation.
  if (!factory_whitelist.has(Context.predecessor)){
    _assert_called_by_foundation()
  }
  whitelist.add(staking_pool_account_id)
  return true
}

/**************/
/* Foundation */
/**************/

/// Removes the given staking pool account ID from the whitelist.
/// Returns `true` if the staking pool was present in the whitelist before, `false` otherwise.
/// This method can only be called by the NEAR foundation.
export function remove_staking_pool(staking_pool_account_id: AccountId): bool {
  _isInit()
  _assert_called_by_foundation()
  assert(env.isValidAccountID(staking_pool_account_id), 'The given account ID is invalid')
  whitelist.delete(staking_pool_account_id)
  return true
}

/// Adds the given staking pool factory contract account ID to the factory whitelist.
/// Returns `true` if the factory was not in the whitelist before, `false` otherwise.
/// This method can only be called by the NEAR foundation.
export function add_factory(factory_account_id: AccountId): bool {
  _isInit()
  assert(env.isValidAccountID(factory_account_id), 'The given account ID is invalid')
  _assert_called_by_foundation()
  factory_whitelist.add(factory_account_id)
  return true
}

/// Removes the given staking pool factory account ID from the factory whitelist.
/// Returns `true` if the factory was present in the whitelist before, `false` otherwise.
/// This method can only be called by the NEAR foundation.
export function remove_factory(factory_account_id: AccountId): bool {
  _isInit()
  _assert_called_by_foundation()
  assert(env.isValidAccountID(factory_account_id), 'The given account ID is invalid')
  factory_whitelist.delete(factory_account_id)
  return true
}

/************/
/* Internal */
/************/

function _assert_called_by_foundation(): void {
  assert(Context.predecessor == contract.foundation_account_id, 'Can only be called by NEAR foundation')
}

function _isInit(): void {
  assert(storage.hasKey('init') && storage.getSome<bool>('init') == true, 'The contract should be initialized before usage.')
}
'''
'''--- assembly/models.ts ---
import { u128, PersistentSet } from 'near-sdk-as'

// import Types
import { AccountId } from './types'

// Export persistent storage structures
export const whitelist = new PersistentSet<AccountId>('w')
export const factory_whitelist = new PersistentSet<AccountId>('f')

// Export classes
@nearBindgen
export class WhitelistContract {
    /// The account ID of the NEAR Foundation. It allows to whitelist new staking pool accounts.
    /// It also allows to whitelist new Staking Pool Factories, which can whitelist staking pools.
    foundation_account_id: AccountId;

    /// The whitelisted account IDs of approved staking pool contracts.
    whitelist: PersistentSet<AccountId>;

    /// The whitelist of staking pool factories. Any account from this list can whitelist staking
    /// pools.
    factory_whitelist: PersistentSet<AccountId>;

    constructor(
        foundation_account_id: AccountId,
        whitelist: PersistentSet<AccountId>,
        factory_whitelist: PersistentSet<AccountId>
    ) {
        foundation_account_id = this.foundation_account_id;
        whitelist = this.whitelist;
        factory_whitelist = this.factory_whitelist;
    }
}
'''
'''--- assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- assembly/types.ts ---
import { u128 } from 'near-sdk-as'

export type AccountId = string; // represent NEAR accounts - e.g. myaccount.near

'''
'''--- compile.js ---
// This file does two things:
//
// 1. Compile the AssemblyScript contract using the scripts in package.json
//    (see buildCmd below). This will create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')
const path = require('path')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// AssemblyScript project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// Use the correct build command based on the `--debug` flag
const buildCmd = debug
  ? 'npm run build:debug'
  : 'npm run build'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require(`${__dirname}/package.json`).name
  const outFile = `./build/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  const linkPath = path.relative(linkDir, outFile)
  sh.ln('-s', linkPath, link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- package.json ---
{
  "name": "whitelist",
  "version": "0.2.0",
  "license": "UNLICENSED",
  "authors": ["Near Inc <hello@near.org>", "Aaron Luhning <vitalpoint.ai> (AssemblyScript translation)"],
  "edition": "2018",

  "scripts": {
    "build": "asb",
    "build:debug": "asb --target debug",
    "test": "asp --nologo"
  },
  "dependencies": {
    "near-sdk-as": "2.2.4"
  },
  "devDependencies": {
    "shelljs": "^0.8.4"
  }
}

'''