*GitHub Repository "near-ndc/astra"*

'''--- .github/workflows/tests.yml ---
name: Rust

on:
  pull_request:
    branches: [master, main]
  merge_group:
  push:
    branches: ["master"]

concurrency:
  group: ci-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: technote-space/get-diff-action@v6.1.2
        with:
          PATTERNS: |
            **/**.rs
            Cargo.lock
      - name: Install latest nightly
        if: env.GIT_DIFF
        uses: actions-rs/toolchain@v1
        with:
          toolchain: 1.69.0
          override: true
          components: rustfmt, clippy

      - name: Install wasm32 toolchain
        if: env.GIT_DIFF
        run: rustup target add wasm32-unknown-unknown
      - name: Build
        run: sh build.sh

      - name: Run Cargo tests
        run: cargo test --workspace -- --nocapture

'''
'''--- CHANGELOG.md ---
<!-- markdownlint-disable MD013 -->
<!-- markdownlint-disable MD024 -->

<!--
Changelogs are for humans, not machines.
There should be an entry for every single version.
The same types of changes should be grouped.
The latest version comes first.
The release date of each version is displayed.

Usage:

Change log entries are to be added to the Unreleased section. Example entry:

* [#<PR-number>](https://github.com/umee-network/umee/pull/<PR-number>) <description>

-->

# CHANGELOG

## Unreleased

### Features

New methods:

- A..

Extended types:

New types:

### Breaking Changes

- B...

### Bug Fixes

'''
'''--- Cargo.toml ---
[workspace]
members = [
  "astra",
  "test-token",
  "astra-factory",
  "astra-staking",
]

[workspace.package]
edition = "2021"
license = "MIT"
repository = "https://github.com/near-ndc/astra"
authors = [
    "Sputnik Devs <near-daos@protonmail.com>",
    "NDC GWG (https://near.social/#/mob.near/widget/ProfilePage?accountId=govworkinggroup.near)",
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = true
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace.dependencies]
near-sdk = "^4.1.1"
near-contract-standards = "^4.1.1"
uint = { version = "^0.9.5", default-features = false }
serde_json = "^1.0"
hex = "0.4.2"

# workspace doesn't have dev-dependencies field, so we have to put the dependencies here
# https://doc.rust-lang.org/cargo/reference/workspaces.html
anyhow = "1.0.72"
tokio = { version = "1.29.1", features = ["full"] }
workspaces = "0.7.0"
near-primitives = "0.17.0"
near-units = "0.2.0"
'''
'''--- README.md ---
# Astra DAO

> Building on the functionality of [Astra V1](https://github.com/near-daos/sputnik-dao-contract-legacy), Astra DAO V2 offers even more features and enhanced configuration ability. Astra V1 is archived because it can no longer be extended. Its newer version, Astra V2, aims to be more flexible in this regard and it provides new features that can be opt-in by the users. [Code Review video with Trevor of CronCat](https://www.youtube.com/watch?v=M8AafQSLi7g&list=PLPxUkIZ41o-2iQWQf_wlyugF7JaY5b5bJ&index=3).

## Overview

| Name                                          | Description                                                           |
| --------------------------------------------- | --------------------------------------------------------------------- |
| [Setup](#setup)                               | Step-by-step guide to deploy a DAO factory and DAO contracts.         |
| [Roles & Permissions](#roles-and-permissions) | Setup roles and define permissions for each role.                     |
| [Proposals](#proposals)                       | Each action on the DAO is done by creating and approving a proposal.  |
| [Voting](#voting)                             | Configure policies, setup governance tokens, and vote on proposals.   |
| [Bounties](#bounties)                         | Add and configure bounties.                                           |
| [Blob Storage](#blob-storage)                 | Store large data blobs and content and index them by the data's hash. |
| [Upgradability](#upgradability)               | Upgrade the DAO to different contract code versions.                  |

---

## Setup

### Prerequisites

1. [NEAR Account](https://wallet.testnet.near.org)
2. [NEAR-CLI](https://docs.near.org/docs/tools/near-cli#setup)
3. [Rust](https://www.rust-lang.org)

<details>
<summary>3-Step Rust Installation.</summary>
<p>

1. Install Rustup:

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

[_(Taken from official installation guide)_](https://www.rust-lang.org/tools/install)

2. Configure your current shell:

```
source $HOME/.cargo/env
```

3. Add Wasm target to your toolchain:

```
rustup target add wasm32-unknown-unknown
```

</p>
</details>

---

<details>
<summary>1. Login with your account.</summary>
<p>

Using [`near-cli`](https://docs.near.org/docs/tools/near-cli#near-login), login to your account which will save your credentials locally:

```bash
near login
```

</p>
</details>

<details>
<summary>2. Clone repository.</summary>
<p>

```bash
git clone https://github.com/near-daos/sputnik-dao-contract
```

</p>
</details>

<details>
<summary>3. Build factory contract.</summary>
<p>

```bash
cd astra-dao-contract/astra-factory && ./build.sh
```

</p>
</details>

<details>
<summary>4. Deploy factory.</summary>
<p>

- Create an env variable replacing `YOUR_ACCOUNT.testnet` with the name of the account you logged in with earlier:

```bash
export CONTRACT_ID=YOUR_ACCOUNT.testnet
```

- Deploy factory contract by running the following command from your current directory _(`astra-dao-contract/astra-factory`)_:

```bash
near deploy $CONTRACT_ID --wasmFile=res/astra_factory.wasm --accountId $CONTRACT_ID
```

</p>
</details>

<details>
<summary>5. Initialize factory.</summary>
<p>

```bash
near call $CONTRACT_ID new --accountId $CONTRACT_ID --gas 100000000000000
```

</p>
</details>

<details>
<summary>6. Define the parameters of the new DAO, its council, and create it.</summary>
<p>

- Define the council of your DAO:

```bash
export COUNCIL='["council-member.testnet", "YOUR_ACCOUNT.testnet"]'
```

- Configure the name, purpose, and initial council members of the DAO and convert the arguments in base64:

```bash
export ARGS=`echo '{"config": {"name": "genesis", "purpose": "Genesis DAO", "metadata":""}, "policy": '$COUNCIL'}' | base64`
```

- Create the new DAO!:

```bash
near call $CONTRACT_ID create "{\"name\": \"genesis\", \"args\": \"$ARGS\"}" --accountId $CONTRACT_ID --amount 10 --gas 150000000000000
```

**Example Response:**

```bash
Scheduling a call: astra-v2.testnet.create({"name": "genesis", "args": "eyJjb25maWciOiB7Im5hbWUiOiAiZ2VuZXNpcyIsICJwdXJwb3NlIjogIkdlbmVzaXMgREFPIiwgIm1ldGFkYXRhIjoiIn0sICJwb2xpY3kiOiBbImNvdW5jaWwtbWVtYmVyLnRlc3RuZXQiLCAiWU9VUl9BQ0NPVU5ULnRlc3RuZXQiXX0K"}) with attached 5 NEAR
Transaction Id 5beqy8ZMkzpzw7bTLPMv6qswukqqowfzYXZnMAitRVS7
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/5beqy8ZMkzpzw7bTLPMv6qswukqqowfzYXZnMAitRVS7
true
```

**Note:** If you see `false` at the bottom (after the transaction link) something went wrong. Check your arguments passed and target contracts and re-deploy.

</p>
</details>

<details>
<summary>7. Verify successful deployment and policy configuration.</summary>
<p>

The DAO deployment will create a new [sub-account](https://docs.near.org/docs/concepts/account#subaccounts) ( `genesis.YOUR_ACCOUNT.testnet` ) and deploy a Astra DAO contract to it.

- Setup another env variable for your DAO contract:

```bash
export ASTRA_ID=genesis.$CONTRACT_ID
```

- Now call `get_policy` on this contract using [`near view`](https://docs.near.org/docs/tools/near-cli#near-view)

```bash
near view $ASTRA_ID get_policy
```

- Verify that the name, purpose, metadata, and council are all configured correctly. Also note the following default values for roles and permissions:

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": ["*:AddProposal", "*:Execute"],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": { "Group": ["council-member.testnet", "YOUR_ACCOUNT.testnet"] },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {}
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [1, 2]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

</p>
</details>

---

## Roles and Permissions

> The DAO can have several roles, each of which allows for permission configuring. These permissions are a combination of [`proposal_kind`](#proposal-types) and `VotingAction`. Due to this combination these permissions can be scoped to be very specific or you can use wildcards to grant greater access.

**Examples:**

- A role with: `["transfer:VoteReject","transfer:VoteRemove"]` means they can only vote to _reject_ or _remove_ a `transfer` proposal but they can't vote to approve.

- A role with: `["transfer:*"]` can perform any vote action on `transfer` proposals.

- A role with: `["*:*"]` has _unlimited_ permission. Normally, the `council` role has `*:*` as its permission so they can perform _any_ vote action on _any_ kind of proposal.

- A role with: `"VetoProposal"` or `"Dissolve"` can perform veto proposal and dissolve DAO actions.

**Here is a list of actions:**

- `AddProposal` - _Adds given proposal to the DAO (this is the primary mechanism for getting things done)._
- `RemoveProposal` - _Removes given proposal (this is used for immediate deletion in special cases)._
- `VoteApprove` - _Votes to approve given proposal or bounty._
- `VoteReject` - _Votes to reject given proposal or bounty._
- `VoteRemove` - _Votes to remove given proposal or bounty (this may be because the proposal is spam or otherwise invalid)._
- `Finalize` - _Finalizes proposal which is cancelled when proposal has expired (this action also returns funds)._
- `MoveToHub` - _Moves a proposal to the hub (this is used to move a proposal into another DAO)._
- `Execute` - Execute a proposal if it was not executed in final vote.
- `VetoProposal` - Veto a proposal. Veto is instant, it will `reject` the proposal and return bond.
- `Dissolve` - Dissolve this DAO: remove all members of the DAO, and sending the remaining funds back to the trust.

---

## Proposals

> Proposals are the main way to interact with the DAO. Each action on the DAO is performed by creating and approving a proposal.

| Contents                                            |
| --------------------------------------------------- |
| [Proposal types](#proposal-types)                   |
| [Add proposal](#add-proposal)                       |
| [View proposal](#view-proposal)                     |
| [View multiple proposals](#view-multiple-proposals) |
| [Approve proposal](#approve-proposal)               |

---

### Proposal types

> Each kind of proposal represents an operation the DAO can perform. Here are the kinds of proposals:

```rs
ProposalKind::ChangeConfig { .. },
ProposalKind::ChangePolicy { .. },
ProposalKind::AddMemberToRole { .. },
ProposalKind::RemoveMemberFromRole { .. },
ProposalKind::FunctionCall { .. },
ProposalKind::UpgradeSelf { .. },
ProposalKind::UpgradeRemote { .. },
ProposalKind::Transfer { .. },
ProposalKind::SetStakingContract { .. },
ProposalKind::AddBounty { .. },
ProposalKind::BountyDone { .. },
ProposalKind::Vote,
ProposalKind::FactoryInfoUpdate { .. },
ProposalKind::ChangePolicyAddOrUpdateRole { .. },
ProposalKind::ChangePolicyRemoveRole { .. },
ProposalKind::ChangePolicyUpdateDefaultVotePolicy { .. },
ProposalKind::ChangePolicyUpdateParameters { .. },
```

- **ChangeConfig** - used to change the configuration of the DAO
- **ChangePolicy** - used to change the full policy of the DAO
- **AddMemberToRole** - used to add a member to a role in the DAO
- **RemoveMemberFromRole** - used to remove a member from a role in the DAO
- **FunctionCall** - used to a call a function on any valid account on the network including the DAO itself, any other DAO, or any other contract. This is a useful mechanism for extending the capabilities of the DAO without modifying or complicating the DAO contract code.  One can imagine a family of contracts built specifically to serve the DAO as agents, proxies, oracles and banks, for example.
- **UpgradeSelf** - used to upgrade the DAO contract itself.
- **UpgradeRemote** - used to upgrade other contracts. For DAOs that are governing other protocols, this type of proposal will allow to upgrade another contract with its newer version.
- **Transfer** - used to move assets from this DAO to another account on the network. Supports both `NEAR` and any `NEP-141` token that this DAO has.
- **SetStakingContract** - used to set the staking contract of the DAO to help users delegate their tokens.
- **AddBounty** - used to add a bounty to encourage members of the DAO community to contribute their time and attention to the needs of the DAO
- **BountyDone** - used to mark the completion of an available bounty
- **Vote** - used to create polls. Vote proposal doesn't have any action.
- **FactoryInfoUpdate** - used for changing permissions of the factory that created the DAO. By default, the factory has permission to upgrade the DAO, but this can be modified by using `FactoryInfoUpdate`.
- **ChangePolicyAddOrUpdateRole** - used to add a new role to the policy of the DAO. If the role already exists, update it.
- **ChangePolicyRemoveRole** - used to remove a role from the policy of the DAO.
- **ChangePolicyUpdateDefaultVotePolicy** - used to update the default vote policy from the policy of the DAO.
- **ChangePolicyUpdateParameters** - used to update the parameters from the policy of the DAO. Parameters include: proposal bond, proposal period, bounty bond, bounty forgiveness period.

---

### Add proposal

> Adds a proposal to the DAO contract and returns the index number of the proposal or "proposal ID". By default, anyone can add a proposal but it requires a minimum 1 Ⓝ bond (attached deposit).

- method: `add_proposal`
- params:
  - `proposal`
    - `description`
    - `kind`
    - `category` [optional]
- proposer account ID
- attached deposit (minimum 1 Ⓝ)

<details>
<summary>Example argument structure:</summary>
<p>

```json
{
  "proposal": {
    "description": "Add New Council",
    "kind": {
      "AddMemberToRole": {
        "member_id": "council_member_3.testnet",
        "role": "council",
        "category": "legal"
      }
    }
  }
}
```

</p>
</details>

<details>
<summary>Example near-cli command:</summary>
<p>

```bash
near call genesis.astra.testnet add_proposal \
'{"proposal": {"description": "Add New Council", "kind": {"AddMemberToRole": {"member_id": "council_member_3.testnet", "role": "council", "category": "marketing"}}}}' \
--accountId proposer.testnet \
--amount 1
```

</p>
</details>

<details>
<summary>Example response:</summary>
<p>

```bash
Transaction Id HbJdK9AnZrvjuuoys2z1PojdkyFiuWBvrDbXsAf5ndvu
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/HbJdK9AnZrvjuuoys2z1PojdkyFiuWBvrDbXsAf5ndvu
0
```

**Note:** The number under the transaction link is the proposal ID.

</p>
</details>

---

### View proposal

> Returns proposal details by passing the ID or index of a given proposal.

- method: `get_proposal`
  - params: `id`

<details>
<summary>Example near-cli command:</summary>
<p>

```bash
near view genesis.astra.testnet get_proposal '{"id": 0}'
```

</p>
</details>

<details>
<summary>Example response:</summary>
<p>

```json
{
  "id": 0,
  "proposer": "near-example.testnet",
  "description": "Add New Council",
  "kind": {
    "AddMemberToRole": {
      "member_id": "council_member_3.testnet",
      "role": "council"
    }
  },
  "status": "InProgress",
  "vote_counts": {},
  "votes": {},
  "submission_time": "1624947631810665051"
}
```

</p>
</details>

---

### View multiple proposals

> Returns multiple proposal details by passing the index ("ID") starting point and a limit of how many records you would like returned.

- method: `get_proposals`
- params:
  - `from_index`
  - `limit`

<details>
<summary>Example near-cli command:</summary>
<p>

```bash
near view genesis.astra.testnet get_proposals '{"from_index": 1, "limit": 2}'
```

</p>
</details>

<details>
<summary>Example response:</summary>
<p>

```js
[
  {
    id: 1,
    proposer: 'near-example.testnet',
    description: 'Add New Council',
    kind: {
      AddMemberToRole: { member_id: 'council_member_4.testnet', role: 'council' }
    },
    status: 'InProgress',
    vote_counts: {},
    votes: {},
  submission_time: '1624947785010147691'
  },
  {
    id: 2,
    proposer: 'near-example.testnet',
    description: 'Add New Council',
    kind: {
      AddMemberToRole: { member_id: 'council_member_5.testnet', role: 'council' }
    },
    status: 'InProgress',
    vote_counts: {},
    votes: {},
    submission_time: '1624947838518330827'
  }
]
```

</p>
</details>

---

### Approve proposal

> Approves proposal by ID. Only council members can approve a proposal

- method: `act_proposal`
- params:
  - `id`
  - `action`
- account ID that is a council member.

<details>
<summary>Example near-cli command:</summary>
<p>

```bash
near call genesis.astra.testnet act_proposal '{"id": 0, "action": "VoteApprove"}' \
--accountId council_member_1.testnet
```

</p>
</details>

<details>
<summary>Example response:</summary>
<p>

```bash
Receipts: 3mkSgRaHsd46FHkf9AtTcPbNXkYkxMCzPfJFHsHk8NPm, GjJ6hmoAhxt2a7si4hVPYZiL9CWeM5fmSEzMTpC7URxV
        Log [genesis.astra.testnet]: ["council"]
Transaction Id BZPHxNoBpyMG4seCojzeNrKpr685vWPynDMTdg1JACa7
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/BZPHxNoBpyMG4seCojzeNrKpr685vWPynDMTdg1JACa7
''
```

</p>
</details>

---

## Voting

>

### Vote on a proposal

> Only council members are allowed to vote on a proposal.

---

### Voting policy

> You can set a different vote policy for each one of the proposal kinds.

Vote policy can be: `TokenWeight`, meaning members vote with tokens, or `RoleWeight(role)` where all users with such role (e.g."council") can vote.

Also a vote policy has a "threshold". The threshold could be a ratio. e.g. `threshold:[1,2]` => 1/2 or 50% of the votes approve the proposal, or the threshold could be a fixed number (weight), so you can say that you need 3 votes to approve a proposal disregarding the amount of people in the role, and you can say that you need 1m tokens to approve a proposal disregarding total token supply.

When vote policy is `TokenWeight`, vote % is measured against total toke supply, and each member vote weight is based on tokens owned. So if threshold is 1/2 you need half the token supply to vote "yes" to pass a proposal.

When vote policy is `RoleWeight(role)`, vote % is measured against the count of people with that role, and each member has one vote. So if threshold is 1/2 you need half the members with the role to vote "yes" to pass a proposal.

---

### Token voting

> DAO votes to select some token to become voting token (only can be done once, can't change later).

User flow to vote with selected token:

- Users deposit the desired amount of the token to the separate staking contract defined by the DAO.
- They can then choose who to delegate these tokens. It can be to themselves or to other users to increase their vote weight.
- When users vote for proposals, their vote is weighted by all the delegations to them.
- Undelegating will block delegating / withdrawing until one voting period passes.
- Undelegated tokens can be withdrawn by the user.

---

## Bounties

> Add and configure bounties using `AddBounty` proposal.

The lifecycle of a bounty is the next:

- Anyone with permission can add proposal `AddBounty` which contains the bounty information including `token` to pay the reward in and `amount` to pay it out.
- This proposal gets voted in by the current voting policy.
- After proposal is passed, the bounty gets added. Now it has an `id` in the bounty list which can be queried via `get_bounties`.
- Anyone can claim a bounty by calling `bounty_claim(id, deadline)` up to `repeat` times which was specified in the bounty. This allows to have repetitive bounties or multiple working collaboratively.
- `deadline` specifies how long it will take the sender to complete the bounty.
- If claimer decides to give up, they can call `bounty_giveup(id)`, and within `forgiveness_period` their claim bond will be returned. After this period, their bond is forfeited and is kept in the DAO.
- When a bounty is complete, call `bounty_done(id)`, which will add a proposal `BountyDone` that, when voted, will pay to whoever completed the bounty.

---

## Blob storage

> DAO supports storing larger blobs of data and content indexing them by hash of the data. This is done to allow upgrading the DAO itself and other contracts.

Blob lifecycle:

- Store blob in the DAO.
- Create upgradability proposal.
- Proposal passes or fails.
- Remove blob and receive funds locked for storage back.

Blob can be removed only by the original storer.

---

## Upgradability

> Allow the DAO to be upgraded to different contract code versions. This allows the DAO to use a newer, more stable and faster version of the contract code. New versions usually include new features, bug fixes and improvements in performance. Downgrade to an older version is also possible.

There are two major ways to upgrade the DAO:
 - Self upgrade by storing blob on the DAO contract and then voting to UpgradeSelf
 - Upgrade from the factory - factory stores new contract and then, if allowed, it upgrades the DAO by calling `upgrade(code)`.

DAOs can explicitly vote to disable factory auto upgrades and can pull the upgrade themselves from the factory.

'''
'''--- astra-factory/Cargo.toml ---
[package]
name = "astra-factory"
version = "0.1.0"
publish = false
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk.workspace = true

[dev-dependencies]
workspaces.workspace = true
near-units.workspace = true

'''
'''--- astra-factory/README.md ---
# Astra Factory

# Deployment & Usage

## TestNet

```
near dev-deploy --wasmFile=res/astra_factory.wasm

# bash
CONTRACT_ID="dev-1608694678554-8567049"
# fish
set CONTRACT_ID "dev-1608694678554-8567049"

# Initialize the factory.
near call $CONTRACT_ID new '{}' --accountId $CONTRACT_ID 

# bash
ARGS=`echo '{"purpose": "test", "council": ["testmewell.testnet", "illia"], "bond": "1000000000000000000000000", "vote_period": "1800000000000", "grace_period": "1800000000000"}' | base64`
# fish
set ARGS (echo '{"purpose": "test", "council": ["testmewell.testnet", "illia"], "bond": "1000000000000000000000000", "vote_period": "1800000000000", "grace_period": "1800000000000"}' | base64)

# Create a new DAO with the given parameters.
near call $CONTRACT_ID create "{\"name\": \"test\", \"public_key\": null, \"args\": \"$ARGS\"}"  --accountId $CONTRACT_ID --amount 30 --gas 100000000000000

# Create a new DAO with the given parameters while having Full Access Key to the account (trusted, but useful in case of testing or upgrades)
near call $CONTRACT_ID create "{\"name\": \"test\", \"public_key\": \"<base58 of public key>\", \"args\": \"$ARGS\"}"  --accountId $CONTRACT_ID --amount 30 --gas 100000000000000

# List all created DAOs.
near view $CONTRACT_ID get_dao_list
```

# ABIs

V1 is archived in a different repo. :)

### Astra Factory :: v3
```
{
  "viewMethods": [
    "get_dao_list",
    "get_number_daos",
    "get_daos",
    "get_owner",
    "get_default_code_hash",
    "get_default_version",
    "get_code",
    "get_contracts_metadata"
  ],
  "changeMethods": [
    "new",
    "create",
    "set_owner",
    "set_default_code_hash",
    "delete_contract",
    "update",
    "store_contract_metadata",
    "delete_contract_metadata",
    "store"
  ],
}
```

### Astra DAO :: v2
```
{
  "viewMethods": [
    "get_dao_list"
  ],
  "changeMethods": [
    "new",
    "create"
  ],
}
```
'''
'''--- astra-factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cd ..
mkdir -p res
cp target/wasm32-unknown-unknown/release/astra_factory.wasm res/

'''
'''--- astra-factory/src/factory_manager.rs ---
//! Module for standard generic contract factory manager.
//! TODO: move to near-sdk standards library.

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base58CryptoHash;
use near_sdk::serde_json;
use near_sdk::{env, AccountId, Balance, CryptoHash, Gas};

/// Gas spent on the call & account creation.
const CREATE_CALL_GAS: Gas = Gas(40_000_000_000_000);

/// Gas allocated on the callback.
const ON_CREATE_CALL_GAS: Gas = Gas(10_000_000_000_000);

/// Leftover gas after creating promise and calling update.
const GAS_UPDATE_LEFTOVER: Gas = Gas(10_000_000_000_000);

const NO_DEPOSIT: Balance = 0;

/// Factory manager that allows to store/load contracts by hash directly in the storage.
/// Uses directly underlying host functions to not load any of the data into WASM memory.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct FactoryManager {}

impl FactoryManager {
    /// Store contract from input.
    pub fn store_contract(&self) {
        let input = env::input().expect("ERR_NO_INPUT");
        let sha256_hash = env::sha256(&input);
        assert!(!env::storage_has_key(&sha256_hash), "ERR_ALREADY_EXISTS");
        env::storage_write(&sha256_hash, &input);

        let mut blob_hash = [0u8; 32];
        blob_hash.copy_from_slice(&sha256_hash);
        let blob_hash_str = serde_json::to_string(&Base58CryptoHash::from(blob_hash))
            .unwrap()
            .into_bytes();
        env::value_return(&blob_hash_str);
    }

    /// Delete code from the contract.
    pub fn delete_contract(&self, code_hash: Base58CryptoHash) {
        let code_hash: CryptoHash = code_hash.into();
        env::storage_remove(&code_hash);
    }

    /// Get code for given hash.
    pub fn get_code(&self, code_hash: Base58CryptoHash) {
        let code_hash: CryptoHash = code_hash.into();
        // Check that such contract exists.
        assert!(env::storage_has_key(&code_hash), "Contract doesn't exist");
        // Load the hash from storage.
        let code = env::storage_read(&code_hash).unwrap();
        // Return as value.
        env::value_return(&code);
    }

    /// Forces update on the given contract.
    /// Contract must support update by factory for this via permission check.
    pub fn update_contract(
        &self,
        account_id: AccountId,
        code_hash: Base58CryptoHash,
        method_name: &str,
    ) {
        let code_hash: CryptoHash = code_hash.into();
        // Check that such contract exists.
        assert!(env::storage_has_key(&code_hash), "Contract doesn't exist");
        // Load the hash from storage.
        let code = env::storage_read(&code_hash).expect("ERR_NO_HASH");
        // Create a promise toward given account.
        let promise_id = env::promise_batch_create(&account_id);
        // Call `update` method, which should also handle migrations.
        env::promise_batch_action_function_call(
            promise_id,
            method_name,
            &code,
            NO_DEPOSIT,
            env::prepaid_gas() - env::used_gas() - GAS_UPDATE_LEFTOVER,
        );
        env::promise_return(promise_id);
    }

    /// Create given contract with args and callback factory.
    pub fn create_contract(
        &self,
        code_hash: Base58CryptoHash,
        account_id: AccountId,
        new_method: &str,
        args: &[u8],
        callback_method: &str,
        callback_args: &[u8],
    ) {
        let code_hash: CryptoHash = code_hash.into();
        let attached_deposit = env::attached_deposit();
        let factory_account_id = env::current_account_id();
        // Check that such contract exists.
        assert!(env::storage_has_key(&code_hash), "Contract doesn't exist");
        // Load input (wasm code).
        let code = env::storage_read(&code_hash).expect("ERR_NO_HASH");
        // Compute storage cost.
        let code_len = code.len();
        let storage_cost = ((code_len + 32) as Balance) * env::storage_byte_cost();
        assert!(
            attached_deposit >= storage_cost,
            "ERR_NOT_ENOUGH_DEPOSIT:{}",
            storage_cost
        );
        // Schedule a Promise tx to account_id.
        let promise_id = env::promise_batch_create(&account_id);
        // Create account first.
        env::promise_batch_action_create_account(promise_id);
        // Transfer attached deposit.
        env::promise_batch_action_transfer(promise_id, attached_deposit);
        // Deploy contract.
        env::promise_batch_action_deploy_contract(promise_id, &code);
        // call `new` with given arguments.
        env::promise_batch_action_function_call(
            promise_id,
            new_method,
            args,
            NO_DEPOSIT,
            CREATE_CALL_GAS,
        );
        // attach callback to the factory.
        let _ = env::promise_then(
            promise_id,
            factory_account_id,
            callback_method,
            callback_args,
            NO_DEPOSIT,
            ON_CREATE_CALL_GAS,
        );
        env::promise_return(promise_id);
    }
}

'''
'''--- astra-factory/src/lib.rs ---
mod factory_manager;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base58CryptoHash, Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{self, json};
use near_sdk::{env, near_bindgen, AccountId, Balance, CryptoHash, Gas, PanicOnDefault, Promise};

use factory_manager::FactoryManager;

type Version = [u8; 2];

// The keys used for writing data to storage via `env::storage_write`.
const DEFAULT_CODE_HASH_KEY: &[u8; 4] = b"CODE";
const FACTORY_OWNER_KEY: &[u8; 5] = b"OWNER";
const CODE_METADATA_KEY: &[u8; 8] = b"METADATA";

// The values used when writing initial data to the storage.
const DAO_CONTRACT_INITIAL_CODE: &[u8] = include_bytes!("../../target/wasm32-unknown-unknown/release/astra.wasm");
const DAO_CONTRACT_INITIAL_VERSION: Version = [3, 0];
const DAO_CONTRACT_NO_DATA: &str = "no data";

// Gas & Costs for blob storage
const GAS_STORE_CONTRACT_LEFTOVER: Gas = Gas(20_000_000_000_000);
const ON_REMOVE_CONTRACT_GAS: Gas = Gas(10_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct DaoContractMetadata {
    // version of the DAO contract code (e.g. [2, 0] -> 2.0, [3, 1] -> 3.1, [4, 0] -> 4.0)
    pub version: Version,
    // commit id of https://github.com/near-daos/sputnik-dao-contract
    // representing a snapshot of the code that generated the wasm
    pub commit_id: String,
    // if available, url to the changelog to see the changes introduced in this version
    pub changelog_url: Option<String>,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct AstraFactory {
    factory_manager: FactoryManager,
    daos: UnorderedSet<AccountId>,
}

#[near_bindgen]
impl AstraFactory {
    #[init]
    pub fn new() -> Self {
        let this = Self {
            factory_manager: FactoryManager {},
            daos: UnorderedSet::new(b"d".to_vec()),
        };
        this.internal_store_initial_contract();
        this
    }

    fn internal_store_initial_contract(&self) {
        self.assert_owner();
        let code = DAO_CONTRACT_INITIAL_CODE.to_vec();
        let sha256_hash = env::sha256(&code);
        env::storage_write(&sha256_hash, &code);

        self.store_contract_metadata(
            slice_to_hash(&sha256_hash),
            DaoContractMetadata {
                version: DAO_CONTRACT_INITIAL_VERSION,
                commit_id: String::from(DAO_CONTRACT_NO_DATA),
                changelog_url: None,
            },
            true,
        );
    }

    pub fn set_owner(&self, owner_id: AccountId) {
        self.assert_owner();
        env::storage_write(FACTORY_OWNER_KEY, owner_id.as_bytes());
    }

    pub fn set_default_code_hash(&self, code_hash: Base58CryptoHash) {
        self.assert_owner();
        let code_hash: CryptoHash = code_hash.into();
        assert!(
            env::storage_has_key(&code_hash),
            "Code not found for the given code hash. Please store the code first."
        );
        env::storage_write(DEFAULT_CODE_HASH_KEY, &code_hash);
    }

    pub fn delete_contract(&self, code_hash: Base58CryptoHash) {
        self.assert_owner();
        self.factory_manager.delete_contract(code_hash);
        self.delete_contract_metadata(code_hash);
    }

    #[payable]
    pub fn create(&mut self, name: AccountId, args: Base64VecU8) {
        let account_id: AccountId = format!("{}.{}", name, env::current_account_id())
            .parse()
            .unwrap();
        let callback_args = serde_json::to_vec(&json!({
            "account_id": account_id,
            "attached_deposit": U128(env::attached_deposit()),
            "predecessor_account_id": env::predecessor_account_id()
        }))
        .expect("Failed to serialize");
        self.factory_manager.create_contract(
            self.get_default_code_hash(),
            account_id,
            "new",
            &args.0,
            "on_create",
            &callback_args,
        );
    }

    #[private]
    pub fn on_create(
        &mut self,
        account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> bool {
        if near_sdk::is_promise_success() {
            self.daos.insert(&account_id);
            true
        } else {
            Promise::new(predecessor_account_id).transfer(attached_deposit.0);
            false
        }
    }

    /// Tries to update given account created by this factory to the specified code.
    pub fn update(&self, account_id: AccountId, code_hash: Base58CryptoHash) {
        let caller_id = env::predecessor_account_id();
        assert!(
            caller_id == self.get_owner() || caller_id == account_id,
            "Must be updated by the factory owner or the DAO itself"
        );
        assert!(
            self.daos.contains(&account_id),
            "Must be contract created by factory"
        );
        self.factory_manager
            .update_contract(account_id, code_hash, "update");
    }

    /// Allows a DAO to store the official factory version as a blob, funded by the DAO wanting to upgrade
    /// Required to successfully upgrade a DAO via proposals (proposal to store blob, proposal to upgrade from local blob)
    /// Only intended for astra v2 DAO's created by astra factory
    /// Payment is needed to cover storage costs for code blob size, paid by the DAO and returned upon blob removal
    #[payable]
    pub fn store_contract_self(&mut self, code_hash: Base58CryptoHash) {
        let account_id = env::predecessor_account_id();
        let method_name = "store_blob";

        let hash: CryptoHash = code_hash.into();
        assert!(
            env::storage_has_key(&hash),
            "Code not found for the given code hash. Please store the code first."
        );

        // Lock down contract upgrades to this factory:
        let dao_id = env::predecessor_account_id().to_string();
        let idx = dao_id.find('.').expect("INTERNAL_FAIL");
        // ex: astra-dao.near
        let factory_id = &dao_id[idx + 1..];

        assert_eq!(
            factory_id,
            env::current_account_id().as_str(),
            "Wrong factory"
        );

        let dao_contract_code = env::storage_read(&hash).expect("CODE_HASH_NONEXIST");

        // Compute and use the correct amount needed for storage
        let blob_len = dao_contract_code.len();
        let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();

        // Confirm payment before proceeding
        assert!(
            storage_cost <= env::attached_deposit(),
            "Must at least deposit {} to store",
            storage_cost
        );

        // refund the extra cost
        let extra_attached_deposit = env::attached_deposit() - storage_cost;
        Promise::new(account_id.clone()).transfer(extra_attached_deposit);

        // Create a promise toward given account.
        let promise_id = env::promise_batch_create(&account_id);
        env::promise_batch_action_function_call(
            promise_id,
            method_name,
            &dao_contract_code,
            storage_cost,
            env::prepaid_gas() - env::used_gas() - GAS_STORE_CONTRACT_LEFTOVER,
        );
        env::promise_return(promise_id);
    }

    /// Allows a DAO to remove the blob stored in its DAO storage, and reclaim the storage cost
    pub fn remove_contract_self(&mut self, code_hash: Base58CryptoHash) {
        let account_id = env::predecessor_account_id();
        let factory_id = env::current_account_id();
        let method_name = "remove_blob";

        // NOTE: Not verifing the hash, in case factory removes a hash before DAO does
        let method_args = &json!({ "hash": &code_hash }).to_string().into_bytes();
        let callback_method = "on_remove_contract_self";
        let callback_args = &json!({ "account_id": &account_id, "code_hash": &code_hash })
            .to_string()
            .into_bytes();

        // Create a promise toward given account.
        let promise_id = env::promise_batch_create(&account_id);
        env::promise_batch_action_function_call(
            promise_id,
            method_name,
            method_args,
            NO_DEPOSIT,
            GAS_STORE_CONTRACT_LEFTOVER,
        );
        // attach callback to the factory.
        let _ = env::promise_then(
            promise_id,
            factory_id,
            callback_method,
            callback_args,
            NO_DEPOSIT,
            ON_REMOVE_CONTRACT_GAS,
        );
        env::promise_return(promise_id);
    }

    /// Upon blob remove, compute the balance (if any) that got paid to the factory,
    /// since it was the "owner" of the blob stored on the DAO.
    /// Send this balance back to the DAO, since it was the original funder
    #[private]
    pub fn on_remove_contract_self(
        &mut self,
        account_id: AccountId,
        code_hash: Base58CryptoHash,
    ) -> bool {
        if near_sdk::is_promise_success() {
            // Compute the actual storage cost for an accurate refund
            let hash: CryptoHash = code_hash.into();
            let dao_contract_code = env::storage_read(&hash).expect("CODE_HASH_NONEXIST");
            let blob_len = dao_contract_code.len();
            let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
            Promise::new(account_id).transfer(storage_cost);
            true
        } else {
            false
        }
    }

    pub fn get_dao_list(&self) -> Vec<AccountId> {
        self.daos.to_vec()
    }

    /// Get number of created DAOs.
    pub fn get_number_daos(&self) -> u64 {
        self.daos.len()
    }

    /// Get daos in paginated view.
    pub fn get_daos(&self, from_index: u64, limit: u64) -> Vec<AccountId> {
        let elements = self.daos.as_vector();
        (from_index..std::cmp::min(from_index + limit, elements.len()))
            .filter_map(|index| elements.get(index))
            .collect()
    }

    pub fn get_owner(&self) -> AccountId {
        AccountId::new_unchecked(
            String::from_utf8(
                env::storage_read(FACTORY_OWNER_KEY)
                    .unwrap_or(env::current_account_id().as_bytes().to_vec()),
            )
            .expect("INTERNAL_FAIL"),
        )
    }

    pub fn get_default_code_hash(&self) -> Base58CryptoHash {
        slice_to_hash(&env::storage_read(DEFAULT_CODE_HASH_KEY).expect("Must have code hash"))
    }

    pub fn get_default_version(&self) -> Version {
        let storage_metadata = env::storage_read(CODE_METADATA_KEY).expect("INTERNAL_FAIL");
        let deserialized_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
            BorshDeserialize::try_from_slice(&storage_metadata).expect("INTERNAL_FAIL");
        let default_metadata = deserialized_metadata
            .get(&self.get_default_code_hash())
            .expect("INTERNAL_FAIL");
        default_metadata.version
    }

    /// Returns non serialized code by given code hash.
    pub fn get_code(&self, code_hash: Base58CryptoHash) {
        self.factory_manager.get_code(code_hash);
    }

    pub fn store_contract_metadata(
        &self,
        code_hash: Base58CryptoHash,
        metadata: DaoContractMetadata,
        set_default: bool,
    ) {
        self.assert_owner();
        let hash: CryptoHash = code_hash.into();
        assert!(
            env::storage_has_key(&hash),
            "Code not found for the given code hash. Please store the code first."
        );

        let storage_metadata = env::storage_read(CODE_METADATA_KEY);
        if storage_metadata.is_none() {
            let mut storage_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
                UnorderedMap::new(b"m".to_vec());
            storage_metadata.insert(&code_hash, &metadata);
            let serialized_metadata =
                BorshSerialize::try_to_vec(&storage_metadata).expect("INTERNAL_FAIL");
            env::storage_write(CODE_METADATA_KEY, &serialized_metadata);
        } else {
            let storage_metadata = storage_metadata.expect("INTERNAL_FAIL");
            let mut deserialized_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
                BorshDeserialize::try_from_slice(&storage_metadata).expect("INTERNAL_FAIL");
            deserialized_metadata.insert(&code_hash, &metadata);
            let serialized_metadata =
                BorshSerialize::try_to_vec(&deserialized_metadata).expect("INTERNAL_FAIL");
            env::storage_write(CODE_METADATA_KEY, &serialized_metadata);
        }

        if set_default {
            env::storage_write(DEFAULT_CODE_HASH_KEY, &hash);
        }
    }

    pub fn delete_contract_metadata(&self, code_hash: Base58CryptoHash) {
        self.assert_owner();
        let storage_metadata = env::storage_read(CODE_METADATA_KEY).expect("INTERNAL_FAIL");
        let mut deserialized_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
            BorshDeserialize::try_from_slice(&storage_metadata).expect("INTERNAL_FAIL");
        deserialized_metadata.remove(&code_hash);
        let serialized_metadata =
            BorshSerialize::try_to_vec(&deserialized_metadata).expect("INTERNAL_FAIL");
        env::storage_write(CODE_METADATA_KEY, &serialized_metadata);
    }

    pub fn get_contracts_metadata(&self) -> Vec<(Base58CryptoHash, DaoContractMetadata)> {
        let storage_metadata = env::storage_read(CODE_METADATA_KEY).expect("INTERNAL_FAIL");
        let deserialized_metadata: UnorderedMap<Base58CryptoHash, DaoContractMetadata> =
            BorshDeserialize::try_from_slice(&storage_metadata).expect("INTERNAL_FAIL");
        deserialized_metadata.to_vec()
    }

    fn assert_owner(&self) {
        assert_eq!(
            self.get_owner(),
            env::predecessor_account_id(),
            "Must be owner"
        );
    }
}

pub fn slice_to_hash(hash: &[u8]) -> Base58CryptoHash {
    let mut result: CryptoHash = [0; 32];
    result.copy_from_slice(hash);
    Base58CryptoHash::from(result)
}

/// Store new contract. Non serialized argument is the contract.
/// Returns base58 of the hash of the contract.
#[no_mangle]
pub extern "C" fn store() {
    env::setup_panic_hook();
    let contract: AstraFactory = env::state_read().expect("Contract is not initialized");
    contract.assert_owner();
    let prev_storage = env::storage_usage();
    contract.factory_manager.store_contract();
    let storage_cost = (env::storage_usage() - prev_storage) as u128 * env::storage_byte_cost();
    assert!(
        storage_cost <= env::attached_deposit(),
        "Must at least deposit {} to store",
        storage_cost
    );
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::test_env::{alice, bob, carol};
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, PromiseResult};

    use near_units::parse_near;

    use super::*;

    #[test]
    #[should_panic(expected = "ERR_NOT_ENOUGH_DEPOSIT")]
    fn test_create_error() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .build());
        let mut factory = AstraFactory::new();

        testing_env!(context.attached_deposit(parse_near!("5 N")).build());
        factory.create("test".parse().unwrap(), "{}".as_bytes().to_vec().into());
    }

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .build());
        let mut factory = AstraFactory::new();

        testing_env!(context.attached_deposit(parse_near!("6 N")).build());
        factory.create("test".parse().unwrap(), "{}".as_bytes().to_vec().into());

        testing_env!(
            context.predecessor_account_id(accounts(0)).build(),
            near_sdk::VMConfig::test(),
            near_sdk::RuntimeFeesConfig::test(),
            Default::default(),
            vec![PromiseResult::Successful(vec![])],
        );
        factory.on_create(
            format!("test.{}", accounts(0)).parse().unwrap(),
            U128(parse_near!("6 N")),
            accounts(0),
        );
        assert_eq!(
            factory.get_dao_list(),
            vec![format!("test.{}", accounts(0)).parse().unwrap()]
        );
        assert_eq!(
            factory.get_daos(0, 100),
            vec![format!("test.{}", accounts(0)).parse().unwrap()]
        );
    }

    //              #################################              //
    //              #    Factory ownership tests    #              //
    //              #################################              //

    #[test]
    fn test_factory_can_get_current_owner() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(alice())
            .predecessor_account_id(alice())
            .attached_deposit(parse_near!("5 N"))
            .build());
        let factory = AstraFactory::new();

        assert_eq!(factory.get_owner(), alice());
    }

    #[test]
    #[should_panic]
    fn test_factory_fails_setting_owner_from_not_owner_account() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(alice())
            .predecessor_account_id(carol())
            .attached_deposit(parse_near!("5 N"))
            .build());
        let factory = AstraFactory::new();

        factory.set_owner(bob());
    }

    #[test]
    fn test_owner_can_be_a_dao_account() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(bob())
            .predecessor_account_id(bob())
            .attached_deposit(parse_near!("6 N"))
            .build());
        let mut factory = AstraFactory::new();

        factory.create(bob(), "{}".as_bytes().to_vec().into());

        factory.set_owner(AccountId::new_unchecked("bob.astra-dao.near".to_string()));

        assert_eq!(
            factory.get_owner(),
            AccountId::new_unchecked("bob.astra-dao.near".to_string())
        )
    }

    #[test]
    fn test_owner_gets_succesfully_updated() {
        let mut context = VMContextBuilder::new();
        testing_env!(context
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .attached_deposit(parse_near!("5 N"))
            .build());
        let factory = AstraFactory::new();

        assert_ne!(factory.get_owner(), bob());

        factory.set_owner(bob());

        assert_eq!(factory.get_owner(), bob())
    }
}

'''
'''--- astra-staking/Cargo.toml ---
[package]
name = "astra-staking"
version = "0.1.0"
publish = false
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk.workspace = true
near-contract-standards.workspace = true
hex.workspace = true

[dev-dependencies]
workspaces.workspace = true
test-token = { path = "../test-token" }
near-units.workspace = true

'''
'''--- astra-staking/README.md ---
# Astra Staking

This is staking contract for Astra DAO.

The default version just allows to stake the tokens by users and convert them into "weight" in the Astra itself.
Further modifications can be done to allow to leverage the staked token for other functions (providing liquidity for example).

### Token voting

> DAO votes to select some token to become voting token (only can be done once, can't change later).

User flow to vote with selected token:

- Users deposit the desired amount of the token to the separate staking contract defined by the DAO.
- They can then choose who to delegate these tokens. It can be to themselves or to other users to increase their vote weight.
- When users vote for proposals, their vote is weighted by all the delegations to them.
- Undelegating will block delegating / withdrawing until one voting period passes.
- Undelegated tokens can be withdrawn by the user.

## Scripted Flow

NOTE: This is not 100% working, help finalize :)

```bash
export STAKING_ACCOUNT_ID=YOUR_STAKING_CONTRACT.testnet
export DAO_ACCOUNT_ID=YOUR_DAO.astra.testnet
export TOKEN_ACCOUNT_ID=YOUR_TOKEN_ID.testnet
export USER_ACCOUNT_ID=YOU.testnet
export MAX_GAS=300000000000000

# Deploy staking contract
near deploy $STAKING_ACCOUNT_ID --wasmFile=astra-staking/res/astra_staking.wasm --accountId $STAKING_ACCOUNT_ID --initFunction new --initArgs '{"owner_id": "'$DAO_ACCOUNT_ID'","token_id": "'$TOKEN_ACCOUNT_ID'","unstake_period": "604800000"}'

# Change DAO to use a staking contract
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "", "kind": { "SetStakingContract": { "staking_id": "'$STAKING_ACCOUNT_ID'" } } } }' --accountId $USER_ACCOUNT_ID --amount 1
near call $DAO_ACCOUNT_ID act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $USER_ACCOUNT_ID  --gas $MAX_GAS
near view $DAO_ACCOUNT_ID get_staking_contract

# Storage Costs
near call $STAKING_ACCOUNT_ID storage_deposit '{"registration_only": true}' --accountId $STAKER_ACCOUNT_ID --amount 0.01

# NOTE: This assumes you have some FT, and are ready to deposit into the newly deployed staking contract, if you need to create your own FT: https://github.com/near-examples/FT
# Send tokens to the staking contract
near call $TOKEN_ACCOUNT_ID ft_transfer_call '{"sender_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Delegation
near call $STAKING_ACCOUNT_ID delegate '{"account_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Check user info
near view $STAKING_ACCOUNT_ID get_user '{"account_id": "'$USER_ACCOUNT_ID'"}'

# Undelegation
near call $STAKING_ACCOUNT_ID undelegate '{"account_id": "'$USER_ACCOUNT_ID'", "amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS

# Withdraw tokens from staking contract
near call $STAKING_ACCOUNT_ID withdraw '{"amount": "123456789"}' --accountId $USER_ACCOUNT_ID --gas $MAX_GAS
```

## ABIs

### Staking Contract :: V1
```
{
  "viewMethods": [
    "ft_total_supply",
    "ft_balance_of",
    "get_user",
    "storage_balance_of"
  ],
  "changeMethods": [
    "new",
    "delegate",
    "undelegate",
    "withdraw",
    "storage_deposit",
    "storage_withdraw",
    "storage_unregister"
  ],
}
```

'''
'''--- astra-staking/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cd ..
mkdir -p res
cp target/wasm32-unknown-unknown/release/astra_staking.wasm res/

'''
'''--- astra-staking/src/lib.rs ---
use near_contract_standards::fungible_token::core::ext_ft_core;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, Duration, Gas,
    PanicOnDefault, Promise, PromiseOrValue, PromiseResult,
};

pub use user::{User, VersionedUser};

mod storage_impl;
mod user;

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKeys {
    Users,
}

/// Amount of gas for fungible token transfers.
pub const GAS_FOR_FT_TRANSFER: Gas = Gas(10_000_000_000_000);

/// Amount of gas for delegate action.
pub const GAS_FOR_DELEGATE: Gas = Gas(10_000_000_000_000);

/// Amount of gas for register action.
pub const GAS_FOR_REGISTER: Gas = Gas(10_000_000_000_000);

/// Amount of gas for undelegate action.
pub const GAS_FOR_UNDELEGATE: Gas = Gas(10_000_000_000_000);

#[ext_contract(ext_astra)]
pub trait ExtAstra {
    fn register_delegation(&mut self, account_id: AccountId);
    fn delegate(&mut self, account_id: AccountId, amount: U128);
    fn undelegate(&mut self, account_id: AccountId, amount: U128);
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    /// DAO owner of this staking contract.
    owner_id: AccountId,
    /// Vote token account.
    vote_token_id: AccountId,
    /// Recording user deposits.
    users: LookupMap<AccountId, VersionedUser>,
    /// Total token amount deposited.
    total_amount: Balance,
    /// Duration of unstaking. Should be over the possible voting periods.
    unstake_period: Duration,
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn exchange_callback_post_withdraw(&mut self, sender_id: AccountId, amount: U128);
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId, token_id: AccountId, unstake_period: U64) -> Self {
        Self {
            owner_id,
            vote_token_id: token_id,
            users: LookupMap::new(StorageKeys::Users),
            total_amount: 0,
            unstake_period: unstake_period.0,
        }
    }

    /// Total number of tokens staked in this contract.
    pub fn ft_total_supply(&self) -> U128 {
        U128(self.total_amount)
    }

    /// Total number of tokens staked by given user.
    pub fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.internal_get_user(&account_id).vote_amount.0)
    }

    /// Returns user information.
    pub fn get_user(&self, account_id: AccountId) -> User {
        self.internal_get_user(&account_id)
    }

    /// Delegate give amount of votes to given account.
    /// If enough tokens and storage, forwards this to owner account.
    pub fn delegate(&mut self, account_id: AccountId, amount: U128) -> Promise {
        let sender_id = env::predecessor_account_id();
        self.internal_delegate(sender_id, account_id.clone(), amount.0);
        ext_astra::ext(self.owner_id.clone())
        .with_static_gas(GAS_FOR_DELEGATE)
        .delegate(
            account_id,
            amount
        )
    }

    /// Remove given amount of delegation.
    pub fn undelegate(&mut self, account_id: AccountId, amount: U128) -> Promise {
        let sender_id = env::predecessor_account_id();
        self.internal_undelegate(sender_id, account_id.clone(), amount.0);
        ext_astra::ext(self.owner_id.clone())
        .with_static_gas(GAS_FOR_UNDELEGATE)
        .undelegate(
            account_id,
            amount
        )
    }

    /// Withdraw non delegated tokens back to the user's account.
    /// If user's account is not registered, will keep funds here.
    pub fn withdraw(&mut self, amount: U128) -> Promise {
        let sender_id = env::predecessor_account_id();
        self.internal_withdraw(&sender_id, amount.0);
        ext_ft_core::ext(self.vote_token_id.clone())
            .with_static_gas(GAS_FOR_FT_TRANSFER)
            .with_attached_deposit(1)
            .ft_transfer(
                sender_id.clone(),
                amount,
                None
        )
        .then(ext_self::ext(env::current_account_id())
            .with_static_gas(GAS_FOR_FT_TRANSFER)
            .exchange_callback_post_withdraw(
                sender_id,
                amount
            )
        )
    }

    #[private]
    pub fn exchange_callback_post_withdraw(&mut self, sender_id: AccountId, amount: U128) {
        assert_eq!(
            env::promise_results_count(),
            1,
            "ERR_CALLBACK_POST_WITHDRAW_INVALID",
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => {}
            PromiseResult::Failed => {
                // This reverts the changes from withdraw function.
                self.internal_deposit(&sender_id, amount.0);
            }
        };
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            self.vote_token_id,
            env::predecessor_account_id(),
            "ERR_INVALID_TOKEN"
        );
        assert!(msg.is_empty(), "ERR_INVALID_MESSAGE");
        self.internal_deposit(&sender_id, amount.0);
        PromiseOrValue::Value(U128(0))
    }
}

#[cfg(test)]
mod tests {
    use near_contract_standards::storage_management::StorageManagement;
    use near_sdk::json_types::U64;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use near_units::parse_near;

    use super::*;

    #[test]
    fn test_basics() {
        const UNSTAKE_PERIOD: u64 = 1000;
        let contract_owner: AccountId = accounts(0);
        let voting_token: AccountId = accounts(1);
        let delegate_from_user: AccountId = accounts(2);
        let delegate_to_user: AccountId = accounts(3);

        let mut context = VMContextBuilder::new();

        testing_env!(context
            .predecessor_account_id(contract_owner.clone())
            .build());
        let mut contract = Contract::new(contract_owner, voting_token.clone(), U64(UNSTAKE_PERIOD));

        testing_env!(context.attached_deposit(parse_near!("1 N")).build());
        contract.storage_deposit(Some(delegate_from_user.clone()), None);

        testing_env!(context.predecessor_account_id(voting_token).build());
        contract.ft_on_transfer(
            delegate_from_user.clone(),
            U128(parse_near!("100")),
            "".to_string(),
        );
        assert_eq!(contract.ft_total_supply().0, parse_near!("100 N"));
        assert_eq!(
            contract.ft_balance_of(delegate_from_user.clone()).0,
            parse_near!("100")
        );

        testing_env!(context
            .predecessor_account_id(delegate_from_user.clone())
            .build());
        contract.withdraw(U128(parse_near!("50 N")));
        assert_eq!(contract.ft_total_supply().0, parse_near!("50 N"));
        assert_eq!(
            contract.ft_balance_of(delegate_from_user.clone()).0,
            parse_near!("50")
        );

        testing_env!(context.attached_deposit(parse_near!("1 N")).build());
        contract.storage_deposit(Some(delegate_to_user.clone()), None);

        contract.delegate(delegate_to_user.clone(), U128(parse_near!("10 N")));
        let user = contract.get_user(delegate_from_user.clone());
        assert_eq!(user.delegated_amount(), parse_near!("10 N"));

        contract.undelegate(delegate_to_user, U128(parse_near!("10 N")));
        let user = contract.get_user(delegate_from_user);
        assert_eq!(user.delegated_amount(), 0);
        assert_eq!(user.next_action_timestamp, U64(UNSTAKE_PERIOD));
    }
}

'''
'''--- astra-staking/src/storage_impl.rs ---
use std::convert::TryInto;

use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::{assert_one_yocto, log};

use crate::*;

/// Implements users storage management for the pool.
#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let deposit_amount = env::attached_deposit();
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);

        if self.users.contains_key(&account_id) {
            log!("ERR_ACC_REGISTERED");
            if deposit_amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(deposit_amount);
            }
        } else {
            let min_balance = User::min_storage() as Balance * env::storage_byte_cost();
            if deposit_amount < min_balance {
                env::panic_str("ERR_DEPOSIT_LESS_THAN_MIN_STORAGE");
            }

            let registration_only = registration_only.unwrap_or(false);
            if registration_only {
                self.internal_register_user(&account_id, min_balance);
                let refund = deposit_amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
            } else {
                self.internal_register_user(&account_id, deposit_amount);
            }
        }
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let user = self.internal_get_user(&account_id);
        let available = user.storage_available();
        let amount = amount.map(|a| a.0).unwrap_or(available);
        assert!(amount <= available, "ERR_STORAGE_WITHDRAW_TOO_MUCH");
        Promise::new(account_id.clone()).transfer(amount);
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(user) = self.internal_get_user_opt(&account_id) {
            // TODO: figure out force option logic.
            assert!(user.vote_amount.0 > 0, "ERR_STORAGE_UNREGISTER_NOT_EMPTY");
            self.users.remove(&account_id);
            Promise::new(account_id.clone()).transfer(user.near_amount.0);
            true
        } else {
            false
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(User::min_storage() as Balance * env::storage_byte_cost()),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        self.internal_get_user_opt(&account_id)
            .map(|user| StorageBalance {
                total: user.near_amount,
                available: U128(user.storage_available()),
            })
    }
}

'''
'''--- astra-staking/src/user.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance, Duration, StorageUsage};

use crate::*;

const U64_LEN: StorageUsage = 8;
const U128_LEN: StorageUsage = 16;
const ACCOUNT_MAX_LENGTH: StorageUsage = 64;

/// User data.
/// Recording deposited voting tokens, storage used and delegations for voting.
/// Once delegated - the tokens are used in the votes. It records for each delegate when was the last vote.
/// When undelegating - the new delegations or withdrawal are only available after cooldown period from last vote of the delegate.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct User {
    /// Total amount of storage used by this user struct.
    pub storage_used: StorageUsage,
    /// Amount of $NEAR to cover storage.
    pub near_amount: U128,
    /// Amount of staked token deposited.
    pub vote_amount: U128,
    /// Withdrawal or next delegation available timestamp.
    pub next_action_timestamp: U64,
    /// List of delegations to other accounts.
    pub delegated_amounts: Vec<(AccountId, U128)>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VersionedUser {
    Default(User),
}

impl User {
    pub fn new(near_amount: Balance) -> Self {
        Self {
            storage_used: Self::min_storage(),
            near_amount: U128(near_amount),
            vote_amount: U128(0),
            delegated_amounts: vec![],
            next_action_timestamp: 0.into(),
        }
    }

    /// Minimum storage with empty delegations in bytes.
    /// This includes u128 stored in DAO for delegations to this user.
    /// They are deposited on internal_register and removed on internal_unregister.
    pub fn min_storage() -> StorageUsage {
        ACCOUNT_MAX_LENGTH + 2 * U64_LEN + 4 * U128_LEN
    }

    fn assert_storage(&self) {
        assert!(
            (self.storage_used as Balance) * env::storage_byte_cost() <= self.near_amount.0,
            "ERR_NOT_ENOUGH_STORAGE"
        );
    }

    pub(crate) fn delegated_amount(&self) -> Balance {
        self.delegated_amounts
            .iter()
            .fold(0, |total, (_, amount)| total + amount.0)
    }

    /// Record delegation from this account to another account.
    /// Fails if not enough available balance to delegate.
    pub fn delegate(&mut self, delegate_id: AccountId, amount: Balance) {
        assert!(
            self.delegated_amount() + amount <= self.vote_amount.0,
            "ERR_NOT_ENOUGH_AMOUNT"
        );
        assert!(
            env::block_timestamp() >= self.next_action_timestamp.0,
            "ERR_NOT_ENOUGH_TIME_PASSED"
        );
        self.storage_used += delegate_id.as_bytes().len() as StorageUsage + U128_LEN;
        self.delegated_amounts.push((delegate_id, U128(amount)));
        self.assert_storage();
    }

    /// Remove given amount from delegates. Updates timestamp when next action can be called.
    /// Fails if delegate not found or not enough amount delegated.
    pub fn undelegate(
        &mut self,
        delegate_id: &AccountId,
        amount: Balance,
        undelegation_period: Duration,
    ) {
        let f = self
            .delegated_amounts
            .iter()
            .enumerate()
            .find(|(_, (account_id, _))| account_id == delegate_id)
            .expect("ERR_NO_DELEGATE");
        let element = (f.0, ((f.1).1).0);
        assert!(element.1 >= amount, "ERR_NOT_ENOUGH_AMOUNT");
        if element.1 == amount {
            self.delegated_amounts.remove(element.0);
            self.storage_used -= delegate_id.as_bytes().len() as StorageUsage + U128_LEN;
        } else {
            (self.delegated_amounts[element.0].1).0 -= amount;
        }
        self.next_action_timestamp = (env::block_timestamp() + undelegation_period).into();
    }

    /// Withdraw the amount.
    /// Fails if there is not enough available balance.
    pub fn withdraw(&mut self, amount: Balance) {
        assert!(
            self.delegated_amount() + amount <= self.vote_amount.0,
            "ERR_NOT_ENOUGH_AVAILABLE_AMOUNT"
        );
        assert!(
            env::block_timestamp() >= self.next_action_timestamp.0,
            "ERR_NOT_ENOUGH_TIME_PASSED"
        );
        self.vote_amount.0 -= amount;
    }

    /// Deposit given amount of vote tokens.
    pub fn deposit(&mut self, amount: Balance) {
        self.vote_amount.0 += amount;
    }

    /// Returns amount in NEAR that is available for storage.
    pub fn storage_available(&self) -> Balance {
        self.near_amount.0 - self.storage_used as Balance * env::storage_byte_cost()
    }
}

impl Contract {
    pub fn internal_get_user(&self, account_id: &AccountId) -> User {
        self.internal_get_user_opt(account_id).expect("NO_USER")
    }

    pub fn internal_get_user_opt(&self, account_id: &AccountId) -> Option<User> {
        self.users
            .get(account_id)
            .map(|versioned_user| match versioned_user {
                VersionedUser::Default(user) => user,
            })
    }

    pub fn save_user(&mut self, account_id: &AccountId, user: User) {
        self.users.insert(account_id, &VersionedUser::Default(user));
    }

    /// Internal register new user.
    pub fn internal_register_user(&mut self, sender_id: &AccountId, near_amount: Balance) {
        let user = User::new(near_amount);
        self.save_user(sender_id, user);
        ext_astra::ext(self.owner_id.clone())
        .with_static_gas(GAS_FOR_REGISTER)
        .with_attached_deposit((U128_LEN as Balance) * env::storage_byte_cost())
        .register_delegation(
            sender_id.clone()
        );
    }

    /// Deposit voting token.
    pub fn internal_deposit(&mut self, sender_id: &AccountId, amount: Balance) {
        let mut sender = self.internal_get_user(sender_id);
        sender.deposit(amount);
        self.save_user(sender_id, sender);
        self.total_amount += amount;
    }

    /// Withdraw voting token.
    pub fn internal_withdraw(&mut self, sender_id: &AccountId, amount: Balance) {
        let mut sender = self.internal_get_user(sender_id);
        sender.withdraw(amount);
        self.save_user(sender_id, sender);
        assert!(self.total_amount >= amount, "ERR_INTERNAL");
        self.total_amount -= amount;
    }

    /// Given user delegates given amount of votes to another user.
    /// The other user must be registered.
    pub fn internal_delegate(
        &mut self,
        sender_id: AccountId,
        delegate_id: AccountId,
        amount: Balance,
    ) {
        let mut sender = self.internal_get_user(&sender_id);
        assert!(self.users.contains_key(&delegate_id), "ERR_NOT_REGISTERED");
        sender.delegate(delegate_id, amount);
        self.save_user(&sender_id, sender);
    }

    /// Undelegate votes from given delegate.
    pub fn internal_undelegate(
        &mut self,
        sender_id: AccountId,
        delegate_id: AccountId,
        amount: Balance,
    ) {
        let mut sender = self.internal_get_user(&sender_id);
        sender.undelegate(&delegate_id, amount, self.unstake_period);
        self.save_user(&sender_id, sender);
    }
}

'''
'''--- astra/ABI.md ---
# Astra DAO Contract ABIs

V1 is archived in a different repo. :)

## Astra DAO :: v2
```
{
  "viewMethods": [
    "version",
    "get_config",
    "get_policy",
    "get_staking_contract",
    "has_blob",
    "get_available_amount",
    "delegation_total_supply",
    "delegation_balance_of",
    "get_last_proposal_id",
    "get_proposals",
    "get_proposal",
    "get_bounty",
    "get_last_bounty_id",
    "get_bounties",
    "get_bounty_claims",
    "get_bounty_number_of_claims"
  ],
  "changeMethods": [
    "new",
    "migrate",
    "store_blob",
    "remove_blob",
    "add_proposal",
    "act_proposal",
    "bounty_claim",
    "bounty_done",
    "bounty_giveup",
    "register_delegation",
    "delegate",
    "undelegate"
  ],
}
```

## Astra DAO :: v3
```
{
  "viewMethods": [
    "version",
    "get_config",
    "get_policy",
    "get_staking_contract",
    "has_blob",
    "get_locked_storage_amount",
    "get_available_amount",
    "delegation_total_supply",
    "delegation_balance_of",
    "delegation_balance_ratio",
    "get_last_proposal_id",
    "get_proposals",
    "get_proposal",
    "get_bounty",
    "get_last_bounty_id",
    "get_bounties",
    "get_bounty_claims",
    "get_bounty_number_of_claims",
    "get_factory_info"
  ],
  "changeMethods": [
    "new",
    "migrate",
    "store_blob",
    "remove_blob",
    "add_proposal",
    "act_proposal",
    "bounty_claim",
    "bounty_done",
    "bounty_giveup",
    "register_delegation",
    "delegate",
    "undelegate"
  ],
}
```
'''
'''--- astra/Cargo.toml ---
[package]
name = "astra"
version = "0.1.0"
publish = false
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk.workspace = true
near-contract-standards.workspace = true
hex.workspace = true
serde_json.workspace = true

common = { path = "../common" }

[dependencies.serde_with]
version = "1.4.0"

[dev-dependencies]
workspaces.workspace = true
near-units.workspace = true
tokio.workspace = true
anyhow.workspace = true
test-token = { path = "../test-token" }
astra-staking = { path = "../astra-staking" }
astra-factory = { path = "../astra-factory" }

'''
'''--- astra/TestPlan.md ---
# Astra Test Planning

The following is coverage checklists & notes about context tests needed to check the security of the Astra DAO contracts. These tests are aimed at 100% of the latest version, and best coverage of older versions.

# Astra Factory

## Init & Default
### new
- [ ] Can instantiate a new factory with default struct, including DAOs set.
- [ ] Stores the latest compiled version of Astra DAO contract in storage
- [ ] Creates metadata for the latest compiled version of Astra DAO
- [ ] Does not allow re-init
- [ ] Does not allow anyone but owner to call "new"

## DAOs
### Creation
- [ ] Allows any account to call create method
- [ ] Created DAO becomes a sub-account of the factory. Example for new DAO: "awesome.astra.near"
- [ ] Creates a new DAO & instantiates with the correct default Astra DAO contract from storage - see metadata
- [ ] Returns the payment amount, if the creation failed for any reason
- [ ] DAO Balance is equal to payment amount
- [ ] DAO exists in the list of DAOs upon successful creation
- [ ] Fails if the DAO name exists
- [ ] Fails if the DAO name is not a valid account ID
### Upgrades
- [ ] DAO Can update to a specific code_hash version of Astra DAO Code
- [ ] Fails if DAO is not within the list of supported DAOs
- [ ] Fails if DAO tries a code_hash that doesnt exist
- [ ] Fails if predecessor is not the DAO getting upgraded (DAO proposal must trigger upgrade)

## Ownership
### Changing Owner
- [ ] Can get current owner
- [ ] Fails if trying to set owner from non-owner account
- [ ] Owner can be a DAO account
- [ ] Owner gets successfully updated
### Adding Code Version
- [ ] Can store code as blob in factory
- [ ] Can set a default code_hash
- [ ] Fails if not owner of factory
- [ ] Fails if no code is attached when storing a code blob
- [ ] Fails if code blob is too small to be a legit contract
- [ ] Fails if attached payment doesnt support the storage cost
### Adding Code Metadata
- [ ] Can add metadata for an existing set of Astra DAO Code (code_hash is available only upon storage of contract inside factory)
- [ ] Can set the code_hash as default
- [ ] Metadata version and other params meet types & spec standards
- [ ] Fails to add code metadata if code_hash doesn't exist
- [ ] Can remove code metadata if called by owner
- [ ] Fails to remove code metadata if metadata by code_hash doesn't exist
### Removing Code Version
- [ ] Can delete a code blob by code_hash
- [ ] Can delete any/all associated code metadata for the same code_hash
- [ ] Confirm storage is empty after deletion success
- [ ] Fails if non-owner attempting to delete code blob
- [ ] Fails if no code blob exists

## views
### get_dao_list
- [ ] Returns empty array for new factory
- [ ] Returns full list of DAOs
- [ ] NOTE: This method will fail when list gets too long for gas to return on RPC
### get_number_daos
- [ ] Returns an integer representing the total amount of DAOs known to factory
### get_daos
- [ ] (Needs Impl) Returns default list of DAOs with a max length of 100 & offset of 0.
- [ ] Returns a list of DAOs matching the specified `from_index` and `limit`.
- [ ] Capable of returning non-zero indexed list, so pagination can be verified
### get_owner
- [ ] Returns a string representing the account that owns the factory
- [ ] Fails if storage is corrupted or no owner
### get_default_code_hash
- [ ] Returns the default code_hash for a new DAO
- [ ] Returns the default code_hash that has been updated after new code blob in factory
### get_default_version
- [ ] Returns the default metadata version for a new DAO, this will be a simplified semver. Example: [2,0] for V 2.0
### get_code
- [ ] Returns an entire code blob based on given code_hash
- [ ] Returns no value if code_hash doesn't exist
### get_contracts_metadata
- [ ] Returns the supported list of all factory code_hash + metadata, indicating the supported versions available for DAOs to upgrade

# Astra DAO

## Dao Policy Configurations
These tests are purely for checking support of certain policy configurations, no simulations.

You can check a DAO's policy by doing: 

```bash
near view DAO_NAME.astra-dao.near get_policy
```

### Default
**Goal:**
Confirm the default policy acts as it should.

**TESTS:**
- [ ] TODO: 

**Default Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {}
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Threshold
**Goal:**
Each 

**TESTS:**
- [ ] TODO: 

**Threshold Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Role Weighted
**Goal:**
Each 

**TESTS:**
- [ ] TODO: 

**Threshold Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Token Weighted
**Goal:**
Each 

**TESTS:**
- [ ] TODO: 

**Threshold Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Groups Weighted
**Goal:**
Each 

**TESTS:**
- [ ] TODO: 

**Threshold Config:**

```json
{
  "roles": [
    {
      "name": "all",
      "kind": "Everyone",
      "permissions": [
        "*:AddProposal"
      ],
      "vote_policy": {}
    },
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

### Groups Varying Policy
**Goal:**
Each group council can have different threshold criteria for consensus. Confirm that a group can be assessed based on their individual definitions versus the default policy config.

**TESTS:**
- [ ] TODO: 

**Varying Policy Config:**

```json
{
  "roles": [
    {
      "name": "council",
      "kind": {
        "Group": [
          "user_1.testnet",
          "user_2.testnet",
          "user_3.testnet",
          "user_4.testnet",
          "user_5.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "0",
          "threshold": [ 1, 5 ]
        }
      }
    },
    {
      "name": "admins",
      "kind": {
        "Group": [
          "admin_1.testnet",
          "admin_2.testnet",
          "admin_3.testnet"
        ]
      },
      "permissions": [
        "*:Finalize",
        "*:AddProposal",
        "*:VoteApprove",
        "*:VoteReject",
        "*:VoteRemove"
      ],
      "vote_policy": {
        "Group":{
          "weight_kind": "RoleWeight",
          "quorum": "60",
          "threshold": []
        }
      }
    }
  ],
  "default_vote_policy": {
    "weight_kind": "RoleWeight",
    "quorum": "0",
    "threshold": [ 1, 2 ]
  },
  "proposal_bond": "1000000000000000000000000",
  "proposal_period": "604800000000000",
  "bounty_bond": "1000000000000000000000000",
  "bounty_forgiveness_period": "86400000000000"
}
```

## Staking Token
### None
- [ ] Confirming other policies means non token-staking works fine
### New Staking Contract
- [ ] Can deploy a new staking contract, configured to the right DAO owner, token & stake period
- [ ] DAO Can propose and accept the staking contract proposal
- [ ] Users can pre-pay storage & register to delegate tokens
- [ ] Users can deposit tokens using FT transfers
- [ ] Users can delegate to themselves within the staking contract
- [ ] Users can delegate to a different user within the staking contract
- [ ] Can check the amounts held within the staking contract
- [ ] Users can undelegate tokens from a delegation
- [ ] Users can withdraw any available tokens that aren't delegated in the staking contract

## bounties

### Happy path
Creates an end-to-end check of happy path completion
- [x] Setup test token
- [x] propose a bounty
- [x] Vote on the bounty
- [x] Claim the bounty
- [x] Check bounty has claims
- [x] Make bounty done
- [x] Check bounty has claims
- [x] Finalize bounty proposal
- [x] Check bounty proposal approved

### bounty_claim
Claims given bounty by caller with given expected duration to execute.
- [x] The method could panic if the bounty with given id doesn't exist
- [x] Should panic if `attached_deposit` is not equal to the corresponding `bounty_bond`
- [x] Should panic in case of wrong deadline
- [x] Should panic if all bounties are claimed
- [x] Should increase number of claims
- [x] Should add this claim to the list of claims, done by this account
### bounty_done
Reports that bounty is done. Creates a proposal to vote for paying out the bounty.
- [x] Should panic if the caller is not in the list of claimers
- [x] Should panic if the list of claims for the caller of the method doesn't contain the claim with given ID
- [x] Should panic if the bounty claim is completed
- [x] If claim is not expired, the `bounty_done` can only be called by the claimer
- [x] If not expired, proposal should be added, claim is marked as completed
### bounty_giveup
Gives up working on the bounty.
- [x] Should panic if the caller is not in the list of claimers
- [x] Should panic if the list of claims for the caller of the method doesn't contain the claim with given ID
- [x] If within forgiveness period, `bounty_bond` should be returned
- [x] If within forgiveness period, claim should be removed from the list of claims, done by this account

## delegation

### register_delegation
Inserts a caller to the `delegations` LookupMap with zero balance.
- [x] Check that delegation appears in `delegations` LookupMap.
- [x] Can only be called by the `staking_id`
- [x] Attached deposit is handled correctly
### delegate
Adds given amount to given account as delegated weight.
- [x] Should panic if `staking_id` is `None`
- [x] Check that amount is added correctly
- [x] Check that a user can't delegate more than it has
- [x] Check that it can only be called by the `staking_id`
- [x] Can't be called without previos registration
### undelegate
Removes given amount from given account's delegations.
- [x] Should panic if `staking_id` is `None`
- [x] Check that it can only be called by the `staking_id`
- [x] Check that amount is subtracted correctly
- [x] Check that a user can't remove more than it delegated
- [x] Can't be called without previous registration

## lib

_NOTE: This covers v2 functionality for upgrades only_

### store_blob
Stores attached data into blob store and returns the hash of it.
- [x] Should panic if contract is not initialized
- [x] Should panic if the blob already exists
- [x] Should panic if the amount of the attached deposit is not enough
- [x] Should save the blob to the LookupMap
### remove_blob
Removes blob from contract storage and pays back to the original storer.
- [x] Should panic if `hash` is wrong
- [x] Should return hash of stored data
- [x] Can only be called by the original storer
- [x] Blob should be removed
- [x] The payback should be computed correctly

## Policy

_TODO: Policy is missing a lot of coverage:_

### TokenWeight
Happy path for token-weighted policy
- [x] Can create new DAO
- [x] Can set staking contract
- [x] Can change policy to TokenWeight
- [x] Can register & delegate tokens
- [x] Can use TokenWeight policy to vote & approve a proposal
### TokenWeight Self-Lock
- [x] Can create new DAO, with TokenWeight set without staking contract id
- [x] Attempt a proposal, fail to move status because voting is locked

## proposals

### add_proposal
Adds proposal to this DAO.
- [x] Check that the method fails in case of insufficient deposit 
- [x] Check that different kinds of `proposal` are validated correctly
- [x] Check that only those with a permission can add the proposal
- [x] Check that the proposal is added to the list of proposals
### act_proposal
Act on given proposal by id, if permissions allow.
- [??] Check that only those with a permission can act on the the proposal
- [x] Check that the method works correctly on any possible `action`
- [x] If the number of votes in the group has changed (new members has been added) the proposal can lose it's approved state. In this case new proposal needs to be made, this one should expire
### on_proposal_callback
Receiving callback after the proposal has been finalized.
- [??] If successful, should return bond money to the proposal originator
- [??] If the proposal execution failed (funds didn't transfer or function call failure), should move the proposal to the "Failed" state

_NOTE: Appears views are currently just helper methods and dont have test coverage_

## views
### version
- [ ] Returns the version of this contract.
### get_config
- [ ] Returns the config of this contract.
### get_policy
- [ ] Returns policy of this contract.
### get_staking_contract
- [ ] Returns the staking contract if available. Otherwise returns `None`.
### has_blob
- [ ] Returns whether the blob with given hash is stored.
### get_locked_storage_amount
- [ ] Returns the locked amount of NEAR that is used for the storage.
### get_available_amount
- [ ] Returns the available amount of NEAR that can be spent (outside of the amount for the storage and bonds).
### delegation_total_supply
- [ ] Returns the total delegated stake.
### delegation_balance_of
- [ ] Returns the delegated stake of the given account.
### delegation_balance_ratio
- [ ] Combines the balance and the total amount for calling from external contracts.
### get_last_proposal_id
- [ ] Returns the last proposal's id.
### get_proposals
- [ ] Returns a vector of the proposals.
### get_proposal
- [ ] Returns the specific proposal by id.
  - [ ] Should panic if the proposal with the given id doesn't exist
### get_bounty
- [ ] Returns the specific bounty by id.
  - [ ] Should panic if the bounty with the given id doesn't exist
### get_last_bounty_id
- [ ] Returns number of the bounties.
### get_bounties
- [ ] Returns the bounties.
### get_bounty_claims
- [ ] Returns bounty claims for given user.
### get_bounty_number_of_claims
- [ ] Returns the number of claims per given bounty.

'''
'''--- astra/bounty-test.sh ---
#!/bin/sh
set -e
# Change these to your account ids
./build.sh
export CONTRACT_ID=astra.md4ire.testnet
export CONTRACT_PARENT=md4ire.testnet

# Redo account (if contract already exists)
set +e
near delete $CONTRACT_ID $CONTRACT_PARENT 2> /dev/null # Ignore errors
set -e
near create-account $CONTRACT_ID --masterAccount $CONTRACT_PARENT

# Set up
near deploy $CONTRACT_ID --wasmFile res/astra.wasm
export COUNCIL='["'$CONTRACT_ID'"]'
near call $CONTRACT_ID new '{"config": {"name": "genesis2", "purpose": "test", "metadata": ""}, "policy": '$COUNCIL'}' --accountId $CONTRACT_ID

# Add proposal for a Transfer kind that pays out 19 NEAR
near call $CONTRACT_ID add_proposal '{"proposal": {"description": "test bounty", "kind": {"AddBounty": {"bounty": {"description": "do the thing", "amount": "19000000000000000000000000", "times": 3, "max_deadline": "1925376849430593581"}}}}}' --accountId $CONTRACT_PARENT --amount 1

# Show error when a user tries to vote along with log
near call $CONTRACT_ID act_proposal '{"id": 0, "action": "VoteApprove"}' --accountId $CONTRACT_ID

# Someone claims bounty
near call $CONTRACT_ID bounty_claim '{"id": 0, "deadline": "1925376849430593581"}' --accountId $CONTRACT_PARENT --amount 1

# Show bounty claims
near view $CONTRACT_ID get_bounty_claims '{"account_id": "'$CONTRACT_PARENT'"}'

# Call bounty_done
near call $CONTRACT_ID bounty_done '{"id": 0, "description": "was not even hard. ez"}'  --accountId $CONTRACT_PARENT --amount 1
# Add BountyDone proposal done
# bounty_done adds proposal BountyDone itself
# near call $CONTRACT_ID add_proposal '{"proposal": {"description": "test bounty done", "kind": {"BountyDone": {"bounty_id": 0, "receiver_id": "'$CONTRACT_PARENT'"}}}}' --accountId $CONTRACT_PARENT --amount 1

# Vote it in
near call $CONTRACT_ID act_proposal '{"id": 1, "action": "VoteApprove"}' --accountId $CONTRACT_ID

# See how many now.
near view $CONTRACT_ID get_bounty_claims '{"account_id": "'$CONTRACT_PARENT'"}'
'''
'''--- astra/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cd ..
mkdir -p res
cp target/wasm32-unknown-unknown/release/astra.wasm res/

'''
'''--- astra/src/bounties.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseOrValue};

use crate::types::{convert_old_to_new_token, OldAccountId};
use crate::*;

/// Information recorded about claim of the bounty by given user.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BountyClaim {
    /// Bounty id that was claimed.
    bounty_id: u64,
    /// Start time of the claim.
    start_time: U64,
    /// Deadline specified by claimer.
    deadline: U64,
    /// Completed?
    completed: bool,
}

/// Bounty information.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Bounty {
    /// Description of the bounty.
    pub description: String,
    /// Token the bounty will be paid out.
    /// Can be "" for $NEAR or a valid account id.
    pub token: OldAccountId,
    /// Amount to be paid out.
    pub amount: U128,
    /// How many times this bounty can be done.
    pub times: u32,
    /// Max deadline from claim that can be spend on this bounty.
    pub max_deadline: U64,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum VersionedBounty {
    Default(Bounty),
}

impl From<VersionedBounty> for Bounty {
    fn from(v: VersionedBounty) -> Self {
        match v {
            VersionedBounty::Default(b) => b,
        }
    }
}

impl Contract {
    /// Adds bounty to the storage and returns it's id.
    /// Must not fail.
    pub(crate) fn internal_add_bounty(&mut self, bounty: &Bounty) -> u64 {
        let id = self.last_bounty_id;
        self.bounties
            .insert(&id, &VersionedBounty::Default(bounty.clone()));
        self.last_bounty_id += 1;
        id
    }

    /// This must be called when proposal to payout bounty has been voted either successfully or not.
    pub(crate) fn internal_execute_bounty_payout(
        &mut self,
        id: u64,
        receiver_id: &AccountId,
        success: bool,
    ) -> PromiseOrValue<()> {
        let bounty: Bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY").into();
        self.internal_remove_claim(id, receiver_id);
        if success {
            self.internal_payout(
                &convert_old_to_new_token(&bounty.token),
                receiver_id,
                bounty.amount.0,
                format!("Bounty {} payout", id),
                None,
            )
        } else {
            PromiseOrValue::Value(())
        }
    }

    fn internal_find_claim(&self, bounty_id: u64, claims: &[BountyClaim]) -> Option<usize> {
        (0..claims.len()).find(|&i| claims[i].bounty_id == bounty_id)
    }
}

#[near_bindgen]
impl Contract {
    /// Claim given bounty by caller with given expected duration to execute.
    /// Bond must be attached to the claim.
    /// Fails if already claimed `times` times.
    #[payable]
    pub fn bounty_claim(&mut self, id: u64, deadline: U64) {
        let bounty: Bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY").into();
        let policy = self.policy.get().unwrap().to_policy();
        assert_eq!(
            env::attached_deposit(),
            policy.bounty_bond.0,
            "ERR_BOUNTY_WRONG_BOND"
        );
        let claims_count = self.bounty_claims_count.get(&id).unwrap_or_default();
        assert!(claims_count < bounty.times, "ERR_BOUNTY_ALL_CLAIMED");
        assert!(
            deadline.0 <= bounty.max_deadline.0,
            "ERR_BOUNTY_WRONG_DEADLINE"
        );
        self.bounty_claims_count.insert(&id, &(claims_count + 1));
        let mut claims = self
            .bounty_claimers
            .get(&env::predecessor_account_id())
            .unwrap_or_default();
        claims.push(BountyClaim {
            bounty_id: id,
            start_time: U64::from(env::block_timestamp()),
            deadline,
            completed: false,
        });
        self.bounty_claimers
            .insert(&env::predecessor_account_id(), &claims);
        self.locked_amount += env::attached_deposit();
    }

    /// Remove the claim of `claimer_id` from this bounty.
    fn internal_remove_claim(&mut self, bounty_id: u64, claimer_id: &AccountId) {
        let (mut claims, claim_idx) = self.internal_get_claims(bounty_id, claimer_id);
        claims.remove(claim_idx);
        if claims.is_empty() {
            self.bounty_claimers.remove(claimer_id);
        } else {
            self.bounty_claimers.insert(claimer_id, &claims);
        }
        let count = self.bounty_claims_count.get(&bounty_id).unwrap() - 1;
        self.bounty_claims_count.insert(&bounty_id, &count);
    }

    fn internal_get_claims(&mut self, id: u64, sender_id: &AccountId) -> (Vec<BountyClaim>, usize) {
        let claims = self
            .bounty_claimers
            .get(sender_id)
            .expect("ERR_NO_BOUNTY_CLAIMS");
        let claim_idx = self
            .internal_find_claim(id, &claims)
            .expect("ERR_NO_BOUNTY_CLAIM");
        (claims, claim_idx)
    }

    /// Report that bounty is done. Creates a proposal to vote for paying out the bounty.
    /// Only creator of the claim can call `done` on bounty that is still in progress.
    /// On expired, anyone can call it to free up the claim slot.
    #[payable]
    pub fn bounty_done(&mut self, id: u64, account_id: Option<AccountId>, description: String) {
        let sender_id = account_id.unwrap_or_else(env::predecessor_account_id);
        let (mut claims, claim_idx) = self.internal_get_claims(id, &sender_id);
        assert!(!claims[claim_idx].completed, "ERR_BOUNTY_CLAIM_COMPLETED");
        if env::block_timestamp() > claims[claim_idx].start_time.0 + claims[claim_idx].deadline.0 {
            // Expired. Nothing to do.
            self.internal_remove_claim(id, &sender_id);
        } else {
            // Still under deadline. Only the user themself can call this.
            assert_eq!(
                sender_id,
                env::predecessor_account_id(),
                "ERR_BOUNTY_DONE_MUST_BE_SELF"
            );
            self.add_proposal(ProposalInput {
                description,
                kind: ProposalKind::BountyDone {
                    bounty_id: id,
                    receiver_id: sender_id.clone(),
                },
                category: None
            });
            claims[claim_idx].completed = true;
            self.bounty_claimers.insert(&sender_id, &claims);
        }
    }

    /// Give up working on the bounty.
    pub fn bounty_giveup(&mut self, id: u64) -> PromiseOrValue<()> {
        let policy = self.policy.get().unwrap().to_policy();
        let (claims, claim_idx) = self.internal_get_claims(id, &env::predecessor_account_id());
        let result = if env::block_timestamp() - claims[claim_idx].start_time.0
            > policy.bounty_forgiveness_period.0
        {
            // If user over the forgiveness period.
            PromiseOrValue::Value(())
        } else {
            // Within forgiveness period. Return bond.
            self.locked_amount -= policy.bounty_bond.0;
            Promise::new(env::predecessor_account_id())
                .transfer(policy.bounty_bond.0)
                .into()
        };
        self.internal_remove_claim(id, &env::predecessor_account_id());
        result
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use near_units::parse_near;

    use crate::proposals::{ProposalInput, ProposalKind};
    use crate::{Action, Config};
    use crate::test_utils::ndc_trust;

    use super::*;

    fn add_bounty(context: &mut VMContextBuilder, contract: &mut Contract, times: u32) -> u64 {
        testing_env!(context.attached_deposit(parse_near!("1 N")).build());
        let id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddBounty {
                bounty: Bounty {
                    description: "test bounty".to_string(),
                    token: String::from(OLD_BASE_TOKEN),
                    amount: U128(parse_near!("10 N")),
                    times,
                    max_deadline: U64::from(1_000),
                },
            },
            category: None
        });
        assert_eq!(contract.get_last_bounty_id(), id);
        contract.act_proposal(id, Action::VoteApprove, None, Some(false));
        id
    }

    /// Adds a bounty, and tests it's full lifecycle.
    #[test]
    fn test_bounty_lifecycle() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1)]),
            ndc_trust()
        );
        add_bounty(&mut context, &mut contract, 2);

        assert_eq!(contract.get_last_bounty_id(), 1);
        assert_eq!(contract.get_bounty(0).bounty.times, 2);

        contract.bounty_claim(0, U64::from(500));
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 1);
        assert_eq!(contract.get_bounty_number_of_claims(0), 1);

        contract.bounty_giveup(0);
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 0);
        assert_eq!(contract.get_bounty_number_of_claims(0), 0);

        contract.bounty_claim(0, U64::from(500));
        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 1);
        assert_eq!(contract.get_bounty_number_of_claims(0), 1);

        contract.bounty_done(0, None, "Bounty is done".to_string());
        assert!(contract.get_bounty_claims(accounts(1))[0].completed);

        assert_eq!(contract.get_last_proposal_id(), 2);
        assert_eq!(
            contract.get_proposal(1).proposal.kind.to_policy_label(),
            "bounty_done"
        );

        contract.act_proposal(1, Action::VoteApprove, None, Some(false));
        testing_env!(
            context.build(),
            near_sdk::VMConfig::test(),
            near_sdk::RuntimeFeesConfig::test(),
            Default::default(),
            vec![PromiseResult::Successful(vec![])],
        );
        contract.on_proposal_callback(1);

        assert_eq!(contract.get_bounty_claims(accounts(1)).len(), 0);
        assert_eq!(contract.get_bounty(0).bounty.times, 1);

        contract.bounty_claim(0, U64::from(500));
        contract.bounty_done(0, None, "Bounty is done 2".to_string());
        contract.act_proposal(2, Action::VoteApprove, None, None);
        testing_env!(
            context.build(),
            near_sdk::VMConfig::test(),
            near_sdk::RuntimeFeesConfig::test(),
            Default::default(),
            vec![PromiseResult::Successful(vec![])],
        );
        contract.on_proposal_callback(2);

        assert_eq!(contract.get_bounty(0).bounty.times, 0);
    }

    #[test]
    #[should_panic(expected = "ERR_BOUNTY_ALL_CLAIMED")]
    fn test_bounty_claim_not_allowed() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1)]),
            ndc_trust()
        );
        let id = add_bounty(&mut context, &mut contract, 1);
        contract.bounty_claim(id, U64::from(500));
        contract.bounty_done(id, None, "Bounty is done 2".to_string());
        contract.bounty_claim(id, U64::from(500));
    }
}

'''
'''--- astra/src/delegation.rs ---
use crate::*;

impl Contract {
    pub fn get_user_weight(&self, account_id: &AccountId) -> Balance {
        self.delegations.get(account_id).unwrap_or_default()
    }
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn register_delegation(&mut self, account_id: &AccountId) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        assert_eq!(env::attached_deposit(), 16 * env::storage_byte_cost());
        self.delegations.insert(account_id, &0);
    }

    /// Adds given amount to given account as delegated weight.
    /// Returns previous amount, new amount and total delegated amount.
    pub fn delegate(&mut self, account_id: &AccountId, amount: U128) -> (U128, U128, U128) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        let prev_amount = self
            .delegations
            .get(account_id)
            .expect("ERR_NOT_REGISTERED");
        let new_amount = prev_amount + amount.0;
        self.delegations.insert(account_id, &new_amount);
        self.total_delegation_amount += amount.0;
        (
            U128(prev_amount),
            U128(new_amount),
            self.delegation_total_supply(),
        )
    }

    /// Removes given amount from given account's delegations.
    /// Returns previous, new amount of this account and total delegated amount.
    pub fn undelegate(&mut self, account_id: &AccountId, amount: U128) -> (U128, U128, U128) {
        let staking_id = self.staking_id.clone().expect("ERR_NO_STAKING");
        assert_eq!(
            env::predecessor_account_id(),
            staking_id,
            "ERR_INVALID_CALLER"
        );
        let prev_amount = self.delegations.get(account_id).unwrap_or_default();
        assert!(prev_amount >= amount.0, "ERR_INVALID_STAKING_CONTRACT");
        let new_amount = prev_amount - amount.0;
        self.delegations.insert(account_id, &new_amount);
        self.total_delegation_amount -= amount.0;
        (
            U128(prev_amount),
            U128(new_amount),
            self.delegation_total_supply(),
        )
    }
}

'''
'''--- astra/src/events.rs ---
use near_sdk::serde::Serialize;
use serde_json::json;

use common::{EventPayload, NearEvent};

fn emit_event<T: Serialize>(event: EventPayload<T>) {
    NearEvent {
        standard: "astra++",
        version: "1.0.0",
        event,
    }
    .emit();
}

pub(crate) fn emit_veto(prop_id: u64) {
    emit_event(EventPayload {
        event: "veto",
        data: json!({ "prop_id": prop_id }),
    });
}

pub(crate) fn emit_dissolve() {
    emit_event(EventPayload {
        event: "dissolve",
        data: "",
    })
}

#[cfg(test)]
mod unit_tests {
    use near_sdk::{test_utils};

    use super::*;

    #[test]
    fn log_hooks() {
        let expected1 = r#"EVENT_JSON:{"standard":"astra++","version":"1.0.0","event":"veto","data":{"prop_id":21}}"#;
        let expected2 = r#"EVENT_JSON:{"standard":"astra++","version":"1.0.0","event":"dissolve","data":""}"#;
        emit_veto(21);
        assert_eq!(vec![expected1], test_utils::get_logs());
        emit_dissolve();
        assert_eq!(vec![expected1, expected2], test_utils::get_logs());
    }
}

'''
'''--- astra/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::{Base58CryptoHash, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, CryptoHash,
    PanicOnDefault, Promise, PromiseResult, PromiseOrValue,
};
use policy::UserInfo;
use types::ContractStatus;

pub use crate::bounties::{Bounty, BountyClaim, VersionedBounty};
pub use crate::policy::{
    default_policy, Policy, RoleKind, RolePermission, VersionedPolicy, VotePolicy,
};
use crate::proposals::VersionedProposal;
pub use crate::proposals::{Proposal, ProposalInput, ProposalKind, ProposalStatus};
pub use crate::types::{Action, Config, OldAccountId, OLD_BASE_TOKEN};
use crate::upgrade::{internal_get_factory_info, internal_set_factory_info, FactoryInfo};
pub use crate::views::{BountyOutput, ProposalOutput};
use events::{emit_dissolve, emit_veto};

mod bounties;
mod delegation;
mod policy;
mod proposals;
mod types;
mod upgrade;
mod events;
pub mod views;
#[cfg(test)]
pub mod test_utils;

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    Config,
    Policy,
    Delegations,
    Proposals,
    Bounties,
    BountyClaimers,
    BountyClaimCounts,
    Blobs,
}

/// After payouts, allows a callback
#[ext_contract(ext_self)]
pub trait ExtSelf {
    /// Callback after proposal execution.
    fn on_proposal_callback(&mut self, proposal_id: u64) -> PromiseOrValue<()>;
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    /// DAO configuration.
    pub config: LazyOption<Config>,
    /// Voting and permissions policy.
    pub policy: LazyOption<VersionedPolicy>,

    /// Amount of $NEAR locked for bonds.
    pub locked_amount: Balance,

    /// Vote staking contract id. That contract must have this account as owner.
    pub staking_id: Option<AccountId>,
    /// Delegated  token total amount.
    pub total_delegation_amount: Balance,
    /// Delegations per user.
    pub delegations: LookupMap<AccountId, Balance>,

    /// Last available id for the proposals.
    pub last_proposal_id: u64,
    /// Proposal map from ID to proposal information.
    pub proposals: LookupMap<u64, VersionedProposal>,

    /// Last available id for the bounty.
    pub last_bounty_id: u64,
    /// Bounties map from ID to bounty information.
    pub bounties: LookupMap<u64, VersionedBounty>,
    /// Bounty claimers map per user. Allows quickly to query for each users their claims.
    pub bounty_claimers: LookupMap<AccountId, Vec<BountyClaim>>,
    /// Count of claims per bounty.
    pub bounty_claims_count: LookupMap<u64, u32>,

    /// Large blob storage.
    pub blobs: LookupMap<CryptoHash, AccountId>,

    /// AccountId which is a recipient of DAO funds in case the DAO will dissolve.
    pub trust: AccountId,

    pub status: ContractStatus,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(config: Config, policy: VersionedPolicy, trust: AccountId) -> Self {
        let this = Self {
            config: LazyOption::new(StorageKeys::Config, Some(&config)),
            policy: LazyOption::new(StorageKeys::Policy, Some(&policy.upgrade())),
            staking_id: None,
            total_delegation_amount: 0,
            delegations: LookupMap::new(StorageKeys::Delegations),
            last_proposal_id: 0,
            proposals: LookupMap::new(StorageKeys::Proposals),
            last_bounty_id: 0,
            bounties: LookupMap::new(StorageKeys::Bounties),
            bounty_claimers: LookupMap::new(StorageKeys::BountyClaimers),
            bounty_claims_count: LookupMap::new(StorageKeys::BountyClaimCounts),
            blobs: LookupMap::new(StorageKeys::Blobs),
            locked_amount: 0,
            trust,
            status: ContractStatus::Active
        };
        internal_set_factory_info(&FactoryInfo {
            factory_id: env::predecessor_account_id(),
            auto_update: true,
        });
        this
    }

    /// Should only be called by this contract on migration.
    /// This is NOOP implementation. KEEP IT if you haven't changed contract state.
    /// If you have changed state, you need to implement migration from old state (keep the old struct with different name to deserialize it first).
    /// After migrate goes live on MainNet, return this implementation for next updates.
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let this: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        this
    }

    /// Remove blob from contract storage and pay back to original storer.
    /// Only original storer can call this.
    pub fn remove_blob(&mut self, hash: Base58CryptoHash) -> Promise {
        let hash: CryptoHash = hash.into();
        let account_id = self.blobs.remove(&hash).expect("ERR_NO_BLOB");
        assert_eq!(
            env::predecessor_account_id(),
            account_id,
            "ERR_INVALID_CALLER"
        );
        env::storage_remove(&hash);
        let blob_len = env::register_len(u64::MAX - 1).unwrap();
        let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
        Promise::new(account_id).transfer(storage_cost)
    }

    /// Returns factory information, including if auto update is allowed.
    pub fn get_factory_info(&self) -> FactoryInfo {
        internal_get_factory_info()
    }

    /// Veto proposal hook
    /// Check for authorities and remove proposal
    /// * `id`: proposal id
    /// TODO: Add events for veto and dissolve
    pub fn veto_hook(&mut self, id: u64) {
        let policy = self.assert_policy();
        let res = policy.can_execute_hook(UserInfo {
            amount: 0u128,
            account_id: env::predecessor_account_id(),
        }, &Action::VetoProposal);
        assert!(res, "not authorized");

        // Check if the proposal exist and is not finalized
        let proposal = self.assert_proposal(&id);
        match proposal.status {
            ProposalStatus::InProgress | ProposalStatus::Failed => {
                self.proposals.remove(&id);
            }
            _ => {
                panic!("Proposal finalized");
            }
        }
        emit_veto(id)
    }

    /// Dissolves the DAO by removing all members, closing all active proposals and returning bonds.
    /// Transfers all reminding funds to the trust.
    /// Panics if policy doesn't exist or accound is not authorised to execute dissolve
    pub fn dissolve_hook(&mut self) {
        let mut policy = self.assert_policy();
        let res = policy.can_execute_hook(UserInfo {
            amount: 0u128,
            account_id: env::predecessor_account_id(),
        }, &Action::Dissolve);
        assert!(res, "not authorized");

        self.status = ContractStatus::Dissolved;
        policy.roles = vec![];
        self.policy.set(&VersionedPolicy::Current(policy));

        let funds = env::account_balance() - self.locked_amount;
        Promise::new(self.trust.clone()).transfer(funds);
        emit_dissolve();
    }

    pub fn finalize_dissolve(&mut self, from_prop: u64, limit: u64) {
        if self.status == ContractStatus::Active {
            panic!("cannot clear proposals, DAO is in active state!")
        }
        let policy = self.assert_policy();
        // Return bond amounts
        for prop_id in from_prop..(from_prop+limit) {
            if let Some(prop) = self.proposals.get(&prop_id) {
                let proposal: Proposal = prop.into();
                if proposal.status == ProposalStatus::InProgress {
                    self.internal_return_bonds(&policy, &proposal);
                }
                self.proposals.remove(&prop_id);
            } else {
                continue;
            }
        }
    }

    fn assert_policy(&self) -> Policy {
        self.policy.get().expect("policy not found").to_policy()
    }

    fn assert_proposal(&self, id: &u64) -> Proposal {
        self.proposals.get(id).expect("proposal does not exist").into()
    }
}

/// Stores attached data into blob store and returns hash of it.
/// Implemented to avoid loading the data into WASM for optimal gas usage.
#[no_mangle]
pub extern "C" fn store_blob() {
    env::setup_panic_hook();
    let mut contract: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
    let input = env::input().expect("ERR_NO_INPUT");
    let sha256_hash = env::sha256(&input);
    assert!(!env::storage_has_key(&sha256_hash), "ERR_ALREADY_EXISTS");

    let blob_len = input.len();
    let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
    assert!(
        env::attached_deposit() >= storage_cost,
        "ERR_NOT_ENOUGH_DEPOSIT:{}",
        storage_cost
    );

    env::storage_write(&sha256_hash, &input);
    let mut blob_hash = [0u8; 32];
    blob_hash.copy_from_slice(&sha256_hash);
    contract
        .blobs
        .insert(&blob_hash, &env::predecessor_account_id());
    let blob_hash_str = near_sdk::serde_json::to_string(&Base58CryptoHash::from(blob_hash))
        .unwrap()
        .into_bytes();

    env::value_return(&blob_hash_str);
    env::state_write(&contract);
}

#[cfg(test)]
mod tests {
    use std::collections::{HashMap};

    use near_sdk::json_types::U64;
    use near_sdk::test_utils::{accounts, VMContextBuilder, get_logs};
    use near_sdk::{testing_env, VMContext};
    use near_units::parse_near;

    use crate::proposals::ProposalStatus;
    use crate::test_utils::*;

    use super::*;

    fn create_proposal(context: &mut VMContextBuilder, contract: &mut Contract) -> u64 {
        testing_env!(context.attached_deposit(parse_near!("1 N")).build());
        contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::Transfer {
                token_id: String::from(OLD_BASE_TOKEN),
                receiver_id: accounts(2),
                amount: U128(parse_near!("100 N")),
                msg: None,
            },
            category: None
        })
    }

    /// Council members with Add, vote on proposal permissions : Accounts [council_member_1, council_member_2, council_member_3
    /// council_member_4]
    /// House CoA with Veto permission : Accounts [ council_of_advisors ]
    /// House VB with dissolve permission : Accounts [ acc_voting_body ]
    fn house_policy() -> Policy {
        Policy {
            roles: vec![
                RolePermission {
                    name: "council".to_string(),
                    kind: RoleKind::Group(vec![council(1), council(2),
                        council(3), council(4)].into_iter().collect()),
                    // All actions except RemoveProposal are allowed by council.
                    permissions: vec![
                        "*:AddProposal".to_string(),
                        "*:VoteApprove".to_string(),
                        "*:VoteReject".to_string(),
                        "*:VoteRemove".to_string(),
                        "*:Finalize".to_string(),
                    ]
                    .into_iter()
                    .collect(),
                    vote_policy: HashMap::default(),
                },
                RolePermission {
                    name: "CoA".to_string(),
                    kind: RoleKind::Group(vec![council_of_advisors()].into_iter().collect()),
                    permissions: vec!["VetoProposal".to_string()].into_iter().collect(),
                    vote_policy: HashMap::default(),
                },
                RolePermission {
                    name: "VotingBody".to_string(),
                    kind: RoleKind::Group(vec![acc_voting_body()].into_iter().collect()),
                    permissions: vec!["Dissolve".to_string()].into_iter().collect(),
                    vote_policy: HashMap::default(),
                },
            ],
            default_vote_policy: VotePolicy::default(),
            proposal_bond: U128(10u128.pow(24)),
            proposal_period: U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
            bounty_bond: U128(10u128.pow(24)),
            bounty_forgiveness_period: U64::from(1_000_000_000 * 60 * 60 * 24),
        }
    }

    /// Add voting_body with Dissolve permission
    /// Add CoA with Veto permission
    fn setup_ctr() -> (VMContext, Contract, u64) {
        let mut context = VMContextBuilder::new();
        let mut contract = Contract::new(
            Config::test_config(),
            policy::VersionedPolicy::Current(house_policy()),
            ndc_trust()
        );
        testing_env!(context.predecessor_account_id(council(1)).build());
        // create four proposals
        for _ in 0..4 {
            create_proposal(&mut context, &mut contract);
        }
        let id = create_proposal(&mut context, &mut contract);
        (context.build(), contract, id)
    }

    fn setup_for_proposals() -> (VMContext, Contract, u64) {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1)]),
            ndc_trust()
        );
        let id = create_proposal(&mut context, &mut contract);
        return (context.build(), contract, id)
    }

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1)]),
            ndc_trust()
        );
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        assert_eq!(contract.get_proposals(0, 10).len(), 1);

        let id = create_proposal(&mut context, &mut contract);
        contract.act_proposal(id, Action::VoteApprove, None, None);
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Executed
        );

        let id = create_proposal(&mut context, &mut contract);
        // proposal expired, finalize.
        testing_env!(context
            .block_timestamp(1_000_000_000 * 24 * 60 * 60 * 8)
            .build());
        contract.act_proposal(id, Action::Finalize, None, None);
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Expired
        );

        // non council adding proposal per default policy.
        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(parse_near!("1 N"))
            .build());
        let _id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: accounts(2),
                role: "council".to_string(),
            },
            category: None
        });
    }

    #[test]
    #[should_panic(expected = "ERR_PERMISSION_DENIED")]
    fn test_remove_proposal_denied() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1)]),
            ndc_trust()
        );
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        contract.act_proposal(id, Action::RemoveProposal, None, None);
    }

    #[test]
    fn test_remove_proposal_allowed() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut policy = VersionedPolicy::Default(vec![accounts(1)]).upgrade();
        policy.to_policy_mut().roles[1]
            .permissions
            .insert("*:RemoveProposal".to_string());
        let mut contract = Contract::new(Config::test_config(), policy, accounts(1));
        let id = create_proposal(&mut context, &mut contract);
        assert_eq!(contract.get_proposal(id).proposal.description, "test");
        contract.act_proposal(id, Action::RemoveProposal, None, None);
        assert_eq!(contract.get_proposals(0, 10).len(), 0);
    }

    #[test]
    fn test_vote_expired_proposal() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1)]),
            ndc_trust()
        );
        let id = create_proposal(&mut context, &mut contract);
        testing_env!(context
            .block_timestamp(1_000_000_000 * 24 * 60 * 60 * 8)
            .build());
        contract.act_proposal(id, Action::VoteApprove, None, None);
    }

    #[test]
    #[should_panic(expected = "ERR_ALREADY_VOTED")]
    fn test_vote_twice() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1), accounts(2)]),
            ndc_trust()
        );
        let id = create_proposal(&mut context, &mut contract);
        contract.act_proposal(id, Action::VoteApprove, None, None);
        contract.act_proposal(id, Action::VoteApprove, None, None);
    }

    #[test]
    fn test_add_to_missing_role() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1)]),
            ndc_trust()
        );
        testing_env!(context.attached_deposit(parse_near!("1 N")).build());
        let id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: accounts(2),
                role: "missing".to_string(),
            },
            category: None
        });
        contract.act_proposal(id, Action::VoteApprove, None, None);
        let x = contract.get_policy();
        // still 2 roles: all and council.
        assert_eq!(x.roles.len(), 2);
    }

    #[test]
    fn test_proposal_execution() {
        let (_, mut contract, id) = setup_for_proposals();

        contract.act_proposal(id, Action::VoteApprove, None, Some(true));
        // verify proposal wasn't executed during final vote
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Approved
        );

        contract.act_proposal(id, Action::Execute, None, None);
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Executed
        );
    }

    #[test]
    #[should_panic(expected = "ERR_PROPOSAL_ALREADY_EXECUTED")]
    fn test_proposal_double_execution() {
        let (_, mut contract, id) = setup_for_proposals();
        contract.act_proposal(id, Action::VoteApprove, None, Some(false));
        // verify proposal was approved and executed
        assert_eq!(
            contract.get_proposal(id).proposal.status,
            ProposalStatus::Executed
        );

        // panics if we try to execute again
        contract.act_proposal(id, Action::Execute, None, None);
    }

    #[test]
    #[should_panic(expected = "ERR_INVALID_POLICY")]
    fn test_fails_adding_invalid_policy() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        let mut contract = Contract::new(
            Config::test_config(),
            VersionedPolicy::Default(vec![accounts(1)]),
            ndc_trust()
        );
        testing_env!(context.attached_deposit(parse_near!("1 N")).build());
        let _id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::ChangePolicy {
                policy: VersionedPolicy::Default(vec![]),
            },
            category: None
        });
    }

    #[test]
    #[should_panic(expected = "ERR_NO_PROPOSAL")]
    fn test_veto() {
        let (mut context, mut contract, id)= setup_ctr();
        assert_eq!(contract.get_proposal(id).id, id);

        context.predecessor_account_id = council_of_advisors();
        testing_env!(context);
        contract.veto_hook(id);

        let expected = r#"EVENT_JSON:{"standard":"astra++","version":"1.0.0","event":"veto","data":{"prop_id":4}}"#;
        assert_eq!(vec![expected], get_logs());

        contract.get_proposal(id);
        // TODO: this should not panic, instead return NONE
    }

    #[test]
    #[should_panic(expected = "not authorized")]
    fn test_veto_unauthorised() {
        let (_, mut contract, id)= setup_ctr();
        assert_eq!(contract.get_proposal(id).id, id);
        contract.veto_hook(id);
    }

    #[test]
    #[should_panic(expected = "Cannot perform this action, dao is dissolved!")]
    fn test_dissolve() {
        let (mut context, mut contract, id)= setup_ctr();
        assert_eq!(contract.get_proposal(id).id, id);

        let mut res = contract.policy.get().unwrap().to_policy();
        assert!(!res.roles.is_empty());

        context.predecessor_account_id = acc_voting_body();
        testing_env!(context.clone());
        contract.dissolve_hook();

        let expected = r#"EVENT_JSON:{"standard":"astra++","version":"1.0.0","event":"dissolve","data":""}"#;
        assert_eq!(vec![expected], get_logs());

        res = contract.policy.get().unwrap().to_policy();
        assert!(res.roles.is_empty());

        context.predecessor_account_id = council(1);
        context.attached_deposit = parse_near!("1 N");
        testing_env!(context);

        // Should panic because dao is dissolved
        contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: accounts(2),
                role: "Council".to_string(),
            },
            category: None
        });
    }

    #[test]
    #[should_panic(expected = "ERR_NO_PROPOSAL")]
    fn test_whole_flow_interhouse_dissolve() {
        let (mut context, mut contract, id)= setup_ctr();
        // council member 1 made a proposal
        assert_eq!(contract.get_proposal(id).id, id);

        // Other members vote
        context.predecessor_account_id = council(2);
        testing_env!(context.clone());
        contract.act_proposal(id, Action::VoteApprove, Some("vote on prosposal".to_string()), None);
        assert!(contract.get_proposal(id).proposal.votes.contains_key(&council(2)));

        context.predecessor_account_id = council(3);
        testing_env!(context.clone());
        contract.act_proposal(id, Action::VoteReject, Some("vote on prosposal".to_string()), None);
        assert!(contract.get_proposal(id).proposal.votes.contains_key(&council(3)));

        // Voting body vetos
        context.predecessor_account_id = council_of_advisors();
        testing_env!(context.clone());
        contract.veto_hook(id);

        // no more members should be able to vote
        context.predecessor_account_id = council(4);
        testing_env!(context);
        contract.act_proposal(id, Action::VoteApprove, Some("vote on prosposal".to_string()), None);
    }

    #[test]
    fn test_dissolve_missing_proposals() {
        let (mut context, mut contract, id)= setup_ctr();
        assert_eq!(contract.get_proposal(id).id, id);
        assert!(contract.get_proposal(id).proposal.category.is_none());

        let mut res = contract.policy.get().unwrap().to_policy();
        assert!(!res.roles.is_empty());

        context.predecessor_account_id = acc_voting_body();
        testing_env!(context.clone());
        contract.dissolve_hook();
        res = contract.policy.get().unwrap().to_policy();
        assert!(res.roles.is_empty());

        // remove 1 proposal from middle
        contract.finalize_dissolve(2, 1);

        // remove all proposals, should not throw error because of missing prop
        contract.finalize_dissolve(0, 5);
    }

    #[test]
    fn test_category() {
        let (_, mut contract, id)= setup_ctr();
        let id = contract.add_proposal(ProposalInput {
            description: "test".to_string(),
            kind: ProposalKind::AddMemberToRole {
                member_id: accounts(2),
                role: "Council".to_string(),
            },
            category: Some("legal".to_string())
        });
        
        assert!(contract.get_proposal(id).proposal.category.is_some());
        assert_eq!(contract.get_proposal(id).proposal.category.unwrap(), "legal".to_string());
    }
}

'''
'''--- astra/src/policy.rs ---
use std::cmp::min;
use std::collections::{HashMap, HashSet};

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance};

use crate::proposals::{PolicyParameters, Proposal, ProposalKind, ProposalStatus, Vote};
use crate::types::Action;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub enum RoleKind {
    /// Matches everyone, who is not matched by other roles.
    Everyone,
    /// Member greater or equal than given balance. Can use `1` as non-zero balance.
    Member(U128),
    /// Set of accounts.
    Group(HashSet<AccountId>),
}

impl RoleKind {
    /// Checks if user matches given role.
    pub fn match_user(&self, user: &UserInfo) -> bool {
        match self {
            RoleKind::Everyone => true,
            RoleKind::Member(amount) => user.amount >= amount.0,
            RoleKind::Group(accounts) => accounts.contains(&user.account_id),
        }
    }

    /// Returns the number of people in the this role or None if not supported role kind.
    pub fn get_role_size(&self) -> Option<usize> {
        match self {
            RoleKind::Group(accounts) => Some(accounts.len()),
            _ => None,
        }
    }

    pub fn add_member_to_group(&mut self, member_id: &AccountId) -> Result<(), ()> {
        match self {
            RoleKind::Group(accounts) => {
                accounts.insert(member_id.clone());
                Ok(())
            }
            _ => Err(()),
        }
    }

    pub fn remove_member_from_group(&mut self, member_id: &AccountId) -> Result<(), ()> {
        match self {
            RoleKind::Group(accounts) => {
                accounts.remove(member_id);
                Ok(())
            }
            _ => Err(()),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct RolePermission {
    /// Name of the role to display to the user.
    pub name: String,
    /// Kind of the role: defines which users this permissions apply.
    pub kind: RoleKind,
    /// Set of actions on which proposals that this role is allowed to execute.
    /// <proposal_kind>:<action>
    pub permissions: HashSet<String>,
    /// For each proposal kind, defines voting policy.
    pub vote_policy: HashMap<String, VotePolicy>,
}

pub struct UserInfo {
    pub account_id: AccountId,
    pub amount: Balance,
}

/// Direct weight or ratio to total weight, used for the voting policy.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum WeightOrRatio {
    Weight(U128),
    Ratio(u64, u64),
}

impl WeightOrRatio {
    /// Convert weight or ratio to specific weight given total weight.
    pub fn to_weight(&self, total_weight: Balance) -> Balance {
        match self {
            WeightOrRatio::Weight(weight) => min(weight.0, total_weight),
            WeightOrRatio::Ratio(num, denom) => min(
                (*num as u128 * total_weight) / *denom as u128 + 1,
                total_weight,
            ),
        }
    }
}

/// How the voting policy votes get weigthed.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum WeightKind {
    /// Using token amounts and total delegated at the moment.
    TokenWeight,
    /// Weight of the group role. Roles that don't have scoped group are not supported.
    RoleWeight,
}

/// Defines configuration of the vote.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct VotePolicy {
    /// Kind of weight to use for votes.
    pub weight_kind: WeightKind,
    /// Minimum number required for vote to finalize.
    /// If weight kind is TokenWeight - this is minimum number of tokens required.
    ///     This allows to avoid situation where the number of staked tokens from total supply is too small.
    /// If RoleWeight - this is minimum number of votes.
    ///     This allows to avoid situation where the role is got too small but policy kept at 1/2, for example.
    pub quorum: U128,
    /// How many votes to pass this vote.
    pub threshold: WeightOrRatio,
}

impl Default for VotePolicy {
    fn default() -> Self {
        VotePolicy {
            weight_kind: WeightKind::RoleWeight,
            quorum: U128(0),
            threshold: WeightOrRatio::Ratio(1, 2),
        }
    }
}

/// Defines voting / decision making policy of this DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct Policy {
    /// List of roles and permissions for them in the current policy.
    pub roles: Vec<RolePermission>,
    /// Default vote policy. Used when given proposal kind doesn't have special policy.
    pub default_vote_policy: VotePolicy,
    /// Proposal bond.
    pub proposal_bond: U128,
    /// Expiration period for proposals.
    pub proposal_period: U64,
    /// Bond for claiming a bounty.
    pub bounty_bond: U128,
    /// Period in which giving up on bounty is not punished.
    pub bounty_forgiveness_period: U64,
}

/// Versioned policy.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum VersionedPolicy {
    /// Default policy with given accounts as council.
    Default(Vec<AccountId>),
    Current(Policy),
}

/// Defines default policy:
///     - everyone can add proposals
///     - group consisting of the call can do all actions, consists of caller.
///     - non token weighted voting, requires 1/2 of the group to vote
///     - proposal & bounty bond is 1N
///     - proposal & bounty forgiveness period is 1 day
pub fn default_policy(council: Vec<AccountId>) -> Policy {
    Policy {
        roles: vec![
            RolePermission {
                name: "all".to_string(),
                kind: RoleKind::Everyone,
                permissions: vec!["*:AddProposal".to_string(), "*:Execute".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "council".to_string(),
                kind: RoleKind::Group(council.into_iter().collect()),
                // All actions except RemoveProposal are allowed by council.
                permissions: vec![
                    "*:AddProposal".to_string(),
                    "*:VoteApprove".to_string(),
                    "*:VoteReject".to_string(),
                    "*:VoteRemove".to_string(),
                    "*:Finalize".to_string(),
                ]
                .into_iter()
                .collect(),
                vote_policy: HashMap::default(),
            },
        ],
        default_vote_policy: VotePolicy::default(),
        proposal_bond: U128(10u128.pow(24)),
        proposal_period: U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
        bounty_bond: U128(10u128.pow(24)),
        bounty_forgiveness_period: U64::from(1_000_000_000 * 60 * 60 * 24),
    }
}

impl VersionedPolicy {
    /// Upgrades either version of policy into the latest.
    pub fn upgrade(self) -> Self {
        match self {
            VersionedPolicy::Default(accounts) => {
                VersionedPolicy::Current(default_policy(accounts))
            }
            VersionedPolicy::Current(policy) => VersionedPolicy::Current(policy),
        }
    }

    /// Return recent version of policy.
    pub fn to_policy(self) -> Policy {
        match self {
            VersionedPolicy::Current(policy) => policy,
            _ => unimplemented!(),
        }
    }

    pub fn to_policy_mut(&mut self) -> &mut Policy {
        match self {
            VersionedPolicy::Current(policy) => policy,
            _ => unimplemented!(),
        }
    }
}

impl Policy {
    pub fn add_or_update_role(&mut self, role: &RolePermission) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == &role.name {
                env::log_str(&format!(
                    "Updating existing role in the policy:{}",
                    &role.name
                ));
                let _ = std::mem::replace(&mut self.roles[i], role.clone());
                return;
            }
        }
        env::log_str(&format!("Adding new role to the policy:{}", &role.name));
        self.roles.push(role.clone());
    }

    pub fn remove_role(&mut self, role: &String) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == role {
                self.roles.remove(i);
                return;
            }
        }
        env::log_str(&format!("ERR_ROLE_NOT_FOUND:{}", role));
    }

    pub fn update_default_vote_policy(&mut self, vote_policy: &VotePolicy) {
        self.default_vote_policy = vote_policy.clone();
        env::log_str("Successfully updated the default vote policy.");
    }

    pub fn update_parameters(&mut self, parameters: &PolicyParameters) {
        if parameters.proposal_bond.is_some() {
            self.proposal_bond = parameters.proposal_bond.unwrap();
        }
        if parameters.proposal_period.is_some() {
            self.proposal_period = parameters.proposal_period.unwrap();
        }
        if parameters.bounty_bond.is_some() {
            self.bounty_bond = parameters.bounty_bond.unwrap();
        }
        if parameters.bounty_forgiveness_period.is_some() {
            self.bounty_forgiveness_period = parameters.bounty_forgiveness_period.unwrap();
        }
        env::log_str("Successfully updated the policy parameters.");
    }

    pub fn add_member_to_role(&mut self, role: &String, member_id: &AccountId) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == role {
                self.roles[i]
                    .kind
                    .add_member_to_group(member_id)
                    .unwrap_or_else(|()| {
                        env::log_str(&format!("ERR_ROLE_WRONG_KIND:{}", role));
                    });
                return;
            }
        }
        env::log_str(&format!("ERR_ROLE_NOT_FOUND:{}", role));
    }

    pub fn remove_member_from_role(&mut self, role: &String, member_id: &AccountId) {
        for i in 0..self.roles.len() {
            if &self.roles[i].name == role {
                self.roles[i]
                    .kind
                    .remove_member_from_group(member_id)
                    .unwrap_or_else(|()| {
                        env::log_str(&format!("ERR_ROLE_WRONG_KIND:{}", role));
                    });
                return;
            }
        }
        env::log_str(&format!("ERR_ROLE_NOT_FOUND:{}", role));
    }

    /// Returns set of roles that this user is member of permissions for given user across all the roles it's member of.
    fn get_user_roles(&self, user: UserInfo) -> HashMap<String, &HashSet<String>> {
        let mut roles = HashMap::default();
        for role in self.roles.iter() {
            if role.kind.match_user(&user) {
                roles.insert(role.name.clone(), &role.permissions);
            }
        }
        roles
    }

    /// Can given user execute given action on this proposal.
    /// Returns all roles that allow this action.
    pub fn can_execute_action(
        &self,
        user: UserInfo,
        proposal_kind: &ProposalKind,
        action: &Action,
    ) -> (Vec<String>, bool) {
        let roles = self.get_user_roles(user);
        let mut allowed = false;
        let allowed_roles = roles
            .into_iter()
            .filter_map(|(role, permissions)| {
                let allowed_role = permissions.contains(&format!(
                    "{}:{}",
                    proposal_kind.to_policy_label(),
                    action.to_policy_label()
                )) || permissions
                    .contains(&format!("{}:*", proposal_kind.to_policy_label()))
                    || permissions.contains(&format!("*:{}", action.to_policy_label()))
                    || permissions.contains("*:*");
                allowed = allowed || allowed_role;
                if allowed_role {
                    Some(role)
                } else {
                    None
                }
            })
            .collect();
        (allowed_roles, allowed)
    }

    /// Can given house execute given action on this dao.
    pub fn can_execute_hook(
        &self,
        user: UserInfo,
        action: &Action,
    ) -> bool {
        let perm = action.to_policy_label();
        for role in self.roles.iter() {
            if role.kind.match_user(&user) && role.permissions.contains(&perm) {
                return true;
            }
        }
        false
    }

    /// Returns if given proposal kind is token weighted.
    pub fn is_token_weighted(&self, role: &String, proposal_kind_label: &String) -> bool {
        let role_info = self.internal_get_role(role).expect("ERR_ROLE_NOT_FOUND");
        match role_info
            .vote_policy
            .get(proposal_kind_label)
            .unwrap_or(&self.default_vote_policy)
            .weight_kind
        {
            WeightKind::TokenWeight => true,
            _ => false,
        }
    }

    fn internal_get_role(&self, name: &String) -> Option<&RolePermission> {
        self.roles.iter().find(|&role| role.name == *name)
    }

    /// Get proposal status for given proposal.
    /// Usually is called after changing it's state.
    pub fn proposal_status(
        &self,
        proposal: &Proposal,
        roles: Vec<String>,
        total_supply: Balance,
    ) -> ProposalStatus {
        assert!(
            matches!(
                proposal.status,
                ProposalStatus::InProgress | ProposalStatus::Failed | ProposalStatus::Approved
            ),
            "ERR_PROPOSAL_NOT_IN_PROGRESS"
        );
        if proposal.submission_time.0 + self.proposal_period.0 < env::block_timestamp() {
            // Proposal expired.
            return ProposalStatus::Expired;
        };
        for role in roles {
            let role_info = self.internal_get_role(&role).expect("ERR_MISSING_ROLE");
            let vote_policy = role_info
                .vote_policy
                .get(&proposal.kind.to_policy_label().to_string())
                .unwrap_or(&self.default_vote_policy);
            let total_weight = match &role_info.kind {
                // Skip role that covers everyone as it doesn't provide a total size.
                RoleKind::Everyone => continue,
                RoleKind::Group(group) => {
                    if vote_policy.weight_kind == WeightKind::RoleWeight {
                        group.len() as Balance
                    } else {
                        total_supply
                    }
                }
                RoleKind::Member(_) => total_supply,
            };
            let threshold = std::cmp::max(
                vote_policy.quorum.0,
                vote_policy.threshold.to_weight(total_weight),
            );
            // Check if there is anything voted above the threshold specified by policy for given role.
            let vote_counts = proposal.vote_counts.get(&role).unwrap_or(&[0u128; 3]);
            if vote_counts[Vote::Approve as usize] >= threshold {
                return ProposalStatus::Approved;
            } else if vote_counts[Vote::Reject as usize] >= threshold {
                return ProposalStatus::Rejected;
            } else if vote_counts[Vote::Remove as usize] >= threshold {
                return ProposalStatus::Removed;
            } else {
                // continue to next role.
            }
        }
        proposal.status.clone()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::accounts;

    use super::*;

    #[test]
    fn test_vote_policy() {
        let r1 = WeightOrRatio::Weight(U128(100));
        assert_eq!(r1.to_weight(1_000_000), 100);
        let r2 = WeightOrRatio::Ratio(1, 2);
        assert_eq!(r2.to_weight(2), 2);
        let r2 = WeightOrRatio::Ratio(1, 2);
        assert_eq!(r2.to_weight(5), 3);
        let r2 = WeightOrRatio::Ratio(1, 1);
        assert_eq!(r2.to_weight(5), 5);
    }

    #[test]
    fn test_add_role() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        let community_role = policy.internal_get_role(&String::from("community"));
        assert!(community_role.is_none());

        let name: String = "community".to_string();
        let kind: RoleKind = RoleKind::Group(vec![accounts(2), accounts(3)].into_iter().collect());
        let permissions: HashSet<String> = vec!["*:*".to_string()].into_iter().collect();
        let vote_policy: HashMap<String, VotePolicy> = HashMap::default();
        let new_role = RolePermission {
            name: name.clone(),
            kind: kind.clone(),
            permissions: permissions.clone(),
            vote_policy: vote_policy.clone(),
        };
        assert_eq!(2, policy.roles.len());
        policy.add_or_update_role(&new_role);
        assert_eq!(3, policy.roles.len());

        let community_role = policy.internal_get_role(&String::from("community"));
        assert!(community_role.is_some());

        let community_role = community_role.unwrap();
        assert_eq!(name, community_role.name);
        assert_eq!(kind, community_role.kind);
        assert_eq!(permissions, community_role.permissions);
        assert_eq!(vote_policy, community_role.vote_policy);
    }

    #[test]
    fn test_update_role() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        let name: String = "council".to_string();
        let kind: RoleKind = RoleKind::Group(vec![accounts(0), accounts(1)].into_iter().collect());
        let permissions: HashSet<String> = vec![
            "*:AddProposal".to_string(),
            "*:VoteApprove".to_string(),
            "*:VoteReject".to_string(),
            "*:VoteRemove".to_string(),
            "*:Finalize".to_string(),
        ]
        .into_iter()
        .collect();
        let vote_policy: HashMap<String, VotePolicy> = HashMap::default();

        let council_role = policy.internal_get_role(&String::from("council"));
        assert!(council_role.is_some());

        let council_role = council_role.unwrap();
        assert_eq!(name, council_role.name);
        assert_eq!(kind, council_role.kind);
        assert_eq!(permissions, council_role.permissions);
        assert_eq!(vote_policy, council_role.vote_policy);

        let kind: RoleKind = RoleKind::Group(vec![accounts(2), accounts(3)].into_iter().collect());
        let permissions: HashSet<String> = vec!["*:*".to_string()].into_iter().collect();
        let updated_role = RolePermission {
            name: name.clone(),
            kind: kind.clone(),
            permissions: permissions.clone(),
            vote_policy: vote_policy.clone(),
        };
        assert_eq!(2, policy.roles.len());
        policy.add_or_update_role(&updated_role);
        assert_eq!(2, policy.roles.len());

        let council_role = policy.internal_get_role(&String::from("council"));
        assert!(council_role.is_some());

        let council_role = council_role.unwrap();
        assert_eq!(name, council_role.name);
        assert_eq!(kind, council_role.kind);
        assert_eq!(permissions, council_role.permissions);
        assert_eq!(vote_policy, council_role.vote_policy);
    }

    #[test]
    fn test_remove_role() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        let council_role = policy.internal_get_role(&String::from("council"));
        assert!(council_role.is_some());
        assert_eq!(2, policy.roles.len());

        policy.remove_role(&String::from("council"));

        let council_role = policy.internal_get_role(&String::from("council"));
        assert!(council_role.is_none());
        assert_eq!(1, policy.roles.len());
    }

    #[test]
    fn test_update_default_vote_policy() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        assert_eq!(
            WeightKind::RoleWeight,
            policy.default_vote_policy.weight_kind
        );
        assert_eq!(U128(0), policy.default_vote_policy.quorum);
        assert_eq!(
            WeightOrRatio::Ratio(1, 2),
            policy.default_vote_policy.threshold
        );

        let new_default_vote_policy = VotePolicy {
            weight_kind: WeightKind::TokenWeight,
            quorum: U128(100),
            threshold: WeightOrRatio::Ratio(1, 4),
        };
        policy.update_default_vote_policy(&new_default_vote_policy);
        assert_eq!(
            new_default_vote_policy.weight_kind,
            policy.default_vote_policy.weight_kind
        );
        assert_eq!(
            new_default_vote_policy.quorum,
            policy.default_vote_policy.quorum
        );
        assert_eq!(
            new_default_vote_policy.threshold,
            policy.default_vote_policy.threshold
        );
    }

    #[test]
    fn test_update_parameters() {
        let council = vec![accounts(0), accounts(1)];
        let mut policy = default_policy(council);

        assert_eq!(U128(10u128.pow(24)), policy.proposal_bond);
        assert_eq!(
            U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
            policy.proposal_period
        );
        assert_eq!(U128(10u128.pow(24)), policy.bounty_bond);
        assert_eq!(
            U64::from(1_000_000_000 * 60 * 60 * 24),
            policy.bounty_forgiveness_period
        );

        let new_parameters = PolicyParameters {
            proposal_bond: Some(U128(10u128.pow(26))),
            proposal_period: None,
            bounty_bond: None,
            bounty_forgiveness_period: Some(U64::from(1_000_000_000 * 60 * 60 * 24 * 5)),
        };
        policy.update_parameters(&new_parameters);
        assert_eq!(U128(10u128.pow(26)), policy.proposal_bond);
        assert_eq!(
            U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
            policy.proposal_period
        );
        assert_eq!(U128(10u128.pow(24)), policy.bounty_bond);
        assert_eq!(
            U64::from(1_000_000_000 * 60 * 60 * 24 * 5),
            policy.bounty_forgiveness_period
        );
    }
}

'''
'''--- astra/src/proposals.rs ---
use std::collections::HashMap;

use near_contract_standards::fungible_token::core::ext_ft_core;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::{log, AccountId, Balance, Gas, PromiseOrValue, require};

use crate::policy::UserInfo;
use crate::types::{
    convert_old_to_new_token, Action, Config, OldAccountId, GAS_FOR_FT_TRANSFER, OLD_BASE_TOKEN,
    ONE_YOCTO_NEAR,
};
use crate::upgrade::{upgrade_remote, upgrade_using_factory};
use crate::*;

/// Status of a proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalStatus {
    InProgress,
    /// If quorum voted yes, this proposal is successfully approved.
    Approved,
    /// If quorum voted no, this proposal is rejected. Bond is returned.
    Rejected,
    /// If quorum voted to remove (e.g. spam), this proposal is rejected and bond is not returned.
    /// Interfaces shouldn't show removed proposals.
    Removed,
    /// Expired after period of time.
    Expired,
    /// If proposal was moved to Hub or somewhere else.
    Moved,
    /// If proposal has failed when finalizing. Allowed to re-finalize again to either expire or approved.
    Failed,
    Executed,
}

/// Function call arguments.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct ActionCall {
    method_name: String,
    args: Base64VecU8,
    deposit: U128,
    gas: U64,
}

/// Function call arguments.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct PolicyParameters {
    pub proposal_bond: Option<U128>,
    pub proposal_period: Option<U64>,
    pub bounty_bond: Option<U128>,
    pub bounty_forgiveness_period: Option<U64>,
}

/// Kinds of proposals, doing different action.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalKind {
    /// Change the DAO config.
    ChangeConfig { config: Config },
    /// Change the full policy.
    ChangePolicy { policy: VersionedPolicy },
    /// Add member to given role in the policy. This is short cut to updating the whole policy.
    AddMemberToRole { member_id: AccountId, role: String },
    /// Remove member to given role in the policy. This is short cut to updating the whole policy.
    RemoveMemberFromRole { member_id: AccountId, role: String },
    /// Calls `receiver_id` with list of method names in a single promise.
    /// Allows this contract to execute any arbitrary set of actions in other contracts.
    FunctionCall {
        receiver_id: AccountId,
        actions: Vec<ActionCall>,
    },
    /// Upgrade this contract with given hash from blob store.
    UpgradeSelf { hash: Base58CryptoHash },
    /// Upgrade another contract, by calling method with the code from given hash from blob store.
    UpgradeRemote {
        receiver_id: AccountId,
        method_name: String,
        hash: Base58CryptoHash,
    },
    /// Transfers given amount of `token_id` from this DAO to `receiver_id`.
    /// If `msg` is not None, calls `ft_transfer_call` with given `msg`. Fails if this base token.
    /// For `ft_transfer` and `ft_transfer_call` `memo` is the `description` of the proposal.
    Transfer {
        /// Can be "" for $NEAR or a valid account id.
        token_id: OldAccountId,
        receiver_id: AccountId,
        amount: U128,
        msg: Option<String>,
    },
    /// Sets staking contract. Can only be proposed if staking contract is not set yet.
    SetStakingContract { staking_id: AccountId },
    /// Add new bounty.
    AddBounty { bounty: Bounty },
    /// Indicates that given bounty is done by given user.
    BountyDone {
        bounty_id: u64,
        receiver_id: AccountId,
    },
    /// Just a signaling vote, with no execution.
    Vote,
    /// Change information about factory and auto update.
    FactoryInfoUpdate { factory_info: FactoryInfo },
    /// Add new role to the policy. If the role already exists, update it. This is short cut to updating the whole policy.
    ChangePolicyAddOrUpdateRole { role: RolePermission },
    /// Remove role from the policy. This is short cut to updating the whole policy.
    ChangePolicyRemoveRole { role: String },
    /// Update the default vote policy from the policy. This is short cut to updating the whole policy.
    ChangePolicyUpdateDefaultVotePolicy { vote_policy: VotePolicy },
    /// Update the parameters from the policy. This is short cut to updating the whole policy.
    ChangePolicyUpdateParameters { parameters: PolicyParameters },
}

impl ProposalKind {
    /// Returns label of policy for given type of proposal.
    pub fn to_policy_label(&self) -> &str {
        match self {
            ProposalKind::ChangeConfig { .. } => "config",
            ProposalKind::ChangePolicy { .. } => "policy",
            ProposalKind::AddMemberToRole { .. } => "add_member_to_role",
            ProposalKind::RemoveMemberFromRole { .. } => "remove_member_from_role",
            ProposalKind::FunctionCall { .. } => "call",
            ProposalKind::UpgradeSelf { .. } => "upgrade_self",
            ProposalKind::UpgradeRemote { .. } => "upgrade_remote",
            ProposalKind::Transfer { .. } => "transfer",
            ProposalKind::SetStakingContract { .. } => "set_vote_token",
            ProposalKind::AddBounty { .. } => "add_bounty",
            ProposalKind::BountyDone { .. } => "bounty_done",
            ProposalKind::Vote => "vote",
            ProposalKind::FactoryInfoUpdate { .. } => "factory_info_update",
            ProposalKind::ChangePolicyAddOrUpdateRole { .. } => "policy_add_or_update_role",
            ProposalKind::ChangePolicyRemoveRole { .. } => "policy_remove_role",
            ProposalKind::ChangePolicyUpdateDefaultVotePolicy { .. } => {
                "policy_update_default_vote_policy"
            }
            ProposalKind::ChangePolicyUpdateParameters { .. } => "policy_update_parameters",
        }
    }
}

/// Votes recorded in the proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Vote {
    Approve = 0x0,
    Reject = 0x1,
    Remove = 0x2,
}

impl From<Action> for Vote {
    fn from(action: Action) -> Self {
        match action {
            Action::VoteApprove => Vote::Approve,
            Action::VoteReject => Vote::Reject,
            Action::VoteRemove => Vote::Remove,
            _ => unreachable!(),
        }
    }
}

/// Proposal that are sent to this DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Proposal {
    /// Original proposer.
    pub proposer: AccountId,
    /// Description of this proposal.
    pub description: String,
    /// Kind of proposal with relevant information.
    pub kind: ProposalKind,
    /// Current status of the proposal.
    pub status: ProposalStatus,
    /// Count of votes per role per decision: yes / no / spam.
    pub vote_counts: HashMap<String, [Balance; 3]>,
    /// Map of who voted and how.
    pub votes: HashMap<AccountId, Vote>,
    /// Submission time (for voting period).
    pub submission_time: U64,
    /// Category of this proposal
    pub category: Option<String>
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum VersionedProposal {
    Default(Proposal),
}

impl From<VersionedProposal> for Proposal {
    fn from(v: VersionedProposal) -> Self {
        match v {
            VersionedProposal::Default(p) => p,
        }
    }
}

impl Proposal {
    /// Adds vote of the given user with given `amount` of weight. If user already voted, fails.
    pub fn update_votes(
        &mut self,
        account_id: &AccountId,
        roles: &[String],
        vote: Vote,
        policy: &Policy,
        user_weight: Balance,
    ) {
        for role in roles {
            let amount = if policy.is_token_weighted(role, &self.kind.to_policy_label().to_string())
            {
                user_weight
            } else {
                1
            };
            self.vote_counts.entry(role.clone()).or_insert([0u128; 3])[vote.clone() as usize] +=
                amount;
        }
        assert!(
            self.votes.insert(account_id.clone(), vote).is_none(),
            "ERR_ALREADY_VOTED"
        );
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalInput {
    /// Description of this proposal.
    pub description: String,
    /// Kind of proposal with relevant information.
    pub kind: ProposalKind,
    /// Category of proposal
    pub category: Option<String>
}

impl From<ProposalInput> for Proposal {
    fn from(input: ProposalInput) -> Self {
        Self {
            proposer: env::predecessor_account_id(),
            description: input.description,
            kind: input.kind,
            status: ProposalStatus::InProgress,
            vote_counts: HashMap::default(),
            votes: HashMap::default(),
            submission_time: U64::from(env::block_timestamp()),
            category: input.category
        }
    }
}

impl Contract {
    /// Execute payout of given token to given user.
    pub(crate) fn internal_payout(
        &mut self,
        token_id: &Option<AccountId>,
        receiver_id: &AccountId,
        amount: Balance,
        memo: String,
        msg: Option<String>,
    ) -> PromiseOrValue<()> {
        if token_id.is_none() {
            Promise::new(receiver_id.clone()).transfer(amount).into()
        } else {
            if let Some(msg) = msg {
                ext_ft_core::ext(token_id.as_ref().unwrap().clone())
                    .with_static_gas(GAS_FOR_FT_TRANSFER)
                    .with_attached_deposit(ONE_YOCTO_NEAR)
                    .ft_transfer_call(
                        receiver_id.clone(),
                        U128(amount),
                        Some(memo),
                        msg
                )
            } else {
                ext_ft_core::ext(token_id.as_ref().unwrap().clone())
                    .with_static_gas(GAS_FOR_FT_TRANSFER)
                    .with_attached_deposit(ONE_YOCTO_NEAR)
                    .ft_transfer(
                        receiver_id.clone(),
                        U128(amount),
                        Some(memo),
                )
            }
            .into()
        }
    }

    pub(crate) fn internal_return_bonds(&mut self, policy: &Policy, proposal: &Proposal) -> Promise {
        match &proposal.kind {
            ProposalKind::BountyDone { .. } => {
                self.locked_amount -= policy.bounty_bond.0;
                Promise::new(proposal.proposer.clone()).transfer(policy.bounty_bond.0);
            }
            _ => {}
        }

        self.locked_amount -= policy.proposal_bond.0;
        Promise::new(proposal.proposer.clone()).transfer(policy.proposal_bond.0)
    }

    /// Executes given proposal and updates the contract's state.
    fn internal_execute_proposal(
        &mut self,
        policy: &Policy,
        proposal: &Proposal,
        proposal_id: u64,
    ) -> PromiseOrValue<()> {
        let result = match &proposal.kind {
            ProposalKind::ChangeConfig { config } => {
                self.config.set(config);
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicy { policy } => {
                self.policy.set(policy);
                PromiseOrValue::Value(())
            }
            ProposalKind::AddMemberToRole { member_id, role } => {
                let mut new_policy = policy.clone();
                new_policy.add_member_to_role(role, &member_id.clone());
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::RemoveMemberFromRole { member_id, role } => {
                let mut new_policy = policy.clone();
                new_policy.remove_member_from_role(role, &member_id.clone());
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::FunctionCall {
                receiver_id,
                actions,
            } => {
                let mut promise = Promise::new(receiver_id.clone());
                for action in actions {
                    promise = promise.function_call(
                        action.method_name.clone(),
                        action.args.clone().into(),
                        action.deposit.0,
                        Gas(action.gas.0),
                    )
                }
                promise.into()
            }
            ProposalKind::UpgradeSelf { hash } => {
                upgrade_using_factory(*hash);
                PromiseOrValue::Value(())
            }
            ProposalKind::UpgradeRemote {
                receiver_id,
                method_name,
                hash,
            } => {
                upgrade_remote(receiver_id, method_name, &CryptoHash::from(*hash));
                PromiseOrValue::Value(())
            }
            ProposalKind::Transfer {
                token_id,
                receiver_id,
                amount,
                msg,
            } => self.internal_payout(
                &convert_old_to_new_token(token_id),
                receiver_id,
                amount.0,
                proposal.description.clone(),
                msg.clone(),
            ),
            ProposalKind::SetStakingContract { staking_id } => {
                assert!(self.staking_id.is_none(), "ERR_INVALID_STAKING_CHANGE");
                self.staking_id = Some(staking_id.clone());
                PromiseOrValue::Value(())
            }
            ProposalKind::AddBounty { bounty } => {
                self.internal_add_bounty(bounty);
                PromiseOrValue::Value(())
            }
            ProposalKind::BountyDone {
                bounty_id,
                receiver_id,
            } => self.internal_execute_bounty_payout(*bounty_id, &receiver_id.clone(), true),
            ProposalKind::Vote => PromiseOrValue::Value(()),
            ProposalKind::FactoryInfoUpdate { factory_info } => {
                internal_set_factory_info(factory_info);
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicyAddOrUpdateRole { role } => {
                let mut new_policy = policy.clone();
                new_policy.add_or_update_role(role);
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicyRemoveRole { role } => {
                let mut new_policy = policy.clone();
                new_policy.remove_role(role);
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicyUpdateDefaultVotePolicy { vote_policy } => {
                let mut new_policy = policy.clone();
                new_policy.update_default_vote_policy(vote_policy);
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
            ProposalKind::ChangePolicyUpdateParameters { parameters } => {
                let mut new_policy = policy.clone();
                new_policy.update_parameters(parameters);
                self.policy.set(&VersionedPolicy::Current(new_policy));
                PromiseOrValue::Value(())
            }
        };
        match result {
            PromiseOrValue::Promise(promise) => promise
                .then(
                    ext_self::ext(env::current_account_id())
                        .with_static_gas(GAS_FOR_FT_TRANSFER)
                        .on_proposal_callback(
                            proposal_id
                    ))
                .into(),
            PromiseOrValue::Value(()) => self.internal_return_bonds(policy, proposal).into(),
        }
    }

    pub(crate) fn internal_callback_proposal_success(
        &mut self,
        proposal: &mut Proposal,
    ) -> PromiseOrValue<()> {
        let policy = self.policy.get().unwrap().to_policy();
        if let ProposalKind::BountyDone { bounty_id, .. } = proposal.kind {
            let mut bounty: Bounty = self.bounties.get(&bounty_id).expect("ERR_NO_BOUNTY").into();
            if bounty.times == 0 {
                self.bounties.remove(&bounty_id);
            } else {
                bounty.times -= 1;
                self.bounties
                    .insert(&bounty_id, &VersionedBounty::Default(bounty));
            }
        }
        proposal.status = ProposalStatus::Approved;
        self.internal_return_bonds(&policy, proposal).into()
    }

    pub(crate) fn internal_callback_proposal_fail(
        &mut self,
        proposal: &mut Proposal,
    ) -> PromiseOrValue<()> {
        proposal.status = ProposalStatus::Failed;
        PromiseOrValue::Value(())
    }

    /// Process rejecting proposal.
    fn internal_reject_proposal(
        &mut self,
        policy: &Policy,
        proposal: &Proposal,
        return_bonds: bool,
    ) -> PromiseOrValue<()> {
        if return_bonds {
            // Return bond to the proposer.
            self.internal_return_bonds(policy, proposal);
        }
        match &proposal.kind {
            ProposalKind::BountyDone {
                bounty_id,
                receiver_id,
            } => {
                self.internal_execute_bounty_payout(*bounty_id, &receiver_id.clone(), false)
            }
            _ => PromiseOrValue::Value(()),
        }
    }

    pub(crate) fn internal_user_info(&self) -> UserInfo {
        let account_id = env::predecessor_account_id();
        UserInfo {
            amount: self.get_user_weight(&account_id),
            account_id,
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Add proposal to this DAO.
    #[payable]
    pub fn add_proposal(&mut self, proposal: ProposalInput) -> u64 {
        if self.status == ContractStatus::Dissolved {
            panic!("Cannot perform this action, dao is dissolved!");
        }
        // 0. validate bond attached.
        // TODO: consider bond in the token of this DAO.
        let policy = self.policy.get().unwrap().to_policy();

        assert_eq!(
            env::attached_deposit(),
            policy.proposal_bond.0,
            "ERR_MIN_BOND"
        );

        // 1. Validate proposal.
        match &proposal.kind {
            ProposalKind::ChangePolicy { policy } => match policy {
                VersionedPolicy::Current(_) => {}
                _ => panic!("ERR_INVALID_POLICY"),
            },
            ProposalKind::Transfer { token_id, msg, .. } => {
                assert!(
                    token_id != OLD_BASE_TOKEN || msg.is_none(),
                    "ERR_BASE_TOKEN_NO_MSG"
                );
            }
            ProposalKind::SetStakingContract { .. } => assert!(
                self.staking_id.is_none(),
                "ERR_STAKING_CONTRACT_CANT_CHANGE"
            ),
            // TODO: add more verifications.
            _ => {}
        };

        // 2. Check permission of caller to add this type of proposal.
        assert!(
            policy
                .can_execute_action(
                    self.internal_user_info(),
                    &proposal.kind,
                    &Action::AddProposal
                )
                .1,
            "ERR_PERMISSION_DENIED"
        );

        // 3. Actually add proposal to the current list of proposals.
        let id = self.last_proposal_id;
        self.proposals
            .insert(&id, &VersionedProposal::Default(proposal.into()));
        self.last_proposal_id += 1;
        self.locked_amount += env::attached_deposit();
        id
    }

    /// Act on given proposal by id, if permissions allow.
    /// Memo is logged but not stored in the state. Can be used to leave notes or explain the action.
    pub fn act_proposal(&mut self, id: u64, action: Action, memo: Option<String>, skip_execution: Option<bool>) {
        if self.status == ContractStatus::Dissolved {
            panic!("Cannot perform this action, dao is dissolved!")
        }
        let execute = !skip_execution.unwrap_or(false);
        let mut proposal: Proposal = self.proposals.get(&id).expect("ERR_NO_PROPOSAL").into();
        let policy = self.policy.get().unwrap().to_policy();
        // Check permissions for the given action.
        let (roles, allowed) =
            policy.can_execute_action(self.internal_user_info(), &proposal.kind, &action);
        assert!(allowed, "ERR_PERMISSION_DENIED");
        let sender_id = env::predecessor_account_id();
        // Update proposal given action. Returns true if should be updated in storage.
        let update = match action {
            Action::AddProposal => env::panic_str("ERR_WRONG_ACTION"),
            Action::RemoveProposal => {
                self.proposals.remove(&id);
                false
            }
            Action::VoteApprove | Action::VoteReject | Action::VoteRemove => {
                assert!(
                    matches!(proposal.status, ProposalStatus::InProgress),
                    "ERR_PROPOSAL_NOT_READY_FOR_VOTE"
                );
                proposal.update_votes(
                    &sender_id,
                    &roles,
                    Vote::from(action),
                    &policy,
                    self.get_user_weight(&sender_id),
                );
                
                // Updates proposal status with new votes using the policy.
                proposal.status =
                    policy.proposal_status(&proposal, roles, self.total_delegation_amount);
                if proposal.status == ProposalStatus::Approved && execute {
                    self.internal_execute_proposal(&policy, &proposal, id);
                    proposal.status = ProposalStatus::Executed;
                    true
                } else if proposal.status == ProposalStatus::Removed {
                    self.internal_reject_proposal(&policy, &proposal, false);
                    self.proposals.remove(&id);
                    false
                } else if proposal.status == ProposalStatus::Rejected {
                    self.internal_reject_proposal(&policy, &proposal, true);
                    true
                } else {
                    // Still in progress or expired.
                    true
                }
            }
            // There are two cases when proposal must be finalized manually: expired or failed.
            // In case of failed, we just recompute the status and if it still approved, we re-execute the proposal.
            // In case of expired, we reject the proposal and return the bond.
            // Corner cases:
            //  - if proposal expired during the failed state - it will be marked as expired.
            //  - if the number of votes in the group has changed (new members has been added) -
            //      the proposal can loose it's approved state. In this case new proposal needs to be made, this one can only expire.
            Action::Finalize => {
                proposal.status = policy.proposal_status(
                    &proposal,
                    policy.roles.iter().map(|r| r.name.clone()).collect(),
                    self.total_delegation_amount,
                );
                match proposal.status {
                    ProposalStatus::Approved => {
                        self.internal_execute_proposal(&policy, &proposal, id);
                        proposal.status = ProposalStatus::Executed;
                    }
                    ProposalStatus::Expired => {
                        self.internal_reject_proposal(&policy, &proposal, true);
                    }
                    _ => {
                        env::panic_str("ERR_PROPOSAL_NOT_EXPIRED_OR_FAILED");
                    }
                }
                true
            }
            Action::MoveToHub => false,
            Action::Execute => {
                require!(proposal.status != ProposalStatus::Executed, "ERR_PROPOSAL_ALREADY_EXECUTED");
                // recompute status to check if the proposal is not expired.
                proposal.status = policy.proposal_status(&proposal, roles, self.total_delegation_amount);
                require!(proposal.status == ProposalStatus::Approved, "ERR_PROPOSAL_NOT_APPROVED");

                self.internal_execute_proposal(&policy, &proposal, id);
                proposal.status = ProposalStatus::Executed;
                true
            },
            Action::VetoProposal => panic!("Operation not allowed"),
            Action::Dissolve => panic!("Operation not allowed"),

        };
        if update {
            self.proposals
                .insert(&id, &VersionedProposal::Default(proposal));
        }
        if let Some(memo) = memo {
            log!("Memo: {}", memo);
        }
    }

    /// Receiving callback after the proposal has been finalized.
    /// If successful, returns bond money to the proposal originator.
    /// If the proposal execution failed (funds didn't transfer or function call failure),
    /// move proposal to "Failed" state.
    #[private]
    pub fn on_proposal_callback(&mut self, proposal_id: u64) -> PromiseOrValue<()> {
        let mut proposal: Proposal = self
            .proposals
            .get(&proposal_id)
            .expect("ERR_NO_PROPOSAL")
            .into();
        assert_eq!(
            env::promise_results_count(),
            1,
            "ERR_UNEXPECTED_CALLBACK_PROMISES"
        );
        let result = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => self.internal_callback_proposal_success(&mut proposal),
            PromiseResult::Failed => self.internal_callback_proposal_fail(&mut proposal),
        };
        self.proposals
            .insert(&proposal_id, &VersionedProposal::Default(proposal));
        result
    }
}

'''
'''--- astra/src/test_utils.rs ---
use near_sdk::AccountId;

pub fn acc_voting_body() -> AccountId {
    AccountId::new_unchecked("votingbody.near".to_string())
}

pub fn council_of_advisors() -> AccountId {
    AccountId::new_unchecked("coa.near".to_string())
}

pub fn ndc_trust() -> AccountId {
    AccountId::new_unchecked("ndctrust.near".to_string())
}

/// creates council member account
pub fn council(i: u32) -> AccountId {
    AccountId::new_unchecked(format!("council-{}.near", i))
}

'''
'''--- astra/src/types.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, Gas};

/// Account ID used for $NEAR in near-sdk v3.
/// Need to keep it around for backward compatibility.
pub const OLD_BASE_TOKEN: &str = "";

/// Account ID that represents a token in near-sdk v3.
/// Need to keep it around for backward compatibility.
pub type OldAccountId = String;

/// 1 yN to prevent access key fraud.
pub const ONE_YOCTO_NEAR: Balance = 1;

/// Gas for single ft_transfer call.
pub const GAS_FOR_FT_TRANSFER: Gas = Gas(10_000_000_000_000);

/// Configuration of the DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// Name of the DAO.
    pub name: String,
    /// Purpose of this DAO.
    pub purpose: String,
    /// Generic metadata. Can be used by specific UI to store additional data.
    /// This is not used by anything in the contract.
    pub metadata: Base64VecU8,
}

#[cfg(test)]
impl Config {
    pub fn test_config() -> Self {
        Self {
            name: "Test".to_string(),
            purpose: "to test".to_string(),
            metadata: Base64VecU8(vec![]),
        }
    }
}

/// Set of possible action to take.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    /// Action to add proposal. Used internally.
    AddProposal,
    /// Action to remove given proposal. Used for immediate deletion in special cases.
    RemoveProposal,
    /// Vote to approve given proposal or bounty.
    VoteApprove,
    /// Vote to reject given proposal or bounty.
    VoteReject,
    /// Vote to remove given proposal or bounty (because it's spam).
    VoteRemove,
    /// Finalize proposal, called when it's expired to return the funds
    /// (or in the future can be used for early proposal closure).
    Finalize,
    /// Move a proposal to the hub to shift into another DAO.
    MoveToHub,
    /// Execute proposal and update proposal status
    Execute,
    /// Veto hook
    VetoProposal,
    /// Dissovle hook
    Dissolve,
}

impl Action {
    pub fn to_policy_label(&self) -> String {
        format!("{:?}", self)
    }
}

/// In near-sdk v3, the token was represented by a String, with no other restrictions.
/// That being said, Astra used "" (empty String) as a convention to represent the $NEAR token.
/// In near-sdk v4, the token representation was replaced by AccountId (which is in fact a wrapper
/// over a String), with the restriction that the token must be between 2 and 64 chars.
/// Astra had to adapt since "" was not allowed anymore and we chose to represent the token as a
/// Option<AccountId> with the convention that None represents the $NEAR token.
/// This function is required to help with the transition and keep the backward compatibility.
pub fn convert_old_to_new_token(old_account_id: &OldAccountId) -> Option<AccountId> {
    if old_account_id == OLD_BASE_TOKEN {
        return None;
    }
    Some(AccountId::new_unchecked(old_account_id.clone()))
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum ContractStatus {
    Active,
    Dissolved
}
'''
'''--- astra/src/upgrade.rs ---
//! Logic to upgrade astra contracts.

use near_sdk::serde_json::json;
use near_sdk::Gas;

use crate::*;

const FACTORY_KEY: &[u8; 7] = b"FACTORY";
const ERR_MUST_BE_SELF_OR_FACTORY: &str = "ERR_MUST_BE_SELF_OR_FACTORY";
const UPDATE_GAS_LEFTOVER: Gas = Gas(10_000_000_000_000);
const FACTORY_UPDATE_GAS_LEFTOVER: Gas = Gas(15_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

pub const GAS_FOR_UPGRADE_SELF_DEPLOY: Gas = Gas(15_000_000_000_000);
pub const GAS_FOR_UPGRADE_REMOTE_DEPLOY: Gas = Gas(15_000_000_000_000);

/// Info about factory that deployed this contract and if auto-update is allowed.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct FactoryInfo {
    pub factory_id: AccountId,
    pub auto_update: bool,
}

pub fn get_default_factory_id() -> AccountId {
    // ex: mydao.astra-dao.near
    let dao_id = env::current_account_id().to_string();
    let idx = dao_id.find('.').expect("INTERNAL_FAIL");
    // ex: astra-dao.near
    let factory_id = &dao_id[idx + 1..];

    AccountId::new_unchecked(String::from(factory_id))
}

/// Fetches factory info from the storage.
/// By design not using contract STATE to allow for upgrade of stuck contracts from factory.
pub(crate) fn internal_get_factory_info() -> FactoryInfo {
    env::storage_read(FACTORY_KEY)
        .map(|value| FactoryInfo::try_from_slice(&value).expect("INTERNAL_FAIL"))
        .unwrap_or_else(|| FactoryInfo {
            factory_id: get_default_factory_id(),
            auto_update: true,
        })
}

pub(crate) fn internal_set_factory_info(factory_info: &FactoryInfo) {
    env::storage_write(
        FACTORY_KEY,
        &factory_info.try_to_vec().expect("INTERNAL_FAIL"),
    );
}

/// Function that receives new contract, updates and calls migration.
/// Two options who call it:
///  - current account, in case of fetching contract code from factory;
///  - factory, if this contract allows to factory-update;
#[no_mangle]
pub fn update() {
    env::setup_panic_hook();

    let factory_info = internal_get_factory_info();
    let current_id = env::current_account_id();
    assert!(
        env::predecessor_account_id() == current_id
            || (env::predecessor_account_id() == factory_info.factory_id
                && factory_info.auto_update),
        "{}",
        ERR_MUST_BE_SELF_OR_FACTORY
    );

    let is_callback = env::predecessor_account_id() == current_id;
    let input;
    if is_callback {
        input = match env::promise_result(0) {
            PromiseResult::Successful(data) => data,
            _ => env::panic_str("ERR_NO_RESULT"),
        };
    } else {
        input = env::input().expect("ERR_NO_INPUT");
    };

    let promise_id = env::promise_batch_create(&current_id);
    // Deploy the contract code.
    env::promise_batch_action_deploy_contract(promise_id, &input);
    // Call promise to migrate the state.
    // Batched together to fail upgrade if migration fails.
    env::promise_batch_action_function_call(
        promise_id,
        "migrate",
        &[],
        NO_DEPOSIT,
        env::prepaid_gas() - env::used_gas() - UPDATE_GAS_LEFTOVER,
    );
    env::promise_return(promise_id);
}

pub(crate) fn upgrade_using_factory(code_hash: Base58CryptoHash) {
    let account_id = get_default_factory_id();
    // Create a promise toward the factory.
    let promise_id = env::promise_batch_create(&account_id);
    // Call `update` method from the factory which calls `update` method on this account.
    env::promise_batch_action_function_call(
        promise_id,
        "update",
        &json!({ "account_id": env::current_account_id(), "code_hash": code_hash })
            .to_string()
            .into_bytes(),
        NO_DEPOSIT,
        env::prepaid_gas() - env::used_gas() - FACTORY_UPDATE_GAS_LEFTOVER,
    );
    env::promise_return(promise_id);
}

#[allow(dead_code)]
pub(crate) fn upgrade_self(hash: &[u8]) {
    let current_id = env::current_account_id();
    let input = env::storage_read(hash).expect("ERR_NO_HASH");
    let promise_id = env::promise_batch_create(&current_id);
    env::promise_batch_action_deploy_contract(promise_id, &input);
    env::promise_batch_action_function_call(
        promise_id,
        "migrate",
        &[],
        NO_DEPOSIT,
        env::prepaid_gas() - env::used_gas() - GAS_FOR_UPGRADE_SELF_DEPLOY,
    );
}

pub(crate) fn upgrade_remote(receiver_id: &AccountId, method_name: &str, hash: &[u8]) {
    let input = env::storage_read(hash).expect("ERR_NO_HASH");
    let promise_id = env::promise_batch_create(receiver_id);
    env::promise_batch_action_function_call(
        promise_id,
        method_name,
        &input,
        NO_DEPOSIT,
        env::prepaid_gas() - env::used_gas() - GAS_FOR_UPGRADE_REMOTE_DEPLOY,
    );
}

'''
'''--- astra/src/views.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use std::cmp::min;

use crate::*;

/// This is format of output via JSON for the proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalOutput {
    /// Id of the proposal.
    pub id: u64,
    #[serde(flatten)]
    pub proposal: Proposal,
}

/// This is format of output via JSON for the bounty.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BountyOutput {
    /// Id of the bounty.
    pub id: u64,
    #[serde(flatten)]
    pub bounty: Bounty,
}

#[near_bindgen]
impl Contract {
    /// Returns semver of this contract.
    pub fn version(&self) -> String {
        env!("CARGO_PKG_VERSION").to_string()
    }

    /// Returns config of this contract.
    pub fn get_config(&self) -> Config {
        self.config.get().unwrap()
    }

    /// Returns policy of this contract.
    pub fn get_policy(&self) -> Policy {
        self.policy.get().unwrap().to_policy()
    }

    /// Returns staking contract if available. Otherwise returns empty.
    pub fn get_staking_contract(self) -> String {
        self.staking_id.map(String::from).unwrap_or_default()
    }

    /// Returns if blob with given hash is stored.
    pub fn has_blob(&self, hash: Base58CryptoHash) -> bool {
        env::storage_has_key(&CryptoHash::from(hash))
    }

    /// Returns locked amount of NEAR that is used for storage.
    pub fn get_locked_storage_amount(&self) -> U128 {
        let locked_storage_amount = env::storage_byte_cost() * (env::storage_usage() as u128);
        U128(locked_storage_amount)
    }

    /// Returns available amount of NEAR that can be spent (outside of amount for storage and bonds).
    pub fn get_available_amount(&self) -> U128 {
        U128(env::account_balance() - self.get_locked_storage_amount().0 - self.locked_amount)
    }

    /// Returns total delegated stake.
    pub fn delegation_total_supply(&self) -> U128 {
        U128(self.total_delegation_amount)
    }

    /// Returns delegated stake to given account.
    pub fn delegation_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.delegations.get(&account_id).unwrap_or_default())
    }

    /// Combines balance and total amount for calling from external contracts.
    pub fn delegation_balance_ratio(&self, account_id: AccountId) -> (U128, U128) {
        (
            self.delegation_balance_of(account_id),
            self.delegation_total_supply(),
        )
    }

    /// Last proposal's id.
    pub fn get_last_proposal_id(&self) -> u64 {
        self.last_proposal_id
    }

    /// Get proposals in paginated view.
    pub fn get_proposals(&self, from_index: u64, limit: u64) -> Vec<ProposalOutput> {
        (from_index..min(self.last_proposal_id, from_index + limit))
            .filter_map(|id| {
                self.proposals.get(&id).map(|proposal| ProposalOutput {
                    id,
                    proposal: proposal.into(),
                })
            })
            .collect()
    }

    /// Get specific proposal.
    pub fn get_proposal(&self, id: u64) -> ProposalOutput {
        let proposal = self.proposals.get(&id).expect("ERR_NO_PROPOSAL");
        ProposalOutput {
            id,
            proposal: proposal.into(),
        }
    }

    /// Get given bounty by id.
    pub fn get_bounty(&self, id: u64) -> BountyOutput {
        let bounty = self.bounties.get(&id).expect("ERR_NO_BOUNTY");
        BountyOutput {
            id,
            bounty: bounty.into(),
        }
    }

    /// Get number of bounties.
    pub fn get_last_bounty_id(&self) -> u64 {
        self.last_bounty_id
    }

    /// Get `limit` of bounties from given index.
    pub fn get_bounties(&self, from_index: u64, limit: u64) -> Vec<BountyOutput> {
        (from_index..std::cmp::min(from_index + limit, self.last_bounty_id))
            .filter_map(|id| {
                self.bounties.get(&id).map(|bounty| BountyOutput {
                    id,
                    bounty: bounty.into(),
                })
            })
            .collect()
    }

    /// Get bounty claims for given user.
    pub fn get_bounty_claims(&self, account_id: AccountId) -> Vec<BountyClaim> {
        self.bounty_claimers.get(&account_id).unwrap_or_default()
    }

    /// Returns number of claims per given bounty.
    pub fn get_bounty_number_of_claims(&self, id: u64) -> u32 {
        self.bounty_claims_count.get(&id).unwrap_or_default()
    }
}

'''
'''--- astra/test.bat ---
:: This script is for Windows.
:: It was auto-generated by near-workspaces-ava,
:: and only runs the tests in the `near-workspaces` folder.
cd tests-ava
npm install
npm run test -- %*
'''
'''--- astra/test.sh ---
#!/bin/bash

# This script is for use with Linux/macOS/Unix.
# It was auto-generated by near-workspaces-ava,
# and only runs the tests in the `near-workspaces` folder.
sh build.sh # to make sure last version is tested
cd tests-ava
npm install
npm run test -- $@ # pass along any CLI flags, such as `--verbose`
'''
'''--- astra/tests-ava/README.md ---
These tests use [near-workspaces-ava](https://github.com/near/workspaces-js/tree/main/packages/ava): delightful, deterministic local testing for NEAR smart contracts.

You will need to install [NodeJS](https://nodejs.dev/). Then you can use the `scripts` defined in [package.json](./package.json):

    npm run test

If you want to run `near-workspaces-ava` or `ava` directly, you can use [npx](https://nodejs.dev/learn/the-npx-nodejs-package-runner):

    npx near-workspaces-ava --help
    npx ava --help

To run only one test file:

    npm run test "**/main*"         # matches test files starting with "main"
    npm run test "**/whatever/**/*" # matches test files in the "whatever" directory

To run only one test:

    npm run test -- -m "root sets*" # matches tests with titles starting with "root sets"
    yarn test -m "root sets*"       # same thing using yarn instead of npm, see https://yarnpkg.com/

If debugging:

    NEAR_WORKSPACES_DEBUG=true npm run test

'''
'''--- astra/tests-ava/__tests__/bounties.ava.ts ---
import {
    Workspace,
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
    ONE_NEAR,
    NEAR,
} from 'near-workspaces-ava';
import {
    workspace,
    initStaking,
    initTestToken,
    STORAGE_PER_BYTE,
} from './utils';
import {
    DEADLINE,
    BOND,
    proposeBounty,
    proposeBountyWithNear,
    voteOnBounty,
    claimBounty,
    doneBounty,
    giveupBounty,
    giveupBountyRaw,
    voteApprove,
} from './utils';

workspace.test('Bounty workflow', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    const proposalId = await proposeBounty(alice, dao, testToken);
    await voteOnBounty(root, dao, proposalId);
    await claimBounty(alice, dao, proposalId);
    const proposal = await dao.view('get_bounty_claims', { account_id: alice });
    test.log('Claims before bounty_done:');
    test.log(await dao.view('get_bounty_claims', { account_id: alice }));
    await doneBounty(alice, alice, dao, proposalId);
    test.log('Claims after bounty_done:');
    test.log(await dao.view('get_bounty_claims', { account_id: alice }));
    test.log('The proposal before act_proposal, voting on the bounty:');
    test.log(await dao.view('get_proposal', { id: proposalId + 1 }));
    await voteOnBounty(root, dao, proposalId + 1);
    test.log('The proposal after act_proposal, voting on the bounty:');
    test.log(await dao.view('get_proposal', { id: proposalId + 1 }));
});

workspace.test('Bounty claim', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    const proposalId = await proposeBounty(alice, dao, testToken);

    //The method could panic if the bounty with given id doesn't exist
    let errorString1 = await captureError(
        async () => await claimBounty(alice, dao, proposalId),
    );
    test.regex(errorString1, /ERR_NO_BOUNTY/);

    await voteOnBounty(root, dao, proposalId);

    //Should panic if `attached_deposit`
    //is not equal to the corresponding `bounty_bond`
    //If we attach more than needed:
    let errorString2_1 = await captureError(
        async () =>
            await alice.call(
                dao,
                'bounty_claim',
                {
                    id: proposalId,
                    deadline: DEADLINE,
                },
                {
                    attachedDeposit: new BN(BOND).addn(1),
                },
            ),
    );
    test.regex(errorString2_1, /ERR_BOUNTY_WRONG_BOND/);
    //If we attach less than needed:
    let errorString2_2 = await captureError(
        async () =>
            await alice.call(
                dao,
                'bounty_claim',
                {
                    id: proposalId,
                    deadline: DEADLINE,
                },
                {
                    attachedDeposit: new BN(BOND).subn(1),
                },
            ),
    );
    test.regex(errorString2_2, /ERR_BOUNTY_WRONG_BOND/);

    //Should panic in case of wrong deadline
    let errorString3 = await captureError(
        async () =>
            await alice.call(
                dao,
                'bounty_claim',
                {
                    id: proposalId,
                    deadline: '1925376849430593582',
                },
                {
                    attachedDeposit: BOND,
                },
            ),
    );
    test.regex(errorString3, /ERR_BOUNTY_WRONG_DEADLINE/);

    await claimBounty(alice, dao, proposalId);

    //Should increase number of claims
    test.is(
        await dao.view('get_bounty_number_of_claims', { id: proposalId }),
        1,
    );

    //Should add this claim to the list of claims, done by this account
    let bounty: any = await dao.view('get_bounty_claims', {
        account_id: alice,
    });
    test.is(bounty[0].bounty_id, 0);
    test.is(bounty[0].deadline, DEADLINE);
    test.is(bounty[0].completed, false);

    await claimBounty(alice, dao, proposalId);
    test.is(
        await dao.view('get_bounty_number_of_claims', { id: proposalId }),
        2,
    );

    let bounty2: any = await dao.view('get_bounty_claims', {
        account_id: alice,
    });
    test.is(bounty2[1].bounty_id, 0);
    test.is(bounty2[1].deadline, DEADLINE);
    test.is(bounty2[1].completed, false);

    await claimBounty(alice, dao, proposalId);
    test.is(
        await dao.view('get_bounty_number_of_claims', { id: proposalId }),
        3,
    );

    //Should panic if all bounties are claimed
    let errorString4 = await captureError(
        async () =>
            await alice.call(
                dao,
                'bounty_claim',
                {
                    id: proposalId,
                    deadline: DEADLINE,
                },
                {
                    attachedDeposit: BOND,
                },
            ),
    );
    test.regex(errorString4, /ERR_BOUNTY_ALL_CLAIMED/);
});

workspace.test(
    'Bounty done with NEAR token',
    async (test, { alice, root, dao }) => {
        const proposalId = await proposeBountyWithNear(alice, dao);

        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);

        const bob = await root.createAccount('bob');
        //Should panic if the caller is not in the list of claimers
        let errorString1 = await captureError(
            async () => await doneBounty(alice, bob, dao, proposalId),
        );
        test.regex(errorString1, /ERR_NO_BOUNTY_CLAIMS/);

        await claimBounty(bob, dao, proposalId);

        //Should panic if the list of claims for the caller of the method
        //doesn't contain the claim with given ID
        let errorString2 = await captureError(
            async () => await doneBounty(alice, alice, dao, proposalId + 10),
        );
        test.regex(errorString2, /ERR_NO_BOUNTY_CLAIM/);

        //`bounty_done` can only be called by the claimer
        let errorString3 = await captureError(
            async () => await doneBounty(alice, bob, dao, proposalId),
        );
        test.regex(errorString3, /ERR_BOUNTY_DONE_MUST_BE_SELF/);

        let bounty: any = await dao.view('get_bounty_claims', {
            account_id: alice,
        });
        test.is(bounty[0].completed, false);

        await doneBounty(alice, alice, dao, proposalId);

        //claim is marked as completed
        bounty = await dao.view('get_bounty_claims', { account_id: alice });
        test.is(bounty[0].completed, true);

        let proposal: any = await dao.view('get_proposal', {
            id: proposalId + 1,
        });
        test.is(proposal.status, 'InProgress');

        await voteOnBounty(root, dao, proposalId + 1);

        //proposal is approved
        proposal = await dao.view('get_proposal', { id: proposalId + 1 });
        test.is(proposal.status, 'Approved');

        //Should panic if the bounty claim is completed
        let errorString4 = await captureError(
            async () => await doneBounty(alice, alice, dao, proposalId),
        );
        test.regex(errorString4, /ERR_NO_BOUNTY_CLAIMS/);
    },
);

workspace.test('Bounty giveup', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    const proposalId = await proposeBounty(alice, dao, testToken);
    await voteOnBounty(root, dao, proposalId);
    await claimBounty(alice, dao, proposalId);

    //Should panic if the caller is not in the list of claimers
    const bob = await root.createAccount('bob');
    let errorString = await captureError(
        async () => await giveupBounty(bob, dao, proposalId),
    );
    test.regex(errorString, /ERR_NO_BOUNTY_CLAIMS/);

    //Should panic if the list of claims for the caller of the method
    //doesn't contain the claim with given ID
    errorString = await captureError(
        async () => await giveupBounty(alice, dao, proposalId + 10),
    );
    test.regex(errorString, /ERR_NO_BOUNTY_CLAIM/);

    //If within forgiveness period, `bounty_bond` should be returned ???
    const balance1: NEAR = (await alice.balance()).total;
    const result = await giveupBountyRaw(alice, dao, proposalId);
    const balance2: NEAR = (await alice.balance()).total;
    test.is(
        Number(balance2.add(result.gas_burnt).toHuman().slice(0, -1)).toFixed(
            1,
        ),
        Number(balance1.add(ONE_NEAR).toHuman().slice(0, -1)).toFixed(1),
    );
    test.not(balance2, balance1);

    //If within forgiveness period,
    //claim should be removed from the list of claims, done by this account
    test.deepEqual(
        await dao.view('get_bounty_claims', { account_id: alice }),
        [],
    );
});

workspace.test('Bounty ft done', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    await dao.call(
        testToken,
        'mint',
        {
            account_id: dao,
            amount: '1000000000',
        },
        {
            gas: tGas(50),
        },
    );
    await alice.call(
        testToken,
        'storage_deposit',
        {
            account_id: alice.accountId,
            registration_only: true,
        },
        {
            attachedDeposit: toYocto('90'),
        },
    );
    const bounty = {
        description: 'test_bounties',
        token: testToken.accountId,
        amount: '10',
        times: 3,
        max_deadline: DEADLINE,
    };
    let proposalId: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'add_new_bounty',
                kind: {
                    AddBounty: {
                        bounty,
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    await voteApprove(root, dao, proposalId);
    let { status } = await dao.view('get_proposal', { id: proposalId });
    test.is(status, 'Approved');
    const bountyId = 0; // first bounty
    await claimBounty(alice, dao, bountyId);
    await alice.call(
        dao,
        'bounty_done',
        {
            id: bountyId,
            account_id: alice.accountId,
            description: 'This bounty is done',
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );

    await voteApprove(root, dao, proposalId + 1);
    ({ status } = await dao.view('get_proposal', { id: proposalId }));
    test.is(status, 'Approved');
});

workspace.test(
    'Callback for BountyDone with NEAR token',
    async (test, { alice, root, dao }) => {
        //During the callback the number bounty_claims_count should decrease
        const proposalId = await proposeBountyWithNear(alice, dao);
        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);
        await doneBounty(alice, alice, dao, proposalId);
        //Before the bounty is done there is 1 claim
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        const balanceBefore: NEAR = (await alice.balance()).total;
        //During the callback this number is decreased
        await voteOnBounty(root, dao, proposalId + 1);
        const balanceAfter: NEAR = (await alice.balance()).total;
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 0);
        test.assert(balanceBefore.lt(balanceAfter));
    },
);

workspace.test(
    'Callback for BountyDone ft token fail',
    async (test, { alice, root, dao }) => {
        //Test the callback with Failed proposal status
        const testTokenFail = await initTestToken(root);
        const proposalIdFail = await proposeBounty(alice, dao, testTokenFail);
        await dao.call(
            testTokenFail,
            'mint',
            {
                account_id: dao,
                amount: '1000000000',
            },
            {
                gas: tGas(50),
            },
        );
        await alice.call(
            testTokenFail,
            'storage_deposit',
            {
                account_id: alice.accountId,
                registration_only: true,
            },
            {
                attachedDeposit: toYocto('90'),
            },
        );
        await voteOnBounty(root, dao, proposalIdFail);
        await claimBounty(alice, dao, proposalIdFail);
        await doneBounty(alice, alice, dao, proposalIdFail);
        await voteOnBounty(root, dao, proposalIdFail + 1);
        //Proposal should be Failed
        let { status } = await dao.view('get_proposal', {
            id: proposalIdFail + 1,
        });
        test.is(status, 'Failed');
    },
);

workspace.test(
    'Callback for BountyDone ft token',
    async (test, { alice, root, dao }) => {
        //Test correct callback
        const testToken = await initTestToken(root);
        await dao.call(
            testToken,
            'mint',
            {
                account_id: dao,
                amount: '1000000000',
            },
            {
                gas: tGas(50),
            },
        );
        await alice.call(
            testToken,
            'storage_deposit',
            {
                account_id: alice.accountId,
                registration_only: true,
            },
            {
                attachedDeposit: toYocto('90'),
            },
        );
        const bounty = {
            description: 'test_bounties',
            token: testToken.accountId,
            amount: '10',
            times: 3,
            max_deadline: DEADLINE,
        };
        let proposalId: number = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'add_new_bounty',
                    kind: {
                        AddBounty: {
                            bounty,
                        },
                    },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);
        await doneBounty(alice, alice, dao, proposalId);
        //Before the bounty is done there is 1 claim
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        const balanceBefore: NEAR = (await alice.balance()).total;
        //During the callback this number is decreased
        await voteOnBounty(root, dao, proposalId + 1);

        //Proposal should be approved
        let { status } = await dao.view('get_proposal', { id: proposalId + 1 });
        test.is(status, 'Approved');

        //During the callback the number bounty_claims_count should decrease
        const balanceAfter: NEAR = (await alice.balance()).total;
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 0);
        test.assert(balanceBefore.lt(balanceAfter));
    },
);

'''
'''--- astra/tests-ava/__tests__/delegation.ava.ts ---
import {
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
} from 'near-workspaces-ava';
import {
    workspace,
    initStaking,
    initTestToken,
    STORAGE_PER_BYTE,
    setStakingId,
    registerAndDelegate,
    regCost,
} from './utils';

workspace.test('Register delegation', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);

    // set staking
    await setStakingId(root, dao, staking);

    await registerAndDelegate(dao, staking, alice, new BN(1));

    // Check that delegation appears in `delegations` LookupMap.
    let bal: BN = new BN(
        await dao.view('delegation_balance_of', { account_id: alice }),
    );
    test.deepEqual(bal, new BN(1));
    const total: BN = new BN(await dao.view('delegation_total_supply'));
    test.deepEqual(total, new BN(1));
});

workspace.test(
    'Register delegation fail',
    async (test, { root, dao, alice }) => {
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);

        // Staking id not set
        let errorString = await captureError(async () =>
            staking.call(
                dao,
                'register_delegation',
                { account_id: alice },
                { attachedDeposit: regCost },
            ),
        );
        test.regex(errorString, /ERR_NO_STAKING/);

        await setStakingId(root, dao, staking);
        // Can only be called by the `staking_id`
        errorString = await captureError(async () =>
            root.call(
                dao,
                'register_delegation',
                { account_id: alice },
                { attachedDeposit: regCost },
            ),
        );
        test.regex(errorString, /ERR_INVALID_CALLER/);

        // Attached deposit is handled correctly
        await captureError(async () =>
            root.call(
                dao,
                'register_delegation',
                { account_id: alice },
                { attachedDeposit: regCost.add(new BN(1)) },
            ),
        );
        await captureError(async () =>
            root.call(
                dao,
                'register_delegation',
                { account_id: alice },
                { attachedDeposit: regCost.sub(new BN(1)) },
            ),
        );
    },
);

workspace.test('Delegation', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);
    const randomAmount = new BN('10087687667869');
    const bob = await root.createAccount('bob');

    // set staking
    await setStakingId(root, dao, staking);

    let result = await registerAndDelegate(dao, staking, alice, randomAmount);
    test.deepEqual(
        [new BN(result[0]), new BN(result[1]), new BN(result[2])],
        [new BN('0'), randomAmount, randomAmount],
    );
    result = await registerAndDelegate(dao, staking, bob, randomAmount.muln(2));
    test.deepEqual(
        [new BN(result[0]), new BN(result[1]), new BN(result[2])],
        [new BN('0'), randomAmount.muln(2), randomAmount.muln(3)],
    );
    test.deepEqual(
        new BN(await dao.view('delegation_balance_of', { account_id: alice })),
        randomAmount,
    );
    test.deepEqual(
        new BN(await dao.view('delegation_balance_of', { account_id: bob })),
        randomAmount.muln(2),
    );
    test.deepEqual(
        new BN(await dao.view('delegation_total_supply')),
        randomAmount.muln(3),
    );
});

workspace.test('Delegation fail', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);
    const randomAmount = new BN('10087687667869');

    // Should panic if `staking_id` is `None`
    let errorString = await captureError(async () =>
        staking.call(dao, 'delegate', {
            account_id: alice,
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_NO_STAKING/);

    // set staking
    await setStakingId(root, dao, staking);

    // Check that it can only be called by the `staking_id`
    errorString = await captureError(async () =>
        root.call(dao, 'delegate', {
            account_id: alice,
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_INVALID_CALLER/);

    // Can't be called without previos registration
    errorString = await captureError(async () =>
        staking.call(dao, 'delegate', {
            account_id: 'not-registered-account.bob',
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_NOT_REGISTERED/);
});

workspace.test('Undelegate', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);
    const randomAmount = new BN('44887687667868');

    // set staking
    await setStakingId(root, dao, staking);

    await registerAndDelegate(dao, staking, alice, randomAmount);

    // Check that amount is subtracted correctly
    const result: string[3] = await staking.call(dao, 'undelegate', {
        account_id: alice,
        amount: randomAmount.divn(2).toString(),
    });
    test.deepEqual(
        [new BN(result[0]), new BN(result[1]), new BN(result[2])],
        [randomAmount, randomAmount.divn(2), randomAmount.divn(2)],
    );
});

workspace.test('Undelegate fail', async (test, { root, dao, alice }) => {
    const testToken = await initTestToken(root);
    const staking = await initStaking(root, dao, testToken);
    const randomAmount = new BN('44887687667868');

    // Should panic if `staking_id` is `None`
    let errorString = await captureError(async () =>
        staking.call(dao, 'undelegate', {
            account_id: alice,
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_NO_STAKING/);

    // Set staking
    await setStakingId(root, dao, staking);

    // Check that it can only be called by the `staking_id`
    errorString = await captureError(async () =>
        root.call(dao, 'undelegate', {
            account_id: alice,
            amount: randomAmount,
        }),
    );
    test.regex(errorString, /ERR_INVALID_CALLER/);

    await registerAndDelegate(dao, staking, alice, randomAmount);
    // Check that a user can't remove more than it delegated
    errorString = await captureError(async () =>
        staking.call(dao, 'undelegate', {
            account_id: alice,
            amount: randomAmount.addn(1).toString(),
        }),
    );
    test.regex(errorString, /ERR_INVALID_STAKING_CONTRACT/);
});

'''
'''--- astra/tests-ava/__tests__/lib.ava.ts ---
import {
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
    DEFAULT_FUNCTION_CALL_GAS,
    Gas,
    NEAR,
} from 'near-workspaces-ava';
import {
    workspace,
    initStaking,
    initTestToken,
    STORAGE_PER_BYTE,
    workspaceWithoutInit,
    workspaceWithFactory,
} from './utils';
import { voteApprove } from './utils';
import {
    DEADLINE,
    BOND,
    proposeBounty,
    proposeBountyWithNear,
    voteOnBounty,
    claimBounty,
    doneBounty,
} from './utils';
import * as fs from 'fs';

const DAO_WASM_BYTES: Uint8Array = fs.readFileSync('../../res/astra.wasm');

workspaceWithFactory.test(
    'Upgrade self using factory',
    async (test, { root, factory }) => {
        const config = {
            name: 'testdao',
            purpose: 'to test',
            metadata: '',
        };
        const policy = [root.accountId];
        const params = {
            config,
            policy,
        };

        await root.call(
            factory,
            'create',
            {
                name: 'testdao',
                args: Buffer.from(JSON.stringify(params)).toString('base64'),
            },
            {
                attachedDeposit: toYocto('10'),
                gas: tGas(300),
            },
        );

        test.deepEqual(await factory.view('get_dao_list', {}), [
            'testdao.factory.test.near',
        ]);
        const hash = await factory.view('get_default_code_hash', {});

        const proposalId: number = await root.call(
            'testdao.factory.test.near',
            'add_proposal',
            {
                proposal: {
                    description: 'proposal to test',
                    kind: {
                        UpgradeSelf: {
                            hash: hash,
                        },
                    },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        test.is(proposalId, 0);

        await root.call(
            'testdao.factory.test.near',
            'act_proposal',
            {
                id: proposalId,
                action: 'VoteApprove',
            },
            {
                gas: tGas(300),
            },
        );
    },
);

workspaceWithoutInit.test(
    'Upgrade self negative',
    async (test, { root, dao }) => {
        const config = { name: 'astra', purpose: 'testing', metadata: '' };

        // NOT INITIALIZED
        let err = await captureError(async () =>
            root.call(dao, 'store_blob', DAO_WASM_BYTES, {
                attachedDeposit: toYocto('200'),
                gas: tGas(300),
            }),
        );
        test.regex(err, /ERR_CONTRACT_IS_NOT_INITIALIZED/);

        // Initializing contract
        await root.call(dao, 'new', { config, policy: [root.accountId] });

        // not enough deposit
        err = await captureError(async () =>
            root.call(dao, 'store_blob', DAO_WASM_BYTES, {
                attachedDeposit: toYocto('1'),
                gas: tGas(300),
            }),
        );
        test.regex(err, /ERR_NOT_ENOUGH_DEPOSIT/);

        await root.call(dao, 'store_blob', DAO_WASM_BYTES, {
            attachedDeposit: toYocto('200'),
            gas: tGas(300),
        });

        // Already exists
        err = await captureError(async () =>
            root.call(dao, 'store_blob', DAO_WASM_BYTES, {
                attachedDeposit: toYocto('200'),
                gas: tGas(300),
            }),
        );
        test.regex(err, /ERR_ALREADY_EXISTS/);
    },
);

workspace.test('Remove blob', async (test, { root, dao, alice }) => {
    const hash: String = await root.call(dao, 'store_blob', DAO_WASM_BYTES, {
        attachedDeposit: toYocto('200'),
        gas: tGas(300),
    });

    // fails if hash is wrong
    let err = await captureError(async () =>
        root.call(dao, 'remove_blob', {
            hash: 'HLBiX51txizmQzZJMrHMCq4u7iEEqNbaJppZ84yW7628', // some_random hash
        }),
    );
    test.regex(err, /ERR_NO_BLOB/);

    // Can only be called by the original storer
    err = await captureError(async () =>
        alice.call(dao, 'remove_blob', {
            hash: hash,
        }),
    );
    test.regex(err, /ERR_INVALID_CALLER/);

    // blob is removed with payback
    const rootAmountBeforeRemove = (await root.balance()).total;
    await root.call(dao, 'remove_blob', {
        hash: hash,
    });
    const rootAmountAfterRemove = (await root.balance()).total;
    test.false(await dao.view('has_blob', { hash: hash }));
    test.assert(rootAmountAfterRemove.gt(rootAmountBeforeRemove));
});

workspace.test(
    'Callback for BountyDone with NEAR token',
    async (test, { alice, root, dao }) => {
        //During the callback the number bounty_claims_count should decrease
        const proposalId = await proposeBountyWithNear(alice, dao);
        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);
        await doneBounty(alice, alice, dao, proposalId);
        //Before the bounty is done there is 1 claim
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        const balanceBefore: NEAR = (await alice.balance()).total;
        //During the callback this number is decreased
        await voteOnBounty(root, dao, proposalId + 1);
        const balanceAfter: NEAR = (await alice.balance()).total;
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 0);
        test.assert(balanceBefore.lt(balanceAfter));
    },
);

workspace.test(
    'Callback for BountyDone ft token fail',
    async (test, { alice, root, dao }) => {
        //Test the callback with Failed proposal status
        const testTokenFail = await initTestToken(root);
        const proposalIdFail = await proposeBounty(alice, dao, testTokenFail);
        await dao.call(
            testTokenFail,
            'mint',
            {
                account_id: dao,
                amount: '1000000000',
            },
            {
                gas: tGas(50),
            },
        );
        await alice.call(
            testTokenFail,
            'storage_deposit',
            {
                account_id: alice.accountId,
                registration_only: true,
            },
            {
                attachedDeposit: toYocto('90'),
            },
        );
        await voteOnBounty(root, dao, proposalIdFail);
        await claimBounty(alice, dao, proposalIdFail);
        await doneBounty(alice, alice, dao, proposalIdFail);
        await voteOnBounty(root, dao, proposalIdFail + 1);
        //Proposal should be Failed
        let { status } = await dao.view('get_proposal', {
            id: proposalIdFail + 1,
        });
        test.is(status, 'Failed');
    },
);

workspace.test(
    'Callback for BountyDone ft token',
    async (test, { alice, root, dao }) => {
        //Test correct callback
        const testToken = await initTestToken(root);
        await dao.call(
            testToken,
            'mint',
            {
                account_id: dao,
                amount: '1000000000',
            },
            {
                gas: tGas(50),
            },
        );
        await alice.call(
            testToken,
            'storage_deposit',
            {
                account_id: alice.accountId,
                registration_only: true,
            },
            {
                attachedDeposit: toYocto('90'),
            },
        );
        const bounty = {
            description: 'test_bounties',
            token: testToken.accountId,
            amount: '10',
            times: 3,
            max_deadline: DEADLINE,
        };
        let proposalId: number = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'add_new_bounty',
                    kind: {
                        AddBounty: {
                            bounty,
                        },
                    },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        await voteOnBounty(root, dao, proposalId);
        await claimBounty(alice, dao, proposalId);
        await doneBounty(alice, alice, dao, proposalId);
        //Before the bounty is done there is 1 claim
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        const balanceBefore: NEAR = (await alice.balance()).total;
        //During the callback this number is decreased
        await voteOnBounty(root, dao, proposalId + 1);

        //Proposal should be approved
        let { status } = await dao.view('get_proposal', { id: proposalId + 1 });
        test.is(status, 'Approved');

        //During the callback the number bounty_claims_count should decrease
        const balanceAfter: NEAR = (await alice.balance()).total;
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 0);
        test.assert(balanceBefore.lt(balanceAfter));
    },
);

workspace.test('Callback transfer', async (test, { alice, root, dao }) => {
    const user1 = await root.createAccount('user1');
    // Fail transfer by transfering to non-existent accountId
    let transferId: number = await user1.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: 'broken_id',
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    let user1Balance = (await user1.balance()).total;
    await voteApprove(root, dao, transferId);
    let { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Failed');
    test.assert((await user1.balance()).total.eq(user1Balance)); // no bond returns on fail

    // now we transfer to real accountId
    transferId = await user1.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: alice.accountId, // valid id this time
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    user1Balance = (await user1.balance()).total;
    await voteApprove(root, dao, transferId);
    ({ status } = await dao.view('get_proposal', { id: transferId }));
    test.is(status, 'Approved');
    test.assert((await user1.balance()).total.gt(user1Balance)); // returns bond
});

workspace.test('Callback function call', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    let transferId: number = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    FunctionCall: {
                        receiver_id: testToken.accountId,
                        actions: [
                            {
                                method_name: 'fail',
                                args: Buffer.from('bad args').toString(
                                    'base64',
                                ),
                                deposit: toYocto('1'),
                                gas: tGas(10),
                            },
                        ],
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    await root.call(
        dao,
        'act_proposal',
        {
            id: transferId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(200),
        },
    );
    let { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Failed');

    transferId = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    FunctionCall: {
                        receiver_id: testToken.accountId,
                        actions: [
                            {
                                method_name: 'mint',
                                args: Buffer.from(
                                    '{"account_id": "' +
                                        alice.accountId +
                                        '", "amount": "10"}',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(10),
                            },
                            {
                                method_name: 'burn',
                                args: Buffer.from(
                                    '{"account_id": "' +
                                        alice.accountId +
                                        '", "amount": "10"}',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(10),
                            },
                        ],
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    await root.call(
        dao,
        'act_proposal',
        {
            id: transferId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(200),
        },
    );
    ({ status } = await dao.view('get_proposal', { id: transferId }));
    test.is(status, 'Approved');
});

'''
'''--- astra/tests-ava/__tests__/policy.ava.ts ---
import {
    Workspace,
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
    DEFAULT_FUNCTION_CALL_GAS,
} from 'near-workspaces-ava';
import {
    initStaking,
    initTestToken,
    STORAGE_PER_BYTE,
    registerAndDelegate,
    setStakingId,
    workspaceWithoutInit as workspace,
} from './utils';

workspace.test(
    'Testing policy TokenWeight',
    async (test, { alice, root, dao }) => {
        const config = { name: 'astra', purpose: 'testing', metadata: '' };
        const bob = await root.createAccount('bob');
        const period = new BN('1000000000')
            .muln(60)
            .muln(60)
            .muln(24)
            .muln(7)
            .toString();
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);
        await root.call(dao, 'new', { config, policy: [root.accountId] });
        await setStakingId(root, dao, staking);

        const policy = {
            roles: [
                {
                    name: 'all',
                    kind: { Group: [alice.accountId, bob.accountId] }, // fails with kind: "Everyone" need to investigate
                    permissions: ['*:AddProposal', '*:VoteApprove'],
                    vote_policy: {},
                },
            ],
            default_vote_policy: {
                weight_kind: 'TokenWeight',
                quorum: new BN('1').toString(),
                threshold: '5',
            },
            proposal_bond: toYocto('1'),
            proposal_period: period,
            bounty_bond: toYocto('1'),
            bounty_forgiveness_period: period,
        };

        let proposalId: number = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'test',
                    kind: { ChangePolicy: { policy } },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        await root.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteApprove',
        });

        // Setting up a new config
        const new_config = {
            name: 'new dao wohoo',
            purpose: 'testing',
            metadata: '',
        };
        await registerAndDelegate(dao, staking, alice, new BN('1'));
        await registerAndDelegate(dao, staking, bob, new BN('4'));
        proposalId = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'test',
                    kind: {
                        ChangeConfig: {
                            config: new_config,
                        },
                    },
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        await alice.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteApprove',
        });
        await bob.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteApprove',
        });
        test.deepEqual(await dao.view('get_config'), new_config);
    },
);

workspace.test('Policy self-lock', async (test, { alice, root, dao }) => {
    const config = { name: 'astra', purpose: 'testing', metadata: '' };
    const period = new BN('1000000000')
        .muln(60)
        .muln(60)
        .muln(24)
        .muln(7)
        .toString();
    const policy = {
        roles: [
            {
                name: 'all',
                kind: { Group: [alice.accountId] },
                permissions: ['*:AddProposal', '*:VoteApprove'],
                vote_policy: {},
            },
        ],
        default_vote_policy: {
            weight_kind: 'TokenWeight',
            quorum: new BN('1').toString(),
            threshold: '5',
        },
        proposal_bond: toYocto('1'),
        proposal_period: period,
        bounty_bond: toYocto('1'),
        bounty_forgiveness_period: period,
    };
    // 'staking_id' is not set, we can't delegate, so this contract got locked
    await root.call(dao, 'new', { config, policy });
    const proposalId = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'test',
                kind: {
                    ChangePolicy: {
                        policy,
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    await alice.call(dao, 'act_proposal', {
        id: proposalId,
        action: 'VoteApprove',
    });
    let { status } = await dao.view('get_proposal', { id: proposalId });
    test.is(status, 'InProgress');
});

'''
'''--- astra/tests-ava/__tests__/proposals.ava.ts ---
import {
    toYocto,
    NearAccount,
    captureError,
    BN,
    NEAR,
    ONE_NEAR,
    tGas,
} from 'near-workspaces-ava';

import {
    workspace,
    initTestToken,
    initStaking,
    setStakingId,
    workspaceWithoutInit,
    voteApprove,
} from './utils';

workspace.test('basic', async (test, { alice, root, dao }) => {
    test.true(await alice.exists());
    test.true(await root.exists());
    test.true(await dao.exists());
    test.log(await dao.view('get_config'));
});

workspace.test(
    'add_proposal fails in case of insufficient deposit',
    async (test, { alice, root, dao }) => {
        test.is(await dao.view('get_last_proposal_id'), 0);
        const config = {
            name: 'astra',
            purpose: 'testing',
            metadata: '',
        };
        //Try adding a proposal with 0.999... near
        let err = await captureError(
            async () =>
                await alice.call(
                    dao,
                    'add_proposal',
                    {
                        proposal: {
                            description: 'rename the dao',
                            kind: {
                                ChangeConfig: {
                                    config,
                                },
                            },
                        },
                    },
                    { attachedDeposit: new BN(toYocto('1')).subn(1) },
                ),
        );

        test.log(err.toString());
        test.true(err.includes('ERR_MIN_BOND'));
        //the proposal did not count
        test.is(await dao.view('get_last_proposal_id'), 0);

        //Checks that the same proposal doesn't fail
        //if the deposit is at least 1 near
        await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );
        test.is(await dao.view('get_last_proposal_id'), 1);

        let new_proposal: any = await dao.view('get_proposal', { id: 0 });

        test.log(new_proposal);
        test.is(new_proposal.description, 'rename the dao');
        test.is(new_proposal.proposer, 'alice.test.near');
        test.is(new_proposal.status, 'InProgress');

        test.truthy(new_proposal.kind.ChangeConfig);
        test.is(new_proposal.kind.ChangeConfig.config.name, 'astra');
        //same config as we did not execute that proposal
        test.deepEqual(await dao.view('get_config'), {
            name: 'astra',
            purpose: 'testing',
            metadata: '',
        });
    },
);

workspace.test(
    'Bob can not add proposals',
    async (test, { alice, root, dao }) => {
        const bob = await root.createAccount('bob');

        //First we change a policy so that Bob can't add proposals
        const period = new BN('1000000000')
            .muln(60)
            .muln(60)
            .muln(24)
            .muln(7)
            .toString();
        const newPolicy = {
            roles: [
                {
                    name: 'all',
                    kind: {
                        Group: [root.accountId, alice.accountId],
                    },
                    permissions: ['*:VoteApprove', '*:AddProposal'],
                    vote_policy: {},
                },
            ],
            default_vote_policy: {
                weight_kind: 'TokenWeight',
                quorum: new BN('1').toString(),
                threshold: '5',
            },
            proposal_bond: toYocto('1'),
            proposal_period: period,
            bounty_bond: toYocto('1'),
            bounty_forgiveness_period: period,
        };
        let id: number = await bob.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description:
                        'change to a new policy, so that bob can not add a proposal',
                    kind: {
                        ChangePolicy: {
                            policy: newPolicy,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );
        await voteApprove(root, dao, id);

        //Chrck that only those with a permission can add the proposal
        let errorString = await captureError(
            async () =>
                await bob.call(
                    dao,
                    'add_proposal',
                    {
                        proposal: {
                            description: 'change to a new policy',
                            kind: {
                                ChangePolicy: {
                                    policy: newPolicy,
                                },
                            },
                        },
                    },
                    { attachedDeposit: toYocto('1') },
                ),
        );
        test.regex(errorString, /ERR_PERMISSION_DENIED/);
    },
);

workspace.test('Proposal ChangePolicy', async (test, { alice, root, dao }) => {
    test.deepEqual(
        await dao.view('get_proposals', { from_index: 0, limit: 10 }),
        [],
    );

    //Check that we can't change policy to a policy unless it's VersionedPolicy::Current
    let policy = [root.accountId];
    let errorString = await captureError(
        async () =>
            await alice.call(
                dao,
                'add_proposal',
                {
                    proposal: {
                        description: 'change the policy',
                        kind: {
                            ChangePolicy: {
                                policy,
                            },
                        },
                    },
                },
                { attachedDeposit: toYocto('1') },
            ),
    );
    test.regex(errorString, /ERR_INVALID_POLICY/);

    //Check that we can change to a correct policy
    const period = new BN('1000000000')
        .muln(60)
        .muln(60)
        .muln(24)
        .muln(7)
        .toString();
    const correctPolicy = {
        roles: [
            {
                name: 'all',
                kind: {
                    Group: [root.accountId, alice.accountId],
                },
                permissions: ['*:VoteApprove', '*:AddProposal'],
                vote_policy: {},
            },
        ],
        default_vote_policy: {
            weight_kind: 'TokenWeight',
            quorum: new BN('1').toString(),
            threshold: '5',
        },
        proposal_bond: toYocto('1'),
        proposal_period: period,
        bounty_bond: toYocto('1'),
        bounty_forgiveness_period: period,
    };
    let id: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'change to a new correct policy',
                kind: {
                    ChangePolicy: {
                        policy: correctPolicy,
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );

    //Number of proposals = 1
    test.is(await dao.view('get_last_proposal_id'), 1);
    //Check that the proposal is added to the list of proposals
    let proposals = await dao.view('get_proposals', {
        from_index: 0,
        limit: 10,
    });
    let realProposal = {
        id: 0,
        proposer: alice.accountId,
        description: 'change to a new correct policy',
        kind: { ChangePolicy: { policy: correctPolicy } },
        status: 'InProgress',
        vote_counts: {},
        votes: {},
    };
    test.is(proposals[0].id, realProposal.id);
    test.is(proposals[0].proposer, realProposal.proposer);
    test.is(proposals[0].description, realProposal.description);
    test.is(proposals[0].status, realProposal.status);
    test.deepEqual(proposals[0].vote_counts, realProposal.vote_counts);
    test.deepEqual(proposals[0].votes, realProposal.votes);
    test.deepEqual(proposals[0].kind, realProposal.kind);

    //After voting on the proposal it is Approved
    await voteApprove(root, dao, id);

    test.deepEqual(
        (await dao.view('get_proposals', { from_index: 0, limit: 10 }))[0]
            .vote_counts,
        { council: [1, 0, 0] },
    );
    test.is(
        (await dao.view('get_proposals', { from_index: 0, limit: 10 }))[0]
            .status,
        'Approved',
    );

    //Check that the policy is changed
    test.deepEqual(await dao.view('get_policy'), correctPolicy);
});

workspace.test('Proposal Transfer', async (test, { alice, root, dao }) => {
    let errorString = await captureError(
        async () =>
            await root.call(
                dao,
                'add_proposal',
                {
                    proposal: {
                        description:
                            'can not use transfer without wrong token_id and msg',
                        kind: {
                            Transfer: {
                                token_id: '',
                                receiver_id: alice.accountId,
                                amount: toYocto('1'),
                                msg: 'some msg',
                            },
                        },
                    },
                },
                {
                    attachedDeposit: toYocto('1'),
                },
            ),
    );
    test.regex(errorString, /ERR_BASE_TOKEN_NO_MSG/);

    const transferId: number = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'transfer 1 yocto',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: alice,
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    const initBalance: NEAR = (await alice.balance()).total;
    await voteApprove(root, dao, transferId);
    const balance: NEAR = (await alice.balance()).total;
    test.deepEqual(balance, initBalance.add(ONE_NEAR));
});

workspace.test(
    'Proposal SetStakingContract',
    async (test, { alice, root, dao }) => {
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);
        await setStakingId(root, dao, staking);

        test.is(await dao.view('get_staking_contract'), staking.accountId);

        let errorString = await captureError(
            async () => await setStakingId(root, dao, staking),
        );
        test.regex(errorString, /ERR_STAKING_CONTRACT_CANT_CHANGE/);
    },
);

workspace.test(
    'Voting is only allowed for councils',
    async (test, { alice, root, dao }) => {
        const config = {
            name: 'astra',
            purpose: 'testing',
            metadata: '',
        };
        //add_proposal returns new proposal id
        const id: number = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        //Check that voting is not allowed for non councils
        //Here alice tries to vote for her proposal but she is not a council and has no permission to vote.
        const err = await captureError(
            async () => await voteApprove(alice, dao, id),
        );
        test.log(err);
        test.true(err.includes('ERR_PERMISSION_DENIED'));

        let proposal: any = await dao.view('get_proposal', { id });
        test.log(proposal);
        test.is(proposal.status, 'InProgress');

        //Check that voting is allowed for councils
        //council (root) votes on alice's promise
        const res = await voteApprove(root, dao, id);
        proposal = await dao.view('get_proposal', { id });
        test.log(res);
        test.log(proposal);
        test.is(proposal.status, 'Approved');

        // proposal approved so now the config is equal to what alice did propose
        test.deepEqual(await dao.view('get_config'), config);
    },
);

// If the number of votes in the group has changed (new members has been added)
//  the proposal can lose it's approved state.
//  In this case new proposal needs to be made, this one should expire
workspace.test(
    'Proposal group changed during voting',
    async (test, { alice, root, dao }) => {
        const transferId: number = await root.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'give me tokens',
                    kind: {
                        Transfer: {
                            token_id: '',
                            receiver_id: alice,
                            amount: toYocto('1'),
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        const addMemberToRoleId: number = await root.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'add alice',
                    kind: {
                        AddMemberToRole: {
                            member_id: alice,
                            role: 'council',
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );
        await voteApprove(root, dao, addMemberToRoleId);
        await voteApprove(root, dao, transferId);
        const { status } = await dao.view('get_proposal', { id: transferId });
        test.is(status, 'InProgress');
    },
);

workspaceWithoutInit.test(
    'Proposal action types',
    async (test, { alice, root, dao }) => {
        const user1 = await root.createAccount('user1');
        const user2 = await root.createAccount('user2');
        const user3 = await root.createAccount('user3');
        const period = new BN('1000000000')
            .muln(60)
            .muln(60)
            .muln(24)
            .muln(7)
            .toString();
        const policy = {
            roles: [
                {
                    name: 'council',
                    kind: {
                        Group: [
                            alice.accountId,
                            user1.accountId,
                            user2.accountId,
                            user3.accountId,
                        ],
                    },
                    permissions: ['*:*'],
                    vote_policy: {},
                },
            ],
            default_vote_policy: {
                weight_kind: 'RoleWeight',
                quorum: new BN('0').toString(),
                threshold: [1, 2],
            },
            proposal_bond: toYocto('1'),
            proposal_period: period,
            bounty_bond: toYocto('1'),
            bounty_forgiveness_period: period,
        };

        let config = { name: 'astra', purpose: 'testing', metadata: '' };

        await root.call(dao, 'new', { config, policy });

        let proposalId = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        // Remove proposal works
        await alice.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'RemoveProposal',
        });
        let err = await captureError(async () =>
            dao.view('get_proposal', { id: proposalId }),
        );
        test.regex(err, /ERR_NO_PROPOSAL/);

        err = await captureError(async () =>
            alice.call(dao, 'act_proposal', {
                id: proposalId,
                action: 'VoteApprove',
            }),
        );
        test.regex(err, /ERR_NO_PROPOSAL/);

        proposalId = await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        err = await captureError(async () =>
            alice.call(dao, 'act_proposal', {
                id: proposalId,
                action: 'AddProposal',
            }),
        );
        test.regex(err, /ERR_WRONG_ACTION/);

        // Check if every vote counts
        await user1.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteApprove',
        });
        await user2.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteReject',
        });
        await alice.call(dao, 'act_proposal', {
            id: proposalId,
            action: 'VoteRemove',
        });
        {
            const { vote_counts, votes } = await dao.view('get_proposal', {
                id: proposalId,
            });
            test.deepEqual(vote_counts.council, [1, 1, 1]);
            test.deepEqual(votes, {
                [alice.accountId]: 'Remove',
                [user1.accountId]: 'Approve',
                [user2.accountId]: 'Reject',
            });
        }

        // Finalize proposal will panic if not exired or failed
        err = await captureError(async () =>
            alice.call(dao, 'act_proposal', {
                id: proposalId,
                action: 'Finalize',
            }),
        );
        test.regex(err, /ERR_PROPOSAL_NOT_EXPIRED_OR_FAILED/);
    },
);

workspace.test('Proposal transfer ft', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    await dao.call(
        testToken,
        'mint',
        {
            account_id: dao,
            amount: '1000000000',
        },
        {
            gas: tGas(50),
        },
    );
    await alice.call(
        testToken,
        'storage_deposit',
        {
            account_id: alice.accountId,
            registration_only: true,
        },
        {
            attachedDeposit: toYocto('90'),
        },
    );
    const transferId: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'transfer tokens to me',
                kind: {
                    Transfer: {
                        token_id: testToken.accountId,
                        receiver_id: alice.accountId,
                        amount: '10',
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    await voteApprove(root, dao, transferId);
    const { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Approved');
});

workspace.test('Callback transfer', async (test, { alice, root, dao }) => {
    const user1 = await root.createAccount('user1');
    // Fail transfer by transfering to non-existent accountId
    let transferId: number = await user1.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: 'broken_id',
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    let user1Balance = (await user1.balance()).total;
    await voteApprove(root, dao, transferId);
    let { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Failed');
    test.assert((await user1.balance()).total.eq(user1Balance)); // no bond returns on fail

    // now we transfer to real accountId
    transferId = await user1.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    Transfer: {
                        token_id: '',
                        receiver_id: alice.accountId, // valid id this time
                        amount: toYocto('1'),
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    user1Balance = (await user1.balance()).total;
    await voteApprove(root, dao, transferId);
    ({ status } = await dao.view('get_proposal', { id: transferId }));
    test.is(status, 'Approved');
    test.assert((await user1.balance()).total.gt(user1Balance)); // returns bond
});

workspace.test('Callback function call', async (test, { alice, root, dao }) => {
    const testToken = await initTestToken(root);
    let transferId: number = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    FunctionCall: {
                        receiver_id: testToken.accountId,
                        actions: [
                            {
                                method_name: 'fail',
                                args: Buffer.from('bad args').toString(
                                    'base64',
                                ),
                                deposit: toYocto('1'),
                                gas: tGas(10),
                            },
                        ],
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    await root.call(
        dao,
        'act_proposal',
        {
            id: transferId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(200),
        },
    );
    let { status } = await dao.view('get_proposal', { id: transferId });
    test.is(status, 'Failed');

    transferId = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'give me tokens',
                kind: {
                    FunctionCall: {
                        receiver_id: testToken.accountId,
                        actions: [
                            {
                                method_name: 'mint',
                                args: Buffer.from(
                                    '{"account_id": "' +
                                        alice.accountId +
                                        '", "amount": "10"}',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(10),
                            },
                            {
                                method_name: 'burn',
                                args: Buffer.from(
                                    '{"account_id": "' +
                                        alice.accountId +
                                        '", "amount": "10"}',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(10),
                            },
                        ],
                    },
                },
            },
        },
        { attachedDeposit: toYocto('1') },
    );
    await root.call(
        dao,
        'act_proposal',
        {
            id: transferId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(200),
        },
    );
    ({ status } = await dao.view('get_proposal', { id: transferId }));
    test.is(status, 'Approved');
});

'''
'''--- astra/tests-ava/__tests__/upgrade.ava.ts ---
import { toYocto, tGas } from 'near-workspaces-ava';

import { workspaceWithFactory } from './utils';

// DAO v2 Upgrade flow:
// 1. add proposal for store_contract_self(get it approved)
// 2. add proposal for UpgradeSelf with hash of blob from #1(get it approved)
// 3. add proposal for remove_contract_self(get it approved)
// 4. Confirm DAO contract code_hash and returned balance

workspaceWithFactory.test('basic', async (test, { root, factory }) => {
    test.true(await root.exists());
    test.true(await factory.exists());
});

workspaceWithFactory.test(
    'Store DAO upgrade code in DAO via factory',
    async (test, { root, factory }) => {
        const config = {
            name: 'upgradedao',
            purpose: 'to test',
            metadata: '',
        };
        const policy = [root.accountId];
        const params = {
            config,
            policy,
        };

        await root.call(
            factory,
            'create',
            {
                name: 'upgradedao',
                args: Buffer.from(JSON.stringify(params)).toString('base64'),
            },
            {
                attachedDeposit: toYocto('20'),
                gas: tGas(300),
            },
        );

        test.deepEqual(await factory.view('get_dao_list', {}), [
            'upgradedao.factory.test.near',
        ]);

        // 1. add proposal for store_contract_self(get it approved)
        // --------------------------------------------------------------------
        const six_near = toYocto('6');
        const default_code_hash = await factory.view('get_default_code_hash');

        let proposalId: number = await root.call(
            'upgradedao.factory.test.near',
            'get_last_proposal_id',
            {},
            { gas: tGas(300) },
        );
        test.is(proposalId, 0);

        const args = Buffer.from(
            `{ "code_hash": "${default_code_hash}" }`,
            'binary',
        ).toString('base64');

        const proposal = {
            proposal: {
                description: 'Store DAO upgrade contract code blob',
                kind: {
                    FunctionCall: {
                        receiver_id: `${factory.accountId}`,
                        actions: [
                            {
                                method_name: 'store_contract_self',
                                args: args,
                                deposit: six_near,
                                gas: tGas(220),
                            },
                        ],
                    },
                },
            },
        };

        await root.call(
            'upgradedao.factory.test.near',
            'add_proposal',
            proposal,
            {
                attachedDeposit: toYocto('1'),
                gas: tGas(300),
            },
        );

        proposalId = await root.call(
            'upgradedao.factory.test.near',
            'get_last_proposal_id',
            {},
            { gas: tGas(300) },
        );
        test.is(proposalId, 1);

        let new_proposal: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 0 },
            { gas: tGas(300) },
        );

        test.log(new_proposal);
        test.is(
            new_proposal.description,
            'Store DAO upgrade contract code blob',
        );
        test.is(new_proposal.proposer, 'test.near');
        test.is(new_proposal.status, 'InProgress');
        test.truthy(new_proposal.kind.FunctionCall);
        test.is(
            new_proposal.kind.FunctionCall.receiver_id,
            `${factory.accountId}`,
        );

        await root.call(
            'upgradedao.factory.test.near',
            'act_proposal',
            { id: 0, action: 'VoteApprove' },
            { gas: tGas(300) },
        );

        let passed_proposal_0: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 0 },
            { gas: tGas(300) },
        );
        test.log(passed_proposal_0);
        test.is(passed_proposal_0.status, 'Approved');

        // 2. add proposal for UpgradeSelf with hash of blob from #1(get it approved)
        // --------------------------------------------------------------------
        const proposalUpgradeSelf = {
            proposal: {
                description: 'Upgrade DAO contract using local code blob',
                kind: {
                    UpgradeSelf: {
                        hash: `${default_code_hash}`,
                    },
                },
            },
        };
        await root.call(
            'upgradedao.factory.test.near',
            'add_proposal',
            proposalUpgradeSelf,
            {
                attachedDeposit: toYocto('1'),
                gas: tGas(300),
            },
        );

        let new_proposal_1: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 1 },
            { gas: tGas(300) },
        );

        test.log(new_proposal_1);
        test.is(
            new_proposal_1.description,
            'Upgrade DAO contract using local code blob',
        );
        test.is(new_proposal_1.proposer, 'test.near');
        test.is(new_proposal_1.status, 'InProgress');
        test.truthy(new_proposal_1.kind.UpgradeSelf);

        await root.call(
            'upgradedao.factory.test.near',
            'act_proposal',
            { id: 1, action: 'VoteApprove' },
            { gas: tGas(300) },
        );

        let passed_proposal_1: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 1 },
            { gas: tGas(300) },
        );

        test.log(passed_proposal_1);
        test.is(passed_proposal_1.status, 'Approved');

        // 3. add proposal for remove_contract_self(get it approved)
        // --------------------------------------------------------------------
        const proposalRemoveContractBlob = {
            proposal: {
                description:
                    'Remove DAO upgrade contract local code blob via factory',
                kind: {
                    FunctionCall: {
                        receiver_id: `${factory.accountId}`,
                        actions: [
                            {
                                method_name: 'remove_contract_self',
                                args: Buffer.from(
                                    `{ "code_hash": "${default_code_hash}" }`,
                                    'binary',
                                ).toString('base64'),
                                deposit: '0',
                                gas: tGas(220),
                            },
                        ],
                    },
                },
            },
        };
        // console.log(
        //     'proposalRemoveContractBlob',
        //     JSON.stringify(proposalRemoveContractBlob)
        // );

        await root.call(
            'upgradedao.factory.test.near',
            'add_proposal',
            proposalRemoveContractBlob,
            {
                attachedDeposit: toYocto('1'),
                gas: tGas(300),
            },
        );

        let new_proposal_2: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 2 },
            { gas: tGas(300) },
        );

        test.log(new_proposal_2);
        test.is(
            new_proposal_2.description,
            'Remove DAO upgrade contract local code blob via factory',
        );
        test.is(new_proposal_2.proposer, 'test.near');
        test.is(new_proposal_2.status, 'InProgress');
        test.truthy(new_proposal_2.kind.FunctionCall);
        test.is(
            new_proposal_2.kind.FunctionCall.receiver_id,
            `${factory.accountId}`,
        );

        await root.call(
            'upgradedao.factory.test.near',
            'act_proposal',
            { id: 2, action: 'VoteApprove' },
            { gas: tGas(300) },
        );

        let passed_proposal_2: any = await root.call(
            'upgradedao.factory.test.near',
            'get_proposal',
            { id: 2 },
            { gas: tGas(300) },
        );

        test.log(passed_proposal_2);
        test.is(passed_proposal_2.status, 'Approved');

        // 4. Confirm DAO contract code_hash and returned balance
        // --------------------------------------------------------------------
        // TODO: Check if balance increased by 6 NEAR for refund
    },
);

'''
'''--- astra/tests-ava/__tests__/utils.ts ---
import { Workspace, NearAccount, BN, toYocto, tGas } from 'near-workspaces-ava';

async function initWorkspace(root: NearAccount) {
    const alice = await root.createAccount('alice');
    // console.log('alice\'s balance is: ' + (await alice.balance()).total) //100N

    const config = { name: 'astra', purpose: 'testing', metadata: '' };
    const policy = [root.accountId];

    //for short let's call it just dao
    const dao = await root.createAndDeploy('dao', '../../res/astra.wasm', {
        method: 'new',
        args: { config, policy },
        initialBalance: toYocto('200'),
    });

    // console.log('dao\'s balance is: ' + (await dao.balance()).total) //~200N

    return { alice, dao };
}

export const STORAGE_PER_BYTE = new BN('10000000000000000000');

export const workspace = Workspace.init(async ({ root }) => {
    return initWorkspace(root);
});

export const workspaceWithoutInit = Workspace.init(async ({ root }) => {
    const alice = await root.createAccount('alice');

    //for short let's call it just dao
    const dao = await root.createAndDeploy('dao', '../../res/astra.wasm', {
        initialBalance: toYocto('200'),
    });
    return { alice, dao };
});

export const workspaceWithFactory = Workspace.init(async ({ root }) => {
    const factory = await root.createAndDeploy(
        'factory',
        '../../res/astra_factory.wasm',
        {
            initialBalance: toYocto('500'),
        },
    );
    await factory.call(factory.accountId, 'new', {}, { gas: tGas(300) });
    return { factory };
});

export async function initTestToken(root: NearAccount) {
    const testToken = await root.createAndDeploy(
        'test-token',
        '../../res/test_token.wasm',
        {
            method: 'new',
            initialBalance: toYocto('200'),
        },
    );
    return testToken;
}

export async function initStaking(
    root: NearAccount,
    dao: NearAccount,
    testToken: NearAccount,
) {
    const staking = await root.createAndDeploy(
        'staking',
        '../../res/astra_staking.wasm',
        {
            method: 'new',
            args: {
                owner_id: dao,
                token_id: testToken,
                unstake_period: '100000000000',
            },
            initialBalance: toYocto('100'),
        },
    );
    return staking;
}

export async function setStakingId(
    root: NearAccount,
    dao: NearAccount,
    staking: NearAccount,
) {
    // Setting staking id
    const proposalId = await root.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'test',
                kind: { SetStakingContract: { staking_id: staking.accountId } },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    await root.call(dao, 'act_proposal', {
        id: proposalId,
        action: 'VoteApprove',
    });
}

export const regCost = STORAGE_PER_BYTE.mul(new BN(16));

export async function registerAndDelegate(
    dao: NearAccount,
    staking: NearAccount,
    account: NearAccount,
    amount: BN,
) {
    await staking.call(
        dao,
        'register_delegation',
        { account_id: account },
        { attachedDeposit: regCost },
    );
    const res: string[3] = await staking.call(dao, 'delegate', {
        account_id: account,
        amount: amount.toString(),
    });
    return res;
}

export const DEADLINE = '1925376849430593581';
export const BOND = toYocto('1');

export async function proposeBounty(
    alice: NearAccount,
    dao: NearAccount,
    token: NearAccount,
) {
    const bounty = {
        description: 'test_bounties',
        token: token.accountId,
        amount: '19000000000000000000000000',
        times: 3,
        max_deadline: DEADLINE,
    };
    const proposalId: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'add_new_bounty',
                kind: {
                    AddBounty: {
                        bounty,
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    return proposalId;
}

export async function proposeBountyWithNear(
    alice: NearAccount,
    dao: NearAccount,
) {
    const bounty = {
        description: 'test_bounties_with_near_token',
        token: '',
        amount: '19000000000000000000000000',
        times: 3,
        max_deadline: DEADLINE,
    };
    const proposalId: number = await alice.call(
        dao,
        'add_proposal',
        {
            proposal: {
                description: 'add_new_bounty',
                kind: {
                    AddBounty: {
                        bounty,
                    },
                },
            },
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
    return proposalId;
}

export async function voteOnBounty(
    root: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    await root.call(
        dao,
        'act_proposal',
        {
            id: proposalId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(50),
        },
    );
}

export async function claimBounty(
    alice: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    await alice.call(
        dao,
        'bounty_claim',
        {
            id: proposalId,
            deadline: DEADLINE,
        },
        {
            attachedDeposit: BOND,
        },
    );
}

export async function doneBounty(
    alice: NearAccount,
    bob: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    await alice.call(
        dao,
        'bounty_done',
        {
            id: proposalId,
            account_id: bob,
            description: 'This bounty is done',
        },
        {
            attachedDeposit: toYocto('1'),
        },
    );
}

export async function giveupBounty(
    alice: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    return await alice.call(dao, 'bounty_giveup', { id: proposalId });
}

export async function giveupBountyRaw(
    alice: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    return await alice.call_raw(dao, 'bounty_giveup', { id: proposalId });
}

export async function voteApprove(
    root: NearAccount,
    dao: NearAccount,
    proposalId: number,
) {
    await root.call(
        dao,
        'act_proposal',
        {
            id: proposalId,
            action: 'VoteApprove',
        },
        {
            gas: tGas(100),
        },
    );
}

'''
'''--- astra/tests-ava/__tests__/views.ava.ts ---
import {
    Workspace,
    BN,
    NearAccount,
    captureError,
    toYocto,
    tGas,
    ONE_NEAR,
} from 'near-workspaces-ava';
import {
    workspace,
    initStaking,
    initTestToken,
    setStakingId,
    registerAndDelegate,
    STORAGE_PER_BYTE,
} from './utils';
import {
    DEADLINE,
    BOND,
    proposeBounty,
    voteOnBounty,
    claimBounty,
} from './utils';
import * as fs from 'fs';

workspace.test('View method version', async (test, { alice, root, dao }) => {
    test.log('Version:');
    test.log(await dao.view('version'));
    test.is(await dao.view('version'), '2.0.0');
});

workspace.test('View method get_config', async (test, { root }) => {
    const config = {
        name: 'astra2',
        purpose: 'testing get_config',
        metadata: '',
    };
    const policy = [root.accountId];

    const bob = await root.createAndDeploy('bob', '../../res/astra.wasm', {
        method: 'new',
        args: { config, policy },
        initialBalance: toYocto('200'),
    });
    test.deepEqual(await bob.view('get_config'), config);
});

workspace.test('View method get_policy', async (test, { root }) => {
    const config = {
        name: 'astra2',
        purpose: 'testing get_policy',
        metadata: '',
    };
    const versionedPolicy = [root.accountId];

    const bob = await root.createAndDeploy('bob', '../../res/astra.wasm', {
        method: 'new',
        args: { config, policy: versionedPolicy },
        initialBalance: toYocto('200'),
    });
    const policy = {
        roles: [
            {
                name: 'all',
                kind: 'Everyone',
                permissions: ['*:AddProposal'],
                vote_policy: {},
            },
            {
                name: 'council',
                kind: {
                    Group: [root.accountId],
                },
                permissions: [
                    '*:Finalize',
                    '*:AddProposal',
                    '*:VoteApprove',
                    '*:VoteReject',
                    '*:VoteRemove',
                ],
                vote_policy: {},
            },
        ],
        default_vote_policy: {
            weight_kind: 'RoleWeight',
            quorum: '0',
            threshold: [1, 2],
        },
        proposal_bond: '1000000000000000000000000',
        proposal_period: '604800000000000',
        bounty_bond: '1000000000000000000000000',
        bounty_forgiveness_period: '86400000000000',
    };
    test.deepEqual(await bob.view('get_policy'), policy);
});

workspace.test(
    'View method get_staking_contract',
    async (test, { alice, root, dao }) => {
        test.is(await dao.view('get_staking_contract'), '');

        //To set the staking_id
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);
        await setStakingId(root, dao, staking);

        test.is(await dao.view('get_staking_contract'), staking.accountId);
    },
);

workspace.test('View has_blob', async (test, { alice, root, dao }) => {
    const DAO_WASM_BYTES: Uint8Array = fs.readFileSync(
        '../../res/astra.wasm',
    );
    const hash: String = await root.call(dao, 'store_blob', DAO_WASM_BYTES, {
        attachedDeposit: toYocto('200'),
        gas: tGas(300),
    });

    test.true(await dao.view('has_blob', { hash: hash }));
    await root.call(dao, 'remove_blob', {
        hash: hash,
    });
    test.false(await dao.view('has_blob', { hash: hash }));
});

workspace.test(
    'View get_locked_storage_amount',
    async (test, { alice, root, dao }) => {
        const beforeProposal = new BN(
            await dao.view('get_locked_storage_amount'),
        );
        test.log('Locked amount: ' + beforeProposal);
        await root.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'adding some bytes',
                    kind: 'Vote',
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        const afterProposal = new BN(
            await dao.view('get_locked_storage_amount'),
        );
        test.assert(beforeProposal.lt(afterProposal));
    },
);

workspace.test(
    'View get_available_amount',
    async (test, { alice, root, dao }) => {
        const beforeProposal = new BN(await dao.view('get_available_amount'));
        test.log('Available amount: ' + beforeProposal);
        await root.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'adding some bytes',
                    kind: 'Vote',
                },
            },
            {
                attachedDeposit: toYocto('1'),
            },
        );
        const afterProposal = new BN(await dao.view('get_available_amount'));
        test.assert(beforeProposal.gt(afterProposal));
    },
);

workspace.test(
    'View methods for delegation',
    async (test, { alice, root, dao }) => {
        const testToken = await initTestToken(root);
        const staking = await initStaking(root, dao, testToken);
        const randomAmount = new BN('10087687667869');
        const bob = await root.createAccount('bob');

        await setStakingId(root, dao, staking);

        let result = await registerAndDelegate(
            dao,
            staking,
            alice,
            randomAmount,
        );
        result = await registerAndDelegate(
            dao,
            staking,
            bob,
            randomAmount.muln(2),
        );

        //Test delegation_balance_of
        test.deepEqual(
            new BN(
                await dao.view('delegation_balance_of', { account_id: alice }),
            ),
            randomAmount,
        );
        test.deepEqual(
            new BN(
                await dao.view('delegation_balance_of', { account_id: bob }),
            ),
            randomAmount.muln(2),
        );

        //Test delegation_total_supply
        test.deepEqual(
            new BN(await dao.view('delegation_total_supply')),
            randomAmount.muln(3),
        );

        //Test delegation_balance_ratio
        test.deepEqual(
            await dao.view('delegation_balance_ratio', { account_id: alice }),
            [
                await dao.view('delegation_balance_of', { account_id: alice }),
                await dao.view('delegation_total_supply'),
            ],
        );
    },
);

workspace.test(
    'View methods for proposals',
    async (test, { alice, root, dao }) => {
        //Test get_last_proposal_id
        test.is(await dao.view('get_last_proposal_id'), 0);

        //Test get_proposals
        test.deepEqual(
            await dao.view('get_proposals', { from_index: 0, limit: 100 }),
            [],
        );

        const config = {
            name: 'astra',
            purpose: 'testing_view_methods',
            metadata: '',
        };
        await alice.call(
            dao,
            'add_proposal',
            {
                proposal: {
                    description: 'rename the dao',
                    kind: {
                        ChangeConfig: {
                            config,
                        },
                    },
                },
            },
            { attachedDeposit: toYocto('1') },
        );

        const realProposalAlice = {
            id: 0,
            proposer: alice.accountId,
            description: 'rename the dao',
            kind: { ChangeConfig: { config } },
            status: 'InProgress',
            vote_counts: {},
            votes: {},
        };

        const proposalAlice: any = await dao.view('get_proposal', { id: 0 });

        //Test get_proposal
        test.is(proposalAlice.proposer, realProposalAlice.proposer);
        test.is(proposalAlice.description, realProposalAlice.description);
        test.is(proposalAlice.status, realProposalAlice.status);
        test.deepEqual(
            proposalAlice.vote_counts,
            realProposalAlice.vote_counts,
        );
        test.deepEqual(proposalAlice.votes, realProposalAlice.votes);
        test.deepEqual(proposalAlice.kind, realProposalAlice.kind);

        //Test get_last_proposal_id
        test.deepEqual(await dao.view('get_last_proposal_id'), 1);

        //Test get_proposals
        const proposals: any = await dao.view('get_proposals', {
            from_index: 0,
            limit: 100,
        });
        test.is(proposals[0].proposer, realProposalAlice.proposer);
        test.is(proposals[0].description, realProposalAlice.description);
        test.is(proposals[0].status, realProposalAlice.status);
        test.deepEqual(proposals[0].vote_counts, realProposalAlice.vote_counts);
        test.deepEqual(proposals[0].votes, realProposalAlice.votes);
        test.deepEqual(proposals[0].kind, realProposalAlice.kind);

        //Should panic if the proposal with the given id doesn't exist
        const errorString = await captureError(
            async () => await dao.view('get_proposal', { id: 10 }),
        );
        test.regex(errorString, /ERR_NO_PROPOSAL/);
    },
);

workspace.test(
    'View methods for bounties',
    async (test, { alice, root, dao }) => {
        //Test get_last_bounty_id
        test.is(await dao.view('get_last_bounty_id'), 0);
        //Test get_bounties
        test.deepEqual(
            await dao.view('get_bounties', { from_index: 0, limit: 100 }),
            [],
        );

        const testToken = await initTestToken(root);
        const proposalId = await proposeBounty(alice, dao, testToken);
        const bounty = {
            id: 0,
            description: 'test_bounties',
            token: testToken.accountId,
            amount: '19000000000000000000000000',
            times: 3,
            max_deadline: DEADLINE,
        };
        await voteOnBounty(root, dao, proposalId);

        //Test get_last_bounty_id
        test.is(await dao.view('get_last_bounty_id'), 1);
        //Test get_bounties
        test.deepEqual(
            await dao.view('get_bounties', { from_index: 0, limit: 100 }),
            [bounty],
        );
        //Test get_bounty
        test.deepEqual(await dao.view('get_bounty', { id: 0 }), bounty);

        await claimBounty(alice, dao, proposalId);

        //Test get_bounty_number_of_claims
        test.is(await dao.view('get_bounty_number_of_claims', { id: 0 }), 1);
        //Test get_bounty_claims
        const realClaim = {
            bounty_id: 0,
            deadline: DEADLINE,
            completed: false,
        };
        const claims: any = await dao.view('get_bounty_claims', {
            account_id: alice.accountId,
        });
        test.is(claims[0].bounty_id, realClaim.bounty_id);
        test.is(claims[0].deadline, realClaim.deadline);
        test.is(claims[0].completed, realClaim.completed);

        //Should panic if the bounty with the given id doesn't exist
        const errorString = await captureError(
            async () => await dao.view('get_bounty', { id: 10 }),
        );
        test.regex(errorString, /ERR_NO_BOUNTY/);
    },
);

'''
'''--- astra/tests-ava/package.json ---
{
  "private": true,
  "scripts": {
    "format": "prettier --write \"__tests__/*.{js,jsx,ts,tsx}\" --tab-width=4 --single-quote --trailing-comma all",
    "test": "near-workspaces-ava",
    "test:testnet": "near-workspaces-ava --config ./ava.testnet.config.cjs"
  },
  "devDependencies": {
    "near-workspaces-ava": "^1.1.0",
    "prettier": "^2.5.1"
  }
}

'''
'''--- astra/tests-ava/tsconfig.json ---
{
  "extends": "near-workspaces-ava/tsconfig.ava.json"
}
'''
'''--- astra/tests/test_general.rs ---
use std::collections::HashMap;

use near_sdk::json_types::{U128, Base64VecU8, U64};
use near_sdk::serde_json::json;
use near_sdk::{env, AccountId, ONE_NEAR};

use crate::utils::*;
use astra_staking::User;
use astra::{
    default_policy, Action, BountyClaim, BountyOutput, Config, Policy, Proposal, ProposalInput,
    ProposalKind, ProposalOutput, ProposalStatus, RoleKind, RolePermission, VersionedPolicy,
    VotePolicy,
};

mod utils;

fn user(id: u32) -> AccountId {
    format!("user{}.test.near", id).parse().unwrap()
}

#[tokio::test]
async fn test_large_policy() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let factory_contract = worker.dev_deploy(include_bytes!("../../res/astra_factory.wasm")).await?;
    let root = worker.dev_create_account().await?;
    // initialize contract
    let res1 = factory_contract
        .call("new")
        .max_gas()
        .transact();

    assert!(res1.await?.is_success());

    let config = Config {
        name: "testdao".to_string(),
        purpose: "to test".to_string(),
        metadata: Base64VecU8(vec![]),
    };
    let root_near_account: AccountId = root.id().parse().unwrap();
    let mut policy = default_policy(vec![root_near_account.clone()]);
    const NO_OF_COUNCILS: u32 = 10;
    const USERS_PER_COUNCIL: u32 = 100;
    for council_no in 0..NO_OF_COUNCILS {
        let mut council = vec![];
        let user_id_start = council_no * USERS_PER_COUNCIL;
        let user_id_end = user_id_start + USERS_PER_COUNCIL;
        for user_id in user_id_start..user_id_end {
            council.push(user(user_id));
        }

        let role = RolePermission {
            name: format!("council{}", council_no),
            kind: RoleKind::Group(council.into_iter().collect()),
            permissions: vec![
                "*:AddProposal".to_string(),
                "*:VoteApprove".to_string(),
                "*:VoteReject".to_string(),
                "*:VoteRemove".to_string(),
                "*:Finalize".to_string(),
            ]
            .into_iter()
            .collect(),
            vote_policy: HashMap::default(),
        };
        policy.add_or_update_role(&role);
    }

    let params = json!({ "config": config, "policy": policy, "trust": root_near_account})
        .to_string()
        .into_bytes();

    let res2 = factory_contract
        .call("create")
        .args_json((AccountId::new_unchecked("testdao".to_string()), Base64VecU8(params)))
        .max_gas()
        .deposit(ONE_NEAR * 10)
        .transact()
        .await?;
    assert!(res2.is_success());

    let dao_account_id = AccountId::new_unchecked("testdao.".to_string() + factory_contract.id());

    let dao_list: Vec<AccountId>= factory_contract
        .call("get_dao_list")
        .view()
        .await?
        .json()?;
    assert_eq!(dao_list, vec![dao_account_id.clone()]);

    Ok(())
}

#[tokio::test]
async fn test_multi_council() -> anyhow::Result<()> {
    let (root, dao_contract, worker) = setup_dao().await?;

    let user1 = gen_user_account(&worker, user(1).as_str()).await?;
    let _ = transfer_near(&worker, user1.id(), ONE_NEAR * 50).await?;
    let user2 = gen_user_account(&worker, user(2).as_str()).await?;
    let _ = transfer_near(&worker, user2.id(), ONE_NEAR * 50).await?;
    let user3 = gen_user_account(&worker, user(3).as_str()).await?;
    let _ = transfer_near(&worker, user3.id(), ONE_NEAR * 50).await?;

    let new_policy = Policy {
        roles: vec![
            RolePermission {
                name: "all".to_string(),
                kind: RoleKind::Everyone,
                permissions: vec!["*:AddProposal".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "council".to_string(),
                kind: RoleKind::Group(vec![user(1), user(2)].into_iter().collect()),
                permissions: vec!["*:*".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
            RolePermission {
                name: "community".to_string(),
                kind: RoleKind::Group(vec![user(1), user(3), user(4)].into_iter().collect()),
                permissions: vec!["*:*".to_string()].into_iter().collect(),
                vote_policy: HashMap::default(),
            },
        ],
        default_vote_policy: VotePolicy::default(),
        proposal_bond: U128(10u128.pow(24)),
        proposal_period: U64::from(1_000_000_000 * 60 * 60 * 24 * 7),
        bounty_bond: U128(10u128.pow(24)),
        bounty_forgiveness_period: U64::from(1_000_000_000 * 60 * 60 * 24),
    };

    let proposal = ProposalInput {
        description: "new policy".to_string(),
        kind: ProposalKind::ChangePolicy {
            policy: VersionedPolicy::Current(new_policy.clone()),
        },
        category: None
    };
    let res2 = root.call(dao_contract.id(), "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res2.is_success(), "{:?}", res2);

    vote(vec![root.clone()], &dao_contract, 0).await?;

    let policy: Policy = dao_contract.call("get_policy").view().await?.json()?;
    assert_eq!(policy, new_policy);
    add_transfer_proposal(root.clone(), &dao_contract, base_token(), user(1), 1_000_000, None).await?;

    vote(vec![user2], &dao_contract, 1).await?;
    vote(vec![user3], &dao_contract, 1).await?;
    let proposal: Proposal = dao_contract.call("get_proposal").args_json(json!({"id":1})).view().await?.json()?;
    // Votes from members in different councils.
    assert_eq!(proposal.status, ProposalStatus::InProgress);
    // Finish with vote that is in both councils, which approves the proposal.
    vote(vec![user1], &dao_contract, 1).await?;
    let proposal: Proposal = dao_contract.call("get_proposal").args_json(json!({"id":1})).view().await?.json()?;
    assert_eq!(proposal.status, ProposalStatus::Approved);

    Ok(())
}

#[tokio::test]
async fn test_bounty_workflow() -> anyhow::Result<()> {
    let (root, dao_contract, worker) = setup_dao().await?;
    
    let user1 = gen_user_account(&worker, user(1).as_str()).await?;
    let _ = transfer_near(&worker, user1.id(), ONE_NEAR * 900).await?;
    let user2 = gen_user_account(&worker, user(2).as_str()).await?;
    let _ = transfer_near(&worker, user2.id(), ONE_NEAR * 900).await?;

    let mut proposal_id = add_bounty_proposal(root.clone(), &dao_contract).await?;
    assert_eq!(proposal_id, 0);

    vote(vec![root.clone()], &dao_contract, proposal_id).await?;

    let mut bounty_id: u64 = dao_contract.call("get_last_bounty_id").view().await?.json()?;
    bounty_id -= 1u64;

    assert_eq!(bounty_id, 0);
    let bounty: BountyOutput = dao_contract.call("get_bounty")
                .args_json(json!({"id": bounty_id})).view().await?.json()?;
    assert_eq!(
        bounty.bounty.times,
        3
    );

    assert_eq!(ONE_NEAR * 1000, user1.view_account().await?.balance);

    let res = user1
        .call(dao_contract.id(), "bounty_claim")
        .args_json(json!({"id": bounty_id, "deadline": U64::from(0)}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    assert!(user1.view_account().await?.balance < ONE_NEAR * 999);

    let bounty_claim: Vec<BountyClaim> = dao_contract.call("get_bounty_claims")
                .args_json(json!({"account_id": user1.id()})).view().await?.json()?;
    assert_eq!(
       bounty_claim.len(),
        1
    );

    let bounty_claim: u64 = dao_contract.call("get_bounty_number_of_claims")
            .args_json(json!({"id": bounty_id})).view().await?.json()?;
    assert_eq!(
        bounty_claim,
        1
    );

    let res = user1
        .call(dao_contract.id(), "bounty_giveup")
        .args_json(json!({"id": bounty_id}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);
    assert!(user1.view_account().await?.balance > ONE_NEAR * 999);

    let bounty_claim: Vec<BountyClaim> = dao_contract.call("get_bounty_claims")
        .args_json(json!({"account_id": user1.id()})).view().await?.json()?;
    assert_eq!(
        bounty_claim.len(),
        0
    );
    let bounty_claim_number: u64 = dao_contract.call("get_bounty_number_of_claims")
        .args_json(json!({"id": bounty_id})).view().await?.json()?;
    assert_eq!(
        bounty_claim_number,
        0
    );

    assert_eq!(ONE_NEAR * 1000, user2.view_account().await?.balance);

    let res = user2
        .call(dao_contract.id(), "bounty_claim")
        .args_json(json!({"id": bounty_id, "deadline": U64(env::block_timestamp() + 5_000_000_000)}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);
    assert!(user2.view_account().await?.balance < ONE_NEAR * 999);

    let bounty_claim: Vec<BountyClaim> = dao_contract.call("get_bounty_claims")
        .args_json(json!({"account_id": user2.id()})).view().await?.json()?;
    assert_eq!(
        bounty_claim.len(),
        1
    );
    let bounty_claim_number: u64 = dao_contract.call("get_bounty_number_of_claims")
        .args_json(json!({"id": bounty_id})).view().await?.json()?;
    assert_eq!(
        bounty_claim_number,
        1
    );

    let res = user2
        .call(dao_contract.id(), "bounty_done")
        .args_json(json!({"id": bounty_id, "description": "Bounty is done".to_string()}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);
    assert!(user2.view_account().await?.balance < ONE_NEAR * 998);

    let latest_prop_id: u64 = dao_contract.call("get_last_proposal_id").view().await?.json()?;
    proposal_id = latest_prop_id - 1u64;
    assert_eq!(proposal_id, 1);

    let prop_out: ProposalOutput = dao_contract.call("get_proposal")
        .args_json(json!({"id": proposal_id})).view().await?.json()?;
    assert_eq!(
        prop_out
            .proposal
            .kind
            .to_policy_label(),
        "bounty_done"
    );

    vote(vec![root.clone()], &dao_contract, proposal_id).await?;

    assert!(user2.view_account().await?.balance > ONE_NEAR * 999);

    let bounty_claim: Vec<BountyClaim> = dao_contract.call("get_bounty_claims")
        .args_json(json!({"account_id": user2.id()})).view().await?.json()?;
    assert_eq!(
        bounty_claim.len(),
        0
    );
    let bounty_claim_number: u64 = dao_contract.call("get_bounty_number_of_claims")
        .args_json(json!({"id": bounty_id})).view().await?.json()?;
    assert_eq!(
        bounty_claim_number,
        0
    );
    let bounty: BountyOutput = dao_contract.call("get_bounty")
                .args_json(json!({"id": bounty_id})).view().await?.json()?;
    assert_eq!(
        bounty.bounty.times,
        2
    );

    Ok(())
}

#[tokio::test]
async fn proposal_tests() -> anyhow::Result<()> {
    let (root, dao, worker) = setup_dao().await?;
    let user2 = gen_user_account(&worker, user(2).as_str()).await?;
    let _ = transfer_near(&worker, user2.id(), ONE_NEAR * 900).await?;
    let user3 = gen_user_account(&worker, user(3).as_str()).await?;
    let _ = transfer_near(&worker, user3.id(), ONE_NEAR * 900).await?;
    let user2_near_account: AccountId = user2.id().parse().unwrap();
    add_member_proposal(root.clone(), &dao, user2_near_account).await?;
    vote(vec![root.clone()], &dao.clone(), 0).await?;

    let config = Config { name: "astra".to_string(), purpose: "testing".to_string(), metadata: Base64VecU8("".to_string().into()) };
    let proposal = ProposalInput {
        description: "rename the dao".to_string(),
        kind: ProposalKind::ChangeConfig { config },
        category: None
    };
    let res = root
        .call(dao.id(), "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    vote(vec![root.clone(), user2.clone()], &dao.clone(), 1).await?;

    let last_prop: u64 = dao.call("get_last_proposal_id").view().await?.json()?;
    assert_eq!(last_prop, 2);

    let prop: Proposal = dao.call("get_proposal").args_json(json!({"id": 1})).view().await?.json()?;
    assert_eq!(
        prop.status,
        ProposalStatus::Executed
    );

    Ok(())
}

#[tokio::test]
async fn test_create_dao_and_use_token() -> anyhow::Result<()> {
    let (root, dao, worker) = setup_dao().await?;
    let user2 = gen_user_account(&worker, user(2).as_str()).await?;
    let _ = transfer_near(&worker, user2.id(), ONE_NEAR * 900).await?;
    let user3 = gen_user_account(&worker, user(3).as_str()).await?;
    let _ = transfer_near(&worker, user3.id(), ONE_NEAR * 900).await?;
    let (test_token, worker) = setup_test_token(worker).await?;
    let (staking, _) = setup_staking(test_token.id().clone(), dao.id().clone(), worker).await?;

    let staking_contract: String = dao.call("get_staking_contract").view().await?.json()?;
    assert!(staking_contract.is_empty());

    let user2_near_account: AccountId = user2.id().parse().unwrap();
    add_member_proposal(root.clone(), &dao, user2_near_account).await?;

    let last_prop: u64 = dao.call("get_last_proposal_id").view().await?.json()?;
    assert_eq!(last_prop, 1);

    // Voting by user who is not a member should fail.
    let res = user2.clone()
        .call(dao.id(), "act_proposal")
        .args_json(json!({"id": 0, "action": Action::VoteApprove, "skip_execution": false}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "{:?}", res);
    let res = root.clone()
        .call(dao.id(), "act_proposal")
        .args_json(json!({"id": 0, "action": Action::VoteApprove, "skip_execution": false}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);
    // Voting second time on the same proposal should fail.
    let res = root.clone()
        .call(dao.id(), "act_proposal")
        .args_json(json!({"id": 0, "action": Action::VoteApprove, "skip_execution": false}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "{:?}", res);

    // Add 3rd member.
    let user3_near_account: AccountId = user3.id().parse().unwrap();

    add_member_proposal(user2.clone(), &dao.clone(), user3_near_account).await?;
    vote(vec![root.clone(), user2.clone()], &dao.clone(), 1).await?;
    let policy: Policy = dao.call("get_policy").view().await?.json()?;
    assert_eq!(policy.roles.len(), 2);
    assert_eq!(
        policy.roles[1].kind,
        RoleKind::Group(
            vec![
                root.id().parse().unwrap(),
                user2.id().parse().unwrap(),
                user3.id().parse().unwrap()
            ]
            .into_iter()
            .collect()
        )
    );

    let proposal = ProposalInput {
        description: "test".to_string(),
        kind: ProposalKind::SetStakingContract {
            staking_id: staking.id().parse().unwrap(),
        },
        category: None
    };
    let res = user2
        .call(dao.id(), "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    vote(vec![user3.clone(), user2.clone()], &dao, 2).await?;

    let staking_contract: String = dao.call("get_staking_contract").view().await?.json()?;
    assert!(!staking_contract.is_empty());

    let prop: Proposal = dao.call("get_proposal").args_json(json!({"id": 2})).view().await?.json()?;
    assert_eq!(
        prop.status,
        ProposalStatus::Executed
    );

    let supply: U128 = staking.call("ft_total_supply").view().await?.json()?;
    assert_eq!(
        supply.0,
        0
    );

    let res = user2
        .call(test_token.id(), "mint")
        .args_json(json!({"account_id": user2.id(), "amount": U128(100 * ONE_NEAR)}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let res = user2
        .call(test_token.id(), "storage_deposit")
        .args_json(json!({"account_id": staking.id()}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let res = user2
        .call(staking.id(), "storage_deposit")
        .args_json(json!({}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let res = user2
        .call(test_token.id(), "ft_transfer_call")
        .args_json(json!({"receiver_id": staking.id(), "amount": U128(10 * ONE_NEAR), "msg": "".to_string()}))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let supply: U128 = staking.call("ft_total_supply").view().await?.json()?;
    assert_eq!(
        supply.0,
        10 * ONE_NEAR
    );

    let bal: U128 = staking.call("ft_balance_of").args_json(json!({"account_id": user2.id()})).view().await?.json()?;
    assert_eq!(
        bal.0,
        10 * ONE_NEAR
    );

    let bal: U128 = test_token.call("ft_balance_of").args_json(json!({"account_id": user2.id()})).view().await?.json()?;
    assert_eq!(
        bal.0,
        90 * ONE_NEAR
    );
    let res = user2
        .call(staking.id(), "withdraw")
        .args_json(json!({"amount": U128(5 * ONE_NEAR)}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);
    let supply: U128 = staking.call("ft_total_supply").view().await?.json()?;
    assert_eq!(
        supply.0,
        5 * ONE_NEAR
    );
    let bal: U128 = test_token.call("ft_balance_of").args_json(json!({"account_id": user2.id()})).view().await?.json()?;
    assert_eq!(
        bal.0,
        95 * ONE_NEAR
    );

    let res = user2
        .call(staking.id(), "delegate")
        .args_json(json!({"account_id": user2.id(), "amount": U128(5 * ONE_NEAR)}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let res = user2
        .call(staking.id(), "undelegate")
        .args_json(json!({"account_id": user2.id(), "amount": U128(ONE_NEAR)}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);
    // should fail right after undelegation as user needs to wait for voting period before they can delegate again.
    let res = user2
        .call(staking.id(), "delegate")
        .args_json(json!({"account_id": user2.id(), "amount": U128(ONE_NEAR)}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "{:?}", res);
    let user: User = staking.call("get_user").args_json(json!({"account_id": user2.id()})).view().await?.json()?;
    assert_eq!(
        user.delegated_amounts,
        vec![(user2.id().parse().unwrap(), U128(4 * ONE_NEAR))]
    );

    let supply: U128 = dao.call("delegation_total_supply").view().await?.json()?;
    assert_eq!(
        supply.0,
        4 * ONE_NEAR
    );
    let bal: U128 = dao.call("delegation_balance_of").args_json(json!({"account_id": user2.id()})).view().await?.json()?;
    assert_eq!(
        bal.0,
        4 * ONE_NEAR
    );

    Ok(())
}

/// Test various cases that must fail.
#[tokio::test]
async fn test_failurestest_create_dao_and_use_token() -> anyhow::Result<()> {
    let (root, dao, _) = setup_dao().await?;

    let proposal = ProposalInput {
        description: "test".to_string(),
        kind: ProposalKind::Transfer {
            token_id: convert_new_to_old_token(base_token()),
            receiver_id: user(1),
            amount: U128(1_000_000),
            msg: Some("some".to_string()),
        },
        category: None
    };
    let res = root
        .call(dao.id(), "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "{:?}", res);

    Ok(())
}

// Test payments that fail
#[tokio::test]
async fn test_payment_failures() -> anyhow::Result<()> {
    let (root, dao, worker) = setup_dao().await?;
    let user1 = gen_user_account(&worker, user(1).as_str()).await?;
    let _ = transfer_near(&worker, user1.id(), ONE_NEAR * 900).await?;
    let whale = gen_user_account(&worker, user(2).as_str()).await?;
    let _ = transfer_near(&worker, whale.id(), ONE_NEAR * 900).await?;

    // Add user1
    add_member_proposal(root.clone(), &dao, user1.id().parse().unwrap()).await?;
    vote(vec![root.clone()], &dao, 0).await?;

    // Set up fungible tokens and give 5 to the dao
    let (test_token, _) = setup_test_token(worker).await?;
    let res = dao.as_account()
        .call(test_token.id(), "mint")
        .args_json(json!({"account_id": dao.id(), "amount": U128(5)}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let res = user1
        .call(test_token.id(), "storage_deposit")
        .args_json(json!({"account_id": user1.id(), "registration_only": true}))
        .max_gas()
        .deposit(ONE_NEAR * 125)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    // Attempt to transfer more than it has
    add_transfer_proposal(
        root.clone(),
        &dao,
        Some(test_token.id().parse().unwrap()),
        user(1),
        10,
        None,
    ).await?;

    // Vote in the transfer
    vote(vec![root.clone(), user1.clone()], &dao, 1).await?;
    let mut proposal: Proposal = dao.call("get_proposal").args_json(json!({"id": 1})).view().await?.json()?;

    assert_eq!(proposal.status, ProposalStatus::Failed);

    // Set up benefactor whale who will donate the needed tokens
    let res = whale
        .call(test_token.id(), "mint")
        .args_json(json!({"account_id": whale.id(), "amount": U128(6_000_000_000)}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let res = whale
        .call(test_token.id(), "ft_transfer")
        .args_json(json!({"receiver_id": dao.id(), "amount": U128::from(1000), "msg": "Heard you're in a pinch, let me help.".to_string()}))
        .max_gas()
        .deposit(1)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    // Council member retries payment via an action
    let res = root
            .call(dao.id(), "act_proposal")
            .args_json(json!({"id": 1, "action": Action::Finalize, "msg": "Sorry! We topped up our tokens. Thanks.".to_string()}))
            .max_gas()
            .transact()
            .await?;
    assert!(res.is_success(), "{:?}", res);

    proposal = dao.call("get_proposal").args_json(json!({"id": 1})).view().await?.json()?;
    assert_eq!(
        proposal.status,
        ProposalStatus::Approved,
        "Did not return to approved status."
    );

    Ok(())
}

'''
'''--- astra/tests/test_upgrade.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use std::str::FromStr;

use crate::utils::*;
mod utils;
use workspaces::{AccountId as WorkAccountId};
use astra::{Config, VersionedPolicy, ProposalInput, ProposalKind, Action};
use near_sdk::{serde_json::json, json_types::{Base64VecU8, Base58CryptoHash}, AccountId, ONE_NEAR};

#[tokio::test]
async fn test_upgrade_using_factory() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let factory_contract = worker.dev_deploy(include_bytes!("../../res/astra_factory.wasm")).await?;
    let root = worker.dev_create_account().await?;
    // initialize contract
    let res1 = factory_contract
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact();

    assert!(res1.await?.is_success());

    let config = Config {
        name: "testdao".to_string(),
        purpose: "to test".to_string(),
        metadata: Base64VecU8(vec![]),
    };
    let root_near_account: AccountId = root.id().parse().unwrap();

    let policy = VersionedPolicy::Default(vec![root_near_account.clone()]);
    let params = json!({ "config": config, "policy": policy, "trust": root_near_account})
        .to_string()
        .into_bytes();

    let res2 = root
        .call(factory_contract.id(), "create")
        .args_json((AccountId::new_unchecked("testdao".to_string()), Base64VecU8(params)))
        .gas(300_000_000_000_000)
        .deposit(ONE_NEAR * 10)
        .transact()
        .await?;
    assert!(res2.is_success());

    let dao_account_id = AccountId::new_unchecked("testdao.".to_string() + factory_contract.id());
    let dao_list: Vec<AccountId>= factory_contract
        .call("get_dao_list")
        .view()
        .await?
        .json()?;
    assert_eq!(dao_list, vec![dao_account_id.clone()]);

    let dao = WorkAccountId::from_str(dao_account_id.as_ref())?;

    let hash: Base58CryptoHash= factory_contract
        .call("get_default_code_hash")
        .view()
        .await?
        .json()?;

    let proposal = ProposalInput {
        description: "proposal to test".to_string(),
        kind: ProposalKind::UpgradeSelf { hash },
        category: None
    };
    let res = root
        .call(&dao, "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);
    
    let res = root
        .call(&dao, "act_proposal")
        .args_json(json!({"id": 0, "action": Action::VoteApprove}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize)]
struct NewArgs {
    owner_id: AccountId,
    exchange_fee: u32,
    referral_fee: u32,
}

// /// Test that astra can upgrade another contract.
#[tokio::test]
async fn test_upgrade_other() -> anyhow::Result<()> {
    let (root, dao, worker) = setup_dao().await?;
    let _ = transfer_near(&worker, root.id(), ONE_NEAR * 1000).await?;
    let (other_contract, _) = setup_test_token(worker).await?;

    let res = root
        .call(dao.id(), "store_blob")
        .args(include_bytes!("../../res/test_token.wasm").to_vec())
        .max_gas()
        .deposit(ONE_NEAR * 200)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);
    let hash: Base58CryptoHash = res.json()?; 

    let proposal = ProposalInput {
        description: "test".to_string(),
        kind: ProposalKind::UpgradeRemote {
            receiver_id: other_contract.id().clone().parse().unwrap(),
            method_name: "upgrade".to_string(),
            hash,
        },
        category: None
    };
    let res = root
        .call(dao.id(), "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    vote(vec![root], &dao, 0).await?;

    Ok(())
}

'''
'''--- astra/tests/utils/mod.rs ---
use std::str::FromStr;

use anyhow::Ok;
use astra::{Action, ProposalInput, ProposalKind, OldAccountId, OLD_BASE_TOKEN, Bounty, Config, VersionedPolicy};
use near_sdk::{serde_json::json, Balance, AccountId, json_types::{U128, U64, Base64VecU8}, ONE_NEAR, env};
use workspaces::{AccountId as WorkAccountId, Contract, Account, Worker, DevNetwork, types::{SecretKey, KeyType}, network::Sandbox, result::ExecutionSuccess};

pub fn base_token() -> Option<AccountId> {
    None
}

pub async fn setup_dao() -> anyhow::Result<(Account, Contract, Worker<Sandbox>)> {
    let worker = workspaces::sandbox().await?;
    let dao_contract = worker.dev_deploy(include_bytes!("../../../res/astra.wasm")).await?;
    let root = worker.dev_create_account().await?;
    let config = Config {
        name: "test".to_string(),
        purpose: "to test".to_string(),
        metadata: Base64VecU8(vec![]),
    };
    // initialize contract
    let root_near_account: AccountId = root.id().parse().unwrap();
    let res1 = dao_contract
        .call("new")
        .args_json(json!({
            "config": config, "policy": VersionedPolicy::Default(vec![root_near_account.clone()]),
            "trust": root_near_account
        }))
        .max_gas()
        .transact().await?;
    assert!(res1.is_success(), "{:?}", res1);
    Ok((root, dao_contract, worker))
}

pub async fn setup_test_token(worker: Worker<Sandbox>) -> anyhow::Result<(Contract, Worker<Sandbox>)> {
    let test_token = worker.dev_deploy(include_bytes!("../../../res/test_token.wasm")).await?;
    let res1 = test_token
        .call("new")
        .max_gas()
        .transact().await?;
    assert!(res1.is_success(), "{:?}", res1);

    Ok((test_token, worker))
}

pub async fn setup_staking(token_id: WorkAccountId, dao: WorkAccountId, worker: Worker<Sandbox>) -> anyhow::Result<(Contract, Worker<Sandbox>)> {
    let staking = worker.dev_deploy(include_bytes!("../../../res/astra_staking.wasm")).await?;
    let res1 = staking
        .call("new")
        .args_json(json!({
            "owner_id": dao, "token_id": token_id,
            "unstake_period": U64(100_000_000_000)
        }))
        .max_gas()
        .transact().await?;
    assert!(res1.is_success(), "{:?}", res1);

    Ok((staking, worker))
}

pub async fn add_member_proposal(
    root: Account,
    dao: &Contract,
    member_id: AccountId,
) -> anyhow::Result<()> {
    let proposal = ProposalInput {
        description: "test".to_string(),
        kind: ProposalKind::AddMemberToRole {
            member_id,
            role: "council".to_string(),
        },
        category: None
    };
    let res = root
        .call(dao.id(), "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    Ok(())
}

pub async fn add_transfer_proposal(
    root: Account,
    dao: &Contract,
    token_id: Option<AccountId>,
    receiver_id: AccountId,
    amount: Balance,
    msg: Option<String>,
) -> anyhow::Result<()> {
    let proposal = ProposalInput {
        description: "test".to_string(),
        kind: ProposalKind::Transfer {
            token_id: convert_new_to_old_token(token_id),
            receiver_id,
            amount: U128(amount),
            msg,
        },
        category: None
    };
    let res = root
        .call(dao.id(), "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    Ok(())
}

pub async fn add_bounty_proposal(root: Account, dao: &Contract) -> anyhow::Result<u64> {
    let proposal = ProposalInput {
        description: "test".to_string(),
        kind: ProposalKind::AddBounty {
            bounty: Bounty {
                description: "test bounty".to_string(),
                token: String::from(OLD_BASE_TOKEN),
                amount: U128(ONE_NEAR * 10),
                times: 3,
                max_deadline: U64(env::block_timestamp() + 10_000_000_000),
            },
        },
        category: None
    };
    let res = root
        .call(dao.id(), "add_proposal")
        .args_json(json!({"proposal": proposal}))
        .max_gas()
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    Ok(res.json()?)
}

pub async fn vote(users: Vec<Account>, dao: &Contract, proposal_id: u64) -> anyhow::Result<()> {
    for user in users.into_iter() {
        let res = user
            .call(dao.id(), "act_proposal")
            .args_json(json!({"id": proposal_id, "action": Action::VoteApprove}))
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success(), "{:?}", res);
    }
    Ok(())
}

pub fn convert_new_to_old_token(new_account_id: Option<AccountId>) -> OldAccountId {
    if new_account_id.is_none() {
        return String::from(OLD_BASE_TOKEN);
    }
    new_account_id.unwrap().to_string()
}

// Generate user sub-account
pub async fn gen_user_account<T>(worker: &Worker<T>, account_id: &str) -> anyhow::Result<Account>
where
    T: DevNetwork + Send + Sync,
{
    let id = workspaces::AccountId::from_str(account_id)?;
    let sk = SecretKey::from_random(KeyType::ED25519);

    let account = worker.create_tla(id, sk).await?.into_result()?;

    Ok(account)
}

pub async fn transfer_near(
    worker: &Worker<Sandbox>,
    account_id: &workspaces::AccountId,
    deposit: Balance,
) -> anyhow::Result<ExecutionSuccess> {
    Ok(worker
        .root_account()?
        .transfer_near(account_id, deposit)
        .await?
        .into_result()?)
}
'''
'''--- build.sh ---
#!/bin/bash
set -e

cd astra
cargo build --target wasm32-unknown-unknown --release
cd ..
cargo build --target wasm32-unknown-unknown --release
mkdir -p res
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- common/Cargo.toml ---
[package]
name = "common"
version = "1.0.0"
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

'''
'''--- common/README.md ---
# Set of common functions and structures

- event handling

'''
'''--- common/src/events.rs ---
use near_sdk::env;
use near_sdk::serde::Serialize;

/// Helper struct to create Standard NEAR Event JSON.
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NearEvent<T: Serialize> {
    pub standard: &'static str,
    pub version: &'static str,

    // `flatten` to not have "event": {<EventVariant>} in the JSON, just have the contents of {<EventVariant>}.
    #[serde(flatten)]
    pub event: T,
}

impl<T: Serialize> NearEvent<T> {
    pub fn to_json_event_string(&self) -> String {
        let s = serde_json::to_string(&self)
            .ok()
            .unwrap_or_else(|| env::abort());
        format!("EVENT_JSON:{}", s)
    }

    pub fn emit(self) {
        env::log_str(&self.to_json_event_string());
    }
}

/// Helper struct to be used in `NearEvent.event` to construct NEAR Event compatible payload
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct EventPayload<T: Serialize> {
    /// event name
    pub event: &'static str,
    /// event payload
    pub data: T,
}

impl<T: Serialize> EventPayload<T> {
    pub fn emit(self, standard: &'static str, version: &'static str) {
        NearEvent {
            standard,
            version,
            event: self,
        }
        .emit()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::{test_utils, AccountId};

    use super::*;

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    #[test]
    fn emit_event_payload() {
        let expected = r#"EVENT_JSON:{"standard":"nepXYZ","version":"1.0.1","event":"mint","data":["alice.near",[821,10,44]]}"#;
        let tokens = vec![821, 10, 44];
        let event = EventPayload {
            event: "mint",
            data: (alice(), tokens),
        };
        event.emit("nepXYZ", "1.0.1");
        assert_eq!(vec![expected], test_utils::get_logs());
    }
}

'''
'''--- common/src/lib.rs ---
mod events;

pub use events::*;

'''
'''--- scripts/deploy_factory_dev.sh ---
#!/bin/bash
#### --------------------------------------------
#### NOTE: The following flows are supported in this file, for testing!
# - deploy factory v2
# - create new DAO
# - create 1-3 proposals
# - upgrade to factory v3 
# - submit DAO code v2 
# - submit DAO metadata v2
# - submit DAO code v3 
# - submit DAO metadata v3
# - upgrade DAO to v3 
# - check if proposals return
#### --------------------------------------------
set -e

# TODO: Change to the official approved commit:
COMMIT_V3=596f27a649c5df3310e945a37a41a957492c0322
# git checkout $COMMIT_V3

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  # export NEAR_ACCT=astra.$FACTORY
  export NEAR_ACCT=astrapm.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

export FACTORY_ACCOUNT_ID=factory_1.$NEAR_ACCT
# export DAO_ACCOUNT_ID=croncat.astra.$FACTORY
# export DAO_ACCOUNT_ID=astradao-dev-v2-1645228499.factory3.astrapm.testnet
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000

#### --------------------------------------------
#### Account & Data management for setup
#### --------------------------------------------
# near call $FACTORY_ACCOUNT_ID delete_contract '{"code_hash":"6SQymHtmezR3u9zAtLBQdb8RWCXxwxnigqSH2mRTxecB"}' --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS
# near delete $FACTORY_ACCOUNT_ID $NEAR_ACCT
near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 40
#### --------------------------------------------

#### --------------------------------------------
#### Grab the factory v2 code data
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'astra.$FACTORY'"}' \
| jq -r .result.code_base64 \
| base64 --decode > astra_factory_original.wasm

# Deploy the previous version to allow accurate testing
near deploy --wasmFile astra_factory_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
#### --------------------------------------------

#### --------------------------------------------
#### Deploy a v2 DAO & Some proposals
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=astradao-dev-v2-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "astra Dev v2 DAO '$TIMESTAMP'", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 10
DEMO_DAO_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID

# some sample payouts
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "1337000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "1000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "2000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DEMO_DAO_ACCOUNT act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
near call $DEMO_DAO_ACCOUNT act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DEMO_DAO_ACCOUNT get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Quick sanity check on getters
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade the factory
#### NOTE: Make sure you've built on the right commit!
#### --------------------------------------------
near deploy --wasmFile astra-factory/res/astra_factory.wasm --accountId $FACTORY_ACCOUNT_ID --force
#### --------------------------------------------

#### --------------------------------------------
#### Grab the DAO v2 code data & store it in factory
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'$DAO_ACCOUNT_ID'"}' \
| jq -r .result.code_base64 \
| base64 --decode > astra_original.wasm

# Store the code data
V2_BYTES='cat astra_original.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS --amount 10 > v2_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2_CODE_HASH=$(eval "tail -1 v2_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2 CODE HASH: $V2_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2_CODE_HASH'", "metadata": {"version": [2,0], "commit_id": "c2cf1553b070d04eed8f659571440b27d398c588"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v3 code data & store it in factory
#### --------------------------------------------
# Store the code data
V3_BYTES='cat astra/res/astra.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V3_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS --amount 10 > v3_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V3_CODE_HASH'", "metadata": {"version": [3,0], "commit_id": "'$COMMIT_V3'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata & DAO
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
# Check a v2 DAO
near view $DEMO_DAO_ACCOUNT get_proposal '{"id": 0}'
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
near view $DAO_ACCOUNT_ID get_proposal '{"id": 2}'
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade a v2 DAO
#### --------------------------------------------
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "Upgrade V3 CODE HASH: $V3_CODE_HASH"
# some sample payouts
near call $DAO_ACCOUNT_ID add_proposal '{"proposal": { "description": "Upgrade to v3", "kind": { "UpgradeSelf": { "hash": "'$V3_CODE_HASH'" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DAO_ACCOUNT_ID act_proposal '{"id": 3, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DAO_ACCOUNT_ID get_proposal '{"id": 0}'
near view $DAO_ACCOUNT_ID get_proposal '{"id": 3}'
#### --------------------------------------------

#### --------------------------------------------
#### Deploy a v3 DAO & Some proposals
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=astradao-dev-v3-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "astra Dev v3 DAO '$TIMESTAMP'", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 10
DEMO_DAO_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID

# Quick check for v3 DAO
near view $DEMO_DAO_ACCOUNT get_available_amount

# some sample payouts
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "1000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "2000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
near call $DEMO_DAO_ACCOUNT add_proposal '{"proposal": { "description": "Sample payment", "kind": { "Transfer": { "token_id": "", "receiver_id": "'$NEAR_ACCT'", "amount": "3000000000000000000000000" } } } }' --accountId $NEAR_ACCT --amount 1
# approve some, leave some
near call $DEMO_DAO_ACCOUNT act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
near call $DEMO_DAO_ACCOUNT act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $DEMO_DAO_ACCOUNT get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check v3 dao all worked
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm astra_original.wasm
rm astra_factory_original.wasm
rm v2_code_hash_result.txt
rm v3_code_hash_result.txt

echo "Dev Factory Deploy & Test Complete"
'''
'''--- scripts/upgrade_dao_direct_dev.sh ---
#!/bin/bash
#### --------------------------------------------
#### NOTE: The following flows are supported in this file, for testing!
# - Create an Upgradeable DAO via astra.testnet, for testing v2-v3 upgrade
# - Upgradeable DAO store_blob
# - Upgradeable DAO proposal UpgradeSelf with hash from UpgradeDAO store_blob
# - Check code_hash on Upgradeable DAO
#### --------------------------------------------
set -e

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  # export NEAR_ACCT=astra.$FACTORY
  export NEAR_ACCT=astrapm.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

# export FACTORY_ACCOUNT_ID=astra.$FACTORY
export FACTORY_ACCOUNT_ID=factory13.$NEAR_ACCT
# export DAO_ACCOUNT_ID=croncat.astra.$FACTORY
# export DAO_ACCOUNT_ID=astradao-dev-v2-1645228499.factory3.astrapm.testnet
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000

# #### --------------------------------------------
# #### New Factory for entire test
# #### --------------------------------------------
near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 80
# #### --------------------------------------------

#### --------------------------------------------
#### Grab the factory v2 code data
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'astra.$FACTORY'"}' \
| jq -r .result.code_base64 \
| base64 --decode > astra_factory_original.wasm

# Deploy the previous version to allow accurate testing
near deploy --wasmFile astra_factory_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
#### --------------------------------------------

#### --------------------------------------------
#### Deploy UpgradeDAO
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=upgradadora-1-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "A DAO to propose upgrade bytes to other DAOs", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 50
UPGRADEDAO_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Deploy Upgradeable DAO
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=upgrademe-1-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "A v2 dao that gets upgraded by self from remote submitted bytes", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 10
UPGRDADEME_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Store blob
#### --------------------------------------------
# propose function call on UpgradeDAO to store_blob on Upgradeable DAO
V3_BYTES='cat astra/res/astra.wasm | base64'

near call $UPGRDADEME_ACCOUNT store_blob $(eval "$V3_BYTES") --base64 --accountId $NEAR_ACCT --depositYocto $BYTE_STORAGE_COST --gas $MAX_GAS > v3_code_hash_result.txt

V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Proposal
#### --------------------------------------------
# propose UpgradeSelf using the code_hash from store_blob
near call $UPGRDADEME_ACCOUNT add_proposal '{
  "proposal": {
    "description": "Upgrade to v3 DAO code using code_hash '$CODE_HASH'",
    "kind": {
      "UpgradeSelf": {
        "hash": "'$V3_CODE_HASH'"
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $UPGRDADEME_ACCOUNT act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $UPGRDADEME_ACCOUNT get_proposal '{"id": 0}'
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm astra_factory_original.wasm
rm v3_code_hash_result.txt

echo "Dev: Go to https://explorer.testnet.near.org/accounts/$UPGRDADEME_ACCOUNT and check the code_hash matches $CODE_HASH"
'''
'''--- scripts/upgrade_dao_proposal_dev.sh ---
#!/bin/bash
#### --------------------------------------------
#### NOTE: The following flows are supported in this file, for testing!
# - Create an UpgradeDAO via astra.testnet, funded with enough for 10 upgrades
# - Create an Upgradeable DAO via astra.testnet, for testing v2-v3 upgrade
# - UpgradeDAO proposal to store_blob on Upgradeable DAO
# - Upgradeable DAO proposal UpgradeSelf with hash from UpgradeDAO store_blob
# - Check code_hash on Upgradeable DAO
#### --------------------------------------------
set -e

# # TODO: Change to the official approved commit:
# COMMIT_V3=596f27a649c5df3310e945a37a41a957492c0322
# # git checkout $COMMIT_V3

# build the things
./build.sh

export NEAR_ENV=testnet
export FACTORY=testnet

if [ -z ${NEAR_ACCT+x} ]; then
  # export NEAR_ACCT=astra.$FACTORY
  export NEAR_ACCT=astrapm.$FACTORY
else
  export NEAR_ACCT=$NEAR_ACCT
fi

# export FACTORY_ACCOUNT_ID=astra.$FACTORY
export FACTORY_ACCOUNT_ID=factory_1.$NEAR_ACCT
# export DAO_ACCOUNT_ID=croncat.astra.$FACTORY
export MAX_GAS=300000000000000
export GAS_100_TGAS=100000000000000
export GAS_150_TGAS=150000000000000
export GAS_220_TGAS=220000000000000
BOND_AMOUNT=1
BYTE_STORAGE_COST=6000000000000000000000000
COMMIT_V3=596f27a649c5df3310e945a37a41a957492c0322
V3_CODE_HASH=FRc1X7yrgGEnjVEauMMuPTQJmzDdp3ZDfxjomkrLexzq

# #### --------------------------------------------
# #### New Factory for entire test
# #### --------------------------------------------
near create-account $FACTORY_ACCOUNT_ID --masterAccount $NEAR_ACCT --initialBalance 80
# #### --------------------------------------------

#### --------------------------------------------
#### Grab the factory v2 code data
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'astra.$FACTORY'"}' \
| jq -r .result.code_base64 \
| base64 --decode > astra_factory_original.wasm

# Deploy the previous version to allow accurate testing
near deploy --wasmFile astra_factory_original.wasm --accountId $FACTORY_ACCOUNT_ID --initFunction new --initArgs '{}' --initGas $MAX_GAS
#### --------------------------------------------

#### --------------------------------------------
#### Deploy Upgradeable DAO
#### --------------------------------------------
COUNCIL='["'$NEAR_ACCT'"]'
TIMESTAMP=$(date +"%s")
DAO_NAME=upgrademe-1-$TIMESTAMP
DAO_ARGS=`echo '{"config": {"name": "'$DAO_NAME'", "purpose": "A v2 dao that gets upgraded by self from remote submitted bytes", "metadata":""}, "policy": '$COUNCIL'}' | base64`
near call $FACTORY_ACCOUNT_ID create "{\"name\": \"$DAO_NAME\", \"args\": \"$DAO_ARGS\"}" --accountId $FACTORY_ACCOUNT_ID --gas $GAS_150_TGAS --amount 12
UPGRDADEME_ACCOUNT=$DAO_NAME.$FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Quick sanity check on getters
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_dao_list
#### --------------------------------------------

#### --------------------------------------------
#### Upgrade the factory
#### NOTE: Make sure you've built on the right commit!
#### --------------------------------------------
near deploy --wasmFile astra-factory/res/astra_factory.wasm --accountId $FACTORY_ACCOUNT_ID --force
#### --------------------------------------------

#### --------------------------------------------
#### Grab the DAO v2 code data & store it in factory
#### --------------------------------------------
http --json post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
params:='{"request_type":"view_code","finality":"final","account_id":"'$DAO_ACCOUNT_ID'"}' \
| jq -r .result.code_base64 \
| base64 --decode > astra_original.wasm

# Store the code data
V2_BYTES='cat astra_original.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V2_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS --amount 10 > v2_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V2_CODE_HASH=$(eval "tail -1 v2_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V2 CODE HASH: $V2_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V2_CODE_HASH'", "metadata": {"version": [2,0], "commit_id": "c2cf1553b070d04eed8f659571440b27d398c588"}, "set_default": false}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Get DAO v3 code data & store it in factory
#### --------------------------------------------
# Store the code data
V3_BYTES='cat astra/res/astra.wasm | base64'
near call $FACTORY_ACCOUNT_ID store $(eval "$V3_BYTES") --base64 --accountId $FACTORY_ACCOUNT_ID --gas $GAS_100_TGAS --amount 10 > v3_code_hash_result.txt

# Update the factory metadata
# Get the response code hash!
V3_CODE_HASH=$(eval "tail -1 v3_code_hash_result.txt | sed 's/^.//;s/.$//'")
echo "V3 CODE HASH: $V3_CODE_HASH"
near call $FACTORY_ACCOUNT_ID store_contract_metadata '{"code_hash": "'$V3_CODE_HASH'", "metadata": {"version": [3,0], "commit_id": "'$COMMIT_V3'"}, "set_default": true}' --accountId $FACTORY_ACCOUNT_ID
#### --------------------------------------------

#### --------------------------------------------
#### Sanity check the new metadata
#### --------------------------------------------
near view $FACTORY_ACCOUNT_ID get_contracts_metadata
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Proposal
#### --------------------------------------------
# FRc1X7yrgGEnjVEauMMuPTQJmzDdp3ZDfxjomkrLexzq

UPGRADE_PROPOSAL_ARGS=`echo '{"code_hash":"FRc1X7yrgGEnjVEauMMuPTQJmzDdp3ZDfxjomkrLexzq"}' | base64`
# propose UpgradeSelf using the code_hash from store_blob
near call $UPGRDADEME_ACCOUNT add_proposal '{
  "proposal": {
    "description": "Upgrade to v3 DAO code using upgrade contract via factory",
    "kind": {
      "FunctionCall": {
        "receiver_id": "'$FACTORY_ACCOUNT_ID'",
        "actions": [
          {
            "method_name": "store_contract_self",
            "args": "'$UPGRADE_PROPOSAL_ARGS'",
            "deposit": "'$BYTE_STORAGE_COST'",
            "gas": "'$GAS_220_TGAS'"
          }
        ]
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $UPGRDADEME_ACCOUNT act_proposal '{"id": 0, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $UPGRDADEME_ACCOUNT get_proposal '{"id": 0}'
#### --------------------------------------------

#### --------------------------------------------
#### Upgradeable DAO Proposal
#### --------------------------------------------
V3_CODE_HASH=FRc1X7yrgGEnjVEauMMuPTQJmzDdp3ZDfxjomkrLexzq
# propose UpgradeSelf using the code_hash from store_blob
near call $UPGRDADEME_ACCOUNT add_proposal '{
  "proposal": {
    "description": "Upgrade to v3 DAO code using local stored code",
    "kind": {
      "UpgradeSelf": {
        "hash": "'$V3_CODE_HASH'"
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $UPGRDADEME_ACCOUNT act_proposal '{"id": 1, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $UPGRDADEME_ACCOUNT get_proposal '{"id": 1}'
#### --------------------------------------------

#### --------------------------------------------
#### Remove cached blob DAO Proposal
#### --------------------------------------------
# FRc1X7yrgGEnjVEauMMuPTQJmzDdp3ZDfxjomkrLexzq

REMOVE_PROPOSAL_ARGS=`echo '{"code_hash":"FRc1X7yrgGEnjVEauMMuPTQJmzDdp3ZDfxjomkrLexzq"}' | base64`
# propose UpgradeSelf using the code_hash from store_blob
near call $UPGRDADEME_ACCOUNT add_proposal '{
  "proposal": {
    "description": "Remove DAO upgrade contract local code blob via factory",
    "kind": {
      "FunctionCall": {
        "receiver_id": "'$FACTORY_ACCOUNT_ID'",
        "actions": [
          {
            "method_name": "remove_contract_self",
            "args": "'$REMOVE_PROPOSAL_ARGS'",
            "deposit": "0",
            "gas": "'$GAS_220_TGAS'"
          }
        ]
      }
    }
  }
}' --accountId $NEAR_ACCT --amount $BOND_AMOUNT --gas $MAX_GAS
# approve
near call $UPGRDADEME_ACCOUNT act_proposal '{"id": 2, "action" :"VoteApprove"}' --accountId $NEAR_ACCT  --gas $MAX_GAS
# quick check all is good
near view $UPGRDADEME_ACCOUNT get_proposal '{"id": 2}'
#### --------------------------------------------

# #### --------------------------------------------
# cleanup local files!
# #### --------------------------------------------
rm astra_original.wasm
rm astra_factory_original.wasm
rm v2_code_hash_result.txt
rm v3_code_hash_result.txt

echo "Dev: Go to https://explorer.testnet.near.org/accounts/$UPGRDADEME_ACCOUNT and check the code_hash matches $CODE_HASH"
'''
'''--- test-token/Cargo.toml ---
[package]
name = "test-token"
version = "0.1.0"
authors = ["Illia Polosukhin <illia.polosukhin@gmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk.workspace = true
near-contract-standards.workspace = true

'''
'''--- test-token/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cd ..
mkdir -p res
cp target/wasm32-unknown-unknown/release/test_token.wasm res/

'''
'''--- test-token/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{near_bindgen, AccountId, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            token: FungibleToken::new(b"t".to_vec()),
        }
    }

    pub fn mint(&mut self, account_id: AccountId, amount: U128) {
        self.token.internal_register_account(&account_id);
        self.token.internal_deposit(&account_id, amount.into());
    }

    pub fn burn(&mut self, account_id: AccountId, amount: U128) {
        self.token.internal_withdraw(&account_id, amount.into());
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        unimplemented!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{env, testing_env};

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = Contract::new();
        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.mint(accounts(0), 1_000_000.into());
        assert_eq!(contract.ft_balance_of(accounts(0)), 1_000_000.into());

        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.storage_deposit(Some(accounts(1)), None);
        testing_env!(context
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.ft_transfer(accounts(1), 1_000.into(), None);
        assert_eq!(contract.ft_balance_of(accounts(1)), 1_000.into());

        contract.burn(accounts(1), 500.into());
        assert_eq!(contract.ft_balance_of(accounts(1)), 500.into());
    }
}

'''