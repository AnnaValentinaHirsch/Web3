*GitHub Repository "EvmosGov/tracker"*

'''--- .eslintrc.json ---
{
  "extends": "next/core-web-vitals"
}

'''
'''--- .github/ISSUE_TEMPLATE/config.yml ---
blank_issues_enabled: true
contact_links:
  - name: Commonwealth Discussions
    url: https://commonwealth.im/evmos/
    about: Join the discussions revolving around Governance on Commonwealth  
    
  - name: Evmos Discord
    url: https://discord.gg/evmos
    about: Join the discussions revolving around Governance on Discord
'''
'''--- .github/ISSUE_TEMPLATE/new_issue.yml ---
name: New Governance Issue
description: File a governance related issue
title: '<title>'
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this governance issue! The more info you provide, the more we can help.

  - type: textarea
    attributes:
      label: üöß The Issue, Concern, or Problem
      description: A concise description of what the problem in our governance.
    validations:
      required: true

  - type: textarea
    attributes:
      label: ‚úÖ Possible Solutions
      description: If you have ideas on how this issue can be solved, please share!
    validations:
      required: false

  - type: input
    attributes:
      label: üåê Link to Commonwealth Discussion
      description: |
        If this issue has been talked about on Commonwealth, please link to the thread for reference.
      placeholder: https://commonwealth.im/evmos/...
    validations:
      required: false

  - type: input
    attributes:
      label: üåê Other Relevant Link
      description: |
        If there is another link you would like to submit, please do so here.
      placeholder: https://twitter.com/evmosorg/...
    validations:
      required: false

  - type: textarea
    attributes:
      label: Anything else?
      description: |
        üí° Tip: You can attach images or log files by clicking this area to highlight it and then dragging files in.
    validations:
      required: false
      
  - type: checkboxes
    attributes:
      label: Is there an existing issue for this?
      description: Please search to see if an issue already exists for the bug you encountered.
      options:
        - label: I have searched the existing issues
          required: true

'''
'''--- README.md ---
# Evmos Govnernance Issue Tracker

## Dev

Checkout the repo and set the required environmental variables by copying `./.env.example` into `./.env.local`.

Next, install the dependencies:

```bash
npm install
# or
yarn install
```

Run the development server:

```bash
npm run dev
# or
yarn dev
```

'''
'''--- jest.config.js ---
/** @type {import('ts-jest/dist/types').InitialOptionsTsJest} */
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
};

'''
'''--- next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/types/global" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

'''
'''--- next.config.js ---
/** @type {import('next').NextConfig} */
module.exports = {
  reactStrictMode: true,
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}

'''
'''--- package.json ---
{
  "name": "better-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@guildxyz/sdk": "^0.1.2",
    "@headlessui/react": "^1.4.2",
    "@rainbow-me/rainbowkit": "^0.3.4",
    "@tailwindcss/forms": "^0.4.0",
    "axios": "^0.23.0",
    "daisyui": "^2.17.0",
    "ethers": "^5.6.9",
    "mongodb": "^4.1.3",
    "near-api-js": "^0.43.1",
    "next": "^12.0.1",
    "octokit": "^1.7.0",
    "react": "17.0.2",
    "react-dom": "17.0.2",
    "react-icons": "^4.4.0",
    "react-markdown": "^7.1.1",
    "react-query": "^3.28.0",
    "remark-gfm": "^3.0.1",
    "wagmi": "^0.4.12"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.0",
    "@types/jest": "^27.0.2",
    "@types/react": "17.0.27",
    "autoprefixer": "^10.4.0",
    "eslint": "8.0.0",
    "eslint-config-next": "^12.0.1",
    "jest": "^27.3.1",
    "near-sdk-as": "^3.2.3",
    "postcss": "^8.4.5",
    "prettier": "^2.4.1",
    "tailwindcss": "^3.0.7",
    "ts-jest": "^27.0.7",
    "typescript": "4.4.3"
  }
}

'''
'''--- postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

'''
'''--- public/js/mobile.js ---
document.addEventListener('DOMContentLoaded', function() {
    const burger = document.querySelectorAll('.navbar-burger');
    const menu = document.querySelectorAll('.navbar-menu');

    if (burger.length && menu.length) {
        for (var i = 0; i < burger.length; i++) {
            burger[i].addEventListener('click', function() {
                for (var j = 0; j < menu.length; j++) {
                    menu[j].classList.toggle('hidden');
                }
            });
        }
    }

    const close = document.querySelectorAll('.navbar-close');
    const backdrop = document.querySelectorAll('.navbar-backdrop');

    if (close.length) {
        for (var i = 0; i < close.length; i++) {
            close[i].addEventListener('click', function() {
                for (var j = 0; j < menu.length; j++) {
                    menu[j].classList.toggle('hidden');
                }
            });
        }
    }

    if (backdrop.length) {
        for (var i = 0; i < backdrop.length; i++) {
            backdrop[i].addEventListener('click', function() {
                for (var j = 0; j < menu.length; j++) {
                    menu[j].classList.toggle('hidden');
                }
            });
        }
    }
});
'''
'''--- public/vercel.svg ---
<svg width="283" height="64" viewBox="0 0 283 64" fill="none" 
    xmlns="http://www.w3.org/2000/svg">
    <path d="M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z" fill="#000"/>
</svg>
'''
'''--- src/config.ts ---
export const githubConfig = {
  repoOwner: process.env.NEXT_PUBLIC_REPO_OWNER || "",
  repoName: process.env.NEXT_PUBLIC_REPO_NAME || "",
  labels: {
    planned: ["planned"],
    inprogress: ["inprogress"],
    proposed: ["proposed"],
    onchain: ["onchain"],
  },

  // secret
  pat: process.env.GITHUB_PAT || "",
};

export const nearChainConfig = {
  networkId: process.env.NEXT_PUBLIC_NEAR_NETWORK_ID || "",
  walletUrl: process.env.NEXT_PUBLIC_NEAR_WALLET_URL || "",
  helperUrl: process.env.NEXT_PUBLIC_NEAR_HELPER_URL || "",
  explorerUrl: process.env.NEXT_PUBLIC_NEAR_EXPLORER_URL || "",
  apiBaseUrl: process.env.NEXT_PUBLIC_NEAR_API_BASE_URL || "",
  jsonRpcUrl: process.env.NEXT_PUBLIC_NEAR_JSON_RPC_URL || "",
  daoId: process.env.NEXT_PUBLIC_NEAR_DAO_ID || "",
};

export const siteConfig = {
  enabledChains: ["near", "evmos"],
  projectName: "Evmos Proposals",
  title: "Evmos Governance Issue Tracker",
  metaDescription: "An issue tracker for all things related to Evmos governance.",
  url: "https://tracker.evmos.vision",
  metaImg: "/card.png",
};

export const config = {
  github: githubConfig,
  chains: {
    near: nearChainConfig,
  },
  site: siteConfig,
};

export default config;

'''
'''--- src/features/api-routes/api/github/__tests__/utils.test.ts ---
import * as githubUtils from "../utils";

describe("github", () => {
  describe("#getMetadataAndClean()", () => {
    const metadata = {
      bounties: [
        {
          chain: "near",
          bountyId: 1,
        },
      ],
    };

    it("should return parsed description metadata", () => {
      const description = `This is a description \n\n<!-- better-meta = ${JSON.stringify(
        metadata
      )} -->`;

      const { metadata: descriptionMetadata } =
        githubUtils.getMetadataAndCleanedComment(description);
      expect(descriptionMetadata).toMatchObject(metadata);
    });

    it("should return empty parsed description metadata", () => {
      const description = `This is a description`;

      const { metadata: descriptionMetadata } =
        githubUtils.getMetadataAndCleanedComment(description);
      expect(descriptionMetadata).toMatchObject({
        bounties: [],
      });
    });
  });
});

'''
'''--- src/features/api-routes/api/github/index.ts ---
import { Octokit } from "octokit";

import config from "../../../../config";
import { metadataCommentRegex } from "./utils";

import type { ReqParams } from "../../../common/types";

const octokit = new Octokit({ auth: config.github.pat });

export async function getIssues(
  reqParams: ReqParams & {
    labels?: string;
  }
) {
  const { perPage = 10, page = 1, labels } = reqParams;

  let labelsArray = labels?.split(",");

  const { data = [] } = await octokit.rest.issues.listForRepo({
    owner: config.github.repoOwner,
    repo: config.github.repoName,
    per_page: perPage,
    page,
  });

  let filtered = data.filter((issue) =>
    issue.labels.some((label) => labelsArray?.includes(label.name))
  );

  return filtered;
}

export async function getIssueByNumber(issueNumber: number) {
  const { data } = await octokit.rest.issues.get({
    owner: config.github.repoOwner,
    repo: config.github.repoName,
    issue_number: issueNumber,
  });

  return data;
}

export async function upsertMetadataComment(params: {
  metadataCommentBody: string;
  issueNumber: number;
  metadataCommentId?: number;
}) {
  if (!params.metadataCommentId) {
    await octokit.rest.issues.createComment({
      owner: config.github.repoOwner,
      repo: config.github.repoName,
      issue_number: params.issueNumber,
      body: params.metadataCommentBody,
    });
  } else {
    await octokit.rest.issues.updateComment({
      owner: config.github.repoOwner,
      repo: config.github.repoName,
      issue_number: params.issueNumber,
      comment_id: params.metadataCommentId as number,
      body: params.metadataCommentBody,
    });
  }
  return true;
}

export async function updateMetadataComment() {}

export async function getMetadataComment(issueNumber: number) {
  const { data = [] } = await octokit.rest.issues.listComments({
    owner: config.github.repoOwner,
    repo: config.github.repoName,
    issue_number: issueNumber,
  });

  const metadataComment = data.find((comment) => {
    const match = comment.body?.match(metadataCommentRegex);
    return Boolean(match);
  });

  return metadataComment;
}

export async function getMetadataCommentId(issueNumber: number) {
  const { data = [] } = await octokit.rest.issues.listComments({
    owner: config.github.repoOwner,
    repo: config.github.repoName,
    issue_number: issueNumber,
  });

  const metadataComment = data.find((comment) => {
    const match = comment.body?.match(metadataCommentRegex);
    return Boolean(match);
  });

  return { id: metadataComment?.id, body: metadataComment?.body };
}

'''
'''--- src/features/api-routes/api/github/types.ts ---
export type Metadata = {
  bounties: {
    chain: string;
    bountyId: number;
  }[];
  address: string
};

export type CommentMatadata = {
  votes : number;
  voters: string[]
}

'''
'''--- src/features/api-routes/api/github/utils.ts ---
import type { Metadata , CommentMatadata } from "./types";

export const metadataCommentRegex = /<!-- better-meta = (.*) -->/;

export function getMetadataAndCleanedComment(comment: string): {
  metadata: Metadata | CommentMatadata;
  cleanedComment: string;
} {
  const match = comment.match(metadataCommentRegex);

  const metadata = match ? JSON.parse(match[1]) : { address: [] };
  const cleanedComment = comment.replace(metadataCommentRegex, "");
  return { cleanedComment, metadata };
}

export function setMetadataComment(
  metadataInfoText: string,
  metadata: Metadata | CommentMatadata
) {
  return `${metadataInfoText}\n\n<!-- better-meta = ${JSON.stringify(
    metadata
  )} -->`;
}

export function buildMetadataInfoText(metadata: Metadata) {
  let infoComment = `This issue has ${metadata.bounties.length} bounties.\n`;
  for (const bounty of metadata.bounties) {
    infoComment += `Chain: ${bounty.chain}, Bounty ID: ${bounty.bountyId}\n`;
  }
  return infoComment;
}

'''
'''--- src/features/api-routes/handlers/bounties/index.ts ---
import * as githubApi from "../../api/github";
import {
  getMetadataAndCleanedComment,
  setMetadataComment,
  buildMetadataInfoText,
} from "../../api/github/utils";
import { ApiError } from "../utils";

import type { NextApiRequest, NextApiResponse } from "next";

/**
 * `POST /bounties`
 */
export async function postBountiesHandler(
  req: NextApiRequest,
  res: NextApiResponse<{
    message?: string;
    error?: any;
  }>
) {
  const requiredPostBodyKeys = ["issueNumber", "chain", "bountyId"];
  const postBody: {
    issueNumber: number;
    chain: string;
    bountyId: number;
  } = req.body;

  Object.keys(postBody).forEach((postBodyKey) => {
    if (!requiredPostBodyKeys.includes(postBodyKey)) {
      throw new ApiError(
        400,
        `Required POST body keys: ${requiredPostBodyKeys}`
      );
    }
  });

  const metadataComment = await githubApi.getMetadataComment(
    postBody.issueNumber
  );
  const { metadata } = getMetadataAndCleanedComment(
    metadataComment?.body || ""
  );

  const updatedMetadata = {
    ...metadata,
    bounties: [
      ...metadata.bounties,
      {
        chain: postBody.chain,
        bountyId: postBody.bountyId,
      },
    ],
  };

  const newMetadataCommentBody = setMetadataComment(
    buildMetadataInfoText(updatedMetadata),
    updatedMetadata
  );

  await githubApi.upsertMetadataComment({
    metadataCommentBody: newMetadataCommentBody,
    issueNumber: postBody.issueNumber,
    metadataCommentId: metadataComment?.id,
  });

  res.status(200).json({ message: "OK" });
}

'''
'''--- src/features/api-routes/handlers/issues/index.ts ---
import * as githubApi from "../../api/github";
import { getMetadataAndCleanedComment } from "../../api/github/utils";
import { ApiError, apiErrorHandler } from "../utils";

import type { NextApiRequest, NextApiResponse } from "next";
import { getVoteCount } from "features/common/hooks/useGuildQueries";

/**
 * `GET /issues`
 */
export async function getIssuesListHandler(
  req: NextApiRequest,
  res: NextApiResponse<{
    issues?: any[];
    error?: any;
  }>
) {
  try {
    if (req.method !== "GET") {
      throw new ApiError(400, `Method ${req.method} not allowed`);
    }

    const githubIssues = await githubApi.getIssues({
      page: Number(req.query.page) || 1,
      perPage: Number(req.query.perPage) || 10,
      labels: Array.isArray(req.query.labels)
        ? req.query.labels.join(",")
        : req.query.labels,
    });

    const githubIssuesWithMetadataComment = await Promise.all(
      githubIssues.map(async (issue) => {
        const metadataComment = await githubApi.getMetadataComment(
          issue.number
        );
        return {
          ...issue,
          metadataComment,
        };
      })
    );

    const githubIssuesWithParsedMetadata = githubIssuesWithMetadataComment.map(
      (issueWithMetadataComment) => {
        const { metadata } = getMetadataAndCleanedComment(
          issueWithMetadataComment.metadataComment?.body || ""
        );
        return {
          ...issueWithMetadataComment,
          metadata,
        };
      }
    );

    return res.status(200).json({ issues: githubIssuesWithParsedMetadata });
  } catch (error) {
    apiErrorHandler(res, error);
  }
}

/**
 * `GET /issues/:issueId`
 */
export async function getIssueDetailsHandler(
  req: NextApiRequest,
  res: NextApiResponse<{
    issue?: any;
    error?: any;
  }>
) {
  try {
    if (req.method !== "GET") {
      throw new ApiError(400, `Method ${req.method} not allowed`);
    }

    const githubIssue = await githubApi.getIssueByNumber(
      Number(req.query.issueNumber as string)
    );
    const metadataComment = await githubApi.getMetadataComment(
      githubIssue.number
    );
    const { metadata, cleanedComment } = getMetadataAndCleanedComment(
      metadataComment ? metadataComment?.body || "" : ""
    );

    return res.status(200).json({
      issue: {
        ...githubIssue,
        metadataComment,
        cleanedComment,
        metadata,
      },
    });
  } catch (error) {
    apiErrorHandler(res, error);
  }
}

'''
'''--- src/features/api-routes/handlers/utils.ts ---
import type { NextApiRequest, NextApiResponse } from "next";

export class ApiError extends Error {
  statusCode: number;

  constructor(statusCode: number, message: string) {
    super(message);
    this.statusCode = statusCode;
  }
}

export function apiErrorHandler(res: NextApiResponse, error: any) {
  const { statusCode = 0, message } = error;

  console.error(error);

  if (statusCode === 500 || statusCode === 0) {
    return res.status(500).json({ error: "Internal Server Error" });
  }
  return res.status(statusCode).json({ error: message });
}

'''
'''--- src/features/api-routes/types.ts ---
export type ReqParams = {
  perPage?: any;
  page?: any;
};

'''
'''--- src/features/bounties/api.ts ---
import axios from "axios";

export async function addBountyToMetadataComment(
  issueNumber: number,
  bountyMetadata: {
    chain: string;
    bountyId: number;
  }
) {
  return axios.post<any>(`/api/bounties`, {
    issueNumber,
    chain: bountyMetadata.chain,
    bountyId: bountyMetadata.bountyId,
  });
}

'''
'''--- src/features/bounties/hooks/useAddBountyMutation.ts ---
import { useMutation, useQueryClient } from "react-query";

import { chainsToApi } from "features/common/constants";
import { addBountyToMetadataComment } from "../api";

export default function useAddBountyMutation() {
  const queryClient = useQueryClient();

  const addBountyMutation = useMutation(
    async (params: {
      issueNumber: string;
      chain: string;
      issueDescription: string;
      token: string;
      amount: string;
      maxDeadline: number;
    }) => {
      const { addBounty } = chainsToApi[params.chain];

      const bountyId = await addBounty(params);
      // await addBountyToMetadataComment(params.issueNumber, {
      //   chain: params.chain,
      //   bountyId,
      // });
    },
    {
      onSuccess: (data, variables) => {
        queryClient.invalidateQueries(["issues", variables.issueNumber]);
      },
    }
  );
  return addBountyMutation;
}

'''
'''--- src/features/bounties/types.ts ---
export type BountyParams = {
  issueNumber: number;
  issueDescription: string;
  token: string;
  amount: string;
  maxDeadline: number;
};

export type Bounty = {
  issueId: string;
  pool: string;
  funders: string[];
  workers: string[];
  status: string;
  deadline: string;
};

'''
'''--- src/features/common/constants.ts ---
import * as evmosApi from "features/evmos/api";

import type { ChainApi } from "./types";

export const chains = {
  EVMOS: "evmos"
};

export const chainsToApi: {
  [chain: string]: ChainApi;
} = {
  [chains.EVMOS]: {
    // Wallet API
    signIn: evmosApi.signIn,
    signOut: evmosApi.signOut,
    isSignedIn: evmosApi.isSignedIn,
    getAccountId: evmosApi.getAccountId,
    // Contract API
    addBounty: evmosApi.addBounty,
    claimBounty: evmosApi.claimBounty,
    doneBounty: evmosApi.doneBounty,
    giveUpBounty: evmosApi.giveUpBounty,
    getBountyById: evmosApi.getBountyById,
    // Tokens API
    getTokens: evmosApi.getTokens,
  },
};

'''
'''--- src/features/common/hooks/useGuildQueries.ts ---
import { guild } from "@guildxyz/sdk";
import axios from "axios";
import { Issue } from "features/issues/types";
import { useMutation, useQuery, useQueryClient } from "react-query";
import { nearAccountToHex } from "utils/helpers";
import { chainsToApi } from "../constants";

/*
 * It checks if the user has access to vote or not
 * @returns A boolean value
 */
export function useVotingAccessQuery() {
  const walletChain = window.localStorage.getItem("wallet-chain");

  return useQuery("hasVotingAccess", async () => {
    if (!walletChain) {
      return null;
    }
    const { getAccountId } = chainsToApi[walletChain];

    return getAccountId().then(async (accountId) => {
      const account = nearAccountToHex([accountId]);

      //Getting guild roles data
      const guildData = await guild.getUserAccess(
        parseInt(process.env.NEXT_PUBLIC_GUILD_ID),
        account[0]
      );

      //Getting role id by chain
      const roleId: string =
        walletChain === "near"
          ? process.env.NEXT_PUBLIC_NEAR_ROLE_ID
          : process.env.NEXT_PUBLIC_ROLE_ID;

      let canVote: boolean = false;

      //Checking if user has access to vote or not
      guildData.forEach((access) => {
        if (access.roleId === parseInt(roleId)) {
          canVote = access.access;
        }
      });
      return canVote;
    });
  });
}

export const getVoteCount = async (issueNumber: number) => {
  const result = await axios.get(
    `/api/comment/getVoteCount?issueNumber=${issueNumber}`
  );
  return result.data;
};

/*
 * It returns the number of votes for a given issue
 * @param {number} issueNumber - The issue number of the issue we want to get the vote count for.
 * @returns The result of the query.
 */
export function useIssueVoteCount(issueNumber: number) {
  return useQuery(["issueVoteCount", issueNumber], async () => {
    /* Making a request to the backend to get the vote count for a given issue. */
    return getVoteCount(issueNumber);
  });
}

export function useVote() {
  const queryClient = useQueryClient();

  const addVoteMutation = useMutation(
    async (params: {
      issueNumber: number;
      isUpVote: boolean;
      walletId: string;
    }) => {
      const result = await axios.post("/api/comment/addComment", {
        issueNumber: params.issueNumber,
        isUpVote: params.isUpVote,
        walletId: params.walletId,
      });
      return result.data;
    },
    {
      onSuccess: (data, variables) => {
        queryClient.invalidateQueries([
          "issueVoteCount",
          variables.issueNumber,
        ]);
      },
    }
  );

  return addVoteMutation;
}

'''
'''--- src/features/common/hooks/useWalletQueries.ts ---
import { useMutation, useQuery, useQueryClient } from "react-query";

import { chainsToApi } from "../constants";

export function useWalletChainQuery() {
  return useQuery(["wallet", "chain"], () => {
    const walletChain = window.localStorage.getItem("wagmi.store");
    return walletChain;
  });
}

export function useWalletIsSignedInQuery() {
  return useQuery(["wallet", "isSignedIn"], () => {
    const walletChain = window.localStorage.getItem("wallet-chain");

    if (!walletChain) {
      return false;
    }

    const { isSignedIn } = chainsToApi[walletChain];
    return isSignedIn();
  });
}

export function useWalletSignedInAccountQuery() {
  return useQuery(["wallet", "signedInAccount"], () => {
    const walletChain = window.localStorage.getItem("wallet-chain");

    if (!walletChain) {
      return null;
    }

    const { getAccountId } = chainsToApi[walletChain];
    return getAccountId();
  });
}

export function useWalletSignInMutation() {
  const queryClient = useQueryClient();

  const walletSignInMutation = useMutation(
    async (walletChain: string) => {
      const { signIn } = chainsToApi[walletChain];

      await signIn();
      window.localStorage.setItem("wallet-chain", walletChain);
    },
    {
      onSuccess: () => {
        queryClient.invalidateQueries(["wallet", "chain"]);
      },
    }
  );

  return walletSignInMutation;
}

export function useWalletSignOutMutation() {
  const queryClient = useQueryClient();

  const walletSignOutMutation = useMutation(
    async () => {
      const walletChain = window.localStorage.getItem("wallet-chain");

      if (!walletChain) {
        return null;
      }

      const { signOut } = chainsToApi[walletChain];
      await signOut();
      window.localStorage.removeItem("wallet-chain");
    },
    {
      onSuccess: () => {
        queryClient.invalidateQueries(["wallet", "chain"]);
      },
    }
  );

  return walletSignOutMutation;
}

'''
'''--- src/features/common/types.ts ---
import type { BountyParams } from "features/bounties/types";
import type { Token } from "features/tokens/types";

export type ReqParams = {
  perPage?: any;
  page?: any;
};

export type ChainApi = {
  // Wallet API
  signIn: () => Promise<void>;
  signOut: () => Promise<void>;
  isSignedIn: () => Promise<boolean>;
  getAccountId: () => Promise<string>;
  // Contract API
  addBounty: (bounty: BountyParams) => Promise<string>;
  claimBounty: (bountyId: number) => Promise<void>;
  doneBounty: (bountyId: number) => Promise<void>;
  giveUpBounty: (bountyId: number) => Promise<void>;
  getBountyById: (bountyId: number) => Promise<any>;
  // Tokens API
  getTokens: () => Promise<Token[]>;
};

'''
'''--- src/features/evmos/api.ts ---
import * as wagmi from "wagmi";
import { InjectedConnector } from 'wagmi/connectors/injected'
import type { Token } from "features/tokens/types";

export async function initWalletConnection() {
  return new InjectedConnector();
}

export async function signIn() {
  const wagmiClient = await initWalletConnection();
  return wagmiClient.getAccount()
}

export async function isSignedIn() {
  const wagmiClient = await initWalletConnection();
  let bool = await wagmiClient.isAuthorized();
  return bool;
}

export async function returnWallet() {
  const wagmiClient = await initWalletConnection();
  return wagmiClient;
}

export async function signOut() {
  const wagmiClient = await initWalletConnection();

  return wagmiClient.disconnect();
}

export async function getAccountId(): Promise<string> {
  const wagmiClient = await initWalletConnection();

  return wagmiClient.getAccount();
}

// export async function initDaoContract() {
//   const wagmiClient = await initWalletConnection();
//   const account = wagmiClient.account();

//   return new wagmi.Contract(account, nearChainConfig.daoId, {
//     viewMethods: ["getMessages"],
//     changeMethods: ["add_proposal"],
//   });
// }

//Function for view methods
// export const viewFunction = async (functionName: string, args = {}) => {
//   const wagmiClient = await initWalletConnection();
//   const result = await wagmiClient
//     .account()
//     .viewFunction(nearChainConfig.daoId, functionName, args);

//   return result;
// };

//Function for call method
// export const callFunction = async (
//   functionName: string,
//   args = {},
//   deposit = "0"
// ) => {
//   const wagmiClient = await initWalletConnection();
//   const result = await wagmiClient.account().functionCall({
//     contractId: nearChainConfig.daoId,
//     methodName: functionName,
//     args: args,
//     attachedDeposit: wagmi.utils.format.parseNearAmount(deposit),
//   });
//   return result;
// };

export async function addBounty() {
  // TODO
}

export async function claimBounty() {
  // TODO
}

export async function doneBounty() {
  // TODO
}

export async function giveUpBounty() {
  // TODO
}

export async function getBountyById(bountyId: number) {
  // TODO
}

export async function getTokens(): Promise<Token[]> {
  return [
    {
      symbol: "EVMOS",
      address: "0x",
      decimals: 18,
      name: "EVMOS",
    },
  ];
}

'''
'''--- src/features/issues/api.ts ---
import axios from "axios";
import { githubConfig } from "config";

import type { IssueType, Issue } from "./types";
import type { ReqParams } from "features/common/types";

export async function getIssues(issueType: IssueType, params: ReqParams) {
  const labelsOfType = githubConfig.labels[issueType];

  const { data } = await axios.get<{ issues: Issue[] }>(
    `/api/issues?labels=${labelsOfType}&page=${params.page || 1}&perPage=${
      params.perPage || 10
    }`
  );
  return data.issues;
}

export async function getIssueByNumber(issueNumber: number) {
  const { data } = await axios.get<{ issue: Issue }>(
    `/api/issues/${issueNumber}`
  );
  return data.issue;
}

'''
'''--- src/features/issues/constants.ts ---
import type { IssueType } from "./types";

export const issueTypes: Record<"PLANNED" | "INPROGRESS" | "PROPOSED" | "ONCHAIN", IssueType> =
  {
    PLANNED: "planned",
    INPROGRESS: "inprogress",
    PROPOSED: "proposed",
    ONCHAIN: "onchain",
  };

'''
'''--- src/features/issues/hooks/useIssuesQueries.ts ---
import { getVoteCount } from "features/common/hooks/useGuildQueries";
import { useQuery } from "react-query";

import { getIssues, getIssueByNumber } from "../api";

import type { IssueType } from "../types";

export function useIssuesQuery(issueType: IssueType, page: number) {
  return useQuery(["issues", issueType, page], async () => {
    const issues = await getIssues(issueType, {
      page,
      perPage: 10,
    });

    const issueVotes: any = {};

    for (const issue of issues) {
      const vote = await getVoteCount(issue.number);
      issueVotes[issue.number] = vote;
    }

    return issues.sort(
      (a, b) => issueVotes[b.number].votes - issueVotes[a.number].votes
    );
  });
}

export function useIssueDetailsQuery(issueNumber: number) {
  return useQuery(
    ["issues", issueNumber],
    () => getIssueByNumber(issueNumber),
    { enabled: Boolean(issueNumber) }
  );
}

'''
'''--- src/features/issues/types.ts ---
export type IssueType = "planned" | "inprogress" | "proposed" | "onchain";

export type Metadata = {
  bounties: {
    chain: string;
    bountyId: number;
  }[];
};

export interface Label {
  name: string;
  id: number;
  color: string;
}

export type Issue = {
  title: string;
  metadata: Metadata;
  created_at: string;
  number: number;
  body: string;
  url: string;
  labels: Label[];
  user: {
    login: string;
    address: string;
  };
  html_url: string;
  color: string;
  comments: number;
};

'''
'''--- src/features/near/api.ts ---
import * as nearApi from "near-api-js";

import { nearChainConfig } from "config";

import type { Token } from "features/tokens/types";

export async function initNearWalletConnection() {
  const near = await nearApi.connect({
    networkId: nearChainConfig.networkId,
    keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
    nodeUrl: nearChainConfig.jsonRpcUrl,
    walletUrl: nearChainConfig.walletUrl,
    helperUrl: nearChainConfig.helperUrl,
  });
  return new nearApi.WalletConnection(near, null);
}

export async function signIn() {
  const nearWalletConnection = await initNearWalletConnection();

  return nearWalletConnection.requestSignIn({
    contractId: nearChainConfig.daoId,
  });
}

export async function isSignedIn() {
  const nearWalletConnection = await initNearWalletConnection();
  let bool = await nearWalletConnection.isSignedIn();
  return bool;
}

export async function returnWallet() {
  const nearWalletConnection = await initNearWalletConnection();
  return nearWalletConnection;
}

export async function signOut() {
  const nearWalletConnection = await initNearWalletConnection();

  return nearWalletConnection.signOut();
}

export async function getAccountId(): Promise<string> {
  const nearWalletConnection = await initNearWalletConnection();

  return nearWalletConnection.getAccountId();
}

export async function initDaoContract() {
  const nearWalletConnection = await initNearWalletConnection();
  const account = nearWalletConnection.account();

  return new nearApi.Contract(account, nearChainConfig.daoId, {
    viewMethods: ["getMessages"],
    changeMethods: ["add_proposal"],
  });
}

//Function for view methods
export const viewFunction = async (functionName: string, args = {}) => {
  const nearWalletConnection = await initNearWalletConnection();
  const result = await nearWalletConnection
    .account()
    .viewFunction(nearChainConfig.daoId, functionName, args);

  return result;
};

//Function for call method
export const callFunction = async (
  functionName: string,
  args = {},
  deposit = "0"
) => {
  const nearWalletConnection = await initNearWalletConnection();
  const result = await nearWalletConnection.account().functionCall({
    contractId: nearChainConfig.daoId,
    methodName: functionName,
    args: args,
    attachedDeposit: nearApi.utils.format.parseNearAmount(deposit),
  });
  return result;
};

export async function addBounty(params: {
  issueNumber: number;
  amount: number;
  maxDeadline: number;
}) {
  callFunction(
    "fundBounty",
    { issueId: params.issueNumber, deadline: params.maxDeadline.toString() },
    params.amount.toString()
  )
    .then((response) => {})
    .catch((error) => {
      console.log("Fund Error", error);
    });
}

export async function claimBounty() {
  // TODO
}

export async function doneBounty() {
  // TODO
}

export async function giveUpBounty() {
  // TODO
}

export async function getBountyById(bountyId: number) {
  // TODO
}

export async function getTokens(): Promise<Token[]> {
  return [
    {
      symbol: "NEAR",
      address: "0x",
      decimals: 18,
      name: "Near Token",
    },
  ];
}

'''
'''--- src/features/near/types.ts ---
export type Proposal = {
  transactionHash: string;
  updateTransactionHash: string;
  createTimestamp: number;
  updateTimestamp: number;
  id: string;
  proposalId: number;
  daoId: string;
  proposer: string;
  description: string;
  status:
    | "InProgress"
    | "Approved"
    | "Rejected"
    | "Removed"
    | "Expired"
    | "Moved";
};

'''
'''--- src/features/tokens/hooks/useTokensQueries.ts ---
import { useQuery, UseQueryOptions } from "react-query";
import { chainsToApi } from "features/common/constants";
import type { Token } from "../types";

export function useTokensQuery(
  chainName: string,
  options?: Omit<
    UseQueryOptions<Token[], unknown, Token[], string[]>,
    "queryKey" | "queryFn"
  >
) {
  const { getTokens } = chainsToApi[chainName];

  return useQuery(["tokens", chainName], getTokens);
}

'''
'''--- src/features/tokens/types.ts ---
export type Token = {
  symbol: string;
  decimals: number;
  address: string;
  name: string;
};

'''
'''--- src/pages/api/bounties/index.ts ---
import { postBountiesHandler } from "features/api-routes/handlers/bounties";
import { ApiError, apiErrorHandler } from "features/api-routes/handlers/utils";

import type { NextApiRequest, NextApiResponse } from "next";

type Data = {
  message?: any;
  error?: any;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  try {
    switch (req.method) {
      /**
       * `POST /bounties`
       */
      case "POST":
        return postBountiesHandler(req, res);
      default:
        throw new ApiError(400, `Method ${req.method} not allowed`);
    }
  } catch (error) {
    apiErrorHandler(res, error);
  }
}

'''
'''--- src/pages/api/comment/addComment.ts ---
import {
  ApiError,
  apiErrorHandler,
} from "../../../features/api-routes/handlers/utils";

import type { NextApiRequest, NextApiResponse } from "next";

import { Octokit } from "octokit";

import {
  setMetadataComment,
  getMetadataAndCleanedComment,
  metadataCommentRegex,
} from "features/api-routes/api/github/utils";

import { getMetadataCommentId } from "features/api-routes/api/github";

type Data = {
  issue?: any[];
  error?: any;
};

import type {
  CommentMatadata,
  Metadata,
} from "features/api-routes/api/github/types";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    switch (req.method) {
      /**
       * `GET /issues/:issueNumber`
       */
      case "POST":
        const octoKit = new Octokit({ auth: process.env.GITHUB_PAT });
        if (
          !process.env.NEXT_PUBLIC_REPO_OWNER ||
          !process.env.NEXT_PUBLIC_REPO_NAME
        )
          return res.status(500).send("Missing environment variables");

        /* Destructuring the request body and then getting the metadata comment id. */
        const { issueNumber, isUpVote, walletId } = req.body;

        const { id, body } = await getMetadataCommentId(issueNumber);

        /* This is creating a new comment with the metadata if matadata doesnt exist already. */
        if (!id || !body || !body.includes("vote")) {
          const commentBody = setMetadataComment(
            `This issue has ${isUpVote ? "1" : "-1"} votes`,
            {
              votes: isUpVote ? 1 : -1,
              //Add wallet is with voting type
              voters: [`${walletId}_${isUpVote ? "up" : "down"}`],
            }
          );

          await octoKit.rest.issues.createComment({
            owner: process.env.NEXT_PUBLIC_REPO_OWNER,
            repo: process.env.NEXT_PUBLIC_REPO_NAME,
            issue_number: issueNumber,
            body: commentBody,
          });
        } /* This is updating the comment with the new vote count. */ else {
          const {
            metadata,
            cleanedComment,
          }: { metadata: CommentMatadata | any; cleanedComment: string } =
            getMetadataAndCleanedComment(body);

          let newVotes: number = metadata.votes;
          let newVoters: string[] = [...metadata.voters];

          //If wallet is upvoting and now downvotes, keep in voters and lower vote by 2
          if (!isUpVote && metadata.voters.includes(walletId + "_up")) {
            newVoters = metadata.voters.filter(
              (voter: string) => !voter.includes(walletId)
            );
            newVoters.push(`${walletId}_down`);
            newVotes = metadata.votes - 2;
          }

          //If wallet is downvoting and now upvotes, keep in voters and increase vote by 2
          else if (isUpVote && metadata.voters.includes(walletId + "_down")) {
            newVoters = metadata.voters.filter(
              (voter: string) => !voter.includes(walletId)
            );
            newVoters.push(`${walletId}_up`);
            newVotes = metadata.votes + 2;
          }

          //If the wallet is upvoting and presses upvote again remove from voters and decrease vote by 1
          else if (isUpVote && metadata.voters.includes(walletId + "_up")) {
            newVoters = metadata.voters.filter(
              (voter: string) => !voter.includes(walletId)
            );
            newVotes = metadata.votes - 1;
          }

          //If the wallet is downvoting and presses downvote again remove from voters and increase vote by 1
          else if (!isUpVote && metadata.voters.includes(walletId + "_down")) {
            newVoters = metadata.voters.filter(
              (voter: string) => !voter.includes(walletId)
            );
            newVotes = metadata.votes + 1;
          }

          //If the wallet never voted before add to voters and increase or decrease vote by 1
          else {
            newVoters = [
              ...metadata.voters,
              `${walletId}_${isUpVote ? "up" : "down"}`,
            ];

            newVotes = isUpVote ? metadata.votes + 1 : metadata.votes - 1;
          }

          const commentBody = setMetadataComment(
            `This issue has ${newVotes} votes`,
            {
              votes: newVotes,
              voters: newVoters,
            }
          );

          await octoKit.rest.issues.updateComment({
            owner: process.env.NEXT_PUBLIC_REPO_OWNER,
            repo: process.env.NEXT_PUBLIC_REPO_NAME,
            issue_number: issueNumber,
            comment_id: id,
            body: commentBody,
          });
        }

        return res.status(200).send("Success");
      default:
        throw new ApiError(400, `Method ${req.method} not allowed`);
    }
  } catch (error) {
    apiErrorHandler(res, error);
  }
}

'''
'''--- src/pages/api/comment/getVoteCount.ts ---
import {
  ApiError,
  apiErrorHandler,
} from "../../../features/api-routes/handlers/utils";

import type { NextApiRequest, NextApiResponse } from "next";

import { Octokit } from "octokit";

import {
  setMetadataComment,
  getMetadataAndCleanedComment,
} from "features/api-routes/api/github/utils";

import { getMetadataCommentId } from "features/api-routes/api/github";

type Data = {
  issue?: any[];
  error?: any;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    switch (req.method) {
      case "GET":
        if (
          !process.env.NEXT_PUBLIC_REPO_OWNER ||
          !process.env.NEXT_PUBLIC_REPO_NAME
        )
          return res.status(500).send("Missing environment variables");

        /* Getting the issue number from the query string and then getting the metadata comment id from
       the issue number. */
        const { issueNumber } = req.query;

        if (!issueNumber) return res.status(400).send("Missing issue number");

        const { id, body } = await getMetadataCommentId(parseInt(issueNumber));

        if (!body || !body.includes("vote"))
          return res.status(200).json({ votes: 0 });

        /* Destructuring the metadata and cleanedComment from the getMetadataAndCleanedComment function. */
        const { metadata, cleanedComment } = getMetadataAndCleanedComment(body);

        return res
          .status(200)
          .json(metadata?.votes ? metadata : { votes: 0, voters: [] });
      default:
        throw new ApiError(400, `Method ${req.method} not allowed`);
    }
  } catch (error) {
    apiErrorHandler(res, error);
  }
}

'''
'''--- src/pages/api/hello.ts ---
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}

'''
'''--- src/pages/api/issues/[issueNumber].ts ---
import { getIssueDetailsHandler } from "../../../features/api-routes/handlers/issues";
import {
  ApiError,
  apiErrorHandler,
} from "../../../features/api-routes/handlers/utils";

import type { NextApiRequest, NextApiResponse } from "next";

type Data = {
  issue?: any[];
  error?: any;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  try {
    switch (req.method) {
      /**
       * `GET /issues/:issueNumber`
       */
      case "GET":
        return getIssueDetailsHandler(req, res);
      default:
        throw new ApiError(400, `Method ${req.method} not allowed`);
    }
  } catch (error) {
    apiErrorHandler(res, error);
  }
}

'''
'''--- src/pages/api/issues/index.ts ---
import { getIssuesListHandler } from "../../../features/api-routes/handlers/issues";
import {
  ApiError,
  apiErrorHandler,
} from "../../../features/api-routes/handlers/utils";

import type { NextApiRequest, NextApiResponse } from "next";

type Data = {
  issues?: any[];
  error?: any;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  try {
    switch (req.method) {
      /**
       * `GET /issues?page=1&perPage=10`
       */
      case "GET":
        return getIssuesListHandler(req, res);
      default:
        throw new ApiError(400, `Method ${req.method} not allowed`);
    }
  } catch (error) {
    apiErrorHandler(res, error);
  }
}

'''
'''--- src/styles/fonts.css ---
@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700;800;900&display=swap');

'''
'''--- src/styles/globals.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

body{
    font-family: 'Montserrat';
}

progress .progress-darksuccess::-moz-progress-bar, .progress-darksuccess::-webkit-progress-value, .progress-darksuccess:intermediate::after{
    --tw-bg-opacity: 1;
    background-color: #00AB52;
}
'''
'''--- src/utils/helpers.js ---
export const parseDate = (date) => {
  const input = !isNaN(date) ? parseInt(date) : date;
  var tempDate = new Date(input);
  const splitDate = tempDate.toString().split(" ");
  return `${splitDate[2]} ${splitDate[1]}, ${splitDate[3]}`;
};

export const nearAccountToHex = (accountsArray) => {
  const resultArray = [];

  accountsArray.forEach((account) => {
    var result = "";
    for (var i = 0; i < account.length; i++) {
      result += account.charCodeAt(i).toString(16);
    }
    let length = result.length / 2;
    let padding = "00";

    if (length < 20) {
      let iterations = 20 - length;
      for (i = 0; i < iterations; i++) {
        result = padding + result;
      }
    } else {
      result = result.substring(0, 40);
    }
    resultArray.push("0x"+result);
  });

  return resultArray;
};

'''
'''--- tailwind.config.js ---
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx}",
    "./src/features/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [
    require("@tailwindcss/typography"),
    require("daisyui"),
  ],
  daisyui: {
    styled: true,
    themes: true,
    base: true,
    utils: true,
    logs: true,
    rtl: false,
    prefix: "",
    darkTheme: "business",
  },
};

'''
'''--- test/mocks/github.ts ---
// export const

export const ISSUE_ = {
  id: 1,
  node_id: "MDU6SXNzdWUx",
  url: "https://api.github.com/repos/octocat/Hello-World/issues/1347",
  repository_url: "https://api.github.com/repos/octocat/Hello-World",
  labels_url:
    "https://api.github.com/repos/octocat/Hello-World/issues/1347/labels{/name}",
  comments_url:
    "https://api.github.com/repos/octocat/Hello-World/issues/1347/comments",
  events_url:
    "https://api.github.com/repos/octocat/Hello-World/issues/1347/events",
  html_url: "https://github.com/octocat/Hello-World/issues/1347",
  number: 1347,
  state: "open",
  title: "Found a bug",
  body: "I'm having a problem with this.",
  user: {
    login: "octocat",
    id: 1,
    node_id: "MDQ6VXNlcjE=",
    avatar_url: "https://github.com/images/error/octocat_happy.gif",
    gravatar_id: "",
    url: "https://api.github.com/users/octocat",
    html_url: "https://github.com/octocat",
    followers_url: "https://api.github.com/users/octocat/followers",
    following_url:
      "https://api.github.com/users/octocat/following{/other_user}",
    gists_url: "https://api.github.com/users/octocat/gists{/gist_id}",
    starred_url: "https://api.github.com/users/octocat/starred{/owner}{/repo}",
    subscriptions_url: "https://api.github.com/users/octocat/subscriptions",
    organizations_url: "https://api.github.com/users/octocat/orgs",
    repos_url: "https://api.github.com/users/octocat/repos",
    events_url: "https://api.github.com/users/octocat/events{/privacy}",
    received_events_url: "https://api.github.com/users/octocat/received_events",
    type: "User",
    site_admin: false,
  },
  labels: [
    {
      id: 208045946,
      node_id: "MDU6TGFiZWwyMDgwNDU5NDY=",
      url: "https://api.github.com/repos/octocat/Hello-World/labels/bug",
      name: "bug",
      description: "Something isn't working",
      color: "f29513",
      default: true,
    },
  ],
  assignee: {
    login: "octocat",
    id: 1,
    node_id: "MDQ6VXNlcjE=",
    avatar_url: "https://github.com/images/error/octocat_happy.gif",
    gravatar_id: "",
    url: "https://api.github.com/users/octocat",
    html_url: "https://github.com/octocat",
    followers_url: "https://api.github.com/users/octocat/followers",
    following_url:
      "https://api.github.com/users/octocat/following{/other_user}",
    gists_url: "https://api.github.com/users/octocat/gists{/gist_id}",
    starred_url: "https://api.github.com/users/octocat/starred{/owner}{/repo}",
    subscriptions_url: "https://api.github.com/users/octocat/subscriptions",
    organizations_url: "https://api.github.com/users/octocat/orgs",
    repos_url: "https://api.github.com/users/octocat/repos",
    events_url: "https://api.github.com/users/octocat/events{/privacy}",
    received_events_url: "https://api.github.com/users/octocat/received_events",
    type: "User",
    site_admin: false,
  },
  assignees: [
    {
      login: "octocat",
      id: 1,
      node_id: "MDQ6VXNlcjE=",
      avatar_url: "https://github.com/images/error/octocat_happy.gif",
      gravatar_id: "",
      url: "https://api.github.com/users/octocat",
      html_url: "https://github.com/octocat",
      followers_url: "https://api.github.com/users/octocat/followers",
      following_url:
        "https://api.github.com/users/octocat/following{/other_user}",
      gists_url: "https://api.github.com/users/octocat/gists{/gist_id}",
      starred_url:
        "https://api.github.com/users/octocat/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/octocat/subscriptions",
      organizations_url: "https://api.github.com/users/octocat/orgs",
      repos_url: "https://api.github.com/users/octocat/repos",
      events_url: "https://api.github.com/users/octocat/events{/privacy}",
      received_events_url:
        "https://api.github.com/users/octocat/received_events",
      type: "User",
      site_admin: false,
    },
  ],
  milestone: {
    url: "https://api.github.com/repos/octocat/Hello-World/milestones/1",
    html_url: "https://github.com/octocat/Hello-World/milestones/v1.0",
    labels_url:
      "https://api.github.com/repos/octocat/Hello-World/milestones/1/labels",
    id: 1002604,
    node_id: "MDk6TWlsZXN0b25lMTAwMjYwNA==",
    number: 1,
    state: "open",
    title: "v1.0",
    description: "Tracking milestone for version 1.0",
    creator: {
      login: "octocat",
      id: 1,
      node_id: "MDQ6VXNlcjE=",
      avatar_url: "https://github.com/images/error/octocat_happy.gif",
      gravatar_id: "",
      url: "https://api.github.com/users/octocat",
      html_url: "https://github.com/octocat",
      followers_url: "https://api.github.com/users/octocat/followers",
      following_url:
        "https://api.github.com/users/octocat/following{/other_user}",
      gists_url: "https://api.github.com/users/octocat/gists{/gist_id}",
      starred_url:
        "https://api.github.com/users/octocat/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/octocat/subscriptions",
      organizations_url: "https://api.github.com/users/octocat/orgs",
      repos_url: "https://api.github.com/users/octocat/repos",
      events_url: "https://api.github.com/users/octocat/events{/privacy}",
      received_events_url:
        "https://api.github.com/users/octocat/received_events",
      type: "User",
      site_admin: false,
    },
    open_issues: 4,
    closed_issues: 8,
    created_at: "2011-04-10T20:09:31Z",
    updated_at: "2014-03-03T18:58:10Z",
    closed_at: "2013-02-12T13:22:01Z",
    due_on: "2012-10-09T23:39:01Z",
  },
  locked: true,
  active_lock_reason: "too heated",
  comments: 0,
  pull_request: {
    url: "https://api.github.com/repos/octocat/Hello-World/pulls/1347",
    html_url: "https://github.com/octocat/Hello-World/pull/1347",
    diff_url: "https://github.com/octocat/Hello-World/pull/1347.diff",
    patch_url: "https://github.com/octocat/Hello-World/pull/1347.patch",
  },
  closed_at: null,
  created_at: "2011-04-22T13:33:48Z",
  updated_at: "2011-04-22T13:33:48Z",
  closed_by: {
    login: "octocat",
    id: 1,
    node_id: "MDQ6VXNlcjE=",
    avatar_url: "https://github.com/images/error/octocat_happy.gif",
    gravatar_id: "",
    url: "https://api.github.com/users/octocat",
    html_url: "https://github.com/octocat",
    followers_url: "https://api.github.com/users/octocat/followers",
    following_url:
      "https://api.github.com/users/octocat/following{/other_user}",
    gists_url: "https://api.github.com/users/octocat/gists{/gist_id}",
    starred_url: "https://api.github.com/users/octocat/starred{/owner}{/repo}",
    subscriptions_url: "https://api.github.com/users/octocat/subscriptions",
    organizations_url: "https://api.github.com/users/octocat/orgs",
    repos_url: "https://api.github.com/users/octocat/repos",
    events_url: "https://api.github.com/users/octocat/events{/privacy}",
    received_events_url: "https://api.github.com/users/octocat/received_events",
    type: "User",
    site_admin: false,
  },
  author_association: "COLLABORATOR",
};

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "baseUrl": "./src",
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

'''