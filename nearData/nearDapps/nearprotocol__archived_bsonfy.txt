*GitHub Repository "nearprotocol/_archived_bsonfy"*

'''--- package.json ---
{
  "name": "bsonfy",
  "version": "1.0.2",
  "author": "Marco Paland",
  "license": "MIT",
  "description": "Ultrafast BSON serializer/parser",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc -p ./src",
    "pretest": "tsc -p ./test",
    "test": "mocha ./test/out/test/**/*_test.js",
    "dev": "lite-server"
  },
  "dependencies": {},
  "devDependencies": {
    "typescript": "latest",
    "lite-server": "latest",
    "ts-node": "^4.1.0",
    "chai": "^4.1.2",
    "mocha": "^5.0.0",
    "@types/chai": "^4.1.2",
    "@types/mocha": "^2.2.47",
    "@types/node": "^9.4.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mpaland/bsonfy.git"
  },
  "keywords": [
    "BSON",
    "Parser",
    "Serializer",
    "Deserializer",
    "JSON",
    "Typescript"
  ],
  "bugs": {
    "url": "https://github.com/mpaland/bsonfy/issues"
  },
  "homepage": "https://github.com/mpaland/bsonfy#readme"
}

'''
'''--- readme.md ---
# bsonfy - ultrafast BSON parser

[![npm](https://img.shields.io/npm/v/bsonfy.svg)](https://www.npmjs.com/package/bsonfy)
[![npm](https://img.shields.io/npm/dt/bsonfy.svg)](https://www.npmjs.com/package/bsonfy)
[![Github Issues](https://img.shields.io/github/issues/mpaland/bsonfy.svg)](http://github.com/mpaland/bsonfy/issues)
[![Github Releases](https://img.shields.io/github/release/mpaland/bsonfy.svg)](https://github.com/mpaland/bsonfy/releases)
[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/mpaland/mipher/master/LICENSE)

**bsonfy** is an ultrafast serializer and deserializer for the [BSON](http://bsonspec.org) format.  
It is written in clean typescript and has no other lib dependencies.
BSON is mainly used as compact transport format for (JSON) objects.

### Motivation
I needed a simple, fast and clean (typescript) module to generate and parse BSON for storing JSON objects in files efficiently.  
There are some parsers around (2016/06), mainly the primary one of the mongodb project. But I found that it's really not lightweight enough and too slow for mobile usage.  
A further requirement was using typed arrays (`Uint8Array`) instead of nodejs buffers, to get this baby portable and running in browsers, too.

### Design goals:
- Written in typescript
- Fast and lightweight parser
- Very easy to use, just one include module, NO dependencies
- tslint warning free, clean code
- Unit tested, around 50 passing test cases
- Rocksolid (I hope so)
- MIT license

## Usage
Using this module is rather simple. Copy or (npm) install *bsonfy* to your project and use it like:

```typescript
import { BSON } from 'bsonfy';
// if you need a require, use const BSON = require('bsonfy').BSON;

// create a test document
let doc = { id: 10, time: new BSON.UTC(), arr: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]) };

// serialize the document
let bson = BSON.serialize(doc);

// and deserialize it, using BSON.UTC objects as time representation
let orig = BSON.deserialize(bson, true);
```

## API

Basically the API consists of just two static methods to serialize/deserialize objects to/from BSON format:

### BSON serialization and deserialiation

**`BSON.serialize(object)`**
  * @param {Object} object The Javascript object to serialize
  * @return {Uint8Array} returns an Uint8Array in BSON format.  
    Unknown objects are ignored in serialization.

**`BSON.deserialize(buffer, useUTC)`**
  * @param {Uint8Array} buffer An Uint8Array containing the BSON data
  * @param {Boolean} useUTC Optional, if set a `BSON.UTC` object is created for 'UTC datetime' instead of a normal JS `Date` object. Defaults to false
  * @return {Object} returns the deserialized Javascript object or `undefined` in case of a parsing error (unsupported BSON element etc.)

### UTC

**`bson.ObjectId.isValid(id)`** - Returns true if `id` is a valid number or hexadecimal string representing an ObjectId.
**`bson.ObjectId.createFromHexString(hexString)`** - Returns the ObjectId the `hexString` represents.
**`bson.ObjectId.createFromTime(time)`** - Returns an ObjectId containing the passed time.
* `time` - A Unix timestamp (number of seconds since the epoch).

### UUID

**`bson.ObjectId.isValid(id)`** - Returns true if `id` is a valid number or hexadecimal string representing an ObjectId.
**`bson.ObjectId.createFromHexString(hexString)`** - Returns the ObjectId the `hexString` represents.
**`bson.ObjectId.createFromTime(time)`** - Returns an ObjectId containing the passed time.
* `time` - A Unix timestamp (number of seconds since the epoch).

### ObjectId

**`bson.ObjectId.isValid(id)`** - Returns true if `id` is a valid number or hexadecimal string representing an ObjectId.
**`bson.ObjectId.createFromHexString(hexString)`** - Returns the ObjectId the `hexString` represents.
**`bson.ObjectId.createFromTime(time)`** - Returns an ObjectId containing the passed time.
* `time` - A Unix timestamp (number of seconds since the epoch).

### Unsupported elements
The following BSON elements are currently not supported (and lead to a deserialiation error):
- JavaScript code
- Min key
- Max key
- Regular expression (implemented, but untested yet - so don't rely on it)

## Caveats
- 64-bit integer BSON values are converted to the Javascript Number type.  
  However, Javascript supports integer precision up to 2^53 as maximum size.
  If a parsed 64-bit integer exceeds this size, floating point rounding errors may occur!

## Test suite
bsonfy is using the mocha test suite for testing.
To do all tests just run `npm run test`.

## Contributing
If you find any bugs, have any comments, improvements or suggestions:

1. Create an issue and describe your idea
2. [Fork it](https://github.com/mpaland/bsonfy/fork)
3. Create your feature branch (`git checkout -b my-new-feature`)
4. Commit your changes (`git commit -am 'Add some feature'`)
5. Publish the branch (`git push origin my-new-feature`)
6. Create a new pull request
7. Profit! :white_check_mark:

## License
bsonfy is written under the [MIT license](http://www.opensource.org/licenses/MIT).

'''
'''--- src/bson.ts ---
///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (marco@paland.com)
//             2016-2018, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// This file is part of the bsonfy library.
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT  OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// \brief Extrem fast BSON implementation in typescript with NO dependencies
//        See http://bsonspec.org for details
//        Usage:
//        import { BSON } from './bsonfy';
//        let obj  = { id: 10, time: new BSON.UTC(), arr: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]) };
//        let bson = BSON.serialize(obj);
//        let orig = BSON.deserialize(bson);
//
///////////////////////////////////////////////////////////////////////////////

import * as types from "./types";
import { cstring, int32, number2long, long2number, bin2str, strlen } from "./helper";

export namespace BSON {

  /**
   * BSON module version
   */
  const version: string = '1.0.2';

  export class UUID extends types.UUID {};
  export class ObjectId extends types.ObjectId {};
  export class UTC extends types.UTC {};

  /**
   * Private, return the size of the given object
   * @param {Object} obj The object to get the size from
   * @return {Number} The object size in bytes
   */
  function getObjectSize(obj: Object): number {
    let len = 4 + 1;                                // handle the obj.length prefix + terminating '0'
    for (let key in obj) {
      len += getElementSize(key, obj[key]);
    }
    return len;
  }

  /**
   * Private, get the size of the given element
   * @param {String} name
   * @param {Object} value
   * @return {Number} The element size in bytes
   */
  function getElementSize(name: string, value: any): number {
    let len = 1;                                    // always starting with 1 for the data type byte
    if (name) {
      len += strlen(name) + 1;                      // cstring: name + '0' termination
    }

    if (value === undefined || value === null) {
      return len;                                   // just the type byte plus name cstring
    }

    switch (value.constructor) {
      case String:
        return len + 4 + strlen(value) + 1;

      case Number:
        if (Math.floor(value) === value) {
          if (value <= 2147483647 && value >= -2147483647)
            return len + 4;                         // 32 bit
          else
            return len + 8;                         // 64 bit
        }
        else
          return len + 8;                           // 64 bit double & float

      case Boolean:
        return len + 1;

      case Array:
      case Object:
        return len + getObjectSize(value);

      case Int8Array:
      case Uint8Array:
        return len + 5 + value.byteLength;

      case Date:
      case UTC:
        return len + 8;

      case UUID:
        return len + 5 + 16;

      case ObjectId:
        return len + 12;

      default:
        // unsupported type
        return 0;
    }
  }

  /**
   * Serialize an object to BSON format
   * @param {Object} object The object to serialize
   * @return {Uint8Array} An byte array with the BSON representation
   */
  export function serialize(object: any): Uint8Array {
    let buffer = new Uint8Array(getObjectSize(object));
    serializeEx(object, buffer);
    return buffer;
  }

  /**
   * Private, used by serialize() and is called recursively
   * @param object
   * @param buffer
   * @param i
   */
  function serializeEx(object: any, buffer: Uint8Array, i: number = 0): number {
    i += int32(buffer.length, buffer, i);

    if (object.constructor === Array) {
      for (let j = 0, len = object.length; j < len; j++) {
        i = packElement(j.toString(), object[j], buffer, i);
      }
    }
    else {
      for (let key in object) {
        i = packElement(key, object[key], buffer, i);
      }
    }
    buffer[i++] = 0;  // terminating zero
    return i;
  }

  /**
   * Private, assemble BSON elements
   * @param name
   * @param value
   * @param buffer
   * @param i
   */
  function packElement(name: string, value: any, buffer: Uint8Array, i: number): number {
    if (value === undefined || value === null) {
      buffer[i++] = 0x0A;             // BSON type: Null
      i += cstring(name, buffer, i);
      return i;
    }
    switch (value.constructor) {
      case String:
        buffer[i++] = 0x02;           // BSON type: String
        i += cstring(name, buffer, i);
        let size = cstring(value, buffer, i + 4);
        i += int32(size, buffer, i);
        return i + size;

      case Number:
        if (Math.floor(value) === value) {
          if (value <= 2147483647 && value >= -2147483647) { /// = BSON.BSON_INT32_MAX / MIN asf.
            buffer[i++] = 0x10;       // BSON type: int32
            i += cstring(name, buffer, i);
            i += int32(value, buffer, i);
          }
          else {
            buffer[i++] = 0x12;       // BSON type: int64
            i += cstring(name, buffer, i);
            buffer.set(number2long(value), i);
            i += 8;
          }
        }
        else {
          // it's a float / double
          buffer[i++] = 0x01;         // BSON type: 64-bit floating point
          i += cstring(name, buffer, i);
          let f = new Float64Array([value]);
          let d = new Uint8Array(f.buffer);
          buffer.set(d, i);
          i += 8;
        }
        return i;

      case Boolean:
        buffer[i++] = 0x08;           // BSON type: Boolean
        i += cstring(name, buffer, i);
        buffer[i++] = value ? 1 : 0;
        return i;

      case Array:
      case Object:
        buffer[i++] = value.constructor === Array ? 0x04 : 0x03;  // BSON type: Array / Document
        i += cstring(name, buffer, i);
        let end = serializeEx(value, buffer, i);
        int32(end - i, buffer, i);    // correct size
        return end;

      case Int8Array:
      case Uint8Array:
        buffer[i++] = 0x05;           // BSON type: Binary data
        i += cstring(name, buffer, i);
        i += int32(value.byteLength, buffer, i);
        buffer[i++] = 0;              // use generic binary subtype 0
        buffer.set(value, i);
        i += value.byteLength;
        return i;

      case Date:
        buffer[i++] = 0x09;           // BSON type: UTC datetime
        i += cstring(name, buffer, i);
        buffer.set(number2long(value.getTime()), i);
        i += 8;
        return i;

      case UTC:
        buffer[i++] = 0x09;           // BSON type: UTC datetime
        i += cstring(name, buffer, i);
        buffer.set(value.buffer(), i);
        i += 8;
        return i;

      case UUID:
        buffer[i++] = 0x05;           // BSON type: Binary data
        i += cstring(name, buffer, i);
        i += int32(16, buffer, i);
        buffer[i++] = 4;              // use UUID subtype
        buffer.set(value.buffer(), i);
        i += 16;
        return i;

      case ObjectId:
        buffer[i++] = 0x07;           // BSON type: ObjectId
        i += cstring(name, buffer, i);
        buffer.set(value.buffer(), i);
        i += 12;
        return i;

      case RegExp:
        buffer[i++] = 0x0B;           // BSON type: Regular expression
        i += cstring(name, buffer, i);
        i += cstring(value.source, buffer, i);
        if (value.global)     buffer[i++] = 0x73;   // s = 'g'
        if (value.ignoreCase) buffer[i++] = 0x69;   // i
        if (value.multiline)  buffer[i++] = 0x6d;   // m
        buffer[i++] = 0;
        return i;

      default:
        return i;                     // unknown type (ignore element)
    }
  }

  /**
   * Deserialize (parse) BSON data to an object
   * @param {Uint8Array} buffer The buffer with BSON data to convert
   * @param {Boolean} useUTC Optional, if set an UTC object is created for 'UTC datetime', else an Date object. Defaults to false
   * @return {Object} Returns an object or an array
   */
  export function deserialize(buffer: Uint8Array, useUTC: boolean = false, i: number = 0, returnArray: boolean = false): Array<any> | Object {
    // check size
    if (buffer.length < 5) {
      // Document error: Size < 5 bytes
      return undefined;
    }
    let size = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
    if (size < 5 || size > buffer.length) {
      // Document error: Size mismatch
      return undefined;
    }
    if (buffer[buffer.length - 1] !== 0x00) {
      // Document error: Missing termination
      return undefined;
    }

    let object = returnArray ? [] : {};   // needed for type ARRAY recursion later

    for (;;) {
      // get element type
      let elementType = buffer[i++];  // read type
      if (elementType === 0) break;   // zero means last byte, exit

      // get element name
      let end = i;
      for (; buffer[end] !== 0x00 && end < buffer.length; end++);
      if (end >= buffer.length - 1) {
        // Document error: Illegal key name
        return undefined;
      }
      let name: any = bin2str(buffer.subarray(i, end));
      if (returnArray) {
        name = parseInt(name);        // convert to number as array index
      }
      i = ++end;                      // skip terminating zero

      switch (elementType) {
        case 0x01:                    // BSON type: 64-bit floating point
          object[name] = (new Float64Array(buffer.slice(i, i += 8).buffer))[0];   // use slice() here to get a new array
          break;

        case 0x02:                    // BSON type: String
          size = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
          object[name] = bin2str(buffer.subarray(i, i += size - 1));
          i++;
          break;

        case 0x03:                    // BSON type: Document (Object)
          size = buffer[i] | buffer[i + 1] << 8 | buffer[i + 2] << 16 | buffer[i + 3] << 24;
          object[name] = deserialize(buffer, useUTC, i, false);   // isArray = false => Object
          i += size;
          break;

        case 0x04:                    // BSON type: Array
          size = buffer[i] | buffer[i + 1] << 8 | buffer[i + 2] << 16 | buffer[i + 3] << 24;  // NO 'i' increment since the size bytes are reread during the recursion
          object[name] = deserialize(buffer, useUTC, i, true);  // pass current index & return an array
          i += size;
          break;

        case 0x05:                    // BSON type: Binary data
          size = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
          if (buffer[i++] === 0x04) { // BSON subtype: UUID
            if (size !== 16) {
              // Element error: Wrong UUID length
              return undefined;
            }
            object[name] = new UUID(buffer.subarray(i, i += size));
          }
          else {
            // all other subtypes
            object[name] = buffer.slice(i, i += size);    // use slice() here to get a new array
          }
          break;

        case 0x06:                    // BSON type: Undefined (deprecated)
          object[name] = null;
          break;

        case 0x07:                    // BSON type: ObjectId
          object[name] = new ObjectId(buffer.subarray(i, i += 12));
          break;

        case 0x08:                    // BSON type: Boolean
          object[name] = buffer[i++] === 1;
          break;

        case 0x09:                    // BSON type: UTC datetime
          object[name] = useUTC ? new UTC(buffer.subarray(i, i += 8)) : new Date(long2number(buffer.subarray(i, i += 8)));
          break;

        case 0x0A:                    // BSON type: Null
          object[name] = null;
          break;

        case 0x0B:                    // BSON type: RegExp
          end = i;
          // pattern
          while (end < buffer.length && buffer[end++] !== 0x00);
          if (end >= buffer.length) {
            // Document error: Illegal key name
            return undefined;
          }
          let pat = bin2str(buffer.subarray(i, end));
          i = end;
          // flags
          while (end < buffer.length && buffer[end++] !== 0x00);
          if (end >= buffer.length) {
            // Document error: Illegal key name
            return undefined;
          }
          let flags = bin2str(buffer.subarray(i, end));
          i = end;
          object[name] = new RegExp(pat, flags);
          break;

        case 0x10:                    // BSON type: 32-bit integer
          object[name] = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
          break;

        case 0x12:                    // BSON type: 64-bit integer
          object[name] = long2number(buffer.subarray(i, i += 8));
          break;

        default:
          // Parsing error: Unknown element
          return undefined;
      }
    }
    return object;
  }
} // namespace BSON

'''
'''--- src/helper.ts ---
///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (marco@paland.com)
//             2016-2018, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// This file is part of the bsonfy library.
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORTtort  OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

/**
 * Private, assemble BSON cstring element
 * @param name
 * @param buffer
 * @param offset
 * @return Element length in bytes
 */
export function cstring(name: string, buffer: Uint8Array, offset: number): number {
  let cstring = str2bin(name);
  let clen = cstring.length;
  buffer.set(cstring, offset);
  buffer[offset + clen++] = 0;
  return clen;
}

/**
 * Private, assemble BSON int32 element
 * @param size
 * @param buffer
 * @param offset
 * @return Element length in bytes
 */
export function int32(size: number, buffer: Uint8Array, offset: number): number {
  buffer[offset++] = (size)        & 0xff;
  buffer[offset++] = (size >>>  8) & 0xff;
  buffer[offset++] = (size >>> 16) & 0xff;
  buffer[offset++] = (size >>> 24) & 0xff;
  return 4;
}

/////////////////////////////////////////////////////////////////////////////
// H E L P E R

/**
 * Convert a number to a 64 bit integer representation
 * @param {Number} value Number to convert
 * @return {Uint8Array} Converted number
 */
export function number2long(value: number): Uint8Array {
  let buf = new Uint8Array(8);
  if (Math.floor(value) === value) {
    const TWO_PWR_32 = 4294967296;
    let lo = (value % TWO_PWR_32) | 0, hi = (value / TWO_PWR_32) | 0;
    if (value < 0) {
      lo = ~(-value % TWO_PWR_32) | 0, hi = ~(-value / TWO_PWR_32) | 0;
      lo = (lo + 1) & 0xffffffff;
      if (!lo) hi++;
    }
    let i = 0;
    buf[i++] = (lo & 0xff); buf[i++] = (lo >>> 8) & 0xff; buf[i++] = (lo >>> 16) & 0xff; buf[i++] = (lo >>> 24) & 0xff;
    buf[i++] = (hi & 0xff); buf[i++] = (hi >>> 8) & 0xff; buf[i++] = (hi >>> 16) & 0xff; buf[i]   = (hi >>> 24) & 0xff;
  }
  else {    // it's a float / double
    let f = new Float64Array([value]);
    let d = new Uint8Array(f.buffer);
    buf.set(d);
  }
  return buf;
}

/**
 * Convert 64 bit integer to Number
 * @param {Uint8Array} buffer Buffer containing a 64 bit integer as typed array at offset position. LSB is [0], MSB is [7]
 * @param {Number} offset Offset in buffer, where the integer starts
 * @return {Number} Converted number
 */
export function long2number(buffer: Uint8Array, offset: number = 0): number {
  const TWO_PWR_32 = 4294967296;
  let lo = buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
  let hi = buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset]   << 24;
  return hi * TWO_PWR_32 + ((lo >= 0) ? lo : TWO_PWR_32 + lo);
}

/**
 * Convert a string (UTF-8 encoded) to a byte array
 * @param {String} str UTF-8 encoded string
 * @return {Uint8Array} Byte array
 */
export function str2bin(str: string): Uint8Array {
  str = str.replace(/\r\n/g, '\n');
  let bin = [], p = 0;
  for (let i = 0, len = str.length; i < len; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      bin[p++] = c;
    } else if (c < 2048) {
      bin[p++] = (c >>> 6) | 192;
      bin[p++] = (c & 63) | 128;
    } else {
      bin[p++] = (c >>> 12) | 224;
      bin[p++] = ((c >>> 6) & 63) | 128;
      bin[p++] = (c & 63) | 128;
    }
  }
  return new Uint8Array(bin);
}

/**
 * Convert a byte array to an UTF-8 string
 * @param {Uint8Array} bin UTF-8 text given as array of bytes
 * @return {String} UTF-8 Text string
 */
export function bin2str(bin: Uint8Array): string {
  let str = '', len = bin.length, i = 0, c, c2, c3;

  while (i < len) {
    c = bin[i];
    if (c < 128) {
      str += String.fromCharCode(c);
      i++;
    }
    else if ((c > 191) && (c < 224)) {
      c2 = bin[i + 1];
      str += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
      i += 2;
    }
    else {
      c2 = bin[i + 1];
      c3 = bin[i + 2];
      str += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      i += 3;
    }
  }
  return str;
}

/**
 * Returns the UTF-8 string length in bytes
 * @param {String} Input string
 * @return {Number} Stringlength in bytes (not in chars)
 */
export function strlen(str: string): number {
  return encodeURI(str).split(/%..|./).length - 1;
}

'''
'''--- src/index.ts ---
///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (marco@paland.com)
//             2015-2018, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// This file is part of the bysonfy library.
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// \brief bsonfy module exports
//
///////////////////////////////////////////////////////////////////////////////

export { BSON } from './bson';

'''
'''--- src/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "declaration": true,
    "outDir": "../dist",
    "rootDir": "."
  },
  "exclude": [
    "dist",
    "node_modules",
    "typings/main",
    "typings/main.d.ts"
  ],
  "filesGlob": [
    "**/*.ts",
    "!node_modules/**/*"
  ],
  "compileOnSave": false,
  "atom": {
    "rewriteTsconfig": false
  }
}

'''
'''--- src/types.ts ---
///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (marco@paland.com)
//             2016-2018, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// This file is part of the bsonfy library.
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORTtort  OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

import { number2long, long2number } from "./helper";

/**
 * UUID class
 */
export class UUID {
  private _id: Uint8Array;

  constructor(id: Uint8Array | Array<number>) {
    this._id = new Uint8Array(id);
  }

  buffer(): Uint8Array {
    return this._id;
  }
}

/**
 * ObjectId class (for mongoDB usage)
 */
export class ObjectId {
  private _id: Uint8Array;

  constructor(id: Uint8Array | Array<number>) {
    this._id = new Uint8Array(id);
  }

  buffer(): Uint8Array {
    return this._id;
  }
}

/**
 * The UTC class contains the milliseconds since the Unix epoch (1.1.1970 00:00:00 UTC)
 */
export class UTC {
  private _time: Uint8Array;

  constructor(time?: Uint8Array | Array<number> | string) {
    this._time = (typeof time !== 'string') ? new Uint8Array(time || number2long(Date.now())) : number2long(+new Date(time));
  }

  buffer(): Uint8Array {
    return this._time;
  }

  /**
   * Convert an (ISO) date string
   * @param {String} date (ISO) Date string
   */
  fromString(date: string): void {
    this._time = number2long(+new Date(date));
  }

  /**
   * Returns the milliseconds since the Unix epoch (UTC)
   */
  toNumber(): number {
    return long2number(this._time);
  }

  toDate(): Date {
    return new Date(long2number(this._time));
  }
}

'''
'''--- test/common.js ---
global.btoa = function (str) {
  return new Buffer(str).toString('base64');
};

global.atob = function (b64) {
  return new Buffer(b64, 'base64').toString();
};

// global.chai = require('chai');
// var expect = chai.expect;
// var assert = chai.assert;

'''
'''--- test/spec/bson_test.ts ---
﻿///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (marco@paland.com)
//             2018, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// This file is part of the bysonfy library.
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// \brief BSON test cases
//
///////////////////////////////////////////////////////////////////////////////

import { BSON } from '../../src/bson';

import { expect, assert } from 'chai';
import 'mocha';

describe('BSON', () => {

  class UnknownObj {
    _dummy: number = 123;
    test() {
    }
  }

  let serialize_vector = [
    {
      obj: { "BSON": ["awesome", 5.05, 1986] },
      bson: "310000000442534f4e002600000002300008000000617765736f6d65000131003333333333331440103200c20700000000",
    },
    {
      obj: { int32: 10, int64: 1125899906842624, flo: 3.141592653, str: "Hello äöü", utc: new BSON.UTC("2011-10-10T14:48:00Z"), bool: true, date: new Date("2011-10-10T14:48:00Z") },
      bson: "6400000010696e743332000a00000012696e74363400000000000000040001666c6f0038e92f54fb21094002737472000d00000048656c6c6f20c3a4c3b6c3bc00097574630000f94dee3201000008626f6f6c000109646174650000f94dee3201000000"
    },
    {
      obj: { arr: ["foo", "bar", 100, 1000], ta: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]), obj: { int32: 10, int64: 1125899906842624, flo: 3.141592653 } },
      bson: "7500000004617272002900000002300004000000666f6f00023100040000006261720010320064000000103300e8030000000574610008000000000102030405060708036f626a002c00000010696e743332000a00000012696e74363400000000000000040001666c6f0038e92f54fb2109400000"
    },
    {
      obj: { da: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], uuid: new BSON.UUID(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])) },
      bson: "80000000046461005c0000000430001a000000103000010000001031000200000010320003000000000431001a000000103000040000001031000500000010320006000000000432001a000000103000070000001031000800000010320009000000000005757569640010000000040102030405060708090a0b0c0d0e0f1000"
    },
    {
      obj: { id: 123456, sk: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]), pk: new Uint8Array([255, 254, 253, 252, 251, 250, 249, 248]) },
      bson: "2f0000001069640040e2010005736b000800000000010203040506070805706b000800000000fffefdfcfbfaf9f800"
    },
    {
      obj: { id: 10, obj: new UnknownObj(), str: "Test", n: null, b: true },
      bson: "22000000106964000a00000002737472000500000054657374000a6e000862000100"
    }
  ];

  let deserialize_vector = [
    {
      obj: { "BSON": ["awesome", 5.05, 1986] },
      bson: "310000000442534f4e002600000002300008000000617765736f6d65000131003333333333331440103200c20700000000",
    },
    {
      obj: { int32: 10, int64: 1125899906842624, flo: 3.141592653, str: "Hello äöü", utc: new BSON.UTC("2011-10-10T14:48:00Z"), bool: true, date: new Uint8Array([1,2,3,4]), nu: null },
      bson: "6900000010696e743332000a00000012696e74363400000000000000040001666c6f0038e92f54fb21094002737472000d00000048656c6c6f20c3a4c3b6c3bc00097574630000f94dee3201000008626f6f6c00010564617465000400000000010203040a6e750000"
    },
    {
      obj: { arr: ["foo", "bar", 100, 1000], ta: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]), obj: { int32: 10, int64: 1125899906842624, flo: 3.141592653 } },
      bson: "7500000004617272002900000002300004000000666f6f00023100040000006261720010320064000000103300e8030000000574610008000000000102030405060708036f626a002c00000010696e743332000a00000012696e74363400000000000000040001666c6f0038e92f54fb2109400000"
    },
    {
      obj: { da: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], uuid: new BSON.UUID(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])) },
      bson: "80000000046461005c0000000430001a000000103000010000001031000200000010320003000000000431001a000000103000040000001031000500000010320006000000000432001a000000103000070000001031000800000010320009000000000005757569640010000000040102030405060708090a0b0c0d0e0f1000"
    },
    {
      obj: { id: 123456, sk: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]), pk: new Uint8Array([255, 254, 253, 252, 251, 250, 249, 248]) },
      bson: "2f0000001069640040e2010005736b000800000000010203040506070805706b000800000000fffefdfcfbfaf9f800"
    },
    {
      obj: { id: 10, oid: new BSON.ObjectId(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])), str: "Test", n: null, b: true },
      bson: "33000000106964000a000000076f6964000102030405060708090a0b0c02737472000500000054657374000a6e000862000100"
    }
  ];

  describe("serialize", function () {
    it("checks empty/unknown object", function () {
      let bson = BSON.serialize("");
      expect(bin2hex(bson)).to.deep.equal("0500000000");
      bson = BSON.serialize({ obj: new UnknownObj() });
      expect(bin2hex(bson)).to.deep.equal("0500000000");
    });

    it("checks int32", function () {
      let bson = BSON.serialize({ int: 0x1234 });
      expect(bin2hex(bson)).to.deep.equal("0e00000010696e74003412000000");
    });

    it("checks negative int32", function () {
      let bson = BSON.serialize({ int: -10 });
      expect(bin2hex(bson)).to.deep.equal("0e00000010696e7400f6ffffff00");
    });

    it("checks int64", function () {
      let bson = BSON.serialize({ int: 0x1234567890 });
      expect(bin2hex(bson)).to.deep.equal("1200000012696e7400907856341200000000");
    });

    it("checks negative int64", function () {
      let bson = BSON.serialize({ int: -78187493520 });
      expect(bin2hex(bson)).to.deep.equal("1200000012696e74007087a9cbedffffff00");
    });

    it("checks double (64-bit binary floating point)", function () {
      let bson = BSON.serialize({ flo: 3.1415926535 });
      expect(bin2hex(bson)).to.deep.equal("1200000001666c6f0044174154fb21094000");
    });

    it("checks string", function () {
      let bson = BSON.serialize({ str: "Hello World" });
      expect(bin2hex(bson)).to.deep.equal("1a00000002737472000c00000048656c6c6f20576f726c640000");
    });

    it("checks UTF-8 string", function () {
      let bson = BSON.serialize({ str: "\u00C4\u00D6\u00DC\u00DF" });
      expect(bin2hex(bson)).to.deep.equal("17000000027374720009000000c384c396c39cc39f0000");
    });

    it("checks boolean", function () {
      let bson = BSON.serialize({ bool: false });
      expect(bin2hex(bson)).to.deep.equal("0c00000008626f6f6c000000");
      bson = BSON.serialize({ bool: true });
      expect(bin2hex(bson)).to.deep.equal("0c00000008626f6f6c000100");
    });

    it("checks null", function () {
      let bson = BSON.serialize({ nul: null });
      expect(bin2hex(bson)).to.deep.equal("0a0000000a6e756c0000");
    });

    it("checks binary", function () {
      let bson = BSON.serialize({ bin: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0xFF]) });
      expect(bin2hex(bson)).to.deep.equal("190000000562696e000a00000000010203040506070809ff00");
    });

    it("checks array", function () {
      let bson = BSON.serialize({ arr: [0xFA, 0xFB, 0xFC, 0xFD] });
      expect(bin2hex(bson)).to.deep.equal("2b000000046172720021000000103000fa000000103100fb000000103200fc000000103300fd0000000000");
    });

    it("checks array in array", function () {
      let bson = BSON.serialize({ arr: [[0x10, 0x11, 0x12, 0x13], 0xFA, 0xFB, 0xFC, 0xFD] });
      expect(bin2hex(bson)).to.deep.equal("4f000000046172720045000000043000210000001030001000000010310011000000103200120000001033001300000000103100fa000000103200fb000000103300fc000000103400fd0000000000");
    });

    it("checks object", function () {
      let bson = BSON.serialize({ obj: { int: 10, str: "" } });
      expect(bin2hex(bson)).to.deep.equal("22000000036f626a001800000010696e74000a000000027374720001000000000000");
    });

    it("checks Date", function () {
      let bson = BSON.serialize({ dat: new Date("2016-06-25T14:48:11Z") });
      expect(bin2hex(bson)).to.deep.equal("120000000964617400f84308885501000000");
    });

    it("checks UTC", function () {
      let bson = BSON.serialize({ utc1: new BSON.UTC("2016-06-25T14:48:11Z"), utc2: new BSON.UTC("2016-06-25T14:48:11+0200"), utc3: new BSON.UTC([0x3D, 0x53, 0xAE, 0x91, 0x55, 0x01, 0x00, 0x00]) });
      expect(bin2hex(bson)).to.deep.equal("2f000000097574633100f843088855010000097574633200f8669a87550100000975746333003d53ae915501000000");
    });

    it("checks UUID", function () {
      let bson = BSON.serialize({ uuid: new BSON.UUID(new Uint8Array([0x43, 0xab, 0x2e, 0x98, 0x62, 0x3c, 0x03, 0xe8, 0x5f, 0x54, 0x1a, 0x17, 0x45, 0xe0, 0x1b, 0xda])) });
      expect(bin2hex(bson)).to.deep.equal("20000000057575696400100000000443ab2e98623c03e85f541a1745e01bda00");
    });

    it("checks ObjectId", function () {
      let bson = BSON.serialize({ oid: new BSON.ObjectId([0xa8, 0x05, 0x57, 0xf0, 0x5c, 0x6d, 0x7a, 0xd0, 0x9f, 0xa7, 0x35, 0x70]) });
      expect(bin2hex(bson)).to.deep.equal("16000000076f696400a80557f05c6d7ad09fa7357000");
    });

    it("checks complex objects", function () {
      for (let i = 0; i < serialize_vector.length; i++) {
        let bson = BSON.serialize(serialize_vector[i].obj);
        expect(bin2hex(bson)).to.deep.equal(serialize_vector[i].bson);
      }
    });
  });

  describe("deserialize", function () {
    it("checks empty/unknown object", function () {
      let obj = BSON.deserialize(hex2bin("0500000000"));
      expect(obj).to.deep.equal({ });
    });

    it("checks int32", function () {
      let obj = BSON.deserialize(hex2bin("0e00000010696e74003412000000"));
      expect(obj).to.deep.equal({ int: 0x1234 });
    });

    it("checks negative int32", function () {
      let obj = BSON.deserialize(hex2bin("0e00000010696e7400f6ffffff00"));
      expect(obj).to.deep.equal({ int: -10 });
    });

    it("checks int64", function () {
      let obj = BSON.deserialize(hex2bin("1200000012696e7400907856341200000000"));
      expect(obj).to.deep.equal({ int: 0x1234567890 });
    });

    it("checks int64 > 2^53", function () {
      let obj = BSON.deserialize(hex2bin("1200000012696e7400FFDEBC9A7856341200"));
      expect(obj).to.deep.equal({ int: 0x123456789ABCDEFF });
    });

    it("checks negative int64", function () {
      let obj = BSON.deserialize(hex2bin("1200000012696e74007087a9cbedffffff00"));
      expect(obj).to.deep.equal({ int: -78187493520 });
    });

    it("checks double (64-bit binary floating point)", function () {
      let obj = BSON.deserialize(hex2bin("1200000001666c6f0044174154fb21094000"));
      expect(obj).to.deep.equal({ flo: 3.1415926535 });
    });

    it("checks string", function () {
      let obj = BSON.deserialize(hex2bin("1a00000002737472000c00000048656c6c6f20576f726c640000"));
      expect(obj).to.deep.equal({ str: "Hello World" });
    });

    it("checks UTF-8 string", function () {
      let obj = BSON.deserialize(hex2bin("17000000027374720009000000c384c396c39cc39f0000"));
      expect(obj).to.deep.equal({ str: "\u00C4\u00D6\u00DC\u00DF" });
    });

    it("checks boolean", function () {
      let obj = BSON.deserialize(hex2bin("0c00000008626f6f6c000000"));
      expect(obj).to.deep.equal({ bool: false });
      obj = BSON.deserialize(hex2bin("0c00000008626f6f6c000100"));
      expect(obj).to.deep.equal({ bool: true });
    });

    it("checks null", function () {
      let obj = BSON.deserialize(hex2bin("0a0000000a6e756c0000"));
      expect(obj).to.deep.equal({ nul: null });
    });

    it("checks binary", function () {
      let obj = BSON.deserialize(hex2bin("190000000562696e000a00000000010203040506070809ff00"));
      expect(obj).to.deep.equal({ bin: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0xFF]) });
    });

    it("checks array", function () {
      let obj = BSON.deserialize(hex2bin("2b000000046172720021000000103000fa000000103100fb000000103200fc000000103300fd0000000000"));
      expect(obj).to.deep.equal({ arr: [0xFA, 0xFB, 0xFC, 0xFD] });
    });

    it("checks array in array", function () {
      let obj = BSON.deserialize(hex2bin("4f000000046172720045000000043000210000001030001000000010310011000000103200120000001033001300000000103100fa000000103200fb000000103300fc000000103400fd0000000000"));
      expect(obj).to.deep.equal({ arr: [[0x10, 0x11, 0x12, 0x13], 0xFA, 0xFB, 0xFC, 0xFD] });
    });

    it("checks object", function () {
      let obj = BSON.deserialize(hex2bin("22000000036f626a001800000010696e74000a000000027374720001000000000000"));
      expect(obj).to.deep.equal({ obj: { int: 10, str: "" } });
    });

    it("checks Date", function () {
      let obj = BSON.deserialize(hex2bin("120000000964617400f84308885501000000"));
      expect(obj).to.deep.equal({ dat: new Date("2016-06-25T14:48:11Z") });
    });

    it("checks UTC", function () {
      let obj = BSON.deserialize(hex2bin("2f000000097574633100f843088855010000097574633200f8669a87550100000975746333003d53ae915501000000"), true);
      expect(obj).to.deep.equal({ utc1: new BSON.UTC("2016-06-25T14:48:11Z"), utc2: new BSON.UTC("2016-06-25T14:48:11+0200"), utc3: new BSON.UTC([0x3D, 0x53, 0xAE, 0x91, 0x55, 0x01, 0x00, 0x00]) });
    });

    it("checks UUID", function () {
      let obj = BSON.deserialize(hex2bin("20000000057575696400100000000443ab2e98623c03e85f541a1745e01bda00"));
      expect(obj).to.deep.equal({ uuid: new BSON.UUID(new Uint8Array([0x43, 0xab, 0x2e, 0x98, 0x62, 0x3c, 0x03, 0xe8, 0x5f, 0x54, 0x1a, 0x17, 0x45, 0xe0, 0x1b, 0xda])) });
      obj = BSON.deserialize(hex2bin("2100000005757569640011000000040143ab2e98623c03e85f541a1745e01bda00"));
      expect(obj).to.equal(undefined);
    });

    it("checks ObjectId", function () {
      let obj = BSON.deserialize(hex2bin("16000000076f696400a80557f05c6d7ad09fa7357000"));
      expect(obj).to.deep.equal({ oid: new BSON.ObjectId([0xa8, 0x05, 0x57, 0xf0, 0x5c, 0x6d, 0x7a, 0xd0, 0x9f, 0xa7, 0x35, 0x70]) });
    });

    it("checks complex objects", function () {
      for (let i = 0; i < deserialize_vector.length; i++) {
        let bson = BSON.serialize(deserialize_vector[i].obj);
        let obj = BSON.deserialize(hex2bin(deserialize_vector[i].bson), true);
        expect(obj).to.deep.equal(deserialize_vector[i].obj);
      }
    });

    it("checks document too small", function () {
      let obj = BSON.deserialize(hex2bin("04000000"));
      expect(obj).to.equal(undefined);
    });

    it("checks document termination", function () {
      let obj = BSON.deserialize(hex2bin("0c00000008626f6f6c000001"));
      expect(obj).to.equal(undefined);
      obj = BSON.deserialize(hex2bin("0c00000008626f6f6c0000"));
      expect(obj).to.equal(undefined);
    });

    it("checks document size mismatch", function () {
      let obj = BSON.deserialize(hex2bin("0d00000008626f6f6c000000"));
      expect(obj).to.equal(undefined);
    });

    it("checks illegal keyname", function () {
      let obj = BSON.deserialize(hex2bin("0c00000008626f6f6c010100"));
      expect(obj).to.equal(undefined);
    });

    it("checks unknown element", function () {
      let obj = BSON.deserialize(hex2bin("0c00000018626f6f6c000000"));
      expect(obj).to.equal(undefined);
    });
  });

  /////////////////////////////////////////////////////////////////////////////

  function bin2hex(bin: Uint8Array, uppercase: boolean = false): string {
    let hex = uppercase ? "0123456789ABCDEF" : "0123456789abcdef";
    let str = "";
    for (let i = 0, len = bin.length; i < len; i++) {
      str += hex.charAt((bin[i] >>> 4) & 0x0f) + hex.charAt(bin[i] & 0x0f);
    }
    return str;
  }

  function hex2bin(hex: string): Uint8Array {
    let bin = new Uint8Array(hex.length >>> 1);
    for (let i = 0, len = hex.length >>> 1; i < len; i++) {
      bin[i] = parseInt(hex.substr(i << 1, 2), 16);
    }
    return bin;
  }

});

'''
'''--- test/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es2015",
    "module": "commonjs",
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "outDir": "./out",
    "rootDir": "../"
  },
  "exclude": [
    "dist",
    "node_modules"
  ],
  "filesGlob": [
    "**/*.ts",
    "!node_modules/**/*"
  ],
  "compileOnSave": false,
  "atom": {
    "rewriteTsconfig": false
  }
}

'''
'''--- tslint.json ---
{
    "rules": {
        "class-name": true,
        "comment-format": [
            true,
            "check-space"
        ],
        "indent": [
            true,
            "spaces"
        ],
        "no-duplicate-variable": true,
        "no-eval": true,
        "no-internal-module": true,
        "no-trailing-whitespace": true,
        "no-var-keyword": false,
        "one-line": [
            true,
            "check-open-brace",
            "check-whitespace"
        ],
        "quotemark": [
            true,
            "single"
        ],
        "semicolon": [
            true,
            "always"
        ],
        "triple-equals": [
            true,
            "allow-null-check"
        ],
        "typedef-whitespace": [
            true,
            {
                "call-signature": "nospace",
                "index-signature": "nospace",
                "parameter": "nospace",
                "property-declaration": "nospace",
                "variable-declaration": "nospace"
            }
        ],
        "variable-name": [
            true,
			"allow-pascal-case",
            "ban-keywords"
        ],
        "whitespace": [
            true,
            "check-branch",
            "check-decl",
            "check-operator",
            "check-separator",
            "check-type"
        ]
    }
}
'''